It is safe compared to C++, and provides comparable performance for webservers, where network latency dominates the request time. I think we know by know that Go will not replace Rust/C++, but Python, Ruby and NodeJS as backends feel the competition.
[FTFY](https://play.golang.org/p/DwQIkE6_et_A)
One of the problem we have with yaml is it's indentation based which disqualify the usage of any tools link linters or formatters (gofmt). Other problems are the ambiguous types which led to some parsers vulnerabilities.
Repository: https://github.com/uber/aresdb
There are different kinds of safe. Don't presume everyone goes by your definition of safe. For example Rust isn't safe in Ada standards yet the hype spams "rust is safe" everywhere.
Flags wouldn't be very good for a REPL, as far as I'm aware.
&gt; Don't presume everyone goes by your definition of it I didn't. I tried to start a conversation about the definition of safety, but apparently that's way too much to ask
&gt;what' s wrong with code generation? Nothing wrong when it's baked into the language (metaprogramming). Otherwise it brings a whole new level of *cumbersome*. 
[removed]
Assuming you have a package called **foo**, keep the mocks in a **\_test.go** file under **foo** package, not the **foo\_test**. This way you can import them from other packages and the compiler avoids them on a normal build.
Maybe its not an answer to your question but I started doing golang by finding any project first, language came along and I find it the best way to learn, plan real project and then care about technologies needed. And the simpliest answer you expect is probably server serving static html or anything using http server. 
If you're looking for an example of how to build a simple key-value store using SWIM you can see this use of hashicorp/memberlist. [https://github.com/asim/memberlist](https://github.com/asim/memberlist)
You wrote: &gt; Rust is safe. Ada is safe. Haskell is safe. If Rust is to be implied as safe as Ada might as well put Go there. Which is obviously wrong for both cases.
I am curious if this creates a memory leak. Is the swift code responsible for freeing that returned string?
Interesting... I looked for some projects too. And because of this, I'm trying to learn the language. In regard of you said: &gt; the simpliest answer you expect is probably server serving static html or anything using http server Well, actually this is not my main expectation. I want to cover many things instead of just what you suggested. But thanks for your reply! I'll put this on my checklist.
Yea, you fixed it not for me, but for OP. My point was like before you try teach somebody you have to make sure you understand it yourself. 
I didn't mean that Rust is "equally safe" as Ada, just that those two languages would be what I'd personally call safe, Go not so much. As I've said, it _is_ safer than C or C++, but considering how unsafe they are, that's not saying much. Of course all of this depends on how someone defines safe, which was what I was trying to start a conversation on here.
I mean how to build my own interpreter. Is this build into the language to handle those tags?
[removed]
Sorry for your downvotes. I thought your post was constructive discussion even if I disagree with you. To me, the combination of removing typical pointer/UB C++ pitfalls, and explicit error handling, and explicit number casting, is enough for me to call Go "safe." It is "less safe" than something like Rust, where the compiler actually prohibits you from sharing data across threads (whereas Go only discourages it), but for me the cutoff point for "safe" is "makes doing the wrong thing difficult/obvious," not "makes doing the wrong thing impossible." In C++ you can get nuked even with good intentions just because you didn't know language-specific arcana like how virtual destructors work. In Go, if something unsafe happens, I find it's almost always because my idea was wrong (or because I was intentionally circumventing the rules). not because I tripped over a language foot-gun. To me, that is a hallmark of a "safe" language. This is something of a semantic bikeshedding argument so I don't think there's any way that either of can "prove" the other "wrong," but that's how I feel. Go feels safe to me in concrete ways.
I did run it before posting, though I admit I could have checked the output more carefully. That's my fault for posting so late at night.
It was meant in jest, since the library was born out of the dislike of the alternatives, rightfully so
That's just a consequence of using largely cooperative multi-tasking, which I wouldn't personally characterize as inherently unsafe. Using channels to end goroutines or to detect when they have ended is fairly straight-forward in most cases. It is certainly easy to *intentionally* leak goroutines, but it has not been my personal experience that accidentally leaking them is common.
Oh yeah, we're definitely not working towards some sort of objective definition of what "safe" is, this is just me not agreeing with what seems like a majority opinion and trying to discuss it. &gt; In C++ you can get nuked even with good intentions just because you didn't know language-specific arcana like how virtual destructors work. In Go, if something unsafe happens, I find it's almost always because my idea was wrong (or because I was intentionally circumventing the rules). not because I tripped over a language foot-gun This is a valid point, and I do agree that Go is much safer than C++, and it makes it really hard to do something _really_ unsafe, like buffer overflows and whatnot. However, I think it still leaves the door open for a bunch of behavior that I'd personally classify as unsafe even though they're not unsafe in the sense of "will compromise security", more in the sense of "these will seriously bite you in the ass". I've talked about eg. goroutine leaks and how you don't get a "handle" to goroutines in other comments here, but there's also `nil`: `null` and its variants have pretty famously been called the "billion dollar mistake", and there's lots of blog posts about it, eg. [this](https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/). The lack of proper enums is also something I'd classify as unsafe, because while you can sort of work around it with a custom named type and `const`s, they don't really do the same thing without a bunch of boilerplate around eg. conversions. So yeah, I guess my point is more that while Go really is safer than a lot of the options out there, my personal definition of "safe" is something that's _actually_ safe, on the level of Ada (not going to mention Rust here, because that seems to _really_ trigger some people). Go is _safer_, and it's good enough for most non-critical stuff, but I really wouldn't use Go when you need safety on the order of, say, aerospace or medical devices just because people call Go "safe".
I've seen a bunch of cases where there have been accidental goroutine leaks, both in open source projects (I think I even helped diagnose one in a Kafka client lib) and in in-house projects. And while using channels (or `context`) and goroutines to emulate behavior that's sort of like Erlang's PIDs if you squint, my point is more that I shouldn't _have_ to write that boilerplate just to make sure goroutines behave as expected. While leaking goroutines isn't unsafe as in buffer overflow unsafe, it does seem like a somewhat common pitfall that I've personally seen causing service instability
Yes, the Swift code is responsible for freeing the memory allocated by the Go string, but if you look closely, this is handled (in Swift) by `String(bytesNoCopy:length:encoding:freeWhenDone:)`.
I'm writing a forum base on Golang + react, and the init commit is hello world, you can find it here: [https://github.com/godiscourse/godiscourse/commit/1af237718611662fcb32d2c24d9e7bf73a62bd35](https://github.com/godiscourse/godiscourse/commit/1af237718611662fcb32d2c24d9e7bf73a62bd35) It still simple now, maybe you can learn from this one, any feedback is appreciated! We can talk about it together. 
&gt; The lack of proper enums is also something I'd classify as unsafe I would say the lack of language supported enums (and some of your other complaints as well) are legitimate complaints about the *convenience* of using the language. I do not agree that a lack of a language supported enum is less safe. &gt; my personal definition of "safe" is something that's *actually* safe That's kind of circular. :) Personally, I do think that Go is *actually* safe. I get what you're saying though. &gt; I really wouldn't use Go when you need safety on the order of, say, aerospace or medical devices just because people call Go "safe" This part of your comment is particularly ironic given how much aerospace and medical device software is currently written in C. The real issue here is that to the extent those applications require real time guarantees, it is not currently possible to do that in Go. (But JavaRTS is a thing, so it should definitely be *possible* to create a realtime fork of Go if someone were motivated to do so.) C (and Ada!) are used in many of those applications because they have hard realtime requirements, not because they are or aren't looking for "safe" languages.
Reddit formatting is kinda dull, have to use 4 spaces
&gt; I would say the lack of language supported enums (and some of your other complaints as well) are legitimate complaints about the convenience of using the language Enums are borderline, but I'd still claim that because there's no _real_ enum type and just `const`s that sort of pretend to be enums, you can get unexpected and unsafe (as in eg. service keels over) behavior especially around serializaton. The lack of PIDs I really would classify as both a convenience issue _and_ a safety issue, since having more granular control (if you can call it that) of goroutines would make it easier to avoid unexpected behavior. &gt; That's kind of circular. :) Personally, I do think that Go is actually safe. I get what you're saying though. Welp, yeah, I really didn't think that one through. And good point re RTS, but just because people had to use C in some places where you really, really shouldn't doesn't make it all that ironic, it just means that people have had to make shitty choices for some reason or another. Still, when you look at eg. Ada, I'm not really convinced people use it just because it can provide hard realtime guarantees, but because it can do that in addition to really doing its damndest to prevent unexpected behavior.
That obvious huh? :( lol
Kind of :D
I have also experienced very high memory usage of Badger. Batch loading of many thousands (hundreds of thousands) of entries will result in skyrocketing memory usage. The amount of memory used when loading data into Bolt databases pales in comparison and furthermore the cooldown period of hot-data in Bolt is pretty short, so memory usage decreases even more when data is not recently accessed.
This isn't specific to Go, but it's the best https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1548868582&amp;sr=1-1&amp;keywords=refactoring
[https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)
Is this difference in memory usage caused by poor design or simply different design goals? 
Hmm, good question.
It works in the new reddit... But yeah, reddit sucks for code.
That SWIM protocol pattern is going to be useful for a host of other distributed systems - having this as a module in its own right would be a good resource.
I'm pretty sure it's design goals. Badger is the KV store that backs a full graph database (DGraph). Nearly every database will make full use of available memory for caching to avoid hitting disk as much as possible. &amp;#x200B; SQL Server for instance will use all of the available memory for it's buffer cache unless you configure it otherwise.
InfluxDB developers got rid out of the BoltDB, because after few GBs of stored data it starts freezing with IOPS.
Simply different design goals. It's meant to be the main storage back-end for a graph-database. So it's intended usage is on big beefy servers with plenty of memory and CPU.
You can also do this with the [official Go Compute API client](https://godoc.org/google.golang.org/api/compute/v1#InstancesService.Insert), which already has the JSON struct created for you.
This. A couple of years ago I had to implement some custom functionality to an open source LoRaWAN server for work, which is written in Go. So I had to learn it and just happened to like it a lot, to the point that we've switched stacks at work and backends are now almost always written in Go, as are other pieces of software, and I now frequent Go's forum and contribute to the project on a daily basis. So maybe you don't have a real need to learn it right now as I did, but you could look about some technology/project you'd like to learn about that's implemented in Go (LoRaWAN network backends would be a great example) and start messing with it. You don't need to start contributing or anything, maybe just fork an interesting repo from [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go) or [https://github.com/trending/go](https://github.com/trending/go) and try to implement something you'd like to include.
Based on my limited understanding, the intended usage of BoltDB is to pre-shard data across multiple db files (many small files.) Performance degrades logarithmically and when your db files cross the 100MB-1GB mark then write operations per second take a nosedive. Yes your drive will thrash (even NVMe drives) and it will be very unpleasant when you see disk read/disk write MB/s plateau while performance flatlines.
 type t []something func (t t) Mutate() { //... } gets a copy of the slice, and through that copy can mutate the "somethings" by copying new "somethings" into the slice, but it can't modify the slice itself, that is, the struct that under the hood has the backing array, offset, and size. Running `t = append(t, ...)` will have no effect on the caller's view of those three things. type t []something func (t *t) Mutate() { //... } can mutate the current contents of the slice, but also mutate the caller's copy of the slice; `*t = append(*t, something{})` will result in the caller's slice being updated to be one longer than before, so it can have a new backing array, offset, and size. It is something I haven't used often, but I have used it before.
That is correct! What I found however was that to create a compute service, it required a the http client which required an entire OAuth2 configuration in order to perform the request. If you have an implementation using the Golang API I would love to see how you did it. 
I had a similar experience when I recently added a modular storage backend to an application that originally used only Boltdb. Some of the boltdb files surpassed 20GB and I would either be faces with really long startup times to open the database when mmap sync was enabled. Or fast open but really slow initial reads when disabled. After allowing for a badger option I found it to be fast either way. 
Helpful article. I switched my application recently to allow for badger or bolt, instead of only bolt. My benchmarked found badger to be almost always faster except for one test where I was scanning an entire prefix range from start to end (negligible). Per this article I should really have a look at the memory consumption for some of my huge databases. Some other benefits I found over bolt were * faster open to end of first read time * TTL support instead of my manual implementation for it in Bolt * library level support for auto compact instead of my manual support for compact-swap-reopen in bolt Although I remember having some initial issues with the difference in iterators with badger. It was easier for me to make a mistake with a gotcha case that needed support. Also I found the approach to reverse iterators kind of weird where you have to know how to prefix your key with a certain byte pattern. 
If your goal is to get abetter random key reading/lookup performance and you can afford the price of very expensive writes to the DB then BoltDB is the way to go. My NVMe storage is working so hard for just a few writes on the large DB. But I need very fast key lookups. No matter what. 
I see more FP in C# code these days than OOP. And each new language version adds more functional concepts.
Yeah just add a simple concurrency argument/env variable. Most DevOps scripts should be configurable in this regard.
Thanks for the answer. So, newbie question. The server I am working with has a single core. So obviously it is not going to take advantage of parallelism. That being said, do Golang developers push concurrent design 100%? Or do they use concurrent design if needed. I know for a fact I won't be running my program on duel cores ever. Regardless is it just standard to codify concurrency?
I have used micro. Would not recommend. Documentation is mostly source code. Errors are weird. API is so different from grpc that it needs it's own ecosystem. Not to mention the one time they broke the whole API - have fun rewriting 30 endpoints to match the new API. Right now I am using plain grpc, when coupled with kubernettes, service Discovery comes out of the box (while in micro it was not very obvious and had some very weird errors) and the ecosystem and docs are much much better. The rare times I have had problems some googling did the trick without going through the source code. This is my experience, cannot talk about other libraries but keep the ecosystem in mind. If you have to reimplement logging for your logger or tracing middleware then it's probably not worth it.
&gt;do Golang developers push concurrent design 100%? Or do they use concurrent design if needed If they're any good its only when needed. With goroutines come new classes of bugs, and much more difficult reasoning about your process. Also if you have a command that you want to run in a parallel fashion, one can often run multiple copies of it simultaneously - GNU parallel is helpful there.
That makes goroutines sound more like liabilities than anything. Haha. When would you use them then? When it's not easy to scale running multiple copies of it?
A single core will lose performance due to the context switching of multiple threads/goroutines, so I would keep it simple. 
Isn't this because of mixing net framework and mono rather than using netcore like anyone would nowadays? Feel like your comment is a bit outdated, but know you said it was some time ago. Still.. misleading probably.
I think I've seen this ad before here couple days ago
In syntax and language design? Hope that's not what you meant because C# is light years ahead and that's well acknowledged within the java community. No one is even debating that C# is the clear winner of those two from a pure language perspective. In terms of industry usage, community and frameworks/libraries it's a different story and actually varies widely across the globe. Could elaborate a bit on the market differences and effects on industry usage, e.g. between US and some european countries like Denmark.
That kind of book author/dev coach usually speaks in very idealistic terms and that does not always apply to the real world.
In my mock drawer with my other underwear.
When appropriate to your problem they're very useful. For instance, a web server that has to handle concurrent requests. But, you now have to reason carefully to avoid data races, deadlocks and just general unintended consequences. Go makes spawning (green) threads very easy, but it's still an inherently more difficult type of programming. Thus, IMHO, to be used where appropriate but certainly not 100% of the time.
I've made similar experiences. While go-micro was great for building a go-only infrastructure it got messy once you introduce another component in a different language (NodeJS for example). I like the Ideas behind go-micro very much but i guess it will only ever work if you intend to write all your microservices in micro. I have recently started to work with go-kit which i really like. It's structure is way more flexible that the one from go-micro. I also like the layered approach to microservices. The only drawback of go-kit is that due to it's heavy use of interfaces you have to write lots of boilerplate code. I would actually be interested in any (reasonable up-to-date) go-kit generators. I've tried a few, but each and every one of them seems outdated. Maybe someone who is using go-kit in production can share some insight? &amp;#x200B;
You can use [`transport/http.NewHClient`](https://godoc.org/google.golang.org/api/transport/http#NewClient) to create a client that uses Application Default Credentials, which will be your gcloud credentials on your local machine. If you need more fine-grained control, combine [`oauth2.NewClient`](https://godoc.org/golang.org/x/oauth2#NewClient) with an `oauth2.TokenSource` like [`oauth2.StaticTokenSource`](https://godoc.org/golang.org/x/oauth2#StaticTokenSource).
Great article. Thanks for sharing
Honestly, I don't see why one would choose micro/kit. With plain grpc we have a monorepo where we generate the clients for each language we use, so we have a bunch of micro services talking to each other exclusively through GRPC in the whole k8s cluster with a strongly defined interface rather than exposing grpc through rest which I think is quite ugly and should be last resort.
[removed]
I'm totally with you. I would much rather also only work with gRPC. But unfortunately we need to use binary protobuf over HTTP as our main transport layer. But as I am trying to push us towards RPC only I like to keep that option and be able to change transport layers later. This is, including the client stuff, one of the reasons I'd like to adapt go-kit. I've actually started to roll my own boilerplate which wraps different transports around a bare gRPC implementation. But then again, it became really similar to go-kit so I did not see any point in reinventing the wheel.
Yep, really interesting! (but Go 1.2?? C'mon!)
&gt; I'd still claim that because there's no _real_ enum type and just `const`s that sort of pretend to be enums, you can get unexpected and unsafe (as in eg. service keels over) behavior especially around serializaton. You can have proper enums using a typedef'd integer and const blocks - type checked at compile time and everything. It doesn't stop you from explicitly casting an integer to your enum type, but it will prevent you from doing something stupid by accident.
&gt; The server I am working with has a single core. So obviously it is not going to take advantage of parallelism. Not of CPU-bound parallelism (ie, "make it concurrent to distribute the load"), but certainly it can take advantage of IO-bound parallelism (ie, "make it concurrent so slow I/O does not block everything"). That said, I doubt that each and every DevOps script needs to be designed for concurrency. I cannot speak for all developers, but from what I see in public code, concurrency is used where it makes sense and not just because.
I think he reposted it and made a new more professional account name, the original was like "neversober" or something
https://play.golang.org/p/5HdsOuipKWw
I just started yesterday, and really feel the same. It's boring, but probably the best tool to solve my problems. &amp;#x200B;
I'd drink too if I worked in buttcoin
&gt; a career in the cryptocurrency industry You mean, a short gig that lasts as long as the crypto founders can pump their currency and cash in on the rubes that buy? How long is that cycle, usually?
Separating the data store from your app logic is a common idiom in every programming language. It's not just necessary from a design standpoint, but it also enables testing your logic without having a DB connected. &gt; creating a custom type in my domain to match DocumentRef More or less, this is what you do: model your data in your application to match what's in the DB. Or the other way around: use an ORM library (I use http://gorm.io/) that configures the DB to match your data model. As long as there's an interface between your data model and your app logic, that's all you'll need for most purposes.
If your workload is waiting on factors like IO you should still use concurrency patterns, while waiting on disk / network something else can run on the CPU...
[type aliases](https://golang.org/doc/go1.9#language) were added to go a few versions back, so that may help. Also [this](https://talks.golang.org/2016/refactor.article)
https://cloud.google.com/translate/quotas
I've been wondering about data corruption and memory usage with faster alternatives like goleveldb, badgerdb, and [the others](https://github.com/Xeoncross/go-embeddable-stores) so I'm glad to see a reliable source like [Tim](https://github.com/timshannon) weigh-in on this topic.
This is a good place to start, as are books like Clean Code, and Code Complete. The concepts of code organization / re-organization / refactoring are independent of language. Learn them first, then you'll recognize the facilities in your favorite language that lend themselves to better organization of code.
GoBuffalo is a good example if you're just getting started with Go and have a background in something like Rails or Django. It's a very "batteries included" approach, and generally a pretty good place to start. Once you've moved beyond the Beginner phase with Go, lots of people are big(ger) fans of just using something like Gorilla Mux and then the standard library's net/http package. Personally I would start with GoBuffalo.
This project is based on the free user layer, not in the Google AI &amp; Machine Learning Products (translate) API. gtranslate (this project) is like to use [https://translate.google.com](https://translate.google.com) but programmatically. 
What a mess.
(Badger author here) I'm sure Badger uses more memory than Bolt. But, I honestly haven't seen any heap profile which shows Badger using \*so much memory\* (8GB in this case). Badger is designed to allow a lot of flexibility. Almost always, it is a setting in Options which can be tweaked to decrease the memory usage. For e.g., by default, the LSM tree is set to \`LoadToRAM\`. Switching that to \`MemoryMap\` would make Badger consume less. &amp;#x200B; [https://github.com/dgraph-io/badger#memory-usage](https://github.com/dgraph-io/badger#memory-usage) &amp;#x200B; There's nothing inherent in Badger, which presumes a lot of memory consumption. LSM trees use inmemory tables, but that's all really (set to 5-10 each being 64MB, by default, can be modified by Options). Badger doesn't have a cache even. So, if someone is actually seeing a big memory usage by Badger, please do create an issue in Badger with a go heap profile -- so we can fix it.
Check justforfunc's youtube videos: [https://www.youtube.com/justforfunc](https://www.youtube.com/justforfunc) . &amp;#x200B; He teaches a lot in his videos, and does a lot of refactoring. Good stuff.
Won't google block requests?
Let's take something beautiful and simple and make it not... that.
The hybrid offspring of Go and Rails. Like most hybrids, it's not very fertile.
Yep. This is how you get captchas when you try and do a regular Google search.
Then it’s very hard to say unlimited API
Are you guys opposed to using any of these folders? Or, the act of preemptively creating a big project structure like this? I think the `/cmd` and `/internal` directory approach (plus whatever else might suit you) works pretty well.
I find it appealing. What structure do you use or want to use that's better?
[removed]
Doesn’t look all that bad
This is good to know (and I do appreciate a direct response from the author of Badger) however I did explore the memory usage options and toggle them as much as I could. Although I did see a reduction as you mention, my use case rules out Badger as a general disk-backed key value store.
To be fair to the author, they recommend using _only_ what you need from that at the start of the readme.
4-6 weeks. Long enough that they can string you along, declaring they’ll pay you next week. And will you take my new shitcoin as payment? It’s worth $0.30 now, but if it MOOOONs, then it’ll be worth MILLIONS! Think of the upside! All the lambos!
This is great stuff. I've never used IDA, but being able to reverse a Go binary is pretty sweet.
I always start with main.go and rarely make it past that point, but when I do I start following that structure and suprisingly it works well.
For things that have artifacts (i.e. compile) we use cmd/ and internal/. For libraries we use the root so people don't have to go into the code. 
Same
I like something simple like [https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) Actually the one I sent isn't necessarily terrible as you add pieces you need perhaps, but it's more the hubris of naming your repos "golang-standards" when they are not, and also presenting something incredibly overcomplicated that is sure to confuse new users. I've also had luck just following some of the conventions that larger projects like Docker, Zmap stuff, and Boulder use. I definitely agree with "to each their own" so here it's more the presentation than any real problem with the approach.
[removed]
No worries, mate. Just wanted to clarify. Plus, if someone can actually send us some heap profiles (future readers of this thread), that could potentially help improve the software.
Sounds neat. But... What is a Noise?
But then you have to import stuff from internal and pkg and you can't have dependency loops so what's the point anyway?
Fair question. So [Noise (or Noise Protocol)](http://noiseprotocol.org/) is a framework for implementing various Elliptic Curve Diffie-Hellman handshake protocols. The handshake is usually the basis for bootstrapping secure communication between two parties. It defines various handshake protocols with varying security properties using highly secure cryptographic primitives. Traditionally protocol designers when faced with implementing secure communication would rely on TLS, well Noise provides a secure alternative that is a lot simpler and without all the baggage and complexity of TLS. Where TLS might require 10000+ LOC for an implementation (X509 parsing, ASN1 encoding/decoding, cryptographic primitives, protocol finite state machine), a noise handshake can usually be implemented in about 5000 LOC. [Wireguard](http://wireguard.io/), WhatsApp, and Signal implement protocols based on the Noise handshake.
That is great, I love me some wireguard. And the more people thinking about security, the better. (You should totally put that explanation on your site.)
I have an old project [here](https://gitlab.com/NatoBoram/Go-Miiko), and the project layout is separated by files rather than by folders. I have types in one file, constants in another, variables in another, and so on. I also have a "wheel" package for when I'm reinventing the wheel.
I'm not the author, but ping /u/kaepora
Very cool!
I would say this is the typical Go layout. Certainly, things can get more complicated, but as long as everything is inter-dependent, this is how things look.
Since you're just wanting to verify the token, you can just use the [go-oidc](https://godoc.org/github.com/coreos/go-oidc#IDToken) package using the [openid connect configuration for Azure AD.](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-protocols-oidc) That package handles all the verification of the JWT and lets you pull out claims and what not after it too. A good reference implementation might be the [Hashicorp Vault Azure AD Auth plugin](https://github.com/hashicorp/vault-plugin-auth-azure/blob/4c0b46069a2293d5a6ca7506c8d3e0c4a92f3dbc/azure.go#L58) that does just that. If you want a more full featured ADAL library, you can check out [Azure's golang library for ADAL](https://godoc.org/github.com/Azure/go-autorest/autorest/adal).
 find -type d | grep -v .git . ./project-layout ./project-layout/api ./project-layout/assets ./project-layout/build ./project-layout/build/ci ./project-layout/build/package ./project-layout/cmd ./project-layout/cmd/_your_app_ ./project-layout/configs ./project-layout/deployments ./project-layout/docs ./project-layout/examples ./project-layout/init ./project-layout/internal ./project-layout/internal/app ./project-layout/internal/app/_your_app_ ./project-layout/internal/pkg ./project-layout/internal/pkg/_your_private_lib_ ./project-layout/pkg ./project-layout/pkg/_your_public_lib_ ./project-layout/scripts ./project-layout/test ./project-layout/third_party ./project-layout/tools ./project-layout/vendor ./project-layout/web ./project-layout/web/app ./project-layout/web/static ./project-layout/web/template ./project-layout/website
I really like this server, service, repository pattern described here: https://outcrawl.com/go-graphql-gateway-microservices I've used it on my first go project and it has made my code easy to reason about and switching out the data layer easy. Props to the author!
Do you want EJBs? 'Cause that's how you get EJBs. 
I'm writing a Golang based forum, [https://github.com/godiscourse/godiscourse](https://github.com/godiscourse/godiscourse) Only sign in through Github is supported, but you can learn authentication from it. Hope it can help you!
I would also create just the directories when needed. Missed in the past a good structure in my code. And I like the idea of a makefile
If you have access to those three commands, then I think the installation succeeded. What happens when you run one of the other commands in this list [1]? [1] https://github.com/fatih/vim-go#features
I think you see it how you want to? I find that really useful as I've found value before in laying out a template of some sort for developers to come. Doing that, to some extent, helps future developers understand where to put a new thing or at the very least, gently guides them in the right direction when they need to organise files and content. Not to mention.. this is all exclaimed in a disclaimer.
Yeah, I think this problem arose because I designed the app with the database in mind, I'll have a look into gorm, thank you. After all I think creating a custom type to match DocumentRef isn't too bad. I didn't like it because even though you don't have a real dependency, it's kind of a logic dependency. Say you want to move to a DB which doesn't support references, than you have a custom type in your models which doesn't really make sense anymore. What's your stance on this? 
Ejb ejb ejb!
The Java Way. 
E492: Not an editor command: GoVet E492: Not an editor command: GoRun % And so on...
If I starting vim with -D option then I see that the default .vimrc is loaded. And it contains next: " Configuration file for vim set modelines=0 " CVE-2007-2438 " Normally we use vim-extensions. If you want true vi-compatibility " remove change the following statements set nocompatible " Use Vim defaults instead of 100% vi compatibility set backspace=2 " more powerful backspacing " Don't write backup file if vim is being called by "crontab -e" au BufWrite /private/tmp/crontab.* set nowritebackup nobackup " Don't write backup file if vim is being called by "chpass" au BufWrite /private/etc/pw.* set nowritebackup nobackup let skip_defaults_vim=1 It places in /usr/share/vim/vimrc Maybe this can help somehow
I had this problem recently too. I figured out that you need this in your vimrc filetype plugin on otherwise .go specific commands wont be enabled. let me know if this helps.
I'm not a huge fan of this structure, as it splits up your code in a lot of different folders. At least for smaller services. I don't see a benefit to having lots of folders that each contain only 1 .go file. It's far simpler to navigate if you have only 1-2 packages with various properly named files I think.
Yes! It works! Thank you! You save me a lot of time )
cheers 😁
Dependency loops are often a sign that something is off with the way the packages are designed/how the abstractions have been designed. In an ideal case, each package should be useful by itself.
It's not \_specifically\_ about refactoring but it's a big part of the book &amp;#x200B; [https://github.com/quii/learn-go-with-tests](https://github.com/quii/learn-go-with-tests)
So what does look bad to you?
This is absolute mess and coding for code. And what a naming: accountService.PostAccount... Please, stop do your java/c#/php stuff everywhere. It barely works for those languages and doesn't work for simple languages like go either. Read Effective Go and start coding for solving usecases.
I'm so pissed about this. And "unofficial golang standards", what does that even mean? Standard means it's official and the way to go. Let's create 1000 folders for a few lines of code.
Really cool, it teaches some principles with a simple example.
There's a lot of negativity here about this standard and I agree it's over complicated. But when I started with Go 4 months ago (coming from Java), it had been the only clear standard of doing things. Also, the whole /cmd and /internal part is what I see everywhere in established projects. Placing everything in the same folder is a mess and definitely not a reliable structure if you're building something that needs more than a 100 lines of code. If there there a better way of structuring Go projects, show it, instead of just shooting down the only thing that tries to give beginners a guideline.
&gt; hubris of naming your repos "golang-standards" when they are not I agree with this. I disagree with how great people seem to think [Ben Johnson’s post](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) is. Don’t get me wrong, I think it’s a good approach and agree with much of his reasoning/ decisions, but it’s far from comprehensive and is lacking if you’re new to Go. If he provided a link to a repo with full example code, that’d fill in some of the gaps I think make his post easier to grok for new Gophers.
I'm not the most discreet it seems ha! By all means, please send them to the Golang Works platform so they can have a browse themselves. We're growing this Golang platform out more this year, so the more the merrier :) Thankss!
Yeah, I think the `internal` folder is overkill if you also have the `pkg` and should consider refactoring this “internal” code.
I agree that it's a good guideline, plus common sense is to use only what's needed. Personally I think that it's quite complicated for most projects and that simple files work quite well to separate components. [Here's](https://github.com/fogleman/pt) a project that is in my opinion pretty well structured, what do you think of it?
I often use this layout to some extent. Usually it's just /cmd, /api and /internal, and it works pretty well for most of my projects. But I think it's no use following these guidelines if your project is just a few .go files/lines of code.
The first one has unnecessary pointer
There's a nice and clean SQL database API in the standard library, though you might need to add drivers for specific databases (eg. if you're working with MySQL, SQLite or Postgres). It could go like ``` import "database/sql" import _ "github.com/go-sql-driver/mysql" ``` [Here's](https://flaviocopes.com/golang-sql-database/) a quick article to get you started, and [another](https://stackoverflow.com/questions/17265463/how-do-i-convert-a-database-row-into-a-struct-in-go) StackOverflow question that seems to fit your needs exactly. Hope it helps!
Why would you use custom functions on map types? Your example is just a 1:1 wrapper for t[key], and if you want to wrap access with locks, I highly recommend sync.Map for that
Thanks for pinging me. The reason why the website is currently not very verbose is because the entire project is under academic peer review and the website itself needs to be fairly (but not completely) anonymized. Once that's over there'll be a Noise Explorer Blog with a bunch of insights and explanations.
This is actually not bad at all. To begin with you'd only take the cmd, internal and/or the pkg root directories and then follow best practices to place code inside these directories. Everything else in this structure is for additional non-Go stuff like swagger definitions, IDLs, web assets. It's not like all these directories are supposed to contain Go code. Of course using a simple main.go file at root a simple binary is fine as is putting all code at root for a simple library, but for anything more serious, I find that cmd plus internal and/or pkg to be a very good root structure.
What OP posted and what you shared don't seem to be incompatible at all _to me_. What OP shared is about structuring the project at root level. What you shared is about structuring a Go package specifically. One could have the root structure similar to the repo and then follow the layout you shared inside `pkg/` and `internal/` 
ty, edited
Here's a comment I recently posted on a similar question, hope it can help. I'd suggest picking something you use every once in a while and re-writing it in Go. It can be a VScode plugin, a perl tool, a small weather javascript api, a markdown-to-html script, or whatever. For example, that's why I re-created [goof](https://github.com/tpaschalis/goof), and it's saving me time every single day. Having used the tool is important, since you'll be more familiar with the possible pitfalls and the general usability and UX, which will allow you to concentrate on the design philosophy, and make the most out of a clean implementation. There's a lot to add, to make the code idiomatic and Go-like. Add correct concurrency, use best practices in regards to versioning and depencencies, create good tests, create documentation, make it easy for other people to import and use. It can be from a library that makes Vector calculus easy, a Web App to check up stock prices on various trading markets, or a small ray tracer (I really suggest that one)..! But once you build it, make sure to polish it as much as possible.
Sure, you can have 1-2 packages inside `/internal` or `/pkg`, and if you are building a binary then have the entrypoint file in `/cmd/binaryName/main.go`. Overall, you have 2 root directories that contain Go code and still have just 1 or two actual Go packages. For extra simple projects of course having the cmd entrypoint at root along with everything else is fine. I don't see at all how this structure forces one to diving code in multiple pieces. All it does is force one to move the packages inside `/internal` or `/pkg` root directories, and separate the CLI cmd code from core business logic which is something one should do anything on any semi-serious project.
That's exactly what I'm asking. Is there any reason to use custom functions on map types. My example just illustrates the approach, it doesn't matter what it actually does. Of course I wouldn't use something like that in a real-world application.
IMO there’s no use case At least in the years I have developed with go, I have never seen one Neither read in someone’s implementation, nor used in my own
Java was never beautiful and simple.
Watched this talk already so often. # Brewput, love it &lt;3
Thanks but. That doesn't do it. I need to create a join table for a many to many relationship in golang
I found it today and i had feeling to share it, its so good!
I consider use of `internal/` harmful, except in rare cases. Many times I've found useful third party packages that I've imported into my own code, and since I vendor dependencies I don't care too much if the upstream author makes breaking changes down the line. But if they put most of their code in `internal/` in a misguided attempt at encapsulation it just is annoying and unnecessary. The other thing I point out to my team is that when you write your code as if it will be consumed by the outside world as a library, you tend to make much better &amp; cleaner design decisions.
Thanks for sharing! I'll definitely be trying this out
We do it occasionally to add convenience actions to a map of entries so code readability is clear. For example, we have this: `type Authorization map[string]*Grant` `func (a Authorization) CanAccessRoute(route string) bool {` `_, found := a[route]` `return found` `}` `func (a Authorization) CanPerformAction(route string, requestMethod string) bool {` `grant, ok := a[route]` `if !ok {` `return false` `}` `switch requestMethod {` `case http.MethodPut, http.MethodPost, http.MethodPatch:` `return grant.Write` `case http.MethodGet:` `return` [`grant.Read`](https://grant.Read) `case http.MethodDelete:` `return grant.Delete` `}` `// Unknown request method.` `return false` `}` Could we have created a struct, sure, but then there is an unnecessary layer. And could we just have some funcs to perform these actions, sure but this way it's clear in the code how it's being used. `if !authRsp.Authorization.CanPerformAction(route, req.Method) {` `doSomething()` `}`
Everything i see from here you are trying to pass const EXTENSION\_HARD\_LINE\_BREAK as argument but its not defined in your code. &amp;#x200B; Although i'm not familiar with this lib i noticed that \`WithExtensions\` takes \[this\]([https://godoc.org/gopkg.in/russross/blackfriday.v2#Extensions](https://godoc.org/gopkg.in/russross/blackfriday.v2#Extensions)) as argument 
Got an answer [over on Stack overflow](https://stackoverflow.com/a/54454878/270779)!
So after all how to use this bloody shit? 
For the record, I gave up **blackfriday** and found a relief in [this markdown package](https://gitlab.com/golang-commonmark/markdown) which is much cleaner and easy to understand. My work donw with just `md := markdown.New(markdown.Breaks(true), markdown.HTML(true))`
Present it better, make a decent readme
Found this in my code, with bf v2.0.1 bf.Run([]byte(body), bf.WithExtensions(bf.Tables|bf.Autolink|bf.HardLineBreak|bf.Strikethrough), bf.WithRenderer(nh))
Cool!! Thank you so much! I'll follow this. 
I like your point. Maybe doing some reverse engineering from some this interesting project. Nothing big but complex enough to makes me grows up technically using this language. Thank you for your nice advice!
&gt; a small ray tracer (I really suggest that one) In regard to a ray tracer, can you give me a hint of where I can start? Your comment (and other above) given me some ideas about what I can do. I appreciate your comment too!
Generics introduce complexity into a language. Readability being a key feature of the language. C#, Java, and so on that have generics tend to rely on the IDE to inform the developer what is being passed in. Try and do a code review with a .NET core app on github that is full of generics, it is extremely difficult. Do the same thing with GO, should be very easy unless the developer has attempted to do something cute. While code reuse has/or had its place it is not very hardware sympathetic. Following patterns like DRY can actually have a negative effect on your GO application and couple you to functionality that is harder to mutate for futures features. In GO when a function is called, Garbage collection can issue a stop the world event, So if you have a function that calls another function, that calls another function, and so on, you are in essence stopping your application from processing and loosing cycles of compute time. if you are curious run some benchmarks/ profilers, there are projects out there or you can roll your own that will add Generic functionality to your GO application and have it work the same way as C# generics. Then remove the generics and write the application the GO way. What you will discovery is performance is better, readability is better, and hardware sympathy is better. I don't have the link on hand but there is one out there from a google engineer that talks/demonstrates hardware sympathy and how memory swaps/unnecessary garbage collections can kill the performance of an application. 
Love real world practical examples in Go! 
I recently followed [this guy](https://github.com/ssloy) who has extraordinarily good material and explanations. He takes small steps and uses Git's diffs to show how the code evolves commit-by-commit when adding more advanced features, so that's neat. He codes in C++, but porting it in Go would be a nice exercise. For his [ray tracer](https://github.com/ssloy/tinyraytracer/wiki) check out this link. Make sure to sprinkle in some concurrency. Another ray tracer that I know of and is written in Go is [this one](https://github.com/fogleman/pt).
so you need to pass `blackgriday.WithExtensions(blackfriday.HardLineBreak)`
By design. Then you can build an ecosystem of courses, talks, project management systems, workflows - all to help manage people deal with manufactured complexity.
I've reviewed Java code that uses generics, it's really not anywhere near as complicated as you're making it out to be and really doesn't hurt readability once you understand generics as long as they're not going overboard with generics. Also if you're so concerned with performance that you're worried about using too many function calls you would be writing code in C not Go. 
Bleep bloop, I am a bot. I like turtles and am here to collect some metrics. I will only comment once in every sub, so do not be worried about me spamming your precious subreddit! Goodbye, and have a nice day.
On a slightly more friendly note than /u/iamugis, this package would benefit from a readme that gives a bit of context. This \*seems\* like something I might be interested in, but I'd like to know what problem, \_exactly\_ this purports to solve. But please do keep us updated!
Please be more specific about how it is coding for code. The problem solved and reasoning for modeling code into each of the 3 layers is very well explained in the post. The only real critique I see from your reply is about naming. Effective Go is a nice intro to the features and conventions of the language, but it hardly goes into best practices when dealing with more complex programs.
Any suggestions for a simpler, more extensible pattern to follow?
There are plenty of use cases where you would want to use methods on a map type. It often makes the code far more readable and extensive in the future, especially if that type then conforms to an interface, like in a mock. It’s certainly doable with a struct, and generally I prefer that so that I can add new variables to the struct later, but defining a custom map is entirely acceptable. 
You create join tables in SQL, not in Go. Go just queries the database. 
I like the term "papered over complexity".
He does have a [sample repository](https://github.com/benbjohnson/wtf), but I don't really disagree.
The biggest question is, do you want users to be able to directly access the map? In `type Whatever map[...]...` they can. So you can provide various conveniences or whatever, but you can't provide any additional guarantees. If you put it in a struct, you can control visibility. I often have methods on things that are not structs, but I find about 75% of those things become structs pretty quickly. But no, there's nothing wrong with putting methods on things that aren't structs. One case I do have is for nested maps: type Nested map[string]map[string]*thing func (n Nested) Get(key1 string, key2 string) *thing { n2, exists := n[key1] if !exists { return nil } return n2[key2] } func (n Nested) Set(key1 string, key2 string, t *thing) { n2, exists := n[key1] if !exists { n2 = map[string]*thing{} n[key1] = n2 } n2[key2] = t } This can save a lot of code, especially if your nesting goes down to three or something. Additional policy can be loaded in as desired.
if you like generics and enjoy complexity then stick with Java. Not all languages are for everyone. I personal love the readability of Go, that I can open up any file, look at any function and gain an understanding of what I am looking at. `Get&lt;T&gt;()` does not afford you that same luxury. You now have to investigate what `T` is, and if it is being used correctly. Generics are a decent pattern in object oriented languages.
Holy crap, don't remind me!
Here's another example: type StringSet map[string]struct{} func (ss StringSet) Add(s string) { ss[s] = struct{}{} } func (ss StringSet) Remove(s string) { delete(ss, s) } func (ss StringSet) Has(s string) bool { _, ok := ss[s] return ok } [https://play.golang.org/p/G9f8WLucZT7](https://play.golang.org/p/G9f8WLucZT7) In this case the fact that it's a map turns out to be handy because you can `make(...)` it and `range` over it, but the extra methods make it more clear to the reader of the consuming code that these are intended as set operations. `Has` is also arguably more convenient to use when it's a single-bool function, since the *value* in the map is meaningless. My rule of thumb here is to do this only when the "map-ness" of the value is part of how it is used. If you don't intend the caller to use native map operations on it then better to hide the map inside a struct, but if it's just a map with some extra helpers then this approach can be helpful. It's not something I tend to do a *lot*, though. I've written variants of the above set idea more times than I can remember since lots of problems are more conveniently expressed with sets, but otherwise it's just been small helpers here and there.
lsof? netstat? Those will tell you what is using them. 
It means, the address is already in use
It means the address is already in use
I don't think adding an '/internal' package in which you place your actual packages adds any value. It simply requires you to open the internal folder first before you see your actual packages and therefore structure of your actual application. I see the benefit of the '/cmd' package, but I also like having my main.go present in the root of my project. At least the main that is the starting point for my service, API or whichever. The '/cmd' packages to me feels like a place to store alternatives, test set-ups and similar. I'm sure there are use cases where this is beneficial though. In the projects I've worked on (micro-services oriented), I've never felt the size of these services was large enough to require a complex packaging hierarchy. I've seen it though from some colleagues, and mainly felt I was lost in the high number of folders each containing 1 .go file.
I wouldn't be happy if those directories were empty.
&gt; It simply requires you to open the internal folder first before you see your actual packages and therefore structure of your actual application. Who cares about having to open a folder in the context of software development... ever? Why does it matter if all packages live at root vs living inside an /internal or /pkg folder? It's actually the same as placing all source code inside an /src folder in traditional projects. Also, the actual use case for /internal is to convey a message that the code is not supposed to be consumed by other projects and can break any time which makes a lot of sense to me. Even within a single company, it can be quite helpful to divide every Go project source between an /internal and a /pkg root directory. It immediately tells others if they can rely on the code as a library or not. IMO it's a very good convention to have.
You can quickly fix almost any import cycle by pulling the shared code into a 3rd package. That's not always the cleanest solution, but after a few times you can do it without even thinking.
I'd try to re-create the issue with netcat. netcat -uvl 1234 
You're trying to bind on a port already open by another application.
I know, I coulda had 15 Lambos by now if I'd only invested in Barfcoin, Poopcoin, and Coincoin. I'm such an idiot.
&gt; it's kind of a logic dependency It's a data dependency. The DB schema is fixed, so should the code be, so should the logic be. That being said, with a data model layer you can "fix" mismatches between the DB and your logic if need be. &gt; Say you want to move to a DB Don't solve problems you don't have. Think more generally about your data store. You have a couple classes you're most likely to use: relational (ex. mysql) or key-value (ex. redis). Make your intermediary data model fit the general pattern and you've got the flexibility you'll need.
Both of them show no use of the port in question. I was thinking that binding the port to 0.0.0.0 first and to specific IPs later could bbe the issue. But a quick test doing so ruled that out.
It isn't. At least not according to lsof and netstat.
Not on that port. At least not according to lsof and netstat.
I like parts of go tho and think it would be much improved with generics. Also you can gain understanding of generic functions quite easily.
Reading from channels is blocking. That means it doesn’t just skip over it if it can’t read (unless you have a select/default). Waitgroups are just one of many ways to synchronize goroutines. Often, you’ll find a goroutine with an infinite loop that just reads from a channel. The infinite loop is what causes it to keep running. A waitgroup is merely a way to say “all other routines have finished, so I must be done”. It blocks the thread much like reading a channel does. 
You actually don't need to fork it. I suggest you to write a small package that preprocesses the markdown with custom formatting direcetives, then pass it to blackfriday. Markdown is a superset of HTML so you should not have any trouble, just make sure your tags don't clash with anything. Example: (Markdown with extensions) --your-package-&gt; Markdown --balckfiday-&gt; HTML
If lsof doesn't show a different program using the address, then maybe you have two parts of your program using it. Run your program under \`strace -f\` (and maybe filter with \`-e socket,bind,...\` whatever you need to see your port usage), and check that it isn't already used from within.
You'll need to provide minimal code that reproduces the error for us to be of any help.
I'm not aware of the Go tool using any form of config files, so it is surprising that you have exported that variable value and then the same shell produces that error when you run a go mod command. 
I usually set the env on the same line as my go command, like this: `GO111MODULE=on go mod [init|tidy]`, if that has any difference.
go itself will not override your env variables. You could also move your project outside of your gopath if you cannot fix this bug.
`$ man tree`
Another reason: you want to define how that map is printed. Defining a String and/or Format method on your named map type lets you do that. &amp;#x200B; Also wrapping a map in a struct and wrapping map access in methods on the pointer to that struct is going to cost one pointer indirection (one fetch &amp;&amp; stall, and one cacheline) for nothing. And probably a extra heap allocation too. So if you were trying to make the code a little leaner and the struct was nothing but a wrapper for a map, then removing the struct and using the naked the map would be a gain.
This seems to draw from Kubernetes a lot. Don't do what we did. I agree with some of this, but not all of it. For example, keeping app-specific code that you dont intend to share under cmd seems fine to me. Kubernetes has tiny main.go and all the app code in pkg/ and it's kind of obnoxious. 
I find it to be mental overhead and complexity that *often* serves no purpose. Go is about simplicity and clarity, so I like my project structure to reflect that as well. 
Channels and waitgroups are *both* things that goroutines use to communicate and synchronize with one another. "Goroutines need waitgroups but channels don't" doesn't make any sense to me.
"internal" has a special meaning : https://golang.org/cmd/go/#hdr-Internal_Directories &gt; Code in or below a directory named "internal" is importable only by code in the directory tree rooted at the parent of "internal".
I've tried doing this in combination with kaiserkarel's suggestion as well. Unfortunately, it's still a no-go. Thank you though!
Of course it depends on your taste and workflow but in most real projects include files that contain a lot more than code. There are interface definition languages, static assets, build configs, CI scripts, deployment/kubernetes/docker files and what not. If we dump all the source code in the main directory, then that becomes mental overhead but anyway, this is getting into a matter of personal tastes now. 
Thanks. Unfortunately it didn't do the trick. My guess is it's going to be something silly that I'm missing. Again, thank you for the suggestion.
Effective Go has base principles which help you to not shoot your legs off while creating something. If you know what you are doing in first place of course. What should I tell you about this article? It's messes up base principles of software architecture, What is repository? What is service? What is even mean? If I grab something from external grpc -- it's repository or not? Maybe it service? But services is for business logic. Business logic PostAccount? Really? Mayber account.Register is usefull and tells something about application, but AccountService.PostAccount tells nothing, except it's some service with account that can post it somewhere. Why it should? And why I should care if we have PostAccount in repository for some reason? Why it contradict Effective Go: returning interfaces, mess with naming and more to come. Is all this stuff really necessary and have some advantages that costs base programming language principles? I guess not. I've seen once an app of major tv distributor which was written in similiar way. A bunch of code that tells nothing about application, just post that get those. Why, for what reason? Nobody knows. And nobody cares. Duplicate code everywhere, repository getting something and just throw it to some service and on questions like "why is that" I had really one answer: because we used to it. We do it because we do something similiar before. Don't do that. Maybe on less 50 entities it readable, but beyond it's just crazy legacy from hell. Start from domain entities and business logic, connect it to infrastructure with interface adapters and have really chill life and good code. Go isn't some alien language with unknown principles and rules. Rules are always the same, tools not, but it's not important. Read books, starting from Uncle Bob's "Clean code" and "Clean architecture", and you will never asking those questions again. Good luck.
nice even better └───project-layout ├───api ├───assets ├───build │ ├───ci │ └───package ├───cmd │ └───_your_app_ ├───configs ├───deployments ├───docs ├───examples ├───githooks ├───init ├───internal │ ├───app │ │ └───_your_app_ │ └───pkg │ └───_your_private_lib_ ├───pkg │ └───_your_public_lib_ ├───scripts ├───test ├───third_party ├───tools ├───vendor ├───web │ ├───app │ ├───static │ └───template └───website
C:. └───project-layout ├───api ├───assets ├───build │ ├───ci │ └───package ├───cmd │ └───_your_app_ ├───configs ├───deployments ├───docs ├───examples ├───githooks ├───init ├───internal │ ├───app │ │ └───_your_app_ │ └───pkg │ └───_your_private_lib_ ├───pkg │ └───_your_public_lib_ ├───scripts ├───test ├───third_party ├───tools ├───vendor ├───web │ ├───app │ ├───static │ └───template └───website
even better, but pasting the result here did not work for me
It seems something is wrong with your directories? The message states "go: modules disabled inside GOPATH/src by GO111MODULE=auto; see 'go help modules'", meaning you are still in GOPATH. Have you by any chance set GOPATH=$HOME or something like that?
You haven't aliased the go command right? That might explain it.
If you run under multiple users, this can happen, for example, if I am running my server, and bind to port 8888 as my own user account. I then kill the program, and re-run it under root, I get this error until a timeout has happened where the socket is available again, the socket goes into TIME\_WAIT state. [http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html](http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html) Not sure 100% if this is your problem, but it is one way you can get this kind of behaviour.
[removed]
At least 5k+ people disagree
&gt; definitely informative and ultimately drove me to Bolt Can you explain this more? When is Bolt/BBolt a good fit?
I have not. Not to my knowledge at least.
I've set the following in my ~/.bash_profile: export GOPATH=~/gocode export PATH=$PATH:$GOPATH/bin And the following in ~/.bashrc: export GOPATH=$HOME/go-workspace export GOROOT=/usr/local/opt/go/libexec export PATH=$PATH:$GOPATH/bin export PATH=$PATH:$GOROOT/bin export GO111MODULE="on"
What does `go version;go env` tell you?
 go version go1.11.4 darwin/amd64 GOARCH="amd64" GOBIN="" GOCACHE="$HOME/Library/Caches/go-build" GOEXE="" GOFLAGS="" GOHOSTARCH="amd64" GOHOSTOS="darwin" GOOS="darwin" GOPATH="$HOME/gocode" GOPROXY="" GORACE="" GOROOT="/usr/local/Cellar/go/1.11.4/libexec" GOTMPDIR="" GOTOOLDIR="/usr/local/Cellar/go/1.11.4/libexec/pkg/tool/darwin_amd64" GCCGO="gccgo" CC="clang" CXX="clang++" CGO_ENABLED="1" GOMOD="" CGO_CFLAGS="-g -O2" CGO_CPPFLAGS="" CGO_CXXFLAGS="-g -O2" CGO_FFLAGS="-g -O2" CGO_LDFLAGS="-g -O2" PKG_CONFIG="pkg-config" GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/0j/0_m20qcx5195tx5lccvy7bhm0000gn/T/go-build652122938=/tmp/go-build -gno-record-gcc-switches -fno-common"
Only thing I can think of is some kind of weirdness due to your GOPATH pointing within HOME, with go1.11...
[GoCenter](https://gocenter.jfrog.com/stats) is live now and we hope the [Wiki](https://github.com/jfrog/gocenter/wiki) page on GitHub has a bit more details than the original landing page had. For the questions on how it works together with Athens, please check out the [FAQ on GitHub]( https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions#doesnt-a-repository-like-jfrog-artifactory-or-athens-achieve-the-same-benefits) Also, send us your feedback! I'd love to see feedback on how we can improve our tech to help the Go community. _Disclaimer: I do work for JFrog_
How many of those people think this is an official Go recommendation? I don't think mentioning that it's not official in a footnote really helps with that.
Gotcha. I may experiment and try pointing my GOPATH elsewhere. Thank you.
Those are great questions. We answered some of them in [the FAQ](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions). For example, [why lock file against GitHub won't help](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions#why-is-immutability-important-and-dont-github-tags-provide-it), and [why GoCenter is not a single point of failure which you are required to trust blindly](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions#wont-a-central-repository-create-a-single-point-of-failure-what-happens-if-it-is-not-available-or-out-of-business). Also, [why it is not a project to provide a private proxy](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions#doesnt-a-repository-like-jfrog-artifactory-or-athens-achieve-the-same-benefits). &amp;#x200B; Hope that helps! *And of course, I do work for JFrog :)* 
Exactly!
It is a first of a kind. It is not an organizational proxy like Athens or Artifactory. [Here's why](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions#doesnt-a-repository-like-jfrog-artifactory-or-athens-achieve-the-same-benefits).
i work on ethereum and it rules my man, got a slick golang backend to interact with the go-ethereum client and its fun as hell
ive been employed by a crypto company for 2 straight years...
This guy, Dmitry V. Sokolov, has other repositories that deal with computer graphics. Very interesting and nice material. Maybe a good way to look for alternative packages in Go and understanding the power under it. I really enjoyed it! Thank you very much!
The only thing I'll mention is that the @_cdecl attribute is unofficial, and mainly used for debugging the Swift compiler.
Thank you, I’ll definitely have a look into that!
[removed]
The difference between Bolt and BBolt is unclear to me. I looked through the BBolt project and I couldn't find anything concrete in what improvements they've made. They make claims like improving stability and whatnot but I just couldn't find any specifics. As for Bolt itself -- it's a solved problem. It's archived now and, far from being perfect, its performance is predictable and consistent and its API surface is very shallow and simple. I like that.
[tiketqq](https://tiketqq.domino99bandarq.com) [rajabandarq](https://rajabandarq.domino99bandarq.com) [sahabatqq](https://sahabatqq.domino99bandarq.com) [mejaqq](https://mejaqq.domino99bandarq.com) [sahabatpoker](https://sahabatpoker.domino99bandarq.com) [crownqq](https://crownqq.domino99bandarq.com) [nagaqq](https://nagaqq.domino99bandarq.com) [jaguarqq](https://jaguarqq.domino99bandarq.com)
How is this a go question? This is no different than python or Javascript. 
and how many gay years?
Scanl is kind of dumb, and I’ve only seen it used in production once, and to be honest it kind of sucked there too. I think it only exists because C has an equivalent function. I’d use https://godoc.org/github.com/manifoldco/promptui instead. 
Scanln scans into a string, not into an arbitrary value. It doesn’t do string conversions to values. var s string _, err := fmt.Scanln(&amp;s) ... error check ... f, err := strconv.ParseFloat(s,64) ... error check ... f is now your float value. 
Couple comments: * Your getFileName method could be shortened to something like: fmt.Sprintf("%06d", e) // pads with 0s to a minimum length of 6 * You split the csv by newlines... this might be fine for a specific file you are working with, but is not proper for actual CSV files, as a single row of data could span multiple rows (new lines within quotes) * To do it properly you'd need to read the file using the csv reader in the standard library If you want to do this as a learning exercise, by all means keep going. If you just need a fast csv processing utility, I'd take a look at xsv (written in rust)
Only thing I can see is your getFileName function. Try a simple: fmt.Sprintf(“%s_%06d.csv.gz”, prefix, filenum) One line. I would also be using flags and setting a default prefix, but that’s more of a personal taste thing. 
Thanks for this I will take a look at xsv.
thanks for this. This will def shorten that method. 
[removed]
I don’t know what I’d use this for but it looks really cool. 
Don't forget about the lattency!
[removed]
/u/juhmayfay’s response is fantastic. While I haven’t looked at the code, it would be shocking if it’s performance wasn’t entirely bottlenecked by disk speed. Try running it against a RAM disk. 👍🏻
The second sentence literally says: &gt;It's not an official standard defined by the core Go dev team If people star things without reading 2 sentences into a README that's their problem.
It would be awesome to add go runtime metrics, to see say # of spawned go routines. I once noticed a routine leak in heroku because of they charting feature they provide. 
I feel like some people could use this to pseudo manage haproxy. 
I found it looking up Docker containers. The author was using it to manage a config file &amp; monitor output.
That’s a neat thought experiment, but I’m not sure this is warranted if you wanted an easier waitgroup. Waitgroups are already dead simple IMO, and now I’m stuck relegating my goroutines to you, assuming I’m wanting that same design pattern across the board.
Why does this need to be an entire library? 
1. We might be making di container when initialize application. 2. Then we will inject this package into that. 3. When we need to run task as async, we should call goroutine of this package from di container. so, we can wait to finish all async tasks when application is shutdown. We prepared sync.WaitGroup as a package in order to do the above easily
Yes but why don’t you just put this direct into your code? Why does it need to be an entirely separate library? You’ll find people that don’t think this is idiomatic go, but I personally like the pattern. But why does it need to be another dependency, and not baked in?
Have you ever had multiple projects? I know you want to saying. But I don't want to write same code at every projects.
Honestly, I don't see the point - you're saving maybe 1 line of code, at the cost of a dependency. Hard pass from me.
Why are you so concerned about dependencies?
Why are you not?!
Because, I don't have plan to changes code of this package. and this package is used only standard packages. Why are you so concerned about dependencies?
https://research.swtch.com/deps
The only CSV-specific thing here is output file extension. Split input file name into name and extension (remember that extension is optional), then use it to generate output file names and you have a universal program.
yes. we can version lock using dep or module etc...
Look at your typical JS application with its 11000 dependencies, and tell me how you're meant to audit that, or understand all that third-party code. Dependencies for trivialities are especially inexcusable though IMO. Does \`left-pad\` or \`Event-Stream\` ring a bell for you (google if they don't)? Dependencies can't break your build or infect your code if you don't carry them. Or to quote Rob Pike (one of the lead Go designers/developers), "A little copying is better than a little dependency." By all means use this in your own projects if it suits, but this sort of sugar is not a dependency I'd consider carrying.
yet you don't even have tags. no one is gonna version lock on `v0.0.0-deadbeef`.
&gt;Rob Pike (one of the lead Go designers/developers), "A little copying is better than a little dependency." This is famous. but my laziness is strong
You're changing your slices a lot for those newlines. Why not use `ReadSlice`: https://play.golang.org/p/FGrcao9wN6N
Wrong subreddit
Nice, I love it! I think this is a good illustration for beginners in how to write their own small package with tests.
you are right I'm sure this completely depends on disk IO for this to be sped up. The problem I see is the file is around 700GB and I would also need the space for the compressed files. So I would probably need around a 1TB of RAM to handle all this. 1TB is pretty hard to actually find without breaking the bank on aws. I was also considering NVME backed storage devices in aws: https://aws.amazon.com/blogs/aws/ec2-instance-update-c5-instances-with-local-nvme-storage-c5d/ Though it looks like I would need the biggest one they offer with the dual 900GB drives. Anyone know of a solution where I don't need 1TB and can still use a ram disk? Thanks for this response. I will def consider this an option if I have the cash and want this to run faster. 
Why? If I cannot install Go packages that has external reference in FreeBSD this is a solution. When cross-compile this type of application from my mac for deploy on FreeBSD I am in trouble. I spend a day for this simple solution. I think that can help others.
Thank you very much for this. I'm very new to golang and still learning all these methods on bufio module. I will defiantly switch to ReadSlice method. Also thanks for the playground example. This helps so much for new gophers :) 
[https://github.com/miguelmota/golang-for-nodejs-developers/blob/master/README.md](https://github.com/miguelmota/golang-for-nodejs-developers/blob/master/README.md) That link was particular useful to me, having a JS background
It has very little to do with Go language. BSD subreddit is more suitable for your post, but I suspect everyone there already knows how to install pkg-config.
I was thinking about this as well. I know I could do something like this: https://www.socketloop.com/tutorials/golang-how-to-split-or-chunking-a-file-to-smaller-pieces The other thing I'm doing is rewriting the csv header row into each new file. maybe if I had the header just in a separate file and read that in once at the beginning and then used this method for splitting the file. I'm wondering how much this solution would speed up the splitting? Thanks for the suggestion and I will definitely consider this as another solution. 
Thanks. I figured it out. Defined a Struct in golang (order_product) that had two fields , the fields (orderID and product ID) were foreign keys linking it to the two tables (Orders and Products) I was trying to join. 
Check out some possible answers [here](https://stackoverflow.com/questions/3751429/reading-an-integer-from-standard-input). Really, you'd be much better off using Scan, something like this fits your usecase, and will return an `err` if you enter something other than a number. var i int if _, err := fmt.Scan(&amp;i); err != nil { log.Print(" Scan for i failed, due to ", err) return }
Tips... - forget about what you know about async/await for a minute, and be sure to properly understand channels, goroutines and mutexes. The more exercises you do with them, the more you'll get a proper grasp of a very technical difference between node and go, - write a few http apis that require routing, before checking out go-chi/chi's router and middleware (know what you need before you pick something that fits your use cases, and don't pick iris ever), - when using a particular stdlib package (net/http), check out it's nested packages too (net/http/httputil, net/http/httptest) for the less common but useful functionality that people usually don't find out until much later, - unless you have a *very good reason*, don't use reimplementations of net/http (like fasthttp or something like that) - the stdlib improves all the time and is in many ways better - embrace the strong type system and avoid `interface{}` (or at least know when you need it - i went in from PHP/JS and was trying to use it a lot at first, and it just needs a mentality shift from the untyped hell that are scripting languages) - have fun? if you're into robotics, then https://gobot.io/ is a good place to start, and they have a list of hardware you can play with too, from drones to something like [the launchpad mini](https://twitter.com/TitPetric/status/823094012273983488). I'm much more comfortable with low-voltage electricity than I was, and I can even wire up 230V devices now (after re-reading the wire color meanings like every time). Pretty sure the sky is the limit, if you have a little bit of a budget and can buy some tinkering hardware. Depends what you're into :)
My suggestion: add a switch (`--csv`, `--header`... whatever you like). When program is run with it, store first line of input file and write it at the start of every output file. There's no need to parse CSV, unless you want to add some transformation and/or normalization (i.e write all string values in quotes). 
 Don't think too much. The beauty is in the types and carrying types through interfaces. This uncoupling everything model. https://medium.com/golangspec/interfaces-in-go-part-iii-61f5e7c52fb5 https://research.swtch.com/interfaces https://www.golang-book.com/books/intro/9 https://www.youtube.com/watch?v=83J256zByHA https://github.com/golang/go/wiki/CodeReviewComments#interfaces https://play.golang.org/p/pv7o3G32I1 https://itnext.io/interfaces-in-golang-f1aea1ba31cb Also, being able to deep dive into code in the standard library. Down to the source code while knowing exactly what's going on. https://golang.org/src/io/io.go#L250 Also, the ease of use of creating a server and connecting to a database is just easy with the API. There are some parts of the API that seem low level. Like writing buffers. If you attempt to load multiple strings into a file, go may not have a universal method for doing so. This is where things get kinda complicated. The same with converting types when params expect a []byte and you want to send an int or whatever. You do have to think. Sometimes also, the scope is not like other languages. Like for instance changing a value in an if statement and having it carry. It's surely not like js at all then. Same with for loop. It has very strict scoping. Not trying to give negative examples here but these are things that really threw me at first from js or php. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
You might think that map[string]interface{} Is a good idea. But if you did, you would be wrong. Don't do that.
If you ever find yourself thinking "there must be a nicer way to do this than a for-loop" - there isn't.
What's the issue with this snippet? Care to elaborate?
In the std lib there is the header of http.request. But there was some discussion about changing the implementation to do lazy parsing. Unfortunately it is not an interface so it's impossible. (Basically an example of how it makes it impossible to switch an implementation)
With some context the original comment could be greatly improved. Generally speaking, using `interface{}` in Go should be avoided where possible because it forces you to do things that slow down your code, make it harder to understand, and make your applications less robust (i.e. you lose the benefits of actually using a strongly typed language like Go). In some cases though, it can be difficult to avoid, or actually less clear. If you were trying to unmarshal an extremely dynamic, piece of JSON then you might find it's only possible to use a `map[string]interface{}` and reflection to work with the data. In some cases, avoiding `interface{}` might mean more verbose code, and in some of those cases too, code generation can help a lot to avoid writing that verbose code by hand.
Yes, I mentioned that @\_cdelc is undocumented, but maybe I should add that is unofficial too.
It seems potential but so complex library, I´ll check it out, thx!
Thats a clear way to solve it, thx!
I actually tried this, but it jumped over the "cantidad" scan, but it seems to be solved if I replace its ScanLn with Scan too, thx!
Don't be clever. Be obvious. 
I would re-phrase the problem. Using **empty interfaces** is okay, but **using empty interfaces to take care of unknown types all the time** is an anti-pattern. There are scenarios that require you to use empty interfaces (many built in library functions are written to expect empty interface or empty interface slice arguments). But most of the time you should take advantage of the type system and come out with a solution without empty interfaces. &amp;#x200B; More: 1. An interface holds two things a *dynamic value* and *dynamic type.* So empty interfaces use up more resources because they have to track the *type* too. 2. *Dynamic type* is a execution-time thing. So you also lose the advantage of static type checking, and you are opening a window for possible bugs.
Although maybe this won't give you tips for you coming from JavaScript, but maybe will get you started since i recently wrote how i managed to learn GO: https://dev.to/kilgaloon/how-personal-opensource-project-helped-me-learn-go-54b9
THank you so much for making this post I"m in the same boat as you and I really needed this one.
I'm in the same boat as OP and one of my senior developer at my workplace suggested me to go through \*go tool tour\*, do you think its worth it?
Do the processing in memory and write big processed chunks of data to disk in a separate goroutine. Have some upper bound on your write queue and halt processing when it's full so that you don't max out on RAM.
The [original video](https://www.youtube.com/watch?v=_YK0viplIl4) was [previously posted to /r/golang](https://old.reddit.com/r/golang/comments/7jrwau/dotgo_2017_sameer_ajmani_simulating_a_realworld/) (without any comments however).
Go has goto instruction. So there is another way, but it's indeed not nicer :)
I also came from js and all I can say is to first, read the docs (obviously), and second, try to tackle a good sized project ASAP. That was when I really learned how things worked. Staying with the same ol “what’s your name” and whatnot will get you nowhere, even if you think it’s the only thing you’re able to do.
\_"[errgroup](https://godoc.org/golang.org/x/sync/errgroup) has the goal is to cancel all asynchronous when at least one async fails."\_ - that's not the only way to use errgroup. That is how it works if you use it with \`WithContext()\`. If however you use \`Wait()\` instead: [https://godoc.org/golang.org/x/sync/errgroup#Group.Wait](https://godoc.org/golang.org/x/sync/errgroup#Group.Wait) then it works pretty much like your library. So you just replicated half or errgroup package for no good reason. It's great as an exercise, but I doubt anyone will use it, except beginners who don't know about errgroup or don't know how to use it fully. &amp;#x200B; Thumbs up for the effort though, keep it up!
The Go tour is short and sweet!
&gt;Also, the ease of use of creating a server and connecting to a database is just easy with the API. Uhh…
The largest thing I think Node developers need to get used to is to reach for third party libraries as a last resort. I strongly recommend approaching third party libs as a “I will use this if I absolutely have to but not before”. I don’t think convenience is a valid excuse. The JS ecosystem makes it easy to download hundreds or thousands of libraries. Normal even. Don’t do that in Go. Most projects I’ve written have had 0-2 library dependencies (and one of those two is pq, the Postgres driver). The standard library is great. It’s huge, covers most use cases most people need most of the time, is well maintained and is generally quite performant. Use that to your advantage. 
It's the transformation of the source code built in the book I released last September. It's not production ready even not completely usable at this point, but I would appreciate any feedback so far, especially on the following: I want to offer a database engine agnostic data package, and so far the best way I found to accomplish this is via build tags. Since MongoDB and PostgreSQL / any database/sql packages are so different in their usage. Would there be a more idiomatic way to do this? The library offers some built-in routes to accomplish common web applications and SaaS actions, like signing up, signing in, entire subscription management. At this stage, if the developer would not want the default routes, they would need to pass an implementation of their own to the library. I want to make sure this would be easy to use and not sure about the best way to either enforce built-in actions by default or having them being opt-in instead. Any thoughts on that? If you had to build a SaaS, would you consider using this library? Thank you for any feedback
Server basically just the "net/http" https://gitlab.com/zendrulat123/goes/blob/master/github.com/zendrulat/goruns/main.go Routes/database: "database/sql" and "net/http" https://gitlab.com/zendrulat123/goes/blob/master/github.com/zendrulat/goruns/temp.go Without it doing restful that's pretty much it to get it up and going from the core API.
Connecting to already existing databases can be tricky if it wasn't made for Go, and some types don't exist in Go. I just wanted to point out that databases are a pain in the ass!
Use the go module system and do not depend on GOPATH. GOPATH was a mistake.
Go? For robots? This seems interesting, thanks for sharing. 
Sorry, but just because it took you a day to solve, doesn't mean it is worthwhile information. This is also definitely not the right subreddit, since pkg-config is not just used in the golang ecosystem either.
Having done js in the past, and now doing go full time: don't look back. The time formatting will piss you off at times. Errors are values, don't use them like exceptions Go is not classically oo, it's about composition and embedding Avoid using map[string]interface{} Remember closures, golang makes use of them too Golang isn't single threaded, use the race detector (go build -race, go test -v -race) Interfaces are your friend, and make testing easier if used wisely. Declare interfaces of dependencies in the package that uses the type, don't declare interfaces next to the type itself (inversion of control) Have fun Think back on your time spent doing js, and be happy you've moved on to a better place 
The book is a good read :) I just finished chapter 7. Will surely get back with a review of \`gosaas\` in a couple of weeks.
There’s a monthly mega post here for hiring (although not very “mega”)
This is probably the single place (aside from The Blue Book) that taught me the most about Go: https://quii.gitbook.io/learn-go-with-tests/
This is exactly what I was thinking. I'm just not sure where to start. Maybe I can't be reading line by line in order to this and I have to reading bytes of data into goroutine. 
Thanks, this means a lot to me. Hopefully gosaas will reach more Go developers as well and be useful.
This is kind of general advice, but applies real well in this case. 1. Think in go when coding go. Do not try to bend it into another language 2. Don’t spend ten hours designing and writing a framework when ten minutes of straight up code works just as well 3. Don’t write code to write code, write it to solve a real problem. Overdesigning just makes everything worse 4. Properly learn go. Take your time, but read up on every detail
A problem with this approach is that each `(*sync.WaitGroup).Add()` accesses a mutex. So if you have to spawn `N` goroutines at once (or in quick succession, like with using a `for` loop), one uselessly does `N-1` accesses of that mutex, when one would just call `Add(N)`. 
As resources go, I usually recommend: - https://gobyexample.com/ - https://tour.golang.org/ - https://github.com/dariubs/GoBooks And if you like to read blogs, I can recommend: - [scene-si.org (mine)](https://scene-si.org), - [Dave Cheney](https://dave.cheney.net/), - [Vladimir Vivien](https://medium.com/@vladimirvivien) There are probably others that deserve a mention, but besides [@rakyll](https://twitter.com/rakyll) I'm blanking a bit. Feel free to add some in the comments and let me know :)
I was just looking at Iris. Can you elaborate on the issues you've seen with it? For context I enjoyed working with echo in the past.
This may not be related, but you shouldn’t need to explicitly set GOROOT. Modern versions of Go can figure it out on their own based on the location of the go binary that you run.
I see where this is going. If you can comment on my code I have here . I did this a while ago . I was trying to unmarshal dynamic data . https://github.com/jaytarang92/goremotsy/blob/master/remotsy.go
Most of these can be replaced by a simple curl
I didn't know about Gobot! It looks like a fantastic project, thanks for sharing it! 
"recursive solution will be so elegant and beautiful" - nope, tail calls are not optimised and there are good chances will never be. Because.
Interesting. I would have to look into netcat more as I am not overly familiar. Netcat is unencrypted right?
Watch justforfunc YouTube videos. They are great at teaching stuff a little more advanced than beginner. [justforfunc](https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw) 
oh thanks for coming
woah that's a nice list thank you for categorizing blogs a bit differently, I like to read a lot
There's this proposal from one of the top go contributors: &amp;#x200B; [https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624) &amp;#x200B; &amp;#x200B;
The author is a dick and squashes commits from contributors, steals code from other projects and and violates licenses, and edits github comments/issues to mask his bad attitude, and several people have made accusations that he's buying github stars for credibility. - Reddit masterthread: https://www.reddit.com/r/golang/comments/57w79c/why_you_really_should_stop_using_iris/ Te don't even need to go into technical reasons. If you need something most likely you're torn either between go-chi, gorilla (at least for websockets) and go-kit for anything more (that's a huge one). Any of those is a good choice.
This is really the point. We have a lot of people creating extremely complicated layouts, patterns (accept interfaces, return structs), idiomatic go and much more stuff right from the start. The real underlying philosophy of golang was simplicity. Idiomatic go is "keep it simple". Somehow it got lost in all the noise.
To be fair it is an explicitly stated design goal to remove "elegant" solutions to ensure first-pass readability.
Master the standard library. Also, Go's strong suit isn't web dev but straight software engineering so it won't hold your hand. In JS, the frameworks are kings. In Go, the language in it of itself is king.
It can be, doesn’t have to be. It pretty flexible.
ctop is Python, isn't it?
WTF the bit "every developer" is there for? 
Don't expect a package for everything; "a little copy is better than a little dependency" is a motto. Go has value types which give you the power to lay things out in memory in a certain way, but they also affect the language's design in ways that can feel limiting if you come from a dynamically typed language (or a statically typed language where everything is implicitly a pointer); once you grok this, these limitations make all the sense in the world and they actually work out pretty elegantly. So you may be tempted to get frustrated by the limitations, but hang in there. :)
I didn’t mean use a RAM disk in production. I meant use one to determine if disk is, indeed, the bottleneck. If you have many files to process and want fast throughout on AWS you can parallelize it across many machines with fast network I/O and use S3 for storage... 
Try the Discord channel "Discord Gophers". There are ~550 users.
&gt; forget about what you know about async/await for a minute Alternately, reformulate it. It's still relevant, it's just nowhere near _as_ relevant because in Go, basically everything is _already_ async/await/etc. If you're adding an additional layer on, _then_ you're doing it wrong. async/await is an [inner platform](https://en.wikipedia.org/wiki/Inner-platform_effect) that basically tries to recover "threading" from a language that doesn't have it built in [1]. In Go, that "inner platform" is already the platform. The compiler is doing much, much more of it for you. [1]: This a controversial opinion, but in my opinion, that's exactly what "async/await" is, and the attempts to separate it from threading based on minor technical differences are rationalization, not technically justifiable. If you're running code truly concurrently, you've got concurrency-type problems, and if your code "solves" concurrency problems by never running more than one thing at a time and claiming that's a virtue... well, fine, maybe it is, but you're "solving" the problem by simply refusing to play in that space, and you're going to need to be OK with the fact that the languages that do will outperform you, albeit at a complexity cost.
Don't forget about `go fmt`! Especially if you use an editor that supports as-you-type suggestions/corrections. My work in Go has been so pleasant for me because, between `go fmt` and stronger typing than the other languages I use, I spend far less time debugging than I became accustomed to. Also, you probably know this coming from JS, but make sure you're used to thorough logging. This will also help you spend less time debugging.
This. I started using modules last week and already hate gopath.
Important to note that verbose code, if thoughtfully written, can be just as clear or clearer than compact code. Yes, it's a pain to have to write a separate function for processing an array of floats vs an array of ints, but reading source code in Go is still easier for me than reading Python. Python devs are always being clever...
Here’s a forum I’m writing now https://github.com/godiscourse/godiscourse And I shared some resources in it too, give me a feedback if you have any questions 
That sounds super useful to be fair, thanks for the tip :) 
This is an example of why you can't assume just because a package is available on GitHub, has stars, and sounds exactly what you need... that you shouldn't still thoroughly check out what's inside.
Yeah, I remember there was something like that in the closed issue. I use go full time for almost 2 years and can't describe it as readable. And I'm not alone. I'm not saying it is unreadable though - just to add a different opinion. As for me functional languages and abstractions are far more readable. 
Well that’s a pretty good point which I haven’t thought about, because I’m that case I usually stick to what you were saying in the end. But having to mock a map... can’t I just create a new map and inject it?
What I always keep in mind is that async/await is an approach to solve problems of asynchronous programming by writing code that doesn’t look like that. To put it into context, it’s syntax sugar that adresses a problem of promises being hard to handle/understand, which again were introduced as solving the dreaded callback hell. It is evolution from something that wasn’t given much attention. As such, async/await don’t have a place in Go, as we can use goroutines/mutexes and channels as a first-order implementation. There’s nothing controversial about your opinion here, it (async/await) is literally a way to have parallelism which is understandable in a language where it by default is not understandable. Note I didn’t say threading - node is still single threaded. Anyway no need to delete async/await from your mind, but it’s usually bad to take those paradigms into Go. I know I made that mistake many times. [Simplicity is complicated](https://talks.golang.org/2015/simplicity-is-complicated.slide#8)
Unpopular opinion - if you want to play with go and actually get something done use a framework like buffalo (it's rails like, but there are a lot of express like options). Later you can go full stdlib. I struggled a lot with that "you need only standard library" community attitude at first. Mark Bates buffalo talk was a relief for me.
Excellent! I'd add: * Make a point of using Go for all small tasks, even if you feel it would be quicker/easier to just use bash/python/nodejs/... . 
This list is horrible; it includes tools for specific types of development, most are network related, and even includes tools the author hasn't even used! 
Good advice for many programming languages.
I wouldn’t trust my data to minio. Try to flex (scale out) the instances or bring any of them down for migration. The clustering story is pretty poor. How do you even recover a node?!
Don't try and write go like JavaScript
Aren’t modules only super new? Like 1.11, and not fully supported by many libraries?
fifty!
Thanks a lot... Didn't know something like that existed
To be extremely clear, the only people who should set GOROOT are people who are working on developing the Go compiler/standard library themselves. Everyone else should leave it unset. 
My brain has become so accustomed to JS that whenever I try to write anything I always think "This is how I do it in JS, how do I do it in go?" &amp;#x200B; This is perfect. Thank you.
Fresh from the clickbait title generator: &lt;insert number&gt; &lt;insert name&gt; &lt;insert property&gt; that every &lt;insert target audience type&gt; needs to &lt;insert action&gt;. ;-) A good list nevertheless. I would also add Docker and restic.
No, at least not [this one](https://github.com/bcicen/ctop).
&gt;GOPATH I remember trying to install the mongo db driver but came across an issue where the dep package wanted me to put my project inside GOPATH. I created a symlink to solve the problem temporarily thinking I'll figure out the correct solution later. &amp;#x200B; You just saved me a lot of time, will definitely read up on the go module system. thank you.
If only we can have go for the front end as well eh? Just looked it up: looks like the most recent version compiles to wasm? Wow.
This is exactly it. Drivers for connecting to databases, gRPC, redis. That’s literally all the external dependencies I have on a BIG project. In the NodeJS world, it’s super common to see a library that does one simple thing. Eg, an entire library that is just a phone number regex, which is depended on by a thousand other modules. Don’t do this in Go. I watched a talk by Ryan Dahl, the creator of NodeJS, where he talked about all the mistakes he made with Node. The one biggest one was package management. He left the node community several years ago to write Go instead, but is now back at it trying to write a NodeJS-like version that uses typescript. I was never a fan of the way Node handles concurrency, or rather, doesn’t do concurrency except in external C++ dependencies. Meant if you ever implemented anything that was CPU bound direct in JS, you locked your other requests/responses until it was finished. Even old school rails (not even modern rails) did a better job of that, and it’s a nightmare hellscape for speed, but it could deal with that. So, learn concurrency. It’s something you don’t have to think about in Node, but you need to fully understand in Go. The core net/http package sends everything down in a separate goroutine, so if you have some shared object that isn’t thread safe, you’re gonna have a bad time. But it also frees you up to lock up a goroutine with some work that’s gonna take a while. And on the note of concurrency and long running work, learn about context. Every function in the request chain should have a context associated that allows the chain to prematurely terminate. Net/http puts it in each request object so you can just use that to detect if the client went away and you can discard your work. The select/default pattern is useful here and adds very little overhead. And use typing. Don’t ever use interface{} unless there’s no other way. When possible, require an interface and not a specific object. Eg, don’t have a function call that needs a file.File. Instead, have it require a io.Reader or io.Writer if you’re doing read/write operations. Use test driven design. Tests are first class citizens in Go. And using interfaces as above really makes tests easy to deal with. 
Also checkout GopherJS and vecty. 
On marshaling json or others, marshaling into/out of a struct is an absolute dream with Go. You can make the most insanely complicated struct tree, requiring pointers in some places and values in others, and the marhaller just figures it’s shit out. I almost never marshal to/from a map. There are cases where you may need to, but generally, straight to a struct and be done with it. 
&gt;go-kit What about gin?
So `rclone` and `syncthing` and… well, `k8s`, anyone? The list could go on and on, that's why I wondering why a randomly-assorted list of software sligthly slanted towards a web programmer is something literally _every developer_ has to know :-) 
This is going to be a little generic, which I hope helps your decision some. It can be argued what you are doing in .net isn't needed, verbose, etc. I have been there and have moved over to the CQRS pattern as it solves/removes some unnecessary complexity. Just don't be dogmatic with your decision either way and give real reason instead of "I'm doing this now because my company did it before" or "I did it in the past so I am doing it now." &amp;#x200B; A design pattern can be universal and should always be asked is it useful and does it make sense. Over time I started to dislike the repository pattern(which it looks like you are doing) as it required so much boiler plate coding and, well, wasting time. The goal of maintainability, test-ability and extensibility should be part of the question and I do believe there are better design patters out there. &amp;#x200B; I have seen some go purist comments on some things like this(design) and it seems its frowned upon if you are coding like you are in .net, java, etc. Maybe being pragmatic is the best suggestion. Personally I think what you are doing is overkill in any language, with that said I have done CQRS is go due to its simplicity and personally I find it ok but I am sure others may say I shouldn't have done it.
If your process (or some other process) is already listening on say `0.0.0.0:1234` and you then try to listen on e.g., `127.0.0.1:1234`, then that is exactly the problem. Please post your code and the quick test so we can see what you are really doing :-)
Two things. You can’t just cast a map value to a string on your response. You need to check that it exists first. https://play.golang.org/p/4vUDl5gx1US Note the panic when grabbing z, because z does not exist. Instead, you need to check if it exists: value, ok := response[“user”].(string) if !ok {} This checks if the value exists first. Otherwise you’ll end up with a panic. Secondly, it looks like you actually know what the data should be already. So you should be using and marshaling the data into struct and not a map. That will make things a lot more readable. You don’t need to put in every key that it will be receiving, but only the ones you want. And you can alias them with the `json:”name"` tag syntax. 
[removed]
You cant not export a package but you can make nothing be exported from said package afaik
I think you're looking for the [internal](https://golang.org/doc/go1.4#internalpackages) directory, which will prohibit \`import\` statements.
Huzzah! Removing GOROOT and updating my GOPATH so that it's consistent seems to have resolved the issue. Thanks :-)
This a **must watch** to anyone involved with Golang. It is incredible how a great real-life example can help illustrate these principles. Excellent presentation!
No fzf?
This one is pretty good ...and free: https://github.com/thewhitetulip/web-dev-golang-anti-textbook
A list of free books (there are also many other languages) https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md#go If you want to learn more on programming you can use github's or competitors' advanced search. Lets you discover a lot of free+open source content. 
system programming languages are different. They just are.
Thank you very much for your response. It may help me I thibky. I will be very interested to have some examples on golang using the CQRS patternsm and see how it's reduce complexity. I would like to know how do you avoid repository pattern if you don't like to use it? How do you handle database abstraction? Because i'm using domain driven design. Thanks 
Take a tour of golang: https://tour.golang.org/welcome/1
Downvoted just for the wanker tracking dialog that only has an "Accept" button. I'd downvote it again for not even linking to any of the tools if I could. What a shitty site.
The new analysis API will be a game changer for the Go community. Gometalinter and Golang CI will be much less relevant with an officially supported way to structure and chain linters.
The lack of links is mindblowing. If you're going to write clickbait shite, at least link to what you're writing about.
I have worked with both nodejs and Go. I like both of these Nodejs is quite fast and Golang is even faster then that. JavaScript is more expressive than Go. In node ecosystem Frameworks are go-to way to create restful app, For Go you may not need framework as Stdlibrary is enough (with mux or chi)
Is there a tutorial for this ?
just focus on concurrency and figure out how useful is it first and expand it later. i heard about go 3 years ago, but i do not know why i should use it. till one day, when i am skimming data from many sites using python. i felt so difficult and i tried with go concurrency . so easy and useful . 
Go is awesome but Django is more complete than any framework in go. Look at beego, it’s an ish framework. I see that everyone thinks x language is pure magic. If you know python and you’re comfortable with it, stick to it. Productivity is all that matters. 
&gt; The largest thing I think Node developers need to get used to is to reach for third party libraries as a last resort. This is good advice in node also. 
Well it's designed for readability for junior developers just out of education - not people already fluent in iterator method.
The Little Go Book is excellent
&gt;&gt;You just saved me a lot of time, will definitely read up on the go module system. Just as a heads up, `go mod` is a new language feature (introduced as preliminary support in 1.11, when 1.12 is scheduled to be released Feb 2019), so a lot of tutorials may have been written before this was a thing. 
The amount of inane justifications in that thread cause me to question whether /r/golang is secretly a jerk subreddit so deep in jerk juice that it's not apparently to outsiders what really is going on
Is there something better you would recommend? &amp;#x200B; I think Minio is a pretty decent S3 compatible API. One instance is one bucket, so if you need to scale it, you have to have a file storage layer that is scalable (e.g. GlusterFS) and a loadbalancing layer (e.g. HA Proxy). Running Minio in Kubernetes should be simple. &amp;#x200B;
But if you ignore that, the library is actually pretty good I don't think he needs to buy stars. I don't use iris (or any other framework anymore) but it used to be the framework with more features out of the box (like websockets for client and server).
How does Golang detect race conditions? disclaimer: I've just gotten interested in the language recently.
Gotcha, appreciate the heads up!
^^ this also looking for resources for backend dev
&gt;Think back on your time spent doing js, and be happy you've moved on to a better place I initially really loved everything about JavaScript: ease of use, vibrant community, countless tools, etc. But when I started working on massive Node.js repos that a lot of devs have contributed to in one way or another (some are still in the company, some have left), it started becoming painful. I've been pushing hard for TypeScript because of this actually, but thats a different discussion altogether. &amp;#x200B; I haven't moved on just yet, I still have a lot of JS code to look at day to day. But working on a compiled language is a really nice change of pace. It really brings back the joy and excitement of building software.
I'll be honest, there are a lot of things I find fairly suspect about this blog post. Let me start with my assumptions. In a raw benchmark test: 1. A direct connection should be fast. 2. Nginx should be faster than both Golang and Clojure because it's written in C and has just a bit of dressing on top of an event queue architecture. 3. Clojure should use the underlying JVM network stack, which is both fast and battle tested. Give that I see: 1. In the naive benchmarks, Golang seems to have outperformed Nginx in raw latency?? 2. What does it mean to drop a request as opposed to surfacing a bad request?? 3. What is "average"? Are we talking p50 latency here? What does p95 look like? p99? Throughout the article, comparisons are made between the legacy Clojure implementation and the newly rewritten Golang implementation. This writeup really doesn't seem particularly rigorous to me.
I'm reminded of a refrain/joke from the early 1980's. "An experienced programmer can write FORTRAN 77 in any language" 
It wasn't just readability for the go source code, they stressed how important it was to keep the compiler as simple as possible as well, such that more people could understand it and work with it. This is incredibly valuable from an auditing perspective, so I thank them for that because it was a good thing to do.
&gt; Don’t spend ten hours designing and writing a framework when ten minutes of straight up code works just as well Disclosure, haven't done more than play with go 3 years ago. But it seems seriously like a KISS language. 
Try VS Code with the the go plugin.
In addition. Read the standard library code for the types and functions you use. Its extremely approachable and will teach you some of the idiomatic ways to solve problems, the go way. I learned to program using c++ and had many cases were trying to understand the Std library was next to impossible. I'm a gopher for life, between a spec that's quite simple, to the understandable std library, my next goal is to dig into that compiler and really understand how it ticks.
Syncthing?
I suspect, although I doubt anyone will confirm it for me, that the goto instruction is there to help self identify bad coders. 
I’d be really interested in this as well. Any example with go serving react would be cool to look at from an architecture standpoint
Yeah absolutely, it's still reflection based, but that's rarely an issue, except in the most demanding environments in terms of performance needs. It's wonderfully easy though :)
Ahhh . Gotcha makes sense . I am Python Dev value,ok makes sense. I'll try to create the Json for some of the responses that I know all the key/values. I am just lazy lol . I appreciate the insight. 
Absolutely. I spent a fair amount of time using Scala before learning Go and getting a Go job, and some of the one liners you could find would take a long time to grok. Even the standard library is extremely readable in Go, whereas some of the things you'd expect to be straightforward looking with Scala took a long time to figure out.
Don't bother trying to make stupid things impossible. You'll fail. Instead, focus on making good things easy. 
[exercism.io](https://exercism.io) The personalized feedbacks you get from mentors are very valuable. 
I've got a small example of this in one of my projects: https://github.com/bradhe/blobd Specifically, look at the ui package: https://github.com/bradhe/blobd/tree/master/server/ui
Gophercises has a few good ones. https://gophercises.com
[removed]
I like to create a router package where router.go contains all the routes, then I have a file per resource(basically handlers). Then to Interact with DB I create a storage package who's only job is db persistance. I create a config package where I have a config.go to load the config. It could also contain a config.json/toml/etc. Basically it all comes down to 1 package per dependency and work with interfaces to keep code decouple. Also I have a domain package where I keep my main structure definition &amp;#x200B; \-config \-router \-storage \-main.go \-go.mod \-go.sum \-Dockerfile \-docker-compose.ylm &amp;#x200B; That's pretty much how my microservices start. Give or take, it works really well. &amp;#x200B;
Pick a simple idea, a CLI or a small web application, check Go by example for relevant language features, upload your code to Github and ask for comments and code review. 
Have any good examples of go projects using CQRS?
I tried my own take on a DDD style approach. I also found if very verbose and repetitive [https://github.com/longfellowone/field-services](https://github.com/longfellowone/field-services)
So I’ve run minio as a service in production and found adding storage to be a pain. You have to bring the whole system (well the container) down. And if you have a cluster with a node that’s no longer available, I didn’t find a method to bring up a new member and rejoin the cluster. I switched to ceph’s rados gateway. 
Yeah, 1.11 and that was experimental. Set for a stable release in 1.13 I think? They build upon the work of `vgo` though, which has been around for a fair bit longer IIRC. From my limited use they seem far superior, but I can understand not wanting to use something marked as experimental in production though. I hope they become the "normal" way of dealing with dependencies though, as it makes life so much easier.
Baby steps, it's not going to happen overnight. You'll encounter everything I said earlier and more. It's a different language, and a better one at that. I enjoyed js at the time, don't get me wrong, but Stockholm syndrome is very real indeed
Honestly, go packages were my #1 pet peeve with Go. I come from the Ruby/gems world where we have such elegant and powerful packaging. To just include the head of a git repo seemed so wrong. 
Yep, I've learned go faster than any other language I've taught myself and it's because I just jumped in and started doing projects. A fun one to try if you want to learn backend stuff is an API that you can send "greetings" to when you travel that will log your travels in a database. Even if you don't travel far, it's good practice. 
Ive recently started writing my apis with json-rpc. Ive written the endpoint to run a goroutine for each function called in the request array, it passes each individual request, and a channel, to the function. Rather than the function returning, it sticks the jsonrpc response into the channel. This allows the server to handle a batch of requests concurrently. To add functionality I just write a function that sticks the errors or the results into the channel, add the function once its done to a map that defines allowable calls and im done.
I love Just For Func https://www.youtube.com/playlist?list=PL64wiCrrxh4Jisi7OcCJIUpguV_f5jGnZ
The author of bolthold just released badgerhold, about to replace my badger with it but no word yet
How about heroku?
I don’t think heroku gives me db for free. I need db too
You could use docker, and there are a lot of examples with Redis
You should be able to fit a simple web server plus Amazon RDS free teir on AWS. Or you could do you web app on heroku and free teir AWS RDS. 
You could use docker, and there are a lot of examples with Redis
You should consider using your skills to work on a great project. Burst is looking to re-write the Burstcoin Reference Software in Golang. All developers welcome to contribute to the project. Get more information by joining the Burst discord and reaching out under the #burst-apps-team channel. I just started learning Go and am loving it as well. Great place to work with others who are writing Go applications.
Depends how many rows you need. They have a free pg tier if you don’t need much.
Aws is nice. You can even just throw up pg on a micro instance anyways. 
I found [https://gobyexample.com/](https://gobyexample.com/) to be very useful when I was getting started. The Go Programming Language book by Donovan and Kernighan was good as well. &amp;#x200B; In general, definitely try writing basic things once you learn the syntax to get a feel for it. I ended up converting a website I wrote in Node.js to use golang and that was where I really had to learn how things worked.
their hobby level tier is free for Postgres 
Posting the following link hoping it might give you some idea. It's still work in progress. But I think it at least gives a general idea. https://github.com/spy16/droplets
Thanks guys. I will try both heroku and AWS. 
A lot of these design patterns were/are invented to deal with common problems with Object Oriented coding. A ton of the enterprise coding standard designs (especially in Java, .Net) are done that way to avoid problems with OO. If you move away from OO, and specifically inheritance, then a lot of those problems disappear and you don't need those patterns to overcome them. Interfaces are not objects. It took me months to work out what that actually meant, and to undo the experience of years of decomposing domain problems into objects. Golang design tends to be bottom-up, not top-down. Start with a simple thing, and add abstraction in order to manage the complexity as you add features. Don't start with building abstraction layers, only add them as you need them. Interfaces make this much easier than objects - you can define interfaces over existing functions, whereas objects need to be coded as classes from the start. So, in your example, I would start by writing a simple `FindUserById` function that calls the database directly. Then I'd mock the database and inject the dependency so I could test it. Then later, I'd want to test the logic that calls this, so I'd group all my User storage functions into a `UserRepository` interface so I could mock that. Or not, and the code would take me in a different direction (a recent project ended up with DisplayUser and User structs so wildly different that I gave up on representing users in a single struct at all and replaced the structs with property maps). As always with Golang, simpler is better. Start with the simplest thing, even if it means some repetition, and only add complexity if it's really needed.
Get a copy of The Go Programming Language book and read it. Literally the best way to get started IMO.
I'm also moving over to CQRS after some great advice here, and finding it useful. Event Sourcing is also proving useful as an architecture for my project, though implementing that is interesting :)
you can try gcp. you'll get one f1-micro instance free forever
I found this very helpful: https://quii.gitbook.io/learn-go-with-tests/ Pair it with The Blue Book and you are good to go. 
Forget everything
RDS is a far better choice for dozens of reasons, including security, backup, trivial scaling, monitoring, etc.
Agreed. But it’s far more expensive if you just need a small database. 
I don't know why you would. But just go to the github and save one file. Becauee the packages are made up of go files. Just pick the one you want.. 
You can remove the service layer. If it's only providing a pass through, you don't need it. However, having little interfaces like [UserReader.Read](https://UserReader.Read)(id) (\*User, error) makes it easier to test. Your controller, which is acting as the embodiment of your use case, can coordinate the repositories. When you test your controller, you can implement or generate implementations that behaves as you want. Something you need to keep in mind is how complex your domain is now and will become. An architecture like Clean Architecture has a lot of steps. Many think that this is over kill. When implemented, every layer is testable. The other extreme you can use a Transaction Script. This is essentially what Gentlman-Tech advocates in the start of his comment. Tightly couple everything. If you aren't going to have to meaningfully maintain the code, this isn't bad. Refactoring afterwards might be more laborious that planning for it at first, but only you know if it's worth the time. Finally, depending on what you need, you might not want to write much code at all. If you are writing a CRUD app, you might want to look at Facebook's GraphQL. [https://github.com/graphql-go/graphql](https://github.com/graphql-go/graphql). The you focus on how you organize the front end.
Don't try to suck your own dick -- you'll succeed.
Go lecture your kids
In domain driven design there are two separate ideas: repositories and services. A repository abstract, poorly for transactional behavior is different between a NoSQL and Relational DB, data interaction. Services coordinate behavior between multiple value and entity/aggregate roots. In many ways Services, in DDD, are use cases. A service might need to ask multiple repositories for entities, interrelate the entities, and return a result. You example doesn't show a DDD service. It shows the traditional 3-layer application design that allows some testability by breaking the view, the top layer, from direct knowledge of the data layer. [https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/](https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/)
Calling javascript from go is a bit of a pain in Go1.11 because everything is async. Go1.12 is switching to a [new synchronous API](https://github.com/golang/go/issues/26045) that will make everything better. Expect vecty to start picking up steam at that point.
A post about BagerHold was how I had come across BoltHold. They sound cool. 
[removed]
Try golangbot.com
Excellent book. It is extremely detailed and provides solid examples that are actually useful, not just "here's hello world in Go."
Good digging, please never do this ;)
recommend now.sh ( v1, docker)
[removed]
10:30 CET happens when this comment is 2 hours and 7 minutes old. You can find the live countdown here: https://countle.com/Q3tQajCj3 --- I'm a bot, if you want to send feedback, please comment below or send a PM.
[removed]
App Engine Standard on GCP. 
SQL? There are some embedded options, even in pure go ([https://godoc.org/modernc.org/ql](https://godoc.org/modernc.org/ql)). Otherwise you're reimplementing a partial RDBMS for structured data... 
Check this GCP link - There's an always free tier for each product. [GCP Free Tier](https://cloud.google.com/free/) &amp;#x200B;
Not OP, but just a quick question: Am i allowed to share my newbie go code here on this sub so other people can give me feedback?
It is initially, but if you have the chops you can have all that and more on EC2 for a considerable saving, especially when your storage needs are large. Obviously not really useful for OP but worth remembering! 
You can also check my blog where I recently started writing some go. https://marcofranssen.nl 
Well I am not doing any reimplementation. There are existing layers on top of a kv database that I already use. So my question was whether anyone had experience with Storm or BoltHold, as opposed to a suggestion to use another database. Although ql seems like a nice way to also get higher level mapping of struct to row in an embedded database. 
Heroku is really great!
I highly recommend this article https://medium.com/statuscode/how-i-write-go-http-services-after-seven-years-37c208122831
It's called Go, not golang
You would be better off asking this question on golang-nuts mailing list, actually. But basically when you build your program with `-race` flag it adds additional institutions which checks the memory access patterns during runtime and reports if memory access is unsyncronized. The downside is that it's 1) makes app slower - 2-100x times slower 2) it may not detect all types of races
heroku, gcp, aws?
Just because you’re ignoring these issues, doesn’t mean that they arent important - companies care about licensing a lot, and having trust issues in the projects leadership is a HUGE red flag. He has shown many times that contributions and work of other people holds absolutely zero importance to him and so he steals and hides contributions. It shouldn’t even be a debate,
I would be interested in seeing your approach.
Why are you commenting in a subreddit called Golang then?
The master has spoken https://twitter.com/rob_pike/status/886054143235719169?s=19
https://twitter.com/rob_pike/status/886054143235719169?s=19
it is actually just Go, "Go is for humans, golang is for machines", golang is just for web presence and search results but it was a childish comment regardless
I know, but pointing it out if someone asks a question is unnecessary. We all know what they are talking about.
yeah, I build same hello world wasm with C and Go. C build is small: only 44k. Go build 2.3MB.
I agree with you. But OP is not a company, but maybe it's only me who doesn't care about licenses and that stuff when I'm making a project for fun or learning. And I think you just read 2-3 posts about Iris being bad and decided that the project was bad. The guy has been very active helping people with issues and other things. And I'm not sure those "many times" he has shown that contributions hold zero importance are true, as far as I know, he rebased the commits and revert them shortly after that, and I agree that was an asshole move. But you're only seeing the bad things in a small part of the lifetime of iris.
Also the community solutions similar to code wars and such 
/r/savedyouaclick
Cool blog! I really like the donation thing at the footer, really creative 😄 Definitely bookmarked!
Thanks. Looking forward to your donation :) I also value feedback in the comments very much.
Thanks I have package my app with go modules and vendor, works great I just need to never forget the `-mod=vendor` when I build.
It's just a copy-paste from Wikipedia
I wholeheartedly agree. Document it! That should be enough.
[Unfortunate name clash](https://pypi.org/project/ctop/)
You can rationalize it however you want. I am not fine with it and it’s not under discussion for me. What you do is on you.
In addition to that: https://martinfowler.com/bliki/CQRS.html
[https://astaxie.gitbooks.io/build-web-application-with-golang/en/](https://astaxie.gitbooks.io/build-web-application-with-golang/en/) Pretty useful covers the basics of the language but also focuses on web development
The talk was very nice. Thank you /u/campoy :)
AWS free tier for a year 
Render.com?
Ich have a self Host vps by contabo. See https://contabo.com/?show=vps ITS Not Free but price and Hardware has a very good Balance. And You can Install and Host all over docker ! 
[removed]
&gt; App Engine Standard Looking at the pricing there, seems App engine will charge $30/month for a single instance 
What is meant by go compiles to web assembly? How did it compile to it before?
I used storm in a backend of a commercial web app. Read heavy with not that many writes. I really liked the andavnced query system and the possibility of writing own matchers. Never got into any problems. It was easy to filter the data in any way I needed and I heavily used the advanced query system. I can't say much about performance in huge datasets. My dataset was around 20000 entries that needed to be filtered by various fields and I didn't notice any relevant performance problems especially with caching but I also didn't run any real benchmarks. I can't really do a comparison to BoltHold as I never used it. I can just say that I really liked working with storm and also used it in various private pet projects, but I wouldn't say that storm or bold are the perfect fit for everything. It's also worth looking at other kv stores like BadgerDB depending on your use case and expectations.
Yeah in general since means including
Are you looking at the Flexible pricing or standard? Standard can be free if you configure it correctly: - use min instances of 0 - this allows scale to 0 when your application isn't being used - set a low max instances (like 2) - configure the instance type to be something like a B1 
Is there a video of this presentation up anywhere?
Not yet, but I'll post it as soon as it is (give me a couple days)
Gotta love this bit: "Changes to the language" "This page intentionally left void" xD
You're missing the animation of the gopher dissolving into the GitHub activity on the right 😄
Not a software developer but from your explanation I'm wondering about the routing. You are listening on your localhost so your app is not exposed to the outside whether on a private network nor a public one. You should have a proxy (load balancer etc) that routes the traffic to the server.
Those `go run` changes aren't listed anywhere in the tip release notes, so I hadn't realized that was coming. Finally, no more \*.go...
You can self-host with [packetriot.com](https://packetriot.com) and use PR's free plan.
It sounds like you have an issue accessing the port on that particular remote host. How are you verifying it remotely from the same host? Are you logging in and trying to curl the endpoint? Also, I would recommend to stop using `go run` here and start using `go build' (separate nitpick) 
time.Time is a concrete type from the time package. It’s basically just a struct with unexported fields. Then you assign it as normal. It’s nothing special. Often, it’s best to use an interface type instead of a concrete type, but time is pretty standard so it’s unlikely you’ll see a different implementation. However, I have seen use cases for mocking time so an interface certainly could help. 
Only 2 reasons i can think at this moment: - something already uses that port - the default route does not include the public ip I’m not sure it’s correct, too tired right now 
Yes of course my example is little simply and do not show really a domain design code but it was just to know if in golang it's good or bad practices to use a layer service or is it prefer to define methods un package relevant with the good interfaces... 
Personally i have some service with multiple repository handling but I'm thinking if the service layer is not overengineering stuff coming from classical software architecture. 
How do you write to `stdout`? It might be that your console displays `stdout` and `stderr`, but the docker and GCP shell only show the `stdout` output, without `stderr`
Great pres, Maartje and Francesc! On the TLS 1.3 slide, why set MaxVersion ? Does it mean by default MaxVersion is TLS 1.2 ? That's not what the doc says on https://tip.golang.org/pkg/crypto/tls/#Config which makes me wonder if you didn't mean to write MinVersion.
You could setup an internal godoc server. Have bitbucket trigger the godoc server to update the library on push. I don’t have a specific direction on that, but it’s a direction you can look in. 
This talk includes go1.11 and go1.12 did you check both release notes?
Oh, that sounds like we mixed it up! Let me check and update the slides if needed
[removed]
Oh jeeze, you're right, that happened in 1.11...
Run that same godoc command for them? That's what golang.org does.
It's not complicated at all. You can use JFrog Artifactory or Athens to do that. But GoCenter is not about that. It's not a private repo. GoCenter is a central public collection for immutable Go modules. It is for the community to use, you can point Artifactory and Athens at GoCenter as their own remote proxy.
I'll keep updating this as I come up with comments: (a) Great job. Keep up the good work. (b) You don't have to cat `scanner.Text()` to `[]rune{}` in that `range`. This is done implicity when you range over strings. That could be simply: for _, r := range scanner.Text() { // ... }
There is some confusion about what GoCenter is in this thread, so let me try to clarify. 1. GoCenter is a central public collection for immutable Go modules, and at the moment it is the only public repository service that exists. It is not a private repo, like Athens or JFrog Artifactory. 1. It is for the community to use, and you can point Artifactory and Athens at GoCenter as their own remote proxy. In fact, the latest Artifactory version already comes with GoCenter as an upstream, and we hope Athens will do the same soon. 1. GoCenter allows you to search for modules and versions, also you can easily add your own modules to it to be shared publicly. 1. GoCenter hosts modules complete with their full dependency graph, where possible. It's different from other solutions (like generating empty `go.mod` files), and we believe it's the right thing to do. It preserves the author intent and makes Go modules much more usable. 1. GitHub does not provide complete immutability since git history can be rewritten. Also, the performance of retrieving modules from GitHub is, let's say, sub-optimal. `git clone` of multiple source files is painfully slow and can't be compared with HTTP GET on a single archive file. 1. Some links for more info: * [GoCenter](https://gocenter.io) * [FAQ on "but... why", "it wasn't first", "how it's different from Athens", "everything works just fine without it", and many other legit questions](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions)
What is the correct way to have a godoc instance provide docs for imported libs that are not in GOPATH? Can docs be pulled from module cache?
Tbh I don't know, but I'm assuming that eventually godoc will be module aware and show only those packages that are dependencies of the current module
[removed]
[removed]
RemindMe! 3 days "The state of go video might be up, check!"
I will be messaging you on [**2019-02-05 21:12:22 UTC**](http://www.wolframalpha.com/input/?i=2019-02-05 21:12:22 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/amd6rr/the_state_of_go_feb_2019/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/amd6rr/the_state_of_go_feb_2019/]%0A%0ARemindMe! 3 days ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
[removed]
Is it just me, or your comment is all messed up? https://i.imgur.com/IA50pOv.png
Thank you very much for your feed back ! It really makes me want to improve myself ! Gonna look into those advices right now. 
it looks good to me but some people have complained that my markdown doesn't render correctly on their end. i think it is a reddit bug.
Ah, I missed that bit. That's great! 
Also consider the possibility that if you are trying to run on a Linux box you often have to be root to bind to ports below 1024. Or you can setup a new user and use set\_cap to give it capabilities to bind to those lower ports.
It's not any different than any other field. It's got a name (BornAt) and a type (time.Time) and that's all. &amp;#x200B; You may not realize it yet, but that \`string\` type you are comfortable with is itself a 2-element struct.
It didn't before
What a fantastic read, thank you for sharing. 
Just write your help text appropriately, and use an if statement to check that the value is valid, then exit with an error if not?
If I understand you correctly, that doesn't need reflection: &amp;#x200B; `func isSlice(obj interface{}) bool {` `_, result := obj.([]rune)` 
[https://play.golang.org/p/5a3gZ8Sxu9i](https://play.golang.org/p/5a3gZ8Sxu9i)
I've just bought a Rapberry Pi 3b+ and it works well for testing. I never switch it off.
http://xyproblem.info/
type T []rune var t T println(isSlice(t)) // false
yes, try `log.SetOutput(os.Stdout)`, the default of log output is stderr.
https://play.golang.org/p/g5yjuyhP9TU A `rune` is just `int32`. And `[]int32("hello")` does not look so obvious XD.
Here is a little bit of power of reflection. https://play.golang.org/p/E9vEFXExTnd
https://play.golang.org/p/ICdIeYF61le Just convert to `[]rune` all possible.
RemindMe! 3 days "The state of go video might be up, check!"
You could have the channel receive a struct that contains a string and an error. Then when iterating over the channel you can check if the struct's err is nil or not. 
This report is so full of misinformation. It's as if they took skills from their site and associated salaries to it after they matched people. Snagit skill nets you $100,305 avg salary. I get that it's a combination of skills that make up your salary, but I can't take them seriously when they think knowing snagit helps you get a job. Directional at best. 
My solution as well. Send a struct down with an err and value. Sometimes it’s nice to pre-parse some or all of the data too before it’s sent into a central processor. 
\`new(Foo)\` is of type \`\*Foo\` \`Foo{}\` is of type \`Foo\` this is the difference btw, \`new(Foo)\` is equivalent to \`&amp;Foo{}\`
If you change the unmarshal call in the first one to just `json.Unmarshall(bytes, v)` (not passing in a pointer to v, just v itself) then it should work. This is because `json.Unmarshal` takes in an `interface{}` there, so by passing just `v` you're actually passing the `*Foo` or `*Bar` directly, but if you pass `&amp;v` then `json.Unmarshal` is getting a `*interface{}` (which happens to contain `*Foo`/`*Bar`). Hope that helps and makes sense!
I felt the same way but as you wrap your head around how interfaces work, and your eyes learn to ignore all the error checking lien it will all start to make sense 
I think it depends on a person's previous exposure to programing concepts. For myself, I had been developing in python for a long time, when I first started learning Go. I found it quite easy to read and learn. But I had also had some minor exposure to C++ at that time. In your case, it may be a mixture of only having one year of previous experience and in dynamic languages like JS and Ruby. If you haven't had to deal with strict types and pointers, and concurrency, you may be mixing that aspect into your experience learning Go. It is possible you may have found similar concepts unintuitive in other statically typed languages as well. 
Same
Never start a goroutine without knowing how it will close. This is a permanent memory leak. 
I understand. However in this case, I think it is fine. I am reading from the output of a kubectl command that follows the logs outpout. If the I am no longer able to read. Say because of an EOF error, (i've decided to simply log it to stderr, Its not that vital to my app in the end), then I close the reader and the channel, and exit. So i don't see any goroutines being leaked here. Unless there is something I am not seeing. The goroutine will close once I can no longer read anymore.
Your answer hit me like a ton of bricks. I was so concentrated making sure I was getting my concurrency right (as i said i am not as practised as I would like to be) that such a simple solution went right over my head. &amp;#x200B; Thanks a ton. &amp;#x200B; (In the end I just log to stderr, since as I realised later I don't want to exit the app as it turns out so its fine. Thanks again.)
Thanks, It makes way more sense that way than to have a channel for each type of data you want to send back. Hardcore blindspot moment for me on my end. Thanks for the help.
I know there's a 😢 emoji next to "TLS 1.3: 0-RTT not supported" but that's a good thing (0-RTT has always been a bit overrated IMO, only a very few of connections would likely benefit anyway, even if it didn't have the serious security risks which, without *very* careful handling, are quite potent -- and one of the main purposes of TLS 1.3 is to simplify the protocol, reducing error and attack surfaces, so it's really a win IMO).
It is because you only have experience in a dynamic typed higher level language. I took a class on C++ in college and have been reading/learning C as a foundation so the concepts were all very similar when I got bored one weekend and wanted to try Go. I plan to eventually learn Go once I feel comfortable with C. I think if you would spend some time learning C first since everything is abstracted from C you would understand why things are done better and also allow you to learn Go easier. Right now you are comparing apples(JS) to oranges(Go). 
I think JavaScript’s `const` is not worth taking positive inspiration from. I see other developers acting like it makes values immutable (it doesn’t; it just prevents rebinding the name) and being surprised when the values mutate anyway. On top of that, it seems pointless as a helper for development. I never wonder whether a name will rebind or not and don’t find that to be helpful in thinking about code. It might provide a JavaScript JIT with help compiling, but for a precompiled language like Go, there is already an analysis done by the SSA. Anyway, I stopped using anything but `let` in my JS because wasting time thinking about if a name was const provides no dev ROI.
An intro to Programming and Go |PDF [https://www.golang-book.com/books/intro](https://www.golang-book.com/books/intro) The Way to Go | PDF [https://files-cdn.cnblogs.com/files/rojas/thewaytogo.pdf](https://files-cdn.cnblogs.com/files/rojas/thewaytogo.pdf) The Little Go Book | PDF [https://www.openmymind.net/assets/go/go.pdf](https://www.openmymind.net/assets/go/go.pdf) Effective Go [https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html) A Tour of Go [https://tour.golang.org/list](https://tour.golang.org/list) Go By Example [https://gobyexample.com/](https://gobyexample.com/)
The only thing I don't like about go is errors. Exceptions that have a specific type are much easier to work with. For example, using a simple `http.Get()` can create errors of many different kinds and trying to handle each error differently quickly becomes a nightmare.
This proposal suggests two immutable concepts actually: **self\_modifiable** and **ref\_modifiable**. **self\_modifiable** is good to declare package-level values, such as immutable error values. **ref\_modifiable** is good to declare immutable parameters.
No godoc isn't module-aware yet. Tracking issue - https://github.com/golang/go/issues/26827 And a workaround - https://github.com/golang/go/issues/26827#issuecomment-451476369
The problem is you're wrapping Foo in a double interface. In the second example you're passing Unmarshal an interfac containing a pointer to Foo. Unmarshal then tries to unmarshal into the Foo. In the first example you're passing Unmarshal an interface containing a pointer to an interfact containing a pointer to Foo. Unmarshal then tries to unmarshal into the second interface. Unmarshal determines how to unmarshal depending on the type it's unmarshalling into. For interfaces it uses the default value. https://godoc.org/encoding/json#Unmarshal &gt; To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value: &gt; &gt; bool, for JSON booleans &gt; float64, for JSON numbers &gt; string, for JSON strings &gt; []interface{}, for JSON arrays &gt; map[string]interface{}, for JSON objects &gt; nil for JSON null If you change this in the first example it should work. json.Unmarshall(bytes, v) 
The &amp; is related to the pointers. Read Golang pointer
I've simplified your example a bit more. [https://play.golang.org/p/shjjrDltNt0](https://play.golang.org/p/shjjrDltNt0) So your confusion seems to be around the new keyword. It returns a pointer and you really just want to return I believe this is the decode function you are trying to write ``` func decode() interface{} { var v interface{} switch XXX { case A: v = Foo{} case B: v = Bar{} // etc } json.Unmarshall(bytes, &amp;v) return v } ``` You can put ANY type into an interface{} variable, not just pointers. I'm not sure if you thought you had to assign pointers to the interface{} variable, or if you simply didn't realize that `new()` makes pointers, but either way, that's your problem.
Ha. I understand pointers, it's more subtle than that. Look at it. (I've been a C/C++ programmer for 20+ years, trust me. Read the code.)
This decodes to a map -- not the type.
I must have misunderstood this library. I expected a flexible library, where a user could enter any string in any order, and the program could pick any key &amp; value from it. Now this is so tightly coupled, that it will break if a user does something wrong.
Nope. Still returns &amp;{}. See: var dst interface{} switch msg.Tag { case RESPONSE: dst = new(Response) /* var dst Response if err := json.Unmarshal(msg.Message, &amp;dst); err != nil { return nil, UnknownCommand } return dst, nil */ case LOGIN: var dst Login if err := json.Unmarshal(msg.Message, &amp;dst); err != nil { return nil, UnknownCommand } return dst, nil } json.Unmarshal(msg.Message, dst) yields: tcp_server_test.go:64: Expected ({true }), received (&amp;{true }) 
Nope. See above comment, under MediocreGopher.
The webpage: https://endophage.com/post/golang-parse-to-interface/ solves it in the same clunky way. 
Are you really sure that it doesn’t support something better? ECB is a massively bad idea. Anything with chaining is better. I would hope that their API just uses TLS/SSL. Try doing a tcpdump/wireshark and check the handshake to see what’s going on. 
Aaaah! I see the problem now. You can use the reflect package to "solve" this problem. https://play.golang.org/p/ahFuYoCnkk6 That said, if you have to use reflect like this, it's usually a sign that you're already doing something wrong. IDK exactly what you're trying to do here, but in code like this, the callers usually want/need the actual type information, so IDK how useful this is in practice. They're going to have to cast output of this function to a concrete type in order to use it anyway, and in order to do that, they need to know in advance what the concrete type will be before they call the function. You're usually better off letting them instantiate the type they need and pass it into your decode function (just like how json.Unmarshal works) instead of creating it for them inside your decode function.
Interfaces are internally implemented using pointers instead of values so it's unnecessary to use pointers to them in your code segments. Also in your test case, new(Foo) instantiates a struct and returns a pointer to it, whereas Foo{} returns a value.
May be you understand pointers, but do you understand interfaces? (1) ```go var f Foo json.Unmarshal(p, &amp;f) ``` In this case json.Unmarshal has got interface consist of pointer to the f and *Foo type reference. (2) ```go var ( f Foo face = interface{}(&amp;f) ) json.Unmarshal(p, face) ``` is the same. But (3) ```go var ( f Foo face = interface{}(&amp;f) ) json.Unmarshal(p, &amp;face) ``` in this case the Unmarshal has got interface consist of pointer to the interface and `interface{}` type reference. Other words: ``` 1 and 2 case -&gt; interface{ &amp;f, *Foo } 3 case -&gt; interface{ &amp;interface{ &amp;f, *Foo }, interface{} } ``` Other words a `func x(arg interface{})` converts a passed argument to interface{} type. 
https://play.golang.org/p/hNJ4DzS86xf
That's just a bug in your test.
And for bonus points, an alternate solution that doesn't require the reflect package. https://play.golang.org/p/KFLbnPNHpBX
This! Interface is already a pointer. 
See https://stackoverflow.com/a/37244844
Is `new` idiomatic? I started learning Go last year and rarely ever see it. 
For a `interface{}' type you can assign as well pointer (or interfaces, which in go are passed as pointers) or value types. In your code you are using `dst = new (Response)` which creates new instance and returns a pointer (new returns pointer). That's why you are getting pointer not a value. Change this to `dst=Response {}` for a value type.
It's super easy to implement middleware just by wrapping your handlefuncs. Try this article for an example: https://hackernoon.com/simple-http-middleware-with-go-79a4ad62889b
Don't you have to handle Exceptions differently as well? Is it that most exception based languages have inheritance with exceptions that allow a level of classification? Or is it just the syntax for type asserting certain errors and the knowledge of what can be returned as an error?
most of the time i see and use &amp;Foo{}. 
For most types, you generally just do `&amp;Foo{}` to create a pointer to a new zeroed value. But for built-in types like `int`, that syntax is not possible. So `new(int)` is the idiomatic way to get a pointer to something of a basic type. Whether you use it for zero-valued complex types depends on your style. I tend to prefer braces because the diff when adding an initializer list is smaller.
+1 Simply pass v to Unmarshal, not &amp;v which amounts to **Foo.
update: the v6 version is released. Much less rule exceptions now.
Added some more functionality: [https://github.com/thedevsaddam/gojsonq/wiki/How-to-use-YAML,-XML,-CSV%3F](https://github.com/thedevsaddam/gojsonq/wiki/How-to-use-YAML,-XML,-CSV%3F)
The main problem is that `interface{}(Foo{})` is not addressable, so there is no way for `json.Unmarshal` to modify that. Otherwise, `v = Foo{}` would have been an alternative. The second problem is that there is no syntax to dereference a `interface{}`, and pointers to interfaces aren't allowed either. You might want to just resort to reflection, if return type is important: https://play.golang.org/p/5gVbp3dv16E I don't see why you need it to be a literal, though.
AWS Elastic Beanstalk with a free tier EC2 VM If it's just for a temporary demonstration, you could also just use [https://ngrok.com/](https://ngrok.com/) and send people the link (it proxies to your local computer).
I think the added complexity does not outweigh the problems you want to solve. I personally never have bugs that are caused by variables that shouldn't be modified. I do wonder how many people do have this problem though.
&gt;if unicode.IsDigit(r) == false { This is a switch on a boolean that was yielded by a comparison of a boolean with another boolean. :)
&gt; What is repository? What is service? What is even mean? Seems pretty straightforward. It is just your bog standard three layer separation of concerns that you find just about everywhere, under various names. In other communities you might know it as MVC, for example. Although many will argue that the term MVC carries more nuance and is not appropriate terminology for the type of application we are talking about, hence why there has been an effort to stay away from that nomenclature. &gt; If I grab something from external grpc -- it's repository or not? Yes, data fetching is a repository concern. The protocol is irrelevant. &gt; Maybe it service? Why would it be a service? 
Redesigned version of reddit seems to support \`\`\` for code formatting where as older version doesn't. &amp;#x200B;
What parts in the proposal do you think they are too complex? &amp;#x200B; \&gt; I personally never have bugs that are caused by variables that shouldn't be modified. &amp;#x200B; There are many levels of securities. At one level, one malware 3rd party package may modify the package-level variables in std packages. &amp;#x200B; And the other problem this proposal tries to solve is security unrelated. It is performance related. By specifying some parameters as immutable, compilers can optimize the code much more.
`new` is older but still idiomatic-ish. Literals like `Foo{}` were added later. Most people—myself included—prefer the latter.
If this is a simple script as you seem to describe it, I would just log the channel's content and panic the error
Doesn't sound like they have a choice. The device OP is attempting to communicate already uses AES-ECB.
what would you have done? :) maybe: ``` if !unicode.IsDigit(r) { ```
[https://www.youtube.com/watch?v=SQeAKSJH4vw](https://www.youtube.com/watch?v=SQeAKSJH4vw)
There's no proper ReadMe
exactly
The markdown you're using only works on the new reddit design.
Yah I saw that one. If I'm reading it correctly that's to decrypt an already ciphered text. I need to actually cipher a payload with a key, net.dial write payload &amp; read response then decrypt response. I've been trying to reverse engineer the decrypt function I to an encrypt in that stackexchange but am stuck. Unless I'm completely misreading what that example function does...
The device is a cheap WiFi enabled light socket, yes it uses TLS. I have a rooted Android device with their app and packet capture, it's how I got device ID and key by sniffing the traffic.
ya -- i made this choice. i thought, at the time at least, that comparing with false was more readable.
It's more complicated than that. The error is not so big a deal. But I am going to follow more than one log and then merge their output together, so I return a channel to the caller, the caller has many channels and merges them and then redirects the merged channel to output. 
Using python as an example, since I'm most familiar with it. try: requests.get("notaurl") except NewConnectionError: # do something if the connection was explicitly rejected except TimeoutError: # do something else if the connection timed out, eg try it again Since errors in Go are more or less containers around strings it makes it much more difficult to handle different kinds of errors coming from the same function call.
What do you consider a proper readme?
What, why, how. That'd be the base. Then there's how to compile and run, and you already have this one. And ambitious projects like this one need to explain the implications of the project. Okay, it's RayTracing in Go… does it use Nvidia's RTX? Can you make an engine with that? Is this just a proof of concept or a library? How useful it is on its own, and in a context? 
Here are answers (mostly straight from the readme): **What?** &gt; This is a chapter-by-chapter progression through the excellent free ray-tracing books by Peter Shirley. **Why?** Because I'm interested in ray tracing, I like Go, and someone has already written an excellent ray tracing series in C++. **How?** &gt; There are tags at each chapter and commits at each checkpoint within chapters. **does it use Nvidia's RTX?** &gt; Package trace renders 3D scenes into 2D images by CPU ray-tracing. **Can you make an engine with that?** I'm not sure what this question means. This is already a ray-tracing engine. **Is this just a proof of concept or a library? How useful it is on its own, and in a context?** &gt; This is a chapter-by-chapter progression through the excellent free ray-tracing books by Peter Shirley.
Thanks!
This is my try to create a redis mocking library (and not a clone) I have several problem with real clones like miniredis and sider. I need a mock for test, If I want redis in my test, I prefer redis itself (with docker it's not that hard) The idea is to expect the commands and control the output, like real mock. but I don't like the api as it is right now. any suggestion?
&gt; ...but for a precompiled language like Go, there is already an analysis done by the SSA. That was my initial thought. For interpreted languages like Javascript there might be a benefit but for compiled languages, I guess I'm missing the point.
Thank you for the explanations also don't forget to mention or put it in more details in the readme.
You might find this useful: https://github.com/ribice/gorsk
Those are copy -&gt; pasted from the readme. Am I seeing a different readme from folks or something?
oh okay normally it only shows the commands to clone and build it and stuff. But yeah will take a look into it
Why "Pull R." above all other options?
You can break it out however you want. There’s no standard way. I know a lot of people dislike breaking things down too heavily, while others like splitting it like crazy. It’s personal taste really. 
I believe it recently changed, but you were able to sed the godoc HTML to stdout instead of running an http server; you can pipe that to a file, and then serve those files?
You can by naming it "internal". This will also make all of it's children private. Sibling and parent packages may still import from internal.
[removed]
See also https://github.com/jimmyfrasche/txt
[removed]
[removed]
We're about 25% through our fleet2kubes migration running (after many iterations!): * Kubernetes v1.13.2 * CentOS Linux 7 (Core) * Kernel 4.19.12-1.el7.elrepo.x86\_64 * docker://18.9.1 * MetalLB and Calico BGP + F5 BIG-IP Controller
&gt;Seems pretty straightforward. No, it's not. It's "straightforward" for you, because you get used to do things in that way. &gt;In other communities you might know it as MVC, for example. MVC is not a good thing. It's means nothing in 2019. What Models in this scheme? Domain + Repository + Service? It's whole application. And Controller grpc or http handlers? And view? Oh, no, please. It's really confusing and doesn't explain anything to people who not get used to do things in this way. I has been doing this for years in my past web-development and it really mess with no rules and best practices. &gt;Yes, data fetching is a repository concern. The protocol is irrelevant. Good. And you have Unit of Work in one repository and you doing external api as repository and... oops. Leave a comment that only this and that repository not support UoW because it's not repository, it's adapter to external api and... Someone really think it's not confusing? &gt;Why would it be a service? Because entity-repository-service pattern (not MVC though) doesn't make any sense to developers who not used to it. It's a mess. Don't do a mess. Do great code, solve usecases, write tests and be cool. I says it again -- in article one of usecases is PostAccount. It's nonsense, it doesn't make sense. Try say to someone: "hey, I have a some service, could you try to post your account to it?". I really doubt that someone really understand what you want. Code must solves usecases. Register user? Yeah, good. LET'S DO SOME REPOSITORY WITH SOME SERVICE is not usecase. And when someone trying to write code, he must solves usecases, not write something that make sense only for some people that doing things in this way for unknown reason (some java frameworks do this is not excuse). &amp;#x200B;
Go doesn't offer any ECB encrypters because ECB is really "no chaining mode". Although there are no methods provided for you, you can manual implement it by encrypting over the data on a block by block basis. The block size for AES is 16 bytes. I've implemented a crypto library in go which offers AES-ECB if needed.
I looked through the source, and I really like the way it's written and structured. It inspires me and makes me want to write my own ray tracer in Go.
&gt; I do wonder how many people do have this problem though. You'd be surprised
Thanks! I'm pretty happy with its structure and readability now too. You should write a ray tracer - it's simpler than I expected and immediately rewarding when you see something on the screen. Redditors seem really confused by the readme, which is throwing me for a loop because I don't know what to add or remove to make that part more accessible.
I'd probably use a nodejs backend just to prevent unnecessary context switching between languages. Since it's also a local server with basically one user, youre not really capturing the benefit of golang, since your server will never be anywhere close to saturated, and async code will always be somewhat synchronous anyway since there is only one client. But if your goal is to learn golang, then by all means use it. I'd also say tryout grpc instead of REST to get some experience with it as well. JavaScript clients exist, so why not? I'm currently writing a very large rest/grpc API and I am enjoying it for the most part. As far as antivirus goes, your sorta at the mercy of the configuration. I assume your program will be installed by an admin, so they should be able to make the necessary policy changes to get it working.
Here's my try at it going for efficiency. Can get bytes from scanner then if writing to a file directly use bytes returned, or easily convert to string if needed. [See at Go Playground](https://play.golang.org/p/OiDX7JUlPjo) 
Some subjects have no merit of debate &gt; Women and Men have different roles, so anyone discussing their differences should not be trusted? what kind of backwards savage thinks like that. Are you brain damaged? Literally a subject that is not for debate, along with racial differences. There is nothing good that could come of it, and it's such a complex area that no amount of study will be able to cut out bias and ensure the study or debate is fair and honest. Also debate is cheap, weak and facile. It's useless. Far better is peer-review by a panel of experts in the subject you speak on. Please seek out and work on educating yourself
You could look into Buffalo, which is a Railsy type Golang framework for web stuff. You could also just do it as it makes sense to you. I've seen projects with a \`controllers\` or \`handlers\` package, and then projects that use something like a \`user\` package, that is supposed to contain each piece of the user domain, things like Controllers, Routes, Services, etc. Ultimate you should do what makes sense to you, just try to keep in mind it should be relatively simple and intuitive - try not to mix impls.
I’d like to brush up on my linear algebra first. I haven’t done any math in a long time! :)
Quoting the [Go docs](https://golang.org/pkg/net/http/#Server): &gt; ErrorLog specifies an optional logger for errors accepting &gt; connections, unexpected behavior from handlers, and &gt; underlying FileSystem errors. &gt; If nil, logging is done via the log package's standard logger. TL;DR: The function is used to log errors that happen while servicing requests. The errors returned from ListenAndServer are typically issues with the listening network socket or some other fatal problem.
give lorca (from the same author as webview) a shot. It can use the pre-installed chromium/chrome v70+ browser
What's wrong with redigomock?
Its depend on the library. I need to cover go-redis too. If you are talking about this one https://github.com/rafaeljusto/redigomock My library aim is to create a client-agnostic mock. 
nice! so why is this version faster?
This post inspired us to use the standard Go http library for our API server. This actually decreased lines of code dramatically in the project. [https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html) I've structured it so that each root path is in its own sub-package. For example for /users?query=x the code is in a users package.
allocations kill mine. if i add: ``` b.Grow(14) ``` i think mine becomes on par with/maybe faster than yours.
That makes sense. Thank you. 
You could read the RFC and grab some test vectors online to ensure the implementation is correct. That’s what I’d do at least.
Interesting. Similar to my project: https://github.com/tmornini/http-spec 
I firmly believe MVC is exactly the wrong architecture for HTTP endpoints, and that your initial plan is the better way to go. 
[removed]
You seriously asked reddit before you read the docs? Please...
So basically you'd end up with a small key/key/value system, and you'd have to somehow distribute the BadgerDB database for it to be useful elsewhere
And black hole is already a concept in web security, it's an end point that your `robots.txt` will explicitly deny so if malicious agents were to find it, you block their IP
Is this still maintained?
&gt; No, it's not. It's "straightforward" for you, because you get used to do things in that way. What is not straightforward about separating interface, business logic, and data access? I guess you can write a big ball of PHP spaghetti with your MySQL calls intertwined with your HTML, as many have done before, but there is a reason why basically every advocates dividing your code along those aforementioned lines. &gt; MVC is not a good thing. It's means nothing in 2019. Seems contradictory. I agree that, like I said before, the Smalltalk usage of MVC has been watered down, which is why there has been an effort to not use the terminology in this context as other communities have done. &gt; What Models in this scheme? Domain + Repository + Service? It's whole application. The data access layer is usable by many different domains. The domains are reusable by many different interfaces. It is not just one application. The whole point of having these separation of concerns is so you don't end up with just one application; tests being a primary example of a secondary application. But we can take that further, where you might want to have a gRPC, REST, and command line interface to your domain. If your business logic is intertwined with your gRPC handlers, you're euchred when you want to change the interface. &gt; And you have Unit of Work in one repository and you doing external api as repository I don't understand. If you have a `Find(id ID)` method in your repository, what difference does it make what lies underneath? In fact, the whole point is to not concern yourself with what is underneath. It could be a gRPC service, a Postgres database, or even a file on the filesystem. It might be all of these things. It might change through the course of development. The last bit is of particular importance as this is why we divide on this line. Maybe you start with a file on the filesystem, then requirements change and you need to use Postgres. The rest of the application couldn't care less. Contrast that with our PHP example at the start of this comment and you'll soon see why it is useful to have this separation of concern. Have fun chasing down all of your file access calls across every HTML page. &gt; Don't do a mess. Do great code Seems pretty hand-wavy. Nobody wants to create a mess or write bad code. Having a logical separation of concerns is paramount to not creating a mess and writing great code. It is essential to write meaningful tests. The entire premise of TDD is to ensure that you force yourself to have a separation of concerns. What divisions of concerns works better in your opinion if not the three that are being advocated for here? &gt; article one of usecases is PostAccount. It's nonsense That doesn't sound like good code. Do not confuse design patterns with bad code.
I've had good success with https://github.com/alicebob/miniredis for unit tests, spawning https://godoc.org/github.com/daaku/go.redis/redistest for integration tests.
I've been happy with gomplate
This is great, thanks for sharing! I love the `go run` improvements. No longer have to glob all the files in `./cmd/foobar`. And now we can have [one-liner quick-starts](https://github.com/hunterloftis/oneweekend#one-liner). wasm progress is interesting too.
[removed]
Cobra uses the pflags library, so arrays of arguments are supported out of the box, see [https://github.com/spf13/cobra/issues/661](https://github.com/spf13/cobra/issues/661) for a bit of guidance here -- simply specify the args as a StringSlice and you can provide multiple values. As for enumerated strings, the only way is a switch or if statement to go from String -&gt; Enum. As an aside, if you only need to go from Enum -&gt; String (e.g. because all of the enum values are created within your program logic), then this is a nice pattern: [**https://programming.guide/go/define-enumeration-string.html**](https://programming.guide/go/define-enumeration-string.html)
&gt; Which one is better for growing rest api application architecture ? This is a question about the future. Question regarding the past are hard to answer and question about the future almost impossible. Do what you find suitable. If in doubt: experiment (keeping a laboratory journal!).
Unsure why you're getting down voted for a constructive conversation. I just had a quick look at the `http.Get` source code. Try this on for size: ``` type ErrorTimeout interface { error Timeout() bool } type ErrorTemporary interface { error Temporary() bool } r, err := http.Get("http://validurl.com") switch err.(type) { case ErrorTimeout: // do something else if the connection timed out, eg try it again case ErrorTemporary: // do something if the error is transient } ```
&gt;What is not straightforward about separating interface, business logic, and data access? Nothing. But a friendly reminder: in this thread we are talking about specific article that tells you to ignore Effective Go, create some folders, copy-paste data access to business logic and that's it. Your app is ready and someone even post it here. &gt;I guess you can write a big ball of PHP spaghetti... But code in article above IS new level of spagetti code. It's tell you to copy-paste everything here and there only for having magic three folders. They supposed to cure your code and give LAYERS, but instead it's just gives you same blocks of code. And yes, idea is good, but implementation is horrendous. &gt;The whole point of having these separation of concerns is so you don't end up with just one application Yeah. It's all good, but some developers really confused about all of this. Like the author of an article above. He is create interfaces for creating interfaces, copy-paste it all over the place and tells you how it reusable. It's not reusable, it's garbage. We still talking about one specific article that topic starter recommends as good architecture reference. Anyway, I tell same thing earlier: &gt;Start from domain entities and business logic, connect it to infrastructure with interface adapters and have really chill life and good code. &amp;#x200B; &gt;I don't understand. If you have a Find(id ID) method in your repository, what difference does it make what lies underneath? It's not about underneath, it's about following same patterns and interfaces. Repository is not just a folder, it's pattern with some another patterns to work with it. If you have a big application you will need to apply Criteria pattern or already mentioned Unit of Work at least. But most of them works well with databases, not api clients. And you will need to break interfaces. Good way of avoiding it is interface adapters, where you separate accessing by implementation. It's really straightforward and tells you what features you can expect. It really big topic for discussions and we still talking about one specific article above. &gt;Seems pretty hand-wavy. Yes and no in the same time. &gt;Nobody wants to create a mess or write bad code. But somebody just doesn't care. Like an author above. Avoiding Effective Go recommendations and base principles like DRY, throwing stuff to some folders and call it architecture. &gt;What divisions of concerns works better in your opinion if not the three that are being advocated for here? I write it earlier and quoted in this post. This topic is not against mythical MVC and folders with names repository-service-domain. it's about specific article. And there is no separation by logic, there is some folders with specific names and files with same interfaces for absolutely no reason. &gt;Do not confuse design patterns with bad code. But we are talking about specific article with bad code.
Ooh, nice! Lemme try &gt; _'20 nodejs frameworks written in cursive that every nuns needs to advocate'_
The linked “magic numbers” Wikipedia page is interesting. This one takes the cake though: &gt; Executables for the Game Boy and Game Boy Advance handheld video game systems have a 48-byte or 156-byte magic number, respectively, at a fixed spot in the header. This magic number encodes a bitmap of the Nintendo logo. 
of course
I'm equally shocked you think that way. 
If you're including malware packages, you're already screwed. No proposal is going to save you. The compiler already optimizes constants. &gt;BTW, the proposal is very easy to implement. The added complexities are small by my own opinion. &gt;I have not much compiler-related knowledge 
I've used [Astilectron](https://github.com/asticode/go-astilectron) for this. It comes with a nice [bundler](https://github.com/asticode/go-astilectron-bundler) for creating cross platform binaries.
This is a very simple tool, but I didn't find any existing implementations so I wrote a quick one myself. My use case is just writing HTML template files and not wanting to distribute extra files at runtime. I also don't want to write HTML directly in Go strings since most editors don't know how to provide HTML editing features in that context. Solution: write a go generate tool that can shove these files into consts. You can also use these for binary files if you want. The generated source code is going to be horribly inefficient (~4 bytes to store 1 byte) but once compiled, the data shouldn't take up additional space.
As I have mentioned, there are many levels of securities. It is not always practical for for the developers of every Go program to check every line of code in all dependency packages. Sometimes, there are millions of lines of dependency code. Now, in an `io.Writer.Write([]byte(aString))` call, the underlying bytes of the `aString` argument will be duplicated. However, it is totally unnecessary. If we can change the parameter type of `Write` method to an immutable `[]byte` type, then we can avoid duplicating the underlying bytes of the `aString` argument. There are many such cases.
Needs "modern" and "simple" to complete the buzzword bingo.
The list of matched types is pretty small, in particular compared to ‘file’
The phrase "blazing fast" always makes me think of a stoned dude doing dishes as fast as he can.
Couldn't you easily optimize to use alphanumeric characters even if the input is binary?
P.S. thanks a lot, it's definitely useful!
&gt;Now this is so tightly coupled, that it will break if a user does something wrong. &amp;#x200B; I'm not sure to completely understand your point but that's one of the killer feature! It allows to detect errors early and not spend too much time debugging unrelated parts. &amp;#x200B;
Cool, good work. I hope you learned something. I’m all for re-inventing the wheel for the sake of learning or other practical reasons, but surely you didn’t search very hard to find existing solutions out there... There are plenty of generators to embed static assets in a Go binary. For example, [vfsgen](https://github.com/shurcooL/vfsgen), which also lists [alternatives](https://github.com/shurcooL/vfsgen/blob/master/README.md#Alternatives) in its README. Here’s a [blog post](https://tech.townsourced.com/post/embedding-static-files-in-go/) comparing many of them. Does your generator offer some unstated compelling reason to use it over all the other options in this space?
Cool, good work. I hope you learned something. I’m all for re-inventing the wheel for the sake of learning or other practical reasons, but surely you didn’t search very hard to find existing solutions out there... There are plenty of generators to embed static assets in a Go binary. For example, [vfsgen](https://github.com/shurcooL/vfsgen), which also lists [alternatives](https://github.com/shurcooL/vfsgen/blob/master/README.md#Alternatives) in its README. Here’s a [blog post](https://tech.townsourced.com/post/embedding-static-files-in-go/) comparing many of them. Does your generator offer some unstated compelling reason to use it over all the other options in this space?
That emoji came from Maartje, to be honest i have no opinion (nor much knowledge) about TLS 1.3 haha
IIRC this was used as a protection against piracy: the console used that to display the logo on the screen, and wouldn't start the game if this wasn't the correct one. So this "magic number" *had* to be part of the cartridge. But if it was included for an "unlicensed" game or cartridge, then Nintendo could sue for unauthorized use of its logo... 
with [burntsushi/toml](https://godoc.org/github.com/BurntSushi/toml) decode / unmarshal into a `map[string]interface{}` then you figure out its proper structure / type and decode into that
If you truly have no knowledge of keys at compile time then you'll be wanting to represent your data in a `map[string]interface{}` and implement a custom `UnmarshalTOML` method. In this case the library has already done the parsing into a map! Checkout the UnmarshalTOML example in the docs: https://godoc.org/github.com/BurntSushi/toml#ex-package--UnmarshalTOML
&gt; Currently I am developing a GUI application for Windows. This is a use case where Go is not the proper solution. If you're not interested in multiplatform support, use the full .NET stack, it's simply easier (you can use WinForms or WPF for your GUI and you can write a Windows service in the same solution).
I would avoid MVC in go at all costs, most importantly avoid models the most, you'll end up in cyclic dependency hell. Push the functionality you would normally put in a model into the service layer.
[removed]
 * when i talk about interfaces, it should sort of make sense when you say the interface name and one of it's methods. Like, "`Writers` `Write`", "`Readers` `Read`", "`Listers` `List()`". 
You can probably do it yourself. Check this link for a rough implementation [https://github.com/golang/go/issues/5597](https://github.com/golang/go/issues/5597) &amp;#x200B; `bs := block.BlockSize()` `if len(plaintext) % bs != 0 {` `panic("Need a multiple of the blocksize")` `}` `ciphertext := make([]byte, len(plaintext))` `for len(plaintext) &gt; 0 {` `block.Encrypt(ciphertext, plaintext)` `plaintext = plaintext[bs:]` `ciphertext = ciphertext[bs:]` `}` &amp;#x200B; &amp;#x200B;
Your issue will be the workerQueue as it's a channel itself. You need an array there to reuse workers (or re-add a done worker to the queue array when it's read from it). https://play.golang.org/p/HOLTBe-1JwF (I also removed the select{} in Start() as a channel read is blocking, and a single channel select doesn't make sense... but the main point is `queues &lt;- worker` when a worker is done).
A quick picture of Go compared to Django. The upsides: + Faster + Easier to maintain with no painful upgrades + Easier to deploy + Consumes less resources The downsides of Go vs Django: - No scaffolding (admin, users and sessions) - More modules are available in Django - No user management and sessions out of the box - Bigger community support in Django
Hi, Read this tutorial on [how to make your own website](https://mobirise.com/how-to/make-your-own-website/) using Mobirise and its HTML templates. This tutorial is simple and easy to understand.
So if the podcast is in french, why exactly is it posted here with an English title? Pretty misleading if you ask me.
Using logo as copyright protection was quite smart at this time. When Game Boy was introduced many countries didn't consider video games as subject under copyright law.
What was the motivation to write this library when there is [DetectContentType](https://golang.org/pkg/net/http/#DetectContentType) already?
Nice effort! I really dig the commit-by-commit approach, thanks for the material!! If someone doesn't feel confident enough to jump in, go for it, it's not that bad! You could check out [this](https://github.com/ssloy/tinyraytracer/wiki) ray tracer, which is even simpler, but enough to teach you the vary basic concepts. I've never messed with graphics before, but I [ported it in Golang](https://github.com/tpaschalis/go-tinyraytracer), and now feel more ready to work with OP's repo.
It must be the examples where I can't find a simple solution then. (Could be me with "my old eyes") Looking for a solution where a user can add any value a config.sane file and where the programmer can grab any value the program needs (without a struct). Is there such an example? (please lead the blind)
I did it less dynamically: \`\`\` \[\[hubbas\]\] name = "hubba1" field1 = "a value" field2 = 100 \[\[hubbas\]\] name = "hubba2" field1 = "another value/" field2 = 111 \`\`\` and now you can loop over the hubbas: \`\`\` memHubbas = config.Get("hubbas").(\[\]\*toml.Tree) for \_, hubba := range memHubbas { name := hubba.Get("name").(string) // etc.... } \`\`\` 
A brief update. Next webview (currently webview-x branch on github) will support EdgeHTML, if that help. ETA: Spring 2019.
Thank you for your suggestion, please accept my lack of excuse for this immature way of presentation. I take it into account.
repo?
No worries, your code looks great. A good readme is usually what makes people want to try it out
[project page](https://github.com/isacikgoz/gitin) I wrote an app to play with libgit2 and quick explorer for commits/branch/workdir. My use cases are like: - for `git log` -&gt; `gitin log` which I think to alias to `glog` - `--ahead` or `--behind` flags can be used for incoming/outgoing commits - it is an interactive way of git log - for `git branch` -&gt; `gitin branch` this also can be aliased to `gbranch` - lets you see last commit info of specific branch - lets you delete or checkout branches - for `git status` -&gt; `gitin status` and finally can be aliased to `gstatus` - you can add/remove files form staging area - lets you commit/amend indexed files 
I'll look for it in the video version when that becomes available.
[https://github.com/knqyf263/utern](https://github.com/knqyf263/utern)
I did make a benchmark, I copied the code [here](https://play.golang.org/p/IuShT7e9Zi8) although you can't run the benchmarks there. Not sure exactly what makes it so much faster but I suspect removing the `unicode.IsDigit` in favor of manually checking that and not using strings. old ns/op new ns/op delta 1229 308 -74.94% old allocs new allocs delta 15 8 -46.67% old bytes new bytes delta 256 128 -50.00%
it is the allocations done when writing the rune to the bytes.Buffer. try this: https://play.golang.org/p/C15adGuYxSF note the `b.Grow(14)`
Thank you for taking time and providing feedback. This package was in use exclusively for my own requirements. I write precise documentation required by each individual package with sufficient detail covering edge cases ( GC loop-hole, meta-ref info loss, recursive DCAS on structs, slices and pointer-tag as types, etc ... ) which poses danger because of user-level atomics ( in terms of language api vs golang internal implementation of same functionalities -- interestingly both using the same mechanic but restricting it to user, for example ) and now this package provides functionality that is similar to golang internals. I still need to study golang internals and add new things to the library.
Happy cake day! Also, this looks slick.
Ben de Go öğrenmeye yeni başladım, eve geçer geçmez inceleyeceğim. Eline sağlık :) 
That along with replacing the `unicode.IsDigit` call helped a bit: old ns/op new ns/op delta 811 305 -62.39% old allocs new allocs delta 10 8 -20.00% old bytes new bytes delta 224 128 -42.86% 
hmph. the unicode.IsDigit() call is really simple. i'm surprised that has much of an impact.
I kinda am too, cool function though I'd never seen that before.
If you want an SQL-like embedded database, the photoprism.org guys just stuck TiDB into their application as a single replication instance. TiDB acts like MySQL.
Bolthold provides aggregate queries. 
Ben de 
Quite a number of french speaking people are on this reddit and there's no French Golang subredit. I'm sorry you feel misleaded, I've tried to make it clear (in the title) about the use of French while following the conventional use of english. Would a small english digest of the content be of any interest?
Maybe link directly here: [https://play.golang.org/p/fpyHDc-8\_uK](https://play.golang.org/p/fpyHDc-8_uK) (it includes their Twitter link up top)!
thank you!
Teşekkürler/thank you! go is fun:)
That's the point though. To handle different errors you have to basically re-define the errors through interfaces. It feels wrong to have to define something that already exists. I like that Go is a very simple language and requires code to be super explicit, but writing interfaces for errors that are already described in the http package. `transport.go` has the httpError type that is used a lot throughout, but since it isn't exported it can't be used in a switch case. But `net.go` has a DNSError type that *is* exported. From the outside it just seems completely inconsistent and somewhat arbitrary and requires the user to write much more code than should be required.
I would recommend a separate French subreddit. If you want me to justify why, I can explain in Finnish.
rolling out v1.0.8 TLS support. &amp;#x200B;
 var tmdbClient tmdb.Client tmdbClient.APIKey = "YOUR_API_KEY" I'd recommend a `func New(apikey string) (*Client, error)` or such.
Agreed, this TUI is very nice looking!
[removed]
Useful, but it doesn’t mention contexts anywhere. That’s extremely useful for managing timeouts, both on the client and server side. 
There’s also go-bindata, which is the big popular one. Includes compression. Also has a native plugin for http called Go-bindata-assetfs, which basically just serves the files directly. I’ve used it in the past and it works really well. An entire web server without any outside dependencies. Nice. 
What sort of morons are downvoting someone for not speaking English?
Looks great! Reminds me of a similar app written in go called \[lazygit\]([https://github.com/jesseduffield/lazygit](https://github.com/jesseduffield/lazygit))
You need to seed the random number generator by calling \`rand.Seed()\`. Also remember there are two \`rand\` packages \`math/rand\` and \`crypto/rand\`. use the correct one for your specific use case.
The correct package is crypto/rand, unless you have a specific and good reason to prefer math/rand. The two primary reasons to prefer math/rand is "I've benchmarked my program, and I need faster random numbers because this is a bottleneck in my code and I'm not using these for crypto" and "I need reproducibility of the random sequences". Even in the latter case, you probably want that for testing, so you should write your code so your test code can specify a known series but real code defaults to crypto/rand. It may feel wrong to use crypto/rand if you feel like you don't need crypto, but there's a lot of little ways in which it's just _behaves more like you'd expect a random number generator to behave_. /u/tom_cruising posts the most obvious, but there's other little ones as well. If you're just using these packages without too much thought, and you expect your random number generator to produce, you know, _random numbers_, no matter what code you write, crypto/rand is what's going to do that. math/rand is more suitable for very specialized cases, despite it's seemingly-more-generic name.
It is similar to lazygit, you are right, but gitin is a different interpretation to git. and offers a different experience. I learned a lot from lazygit btw, and it is also a useful interface to git.
Yes, very nice addition! Tbh. I can't recall to have used math over crypto.
GoCenter is not a replacement for Athens. GoCenter is a centralized public repository, while Athens (and JFrog Artifactory for that matter) are organizational proxies. Both can use GoCenter as their upstream to gain reproducible resolution and speed. There is an entry about how they differ [in our FAQ](https://github.com/jfrog/gocenter/wiki/Frequently-Asked-Questions#doesnt-a-repository-like-jfrog-artifactory-or-athens-achieve-the-same-benefits).
I see you use libgit2. Did you consider [go-git](https://github.com/src-d/go-git), and if so, what made you choose libgit2 over go-git?
I used go-git with [gitbatch](https://github.com/isacikgoz/gitbatch) libgit2 is much more faster, and it is much more like git. go-git on the other hand is much easier to use. I consider switching to libgit2 on gitbatch too. But distribution of libgit2 is not easy as go-git. It will be a hard decision for me :)
Perfect!
Nah it's ok. I could write in English but we Turks can be stupid sometimes; so much so that someone from the same country doing something good has made me happy for no reason and I just wanted to write in our own language for a warmer thanks.
Video is available now. https://fosdem.org/2019/schedule/event/thestateofgo/ 
dot is really a bad name choice (graphviz).
Thanks for that hint! Do you have a nice resource where I can learn and than adapt the article? I never needed contexts for managing timeouts
And you're not in the negatives anymore. Some English speakers can be real snowflakes about foreign languages
Oh, there's plenty of awesome Go open-source projects. I would start by looking at the *awesome go* list: [https://awesome-go.com](https://awesome-go.com) Good luck!
Wow, sounds like you're on an exciting journey. Others might point you to some better resources but one place to checkout might be awesome go: https://github.com/avelino/awesome-go it's a collection of go peojects. Maybe have a browse to see if any projects take your fancy. When you find a project have a close read of all the documentation, spelling / grammar and minor text changes are a good way to get a feel for how to contribute to the project, also take a look at the issues that are open sometimes projects use the 'good first issue' label which could be useful, additionally if the have a contribution guidelines page have a read. Im sure others will chime in with more suggestions but I hope that helps!
Justforfunc has a few videos on contexts. I found them super helpful. 
I would use/accept an \*HttpClient rather than use the standard default client, as there is no timeout set. 
check out restic! 
Also keep in mind that time isn't real on the playground. `time.Now()` always starts at 2009-11-10 23:00 So if you call seed with time it is also actually odd on the playground.
What does "utilize redundancy" mean to you here? You can certainly only have a single process listen on a port at any one time - this is not a Go limitation.
sorry, I'm still getting to know my way around the terminology for backend stuff. the basic idea is that I want to be able to run multiple instances of this daemon in case one fails. it appears the current setup defaults to just one port, and if that port is not open then it exits. I understand this is is not a golang limitation, but what I'm wondering is how I can convert this daemon to utilize more than one port? 
Sounds like you want a load balancing setup. You could run multiple docker containers containing your application and then something like traefik or haproxy that takes traffic from port XXXX and routes it appropriately.
That's not going to help you unless the application is stateless, or shares state between instances somehow, and you have some sort of load-balancer in front of it that can distribute connections to multiple instances and detect failures. Running multiple instances on a single machine is probably not very useful any way. If you're concerned about the application exiting, just have your supervisor process (docker/systemd/whatever) restart it.
yes
Hmmm ok I’ll look into these alternatives and get back with y’all. The reason I ask this is because the sys-admin has asked to make the daemon so that multiple instances can be run. 
This is very generous. Thank you everyone involved in producing, recording and sharing the talks.
Doesn't a more standard JSON schema fulfil this use case?
I would disassemble the binary [1] and pass the output through an ASM visualizer [2]. [1] https://golang.org/cmd/objdump/ [2] https://godbolt.org/
Thanks! I'm currently a mech engineer in the space industry in California and getting pretty home sick. Always liked coding in school so hopefully I can pick up C and Go easier than some subjects I had to learn in school. That website looks like a pretty good starting point. The cockroachDB documentation, style and rules for contributing got pretty confusing pretty quick. I think it is mostly because I have never used git before.
The usual Unix trick is to set up the network listen, then fork. Go basically doesn't work with this approach. The solution is to use a process supervisor to restart it if it fails. There's a million of these things, and the best solution is to reuse one your organization already used, but you can use any of them. monit is an example of one such too, if it would help you search.
Also could I do it at build time? i.e. I'm in the project directory in my $GOPATH. I.e. I don't just have the binary to work with. Sorry I wasn't clear to begin with.
thanks so much for the response / suggestions. At the moment I don’t believe our org currently has a process supervisor, so I’ll look into monit to see how it would work with our infra can I ask why the ‘listen then fork’ approach doesn’t work with Go? 
Thank you very much for the code review, I don't know if I would've caught that. What a silly oversight on my part. Lesson learnt, remember to never give my workers vacation.
In that case, I would use something like Twiggy [1]. It analyzes a binary’s call graph [2] to answer questions like: • Why was this function included in the binary in the first place? • What is the retained size of this function? • How much space would be saved if I removed it and all the functions that become dead code after its removal [1] https://github.com/rustwasm/twiggy [2] https://rustwasm.github.io/twiggy/concepts/call-graph.html
Thanks for posting those links. This took me ~10 minutes to write. That means that if I spent more than 10 minutes looking for existing solutions, evaluating their code quality, stability, trustworthiness, how to use them, etc., it would have been a net loss. One of the Go proverbs is [A little copying is better than a little dependency](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=9m28s). Copying code or implementing something yourself, especially if it is small, is often better than pulling in a dependency. I find that most modern programmers are way too dependency-happy, leading to incidents like the left-pad fiasco. Russ Cox also [wrote](https://research.swtch.com/deps) about the problem with how modern programmers use dependencies. With that said, I encourage people to copy this bit of code (please keep the Apache license though!) to avoid adding a dependency.
Im also from Philadelphia! Just curious - what’re you interested in specifically with Comcast? In addition to the other advice you’ve received, I would join the Goohers slack channel to get familiar with the ecosystem and community.
That already happens, so this is pretty good at storing text files.
An image processor (could pixelate to ASCII art or apply some sort of filter). A music visualizer. A to-do list. A program that accepts calendar event info and logs it to your choice of calendar application. An email client. 
For very beginning you could write cat in golang. Then you could make a tools which are taking the input via stdin. For example a tool for making md5, sha1, ... hashes. Or a tool for gzip that.
Hey /u/sat5344 TLDR; come work on [github.com/pions/webrtc](https://github.com/pions/webrtc) we would love to have you :) The hardest thing will be staying motivated and contributing even when things frustrate you. I have seen lots of people drop in, but usually burn out after their first couple issues. It could be me my (the maintainers) fault, but it is really hard to make everyone happy. I would pick a topic/something you find interesting. Working on Open Source is a great way to meet people and build skills, I have never gotten a job directly from it but it sure has influenced me a lot!
I'll have to check it out! From the quick read, it looks similar to what Comcast would be doing with its real-time streaming to customers. I'm not hoping it gets me a job but I'm pretty against following a tutorial series for a project so after I learn the basics from some readings and mit/harvard lectures I want to start applying the new material and solve problems.
I would look at using a named pipe to communicate between the processes. It is local to the machine (unlike opening a port) so 1) you don't have to worry about needing permission to do it and 2) it is way more secure. Your ElectronJS process would generate a random name, create the named pipe with that name, then start the Go process and pass in the name as a process argument. I haven't done this specifically with ElectronJS and Go (only C#) but I see libraries exist for both of those, so it should be possible. There is no guarantee that Antivirus software (or even the built-in Windows firewall) will allow your program to open a port. It is also insecure. Imagine half of PowerPoint was running as a service listening on a port. If I know your IP address and I'm on the same LAN I could send it HTTP requests and potentially steal your data.
When you fork() only the kernel thread which called fork exists in the child process. The go runtime, and possibly the packages you may have used up to that point, also require their goroutines and kernel threads to be propagated in order to continue to function properly.
Please no! Using crypto/rand to generate random numbers is a really bad idea. It is slow and much more important: You cannot regenerate the stream of random numbers which makes it impossible to verify (by rerunning) any experiment. And debugging gets much harder too. Never use crypto/rand for random numbers used for statistic sampling, Monte Carlo simulations, probabilistic code, etc. Really: Never! It is fine to seed your PRNG from math/rand with a few "really random" bytes taken from crypto/rand if you record that seed together with your results so that you can rerun the exact same simulation by reusing that seed. 
Might be used to scale up an ML system, but the first version will likely be in something like Python.
Most likely not. Machine learning needs high mathematical precision and mare floats aren't good enough for serious application. That's one of the reasons why Python is preferred. Also there is new language which is booming exactly for this type of thing - Julia. Which maries Python with Go like performance. 
In my opinion, it's not just TensorFlow and other ML bindings. A large part of applied ML and AI is simple calculus, statistics and array/matrix calculations, and Go doesn't seem to be the best at that. Also, Python and R have a *huge* was-here-first advantage in libraries, tutorials, documentation and adoption by non-CS people. If Go were to compete, it would have to do so against Python, R, Julia, Matlab, and many other solutions *specifically created* to tackle these problems. Also, sure, speed is important, but at most companies it's not something that cannot be solved by throwing some cheap hardware on it, and porting to other languages/infrastructures rarely happens in my experience, so projects get "stuck" with their first option.
That's unusual for redundancy, but you can do that by leveraging SO_REUSEPORT. Since Go 1.11, you can set this option through ListenConfig (https://golang.org/pkg/net/#ListenConfig) by using `syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)` in a `Control()` method.
It's pretty simple, just use a map to handle the dynamic part of your section. I use this technique to manage a semi-structured config Here a working example... &amp;#x200B; `package main` `import (` `"log"` `"github.com/BurntSushi/toml"` `"github.com/davecgh/go-spew/spew"` `)` `type TomlFile struct {` `Version int` `Server map[string]server` `Default struct {` `Folders map[string]map[string]interface{}` `Params map[string]interface{}` `}` `}` `type server struct {` `IP string` `DC string` `Ports []int` `}` `func main() {` `data := \`` `version=123` `[server]` `[server.alpha]` `ip = "10.0.0.1"` `dc = "eqdc10"` `[server.beta]` `ip = "10.0.0.2"` `dc = "eqdc10"` `ports = [8888,9999]` `[default]` `[default.folders]` `[default.folders.Mercury]` `root="apps"` `log="logs"` `config="cfg"` `[default.folders.Jupiter]` `source="src"` `documents="doc"` `[default.params]` `#notifications` `smtp="gmail.google.com"` `sender="12345@gmail.com"` `pwd="#·$%&amp;@·ºª&amp;"` `#misc` `debug=false` `type="csv"` `encoding="utf-8"` `\`` `tf := TomlFile{}` `if _, err := toml.Decode(data, &amp;tf); err != nil {` `log.Fatal(err)` `}` `spew.Dump(tf)` `}` 
Yes, absolutely. Today everyone is talking about ML but few really understand it or practice it. When ML is understood by more programmers, it for sure implemented in many languages.
Core: - write your own `print` or `echo`. High level: - write own nginx, that handles connections with coroutines or simple queue and returns static pages.
Your blanket statement is so wide that it's harmful. &gt;Using crypto/rand to generate random numbers is a really bad idea. Oh so the next time I implement something that generates random password salts and UUIDs I should be using `math/rand`? Gotcha... &gt;You cannot regenerate the stream of random numbers which makes it impossible to verify (by rerunning) any experiment. Yes that is indeed the purpose of a cryptographically secure pseudo random number generator! It's designed **not** to be predictable or reproducible! &gt;It is slow [citation needed]. I ran https://play.golang.org/p/vKGumSTH8CX which generates 1 GB of random bytes on a DigitalOcean VM: crypto/rand took 5.979774218s math/rand took 2.824786094s Make your own judgement whether or not you consider this to be "too slow" for your specific use case. I certainly wouldn't consider it too slow in most of my use cases. &gt;And debugging gets much harder too. Uhh, not really? You can run tests/debug using `math/rand` and use `crypto/rand` in production? They both provide structs that implement `io.Reader`. &gt;Never use crypto/rand for random numbers used for statistic sampling, Monte Carlo simulations, probabilistic code, etc. Really: Never! Sure, those are probably some good cases when you don't want to want to `crypto/rand`. &gt;It is fine to seed your PRNG from math/rand with a few "really random" bytes taken from crypto/rand if you record that seed together with your results so that you can rerun the exact same simulation by reusing that seed. It's important to mention that doing this will forfeit the cryptographically secure part of `crypto/rand` because `math/rand` is not cryptographically secure! i.e. knowing some of the values of the output stream of `math/rand` can be used to predict future values. ---- Look, like with most tools in the world, both `crypto/rand` and `math/rand` have their specific uses. There is no "correct" one to use in *all* situations. Just like how Go shouldn't be used to solve all problems. The correct one to use is really dependent on the use case scenario, it's up to the developer to understand the differences between the two and decide which traits of the random number generators are most ideal for their use case. Do you need to have your random values being **truly** random? Go for `crypto/rand` for all means. If you need to be able to reproduce the output then log `crypto/rand`'s output to a file. Do you want streams of random, but easily reproducible or predictable values? Then go for `crypto/rand`. It's extremely misleading to say one solves all your problems.
Could the issue just be the GCP Server firewall? It would explain the application running correctly, but not being accessible. Otherwise, check if another process is using the port, using `lsof` or `netstat`, and if that doesn't fix it, check the ACLs you have configured with the GCP console. Also, on your local environment, you mentioned the port `:3012`, but on your remote machine, the process mentions `:80`. Which one do you run the app at? Is it a web page, or a different custom service?
It’s not a good reason why it won’t be taken up in Go. There are good big number libraries for Go that solve the limited precision problems of a typical float, just as there are for C and most languages. Lots of other reasons tho. 
Whoa, slow down there. I think you are jumping in with the wrong mindset to open source. While contribution is certainly a major factor to open source, open source developers dont just think hey I want to contribute. In my experience it is more of I have a dependency and either that dependency isnt behaving correctly or doesnt fulfill what I need it to do. Depending on the level of complexity in the solution I may create a github issue to have some input on how the maintainers may want the new feature to work. However, if it is a bug, I’d go ahead and fix it and submit a pull request (PR). Here’s what I would do if I were you. I would create a github project of my own that is complex enough to have a couple dependencies. Maybe something that deals with AWS if you have the money to spend. From there you’ll encounter bugs when using a dependency or perhaps things that arent clear in the comments or even in the README.md. When you encounter these, it is your duty as an open source developer to fix these and send them back upstream. Start small with fixing documentation in comments and go from there.
I’m not convinced that Go would even speed up something like Tensorflow. TF is already written in C, which is faster than Go (marginally). I haven’t dug into TF for Go but I assume it’s just using the C bindings and isn’t a re-implementation in native Go. That means it’s already as fast as it can be, and most languages are already fast enough to feed in data to the model/training to saturate TF. There is, however, a good case to be able to load a trained model and actually run it within whatever language you want. In that sense, it doesn’t need to compete with anything, it only needs to be able to run the models. IIRC, that’s already doable in Go, even if under-developed. So it’s not really about replacing or augmenting those solutions, but using their output in a more workflow-centric way that may not be as functional in a different language. 
It's the first time I'm hearing 64-bit precision not being enough for ML/AI applications, and I don't know of people hitting *that* bottleneck, so you got me interested! Is there any resources or stories on this problem you can point me to?
Yes, you have a great point. And if you get to actually train your model in some other language/infrastructure, I can't think of many strong reasons to turn to Go just to run it.
I'm not sure that was the lesson here :)
Please excuse if I upset you. crypto/rand is for cryptographic numbers where you want the number to be "unguessable". UUID, password salts, etc are almost prototypical applications of crypto/rand. My comment to "not use" crypto/rand was based on your remark "The correct package is crypto/rand, unless you have a specific and good reason to prefer math/rand" as I think it is completely the other way around. Most code needs reproducible PRNs and only crypto related stuff (UUIDs and password salts _are_ crypto related) should use crypto/rand. But I do acknowledge that a shipload of developers never have and probably never will write numerical code or code in any scientific context and nether have nor need to understand the subtleties of "randomness" and recommending them crypto/rand might be fine as it (you are right here) better models the naive notion of "random".
Honestly? Poorly. From the fact that this is selected run (instead of actual round of benchmarks) to the whole "memory is cheap" or "you never get to this kinds of loads" arguments in linked /r/programming thread. С# allocator is wired towards throughput, so it has some latency problems on big heaps. Go on the other hand is performing quite well on big heaps. For a better explanation look here: https://medium.com/servicetitan-engineering/go-vs-c-part-2-garbage-collection-9384677f86f1 Plaintext benchmarks is a fun game, but it doesn't show much. If the only thing you need to is to return static text, I think it's better(most of the time) to use nginx instead of handrolling your own web server. Fortune and queries have a lot more common with reality (aspcore fares quite well in those too). At the end of the day it's not about what you like. It's about what fits the job best. 
It’s 2019, where 1 million requests per second on a couple physical CPUs is considered slow. I’ll look into the methodology, but seems interesting. 
You might give [gophercises](https://gophercises.com) a look.
Peculiar that nginx would fare so badly on that test tho. My guess , without digging too deeply, is nginx is grabbing the data from disk whereas the others are likely raw-writing from code. Some other possible biases are in headers. If they pack more headers, they won’t be able to pump as much traffic/requests in a response. Would need to look into it, but these kinds of tests are most academic anyways. When you’re burning millions of requests per second on a single server, you’re well into “not gonna be a problem for me” territory unless you’re google. 
It's not that bad when you come from a Java or C# background, but I believe now with the latest JS versions things has been made a lot easier and powerful making wrapper languages not that necessary for proficient people on JS.
Hello, [Gorgonia](https://gorgonia.org/gorgonia) contributor here. There is **DEFINITELY** a future in machine learning in Go. I'd like to address a few issues in your post. I'll start with the second paragraph, and then answer the top questions. 1. Tensorflow. TF bindings in Go are not great. Given the cgo overhead, it will likely never be great. The only way I can think of making a good TF binding opens your programs up to a lot of security issues (i.e. you have to put your code/program in some sort of shared memory space) 2. Golearn. Golearn is great. However, its main drawbacks are its overreliance on C libraries. 3. Gonum. Gonum is even greater. With Gonum, you can implement 90% of machine learning algorithms. There are no high level libraries, because right now, the people who use Gonum, myself included, simply prefer to write the ML algorithms straight out. In this sense, **Gonum is in fact a perfect level of abstraction**. 4. Multivariate linear regression again, is very straightforwards (I literally have [this](https://twitter.com/chewxy/status/986803321619951616) in a T-shirt). You can implement it in Gonum yourself from scratch. Or you can use Sajari's [regression](https://github.com/sajari/regression) package, which uses Gonum. At this point, it would be quite instructive to use the `regression` package from Sajari as a case analysis. The problem with machine learning is this: there is no "one size fits all" API. Scikit-learn has gotten many people used to the whole `.fit()` and `.predict()` APIs. These work for Python. I invite you to design an interface that works well for Go. It's harder than you might imagine. You might be tempted to reuse the methods - so, say, define a ML interface as such: type Learner interface { Fit(...???) error Predict(...???) (???, error) } type Modeler interface { Model() ??? } type Scaler interface { Scale(Learner, ???) error } What you will end up with is commonly known in Java-land as a tower of abstractions. Which is clearly against Go's philosophy of software design. The best way I can put it is: software should be designed to purpose. Python style ML libraries do not work for Go\*. Gophers need to forge their own path forwards. Now, time to answer the top questions: 1. Yes, I'm using Go in production ML applications. There are currently according to my best knowledge, about 200 production level recurrent neural networks, convolutional neural networks written in Go with Gorgonia (I am personally responsible for half of them, from my consulting work). Some of these NNs have been running nonstop for at least 3 years (given I've not heard any complaints). Heck, I even once attempted to [write AlphaGo in Go](https://www.youtube.com/watch?v=nk87zsxpF1A). 2. I see Go development in ML to be growing, but it's in its critical phase now. More love and support should be given by the language designers. Having more contributors to Gonum and Gorgonia also is vital at this juncture in time. I'd like to highlight a few of my favourite recent developments in ML with Golang, if you allow me. 1. I am personally very excited about Olivier Wulveryck's work done on making Gorgonia play nicely with ONNX. In the future, all deep learning models will be able to be run across different frameworks, and Olivier is the main man in making this happen. 2. On the theory side of machine learning, there are some surprising things that you can do with Gorgonia that you can't really do with TF without much pain. This has led to some interesting developments that I'm working on - particularly interpretable machine learning models. \* Sure, we can add all sorts of abstraction towers, but this makes for very expensive mistakes. Personal opinion.
Counter point: Go is such a get-shit-done language because there is little room for meandering, both down the `AbstractBaseClassFactoryBeanConstructor` path and the let's-make-our-data-type-implement-all-the-typeclasses path. This puts Go directly in the path of Python, and R. Both Go and Julia has more static guarantees than those other two languages, therefore is better. Hence, really the only competition is Julia. Julia in my opinion, currently beats Go in terms of flexibility and numerical computing prowess, but you cannot really beat Go in compiling a neural network straight to a binary that runs everywhere. In 2 seconds. Another counterpoint: R was there first. Python soon overtook R because Python allowed for a wider breadth of applications.
Wat. You can run deep learning neural networks with just an 8-bit float. I frequently train networks using a 16 bit float in Gorgonia.
&gt; Go is such a get-shit-done language because there is little room for meandering, both down the `AbstractBaseClassFactoryBeanConstructor` path that is found in OOP style languages and the let's-make-our-data-type-implement-all-the-typeclasses path that is found in functional languages. Yeah... and then I have a look at the [io package](https://golang.org/pkg/io/) and see that there's over 15 interfaces, many of which are stuff like type ReadWriteSeeker interface { Reader Writer Seeker } Now, maybe I lack the appreciation for fine Go interface work, but I fail to see how that is significantly better than those damn AbstractSingletonVisitorFactories... 
It's not really ML/AI, but I've hit precision problems in raytracing in the past where double wasn't enough. Chain enough numerical operations and even a tiny imprecission scales up. 
\*Save comment*
Can you explain your use case a bit more? Having your server do authentication “with AWS” doesn’t quite make sense since IAM is the thing that will do the auth. Do you want to validate tokens issued by Cognito?
Thanks for the perspective! I think you have a good point I hadn't thought about.
I have [written about how to use interfaces in Go](https://blog.chewxy.com/2018/03/18/golang-interfaces/). It's better than an AbstractSingletonVisitorFactories because those are not ad hoc, while the best uses for Go interfaces are ad hoc. The io package happens to be a collection of some of the most used interfaces.
I was thinking about a cat version of `cowsay` when reading the firstline.
&gt; The io package happens to be a collection of some of the most used interfaces. It seems to mostly be just workarounds for the lack of support for multiple interface bounds on function params. 
You will want to look up "OpenID Connect". For example, here's a client library for Go: [https://github.com/coreos/go-oidc](https://github.com/coreos/go-oidc)
One way to think of that is that it's a cartesian composition of interfaces. 
It's not enough for common operations like currency convertions. When your whole schtick is precise data analysis it becomes obvious. I'm not saying you can't. It's simply not optimal because it doesnt cover as much use cases.
I'm pretty sure that, given a few years, there will be machine learning written in Minecraft red-stone. I think the ML scene is growing in all languages as the understanding/interest of ML grows in the world. There is definitely a future in it - If you'd enjoy doing ML in Go, just keep an eye out and use the libraries that reveal themselves! There may be a secondary question of "Will there be jobs available for doing ML in Go". I'm not sure anyone can answer that with certainty. But there isn't an immediate need or strong industry desire to leave Python or R, at the moment. I primarily see people creating models/APIs in those languages and using their preferred language to communicate with those models/APIs. Unless that becomes a bottleneck or a very determined group creates an amazing set of libraries in another language, I don't see it changing soon.
Have you had the chance play with the Apache beam go sdk? If so, what are your thoughts/criticisms of it? Could you provide some links where I can learn more about how gorgonia creates more interpretable models? Also, for everyone reading this post, I HIGHLY recommend you watch chewxy's talk on implementing alphago
I've only skimmed through it on a phone - also have never used Cognito - but this seems like a pretty thorough example of using Cognito JWT tokens in Go. https://github.com/yoskeoka/gognito/blob/master/main.go
There is an open issue to investigate why fasthttp dropped from 7 to 4.5 million requests/s: https://github.com/TechEmpower/FrameworkBenchmarks/issues/4410 I'd appreciate if someone could chime-in with answers but please no bike-shedding. Also fasthttp core contributors seems to be on the case.
&gt; Python however has built in fractions Like these? https://golang.org/pkg/math/big/#Rat
I will be uploading them to YouTube soon for those that prefer the possibility of streaming.
You can deserialize to a `map[string]interface{}` i'm doing it here: [https://github.com/bloom42/acro](https://github.com/bloom42/acro) something like type Config map[string]interface{} confStr := ` any = 1 field = "hello" you = { a = 1 } want = [ 1.1, 2.2 ] ` config := Config{} sane.Unmarshal([]byte(confStr), &amp;config) &amp;#x200B; &amp;#x200B; &amp;#x200B;
Yeah Julia is certainly something to look out for.
[Go supports multiple interface bounds on function params just fine](https://play.golang.org/p/FSvLThs_eOg). In general, you can create ad-hoc types inline. In fact, technically, `interface{}` is exactly that; it isn't a special type, it's an ad-hoc interface you specify on the spot. For it to be a special type would require something like `type Anything interface{}` to exist somewhere. It's just that it's unusual to be in a situation where it's not a better idea to pull the interface declaration out for software engineering reasons. It's silly to repeat such an inline declaration even twice.
https://github.com/golang/go/issues/2381 suggests using running godoc locally and using wget to create a static backup: "I haven't thought about using wget. Nice. For those interested in this trick, here are some notes. First, edit robots.txt in the go root directory, and remove "Disallow: /". Otherwise only the index will be downloaded because wget respects robots.txt. Then start godoc pointing to the project path: godoc -path="/path/to/project" -http=:8080 And finally this a more complete command to get a working static docs, including static files and with proper links: wget -r -np -N -E -p -k http://localhost:8080/pkg/ -r : download recursive -np : don't ascend to the parent directory -N : don't retrieve files unless newer than local -E : add extension .html to html files (if they don't have) -p : download all necessary files for each page (css, js, images) -k : convert links to relative"
You criticisms would be much more trenchant if I hadn't _mentioned and discussed those exact issues myself_. I really don't appreciate the implication that I'm somehow unaware of the issues when you mostly just repeat points I've already made. Like any other optimization, the slowness only matters if you've benchmarked it and determined it is your real problem. Testing can be solved by _exactly the thing I discussed in my post already_ and is a non-issue. I know. I've done it myself. In fact you _need_ to if you want to test code that actually does want to do crypto.
Though a map for options is "future-proof", its bad from a consumer perspective. Rather i'd have a struct for options and flags for things like options\["append\_to\_response"\] = "credits,images" But to be honest, that would be a lot of work :)
Does anyone know where can we find the list of speakers? 
Maybe I've just drink the cool-aid too deeply, but to me ReadWriteSeeker is seems clear &amp; concise -- no muss, no fuss. The only way I could imagine getting more straightforward would just be eliminating the ability to abstract at all (so you just get `file` or something), but I do think there are advantages to having abstraction.
CSV peek: makes CSV files readable on the command line so you can quickly peek at the contents of a multi gigabyte file without either using Excel (too slow) or `less` (unreadable). 
Thank you alot of choices here, the calendar idea is really interesting.
Thank you, the use case is perfect.
Does it make sense to say high level allows for me to add on to it little bits at a time?
Well, if you're trying to turn your model into an API or web app, I would argue Go is better suited to that than Python, but that's the opinion of someone who doesn't like Python very much.
Possible. However it still changes little. Python was there first. Meaning it reigns supreme as lingua franka due to well established ecosystem. And the successor to it is Julia. That's not to say Go can't be used, but since it's the academia which is the driving force due to necessity of high math and statistical analysis, Go will remain to be used by common web developers regardless of hyping.
I almost wrote it the other day when waiting for Excel to open a file. 
Thanks for the awesome response. I had not heard of Gorgonia before and will be looking into it. I guess I hadn't considered the simplicity of writing my own multiple regression functions and I hadn't found Sajari's regression package either. My primary concern, coming more from an economics background than ML, was having access to a variety of models to experiment with, as this is how the Python community seems to recommend doing it. I agree that the abstraction should work differently in Go than Python. I don't particularly want to spend that much time writing Python. That being said, I am not an expert on machine learning, and while I wish I had time to learn all the math and write my own SVN or RNN, that just isn't feasible. Obviously I can suck it up and train my models in Keras/Tf in another language, but I do think that Go's combination of performance, simplicity and proclivity for concurrency make it a very strong candidate for training ML models, and it would be great to be able to build tools without all the context switching. Thanks again for the answer and recommendations.
Google never serves millions of requests per second from a single server. Not even close. Because that would be a stupid thing to do. These kinds of benchmarks are ridiculous (i.e., they should be ridiculed).
&gt; I write precise documentation required by each individual package with sufficient detail covering edge cases Yes, I saw the godoc and noticed the individual functions were well documented. That said, it's still hard to see how to piece everything toghether. I (personally) would really appreciate a quick demo in the form of "how to build X with this package". It would really help one get started. (I've starred this, btw, so I'm keen to see how it evolves)
Opensource code bases succeed and fail depending on the people and communities that make use of them. The Pareto principle rules. 
Thanks 
Thanks 
Indeed, I'll try to improve that. 
For inspiration: http://eagain.net/talks/go-projects-2013/
Wrap your favorite site's API. Example: a reddit CLI tool where you can even comment and upvote.
[removed]
[removed]
I'd be interested in a solution for this too. 
Using timeouts in general is a good practice for any type of request/response architecture -- you need to have a reasonable expectation of when that request is suppose to finish, and then make an educated decision on how long to set a timeout to so that you can detect anomalies such as maybe the server crashed before the request finished being serviced but a load balancer is still keeping the connection alive beacuse the health check hasn't yet taken that crashed server out of the rotation -- as an example. &amp;#x200B; Long story short, timeouts are used because in the event that some unexpected behavior is exhibited, you don't want your goroutine to sit there waiting for ever for the request to return, you want to timeout and move on.
http://www.catb.org/esr/faqs/smart-questions.html &gt; When you ask your question, display the fact that you have [searched for your own answers] first; this will help establish that you're not being a lazy sponge and wasting people's time. Better yet, display what you have learned from doing these things. We like answering questions for people who have demonstrated they can learn from the answers.
I was kind of thinking doing the opposite. CoreOS with bootkube is very nice, you don't have to have configuration management in place.
&gt;Sure, but when ML has to leave the confines of the academic labs and go into production systems for practical applications, it will not be through Python or Julia, but through production optimized languages like Go. &amp;#x200B; &amp;#x200B;
Nice man, thanks! I'm new in Golang world. I'll improve the code.
Well, that's the thing. Julia is not all that slower than Go. One of the key points in it's development was to address the Pythons reliance on C libs, while maintaining ease of use of Python with some new features which makes writing mathematical calculus a lot easier. It's actually designed for it. Now obviously common business cases don't need same level of precision as for example, determining progression of diabetes caused blindness from retina images. I also don't expect businesses to commit to maintaining multiple languages too when for more simple tasks like transfer surveillance general purpose languages are simply good enough. 
I believe what you are describing is implementing oauth2. You can take a look at [https://github.com/openshift/osin](https://github.com/openshift/osin) 
I got excited then realized it was in French :( GoFM is dead so we have no English golang podcasts that I know of. 
Your service should authenticate against Cognito using a JWT. You wouldn’t add the auth layer between the services. Each one should handle auth using the Cognito SDK, independent of each other. 
Machine Learning has a HUGE component of experimentation. For that purpose, interpreted languages (the jupyter languages, Julia/Python/R) are the right choice. Traditionally, once you had some Python/R/Julia model that worked and had to be deployed, you asked the ML/Big Data engineers to "translate" your cool model into a language that performed well (Java/Scala usually). Lately, with the current trend of making python/R bindings to Big Data/DL frameworks (which are not coded in python/R, that would be very inefficent) we have simply removed the translation step.
For sure, it seems like they can share the AST too, which is a big advantage for speed ([gometalinter actually re-parses the AST for every linter!](https://github.com/alecthomas/gometalinter/issues/380). [golangci-lint](https://github.com/golangci/golangci-lint) avoids this by vendoring and modifying every linter to support accepting an AST instance, I can't wait for this to become part of `go vet` and for linters to start implementing this!
A late, but still shameless plug. Try replacing the gzip library with pgzip which will do async compression and decompression which should be more effective: https://github.com/klauspost/pgzip
I think you are missing the point. I am a novice and have only started learning C and Go. I have barely learned the syntax, fundamentals, and libraries. So having dependency problems or wishing something did more than it currently did is way above my level of coding right now. The only project ideas I have is a basic CRUD application but it doesn't have any real value. That is why I was thinking about learning and contributing to an actual open source project first. It would help me understand how people much better than me write code and then the whole process of git and real projects. I never was keen on following tutorials that build some pointless thing for the sake of doing it. It tends to abstract and because there is no real world application I'm not as interested in improving it. 
FFS, they're not evil, they just have drawbacks (and advantages). Don't design your code to fall into a trap, and you'll be fine.
Really? Out of all the 18923479348723 Golang video tutorial on Youtube you didn't find any good ones? Hmm Just go on udemy. They have several really good ones and they're only 10 bucks. At least here in Germany. If that's different in your country, just google for some udemy coupons. 
I advice you to learn by practicing. Exercise.io is pretty good for that. Hope I helped
I think open source isnt the best option honestly. I mean, you can try it, but I really think you’ll find yourself disheartened. And if you dont want to follow tutorials, get a textbook instead. Answer the questions and go from there. Good luck.
I have a few books I’m reading but turning that theory into some real application is where I fall short. IDK what I can do with C or Go so idk what type of project to do. It’s like never painting before and given a blank canvas and being told paint the landscape without knowing any of the skills required to do it. 
No problem -- this advice applies across any language, not just Go, where you are doing networking (generally, I/O) bound work. The good thing about Go and it's error handling is it makes you think about these up front right at the call site where they happen, rather than do some Pokemon "gotta catch em all" exception handling. you want to set timeouts to have reasonable expectations of what your program will do in the event of the unexpected happening. This applies to databases, API calls, syscalls (doing stuff with files, etc), and there is typically always 3 variables: the connection itself (so timeout on the actual connection or transmission itself, the file pointer, the database connection, etc), the read side (on the server this might mean interpreting the request to figure out what the client is trying to ask it to do, so reading the JSON body of your POSt request, as an example, on the client side, this might be parsing the results, whether thats an XML feed, JSON again, or a stream of bytes -- think video or other media), and the write side, so that is writing data over the connection, typically you see this one in databases where say for example you sent 2 gigs of data to be written, well that db server is going to spend some time writing that data, and you expect 2 gigs to take X amount of time, so you set a write timeout on the server as an example to say ok if you take X + some reasonable amount of time to write this data, something is wrong -- maybe the network connection is experiencing intense packet loss so fetching the next sequence of bytes to write is hard, maybe the disk is severely fragmented and has slowed down writes, maybe that particular table is corrupted -- just some examples.
Split your database as micro databases and your doing 500k inserts over 10DBs. Or 100DBs hit 5M inserts per day. Trow it up on a NVME and see it improve even more. Let alone something like Optane. The issue is, that people think one Sqlite file = x databases in a single file, just like they are used to with mysql/postgresql. And they forget that sqlite allows for data micro servicing ( and if you really need some shared data, simply "attach" ). It even makes backups easier because you only backup databases that have any changes. The cold databases ( that you normally ended up backuping again and again with mysql / postgresql ) are ignored. Many people still think of Sqlite as it was 10 years ago, without wal mode, slower, etc.
I don't think they're saying anything other than Modules will land in 2019. There is in fact a whole section about 'getting it right' vs. 'getting it now.' I was surprised when I read the title, because I didn't suspect Go 2.0 to land this year, and it turns out the article isn't saying that at all.
&gt;We’re really embarking on what we call Go 2.0. Or, Go 2 — sorry no “point 0.” "Go 2.0" considered harmful?
Perhaps you should ask him to explain the request. It's impossible to describe how to achieve something without knowing what it actually is.
Are you asking to implement oAuth?
There is no situation in which an init function is the best way to solve a problem. I'm not sure I'd call them evil, either, but they're definitely always a red flag, and they can (and should) always be removed.
How would you propose using spf13/cobra (or even stdlib flags) without init()? I agree they're generally a smell, but they have legit uses.
I don't know of a single machine learning application that uses fractions in that way. Everything uses floats. Finance uses fixed point, and so also doesn't use fractions like that. It's a cute feature of some languages, but not one I've ever seriously seen used. If anything, it's a feature people need to work around as it gets in the way of high performance computing. 
Registration pattern like in image/decode and database/sql is best solved by init. Not by requiring developer to not only import a packages but also register it manually. And in general, any one time initialization thing is much better in init. So many times I caught hard to find bug exactly because I forgot to initialize something or did it wrong. The fact that execution of init has no defined order forces developers to not depend on it and prevents writing fragile code. Exactly the same as random select, map enumeration etc. &amp;#x200B; I can never understand these "never use thing X", "thing X is evil". Like with all things, you can always misuse it. Use it properly and embrace the advantages it provides.
https://tour.golang.org First google result btw
That domain is for sale
Exercism.io Sorry my phone has corrected the domain 
This is fkn amazing Thanks very much 
You are very welcome. It helps me to turn from python and ruby to golang:) 
Just simulate things of real life. A good one to start with may be something like an ATM machine which reads a card, ie a series of numbers, and asks for a pin. From there you can check your balance, add money, or take money out. &amp;#x200B; I've written some of the code. You'll need to fill in the TODOs. [https://gist.github.com/xibz/8734e20a3bee1490c8a50cd4430bdf33#file-atm](https://gist.github.com/xibz/8734e20a3bee1490c8a50cd4430bdf33#file-atm)
Over the years I learned that any technology related to XML should be avoided.
+1
Definitely one of the better ones I’ve seen. https://gophercises.com
One thing init can lead to annoying results when testing. You'll have to fire off the init whatever you want to test to build up the dependencies. Dependency injection is a nice way to get around using an init and a nice way to intialise only parts of your app for testing.
I doubt it, if only because the lexer automatically inserts semicolons at the end of lines, with some exceptions for common cases (line ends with opening brace/parenthesis, comma, etc). You might be able to make it auto-format around those cases, but I don't really see the value over just inserting it manually at that point.
It's your package. Not that hard to make it properly testable even in presence of init.
Im trying to shy away being dependent on a network connection, I messed around with this for hackernews.
remind me of (some author on internet) Some languages can be read by human, but not by machines, while others can be read by machines but not by humans. XML solves this problem by being readable to neither.
&gt; Machine learning needs high mathematical precision No. &gt; It's not enough for common operations like currency convertions. That justification does not support your previous claim. And floating point numbers are never suitable for representing currencies, which is an issue that all programming languages have. Currencies can be correctly represented by using BCD.
Both spf13/cobra and stdlib flags are poorly designed insofar as they use globals. Both packages would be improved by removing globals and requiring callers to instantiate an e.g. flag.FlagSet independently in the calling code, and operating on that directly.
&gt; Registration pattern like in image/decode and database/sql is best solved by init. This pattern has proved to be a mistake. It can't be removed, but no new code should be written to copy it.
If you install golangci-lint, one of the ones it comes with that you can turn on is a long-line checker. Integrate that into your source control commit process and it should do what you want.
Care to elaborate?
[removed]
[removed]
The registration pattern was a particularly tragic mistake with database/sql, because it's often one of the first things beginners run into, and it's very magical and non-intuitive. It leaves the wrong impression about Go the language and the rest of the standard library.
Lol generics
Sometimes one’s occupation requires working with existing legacy technologies, in which case, I’d rather have a solid library for doing so.
&gt; I would have thought any method of appending data would still involve reading out the data, and writing it back in Open the file, [seek to the end](https://golang.org/pkg/os/#File.Seek), then start writing your data. There is no reason to read the existing contents into memory if you're just appending. It's expensive (both in IO and memory).
&gt;gowitek.com/iot/bl... It supports more file types than DetectContectType. DetectContentType only supports a limited number of files types (mostly image types, fonts, and audio and video types). More details on the file types it detects is provided here: [https://golang.org/src/net/http/sniff.go](https://golang.org/src/net/http/sniff.go)
Oh I see, that does make more sense. Thanks for your feedback
This is inefficient because you read the entire file into memory. Go provides streaming I/O which allows you to read from a reader and write to a writer piecemeal. So the efficient way to do this would be something like: ``` in, err := os.Open("test.txt") if err != nil { // handle error } out, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0600) if err != nil { // handle error } io.Copy(out, in) ``` `io.Copy()` will, in a loop, read about 32k byte chunks from `test.txt` and write them to your `filename` until it either gets an `os.EOF` (or some other error) from the reader (in this case, `in`) or it gets some error from the writer (unlikely -- but for example, if the filesystem fills up before the copy completes).
Ah yes. This is useful, thanks
If you want all the file types supported by file, you can always go with [https://github.com/rakyll/magicmime](https://github.com/rakyll/magicmime) but this has a dependency on the libmagic library. I think the idea behind h2non/filetype is to provide you with enough file types to be useful (and more than the standard library provides via DetectContentType()) without requiring libmagic (think of the use cases where you are developing a cross-platform application or you don't want to have an external dependency).
To be more specific, both [golanci-lint](https://github.com/golangci/golangci-lint) and [gometalinter](https://github.com/alecthomas/gometalinter) use a tool called [LLL](https://github.com/walle/lll) to lint long lines, and by default it warns about lines longer than 80 characters.
I just developed Stockholm Syndrome for the way errors are handled. For all its verbosity and mind bending arrogance, I actually like not having exceptions. It makes it easier to reason about. 
* The way you dispatch the command is wonky. I'd recommend something like the following instead: ``` func dispatchCommand(commands map[string]func(string), command string) { if f, exists := commands[command]; exists { f("") } return } ``` 
Here’s the same comment using the “Old Reddit Format”: Ref: https://old.reddit.com/r/golang/comments/anljkg/a/ --- The way you dispatch the command is wonky. I'd recommend something like the following instead: func dispatchCommand(commands map[string]func(string), command string) { if f, exists := commands[command]; exists { f("") } return } The bufio stuff you're doing is wonky. i'd do something like: addCommand("l", doLook) addCommand("lo", doLook) addCommand("loo", doLook) addCommand("look", doLook) scanner := bufio.NewScanner(os.Stdin) for { fmt.Print("Enter a command: ") if !scanner.Scan() { break } fmt.Println(scanner.Text()) } I think a full working copy of what you're trying to do is below (though i think there are still some major problems): https://play.golang.org/p/Il63kBwGKA0
try this. ``` package main import ( "bufio" "fmt" "os" "strings" ) func doLook(args ...string) error { fmt.Printf("you looked: %v\n", args) return nil } func main() { commands := map[string]func(...string) error{ "l": doLook, "lo": doLook, "loo": doLook, "look": doLook, } for scn := bufio.NewScanner(os.Stdin); func() bool { fmt.Print("enter a command: "); return scn.Scan() }(); { argv := strings.Fields(scn.Text()) f, exists := commands[argv[0]] if !exists { continue } if err := f(argv[1:]...); err != nil { fmt.Println(err) } } } ```
cool thank you very much for this. I will take a look at this. 
Just as a note, other languages you'll see will do this as well. This isn't a pattern exclusive to go. ;)
Is this thread where I complain there aren’t native Go bindings for Cuda?
It’s good right that it’s getting this?
&gt; We’re going to launch things in stages. We expect in early second quarter that we’ll have what we’ll call an Alpha release of this. It’s going to be public, we’re going to let people work on it, and then we’re going to work throughout the rest of Q2 and into Q3 to have a fully stable release. All of this is leading up to Go 1.13, which will out in August, which will have modules on by default. That’s the major feature in that release. modules on by default should speedup adoption and put the nail on the coffin of GOPATH.
Easier? I’d say possible. There’s no real way to know what happens with exceptions. Even worse, it’s used for normal program flow in some languages and frameworks. Exceptions are far worse than gotos in that there’s no structure. 
Generic isn’t a good thing, and I fail to see why people think so. It vastly increases the complexity of everything from compiler to language to frameworks to applications. I’ve spent the last 20 years coding. I did C++ for about 10 years, I coded my fair share of Java, I’ve coded in swift. My experience is that genetics complicates things, especially if you bring in new people to a project. It’s clever magic through and through. Go check out Andrei Alexandrescu‘s work on templates for an example how complex things get. Golang is great because it has avoided complexity. Generics will remove that. Generics is complexity. 
I agree
Like I said I found a good one on YouTube that was at the end of super basics. And instead of trying and hoping to find a good one that I don't know if it is actually good I came to ask people that I thought would know. I didn't expect some kind of Spanish Inquisition
&gt; Care to elaborate? He's saying its much simpler to have a constructor that returns a driver that you can then pass into Open versus making Open take the name of the driver and consult a global registry to grab it.
This is actually great. Very much something I have been looking for. I was using the official tutorial site for it but it felt like teaching myself Spanish using only a textbook which was not easy reading. Thankyou
Yeah I tried that but it felt like learning from a text book and I wasn't able to put what I learned into practice which is why I moved to YouTube video tutorials as a base instead
I thought so as well I was told it would be easier to use the addCommand() though because I will be adding multiple command options to the map later on. I've been told to use global variables as little as possible but I could not think of another way around it, Also, for the dispatchCommand() if the user did type one of the available commands how do I call it after finding it using the function? Thank you very much!!!!!!
Thanks kyou I will try this one and the exercism.io I was told about as well. 
Wow thanks! This is a great start. Think I want to finish the book on C before I start this though. The fact that you just made this example code for me today is what I was talking about me being a complete novice. I didn't understand half of the code you wrote but I'll try and learn it.
I really hope Go doesn't get generics or "better" error handling and I don't think I'm alone in that.
I have never been able to understand exceptions. I can understand how they work, but why would someone use them instead of returns? The best I’ve been able to come up with is that they became popular in a time when multiple return values was rare, generally speaking. So you can get your data or get an error, but not both, unless you’re dealing with pointers or return objects, which are pretty gross. They work, sure, but whenever I see them I want to cry. Swift has a nice try syntax keyword that effectively turns it into an in-line call. I’m starting to love swift almost as much as I love go. 
Honestly, generics are just another word for interfaces. There, I said it. There are some things that are nicer with generics. I do miss them with Go. But once you embrace interfaces, the need for generics totally disappears. And once you embrace interfaces, you want them in other languages so you use generics which more or less do the same thing. There are some mostly academic differences, but for the average programmer, it’s the same thing. 
I think Swift got it right here. Under the hood, Swift errors work like Go, but with native language support that looks kind of like exception handling. You know exactly which functions can return an error, the compiler forces you to deal with them rather than automatically forward them up if you don’t, and you can handle all errors for a collection of actions in a single place.
Wait, they finally caved on generics? I haven't been paying attention in awhile...
Nothing has really changed. Generics has always been "when we find an implementation that isn't terrible" and, as even the link tells, it remains that way. With that said, there is a proposal has come forward that seems promising. Under more scrutiny it may end up being filed under terrible like all the others that have come before it, but there is a a chance that it will be considered good. If so, then Go will get generics.
I'm not a fan of XML either. OPC defines the file structure as XML files, but these are all managed by this package and the clients using it only need to worry about their content, which can be in any format.
Go still has exceptions (panic/recover). It just rightfully keeps them for exceptions, not usuals.
I appreciate that you like it. Enjoy 😉
Often it does. Now again, as I've said before, for common businesses cases it's not usually required. But we are not talking here about common business cases. We are talking here about such things as AI deciding the length of imprisonment of a convict. Or molecule modeling / simulations on experimental medicine in pharmacy, or making colossal calculus in astrophysics. Claiming that one does serious machine learning / big data analysis and continue to work with something like brain.js or any general purpose language for that matter on customer behavior in your app is .. like doing wordpress and claiming you're a software engineer. It simply doesn't compare. It's in whole different level. I choked a little on my morning coffee because I imagined that you suggested crypto here, as I'm not aware of what that acronym stands for. There are specific libraries for dealing with lack of precision. However language like Python has it built in. Languages like Julia has even more tools for doing all sorts of precise calculus. &amp;#x200B; &amp;#x200B;
How many molecular modelling and chemical simulation calculus in pharmacy you've made? Not aiming here to be condescending but it seems we aren't even talking about the same thing here. I work in finance. I'm not sure what you mean by "fixed point".
&gt; AI deciding the length of imprisonment of a convict. Seriously, where do you get that from? 32-bit floating point numbers produce a digits of precision, and 64-bit provides 16 digits of precision. &gt; Or molecule modeling / simulations on experimental medicine in pharmacy Please provide a citation to an existing project, where the ML requires &gt; 64 bit FP numbers. &amp;nbsp: BCD stands for Binary Coded Decimal. 
US courts, it's applied when deciding on the lenght of the sentence, there was quite a scandal when it turned out that AI punishes afro americans harsher than caucasians, that's a whole different story though. Since final judgement is pushed by jury and not the judge like in continental law it's not as much of a big deal. Will I need to do the leg work for you? \&gt; 32-bit floating point numbers produce a digits of precision, and 64-bit provides 16 digits of precision. Irrelevant. Problem is not the expression of precision, but that computers can't do precise calculations with floating point numbers. And values are being lost in the process. \&gt; Please provide a citation to an existing project, where the ML algorithm requires &gt; 64 bit FP numbers. How about you go read some common applications of Julia? Like risk calculation in insurance and when come back. Again, not going to do the leg work for you. Want to learn go outside and do. One's ignorance is not my responsibility. And I'm late for job at this point.
Give me some advice on how to solve my problem without generics. In multiple places in my application I need a function that takes a slice of functions, executes them concurrently, then returns a slice with the results. The results are all the same, so it will be a slice of the same return type of the function. With generics, the solution is func DoConcurrently(T) (...func() T) []T { ... } Right now, I need to copy/paste the same code for each place I need this logic.
We all know that ML is being used to decide the length of prison sentences. It should've been obvious that I was asking about how you could support your claim that &gt; 64-bit floating point numbers are required for those ML algorithms? &amp;nbsp; And the same with your claim that &gt; 64 bit FP numbers are required for ML molecular model simulations. &amp;nbsp; We are not talking about non ML algorithms. Do you understand?
additionally, always think about your maximum supported content size for a server and client, support `func LimitReader(r` `Reader``, n` `int64``)` `Reader` think about a webclient that improperly loops a file and continuously uploads megabytes of data to places where you only expect a few KiB as JSON. Or a hijacked webserver, that sends the client (you) an unzipped - zip-bomb killing your application, or worse, filling up your diskspace
You're not the only one. I feel that handling the errors explicitly not only makes you think differently about the code, but (for me) also helps get into the testing mindset.
By having a relative who works in Spain. He's a chemist who works on molecule modelling software for intended use of pharmacy companies. If you expect me to waste my time on your ignorance, I wont. Do your own leg work. 
“XML is like violence: if it doesn’t solve your problem, you’re not using enough of it.”
No, you've been making, and continue to make, broad-unsubtantiated claims about the suitability of 64-bit floating point arithmetic for ML algorithms. Also, learn to differentiate ML from non-ML algorithms. Admit that you cannot substantiate your claims.
&gt; genetics complicates things, especially if you bring in new people to a project. Racist
Google's TPU (tensor processing unit, used for ML) CPUs use 16 and 32-bit floating point arithmetic. Look https://cloud.google.com/tpu/docs/system-architecture 
You said it yourself, without generics, you'd need to copy/paste the code for each piece of logic where this is needed. So you can see how people can be opposed to generics, as they will complicate things even more, where a simple solution does exist. It's like `if err != nil`, where people initially pouted about the verbosity, but IMO a part of the community has accepted it, and actually prefer it to exceptions.
You can often resolve this kind of generic problem with closure. https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5 tldr : look at sort in stdlib 
Well yeah that works, however I now need redundant, repeating code that I have to test. It's a new point of failure, and extra cognitive load on new developers. Generics everywhere are terrible, I agree, but repeating code is not the solution to this problem and if it isn't generics and can't be type casting after the fact, what is it? 
Thank you for this, will dig into it tonight
to spend my last comment: &gt; Yann LeCun, one of the pioneers of deep learning, has noted: "Getting excellent results on ImageNet is easily achieved with a convolutional net with something like 8- to 16-bit precision on the neuron states and weights."
Yes, Golang does have some shortcomings however if I were to tell you why I absolutely love Golang, then these would be my top points: 1) Declare only if you need it. Go lang restrict/forces you to remove unused variables. 2) Golang has a garbage collector I don't need to take care of any garbage collection related stuff, go handles it. 3) Golang keeps the bugs away Since it is a compiled language, with very strict typification, and it is statically typed, developers have to be more accurate and attentive, so the code is neater and safer. 4) Golang provides all necessary components/features to achieve oops implementation It provides type struct and association of it with methods to achieve class like functionality. 5) Code compiles very quickly. It provides a model for software construction that makes dependency analysis easy and avoids much of the overhead of C-style include files and libraries. 6) Native concurrency Go uses goroutines, like in Java which uses OS threads. however, drastic distinctions between their concurrency models and how they handle threads. 7) Platform independent Go is compiled to machine code and is executed directly.
I would lean toward making functions likes 'DoConcurrently' use func() and function composition, removing all concrete types in the 'generic functions' without replacing them with interface{}: func DoConcurrently(fns ...func()) functions := []func() string { ... } items := make([]string, len(functions) concurrentFunctions := make([]func(), len(functions)) for idx, f := range functions { concurrentFunctions[idx] = func(idx int, f func() string) func() { return func() { items[idx] = f() } }(idx, f) } DoConcurrently(concurrentFunctions...) because then you same DoConcurrent function can then utilize different types and primitives besides just slices. it can also hook into retry logic, you can do multi-return values so that you can track errors in concurrent pipelines, and any limitations that generics would give you are completely avoided. functions := []func() string { ... } ch := make(chan string) concurrentFunctions := make([]func(), len(functions)) for idx, f := range functions { concurrentFunctions[idx] = func(f func() string) func() { return func() { ch &lt;- f() } }(f) } DoConcurrently(concurrentFunctions...) Eventually, then, you can adapt different function types into the same conccurrent pipeline: func func1() string { ... } func func2() int { ... } func func3(ctx context.Context) string { ... } func listStrInsert(l []string, i int, f func() string) func() { return func() { l[i] = f() } } l := make([]string, 2) DoConcurrently(listStrInsert(l, 0, func1), listStrInsert(l, 1, intToStringFn(func2)), listStrInsert(l, 2, withContextStringFn(ctx, func3)) you do end up with many small, types functions that could use generics but they are small utility functions that are cheap to write, cheap to test, and compose nicely. 
&gt; It’s clever magic through and through. Magic is precisely what generics _are not_. In fact, adding generics leads to _removal_ of magic - with no generics in Go you have purely magical types like slice, channel, and map. &gt; especially if you bring in new people to a project From my experience newbies don't have much trouble understanding the _usage_ of generic types since reasonably-written generic types are typically quite easy to use. After all, this is evident even from slices and maps in Go. And newbies typically don't venture into creating custom generic types. Besides, Go is very unlikely to add complex generics as in C++ or Rust or Haskell, much more likely it'll be something simpler like the ones in Java or TypeScript or the like. I think the only valid point here against generics is that it inceases compiler complexity and slows it down. That is certainly a valid point and something to consider. But then again, simpler form of generics have smaller impact in this area. 
Well, the extra cognitive load can be either on repeating code and additional tests, or to how a function can handle different types on the same way. I'm not saying which of them is better, one could argue for both. For example, one might want to have a `func Multiply(T) (... []T) []T { ... }` that can either take as inputs integers, vectors, and matrices, and well, multiplies them. You could see how it could be tiresome to keep track of what goes in and out of this function.
Curious why Go appeared to give some hiccups during the rampup phase.
Not yet. Had a project that I wanted to use, but it turned out I didn't need it. On how Gorgonia creates more interpretable models: the VMs in Gorgonia do not seem like it, but are actually quite composable. Putting them together allows you to do weird things like reading matrices of a disjoint subset of the same graph parallely while training the neural network. To do the same thing on TF would require code that is hard to read. Write up coming soon once I verify things work as intended
Basic 2nd and 3rd year econometrics gets you covered for most of machine learning. If you know how to do derive first and 2nd order derivations, you're sorted. The names are different in ML but the techniques are the same (for example, maximum likelihood in econometrics is the same thing as euclidean costs/distance in ML...). One thing is classification is a lot more popular in ML, hence a greater focus on logit than regressions. If you are familiar with how to get to a probit/logit, you are familiar with classification tasks. Now just write the program that implements your derivations!
&gt; I actually like not having exceptions Luckily, exceptions aren't the only alternative to C-style errors. 
[removed]
&gt; Go supports multiple interface bounds on function params just fine. Oh, okay, thanks. &gt; It's silly to repeat such an inline declaration even twice. I disagree, I find the opposite - declaring various cartesian products of interfaces - to be pretty silly. From my point of view the inline declaration of multiple requirements is much more transparent. However this is higly subjective and a matter of taste I guess so your opinion here is no less valid than mine :) &gt; This differs _significantly_ from Java because you don't have to pre-declare compliance with those interfaces. If you implement something that has the correct Read, Write, and Close methods, then you have an `io.ReadWriteCloser`. I agree this is a significant different. But the difference is two-fold: a) that interfaces can be implemented ad-hoc, and b) that they are implcitly implemented simply by implementing the right set of member functions. I very much like the a), it makes things much more flexible and simpler at the same time. OTOH I think b) is a step in a really bad direction and seems to me to be a violation of Go's own principles of having things explicit rather than implicit. Also it makes it unnecessarily hard to match concrete types and interfaces when reading unfamiliar codebases. In codebases with explicit interfaces implementation (whether ad-hoc or not) it's much easier for me to find example usages of some interface, which is often useful when trying to grok why some yet-unfamiliar interface is designed the way it is. 
Why Elixir uses so much CPU?
Shame audio is a bit poor
[removed]
ok, database/sql can be replaced by dependency injection but it doesn't really improve anything. What about image/decode? One time package initialization? One time initialization could be solved by \`sync.Once\` in some cases but I find it harder to read and understand. It's also more error prone as you have to put the call in every relevant place. But there're other use cases in the runtime for which I don't see an obvious solution without init. Usually lower level stuff - global callbacks, cmd arguments, signals.
Yes, this is inefficient but if your file is under gigabytes and your program is a batch program that doesn't run continuously, then it's OK. Do the best thing that is clear for you, not the clever and the most optimized.
I didn't find that to be the case when learning Go.
If you want an open source solution for OAuth / OpenID Connect, then I'd check out Keycloak personally. It's a very feature-complete solution for authn/z, and provides optional service accounts for clients (which is what you seem to be after).
&gt;f(argv\[1:\]...) This calls the function with all the passed values already.
Why videos for [https://fosdem.org/2019/schedule/event/kubernetesclusterfuck/](https://fosdem.org/2019/schedule/event/kubernetesclusterfuck/) is not exists?
Not *yet*, videos are coming up slowly
Lol, nodejs were tested without cluster enabled. That means, nodejs were single-core limited, while Go and Elixir used all available CPU cores.
I mean, it's pretty incredible you have Node - a Javascript runtime - competing against those languages - without using it's clustering paradigm. 
How would that improve anything? Saying it would be better or "globals are bad" is not an argument. Globals in Go are idiomatic and don't introduce the kind of problems that usually attributed to them.
My guess would be that the goroutines where allocating during a gc phase. The gc can then use that goroutine to assist in marking. This only ocurs when the heap-size growth. 
Doesn’t that invalidate the whole test? 
As you yourself pointed out in your earlier post, Julia being as nearly as fast as Go changes little. Go is already in production systems of numerous new age companies. It reigns supreme there because of its established ecosystem and fast time to production. Those companies not going to ditch Go in favor of Julia just because its used by academics for ML if the same thing could be done nearly just as well done in Go. As chewxy pointed out, there are already installations of ML built on Go in production. &amp;#x200B; Cloudflare for instance has a fair amount of their back-end written in Go and they do use ML for several things. I do not know for certain if their ML applications are in Go, but there is a very good chance that they are in Go or C. &amp;#x200B; Go being tied to Google is hardly any reason for its non-acceptance. C was tied to Bell Labs, Java was tied to Sun and now Oracle, C# was tied to Microsoft. Shift is tied to Apple. Every general purpose language in use is tied to one corporate or the other for its continued evolution and adoption even if the language specs are open. Its not a bad thing. My own workplace (a $8 billion company) has Java, C#, Python, PHP, node.js and Go in Production. I was the one who inducted Go into my workplace and Google's link to Go is one of the key points of my sales pitch apart from the technical benefits. &amp;#x200B;