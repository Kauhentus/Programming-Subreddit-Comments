So i'm no expert on what you're doing but I feel extracting a lot of code from main into wel-named functions would really help readability. try and aim for a single level of abstraction per function. Your main should read like a book and make it clear what your doing from a high level abstract perspective, and leave the details on how to do that to the functions called in main. Getting more technical the deeper you nest. http://principles-wiki.net/principles:single_level_of_abstraction
Why do you use goto statements ? - https://github.com/itsmontoya/mailbox/blob/master/mailbox.go#L44 - https://github.com/itsmontoya/mailbox/blob/master/mailbox.go#L59 - https://github.com/itsmontoya/mailbox/blob/master/mailbox.go#L119 From my experience its not a good to control the program flow with goto statements. In all those cases you can use normal go flow control statements. 
Thank you! I completely agree, and in fact a wordpress-like environment is exactly what this is for 
I was running postfix mailserver from home about 8 years ago, and both hotmail and gmail servers refused any mails delivered from smtp servers not on their whitelist.
From home could be the issue, I've heard that they blacklist whole ranges of home ISPs to prevent bots from spamming. As I said I have no issues from OVH, I'm using their cheapest VPS which is £2.99/mo. I have both SPF and DKIM, and reverse DNS is setup for the IP. I don't know if it makes any difference, but I also have port 25 open so i look more like a proper mail server - I don't accept or relay any mail, but will do the SMTP HELO handshake.
That's the way! Looks better! :) Just dont understand why did I get downvoted over my initial comment =\ 
It is definitely interesting
Run a proper mail server. If you want to play nicely with the big kids, there's practically no way around it. If there were an easy and reliable way to send mails from arbitrary (read not properly setup for a domain) IPs, spammers would use it all the time. That's why those quick and dirty solutions will ultimately end in more trouble than the setup of a proper mail server for your domain would have been.
OK, whose going to use [GopherJS](https://github.com/gopherjs/gopherjs) to compile this to Javascript?
Some mx do a simple reverse DNS to check. No need for SPF to fail. If there were an easy and reliable way to send from arbitrary IPs without proper DNS, spammers would use it and we would close it up. Also, not only "residential" but also short-lived VMs can be in blocked dynamic IP ranges.
Everybody saying this looks interesting, I'm gonna shake things up and say this is AWESOME, because it is. Cool project!
"just" start. -- Seriously, go give it a try and it will become very evident right away what you do not understand yet and what you need to learn in order to go further. I have found that this is the best way to do most things like this, in general.
It use very similar characters to trick you into thinking it's the same name. edit: Well, it seems a bit more more tricky as the second setVаlue is in ascii "73:65:74:56:1f:6c:75:65". I'm not sure how the control character '1f' comes from 'a' but anyways, it's not function overloading :)
Neat. I want to see your CMS. 
The following function has a [timing side-channel leak](https://codahale.com/a-lesson-in-timing-attacks/). func CompareHexHash(hash func() hash.Hash, str, hexStr, key string) (bool, error) { kb, err := hex.DecodeString(key) if err != nil { return false, err } return HmacToHex(hash, str, kb) == hexStr, err } You should use a constant time compare function (one simple way is to sum the difference of each byte in the two strings being compared and return true if 0 and false otherwise). Also, you wouldn't want to use HMAC to store customer passwords. Use a [password based hash function](https://en.wikipedia.org/wiki/PBKDF2) such as PBKDF2, SCrypt, (or the latest and greatest) Argon2. Lastly: [read this](https://www.bsdcan.org/2010/schedule/attachments/135_crypto1hr.pdf).
Indeed `andlabs/ui` is not bad but I still wish we had a pure Go gui library with no dependencies so that we can easily cross compile and share it as a single binary in the standard Go fashion. I'm keeping my fingers crossed for `x/exp/shiny` but development seems pretty slow. :(
Thanks for pointing to the "read this" slides. A must-read for every crypto newbie, very insightful! Are the do's and don't's still up to date? (The slides are from 2010). 
It is mostly up to date. Curve25519 ECDH is somewhat trivial to implement now that we have [rfc7748](https://tools.ietf.org/html/rfc7748). ChaCha20/Poly1305 AEAD is also trivial to implement, again thanks to [rfc7539](https://tools.ietf.org/html/rfc7539). TLS is showing age we now have decent alternatives like [noise](http://noiseprotocol.org/). A lot of these primitives that /u/perciva warned against in those slides are no longer accurate since we now have good documents spelling out how to do a correct implementation.
Thanks!
For better or worse, this is how I've learned the most about coding.
The gap above the nose is intentional, for eyeballs insertion?
Working on a release page. Will PM you.
Where did you get the model from?
Oh yeah, totally forgot! https://github.com/StickmanVentures/go-gopher-model/tree/master/3d-printable Printed on form 1
No problem. Actually Go has [hmac](https://golang.org/pkg/crypto/hmac/) and it includes a [constant-time compare function](https://golang.org/src/crypto/hmac/hmac.go?s=2371:2405#L83). No need to write one in this case. Anyway good luck with this stuff. When using cryptography or implementing any kind of security, you just need to be extra careful. Even the most subtle programming errors [might become the next heartbleed](https://en.wikipedia.org/wiki/Heartbleed).
I will be careful. Also, I fixed it based on your advice. Thanks :)
It doesn't seem that the readme is very clear on the features it adds or advantages over HCL - is it mainly the includes / mixins?
&gt; Maps and slices are not pointer types, mainly because append(slice,...) mechanics. surely, maps and slices are not pointer types, they are normal nono-pointer value types. 
&gt; Maps and slices are not pointer types, mainly because append(slice,...) mechanics. surely, maps and slices are not pointer types, they are normal non-pointer value types. 
How does this compare to otto? 
*sniff* ah shucks! but seriously....Go has become my default language, and 98% of the time it is the best solution. Thanks!!
Write a function that takes a data structure of interface{} type and calls it might help, hint: you need to accept the function as an interface too. This means you can only call it using call slice, or assert it from a known type. The template package is an example of something that has to do this. https://golang.org/pkg/text/template/#FuncMap
And many more years to Go...
Otto is a very straighforward implementation of the ECMAScript spec. I used a few tricks trying to improve performance and reduce memory usage: * the code is converted into a set of instructions and is run on a stack based VM; * functions that don't form closures use stack instead of allocating a separate environment record; * 'simple' properties (writable, configurable and enumerable) are stored directly without using wrappers; * numbers remain integers where possible; * arguments object is not created if not used. Some examples (like the [fib(35) test]( https://github.com/yuin/gopher-lua/wiki/Benchmarks)) run about 15 times faster than otto. There are no trade offs other that it hasn't been tested as widely as otto and may (and probably does) contain bugs. No additional APIs have been implemented but the main idea is, like with otto, that you can pass any Go type (including structs and interfaces) and use them as native JS objects. 
Post it to /r/golang ;)
I will as soon as I'm not so horrified by my own lack of documentation :)
Generators!!! Everything and all of the time!
I have [another one](http://i.imgur.com/MYrC67t.png). He always carefully watching me :D
The API is similar but not fully compatible. It also uses a slightly different approach when it comes to converting Go types into JS types and vice versa: otto for example would "collapse" any custom primitive types into JS primitives, so when the value is exported the original Go type is lost. Goja maintains the type and the imported value looks like JS Number or Boolean. When exporting arrays otto tries to guess the type of the array element, whereas goja will always export into []interface{}. If you want to coerce into a specific type, use Runtime.ExportTo(). There is no documentation other than what's in Readme and [godoc](https://godoc.org/github.com/dop251/goja), sorry.
This is great and I appreciate the info you've shared here! I'll be playing with this tonight. :)
Of course, but, this is purpose-built for a Wordpress-similar install where the system needs to send something like an account recovery email. Quite unlikely that someone will be able to configure all that's necessary to run a full mail server, or for me (or another package dev) to automate in such a way that isn't overly complicated. As far as I've tested, with the proper SPF records, there shouldn't be many issues in the majority of cases.
We had a system at $WORK that used Rhino to run customer-authored, server-side Javascript. A feature to help simplify the concepts for non-programmer customers was to pause and ask the client for more information. Rather than relying on server-side sticky sessions we would just save the entire VM state to the database and thaw it out when the next HTTP request came in (that contained the answer the script needed). It allowed our customers to write stateful, easy-to-read Javascript but service it via a cluster of servers over a stateless protocol. Not a common use case, but based on that experience I'm always looking for other tools that might work for that type of system.
You, and I mean this in the best way possible, you and your coworkers belong in the looney bin.
Is bcrypt2 still good for use?
When you say independently, you mean as a separate repository? Or separate pkg in the same repo? I'm not sure. It's a very small package, and IMO it's ok to just import it for the `Wrap` function, even if you don't end up using the `CaptureMetrics` one. What do you think?
Don't recall any cryptanalysis but I think both PBKDF2 and scrypt are easier to tune (my opinion). Edit: sorry, PBKDF2 doesn't really compare to bcrypt since it's not memory hard, but scrypt does incorporate the use of PBKDF2. 
As a C veteran, I find Go refreshing and unique. After C, Go and Rust are two languages which make me want to program more. :) Good job on Go. PS:- Please add Generics for 2.0 release, would love to have a zero cost Generic abstraction, can ditch C++ for good.
Awesome work as always! I really appreciate these episodes
Choosing any tool "for anything" over anything else is fundamentally a mistake. Choose the right tool for your task, and don't be afraid to switch around. Go is incredibly good for building CLI tooling and network/performance dependent applications (daemons, monitoring tools, infrastructure tooling, etc), but for many other tasks there are languages/tools that will work better than Go :) 
Go likes being on a distributed (or atleast any) service system like a webserver or a database. That's where Gophers feel at home. Or the command line. C# on the other hand is probably the next best thing to z\*\*\*\*\* for developing a GUI client. That's atleast my take on it; Go for CLI and Servers, C# for GUI (on Windows).
Because I don't use Windows, and right now .NET's promises to be fully cross-platform are just that -- promises.
ha! Says a soul who wasn't tried actually doing that I'm guessing. You can *technically* compile and run some things, and even use some nuget packages, but you can't use nuget 3.* yet, and many things don't quite work; the package.json format is depreciated and the new format isn't fully supported yet. Once Rider is out of EAP and doesn't crash any more (to be fair, it only crashes about 3 or 4 times an hour at the moment) at least there will be a compelling IDE story for it, but its *certainly* not there yet, and 'runs perfectly on linux' is flat out not true. Try it. You'll immediately see that it's far from perfect. Its usable; barely, but definitely usable. You'll want to wait at least a few months before betting on it as a platform though. I don't think there's any real decision on the .Net standard vs. .Net core yet is there? 
MsSql is one thing from MS I love, trust, and will always defend. It ain't perfect, but it has rarely let me down. I've built so many systems that live on top of it... Let me ask you, do you interface much with sql server from Go? If so, how has that been working for you?
My experience jives in that I've frequently worked with programmers who were not all experienced geniuses, but I've also worked with academics who couldn't code maintainable (or sometimes even working more than once) code, and some experienced geniuses who could solve any problem, but not necessarily in a way that anyone else could work on. It has sometimes seemed like great programmers who write selfless code are a minority. Regardless of how hot you think you (or others) are as a programmer, I think that you're better off writing code that's easily maintained by anyone who might follow you in the minimum amount of time, and Go can help do that (although not enforce), not just in terms of the simple language, but also in terms of the no hassle code documentation and testing. I quite like the saying "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live." and feel like Go helps to point you in the right initial direction for that and good sensibilities and habits can take you the rest of the way.
Yeah honestly not sure why #2 was even included... Go was built to favor simplicity as a function of design. You should be able to look at a any section of code and be able to impliciy understand it. This leads to an interesting dynamic. In Go I find I take about 25% longer to write an equivalent section of code then most other languages, however, I find that time spent maintaining that same code is 2-3 times less expensive. All that simply due to the fact that in Go you tend to be able to hold the full concept of what is happening in your head with room to spare. Go tends to favor simple and clear over clever coding and that is HUGE for million+ line code bases. 
As someone that know and used both. They both have their use cases and different tooling. I would use C# over Go for any desktop(Windows)/mobile UI development because tooling is a lot better. I would use Go everywhere where i need control over allocations and performance (it's a lot easier to do with Go guarantees instead of using C# generational GC and hoping that all will go into first generation). I would use Go in every team that do not know either one, because Go is a lot simpler to learn than C# (with all it's concepts and rules). Simplicity is very strong argument to choose Go over C#. If i would need highly structured code with a lot of corporate constraints and composition (access restrictions private, public, protected, inheritance, generics etc.) I would choose C# because it shines there. As you see it depends, both are better than the other for different use cases, they have also common ground on which they are both good. It really boils down to your use case.
Right, but since that's just console apps, what's the advantage over Go?
Templating, especially for the web, is nowhere as nice as many other web based frameworks. I use go as everything right now and that is my biggest gripe. I plan on making go the brains of my web app, but have something else do the front end, whether that will be Angular/React/Vue or something like Laravel acting between I don't know yet.
No, everyone develops Electron-Apps now.
If you are not felling any pain points developing in .Net, then I don't see why you should switch. You can just learn Go for fun and not use it for work. For me, I never got to much into the .net platform and don't feel the need to as Go covers my needs. Microsoft does have some very good developer tools, but I'm not going to switch platform just for the tools.
I am using this github.com/alexbrainman/odbc for SQL Server in go and its working beautifully. Go is fast and everything "just works" The standard library probably has about 98% of what you would need to build a web app back end. The only real issue i've had is the lack of multiple results sets from SQL Server stored procedure support. This is arriving in Go 1.8 
I think it depends if the cost-benefit analysis makes sense to you. I don't see anything that .Net can, but Go cannot do. Go language spec is very small, 2-3 weekends and that's it. You are good to go. To me, that's a strength. Also, how's deployment story in .Net Core? Do you need to install a VM on every box? If it's anything like Java, there's an upgrade cost there that you don't have to pay in Go.
If you haven't already, go to the [Go tour](http://tour.golang.org). IIRC, it takes a couple hours and you should be able to write complete, interesting Go programs by the time you're done. Adding to that, the fact that you can learn a programming language to the point where you can be productive in *hours* (or at worst, a couple days) is a big selling point in and of itself. C# is a great language, but a few of my reasons for preferring Go are: 1. In Go a type definition is neither pointer nor value, it's just a type. Individual instances can be passed around by value or by reference and converted back and forth. This makes it *much* easier to reason about memory allocations and collection (Go also has escape analysis, which C# doesn't, at least not yet), and eliminates the need for copy constructors and other such things. 2. Go doesn't have classes (no extra runtime metadata on my object, though reflection still exists). In my opinion, C# would be much better if it only had its "struct" types, and passed these around by reference when necessary (see point 1). 3. Go doesn't have inheritance, it has interfaces for polymorphism and some sugar for automatic delegation ("struct embedding"). One fewer footgun. Building your project is 1 command (`go build`) if you have all of your dependencies installed, otherwise it's `go get &amp;&amp; go build`. 4. Simple build system. No project metadata files. Everything Just Works (this will be even more true in 1.8 when GOPATH defaults to $HOME/go). No runtime dependencies, so you can get a binary with `go build` and then pass it around to anyone on your platform. Want to compile for linux arm from your MacBook? `GOOS=linux GOARCH=arm go build`. Send the binary to whomever you want--there are literally no runtime dependencies besides a minimal OS (~~not even libc~~ this isn't quite true, see [conversation below](https://www.reddit.com/r/golang/comments/5cenu6/go_over_netc_why/d9w653v/)). Last I checked, there was no *practical* way to do this for .Net (though there were some experimental solutions). 5. Implicit interfaces. If I'm using your library, and I want to use one of your types to satisfy my interface, in C# I would have to create a new type that extends your type and implements my interface. In Go, I would just use your type and never think about it again. 6. Great standard library. Go's standard library covers JSON, Templating, HTTP (production grade), testing, benchmarking, etc, etc. BTW, `go test` will run your tests by default., `go test -bench .` will run your tests and benchmarks. 7. Standard formatting. Everyone uses the same style courtesy of `gofmt` (a program distributed with Go, which everyone binds to the save function in their text editor). 8. Documentation for free. No special syntax, `godoc` parses the comments above any public declaration and produces documentation. http://godoc.org does this for any repository path you pass it (e.g., http://godoc.org/github.com/russross/blackfriday). Did I mention you (and thus your entire team) can learn it in a couple hours?
+1 for the name.
I've been using https://github.com/denisenkom/go-mssqldb with patches for bulk inserts. I find that it is pretty easy to work with and performs well. I'm trying to make time to finish out some of the bits that are needed for bulk insert to support all data types.
I guess my main critique is, that people will assume this works *without* taking proper care to prevent false positives in spam detection. After all, if you went all the way to make your server a proper mail relay, it's only a small effort to install a standard mail server.
&gt; Choose the right tool for your task My advice too. And lastly, if you are a Windows + Visual Studio shop, you are probably better off with C#. 
I'm currently working on a typescript/react/go project, and I think these starter kits are a good idea because the old kits are out of date like you mention, and it really helps to see the minimal set of things needed to get a project running. That was one of my biggest roadblocks to being productive. I really like how you have: * incorporated tests that can be run pretty easily * some kind of CI integration * go report card * typescript 2.0 A couple of notes from my perspective: * I would rather use typescript 2.0's `@types` instead of `typings`, so I would not want to see the `typings.json` file (even though it has nothing in it) or folder. I'm pretty sure `immutablejs` comes with typings already. * I would rather use `npm` "scripts" instead of a make file. Though I understand your reason for doing so, and I think your use makes sense. But I'm always trying to use less tools, plus not every environment has make (windows). * I would rather see more linting too. The go report card already does a lot of linting on the go code, but there is none for the typescript. Not a huge deal though, and it does add more complexity. * I would rather see more dev-tools set up. I think one of the hardest things for our setup was just getting the webpack dev server running. It looks like this was a conscious decision on your part, so I understand. But I think the dev-tools are one of the best parts of using these technologies/frameworks. If you ever decide to do a "dev-tool-starter-kit-level-2", I would love to see a clean webpack dev server setup for a SPA (I'm still having trouble setting up the routes). One last thing I think would have been helpful to me is integrating some build-information into javascript. I wanted to be able to switch from a local dev server to a remote one without changing much code. So now I use webpack's define plugin to set the address of the server on build. Something like this: new webpack.DefinePlugin({ 'process.env.COMMIT': JSON.stringify(require('child_process').execSync('git rev-parse HEAD').toString().trim()), 'process.env.BUILD_TIME': JSON.stringify(new Date().toJSON()), 'process.env.NETWORK_ADDRESS': JSON.stringify(process.env.NETWORK_ADDRESS || 'https://localhost:8000'), }), Then I use `env NETWORK_ADDRESS=https://some.server npm build` or something similar. edit: formatting is hard.
Great tips! I really appreciate the feedback, and am drafting some issues to get these in the next iteration. Specifically, I was not aware of the webpack define plugin and that seems extremely useful. As for a L2 type kit you're reading my mind. I have been trying to put something like that together for several months now. What I _really_ want is a cli tool written in Go that does for a full stack, TypeScript/React driven SPA what `goa` already does for design-driven API. It would be awesome to, say, define a GraphQL query and have the tool parse that and autogenerate the requisite .ts and .go boilerplate.
lol: clever
That would be pretty interesting. I haven't used GraphQL but it sounds really nice! I think that would be a pretty interesting project. If you do start building something like that make sure you post it!
The decision to use a TS/React client with a Go server reflects design choices for the original internal project. edit: my terrible grammar.
I have a current project that has a service running as dotnet core(C#, on linux. I originally wanted to go with java/scala - but the guy i am doing it with couldn't quite get into java from a C# background, no idea why, anyway), its self contained and released as a docker container, the reason why we chose that is the awesome generics in C#, it was easy to map our entire model in it, we have migrations with EF, the restful controllers are easy to maintain and the testing frameworks seem nice enough. Now we needed a webserver aswell, and it didn't need a good ORM, generics etc. So i started to look around and i hadn't tried Go at this point, i just looked around the programming community for an alternative to C#, and its mainly Java/scala, Node.js, php, ruby, python and the other huge languages, and honestly there wasn't any of those that i really wanted to work with. Now, my first encounter with Go, i have been an avid Vim user for a bit more than 1 year now, and i love it, when i joined golang a few weeks ago and realized that alot of people actually develop with vim in this environment i googled their setup, i installed neovim, vim-go, deoplete, deoplete-go and it is freaking awesome, i have never had intelligent autocompletion in Vim before, jump to declaration etc. and it just makes a world of difference when you combine a simple programming language with the power of vim, and at the same time you feel like youre not too far from the steel either, then it also auto indents your code in a specific way everytime you save the file(so awesome), easy to generate HTML from the docs you write, type-safety, the project structure is very UNIX like(and clever in the sense that it structures your project based on source control structure(hadn't thouth of doing that before Go). On the other side we had C#, which is "fine" i suppose with its View in the MVC pattern but its never something that blew me away, i think i spend most of my time just copying documentation when i write in C#, everything is just so laid out for you, which is nice when you need to get the job done. But if you want a code flow that is not interrupted all the time of frameworks, online docs and perceived best practices - its very liberating to just jump into Go and code, if you call a method from the std library, you can jump to its implementation and actually understand what it does. And of course, Go is opensource, which just makes a world of difference when talking about tooling, editor support etc. i am allways surprised when i see a successful opensource project in C#, i dont know why, it just seems so unnatural to me, why anyone would spend so many hours improving a companys product without them being paid for it. I just think that alot of it boils down to the UNIX feel vs the Microsoft feel - and some people just like one over the other, and i am 100% for the way of developing on UNIX, in general i think its more programming oriented, while microsoft has a whole market of casual users they have to take care of. 
I find that .NET is something I need to work with a lot to remain an expert because new frameworks and libraries are always coming out. There is a lot of great stuff there for the taking if you want to integrate with Active Directory, and I love ASP.NET and Active Directory Services. That said, Go is nice because it's simple enough that I can use it as a hobby. I'd enjoy a job writing only Go, but I don't need one to keep up on the language. Where C# adds tooling, new syntax, and flexible features, Go instead tends to stay readable, understandable, and easy to leave and return to. Sometimes the explicit nature costs a few more lines of text, but it's a fantastic feeling. I find myself nearly never lost in a complicated codebase in Go where C# can hide a lot with its magic. I love both, and I feel no reason to choose between them since they both offer a lot of advantages. Both are more or less elegant for different things. I've recently been using Angular 2 with Go, so I don't use the Go templating much but really enjoy making the APIs in Go. Microsoft's Web API framework is also wonderful, but even now that I know it well, the magic is sometimes too thick for my tastes. Core is fantastic, but still different pros and cons between them all.
Fixed now. Many thanks.
Congrats on your several apps, that's clearly evidence that .net works perfectly for everyone on linux. Also evidence that you're a tool.
The OP was writing "alot" instead of "a lot". The former is not a word in the English language, but a common typo. Evidently this bot is "conjured" by said typo.
Another alternative https://github.com/uber-go/ratelimit
We should downvote this comment, not the one above.
I'd call it a matter of preference. .NET can be easy, but go is simple. If you want all the features, in a massive monolithic framework/toolset that insists on doing all sorts of black magic at runtime, like having settings in your applications config file get overridden by some other setting in a machine level config file, then .NET is for you If you want your team to never update their software, because it just works now and when they change the framework, they spend hours trying to get it to build and run again before giving up and going to the one person who actually understands all the subtle differences and breaking changes between each version, then .NET is for you. If you want a magic build button in your ide that just works, but is subtly different than the msbuild job used in your continuous integration, and leaves your devs tearing their hair out wondering why the same exact code results in 2 drastically different build outputs, then .NET is for you. On the other hand, if you want a very small set of orthogonal features that stay out of your way, let you do your job, and provide as little magic as possible, then maybe you should check out Go. Disclaimer: I actually quite like C# as a language, it's just .NET that I have issues with. I know Microsoft lifers who learn enough about .NET to be very productive with it. However, the "ease" of .NET also breeds a whole other, more common class of developers who learn enough to write code, but not enough to actually understand how the tooling builds it and the framework runs it. Eventually, it just gets very hard to maintain. As a polyglot, I want a language that my team and I can pick up and be productive with, leave alone for 2 years, and then pick up where we left off without the ecosystem having totally shifted out from under us. IMO C# has never been that language. Go is.
very nice
On the one hand I wish the presenter was a little more prepared, but on the other hand I kind of enjoyed the feeling that I was learning it at the same time he was.
Have you touched geometry support with that? That's a weird one I worry about.
I have probably lost years off my life spending time fiddling with web.config and app.config files. The amount of XML and magic is astounding under the guise of being "easy". More tools should exist that take the ceremony out of .NET development.
TypeScript helps with dynamic typing!
My guess the downvotes are because the use of the word 'perfectly' is very fanboyish. I haven't used it, so I'm in no position to judge, but it's hard to imagine a 1.0 release would be 'perfect'. Of course, there isn't any software anywhere that I'd call perfect.
Or the battle-tested : https://github.com/juju/ratelimit
It's a nice article but I don't see the reason for encrypting a file that you'll have to decrypt at some point and probably even automate decryption to automatically scale the infrastructure...
The problem with this sort of marketing posts is that it's pretty damn damaging to community. Whilst it provides no actual **value** (I myself couldn't outline a single thing), all it does is vain hype illusion. And then people start saying that the thing is a hype machine all over again just because there's so much of marketing noise around. It makes a bad impression on community itself to outsiders. Stop. Stop hyping Go just because you can. We know you use Go, some other people do too. [Unless](https://blog.cloudflare.com/go-at-cloudflare/), [you](https://blog.cloudflare.com/what-weve-been-doing-with-go/), [have](https://www.cockroachlabs.com/blog/outsmarting-go-dependencies-testing-code/), [something](https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/), [specific](https://www.cockroachlabs.com/blog/how-to-optimize-garbage-collection-in-go/) to say, don't do this. At this point it doesn't need much hype. How I see it, at this point Go needs to get overall respect and acclamation, which is usually deserved by building a big, robust community and reliable code bases. At this point seems like we are getting stuck in some technical limitations (see vendoring debate, aliases, generics start showing signs of depression, etc) and it all has absolutely nothing to with bloody marketing needs. Stop. Just stop. **Edit**: Moreover, what I find fascinating is that this piece, at the time of writing, stays upvoted (with 75% upvote ratio). Do people upvote it only because it mentions Go positively? It's the only explanation I can come up with, to me the piece itself provides no actual value. As it reflects the community attitude well, I find it more or less concerning.
Happy to hear someone might ind this useful. I also needed to stream arbitrary live stream of json logs to influxdb but via telegraf this library helped a lot.
Hey, they are different structs, therefore different types, therefore no overriding is happening. I expected you to show how they implement some interface but instead you referred to some other interface that did not use your two structs, though you implied they might , so you did not demonstrate `substitution` with an interface. Even if you had then that would not be overriding either. Im afraid I don't think you have demonstrated overriding. In the second example you do show embedding and function hiding, your implementation `Renderer` embeds `*blackfriday.Html` which I suppose has its own `BlockCode` func - you `Renderer` `BlockCode` hides `Html`'s Whilst some may call this a kind of overriding - it isnt int the true inheritance sense - you cant refer to any Base class, and there is no substitution, or dynamic dispatch in this case. This may explain better: https://play.golang.org/p/cUT7oygIlL 
Thank you for your comment! :) &gt; Whilst some may call this a kind of overriding - it isnt int the true inheritance sense I agree. I just wanted a short way to describe my goal. There is no overriding in Go in that sense. I thought this term could be used to describe how I solved my problem. I will make an edit to the post later today to clarify that.
One thing I hope GO developers do more often is proper version control. There's way too many packages out there that sit on master without any versioning at all lol.
wrote a similar library in python that did the same while using a qt app to interface between the phone and the library been meaning to port it over to go, just havent the time yet 
Goose bumps guaranteed.
That's completely ridiculous.
The guy is declaring, completely unqualified, that .net works perfectly on linux. That's absurd. He's also being a dick about it. Are you under the impression that "maybe you should actually try to to deploy .net core" is a thing people say in good faith? Because it isn't. So he's wrong, and he's a dick. I don't really feel bad for calling him out on it. e: christ I just took a gander through my own comment history and I think *I* might be a dick.
I've just had a quick look. Here are some differences I see: * If the underlaying ResponseWriter doesn't implement Hijack, CloseNotify or Flush, noodle's logWriter will add them. However, if your application's handler is trying to use them, noodle will panic. httpsnoop's wrapped ResponseWriter always has the exact same interfaces as the underlaying ResponseWriter, so adding it to an existing project will not cause code that was previously fine to panic now. * If the underlaying ResponseWriter supports io.ReaderFrom, noodle's logWriter will shadow this method. Any handler optimized to use io.ReaderFrom will potentially be slower with noodle. httpsnoop has no such side effects. * If multiple goroutines are calling Write and/or WriteHeader concurrently, noodle's behavior is undefined. httpsnoop uses a synchronisation mechanism to address this scenario. * httpsnoop tracks the number of bytes written by the wrapped handler, noodle doesn't. There might be more, but that should be a good summary of the differences ;).
I've used `gopacket` for a couple of things in this area, including to perform full-scale traffic analysis while troubleshooting some particularly weird behavior in a production system. I think it's a great suggestion!
Indeed, that looks promising. Added to "Watch Later". Thanks for the share. :)
Pretty cool! Though the saddest part for me is seeing ken@golang.org disappearing around 4:22 - 4:38. It makes me wonder what he is working on right now and if he is even using the language at all.
That was quite enjoyable to read. I wish I had the same luck with the people I am working with. Unfortunately Java is very dominant around the #enterprise area.
Right, I understand there are semantic differences to the code. I just fail to see how that semantic difference would result in a runtime performance cost. I'm likely just very ignorant on how the go compiler works but I thought it would implement defer statements by injecting the machine code instructions for the defer at the point of the function unwind which would need to be executed anyways even using a goto. Where does the runtime performance cost of a defer come from? Genuinely curious if you don't mind explaining it to me.
Perhaps have a look at PacketBeat on Github?
One thing that might be useful is that you can run "adb shell uiautomator dump" and it will write an xml file to the sdcard that describes the layout of the screen. This means that for some apps you don't need to do template matching to find things but can just parse the xml.
You could just run tcpdump as a child process and use the output (the binary, not the text summary). It's pretty easy to parse. 
The flipside to this is that sometimes, due to language restrictions, idiomatic Go feels downright nasty; in many cases you're either forced to use `interface{}`s and reflection, or you have to essentially copy-paste code. Not all *that* common in most cases, but I still run into both enough that they do irk me from time to time
We have been using go to write infrastructure related micro services, log aggregators for many docker daemons, side car type apps for oss projects (helpers to push metrics, alerts, etc, from nginx, haproxy through the sidecar), even some other more complex projects. I have no complaints at all working solo or as a team with go. Your mention of error handling is something that does crop up once in a while. It's generally the same kind of "TODO: unit test this function" sort of thing. I hadn't thought of it as being an idiomatic/the way you're looking at the problem thing though. I absolutely love the if err != nil pattern though. The only time we have consistently ran into bugs is with parallelism and concurrency type things. It's pretty common though since that's generally a complex subject. My background is more in ops with really only experience with ruby and shell. Go is now hands down my favorite and strongest language. 
"AGPL/Commercial license" Does not compute; AGPL **is** a commercial license. There is nothing in the license to prevent or impede commercial use, in fact it forbids any such restrictions. *edit*: Whoa, wait a f-ing minute: "UniDoc is licensed as AGPL software (with extra terms as specified in our license)." If you've added some additional terms to change the nature of the license, it's not the AGPL. And if you've added terms forbidding commercial use, **it's not open source by any commonly accepted definition**. Clarity needed. This is either a miscommunication of good intentions, a misunderstanding of what "open source" /"free software" means, or a deliberate lie for marketing purposes. Which is it?
See the "Avoid stutter" section in https://blog.golang.org/package-names. It should be `client.New`.
And then an attacker makes thousands of calls with random fake Host headers like `s37dosdgg366.domain.com` and your rate limit is exceeded.
Love these historic posts. Very well written. Tks 
Rephrase the aphorism slightly: accept interfaces; return concrete types. Maybe it could even be put more in a [Go Proverbs](https://go-proverbs.github.io) style of wording. Being judicious when returning interfaces (defaulting to preferring concrete types) is a hard lesson I learned four years ago; see my link above for Package hash for a case where I thought what stdlib was correct but turned out not to be. Returning interfaces can add stutter to your tests as this contrived example illustrates: https://play.golang.org/p/SAz3lgw8dO. Seen more than my fair share of this in real production code. Further food for thought: * [Solid Go Design](https://dave.cheney.net/2016/08/20/solid-go-design): It speaks to this briefly. * [Package hash](https://golang.org/pkg/hash/#pkg-subdirectories): I have a hard time imagining that the subpackages would return interfaces as opposed to concrete types were this to have been rewritten today.
I agree with the message but I don't think your examples are the best. Your returning interface example could get the same treatement as your returning struct example (defining an interface in the consumer), there was never any need to return the struct. It's still a good idea to retun structs instad of interfaces though, that way the consumer can pick what it wants from it without the producer needing to return a fat interface. Diff of returning interface code with the consumer Client interface defined: package mywebsite import( "github.com/someone/client" "github.com/someone/rest" ) +type Client interface{ + DoSomething()error +} -func SomeFunc(c client.Client)error{ +//Use the Client interface in this package instead of the client package. +func SomeFunc(c Client)error{ return c.DoSomething() } func main (){ c := client.New(rest.Config{ Host:"ahost", Port:3000, }) SomeFunc(c) } The test code from the returning struct example now works without any modifications. //test my service with a mock client package mywebsite_test import "github.com/me/mywebsite" type mockClient struct{} //notice we have to implement ONLY the method we use now. func (mockClient)DoSomething()error{ return nil } func TestSomeFunc(t *testing.T){ if err := mywebsite.SomeFunc(mockClient{}); err != nil{ t.Errorf("did not expect an error but got %s ", err.Error()) } } This makes this statement false as we can pick out subsets of method from both structs and other interfaces. &gt; But more importantly, because we returned a struct, the consumer of the code can define their own interface with just the methods they care about.
It's a thought...though I have to wonder about the performance implications of scraping stdout for info on the communicating nodes if you had more than even a handful of nodes.
returning a type means that if the caller stores the error into a variable with type error, it will always be non nil because interfaces are non nil if they contain a type, even if the actual value that the interface stores is nil. In Andrew's case, the variable was always of type *appError so it was fine.
&gt; In fact, Pike wrote a good article about this, showing some common patterns that could be rethought to be expressed more fluently. I've written Rob's article many times. It talks about a very specific case. You can only do stuff like that when a common pattern arise in your codebase. But when you write plain, "boring" code that just chains other functions together, (imagine an http handler that accepts a form value, converts it to integer, then calls a database function and writes a JSON with the result) then you will naturally have a bunch of `err != nil` for proper error handling. &gt; may take many refactorings and deep thought to finally settle on the most succinct expression. Yeah I agree with that but sometimes I wonder if it is really worth it. When you come back 1 year later and have to fix a bug in the code, will it be easier to debug the succinct version that came after hours and hours of deep thought, or the simpler and probably more verbose version? &gt; I haven't studied the camlistore codebase, but I imagine even it contains code that works and was considered good enough, but could be expressed in much a better way if someone wanted to put in that effort to refactor it. That might just be the case. While I think that Camlistore is an awesome project, I believe its codebase is a complete maze. The thing is that there aren't that many examples of large/non trivial (web) Go projects written idiomatically so obviously when someone like Brad Fitzpatrick writes one, it's only natural that many people will look up to it. In general I do not disagree with you but I felt off by this sentence of yours: &gt; a really good sign you're not thinking about the problem correctly 
Why Go code in snippets is not gofmt'ed? Is there any example in stdlib / any popular package that uses config interface instead of a struct?
Yeah, we were lucky enough to start from scratch with our language of choice. Our customers use a lot of Java and a few of our developers are Java strong. We also have a few coworkers that refuse to use Java so that benefited this project.
I've been writing go for a while now and admittedly interfaces still feel like a bit of a mystery to me. Oddly enough channels, go routines, and pointers make complete sense to me. I have a few days off and this was one of the things I had planned on working on. Thanks for the post! The way you've laid out the examples and explains them makes a lot of sense to me, so I'll give it a go (ha) with refactoring a project I've been working on.
Formatting should be fixed now.
Thanks! Glad to hear more companies are trying to learn it. I think the strengths of the language make it wonderful to work with.
My background might be different from some; go is the first "programming language" I've really felt comfortable with. I've written a very small amount of java/scala/groovy and C, but I've never shipped anything in any of those languages. Most of my background is ruby/python/shell. My understanding is that interfaces are a somewhat of a common pattern in other languages. Most of the examples, tutorials, and articles I've found are all very `type Animal interface{}` sorts of things, which for me are difficult to grok for whatever reason. Having more realistic examples and a more real-world pattern helps out a lot.
We don't have coding standards as far as "must comment functions that xyz, functions can be nnn lines, return types zzz" etc, there's more just "make sure your Makefile works and you have a build job, tests, etc" sort of things. I've always been huge on commenting on logic and throwing in TODOs for either refactoring notes, or "this is kinda janky, we should probably do xyz but will require nnn changes" sorta stuff. Nothing grinds my gears like poor logging, throwing away errors, and no comments, especially if it's something that isn't completely simple an obvious. Even then there's really no excuse not to throw in comments unless you have a really really legitimate reason (I can't think of one). I'm also the person that will write documentation and runbooks for things as part of design. I am probably on the extreme side of the spectrum for that :P E: I'm also really big on structured PR's too. Every PR I file no matter how large or small has Headers of Description, Changes, Request for comment, TODO (which includes justification for poor error handling, logging, metrics, and anything else that's a "this isn't ready for production, reference github issue 123". We're a medium sized engineering org with I think 4 teams of about 3-5 engineers, so we try to treat all of our code bases as close to normal oss projects with communication, reviews, and ownership, as possible. There's a little overhead for doing it but the payout when you need to review commits and PRs is huge.
I REALLY like it. For me - this is the best way to learn. A practical tutorial. Big thumbs up Francesc :)
Putting passwords in consts seems like a bad idea. `fmt.Sprintf` for constructing sql connection strings, without any consideration for quoting, is a timebomb.
I meant look inside to see what it uses. It's open source and written in go. :) 
There are literally dozens of us!
I should add to this that unlike binding to sql package, pgx uses the postgres protocols directly so it is much faster too :)
As a newbie I think you made the right decision. I think I've got a decent understanding of how to use flags, but I also know I might get distracted or even discouraged by things I might not fully understand and are not covered in an article. Thanks!
Thanks, I'll check out pgx. I opted to use the datastore/sql package because I also want to discuss ORMs and [GORM](https://github.com/jinzhu/gorm) down the road, and you need a `database/sql` connection for that.
RabbitMQ is kind of slow. Last time I checked, a ridiculous number of RabbitMQ nodes were required to get over 100k requests per second. Between mangos, zmq, and nanomq - I find no reason to use Rabbit.
&gt; You can use pgx as a driver for database/sql I did not know that. Thanks for correcting me :)
I use pgx as a driver with sqlx. It's a nice compromise without the overhead of using an ORM. I used to be strongly against writing SQL in code, but I will continue until it becomes an issue. 
Spoiler: it uses gopacket (https://github.com/elastic/beats/blob/master/packetbeat/sniffer/sniffer.go) 
I thought I was the only one that didn't like the idea of ORMs with languages like C and Go huehueheu. However I didn't know about go-pg. I might give it a try also to keep up to date with how cool kids do things.
It may have something to do with tooling: The Gradle build tool is all groovy and so is the (fantastic!) Testing tool Spock.
Why do you need the nillity check? If either slice is nil, its length is 0, so you can exit early. I think your slices are too short to have BCE and pointer checks significant effect.
Correct. This is for gophers who want a ready-to-bake TS/React SPA kit. 
And what's your qps on those? Which one is easiest to setup? Which one do you like most?
Feels a bit like overkill. I've usually been able to get by with http://stackoverflow.com/questions/13194272/what-does-a-underscore-and-interface-name-after-keyword-var-in-golang-mean and the core domain tests for my type.
It's Go, not Golang.
Searching for just "go" makes answers few and far between though. I've found that I almost always need to search for golang. 
We use an in house mq internally. I just didn't feel this was the place to plug the repo. We've used zmq, nanomq, and mangos. My favorite was mangos, due to being pure go and having no dependencies. Nanomq and zeromq get 100k+ IIRC. Mangos will drop messages that are being sent (if the rate is too high). I think we got 14k per second before seeing message loss. 

Ah ok, makes sense.
I really dislike the RabbitMQ API - I was trying to do something relatively simple (request / response) and there were a ridiculous number of calls to make with those multiple boolean arguments that basically require you to comment each argument to remember what it was (never mind trying to remember or figure out what they do). 
I use Beanstalkd, simplest solution ever. It's like memcached or redis in terms of infrastructure. Single binary. If you want failover you must do it yourself, but seriously, if you're starting small, just save yourself some time.
Pretty sure ((you want to be sure the WaitGroup.Add calls happen before the WaitGroup.Done ones) and (the language doesn't guarantee that happens unless the WaitGroup.Add calls come before the go statements)).
It's a shame the compiler doesn't give you that you you try to use the equality op on a slice.
Yup. And you can easily expand that server if you need to go beyond a static SPA. I'm looking into ways of making that step simple as well. 
Isn't SteamOS just Debian? You can enable the normal Debian repos using [this guide](https://steamcommunity.com/groups/steamuniverse/discussions/1/648814396114274132/), and then you can just get Go using apt. I'd recommend using debian.org rather than leaseweb though.
Love the concept, will try it out. 
I imagine you have alteady visited: https://golang.org/doc/install/source but that is what I used to build Go from src for the first time. Since then I've picked up some scripts and make files from https://go.googlesource.com/build/+/master to build the latest Go versions. If you are stuck at a specific point let me know.
I just used the Debian 8 backports package to build the set of packages. Seemed to work fine. Kinda stumped building docker (local or pbuilder), but that's outside the scope of this subreddit :/ http://sprunge.us/fLaa 
I don't know who Jesus Harrison Christ is, but I agree on you about Rust. It is full of great features and guarantees, but very noisy syntax.
They changed the search term they use as a proxy for Go usage from "Golang" to "Go", which explains the sudden recent jump in results. But don't be fooled, the TIOBE index is still junk statistics.
Yes, Go needs Go to build. There's no catch-22, you can break the loop by either A) installing the binary package, or B) cross-building on another machine. B would be your choice if you were building on some new and exciting platform, which SteamOS is definitely not, so A works fine.
The primary problem I have working with JSON is that it is other people's JSON because I would never touch JSON if I had a choice, and they do very annoying things that have to be handled manually in Go, since the JSON package can't catch them. For example, when Reddit returns the JSON for a thread and comment tree, the "replies" field is either an empty string, or a "thing" type representing a listing with more comments. The unmarshaller will choke in some cases no matter what expectation you specify. I've never worked with a service or client that wasn't littered with annoyances such as this that naturally arise because of how absolutely unforgivably terrible JSON is. I love the idea behind your package. I think it would have saved past me a lot of time if it had a way to set up expectations for fields that can be multiple types based on * the value of another type in the JSON (lots of things use a "kind" field to specify the type of another field.) * chance. * developer spite.
SQLBoiler has barely any overhead (it's actually faster than SQLX at binding, which is nearly all SQLX does). Reflection-based ORMs have performance penalities, generated ones do not.
I'll check it out, thanks!
 func fileServer() http.Handler { return http.FileServer(http.Dir("../")) } won't this end up serving your Go sources as well? might want to revise this structure.
I guess I got fooled. Thanks for responding!
I have looked at it briefly and I plan to write about it as an option as well. Unfortunately there are only do many hours in a day.
as someone who comes from a Python background, are functions in Go not first class? Why should one fear them when writing go?
&gt;And md5.Sum always returns 16 bytes (128 bit hash), so it returns an array to avoid allocating. Using an array to save 2 int worth of memory fell more like c than like go. **Edit:** Especially since you would have to slice that array to use it with about any function from the standard library.
If you instead declare.. type SnapshotSlice []*rds.DBSnapshot Then you can freely convert between them, and add methods to the SnapeshotSlice type. Saves you about 6 lines.
You're right. Good call.
`net.Conn` is an interface, which is (someone will yell at me for this) "pointer-ish" in that it's a pointer to the underlying struct that satisfies it. So passing it around keeps a reference to it. I believe you can write to it from multiple goroutines, but you may end up sending an interleaved message. I imagine - as he mentions in the post - you're more likely to have a struct pointer or interface that wraps a conn, and provides mechanisms for appropriate syncing of messages going out.
Not everyone who is new to Go knows the concept of functions as first-class objects. This article helps wrapping one's brain around that concept. 
If the compiler sees, that a `[16]byte` is returned, it can create 16 byte worth of space on the stack and have the function return it into that. Whereas, if a `[]byte` is returned, it doesn't know the size, so the bytes themselves need to land on the heap. Now, with inlining it doesn't need to matter, though a) I don't know if the compiler is clever enough and b) you can't always inline. The `[16]byte` thing doesn't even need to be a compiler optimization; it can in theory be built into the calling convention. All of that being said: I'm guessing. No idea about the actual implementation here. [edit] Your example isn't very illustrative, because the bytes probably escape (as you do use a slice). That being said, a simplification shows, that my guess also doesn't happen :) So, no clue.
It is also a really good language for general purpose scripting. The Grape feature is something that a lot of other scripting languages don't have. 
You would usually just store the sum, not needing to "use it with about any function from the standard library." The sum will probably be stored in a database or in some in-memory structure. You can do equality comparisons with the byte arrays, which is generally all you want out of a sum. var sumTable map[string][sha256.Size]byte func check(id string, in []byte) bool { expectedSum := sumTable[id] newSum := sha256.Sum(in) return newSum == expectedSum } 
1 month later https://github.com/kataras/iris/commit/948eb2ecc132e299e476bfbd051a8100e216f2ac 
1 month later https://github.com/kataras/iris/commit/948eb2ecc132e299e476bfbd051a8100e216f2ac 
The nice thing about the time package is the use of the context stuff for timeouts and cancellations. being able to add a deadline and support cancellation in a method that can apply throughout the request workflow. We have requests inbound that get a timeout added to them on the first step and then no matter where the request\resource is passed they all use that same timeout value. (i haven't looked at the uber ratelimit much. (it is apparently faster)) *edit n* You could translate between the deadline and the duration type wanted in the juju ratelimit. 
Neat! s/gostaticheck/gostaticcheck/ in your example.
I have to say i really prefer zmq and pebbe's zmq4 package worked great for me. I made a go client for EDDN when Elite Dangerous was still cool and it was fairly easy to navigate the api. Decided to mess around with a distributed chat for funsies and it handled it fairly well. Didn't feel sluggish. 10/10 would recommend (note I didn't do any benchmarks. I just like sharing my feelings)
Hmm, so this is another good HTTP option. I did read through the similar HLS protocol by Apple, which got me thinking more about http. My problem is now how to implement that using the STUN method I described.
I wrote up some benchmarks for you that might help illustrate the difference. https://github.com/TheDorkKnight/arraybench I tried to target only the difference between returning arrays and slices in my benchmarks, though I can't guarantee for sure that my methods are sound. The upshot of my results: There is a noticeable improvement in performance when we return an array on the stack (*BenchmarkArrayCopy*), instead of allocating a slice on the heap (*BenchmarkSlice*). I've also included benchmarks that help us compare performance when zero copying occurs (*BenchmarkSliceWrappingArray* and *BenchmarkArray*).
Mostly upvoting for the 'start small' advice. It's important to start with something you understand before moving on to bigger things like hadoop, if you ever need them. If you start with hadoop it's just overkill for a simple web page storage, letssay... :)
No one ever mentions the first-class "methods" in Golang. You can pass a reference to a method with the instance as part of the reference. I've never seen that before in a language. mRef := instance.method mRef() // calls "method" on "instance" The reference to the method, embeds the instance. When something calls that function reference, the method is actually called on the original struct instance. The code you pass that reference to has no idea its a method ref rather an a function ref. It just looks like any old function reference, with a regular function prototype and everything. This means you can easily pass these in, in place of function refs. Which is a kind of currying. This can be very powerful. https://play.golang.org/p/gkv6Uo92hR 
And I'm back to not getting it ... If you store the hash, it will probably have to be on heap at some point and you lose the advantage of using an array. Your map of array is basically a map of slice since the array in the map have to be in heap. Worst, when you extract expectedSum from you map, since it's an array, it has to be copied. On the plus side you get to use the Equal operator. Also, i find it funny that you called the *data* that you passed to sha256.**Sum** *in* which is the name of the completely different argument of sha256.digest.**Sum**, because it's those extremely confusing names that brought me to question myself in the first place.
This is still a pre-version 1 release so there's time to add Context if it can help. Most of the libraries Stow uses under the hood don't implement context, so we're weighing it up against the fact that people might assume they can cancel things that they cannot. Please get involved at https://github.com/graymeta/stow/issues/103 
I've given up trying to find truly unique names for projects, instead we probably have to rely on context.
&gt;Rx is a new, alternative way of asychronous programming to callbacks, promises and deferred. Yeah, you mean [Observer](https://en.wikipedia.org/wiki/Observer_pattern) pattern that has been around for decades?
Thanks! Fixed.
lol
Surely it's not just an allocation thing: if it were, the code should manually allocate an array and then return a full-length slice of it. I've wondered about (and worked around) this array-not-slice behaviour before, too. Would love some insight.
Thanks, I wanted to do this kind of benchmarking but I was not familiar enough with *testing*. But I too am not so sure about the methodology. First of BenchmarkArrayCopy and BenchmarkSlice does not seams relevant in this context, they feature lots of manipulation of the slice/array elements which is not really the focus here. (by the way, BenchmarkArrayCopy is kind of a misleading name since BenchmarkArray also does copy the array, but in a more efficient way) The two other benchmark look more promissing. crypto/&lt;hash&gt;.Sum and crypto/&lt;hash&gt;.digest.Sum() both call the same digest.checkSum and get the same [Size]byte (presumably on the stack) the first one returns it(similarly to BenchmarkArray) while the other append it to a given slice and return it instead (kinda similar to BenchmarkSliceWrappingArray, but not really) 
Doesn't the receiver change with javascript? That is, mRef() would use the current context as the receiver, as opposed to 'instance'. Java has proper method references though. Instance::method, or instance::method.
Python lets you do this. 
Thanks for the link, I never knew about the `subtle` package.
Well, well, well. So the person that wrote [Why Go’s design is a disservice to intelligent programmers](http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/) is now suddenly writing about Go channels?
Very good. Remembers something similar I started some months ago. https://github.com/dimiro1/bogus
People can change... Water is wet
Yeah but why is it "the right thing to do"? What do we earn by returning the concrete type instead of the error interface in that particular case?
Rx has been around for quite some time. Not sure about JS, but I've been using it in Java for a while now, and I imagine C# has had them for even longer. I wouldn't say it is the 'new popular thing'. It's just a very nice way of handling things that emit. Kind of like channels, but lots of people get the same item. While I would love to have rx in go, this implementation kinda sucks though, mostly because of lack of generics. Having to type assert everything is a long way from optimal.
I think it's immaterial what their opinions on go where and are. Let their post stand on it's own merit. FWIW: I think Haskell has a lot of great features in it. I could imagine, to use it at some point to write something about how Monads and lazy evaluation can be used to solve interesting problems in interesting ways (or whatever). I don't *like* Haskell and I don't want to code in it, but if it's useful as a tool to illustrate or implement something, why wouldn't I use it?
Hi guys, Been working on this for quite some time. Currently, it just writes to files. No remote targets are available, its a TODO item. Any feedback will be greatly appreciated !
Funnel does the job of buffering. Not trying to argue here, just curious. Can you explain why an app should buffer its logs before printing to stdout ?
Because otherwise `nil` comparisons will fail, which breaks error checking. Another issue is that if every function returns different types for errors, you'll either need to predeclare an error variable, such as `var err error`, or you'll need to use a different one for every function's return value.
I haven't ever thought of that possibility on any language that supports it. It blows my mind.
Not as useful but still interesting, you can call the static instance of the method on the type and pass in the instance! type Foo struct {} f := Foo{} Foo.Bar(f) is the same as calling f.Bar() 
Anyone know what theme the guy has in the code examples?
What's the matter with runit's svlogd?
Reading the examples of the article (against D), looks like he tried really hard to write complicated Go code. I guess he just have way more less experience in Go than in D. Ask me to write snippets in D &amp; Go, the result would be the opposite I guess.
A couple of features differentiate it from svglogd - 1. In svlogd, old files are always rotated by appending the timestamp. Similar to daemontools' multilog. In funnel, you can specify the timestamp rename policy or a serial file rename policy like nginx does. 2. To reload its config, you need to send SIGHUP. No more of that in funnel. You just edit the file, it automatically reloads config. 
I totally agree. Yet the article says: &gt; (It's usually a mistake to pass back the concrete type of an error rather than error, for reasons discussed in the Go FAQ, but it's the right thing to do here because ServeHTTP is the only place that sees the value and uses its contents.) Sure in that situation it is safe to pass the concrete type since only ServeHTTP sees it but why is it "the right thing to do"? This is the subtle case that I was never able to understand in the article. I was under the impression that you were explaining that.
Oh. Dang. I didn't even see that part of the quote. I should really stop replying to things at 2:00 A.M. It looks like a mistake in the article. `*appError`, despite the name, doesn't actually implement `error`. It's just a 'normal' struct being used to pass information around.
Looks like a lot of these would be a lot more straight forward/clean if they just used the [sync](https://golang.org/pkg/sync) package
No, the Go compiler decide wither to allocate on heap or stack depends wither a pointer to the function escapes the function. https://golang.org/doc/faq#stack_or_heap &gt;In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack. 
There is also a https://golang.org/pkg/hash/#Hash32 and Hash64. The slice base hash interface has two advantages: 1. Allow different sizes of hashes to implement the same interface. 2. Allow allocation free append to a byte slice with enough capacity, this is useful for faster encoding to stranded protocols.
Glad you like. :)
Example of such: https://gist.github.com/montanaflynn/3692047f02fe06b90543a261bdb64783
For in browser video streaming you can use webRTC for chrome and firefox.
90% sure it is Node.JS
Looks interesting. Congrats! Whats next? hmm... keyword as a service (KAAS) may be! /s
&gt; How does this compare to logspout? Didn't know about logspout. Thanks for bringing it to my notice. :) Well, logspout mainly seems to ship to a remote syslog server (along with other targets supported by 3rd party modules). Funnel writes to files locally and does all the functions that a log rotator would do - rolling over to new file, deleting old files, gzipping ..etc. &gt; Are you planning on supporting Kafka? Yes ! Why not ? I was thinking which output target to write first. Kafka just got bump up. :)
I find this very interesting. I have been contemplating something similar, and was thinking of using code-generation rather than reflection. Not sure exactly what the performance differences would be. Right now, I am doing the response side only by making my handlers all of the signature `func(w,r)(interface{},error)`, and having my bottom level middleware handle json serialization and error handling and such. What I really want is twofold. First I want a solution that handles request parsing and validation. Perhaps a reflection based approach is ok, but I'd like to see some benchmarks. Ideally I can define my handlers as `func(*RequestType)(*ResponseType,error)`. Secondly, I would like to be able to generate documentation for my routes/handlers. That is a tricky problem that a few frameworks have tried to tackle, but none really in a way that I like. Not sure if comments are an ok way to define docs, or maybe some go-native code structure could make it work. Not sure. Sorry for rambling.
Kafka output would be awesome!
Nice and simple but here's one thing you may want to consider. Currently, if any one of the 3 RTMP streams you're copying packets to become congested it would cause writing to the other two streams to stall/halt as well. This would also end up blocking the reading go routine as well. To solve this you may want to use buffered channels for those go routines that are storing the "copied" packets to be sent. To go even further, if one of the RTMP streams becomes so congested that even your buffered channel fills up you can simply check the length of the channel to see if it is full and if so drop packets until it's no longer full. Lastly, if you do end up dropping some data it would be best to resume sending data at the start of a video Key Frame. Update: I looked through the joy4/rtmp code and saw that WritePacket eventually goes down into a bufio.Writer so it's possible congestion would go unnoticed (just using up more memory) or would just take longer to show up in your WritePacket go routine.
I was expecting to enjoy this article from the title, but there was no race condition until the "Second, bigger hint." The race condition was caused by code that didn't exist until later, so it would be impossible to "figure out" the race condition before the second hint.... I mean, *anything* can be a race condition if we add more code onto it. Even a uint64 that we only read/write with atomics is still prone to external, uncontrolled writes if it's a field struct. However, when I want to control my readers with an iron fist I use closures, as in: https://play.golang.org/p/aLygBdf9S7
The names of the benchmarks refer to how the *compiler* will behave, not so much how the code looks. **BenchmarkArrayCopy** copies the bytes of the array into a new array *(so that the compiler can't optimize it away)* and returns that on the stack. We then compare that to **BenchmarkSlice**, which takes about 30ns more than **BenchmarkArrayCopy** but is otherwise copying and working with the exact same data. Thus, we can guess that allocating the slice takes about 30ns. **BenchmarkArray** and **BenchmarkSliceWrappingArray** are just there to show us that we need to do some tricky copying or else the compiler will optimize away the array-value-return and slice-allocation respectively. Seems the difference between **BenchmarkArray** and **BenchmarkArrayCopy** is about 15ns, so that's probably the time we wasted tricking the compiler. Anyway, all of this was just to show that it's usually faster to return smallish values on the stack (copying an fixed size array) than to return a pointer to something that requires heap allocation (a slice).
The twitch chat linkup. I'm curious why you decided to go for a websocket and manual IRC protocol handling instead of using an IRC client library? (eg: https://github.com/thoj/go-ircevent ) Looks really awesome, though! Definitely something I can learn from.
Doesn't Apex require AWS Lambda though? It appears IronFunctions is a self-hosted alternative to AWS Lambda. Whereas the former is a AWS Lambda deployment and management tool. edit: seems @njpatel beat me to it :-D
Thanks to Travis Reeder and company for open sourcing this!
Oh yeah I can see the difference now, my bad!
If you look at the stacktrace in a panic, you can see thats how it calls the methods. Informative. Furthermore, this gives a hint as to why its possible to call a method on nil (when the runtime thinks its got a type), and why the panic that happens as a result, fires from _within_ that method, and not before it.
Nice!
The idea is more about the struct itself, and it's methods, aren't enough to know if there's a race. It may not be immediately obvious that external packages can trigger reads of private variables without going thru struct functions and without copy assignment.
GAAS (Generics as a service).
&gt; language agnostic ... yet only posted in /r/golang and /r/serverless. Why not in /r/programming if *"[t]he main benefits that most people refer to are on the developer side"*? Besides that *serverless* is a stupid name because of course there is always a server, if at all it's *serviceless* or *daemonless* ... *FAAS* however is a better and more intuitive name. And while I'm sure there is a tiny use case for this in some niche (just like SPAs) people will jump on it like it's the best thing since sliced bread and will abuse it to no end, building way too complex tools around it to make it do what it probably should not^edited do ... 
I am the author and I do have conflicting opinions on Go. On the one hand, it is a very dumbed down language and I believe has gone a little too far. For example, I think developers can handle (and not abuse) conditional expressions (ternary operator) but Rob Pike doesn't think so. On the other hand, the concurrency support and garbage collector are simply best in class and are awesome to use. Since the [disservice article](http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/) I've stopped using D for general programming and I now use Go. Why? Because of Go's community, the vast amount of libraries and the amazing tools you get straight out of the box. Just because I use Go and enjoy it, doesn't mean I can't grumble about it from time to time.
Delphi had it back in the day. I wrote a preprocessor that inserted lexical closures into the language using "method pointers"
Very good point, thanks for that! I haven't witnessed congestion myself when using it, but you're right that I should be handling it even if it's eventually ending up in a bufio.Writer. 
Can I give a JSON structure to be served over HTTP?
Have you got a snippet showing this in action please?
Even if lambda alternatives can re-use containers just like AWS, I'm still not thrilled on the startup latency of containers, especially Docker. 
You did not mention whether the code was buggy and apparently it wasn't. You and your team enforced your preferred coding style, fine. But I don't take it as a justification for banning this feature from the language. I mean, what if I told you that once I saw someone abuse anonymous functions for setting options ;-) and so they should be disallowed?
Its a bit large one but I used `sync.Cond` in place of channels for a [queue of work](https://gist.github.com/jasdel/217eeecb6a8e12f689b6bb9976b54326#file-pendingqueue-go-L86). Specifically links that were scraped from webpages for spidering. Channels could be used for this but you eventually will run into the issue of a channel being full which causes all writers to block until the reader is available. Whereas, the queue ensures that writers should never block adding to the queue. The queue uses [sync.Cond.Broadcast](https://gist.github.com/jasdel/217eeecb6a8e12f689b6bb9976b54326#file-pendingqueue-go-L69) to notify goroutines waiting on the condition that there are more pending links to process. In the context of link scraping where there generally are many subsequent links for ever one request. This would easily fill up a channel pretty quickly. Using this queue would use more memory, but the workers won't be blocked as often. The code that reads from the queue is: func (w *brokenLinkWorker) Run(queue *PendingQueue, known *KnownLinks, broken *BrokenLinks) { for { pending, ok := queue.Next() if !ok { break } // .. process pending link // Completes the link (used to prevent the worker exiting early // even if queue is empty. Queue is never "empty" until no more pending links. queue.CompleteLink(pending) } } 
&gt; It is by definition a coding style when you have to choose between two equivalent programs w.r.t. criteria such as readability or maintainability. Ever tried to debug code with chained ternary operators? It is not pleasant. &gt; As for the claim that if-statements are more readable and more maintainable than if-expressions in general, I disagree. I did not meant this as a general claim. I was speaking about that particular case. I understand your doubts since you didn't see the code but if 3 experienced programmers agree that something is more readable well then... you get the idea. &gt; Why not simply have the choice? You have the choice on many languages but not Go since it was designed for "human scale". [This talk](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent) perfectly explains what I mean by that.
Sure, why not?
there is work happening to fix this https://github.com/iron-io/functions/issues/69 also hopefully rkt support can be done soon too :D 
http://stackoverflow.com/a/25034437/1327984 Try `go tool objdump &lt;binary&gt;` for a disassembly.
You can get a regular assembly disassembly (at least, on Linux) using `objdump -d &lt;binary&gt;` but you can take advantage of the `go tool objdump` to also get Go-specific debug info such as source file names, more symbols and line numbers. I think I am a bit wrong on the technical explanation but that's basically the gist of it.
Loving the retro serif look, and I also like the unique font used on the blog itself. Might take some getting used to but I found it very elegant and easy to read.
Based on Bigelow and Holmes' [proprietary Luxi series](https://www.fontsquirrel.com/fonts/Luxi-Sans).
Very strange decision. 
But... why?
Go figure.
This looks interesting, thanks for the link! This is exactly what I was trying to do. I was reading about quines and thought this might be a fun way to try one. I might try something easier for now... But it sort of felt cheap to just have a print statement with the "package main import fmt" etc etc and have that be the quine, so I wanted to try something different. It seems that this approach might be easier in Java or C/C++, but I'll keep digging around.
Probably because it's written in go and that's interesting for us as go developers to read and learn from.
First thought: WTF? Second thought: Oh, it's all about the license. Third thought: Well, actually, the fonts really look very pleasing. (Guess I'll test them against the Lato/Source Code Pro combo on my blog, in terms of both readability and style.) UPDATE: The longer I compare Go Mono against Source Code Pro Regular, the more I prefer the latter. The Go font looks a bit too dense and heavy to me, plus the serifs appear to make the letters slightly slant to the left (an optical illusion, I know, the vertical lines are really vertical). 
This confused me a bit at first, but I think the fonts look great. I'm going to give them a shot. I've just pushed two packages to the AUR if anyone on Arch is interested too: [ttf-go-mono-git](https://aur.archlinux.org/packages/ttf-go-mono-git/) and [ttf-go-sans-git](https://aur.archlinux.org/packages/ttf-go-sans-git/)
is this feature supported?
Care to elaborate?
&gt; Go source code looks particularly good when displayed in Go fonts But not as good as in my favorite font: http://i.imgur.com/wA7wPGx.png
Cheers, mate. I've found right combination for CFLAGS and LDFLAG then built code. 
I'm absolutely agree. I was using linux as my main workflow for years and it was awesome. I swaped to macos three years ago and found this system as kinda unix with solid gui and native MS Office and Photoshop support and I love it. Problem is that I don't know any good way to create soft for Windows in Linux or Mac environment. Yeah, there's virtual machine but it's bloody slow. 
Haha do you still live in the 80's? :D
The blog uses the Go font actually, I think it looks really well too!
Doing that would promptly promote the array to the heap.
If you ever try to write a self-contained package or even a tool that has to render text onto/into an image you'll be glad if you have high quality fonts with lots of glyphs and a **suitable** **license**. Until that point you'll have to believe people who already did this that Go fonts will make this much easier.
All those //'s... Why not just use /* */ ?
Hopefully they will extend the character set a bit, I'm always running into edge cases...
Perhaps his preferred font lacks a glyph for star?
Your best bet for Go would be NA or China :-) (statistically speaking (statistics pulled out off my...) I would say Europe is too conservative (js,C#,java are very popular here + C/C++).
Also https://github.com/dgryski/go-duoweb
It takes time and effort to craft a new font. There are already a ton of free fonts you can use if you just want to test your software. It doesn't seem very well related to managing a new language. But I'm not complaining. Just find it to be a weird choice on their part. 
[removed]
[removed]
&gt; This really isn't a valid argument because you could apply this to other language features. Not including a ternary operator because 2% of programmers may abuse it is what my original article was aimed at. You are doing a disservice to the 98% of programmers that use that feature just fine. I am afraid that you are missing the point. Go was not designed to do innovative language research or serve "98% of programmers". Go was designed for [engineering large software projects](https://talks.golang.org/2012/splash.article) and from that perspective, leaving out features like ternary operators and unused imports makes perfect sense.
They both have serifs. Maybe it depends on your rendering settings. 
`set guifont=Fixedsys\ Excelsior\ 3.01-L2\ 12`
I think I like it. http://driusan.github.io/de/fonts_dejavu_vs_go.png (Left is Deja Vu Sans Serif Mono, right is Go Mono.)
The monospaced version of this font seriously reminds me of the one Sun used during its boot-up (I think it was for the EEPROM...)
I think that's just because that screenshot is using the non-monospaced version.
I know that, but array are returned by value, which mean that no pointer generally escape when they are returned and they are (generally, but it is the case in our particular case) allocated in stack and. Slice on the other hand are struct that contain a pointer to an array so if you return a slice its array will always be on the heap.
There's a market for Go jobs, steadily growing, here in Switzerland. Every meetup I attend has several official or "undercover" recruiters looking for qualified people. Also, the demand for on-site personnel here is big. Outsourcing has kind of a bad reputation when it comes to quality and, as you may know, the Swiss are all about quality. Lastly but not least, Google is headquartered here. So if you think you're qualified enough -- go ahead and apply for an SWE or SRE position.
I love it, especially the clearly different I and l (that's capital i and lowercase L) and O and 0. 
just wondering, are you trolling :) Nothing wrong with that, I laughed while reading and that's why asking?
You might want to look again.
That's pretty common. As long as it's your editor that handles the commenting, it's easier to deal with because you can toggle individual lines independently of the whole block. More importantly, you can comment *anything* this way, whereas a `/*` comment can't contain `*/`. Funnily enough, IIRC this was actually a problem in a Go doc comment explaining how comments worked in the language reference for a while.
Is this supposed to look like the playground font??
I agree. For my day to day work I use a font called ["hack"](http://sourcefoundry.org/hack/), which is a sans-serif, monospaced font face. The serifs and design of Go's monospace font look complex, heavy and, in effect, antiquated to my eye.
The current playground font is Menlo, a sans-serif font: https://en.wikipedia.org/wiki/Menlo_(typeface) Perhaps they will switch the Go website and playground to the new Go fonts as they already did with the blog.
Not for us children.
will we still be allowed to compile code not written in this font? /s
citations please. There are many situations where tree-based data structures (linked list are trees) outperform hash-based data structures. Hash-based data structures are usually chosen for constant amortized time of operations, however, sometimes other considerations must be made.
Great to hear. 
There is actually a talk on why they haven't changed it. Rob Pike HATES the monorepo. That is just one from the go project. I will add others as we continue this conversation, next time someone from other parts of google- there are so many others.
I would personally do it the other way around, but whatever suits you.
* check Golang Meetups : https://www.meetup.com/topics/golang/ * Check (Commercial) Open Source Projects ( Golang ) on Github and check their open Jobs .... 
This gives me a really valid reason. Sadly I dislike the font. Not looking forward to reading doc with that font.
It's the serifs
That font looks a lot like the [Plan 9 font](https://swtch.com/plan9port/screenshots/sam.png). Plan 9 is the operating system the Go team developed before it was the go team. Coincidence?
Since black-on-white and no highlighting honestly feels like a kind of rare preference besides I guess Rob Pike's, here's an example in a light-on-dark style in VS Code: http://i.imgur.com/Y0IEtTC.png I'll try it out for a while. :p Edit: The pointer asterisks look like little flowers. I need to use pointers more now.
Same here
This service is an example app we wrote to show case how a developer could use Stream's API and feed types to build a backend service for a social photo sharing application. We've also posted a separate article on the blog about how to set up the feeds and will have an Android application ready early next week.
How did you install the font with vscode? I'm new to fonts. I'd love to give it a try, but I'm not exactly sure how you "install" fonts like this. Can `editor.fontFamily` just be a url?
&gt;ends up dying like the late but still very promising gxui Yes, I was sad to see that project be abandoned as well. &gt;it makes it a little harder to follow its development and it also gets lower visibility by the community. Agreed, I think this is mainly due to it's current state of development, there are likely still lots of lower-level things that need to be solved, like recently they implemented a compact format for vector graphics to be used for icons, emoji etc. This hasn't been updated since May, but it gives an overview of the widgets which are to be implemented: https://github.com/golang/go/issues/15534
I didn't read the whole thing but, her are my suggestions. Germany, The Netherlands, Switzerland and Great Britain need Go developers. A lot will do distance developers. It is not too hard to get into Germany or The Netherlands if you have a company sponsoring you. There are a ton of Go projects you can involve yourself in, such as Docker, or unik. I want to do work on unik I just don't have the time. What is more important than Go itself is an understanding of the growing microservice environment. Many companies adopting Go are using it because they are new or restructuring. Either way a lot of them are building around microservices, and having an understanding of microservices is probably more important than knowing Go. It is sort of a chicken egg thing.
It's a bit better on a dark background, but still the serifs make it still far too busy for my liking. The eye-hurt is still present.
When I first started learning Go, I decided to try to work my way through as many of the standard library's functions and methods as I could and by the time I was done, I felt pretty adequate at writing Go. Of course there are lots of good tutorials and such out there, but I believe the best way to learn is really to just write as much code as you possibly can. If you decide to try to do the same thing that I did, you can check out https://github.com/radovskyb/go-packages, which is a large amount of examples that I wrote or found online whilst working through the standard library's packages. Edit: As for the learning curve, especially coming from a handful of other languages, including the same as your background, I found this extremely easy, just time consuming :)
Well first you can go through the tutorial here, https://tour.golang.org/welcome/1 . After that you can probably remake one of your Rails projects in Go. Or just make an app that can consume a public facing API. As for the learning curve, Go is one of the easiest language I have learned. I am not saying it is easy to master, which its not, but getting something up and running is dead simple. Plus there are tons of resources online that will help ease any concerns. 
^ Good advice
I realize this was setup as an example, but I feel as though it could have been cleaner, and more modularized. Having to go through everything in a single main file, is a bit much. Also, it seems as though using Gin was a bit overkill, as much of what you needed could've been achieved by just pulling in [httprouter](https://github.com/julienschmidt/httprouter), which if I am not mistaken is what Gin uses (I went through it quickly so maybe I missed a few things). Doesn't seem like it is the "idiomatic go" way of doing things. Do others have an opinion on this? I have been doing web development for a while, so naturally use frameworks to speed up development. But I've found that with Go, it often is quicker/cleaner to just pull in the specific package you need, and the whole "use a framework, it will be quicker and you will be more productive" idea kind of doesn't apply. But maybe it's because my projects have been on a smaller scale? Who knows...
Binaries that are available for downloads are compiled with https://github.com/annulen/webkit , but server should also work with old community builds of webkit.
Nice, I was even just playing with that lib but I didn't wrap it with the quotes like you did. Very helpful! Thank you!
I started with the book by Caleb Doxsey. Then the book by Kernighan.
I started with this Udemy class by Todd McLeod: https://www.udemy.com/learn-how-to-code/learn/v4/overview He's a good instructor and pretty thorough. I highly recommend it. He has a list of resources where he also suggests a number of books that I'm going through - 2 of them have already been mentioned here. https://docs.google.com/document/d/18-0u5CvNIr83oOfMXPoM4klVFASXGl3Vvua1wBGMIoQ/edit Go By Example is a great resource, too: https://gobyexample.com/
So I actually totally agree with you, it's just off-topic and not super constructive doing it this way. :-/
Dunno why you're getting downvoted. They were distracting to the point that I just went "well fuck this" and closed the tab
Your comment is not idiomatic.
And it's a third-party comment. (From my perspective.)
I agree that it could be a bit more idiomatic. Having everything in `main.go`, all of the types, methods used, routes and handlers, etc is going to make the whole application much harder to manage. Imagine if you have to continue adding to it when the LOC is already at ~1350. If you want to go the Model, View, Controller route, you can definitely do that. The models declared at the top could be moved to their own `models` package (and could even make each model its own package within that). The types could be moved to their own package as well. For the routes, you could make each route a service basically and you just pass the router to each one, which handles the actual definition. Using httprouter over Gin as /u/zarbles recommended I think is a good idea too. Last thing I noticed was that some functions have quite a few paramters. It seems that when you have three or more parameters for a function, it can start getting messy. What I've done when that happens is simply create a new type for the parameters that the function will accept, i.e. from: func getFlatFeed( feedSlug string, feedUserUUID string, myUserUUID string, lastActivityUUID string, ) (int, map[string]interface{}) {} to: type flatFeedParams struct { feedSlug string feedUserUUID string myUserUUID string lastActivityUUID string } func getFlatFeed(params *flatFeedParams) (int, map[string]interface{}) {}
Also, lower your expectations on frameworks like Rails. * Start with The Tour (the syntax is similar to C) * There are bunch of free books to get started with. * Read the docs, docs, docs. The standard library is huge. * follow reddit channel for program showcasing and read through the code and see how they work. * Practice at Exercism - http://exercism.io/languages/go/about * I read the cycle book from here - http://www.golang-book.com/ * Absolutely "no" convention over configuration is encouraged by the community. 
thank you for your kind words! I have written a book on teaching how to write webapps in Go which is FOSS. http://github.com/thewhitetulip/web-dev-golang-anti-textbook/ I have added it in the README of this project. I am going to study Vue in the next few weeks and probably write a chapter about how to write the Tasks app(example project of my book). I also plan to write a short intro to Vue.js; I am a total newbie to front end dev and I found the docs to be surprisingly complicated for me to understand, so probably a short series of tutorials bundled in a book to teach Vue to new comers like me. If you want help related to writing webapps with Go, shoot me an email, I'd be happy to help. also check this out http://github.com/thewhitetulip/Tasks. (this is a sample todo app) email is on my github page. Also, this tutorial is intentionally short, this is a Vue tutorial with Go as backend :-) I am planning to add new features about Vue to this tutorial though.
Your username was appreciated, at least by me.
Good. [There are still multiple architectures missing though.](https://buildd.debian.org/status/package.php?p=golang-1.7&amp;suite=sid) Next add **sparc64**, please.
&gt; The models declared at the top could be moved to their own models package (and could even make each model its own package within that). That would we fine if we were writing Java or Ruby on Rails. But we are writing Go so something like [this](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1#.b1wukcxov) is probably more appropriate.
But cross-compiling with gcc is a breeze as well, provided your Linux distribution has a decent cross-toolchain like Debian testing/unstable. I'm cross-compiling here all the time for any of the 22 architectures/targets Debian supports.
Note that it doesn't support cpu's without an fpu.
Do routers generally have FPUs or not?
Yep, same here. Especially on big chunks of text.
My Go to (please excuse the awful pun) exercise for learning new languages is to do the first 50 or so problems of [Project Euler](https://projecteuler.net/) in the new language. 
Where does it say that this is a requirement? Would software emulation of FP instructions not suffice?
I don't see why in-kernel FPU emulation won't work, however, some (many?) embedded kernels disable FPU emulation. Go does not have soft-float, and it's very unlikely it will ever have soft-float. 
Is there a way to check the presence / absence of an FPU and its type in a running kernel?
I really need to make this a blog post so it is easily discovered, but since I haven't, you are going to get a wall of text here. I hope it helps. # Learning to program in general If you are looking to learn how to program in general, I would start out with Todd McLeod's Udemy course and his youtube videos. - https://www.udemy.com/learn-how-to-code/ - https://www.youtube.com/channel/UCElzlyMtkoXaO3kFa5HL0Xw He started teaching while learning Go at a college he teaches at, and I think that has made him a better teacher than many experts in the field because he didn't really have to "pretend" to be a beginner. He was one. His course is like $40, but you can get a discount code for it all the time. If you really can't afford it, email Todd and I'm positive he will try to help you out. He is a great guy. Another option is to check out Caleb Doxsey's book. - https://www.golang-book.com/books/intro In my opinion it doesn't teach programming in general, but it is definitely better than the tour of Go for a beginner and it is free. Overall I suggest Todd's course if you don't know how to code in another language. # Go reference material Assuming you are more familiar with programming, you are still going to want some reference material. This is especially true if you are familiar with another programming language and don't go through an entire course like Todd's. Below are some books and reference materials you should bookmark. - https://gobyexample.com/ - Quick reference implementations of different things in Go. Awesome when you just want to an example of how something works. Not so great if you don't know what that something you should be using is. - https://tour.golang.org - The official tour by the maintainers of Go. This is only useful if you know how to program in another language, otherwise it moves way too fast. If you do know another language, this is likely a good place to test out Go and get a feel for it. - https://golang.org/doc/ - You likely won't learn directly from these docs, but they are a good reference at times. - https://godoc.org/ - Like the docs above, but this also includes third part packages. # Learning HTML, CSS, JS, the command line, etc If you want to learn HTML, CSS, JS, or the command line I suggest checking out the Learn Enough to Be Dangerous series by Michael Hartl, the creator of Rails Tutorial. - **Learn Enough to Be Dangerous** - https://www.learnenough.com/ Everything is available free in web format, but if you benefit from it I suggest you buy a copy to support Michael. He is also a great educator and I'm a big fan of supporting people who help educate the next generation of developers. # Books for after the "beginner" stage After that, you are likely going to want to start checking out some more advanced material. If you want just a full list of books, there is a fairly large one maintained on github: https://github.com/golang/go/wiki/Books Of those, the ones I have some familiarity with are: ## Go in Action - http://goinactionbook.com/ I haven't read this entirely, but it is an amazing reference for anyone past the beginner stages of Go. I believe there is a sample on the website, so check that out to see if it is for you. ##Learn Go - https://yng.mn/learngolang Again, samples are on the website, so check it out and see what you think. You will likely want to pick between this and Go in Action if money is tight, so see which jives better with you. That said, there is no harm in owning both :) Oh and if you email me - jon@calhoun.io - I can possibly get you a discount for this one. ##Web Development with Go - http://usegolang.com *Full disclosure, I am the author of this book.* This book teaches web development with Go and is good for someone in a near-beginner state all the way up to an expert in another language looking to get into Go. It is meant to be very similar to Rails Tutorial (https://www.railstutorial.org/) where it guides you through the process of building you first really simple web application that is 1 page and 15 lines of code all the way to building a production ready application. I started writing it because after two years of using Go I still didn't see anything near as good as Rails Tutorial for Go. I try to make this accessible to beginners, but I don't spend time teaching HTML, CSS, etc. Maybe eventually, but for now I recommend you check out Michael Hartl's Learn Enough series (linked above) to learn those things. The book has about 8 chapters done of ~20 total chapters; That translates to over 150 pages of content that is currently available now, and the final book will probably exceed 300 pages. I can provide a sample if you are interested, and I can definitely get you a discount code for this one :) # Go Blogs Books are great, but blogs and mailing lists are also a great way to keep in touch with changes in Go, learning new techniques, etc. The ones I read most frequently are: - http://dave.cheney.net/ - Dave is a gophercon organizer and is pretty involved in the Go community. He also has a list of beginner resources here: http://dave.cheney.net/resources-for-new-go-programmers - https://medium.com/@benbjohnson - Ben has some great articles on standard libraries, structuring Go code, and much more. Definitely worth checking out. - http://golangweekly.com/ - Not a blog, but this newsletter has some great articles in it every week and you can reference the old emails on their website here: http://golangweekly.com/issues Tons of great content there. - http://www.calhoun.io - This is my personal blog. I mostly focus on web development and algorithms, but there are posts on other topics as well. You can always email me with specific questions too, and often those discussions inspire posts. - https://twitter.com/dotgoeu publishes some great articles and blog posts given by speakers with a large array of backgrounds on twitter. The site with the posts is http://www.thedotpost.com/ - https://www.goinggo.net/ - William Kennedy's (author of Go in Action) blog. Pretty much everything here is good as well. # Online communities Online communities also can be really helpful. The best ones I have seen are: - r/golang, r/learngolang/, and r/learnprogramming - https://forum.golangbridge.org/ - http://discourse.codenewbie.org/ - not Go specific, but intended for coding beginners # Debugging Some people asked me about resources for debugging, so I tend to send them over to this blog post: http://blog.mailgun.com/introducing-a-new-cross-platform-debugger-for-go/ You should also get familiar with the `log` package in Go. Most debugging can be done with print statements. # Disclaimer I included more resources than you will need, so don't try to use them all. Instead pick and choose ones you like, and if you ever get confused or stuck check to see if another resource covers the same topic. More than anything, you just need to build things to learn Go. Best of luck! And feel free to PM or email me with questions. 
&gt;when I was learning how to write webapps routers were difficult to grasp, had no clue how they worked, now that I know it, it is time to use a router What is it in web routers you found difficult to grasp? 
To be honest, I understood **nothing** about webapps. I was in a stage where I didn't even know the difference between GET &amp; POST methods. I read a lot of books and stuff; but they always have a statement "We expect you to be familiar to webdev", either that or they taught 1+1=2 and expected me to write a thesis on differential calculus. I begun reading code, just like the Vue project and I understood things by example. I built a todo list manager and wrote a book which I have commented in an earlier post.
You are welcome :) I did not try polymer. To the best of my knowledge, polymer is a lib for web components. Vue is webcomponents + reactivity + (other ecosystem like router, state mgmt). But you can try Vue. It is really simple and easy to understand. I am planning to write a small tutorial on vue. Also, the docs for vue are amazing and small!
Awesomesauce. that is some nice info and I had no idea about that issue, thank you! 
Most of those are long dead and likely never to receive support. As much as I love Alpha, PA-RISC, and the amazing m68k, their fates are sealed.
sparc64 is very much alive, and I wasn't suggesting otherwise.
&gt; No, Go was created to cater to the lowest common denominator of developers. Because they couldn't be trusted to not abuse language features. I disagree unless you consider the average developer to be the lowest common denominator. At scale there are no brilliant and bad developers. There are just average developers. I hope you'll be able to see that. If you cannot, let's just agree to disagree. I hope you'll keep enjoying Go regardless. I'll end with this quote that I find quite fitting for Go's lack of features: "I fear not the man who has practiced 10,000 kicks once, but I fear the man who has practiced one kick 10,000 times." ― Bruce Lee
Please also add an example or two to the readme. :D
As for the rest: * m68k runs fine on qemu and Aranym, the Amiga and Atari community is also still very active. Both the kernel, the toolchain and glibc are actively maintained. qemu just got a new maintainer for m68k. Plus, new hardware using FPGAs is on the way. * sh4 is being resurrected as [J-Core](http://www.j-core.org). Kernel and toolchain are actively maintained. * hppa has no new hardware, but kernel and toolchain development is very active, the port is in a very healthy state. * powerpcspe, powerpc are being used for new Amiga hardware. * ppc64 (big-endian) is well supported and has a golang port. * alpha is similar as hppa but there are some kernel and toolchain issues, development isn't as active as hppa.
This is amazing. I love you. I will try adding this to Debian *unreleased* for *sparc64* this weekend. Edit: This is currently Solaris only, so it'll need some work for Linux/sparc64.
I do not really understand what you mean by a lot of JS. of course there will be a lot of JS! We are building a front end right? Also, from what I have read, Polymer is just a lib to build components, Vue is a react alternative, using which you can build front ends, polymer would be a small portion of Vue, the component one. What I mean by reactivity is that when you use `&lt;p&gt;{{message}}&lt;/p&gt;` in a Vue template and you initialize the `message` in the Vue instance then if the message is changed by you in the devtools or by the app, the `&lt;p&gt;` is updated, thus reactivity. Vue's docs are also amazing. http://vuejs.org I have had the opposite feedback of React, from what I have read, people are starting to move away from React, read a lot of -ve things on Reddit. Also, I am a little wary of Google, they have a habit of killing projects. I'd look into polymer and get to know it better.
Back
Interesting, thanks for sharing.
As a fellow CBM user, I recognize and applaud the community efforts to keep these things alive. I also recognize the commercial realty behind them, and the scope of influence that brings. 
&gt; I tried the angular tutorial, didn't understand it. Out of curiosity, were you trying to learn Angular 1, or Angular 2? 
&gt; I do not really understand what you mean by a lot of JS. I did not meant it literally, that is why I put 'a lot' it in quotes. Sorry for the confusion. &gt; of course there will be a lot of JS! We are building a front end right? I attempted to explain myself on this one but I probably did a lousy job. I'll give it another shot: When I tried polymer, I found that there is less javascript than other solutions and I liked that. &gt; Also, from what I have read, Polymer is just a lib to build components Indeed that is true but a front end is composed of components. They have a [demo](https://shop.polymer-project.org/) that showcases that. &gt; I have had the opposite feedback of React, from what I have read, people are starting to move away from React Well that is good to know as my first impressions of React were not the best. &gt; Also, I am a little wary of Google, they have a habit of killing projects. That is a very valid concern. &gt; I'd look into polymer and get to know it better. I can recommend [this talk](https://www.youtube.com/watch?list=PLNYkxOF6rcICc687SxHQRuo9TVNOJelSZ&amp;v=VBbejeKHrjg). I will also try Vue. Thank you for all the info. 
Hah, i got excited thinking this was a Go-&gt;wasm compiler. I know i know, Wasm for Go is a long ways out because it requires Wasm Phase 3 GC integration.. but it doesn't *really* need that in theory, it just means you have to ship the full Go GC along with the wasm binary. Not feasible for production sites, but side projects or home servers is another story.
this 'reactivity' you speak of sounds an awful lot like property bindings (aka the observer pattern). Polymer also has 'reactivity'.
what's so hard about differential calculus? :)
I haven't been able to find any screenshots of anything made with "Shiny".
I'm curious about the decision to not check in the vendor'd source. I know a lot of people make that decision, to me I hate it. Having the source in my repository means I have a consistent reference and I don't worry about team members introducing version discrepancies or new dependencies for others to vendor.
Yeah, I ran across that same post when trying to pool the Gob encoder and decoder, which you can't really do, because the encoder itself is stateful. You can specify a different encoding method on the options, for example JSON: store, err := bolthold.Open(filename, 0666, &amp;bolthold.Options{ Encoder: json.Marshal, Decoder: json.Unmarshal, }) And I haven't seen much difference in performance between Gob and JSON, and the overhead of both, is minuscule compared to the cost of disk access. 
It also has to be on a white background.
Non-monospace font for coding? o.O yuck....
Personally I don't like committing the vendor directory, it just doesn't feel right to me. I can see the advantages of doing so (source repo disappears, don't need to clone all deps on initial check out or each ci run, etc). I feel like not committing vendor makes me look closer at the packages I am including in my projects. Arguably I should be doing that regardless of committing vendor.
I had a much cooler name (wagon) but I figured I should keep it for the real thing :P
Relying on the package manager and the glide.lock file should be enough. 
 value, err := factory.Default.GetByType(new(example.Controller)) controller := value.(example.Controller) This seems like a lot of extra work to cross the DI boundary. What is stopping you from supporting an interface like: var controller example.Controller err := factory.Default.GetByType(&amp;controller)
`git submodule update --init`
came here to say the same thing, at least the proportionally-spaced fonts hurt my eyes, the larger bold monospaced fonts are much more pleasing
Good to know :-) As I said earlier, I had 0 knowledge about front end, I was blown away at the ease which Vue offers! I still have little knowledge about front end, I am a total newbie.
I love differential calculus! but when you expect someone to understand it, you don't teach them 1+1=2 and say, okay now, enough theory, go figure out differential calculus on your own :-D
I mean... seems harmless enough? It's a useful language feature I oft finding myself lamenting the lack thereof. Could it not be added to the language and maintain Go 1.0 compatibility promise? Since it's not changing an existing thing and only adding a language feature (such as making type identifiers in map literals optional, and so forth). Was there some specific philosophy/technical concern that decided that this would not be included (in the same vein as Generics or something)?
That is good news! Thank you. I feel that the more examples we have about these things, the better for newcomers to understand them. I am thinking on putting together a short series of articles and distributing them in PDF/gitbooks format, it would be a practical tutorial about building apps in Vue (can have a chapter later about Go backend). Do let me know. I still have a _lot_ to learn, like the vuex(redux) things etc.
To [quote](https://groups.google.com/d/msg/golang-nuts/w1dPeHFSp9g/cMjgL76B7jIJ) Rob Pike from '14: &gt; Go has lots of ternary operators. If you're speaking about the lack of a?b:c, which for some reason is often called "the" ternary operator, it's because it is the source of too many readability debates and much ugly code. Better not to have it. &gt; &gt; -rob Also perhaps see [here](https://groups.google.com/d/msg/golang-nuts/rt_10QiYtmk/YWBmunxQ7TIJ) and [here](http://stackoverflow.com/a/19979829/5905344). &gt; in the same vein as Generics or something I'd just like to raise the point that this vein might not be clear to you or to others. The official stance (_roughly_ "generics are hard to implement right") is very different than the commonfolk stance ("Go developers think they don't need generics / don't like them").. which vein are you talking about?
there's already some good discussion about this at https://www.reddit.com/r/golang/comments/4fsh1m/should_go_have_a_ternary_operator_or_was_it_left/
&gt; I believe that one of the problems Go is very fitted to solve is that of unreadable, gargantuan codebases, with too few comments and tests, too hard to refactor and too unstable to tweak. Have you heard the saying "Real programmers can write Fortran in any language"?
How long have you been using Go? My advice is to wait before making a judgement. Give it a few months or maybe even a year of serious development with go. Then come back and ask "does go really need x" where x is any feature you missed at first. I felt a little let down by a lack of a ternary at first as well, but after using Go long enough my view has changed. The ternary just feels like a cheap way to merge a few pieces of logic all into one line, and that doesn't improve readability. It may not hurt it every time, but it never seems to improve it.
The name of the particular course is [On Track With Golang](https://www.codeschool.com/courses/on-track-with-golang)
I got complete product (well almost) which uses webpack, vue.js, vue router, vuex, vue components, and these all things are compiled into single binary. I got still couple of tasks to solve there, but it's almost prepared to be beta tested. This is a screenshot how it looks like, so you can see it's not really trivial app.. http://i.imgur.com/ax6bdbo.png
I love you!
Thanks I really think this comment is very useful. Yes, I'm looking for a way to make this as idiomatic Go as possible, i.e. optional interactions with channels. However, the reactive philosophy usually goes against exposing a language's concurrency constructs, since they are abstracted into observable-observer pattern. With your suggestion, it almost beats the purpose of writing an extension at all (Imagine rxPy for Python exposing threads, for instance).
We had a brief [discussion](https://www.reddit.com/r/golang/comments/5d27j3/interesting_ways_of_using_go_channels/da2ob65/) about this with the author of [Why Go’s design is a disservice to intelligent programmers](http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/) who is apparently using Go nowadays. No drama please.
D has that too
https://thewhitetulip.gitbooks.io/manuscript/0.0installation.html is giving a 404
The stopping part should be that this is all unnecessary.
This is good! I am looking forward to reading the source code. I also want to understand how to use vuex/vue router and webpack!
You are correct, there is nothing to comment on :-D Also, yes, the API is not implemented, because I just wanted to make sure I can get the GET/POST requests to the backend, once we have the connectivity, then we can easily add in stuff to connect to the db/send notification or anything for that matter. if you have the time, then I would like to know how to improve the codebase here, http://github.com/thewhitetulip/Tasks.
It works now, I got the link from your github page (read online, next chapter) and it gave me a 404. It's working now though, thanks!
I found out about vanadium by being randomly cc'ed on an issue. Blew my mind when I finally realised what it was. It's a shame that it never actually "launched". I still believe there's huge potentially for projects like Vanadium, hence my own work on [Micro](https://github.com/micro/micro), but Vanadium started in a time before gRPC and Kubernetes. While there was significant amounts of code in the Vanadium project, it was at times hard to follow and some of the concepts were abstracted in a way that again made it hard to reason about. The tools likely to succeed will have much more familiar concepts and abstractions akin to the kernel, the datacenter and systems engineering. Shame to see it get EOL'd but glad that it's still on GitHub for people to try out or be inspired by.
&gt; Explosives can be abused negatively, but they can also help you from having to use a pickaxe to extract minerals from the earth. Thats not a fair analogy. If-else is just very slightly longer. 
I really like the state machine pattern from this talk and have used it a number of times.
Yes
The url of this video should be the title of #go-nuts on freenode, for many years to come.
Sure, I concede that it's a bit exaggerated, but more to highlight the point more clearly is all :P I had a a feekubg someone would comment to that effect!
That statement links to the code review: https://go-review.googlesource.com/#/c/29656/, where there are results of up to ~43.3% overhead reduction reported.
and the video is 5 years old...
There's new people getting into Go every day and excellent videos like this (unfortunately) do not come often. So it is good for old and new gophers to (re)watch them.
I believe the problem is that map keys are [randomized on iteration in the normal runtime](https://blog.golang.org/go-maps-in-action#TOC_7.), except ~~they're not randomized~~ the random seed is fixed in the Go Playground runtime. In this case, we compose the result by iterating over a map, so the result is not deterministic. Whenever you're writing unit tests that depend on the ordering of map keys, you'll need to sort them before comparison to produce deterministic results.
thanks for the reference, that's definitely it; they are randomized in the go playground runtime as well fyi - you can run it a few times to verify
Pick a dependency version system (no go get and vendoring are not acceptable) and add a function by default that can check if a value is in a slice.
Literally every other modern language as the option of if x is in list y. This is a solved problem, I shouldn't have to rewrite it. Even if it's a not very elegant function or you need multiples to get around the lack of generics it should still be in the base language.
http://imgur.com/gallery/U7Ghu2s :)
This reminds me I used this article a while back to write a few parsers myself. I ended up abstracting out some of the more common functions into a helper library and added in some error logging. [https://github.com/deslittle/go-dsl](https://github.com/deslittle/go-dsl). It's only got two basic tests but if anyone is interested I might go back and beef up the documentation.
Sets arent ordered both are correct.
Despite being trivial it's still visual and maintenance noise in my opinion. That's 5-6 lines X however many times you have to do it X probability that a junior dev will blunder it.
Check out text/template. :-)
I believe the playground is randomized, but always starts with the same seed -- which I suspect you know as well. :-)
If you know any, please add them!
And then put that function in the go library 
Yeah, the joke is threefold. First, they write that the language name is Golang, then they add the word language right after that, then they misspell that word to lanugage. I don't know I just found the combination hilarious especially when I say out loud "Golang lanu-gage"!
This made-up example is readable but does not make sense. In one branch you are asynchronous, and in the other, you aren't. $scope.clientData is undefined while you fetch the client data. This looks like a broken promise. Rewritten with an if, the problem persists. 
I hear lanugage every day! Don't you know lanugage? It's the greatest word ever!
If the committee uses the results of a 1000 people survey to make decisions that will affect the whole community for years and years to come then we are all going to have a very bad time.
I dont think that Go is competitor for Java or Scala. https://opencredo.com/java-go-back/ From Java to Go, and Back Again
&gt; I will point out that even the use of the else keyword itself, in most cases, is considered unidiomatic. That's a surprising statement. Care to elaborate?
If you have concerns about a decision made via public survey, you need to make people aware of it and have them submit data. If even with your effort, the decision goes against what you like, then it's not a failure of those who are using the survey to decide and rather a failure of you to bring enough people to even care about the issue. I'm pretty certain that most people won't be negatively affected by this change.
I'm not totally sure what you're cautioning against. The survey results were presented to the committee and served as a great barometer of [at least an active subset of] the community's opinion. There were many other considerations, all quite painstakingly documented in the various Google Docs. Happy to answer any further questions if you've got 'em.
Author here. I'm open to a code review or notes of any kind :)
It would be interesting to know from the 54 people who have answered "Never" to "I need to have reproducible builds". What requirement might drive you to **never** have reproducible builds ?
&gt; There were many other considerations, all quite painstakingly documented in the various Google Docs. As long as these other considerations are taken heavily into account vs trying to satisfy as many people as possible then it will probably end up fine. I do not want to cause any drama. I am just concerned, that is all. I'll link you some of my concerns based on what we've seen till now: 1) https://www.reddit.com/r/golang/comments/5abj7i/draft_spec_for_package_management_tool/d9n079g/ 2) https://www.reddit.com/r/golang/comments/5abj7i/draft_spec_for_package_management_tool/d9fs2cq/ 3) https://www.reddit.com/r/golang/comments/5abj7i/draft_spec_for_package_management_tool/d9hbhoc/ I do not mean disrespect with any of this and I am grateful for all the work the committee is doing.
It's like the theme for 2016. 
I think you're misreading that. My take is "Having reproducible builds is never a requirement for me".
Like we see when we compare Go with other languages, it's very difficult to argument on the principle that a lack of feature is a feature. It's the same with PM. Without standard PM in Go I feel more comfortable than with Python and pip for example. And I remember the time when we had not pip and virtualenv in Python. How we did ? We was taking more care about dependencies and compatibility. I think it's what we do in Go now and it's a feature. The more the PM will be fine, the less we will have to take care of compatibility and dependency. It will be worse again.
I think that's the same. Why would you NOT want your builds to be the same?
Got amazon link for that usb dvb/fm stick?
Thank you of your reply! &gt; but you may end up sending an interleaved message Mhh, like multiple messages mixed? &gt; I imagine - as he mentions in the post - you're more likely to have a struct pointer or interface that wraps a conn, and provides mechanisms for appropriate syncing of messages going out. Ahh that explains it. It wasn't relevant for the example in the video, so that's why he went the 'easy route' in the example, I guess.
&gt; I practically never use goto but I am happy to be able to use it when all else fail. I understand you don't agree with that. No I agree and I am fine with goto. But it is quite a different case than ternary operators.
Good call, updated. :)
Yes, he was being sarcastic by saying "totally readable" to mean that it is in fact "unreadable". But to me, this is in fact readable. The only difficulty is operator precedence, which varies from languages. I would add parentheses. I would have loved to refactor the affectation out of the ternary branches, but as I said, both branches do something totally different w.r.t. evaluation time. What should happen after this snippet when someone wants to read $scope.clientData and the data is not yet fetched? This is the real WTF here.
Because for you goto and if statements are primitive operations, whereas ternary if expressions are syntactic sugar? Because you don't view an if as a primitive expression like "and", "or", "+", but as a statement? Because machines use JMP operations and by manipulating such constructs in Go you are somewhat closer to how the hardware operates?
&gt; Yes, but the question was more about you. I suppose you would not defend ternary if even if they were added in the next version Due to the experience I have described at my first post, no I don't think I would easily defend ternary operators. &gt; or that you would still like gotos if somehow they never were included. I would probably like it if goto was not included in Go. But since there are strong reasons for it to exist and it has that "stigma" then I am fine with it. &gt; I think the quote is: Yeah that is exactly what I meant! Good job finding it.
What makes you think [go wouldn't support unicode in type names?](https://play.golang.org/p/UdOWcXHYkE).
Ok, but I don't really see that as "most cases". Besides, I consider the second version better in some cases: I prefer to reserve the first version for "special" cases, like bar == nil. But I've checked my current project, and there are quite a lot of cases where the first version won't work, e.g. in a loop, or in general, when the condition is not the last statement of the function.
This is totally valid javascript. It is undefined while you fetch the promise data, but (because angular) with an `ng-if`, the watcher will just wait for `clientData` to exist and then rerender. If those conditions are not met, leave clientData as `null` so the watcher does not rerender.
How is it better than [Haxe](http://haxe.org/), which already fully supports dozens of programming languages?
If we switch from Java to Python to Golang, it counts ? ;-)
*shrug* I dev for a php app that does 200 mil a year. Not sure how that's supposed to be an insult.
Yet another github page with no useful information about what it does or why one might want to use it.
https://github.com/jmartin82/mmock/tree/master/config
impressive
Not the author, and not exactly replying to your question, but this is the cheapest one I could find (and buy... bought two some months ago): http://www.gearbest.com/tv-box-mini-pc/pp_188367.html (no affiliate code. If you don't trust me, just google "gearbest rtl-sdr"). It's shipped from china, so shipping takes ~1 month, though... Depending on where you live. AFAIU, it's always the same chip between "different" models... It's famous, so you can google "RTL-SDR" and find LOTS of info and cool stuff. also, there is /r/RTLSDR , IRC channels, etc. about this.
Go 10x faster!
Waiting more than 30 secods, and I stop it.
And something like this isn't in the base language because... why? It's 2016, not 1995.
Reflection adds some overhead. Writing your own version by specifying the type is trivial and faster. BenchmarkContains-4 3000000 437 ns/op BenchmarkContainsInt-4 500000000 3.22 ns/op But I totally agree with your point about functions.
Writing your own version of `contains` and specifying the type is trivial. Not every program needs a generic solution which [as you can see](https://www.reddit.com/r/golang/comments/5drkak/dotgo_2016_john_cinnamond_a_look_at_the_criticism/da98iyc/) adds some overhead.
There are many things I want to do in my Life. I chose to learn Go, and then I will be able to do everything in parallel
&gt; Well sometimes you gotta say unpleasant / not necessarily milly willy things in order to keep discussion constructive. There is nothing constructive about your comment.
Yay!
&gt; I don't trust you so I'm not going to visit the link. In the end it might be some scam or phishing anyway Fair enough. Here you go. This might help you: constructive /kənˈstrʌktɪv/ adjective 1. having or intended to have a useful or beneficial purpose.
You and I have a very different definition of what an "ultimate Go build system" is...
https://github.com/mcandre/mcandre/issues/24
Did you look at the page ? Seems like it's something equivalent to protobuf , it's not a programming language
I am afraid I not familiar with the `\s` idiom. The closest thing that comes to mind is something in the context of regular expressions. Or is it some kind of obscure escape character? Some fancy vim command? In any of these cases, I am failing see how it connects to my poor attempt at being funny.
"&lt;sarcasm&gt;...&lt;/sarcasm&gt;" evolved to "&lt;/sarcasm&gt;" and eventually degenerated to "/s" because people of the interwebs are kinda lazy
But you prefeed the algorithm with info where to start. The whole point is that my code check where the knight should start
The knight could start on any position.
Didnt really happen to PHP-FIG, but to a framework in the PHP community (PHPixie). Was rumored to be the framework author that did the botting.
ok after some more searching, finally found it. https://github.com/golang/go/commit/104cd57c6d8f63eae00564eeca6de80d09e27a17
Thank you so much!
&gt; But sometimes your are not Galileo, the majority is right and the "different kind of medicine" is wrong. But what's the point in writing a language that's pretty much the same as all the others? &gt; What I find dishonest is how critical thinking often stops when talking about Go. When Go has it, it is because it serves pragmatism and real programmers who know better. When Go doesn't have it, it's because YAGNI, go play with your toys and let real programmers work. Doesn't that also perfectly describe the mindset of many of the critics, i.e. "Go lacks X, therefore it is a toy/newbie/Stone Age language"? &gt; But since Go makes extraordinary (and provocative) claims, people wait for the extraordinary evidence Don't the great uptake and impressive projects being written in Go count as evidence? To be honest, I'm not following your "false dichotomy" argument. People are managing to create lots of very useful projects with Go just fine without all these supposedly important features it lacks. YAGNI seems a reasonable enough position when you're *already* getting along just fine without X or Y. As best as I can tell, it boils down to "Go programmers think the language is mostly fine as it is, while you (and many others) disagree." I don't see why you're framing that as some kind of drunk-the-Kool-Aid hypocrisy/delusion on the part of Go programmers. I mean, why are you right and they wrong? As noted, Go programmers seem quite happy with the language and plenty productive enough. So where's your evidence that they're not or that they'd have been better off with C# or Rust or Haskell or whatever? 
MIPS doesn't support soft-float yet (if ever).
This was not very informational at all, it seems more like and ad for codeship
Yes, you can use ReadAll to get bytes for current Entry, you can use EntryFor if you know filename in archive, there is no need to extract all. What is missing currently is function to list contents of archive.
There exist at least one[1] closed tour, i.e. the end position is within a single move form the start position. Hence you can choose any position and repeat that one closed tour. When I said "There's a lesson to be learned here", I wanted to point out that it's also important to understand **why** something works fast. In this case, one of the subproblems **happened by accident** to find a solution faster, due to the specific ordering of the recursive invocations of `tryToMove`. It has absolutely nothing to do with parallelism. The solution would be found relatively quickly even if each try for a next move was done in lock-step, interleaved without any parallelism with the other tries. There's a pitfall too. The goroutines are not preemptively scheduled: it may well happen, that the *lucky one*, which finds a solution quickly is not a part of the initial batch and has to wait its turn to run until one or more of the other goroutines finish their work. Otherwise, the approach taken in the original program is valid, in principle: spawn a few different ways to solve a problem, query a few different servers, etc, and take the one that finishes first. However, toy programs aside, when you think about actually employing such approach as a solution in a real-world program, you have to think what happens to the workers, whose work is not needed anymore. Obviously, you cannot afford letting them run potentially for millennia, hence you have to think how to communicate to them that a solution has been found. [1] actually 19591828170979904 ones, but just a single one suffices 
Does this work for rar files that are split across multiple files/buffers?
Yeah I agree but my point was that when you need to find if a slice contains something, the first thing you write is a type specific function and not a generic one with reflection (unless you need a generic solution of course). Obviously if you have a lot of data you are gonna choose binary search over linear. That is standard stuff.
&gt; Go is the only modern language that was created after computers had more then one core Rust? Swift? Crystal? Pony? Elixier? Perl 6? Nim?
I've taken note of many of the comments here. Thank you for the feedback! If you enjoy this kit, please follow the GitHub issue tracker to see where things are going and how you can contribute.
Python 3? ^I'll ^^see ^^^myself ^^^^out, ^^^^^sorry...
What's the benefit of using interface{} over string?
`interface{}`, or empty interface, is a type that can store a pointer to any type. It's kinda `*void` for C and `Object` for Java. You can read more about why `interface{}` is so powerful here: http://research.swtch.com/interfaces
thanks for your response, yes they aren't but my question was around the specific bug that exists in the linked code
Thanks for writing this. It's hard to keep this all straight.
The author edited his article since then: &gt; Go is one of few languages that were created after computers had more then one core
Maybe it's too early in the morning and I don't see the obvious, but how can `string` replace `interface{}` in this particular scenario? 
That's a wholly different issue: how to structure code. That's unrelated to the language and its idiomatic use, IMO.
&gt; who outlined his specific problems Sorry but from my perspective he didn't outline any specific problem. He merely complained about a feature that Go doesn't have. &gt; watchandremember claimed to be a PHP developer, so I'm not sure he is using Go anyway If that is true then this is yet another reason to *not* give someone new to the Go language a generic solution based on reflection even on something so easy as this. Start with a specific solution and use reflection only if it is needed. "[Reflection is never clear](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=15m24s)". 
To hell with those early mornings! :-)
Phyton 3 is not "new", it's still Phyton 2.7 2.0 basically, not created from scratch.
It was intended to be really simple: local filesystem, and local databases.
http://research.swtch.com/interfaces
Thank you.
Just tried, it doesn't work for split rar files: ! rar.c:71: Splitting files isn't really supported ! uncompress-rar.c:24: Unexpected EOF during decompression (truncated file?)
I recommend using a `chan struct{}` instead of a `chan bool`. The compiler knows that the size of a `struct{}` is 0 bytes, so a call to `make(chan struct{}, 1000)` will allocate much less memory than `make(chan bool, 1000)`.
&gt; His stated problem was writing the same code over, and over, and over, and over, and over, and over, and over again. Your solution: Write the same code over, and over, and over, and over, and over, and over, and over again. But this time Wrap It In A Function™. Your solution: Write the same *reflection* code over, and over, and over, and over, and over, and over, and over again. But this time Wrap It In A Function™. &gt; Look, I get where you are coming from. In the typical case, your suggestion is perfect. However, I just went back and read your exchange with watchandremember and it is still abundantly clear that he was not finding your solution satisfactory for his specific set of problems. You weren't listening. I also went back and and reread what watchandremember wrote. It is abundantly clear that not only he didn't specify what he needed in detail but most importantly that he doesn't care about this discussion whatsoever. So it is basically just you and me arguing over nothing. &gt; Nonsense. If he is new to Go he should be failing fast and breaking things. That's how you learn. reflect is quite possibly the best way to fail fast and break things when it comes to Go. You don't wrap kids in a bubble and then at the age of 18 you throw them into the real world, no, you let them get out there, scrape some knees, break some bones, and then by the time they are 18 they have the experience to understand how to avoid the pitfalls of life. Engineering is no different. There's a reason we have junior and senior developer classifications. Nonsense. When you write Go code and you need to find something in a slice, you quickly do a for loop and move on to the next problem. In fact I wouldn't even call it a problem. You just write it without even thinking about it. You do not start writing reflection code, failing and breaking things. Better fail at something that includes your application's problem domain; that would be something worth breaking stuff and spending time on. Not something as trivial as finding something in a slice. &gt; &gt; "Reflection is never clear". &gt; In which case he isn't going to use my function anyway, so your concern is completely unwarranted. Not many people are aware of the Go philosophy. Proof is yourself when the first thing you proposed as a solution was reflection. So my concern is very well justified and in fact just proven. Anyways I am not even sure what we are arguing for anymore and this has started getting very tiring for me as this is a totally pointless discussion. I do not know if we agree or disagree but if we disagree let's just agree to disagree. Use whatever code you want, break all the things you want and teach new people whatever you wish for all I care. I am done here. 
Is there any reason you can't rely on the runtime randomizing iteration with: var randomValue mapKeyType for k := range myMap { randomValue = k break } ?
Indeed! I mention why in Part 3, but I also talk about it more explicitly in the randmap [README](https://github.com/lukechampine/randmap): &gt;The (current) map iterator implementation simply chooses a random index in the map data and iterates forward from there, skipping empty "buckets" and wrapping around at the end. This won't produce uniformly random values due to the "skipping" behavior. I even added [a test](https://github.com/lukechampine/randmap/blob/master/randmap_test.go#L44) that confirms this behavior.
&gt; is it a problem that needs to be fixed in the first place? I am wondering the same thing and only an expert from the Go team can tell us for sure. /cc /u/bradfitz
You're absolutely right. I've changed the implementation. Thanks
Nice, very clean solution.
Yes it's very straight-forward under the hood. I've created it because I love the expressiveness of the syntax of sync.WaitGroup. 
Nice, that looks really great. Any reason why MySQL over Postgres? or at least allow us to choose? I'm not really that fond of MySQL anymore and have been using Postgres for years already. Edit: sorry I see both now in the vendor directory, so I am assuming you do allow Postgres :)
Had you thought about making pull request with map API extension?
I wonder why they use QEMU instead of KVM or Xen. EDIT: I think I misunderstand QEMU...
You mean to the official Go repository? That's an interesting idea, but you'd have to be careful not to break the Go 1.0 compatibility promise. I think the only place it could fit into the standard library is the `reflect` package. The `runtime` package already exports some functions for use in `reflect`, so it could add `randmapkey`/`randmapval`. Then, `reflect` would add new methods to the `reflect.Value` type called `RandMapKey`/`RandMapVal`. So it's possible, but I doubt that it's useful enough to warrant the effort. That would be super cool though!
I liked this write up, I do map conversion in a library from other types and I do some awful (but fast) things to avoid reflect package for map keys when I can. I went down a similar path as you because I found it interesting but the rabbit hole stopped being interesting a bit sooner for me (and I realized it was unrealistic for something meant to be "safe"). I wish Go had something in reflect API that wasn't so defensive for fast map iteration though, assuming a map would not be mutated during iteration would be OK for most use cases and enable a ton of speed up. Example of [map conversion](https://godoc.org/github.com/cstockton/go-conv#ex-package--Maps) that could benefit from a derivation of faster map iteration to avoid ugly (albeit efficient) things [like this](https://github.com/cstockton/go-conv/blob/master/map_gen.go) lol..
I understand, but I thought that being idiomatic is not (strongly) related to other issues of style. It's always possible to program without an else: BASIC notoriously makes you do without it. You can also get rid of for and while, or recursion, or switch. Perhaps this is a good topic once we're done with tabs and spaces (insert smiley of choice).
Awesome! We definitely appreciate your work as well. We weren't sure it would be possible to get the libvirt RPC working from Go, but after some trial and error, it ended up panning out. Feel free to join us in #go-qemu on freenode if you want to talk more about it!
I don't remember that font enough, but if it is really similar then it would be a font equally good for Go and FORTH (the language available in the Sun boot monitor) :-)
Nice! The support for the `delta` is very great.
You likely do not need to worry about reflection. "Reflection in computing is the ability of a program to examine its own structure, particularly through types". For instance, you can pass a struct into the json Marshal, and it will output a json object which uses the names of the passed struct's members (even though the marshal-er just accepts interface{}) https://blog.golang.org/laws-of-reflection
why wait to be fired when you can quit?
Yea you're spot on, the type switches compile into a big JMP table for d&amp;c, they were unexpectedly fast, I initially started with a 2 dimensional LUT table partitioned by the reflect.kind but the cost of the lookup + getting the reflect.Kind (plus you need resolution of the element and key types) ended up being around 50x slower then the giant switch. Python for loop for the win. :- )
Well I guess I'll worry about it again once I have a bunch more experience in Go, thanks. 
From the laws of reflection post (emphasis mine): &gt; [Reflection in Go is] a powerful tool that should be used with care and **avoided unless strictly necessary**.
Thanks for the reply. Ok so lets forget about the core fixes then. What does it mean to include all the critical items that the core team produces? Does this mean, for instance, that instead of waiting for an official point release from the Go team, that ActiveGo might release their own point release sooner? It seems that if there are critical fixes, that the Go team ends up immediately releasing a point release. As for the package support... so this means that ActiveGo decides which packages are the best, such as saying "your web framework will now be Beego", and then ActiveGo will provide bug fixes for Beego, potentially faster then they get merged in the original project? &gt; The value is in the support, documentation, ease of adoption/use, enterprise valued features, and risk reduction for specific customer needs. This is very "buzz-wordy" to me. So, in addition to the automatic documentation provided from the source via godoc, ActiveGo will write their own indepth documentation for each supported package? What is the ease of adoption and use here? That it already comes with, say, Beego as your web framework, so that you don't have to decide on one and run "go get"? I think the only thing I can really grasp here in terms of value is that if a user of ActiveGo does really like the specific selection of packages that you have decided to include and support, then at least they know they have paid someone else to fix their bugs in those packages as opposed to relying on the free support from the open source project owners.
reflection is legitimately different in Go than it is in other languages, because they legitimately have different type systems and guarantees. In Python for example, _all_ type errors remain remain undiscovered until runtime. In Go, many type errors can be found at compile time. If you fall back onto using reflect (or interface{}) for too many things, you're throwing out a lot of the guarantees that the Go compiler can give you that don't even exist in Python. Feel free to substitute your dynamic language of choice if you're not into Python, the point still stands: it _is_ different. it's rare that you legitimately need to use reflection in Go. The one major class of exceptions to this rule are when writing custom serializers/deserializers (uncommon for most projects) or for doing things with struct tags (incredibly useful but should be done sparingly). The one reason I find myself importing reflection in a lot of cases is to write better error messages.
To old and new gophers I'd like to remind some of the [Go proverbs](https://go-proverbs.github.io/): * interface{} says nothing. * Clear is better than clever. * Reflection is never clear. [Explanation](https://www.youtube.com/watch?v=PAAkCSZUG1c).
Does gofmt turn chocolate into gold?
Imagine: Harry Potter and The Formatting of Go.
I love gofmt. Sometimes I'll copy in a bunch of code that's all messed up and I just hit control-S and watch it all magically fall into place.
No, they turn orange
i dont see the point in this over something like glide
True that. But at least in Germany you get some kind of penalty when you quit. It's better to get fired.
Any specific reason why you prefer this company over digital ocean? Seems their main selling points are dedicated SSDs and ARM hosts? 
Same! I don't even bother with `:set paste` in vim anymore, at least for Go.
Also https://melody.sh/repo
&gt; The goroutines are not preemptively scheduled: it may well happen, that the lucky one, which finds a solution quickly is not a part of the initial batch and has to wait its turn to run until one or more of the other goroutines finish their work. The preemptiveness of the Go scheduler is not an issue here. Sure, Go has not a full preemptive scheduler, but only with a very specific code it cannot be full preemptive (like this one: https://github.com/golang/go/issues/11462). So, if there is a single function call in the go routine, this routine will be preempted by the Go scheduler. 
I'd rather just have one format to rule them all and not go back to the dark ages of formatting arguments.
I felt the same way. But then I found that vscode actually has a lot of formatters for various languages. So I hit "ctl-shift-i" and it will format go, python, javascript, etc. Mostly through plugins, but I still very much appreciate it. I assume similar plugins are available on plenty of other editors, I just never discovered them I guess.
also not my personal preference, but i swallow it for the overriding benefit of uniformity. submit and benefit!
Is there something in the works?
and magically yet here are two gophers arguing over formatting
I think solutions like Apple is doing with Swift server API's via a work group of several contributors is the key (https://swift.org/server-apis/). It would make things work much more streamlined and conform to golang standards.
[Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=8m44s)
Nah, not really. The people that are still complaining about formatting in the Go community can probably be counted on the fingers of one hand.
I'm sure you put a lot of work into this and your excited about the result so I'll give you some honest advice. Right now the article feels like just a tacky advertisement, least to me. If I was you I would make the entire interpreter and source available on github. That would be a great way to generate some buzz and people who may have otherwise skipped by may actually have their interest sparked by the source and want the reading material for interesting parts of the interpreter. Plus you will get stars, probably a trending repo since you put so much effort into it which will be more exposure. As it stands now there's very little attraction, just a marketing page with some bold text and a snippet or two. A full interpreter is the attraction, show it off to sell the product :-) Just my two cents. Either way good luck and good job seeing such a big effort through from start to end, that's admirable. 
Well I said probably. Besides there will always be irrational people in the world or people that just like to complain for no good reason.
Michael here from Gemfury. This looks similar in purpose to the repo cache I've built for our dependency manger: https://melody.sh/repo. We would love to work with you to get compatibility with said manager: https://melody.sh
You have a great attitude, so I bought a copy of your book for you to give away to someone on twitter or something for fun or promotion. I didn't click the download button, hopefully you have a way to check that. If you end up making it open source at some point I would be really interested to know if it had a positive or negative impact on your books success. Good luck!
Thank you very much for the support :). I will give it a try first. Never been a Linux guy. But ready to learn If I need to. 
Thank you very much for the link. I have read it. By more suggestions, I will start with Google app engine. 
which i also dislike. a team member put a dependency in our project with a gopkg.in url, and it broke on the day of that big DNS DDoS in October. guess i should start using the vendor directory, however i prefer my dependencies' source not be mixed into my repo
A new option is http://hyper.sh where the idea is to package your app as docker container and deploy it easily to hyper.sh hosted service (which is like Digital Ocean but for running docker containers, not linux distros). I use it for my blog http://blog.kowalczyk.info, which is a Go app serving mostly static files. You can see how I package it as docker image and deploy to hyper by following https://github.com/kjk/web-blog/blob/master/scripts/hyper_build_and_upload.sh 
&gt; What happens when you forget a ?? Then the compiler gives you an error that you did not set a default value for a nullable variable. Afaik some languages do that, can't remember which one (Crystal/Scala/Rust/Kotlin?).
This is awesome. Would love to try this out (even if not free).
Probably one of the cheapest and best solutions is DigitalOcean. Even if you do not have a lot experience with setting up a Linux server, they have awesome tutorials that guide through setting up and securing your server. You will learn lots of things this way but you might need to do some "server maintenance" eventually. If you want a free solution, your best bet is probably Google App Engine which also has the big advantage that you do not have to tweak or maintain the server. The big downside is that you need to modify your code to play with the App Engine platform which depending on what you write can be a lot of work. This also means that if you later want to migrate your program to a generic server, you will need to do more changes. Of course there are ways to write your code so that it plays on both App engine and a generic server but it can be quite a lot of work.
I was excited for a moment then I noticed that it is not open source.
Having null (nil) as possible value for string, int or any built in simple type in GC language is horrible idea in my opinion, that would be cause of numerous bugs. Zero values win hands down. And your syntax examples are readable as Perl.
138 char now.
Yes yes yes! Using `const p=` being shorter than `var p string=` I have saved even more characters! 129 bytes! package main func main(){b:=string(96);print(p,b,p,b)} const p=`package main func main(){b:=string(96);print(p,b,p,b)} const p=` 
http://www.gopl.io/ is $21.59 as an ebook. Are you seriously suggesting this book about an interpreter should be valued higher than the book that's bound to be the "D&amp;K Bible" (just google k&amp;r bible)?
I've found over the last two years that Go has a lot to dislike about it. The namespacing kills me, and up until discovering Dave Cheney's "gb" tool, the project layout drove me nuts. Still does on libraries, which don't fit gb's model well. `var foo = ` vs. `foo := `, some of the gofmt choices, .... I could go on; there's a lot to complain about. The thing I have to do is start playing with other languages to remind myself that Go's imperfections are far fewer than pretty much everthing else that I use regularly. So I tend to just temper my rage by reminding myself, "This is not Java, PHP, Ruby, or Python. I have a fast compiler, good compiler error messages (usually), and a fair expectation that my code will work if it compiles. I have good Unicode tools at my disposal. I can use vim and still have powerful features usually reserved for slow, bloated IDEs (goto declaration, for instance, via vim-go). I can ship a binary instead of installing ten billion packages onto my production systems. I can just live with gofmt's odd choices, and never have to debate code formatting again." It's not perfect, but it sucks less than the other stuff I use. :)
Library and Exciting... DOES NOT COMPUTE
&gt; It's not perfect, but it sucks less than the other stuff I use. :) Agreed. On the mention of your editor integration, definitely liking that because of a few smattering tools made with/for Go, I can transform Visual Studio Code into a full fledged Go IDE without the overhead and bloat as you mentioned. Syntax Highlighting, mouse-over hinting, contextual auto-complete, find definition, find references, instant feedback with errors/weird stuff (the little red/green squiggly underlines with mouse-over error/suggestion messages), easy refactoring, and heck... even visual debugging that I was so used to with C# from days long past!! All because of a small set of go tools wrapped up in a plugin for VSCode that I can run on both Linux and Windows. It's like heaven.
I'm suggesting people value their career development accordingly.
116 package main func main(){b:=p+"\x60";print(b,b)} const p=`package main func main(){b:=p+"\x60";print(b,b)} const p=`
Thanks for the sample chapter. I think it was enough to entice me to buy, but not very apparent on the page. You may want a large call to action for the sample.
Gofmt is probably one of the nicest thing about coding in go. Everyone just stfu about their preferred style and work together.
Your the reason gofmt is wonderful.
Conversely, I feel that $29 is a good price for content at this level. I paid about that much for a PHP way back in the day and that was just a language reference and building a fairly simple website. The topics of writing a parser, lexer, and all that goes into a programing language is way more in depth and, I feel, justifies the price.
Thanks for the detailed answer :). But I have some questions to get clarified. Very basic. Now I have used database support for the app. I have used [this sqlite library](https://github.com/mattn/go-sqlite3). If opt for Google app engine for time now, then can I use this library to store data or i have to move to data store library offered by google for app engine? is it mandatory to modify for data store api or app engine also supports third party database as well?
First of thank you very much for the suggestions :) I know nothing about Docker and any links that you followed or any step by step procedure would be very helpful. Thanks alot again :) 
91 bytes if the name of the file is m.go :) ```package main;import(."fmt";."io/ioutil");func main(){b,_:=ReadFile("m.go");Printf("%s",b)}``` Edit: Actually 84 bytes: ```package main;import."io/ioutil";func main(){b,_:=ReadFile("m.go");print(string(b))}```
Snapchat ran for years on App Engine, so unless you're bitcoin mining, it should be sufficient. :)
Wow! Quick turnaround on implementing those! Very impressed. Can't wait to try it out.
112 with `var` package main func main(){b:=p+"\x60";print(b,b)} var p=`package main func main(){b:=p+"\x60";print(b,b)} var p=` Beating my top-comment record.
The one I posted below is 84 bytes, but that's with imports. Edit: Just found out that a `quine` can't read a file so it's not actually a valid `quine` :P
Thank you!
Hey, this is the thread for v1.8 :) anyway, the reason is that .87 includes an important bug fix. So that's the minimum I've set. 
'let g:go_metalinter_autosave = 1' Yiisssss!! This some very amazing work right there! I'm going to throw some money at you mate for this. Thank you for your massive effort, and everybody who helped and contributed! 
Thank you for the feedback! Lots of followup questions, I hope that is ok. I didn't run gofmt but I assumed it was pretty close to formatted. I'll look into that. [Edit] I see now, the struct formatting. Good eye Can you please expand on your second point regarding the struct being an http.Handler? Third point, can you explain why you suggest NewEncoder over Marshall? And in cases where a type is used only once, what is the advantage to avoiding map[string]string? Regarding Tiny.save() the reason I have it like this is because it would have to be three functions (Unless you propose saveURL() updating the path column in the db?) Your last point is interesting. I suppose I never really thought about a need for security or using hashes on the short path/code. I always imagine a hash to be pretty big in relation to the size of the average tiny URL. Again, I really value the feedback.
I think it's a typo in the changelog. Both GoCoverage and GoCoverageBrowser are executed asynchronously without blocking the UI. They usually take time depending on the code source. So this is now better :)
66 characters, I guess I won't last very long. package main;import."github.com/kindermoumoute/q";func main(){Q()}
Try Swifts optionals for a while, and you should relatively quickly get bothered by this very syntax. As others mention, there is no need for this feature. It would also be limited in usability, as functions that return multiple values would break the chain. In Swift, a language with this feature, you don't seem to ever make any chains. You may guard a method call with ?, causing its return value to also be optional, or assert the value as non-nil with !, which would throw a runtime error on nil much like Go would panic. The former ends up being a nuissance, and a "if nil, throw an appropriate error, otherwise, unpack with !" pattern emerges.
The idea is good, but a quine must not access/read any external file, not even itself. 
Ohhh I had no idea about that :) Didn't even know what a `quine` was until I googled it's name, but didn't see anything about what you just said =]
I love Melody 😎
You could lobby github to change the message. I dislike the phrasing "&lt;author&gt; committed with &lt;committer&gt;" too. I wouldn't worry too much about this making it seem like you stole stuff, though; the commit object clearly distinguishes between the author and committer and as this is the same message that appears on (squashed and?) merged pull requests, the github community should be aware. And someone who would *actually* claim a commit as their own would've also erased the author anyway.
does the Go SQL driver automatically sanitize these sorts of injections?
Sentry doesn't handle being hammered all that well... At all. For us, we have a *lot* of similar events so, seeing as it's UDP, we just accept occasional drops. It works well alongside sentry rate limiting in 8.6+
So, you'd wind up with a type called `urlDB` (or whatever), which would encapsulate the `*sql.DB` object. Then you define a `HandleHTTP` method on `urlDB` so that it satisfies the `http.Handler` interface. Then in your `main` function you create the `urlDB` object and simply call `http.ListenAndServe("/", urlDB)`. That way, all your handler functions will have access to the database without the need for a global var. As for `NewEncoder`: In Go, it's very common to use the `io.Reader` and `io.Writer` interfaces to stream data around instead of reading it all into memory. If you were encoding a large struct, for example, `NewEncoder` could drastically reduce the peak memory consumption of your app. But honestly, the performance aspect is incidental. The real lesson is to get in the Go mindset of wiring up interfaces. Insider your handler function, you want to write data out via the `http.ResponseWriter`. One way to look at it is: "ok, `w`, has a method called `Write` that takes a `[]byte`. So I need to pack my data into a `[]byte` somehow, and then call `Write` on it." But the more idiomatic approach is: "ok, `w` is an `io.Writer`. What tools do I have that play well with the `io.Writer` interface? Ah, I see that I can write my data to an `io.Writer` directly by using `NewEncoder`." The more you familiarize yourself with the standard library, the more natural this mindset will feel. The `map[string]string` thing isn't super important, but it's good practice if there's any chance you'll use the type elsewhere. It also improves readability, since you'll have an expression like `URLResponse{url, err}` instead of a generic `map`. Finally, if someone wanted to write a Go package that used your API, they could import your package and decode directly into your `URLResponse` type instead of reimplementing the logic themselves. I guess my main critique of `Tiny` is that it's methods are kind of backwards. That is to say: when you call `t.save()`, `t` is being implicitly saved to a global `db` object. This behavior is a little surprising, since a `Tiny` object is just a collection of "inert" data. I would expect the args to be reversed, i.e. `db.save(t)`. Furthermore, a method called `save` should _only_ be concerned with moving data from memory to disk. Generating+encoding the short URL should be handled in a separate function. This will make the coder easier to follow, make it easier to test, etc. As for hashing, you can truncate the hash as necessary. For example, 6 bytes of a hash will give you 280 trillion possible short URLs. As with any shortening service, it is desirable to use as few bytes as possible, but you need to weigh that against your other concerns.
I'll have to give this another chance. I switched to sublime at work because I was tinkering so much with my configs :) Would definitely love to switch back to vim.
The apps I put on app engine are usually so simple that do not even require a database so i am not 100% about this but from what I understand you cannot use sqlite on appengine. You need to use their database. This has the advantage of scaling. If your app suddenly becomes popular you won't have to care about adding extra databases or servers. App engine will take care of it (for a price depending on the popularity). This has the drawback that you need to write app engine specific code and if you want to support both sqlite and app engine you need to do extra work. This extra work is actually a good design practice. For example instead of writing directly your database code, you define an interface and then you have 2 different implementations, one for app engine and one for sqlite. If you want to avoid the app engine specific code then I'd suggest you to try Digital Ocean. The price is very good and you'll be able to run many different Go programs on it not just one (behind a proxy). I have a small server that runs around 5 Go services, each one doing a little thing.
Fair enough. You could have also let people give what they want for it. I think it is a great system. People who are not willing to pay can still read the book and talk to their friends about it. The others can choose to pay what they think is a good price for the value you brought to them. Personally I will wait until you release the sources on Github to buy it.
Yes here is a proposal draft : https://docs.google.com/document/d/1qnmjwfMmvSCDaY4jxPmLAccaaUI5FfySNE90gB0pTKQ/ If somebody know what's append after that ?
Glad you liked it. 
Great, we offer thirty-day trials if you'd like to try it out. We have a signup form at backtrace.io/go, you can directly reach me on the Gophers slack under @amathew or email me at amathew@backtrace.io
I tried using this (the previous release), but around 1/5 of the time when I save a file Vim crashes. I haven't dug into it, but guess it's an incompatibility with another plugin. Has anyone else experienced this?
https://github.com/fatih/vim-go/commit/dc8073386754bf5ca09a8dbe2bd9cc8886c61446 It has good chunk of has('job') followed by has('neovim'), so it's really safe to say that most of Neovim's async features are supported
Seems like you're using vim 7.3.x.. which is not compatible with vim-go. Otherwise it's rock solid, shouldn't cause any problems.
Thanks! I hope you enjoy it
Oh well... serves me right for not RTFM. Thanks :D
Wait what. Wow, this is great! I did not know you could declare a `var p = ` without specifying a type. I guess I have not seen that done that often, though thinking about it, I have seen it a few times. Going to the spec I found "If a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. " https://golang.org/ref/spec#Variable_declarations
*clap* *clap* *clap* *clap* *clap* *clap* You have now beaten the best I have seen even with using the "fmt" package of the standard library. I did not think it could be done. 10/10. Really glad I posted this up for fun :).
Are there any plans to expand neovim coverage?
Interesting! So something like this? I like the concept. In this case I think a global is probably safe, however, in larger apps your method appears to be a much better approach. Funny, a week ago I asked in this subreddit about using a global DB connection and nobody responded. I am going to try this method out. I can already see some benefits once I start using cookies and accounts. type urlDB struct { db *sql.DB } func (udb *urlDB) HandleHTTP(w http.ResponseWriter, r *http.Request) { udb.db.Query(...) writeResponse(...) } func main() { gdb := &amp;urlDB{} gdb.open() http.HandleFunc("/test/", gdb.HandleHTTP) } **[EDIT]** Having a tough time understanding your idea for save()/load() running off the urlDB type. I suppose in this case it may make sense, but once I add more functionality such as user accounts, traffic stats, and other tables into the database it won't be as clear. For example if we have users there will be a user type, so we will want to update that struct and run someUser.save(db). Going the opposite way seems cumbersome to me because then we need to accept all types and check for types in the save/load functions. func (db *urlDB) save(t interface{}) error { switch t.(type) { case Tiny: // Save tiny object to DB case User: // Save user object to DB } } Seems more difficult to read and manage than the following func (t *Tiny) save(db *sql.DB) { // Save Tiny object to DB } func (u *User) save(db *sql.DB) { // Save User object to DB } Forgive me if I sound argumentative, I'm not trying to be. It's just that I am VERY new to Golang so I am going to question everything until it totally makes sense. :)
Excuse my ignorance, but can you explain what an OOM is? I googled it but can't find anything. I think with your discoveries I will be implementing a URL length limit and a blacklist for those who try to exceed it X times in a day. Thank you
Kinda poor choice of name as there's already a go project called melody ([a websocket lib](https://github.com/olahol/melody)) and it's already on godoc.
The Go way to indicate errors is to return an error value as a separate value, rather than try to indicate errors by returning null as the main value. 99% of the time the only thing you should be comparing with nil/null is the error return value, not the main return value of the method. So what you'd need in Go would be an operator that effectively took a return tuple of type `(T, error)` and a default value of type `T`, and returned the default if the error was non-nil, otherwise the first value from the tuple. Then you could write x := examplefunc("badval") .? "gooddefault" and always get a string as `x`. It's not clear to me that it would be a big win for clarity, and it would throw away all of the error information, which is a terrible idea.
I wrote [a post about Go reflection](http://lpar.ath0.com/2016/04/20/reflection-go-modifying-struct-values/) applied to structures which might help.
Likely means out of memory in this context.
So I just updated the code on Github to implement both browser side, and server side checks for URL length. Capped at 1024 bytes. Would that be sufficient or is there something else you'd suggest?
Ah, good points. I hadn't seen this message before in my own work, so it must be something with the way I applied the patches. But if people are used to it, I won't worry. Thanks!
It is a 1-quinepotent program.
Cannot up-thumbs this enough.
I'm a little confused about what "for Acme" means in this context. Why can't they be used on the command line or in a unix pipeline or anywhere else that reads from stdin, transforms the output, and outputs to stdout?
With this, one could still upload gigabytes of random non-sense. I suggest a https://golang.org/pkg/net/http/#MaxBytesReader for this. Also you should check if the URL is a real URL. You can easily do that with https://golang.org/pkg/net/url/#URL and check the corresponding fields like scheme and host. For the timeout functionality I recommend using https://golang.org/pkg/context/#Context.
ContentLength will be the value of given HTTP header or 0. But somebody that has the worst intend doesn't care to send you this header. You could do something like: r.Body = http.MayBytesReader(w, r, 1 &lt;&lt; 20) To limit the request to 1MiB. Then you should use r.ParseForm() since this can return an error, in this case you get a special error from MayBytesReader to signal that the maximum amount has been read.
No worries -- you are correct that having a single `save()` function with a type switch would be a bad design. There's two approaches I would consider: - You can define a separate method on `urlDB` for each type - You can define a `saveToDB` method on each type The latter approach is reminiscent of other serialization code, like the `json.Marshaler` interface. This is good when you plan to be encoding the data in multiple places. However, I don't think it's a good fit for storing the data in a database. The reason is that different databases may have a different schema for storing a particular type. So I think it makes more sense to group all the `saveX` methods under the single `urlDB` type, since all the methods must operate within the same schema. Also, re: global vars: Part of the reason I'm averse to them is that you can't see that they are being modified just by looking at a function's arguments. Whereas if a function is a method on a `db` type, you can assume that it will read or write to the database.
Pardon my ignorance, but what does ACME stands for here in this context? EDIT: I guess my question is, is it really just "A company that makes everything?"
Text editor: https://en.wikipedia.org/wiki/Acme_(text_editor) Demo: https://www.youtube.com/watch?v=dP1xVpMPn8M
The core language designers have always had [plans for a debugger](https://www.youtube.com/watch?v=VoS7DsT1rdM&amp;feature=youtu.be&amp;t=46m11s). The situation is a little different than what you think.
Any plans to support more platforms?
1. Go has some sort of an established community here, and just killing it, especially without suggesting a replacement (although that wouldn't be much better) would do a good job of making Go less popular. 2. As programmers we should all already have been aware that that data on reddit is transient and able to be manipulated by those running the website, and further we should also know we aren't a particularly political subreddit that's likely to be subject to this sort of intervention. The least the Go team could do would be to shift moderation of the subreddit over to other users, if they are particularly bothered by this. 
What would be the alternative to reddit? Personally, I love the golang subreddit and would hate to see it go.
The Reddit community and the reddit CEO are not the same thing. Like, please don't delete the US because of Trump. 
I like the Go subreddit. Don't want to see it go.
So people that rarely use this subreddit want to get rid of it? Okay.
Upvoting for visibility. I linked this thread from the mailing list to show that there's already a fair amount of pushback against this proposal.
This is basically the only subreddit I look at and I get notified of many new projects through it.
Yeah... lets not take our ball and go home, let's take the whole fucking playground!!!
Heck, that's hyper-reactionary. If we discover a city government official doing something dishonest, should we abandon that city and go live somewhere else? Forcing closure of this sub would harm the community and it'd certainly harm the popularity of the language
The CEO's actions are definitely repugnant but I agree with many of the comments here, it would be premature to delete our sub-reddit before we see what will happen here... I believe the CEO will be forced out and more stringent security controls will be placed around comments placed by people. 
Whoa, slow down there. This is my primary source for Go developments and news.
I honestly think most of Reddit is garbage, but this is one of only 2 subreddits I actually follow. Please don't delete this.
I'm learning Go and this is my primary source of information. Wtf is happening? If you don't like Reddit or the community just quit and don't bother others. Well... They use email lists in 2016... So yeah... I can understand now...
It doesn't seem like the principles of Go leaders (real or thought or otherwise) don't really align with the modus operandi of Voat... [removed an off-topic rant about Voat's disgusting trash posts on the front page]
Thanks for clearing that up. But regardless, taking away this subreddit from the entire community is an immature way to handle this situation imo
Several prominent Go community members have expressed their hatred for Reddit before. This incident is merely a convenient excuse to do what they've always wanted to do. Admins - please don't take this sub away. It's my primary source of Go news and links. 
It always impress me seeing engineers trying to answer human problems with machine forms. 
Yeah, you're right. Editted.
Some of the main developers of go feel that this subreddit is cancer for whatever reason. Meanwhile they are usually a big reason why a discussion turns to shit. 
Well they follow the same model Reddit does, so we don't have to subscribe to their subs and we can make our own communities with our own rules. There's no place for politics in a Go forum anyway.
https://www.quora.com/What-are-examples-of-Google-acting-unethically-or-illegally Might as well delete Google also and all its products. But also, bad move by reddit and I don't like them as much anymore.
I've been coming to this subreddit multiple times a day since 2012 and I'll be damned if I have to Google groups for my Go news. The mods should just stop using reddit and leave the subreddit to someone that cares. 
ITT: An overwhelming "No pls"
Brad just posted this onto the google groups discussion: &gt;The question is what to do with /r/golang when all moderators of it want to leave. &gt; &gt;I don't think we want an unmaintained /r/golang that looks to be an official Go space. &gt; &gt;When /r/news had drama and people split off, /r/uncensorednews started off okay for a second and then turned into a clusterf*ck. &gt; &gt;I don't want /r/golang to turn into crap while looking like it's official. &gt; &gt;So I'd prefer /r/golang become dormant and users go to wherever they like, be it the Go Forum, voat, or /r/unofficialgolang. Or we find an open source Reddit clone and run an instance for just Go. There are many things I like about the Reddit voting &amp; thread model &amp; UI over, say, the Go Forum. &gt; &gt;Nothing will happen immediately, but it's clear that we now need a plan for what to do with /r/golang. Basically he is saying that he doesn't want the /r/golang name sullied by an unmaintained mess that he believes will happen when the Go team itself ceases its moderation. I honestly think that making a new golang subreddit that isn't "officially" tied to the Go team seems like a garbage idea. /r/unofficialgolang ? If you were searching for a solution to a particular problem, and you had a very nice and concise answer come up in your search results, but under that address? You wouldn't bother to go to it. That would essentially kill the Go reddit community, which to me seems like something they wouldn't mind doing. Dave Cheney, Brad Fitzpatrick, and many others in the google groups discussion linked above don't mind that we lose this place as a means of discussion and gathering news. "Delete it." It's shitty how the members of that google group thread seem to be looking down on us as a community just because of the Admin that royally fucked up. Thats not fair to us and to take away our space because it looks like an "official Go space" is just as shitty. Let us keep this space! We will put a stupid fucking disclaimer on it that keeps it from looking "official". 
The world is a nasty untidy place, let's just delete it.
I'm certain there are many community members willing to step up, should the Go team no longer wish to. Just an open call and handover wouldn't be so hard 
I read the article and know what happened, I'm not sure I agree either one is much worst coming from the CEO but I don't care to argue the point. Mostly trying to make the point that we should not react so hastily because of a single action by a single person. People do dumb shit some times, sometimes those people are the face of an entity, a business, organization, or a circle of friends. It's a social customary to allow the entity to react in order to show they did not condone the action before you decide to change your entire perspective of the entity as a whole based on the actions of an individual. It would be rather hard to have a resilient civilization otherwise..? All I'm saying is let's give Reddit time to react, plus, turkey.
I nominate /u/fuzxxl to moderate this subreddit.
Thanks for the detailed explanation here. I opted for rewriting my app to support data store and I was successful in make this work. I will think about migrating it to Digital Ocean or even I may use it for other app well. But either the way, I am really happy that you came up and try to help me. Thanks again :)
&gt; As programmers we should all already have been aware that that data on reddit is transient and able to be manipulated by those running the website Well, obviously. It was never a question of whether they're capable of doing it, but whether they *would* do it. I for one didn't expect reddit's admins to stoop so low. 
I expect more than this knee jerk reaction from our mods. While /u/spez seriously screwed up, it has been a long time since this site could be considered a bastion for free speech (which it explicitly is not). Deleting this subreddit without first establishing a viable alternative is simply counterproductive and will harm the adoption of golang. Many of us depend on this sub for news and new open source libraries. I am not married to Reddit, but we need another place to serve this function before we delete it, especially if the reason is to make a statement rather than for practical purposes. 
Thank again for your kind advises and links :). This really helps me in boosting the motivation to go ahead to learn more about Go. Yes, Learning docker has been added to my "learning list" now. I will follow your links at first.
also thank mr skeltal for good bones and calcium
The thing about reddit is that it combines many different interests into one place. A go specific forum is not a viable replacement.
Founding a community and owning that community are 2 very different things.
Let's be clear for a minute. One, _singular_, reddit admin was involved in these shenanigans. One, of many admins. Yes, it was the CEO. But his actions do _not_ reflect the opinions of the rest of the admins, nor have any of the other admins come out in support of his actions. He is alone in what he did. We cannot suddenly say that 'the reddit admins' are all corrupt because one of them did something wrong.
A community is what the community wants it to be, not what your corporate sponsors want it to be. If Brad and other mods want to leave, they are more than welcome to. If they want to destroy this sub, they have the technical power to. But no amount of rhetoric gives them the moral right to make that choice for anyone else.
Shame on the CEO and all that but this has no material affect on /r/golang. The risk of someone modifying our content remains as negligible as ever. It seems to me that manipulating the comments of a few Trump supporters (while dastardly) is not the kind of moral crisis that merits deleting the sub in protest.
Frankly I'm impressed the Go team is upset at this. I erroneously suspected the slight against Trump supporters would be brushed off because they don't seem to share the same politics. On the other hand, this *should* be brushed off because this represents no material threat to our sub and this isn't a sufficiently large civil rights violation to justify polluting the community with politics.
After seeing the whole Golang moral police thing a couple of weeks ago, it's hardly surprising. Something code of conduct enforcement. 
So it becomes legible.
&gt; One, singular, reddit admin was involved in these shenanigans. He also realized he made a mistake, undid what he did, and then confessed. That goes a long way in my book. I'm really not caring as much about this as some people seem to. If this was some systemic thing, I'd understand all the commotion. As it stands, it's just "meh, whatever" to me.
Because killing a community because it contains bad actors has worked so well in the past. There are 25k or so subscribers here, who obviously find value in the community. Suggesting that this is a rational response: "In light of the CEO of Reddit admitting to editing user comments (see dozen news stories today), I propose we delete the /r/golang subreddit./" sounds kinda... "That is so beyond unethical and immature". 
This and /r/programming ? Because that's what I do too!
No real plans my requirement was to run it on a Pi
I do feel like this is kinda ironic. /r/golang is the only place I even find Go related stuff and I like it.
I would really prefer that we delete Google Groups. There's a ton of Go related stuff that I would like to read and follow, but Google Groups actively discourager me. It's the absolute worst interface that I've actively used for anything in the past 5 years. 
Go governance has developed an implicit hierarchy. Reddit offers an alternative to that...here the Go insiders must compete fairly with total nobodies like me for mindshare. Don't close this down and replace it with something that defaults to reinforcing the implicit power structure of some Google employees...Go governance is already veering towards a tiered system as it is Indeed, it might be nice to the Google employees give up moderation privileges...you folks are already concentrating enough power....interestingly the only people in favor of closing this sub seem to be the insiders Really disappointed to see this sub described on the mailing list as being full of "scum and villainy"...I know it's just a witty quip but it's also totally off base.
Should we require the Go code to be `gofmt`ed?
&gt; any external file What about something like [this](https://www.reddit.com/r/golang/comments/5ek8ya/i_wrote_a_quine_for_fun_it_is_192_char_long_how/dadjseo/)? Does standard library count as external? What about the Go compiler and its runtime? How do you fairly figure out where to draw the line? **Edit:** Wikipedia says "Quines, per definition, cannot receive any form of input, including reading a file", so an external library is a piece of code and not really "input to the program", so it should be valid, right?
...and the flexible UI...the scalable content delivery hosting...etc etc 
actually you do...that's the point...Reddit puts /u/bradfitz on the same level as losers like me
Go governance is becoming very cliquey...I feel like this move masks a desire to move discussion someplace where an inner circle have permanent and infinite "mod points"
And what about the people that actually like to browser reddit? Just ignore those, yes.
Marginalizing what spez did isn't a healthy way to handle this. People are allowed to be pissed off about it and rightly should be. Having a proper discourse about how it impacts this facet of the community is what needs to happen.
What everyone uses for primary source of news about Golang ? Blogs and stuff are welcome. I just want to put it effortlessly to my feedly feed. Thx
Oh, so the problem shows up on the client side. I assumed that problem with TIME_WAIT connections would manifest itself on the server side, but then it's not your problem, right? :) (because you're writing client) Thanks!
The public statistics don't show moderator actions, as far as I know. This could be quite a bit of work, and it's pushed onto you once you are in the moderator club. I can understand that people do not want to interact much with the site beyond the moderation effort.
Yes, but what about the people that actually like to browse reddit? The /r/golang sub is a valuable resource for many. The moderators seem to answer to a betreyal of trust by further betraying the trust of the community. How can we ever trust the "official" golang moderators of any forum to not close it without notice because someone did something they didn't like?
I agree, this is also my primary source of Go news.
Oh, what did I do now?
I am surprised that the question about wether or not to delete this sub is directed at the other mods and not others in the community. The moderators play a very important role, but in the end it is the users that keep the community alive (in this sub or other places). I understand that strong ownership of the language has made the language great and not some sort of monstrosity of "design by committee" or groupthink or what not as you see in some other languages. But there is no reason to translate that behavior to the way the community is managed. This proposal is not how it should be done as far as I am concerned. 
What's the point? Someone will just make a new one called uncensoredgolang or truegolang or some other stupid name.
Please put a license. Something permissive like MIT
It was not founded by the Go team, it was founded by /u/uriel, which then added /u/rsc (from the Go team) as a moderator, and multiple other people not from the Go team. The Go team was never really involved in day to day operation of this reddit. Until recently, there was no involvement whatsoever. More recently there was some minimal level of involvement but hardly the level necessary in order to arrogantly claim they **own** this place. 
No. Entry of a function is the place where a goroutine **can** be preempted (e.g. if it needs to grow the stack or stop for GC), not the place where it **will** be preempted. 
The hypocrisy here is mind blowing. A moderator gets offended because a person (not even related to the golang community) abused his power to edit some comments. So what does this moderator do? Abuse his power by wanting to close the entire subreddit, without any discussion with the people in that community. Amazing...
I find this a bit of a childish reaction. And sucks that this is being discussed off the platform itself ? 
this person right here gets it. I will not go on to another platform. I have enough content providers to visit already.
They really should be communicating with the users here first about its fate, rather than on another platform.
TBH, giving back /r/golang to cat-v doesn't sound like a particularly bad idea.
The problem is, most people who haven't been censored stay on reddit, and people who have been banned from reddit or have had a subreddit they enjoy banned go to Voat. So the kind of people who browse /r/aww and /r/pics and occasionally engage in respectful political discussion stay here. Meanwhile, a large portion of Voat's userbase are there to browse subverses that got banned from reddit, like /v/FatPeopleHate and /v/Niggers.
So there are two languages that actually get the job done: Lisp and C. How close to reality.
Did you read the thread? They didn't decide, one of them had a proposal. He doesn't want to support reddit and wonders if all the moderators feel the same, how to proceed then. He even suggested building a replacement, so he's not completely uncaring of the the community. A few bystanders (at least the names don't match moderators), agreed with him, but that still is no decision. Reading the community guidelines (or only the small version that says: * Treat everyone with respect and kindness. * be thoughtful in how you communicate. * Don’t be destructive or inflammatory. It seems that indeed this is failing. Your post got a lot of upvotes, is not respecting anyone, somewhat inflammatory. How thoughtful it is, that's up for debate. You had a few pretty complicated words in there. :) 
There were suggestions of replacements, including building something new in his original post.
Yeah, focus on my understatement, and ignore the rest. Makes discussions much better.
The post you respond to is at -4, so voting doesn't work so well here. (well, it works in a agree/disagree way, not in a 'good discussion point', 'bad discussion point') Looking at that forum for 2 minutes makes me really appreciate reddit-threading though. 
I'd love to check it out but your website is kill currently :(
It never should have been an "official space", it wasn't even created by a Go team member in the first place. They can not support it all they want but they need to name someone else moderator and let this community be, they shouldn't close it. 
Terrible idea. If Googlers have a problem with Reddit (beyond Google failing at social media and being jealous because of it), they can hand /r/golang over to the community and consider it an unofficial subreddit. We'll also get rid of the CoC that has caused more harm than it helped this way. 
HackerNews discussion: https://news.ycombinator.com/item?id=13035760.
The subreddit is also still available. So, I'd hope that some of the moderators are either fine with staying moderator, or that they'd find other people to moderate. If they feel it is too official and too hard to keep their 'community guidelines' alive here between all the other reddits with other guidelines, I'd hope some people would set up /r/gousers, or /r/gopgrammers and that they'd keep a sticky post pointing from here at the new place. (or if private reddits have a custom message, that they'd use that, whatever, as long as there's a redirect for new people who search for golang. 
Become one. HTH, HaND.
I am new here, and want to learn Go. Don't you bloody dare to delete this subreddit!
I didn't know that. This makes it even worse. So Go team takes over the subreddit, starts enforcing CoC and then discusses on another platform to simply delete the subreddit! WTF? 
Yes my bad.
fine, keep nudging me towards .net core... I've been fighting for go at work, but it keeps getting g harder and harder to stand up for. because of .... politics and mod management? fml
I'm honestly surprised that this subreddit is considered an official channel of the go team. The subreddit should be own by the user community not the creators anyway.
&gt; I mean, what are you going to use, Google Groups? Yuck. Even worse is someone on the mailing list suggesting Google+. Now that would be a fucking travesty.
I can't believe they even suggested voat, that place is a cesspool of white supremacists and pedophiles that left Reddit because "censorship".
it seems the guy has a lot of free time.
this has been my experience as well. outside of this subreddit, most go communities seem extremely exclusive and toxic. Google groups included.
Also Brad starts with his concerns about Reddit as a whole but then the discussion turns into why they hate this subreddit.. EDIT: I had to take a break of the golang scene but wow, I see, 2 days after, that a fellow gopher gave me gold! Thank you :)
Voat is dead
I'm not marginalizing anything when I say I don't care lol
**Fuck** all that code of conduct and especially **fuck** /u/bradfitz!
I never participated in comment threads before, but this thread suggests people have a hard time sticking to the civility the sidebar requests. Hopefully this thread is exceptional, but if this is the norm, then yeah, I can imagine they get negative associations with it.
&gt;Brad Fitzpatrick and other Go members who supported this motion should resign from any official Go language related project. Yes! And they should also remove all the code they wrote for the project! /s No offence, what you said is very stupid. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/drama] [Proposal to Delete \/r\/golang](https://np.reddit.com/r/Drama/comments/5etmr0/proposal_to_delete_rgolang/) - [/r/subredditdrama] [\/r\/golang mods (Google employees) are so pissed off at \/u\/spez they want to delete the \/r\/golang. Drama ensues.](https://np.reddit.com/r/SubredditDrama/comments/5eubhq/rgolang_mods_google_employees_are_so_pissed_off/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
&gt; this thread suggests people have a hard time sticking to the civility the sidebar requests No, it does not suggest such a thing at all. It seems like you are confused about the difference between people disagreeing with some position (usually yours) and being civil. Hint, people who want this reddit to be nuked from orbit without any concern about the actual people here are the ones who are not civil. Another hint, if someone downvotes you, it doesn't mean he is not civil. You don't want civility. You want passive acceptance of your internet culture and you call it civility. Shame on you for not calling what it is!
Is that you Spaz?
My idea of civility might differ from yours, but your description of mine doesn't resemble mine at least. Someone asks 'what would be an alternative', and someone else (not me) responds with a link to the forum. That's at -6 now, so gets collapsed by default. I find it somewhat uncivil that when someone gives a reasonable response to a question, they get downvoted to prevent people seeing that easily. Some people respond and argue that that forum is a lot less convenient than Reddit. Civil. But yeah, if the reddiquette and CoC are not the base on which to start a discussion, then it gets hard. Thankfully, I know where the exit is. 
Pls do, this needs attention.
https://www.dropbox.com/sh/po7bohbj6onol58/AABcB51UOd311oQ6V26BP5T1a?dl=0 These might be slightly out of date, meaning there may be a few unfixed typos, but they should hold you over until I update them this evening.
Well, in all fairness redirects open(ed?) up a security vulnerability. I can't quite remember which one. 
Just wanted to throw my hat in he ring. I, too, find this subreddit informative and it serves as the primary source of my Go news. I check Reddit several times a day. I like subscribing to a variety of niche subs. I wouldn't check a 3rd party source nearly as often. Google Groups is so bad, it would deter me from checking up on Go entirely. 
Yes, the one place in the Go community where there is no hierarchy.
Never let a good crisis go to waste.
There is no viable alternative. Tell me one place over the Internet which is as open to newbies as Reddit is? Google Group? nope, threads die out if they are just for asking advice as the "busy" people either be snarky or otherwise. Reddit is a place where everyone is kinda equal.
Ironically the person posting is complaining abuse of power.
I am not sure if they even maintain it anymore.
No license needed.
The fact that the Reddit CEO's situation is being brought to light is better than what's happening on n other social media platforms. Reddit is a welcoming place for technical discussions, and I hope /r/golang remains here.
I got most of the traffic to my book through this subreddit. Heck, even the advices/critique I got for my book was due to this subreddit. It wouldn't have existed without this subreddit, since the book was practically brushed off in the go-nuts channel and IRC is an terrible alternative to Reddit, so is that goforum thing, way too much JS and terribly slow. Reddit is Reddit, if their CEO did something shit and the Go project doesn't want to consider this unofficial then just leave it to the community, ironically enough, that's the whole point of open source.
There's an increasing tendency for this. For example, /r/Twitch is pretty much fully controlled by Twitch already, with community volunteers. Also, /r/Amazon, a bunch of others.
Agreed about it not looking official. Hell, I didn't know anyone from the Go core team was actually on this sub. I just thought it was all enthusiasts.
chapter 1 sucks. Next time assume a brain for the reader.
Nope. make this unofficial channel and let it live. This is the primary place to get Go news and traffic + visibility for new projects. This is the one place where the elites and the plebeians like us are treated almost equally, with just the community sorting this with up/downvotes. It is ironical that this discussion was started on Google Groups and not here. It shows that the Go community really is split into two parts, Googlers and others. Google+ is horrible, Google Groups is horrible. There is no replacement for Reddit + I do not want the elites to be in control of the communication medium, they already have control over every other part, let the community thrive on reddit. We are fine, thank you. Just hand over the moderation to someone else. P.S Many many years ago Zuck called everyone who signed up to his intranet website as "dumb fucks", let's delete facebook.
and a replacement probably won't exist.
It seems pretty fucking childish to want to delete the entire subreddit, a repository of uncontroversial knowledge and to which 25k people subscribe for professional assistance. I understand making a stand when free society is threatened, but deleting r/golang isn't going to do anything but hurt your peers.
This was pretty much my point. Also, if these guys deleted the sub before they found a better home, they would be incapable of telling their audience where they went, so we couldn't even follow them to the promised land. This whole thing would be akin to rage quitting a job before you have another lined up.
If you understand my point, you understand it remains valid even with your consideration.
Thanks for the link. God, what a mess.
They have said they'll find an alternate home. Sure, because they are going to find a place to have democratic conversations. Nothing on the Internet is like Reddit. Everywhere else the snark lords will rule and Go community will collapse like the Berlin wall
Hey, if they can find an alternative home that can support the community in a similar fashion, I'll be happy to to with them. Heck, maybe we could even move over to Voat, although that place is kind of a cesspool.
Your quoting suggests a few things that I said and a few things I didn't say. Confusing. I love clear communication, and as a Dutchman I have the necessary training to deal with direct communication. (In my circles, the Dutch are somewhat infamous for speaking their mind). There is a big difference (imo) between saying: &gt; You are incorrect for a, b, c. and &gt; You fucking moron, learn to think. (I couldn't possibly explain what you said as the second, it's a huge fantasy). The first was direct, and provided 3 reasons, the second was just insulting and didn't actually move the discussion forward. Your suggestion that they overstep their bounds as if it already happened, or is a sure thing to happen, was (imo) not helping move forward. You were suggesting that someone who complains about an admin modifying what someone said is at about the same level as asking how to proceed with this subreddit, that is just distorting things to ignite fires, not to have a clear discussion.
Thank you Brad. 
I think the main issue here is that the community hadn't been alerted of, or invited to participate in any discussion about this. The whole /u/spez snafu is a problem, and there's certainly a debate to be had about it -- and it _does_ make sense to have that debate outside of Reddit (even if only out of principle), but a modpost or sticky post with a link to the Google Groups discussion as it starts up would've been nice, and likely would've reduced the appearance of a disconnect between the subreddit and Googlers working on Golang (not to mention, it would've increased transparency, which is usually good).
only if they consider us as peers. 
Link for the epub format has all 3. Enjoy :) Edit: https://www.dropbox.com/sh/po7bohbj6onol58/AABcB51UOd311oQ6V26BP5T1a?dl=0 in case you don't want to hunt for it.
I have written one book which I made free to download via leanpub, There have been 500 downloads, 5 of them were paid. The price I set was just $5. On gitbooks, where one can download for free, there have been around 2k downloads in the last year. I have got feedback from many readers that they loved the book and the teaching style, yet only 5-6 have paid until now, even with the price tag of $5. I wanted to open source the book and intentionally kept the pay as you go model because I wanted to contribute to the FOSS community. I understand the author's feelings behind charging 29$. http://github.com/thewhitetulip/web-dev-golang-anti-textbook/ link: http://leanpub.com/antitextbookGo/
I feel this is a discussion which needs to be separate. The majority of the discussion in that thread revolves around the proposal to delete and the (un)involvement of the Go Team, rather than how the /r/golang community should move forward. I think it's better to have a separate thread for the purpose of discussing the future.
I'm fuzzy on details, but I do recall in the past that some spaces were considered "official", which I think meant they were linked from the main site at least, and something something about Code of Conduct? That's what I'm trying to figure out now. Just glanced at Imzy. I still like the density of Reddit's UI. :-/ 
&gt; In light of the CEO of Reddit admitting to editing user comments (see dozen news stories today), I propose we delete the /r/golang subreddit. &gt; &gt; That is so beyond unethical and immature, I no longer want anything to do with that site. I will be deleting my account on Reddit after backing up my content, and I will no longer be a moderator of /r/golang. &gt; &gt; If other moderators of /r/golang feel strongly that it should remain, I suppose you're welcome to keep it going. &gt; &gt; But if the other moderators want to abandon it and focus our conversation elsewhere (or build a replacement), I'm happy to just delete /r/golang. &gt; &gt; Opinions? &gt; Where are the suggestions you are referring to in this text?
@bradfitz, why is it necessary for Googlers to drop out of the community? I'd think they would want to help build, not abandon.
I really expected better of Brad. Maybe back off your crusades and just let tech be tech. Keep your advocacy for the political subreddits.
&gt; It hardly looks official anyway, just a regular ol' code subreddit. Indeed, compare /r/php, /r/python, /r/haskell, /r/rust. /r/golang is the default style with a custom logo, that's about as official-looking as /r/ruby or /r/linux (aka not very).
https://news.ycombinator.com/item?id=13037636 At least he backed off now. 
This guy needs to crawl out of his own ass. If you didn't think background edits of content (including user comments) was technically possible you are hopelessly naïve and shouldn't be designing software. If you think this is the first time this has ever happened, you are also deluding yourself. Reddit is a community discussion board, nothing more. If you are making life decisions or judging someone's reputation based on what is here, you have missed the point. What spez did was wrong and there will likely be consequences for it. He may have to step down as CEO. But reddit is no more or less reliable than it was last week, get over it.
Can you elaborate on why you feel they are outdated and not ideal? Both have worked well for me in the past. Also, do you have any suggestions for alternatives to consider? Ideally I would almost like to avoid using any ORMs, third party libs, etc and just do everything from scratch (using standard libs), but I didn't do that because it would make the book a good deal longer. Perhaps this would be better suited to a mini-book &amp; blog series. I'm not certain. 
I think the kinds of things that have been being posted to /r/golang have been fine thus far. Mostly links to articles/blogs about using it, questions about the language, etc. There hasn't been to much spammy crap I can recall. If the Go team isn't active here, they should _not_ be moderators here. End of statement. This would be like Guido being a mod for /r/python and not using it. Foolish. I understand they want some level of control over things with their language's name...but sorry, this is the Internet. That's not really how things work in practice. Active members of the community here should be chosen as mod, we should re-assess the rules of this sub, and move on. I'm not sure why the mailing list shits on this sub so much, since the mailing list itself has been the scene of so many childish interactions and outbursts. I'm guessing it's the general reddit hate (which I have too for lots of sections of this site). So if they don't like it, that's fine. They don't have to use it. I think building out a somewhat decent wiki of common topics, approaches, hints, tips, etc. would help newcomers quite a bit. We can direct people toward common and de facto environment configurations, promote commonly used toolchains, etc. Community code reviews tend to get...touchy, though. People take critiquing of their code very personally for lots of reasons, and having a veteran review a beginner's code and leave shit comments like "This isn't how we do things" is a great way to start a war here. That's my $0.02. I think having this conversation here rather than in the "Let's delete the sub" conversation is a much better idea. Remove some of the charged emotion, keep the conversation focused, and hopefully we can make something positive out of this.
I'll just make an r/officialgolang sub. I use Reddit, I won't stop because a CEO pulled an idiot move on some Donald posters.
Anything to do with the Code of Conduct is going to be a polarising discussion - there's people who like having it, and people who are insulted by its very existence. I personally fall somewhere in the middle and try to live by a "don't be an asshole" philosophy. I'd love to see a more playful and community-based posts on the subreddit. At the moment, the most commented thread (apart from the deletion one) is about writing a quine in Go, with users making suggestions and posting their own improved versions. Fun, friendly, and interesting. 
Thanks. The Go 1.7 sub tests looks very useful. The only reason I haven't started using it is that most of the projects I'm involved have a current and current-1 Go version support policy. 
Also dupe #3 with more comments: https://news.ycombinator.com/item?id=13036890
Yes and they will remove it. We aren't against it.
1 character. &gt;&lt;null&gt;
I've been disappointed with how the Go team has tried to force the code of conduct upon this community that is overwhelmingly against it, as I am sure /u/uriel would be if he were still with us. However, I do not agree with the assertion that the Go team does not contribute to the subreddit. I have often seen members of the Go team join discussions here—perhaps less frequently in recent times?—and I hope that they will continue to do so. I would like this subreddit to be run by the community. I would like members of the Go team to step down as moderators and for the community moderators to remove the reference to the CoC and the CoC e-mail address in the sidebar. I think the bullet points in the sidebar that basically say "don't be a jerk" are fine. Other than that, I think the subreddit is fine as it is. I don't want the moderators to "drive engagement" or to spam the subreddit with automated posts. The community is quite capable of bringing up topics for discussion by itself. The moderators should only be responsible for removing off-topic posts and driving away the trolls, but without turning it into a witch hunt. I never liked subreddit style customizations, but fortunately I have already disabled those for myself site-wide, so they don't bother me.
I love the Go Forum. It is an important place for the Go community. However, it differs from /r/golang in many aspects, so I think neither of the two can replace the other. (Side note: I completely fail to understand the downvotes that your comment received. This is really one particular aspect I hate to see here: Pointless downvoting for no apparent reason.)
&gt; However, I do not agree with the assertion that the Go team does not contribute to the subreddit. I have often seen members of the Go team join discussions here—perhaps less frequently in recent times?—and I hope that they will continue to do so. I'm referring only to the moderation team for the subreddit, not the whole go team, some of who do post more regularly. * /u/rsc hasn't posted here for 9 months. * /u/enneff hasn't posted here for 22 days * /u/agl hasn't posted here ever? * /u/dsymonds made a comment a month ago, the one before that was 5 months ago * /u/campoy is probably the most active, but only seems to post to advertise his own youtube videos and podcasts The other mods, outside of the Go Team: * /u/dgryski **posts almost daily** * /u/skelterjohn last posted here 18 days ago * /u/0xe2-0x9a-0x9b last posted here 9 months ago * /u/jessta posts a lot in reactjs and elm subreddits, but last post here was at least a year ago * /u/TheMue posted something 2 months ago, last before that was a year ago * ~~/u/bketelsen *who was added 9 days ago* hasn't posted for 29 days~~ **Edit**: Has now removed themselves as moderator.
That's a really good question about the limiting of GET length in Go. I can't answer that, I'm afraid. When you switch to POST it should be fine. You can remove your "Ignore super long URLs" check then cause it will be catched by ParseForm. What is the reason to allow GET requests in this case anyways?
I'm curious, your original post mentioned building a replacement. Would you still be interested in building an official go forum (in Go of course)? Or do you feel given the amount of spaces available (go-nuts, r/golang, imzy, etc) that it's unnecessary? I was thinking that building a miniature-specific-use-reddit-type-clone in go would be a fun project. Although I'm sure no one has time to do such a thing. It's also interesting from a cryptographic point of view. If everyone signs their posts and they are stored in a decentralized way, it would be a lot harder for anyone to edit them arbitrarily. I wonder what sorts of security guarantees could be made, if any.
I already made the switch this morning. No particular reason for using GET honestly. Made sense to me at the time since it was requesting a JSON packet and I wasn't expecting large data to be sent.
Personally I use Reddit because I have one account to keep track of many interests, especially programming communities. I hate mailing lists and specific forums (Google Groups included). I think in the long run they are a terrible way to manage a community. If /r/golang goes away, I won't bother with a mailing list or forum. I'd see it as a failure of the community management. Then again maybe someone will argue that I'm not the audience the Golang team wants to keep around. Political disagreements shouldn't divide a programming community like this.
Was curious, which book? Also, /u/thewhitetulip gonna check out yours. 
&gt; Their brand of hate is the Right Kind^tm. I would totally buy that t-shirt!
Could you give us an official alternative to golang subreddit please? If we can have that then I do not mind if this becomes an unofficial Go subreddit. But till we have that official alternative then things have to remain as they are here in terms of "officialism".
&gt; That attitude assumes you own the community and can do with it as you will. That's what the mechanism of reddit enforces. That's why forums default to the feeling of totalitarianism. They *are* totalitarianism!
I presume these are topics posted, not comments posted? Is that correct? At least I _hope_ that's the case. If you're a mod of a subreddit, I feel like you should be actively commenting at the very least so you have a sense of what's going on.
A nil string that worked like a nil slice would be "", which is the zero value of string already. :)
Why do you need do comment to see what's going on?
How about a change to the sidebar to make it clear it's unofficial and have current mods that would prefer to see the subreddit closed/deleted step down? Seems straightforward. Let's not make a mountain out of a molehill and move on.
Even if it was setup by a Googler I don't think deleting it would have been warranted, this is all content created by users with little to no participation or involvement from the Go team or Google. It wouldn't be fair to delete everything imo. 
&gt; Seemingly the admins of this subreddit don't like the userbase. This seems to be a widespread problem across the internet, and across society. There's a severe rift in society between those with access to first rate education and resources, and "everybody else." I say this as a graduate from an Ivy league school, who has also had a chance to see what it's like from "the other side." (Heck, I even know a bit of what it's like to be at the status of homeless person.) Much of the "upper echelon" really does regard "the rest of us" as trash who can't have nice things. I understand what it's like to be on the receiving end of that, as well as understand the thinking behind it. Basically, everyone needs to shut up and listen to the other side. More easily said than done, as 21st century media and culture basically teaches everyone to read superficial signals and pigeonhole everyone quickly. In fact, what I find is that most young people seem to equate such a mental process with noble and intellectually worthy things -- when in fact it's just *prejudice*! (Look up the etymology of that word sometime!) The story throughout history is the same. Our instincts to protect each other and stand up for justice are exploited through ["irrational jingoism"](https://www.youtube.com/watch?v=VA5jOdPiZWI) to set us against each other. 
&gt;Purpose First and formost, /r/golang should serve for sharing projects and leading beginners on the way to learn the programming language. This includes answering beginner questions (over and over again), this is the best way to promote the language itself. I check /r/golang regularly to see what kind of neat projects everyone has come up with and to see if I could maybe help some beginners and show them the ropes. &gt;A moderation revamp I'm in favor of a community controlled moderation team. The actions taken by brad do not shine a bright light on them either and IMO there is a question of trust. Can we trust them to *not* delete this subreddit without notice because it was decided on a mailing list? I'm not certain of this anymore. The community should be responsible for itself. &gt;Community Building Of course, there needs to be friendliness and understanding. I'm not particularly in favor of a code of conduct, atleast if it exceeds "don't be an ass" (vague, I know). I'm a coder, I have simple needs and a tough skin helps to accept criticism and filter out everyone who's just trolling or something like that. IMO there is nothing better than to be open for ideas from everyone, regardless of who they are or what they do elsewhere. Code is code, that is what counts. &gt;Engagement and Structure I think it would help to clean up the sub a bit to have a daily or weekly Code Support Thread where beginners can ask simple, one or two sentence questions. A monthly Code Review Thread would be a nice thing too, though I'd probably look out for how popular it is before I'd make it permanent (maybe try it a couple times and see if people warm up to it) I'd avoid Daily Threads if possible. A weekly, pinned thread is sufficient &gt;Customisation It would be nice to link to the awesome-go list on github and maybe the libhunt site, it's a nice resource. A link to the go tour and the golang standard document would be neat for beginners. Lastly, I'd add some flavored CSS. I wouldn't overdo it like in some subreddits, rather I'd take an pragmatic approach and clean up the interface a bit, reduce contrast (bright white makes developers eyes hurt) and focus the content. &gt;What are your thoughts? Chicken Soup or Thai Soup.
/u/bradfitz has posted here a lot, and he only very recently removed himself as moderator.
Why, other than the proposed deletion of r/golang?
I don't think you _need_ to comment to see what is going on. But I think an administrator that doesn't participate is too disconnected. This kind of thing used to happen all the time on BBSs and on vBulletin sites. An admin or mod would get disinterested in the group or community, and then it would fall to shit until someone else took over. It's just part of community evolution.
Make it a choose your own adventure style book. But obviously when you have the time to do so. No need to split the book into multiple books.
time to build the tool :) great idea.
I feel the same except you can't really trust people not to be assholes. Pretty much my philosophy on law as an entirety. You cannot trust everyone to do the right thing; not everyone has the same view of what the right thing is.
You're somehow drawing a conclusion here that simply doesn't need to be drawn. Part of being a _good_ mod is specifically _not_ getting involved with the "mudslinging". That's why people choose them as good mods. This idea that someone can't participate and be neutral is nonsense.
I like there being a code of conduct for official channels, but I don't think this subreddit should be part of the official channels. (I also think the people that enforce the code should be assigned to it on a rotating basis, a la jury duty, instead of a volunteer position, where there's an increased likelihood of administration by people with enforcement agendas, but that's another topic for another day). I was genuinely surprised when I discovered that this subreddit was part of the "official" surface area for the Golang community. And clearly this thinking has caused some tension or drama, most clearly highlighted in the audacity to suggest nuking the community without soliciting the opinions of the community itself. /r/golang should be a place where tools, guides, Q&amp;A, and news or features can be discussed openly and (ideally) separately from the official channels. I still support the idea of cleaning up redundant blog spam, and a similar level of moderation as what's taken place so far, but it should not come from the perspective/context of representing anything officially.
I have no time to really elaborate why but I am for a a moderation revamp. It's necessary especially because of Code of Conduct.
https://www.reddit.com/r/officialgolang/
It could be useful but only in very specific cases and rare enough not to care for it that much.
FWIW, I'm a software engineer at Wycliffe Associates and am about to push an entire golang backend that I wrote to production for the first time. I'd be interested in contributing effort toward whatever is needed on this sub channel. I have found it to be very useful along my way.
What the hell is going on I just come here to read about programming, people need to chill out with this drama.
Well from what Brad wrote on HackerNews, it will be made unofficial by 'giving it back to the community', anyone know what that actually means ? What exactly makes this subreddit 'official' at the moment (given that it wasn't created by Google employees to begin with) ? Anyway, very happy that it won't be shut down, it's the 8th most popular programming language subreddit: 1. Python 143689 2. Javascript 95845 3. Java 59514 4. PHP 44981 5. C++ 42625 6. C# 33718 7. Ruby 33042 8. Go 25221 9. Haskell 25080 10. C 23751 11. Swift 21730 12. Rust 20452
You know that, being a mailing list, you can get the content of golang-nuts sent to your email address? No shitty interface woes.
It'd be nice if bradfitz could just remove himself from here. That guy quite often insights the desire for me to split his lip. What a whiner. So the CEO modified the posts of some Trumpians. Who gives a fuck. /r/golang has nothing to do with any of that. Our corner of reddit is so far removed from any of that as to be it's own completely separate thing. This subreddit is perfectly fine. I have no idea where the contempt is coming from. All I see is on-topic discussion and project releases. Nice people answering questions, helping, and giving feedback; a little snarky but harmless conversation here and there; and the usability of reddit far exceeds that of anything Google has to offer. Google is just simply awful at anything social: G+ is a joke, YouTube (talk about being anti free spech!) comments are completely undiscoverable and mostly toxic; their own forums are something out of 2007, and similarly unusable. I just think the mods that have an issue should just leave and let some people who aren't reactionary whiners trying to personally involve themselves in drama needlessly step up and take the reins. I don't see any reason to change anything about this subreddit. There hasn't been widespread concern here in /r/golang, and if there has... I'd be hard pressed to find it.
I'm just the bearer of bad news, not affiliated with the proposal at all - bradfitz just stepped down as a mod 
It's "official" in the sense that it's mentioned on https://golang.org/help/ and a bunch of Googlers are moderators here. I have no idea how they intend to give it back to the community. Apparently if the last moderator removes himself, the sub turns public and then it's up to a Reddit admin to give mod rights to someone. Right now there are still non-Googlers mods, but they're inactive. If all Googlers remove themselves from moderation, the other mods will remain and it would stay the same as today.
&gt; Now I'm brainstorming how one might build a federated Reddit with public, signed mutation log, ala CT or other chains. And then multiple UIs could render the same public &amp; federated data set. /u/bradfitz - [we just had a recent discussion here](https://www.reddit.com/r/crypto/comments/5epqh9/chainmail_a_modest_proposal_for_censorshipfree/). Would welcome proposals and I'd definitely help build it out.
http://choosealicense.com/no-license/ look for the users section 
Yes. It's not strange if you consider a shared build system, for example.
Can I ask, what harm has the code of conduct actually caused?
The most recent mod added seems to be of the opinion the subreddit should be closed. Perhaps I'm misreading this? https://twitter.com/bketelsen/status/801938047814291460
Golang team is too loud, tantrum all the time.
I don't expect them to be posting every day, but you'd think one of the Go team would have *something* to say about the proposed deletion of subreddit that they regard as an official part of the community. So far the only one to comment has been Brad who has had the sense to remove himself as a moderator. 
Can we also get rid of you then? Code of conducts are very useful and help maintaining a safe space for people who otherwise would not feel safe enough from people like you. 
Edited my comment to (hopefully) better reflect what I meant. Brad has been great, but it's impossible to see how his proposal to delete the subreddit could be anything but harmful.
I think it's a legitimate viewpoint that a trust between reddit management and the community has been violated. I'm just worried that without this subreddit, there will be no refuge for Go programmers who are sick and tired of all this divisive CoC sillyness.
Well said. My thoughts exactly.
so why do they hate us anyway? What are the actual critiques of this space.
he even deleted his reddit account right?
they do not have to delete the posts even, the community will downvote it to oblivion. Don't believe it? Try posting something unrelated :D
Yes, and the wiki shouldn't be of the official Go project, let's create a github organisation and write our own wikis if we want
Yes and why we shouldn't revamp things so that they think highly if /r/golang. we don't care what they think(morally). Enough with the control. They are technically superior than most of us, but this is an artificial community if you don't let the community thrive. &gt;a wretched hive of scum and villainy Only someone who doesn't use /r/golang can call this whatever they called. I am pretty sure if you call their mailing list this they'll ban you from reddit. Irony?
Because there is value in building a system that cannot be manipulated by a central authority. He's not wrong that Reddit is flawed.
But they don't want to build someone and _not_ have an authority on it.
http://r8r.org/cf
I didn't know it was fine to be an ass on the official mailing list. No wonder /r/golang gets more visits than the "official" forum.
Yes, they call /r/golang toxic but they are fine calling /r/golang as a "wretched scum and villainy" on the "official" mailing list. Now we know what exactly is toxic, the google group. I have never had a -ve experience on /r/golang unless it was an interaction with the elites (they even had me banned for 60days because I told him politely what he told me in a snarky comment, I may be wrong, but still, /r/golang: never felt it was toxic) /r/golang is the most welcoming community which I was a part of.
Let's make a github org to post things there. It'd be really helpful.
Yes, that's the one I am talking about as well. https://github.com/avelino/awesome-go/pull/953 I have no clue why the travis build failed, it is a book, it does not have a unit test case doc!
What is the mailing list referred to ?
&gt; We want answers on /r/golang Agreed. And we get answers, and discussions, and links, and self-promotion, and the occasional troll, and the regular "/r/golang is toxic" hate speech. And that's okay. Stackoverflow is a club, and /r/golang is an open bazaar. Both have a reason to exist. Good to hear that this bazaar continues to live.
[removed]
Your pull request for Vue.js doesn't make any sense—it's completely conformant to the [HTML5 standards](https://www.w3.org/TR/html5/syntax.html#optional-tags) to omit those tags. In fact, the [Google Style Guide](https://google.github.io/styleguide/htmlcssguide.xml?showone=Optional_Tags#Optional_Tags) even recommends it. EDIT: fwiw, I use Vue.js using plain .js/.html/.css files (well, I use SCSS), without any other dependencies. I created a short Makefile to concatenate and minify the files, but these steps are unnecessary. Also, Evan You (creator/maintainer of Vue.js) no longer works for Google (and hasn't for a few years now if memory serves me correctly).
I would suggest to add recurrent postings asking the community for the latest nice go coding tricks they found, the latest no-no on some go code they want to share. On r/france they have such recurrent postings and this helps keeping the list active and interresting. 
Why would a moderator have to post on the sub ? What is relevant is that he/she realy moderates. What would be a problem is that the moderator is fake and just serve for reaching a quorum. 
If it is any consolation, that quote is a reference to what Ben Kenobi says in Star Wars about the Tatooine city Mos Eisley.
&gt;You won't believe how unpopular it is to make content simple to understand to newcomers. I think this is the usual greybeard-problem, tho with less greybeards. It might help to understand that teaching somebody to program is a not a zero-sum game, you don't loose anything, on the other hand, you can only gain and the other will definitely gain from it. Teaching others to program is the most essential thing we can do. It is not a shame to be taught or teach somebody. Of course some of the elite don't care, the greybeards (no offense to actual greybeards here), but hopefully enough people do. &gt;The thing is, here people downvote any and all comments which are rude, so it doesn't really matter to have their code of conduct. Which is why it should stay at "don't be an ass", it's enough of a code of conduct to have a clear baseline and vague enough that the community can fully police itself. &gt; had submitted a book to awesome-go, it hasn't been accepted yet and the authors didn't even comment yet. Even if awesome-go doesn#t accept every pull request, it's still an invaluable treasure of tools and libraries that make life easier and it should be included in the list. More traffic also might encourage the maintainer to accept more pull requests and police the list better. &gt;coding competitions Maybe, in my experience competitions on a subreddit quickly go forgotten because nobody really wants to do them, not that it's a bad idea.
Terrible idea.
Has vim 8 made its way to Ubuntu repositories yet?
Behaviour like yours is exactly the problem which I wanted to highlight. (inflexibility for adding things for aiding newcomers). It doesn't make sense to you, but it makes for the general user who is new to front end frameworks and reads the official guide ten times and does a npm install webpack and the npm installs the entire internet after half an hour and the user is still clueless. edit: Okay, html is fine without the head tag, but look at the whole PR, and the guide after the pr merges, it encourages the user to have the experience without having to go to jsfiddle, copy paste this to a html file and go along with the guide. It is myopic really and beginner unfriendly. Thanks for commenting it out, I would not have pointed the problem out without your comment.
I did read his passage. /r/golang is fine without anyone who thinks reddit is a "scum and whatnot". /r/golang is a place where I get news related to Go. This is not some company's official message board where we need to "trust" the website. This is unofficial. yes, if Medium.com did something like this then I can understand that companies wouldn't want to host their blogs there, but /r/golang is fine, we are not demanding an alternative and even if you end up creating one, /r/golang isn't going to go anywhere.
It is sad to hear this. I came to reddit one year ago so I am clueless as to who he was.
Ok that's great, but what does /r/golang have to do with coming up with a federated medium with signed mutation logs?
I don't disagree generally. But I would _hate_ to see the Golang wiki "choose sides" and officially endorse a particular project that isn't part of the core. For instance, if the Golang wiki went on at length about how to use Gorilla Mux, and completely ignored the myriad competitors it has. In other words, I feel like the Golang project should be as neutral as possible except for core libraries/packages whereas a community site can be as opinionated as the community wishes.
I was under the impression that he wanted to replace /r/golang to the new federated structure. Apologies if I misunderstood.
EDIT: Downvotes sort of prove my point. That's great background, thanks for the context. There are multiple issues here, but none of them are going to be fixed by removing the CoC. In fact, removing it may send out the wrong signal and significantly damage the community by asserting the mistaken notion that "political correctness" is a bureaucratic authoritarian control mechanism that seeks to censor, rather than it being a way of reminding people that other people have feelings that can be hurt. I'm involved in several programming language communities, because I'm a bit of a polyglot. I'm still very new to the Go community. The Go community has a pretty bad reputation with members of other programming language communities. Some of that is because of a perceived intolerance on technical ideas (of which I'm sure we can all think of numerous examples), and some of that is because of drama like this. Let's take the nicest community I know as an example of how to get it right: the Ruby community. Actually, since Rails, it's kind of become a bit horrible, but let's wind back. The code of conduct there is encapsulated by a single acronym: MINSWAN, which stands for "Matz [the language's creator] Is Nice So We Are Nice". If somebody is being a jerk, all you have to say is "Hey, MINSWAN, 'k?" and the meaning is clear. Normally enough to make somebody think "Oh man, everybody is so nice here, and look, I wasn't, perhaps I should fix that". The other factor is that people are rewarded for _entertaining_ other people. _why was widely lauded. Others who ran the weekly "Ruby Quiz" (which ended up as creating source material for a pretty good book), also became highly regarded. In Ruby there is always more than one way to do something, and therefore there has always been a fuzziness to whether somebody's answer to a problem could be considered "wrong". The strongest criticism I think I ever saw is "that's not very idiomatic Ruby, we might in general suggest using this method instead…" For some people this is why they hated Ruby. Fine. Get past that, and surely you can see that it is a more welcoming and nicer place to be than the Go mailing lists, right? Then Rails happened and people with "strong opinions" demanded attention, and it became popular, and now it's a little less of a nice community. The Go community to my eye - I've only been knocking around for less than a year - is already at the post-Rails stage. Lots of smart people with big opinions making them strongly, rubbing each other up the wrong way, and with no means to step in and say "Hey, enough, OK?" because there is a heavy leaning on formal measure - the CoC - and less so on a MINSWAN concept or the fact we accept we're all clueless monkeys trying to work things out for ourselves. It's more valued to be technically right in many parts of the Go community than it is to be entertaining (I'm not saying that's wrong, just an observation), and people don't want to be "fuzzy" about an answer, perhaps because the language itself is not quite so forgiving as others (and that's fine, it's part of the elegance). I asked for specific examples, and three people mention the same one, a member of the community for being sanctioned/warned for what that person strongly believes to be "objective truth". To my mind, they phrased things a little bluntly, and deserved to be told "hey, come on now, I bet their English is better than your [whatever language the other person spoke], right?". Did it need official warnings? Probably not. Interestingly for me, this exact issue would never happen in Ruby land either. The creators are all Japanese, and indeed the anglicisation of Ruby involved a few early adopters learning just enough Japanese to be able to speak to them very, very badly, and so the community is built on a bedrock of poor English, poor Japanese and everybody taking the time to try and help each other communicate better. But that's an aside. Would removing the CoC have made this issue better? Probably not. Somebody would have still been a bit rude ("It is just the truth", is no defence, but you can still be rude whilst telling the truth), somebody else may have felt they were being rude, except without the CoC they may not have felt able to make that clear. There is a global problem at the moment about valuing other people's problems as highly as one's own, and this seems a good example of it. Freedom of expression, "truth", reactions to authority, they've all played out in society in 2016 in ways few of us predicted, and these attitudes seem to be seeping into software communities, and this is perhaps a good example of it writ small. If you really want to get rid of the CoC, find a way to make it redundant. Find a way to get to Go's MINSWAN. Value comments and projects that entertain you, have whimsy within them, value those people who make you feel like you're at the online equivalent of a long, amiable, dinner party with great friends, because that's what the best communities feel like. At some point somebody will say "do we need this CoC?" and the answer will be a resounding "what CoC? Wow, forgotten all about that". Ripping it down as a political statement though? It's not going to fix _anything_.
I didn't find that was the case. I think /u/bradfitz was genuinely unhappy about /u/spez abusing his powers. In light of these events, he wants to solve the underlying problem to prevent this. After all, his previous work is in camlistore which is kind of similar.
[removed]
the Go community is becoming awful. the core team has never been much for PR but it seems to be reaching the point of disdain. the tone was set by Andrew Gerrand who has been dismissive and aloof from the start. not everyone is cut out for a PR role. Rob Pike is likewise not approachable or congenial but he doesn't purport to provide PR. Dear Google Go team: please post a picture of yourselves laughing or smiling. I need confirmation that you are human. too many people in the Go community outside of Google grovel to the core team, which doesn't help. 
You are precisely right that so much of the kindness of the Ruby community flows from Matz himself, who is a truly special person. We simply don't have anyone like that in the Go community; the tone set by the Google staff has been quite dismissive and aloof from the start and Brad's initial comment that set this off was of no surprise Removing the CoC would put us all back on a level playing field....not one where Andrew Gerrand is the morality police. It is worth noting that when the CoC was proposed, Dave Cheney suggested purging anyone who even wanted to critique it. Dave: please go away. You contribute nothing of real value, you are just a parrot
to be honest, nobody is happy that reddit CEO edited comments + announced it to the web. As a different project, yes, alternatives are needed, but not to replace /r/golang. /r/golang is pretty much the only place where mods don't kill curiosity of new comers.
Has anybody complained to the CoC team about these comments? It might be interesting to see if they are held to the same bar.
&gt; Behaviour like yours is exactly the problem which I wanted to highlight. (inflexibility for adding things for aiding newcomers). Every single issue you've had seems to stem from a [single piece of text you must have skipped over](http://vuejs.org/v2/guide/#Getting-Started). &gt; The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required. The text you wanted to add would only help people who know nothing about JS. You should not be using any framework if you are clueless about the language the framework enhances in the first place, and thus the extra text is superfluous. It's just like using a Go framework without any Go knowledge—it simply doesn't make any sense! You should really read [this](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.7nut18230) to learn how the state of things are in the current ecosystem, and hopefully don't end up killing yourself due to the numerous abstractions and tools required. I was completely new to front-end frameworks as well (although I knew JS), and was unable to get my head around React/Angular documentation at the time. Vue.js was the first project which made sense to me, thanks _to_ the documentation. The entire npm/webpack/whatever flavour of the month is usually where newcomers have problems (hell, I have issues with that entire ecosystem, which is why I tend to be as vanilla as possible with my implementations). But it is not the job of Vue.js to teach you how to use every other tool, they have their own documentation for that exact purpose. &gt; Okay, html is fine without the head tag, but look at the whole PR, and the guide after the pr merges, it encourages the user to have the experience without having to go to jsfiddle, copy paste this to a html file and go along with the guide. The JSFiddle is _easier_ to grasp because you can see the working example right in front of your face. No need to copy and paste. This gives new users a playground from which they can test different things to see how the application works without having to set up anything. With your method, they'd have to create a file somewhere on their computer (and assuming they're using Windows, have removed Windows from hiding file extensions, considering by default they're hidden), copying and pasting in the text, then having to open it in their web browser. If you actually care about people who are absolutely new to JS, these are yet more unnecessary steps to get a working example. Or they can just open up the JSFiddle and play around with the example. This is _exactly_ the same reason why [Golang](https://tour.golang.org/welcome/1), [Rust](https://doc.rust-lang.org/book/guessing-game.html), etc. all use online compilers to teach as well. It's easier. &gt; It is myopic really and beginner unfriendly. Well, that's like, your opinion, man. Vue.js has been used by multiple large companies and by thousands of people, yet you're the only one who seems to have any issues with it. In reality, it's actually the exact opposite. Perhaps all these problems don't stem from the documentation? EDIT: &gt; html is fine with invalid markup It's not invalid markup, that's the entire point. It's valid, as per the standard I linked.
No, it would act like "", but it wouldn't *be* "". However, just pointing out that nil is not a problem.
I had to do: sudo add-apt-repository ppa:jonathonf/vim sudo apt update sudo apt install vim So I guess not.
We use one of these boxes for deployments. Pulling down code and compiling would probably be a lot faster than compiling locally and then transferring up to AWS.
&gt; Nobody cares if it's an "official" Go subreddit or not. Literally, nobody. I care if it's an official Go subreddit...! :'(
I assume they either don't care at all what is happening here now (it's a space for the "plebs") or they are reading and realize this discussion is too radioactive to touch Absolutely sure they use a lot of off-channel communication inside Google, and there will be more as time goes on
&gt; Purpose News, happy with the content as it is. &gt; A moderation revamp If they don't use it then I think they should be replaced. &gt; Community Building I honestly don't care what the mailing list thinks. &gt; Customisation Please please please don't style the page differently to the default. I mean not at all, not in any way. No clever up/down vote css, no new thread styling, no header that means that every subreddit I go to I have to re-learn where the navigation is. Sure, add links to the sidebar, but I come to reddit for news, and the only thing that styling the page does is make that harder. The existing style works just fine.
I care about language design for many reasons including that languages shape the fault-tolerance, performance, and flexibility of the programs that are written with them. Yup you can make money with any language. That's not a good litmus for language design.
The quality of this /r/ is rapidly decreasing. Every 2nd post is a pic or an attempt to implement something like generics poorly.
&gt; Can we also get rid of you then &gt; help maintaining a safe space Apparently this "safe space" doesn't apply to OdinSQL (or perhaps not to anyone that also thinks the "code of conduct" is garbage).
I was talking about the Unix motto of "do one thing and do it well". I'd rather have a single tool for each purpose which I can easily integrate with other tools. I don't think you can cache so much that it would save a significant amount of time for things like goimports, but the code is there, so check where the bottlenecks are and maybe you can find something worthy of improvement.
Ahh gotcha, totally agree for the most part. I think my experience with Go tools is probably different since I had so many projects checked out. This was what got me thinking about this: https://github.com/golang/go/issues/17916
You're correct that removing the CoC isn't necessarily the correct solution. The fact that it has ever been enforced here creates a situation where removing it could send out the wrong signals, but I can't see any way forward where it remains in its current form. The actual "core" of the [Code of Conduct](https://golang.org/conduct), the **Gopher Values** and **Unwelcome Behaviour** sections are reasonable (imo), and I don't think that many people have an issue with those parts of the CoC - they are generally values to aspire to. The problem really comes to the moderation of said code. Assuming that /r/golang does become a non-official "Go Space" then the moderation of the CoC falls to the moderators of /r/golang, and not "The Code of Conduct Working Group" who have been the enforcers until now. It's worth noting that it does not appear as though **any** of the CoC Working Group actively participate in /r/golang, despite being described as "a group of people that represent the Go community". The Working Group never really represented /r/golang, but they were suddenly given moderation power over it, and for a website which is built around self-moderation, that feels very invasive. /r/rust is a good example of a subreddit where a CoC works fine, ~~which is why (to my understanding), the Go Team spoke to the /r/rust mods a few weeks ago about how they implemented their CoC without upsetting the community - again though, that just shows a complete lack of understanding by the Go Team because rather than attempt to hold a conversation about /r/golang in /r/golang, they went somewhere else~~ **edit:** please see the comment by /u/dgryski below. Moderation of /r/golang needs to come from the community. Taking the Values and Behaviour sections of the current CoC and using them for /r/golang could be a good middle ground.
edit: this is a waste of time.
True that. He is acting as if Google is an epitome of honesty. &gt;voting on comments is why reddit is so successful after all. Exactly, we do not need anything more. Reddit is just fine.
Thousands of other developers including myself have been in your place. Do you know what we did? We sat down quietly, learnt what we needed to learn in order to understand the material and moved on. Do you know what we didn't do? 
This is not exactly true. Some of them have been talking about deleting /r/golang for quite sometime now (check twitter if you do not believe me). The spez incident is just a scapegoat. 
&gt;Do you know what we didn't do? Write books which would help others save time?
I'm not going to not let them, I just don't want them to.
Please further your brainwashing. Where can I learn more about this economy? DId I purchase this too? :)
This is not constructive to the conversation.
Don't shut down r/golang, an incredibly helpful community, just because a political subreddit was abused. Wtf Google Groups suck. I'm glad that Reddit offers another, much more organized way to communicate.
Golang's electoral college.
&gt; /r/rust is a good example of a subreddit where a CoC works fine, which is why (to my understanding), the Go Team spoke to the /r/rust mods a few weeks ago about how they implemented their CoC without upsetting the community - again though, that just shows a complete lack of understanding by the Go Team because rather than attempt to hold a conversation about /r/golang in /r/golang, they went somewhere else. Since this was me, I'm going to clarify a few points here. *I* spoke to the /r/rust moderators. I'm not the Go team. I don't work at Google. I reached about because of the last huge CoC blow up thread. I didn't get involved in that, hoping it would blow over quickly. But it didn't. It got worse. And there were a lot of really negative, mean, rude, and *malicious* things being said about the people involved. I felt responsible, because as a moderator I *should* have stepped in and kept things civil. But I didn't. Part of that was because I didn't know exactly how to handle it. Part of it was because I didn't want to targetted by the anti-CoC crowd and have my name added to the list of Bad People(tm). (I've seen some people comment that "We deal with the jerks with down votes", but many of the things I felt particularly bad about leaving in that thread were high-ranking comments.) So, I reached out to /r/rust. They have a very different relationship with codes of conduct than Go does. Graydon set a very clear tone from the beginning about what was expected, and enforced it consistently across all the spaces he was present in. People who didn't like that chose not to get involved, or to play by his rules. When /r/rust became more popular, there was already the expectation of civil behaviour. Adding a written policy was no big deal. Leaders shape the tone of the community. We can see it with Graydone and Rust. We saw it with Matz and Ruby. And we saw it with Rob and Go. He's can be a bit of a jerk. And that snarky attitude set the tone of the initial mailing list and the initial community. People were given a pass to have "attitude" because that's how the leaders spoke. So when a CoC was introduced, people felt it was a change to how they were expected to behave, rather than a codification of how the community should be run. I wanted to know how the /r/rust moderators dealt with keeping a purely technical community. How did they respond to violations, to repeat offenders. How much visibility did they give to themselves and their actions. Obviously this is not something I could have asked from /r/golang. On the other hand, I *could* have asked "How do you want to be moderated?" But as we've seen before, the threads explode into anti-CoC rhetoric, strawmen arguments, and slippery slopes I'd get tired of linking to https://yourlogicalfallacyis.com/ . It's hard to know what people really think. And how many people think that way. Are these anti-CoC people trolls from outside? Sockpuppets? Are they just a vocal minority or do they really represent the views of the group? I want /r/golang to be a welcoming community. And for the most part it is. My goal with submitting content is to ensure that people have a reason to keep coming back. To ensure that people who drop by occasionally don't see the same 4 posts from a month ago. To show that there *is* Go stuff happening everywhere. It should be a celebration: Look at all this cool stuff we're doing! The people on the mailing list who don't read /r/golang only see the nasty threads, because those are the ones that get linked and shared in the other forums. "Wow, look at /r/golang blowing up against CoCs again. Look at the mean things they're saying. Aren't you glad we're not like them?" The rest of the time, /r/golang chungs along happily, but that's not the perception that outsiders get to see. By definition, they're not here every week reading the day-to-day posts and discussions. I don't have answers to these questions, nor do I have a good way to get them. Can I trust 400 reddit comments to come to a consensus on what should be done moving forward? I'm here because I want to make /r/golang a nice place to be. I've been submitting things here for long before I was a mod. Andrew made me a moderator after GopherCon specifically *because* none of the existing Go Team mods were involved in the Reddit community. How does this tie into https://en.wikipedia.org/wiki/Consent_of_the_governed ? Where do we draw the line between "free speech free-for-all" and "heavy-handed CoC-based moderation". How can we change the negative perception of Go that lingers in the other programming reddits? How can we change the perception of /r/golang on the mailing list? Where does the Forum fit into this? Or the IRC channel? Or the Gophers Slack? I still don't know. I'm still trying to figure it out. I'm also trying to figure out how to help this community I care about grow. Suggestions welcome. Even if it includes "Please step down."
While the criticisms may have been true when Rob Pike was more involved in the project, I don't think they've been applicable for a while now. I would *never* characterise Andrew as being dismissive and aloof. You could easily argue he cares too much, which is why the two-months of dealing with constant hate during the CoC drafting process pretty much burnt him out. (You might not notice but he's *way* less active than he used to be..)
Maybe I should have added that I noticed it will close automatically - however, I was expecting to find a way to close it manually but didn't. Looks like it can't be done :/
&gt; So when a CoC was introduced, people felt it was a change to how they were expected to behave.. I think this is because the CoC was driven top down and not really bottom up. Compare the CoC process with the package management process. Unless I missed it, the CoC process was more forced. A lot of people think a CoC of "Don't be an asshole." would be sufficient. &gt; It should be a celebration: Look at all this cool stuff we're doing! We should have a "What are you working on this month thread" like a number of other programming language subreddits do. &gt; How can we change the negative perception of Go that lingers in the other programming reddits? That should not be our goal really. Most people will never get past the lack of generics. Or feature X. &gt; Where do we draw the line between "free speech free-for-all" and "heavy-handed CoC-based moderation". Impossible question to answer, but I think we should err on the side of free speech. If a user is a continually problem then take the appropriate measure. The response to /u/4ad was too heavy handed a response for something so minor (especially since it was a complete misunderstanding of his post anyway...). The internet instinctively lashes out against all attempts to stifle free speech and it's a losing battle. &gt; How can we change the perception of /r/golang on the mailing list? As I tweeted to you, I don't think the mailing list overall has a negative opinion of reddit, but instead a range of Go stakeholders have certain social opinions that are often in conflict with how a large portion of the internet uses reddit. &gt;Where does the Forum fit into this? The forum doesn't fit into reddit at all. It is a different community with many overlapping users. They are fit to moderate how they choose. Same for IRC and Slack. &gt; Suggestions welcome. Even if it includes "Please step down." If you stepped down the only mod who actually uses reddit would be gone, which would be incredibly disappointing.
I think when people say "get rid of the CoC" they really are saying is "I don't trust the people who are supposed to be enforcing the CoC." No rational person really disagrees with the larger goals of keeping toxic people from distracting from building great things, but a lot of people are especially concerned about losing the "Linus Torvalds" of a community over something non-technical.
It's a trick to force people constructing that struct to name the fields. The added field there has an unexported name (the leading underscore), so it can't be named from outside the package.
+1
Shell scripts for simple stuff, a Go application of its own for more complex stuff. I used to use Python for the latter case, but Python is a bitch whenever you need a dependency just to run a script, something Go solves. Plus anyone able to hack on your app's codebase would be able to hack on the "scripts" since they share the same language.
There is the theoretical possibility of calling the [Flush](https://godoc.org/net/http#Flusher) method, if implemented, via type-assertions. But that will make your code brittle and make it potentially change behavior significantly under future refactorings (or the phase of the moon).
Make it trigger via API. Then you can set up a timer to call the appropriate endpoint to trigger it. For making the requests you can just use a channel. Spawn however many go funcs for the # of requests you want to be in flight at once. Not complete code since I'm on my phone but the general idea: // buffered channel, used trigger requests ids := make(chan string, 500) // have a max 25 in flight for 0...25 { go func(){ for { pic, err := catpics.Get(&lt;-ids) .... // save to db } }() } // load Garfield into db ids &lt;- "Garfield" This is a way to do it with queuing. If you need to trigger this from many places in code, you can easily encapsulate that into a struct to avoid passing around channels. You'll probably want a close channel in there, too. An alternative is you could just spawn 15k fibers (one for each request). You didn't give much info on the rate limiting Edit: don't split into a separate process unless it's impacting performance (which it really shouldn't unless you're doing complex processing). If you've put the logic in its own struct/interface, it's as easy as adding an implementation that triggers via the network instead of adding an item to the channel
I'm not going to say you are wrong. I'm going to say you failed to provide proof. And when such strong opinions, you should probably put up some evidence. 
&gt; I still don't know. I'm still trying to figure it out. I'm also trying to figure out how to help this community I care about grow. Like the efforts with the CoC, you're just trying too hard. If you expend too much effort trying to come up with a solution to a problem that is virtually non existent, you'll just end up wasting time or have it backfire (which for all intents and purposes -- the CoC kind of has). P.s. I'm not anti-CoC. The claims of effectiveness are dubious at best. I would prefer rules/policies be developed organically as situations arise and just have a blanket guideline that everyone should try to be reasonable to each other.
Pretty cool, but they forgot to drain the body of that `http.Get` in `doSomeAPICall`
FastHTTP is not as fast as net/http with HTTP2. Don't use it unless you only want to support HTTP/1.1.
https://github.com/labstack/echo
You can link them as you wish. Or just PM them to me is fine.
this is a great response, thanks for taking the time!
This is an excellent example of why it's good to learn different languages. With popular modern languages, like the ones you mentioned, you invariably learn their corresponding ecosystems as well. I have been using Python and Java for a long time now but I worked at Ruby shop for about year not too long ago. One of the big things that impressed me about Ruby was the tooling, I found Rubygems and bundler to be superior to virtualenv/pip and Maven/Ant. Also, rake really blew me away - a build/task tool written in and providing direct access to the language I was using. I'm using Python and Java mostly these days (trying to work some Go in where I can) and I've come across pyinvoke which is like a rake for Python. It's pretty good but there are many others in the Python world, it's just that there isn't really one headliner task tool like there is for Ruby. Now the problem with Go is that like Java, it's compiled (yeah yeah, native vs. bytecode) which means it doesn't lend itself well to a build/script/task environment. It's a bit weird to compile your build scripts to compile your project. . . interpreted languages just feel more natural in this type of environment. Even bash seems like a better choice than Go. BTW, I've looked for a task manager in Go too and didn't find much (just as you haven't). Couple points there 1. You could write one yourself, that does not help you right now though, it'll take some time to whip something together. 2. Because Go is compiled, I think a task manager written in Go would end up being like Ant or Maven, that is written in a config/markup language like YAML, JSON, XML, etc which in my opinion is less desirable than rake, gulp, pyinvoke or bash. Actually, with Java, I've moved away from Maven/Ant altogether and use gradle which uses Groovy and is very similar to rake and friends. 3. So just use rake, gulp, pyinvoke, gradle, etc. Your task manager doesn't need to be written in the language your project uses. It's certainly convenient but Go just doesn't feel like the right language for this kind of job. 
Wow, so I am fighting +vely to improve the docs and I am being downvoted. edit: I accept that I did a poor job at explaining my points in the hug f* ridden msg above. 
Just group related code together to minimize jumping between files and try to keep a healthy amount of code on each file. What I like to do when I start a Go project e.g. with a package or project name `goo`, I keep all the types and (package) domain logic in the `goo.go` file. When it grows too large I start moving code to other files with meaningful names. For example if I have code that handles users in my application I move the User type, services and related code in a `user.go` file but still keep `goo.go` as the "entry point". Personally I've never had the need for a `types.go` file and it is rarely used in the standard library as well (only 2 cases: database/sql/driver/types.go &amp; os/types.go). I suppose you could use a `types.go` file if you cannot find any other meaningful name but you should not restrict yourself to keeping all your types there. Split your code when it makes sense.
Looks like another electoral vote vs popular vote ;)
&gt;Just be sure to not annoy anyone who tells you that they don't want your pull request as you did here, as in the end, it's their project, and most likely understand it far better than you do. Yes, I won't annoy them. Deleted the message. The problem would be that the post was written out of frustration and anger. Either my points are totally wrong _or_ I did a horrible job at explaining them. I'm sorry for that. I'll be polite in my point below, if you seem it to be valid, pls leave a comment. "The problem I have is that the doc teaches people to use webpack and things like that. Do we really need that? The docs are great, can't we have a simple example in the docs to copy paste for newcomers? The thing is, when anyone new comes to the docs, they would want to run examples by themselves, and execute it, (here I think offline examples are great rather than jsfiddle, because half the time I am not having internet access). My point (please excuse the many f*) was this, docs are great, but they can me made better? You guys are Vue pros now, so it might not matter to you! It does to the newcomers who struggle with npm. lastly, there is really no need to use npm webpack, I do realize it is their docs and their decision, which is why I abstain now. But I do strongly feel that docs should be as newbie friendly as possible. And I get very angry at how docs are not newbie friendly"
Can you point out* where in the documentation it says you have to use npm or webpack? (outside of the Advanced section, of course)
precisely my point. I can't use this tool because of this.
It's simple. You cannot use Vue.js with zero JavaScript knowledge, and knowing how to run JavaScript (using &lt;script&gt;) is the very first thing anyone learns about the language, so anyone reading Vue.js documentation should already have that knowledge. Even _jQuery_, which is known for being the very first framework people new to JavaScript use, [doesn't have that](https://jquery.com/download/). If they don't know how to run JavaScript, then they shouldn't be using a framework in the first place, as they can do absolutely nothing with it since they don't understand the language which the framework is built upon. Remember, a framework _enhances_ a language, so you need to know the language first. Does that make sense?
Honestly, the fact that we even need to debate whether it's ok to shut down the community subreddit just because one google dev got pissed at the reddit ceo is pretty sad.
Currently I only plan to use HTTP/1.1. The application I need it for is only for a handfull users. I expect FastHTTP will catch on if it's possible. FastHTTP is 5 to 10 times faster. I don't have many users, but I want to spare server ressources for data processing.
And then read this for a deeper understanding of C https://pacman128.github.io/pcasm/
So, as far as I understand - you need to batch up requests to another API. And those requests are created by either requests to your API or a timer. I would say divide this task into 2 separate goroutines. One handing the creating of the external API request, other one handling the batching and actually making the request and subsequent write to the DB. The 1st goroutine can be a simple for-select loop, where the 2 conditions are a timer tick, and a request to your service. Then, inside the block, you construct the request to make and send it over to the 2nd goroutine. The 2nd goroutine can have a fill and flush policy - where you queue up requests and a timer ticks, after which you make the requests.
Care to describe how it was done in a totally unreadable way?
yes, there are many of them.
Can you paste such a thing here? I can't recall the licensing and contractual details of such speculative code that may exist.
What I know is that using or not using pointers changes the style of constructing your functions. If your data can go on the stack then maybe don't use a pointer, if your data must persist and cannot be copied then use a pointer to the type instance. By taking this choice now the mutex may be necessary for goroutine programming. So your choice also has effects in the concurrent part of the Go language too.
Wouldn't a comment suffice?
I don't know much about MQTT but is there a need for TLS? Also what kind of authentication/trust do you plan to implement? You could implement encryption/trust at the application layer. 
Yeah I explained rather poorly. There's 2 rate limits I need to obey: no more than 20 concurrent requests at a time, and no more than 100 requests per second. In node I implemented the queue as a simple (unexposed) array that got filled through a public method. That method would add a single request and call another method to start executing the queue, which took queued requests from the queue and started executing them in parallel within the rate limits. Each finished request in turn would call that same method to continue the flow after it was finished. &amp;nbsp; It seems I have misunderstood channels on a pretty basic level. Please confirm if I'm interpreting the your code correctly: * You create a channel to serve as a means of communicating between the main and secondary threads. * You then create 25 secondary threads that will be in an endless loop, waiting for a message through the channel and will execute a request once they get it, then wait again * You can send a new request to the processing functions by sending something into the channel If that is how the code works, then thank you, this was pretty much what I was looking for. Would using a mutex and an int counter be a good solution to handling the req/s part of the limit? Check the count before sending a request into the channel, increment before executing the request, decrement 1s after the request is done? &amp;nbsp; Edit: Another question - since I know I can have a large number of queued requests at the same time, what would be the best way to work around the channel buffer size? One solution I found (https://groups.google.com/forum/#!topic/golang-nuts/UnzE5vgyzqw) is to simply send to channel in a go subrutine: &amp;nbsp; func (ch Chan) send (val Type) { go func() { ch &lt;- val } () } Is that an acceptable solution? If I understand it right, the subroutine will wait until the channel's buffer is not free and then add the value to the buffer, while not blocking the main thread's code.
I would like to learn how to use Go with Angular 2. I am curious about Angular Universal. Enable Angular Universal with a Go backend https://github.com/angular/universal/issues/391
go tool dist list
(I'm mostly a lurker here but the outcome of this discussion will most likely change that one way or another so I thought I should chime in...) To be fair, IMHO it doesn't really matter if a moderator works for Google or not. What matters is who decided who can become a moderator here. At least from the outside it had the appearance for me that this decision was limited to Go core team members or Google employees. In this situation calling it "official" somehow makes sense. If a moderator is reading this, could you please give some details on this process? Thanks :-) If that "official" status should be changed, there has to be some kind of orderly transition. IMO making Reddit's admins pick moderators should be the last resort. I'm pretty sure there are tons of great folks here (big thanks to /u/dgryski for all his work, btw!) that we can resolve this :-)
Okay, we are not reaching a conclusion here. 1. As I mentioned earlier, the warning was added _later_ after an issue raised by me. 2. I am not trying to use webpack with Go. also don't you agree with the point that if you are having an example of initializing a project with the cli, you should at least have an example which shows the basic html? including the &lt;script&gt; tag? Anyways, you aren't a newbie to front end dev thus it is a piece of cake for you. It isn't for the newcomers. I am speaking as a newbie myself.
The requirements you described seem to pretty much meet mine, too, so your project might be interesting. However, since you got no documentation and only few code I don't have much of an idea, what it's actually about. But still keep me up to date :-)
No he has advanced the conversation, and he has not engaged in baseless criticism. Negativity or subtractive processes can certainly be very productive, and positivity or additive process can certainly be counterproductive. Saying that what somebody says is consistently negative, especially in an opaque and cognitively miserly way, does seem counterproductive.
Not sure I'd ever personally need to do a map/reduce. Mainly would just like a wrapper around slice/map/linked/etc that gives concurrency safe API abstraction. I found [gengen](https://github.com/joeshaw/gengen) can suit my needs.
Yeh, because I would love nothing more than to have thousands of mails cramming up my mailbox. Also the lack of voting means everyone's random crap is given equal priority. Mailing lists are horrible.
A Code of Conduct is not itself the polarizing discussion. It's really Google's mismanagement of trust, characterized by sweeping and ugly statements about people, unilateral decision-making over the community, aversion to punishing other Google employees for &lt;clear&gt; conduct violations, and the ugly willingness to consider decisions about name-squatting here without regard for community perspective (this would prevent the community from using the subreddit after Google abandons it). And Google waited until controversy to really react to the community. Only now when there's a PR issue for Google do they respond congenially. I can only imagine that as Google's name is on the line, more conversation is going to be pushed offline or to unmonitored channels. I don't think they're going to risk further damaging Google's credibility.
"Writing An Interpreter In Go" https://www.reddit.com/r/golang/comments/5eiiw6/writing_an_interpreter_in_go_now_available/
Can I ask why you want to do this? I think you should just be able to "return" if you want your handler to finish explicitly, won't stop other wrapping handlers though.
That is my current solution as well. And it is actually pretty good as there is a fixed upper bound for vertex, edge and face count for Voronoi generation (which I am doing). The first approach was a list of pointers and not actual data. And generate data with ``` return &amp;Edge{...} ``` But that leaves the allocated memory all over the place. 
Golang Weekly is my favorite one!
GNU make for large projects and `go build`/`go test` for small-medium sized projects.
I totally agree that, up to one scale, static files are just fine, I believe that many of developers do that, and when you reach a point when maintenance of this files, domains, SSL certificates, audit logs and user access becomes burden, then you try to automate and track changes. For a small set of packages/repositories and developers, files are the simple and right solution. When projects, teams and demand on change management grows, then a different approach is needed. If files were just fine, for example, git repository services would not exist, either public or private, gitolite, gitosis, gogs, even services like github or bitbucket. A solution for a problem at one scale (or requirements) may be a new problem at another. I hope that my answer contributes to a better understanding for writing this service. 
But why?
IMO this is the wrong question to ask. Instead you should learn what pointers are and how they operate so that they are not confusing to you (and a simple answer to your question will not help with that). Pointers are not black-magic, they are not complicated, it's like learning what a function is, what an argument is, what a variable is, etc; it's a basic programming concept (for languages that have them). Without an understanding of pointers you are destined to make basic errors using them (and, honestly IMO without having such an understanding you cannot be a competent Go programmer).
Make is still best in class for what it does, build a dependency graph of local files and commands to create them. Make becomes a problem if you try to use it to manage things that aren't files. Even docker images and containers becomes less ideal for make imo. I think make is a well understood tool by any seasoned developer just makes sure to keep it simple. If you have more complicated things to do put them in scripts in a separate dir using python / sh. I only write scripts in Go if they require my libraries API, when they do they get a cmd/&lt;name&gt; dir. Thats just my opinion, for quickly getting shit done Go is really rigid because it has properties that aren't motivated by that goal.
The grpc gophers slack channel is a pretty good source of information as well. 
As the author of gitosis, let me assure you the reason for the existence of gitosis is purely security, to limit what the git-only accounts can do.
Great, thank you for gitosis, it was very helpful for me for access control, or as you said security. That is one of the main features of gopherpit, but just with web interface, beside audit logs, domains and team management on the same web interface, and automation of ssl certificates for every domain. While gitosis and gitolite are great for a smaller teams. And for example gogs is written with much more features, and suitable for a different scale of projects, developers and/or requirements. It is great that both of them can be used depending on requirements. The same as one can use for go packages files served by a webserver, gopherpit (local installation or public service), or to write different solution and hopefully to share with others. As you are the author of gitosis, I found your first comment a bit controversial.
Excellent. A bit dense in information but very comprehensive. 
Ive got an example GRPC project that I didn't quite finish that I'll post in there.
so far the only "official" engagement seems to be punitive and/or dismissive. other than that, the rest of the "normie" community here has been extremely helpful, and all of the shared projects and articles are a very welcomed resource. **Purpose** A place for general discussions, sharing articles, etc. you know--basically exactly what we already do here. **revamp** Only moderators that should step down should be any that entertained the idea of shutting this subreddit down. Any type of attitude that leans towards that, should not be welcome. I'm not aware of any mods in that camp, but I don't keep tabs either. **Community Building** Some other good creative subreddits usually have a weekly "What are you working on?" threads, along with weekly (or certain day) threads about "everyone discuss X topic" (e.g. let's all discuss the logrus package -- tips, tricks, caveats, limitations, forks, etc.) As for the mailing lists, I don't understand why anyone would prefer that format. I don't even bother reading the google groups/etc. **Engagement and structure** same as above, i probably conflated the two. **Customization** Just make it abundantly clear this is an unofficial resource, and beat users over the head in the header with logos/links/etc. all going towards the "official" places for golang. So that everyone on the mailing list can stop whining about visitors getting confused that this is official.
Nice little write up. It may be good to mention the [relevant documentation](https://golang.org/pkg/text/template/#hdr-Actions). Specifically, noting that the original form you had is explicitly executed with "nil data", while the second form allows you to pass in a value for dot: {{template "name"}} The template with the specified name is executed with nil data. {{template "name" pipeline}} The template with the specified name is executed with dot set to the value of the pipeline.
Good point. I'll add that right now.
&gt; As I mentioned earlier, the warning was added later after an issue raised by me. Why do you believe it matters _when_ the warning was added? It's there now, and you're still complaining. People visiting that page will no longer try to use vue-cli due to this message, and thus will not come across your problems. &gt; I am not trying to use webpack with Go. You said, and I quote: "I have no clue how to use webpack with Go", which means you are. &gt; also don't you agree with the point that if you are having an example of initializing a project with the cli, you should at least have an example which shows the basic html? including the &lt;script&gt; tag? The CLI creates [a full HTML page](http://i.imgur.com/g8cLEFb.png), and explains with a comment that the built files will be automatically injected into that document. Then if you go into "src/" and look at Vue.js, [you'll notice that the script tag is there](http://i.imgur.com/tN6iC8F.png). If you can put two and two together, that means that the script tag is injected into the HTML file. And by the way, this is coming from someone who has never used vue-cli before, so we're on the same level here. &gt; Anyways, you aren't a newbie to front end dev thus it is a piece of cake for you. It isn't for the newcomers. I am speaking as a newbie myself. This is just a cop-out. If you're so new to web development that you don't know how to write JavaScript (and thus can't figure out that all JavaScript code should be inside a script tag), you don't use a framework built around the language (as I've said multiple times). You have failed to show me a single difficult problem for newcomers at this very moment in the documentation.
I am also interested in this topic. The argument that the existing C codebases are already good enough and it is not worth rewriting anything is quite strong and I am not going to disagree. Nevertheless it's always nice to see pure Go implementations even of just a small part of those libraries. If nobody ever starts them then they will never exist. Maybe the Go implementation will not end up being as fast but it might be a good trade off in terms of memory safety and might result in a codebase that is easier to maintain. Right now I am looking for something that can deal with webm files written in pure Go but there doesn't seem to be much out there.
Thanks. I now understand. Pretty nifty trick, even if slightly ugly.
* **Purpose:** In my mind, /r/golang exists as a vehicle for general Go discussion outside of Google. "General" in the sense of having a more expansive scope than the mailing list (which tends to focus on esoterica of the core language rather than the broader ecosystem), or specialized sites such as StackOverflow. "Outside of Google" in the sense that Googlers should feel welcomed, but not charged with any control or 'official' affiliation whatsoever. * **A moderation revamp:** I don't care how frequently a moderator writes posts on this subreddit. However, if they're not actively participating *in moderator duties*, then they should step down. Moreover, my sense from the mailing list is that the Go team's internal views of this community range from apathy to outright disdain. It does not seem that the Go team wishes for any "official" affiliation with Reddit... and after reading the comments in /u/bradfitz's mailing list thread, I don't want the Go team wielding exclusive power over this subreddit. If there are any active mods on the Go team who wish to continue, then I'm fine with that. But "ownership" should revert to the community. Let /u/dgryski, /u/skelterjohn, and any others issue a call for moderators. * **Community Building, pt. 1 (relationship with the mailing list):** I am not concerned about the cultural differences between the Go mailing list and this subreddit. The mailing list seems mostly to be very experienced, very intelligent, C++ greybeards who seek very specific discussion with a very specific tone. Reddit seems to attract more of the younger, less experienced, Python/Ruby/JavaScript webdev people who want broader discussion (e.g. learning about which libraries and frameworks are hot right now, showing off personal projects, etc). It's a shame that the mailing list people have always looked down on the Reddit community... and it's a shame that the Reddit community spends so much energy on immature anti-SJW outrage. Frankly, both group NEED the other in order for Go to exist and have any relevance whatsoever outside of Google. Alas, the two groups don't mix very well, but that's okay. They don't have to... these two communities are quite complementary from a distance. * **Community Building, pt. 2 (the CoC):** I'm really frustrated by a lot of the comments in this thread about the Code of Conduct, and by some *very* well-written comments being downvoted simply because the poster doesn't condemn the CoC. Well, downvote away... but if most people actually *read* that thing and decide that they can't abide by it, then I frankly don't want to be here. In terms of actual CONTENT, the thing basically just boils down to "don't be an asshole". I believe what sets people off is its STYLE... the references to "spaces", "microaggressions", etc. I guess you could say that people with a libertarian axe to grind are "triggered" by the phrasing. But regardless of how this subreddit's rules are drafted, there absolutely SHOULD be some rules... and they should be enforced by the mods. Base the rules on the current CoC text, or scrap it and start over, I don't care so long as the "don't be an asshole" spirit remains. In either case though, the proper recourse should be contacting the MODS rather some outside email address at Google. * **Engagement and Structure:** I wouldn't be adamantly *opposed* to "gimmicks" like "Crazy Contest Tuesdays!!!", but I wouldn't support them either. I'm happy with the overall content of this sub as-is. Moreover, I bet that participation in the gimmicks would quickly die off... and having those half-dead threads every week would make the sub look less healthy than it actually is. * **Customisation**: I would add a blue gopher logo and a couple of links. MAYBE. But then again, I personally have subreddit-specific CSS disabled across the board because I think it's annoying more often than not. 
The faq doesn't present any limitation in HTTP support. The optimization is only avoiding memory allocation and data copy. I'm still looking for a more detailed comparision to make a decision. I don't understand the downvote of my comments. I'm just asking.
iirc, the standard library lexer and parser isn't very good, and changing it would require changing the API so instead of breaking the Go compatibility promise, the compiler implements its own.
&gt;Usually there is only one correct way to do things. vs &gt;There should be one-- and preferably only one --obvious way to do it. 
It's called *The Zen of Python* but it contains principles that do not only apply to Python but to programming and software engineering in general and even to seemingly unrelated fields. I guess my point is that instead of watching this guy talk for 20min you can just read this document in 2min.
Excellent, thank you!
Nice! I'll be using this on Slack at work. What do you think about adding support for still image formats too? It looks relatively simple to do, just don't loop over the frames like you do in the gif. No memes would be safe! Thanks for the post. Looking at your repo gave me some ideas about refactoring some of my toy projects. Every day's a school day.
I threw together [an example](https://play.golang.org/p/Lx_f07gFUG) for ya. I think you get the general idea. &gt; You create a channel to serve as a means of communicating between the main and secondary threads. Yes. However, in the example I am also using channels to limit the requests that are ready to be processed &gt; You then create 25 secondary threads that will be in an endless loop, waiting for a message through the channel and will execute a request once they get it, then wait again Exactly &gt; You can send a new request to the processing functions by sending something into the channel Right. But as you'll see in the example I posted, we don't need to know that channels are used outside of where it's implemented. This makes it easier to interact with. func (ch Chan) send (val Type) { go func() { ch &lt;- val } () } you could just as easily use `go send("hello")` this way is nice because you can change the signature to `Send(val Type) error`. If you ever want to use it synchronously, you'll have the ability to get the return value(s)
 &gt; The code of conduct there is encapsulated by a single acronym: MINSWAN, which stands for "Matz [the language's creator] Is Nice So We Are Nice". If somebody is being a jerk, all you have to say is "Hey, MINSWAN, 'k?" and the meaning is clear. Normally enough to make somebody think "Oh man, everybody is so nice here, and look, I wasn't, perhaps I should fix that". I think having a single acronym like that is good because it is straightforward. DFTBA (Don't Forget To Be Awesome) is one of my favorites, via the Vlog Brothers (Hank and John Green). Which covers being positive AND entertaining (cause both are awesome). &gt; It's more valued to be technically right in many parts of the Go community than it is to be entertaining (I'm not saying that's wrong, just an observation), and people don't want to be "fuzzy" about an answer, perhaps because the language itself is not quite so forgiving as others (and that's fine, it's part of the elegance). Great observation -- part of this I think also has to do with where people started using Go at first. Ruby a lot of us played with at home, opted in and got to warm to slowly, it has a lot of fun (and insane) bits. Go is in production, in the wild, at our jobs. Lots of people deal with their first Go code at work. This lessens the entertainment / fun side and increase the stress and focus on correctness. &gt; Did it need official warnings? Probably not. And, IMHO, the tone of the warning was just as bad as the tone of the comment. "This is your warning" is very dismissive and rude and despite claims to the contrary to me seems like the end of the conversation, not a request for pushback. &gt; Would removing the CoC have made this issue better? Probably not. In terms of the subreddit, the CoC doesn't make much sense, because it demands review by an official board that explicitly has disavowed Reddit. It will have to change no matter what, if nothing else just to change who applies it. 
Ah, thanks for clarifying.
gitosis is a simple &amp; minimal tool, and its author suggests a simpler, more minimal approach. Checks out fine.
I didn't know that. Good callout. I'll add that to the readme. Thanks!
I put your comment back up to 1. Idiomatic libraries are a religious issue here, often for good reason. Even though I'm not strictly discouraging you from using fasthttp, I'm pretty sure any bottleneck in your application does not lie in the routing. As for HTTP support, the FAQ tries to hide it by wording it like this: &gt;net/http handles more HTTP corner cases.
This is one of those areas I think some game development patterns may workout nicely. I've seen other stuff like slack bots that follow a similar rule based pattern that run into the same scaling issues. Might be worth while to look into before you have too many rules too refactor. I won't deep dive the subject, but a good starting point would be behavioral trees. Go would make a concurrent tree much easier to reason about similarly to how you have already done, the main win from a behavior tree is you can efficiently drill down through rules without redundancy that may end up in groups of checks. For example maybe 3 of your 6 rules have a condition that requires a slow call to the FB api. You can add a condition above the rules in the tree to only check it once. Go would be cool because if you had several slow checks you could easily create a Select condition that launches a group of child conditions in Go routines and returns the first match (which in a properly constructed teee would be exactly one). Just food for thought cool article though. 
&gt; I suspect that rather than converting the compiler to use them it makes more sense to make the newly redesigned parser and lexer available as their eventual replacement. The compiler's packages are nicer in many ways, but much of the value of the standard AST package derives from it being _the standard_ AST package. I dread the mountains of busywork that would result from maintaining two ports of crucial AST clients such as the type checker and parts of x/tools.
There's an existing Foreman clone called Forego. Iirc it's by the Foreman author. https://github.com/ddollar/forego
Oh, I guess I didn't realize the name is overloaded. TIL. Thanks. 
I don't need or appreciate anyone creating a "safe space"protecting me from criticizim of any kind. 
Once the new libraries are in place, the old ones can no-doubt be replaced by simple wrappers of the new ones -- which perhaps could emit deprecation logs at some point...
Why has the spez incident had such a radical impact on your view of reddit? It was admitted to, and as a result is very unlikely to happen again. It was also likely to be an isolated incident. People make mistakes, he owned up to this one with transparency. No platform is perfect, you seem to be holding reddit to an unreasonable standard. 
Before you try, Go tip on Android is not working due to low level runtime stuff, should be fixed soon :) https://github.com/golang/go/issues/18041
+1