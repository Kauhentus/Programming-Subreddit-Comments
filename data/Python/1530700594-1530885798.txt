I like it. Nice and simple. I think I will try it with a very simple project I have. 
Go for Django. Maybe the leaning curve is a little bit harsh but it's worth.
Until Armin get's of the high horse about unicode handling, suggesting click should come with a warning.
Awesome explanation, thanks!
The official PyMongo client works just fine.
Umm... orthogonal to the question. But legal or not scraping is rife in numerous commercial sectors. 
Working on expanding our reach for PyCon Balkan 2018 in Belgrade, Serbia! We're looking for potential speakers and people to host workshops, as well as just building up interest for our convention this November. http://pyconbalkan.com/
To be fair, Python just got tolerant of misconfigured ASCII environments in 3.7. I've dealt with the problem click solves on various Linux distros, and it is frustrating because everything will seem fine until the multibyte character appears.
For those interested in doing these kinds of simulations, have a look at [https://fenicsproject.org/](https://fenicsproject.org/), which is supported by NumFOCUS: &gt;FEniCS is a popular open-source (LGPLv3) computing platform for solving partial differential equations (PDEs). FEniCS enables users to quickly translate scientific models into efficient finite element code. With the high-level Python and C++ interfaces to FEniCS, it is easy to get started, but FEniCS offers also powerful capabilities for more experienced programmers. FEniCS runs on a multitude of platforms ranging from laptops to high-performance clusters. It is extremely useful for fluid dynamics simulations. I'd like to know from the FluidDyn project members how they view FluidDyn compared to FEniCS.
I'll freely admit that it's unethical and I don't expect everybody to agree, but I build my automations to break without some kind of relatively regular low level input from me every couple of weeks. If I leave on good terms in the future and my automations are still relevant I'll write out the input requirement and they can continue to run and be used until they naturally break from system changes or whatever, but if for whatever reason I don't leave by choice, they're not getting free "labour" off of something I made for more than a couple of weeks. 
Thank you very much
Python does not add anything useful over assembly, other than a lower line count. Clearly then, more powerful ways to express things in fewer lines is valuable, so it's not a black or white argument of "just syntactic sugar", "doesn't add anything useful". We could argue over how much value it adds, but it is a far more nuanced tradeoff than all of the people blindly overreacting to the PEP make it out to be.
i did try it but it doesn't support command like [myprog.py](https://myprog.py) list files -arg1 -arg2. If it does i could not find it which means it's more complicated than it needs to be. In addition i wanted to make the argument name optional, so if i run \`list files 1 2 3\` 1 2 and 3 will be automatically red as argument but if i want i can also specify the names \`list files -arg1=1 -arg3 3 -arg2=2\` which i think it's not allowed in click
It is inline javascript with a bit that happens to look JSON compatible (because the quoted property names). BeautifulSoup doesn't parse the javascript code itself but you can use it to extract the text content from the script tag and then use a bit of Python to extract the data you need. Maybe some regex, or maybe chop the `var reports=` and `;` and parse the remainder with a JSON parser (depends on what else is in there. 
I don't agree with the tone, but to be fair, dataclass is basically `attrs` which already exists and is widely used. Maybe they could fix aysncio's event loop or work more on the GIL removal etc?
Looks great! Yet to try it out but I look forward to doing so when I can
`all()` and `any()` are defined to terminate eagerly, on the first value that they can. A equivalent for loop is shown directly in the documentation.
Python has a lot of users in data science and machine learning. These users can't use Jython as they need c-extension compatibility.
^The linked tweet was tweeted by [@SerhiyStorchaka](https://twitter.com/SerhiyStorchaka) on Jul 03, 2018 22:27:52 UTC (1 Retweets | 4 Favorites) ------------------------------------------------- [@1st1](https://twitter.com/1st1) [@ncoghlan\_dev](https://twitter.com/ncoghlan\_dev) [@elibendersky ](https://twitter.com/elibendersky ) The result of the poll: 29 coredevs dislike üëé PEP 572 vs 3 coredevs like üëç it. Seems that just these 3 people generate 50% of comments. [https://www.mail-archive.com/python-committers@python.org/msg05324.html](https://www.mail-archive.com/python-committers@python.org/msg05324.html) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
Could you elaborate?
Wha?
 def __init__(self, name, shortName=None, argType=str, required=None, variable=None, default=None): `shortName` and `argType` don't follow PEP8, they should be `short_name` and `arg_type`. Since this is external API, not following conventions would definitely be confusing for the user.
It needs the ability to adjust the speed. For a light I'd expected about 15 words per minute with a competent operator. Audio can be a lot faster. My grandfather was World War 2 Navy and they hit 100+ wpm on audio.
Props on gathering 18 upvotes right off the bat whereas my attempt to share mine a bit ago was stuck at +0 for a whole day :) Maybe it's in the title...
It looks horrible. Hopefully it can be saved in syntax highlighting. But you're right. If people don't like it, they can crush it in code reviews.
thank for pointing it out, i'm surprise my linter didn't complain about it, i'll fix it
i honestly didn't expect any upvote :D i didn't even know if it was worth posting on reddit but i'm happy to see that people find it nice :D help with the motivation
 There is a precedent that it's not illegal in the U.S. [https://arstechnica.com/tech-policy/2017/08/court-rejects-linkedin-claim-that-unauthorized-scraping-is-hacking/](https://arstechnica.com/tech-policy/2017/08/court-rejects-linkedin-claim-that-unauthorized-scraping-is-hacking/) 
2 months ago. Which is 2 centuries on Python-idea.
This syntax is already banned in our style guide at work and we haven't even migrated to 3.7. I can't believe such atrocity was accepted, but we still can't have switch statement or pattern matching.
I hesitate to say.. RTFM.. but you may need to dig deeper next time. What you're looking for in click is `group`. Options and Arguments also take a number of input parameters within the code,which make your examples also possible. The entire git cli could be written in python using click. # myprog.py import click @click.group() # lots of options here for group too def run(): pass @run.group('list') def list_command(): pass @list_command.command('files') @option('-1', '--arg1', 'arg01', is_flag=True, help='Arg 1') @option('-2', '--arg2', 'arg02', is_flag=True, help='Arg 2') def files_command(arg01, arg02): ... 
Why did they ruin 2 by making 3.
Fair enough, I haven't looked into it any much detail at all but appreciate the insight.
We are aware of FEniCS but we don't have hands on experience with it to make a quantitative comparison. From what I know so far, key features of FEniCS are: 1. Solvers which use **finite element method**, thereby able to tackle complex geometries and suitable for industrial applications. 2. Defines solvers symbolically. 3. Fenics JIT compiles its solvers into compiled extensions (Am I right?) *On point 1*: FluidSim, the CFD framework of FluidDyn project, is right now focussed on **pseudo-spectral** methods, with some support for **finite-difference** methods also, out of the box. Therefore the geometries it solves as of now are quite simple. But what we offer on top simply providing a solver, is an ability to run postprocessing on-the-fly (during runtime), and output somewhat involved analysis such as spectra, structure functions, time-series of physical quantities. *On point 2*: Symbolic solvers frameworks, usually require users to build a solver **from the scratch (or from examples)** and using the building blocks they provide. Also optimization may require an expert knowledge of the internals. Our approach is to define the solvers and building blocks using **classes** \- which means you can use inheritance and reuse code as much as possible for similar problem. We have some builtin solvers for standard governing equations. To define a solver, you might need to know how to write classes and some NumPy code. *On point 3*: To promote ease of debugging and maintainability and to make developing easier for newcomers, one can follow the Pareto principle (80&amp;#37; of the runtime is performed by 20&amp;#37; of the source code and vice versa). In FluidSim, a majority in terms of lines of code is Python-Numpy code. Functions which require optimization are identified via **profiling** and turned into extension**s using Pythra**n/Cython. Lastly, being a framework, it can interface well with third-party solvers such as [Basilisk](http://basilisk.fr), so I am quite optimistic we can enhance other solvers as well.
Wtf? We need to get done with this mentality. Things move forward. And change. What is exactly that they killed and thus ruined 2? It's been more than a decade and they still support 2.7 providing hotfixes and many backports.
That seems a bit exaggerated.
The datetime package is quite confusing to me, it's both common to import datetime and to "from datetime import datetime", and I can never remember if the things I need are in datetime or datetime.datetime. But that's also because I don't use it super often. I still think that this was not the best naming
Thanks, I actually just caught wind of this in a different thread and is testing it out! 
Metaclasses
This tweet is I think almost intentionally misleading. If you go to the source link you can find that: &gt; Two people voted on a variant of the PEP, so I excluded from my results: &gt; &gt;* Steven D'Aprano: With the changes suggested by Guido, +1 &gt;* Ethan Furman: With Tim's and Guido's latest suggestions, +1 In other words he's already misrepresenting the current poll. Furthermore: &gt; Again, it was just a poll. Not a vote. Multiple people also added a second vote for a variant of the PEP. I only counted results on the current PEP version. There exists a separate opinion poll about the PEP in a more recent developed state and the results of this poll aren't included in the post or the tweet about the issue.
A switch statement is redundant in every language. 
I remember thinking I'd love python to have all sorts of fancy features: multiline lambdas, "prettier lambdas", a switch statement, pattern matching, syntax sugar for partials, function composition, piping, etc." But the older I get the more I can relate to [this sentiment](https://youtu.be/p33CVV29OG8?t=3814).
#### [Modern Dictionaries by Raymond Hettinger](https://youtu.be/p33CVV29OG8?t=3814.) ##### 51,760 views &amp;nbsp;üëç732 üëé13 *** Description: AbstractPython's dictionaries are stunningly good. Over the years, many great ideas have combined together to produce the modern implementation in Pyt... *SF Python, Published on Dec 15, 2016* *** ^(Beep Boop. I'm a bot! This content was auto-generated to provide Youtube details. Respond 'delete' to delete this.) ^(|) [^(Opt Out)](http://np.reddit.com/r/YTubeInfoBot/wiki/index) ^(|) [^(More Info)](http://np.reddit.com/r/YTubeInfoBot/)
https://stackoverflow.com/questions/23377665/python-scipy-fft-wav-files Most of what you're looking for is just maths based on the result of an fft. I've used the above method with good results. 
wow, N=32!
That is such ultra powerful stuff.. I also recommend DYMGroup (Did-you-mean?) which offers hints on spelling errors: https://github.com/click-contrib/click-didyoumean Another extremely powerful feature is wrapping stuff up via setuptools' entrypoint system: http://click.pocoo.org/dev/setuptools/#scripts-in-packages Generally, having a good look at click-contrib is a good idea: https://github.com/click-contrib Have fun!
What does it have vs argparse that would justify adding a non- standard dependency?
making an empty function just to create a group it's still a bit annoying but i will try it again. Another feature i wanted to add is automatic parameter inference using mypi syntax but if click is really so good i may add it to click
So what's bad about it? I don't really follow PEPs but this seems like a useful feature to me.
&gt; A switch statement is redundant in every language. All other operations than [DBZ](https://en.wikipedia.org/wiki/One_instruction_set_computer) are obsolete on any architecture. However, the practicality of such an architecture is somewhat dubious. Likewise for switch being redundant. For instance, how would you implement Duff's device without a switch? 
IO means input and output. This refers to any data coming into or going out out your program. Executing most operations is usually extremely fast but IO is typically one of the slowest things you'll do. Programs typically operate in a serial fashion with one event giving rise to the next and so on and so forth. Only one thing is happening at a time. We can get around this by threading or multi-processing but this is difficult to do correctly and error prone. What async does is allow the program to do something else whilst it waits for the IO operation (this is a free gross misrepresentation, but works for you). That way we can do something else whilst we wait for our data to come in e.g. we can create a new file to store the stuff in, open a database connection and so on. When the IO operation completes we can then use the info we got from it. It means we don't have to wait for the IO operation to complete before doing something else. Async is more than just IO though so don't think it actually has anything to do with it, except that we can use it for that. Async is probably the best way to overcome IO limiting factors because speed of code execution is so insanely fast. Just so you know, list is a reserved word. Don't use it in programs even in pseudocode. Now I can guarantee that your requests is probably the slowest part of your code. This is unlikely to produce any speedup but may help if the server returns bad headers. Try this: lst = requests.get(https://website.com/api/v1.1/public/info, headers={"Connection":"close"}).json() In all honesty, the speed you're looking at is about right for a URL request. This is largely a limitation of Internet speed, latency, and just how long the address takes to resolve and traverse. You can try using low latency infrastructure like fibre, putting your server closer to where your destination server is, maybe create persistent sockets if there is a way to and so on. As I keep saying, your code isn't going to be the issue. It's the network part of it all that is slow and costing you milliseconds. 
I think the general consensus is that it fundamentally alters the language semantics and really just does this: thing = do_call() if thing is not None: print('Do things with thing') to if (thing := do_call()) is not None: print('Do something with thing') It saves a single line (in a trivial example) with the cost of adding a new operator `:=` and requiring parens for clarity to ensure evaluation order. The place it could really help is [list comprehensions](https://www.python.org/dev/peps/pep-0572/#examples), though for anything complex I'd still go to a standard for-loop.
If you run click-script on a unicode-misconfigured system, it'll refuse to act at all and only display a warning to the user, until the problem is fixed: http://click.pocoo.org/5/python3/#python-3-surrogate-handling Additionally, last time i encountered this was on a specially hand configured unicode setup which mixed some encodings, because e.g. i do want a german locale but read manpages and shell output in the default "C" locale - mostly for being able to post shell output to non-german users. Unicode in Python worked fine with that, yet click complained hard until i standardized the setup. Imho, this is not a really problematic issue.
I hope everything works out for you. Happy hacking!
This is great! I'll first finish my python lessons and then start following this. Looks like a great project
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/engineering] [Python Scripts for Structural Engineers](https://www.reddit.com/r/engineering/comments/8w1nec/python_scripts_for_structural_engineers/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
the only thing i could not do with argparse is the option of avoid typing the name of the argument for non positional arguments. with Climb you can declare argument and call them by position or by name without changing anything. Except for that climb make it easier to write CLI compare to argparse.
While I'm pretty familiar with much of the datetime package, I agree. It's a huge mess, and often it's a better idea to use `dateutil` to do even intermediate date manipulation. There are a few things that could be done to improve datetime, such as adding synonyms for the classes that follow the PEP8 standard of PascalCaseClassNames, but honestly that's only a small improvement.
If you don't have a library handy, you could use `subprocess` and `ffmpeg ‚Ä¶ -f wav` to convert from `mp3` to `wav` (or if adventurous, to raw `pcm_s32le` or whatever you prefer). The math I'll leave to you.
I like it because I feel like it makes code clearer in quite a few cases. I often find myself writing ocde in a way that's clear, realizing that I'm evaluating something twice, then re-writing it in a less clear way with an assignment statement. I also like being able to use assignments in places where you can't use statements, like lambdas.
Yeah. In theory, users should not have to understand this, and the Homebrew project should be able to upgrade all the major Python packages in lockstep. In practice, that's not going to happen (not called Debian). And a Python programmer should probably understand `$PATH`, that `site-packages` are specific to Python versions, etc.
To be fair though all of those features would be more useful than this while keeping the feel of Python intact. I'm thinking of multiline lambdas* and pattern matching specifically. \* I know the solution is defining a function but there are times where this just isn't practical.
&gt;the only thing i could not do with argparse is the option of avoid typing the name of the argument for non positional arguments. What do you mean by this? If you don't have the name of the argument how can you know what argument it is other than position? &gt;th Climb you can declare argument and call them by position or by name without changing anything. Can you give an example? I legitimately don't understand. &gt; xcept for that climb make it easier to write CLI compare to argparse. Easier is subjective. Argparse is damned easy imho. 
‚ÄúAtrocity‚Äù is very emotive - care to offer an opinion with some substance? The new operator will show up rarely as good developers will know when to use it.
Thanks! I'll post an update in a few weeks in the weekly thread if anyone's interested
It is until you realize that there's a lot of power that you can gain by segregating the functionality. You may not need that right now, but in your package, you can't even tap into that feature set because of how you've set it up.
&gt; All other operations than DBZ are obsolete on any architecture. Huh, looks like I ruffled some feathers &gt; For instance, how would you implement Duff's device without a switch? I would leave loop unrolling to the compiler
I think there are places that it can improve readability, but the one I'm hoping it works for is assignments inside a lambda or comprehension to some subscriptable object, like a dictionary: [ d[k.upper()] := v +1 for k, v in other.items() ] Or when working with a collection of objects where you want to assign to some attribute on each of them and get those values for other computations: { obj.name: (obj.prop := f(obj)) for obj in myobjs } Obviously these are overly simplified examples, but I've run into problems before where the code would have been simpler if I had assignment expressions. It doesn't crop up a lot, but enough that I've looked for ways to do it before. It doesn't come up a lot, but consistently enough that it's a nice to have. Especially for us that have more C experience and are used to these types of tricks. Coming from an EE background, I'll say there's a lot of engineers that will use this syntax happily. 
Nah it‚Äôs a fundamentally different result in VHDL and Verilog. That‚Äôs a pretty reactionary statement. 
&gt; For instance, how would you implement Duff's device without a switch? void duff_without_switch_pseudocodey&lt;T&gt; (T * dest, T * src) { size_t to_copy = some_suitable_len_implementation(src); size_t to_single_byte_copy = to_copy % EFFICIENT_CHUNK_COPY_SIZE; to_copy -= to_single_byte_copy; while (to_single_byte_copy-- &gt; 0) { bytewise_copy(dest++, src++); // assuming pionter++ increments by the correct ammount } while (to_copy &gt; 0) { efficient_chunkwise_copy(dest++, src++); // assuming pionter++ increments by the correct ammount to_copy -= EFFICIENT_CHUNK_COPY_SIZE; } } 
Nice job! I bet there are a load of organisations out there that don't have the programming skill or mindset in-house to pluck this sort of low-hanging fruit. It sounds like a great opportunity - have fun! 
&gt; Huh, looks like I ruffled some feathers Not mine. My point is that even though it's possible to reduce everything to a Turing-machine, it's by no means redundant. I also think you took my comment about Duff's device a tad too serious.
That doesn't sound like a high horse. That sounds like a hard problem.
i Dont need asyncio, i need only twisted.
I almost want to give all my staff basic python training/courses because who knows what they will find in their own duties. it's really changed my perspective on things
The API and requirements of files and File-like objects. It is a bit of a mess to figure out what the file API is. What methods do they have? Is a name expected? What is all the stuff in `io` package, the various tempfile things and what you get from open() or requests/urllib? When is a file a stream? Does it even block? I got a basic working knowledge from experience but the docs are a bit murky.
Metaclasses are simple, when you need to solve a problem with metaclasses you shutdown the computer and go drinking instead.
I second that. Also with timezones. Last time I had to work with that, I spend quite some time to figure out things. 
Yeah, I missed that the PEP was since then [updated once on May 22](https://github.com/python/peps/commit/6d81538ecb9592ed14aa5bdeadf1502dda7cd0d3), but this change wasn't noted in the 'Post History' header. But judging by the responses to the latest python-dev discussion and by reactions on Twitter from core devs and other notable people in the community ([[1]](https://twitter.com/SerhiyStorchaka/status/1014229716121812992), [[2]](https://twitter.com/dabeaz/status/1014443173958115329), [[3]](https://twitter.com/ncoghlan_dev/status/1014280683731075072), [[4]](https://twitter.com/1st1/status/1014271636525240321)) it does seem like only three-four people dominated the convo and forced by their sometimes short-tempered responses to push all who disagreed with the PEP out of it. I do think there are some use-cases where this feature would be very helpful, but the way the discussion was handled and valid concerns dismissed (esp. by BDFL) makes me quite worried.
Why does `list` use `__repr__` instead of `__str__`? I am familiar with asyncio but the python implementation of the event loop is either very weird or slightly broken. Why does the new dataclass not assume `any` in the absence of a missing type declaration?
Can you elaborate about the list thing? 
The auto-completion and type checking of a good Python IDE is significantly improved by type annotations. You could argue for a different syntax based entirely on comments, but then you'd be writing your own custom tools for it.
If I call str on a list it should call str on each element, but it isntead uses repr.
how i coded if you define 3 arguments called arg1 arg2 arg3 the are both positional and keywords argument. if you if you run the program like this "[prog.py](https://prog.py) 1 2 3" arg1 will be 1 arg2 2 arg3 3 but at the same time you can run it in like this "[prog.py](https://prog.py) \--arg1 1 --arg3 3 --arg2 2" and it will work in the exact same way. the only limitation is that after passing an argument with a keywork you will need to use keywards for all the following arguments. I find this really useful in my CLI tools
Just downloaded pycharm, I realized I could get it free with a student email. I‚Äôve been on atom learning to work with Django. Wanted to get to know how to use pycharm quicker and get some projects going, but this thing seems like a python monster. Appreciate any tips or tricks links that you might prefer. Thanks. 
i don't doubt that. my package is still in very early stages so it can be changed easily if specific features are required. As i said i will give Click another go
Yup! I've resorted to doing this... from datetime import time as xtime import time 
How about an [abstract base class](https://docs.python.org/3/library/abc.html)? or just a [plain mixin](https://stackoverflow.com/a/547714/34549)? this keyword thing is just playing to folks who only know PHP or something. it's an anti-pattern.
I see. And what about "a1 a3 -arg2 a2" what happens then? Does it work?
Side effect operators in general are troublemakers. This PEP has a specific algorithm to give meaning to this line, thus avoiding undefined behavior: (x := (y := (x := 0))) But a language shouldn't require a complex procedure to interpret its syntax. Software semantics are complex enough without the syntax getting in the way.
Can you give an example where it makes code clearer? Every single example I've seen, it makes the code uglier and harder to read. Personally, I often even split more complex lines into multiple lines. When I write python, clarity is #1, and lines of code comes after. In almost every single case I've seen, this trades readability for fewer lines of codes, never the other way around.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
These are almost unreadable and very confusing. If someone writes this in my codebase I'll reject their PR. If you want complex behavior like that, use a proper loop, that sort of stuff doesn't belong in a comprehension. In python, readability is #1 for me. I'd rather have a few more lines of code that are readable, instead of a one-liner that I'll have to spend 10m deciphering in a year.
So then you're adding complexity to the language to solve a problem that is super rare and the solution of which is not that bad? That sounds like a very poor way to design a language.
I mean 263130836933693530167218012160000000 is a pretty large sample size.
Any good tutorials out there or resources you used that focus on the water resources libraries and how to implement them?
Sadly not much has changed. They proposed using the `as` keyword, which imo would've been cleaner, but that got rejected. They put a bunch of restrictions about where you can use it, which is good but at the same time just shows how rarely this will be used and it just adds to the complexity, you gotta remember where you can and can't use it. The whole parenthesis stuff for readability adds extra bloat too. All in all, this feels rushed, poorly thought out and unnecessary. It's making the language more complicated to solve one specific rare problem, and all it does it save 1 extra line of code. And some will argue that it makes your code cleaner, but I absolutely disagree. Rarely used operators will be inherently less known about, so it'll just confuse new users and make your code less readable.
That was quite an interesting talk you linked there - thanks!
How to create a linked list. It couldn‚Äôt ever stick with me through Uni.
Imo it actually makes your code more nested. Not in the indentation sense, but in nesting multiple things in a one-liner sense.
People weren't against f-string because of the feature itself, the problem was that having 3 string formatting in general is bad. f-strings are amazing, but it would've been much much better if they were the first and only string formatting in python. I guess with lint you can control what people in your codebase use.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Is there a place where we can respectfully and calmly voice our dislike for it? I don't want to spam mail lists or anything, but I'd like to say I at least tried to voice my opinion and impact Python's path.
The whole deal around packaging, importing modules, sys.path, and whether I need or don't need __init__.py. I know Python 2 required it and it's optional in Python 3. Even when the script works perfectly fine, I still find tools like Pylint and syntax highlighters complaining about not being able to find modules, which leaves a nagging thought in the back of my mind about whether or not I'm doing something wrong or if it's just some quirk of the tools. The second thing is dealing with requirements, virtualenvs, packaging, and publishing to PyPI, I get how to do it, but what I don't get is why it's still so cumbersome after so many years. Why are there so many different files and tools? setup.py, requirements.txt, setup.cfg, MANIFEST.in, pyproject.toml, Pipfile, setuptools, virtualenv, and probably more. There are even 3rd party tools built to help you deal with this mess like flit, hatch, and poetry. The fact that there's AT LEAST THREE is a red flag that indicates the normal way to do it isn't convenient and could definitely use improvement. The newest tool, Pipenv, is really great in simplifying management of requirements and virtualenvs, but it falls short as it doesn't address setup.py or setup.cfg at all. Plus, Pipenv is meant for Python applications and not Python libraries, the developer even said so himself. So as much as I love Pipenv, I'm a little disappointed that it didn't take the opportunity to just clean up this entire problem area once and for all. Maybe in Python 4...
Wouldn't a cleaner version be: `[s for s in map(str.strip, lst) if s]` Point is, if you need f(x) on both the left and right side, why not apply it before iterating on it?
Nice! Certainly for me, I can never muster half the productivity I'm really capable of until/unless there's a real deadline. Now you've got that! One thing I'll recommend: Prioritize features by importance, and make CERTAIN you test. TEST TEST TEST. Last thing you want is to discover 3 months from now that your output has been off for certain edge cases and stuff and you've made business decisions on dodgy data. Good Luck!
&gt;He didn't even know I was working on this software and if he did, he probably would have been happy because there is plenty of other non-data entry/processing work to do, so its not like he left because he caught wind of my software replacing him or something like that. He just didn't care or even understand what he did. Are you sure you are being paid enough for the role? I mean he could have a very good reason for leaving if hes being underpaid.
I‚Äôve wanted this feature specifically for the case where I‚Äôm writing a while loop (usually) and I want a loop-internal variable to get a new value on each iteration. Without assignment expressions, there are a couple options but I dislike them all. 1. Initialize the variable before the loop and do the reassignment at the end of the loop body, after its value has been used for the current iteration. 2. Create a boolean flag outside the loop and use that as the value that the loop checks. Then the needed variable is initialized at the start of the loop and the flag can be updated. I think (1) is more difficult logic, and (2) is needlessly complex. I would much rather be able to do the assignment in the test of the loop. It‚Äôs very common in C, and I always felt it had some elegance to it. The logic of the loop is much clearer (the value of the variable at hand is directly tied to the loop‚Äôs test, and the assignment is done up-front) and there‚Äôs no complication with an extra flag. But that‚Äôs the only case I can think of where I‚Äôm likely to use this new feature, and it doesn‚Äôt come up all that often really.
Right, which is my problem entirely. You're introducing a whole new operator to the language and adding complexity to solve 1-2 specific usecases. And on both of those cases, as you mention, you're only making the code slightly cleaner. I'm curious, would you be able to turn your socket or whatever you're consuming in the while loop into a generator and loop over that? Imo that would be cleaner and more Pythonic.
Oh yeah I have been testing throughout with that fear in mind. Good advice for sure! There are still going to be some things that will have to be done manually, but I always knew that would be the case. I figure in 3 months I will probably end up rewriting my garbage learner code from scratch. I plan on giving this thing a GUI or implementing in django as part of a much larger business app I'm planning.
Here's a presentation by one of the core Python developers that will give you some idea about async: https://youtu.be/9zinZmE3Ogk
I don't think it was that, I think he just wanted something new. He was doing that data job for almost 5 years, I don't blame him
I'm not a structural engineer, but why not use MATLAB for this?
I don't really understand that logic. At a high level, they both "mean" the same thing. Yes, in the with-statement, there's some extra magic that happens with the context manager, but I see that more as a property of the with-statement than a property of the `as`. I've always seen the `as` to be equal to `fp = open('file.txt')`, and the with-statement handles the context. As for interference, all you need to do is have an exception for with-statements. This is silly, we have a whole "keyword" that has a single unique use, and we could give it more utility, but instead we're gonna dd a whole other operator, which is even uglier. 
because MATLAB licenses cost $
Thanks for put me on the track :) it wasn't simple as that but I did it :D The --onefile tag create temp folder when script is running so to add any extra files I had to attach those files into temp folder. 1. Add to main .py script code. *if getattr(sys, 'frozen', False): #will detect running type* *script\_dir = sys.MEIPASS #compiled .exe* *elif \_\_file\_\_:* *script\_dir = os.path.dirname(\_\_file\_\_) #running live from ide* *#where "script\_dir" is location for files* \#*sys.MEIPASS - environment variable* 2. Run pyinstaller to get .spec file *e.g. pyinstaller -w -F Populate3D2.py* 3. Open spec file and edit: Add function [(from)](https://stackoverflow.com/questions/7674790/bundling-data-files-with-pyinstaller-onefile): *def resource\_path(relative\_path):* *""" Get absolute path to resource, works for dev and for* *PyInstaller """* *base\_path = getattr(sys,* *'\_MEIPASS', os.path.dirname(os.path.abspath(\_\_file\_\_)))* *return os.path.join(base\_path, relative\_path)* and add files like: e.g. a.datas += \[('3dlib.exe', resource\_path('3dlib.exe'), 'Data'), ('newini.ini',resource\_path('newini.ini),'Data')\] Will add '3dlib.exe' and 'newini.ini' into the bundle. 4. Run pyinstaller but this time .spec instead of .py *e.g. pyinstaller -w -F Populate3D2.spec* I'm new to python so I'm sure that's not the best solution but it's working. for me. 
I tend to agree. IIRC one case in particular did end up being a lot nastier to write, since it was a fairly complex operation that needed to both update and transform several nested layers of objects. While I usually like to take a more functional and immutable approach, this was also working with a large amount of data (for that system) where execution speed suffered by making extra copies of the data. It really was a case where this syntax would have helped to make things more succinct and readable. The alternative loops and whatnot were definitely more complicated to read. In general though, I wouldn't use this syntax much. There just aren't that many use cases where it's better than existing syntax. I don't think adding this operator is the best idea, but I also don't think it's the worst. I can see the rationale behind it, and personally have run into edge cases where it would have been nice to have, but it isn't a necessary feature of the language. Honestly, I think python has enough syntactic features already. 3.7 has all the things I want out of python, and I wish that developer time could be more focused on improving the existing code base. Problems like poor error messages in some places (I'm looking at you generators), better documentation, and the tool ecosystem. 
Why not `filtered_data = [x for x in map(f, data) if x is not None]` It's more readable and doesn't use any new operator. If you need f(x) on both left and right side, why not apply it before iterating? The problem with your code is that new users will have to know yet another operator to understand that line, and also understand that the right side runs first. The point of a comprehension is that it reads well and is simple to follow, this defeats that entirely.
I'd be curious to see what error messages from these assignments look like. Doubt they'd be much cleaner than generators.
Agreed. Complex comprehensions are a lot like complicated regexes: fun to write, **awful** to maintain. You get practically nothing from them over a for loop. 
This pretty much sums it up.
Fair, but I imagine if it increased productivity then most firms wouldn't flinch at the cost. Most multi-disciplined engineering firms are already gonna be dropping a ton on software.
def async and await confuse the shit out of me. I understand generators. I understand coroutines. Then I get lost.
That's a good point, I bet you're right that they'll be kind of crappy. Not awful, but not great. 
Yield. How to use it, when to use it and how it differs from return
&gt; You're introducing a whole new operator to the language and adding complexity to solve 1-2 specific usecases. Yeah, that's definitely a fair point! I don't think I made it clear, but overall I think this PEP probably was a poor choice. I was just trying to play devil's advocate for a minute haha. I do think it has some added benefit in that it means that in cases like these, there's now a single most-obvious way to do it. But I think the added benefit is outweighed by the complexity cost to the language as a whole, and probably many people will never use it anyway. &gt; I'm curious, would you be able to turn your socket or whatever you're consuming in the while loop into a generator and loop over that? That's actually a really great idea! I had never thought of that, but that makes a lot of sense. I'll have to keep that in mind going forward. Thanks!
Thanks for the tip. I will certainly look it up 
yeah not an issue bro glad you found the solution
`open` is the perfect example here. While it‚Äôs easy to mentally map `with open(‚Äòfile.txt‚Äô) as fp` to `fp = open(‚Äòfile.txt‚Äô)`, that isn‚Äôt actually what‚Äôs happening. As I‚Äôm sure you know, `open`‚Äôs return value isn‚Äôt what is assigned to `fp`. If you were to implement this PEP using `as`, though, would that change? Would there need to be an additional change to the grammar to capture the author‚Äôs intent? And the people who worked on this don‚Äôt want to make an exception to keep support out of `with` because that leads to a lot of confusion for people learning the language. &gt;Why does `if f() as var:` work but `with f() as var:` raises an `AttributeError`? To someone who knows the language, you know that you can‚Äôt use arbitrary callables as context managers and that you can‚Äôt use arbitrary context managers as callables. But to someone learning the language that would be really confusing. It would make Python a harder language to learn and a harder language to teach. Using a different syntax shows a different intent which makes the differences easier to comprehend. 
Has... if (do_call() as thing) is not None: print('Do something with thing') been proposed?
I'm no expert but I think I understand metaclasses. It allows you to make tools for other developers. They're how Django performs all its black magic. Metaclasses are just classes that define how classes behave. They're a hook in to class definition behavior. When Python encounters a class definition it calls the defined class's metaclass's \_\_new\_\_ and passes the definition as a namespace. This way, you can do all sorts of fun shenanigans! 
Yup, as someone in stated in another comment the `as` keyword was proposed and rejected.
To be fair, that‚Äôs probably more because time zones are just an intrinsically complicated topic even in principle, let alone a specific implementation in a language. 
There‚Äôs not really any advantage to Matlab over Python here though. Matlab doesn‚Äôt have any special package or functions that makes it better at this application, so you would just be paying more money for nothing and if you want to use it across the office you‚Äôd need to get a new license for every user. If anything, the larger user base means it‚Äôs more likely to be maintained and get support in Python.
The asyncio package up on PyPI works on 3.3, as a note. The problem here is as follows-- you are the library maintainer. You support, say, 3.4, because for various reasons you need to. But people will still want you to support 3.7. People will want you to put in features that exist in 3.5-7 that don't work in 3.4, like asynchronous iterators. Or dataclasses. Or type annotations. Or whatever. So when you implement these features, which you may when people bug you enough, you end up writing very awkward, smelly, unmaintainable code, just to be able to support these features. Because selectively supporting them by version doesn't work, because even if you check against Python versions you will get a SyntaxError. And then you have to deal with people PRing your code with new syntax and you get into 30 comment arguments because people are stubborn. Forward compatibility between minor versions is important-- that's why Py2 had it quite a bit. But forward compatibility with these features is nonexistent in Py3.
Do you have a link to the rejection of the `as` keyword? That was my preferred proposal too.
 heh, I was just going to write the same about packaging. I just wrote my first package, wanted to make it "proper". So far I am just confused, I guess it will live just on my hd for a while yet. 
Download the Mac version from python.org
&gt; I‚Äôve wanted this feature specifically for the case where I‚Äôm writing a while loop (usually) and I want a loop-internal variable to get a new value on each iteration. Without assignment expressions, there are a couple options but I dislike them all. Are you sire that's really needed? It sounds much like my own problem of using C idioms, rather than real Python. Can you show some code where the iterator itself isn't enough?
That‚Äôs what I did
&gt; There exists a separate opinion poll about the PEP in a more recent developed state and the results of this poll aren't included in the post I'm not aware of any other polls on python-dev or python-ideas. We only had one poll and Serhiy didn't misinterpret it.
Well the good news is that people won't even be using 3.7 for probably years, so we'll all forget about this for a long time. It will probably end up being an uncommon idiom.
The answer is yes it can. I find SWIG to be an incredible achievement in that it provides an easy interface to your C and C++ code (amongst other languages) to your scripting language. For your particular usage, there might be easier ways to achieve what you want by using something more specific to Python such as using something like cython or pypy or even *gasp* the python c api.
Lambda
Because python is publicly (under)funded, and doesn't have the manpower to make huge advancements without breaking backwards compatibility, like Oracle/Microsoft can with Java/C#.
It's not a matter of an N year delay, it's a matter of an N year delay with many new syntactical features being pushed out in between. Even with 5 years it's an issue. 2.7 to 3 didn't really add any new syntax. 2.1 to 2.7 added a bunch, and foward compatibility was always a feature, minimizing the wait. In regard to the 30 comment thing, you'd be surprised how stubborn brand new contributors are. Many times there is no concept of seniority, and they will fight to their hearts content to use their syntax instead of the complicated hack you want them to use, and suggest "just drop the non supporting version". The "library drops support when the Python version is EOL" is an unobtainable dream. Py2.6 EOLd in 2013, and even in 2016 pip supported it (going off github issues) and may support it even later than then and now. EOL doesn't mean it shouldn't be supported in terms of libraries, just that the development team will not fix any bugs that you may find after that. You can easily not care about the distribution maintainer's stupidity. But you have to care about the end user and their hardship.
Is it possible? Sure. Will it do it automatically? No. If you have critical functions that are slow in Python but would be fast in C/C++ then yes, you could put those in a compiled accelerator library and use SWIG to generate bindings and access that library, and that will speed up your Python code. But in order to do this, you need to understand (correctly, not just guessing) what parts of your code *are* the slow parts, and which parts of those slow parts will be accelerated by re-writing them in C, so you have to understand *why* they're slow in Python. Are they competing for the GIL? Are they creating circular references that need to be garbage collected, or performing too much reference counting and type checking? And then once you've identified the problem areas, you have to actually re-write them in C. SWIG does not do any of that for you. It's just a tool. It's possible to use a hammer to build a house, but that doesn't imply that you will be able to pick up the hammer and know how, or that it's going to be easy, or even that it's the right tool for the job. That all depends on a lot of different variables. Same with SWIG, it's a tool. Maybe it's an appropriate tool, maybe it's not.
Python is easy to use but its runtime speed is much slower than C++. Currently, I want to make the simulator a library so that it can be used for research purpose. There are many limitations for PyPy, it can't support all libraries, for example TensorFlow. As for cython, I have no idea about it.
Asserts are turned off with python -O
Unpopular Opinion time! I think Python could stand to have something like this as a complex self-troll. Hear me out. About 10 years ago I started trolling my future self. Like hiding terrible music in a huge playlist that I'd only ever find randomly a year from then. This can be a lot of fun, because when the troll occurs I'm like: Damn it. You got me, me. I think some of the examples we've seen here of assignments in list and dict comprehensions are an excellent opportunity for trolling in your code base. I get that people are worried about readability in the future, and that's fair, but it can also be fun to have to reverse engineer a particularly intractable comprehension. If you're really worried about future you so much, add a comment. But I say you should have some fun with your future self, you've been through a lot. 
That's a great video in entirety 
What‚Äôs the issue? When you open the command line and type `python` it...?
The main difference is that when you call a function that returns something, next time you call it, it will start from the top. Generators (methods that yield) will resume from the next line after yield. More formally yield makes a function to retain its state after the call. Please someone correct me if I'm wrong. 
And then you come back and it do it anyways, except drunk. 
Look into Cython. It's a way to take existing Python code and incrementally translate it into high-performance C code. It doesn't work for all scenarios, but for math-and-stats operations being performed in pure Python it's useful.
Thank you for your hints. The simulator was written by Java, and since Python is easy to use, I rewrote it with Python, but the speed is ten-times slower. That's why I want to use CPP and SWIG.
One great thing I heard was by Raymond Hettinger saying that lambda should be named "makefunction". Then everybody would understand what it does. It creates a function. Essentially any function can be written as a lambda. And lambda is an anonymous function. Meaning it's a normal function just without a name. And I think I really got it when I started using it as key in eg max function. If you have a list with objects anything but number, and you want the max of the objects based on a property you need to give python a method that quantifies each object. Hope this helps a bit. 
Like I said, I see it as a property of the with-statement. You're writing `with open() as fp:` and not `open as fp:`. The with is what's managing the context manager, and the lower-level specifics isn't really relevant. And if your example, `if open() as fp` wouldn't throw an error, it would do exactly what you expect it to do, it would be `fp = open(); if fp:` You can also imagine it as `with fp = open():` which imo would be fairly readable too. If `as` wasn't already a keyword for import statements, I'm sure they would've done that instead.
Is there a good example of this somewhere? 
Just a friendly reminder about something I think a lot of small businesses don't really plan for enough: any employee who is carrying out some process that couldn't be picked up immediately by somebody else should be carefully documenting what they're doing, and the time it takes them to do so should be factored in to their workload. There are plenty of other situations in which a staff member might be suddenly unavailable and the work would have to be picked up by somebody else.
Cheat sheets were great back in the day. But now I can look something up on google/stackoverflow in a fraction of the time it would take to look through 5 cheat sheets, especially when one of them is 26 pages long. I dont mean to offend, and i do think these would be handy as brush-up resources before i were to go into an interview, or take a python test. 
Well, in this scenario, he's the creator and support desk. Structural engineers aren't typically programmers, so if someone has issues they aren't even going to know to go to a python support forum. From an enterprise standpoint, an engineering company is most likely going to prefer enterprise software with support and thorough documentation. MATLAB is pretty much set up exactly for what he's doing- it has all the libraries, functions, etc thoroughly documented in a runtime environment that's already set up and good to go. He has the knowledge to do it on his own- which is great, but what happens if it's use becomes prominent in his firm, he leaves, and it breaks? They are now stuck relying on a broken piece of software with no support. Now, as I said, I'm not a structural engineer and this tool may not be super important. I don't know. I'm just thinking from a reliability and dependency standpoint, especially if these custom programs become more common, that a company would prefer them to be developed on a common platform they is well supported and easy to use.
BioPython?
I didn't say it was "needed"; just that I like it in this specific case. I did admit that I got it from C, but I still think it's an elegant solution to the problem. &gt; Can you show some code where the iterator itself isn't enough? I cannot. I admitted to the other person that I hadn't considered an iterator before, and that I thought that was a good solution to the problem. I'll probably use the iterator method going forward.
The tool you're looking for is Cython. This lets you convert a python module into a compiled python module. Then you selectively add C type-information to convert the performance-critical sections of your code into fast-running C. One killer feature of Cython is the "cython -a" command. This generates a html representation of your code with colouring to illustrate which bits are calling the python interpreter (slow) vs which bits are converting to pure C (fast).
This. It's just as fast to lookup the docs really.
Yes, I think it's more the convenient learning that attracts people to cheat sheets than the day-to-day struggle for Python syntax. 
Exactly why I decide to do this project in the first place. It is definitely a huge problem for small business - lack of cross training and people getting very comfortable with their roles. I have vowed to never let this happen again.
Only for testing on your own end. 
Maybe parsing is not the best approach for this. If the page is creating a js variable for you you can access it from python code using selenium. I set up a simple web page with this js: my_js_obj = {"thisprop": "the_value", "thatprop": 34}; Then I use selenium in python like this: from selenium import webdriver browser = webdriver.Firefox() browser.get('file:///D:/Dropbox/python/selenium_fun/test_page/index.html') the_obj = browser.execute_script("return my_js_obj") print(the_obj['thatprop']) print(the_obj['thisprop']) In the python code I am able to access the properties that are set on the JS object.
You deleted the built-in version of Python? I don't know how you managed it but it's part of the OS... I think the best way to do it is to restore the OS
Thus the "(useful)"! The other user seemed to be inquiring as to any benefits in, for example, code performance.
That person sounds very intelligent. You can hear it in his voice.
I have yet to see a talk by Raymond Hettinger that is not interesting :)
When it's just library features, you have to hope for someone to have released a backport and use that as a fallback if the standard import fails. For language features you can only hope they added a `__future__` import
An ABC or a mixin would need to analyze the class structure each time they're called. This is generated when the module the class is in is imported. PHP doesn't even have keyword arguments. You're not making sense.
arg1 = a1, arg2=a3 arg2= a2, so arg2 is assigned twice in the end arg2 will be equal to a2. I should probably create an error when this happen. The basic idea come from python functions arguments.
Yeah check [this](https://docs.djangoproject.com/en/2.0/topics/db/models/) out. It's pretty easy to wrap your head around.
I'd sign a petition to avoid PEP 572 right away.
Some devs seem to be very intent on killing python.
Typically all the pieces are there, but it takes piecing different libraries together. I have recently started a blog showing how to use some of the different libraries that apply to water resources. It's called [KnickKnackCivil](http://www.KnickKnackCivil.com). It's just getting off the ground, but an upcoming post is going to involve an overview of some of the libriaries I use. Some of the more popular libraries I use are shapely, gdal, pyswmm, lxml, pyshp and a host of other small libraries. If I am using Python, I rarely have to reach for the ESRI stack for spatial analysis.
Read this StackOverflow answer as well as its four comments: https://stackoverflow.com/questions/1779372/python-metaclasses-vs-class-decorators
I would go with the foreign key version of your example. Just a few additional thoughts and not picks on this. 1. think about changing your model name from ‚ÄòPartners‚Äô to ‚ÄòPartner‚Äô. Your model class is a representation of a single instance of the model. 2. Be careful with on_delete cascade. In your version deleting a partner would only delete the profile connected to the users but not the users themselves. 3. The related name you set on the foreign key from Profile to Partners is odd as it represents how you access the Profiles connected to a partner. E.g all_user_profiles_of_a_partner = Partners.objects.first().partner
Great thanks. Makes more sense now. 
You poor soul. What makes you think this?
You can maybe incorporate your code into two modules (e.g. helper\_functions37 and helper\_functions36). Then you check the version and import the right one as helper\_functions. But now you're maintaining two helper\_functions. Whether this is feasible depends on how much code needs to be in here/how often you expect to update the code. 
So you're going to port everything - not just ML but all of data science too - and have it all run slower because java vs c? Right.
You are allowed to say no when someone asks for a new feature or sends you a PR. How do you even get into an argument. Just close the issue and move on.
In Python everything is an object. `21`, an object. `"hello world"`, an object. `datetime(2000, 4, 25)`, an object. If you inspect these with type, you'll find out their class: type(21) # int type("hello world") # string type(datetime(2000, 4, 25) # datetime We can control how these are instantiated by modifying their class. classes are also objects. class Frob: pass Their type is type: `type(Frob) # type` We can control how classes are made, we modify *their* class, which is type. For example: class Tell(type): def __init__(mcls, name, bases, attrs): print(f"Making type {name}") super().__init__(name, bases, attrs) This is a metaclass that will print out the name of the class that's being made. By itself it's not very useful, but we can apply it to a class by using the metaclass hook: class Frob(metaclass=Tell): pass # making type Frob There are more interesting things to do with metaclasses, but some of them are only possible by overriding `__new__`, a lesser used lifecycle hook in Python. This hook is used by tools like marshmallow, sqlalchemy and others to control how the class itself is produced. You would use this if you were building a library marshmallow where schemas are defined like: class SomeSchema: bar = fields.String() foo = fields.Integer() but they're not available on the class itself after it's made: `SomeSchema.bar # AttributeError ...`. You can only accomplish this in `__new__` by doing something like: class ExampleType(type): @staticmethod def __new__(mcls, name, bases, attrs): special_fields = {name: value for name, value in attrs.items() if isinstance(value, OurAttr)} attrs = {name: value for name, value in attrs.items() if name not in special_fields} attrs['_special_fields'] = special_fields return super().__new__(mcls, name, bases, attrs) It's worth explaining each of the parameters is as well: * `mcls` \-- this is the metaclass, this is similar to passing `cls` as the first argument to classmethods. * name -- this is the name of the class itself. In a definition like `class Frob` this will be set to Frob. * bases -- this is the collection of classes that the new class will inherit from, in the definition `class Frob(A, B)` this will be `(A, B)`. * attrs -- this is everything assigned to a name inside the class block, methods, attributes, etc. There are other interesting places to hook into a metaclass as well: * `__new__` \-- override this if you need to control things like the MRO, attributes, the name of the class. * `__init__` \-- override this if you want to control the instantiation of the class, but don't need to alter its characteristics. * `__call__` \-- override this if you want to control how objects created by the class are instantiated. * `__prepare__` \-- this is an interesting one, by default it returns an empty dictionary, but you can use it to return *ANY* class that implements` collections.abc.MutableMappin`g. This becomes the namespace that the class body is exec'd into. The last two deserve examples of their own. Creating an object from a class has a call path that looks like this: `type.__call__ -&gt; obj.__new__ -&gt; obj.__init__` we can see if we do the following: class Trace(type): def __call__(self, *a, **k): print(f"Creating instance of self.__name__") return super().__call__(*a, **k) class Traced(metaclass=Trace): def __new__(cls, *a, **k): print(f"newing up {cls.__name__}") return super().__new__(cls, *a, **k) def __init__(self, *a, **k): print(f"initing {self.__class__.__name__}") You'll see creating instance, then newing then initing. You can use this to create singletons without doing anything weird in the class itself: ``` class SingletonMeta(type): instances = {} def __call__(self, *a, **k): return self.instances.setdefault(self.__name__, super().__call__(*a, **k)) class ASingleton(metaclass=SingletonMeta): pass a = ASingleton() b = ASingleton() assert a is b ``` With `__prepare__` we can do things like preload the namespace to hold some values: from abc import ABCMeta, abstractmethod class MyABC(ABCMeta): @classmethod def __prepare__(mcls, name, bases, **kwargs): return {'abstract': abstractmethod} class AbstractClass(metaclass=MyABC): @abstract def some_method(self): pass
You can look into Essentia, http://essentia.upf.edu/documentation/, they provide a Python API, also look at Librosa, https://librosa.github.io/.
An automated player for Princess Punt. For a bit of background info, it's a game slightly like Angry Birds, except it has the annoying part of requiring a lot of play to advance, which spoils the fun. Therefore, I wrote a Python script to play a level over and over to accumulate the points needed to advance.
Hm. To be honest in that case I think that the behavior you've specified you want is sort of broken in terms of semantics for a command line parser....its not what I would ever want. However, if you want your args to work this way it's pretty easy to do with argparse in like 3 lines of code tbh.
i create a software that send messages to prostitutes and say " "insert my name" is near your area", very hard to make, very satisfying.
Slightly broken? For dataclasses, it's because that would cause Python to raise a NameError. The point of dataclasses, or at least what led to their implementation in this manner, was that Python 3.6 added variable annotations -- aka the `var: type` syntax, which allows a variable to "mentioned" without ever being assigned a value. Simply writing `var` without the type annotation makes Python think you're trying to use the variable's value as an expression, however, so if the variable has no value (not yet assigned to) it can do nothing but raise a NameError. In addition, var annotations declared at the top level of a class can easily be viewed using the dict `class.__annotations__`. That's why dataclasses require those type hints; to add the behavior you mention, where no annotation would cause `typing.Any` to be assumed, would require making an unprecedented and likely-unjustifiable change to Python and the way it handles yet-undefined variables. Dataclasses' implementors did not want and never did intend to do this. What is disappointing however is that (a) the PEP for them doesn't explain that this is the reason for it, leaving people unaware like you in the dark, and (b) that this is clear abuse of the var-annotation syntax (in that it is not at all what said syntax was added for) so it's the sort of hacky-but-kinda-neat thing you'd expect from a third-party package -- NOT from something in the Python standard library, which as a base assumption I think should be reasonably expected to avoid misusing and/or complecting a feature of its own language.
I don't know why they didn't use closure syntax and allow inline multi-line lambas like other languages allow anonymous functions (C++, Java). Adding language constructs "conditional expressions" (those backwards if statements) and the like to make things one line seems excessive. 
It isn't in 3.7 btw
Are you sure it would violate LL(1)? My lack of experience may be showing, but could you explain how? The parser can already tell you why the former of these is invalid: func(i for i in iterable, None) func((i for i in iterable), None)
Python is a common platform thats well supported and easy to use. half of the web runs on it ffs. Matlab is bloody expensive, and offers no major benefit, if you wrote it as matlab scripts the what if he left has exactly the same impact, as Matlab arent going to give you support for his code, only their environment. Probably a lot easier to find a programmer who can debug python than a matlab program.
To add to this answer; I would first start out by writing everything with numpy. Then if that is still too slow, start with cython. I only recently started looking into cython due to large simulations that I am running requiring ridiculous runtimes. Cython helped by reducing runtimes by 40 percent. 
All fair points, I kind of chose python to learn because it was also pretty easy to read and get the jist of what's going on. I work at a smallish firm so the IT budget is pretty tight.
Oh come on. You know you love it when your coworkers scream in pain at the beautiful, 79 character line that replaced a package bug-for-bug and now they have to modify it! And you especially love it when you curse yourself for writing it! (Obviously, this is sarcasm. But I will grant that I do get a cheap thrill out of the experience‚Äîuntil I have to get back to work and curse myself.)
Copy/pasting from my response elsewhere: &gt; For dataclasses, it's because that would cause Python to raise a NameError. The point of dataclasses, or at least what led to their implementation in this manner, was that Python 3.6 added variable annotations -- aka the `var: type` syntax, which allows a variable to "mentioned" without ever being assigned a value. Simply writing `var` without the type annotation makes Python think you're trying to use the variable's value as an expression, however, so if the variable has no value (not yet assigned to) it can do nothing but raise a NameError. In addition, var annotations declared at the top level of a class can easily be viewed using the dict `class.__annotations__`. That's why dataclasses require those type hints; to add the behavior you mention, where no annotation would cause `typing.Any` to be assumed, would require making an unprecedented and likely-unjustifiable change to Python and the way it handles yet-undefined variables. Dataclasses' implementors did not want and never did intend to do this. &gt; What is disappointing however is that (a) the PEP for them doesn't explain that this is the reason for it, leaving people unaware like you in the dark, and (b) that this is clear abuse of the var-annotation syntax (in that it is not at all what said syntax was added for) so it's a sort-of-hacky-but-kinda-neat thing you'd expect from a popular third-party package -- NOT from something in the Python standard library, which as a base assumption I think should be reasonably expected to avoid misusing and/or complecting a feature of its own language. cc /u/bakery2k
Rarely used?! Given the numberous examples, I suspect this will be heavily used.
The interpreter tries to function the same with respect to the code you write. Largely it does aside from some threading differences etc. However it has to be compiled differently and the system packages it relies on will be different. Same for any packages you use. Because of this the interpreter can't be packaged in a way to be platform independent.
Whenever he says "Have you learned something new?", I whisper "Yes Mr. Python man in a YouTube window". 
When I try to play around dataframes (add columns change cells etc) and python yells at me. Then I open R...
PEP572
&gt; The "library drops support when the Python version is EOL" is an unobtainable dream. I'm more optimistic. This actually is a relatively common strategy for 3rd party libraries already. Another common strategy is for 3rd party libraries to drop support for a given Python version once usage of it is "low enough". (That's basically the exact rationale pip used to drop support for [Python 2.6][0] and [Python 3.3][1] in time for Pip 10 earlier this year, for example. (This interestingly caused a ripple effect on a large portion of the Python ecosystem -- see all the linked issues at the bottom of both issues.)) I think with proper maneuvering, those two strategies will look identical maybe in 3-4 years. Specifically, there's currently still a lot of lag between the "wait until usage is low enough" and "wait until the Python version is EOL'd" -- I suspect that's mostly because of Python 2.7. After all, if you need to support 2.7, it's usually not that hard to also support 2.6 and 3.3. However, once libraries finally drop support for 2.7 (which many are [planning to do in 2020][2]) and only need to worry about Python 3 users, they can start expecting that their users are able to upgrade much more easily then before. In particular, the Python core devs learned from the 2 -&gt; 3 switch and are now working under a mandate to make upgrading from an older version of Python 3 as painless as possible. (For example, new complex additions to the stdlib are added under a provisional basis to give the devs latitude to make breaking changes as necessary, features that are to be removed are deprecated and retained for at least one major cycle...) If data shows that users are actually start making use of this new implicit feature and start upgrading much more frequently (which I think they will), libraries will be able to start shrinking that gap to the point where eventually the "drop support when usage is low" and "drop support when the version is EOL'd" strategies end up looking identical. &gt; In regard to the 30 comment thing, you'd be surprised how stubborn brand new contributors are. Many times there is no concept of seniority, and they will fight to their hearts content to use their syntax instead of the complicated hack you want them to use, and suggest "just drop the non supporting version". Sorry, I still disagree. Let the user know what the policy is and if they insist on breaking it, leave a note saying "sorry, this is not up for debate.", close the issue or PR, and ignore any follow-up comments if they try and continue to argue. After all, if you refuse to even engage, there really isn't anything the user can do no matter how stubborn they are. It's not like they can force you to accept their PR or to reply or anything. If the issue devolves into a long argument, I think that's really the maintainer's fault for not knowing how to draw a firm line/not understanding that disengaging is a viable strategy. &gt; You can easily not care about the distribution maintainer's stupidity. But you have to care about the end user and their hardship. I think the Python project really has done all that it can to avoid adding unnecessary hardship. Asking users to jump from 2 to 3 is painful and could have been executed better, but the devs *have* learned from that experience. New changes to the language almost never break existing Python 3 code and changes are now made in a way that ensures upgrading is relatively painless. If distributions or libraries want to invest energy in support users beyond that, well, I respect their decision. The only thing I dislike is projects (libraries, companies, distributions, whatever) that decide to use EOL'd versions of Python and expect other people to do the grunt work for them for free. -- So, tl;dr: 1. I believe the "drop support for EOL'd versions of Python" strategy is already viable for some projects and seems likely to become increasingly more viable the further we move past the Python 2.7 drop date. 2. New contributors can't actually force you to do anything -- just don't engage if they're trying to debate a point that's not up for debate. 3. Avoiding user hardship is of course important, but you can't realistically expect a team of volunteers to maintain support for old version indefinitely. If an organization decides to continue using old software, at some point it becomes their responsibility to deal with problems. [0]: https://github.com/pypa/pip/issues/3955 [1]: https://github.com/pypa/pip/issues/3796 [2]: https://python3statement.org/ 
Whether I should create a requirements.txt file and commit it to SCM, or should I only commit setup.py. 
As a civil engineer, I think the Enterprise aspect is overblown. He is offering a free tool that others can use if they like, or make changes if they like. He is not obligated to be the support person. A company can weigh the cost of paying to add features or fix a bug or have an internal person do it... Or pick the proprietary option. If you build your library on other open source libraries, it has a host of benefits. It gives you the ability to not only use it for free, but to make changes and additions. It gives you flexibility to modify the original channel of delivery (desktop or web app). You have total control as a random user to improve the product. With so many proprietary tools (which I have nothing against) the limitations are arbitrary. It's why when I do spatial analysis with Python, I never reach for ESRI products. Many of the advanced tools that require a special license in ArcGIS, can be done with open source libraries fairly easily. And these open source geospatial libraries have proven to be rock solid for users.
"There must be a better way!"
`yield` is a shortcut to writing an iterator class. Let's implement something that will continually output a sequence a numbers starting at 0 and continuing into infinity. Without `yield`, we'd need to implement a class: ``` class Count: def __init__(self): self._current = 0 def __iter__(self): return self def __next__(self): current = self._current self._current += 1 return current counter = Count() print(next(counter)) # 0 print(next(counter)) # 1 ... ``` But that's a lot of boilerplate including a method that only returns the current instance of the class, which is confusing to some people. We can't do this with a regular function because after a function returns, all of its state is disposed of: ``` def count(): current = 0 return current # nothing after this is run ``` we could use a global, but then we wouldn't be able to have separate counters just a single global counter: ``` _current_count = 0 def count(): global _current_count current = _current_count _current_count += 1 return current ``` Additionally, since this isn't an iterator, we can't use it in for loops, listcomps, etc. If we don't want to write a class and we don't want to use a messy global, we can write a generator: ``` def count(): current = 0 while True: yield current current += 1 ``` When we call count, we don't immediately see anything happen but we do get a handle on a generator object. From there we can call `next` with it and start receiving values: ``` counter = count() print(counter) # generator object blah blah print(next(counter)) # 0 print(next(counter)) # 1 print(next(counter)) # 2 print(next(counter)) # 3 ... ``` We can create another and it has its own independent state: ``` counter2 = count() print(next(counter2)) # 0 print(next(counter)) # 4 ``` yield acts like the pause button on the function, when it's hit a value pops out and is given to the caller. return on the other hand is like a stop button, when its hit the state of the function is disposed and whatever is the right of the return is given to the caller. Generators get more complicated than that and I'm happy to go into it, but those are the basics for using yield.
fortunately there is no need to use a linked list in python (built-in list) or modern C++ (usually vector is plain faster) so why your school is teaching C things in python is a bit wtf :-)
You shouldn't but if you need to, it'd probably look something like: ``` class LinkedList: def __init__(self, value, next=None): self.value = value self.next = next def append(self, value): self.next = LinkedList(value) def __iter__(self): return self def __next__(self): return self.next ``` There's use cases for linked lists but you're usually better served by using an array or a tree.
Basic CRUD web app - flask, sqlalchemy, mysql - can be any few objects that relate to each other. You'll probably want at least one One-to-Many and one Many-to-Many relationship to facilitate learning how to implement them. Some examples: Restaurant with Menus that have MenuItems you'd have something like a Restaurant can have many Menus, but your Menus can only have one Restaurant. Your Menus can have many MenuItems, and your MenuItems can be on many Menus. League with Teams the have Players Teams with Players that have Skills Teams can have many Players; Players can only have one Team Players can have many Skills; Many Players can have the same Skills It was my first time working with DBs, so that was probably the biggest challenge, even though flask+sqlalchemy makes it relatively easy. Its neat seeing your python models be created in a database and written properly as needed.
Yeah, and then they keep making new issues / PRS until you ban / block them, and then get called a nazi for doing so and have a smear compain against you for doing so.
The idea seems a little strange to me. I'm sure my first python project was Hello World, but I'm sure you don't mean that. The complexity of my projects slowly increased from there, but I'm not sure which level of complexity would meet your definition for "first project".
First? Oi. Probably a 30 line thing to replace an equal amount of Perl, parsing some log file and extracting some term and counting. Aka, a hello world of Perl.
I say this all the time lately, it's nice to have my opinion validated by somebody dignified like this.
ClusterShell contains an implementation of a pattern derivation, with the same structure. See https://clustershell.readthedocs.io/en/latest/tools/nodeset.html - especially the Fold option. This is written in python; read the source. 
this isnt a python problem
&gt; The whole deal around packaging, importing modules, sys.path, and whether I need or don't need `__init__.py`. I know Python 2 required it and it's optional in Python 3. What `__init__.py` does is mark the current folder as a Python module. It's not really optional in Python 3, but its absence means something else. If you have a directory structure like: ``` /foo __init__.py /bar __init__.py something.py ``` Python will treat both foo and bar as modules, foo will be importable as `foo` and bar as `foo.bar`. Of course this all depends on `foo` being on your sys.path. There's a few ways that can happen: 1. Your working directory contains foo. Python will attach your working directory to `sys.path`. 2. foo is located in your interpreter's `site-packages` directory. 3. foo is otherwise added to your `sys.path` -- e.g. `sys.path.append('/path/to/foo')` There are other ways, but these are the three main ways. For the absence of the file, given this directory structure: ``` /foo __init__.py /bar something.py ``` `foo.bar` is a "namespace package". The full semantics are little confusing, but the short of it is when you run `from foo import bar` Python searches `sys.path` looking for names that match bar. If it encounters a bar that has an `__init__.py` in it, that's the one that'll be imported. Otherwise, it'll gather up all the bar directories and stitch them into a single package. There's all sorts of cool things that you can do with this like create plugin mechanisms, extensible packages, etc. It's neat, but it only takes one person who doesn't know to fight against every instinct to put an `__init__.py` in the directory to break it.
I'd be much more inclined to use python if dealing with dependencies/versions/libraries wasn't such a terrible mess (at least it looks like that to someone just learning the ropes). So I'm going to have to say it's 'dependency management' (though there's a lot of other things I'm sure I also still don't get... a good understanding of 'the proper way' to do dependency management is the one thing that really hampers me from picking up python and writing non-trivial working code).
I have a basic implementation of an exponential moving average algorithm written in C++ that I could share with you if you want. I‚Äôve only recently gotten into trading algorithms so it‚Äôs all still pretty fresh in my mind if you need any pointers getting started if you choose to make one.
&gt; After reinstalling it, it looks very different and the folders aren‚Äôt the same. What does that mean? I can't figure out what your problem is from this explanation.
It is in the sense that the lack of forward compatibility is the cause. They kept forward compatibility in 2. But for whatever damned reason, threw it away in 3. This constantly leads to ugly code for the sake of support and shitty debates.
&gt; The second thing is dealing with requirements, virtualenvs, packaging, and publishing to PyPI, I get how to do it, but what I don't get is why it's still so cumbersome after so many years. yeah, packaging sucks. To be fair, I've never met a packaging solution that I did like in any language. Some languages have better solutions or hide the nitty-gritty better, but overall packaging is always sucks for me. &gt; Why are there so many different files and tools? setup.py, requirements.txt, setup.cfg, MANIFEST.in, pyproject.toml, Pipfile, setuptools, virtualenv, and probably more. Only some of these are actually related to packaging your code into something that's deployed to pypi. Pipfile, virtualenvs and requirements.txt aren't related to that (though they could be used in conjunction with it). The others all serve different purposes: * setup.py -- this defines things like names, dependencies, authors, versions, etc. * setuptools -- this is the de facto standard for handling packaging and publishing, there are competitors like poetry. * setup.cfg -- this is used to configure some things about packaging. The only really useful thing to set in here `universal` which defines if a package is both pure python AND compatible between 2 and 3. Honestly I hope this is deprecated and removed in favor of pyproject.toml. You *can* use this to configure other tools like pytest, mypy, flake8 but I'd recommend against it as this is a non-standard usage and could break. * pyproject.toml -- this defines what is needed to actually run the install for your package. This enables using tools like poetry to handle installs rather than setuptools. Previous to this, there's an entry for `setuptools.setup` called `setup_requires` but you can't use it because you'd need to have those things installed in order to install the package that requires those things to install it....wutface.png. If you're using setuptools to package your project, you don't need this right now. It will probably become more important in the future. * MANIFEST.in -- ah, this file is infamous. This is used to include non-Python files into a Python package. If you package up a webapp, you'd use this to include HTML templates, CSS, javascript, etc. But even without it, if you want to do something like use your README file to populate `long_descript` you should list your README in this file so source installations still work.
[somewhat relevant Tom Scott video](https://youtu.be/QCwpVtqcqNE)
Adding an operator for the purpose of adding syntactic sugar is starting down a slippery slope. How many other operators should be added to make the code more readable? At some point if by adding enough of these operators that exist simply to make the code more readable, it accomplishes the opposite. It violates the Zen of Python: https://www.python.org/dev/peps/pep-0020/ &gt; There should be one-- and preferably only one --obvious way to do it. 
I group python developers into three groups depending upon their approach to metaclasses: 1. Beginner. Doesn't know what metaclasses are. 2. Intermediate. Has learned what metaclasses are, tried to use them in an attempt to become "less junior" and made an almighty mess. 3. Expert. Knows *when* to use metaclasses but doesn't. In about a decade of coding python I can think of exactly one time when I've thought "you know, I wish they'd actually used metaclasses instead" and about 50 times when I wish they hadn't.
Even reading through the blog post advertising [`maya`](https://www.kennethreitz.org/essays/introducing-maya-datetimes-for-humans) reminds me of a point /u/zzgzzpop made in this thread: "The fact that there's AT LEAST THREE [tools] is a red flag that indicates the normal way to do it isn't convenient and could definitely use improvement."
Yes, this is what SWIG's purpose is. You can write a library in C++ and just expose bindings in Python for easier usage. e.g. TensorFlow and lldb are both written entirely in C++ but both contain SWIG wrappers that let you control them. 
Yeah, I'm astounded by the number of core devs these days! Must be all the machine learning people arriving in the last few years. 
I never understood the "for humans" thing. Is it more common to write libraries not for humans?
Assembly scanner to diagnose a problem with the optimizations done by clang &amp; llvm for a particular set of optimizations. 
I just use the xmlrpc in the standard library
Arrow has saved me from the many pitfalls of datetime: http://arrow.readthedocs.io/en/latest/ It‚Äôs the API I wish datetime was!
Right, that's the exact rationale for pip. But they started the process *three years after EOL of 2.6*, not immediately at EOL, and a little less than a year after 3.3. But the change from 3.3 to 3.4 was minor, whereas the change from 2.6/7 to 3 was major, you can't compare them directly and throw up your hands. The other common strategy is exactly what I mean! But because "low enough" is not only subjective, but also majorly at the hands of OS distributors, which still force people into 3.4. And they are making the process as painless as possible-- for a lot of people. But not for library maintainers because of the exact lag that you are referencing. Re: debate-- easier said than done in today's world. You ostracize a new contributor, maybe ban/block them. And then they make a smear campaign against you. There have been multiple scandals on github of that nature that have occured over *less*.
These two files only look like they're related, but they're really not. setup.py is for packaging and installing packages, it has an entry for `install_requires` but these are "abstract dependencies" -- e.g. your package depends on requests so you list that there. You shouldn't say your package depends on requests 2.11.1 there because then if your users have 2.11.2 installed, pip will be unhappy. You can say your package depends on AT LEAST 2.11.1 by declaring the dependency as `requests&gt;=2.11.1`, or you can say it depends on any version of requests from 2.11 and up to but excluding 3.0 with `requests&gt;=2.11,&lt;3`. You can also say you want any version of requests from 2.11, up to but excluding 3.0 but also not 2.25 (maybe it has a bug in it) with `requests&gt;=2.11,&lt;3,!=2.25` requirements.txt is used for development purposes or things that aren't really meant to be installed through `setup.py`. With requirements.txt can be used to pin dependencies but I'd still recommend just using ranges with &gt;, &gt;=, &lt;, and &lt;=. I often have several requirement files in my projects: 1. requirements.txt that declares the dependencies when developing, usually this mirrors whats in setup.py and includes tools like tox. 2. `requirements-test.txt` that declares things that tox should install in order to run tests 3. `requirements-docs.txt` that declares things sphinx needs to generate my documentation, this is mostly for use with readthedocs 4. `requirements-cov.txt` if I'm using travis and coveralls together so I can install a consistent version of coverage to publish coverage results 5. `requirements-travis.txt` if I'm using travis, usually this just installs tox-travis and whatever is in requirements-cov.
I hope you aren't wrong because this really makes sense
The datetime classes actually follow pep8. The reason they're lowercase is because their canonical implementations are in C.
To add further: Profile, profile, profile! Find out where the actual performance bottlenecks are in your code, and optimize those as best you can. I'm often shocked at how the slowest things in my code are nowhere near where I thought they were.
But this would still be better addressed by while as and if as, which were rejected
Or the snippet could be written more sanely in the first place: reductor = dispatch_table.get(cls) if reductor: rv = reductor(x) elif hasattr(x, "__reduce_ex__"): rv = x.__reduce_ex__(4) elif hasattr(x, "__reduce__"): rv = x.__reduce__() else: raise Error("un(shallow)copyable object of type %s" % cls) 
Yep, I certainly don‚Äôt disagree with you!
Aside from the near-irresistible /r/TOTALLYNOTROBOTS plug I'm making, I think Reitz is criticizing the fact that certain python libraries are not as intuitive for programmers to grasp as (he thinks) they should be.
How "complex" is too complex for you? Operator precedence is a "complex procedure". Should it go away and require explicit grouping instead?
str on a container uses the item's repr. A downside to doing it the way you propose is that you can't distinguish `1` and `'1'`.
Everything you need to learn you can find online for free. Infact ability to find what you need online is the most valuable skill you can have as an engineer. 
What are the numerous examples? The only 3 are: 1. Getting data in a while loop (which just saves you one line of code) 2. Assigning a value in an if statement (again saves you one line of code) 3. doing f(x) in both left and right side of a comprehension (might as well loop over `map(f, xs)`, much cleaner) The cost of complexity you're adding is far greater than what you're saving in those specific edge cases.
But you can easily get all variables from a class and add an object to the dataclass module being `dataclass.no_default` and `dataclass.no_data`. Ex, instead of the current syntax, @dataclass class Insect: weight = dataclass.no_default crazy: dataclass.no_data = "yes" group: str = "animal" num_spots: int It is *extremely* simple to implement it this way, and it completely removes the necessity of type annotations, with barely any performance hit. Functionally it has just two changes: 1. `dataclass.no_default` acts like the fact that num_spots has no default, except no typing information is required to be added 2. All class variables are by default data variables, instead of just ones with type annotations, with the type annotation of `dataclass.no_data` it designates it as a class variable that isn't a data variable. These minor changes completely negate the necessity of type hints and the hack around them, causing them to yet again be optional and give optional info, instead of mandatory info.
&gt; Essentially any function can be written as a lambda I'm not sure if this is actually true, is it? More like, any function that can be conveyed as a single statement. However, the inverse is true: Any lambda function could be written in a block function definition. A function definition can be arbitrarily complex and use iteration repeatedly. A lambda cannot really do this. People may argue that you should try to avoid making such big functions, but it isn't uncommon for the complexity of some function to exceed the capabilities of a lambda. `makefunction()` is kind of a nice mix between logical and practical, but if you were to be totally explicit, it's almost more like `function_from_expression()`. Usually, you do see lambdas used as parameters for other callable objects (like `sort()`, for example) specifically for situations where the programmer consuming the library in their application needs the ability to inject their own piece of logic into a designated spot within the chunk of code that they are calling into. In such cases, it's relevant to note that you can use named functions for this purpose just as well any time the logic needed exceeds the complexity you can achieve with a single expression.
[removed]
enumerate
What about it? You don't like it, understand it or you can't get used to it? 
I really hope Guido doesn't start going all George Lucas on Python.
Huh, that makes sense I guess. But having both a `datetime` module and a `datetime` class is rather subpar, especially since the module contains more than just that class.
Errrr LL(1)? The parser doesn't have to do some lookahead here-- just scanning for the first ending parenthesis and grouping the inner piece. In somethings such as with (a as b) as c: ... with (d as e): ... At least three issues arise just at the top of my head. 1. In the first is it is confusing to understand as a human which "as" causes `__enter__` to be called and which variable contain the result of that call and which contain the context manager parent object. Whether you yourself are confused or not doesn't matter, it is a reasonable concern. 2. In the first, you have to do forward lookaheads to determine which "as" is the call to enter and putting the result into the variable, because parenthesis in Python are used in two cases and two cases only-- method calls and logical/syntactical grouping. Since this is syntactical grouping, this grouping can have more than one meaning in the larger expression, which is difficult to parse and determine. 3. In the second, as mentioned parentheses are grouping tools. So, make the decision, right here and now-- does that group and cause variable duplication via `DUP_TOP`, or does it cause the return of the enter statement be sent to e via `DUP_TOP`. As in, which has precedence here? The with keyword or the as keyword, and why should the as keyword with parentheses have action precedence rather than the with keyword, because the with keyword already has implied precedence for everything after that. It is confusing from a dev position, from a parsing position, and a "choose the behavior to implement" position. This issue luckily doesn't occur on import statements because they already act like such in import statements. Using a different syntax, whether it be `:=`, `-&gt;`, `&lt;-&gt;`, `dup` or `¬Ø\\\_(„ÉÑ)_/¬Ø`, rather than the already used keyword `as` solves these issues partially. Using an operator instead of a keyword solves these issues completely.
r/learnpython
https://imgur.com/a/u4gb8Sq
Actually yes, some libraries or tools are made without general audiences in mind and so can require a bit of background to use effectively. The ‚Äúfor humans‚Äù tag means that he believes that his work can be easily understood and used without niche knowledge.
They are not equivalent. Pyro is fantastic when both sides are under your control and using python. gRPC, etc may be more appropriate if you want to document the format for interoperability between independent implementations that may be in completely different languages. 
It seems that the preinstalled version on Mac os isn't the same of the python.org version. But i don't remember too much.
I can see that. I think it's a better setup than C#'s just import system and here's all this other gunk as well solution. What rubs me the wrong way is that there's time.time and datetime.time that both serve different purposes but can easily be confused. Worse, datetime.time has a timezone component but that doesn't make any sense at all because timezones are both date AND time dependent. Comparing 2pm US/Eastern and 2pm UTC doesn't mean anything if you don't know what day it is as well. I feel like I'm missing something in the design process, but it doesn't make real sense no matter what angle I look at it from. I'm usually a pretty staunch defender of datetime since it's builtin and not completely terrible but there's some real boneheaded stuff in there. 
One developer on Hacker News declared that he was actually [creating a Flake8 plugin to outlaw assignment expressions](https://news.ycombinator.com/reply?id=17451814&amp;goto=item%3Fid%3D17448439%2317451814).
k- so... how exactly did you manage to delete the os installed version of python? Tell me what the exact steps involved here... If you did indeed delete it, you're going to need to reinstall the OS. 
Re: discontent. One developer on Hacker News declared that he was actually [creating a Flake8 plugin to outlaw assignment expressions](https://news.ycombinator.com/reply?id=17451814&amp;goto=item%3Fid%3D17448439%2317451814).
How do they break backwards compatibility? 
I agree with that sentiment exactly, but with a small note: if forward compatibility existed like it did when features were being added from Py2.1-2.7, in the form of future statements, I doubt that there would be as much friction with the fast additions of new features. But for some reason that thought process was by and large thrown out the window in Py3.
Using the as keywordz while easier to look at and cleaner, would be more difficult to parse and to understand because of / in with statement expressions.
I don't have a link to the rejection, but here is a great explanation of what motivated them to reject it (see response by /u/BlckKnght): https://www.reddit.com/r/Python/comments/8stu3u/pep_572_and_decisionmaking_in_python/e12x40p/?context=1 In short, the existing `as` keyword is assigned to the value of `expr.__enter__()` in `with expr as a:`, not to `expr` itself (as with this proposal). Apparently two different behaviors for the same keyword could get confusing.
Is a library somehow not for humans if its niche?
I would really recommend not giving them any money. More info here: https://www.reddit.com/r/Python/comments/8sl76u/sentdex_on_udemys_awful_business_practices
Why on earth make breaking changes for something so trivial, over 20 years in? I just don‚Äôt get it at all. I‚Äôm sure I‚Äôll be pilloried for it, but I still don‚Äôt see anything insurmountably wrong with 2.7. 
https://xkcd.com/323/
You're being ridiculous, at this point. Dataclasses are succinct, standardized, easy to read and don't force you to write ad-hoc parsers that will eventually break in unexpected ways when someone writes a docstring in a slightly different way. 
You're being ridiculous, at this point. Dataclasses are succinct, standardized, easy to read and don't force you to write ad-hoc parsers that will eventually break in unexpected ways when someone writes a docstring in a slightly different way. 
&gt; But they started the process three years after EOL of 2.6, not immediately at EOL, and a little less than a year after 3.3. Yes, so my point here is that the situation is improving. A 3 or 1 year extension is certainly better then the 5+ year extension Python 2.7 is getting. &gt; And they are making the process as painless as possible-- for a lot of people. But not for library maintainers because of the exact lag that you are referencing. I am really not sure why this is the case. Just don't use features that aren't supported on the range of versions you want to use. Most of the non-backportable changes made to Python are cosmetic, so this is pretty easy to do - the only exception that I'm aware of is async/await. In any case, my point is that making the process painless for users will indirectly make life easier for library developers. It's of course not an immediate process, but that's to be expected. &gt; easier said than done in today's world. You ostracize a new contributor, maybe ban/block them. And then they make a smear campaign against you. Who said anything about ostracizing? There are plenty of mechanisms and techniques you can use to effectively say "no" without having the discussion blow up. For example, you could first start by setting up your CI tool to automatically run the tests for the Python versions you want to support on all pull requests. If you're running an open source project on Github, you can do this for free using Travis or something, for example. This helps keep things professional: you have an objective minimum bar for what's going to be accepted or not, many people find it easier to accept feedback from a machine rather then another person, many people are already used to having to submit a few times to satisfy PR, etc... If the contributor asks that you review the PR even while the tests are failing, you have a ready-made excuse: "our policy is to make sure master stays green -- once you fix the tests, I'd be happy to take another look." If somebody tries changing the CI config to drop support for a certain version and they don't have convincing rationale why, that's again easy to say "no" to. You can maybe say something like "Sorry, our policy is to support Python versions x, y, and z: here's a link to some past discussion about this/a link to some rationale. We might reconsider dropping support for Python x in a year or two, but we don't have any plans for dropping it for now." or something similarly polite. Then, just close the issue and ignore any further attempts the user makes to try and make you change your mind. If the attempts start getting rude, only then would you ban the user. &gt; There have been multiple scandals on github of that nature that have occured over less. I find this difficult to believe. Can you link to examples of where this occurred?
&gt; To be fair, I've never met a packaging solution that I did like in any language. Some languages have better solutions or hide the nitty-gritty better, but overall packaging is always sucks for me. im not a huge fan of the language, but dart did a pretty good job
It's something to do with list comps being a new scope, and eval sucking. It's actually quite an interesting question and I'd love to see the answer if you solve it.
The closest thing we can get to switch is this: def one(**kwarg): pass #repeat for all cases func={1:one, ...}[evaluator lambda]({}) And it‚Äôs attrocious üòÇ. I don‚Äôt know why we still don‚Äôt have it or pattern matching. Tbh I like rust‚Äôs and f#‚Äôs pattern matching.
&gt; I'm not sure if this is actually true, is it? in most languages that support lambdas it is, just not in python
A good enough programmer would care about readability. 
Right, good point. Python is known for being different in this regard.
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Dataclasses aren't type safe. 
Can you elaborate what is the problem with this line? Would it not simply be like x = y = x = 0; in C?
The with-statement and import-statement are the only place where it's used, and it would be trivial to put an exception for those two. This kind of limitation sure didn't stop them from using "yield" and "from" keyword for async. At a high level, the `as` means the same in all cases anyways. You can see a with-statement as: `with fp = open('file.txt'):`. Of course, the with-statement itself does some contextmanager magic, but the assignment is the same.
For personal use: download all images from web pages. For work: scan a folder so that when you put csv files, upload them automatically to a database.
Sounds like this is one more reason you can give them to update, then. 
Checkout Sitespeed.io. It uses webpagetest and a bunch of other tools. Run it in docker, upload results to InfluxDB. Graph it with grafana. Lots of toys!
Agreed, your proposal is so so so much more elegant. My long comment was only explaining the motivation, not justifying or defending it -- I wish they'd thought to do it like this instead.
I'm not sure what the best syntax is to get assignment in these expressions, but I can say that when using languages where this is available (almost every other language I've used) I use this _idea_ with some reasonable frequency. Python loses in clarity and lines of code until it figures out a good way to do this. I'm only lukewarm on the assignment operator, but it at least makes it _possible_.
I created a twitter bot. Now I'm onto all sorts of madness. https://twitter.com/putln2
decorators
Wow, that's extremely compelling. Thanks for the link.
I'm going to take a controversial position and say that this proposal is a step towards the expression-oriented programming seen in languages like Scala where everything is an expression. Such programming allows for incredibly elegant piping of operations. In the future, with the addition of pattern matching and the like, statements that are also expressions will go from being redundant to being essential.
FWIW, I jumped in with out looking. Some libraries aren't ported yet, and print requires parentheses. Also, f-strings are great. 
Oh lol. Did you actually try your second example? In today's Python it is always, everywhere, a syntax error to have the `as` keyword within parentheses. The following statements: with (... as f): ... try: raise TypeError except (TypeError as e): pass ...will both fail. Using parentheses after `import` is also invalid, but that does not have to do with the presence of `as` (and, in fact, `import as` has the same semantics as the "as" currently being discussed) so it can actually be ignored here and I shouldn't have brought it up initially :) So this is why I fail to see the issue, because if the parser encounters a parenthesized `as` after `with` or `except` it can always, without question, be assumed to imply an assignment expression rather than whatever contextual meaning an `as` might have there (`__enter__` or the exception object). There is no ambiguity and I'm pretty sure you won't need a special-cased lookahead at any point. Also, turns out I didn't even have to bring up generator expressions in my previous comment; I was trying to provide an analog to the "multiple `as` in a with or except statement would be a syntax error" behavior, but that literally already exists in Python so nothing there would need to be changed: try: pass except Exception as e as nope: with open(...) as f as nope: And this too is all done with only one token of lookahead, as I'd assumed it would. (Note that an unparenthesized assignment-expression `as` would not need to be a syntax error outside of the above statements, only within them to distinguish meanings) Your point 1 is almost valid, but... no, there were so many devs on python-ideas and python-dev campaigning for `as` that I doubt your opinion of it holds water. I mean, we've already got flat-nested list comprehensions: [i for for j in iterable if cond for i in j if cond] where it's hard to distinguish individual units, but the world hasn't ended; comparatively, having those handy parentheses to clearly delineate one `as` from the next seems pretty okay to me. &gt; Errrr LL(1)? ? Python's parser is LL(1), where the 1 refers to the one token of lookahead it consumes during parsing.
I'm working on api for notification center, python is really fast with multiprocessing but still facing an issue with running 13 function at the same time. I have 13 different card and each one has its own tables to get info from. Still struggling with it.
I'm working on a server-client solution where maillog is getting filtered and sent to a server to do some metric stuff. But I'm doubting if this is the right solution because it isn't really fast. 
*for humans* is a bad meme that Reitz has been riding out since Requests found success with it
Still trying to run multi function at the same time. each function has its own different requirements but all are for the same purpose.
I still slap any nearby surface and shout that when I think something has got too complicated. I firmly believe it is a fantastic mantra for programming!
it sounds like the variable in question isn't actually supposed to be internal to the loop if you're having to keep reassigning it. are you doing something like searching a list for a particular value, at which point you break? if so, as others said, a generator is a good idea. but there's a lesser-known feature as well... you can add an `else:` statement after a `for` or `while` loop, which will only execute after your loop is done (but won't execute if your loop ended because you called `break`)
It's time for a palace coup and a new BDFL. I'd back Coughlin or Hettinger. Maybe still having to code in Python 2 has driven Guido mad. 
Trivial to disallow or trivial to specially parse? The first is annoying for a lot of people, the second is incorrect if you have experience parsing.
The fact that it is currently an error is irrelevant-- you change behavior and then have to consider that that is no longer an error. Like Raymond Hettinger and his mention of underscores being valid in numeric literals now causes a ton of previous exception causing code to silently fail by being treated as a number. Your examples are one token lookahead. But there is no limit on how many as statements can exist in an expression if used as an assignment expression. The devs on python ideas, from what I aware, were not devs working on the core parsing code.
I just can't get JWT Token authentication. And the amount and quality of examples sucks. 
Thank you very much! It's exactly what I needed. It works well.
Uh, no, there isn't... there's a federal judge providing a preliminary injunction that bars LinkedIn from blocking the plaintiff's scraping of LinkedIn's data ... that injunction doesn't constitute precedent, and anyway is currently under appeal to the 9th Circuit, where it seems to contradict the higher court's earlier rulings. It also comes very close to being a form of prior restraint on what would likely be considered to be LinkedIn's 1st Amendment rights, especially given the makeup that we can now expect the Supreme Court will have in its next session and onwards. But here's the thing, even *if* the 9th Circuit's 3 member panel agrees with the judge's rather novel idea, and *that* makes it past an en bank appeal, and *then* HiQ wins it's actual case against LinkedIn, it *still* would only be precedent to those in the 9th Circuit, unless and until the Supreme rules on it. Only at *that* point would it be unambiguously not illegal in the US.
You can make music via python.
If that's all this is about, why not allow assignments in conditional expressions. if (thing = do_call()) is not None: do_something() We already allow assignments to "return" their value- e.g., `a = b = c = 5` is valid.
I've been advocating for a palace coup for a while now. Guido doesn't seem to have the same judgement he used to. 
I thought it was best practice to avoid this in general? Hard to keep track of what assignments return in different languages and in general kind of confusing. I'd never use this and I bet most people I work with would never use this either.
Providing arguments to super is bad enough for me.
If/when there'a palace coup, I'm hoping Hettinger gets placed on the throne, and this sentiment about features being rushed into Python was what made me decide that. 
Remember when they decided that libraries could be added to the Python provisionally, to indicate they might change in the future or even be taken out? This was for additions that they thought were good ideas but weren't convinced the syntax or api was the best yet. That seems to have been completely forgotten about, such as the type hinting/mypy. Speaking of which, those hints were supposed to be for whatever the end users wanted, and then that got ignored with the addition of type hinting too. 
I've wanted this feature as well and I'm glad we're getting it. Wish it didnt need parens though.
When I was doing a survey of languages in 2012 and I came to Python, someone told me "Try to watch a video by Raymond Hettinger. You won't just learn about Python; you'll learn about programming". How true that was, and I became a Python fan/convert as a result.
When you have functions you can define anywhere, why do you need multi-line lambdas? Those are for "pure" object-oriented languages like C# that don't have first class functions. We don't need them, or "static methods". 
I once saw the Python dev mailing list reject an idea because it "would be just one more thing to learn". Now... this. What's going on? Has Guido been kidnapped and been replaced by Larry Wall in a Guido mask? Or did the functional language people who have always hated Guido since he rejected tail-call optimization (any time he's mentioned on the Haskell mailing list, someone replies "Is it April Fool's Day already?") do something to him?
I think they're unreadable because you're not used to seeing it. Its simple enough once you've seen it a few times.
I mean, list() is an object, so it has its own `__str__` method, which calls the `__repr__` method for each item in the list, which is the default representation for the object. If you did it your way, what if you wanted a str() representation which does show the `__repr__` function's return value? How would you do that then? You can make your own custom container type that overrides `__repr__` quite easily, but it shouldn't really be the default behavior.
Also, I left Delphi/Pascal for Python and those assignment operators are giving me post-traumatic stress! :-( I'm suddenly afraid Python will start charging me $1,400, and confine me to one IDE that only runs on Windows. 
There are an infinite number of ways to produce any kind of output. We haven't had any operator that does assignment and returns it's assignment.
Isn't assignments in conditional expressions considered one of the dumbest ideas of C? I remember being bit by this in college and going off on a rant in the computer lab when I finally figured it out about why Pascal was superior to C. I've since avoided C for 24 years now. :-) AND NOW IT'S FOLLOWING ME TO PYTHON. 
I like this better than the := approach.
Its not super rare. Most times you do while true or if something is not none can be replaced with this.
I can't understand if you are adding on to my point or trying to say something against it.
No, right now I'm using plain python. I'll look into biopython when I'm done with the book.
Well the question is: is an assignment an expression which returns a value? Syntax like: `a = b = c = 5` implies that *yes*, it is. So if it *is*, why couldn't you use it in a conditional expression? Yes, because `if (a = b)` looks like you're comparing a and b, not assigning. And that's why I don't like using `=` as the assignment operator, but it's so standard across so many languages, it's the dominant form anymore. My pet peeves aside, I do think: if a = foo() == 5: do_something(a) is a bit awkward syntactically. I'd actually rather have some sort of block approach, for example, the way i'd really do this in a C-like language would be: { int a = foo(); if (a == 5) { /* stuff */} } //a ceases to exist here So if I wanted the same thing in Python, I'd want something like: with a = foo(), b = bar(): if a == 5: do_stuff(a) else: do_stuff(b) # a and b are scoped to this block, and cease to exist here That'd be a pretty big change, though. This is a case where I'd say, "let's just not bother" and leave it as it is.
\_\_do\_not\_put\_init.py\_here\_\_
Notice that `x` is twice there? What is the meaning of this? (x := (y := (x := 0)) + 1) Yes, there is a perfectly defined meaning. But it is not obvious, and there is no way it could be made obvious.
One operator changing the meaning of things on the same expression is complex.
It could be specifically for data scientists, for example. Yes, every data scientist is literally a human but it‚Äôs not human vs nonhuman the tag is getting at.
Without this as a code snippet I cannot tell if this is really how the file looks like...
This was a fantastic talk; I'm a huge RaymondH fangirl.
To be clear, Python's list is not a linked list. It's more like C++'s vector
I feel like you need to `import this`.
You can't define functions anywhere in Python. Non-lambda functions cannot be defined in expressions. This is the crux of the issue.
Getting extentions running on windows and understanding how to mix conda with pip and how that works with virtual environments. I use python in environments, where pip install fails do to hard firewall rules, so getting stuff installed and running is a pain. I'm surviving on "https://www.lfd.uci.edu/~gohlke/pythonlibs/"... if that did not exist I'm probably be doing something else by now...
Consider the expression: x &lt; y &lt;= z This seems simple and intuitive, right? It evaluates `True` if `x &lt; y` and `y &lt;= z`. And in fact that's how Python defines a chain of operators like that: `expr1 op1 expr2 op2 expr3` is defined as equivalent to `(expr1 op1 expr2) and (expr2 op2 expr3)`, except Python guarantees that in the chained-operator form `expr2` will only be evaluated once. But it also means that, for example, `False == False in [False]` evaluates `True`. Which people find so unintuitive that they put it on lists of "Python wats". Yet it's exactly the same principle. Is this feature of Python too complex?
Packaging. `pipenv` helps a lot for applications, and `poetry` seems to largely be the same thing for libraries, but oh lordy how I'd love a build system that's as simple as Rust's `cargo`.
Raymond is such an entertaining speaker, I'd watch his talks even if they were completely irrelevant.
Also interesting; Kenneth's [first hand report](https://www.kennethreitz.org/essays/mentalhealtherror-an-exception-occurred) of a mental breakdown.
Numba can be amazing once you understand its strengths (and weaknesses) 
Are you sure it's not yaml?
classes are instances of a class. It's pretty rare you really need them. Example: If you're writing library that provides base classes the user is expected to inherit from. You can write the base class as an instance of a metaclass that checks the metaclass satisfies certain behaviors/properties.
Personally, I also had this apprehension until I *had* to use it for a project (conflicting dependencies between a package I had to have for a project and a module I use constantly). So I finally bit the bullet and tried to figure out how it works. Once I did it, it was actually a lot simpler than I thought. I tried out virtualenv and conda. Conda fits my general work flow better than virtualenv, but I'd get familiar with virtualenv since it's the widely used one (though that might change with `pipenv` being released recently).
Fuck Udemy. Everything there is always on sale, and even at a couple of dollars, the courses are rarely worth paying for over the abundant free learning materials.
I've put off learning Django for so long because I can't grasp the concept of separating a project into apps. Say you're making a reddit clone. You should apparently have an app for "each functionality of the site", so you'd have an app for reading and commenting in threads, an app for registration/authentication, an app for searching for threads... but then how do they interact? They'll need to share models between them, for example the authentication app will need the User model, as will the app to comment on a thread. So if they all depend on each other, then the apps aren't really standalone modules that can be easily migrated into another project, which I thought was the whole point of apps.
You don't need to worry about memory management.
Damn! I'm running a channel about Python in Telegram, and since I always look for something to write about, this thread is a treasure for me.
I agree that pandas is unintuitive in terms of syntax sometimes.
Maybe I‚Äôm too inexperienced with python but why wouldn‚Äôt you implement this as a function that takes a uri, a json path and a log path as parameters? Then it‚Äôs just a matter of parallelizing the function calls so that they‚Äôre both working in tandem, which isn‚Äôt strictly required by your request but kind of implied. 
I wasn't familiar with YAML. It looks like that's what it is. Thanks.
Yeah. Many libraries reproduce the feature set of an underlying C library or all the elements of some standard, but without the craftsmanship required to make it easily used. 
Yeah, I don't get apps either.
I'll give it a shot with a metaphor example. Jane works in a factory. And what she does is she drives the lift and move things around. She always gets a package and the destination location and she moves it. Jane is a function, because she needs specific things (destination and package) and has a specific and well defined task. Helen works also for the same company as a driver, but she delivers the products to the warehouses. She gets a list of objects and a destination and she transport them. She is also a function. The new manager has identified that some times the drivers take very long to finish their deliveries and no-one knows where they are. Manager has tried to ask them to report in case they have a problem but our friends are slow learners. The new manager is you (the programmer). You found another way to make it happen. You will hire Anne, whose job will be to monitor the drivers. Her task is to get the list with objects and destinations, deliver it to the drivers and also check the time when they leave, check the time when they are back and if they take too long, call them back. Anne is an equivalent to function decorator. Her job is meaningless without the function that performs the task. Her functionality is to control how other functions work. Add some before-after and some different behavior. I could extend the examples for context managers but I'm a bit drunk and I think you got it.
Wait, this isn't in 3.7 is it? 
I'd be interested in a follow up!
If the CMS does not offer a forum you're going to have to write an integration.
You probably need to give an absolute path. I haven't Ruby'd in a while, but you should be able get the current working directory, or at least the absolute path to ".program" and then concat that to "lib/program" and use than in whatever function you're using to run the script. 
Yeah that makes sense. The solution to this is however pretty Ruby specific, but I believe I have a solution that does the job at least. Thanks for your assistance.
Just an ordinary user here. I can see that this might make some loops or if statements tidier. However, all the examples I've seen of using this in list comprehensions seem very nonintuitive to me: I have to read it two or three times to understand the intention. I'm anxious that I'll have to significantly change my mental model to understand something as fundamental as assignment. Granted, these are emotional rather than specific responses, and the := syntax is something I'd probably get used to.
^The linked tweet was tweeted by [@anthony_barker](https://twitter.com/anthony_barker) on Jul 04, 2018 22:09:44 UTC (0 Retweets | 0 Favorites) ------------------------------------------------- Python programming is exploding in \#China ..at least according to google trends. \#Python [@ThePSF](https://twitter.com/ThePSF) [Attached photo](https://pbs.twimg.com/media/DhSyNx1WsAILQzT.jpg:orig) | [imgur Mirror](https://i.imgur.com/mnK8Xwq.jpg) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
I really **love** [`delegator.py`](https://github.com/kennethreitz/delegator.py). What a pleasure to deal with subprocesses using this library. &lt;3
Udemy sucks. Period. 
Best description so far. The phrase is nearly pointless
Little script to scrape time series from the web. Financial data. 
None of those are creating side effects that may apply to some other part of the same expression. I don't get why are you comparing them with (:=). Anyway, it looks like the later one is complex enough to not be used; even it being in a incomparable simpler category.
The event and the results are not really copyrighted. The way it's compiled together is protected. 
&gt; PHP doesn't even have keyword arguments. &gt; You're not making sense. I didn't claim PHP has keyword arguments and I can do without the rude taunts. I am referring to the wisdom of using [composition](https://en.wikipedia.org/wiki/Object_composition) rather than long lists of options that are not easily extensible. &gt; An ABC or a mixin would need to analyze the class structure each time they're called. Not commenting on ABC's specifically but in the abstract there are several solutions to this problem, the simplest being memoization. 
Apps are just Python packages with naming conventions and mechanisms that allow Django look for required information at startup (what models are defined and require db migration, what's the template search path, what admin forms should be created, etc.). Just like Python packages, apps don't have to be independent and there's nothing wrong if you import something from another app, especially if it's a model. In fact, some builtin Django apps depend on each other, eg. `auth` depends on `sessions` and `contenttypes`.
Oh man you never used pattern matching if you feel that way. 
He's great at writing things for humans. He's not so great at interacting with them. He [shat on this entire community](https://www.reddit.com/r/python/comments/8kjv8x/_/?sort=top) when he couldn't take some criticism.
That doesn't really feel like a particularly compelling reason to me. I dont know if there's more of an implementation specific reason, but within the context of a \`with\` statement you get back \`\_\_enter\_\_()\` not the return value of the function....fine...? That's already true and not necessarily obvious. In all other contexts (afaik) the \`as\` semantics match what's happening with assignment expressions; so I'm pretty comfortable with \`with\` statements being the odd man out, if you even need to think of it that way.
By the time you hit an \`as\` token, you already know you're within a \`with\` block, so I don't think it would be particularly hard to define semantics of how an assignment expression should work within a with, or to simply disallow it. At least with a hand-rolled parser, I'm not sure if python uses a parser generator or not.
Speaking for myself, I do these things all the time and would welcome the tighter syntax. Subjectively, I find map() to be overly lisp-y and prefer the syntax of comprehensions because they make the list result explicit with the use of square brackets. (Obviously, we're arguing about syntax...) Constructively, it would AWESOME to have a bidirectional gofmt-like tool that unified Python 3.7 syntax. Obviously it's challenging to auto convert to and from something like PEP 572. But if it worked then everybody could have precisely the language subset they liked ! 
Not really, I generally shy away from any comprehension that's more than just `[f(x) for x in lst if g(x)]`. If you're doing something more complex, use a loop, it's far more readable. if `f==g`, you can iterate over `map(f, lst)`. Comprehensions are inherently supposed to be almost english readable, just like the ternary operator. Those things up there definitely aren't readable.
How is the second not true? If you're within the context of a with-statement, use with-statement as, otherwise use assignment.
I'll just leave the previous discussion I had about this here: https://www.reddit.com/r/Python/comments/8vmq27/pep_572_assignment_expressions_is_officially/e1sn441/?context=6 General rule is, don't claim it to be simple unless you are willing to implement it right here, right now.
Yes, except you can have something like this: with manager([g(y) for x in container if y as f(x) is not None]) as stream:... They wanted to allow assignment expressions in comprehensions. To then not do so if the comprehension is part of a with statement context manager parent, is paradoxical. Writing a parser for such, is extremely difficult.
Honestly, a lot of his other projects have left me scratching my head wondering what they were really good for. 
Amusingly, I just said yesterday that I'm glad this "for humans" thing appears to have died out, and then here we are today. 
And that library's advocates would then reply that this just means that they're smarter than you and don't need to use a dumbed-down library. :-(
&gt; The with-statement and import-statement are the only place where it's used It's also used in the catch part of exception blocks, but that doesn't change any of your argument I think.
Have you ever done while true with a break on the first line? I think this is way more readable.
er, 3.8 I think, Someone else mentioned it above somewhere. Regardless, most people writing python for money probably won't be using even 3.7 for quite a while I'm guessing.
You just group logic together. Theres no rule they can't be big or import from eachother.
I just get annoyed when I can‚Äôt do this: x = dataframe.csv x = x.addcolum(mycalculatedcolumn)
More low rent, linksynergy redirect, SPAM nonsense.
I get the appeal, but I don't see it as a huge improvement over `subprocess.run()` in Python 3.5. 
I don't get that "is not None" stuff. Just "if x" would work. No need to get all wordy about it
But at what cost?
But it's not the immediate parent context anymore. You're 3 layer down the syntax tree by that point.
Nope, 3.8, I believe.
That was an intense read! 
&gt; how much of your stuff is wrapping other old codes? Given [the use of numpy](https://github.com/buddyd16/Structural-Engineering/search?q=numpy&amp;unscoped_q=numpy), there's a lot of C behind the scenes here.
&gt; what they were really good for Humans apparently
That particular exception is raised because `eval` is attempting to look up `str` in `__builtins__`. Given these globals passed to `eval`: {'__builtins__': None} we can see that `None` is not a mapping, hence the exception. But why even look in `__builtins__` when `str` is in the supplied locals? That happens because, as /u/raarzer alluded to, locals are not what you expect inside of a list comprehension. The comprehension has its own local scope. For example, play around with the following and see what results you get: print([locals() for x in [1]]) I'm assuming this behavior is a consequence of preventing list comprehension variables from leaking out to the enclosing scope as they did in Python 2.7. I'm not sure if this is an oversight in the implementation of `eval` or working as intended. P.S. How safe does your `safe_eval` needs to be? If you only need to prevent well-intentioned users from making honest mistakes, things might be ok. Otherwise, consider this "safe" input: object.__subclasses__()[[str(c) for c in object.__subclasses__()].index("&lt;class '_frozen_importlib.BuiltinImporter'&gt;")].load_module("os").system('/bin/sh -c "echo \\"Owned\\""') (This is just a quick example that I threw together targeting Python 3.7. There are lots of other viable approaches.) 
Some interesting libraries!
I think he was adding on.
My answer was generic; not specific to Python. Hence: "Normally" in my response. The usual route is to model dataclasses with Plain Old Objects in your language of choice, or use language specific dataclasses as demonstrated in Kotlin. I should have been more precise in my reply. Thanks!
I totally bookmarked all that to try to understand later
x[newcolumname] = mycalculatedcolumn 
Not that I would necessarily, but you could define it the line before. I do still wish for multiline lambdas though... Would make `map` et al more generally useful and pretty.
You might want to use a subreddit stream if you want to have it run continuously.
I can't remember my exact first project, but a good one to do might be going thru a list of urls and downloading the raw HTML? (Super easy using Requests module) [https://github.com/SomethingGeneric/pyNoise](https://github.com/SomethingGeneric/pyNoise)
 False is not None
You can't catch arbitrary exceptions inside a lambda as far as I know, but you can do just about everything else. You shouldn't, but you can.
&gt; makefunction That is a good way to put it. Lambda basically creates a function as it is called, rather than def which creates a function as the module is loaded. Because of this the lambda functions don't have a name since they are never referenced. They are created, executed, and immediately forgotten about.
I haven‚Äôt heard about that. Currently I just have the script scheduled to run every 2 hours on my PC. If I used a subreddit stream would the script have to run 24/7?
I also rely alot on Scipy, TKinter, and Matplotlib. My previous reply was geared towards methods pertaining to the engineering calculations. A more wholistic answer is yes I do rely heavily on wrapping these other modules.
The trick with decorators is knowing that they are called when the module is loaded and basically replace their decorated function in-place. The decorator isn't called every time the function is called, it *replaces* the function once at the very beginning.
Lists do not have a `__str__` method. They have a `__repr__` method, and the `str` function will fall back on `__repr__` if the object you call it on doesn't have `__str__`. It should not surprise you that list's `__repr__` method calls the `__repr__` of the items inside the list.
Hahah what? Github link please? I have to see this lol
The original version had a folder for site-packages. I don‚Äôt know where that‚Äôs gone and therefore I don‚Äôt even know where packages go when I install them. Also the actual icon of the folder is different which makes me assume that it‚Äôs not the same python that comes preinstalled.
Will reinstalling the OS cause me to lose anything? Could anything go wrong?
I can't define them in the middle of a variable name either. "Anywhere" means a sensible place where things are defined. If I can do: &gt;You can't define functions anywhere in Python. Non-lambda functions cannot be defined in expressions. This is the &gt;crux of the issue. "Anywhere" in this case means in a sensible place for defining something. If I can do def whatever(x): z = x ** 3 if c &lt; 7: return 3 else: return 1 something(func=whatever, num=7) ...what do I gain by sticking the definition of function whatever right in the call to something? Nothing except a hard-to-read mess. Maybe I save a few characters tops depending on what I name the function. Otherwise it serves no benefit. In "pure" object-oriented languages like C# or Java, there are no independent functions; every function is a method of a class. In that case, lambdas work around the problem of being "purely" object-oriented. In Python, it's a mere bit of sugar. 
jwts are odd and I kind of don't like them but I see what they're trying to accomplish. traditionally, sessions are managed by the server. the server sets up some data structure somewhere (the database, redis, whatever) and sets up an opaque pointer to it that it gives the client. the client is then responsible for sending that pointer to the server when it makes a request. jwts change this dynamic by sending the data structure to the client - encoded and signed so the server knows if you messed with it. The jwt token is three parts: a preamble that talks about the encoding, the body which is just a json object blob, and the signature which is cryptographically secure (or rather should be). the idea is that server doesn't need to maintain a session anywhere and only needs to validate that the token hasn't been tampered with and hasn't expired. There's pros and cons to both. For traditional server sessions, you can do a lot of things that you just can't with jwts. You can force expire sessions by just deleting it from the store - if you've seen those "you're also logged in with an Ubuntu laptop" or the like on Facebook or Google, that's what's going on there. You can also change things about the session without worrying about stale information - users groups change? just update the session. The con is you have to make a trip to the session store to get that information. Personally, I don't think that it's that big of a deal. With jwts, you don't have to worry about storing that session any where, that's on the user. The cons are that you can force expire the token without reimplementing server sessions. you also can't update the session and know you're not getting stale information since the user stores the token and you have to reimplement server sessions to get around it. I'd advise against using jwts, honestly. They only create more problems than they solve in my experience. 
Because that introduces a hard to find bug when you use = instead of ==
this is neither /r/HomeworkHelp nor /r/beermoney . Did you try anything yourself? What's the problem? The UI code? The data mangling? 
No amount of money can fix the mess that are strings in python 2 without breaking compatibility.
Use excel to save the files as csv, then read it with pandas.
So then what's the point of separating a project into apps if not for reusability and decoupling?
This is a great tutorial. Thank you for sharing!
Oh come on. I know this sub is bitter about Kenneth but are you guys seriously going to discredit the other work he has produced? People like you guys are the reason why people don't participate in Open Source. 
RemindMe! 
**Defaulted to one day.** I will be messaging you on [**2018-07-06 01:01:26 UTC**](http://www.wolframalpha.com/input/?i=2018-07-06 01:01:26 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/8w5ra9/a_real_python_cheat_sheet_for_beginners/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/8w5ra9/a_real_python_cheat_sheet_for_beginners/]%0A%0ARemindMe! ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
I don't see what is so unreasonable. What to you is him shitting on the community?
Try using `xlrd` to import excel files to python
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
* he took comstructive criticism of pipenv as personal attacks * he implied this community as overwhelmingly negative and toxic * he decided to make /r/positivepython to circlejerk himself * he decided to egotistically brush off any criticism of him, which mind you only occurred after he flew too close to the sun, as garbage. * consistently calls himself "Kenneth Reitz, of Requests fame" as if he is marketing himself, but then he denies it. * fosters negativity in many of his own communities, and there are various links of him doing so in multiple comments in that post, to both Github discussions and reddit discussions with him * rallied his twitter followers to his side, holding an "open" hangouts discussion where they circlejerked him to oblivion * disgraced everyone with bipolar disorder, constantly blaming many of his long term actions all on his condition The entire thing was a gigantic disgrace. And I didn't even mention all of it. And while I personally would more than gladly let bygones be bygones, if only he admitted his mistake and apologized to /r/Python, but no, he doubled down and defaced the pipenv repository for a little while in protest. And to this day, he still hasn't apologized, because he holds himself on that high horse.
Here's a sneak peek of /r/positivepython using the [top posts](https://np.reddit.com/r/positivepython/top/?sort=top&amp;t=all) of all time! \#1: [A quick thought on being nice](https://np.reddit.com/r/positivepython/comments/8kdpo9/a_quick_thought_on_being_nice/) \#2: [EdgeDB ‚Äî Awesome new Python‚Äìinspired (and written) Database!](https://edgedb.com) | [2 comments](https://np.reddit.com/r/positivepython/comments/8kdo9n/edgedb_awesome_new_pythoninspired_and_written/) \#3: [Setting expectations for Open Source Participation - PyCon 2018 Keynote discussing negativity in OSS](https://youtu.be/tzFWz5fiVKU?t=48m56s) | [1 comment](https://np.reddit.com/r/positivepython/comments/8koitf/setting_expectations_for_open_source/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
He does plenty of good work-- but you have to concede that some of it doesn't have a clear use. He is not our Python God. Being able to see both the good and bad in people is a necessary skill.
I know thats how it is done but foe some reason I keep getting errors for trying to change something that already exists. At least thats what I remember I got lora of errors and just coded the whole data cleaning in R. 
Kenneth started that trend, with requests he indeed made it simpler than existing APIs, but then he started slapping that term on everything else he was working on. Others started copying that phrase and he we are.
Honestly, I don't have a horse in the race (although I do use and like pipenv so conclude whatever you want about my own bias), but I think that's a bit harsh. He definitely didn't have the most mature reaction, but I think it's hard to have work you've done (for free?) criticized so heavily. Most of the comments were totally reasonable, but there were some that I think past constructive criticism. 
however, with the the new PEP572 we can also do with f := open(...): Which is kinda fucked up anyway. 
I'm excited! This is my first Python package, and a major update to the [webapp](http://www.pointillizer.com) I put up. Try it out with your own photos! It makes really great artful images from any photo. I've set up a [dedicated repo](https://github.com/tsennott/pointillism) for the project, complete with tests and coverage badges and all that fanciness. The PyPI package is [here](https://pypi.org/project/pointillism/) Thanks for checking it out, and please let me know if you have comments!
Interesting, I didn't realize that "Legal Precedent" was a thing. I always just assumed it was the common definition for precedent. Thanks for clearing that up.
It has things like built-in pipes, too. 
This is bogus. The "for humans" meme had been around long before Kenneth Reitz. It was a trend before him, too. People slapped it around here and there. But Kenneth was the first, or seemingly the first, person to slap that phrase on an extremely popular package (requests). As the package grew further, he started slapping it on other packages of his, whether or not they were really relevant. It lost it's meaning in the Python community, and is now almost synonymous with "this is by Kenneth Reitz, of Requests fame", even though there are a few other people that slap that phrase on their projects.
lol I don't get why it got down voted. It's for Python. Also JetBrain is where it's at 
This is pretty cool. I like the way this cheatsheet is structured, succinct and written as coded examples. Thanks
Hammergeil 
No. The large majority of comments on pipenv were completely constructive. The second he perceived it as a personal attack and got all offended, then people started actually attacking him. And, that, was too far to some extent. But not without reason-- he shut down their constructive criticism first in a completely narcissistic way. It does not matter if he puts the work crafted by God himself out there for free. It is great work, and we appreciate and applaud him on it. But we have the right to criticize it as well. He acted above all, as if he was the patron saint and God of Python himself. And thus, he was struck down. He had a glass house, and decided to throw stones.
+1 for arrow. had to write some custom date parsing functionality for work and arrow really helped with a lot of the heavy lifting 
How does it call C libs? What does it mean to say a language like Python has bindings for it? Like, I saw theres a specific pattern to follow to compile something so Python can use it as a lib but I just don't get how that works. Or why/how running part or code becomes faster when it's running inside the Python environment? Or really for any other language/env.
Remindme!
Get off your high horse. I have no idea who kenneth is other than the guy that made requests. It was a joke. If people don't participate in open source because of jokes, I'll survive.
Only because this is true: f = open(...) ctx = f.__enter__() print(f is ctx) # True Not all context managers work this way.
I feel like he missed the mark. "for humans" always came off as passive aggressive to me, but I'm sure that's not popular opinion. He seems to be pretty well liked?
If "for humans" became a standard, I would be thrilled. I truly loathe this cycle: 1. I have no idea how X works and there are N libraries, so I'll make a new library that abstracts it away for me. 2. *learns about X to make library* 3. Wow, there sure are a lot of options! I better expose them all. 4. Next guy: I have no idea how X works and there are N+1 libraries...
I mean `f` is accessible outside `with` right?
^ This
Yes, in both cases. Scoping for `with` by default is function-level.
Note that the '[learnxinyminutes.com](https://learnxinyminutes.com)' website has a whole bunch of similarly structured "cheatsheets" for other languages and tools, and they are all pretty decent in my experience. Definitely worth exploring.
Thank you! I am a beginner and this really helps.
This is absolutely perfect for my learning style - thank you so much for posting!
I'm looking forward to that v2 branch. 3.7 was recently released though so I'm guessing it'll take more work to release. Can you ask for help? It's a beautiful site that a lot of people use as a reference when porting old code and writing new code. We'd all love to see it updated for more recent releases.
Requests - very popular, very useful. Some of his other libraries never caught on though. Tablib and Records (both of which are basically subsumed by Pandas), Maya never caught on versus Arrow or Delorean. Reitz's own comparison of Maya and Arrow reads "Arrow, for example, is a fantastic library, but isn't what I wanted in a datetime library. In many ways, it's better than Maya for certain things. In some ways, in my opinion, it's not" which doesn't really sell it. :-) 
 a = [1, 2, 3, 4] # Point a at a new list, [1, 2, 3, 4] b = a # Point b at what a is pointing to b is a # =&gt; True, a and b refer to the same object b == a # =&gt; True, a's and b's objects are equal b = [1, 2, 3, 4] # Point b at a new list, [1, 2, 3, 4] b is a # =&gt; False, a and b do not refer to the same object b == a # =&gt; True, a's and b's objects are equal Never seen this explained so clearly. I love it.
This is great, thanks!
This is great. I'm embarrassed to admit I did not know about the // division... Also, just curious, the styling for the True and False code examples is the same as comments. Am I not seeing this right on my phone, or was this perhaps on purpose?
I made TicTacToe, but why stop there. So I made levels of the computer to play against, then I made a GUI, then I made a database to compare win %, then I made others games (Minesweeper, blackjack, connect4, checkers, hangman, etc). It was a lot of fun.
Before you do anything else, backup anything of yours that you value to an external drive. As well as doing a timemachine backup.
This is awesome. My own cheat-sheet-in-progress is about 1/10 as useful. And I learned stuff! Thanks.
 @foo def bar(): ... is just def bar(): ... bar = foo(bar) A simple example decorator would be def logger_decor(f): def inner(*args, **kwargs): print(f'called {f} with {args} {kwargs}') f(*args, **kwargs) return inner @logger_decor def square(x): return x ** 2 square(3) &gt;&gt;&gt; called blahblahblah with (3,) {} If you are having trouble with decorators I would recommend looking up stuff on closures and first class functions. Decorators are just a very light syntax sugar, and just confuse the issue in that respect. You can also decorate classes, but if you remember the desugaring above and that classes are first-class objects that can be manipulated or mutated like any other there's nothing really interesting about that.
Personally no. See: https://www.reddit.com/r/web_design/comments/4vw36y/best_resource_for_learning_css/d61zz0i/
Quite the opposite in my opinion. 
They are not really all that comparable. They accomplish different things.
Sorry for piling on with another "have you tried" but have you tried plumbum? 
few month learned css code really a bit hard. dont know about python
i know
kool, great share.
Y U no dvcs?
Yes
Yes
TIL Comparisons can be chained.
Thank you!
No. CSS is much, much simpler. But they cover completely different use cases, and the paradigm is completely different (declarative vs. imperative), so you may have some trouble familiarizing yourself with that and developing debugging techniques that work for you.
Slight correction, the result of division *is not* always a float. If you open your interpreter and type 10 / 3 you see that the result is '3'.
def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b
def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b 
Exiftool
That's true for python 2.X. But here we are looking at python 3.X!
Oh shoot, reading is hard.
This is a good resource. But why do you have to call it a "REAL" cheat sheet... This sort of implies that all other cheat sheets created before this are bad, and this is the only solution out there. I know I'm nitpicking, but I really hate clickbaity titles like this
What you say is true for Python 2, but not Python 3. In general people, especially beginners, shouldn‚Äôt be using Python 2 unless they are working with a legacy codebase. Python 2 will be unsupported in under two years time. In modern Python 10/3 is 3.3333...
I wrote a crawler to backup specific user's posts and articles of a website. All data captured are stored in mysql database. It's that sometime the request return a different data format or sometime the request is block by anti-crawler program that took mu much of time to handle it. My project: [https://github.com/HubQin/sinaCrawlerV](https://github.com/HubQin/sinaCrawlerV)
CSS is simple to get started and grasp advanced concepts BUT... The more you learn about css, the less you feel you know about it. There are lots of edge cases that might make you go crazy especially if you wanna be pixel-perfect and support older browsers. Nonetheless, CSS is the best way to describe the UI imho. Also, it's been actively developed/updated and is not going anywhere for a long time. Source: been a web dev for 6 years. 
Hi I am able to read .docx file content through textract and able to create one post with image through xmlrpc. How do I upload entire folder for a post through xmlrpc?
For python's advantage in AI, machine learning, it's hot in China. But the most widely used langue is still PHP.
[cefpython](https://github.com/cztomczak/cefpython)
So I just messed with this for a bit and while it does seem to edit some title tag on the file, as I can see the new title by using exiftool, no other program seems to see the new title. They all still see the old title I added manually, even windows itself still shows the old one under properties &gt; details &gt; description &gt; title. Maybe I'm just doing it wrong if there's more than one type of title tag, have you ever used it to edit the tags on video files? Seems like it's mostly used for pictures.
Isn't the internship supposed to do just that?
I'm not interning for IT or any computer science relate course, I'm in chemistry
fork away :p
Maybe use a notepad app of some sort to write stuff while you‚Äôre there, then send it to yourself on your pc to compile later on
Yeah, it's one of the more complicated things to learn about law... precedent is basically the sum of all of the previous opinions by higher courts (and/or upheld by higher courts) that are relevant to any given topic or controversy. Opinions can explicitly say how narrow they are, and whether or not they can be used as precedent in other unrelated cases (often the judge feels the opinion applies only to the case in front of them), and jurisdiction matters (a federal court in the 9th Circuit is bound by the precedent of all 9th Circuit opinions (unless overruled by the Supreme Court), but may choose to reference precedent in other Circuits for help in determining the reasoning behind their opinions, so precedent can cross pollinate between jurisdictions but can also end up having different (or even contradictory) effect in different jurisdictions, which is why the Supreme is needed to settle the contradictions in lower courts. And is also why the Supreme shouldn't ever be stacked with too many idiots.
Quick question because I am fairly new to Python: I am just seeing &lt; "{}".format(var) as an option to format strings, but I am only using &lt; f"{var}" Is my method less pythonic than .format ? 
There are no ready solutions? Is it complicated?
How does that help you? 
somewhat related: https://hbr.org/2018/05/drunk-people-are-better-at-creative-problem-solving 
https://mutagen.readthedocs.io
`str/unicode/bytes` was insurmountably wrong in 2.7. 
Indeed! Another good explanation is the one from [Dan Bader](https://dbader.org/blog/difference-between-is-and-equals-in-python) with the twin cat allegory.
no. format is the old way. you are doing it the newer, correct, most pythonic way. kudos
I've looked into that, I'm pretty sure it only supports audio files, not tags on an mp4 container. If I'm wrong though please tell me.
I need to learn data science for my thesis in undergrad chemistry. Can you please just stop asking me "why" and focus on answering my question
If you go to the root website there are cheat sheets for other languages too!
Yeah that is actually what I am doing. Writing down ideas, but it would be super awesome to see and practice actual code. :) thanks though
Yep, got the exact same problem. Beta 3 doesn't help.
Yeah, thanks for reposting my same exact post from 6 months ago I guess... https://www.reddit.com/r/Python/comments/7n1c9u/a_real_python_cheat_sheet_for_beginners/ Btw. it was in response to [this post](https://www.reddit.com/r/Python/comments/7mwgtw/python_cheet_sheet_for_begineers/).
Can you explain what you're trying to do? It's probably possible in Python.
If you are in an iPhone Pythonista is awesome. 
What actual algorithm are you using? 
Yay! Thanks for the answer :)
[https://github.com/flexxui/flexx](https://github.com/flexxui/flexx)
Thanks! Both frameworks seem to be actively maintained are exactly what I am looking for. I'll try them out both soon. 
Sure, when I get to a PC. In theory it works in python, in practice the functions process order doesn't allow it. I'm open to the possibility though :) 
Same, at this point it is just annoying.
Personality cults aren't good for anyone. Just that one part of the work is great doesn't mean the rest has to be as well.
&gt; Delegator.py ‚Äî Subprocesses for Humans 2.0 Oh ffs this for humans thing is getting out of hand.
css is easy, it's the browsers that will make you mad.
How to properly write a mainloop ( Signal handlers, threads, threads with async workers inside them, etc.) and also the `proper` way of re-trying idempotent steps. 
try sololearn ! they have some data and machine learning stuffs !
&gt; EXPR as NAME: &gt; stuff = [[f(x) as y, x/y] for x in range(5)] &gt; Since EXPR as NAME already has meaning in except and with statements (with different semantics), this would create unnecessary confusion or require special-casing (eg to forbid assignment within the headers of these statements). https://www.python.org/dev/peps/pep-0572/#id19
I create something very similar since I do not like argparse as well.
&gt;He is not our Python God. Yeah, Raymond Hettinger is
It's main use case is audio files (it doesn't expose any video related info like resolution, fps etc), but the metadata in case of MP4 should be the same for both audio and video.
The thing which seems to get completely missed in discussions about POSIX file system encoding, is that POSIX file names are not text, and so do not have an encoding. They are null terminated byte strings. The only reason to decode a filename as ASCII or UTF8 or anything else, is for display. Anyone who says the "filesystem encoding" is synonymous with the system encoding is wrong. Just plug in a USB stick created on a Chinese or Japenese system. Things break badly in python. NTFS / modern windows is different. Those filenames are UTF16 (I think) strings. 
&gt;Also, just curious, the styling for the True and False code examples is the same as comments. Am I not seeing this right on my phone, or was this perhaps on purpose? Yeah, it's the same on desktop browser, and I think it's just a formatting mistake.
[https://github.com/iogf/gle](https://github.com/iogf/gle)
Agreed. People get way too fussy about metaclasses. They are just another tool in the bag. Most of the time, they are not needed, but when you need to do something unusual, they can be a nice solution when used sparingly.
God's work 
 -5 != False != True #=&gt; True I dislike these kinds of example as they suggest there being an unequals operator with 3 operands. Maybe this would be better -5 != False and False != True and -5 != True #=&gt; True
Oh yes, it's a hard problem especially in Linux, and it really needs the OS to manage the solution. The complaint is that until Python 3.7, the core devs were insisting the right thing to do in Python in the absence of information from the OS was "assume ASCII and throw exceptions" rather than "assume UTF-8 with surrogate escape".
Amen.
css is difficult too remind me https://qph.ec.quoracdn.net/main-qimg-81d2bffd2d12c8275ab2c708b3fd5297
I mean... maybe like 3-4 years ago I could relate to that meme a lot XD but modern CSS with flexbox and grid is just a charm. Read this post [https://medium.com/actualize-network/modern-css-explained-for-dinosaurs-5226febe3525](https://medium.com/actualize-network/modern-css-explained-for-dinosaurs-5226febe3525) It covers bunch of important aspects including pre/post processors (which is basically CSS on steroids but very optional especially for smaller projects) 
Why not just use Numpy for that?
That works too, with the additional cost of constructing another list My point was that this new Assignment Expressions feature makes this probably a bit more efficient. And shorter to write. But in my opinion that wasn't reason enough to justify a new syntax
feel free to ask me questions about Pandas if you have any. [link to thread](https://www.reddit.com/r/learnpython/comments/8urtqx/ask_me_your_pandas_data_manipulation_questions/?ref=share&amp;ref_source=link).
Given the specifics of the site (there is a T&amp;C, but it does not mention any form of agreement to not engage in scraping) and the data (which is most likely gathered and entered in an automated process, or if a manual process one that involves no intellectual or creative work), it's likely the copyright extends only to not reproducing the format of their page directly. Scraping the data is most likely fine, unless and until they update their T&amp;C to bar it.
Interesting. Can you plot it as % of ratings? It seems like there's a general increase in # of votes, the question is if the rate of increase in 5 stars is higher than the rest. It's interesting to note that all trends seem linear. Also, what did you use for visualization ?
// does not truncate. It's called floor division and rounds down the number from the division. Sure, it has a similar effect to truncating the number, but that's not how it works.
Lambda, decorators.
...another low effort 'comparison' of data science libraries. These must drive traffic or something, because they keep popping up. Usually as a 'listicle' style article which just state the existence of a bunch of unrelated libraries without assessing any of their qualities or even giving anything more than a trivial example. TBH as a scientist I'm a bit concerned, 'data science' is so trendy that every idiot learns 3 lines of Python and starts to call himself a Data Scientist. People are promoting themselves as scientists with basically no qualifications or understanding of scientific methods.
Check out /r/bioinformatics if you haven't already!
Here's a sneak peek of /r/bioinformatics using the [top posts](https://np.reddit.com/r/bioinformatics/top/?sort=top&amp;t=year) of the year! \#1: [Thanks, Donald](https://i.imgur.com/tpqIcFd.jpg) | [124 comments](https://np.reddit.com/r/bioinformatics/comments/7s5uao/thanks_donald/) \#2: [I wore a Fitbit during my successful 4 hour thesis defence, here's the effect of intense questioning on my heart rate](https://imgur.com/a/XHBwAuU) | [14 comments](https://np.reddit.com/r/bioinformatics/comments/8q09lg/i_wore_a_fitbit_during_my_successful_4_hour/) \#3: [I thanked r/bioinformatics in my thesis defense today.](https://np.reddit.com/r/bioinformatics/comments/8cpsk8/i_thanked_rbioinformatics_in_my_thesis_defense/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Thank you for sharing. 
It looks like [Nuitka](http://nuitka.net/pages/overview.html) does what you want.
It requires one of two things: 1. The filesystem to store encoding information, or... 2. The POSIX standard gets updated to specify UTF-8 I think 2 is probably the better option. UTF-8 is the new ASCII. Don't get me wrong, I'm much happier with the PEP implemented in 3.7 than the situation before hand. At least now the system looks to be transparent, so what goes in, should come out. That's a huge improvement. 
I thought everyone always used the convention "import datetime as dt". This way it's always clear which is what: dt.date(...), dt.datetime.now(), dt.timedelta(...), etc.
[Odoo](http://learnopenerp.blogspot.com/2016/03/what-is-odoo.html) is an open source python framework, just try this.
&gt;But if it worked then everybody could have precisely the language subset they liked ! That's nothing like gofmt then?
What version of Python and what OS?
r/learnpython
Windows and 3.6.4 
I wrote a comment on my opinion a while ago https://www.reddit.com/r/Python/comments/8ex72p/pep_572_assignment_expressions/dy1uln8/ The revised PEP, which attempts to disable this syntax when the assignment equivalent is valid, is definitely an improvement, but I'm still not convinced. Something that recently occurred to me is that this is still very limited - you can't use any of the in-place assignment operators. I'm not arguing that we'd actually want that though.
`C:\Users\(your username)\AppData\Local\Programs\Python36`
Thank you so much :)
Thank you 
That'd be cool to see for sure.
Thanks for sharing !!
`as` keyword is already reserved for `__enter__`/`__exit__` magic methods.
Eh, shitty syntax doesn't kill languages. Just look at PHP - ugly, inconsistent and bloated, and yet it still as popular as Python.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
this helped me understand yield and generators https://medium.freecodecamp.org/how-and-why-you-should-use-python-generators-f6fb56650888
Didn't expect this to offend anyone! 
http://strftime.org/
No new list will be constructed, map is lazy in py3.
Remember that datetime objects implement `__format__` so you can do: print(f"{[datetime.datetime.now](https://datetime.datetime.now)():&amp;#37;Y-&amp;#37;M}"). There is rarely a reason to use strftime anymore.
Been reading the docs a bit, I don't think this will work either though I haven't tried again since first messing with it a week ago. It tries to edit the tags of an mp4 file associated with its audio file so it does have a title tag but it's track title. Not just normal title so I dunno if it'd work out the way I want. 
&gt; Expert. Knows when to use metaclasses but doesn't. Addendum: If metaclasses are to be used, use codegen instead. Metaclasses can quickly become a performance hog, which is hard to tame.
If you're wanting to support 3.6 but use dataclass, [there's a backport](https://pypi.org/project/dataclasses/). 
Because it's firmly entrenched in the web dev ecosystem. If I want to mock up an idea in a script and this stuff pollutes the syntax to the point that it's a hassle to read, there is no point in using python.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Seems to work fine here: Python 3.6.6 (default, Jul 5 2018, 08:12:01) [GCC 7.3.0 32 bit] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from mutagen.mp4 import MP4 &gt;&gt;&gt; a = MP4("a.mp4") &gt;&gt;&gt; a {'¬©too': ['Lavf57.26.100']} &gt;&gt;&gt; a["¬©nam"] = ["mytitle"] &gt;&gt;&gt; a.save()
When I was just starting out with Python I used this exact cheat sheet as my 'to do' list, I'd play with each bit until I understood it, helped a lot, got me to play with code rather than passively listening, and was structured well.
I don't get the purpose of the records library. It is based on sqlalchemy, and doesn't seem to provide anything on top of it, except for one dangerous feature: caching iterated rows. It seems quite popular though, so maybe i'm missing something.
 # More comparisons 1 &lt; 10 # =&gt; True 1 &gt; 10 # =&gt; False 2 &lt;= 2 # =&gt; True 2 &gt;= 2 # =&gt; True Should the last one be: 2&gt;=2 # =&gt; False
What about French? /s
I don't know, Perl and Lisp were extremely popular scripting languages which are also known to be extremely ugly. My point being is that the correlation between success and syntax is very inconsitent to say the least. Sure Python is admired for it, but some languages that are just complete opposites are doing just as well. Maybe more appropriate thing to compare here is enjoyment of working with a language - the recent stackoverflow polls definitely correlate syntax and package management to enjoyability.
No. &gt;= is the "greater than or equal" operator, and since 2 is greater than or equal to 2 (it's equal) it returns true
Yep! I have no idea what I was thinking there. I am an idiot...
Can't test it right now but it means "2 equals or is greater than 2" which would be True.
Actually it is! 2 != 2 != 3 is False, while: (2 != 2) != 3 is True. Likewise you can do: a == b == c which check if all three variables are equal. It is very different from: (a == b) == c You can see that the fist example is actually a 3 operands comparison: &gt;&gt;&gt; print(ast.dump(ast.parse('a != b != c').body[0].value)) Compare(left=Name(id='a', ctx=Load()), ops=[NotEq(), NotEq()], comparators=[Name(id='b', ctx=Load()), Name(id='c', ctx=Load())])"
Pass by reference &lt;3
Faster may be better if it is as "random" as the `random` module. How does it compare with `random` in the statistical test suite(s)?
I like this more: [https://pyformat.info](https://pyformat.info)
Not 100% clear what you want. Maybe like this helps you further? https://regex101.com/r/uZHrDU/2/ If you use `re.sub()` you coul use `$1` etc to keep a capturing group in the substitution, like `$1--$2--$3`. Or if you want just the path grab group 2 from `re.search()`.
Mind Blow. On the one hand this is quite a nice feature. On the other hand: damn another subtle diffrence between programming languages to keep in mind.
To his credit, Kenneth puts a lot of effort to make extremely intuitive APIs.
‚Äú^([^/]+)(\S+)(.*)$‚Äù
Call me crazy, but as the same way with Maths, I prefer to learn this kind of concepts by applying it to concrete things, I mean: by solving problems. Otherway it's hard for my brain to remember pure theory that is not related to something that I fixed/used.
Because it's not neccessary in a dynamic language. You can do everything with `if / elif / else`
&gt;Taught myself
True, well, the cost of the load and call of `map` Likely to be negligible, it would be interesting to compare such a loop against the `:=` version I benched our 2 different forms on a short list on Python 3.6.5, turns out repeating strip() performs better python -m timeit 'lst = ["a ", "b "]; [s for s in map(str.strip, lst) if s]' 1000000 loops, best of 3: 0.827 usec per loop python -m timeit 'lst = ["a ", "b "]; [s.strip() for s in lst if s.strip()]' 1000000 loops, best of 3: 0.76 usec per loop 
That's EXACTLY my position right now. I did the same as you and being in a small company and working my way up I gained insight on nearly all business processes my coworkers have to deal with daily. There is so much automation potential that I am regretting not having started with Python earlier! Check out "Automate the boring stuff" by Al Sweigart - it has very good explanations to basic Python concepts and a lot of inspiration on what you can automate (which is surprisingly difficult to think of if you just started out with Python). It's very exciting to get my coworkers into the mindset of "do I really have to do this manually?" as it is a win-win situation!
Why use regex for this? It's such a simple thing to do with string applying instead and will be much easier to read and maintain. Regex is great but IMHO shouldn't be the first thing you reach for. But for regex why not be explicit with the strings you want to match? `re.sub('^(Lock on).*(acquired by)$', '\1 .* \2')` 
That's not breaking backward compatibility, that's just not being forward compatible (old version not supporting new features). Breaking backwards compatibility would mean that old code would break and need to be fixed, like what happened with the transition from Python 2 to 3.
Reinstalling the OS would likely cause you to lose everything, so backup everything you want to keep. https://support.apple.com/en-us/ht204904 But before you do, you should post here how exactly you managed to delete the OS installed python? This is not something that's easy to do. 
Except that's not, that's a regular serializer class. What my lib does is: from marshmallow_annotations import AnnotationSchema from .music import Album, Artist class AlbumScheme(AnnotationSchema): class Meta: target = Album register_as_scheme = True class ArtistScheme(AnnotationSchema): class Meta: target = Artist register_as_scheme = True scheme = ArtistScheme() scheme.dump( Artist( id=1, name="Abominable Putridity", albums=[ Album( id=1, name="The Anomalies of Artificial Origin" ) ] ) ) # { # "albums": [ # { # "id": 1, # "name": "The Anomalies of Artificial Origin" # } # ], # "id": 1, # "name": "Abominable Putridity" # } No fiddling with fields. If you add a `class Fields` to the Meta definition then you can set field constructor arguments. https://github.com/justanr/marshmallow-annotations check out out, I think it's kind of neat.
You could store each reading in a pandas dataframe (and output to a .csv file), then just group them by the fridge number. 
You are a God among men. Thank you. 
If it works in matlab it works in python
When you compare PRNGs speed isn't the only important metric. Depending on the use case it may actually be a secondary priority besides factors such as uniformity (or rather "randomness") and cryptographic security (predictability). You're describing it as "general purpose", but what does that include? Which algorithm(s) are you using and what are their characteristics? Also this statement &gt; While it's probably unreadable for anyone other than me makes me not want to touch the library with a ten foot pole.
Then I need help because I can't get it to work. 
What kinds of analysis are you looking to do, and why?
Where are the performance comparisons? Python's random is written in C as well and uses a decently fast algorithm, so I'm not sure how you can make a 20-90 times faster implementation without sacrificing all of the random quality. 
r/learnpython
Thats how I got started! That and Clever Programmer on youtube and a few other guys. 
Im trying to do some analysis on how fanbases grow and change over time, using their user join date, and what story category they wrote for.
Unless you save it: &gt;&gt;&gt; mult = lambda x, y: x * y &gt;&gt;&gt; mult(2, 3) 6 
yes
The Universe as LUN is my takeaway from this.
The final result was BDFL 1 The Rest 0. If you don't like that it's just tough as it's his language. You can obviously fork it if you want but you can't call it Python as the PSF owns the trademarks and suchlike to the Python name. Here endeth the lesson.
I've added it. :)
I've added it :)
Alternately, when you have functions you can define anywhere, why not allow multi-line lambdas? Just convert `lambda x, y:` into `def __GENERATED_UNIQUE_NAME__(x,y):` The traceback might be a little wacky because you would have this generated name that you have to identify as being the lambda, but why wouldn't that work? For me `lambda` means: "I need a function, one time, one place, and don't want to bind a full name to it for reuse." I'm perfectly happy with it being a function, I just don't want to have to come up with a name for it. 
To me Arrow is superior to anything else out there, it should be in the standard library. It's even more noticeable when forced back to datetime.
If you just need the Jacobi method, [here](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jacobi.html) is a prebuilt implementation for you.
That is his point. They have preemptively banned a syntax far in advance of it being released, much less deployed onto their servers.
Can you help me implement it? I'm not sure how the values work with respect to a 3d variant. I assume I repeat the process three times? 
Interesting that the author of the Zen co-authored this PEP. I'll also assume that you don't understand the humour in the line from the Zen that you quoted.
You can try [this](https://github.com/maroba/poisson) - it seems to do exactly what you want.
Maybe stupid but... what if you wanted `b` to point at `a` rather than what `a` is pointing at? Can this be done in a reasonable manner?
A bit late now. Perhaps when the ternary operator was approved but that was decided on 29/09/2005. Blimey, seems like yesterday. Also note that several PEPs have been delegated to other core devs who have more experience than the BDFL in the area being discussion.
So what is the alternative to have new visitors discover your old post?
I don't understand why you wrote this here.
The BDFL has all ready stated that it will be accepted.
&gt;If anyone could help me get it ready for distribution on pypi I'd appreciate it (and credit you of course). When you build an rng, you will be asked: * What algorithm is it? * Where are your tests for randomness? You should run against a test suite like diehard or practrand.
Python is exploding according to many people on the web and elsewhere due to PEP 572.
This post documents how I updated the code for my [scikit-learn video series](https://www.dataschool.io/machine-learning-with-scikit-learn/) from scikit-learn 0.16 &amp; Python 2.7 to scikit-learn 0.19.1 &amp; Python 3.6. If you just want a copy of the updated code, you can [download the Jupyter notebooks from GitHub](https://github.com/justmarkham/scikit-learn-videos).
Thanks. I've looked at the link you shared and although it seems to contain elements of what I need, I don't think it lets me use my array (with values generated earlier in the code) and solve it from their. I also, don't understand how to implement it. I'm not the best at inserting other code into my work (no formal training in python etc).
In the movie version the woman wasn't real.
Yeah, but that's basically the same thing as def mult(x, y): return x * y I'm not 100% sure about how python handles the difference between the two, but it might be slightly less efficient to use a lambda in this case. I should run timeit tests, but I'll probably forget.
I actually prefer metaclasses to code generation. Code generation is ugly and a pain in the ass to maintain. The one time I wished metaclasses were used where they weren't was when I had ugly swagger autogenerated code polluting up my code base.
&gt; what do I gain... Nothing except a hard-to-read mess. That is not true. What you gain is the direct association of the `whatever` function with its use as an argument for the `something` function. It makes clear that `something` is not a normal function, but actually an operator/functional that takes a function as its argument, and it makes clear that `whatever` is unused outside of `something`. It clearly and directly ties the two together. Now I agree that there is risk with multi-line lambdas that the lambda could become too complex and that the trade-off could shift towards the "hard to read mess" side of the equation, but there is a middle ground where a multi-line lambda may be useful. 
'INFO [org.apache.hadoop.hdfs.server.common.Storage](https://org.apache.hadoop.hdfs.server.common.Storage): Lock on /home/james/hadoop-2.7.4/hdfs/data/in\_use.lock acquired by nodename 12243@deimos27' for example with above string i want to replace ' /home/bctak/hadoop-2.7.4/hdfs/data/in\_use.lock' to '.\*' so that it turns it into 'INFO [org.apache.hadoop.hdfs.server.common.Storage](https://org.apache.hadoop.hdfs.server.common.Storage): Lock on .\* acquired by nodename 12243@deimos27'
&gt; 'INFO [org.apache.hadoop.hdfs.server.common.Storage](https://org.apache.hadoop.hdfs.server.common.storage/): Lock on /home/james/hadoop-2.7.4/hdfs/data/in\_use.lock acquired by nodename 12243@deimos27' for example with above string i want to replace ' /home/bctak/hadoop-2.7.4/hdfs/data/in\_use.lock' to '.\*' so that it turns it into 'INFO [org.apache.hadoop.hdfs.server.common.Storage](https://org.apache.hadoop.hdfs.server.common.storage/): Lock on .\* acquired by nodename 12243@deimos27' 
Building on simple projects that I started ages ago. I'm currently working on a dice rolling simulator that provides graphs, charts, etc of each roll, using tkinter, and Matplotlib. 
You can use cython to compile sensitive modules to dlls and then make exe by py2exe. Py2exe and other tools just pack pyc files
It‚Äôs not a tutorial though (although it includes the Python docs).
How do you prevent it from hitting the "prove that you're not a robot" check? Which with default user agent and no specific headers is hit pretty soon in my experiences. I can't see anything in the code that would evade that.
Right, i agree that it may make it more efficient, but to me python has always been more about simple clean code than that kind of optimization. Also in py3 map makes a generator so it shouldn't be an issue. 
Another "comment from elsewhere": https://www.reddit.com/r/Python/comments/8vmq27/z/e1rd6fo
How depressing that this has been going on for two months
It uses noVNC and xterm.js on the frontend. All of the backend is custom.
It just doesn't make it into production code. I think part of it is because it is slow but I don't know all the details.
Asyncio is all very new but it can support tens of thousands more connections than you can with threads. Channels documentation is kinda limited to what is on read the docs but there are example projects as well.
"if hasattr(x, "\_\_reduce\_ex\_\_"): rv = x.\_\_reduce\_ex\_\_(4)" is inefficient because hasattr() already does an attribute lookup internally and then drops the result, then "x.\_\_reduce\_ex\_\_" does the same lookup again. About correctness: in some weird cases with weird objects, two sequential lookups can give two different results. ["Easier to ask for forgiveness than permission" (EAFP)](https://docs.python.org/3/glossary.html#term-eafp) is safer than ["Look before you leap" (LBYL)](https://docs.python.org/3/glossary.html#term-lbyl). Example: "In a multi-threaded environment, the LBYL approach can risk introducing a race condition between ‚Äúthe looking‚Äù and ‚Äúthe leaping‚Äù."
So don't use dataclasses until PyPy3 supports them. 
It's the same code, but in 3.7 it comes bundled in the standard library, what's the problem? 
Second this 
Lots of people can write CSS. I've only met a few who can write \_good\_ CSS. You need to adhere pretty strictly to some style guide like OO IT BEM or whatever.
Sure! It just doesn't need the bad tagline.
From where I'm standing, Kenneth Reitz uses *for humans* to indicate that he works hard to make his APIs easy to use and understand -- and he does, and they are. His results live up to the slogan. To say *for humans* is often an empty slogan may be true, but to say the slogan is empty in his case is not cynical but wrong.
The absence of future imports is going to be a massive problem for python 3 in the future. What is the future of pypi? Its bad enough how long it is taking to get people off of python 2, but what version of python 3 are they going to adopt? And what version should python libraries support? We just turned a python 2 vs 3 problem into a python 3.0 vs 3.3 vs 3.5 vs 3.6 vs 3.8 problem... so much winning!!
It's exactly the same: In [5]: def mult_defed(x, y): ...: return x * y ...: In [6]: mult_lambdaed = lambda x, y: x * y In [7]: import dis In [8]: dis.dis(mult_defed) 2 0 LOAD_FAST 0 (x) 2 LOAD_FAST 1 (y) 4 BINARY_MULTIPLY 6 RETURN_VALUE In [9]: dis.dis(mult_lambdaed) 1 0 LOAD_FAST 0 (x) 2 LOAD_FAST 1 (y) 4 BINARY_MULTIPLY 6 RETURN_VALUE In [10]: %timeit mult_defed(1, 100) 109 ns ¬± 3.42 ns per loop (mean ¬± std. dev. of 7 runs, 10000000 loops each) In [11]: %timeit mult_lambdaed(1, 100) 106 ns ¬± 2.16 ns per loop (mean ¬± std. dev. of 7 runs, 10000000 loops each) But as was mentioned in other comments, the `def` functions get parsed and defined at startup, while lambdas get evaluated (and created\*) at runtime. \* That also means that lambdas inside loops can result in a performance hit since you're creating the function on every iteration. The easy fix is defining the funciton beforehand, either with def, or assigning the lambda to a variable. I may have fixed my share of "slow code" which was abusing lambdas inside nested loops.
I don't know your exact use case, but it looks like it'll be a simple web app. Django is a good framework to do that, but for something simple I'd use Flask. Flask Tutorials: https://www.youtube.com/playlist?list=PL-osiE80TeTs4UjLw5MM6OjgkjFeUxCYH I personally host my small apps like that on Heroku or my own server (Raspberry Pi). How it'll be used? How big you want it to be? Will it only be an Excel document generator or something more? 
Hm... not 100% sure about which of these was the coolest. - My first Slack application is worth noting. I did some work to get a workspace on the free plan to use UserGroups, normally only available on paid plans. Until that point we tried solving it using Slackbot which would react with pinging people in a response. However since it didn't invite those people into the channels if they weren't in there, I made an application that handled the invitations. Only later did I figure out it was part of the paid plan... While testing my implementation I found a temporary server side issue at Slack, which was then fixed on a weekend. Kudos for slack for fixing it so quickly. - The second one was a proof of concept application I made to prove to my university CERT team that when combining the different systems students could access, it was possible to gather personal data on over 20k students, both current and historical (basically all students from the last 10 years since they created one of the systems). I made a small tool where a student could log in, and it would create PDF files with full records on a class of students. From initials, full name, student email addresses, internal usernames, personal email addresses if available to any data their part of university supplied as well. They didn't listen to me before, but once I gave them a couple of the PDF files of random classes it got fixed within 2 hours. 
Python2 and mongodb...has hell frozen over?
&gt; There are no ready solutions? Plenty just not in the Python ecosystem. &gt; Is it complicated? Totally dependent on your skill-set. If you're comfortable working with an ORM like SQLAlchemy I can't imagine its difficult to add a forum onto your CMS of choice.
While I agree with the general sentiment, shorter code is not always more readable code, as is with the while loop example. If thats the example you use to say 572 shouldn't have gotten vitriol, then your supporting point barely has any ground.
Well... did you notice... you just mentioned 3 different systems 'conda', 'pipenv' and 'virtualenv'? And I bet there are others, that you didn't mention. That kind of fragmentation is exactly what I'm talking about when I am calling it a 'mess'. I have used virtualenv, and tried conda. To be honest setting those things up was a bit of a Pita and its certainly not clear as a 'beginner' which one of the numerous options you should use. Also as a bit of a 'casual' user using Python only on rare occasions, I find it rather cumbersome to figure out how to make them work properly every time I need them (somehow this stuff feels hard to remember to me, when I don't use it on a daily basis, but maybe its just me :-)
How should I advertise this.
That *really* depends on which package you mean. Many are fine with, say, subprocess and sqlalchemy over delegator and Records. Evem Kenneth is overusing his own tagline. In the Python world, he has made "for humans" synonymous with "Kenneth Reitz", rather than "intuitive software, which usually comes from Kenneth Reitz".
Yea I need to upgrade to Python3. No love for monogdb tho?
If I may ask, what use do you get out of it? I'm usually okay with datetime + dateutil (not always needed) + pytz. Never used arrow, so I'm curious what it brings to the table.
Do you mean delegator? Because subprocess does too...
It has another nice feature, converting to different formats, ex json, but the use you get out of that depends on your project.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Actually it turns out I didn‚Äôt delete python however I did delete some important python files. After typing ‚Äúeasy_install‚Äù in terminal rather than getting a warning saying there was no input after the cmd I get this: ‚ÄúImportError: No module named pkg_resources‚Äù. I‚Äôve searched everywhere online and no one seems to have the same issue as me or the solutions provided simply don‚Äôt work. I don‚Äôt know what to do. If you need any more information I would be happy to provide it. I haven‚Äôt reinstalled the OS yet since it will take about 3hrs but would that set everything back to the way it was. I‚Äôve already backed everything up.
Mongo is fine for some projects, but a bit overkill for something like this. And a bit underkill for other things. Something something "but mongo is web scale", no it isn't, and even the creators are in on that [joke](http://www.mongodb-is-web-scale.com).
*Thank you*. Other people on this sub keep saying I'm making a mountain out of a molehill and that it's easy to drop support for Python 3.4/3.5/3.6 for 3.7/3.8 features. It isn't. 3.0-3.3 is another thing though, there were so many issues in those releases it really should all fall under Py3.0beta, in my opinion. Haven't seen much use or need to support those.
One confusing thing about object comparison is how Python handles integers: a = 42 b = 42 a == b # =&gt; True a is b # =&gt; True c = 4242 d = 4242 c == d # =&gt; True c is d # =&gt; False c == e # =&gt; True c is e # =&gt; True `c is d == False` because integers in the range of `[-5, 256]` are assigned by cPython to dedicated memory locations - so their `.id` is the same. I guess this makes sense in the range `[0, 256]`, but I have no idea why they chose to pre-assign `[-5,0)` as well. 
Can any of the mods create a cheat sheet section. This type of post keeps on popping up.
Assignments *don't* return their value though. The example you used just uses `DUP_TOP` to mirror the right most side to the left. The reason why they didn't change it to do this like many other languages is because it is far too late in the game to do so. It breaks forward compatibility even more, arguably, swallowing code that would previously be a syntax error. They don't want another 2v3 debacle.
Interesting. Thanks for the link!
Some of those wats are garbage though. Like the "converse implication" stuff-- booleans are integrals, 0 or 1. Take those numbers and use exponentiation and you get the same result.
Thats a reply link and makes me log in
r/learnpython
&gt; format is the old way. Really? I‚Äôve never seen that in the docs. https://docs.python.org/3.6/tutorial/inputoutput.html#fancier-output-formatting
To go with that, "as" works just fine within an import and within except clocks. So `as` already has a different behavior depending on where you see it. Both all those 3 are pretty corner cases (inside import-statement, inside except-statement, inside with-statement).
I'm having a weird issue in a project using numpy and PIL - saving 16 bit PNG doesn't work, PIL chokes on the data expecting more data - but saving at any other bit depth works as expected. Also, I don't understand why I need to do normalization to 8/16/32 bit/float manually when saving with PIL. It is just awkward to provide a modular interface where you need to expose another parameter just for the user to give a bit depth. I really am out of idea, and if anyone wants to help, here's a link to the [GitLab issue](https://gitlab.com/solarliner/terrainlib/issues/2). The project is a library for modular landscape generation, aimed at artists, that I called [TerrainLib](https://gitlab.com/solarliner/terrainlib). I am looking for volunteers to help me with various tasks (like native English speakers for proof reading and others for translation, if it is possible with Sphinx).
Metaclasses. I want to make base classes and other base classes that build on top of the base functionality. But I always get metaclass conflicts and no way of resolving them despite ending on page 3 of several different Google searches.
File&gt; setting &gt; project interpreter &gt; +
lol. I didn't even realize the irony of "it's easy, just choose one of these three arbitrary choices!" I'm sure there are plenty of others out there, but those three are the main options, with conda being the outlier as it's mainly targeted at science and engineering applications (which is what I do!). It's certainly not clear as a beginner which one to choose. I started with virtualenv, then switched to conda (mainly because the environments are stored globally, so I can activate them in any directory). There are probably more options, but I don't think it *really* matters which one you choose. It's just whatever works best for your workflow. Conda generally works great with mine, plus I normally install python on a system through Miniconda anyways, so there's that convenience too. As far as making them work, I'm relatively casual too. I'm an engineer first, I only program for utility (sometimes fun too, but it's always for a purpose). &gt; I find it rather cumbersome to figure out how to make them work properly every time I need them The primary reason I use conda is because it's really simple to activate and deactivate environments: \`activate &lt;ENV NAME&gt;\` and \`deactivate &lt;ENV NAME&gt;\`. Because the virtual environments are accessible globally, I do that from any directory, and I can get the environment I need. &gt; somehow this stuff feels hard to remember to me, You're not the only one. If I had a dollar for every time I had to Google how to do a simple task that I know I've done before, I'd have enough money to hire an actual programmer. lol. Personally, I've accepted my fate as far as that goes, to it's not as much a barrier to entry to me. If you have any specific "why do I do this?" or "How do I do this?" kinda questions, let me know. I'd be happy to help. 
You can import. You have imported the packages. Grey lines mean you haven't used them yet. Once use them, the color will change. Hover your cursor over the lives for more details. Happy Coding! Bonus: Use `import numpy as np` instead of that. You'll be using it frequently that's why.
Ah true, I was just thinking of it as a place to practice writing code on phone. 
Wanted to add the other side of this is I developed all of this at home nights and weekends, if I developed on company time I ikely wouldn't be able to share. With that in mind I wanted something I could run on my linux machine at home, macbook when I travel, and on my work machine without incurring any significant costs or licensing issues.
People just dislike new features added to their favorite historied program languages. It adds a new syntax that's useful in certain situations. If you don't like it don't use it but you should still understand it. If you think that it hurts python you're just being stupid.
Top comment yet I don't see what you're trying to say whatsoever
How is it hard to understand. It assigns then returns the assigned value.
More low rent, content-less Medium SPAM, topped with a healthy serving of linksynergy redirect referral rabbit holes, landing the user on Udemy's front porch.
Great Materials
Wait... WTF did I just read? :O
If you are worried about such low-level efficiency, you should be damn sure of what you're optimizing - variable creation and assignment and cleanup ain't free, either. Heavily optimized code often tends to be the opposite of short and clear - loop unrolling is a good example. But in any case, the snippet was brought up in the context of readability, not efficiency. 
You say this in jest, but I watched a video of his on a whim (a pycon one, maybe?) and was so impressed, I decided to learn Python. Only later did my team hire a bunch of ML people who were already doing it, so the timing was serendipitous. But I saved that video and re-watch it, now that I know more what he's talking about.
Does this look beautiful? Is this explicit? Is this simple? Is this flat? Is this readable?
You can submit a pull request for that, the learnxinyminutes.com source code is on github. 
Oh, wow.. All the `bit.ly`'s.
Very cool! I've always wanted to see what a lineup-simulator code looked like. &gt; plt.title('Earlier batters have more At Bats on average') That should be "Plate Appearances" and not "At Bats". (Walks, hit by pitches and sacrifices are plate appearances that do not count as at bats). This explains much of the study too. The end of the game can occur at any point in the lineup so each lineup position is worth an extra 18 (=162/9) plate appearances per season.
Why don't you just use JS for web?
Good catch! Thank you for the feedback.
I would like to deploy ML models and python has the easiest interface. There's a nice effort towards JS now since Google announced TensorflowJS but it's just too far behind. 
Thanks, the first two seem especially useful. 
This discounts things like power and speed. A .250 batter who hits 50 HR will get more value hitting in the middle of the lineup behind higher OBP guys than hitting towards the back of the order. Likewise, a high average low power guy won't do as well in the middle. A speedy guy hitting #2 behind a high OBP guy in the #1 spot might save some double plays by beating out throws, or advancing to second before the player behind him hits a grounder to a middle infielder. .OBP and/or K/BB is a much larger factor than batting average. I'd also like to see some correlation in BABIP in there as well. For certain, batting order matters. You don't put Alcedies Escobar in the number 3/4/5 slot. Likewise, you don't put Harper, Judge, or Trout in the 7/8/9 slot.
Just to blow your mind a little more, maybe: "strin" + "g" is "string" Is True, while: s1 = "strin" s2 = "string" s1 + "g" is s2 Is False!
I agree. That while loop example is really difficult for me to read. I can tell anytime I see that in some code base, it's going to take more way more time to read and understand then if it was just broken out. Saving a few lines at the cost of readability is really tough to stomach, imo. My company is very unlikely to allow that type of confusing syntax. They also don't like ternary operations for similar reasons, legibility is sacrificed for saving a space. Is the space savings really worth it? Just my thoughts. I'm not angry about it but there's no way I'd use it myself.
Both great answers I could definitely use.. Any other suggestions? 
Yea, I was hoping for a more official solution that works with everything.
I don't know much about statistics beyond the capabilities of what's in [statistics.py](https://statistics.py). With that, I've done billions of tests on all of the functions on 32/64 bit with both generators to make sure the results are within 1/1000th of both the MT and urandom implementations from [random.py](https://random.py). This doesn't actually mean anything but it's trippy to look at this static: [https://i.imgur.com/boueXZl.png](https://i.imgur.com/boueXZl.png) was generated with \`os.urandom\` and [https://i.imgur.com/zZs4KAe.png](https://i.imgur.com/zZs4KAe.png) with xorshift128. This is hilarious. I was going to post an example of one of my stat tests (for \`rand\_int\`, specifically). Ran it and discovered it hangs on \`rand\_int(1152921504606846976, 45)\` and in general is just never going over 60 bit. Its going to have to wait until tomorrow but hopefully I can restore a version without breaking the current setup that I didn't think I needed to keep backwards compatible...
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
&gt; I didn't claim PHP has keyword arguments I thought you were implying that with: &gt; this keyword thing is just playing to folks who only know PHP or something. That link shows default arguments, not keyword arguments. I'm not trying to be rude, I'm just confused by what you're saying. &gt; Or the decorator, or a metaclass, could use the presence of mixins to create these memoizations up front. Hmm. I suppose thanks to `__init_subclass__` this could be done cleanly with some mixins, at least for the default case. Something like: from dataclass import DataClassMixin class Foo(DataClassMixin): bar: int But this would fall down when you want to mix and match what's generated. Say, if you wanted no repr / the default repr, but to add Order and Frozen: from dataclass import InitMixin, EqMixin, OrderMixin, FrozenMixin class Foo(InitMixin, EqMixin, OrderMixin, FrozenMixin): bar: int I still don't see what's so confusing about the keyword argument and decorator approach.
yes, and it' more art than science. that's why they haven't automated the manger's job.
xorshift128+ for 32bit and xoroshiro128+ for 64bit by default. [http://xoshiro.di.unimi.it/](http://xoshiro.di.unimi.it/) \- according to my interpretation reading their papers, as long as the lowest 2 bits aren't used they're statistically equivalent. Since xorshift128+ performs about 10&amp;#37; better on systems without a 64 bit ROL instruction it's worth the difference imo. I wanted to allow a choice at run time but that would either require doubling the size of the already massive 100KB binary to keep function inlining or take a huge performance hit with function pointers.
So how does your module compare to, say, [this](https://github.com/ihaque/xorshift)?
Same, I‚Äôm pretty new to Python and this was just too much first read through. Second read through, makes perfect sense!
I am afraid my Django skillset is not so good. Can you suggest Python forum package and Python CMS that offer the easiest integration between each other? Or it doesn't matter?
I believe os.walk now uses os.scandir internally so there shouldn't be any performance penalty for using os.walk
The scheduler is likely storing things in memory, so unless that data is stored somewhere else between runs, no. But why do you want to do this? Repeatedly running the script incurs the following penalties 1) OS has to create a new thread. 2) Python interpreter has to load/import modules. I dont have the link, but IIRC Guido did a write up awhile back on how the cpython interpreter (and maybe all Python interpreters) need to improve start up time. 3) Data has to be stored somewhere between runs. Lets pretend its files. 4) youve now incurred open and write times when the script closes. 5) youve also incurred open and read time when the script starts. This is a bad idea, if you have something that needs to fire repeatedly, you should find a way to parallelize it.
Question about pendulum, or other "drop in replacements", if they truly are drop in, why not push for these features to be added to the original datetime package?
Examples of statistical tests you can perform with your RNG are the [Diehard test](https://en.wikipedia.org/wiki/Diehard_tests) and the tests implemented in [TestU01](https://en.wikipedia.org/wiki/TestU01) (which you could just feed the results of your RNG into). As those pages talk about, draws from your RNG should follow certain distributions for your RNG to be considered "good". For many applications this doesn't matter. But, for instance, if an RNG is used in a scientific application, then the failure of an RNG to be close to truly random can seriously bias results. Either way, good for you for making your own! It's a fun exercise.
**Diehard tests** The diehard tests are a battery of statistical tests for measuring the quality of a random number generator. They were developed by George Marsaglia over several years and first published in 1995 on a CD-ROM of random numbers. *** **TestU01** TestU01 is a software library, implemented in the ANSI C language, that offers a collection of utilities for the empirical randomness testing of random number generators (RNGs). The library was first introduced in 2007 by Pierre L‚ÄôEcuyer and Richard Simard of the Universit√© de Montr√©al. The library implements several types of random number generators, including some proposed in the literature and some found in widely used software. It provides general implementations of the classical statistical tests for random number generators, as well as several others proposed in the literature, and some original ones. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; I still don't see what's so confusing about the keyword argument and decorator approach. it's not confusing except it's what's known as "there's more than one way to do it". that is, the language presents many options and alternatives, built-in and all slightly different, that all sort of seem to do the same thing, but aren't *quite* the same. This sows confusion and creates for APIs that each have shortcomings against each other. This is why "import this" says "There should be one-- and preferably only one --obvious way to do it.". as for keyword arguments, the dataclass has a fixed set of arguments: @dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False) First issue, why do "__init__", "__repr__", "__eq__", "__le__" get special treatment? dataclass() seems to be a function so we can't subclass it, should we be expanding on this approach for all the methods we want to add? What if I want to define "json=True", "xml=True", "store_in_mysql=True"? These are also methods that would benefit from an up-front scan of the attributes to form a template for these kinds of serialization. Is it a good idea to turn them into keyword arguments also ? If we say "no", then the system is just non-extensible and inconsistent with itself (repr() and str() are after all forms of serialization). If we say "yes", then we get into the namespacing / too many keyword arguments problem. If I can go onto pypi and download all kinds of dataclass extensions, now you have a namespacing problem - one person's "persist_mysql" is not another ones, libraries that provide dataclass plugins start to collide, etc. This is why composition is favored for an extensible system. In the "we say yes" category, I saw this and shuddered that folks are going to want SQLAlchemy to start working this way. Which would have to be "yet another way", with its own bugs, shortcomings, inconsistencies against all the other ways that still have to keep working. oh and I maintain SQLAlchemy. 
The code you posted fails because the array `res` is never declared, for example as an empty array: res = np.empty((maxpoints, maxpoints, maxpoints)) As long as `res` is only used in the inner loop you could simply use the scalar `res` rather than an array with indexing. Depending on the type of iteration being used you might instead want to set `u = factor * res.copy()` after the `for` loops (but still inside the `while` loop). 
This is a great post 
One advantage of python, like C, is that the whole syntax can basically fit in your head. Each new syntactic feature threatens that. *Some* syntactic features are so good, so yummy, or so self-evident once you've been introduced to them, that they either *lower* the total mental overhead or they are worth the cost in some other way. For example, f-strings are f-ing awesome! PEP572 is not immediately self-evident to me, and the benefits are... very, very close to the cost. Maybe it's worth it? I haven't seen any examples where it actively made code significantly easier to read. Which is not to say that PEP572 isn't a nice feature... but it has a cost, and I'm not sure I want to pay it.
Here is code to do what you requested... This does not use the path name ... instead it looks for the "Lock on" and "acquired by" key words. import re data_in = 'INFO org.apache.hadoop.hdfs.server.common.Storage: Lock on /home/james/hadoop-2.7.4/hdfs/data/in_use.lock acquired by nodename 12243@deimos27' data_goal = 'INFO org.apache.hadoop.hdfs.server.common.Storage: Lock on .* acquired by nodename 12243@deimos27' exp = r'^(.* Lock on )(.*?)( acquired by .*)$' sub = r'\1.*\3' data_out = re.sub(exp, sub, data_in, 0,re.MULTILINE) print('Input', data_in) print('Output', data_out) if (data_out == data_goal): print('Succcess!! Output matches goal') 
&gt; What you gain is the direct association of the whatever function with its use as an argument for the something function. It makes clear that something is not a normal function, but actually an operator/functional that takes a function as its argument, and it makes clear that whatever is unused outside of something. It clearly and directly ties the two together. I think his argument is that if you define ``whatever`` immediately above the call to ``something`` (and name it ``_some_arg_function`` instead of ``whatever``) you can achieve almost all of what you are looking to get there. Yes, its not exactly the same, but it is pretty darn close. I've seen arguments over the right syntax for multi-line lambdas in python, and most of the options are not that pretty. Under the circumstances I think the small cost (that can be patched over as above) is not so bad under the circumstances.
Did I say that speed is the most important factor? I think I said that "besides quality, speed is the most important factor" somewhere in the documentation but I must have changed it because I don't see that line anymore. And I think it should be obvious that "general purpose" means "NOT for cryptography" (which is on of the first things mentioned in the docs). And while I was mostly being hyperbolic about nobody being able to read it (I hope anyway), feel free not to touch it with a ten foot pole. 
&gt;Maybe I'm just doing it wrong if there's more than one type of title tag, have you ever used it to edit the tags on video files? No, just to analyze tags, but the docs say it can edit so I assumed it could. 
I understand what he is saying. I just disagree. I think its a big difference to pass a lambda to functional, vs passing a name to a function.
Thanks for making me learn what dogfooding is lol
There's plenty of existing python features that are easily abused to the point of not being readable (like nested list comprehensions with lambdas and using "(boolean) and value or value" to top it off). I don't necessarily like this PEP, but I will use it sparingly. It is no more or no less fuckuppable than the rest of python, so if someone fucks it up, it's not going to be this pep's fault. 
If you use indentation in order to delimit code blocks, defining a multiline lambda is a bit trickier - what syntax you would propose? Remember the Python parser cheats in order to avoid the need of a recursive parser.
Not saying there aren't abused features nor that this feature is being abused or not in this post. Just that for a sentiment of "it is readable", *that* example fucking isn't. I mean I like the PEP. Just pointing out that example didn't strengthen his argument, it weakened it.
I will second pprintpp, I had nested dicts where the internal pointed into the outer (don‚Äôt ask) and it handled it just fine and was very useful to my project!
&gt; what syntax you would propose? I've always felt that semi-colons and braces should be an optional alternative way to indicate statement endings and scoping, but that indentation should take priority, and if there is any conflict that it should be a syntax error. So with that in mind, I would think say that `{lambda x, y: z=x+y; return z}` would be fine with me. &gt; Remember the Python parser cheats in order to avoid the need of a recursive parser. Not my f-ing problem. Everyone hates the limits of CPython anyways (the GIL and all), so I don't know why design choices in the implementation of CPython should dictate the language design. Only if your target environment is super constrained and cannot host a fully recursive parser does it make sense to me that you would limit the language based on the parser. 
The `Deflate` object in `compression.py` sets attributes that aren't defined in `__init__`. This is a poor design decision and makes it harder to optimize when you drop down to Cython or use `__slots__`.
Thanks I think I may have done this post writing my question. I can get the code to run but the iteration won't converge. :s I'll have a look and test it again though with this comment in mind. 
I don't know how optimized the `csv` module is, but earlier this week I swapped out the stdlib `json` module for `ujson` and got a ~10x speed up. You can also get at MINIMUM a 25% performance boost using `subprocess.Popen` to tar+compress files over the built in Python versions. I'd look for optimized modules before re-architecting your application.
This may look nicer to you, but it is obviously different code that will do different (but similar) things. It's inappropriate to pretend they do the same.
What did you use for plotting all of this?
:O how can i get it? (also student)
This library are unheard ..who knows if they are actively maintained or buggy ..I will probably stick to what I know 
Create an account with jet brains and it prompts you to verify student email (.edu) Type in code. Pretty simple. I think it‚Äôs good for a year. I‚Äôm not too sure but free is free
I've never used wxpython, I can't say if that will work with pypy or not. I like to use the multiprocess module. You can divide the work up between different child processes. You'll see the largest performance improvement if you zip the contents before they ever hit the disk. Writing plain text, then reading it, then writing the compressed version is a lot of unnecessary disk io. I would use the subprocess module and write my output to the stdin of gzip, writing stdout to filename. If you're on WIndows, I'm not sure how stdin or out would work.
Having heard about Pendulum a while ago, it's really sweet to see it pop back in here since I forgot about it. Great library compared to datetime!
You could easily discover that by exploring a little bit, but I will help you out: Inflection is very stable. It has a commit within the last year, and is 5 years old or more. I trust this one very much. The documentation is very straightforward with examples included. Pendulum is very active. The author, /u/sdispater, just released version 2.0 with some nice updates. The documentation is exquisite with lots of examples and great style. pprintpp is active. There are commits within 10 days. The documentation is adequate, and examples are included. Snakeviz is not terribly active, but it is stable. The documentation is straightforward with good examples, and the tool is very intuitive to use. Livereload is active. There is good documentation and examples flying off the page at you. py-buzz is active. I address bug reports as quick as possible. There are a couple of feature issues (I created them), but it's really stable. It's also in production use, by me and my team, so issues get addressed, patched, and shipped rapidly. I happily vouch for all of these packages; That's one of the reasons I wrote the post. I want others to know about them! Also...sticking to what you know is ok, but I really think you're missing out on some of the rich ecosystem of python. I've found so many amazing tools, libraries, programs, what-have-you by constantly expanding what-I-know. It's fun, and it will save you work and frustration. But, to each their own.
Yeah, I really like it. I used Arrow for a while, but it's not a drop-in, so you have to use a bit more glue with it. Also, I think Pendulum's approach to parsing, timezones, and manipulation is more correct. Also...the docs! just pretty
I believe "drop-in replacement" refers to the fact that it out puts a `datetime` object, and can therefore be used as an *input* to any function requesting a `datetime` object. Pushing it to be added to the original requires that there aren't any method or attribute conflicts between `Pendulum` and `datetime`. It also could interfere with other packages using `datetime` as a base class. That said, I'm all for improvements to `datetime`.
Isn't `c is d` false because you constructed two separate integer objects?
I'm going out on a limb here, but I'd guess that it's because Pendulum does more than Python's `datetime` does, and all of its functionality might not belong in the core. Every time you add something new to the core, it adds a responsibility to maintain it.
Is there any information on how these expressions do performance wise?
I'm fairly a beginner in python, I've never seen the &gt; := expression ? Can you please direct me to the pep that explains it?
Technically, yeah - but that would also lead you to believe that `a is b` would be `False`, when it isn't. :)
Thanks bro I will take my time and look into the lib ..thanks for informing us 
Do tell, what is the difference? 
Pendulum sounds interesting. I've been using [arrow](http://arrow.readthedocs.io/en/latest/#creation) for it's Moment.js like interface, though it gives me trouble when using them for my Django model fields as an `arrow` object is not a `datetime` object. I'll have to check it out!
Nice job. I'm curious about the nature of the transaction data. Ideally, this information shouldn't even be hitting a spreadsheet in the first place, should be going to a database of some form or another. I'm happy to help you any time, please feel free to PM me. Sometimes I do work on freelancer.com; I've never used someone else's services from there, but it's one place to consider.
The main reason I've always seen(when this is brought up about requests) is because the developers of the package do not want to be constrained by the Python release schedule. Why wait for all of this to get a PEP, go through all the channels and be discussed, just to have it added. Then any new features or fixes go through the same thing. Most devs would rather not. 
The maintainer of the backport is a core dev. Doesn't get more official than it being actually backported into 3.6 itself. 
&gt; If you're on a Mac, Linux, or Unix machine, you may need to type sudo before the command to install the package with administrator privileges. Do **NOT** sudo pip. It's a terrible idea. Use a virtualenv.
The original never makes hasattr calls, the modification makes a few. Even if the end result is the same, the operations performed are different.
That's really interesting. Is this type of issue common in interpreted languages? 
Thx for sharing!
 What I am looking at: [https://imgur.com/a/rtADhob](https://imgur.com/a/rtADhob) 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/y9ZTAXf.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e1uv22i) 
Interesting, thanks for publishing it. I'm all for people building their own tools if they feel the existing ones are missing something, or should have a different design, or whatever else is bothering them. That being said, I'm familiar with click and I think some of the arguments you bring up against it might not hold up against closer scrutiny. For example, you don't have to use decorators to construct a cli, with click which means you can very well re-use the same (imported) function in different commands. Also, the magic argument does not really apply, for the same reason. I construct my click-clis quite often not using decorators at all. Even if that's not the case, they are decorators, and I don't think there's any magic involved. But fair enough if you don't like decorators in general. I think they are one of the best features of Python, and actually under-used. Ah, and you don't have to use click.echo at all if you don't want to. It's just an optional helper function. You can just use prints if you want, but it's nice to easily be able to style output and have some encoding edge cases and piping issues dealt with automatically. Overall I'm really happy with click, and I'm familiar with it, so there's not really a reason for me to switch. Congrats on doing your own thing though, it's good that there are options and other ways to try things! Will keep an eye on it :-)
Um.. the original makes getattr calls, which are very much just like hasattr calls, check the Python C source. It all boils down to PyObject_GetAttr anyway. Secondly, the snippet is from `copy.copy`, the invoker of the function has absolutely no guarantee on what methods get called on the object how many times. Thirdly, an object with costs or side effects to hasattr calls is a ridiculously badly designed object. 
&gt;compiler &gt;interpreted languages Is it just me, or is something off about this...
Cool. I am trying to make an extremely simple baseball simulator as my first javascript program.
Inflection looks useful. Thanks!
It's probably because CPython is doing a bit of [constant folding](https://en.wikipedia.org/wiki/Constant_folding)
**Constant folding** Constant folding and constant propagation are related compiler optimizations used by many modern compilers. An advanced form of constant propagation known as sparse conditional constant propagation can more accurately propagate constants and simultaneously remove dead code. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt; the original makes getattr calls, which are very much just like hasattr calls But it's different code, isn't it. It makes different calls. That was my point--you're writing code that works differently, you shouldn't pretend like it's the same when it compiles. Don't pretend to be obtuse so you can win an argument.
While I understand the sentiment, it doesn't seem like `requests` is a drop in replacement
How do you feel about the biopython documentation? Do you have any favorite functions that you use? 
`format()` has been in python for a while, f-strings are new to Python 3.6 (here's the [P.E.P.](https://www.python.org/dev/peps/pep-0498/)).
This is the real reason why the argument about this has been contentious: There is a real gain in real code as shown by /u/godaygo here. However, IMO, this real gain is utterly worthless in light of how badly I expect this feature to be misused. Super against this PEP, but it's been hard to have a good discussion since people won't even try to understand the problem it's solving.
asyncio will only help for the FTP (parallel uploads), the file IO in python is blocking. Try curio, which supports async file io
Lord almighty. Even though x = 20 x -= 5 makes different calls than x = 5 x += 10 they're still the equivalent code. 
But which version did you download?
I've found it quite useful personally. I work with a couple bininformaticists who have been picking up Python gradually as a replacement for their old Lua/Perl/etc work. When I have been introducing them to some key libraries, like records or requests, they really seem to appreciate that the API "for humans" is straightforward to understand and utilize, and that every effort is made to keep gotchas and "it's not a bug, you're just unfamiliar with the implementation" occurrences to a minimum. Yeah it may seem cheesy, but the libraries do exactly what it says on the tin and it has definitely eased their introduction to the language.
It can be if your just fetching web content (over urllib). I was referencing requests more because the author released a statement with a similar opinion before.
ZzDummy is an example extension to idle, basically without function. The Python documentation says it is sometimes used for testing. Check down the page for [26.5.4.3](https://docs.python.org/3/library/idle.html)
Oh, now I get it. That seems broken. Is the 'is' keyword still safe to compare references? Or just not for integers, or what?
Inflection and Pendulum helped me a lot, thanks for sharing!
&gt;However, you can't reuse commands from multiple third-party modules in one CLI, which is what we want. That's because command reuse relations are defined with decorators, and you can't decorate an imported function. In other words, you can create a new player that implements seek and borrows play from player, but you can't add seek into player. That's just false. [This is all the more it takes](https://github.com/flaskbb/flaskbb/blob/114f5a8955b1360f923225a3d037405aec558cf8/flaskbb/cli/main.py#L46) class CLI(BasicCLI, SeekCLI, *MoreExtensions): '''The complete CLI that borrows from the basic CLI and extensionss. Notice that the class body is empty: the logic is already implemented by the parents. ''' pass This on the other hand looks like a nightmare to deal with. Multiple inheritance has rarely been the correct choice for things, and composing CLIs from it might be the grossest misuse I've seen of it. What happens when I have two CLIs that expose the same command? How do I have a sub-command, e.g. `docker container ls` &lt;- ls is a child of the container command. &gt; I believe DSLs should be avoided whenever pure Python is enough. A DSL requires time to learn, and the knowledge you gain is virtually useless anywhere outside the scope of the DSL, which is by definition the app it's used in. Something you should be aware of is that a DSL isn't just adding new syntax, but it's also how you interact with a particular library. This is also a DSL: @set_arg_map({'n': 'repeat'}) @set_metavars({'name': 'NAME'}) @set_help({'name': 'The greetee', 'shout': 'Set to shout the greeting'}) def hello(self, name, n=1, shout=False): &gt; Note that hello function accepts two positional arguments, count and name, but we call it without any arguments. That's because the params are added by the decorators based on the arguments of the decorator generators (--count and --name). This is broken code only forced to work by the magic of Click's decorators. You're not calling the `hello` function you defined, you're calling the wrapper that `click.command()` generates. &gt; Also, Click forces you to use its own echo function instead of the good old print. I'm sure this is justified but it still is confusing. It has to do with stdout and the various ways it can be horribly broken. [Here's the documentation on it](http://click.pocoo.org/5/utils/#printing-to-stdout) &gt; Cliar lets you define argument and option type with type hints. The logic is similar to Click's: if the type hint is given, use it, if not, infer the type from the default value, otherwise assume string: I do really like this. I wish more libs would do this. I look forward to seeing where this library goes, but I'd recommend learning about the decisions and choices that went into tools like docopt and click rather than speculating about them.
Isn't one of click's selling points its capability for modularity...?
Don't take this as an authoritative answer, but as I understand it this pep is essentially just syntactic sugar and as such should have negligible performance implications.
Thanks. Found it in the language reference under literals (2.4), not strings (6.1 of Standard Library), once I knew what to look for. Not at all in the tutorial. I guess I should figure out how to use the bug tracker. 
Rejected again by the BDFL just an hour or two back.
&gt; I wish more libs would do this. I believe this use of typehints has been around pretty much since the annotations PEP was published. [My own argparsing lib](https://github.com/letrhn/ergo) got the idea from [discord.py](https://github.com/Rapptz/discord.py)'s 'commands extension' feature, which apparently in turn was "inspired by a mitsuhiko argparse substitute"? And although I couldn't find them when I tried to just now, I did see it in a couple other offerings when I searched github for them to compare to mine a while ago. But my point is that the feature does pop up a lot, so I don't think it's anything to pitch as new, and the "inferring type from default argument" thing (which I do not think is a good idea, for what it's worth) has been around for even longer.
Well of course there can be library interferences but they'd remain consistent theoughout the same minor version-- there's only any conflicts if pendulum changes behavior of any datetime-existant classes/methods, rather than adds to it, because the supplemental libraries would just be overwriting things. Not to mention older versions of pendulum/datetime can be specified to be installed in site-packages.
If I may ask, what is the issue / friction with the Python release system (as I don't know any such requirements posed on me if I want my package added to the stdlib). I mean in an ideal world I'd be able to update at will and push to PyPI while Python can just pull in the most recent stable version of my package as they update minor versions, and update to the most recent stable relevant minor/patch version of that major version as Python increments their patch number (updating multiple packages at once, of course, else we'd get hundreds of patch versions).
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I only use `fire`. I've used it on tons of projects and it's just a delight to use. I can literally just throw `Fire.fire()` at the end of the file and be done
I half expected this to be a joke that says "Don't"
I meant specifically the type annotation thing, I went looking for examples a while back but only knee off apistar off hand. 
link?
Thanks for this list, things I didn't even know I wanted. Just so you know, 'Features' is misspelled in the table of contents on [this page](http://py-buzz.readthedocs.io/en/latest/).
If you are about to ask a "how do I do this in python" question, please try r/learnpython
Doesn't matter. You'll have to write an integration. You won't be able to. There are plenty of PHP-based software you can use.
I'd guess that the Matlab cov function has similar behavior, and iirc numpy is based on that.
Yeah it would be a good option for dataclass, I was kind of wondering about all cases though.
Not in all cases, but quite a few back ports exist in pypi, usually maintained by core devs or people close to the official lib. 
Codeswars? Pybites?
I was delighted to discover Inflection a few weeks ago. Our DB folks named tables and columns in CamelCase, but all our python uses snake_case. I was working on a simply python utility to automatically generate query code and generate corresponding python models. Inflection made it so easy.
Are you out of space? I would stick it on the ssd because its pretty small, but it honestly won't make much difference.
Async is just cooperative multitasking. It can‚Äôt make disk access faster if that‚Äôs your limiting factor. All it can help with is running more things at once, but that doesn‚Äôt seem to be a problem for you. 
Once a package is absorbed into Pythons core/standard it has to go through approval processes set in place by Guido Van Rossum and the Python Foundation. Every change or new feature therefore requires a PEP (Python Enhancement Proposal) which is a large length and overly scholastic article explaining everything about the change. That is the only way code becomes a part of Pythons core. I also believe that once a project is taken over the original repo is moved under the main Python account (I know this is how Django works at least). If you created a package and it was adopted into the Python core, then you would no longer have the original repo. You could fork the original repo to make changes instead of going through the PEP process, but then you no are no longer maintaining/adding to the original package, you have created a feature fork.
Never mind. I just finished reinstalling the OS and everything works fine now. Also, I didn‚Äôt lose anything.
Py-buzz seems a lot like that library you never knew you needed until you try it... That being said, don't Python 3.6's f-strings kinda make the formatting redundant?
Flask and Django are web modules.
I wrote my own structural engineering code to learn, and it was incredibly useful. Use some example problems as tests you can run every once in a while to make sure you didn't break everything.
Separate the input, output, and business logic. A simple FEA implementation is not hard to drum up. Get Logan (A First Course in the Finite Element Method) &amp; Menon (Advanced Structural Analysis) for a quick solution.
I doubt that you're going to find a remote services that supports the `webbrowser` module. The code isn't running in your browser; it's running on a server somewhere. Giving it the ability to open applications on your computer would be a scary thing to do. If your goal is to scrape web pages, though, `webbrowser` won't be of much use anyway. You should take a look at [requests](https://pypi.org/p/requests), [Beautiful Soup](https://pypi.org/p/beautifulsoup4), and [Scrapy](https://pypi.org/p/scrapy).
Thank you for the feedback and book recommendations. Will certainly give those a look as fem is a logical progression from the classical methods I have been using.
Never seen any benchmarks, but since the general recommendation is to install OS and computing related things (to improve I/O) on SSDs, I would also recommend SSDs in general. 
Yes, but I want to create an offline app which works like a diary or a journal. So I'm assuming a I need a database along with Qt?
https://hackernoon.com/nightmarishly-good-scraping-with-nightmare-js-and-async-await-b7b20a38438f
yes, absolutely. I wrote this when we were still on 3.5.
Yep! These are the exact kind of use cases a useful and compact library like inflection can save you from implementing. 
what does drop in meanÔºü
It means almost anywhere you can use a normal DateTime, you can also use a Pendulum DateTime. It's really handy if you need to do some timestamp algebra, because the native library is pretty cumbersome. 
good
nice sharing
as a bio student, create project to calculate DNA similarity
Can someone give u/dusktreader a +1 for ethics? I don't know if you noticed, but "5 libraries and one of mine" is a more honest way of saying "6 Amazing Python Libraries You Need to Use Today This Post Doesn't Have an Ulterior Motive At All." The latter are all too common in the world of clickbait and sponsored posts.
[this](http://learnopenerp.blogspot.com/2016/03/welcome-to-python-3-programming.html) one?
**Beginner**: Write a function that takes in a string of As, Ts, Cs, and Gs, and return the complimentary string (cause Adenine (A) binds with Thymine(T), and Cytosine(C) binds with Guanine(G) in our DNA :)). Bonus: add a flag that defaults to False called something like is_rna. If it's set to true, Pair the Cs to Gs but remember to pair the As to Us (cause in RNA we Uracil, and not Thymine). **Intermediate/advanced**: Given a lifeform, walk down the Linnaean classification chain. Example: &gt;&gt;&gt;Enter a lifeform: Dog &gt;&gt;&gt;Result: Animalia &gt; Chordata &gt; Mammalia &gt; Carnivora &gt; Canidae &gt; Canis &gt; Canis Lupis Start out with a basic set of allowed input, eg maybe allow inputs like "Dog", "Car", and "Rose" only. Then think about how you may generalize your program to work for more lifeforms. I'd say getting it to work in general would be quite challenging.
Thank you! This has given me something to work with! 
No problem :). Feel free to post your progress
Interesting, and laudable to want to turn ldap into a microservice. Out of curiosity, why not use native ldap[s] connectors? Or maybe replicate the Azure Graph API to provide compatibility with existing APIs?
That's like a complete medium post
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. *** ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
there's no huge hero image at the top. :(
Maybe I'm crazy, but if I wrote such a package, then I'd never want it to be in the stdlib. You go from being the BDFL of your own small package to being some highly regarded package politician that has to go through immense beurocracy. And sure I'd be fine with being a team player, but not the level of buerocracy that you describe.
I feel like the assignment expression will come most of use in 2 places: 1. The articles first example, as the condition in a while loop 2. In the if clause of a comprehension The first will be used for convenience and it honestly looks more nice and understandable. The second will be used to do something not possible with current list expressions, and which would be a lot more code without the list expression.
practicing writing classes by implementing chess... 
check portable python... it does not need installation and runs python... 
I can not connect any external devices that are not already approved. USB drives of any kind are unapproved. 
I've been using the SeqIO module to quickly work with sequences/reads. Overall just nice to filter or prepare them for further processing.
not even something like this: https://winpython.github.io/ no installation, no external drive needed. Its WinPython. 
But it requires a download. 
That's what this PEP adds, in Python 3.8. See the link from @andrewcooke above
&gt; Both have no obvious mistake. Lol well that depends on who's looking :) What are you expecting the output to be? Did you mean: [i^j for i, j in zip(lst1, lst2)] 
The format method was introduced in [PEP 3101](https://www.python.org/dev/peps/pep-3101/) on 16-Apr-2006, last updated on 14-Sep-2008. F strings were introduced in [PEP 498](https://www.python.org/dev/peps/pep-0498/) on 01-Aug-2015, last updated on 06-Nov-2016. 
ah. I guess I misread... i considered this as just a file download (which it technically is, like downloading a PDF) and not akin to downloading and installing software from the web... please ignore me!
You're fine! Thanks for the help. 
decorators
That's usually all I use with that too. I always feel like I'm under utilizing the library but next to the documentation of libraries like Qiime2 and ete toolkit, I end up finding a solution to my problem elsewhere or just end up writing my own solution. I want to use biopython more, but never have a solid use case to force me to take the dive.
This looks interesting. I don't have time to evaluate this for myself right now (I look forward to doing it at some other time, though) but my first impression is that the usefulness may depend on the particular use case and its complexity. I've mostly been using docopt so far and my guess is that for some CLIs docopt will be easier to use and for others your approach will. What I like about docopt is the flexibility it gives you in customizing the help text. It is, after all, something written for humans. With automatically generated help texts it is a lot more difficult (if at all possible) to influence the structure and add intermittent comments.
sounds right. Yield essentially jumps out of the function at that line and returns to start executing from the next line onwards when the function is called again... until it hits another Yield. Play around with the itertools module... pretty much all of the module is implemented as iterators, so you will learn to manipulate Yield. Right your own function with 2 yields and put the function call in a for loop and see the results. I think it was Dave Beazley who explained the yield statement as a scissors... it snips the function into 2 halfves, and python will execute the top half then execute some code in the middle (typically body of a loop) and then execute the rest of the function. Yield also takes input by the way... but thats for another day.
Maybe try requests-html. They allow you to download the page and then run the js code. You have an example here: https://html.python-requests.org/
I think that if you model the relationships between the entities you need to filter for and the organization you can keep everything in the same DB. - can users belong to multiple organizations? If no, then the login/session can be used to set an organization id for every request, and thus always know what organization id to filter for. If yes, then you need to keep track of both for every request and it's a bit more tedious. - model containment for all the things that belong to the organization, so every thing has an organization id. - abstract your db layer with a well tested service that enforces the presence of an organization id clause. - index the organization id. Of course all other options are also viable but may be very heavy handed. In SQLA you can use the type function (https://docs.python.org/2/library/functions.html#type) to generate ORM models on the fly and pass in a schema or table name as a parameter for example. It's possible, but it will be harder to test and you will need to include some amount of DDL when provisioning new orgs. 
Saving this*
It‚Äôs weird behavior but nothing is broken. In order to be more efficient simple versions of things like ints refer to the same object even when construct separately. This works because all these types are immutable so their won‚Äôt be any weird changing values of any variables. So if you had a million different variables equal to one they would all be the same object since they point to the same object. 
Python FTW
Nope, it was neither of them It was something like ‚Äòinteractive python‚Äô or something but I really can‚Äôt remember 
Nope, sorry, it wasn‚Äôt this one either :(
[Wrong subreddit.](https://www.reddit.com/r/learnpython) 
&gt; The latter style is far too common in clickbait and sponsored posts. Well the real difference here is OP is a redditor making a self post rather than some blog spammer linking to blog spam for clicks and ad revenue. All OP gets is some sweet, sweet internet points.
:(
In industry people will use software like ANSYS CFX, Fluent, Comsol, Star-CCM and so forth. If you want to look into mechanical loads on structures they might add ANSYS Workbench, ANSYS Mechanical, or ABAQUS into the mix as well. This is not an exhaustive list or anything but these are the major players in CFD and FEA. In academia people will generally use the ANSYS or ABAQUS package if they are more concerned with studying problems, and otherwise they will develop or use opensource command-line based software that they can develop and extend, like [deal.II](https://www.dealii.org) for example. Python wouldn't work because it's just too slow. I don't mean it in a superficial "Python is an interpreted language so it's slow" way, but I mean it in a "these simulations literally take 40+ hours to run on a dedicated computing cluster with 40 parallel cores using highly optimized and efficient C, Fortran, and C++ code."
Right. It‚Äôs under Literals, but not under strings in the docs, and not in the tutorial. That should be updated. 
Not that I know of. I would expect them to be a little faster, since there will be less bytecode than the alternatives.
You probably didn't select "add to path" checkbox while installing. You should either reinstall it or use full path (probably something like `C:\ProgramFiles\python\python.exe`).
You have a spelling error in your buzz docs in misspelling features in the section headline.
Hm, dask may suit your needs. It as been built for such tasks. 
Yeah I think there really isn't a use case for it actually. It is certainly nice to have on the side but people have developed specific tools for specific purposes already so why throw BioPython against it when better/more specific tools exists anyway? Python as glue code, though, works wonders! Gotta love the speed of making pipelines and stuff.
Is there anything more mid level for this same company?
I thought so at first as well, "shorter isn't better!" I was thinking. However, I think reading `:=` as "which is" can help. So: while (q := c//n) &lt; n: n = n + q &gt;&gt; 1 can be read as: &gt; while `q` (which is `c//n`) is less than `n`, do this... It moves the emphasis in the comparison from *the calculation of the value* on the LHS of the `&lt;` to the *name of the variable* itself which, if named well, can be read more easily. That said, I'm not convinced that such a small improvement in some special cases warranted new syntax being added to the language, adding a burden to teachers of the language, students and people reading others' code.
Changing the wording doesn't help me really. Still more work to mentally parse.
Welcome to the painful world of infix operators and random grammatical constructs. Python makes this world particularly comfy by overloading the meaning of parenthesis in different contexts. Depending on what you actually wanted to do, the code may look differently. If you wanted something like broadcasting (from NumPy), i.e. you wanted to xor every element from the `list1` with every element in `list2` that would be something along the lines of: [i ^ j for i in list1 for j in list2] However, if you aren't satisfied with the shape of the result (it is one-dimensional), but, you wanted two-dimensional: [[i ^ j for i in list1] for j in list2] If you wanted to xor those elements pairwise, then you can do what novel_yet_trivial posted.
It‚Äôs gray because you‚Äôre not using it yet: import random is gray but import random print(random.randint()) is not
That was a tweet I was quoting. I'd agree that example doesn't make the case, but the diffs in the links are more compelling.
The GIL. Why can‚Äôt we come up with a better alternative for threading?
I understand you were quoting the tweet, but you were still using it to fight for your argument, where instead it fought against it.
Also give [`prettyprinter`](https://prettyprinter.readthedocs.io/en/latest/) a look - its output is also very neat. [This](https://tommikaikkonen.github.io/introducing-prettyprinter-for-python/) is the author's (very reasonable imho) justification about why another pretty printer for Python is needed.
They may have lower performance or higher memory needs than the plain datetime or timedelta objects. For example the documentation says a Pendulum timedelta will remember the datetime objects it was created from.
This is brilliant! I don‚Äôt know how I lived without this for so long! 
http://automatetheboringstuff.com/
You could contribute.
Why do you care? The repost helped a lot of people. The karma is a number on a screen...
yes. omg yes. made my toes curl.
Yes it is possible to automate business tasks with python. First, you find a business task that could be automated, then you write code to automate it. Next you use that code to automate it. 
And all is needed is to rewrite nbviewer python module.
That's actually a good question. It matters because bots with a good amount of karma can be used for vote manipulation more easily than bots with 0 karma. As far as I know, new-ish accounts with 0 karma don't do much to the total up-/downvote count of a post/comment, but accounts with more karma are more "trustworthy" to Reddit's anti-vote-manipulation systems. I'm kinda talking out of my ass here but I hope I could shed some light on why I think this kind of karma botting is bad.
Quality post, thanks for the writeup!
HN discussion: https://news.ycombinator.com/item?id=17469701
Thank you for posting. This is the first time I discovered all five of these. I liked Inflections and pendulum. I have worked with Arrow which was a port of Moment.js pretty powerful I thought, Pendulum seems even better. I will use it!
Awesomepython on github Œπs a repo full of such modules and they are likely to be there. 
Lol you're right about me not understanding anything, I just graduated highschool and I'm planning to go on to major in aerospace. And yea, I have zilch knowledge on programming so i just was researching on how to program a drone from scratch. But thx for sharing your knowledge on what programmes/softwares are used in modelling aerodynamics. Turns out it's pretty hard and complicated as you'd need to hire highly paid engineers.
Thanks! Didn't know that sub existed :D
Finally, once you‚Äôve automated some tasks and have saved time at work, keep a frustrated look on your face when you‚Äôre not actually working. It gives the impression that you‚Äôre working hard.
I've made this probe plotter a long time ago, it is an interface to a sensor using the serial port. https://github.com/ianliu/probeplotter
And then you have to remove the good part 
Isn't Vincenty's Formulae more accurate?
Simplest libraries for that would be * Kivy (probably the best one, since it's cross platform and free) * PyGTK (Linux only) * PyQT (but it has some licencing problems, better check it before you use it) 
For developing a GUI?
The issue is the page has to be rendered before its populated with the information youre looking for. Ive had this issue as well. Check into selenium that can run as a headless browser and render the page for you. [https://stackoverflow.com/questions/29404856/how-can-i-render-javascript-html-to-html-in-python]Here is a stackoverflow post that i think addresses your issue.
Thanks, I'll check it out
&gt; Vincenty's Formulae Yes.
I use Pendulum extensively in 2 of my projects. Even Kenneth Reitz's Maya uses Pendulum behind the scenes. Absolutely love it as datetime drove me nuts. Love how easy it is to add hours or days to a datetime object. Glad to see it getting some love.
Would like to know..
Flask is more of a ground up do it yourself experience. Django is better if you want a complete web app and don‚Äôt want to reinvent the wheel yourself. 
What website is that?
If a website at all...
Thank you very much ! I'm still a bit confused about the utility of it and don't see why someone would use it since the examples provided are nested and nested again. Plus it seems like it's less and less clear and less easier to read, so I do not see why someone would use it over a regular assignment.
That is discussed in the article. 
Oh, sorry! I only skimmed through it.
That's why most package developers do not ask for their package to g be absorbed into stdlib. Most would rather be able to have full control over their package. 
What kinds of processes do you do at work? Because asking can a thing be done and then not saying what exactly you need to accomplish is vague. Are you talking about daily reports with graphs? Emails sent to stakeholders? Pricing updates? What business are you in? This site has a lot of examples http://pbpython.com
So what is it ?
zybooks, had to buy it for one of my classes 
Thanks! 
In the absence of further information: If you're making a 3d game or want to release on mobile, use Unity. If it's 2d, pygame can be OK. If it's a dialogue-based RPG (visual novel), use renpy.
He uses his own library
https://www.udemy.com/pythonbootcamp/?couponCode=THANKSREDDIT Maybe give this bootcamp a try. Its free right now, and looks like it covers all the basics. 
Thank you kind sir, i just saw that post and enrolled in it. Ill check it for sure. If you can then ill appriciate if you answer my questions above. Thank you again. :)
Pendulum seems interesting. I have always used arrow for working with datetime. Do you know whats different between them and how do they compare to each other?
A string is a TYPE of data- like an int, float, or Boolean. A variable is simply a piece of data that you assign a name to. Every variable has a data type. So if you write: my_variable = ‚Äòblah‚Äô my_variable is the variable, ‚Äòblah‚Äô is the data you assigned to it, and the data type is STRING, because it is simply text, notated with quotes around it.
So a String is a Value representing a Text And Variable is a name referring to a Value, is it? And is there a difference in single and double quotes in Strings.? (with Python2.7 or Python3)
Ah sorry. The two I mentioned are really good too. You should check them out.
Thanks! I suspected it might mean that.
Basically, yes. So whenever you use/declare a variable, it is simply referring back to the data you assigned to it. And yes, in python, you can use single or double quotes for strings interchangeably. 
Terrible question, though, when it's about your counting skills, not about your programming knowledge.
&gt; I'm stuck on how to actually make the signal generator work with that GUI. Why not have the GUI call the code you already wrote to control the signal generator? A basic GUI could do nothing more than issue the commands you already have implemented.
ipynb's use of json to organize cells makes it a bit too rigid a format, I think, to be a true competitor to those you mention. It was made with a specific purpose, although it's true that Notebooks have been put to a great variety of presentation formats. R Markdown and KnitR, I think, does a better job of this, by sticking more closely to the general Markdown specification. 
You can use either " or '. For example "String" is the same as 'String'. Although if you have a word like Dave's, you can't wrap this in single quotes because the interpreter will think the string ends at e. So you would wrap it in double quotes like this "Dave's"
I was worried first about the ZyLabs model, but I'm talking a C class at a JC right now and it's good.
Just started it, thanks! 
I had a misfortune to subscribe to Python developer's mailing list. Now, sometimes when I have breaks at work, I read the discussion around PEP-572. This feels so surreal... it's kind of like watching Bunuel's movies, except it's actually happening. I mean, I looked into release notes for Python 3.7, and the only thing that might make it worth updating is the update of OpenSSL version. Everything else is either pointless, or right-away damaging. It's like as if someone was purposefully trying to make a not so great language into a horror show of stupid ideas.
Perhaps check for the existence of the file (using pathlib for example) before trying to load it with openpyxl?
That first question reminds me why i hated college. 
Lost count of how many basic security issues this fails. You know all you had to do was copy the code from the secrets module in the standard library, and instead you did this? https://docs.python.org/3/library/secrets.html
The function opens a window for the user to select a file (I'm rolling it out to the business soon) and I can guarantee that someone will click the button, then decide to do it another time and click cancel. This is where I want to catch that exception, but openpyxl somehow stays running, even after my tkinter window is closed. 
Can software be used to automate stuff.... I had never even considered it! Oh my!!! We will have to look more closely to see if this would indeed be possible. Next items on our list of philosophical musings to be more closely examined: -can guns be used to kill people? -can trucks be used to transport things (this one is interesting, I really had not considered it) -can boats be also used in the water (besides being on land where we build them). 
Thanks! works great.
There are soooo many factors influencing the loading speed... I don't even know which are more important: it would depend on the system and the way it is used, I guess. Here are just a few to give you a taste of it: 1. What filesystem are you using? If it's some junk like NTFS, or, perhaps, ext2 or HFS... it doesn't really matter... or maybe it does (see #2). Because filesystem testing cycle and thus the time to delivery is very long, most filesystems used today on consumer electronics are dinosaurs from the previous century. They have no knowledge of SSDs and assume the underlying storage to be a spinning disk. They tremendously under-exploit the capabilities of such hardware. 2. Operating system. Well, your programs probably don't interact directly with the filesystem, most likely they use system calls to open files, read from them etc. Your OS can be configured in many different ways, to do caching, to set the size of the buffer for reading, to use different drivers to tell the filesystem how to talk to the device. Finally, some OSes provide several different APIs to communicate to storage devices. On top of that, you can have drivers that work in user space or in system space, which would affect how much copying of memory is going on. Aaaand... some OSes provide APIs for asynchronous as well as synchronous access to storage devices, which is also important. 3. Not to mention that your OS needs to execute much more stuff than just your Python process. In case your background stuff is thirsty for I/O (say, does tons of logging), that may cancel all the benefits you can get from loading from a different drive. 4. On the hardware level, there's also a concern about the throughput of your bus, say, NVME SSDs have much higher throughput than SATA. So, if your computer can only connect SSDs via SATA cable: well, too bad for you.
Thanks, I tried this, but since I'm using bash on windows I couldn't get Selenium working without the work around for it. (work pc). From what I've read though, this sounds like a the best solution.
I'm 50/50 on it. How many off by 1 errors does code like this contain because people can't count array indexes? Sure, I would use some kind of pattern matching instead of counting but I've been doing this some number of years.
How much does it cost?
Thank you so much!
I wouldn't write something like that in my actual code: RedditDomain = 'https://reddit.com' def strip_reddit_domain(url): if url.startswith(RedditDomain): return url[len(RedditDomain):] elif url.startswith('/'): return url # probably it's a path else: raise ValueError
If you are concerned about memory usage, and, say, the keys in your dictionary are strings, then you could try `trie`. I didn't try this myself: http://kmike.ru/python-data-structures/ (look for the "trie" section), but seems like it's the best one you can find (there are several other implementations, but I trust the one written in C will be more memory-efficient). I'm not sure how global variables are going to help you with the memory used in this case. Can you elaborate?
First and foremost, this belongs in /r/learnpython Second, Conda is just a tool to manage and download environments. And you haven't even begun to come close to providing enough information including: * Your OS * Conda version * Exact error message * Maybe even a screenshot
I did, but then they gave me more to do lol
I recommend the [Godot engine](https://godotengine.org/). It's easy to use, feature-rich, lightweight and has a scripting language that is similar to Python. Someone is working on a [Python plugin](https://github.com/touilleMan/godot-python), but I don't know when it will be ready.
As UI said, some kind of pattern matching. BTW, there's url parser in the standard library that'll split a URL into its 6 constitutent parts (domain, path, query params etc).
Yeah, this is the kind of argument I read a lot on the mailing list: "if other things suck, let's add one more thing that sucks, because... potato!". How is adding thing that sucks (perhaps, not all the time) is going to improve anything? On the other hand, with this retarded amendment to the language, they will throw away about 10 (ten) years of people writing code for the language that will not work anymore because it will not be able to parse Python. And this happens every dot-release. If Python wanted to uninvite anyone writing linters or general-purpose language utilities / libraries, they couldn't possibly have chosen a better strategy.
I'm not sure how to pass the value entered by the user to the section of the code which does the generating part
If you are running windows you can use the where command on the command line. C:\\&gt;where anaconda which should help you find it.
Just enrolled, thank you so much!
I think around $50, you might be able to preview the first chapter for free 
google :-)
Because it's a useless addition? It's like asking why don't you grow a third leg. The language has tremendous problems on every level. It has tons of junk in its grammar. It has huge performance issues. It has no real way to write parallel code. It has defective / deficient meta-language tools. Not to mention that every other module in standard library is all sorts of bad, outdated, uninventive only 90% functioning code. And yet, the things that find the way into new releases are total and utter fashion-driven garbage, like f-strings, asyncio, unicode strings and a bunch of useless and random syntax.
I also think that writing plain Pandoc Markdown is a better option. I chose ipynb as an a output format because it has decent python support, popular and can serve two purposes: * be viewed by nbviewer online: here it can use only js plugins, * be run in Jupyter: here it can also use python back end interactively. P.S. I write Pandoc Markdown in Atom/Hydrogen then convert it to ipynb via pandoctools - very happy about it.
Thanks for this! 
gevent for hard i/o task, prefork for fast samll task
Absolutely, e.g. who in their right mind around the world would want to avoid using ASCII as their default text encoding as in PEP 538 and PEP 540?
Well done. Thanks for taking the time write this. 
lmfao sarcasm overload
Thanks you so much!!
Just enrolled and looking forward to it. Thank you.
Good article. Have you looked into converting Geodetic to Cartesian and spatially indexing for O(nlogn) compares of nearest cities?
I am running Conda version 4.5.5 for python 3.6 on windows 10. When creating a new project interpreter under the Conda environment, it requires a Conda executable path. I am not sure which path this refers to. 
Heck yes! Thank you!
thanks buddy :)
I used that command in the anaconda prompt and put it in the Conda executable field but got an error: "anaconda: error: argument : invalid choice: 'create' (choose from 'auth', 'label', 'channel', 'config', 'copy', 'download', 'groups', 'login', 'logout', 'notebook', 'package', 'remove', 'search', 'show', 'upload', 'whoami')"
It provides a lot more convenience - basically everything is timezone-aware, you get a bunch of common formats for string input and output, and dealing with time ranges is heavenly compared to `arrow`. The only "complaint" I've noticed so far is PyCharm warning me when providing the `pendulum` `DateTime` to something expecting `datetime`, but in reality that hasn't been a problem.
And I don't see how Jupyter format is rigid as it can have any Markdown and html inside Markdown cells and we can always convert Jupyter notebook to html or Markdown. As about sticking to some Markdown spec: I think it's useless as there are infinite number of Markdown flavours if we are to use pandoc filters. And it's really nice to use them! So Jupyter notebook with it's Markdown flavour is no worse than any other if we treat it as output format for pandoc/pandoctools.
I never realized this until your comment, but this is exactly my pain point now. New features used to be available from `__future__`, but now they just *land* and people start using them, and everyone else has to upgrade to the latest Python version or not use the software. It's much worse now.
Wow thanks! Enrolled :)
I never learned a programming language in a structured environment... is there no way for the student to just throw this question in the py interpreter? It's what they better be doing in the real world...
Thanks! No, I haven't heard about this. Is this a particular method?
Oh. Look at the python docs for tkinter. I think it's the data binding between widgets and variables. Use those variables to generate the command when you call the function called by the "go" button.
I've given this a try and can't seem to get past a page saying I do not have cookies enabled and mat web requires cookies to be enabled
For 3D rendering I suggest you use glsl or POV-Ray, with python as the interface. For example you can have a look at my repo [https://github.com/neozhaoliang/pywonderland](https://github.com/neozhaoliang/pywonderland)