Regex is something *every* programmer should have in his tool-belt. Learn it!
Obviously that will work. However, that is completely irrelevant to the discussion decorator or explicit mapping. One can easily be converted to the other.
I like this. Even if it is another layer of functionality to learn, the end result is more readable and the method of registering new patterns is simple and effective.
Are you the author? Which Drupal version did you use before switching to Django/Pylons?
I have similar feelings from my experiences with Django; I'll have to check out Pylons for my next project. Thanks for the article.
Thanks. modwsgi is how I've done the last couple (django powered), and its been much, much easier, but still feels fragile and uses a lot of magic absolute paths (compare the config files with just putting PHP files in the /var/www folder in terms of ease of transition).
Oh, I see now -- I totally missed the point. Excellent feature, and thanks for clarifying a source of bugs I totally haven't been anticipating.
You might want to take a look at [Cherokee](http://www.cherokee-project.com/) as they supported self-healing [uWSGI](http://projects.unbit.it/uwsgi/) out of the box. Granted, I've found it to be slower than [Nginx](http://nginx.org/), but you got a really easy-to-use [Cherokee-Admin](http://www.cherokee-project.com/doc/bundle_cherokee-admin.html) in return. The usual workflow for setting up a web application using uWSGI and Cherokee is: 1. Setup a [uWSGI config](http://projects.unbit.it/uwsgi/wiki/Example). 2. Create new virtual server using uWSGI preset through the admin page. 3. Point uWSGI handler to the configuration file you just created. Now the most tricky part in this is to actually write a uWSGI config. If you're for the performance, running multiple instances of a fast event-driven Python web server [FAPWS](http://github.com/william-os4y/fapws3) behind [Nginx proxy](http://wiki.nginx.org/NginxHttpProxyModule) might not be a bad idea, but it's more complicated to setup: 1. [Setup FAPWS instances](http://github.com/william-os4y/fapws3/tree/b78eaed4129b801dc4fe9a849649819c1a7cd7ed/sample/django); maybe also creating rc script. 2. Setup Nginx as a reverse proxy [with load balancing](http://sameerparwani.com/posts/load-balancing-with-nginx) to your FAPWS instances. This way is going to be hell to maintenance in a long run, but it's fast! [Passenger](http://www.modrails.com/) is nice if you want to simplified the deployment, a la PHP, but I have never had any experience with it. From what I need, the workflow seems to be simple enough: just put a WSGI handler named `passenger_wsgi.py` in your document root and done with it.
Look for a web server with built in WSGI integration. As far as I know, this is only Apache. I don't like Apache either. It's heavyweight and probably perfect if you're a hosting company, but not for me. Alternatively, look for a web server with FastCGI or SCGI support, and a separate Python library to run a FastCGI/SCGI to WSGI bridge daemon. I use nginx with python-flup for this. It works really well. Let's say that you already have a WSGI app in Python called `app`. Then to run a FastCGI server all you need is: import flup flup.server.fcgi.WSGIServer(app, bindAddress='/var/run/fastcgi.socket') Then just point nginx (or your web server of choice) to that socket, and add daemonizing code to the Python app and an init script as required.
nginx with paster (see pylons framework) works very very nicely
If you want to drop files somewhere and they Just Work with decent performance -- provided you're not using something like Twisted -- FastCGI is worth a look. I've used it to good effect with several languages and http daemons.
I'm a bit sick of these "look at this crazy awesome deployment strategy where I compiled and reconfigured everything myself" posts. This might show that there's something deeply wrong with Django deployment, or maybe just Web deployment in general, but getting excited about this kind of thing doesn't help. It shouldn't be crazy and awesome, it should be simple and standardized. This customized nginx sounds like it would have to be rebuilt the moment any component comes out with so much as a security patch. Does anyone write about deploying Django with, you know, standardly available packages? If Django's for "perfectionists with deadlines", why aren't we hearing how the perfectionists with deadlines do it?
If you just learn to ignore the legacy of Apache, it's not really that heavy. You can run it with a simple config file just like you run other servers, even though most people rely on a big monolithic hodge-podge config file in /etc/apache2. Setting up a minimal rig with Apache and mod\_wsgi is pretty reasonable.
&gt; The big advantage is that if you see an unqualified variable, one with out a something. in front of it, you know you're dealing with either a local variable, or a global variable Or a \_\_builtin\_\_... &gt; it helps avoid variable collisions If you explicitly import a name, why would you collide with it? &gt; The amount of extra typing is tiny - and you save all that time the very first time it saves your ass in debugging I don't really think I've ever had a bug related to not identifying a name was from a non-current module...
[CherryPy](http://www.cherrypy.org/) would do just fine then. You can solely use its HTTP server if you must.
Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. -- Jamie Zawinski
Way to go. I think what many people miss about the whole regular expression mapping thing is how impossible it is to reverse them. I mean, if all variable parts are in groups it works. Also, it is nice if you are able to type cast the varoables for building and matching and regular expressions just dont do that trick.
I hate regex; it does my head in, this, on the other hand, seems eminently understandable
magic/unfinished magic -&gt; abstractions/leaky abstractions
Agreed, and Werkzeug does a very good job in the URL routing department. I couldn't see any special support for building URLs in django-selector, so I suppose you just use the url tag or reverse(). Working with Werkzeug endpoints and rules seems easier than working with view functions, it's a shame these abstractions aren't there in Django.
Its kind of outside the scope of the question, but more and more I've been doing my "toy" apps on App Engine. Definitely nice to not worry about things like what server to run them with, though obviously it has many limitations.
When Python programmers -O? There is also the documentation that gives you the syntax, so if you want to use language features (much like the exception handling tuple gotcha grieved about few months ago) -- RTFM first. Not really hard -- if I can do it, so can you. In all seriousness -- I have never used assert and I hate the idea. I don't put ,,debug only'' code in my programs, especially if it can be turned off easily by a single runtime switch. And `AssertionError`? How do you handle that? No, seriously -- write a TestCase for that behaviour and maybe run some solid inner-checks that give real errors. Assertions are only one step above ,,debugging using print''.
Actually I'd go for `not X is None`, since I've been writing that for a long time and it seems more natural, but for some time now `X is not None` is equiv to that.
I think that they are taking it a bit too far. First, assuming that (a) you keep your files reasonably small and (b) have all your imports at the top of the file, it really isn't a problem to always know where any given symbol comes from. Second, it doesn't allow you to use some common Python patterns, like if something: import something as foo else: import something_else as foo from foo import x, y, z ... (Think stuff like Django's database backends.) Third, there already exists a widely accepted Python style guide, [PEP8](http://www.python.org/dev/peps/pep-0008/). 
I thought the recommended way to do it was Apache + mod_wsgi. Not sure how "official" that recommendation is though.
Not really. The problem is that Django makes a lot of assumptions as to the underlying model. For example, a lot of apps assume that you use the contrib.auth.User model for authentication. This greatly adds to the "pluggability" of Django, at a cost of flexibility. Pylons does not make those kinds of assumptions - it doesn't even assume the same data access layer (even SQLAlchemy is disabled by default). That gives you a lot more flexibility, but it also means that pluggable apps a la Django are just not possible (WSGI middleware is at a lower level of abstraction). So, in other words, for Pylons to have the same pluggability as Django it would need the same level of constraints. As people choose Pylons over Django because of the relative freedom it offers, I can't see that happening soon. It may happen however with a higher level framework based on Pylons, like TG2 - I don't know enough about TG2 to know whether that will be possible or not.
I hate apache2 for everything (slow, ugly config syntax, etc.), but love lighttpd for everything (php/python/ruby).
A pass on the chance to construct additional pylons? Are you mad?
^^^^^^ this is a well thought out answer. Paste provides some facilities for combining applications into bigger websites using [urlmap](http://pythonpaste.org/modules/urlmap?highlight=urlmap#module-paste.urlmap) and then you can use something like [deliverance](http://www.coactivate.org/projects/deliverance/introduction) to provide the common look and feel. At least in this way you can have loosely coupled wsgi applications, as potentially reusable components, but they would tend to be pretty coarse.
Traditionally I've used Apache with mod_wsgi. I've also been hearing good things about [gunicorn](http://gunicorn.org/) proxied behind a lightweight server like nginx, though, and need to check it out.
I understand that it can be cut down, but it isn't in most distributions by default. I prefer to use the version and defaults supplied by my distribution as much as possible, as this makes automated deployment easier to set up, is more maintainable, receives security updates automatically, etc. I could strip it down by hand, but that would take time to figure out and time to set up and maintain. For example, nginx depends on `libc6 (&gt;= 2.4), libpcre3 (&gt;= 7.7), libssl0.9.8 (&gt;= 0.9.8f-5), zlib1g (&gt;= 1:1.1.4), lsb-base (&gt;= 3.2-14)` and I can see that I directly need those libraries for my own configuration. On the other hand, apache2 depends on `apache2-mpm-worker (&gt;= 2.2.12-1ubuntu2) | apache2-mpm-prefork (&gt;= 2.2.12-1ubuntu2) | apache2-mpm-event (&gt;= 2.2.12-1ubuntu2) | apache2-mpm-itk (&gt;= 2.2.12-1ubuntu2), apache2.2-common (= 2.2.12-1ubuntu2)` and that's only the top level. Not that the dependencies matter directly, since the distribution does all of that for me. I'm just using it as an indicator of complexity.
Nice catch :) These regexes were defined by the original Selector package, whose page is unfortunately not responding, but [is available in google's cache](http://74.125.47.132/search?q=cache:gOR-KCgN3bgJ:lukearno.com/projects/selector/+luke+arno+selector&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us). The "number" one is definitely a bug (r'\d+[.,]?\d*' look ok?), but the "chunk" issue is probably me not reading the regex carefully. I actually don't mind regexes; I'm pretty comfortable with them, I just find myself repeating the same recipes in urlpatterns quite often.
Although not mentioned in the article, Pyjamas works great with web2py but the binding are not in Pyjamas, they are in web2py, since web2py provides the @service.xmlrpc decorator that turns any function into an xmlrpc service. [Here is a complete example](http://web2py.com/AlterEgo/default/show/203).
You really want to read up on [gunicorn](http://gunicorn.org/), I think.
To be honest, i'm pretty sure that a framework at the level of pylons should not concern itself with providing plugpoints for slotting "applications". This task is probably better left to a system built on top of pylons (e.g. something like drupal or plone, but built atop pylons). I think this is probably true for any web framework. The reason I say this is that there's just a natural tradeoff between flexibility and ease of application composition. Every time I've seen it done, you have to make some sacrifices to easily integrate someone else's "application" into your site. For example, you might need to lay out your database in some particular way, or arrange your URL structures in a particular way, or use some particular persistence mechanism, etc. These sacrifices shouldn't need to be made if you're *not* reusing an application; but when folks latch on to the idea that a web framework provides slots for pluggability in this way, some code that causes these sacrifices starts to bleed into the framework itself, and makes trouble for the folks who don't need the reuse. Thus IMO it's probably just better to build a layer atop the web framework into which applications can be plugged explicitly; when people use it they understand they'll be giving up some flexibility. Note that Zope's CMF is such a system. Django shouldn't be concerning itself with pluggable apps; instead this should be the job of Pinax probably. IMO. 
instead of inventing a technique to prevent recursion (one of the most powerful techniques), it's better to check "the base cases" to ensure your program doesn't go into an infinite loop.
Thanks for pointing out those two packages - definitely worth a look. 
&gt; Django shouldn't be concerning itself with pluggable apps; instead this should be the job of Pinax probably. IMO. Django doesn't concern itself with pluggable apps (apart from those it provides in contrib). Apps are merely the basic building block of django projects, the idea of pluggability arises naturally from this. 
Here's a [Django + Pyjamas](http://gdwarner.blogspot.com/2008/10/brief-pyjamas-django-tutorial.html) tutorial I just found.
[Supervisord](http://supervisord.org) + [fabric](http://docs.fabfile.org/0.9.0/) are also very handy for managing all your Paster instances.
Yes, i use the CherryPy server for development and then deploy to Apache with mod_wsgi (or your server of choice that supports WSGI) for more stable code. The CherryPy server will give you much more informative errors, and has auto-reload when you modify code. Apache you must restart the server to be sure your code is current, else you will get caught out with cached modules. I simply have two entry points, "site.py" starts a cherrypy server, and "wsgi.py" is mounted when using a WSGI server. Both those are only ~30 lines of python, just enough to get the server started and a few settings. Everything else is common to both platforms. To be honest the CherryPy sever is pretty awesome and would be fine for any small site. I just like to know that my code functions fine on more than one server platform.
If you had read the example given, you would realize that the purpose is reuse of code not an issue with "base cases"
Your suggestion makes so much sense it most certainly can not be true.
That is the official recommendation. There are however many different apps and a one size fits all approach is not a good fit for something like a django project. Many of them tend to be a little weird. Most of the time, there is no "right way".
no problem. if you're using pylons, paste is already there. and deliverance is just middleware that is an easy_install away, so your integration point could be your ini file if you like. 
"Django doesn't concern itself with pluggable apps (apart from those it provides in contrib)" so it does concern itself with pluggable apps. It's so clear now.
this article really opened my eyes. I will not be recommending django to my employer. Instead I will use web2py... thank you
Django and Pylons are two very different frameworks. The different components of Django (ORM, template languages, routing...) are tightly coupled together. Pylons is mostly component glue. Since you're free to switch ORMs, a plugin cannot make assumptions about what kind of model your application need.
It's been awhile since I did anything with plugins for Pylons, but it does support an entry points system: http://wiki.pylonshq.com/display/pylonscookbook/Using+Entry+Points+to+Write+Plugins (That's an old document - not sure how current the info is - but it should give you the idea). I've done some work with it and it functions fairly well when done right. 
Of course in the example of the factorial function it is easy to check the base cases, but in my case the function that was recursing did not take any arguments. How do you check the base case then?
Decorators are buzzwords? They're just functions.
yes, It is the app used i the web2py example below and referenced in it.
I've found Django's ORM to be much easier to pickup than SQLAlchemy
This seems like a design problem that you hacked around instead of addressing the root cause. A nifty hack is still a hack.
I think it's as much of a hack as memoizing a recursive function. Instead of returning a memoized value it's just returning a default value. Maybe that's what I should have used instead.
Edited, but still a solution looking for a problem.
To the extent that other projects do? No, it doesn't. Django's contrib folder serves two purposes: 1. Provide tested, common implementations for a few things lots of people need (sessions, auth, admin, etc.) regardless of the type of stuff they're building. 2. Provide useful examples of (hopefully) doing things right which developers can refer to for ideas or learning purposes. Which isn't really the same thing as "providing apps"; the things you can do using nothing but contrib (i.e., no third-party applications, no apps you write yourself) just aren't all that interesting unless you're happy with a site made up of nothing but dirt-simple flat pages.
"To the extent that other projects do? " what other projects?
Like seti32 said below, it's a design problem. If you require that there be no argument for your function, then okay. But why not? You can simply pass in an argument that increments itself in each recursive call. This should allow you to stop without the need of your approach here. Use something to stop a recursive call being recursive doesn't seem right. 
I'm guessing you don't have access to the code for your specific function?
Well, Pinax for one, which exists solely to provide and integrate a bunch of applications.
well now you're just agreeing with mcdonc
Maybe look at something like [code.InteractiveConsole](http://docs.python.org/library/code.html#interactive-console-objects) ?
Well, he was right. You apparently decided to be snarky and claim that the existence of `django.contrib` was a contradiction ("Django doesn't focus on apps, but it does"). Which, frankly, makes no sense, so I posted a comment explaining that. Does Django provide a couple applications to help you get started? Yes. Does that mean the core distribution focuses on providing them? No.
WTF? How did I miss that? I think that'll do perfectly - I'll point stdout and stderr to my own handler. I was actually starting to build something that did exactly what the interactive console already does, and I thought there was an easier way. Thank you sir!
I'm sorry you mistook my want of clarification as snark. your further clarification in this regard will benefit the internet as a whole.
[Did somebody say....recursion?](http://www.reddit.com/r/Python/comments/bb47f/a_decorator_for_preventing_recursion/c0lwag1)
 &gt;&gt;&gt; from IPython.Shell import IPShellEmbed &gt;&gt;&gt; IPShellEmbed()() In [1]: * [IPython](http://ipython.scipy.org/moin/) * [Embedding IPython](http://www.ifi.uio.no/~inf3330/scripting/doc/python/ipython/node9.html)
XML-RPC? Great, now I've got a 90s J2EE flashback.
No, line_profiler (I'm the author. Hi!) won't let you step through the code. Use the trace module for that.
Here's a nice link, with supposedly an improvement on code.InteractiveConsole: http://writeonly.wordpress.com/2008/09/08/embedding-a-python-shell-in-a-python-script/
Replace the w=90 with other numbers for other rules... [110](http://en.wikipedia.org/wiki/Rule_110), [30](http://en.wikipedia.org/wiki/Rule_30), etc
Still your project (a line profiler) is a useful one. :)
one *terrifying* line of python
If you're already running the application from a shell then &gt; import code; code.interact(local=locals()); will give you shell with all the local variables set. I use that a lot for debugging.
Typo. I meant @service.jsonrpc. Web2py has both and some more (@service.xmlrpc, @service.amfrpc, @service.csv, @service.rss)
I'd add Eclipse + PyDev as a surprisingly effective development environment. I was prepared to hate it, but found it usable and effective enough to use it as my main IDE. And I'm not an IDE guy.
Anyone care to make a more readable version?
librelist is awesome. i use it for the zine list and wrote a custom web archive for it.
Here's it unrolled as iteratively as possible. (I've made a slight change in printing each row as we go, rather than construct the whole **s** array and print at the end, but it's essentially the same): # coding: utf-8 w=90 lastrow = [0]*31 + [1] + [0]*31 # Initialise array as [000...00100...000] print ''.join(u" ▲"[c] for c in lastrow) # Print the first row for j in range(31): # Generate the next row from the previous row as: nextrow = [0] * len(lastrow) # Initialise it to same size # Each point in the next row will depend on the 3 immediately above it # (Note: wraps to the other end at start and end of array.) # The combination of this determines how many bits we shift our value, from 0..7 for i in range(len(nextrow)): left, middle, right = lastrow[i-1], lastrow[i], lastrow[(i+1) % len(lastrow)] nextrow[i] = w &gt;&gt; (left * 4 + middle*2 + right) &amp; 1 lastrow = nextrow print ''.join(u" ▲"[c] for c in nextrow) # Print the row. Essentially on each line, each cell can be 1 or 0, starting with a line where only the central item is 1. Each cell on each subsequent line depends on the 3 neighbouring cells above it. These are combined together to construct a value between 0 and 7 which identifies the index of a particular bit in the w term. Eg, if the 3 above are 011 from left to right, that corresponds to 3 (read them as a binary number), so we look at bit 3 in the w value (from the right, 0 indexed) 90 = 101**1**010, so that cell becomes 1. Repeat for each subsequent line, and you get this pattern. [Updated to fix bug I'd introduced, pointed out by finite below]
It would be useful if the title was amended to include "based on Twisted". Phillip.
It would be more useful if the title had "made of pure win" appended to it.
Output: http://imgur.com/9GAJE.png
Now I'm going to spend my morning playing with cellular automata.
I believe that is an Nginx thing. It doesn't load modules the way Apache does, it has to be recompiled to add modules. You could look into Cherokee for a simpler process.
How did you do that without editing your comment?
Review of Python Testing (a beginner's guide) review: find the review, read it and examine the typos BEFORE you trust it. Then you'll know if you want to spend your hard earned free time on this mess.
It isn't marked as edited if you do it within ~ 30 seconds or so. I think. [for example](http://www.reddit.com/r/Python/comments/bb47f/a_decorator_for_preventing_recursion/c0lxsuj)
I believe you're looking for [this](http://www.perl.org/)
And to see the *meaning* of the "w" parameter, consider it as a bitmask of rules indicating what states produce 1 in a cell based on its neighbours above. Ie. 90 = 1011010, which has 1 bits in positions 1, 3, 4 and 6 (measuring from the right, with bit 0 as the rightmost). Which means that you produce a 1 only if the cells immediately to the above-left, above and above-right are: 001, 011, 100 or 110 (ie binary representation of these numbers). The symmetric 001 and 100 are actually the only things involved in this pattern in the region shown (since there are no 2 cells produced next to each other), so you actually get exactly the same pattern if only bits 001 (1) and 100 (4) are set, for a value of 10010, or 18. (Though it makes a difference if you continue for a few more lines as the triangles join up.) Similarly, asymmetric rules will give you asymmetric results. Eg 30 = 001 010 011 100, and produces chaotic left leading staircase patterns.
Oh.
Considering the context, I should think w=34 is the most appropriate selection. :)
This wont work for raised exceptions. You'll need something like: f.callcount += 1 try: return f(*args, **kwds) finally: f.callcount -= 1 But I agree with vph: change your program so it doesn't go into an infinite loop. Just read your blog entry again. The issue seems to be index.html - does it represent just one template or the entire directory? That seems to be the conceptual flaw. Sometimes you want it to mean all the pages but other times you want it to mean just that page. Maybe you can try get a list of pages from the directory and treat index.html like just one template.
Cool. I could not resist. Now it is running [online](http://web2py.com/sudoku)... 
Ha. What a coincidence, I just learned about this today in class! Pretty cool implementation, too!
I'm not sure what you mean by "python and apache2 have a rough relationship." Is that something to do with mod\_python? mod\_wsgi seems to be the recommended way of running Python apps in Apache these days. Personally, I run Paste server (Pylons) behind Apache/mod_proxy and have been doing so for many years. It's very straightforward, well-supported, etc. 
Excellent! I recommend checking out [CAGE](http://pypi.python.org/pypi/CAGE). I have a big patch adding a bunch of features that I've been meaning to send to the author...
&gt; " ▲"[c] That is what I had originally, but subscripting the triangle character out didn't work for me (python 2.6 on Ubuntu). It just returned the first byte of that multibyte character. Hence, (" ","▲")[c]
This is awesome - i've been playing with this for 30 min. My next logical question is - what is the minimum number of numbers to be filled in to generate a distinct Sudoku puzzle? 
another one??
"new ... driver" was probably a bad choice of words for that article. What would really be useful is to have one driver that people could contribute to instead of many separate ones. To that end, there are two possible projects that might fit this: pygresql or py-postgresql I have talked to the developers of several of the postgresql driver projects. Here's is a basic rundown of the MIT/BSD drivers (basically all the ones that are unrelated to psycopg): * py-postgresql - one very active developer: James Pye * pygresql- one semi-active developer: Christoph Zwerschke * PG8000 - one semi-active developer: Mathieu Fenniak * ocpgdb - developed by 1 person; he has no more time to work on it Based on this info, and talking with each person, the best option seems like it may be to go with pygresql or py-postgresql and invite other developers who may be interested to focus their efforts on one of these drivers. However, the big issue is going to be the differences between these two drivers. **Are there other people out there interested in working on a postgresql driver? If so, I'd love to hear from you.** Maybe you have some thoughts about these two drivers?
By passing extra arguments into the function using keyword arguments s.t. no argument can be passed as well in the intended "public" interface as in the following example: def search(obj = None, visited = None): visited = set() if visited is None else visited obj = obj if obj is not None else self.xyz ... if obj not in visited: visited.add(obj) ... next = compute_next(obj) search(next, visited) ... The `visited` cache memoizes objects and prevents calling `search` twice on the same `obj` argument. In the implementation the cache is a local one. If it shall be global, one can also set `visited = set()` in the defining keyword argument clause.
It shows up as 3 lines but is only really 2. The first 2 lines of text are one line of code. I challenge people to write shorter versions.
Oops, you're right. Forgot to mark it as unicode, so it treats it as 8 bit data. Updated.
problem is resolved. psycopg2 updated its licence to LGPL, documentation for psycopg2 was created and the webpage updated. Federico was asked to introduce himself next time he passes a PostgreSQL booth, so that beers can be shared. 
[I did a post about the new licence](http://www.reddit.com/r/Python/comments/bb5o4/) but it took some time make its way to the Python reddit (it still connot be found when searching for "psycopg2")
Thank you Josh Berkus for raising this issue after all these years. It's a bit funny that it's taken a high level PostgreSQL developer now working with Django to finally raise a stink about the pitiful state of python database adapters in general, and postgresql in particular. So i guess indirectly this is another thing python has to thank RoR for. &lt;rolls eyes&gt; I remember long ago when i used to read the mailing list (like 5 years ago), the ridiculous arguments over licensing and the sad justifications of the GPL-religion being spouted. Yes, Frederico is perfectly right to license it any way he saw fit, but we also have the right to say it was just an embarrassing and painful mess. All of those "historical" excuses aren't very impressive at all. I'm amazed it seems at long last some light has dawned on the psycopg licensing, and Frederico has given in a little. And they've generated sphyx documentation and replaced the cringe-worthy rant (against Trac?! Not my personal favourite piece of software either, but come on...) that served as psycopg's home page for *years*. Amazing progress. 
Also not mentioned, probably due to its long abandonment, is [pyPgSQL](http://pypgsql.sourceforge.net/). I still use this trusty old BSD licensed driver from time to time for small tasks... just for the sake of not using psycopg when I can avoid it. 
Apparently [17](http://units.maths.uwa.edu.au/~gordon/sudokumin.php), but no proof this is so. 
Why do we need to thank RoR? (genuine question - don't get the connection)
I understand that technique.. In my situation the function did not call itself in the body of the function, the recursion happened 2-3 layers away: * 1.) In the `search` function... * 2.) There is a call to [blatter](http://bitbucket.org/jek/blatter/) to give me a template loader * 3.) Use the template loader to [render each template](http://jinja.pocoo.org/2/documentation/) * 4.) The `search` function is used somewhere on one of the templates, which starts back over at step 1 again. I don't see how I could easily pass `visited` arg through those extra layers without things getting messier. The one easy option I see is to keep the `visited` cache outside of the function, similar to what the decorator does.
Plus there's a Python 3 branch. https://dndg.it/cgi-bin/gitweb.cgi?p=public/psycopg2.git;a=tree;h=65137d72e27831dbf4c6ec0782b6b96c3074ac2e;hb=65137d72e27831dbf4c6ec0782b6b96c3074ac2e So there's no issue here.
He's probably implying that the hype generated by RoR was what caused the latest genreation of Python web frameworks like Django and Pylons to finally emerge. Possibly even that they are simply RoR clones.
It may depends on what the values are their location. Not sure.
Oh, right. In other words he's wrong. Thanks.
oh wow he finally updated the psycopg2 site from that rant on how much trac sucks The only think I didn't like about psycopg2 was how the docs seem to imply, that it does its own escaping instead of using the libpq mechanisms. It didn't seem to say that using pure postgres style parameterized queries would skip psycopg2's own mangling layer
[Hello. I need some help with recursion.](http://www.reddit.com/r/Python/comments/bc3z3/newbie_help_with_recursion/)
I've been using Pylons for a couple of years now, for small and large web projects. You'll find that the more you use it, the more it becomes your go-to framework even for quick easy sites. Where I used to cram some ugly php into a folder for something new, now it's paster create -t pylons myQuickie Throw in my basic starter mako template and go to town on the controllers. Pylons makes debugging fun. :3 **No more**: syntax error, unexpected T_VARIABLE 
Try examining the output when the number of years is -1.
[That's not really recursive. This comment is.](http://www.reddit.com/r/Python/comments/bc3z3/newbie_help_with_recursion/c0m08ts)
workbob's comment is mutually recursive.
You build a recursive function by looking at, essentially, two cases: 1. A base case (which, in your circumstance, is when years == 0) 2. A recursive case Try to determine the behavior of your algorithm when years ==0, then look at how you build the result up when years &gt; 0.
[If we continue that deep we might found us redirected here](http://stackoverflow.com/)
Man I don't want to be an ass but if it's an assignment try to solve it yourself.
Thanks, with your help I got it working. I wasn't aware that I could pass assign default values to variables in the function declaration line - that helped a great deal.
He didn't seem to ask for the answer. He seemed to ask how you would solve it using a basic Python skillset. Nothing wrong with asking for help but how you interpret it. 
It seems one issue you're having is that you're confused about what your function is producing. In nestEggFixedRecursive, you are returning a list, but two lines above you seem to be doing some multiplication using the result of the function. But what does it mean to multiply something by a list? This seems to be a common problem a lot of newbie programmers make (especially when using dynamically typed languages like Python), and I've seen it a number of times from tutoring the freshman intro class at my university. One thing that might help is writing a comment above each function you write that says what the inputs and outputs are. For example, with this function you could have: # nestEggFixedRecursive: number number number number -&gt; list of number This way, it's harder to forget what type of data you're working with when you make your recursive call. Now you can think about what information your recursive call is providing to you, and see if/how you can use that to produce your final result. I hope this helps!
It's a nice project, but what python *really* needs is a proper way to call C++ code from python. And by that, I mean create classes, convert python lists to std::vectors automatically, and so on.
Do NOT put mutables as defaults for parameters!!! import random def mutable_example(my_list=[]): my_list.append(random.random()) return my_list &gt;&gt;&gt; mutable_example() [0.53772113976858504] &gt;&gt;&gt; mutable_example() [0.53772113976858504, 0.97733850050236359] &gt;&gt;&gt; mutable_example() [0.53772113976858504, 0.97733850050236359, 0.47571567354521627] &gt;&gt;&gt; mutable_example() [0.53772113976858504, 0.97733850050236359, 0.47571567354521627, 0.91811727730334702] Unintended consequences GALORE!
Here's my recommendation to you: don't recommend ANYTHING to your boss unless you've actually used it yourself and fully understand the pros/cons. You'll be badly burned otherwise.
Or [here](http://stackoverflow.com/questions/23860/what-is-the-best-way-to-learn-recursion) (Well played.)
Doing development other than .NET/C# on Windows is a pain, so I can't say I'm surprised that there are so few volunteers.
A bit OT, but it seems like if you're going to use Git (or Mercurial) you might as well use Github (or Bitbucket) for all of the community features. *shrug*
Note that I said C++, not C. The C bindings work fine (even though I still think it could be simpler), but AFAIK, there is currently no good way to connect C++ and python without a huge impedence mismatch.
Thank you! I've discovered quite a few solutions that didn't exist the last time I looked. I need to take a closer look at them now :)
Note that this is exactly what Microsoft wants, so it's not going to change any time soon. Why make it easy for people to develop cross-platform applications when you can lock them in with nice Windows-only libraries?
That's a tough problem; the C++ ABI is a mess and not standardized as far as I know.
Minor question: did you use any of these? Because there seems to be an aweful lot of concurrent solutions, and no clear winner...
Good point. I guess any good solution will be compiler specific then.
To the psycopg2 developers: I'd just like to say thanks for the updates! The documentation is especially welcome.
&gt; The only problem I have at the moment is how will I get this bytecode back to python source code. This is a lossy step. Going from bytecode back to source will be like trying to go from muffins to flour and eggs.
&gt; I'd rather not write C++. FTFY
how big the generated files usually are?
I hope you saw namcor's reply. The way to do this is to pass in an empty list as the paramter on the first call and not use a default value in param list. def rtest(val, lst): if val == 0: return lst lst.append(val) return rtest(val - 1, lst) &gt;&gt;&gt; print rtest(3, []) [3, 2, 1]
how do I know your recommendation is sincere? you could be a troll 
Do you do any work on the driver or do you just use it? py-postgresql and pygresql need helpers.
BTW, do you know how to contact any of the contributers to pyPgSQL? I can't get in touch with any of them.
The C++ code is basically your Python code converted to C++, no Python calls or anything. They're quite small, an assignment I wrote was 300kb.
I was introduced to ShedSkin a while ago, and it's absolutely fantastic. You write your code (taking care not to mix types), compile and get a 100x speedup on heavily algorithmic code. I would love to help but I switched to Linux a few months ago :/
What's wrong with py2exe? I'm starting to use that and it seems fairly decent, for deployment.
signed up, thank you
If your competition is decompiling python bytecode, (I hate to be actually saying this) but wouldn't it be a violation of the DMCA?
What are your problems with SQLAlchemy?
pip install SQLAlchemy
Not so much problems as questions. Right now I have a module for all my "table classes" as described [here](http://www.sqlalchemy.org/docs/ormtutorial.html#creating-table-class-and-mapper-all-at-once-declaratively); and another module with functions to return engine and session objects (as described [here](http://www.sqlalchemy.org/docs/ormtutorial.html#creating-a-session)) Is this the right approach? Is there any pattern to organize the code that uses this classes and objects? Hope I made my self clear
All in all, SQLAlchemy is *the* preeminent way to do db interaction with python. Especially given that you can do "close to the metal" sql queries using it's connection pooling, but step back to the ORM for editing small numbers of objects. The main competitors are SQLObject, AppEngine's BigTable interface, Elixir (a rather nice declarative layer for SQLAlchemy you might like)... but in the end none of them are revolutionarily different from SQLAlchemy. As far as how to use it, i've found the pylons web framework's structuring of model / view / controller, particularly with regards to sqlalchemy, was quite useful... i've successfully adopted some aspects of it into a pygtk based app. it may have some patterns worthy of learning. in the end though, I feel your frustration in a more general category: serialization / persistence. I haven't seen a single persistence system (pickle, pyyaml; sqlalchemy, sqlobject, etc) which managed to feel as truly pythonic as freeze/thaw feel Perl-ish. I've got my own pet project I use in my company (mainly a Elixir-like layer that can work with other backends), but I'm still hunting for the magic pattern than makes it all click with my code. The only SQLAlchemy-related patterns I've found so far which helped even slightly: * putting all classes which map to the db under a single "model" subpackage (ala pylons) * having said classes correspond to db tables (at least loosely) * embedding common db operations as classmethods inside those classes (eg: by_id() by_unique_key(), query_all()) * ensuring such methods take a "session" kwd, instead of having an implicit session (isolating global session objects and session creation in the controller code) * as a rule of thumb, only doing commit/rollback in the controller (unless the model really has to) * making use of threaded proxy objects (ala Paste's Stacked Object Proxy) to allow global variables that aren't known until runtime, when I really _do_ have to import something into the model. keeping them per-thread ensures the value is always correct for the *current* call stack, and not conflicting w/ parallel copies of the app w/in the same process. edit: reformatting the list
Thanks for your comment. I'll try out what you describe in the last paragraph.
I don't think so. I think the DMCA only applies to reverse engineering security devices that protect media. It definitely doesn't apply to reverse engineering software in general.
More elegant than always having to pass in an empty list: def rtest(val, lst=None): if lst is None: lst = [] if val == 0: return lst lst.append(val) return rtest(val - 1, lst) That said, doing recursion in Python is usually a bad idea, since the stack can only ever be 1,000 items deep before it crashes. You can use recursion for things where it makes sense, like trees, but using it for lists is a waste of time except as a teaching exercise.
If there is sufficient business benefit your company could consider sponsoring Mark (or someone else) to maintain Windows support.
Consider using Elixir (a layer on top of SQLAlchemy) It will be much, much, much simpler to get things up and running. Link to tutorial as proof: http://elixir.ematia.de/trac/wiki/TutorialDivingIn
If your product is worth decompiling python bytecode, it is worth hiring engineers to create it from scratch. Programming is not magic, generally it is easier to create a program from scratch than to decompile it. Reverse engineering is used when you need to be compatible with something (file formats, or hardware interfaces).
Thanks. I've been doing a lot of work in Erlang lately, and the empty-list-arg comes naturally, all of a sudden. So does the tail recursion, even though Python doesn't take advantage of it.
thats just a link from their site, you might want to tell them.
Hey Al: I wanted to say thanks as well. You have written a great book. I can't wait for my kids to get just a little older so we can work through it.
So I was an ass. The tricky part with recursion and Python is that sometimes you expect the param you pass to be copied but they're not (for list or dictionnary).
I've found SQLAlchemy to just be too much for smaller projects. I understand why - they build SQLAlchemy as a swiss army knife, it has every tool possible, to fit every database situation possible. Since a lot of people need to work with existing legacy databases, or merging multiple databases or all sorts of weird things, the features that SQLAlchemy provides them is completely vital. But for me and most of my projects, it's just wayyy too much gunk to wade through when all I want is a few tables, and a few minor relations. I really liked SQLObject back when it was the default in Turbogears 1.0, but I haven't used it for a long time. Elixir, to me, just seems like an extra layer to just turn SQLAlchemy back into SQLObject. It adds a layer of complexity to go back to simplicity. I'm not a fan. Django's ORM is pretty nice, but I haven't done anything major in it. I've just started looking into web2py, and it looks promising, but still not quite what I'm looking for. I think the issue is that all these ORM's push you into thinking like SQL, instead of thinking like python objects. It seems almost wrong to write object methods to your declared models, which then means I'm doing way too much in the controllers. So far, my favorite has been the Google App Engine datastore. But as far as I know, you're limited to google app engine (unless they released that as it's own module and I'm just unaware?). It still feels... not quite right, but it feels more right than anything else I've used. I'm going to start looking into some of the NoSQL options to see how they feel. CouchDB and MongoDB look promising for a couple of my upcoming projects. Then Zope has an object persistence database that looks like it may fit the bill... Sometimes, though, especially for the smaller projects, it feels better to just write the SQL out manually in a bunch of getter/setter methods, and skip the ORM completely. I'm sure as time goes on, something amazing will come by. The amount of choices and ease of use has gotten better in the few years I've been using Python.
If you absolutely have to have TCO because it feels more natural to you, there are a number of function decorators out there to keep the stack from blowing up on you, but none of them have very good performance characteristics. Still, for personal projects, it might be good fit.
I've just implemented something like your last paragraph, but backed by Redis. It was very simple to implement and so far, very fast.
Interestingly not so many people are aware of [dejavu](http://www.aminus.net/dejavu), which offers an alternative to those you suggested.
it was great
&gt; I've found SQLAlchemy to just be too much for smaller projects. When you say "too much" do you mean the learning curve, memory footprint, performance, all three or something else? I have to say that if you look at the examples, SQLAlchemy seems fairly easy to use and yet I've found it to be pretty powerful, and also it provides a lot of extensibility options. You don't *have* to use the ORM, but if you want to think in terms of Python objects, you can use the SQLAlchemy declarative extension or Elixir to provide a natural, Pythonic interface between the RDBMS and Python code.
I found Storm (storm.canonical.com), a lightweight ORM created by Canonical to be quite good for projects where SQLAlchemy is overkill. My only criticism is the documentation is not sufficiently comprehensive, so a few things took me a while to figure out.
But if they xor-encrypted the important code with a password stored in plaintext, suddenly the DMCA would kick in, I guess.
I actually looked at this and it seems pretty decent.
&gt; I've found SQLAlchemy to just be too much for smaller projects. I understand why - they build SQLAlchemy as a swiss army knife, it has every tool possible, to fit every database situation possible. Since a lot of people need to work with existing legacy databases, or merging multiple databases or all sorts of weird things, the features that SQLAlchemy provides them is completely vital. But for me and most of my projects, it's just wayyy too much gunk to wade through when all I want is a few tables, and a few minor relations. You don't have to use the "gunk" &gt;&gt;&gt; from sqlalchemy import create_engine &gt;&gt;&gt; db=create_engine("postgres://...@.../inventory") &gt;&gt;&gt; print db.execute('select count(1) from port').fetchone()[0] 31937 &gt;&gt;&gt; for x in db.execute('select name from building'): print x.name ... Blah Foo Bar
What is the "java way"?
Especially if you have a ton of static content. nginx is insanely efficient and fast.
download web2py, unzip ip and add /path/to/web2py/ to sys.path. Then db=DAL('mysql://username:password@location') db.define_table('tablename',Field('fieldname','string'),....,migrate=False) db.tablename.insert(fieldname='fieldvalue') for row in db(db.tablename.fieldname.like('a%')).select(): print row.fieldname db(db.tablename.fieldname.like('a%')).update(fieldname='othervalue') db(db.tablename.fieldname=='othervalue').delete() It does not depend on any third party module. select() can handle joins, left joins, nested selects, aggregates and combination. migrate=False means that it will not try to create missing table nor alter them. There are some restrictions with mysql: tables have have an auto-increment integer primary key called id.
I've been looking at MongoDB the past few days and it has some crazy-cool features, I'm very excited about it. CouchDB's map/reduce (which is also available in mongo) makes my head spin, it so unlike anything I've ever seen.
&gt; So you're saying that problems can be solved by just throwing massive amounts of money at them? I'm saying that if it is worth massive amounts of money there are better solutions than reverse engineering. &gt;Many people really do use compiled languages just for the obscurity though, and it works for them. True, but python byte code should be plenty for these people. Shipping the python with comments removed and variable names obfuscated should be enough.
Some people when faced with a discussion about regexes think "I know, I'll quote Zawinski". Now eveyone has a problem.
can you name some steps which SQLAlchemy requires that Storm does not ? 
I went ahead and made this into a little web app. You guys can run it here: http://utilitymill.com/utility/Simple_Cellular_Automata Note: I used Brian's version so the code is more readable.
You don't wanna know. In case you do. [JavaBean :-(](http://en.wikipedia.org/wiki/Enterprise_JavaBean)
Sounds good. How compatible with CPython (in terms of pure python code and C extensions) has PyPy become?
Pure python code is almost 100% compatible. There's no compatibility for C extensions right now though.
really awesome subject, really shitty presentation
:-D
Why use sqlalchemy at all if all you're going to do is write the queries by hand?
FYI, the tools to reverse binaries are far, far more advanced than the tools to reverse python bytecode.
Mostly for me it's the learning curve. Now, to be fair, I tried very hard to ignore SQL for as long as possible, and only just started learning it for my latest job. What I was hoping for out of SQLAlchemy (and all ORM's) is enough abstraction that I don't have to think at all about the database. I just wanted something along the lines of "Tickets have notes, notes can have parent notes." None of my apps up until last month has had more than 4 tables. However, I've started learning SQL pretty deeply since my latest job has one huge shitty mssql peice of legacy bullshit that I have to use in PHP, C++, and Python. Perhaps now that I understand SQL better, SQLAlchemy may be a more useful tool. Really what I want is a way to turn tables into tree-like structures. I know it can be done with foreign keys and crap, but it just doesn't feel right...
You mean python bytecode?
Lots of reasons. sqlalchemy is more than just an ORM: http://www.sqlalchemy.org/docs/_images/sqla_arch_small.jpg The two main reasons for me are: * Connection pooling * Smoothing over all the crap that exists in DBAPI - the connection/query layer of sqlalchemy is what the DBAPI should have been. If you add in the sql layer (which is totally separate from the ORM) then you get a nice way of building up queries that doesn't involve hackish string concatenation (that usually ends up being vulnerable to sql injection) ..
Agreed. I'll definitely be on the look out for more documentation on the subject
Fair enough. I'll have to give SQLAlchemy a better look on my next project. As I said below, I've been learning a lot more straight SQL lately, so the SQLAlchemy paradigm may click better this time around.
Uhhh, ummmm, uuuuhhhh... [insert generic speach here] uuuuhhhhh, ummmmm, uhhhhhh.... To be fair though I would have probably done much worse and only have about 1% of the knowledge that this guy does on python ;) -- I still couldn't watch it because it was making my brain asplode.
The previous releases's goal was compatibility with Python 2.5.
&gt;thought the whole point of PyPy was that they could do everything a thousand times faster. I'm afraid, that has not been the case for a very long time Here is a discussion from 5 years ago http://www.mail-archive.com/pypy-dev@codespeak.net/msg01157.html to give you a taste of pypy priorities.
"priorities" is not necessarily a word in the pypy namespace.
How do you know that a mailing list discussion of five years ago is still completely true today? If you look at the archives of the [PyPy blog](http://morepypy.blogspot.com/) of the last year, you will note that most posts are about working on the JIT, which is all about speed.
Yes, indeed! We only do completely random things! Next week we will switch to Fortran and try to make it as slow as possible!
Please do a whitespace version after that, so I can print the code eco-friendly.
It's great and easy to set up so long as your site doesn't need to accept large-ish (over 500kb) file uploads; otherwise uWSGI hangs up. This was on uWSGI + Cherokee
I tried it, but psyco is still the fastest thing on Earth for Python. 
Psyco is still faster.
For what exactly?
For my program.
Which is? If you can point someone to the program, then we have a chance of improving things. Otherwise, not our problem.
I clicked hoping to see that I could get the memory usage of *any* process, not just ones I spawn and only in Linux.
Too bad Next/Previous links (usually near the Module and Index links at the top right corner of the page) are not here, it's less convenient to have to go back to the index in order to see the next page :/
There are X-platform methods described there too. Not just linux only ones.
That was very brief, but I hope it inspires others to take a peek under the hood of their favorite languages!
Aha. In the update, I see psutils, which is the best of the bunch by far.
Oh, sure, pypy focus has shifted to JIT within last couple of years.. (Which is very good, as without that shift pypy would have been totally pointless while now there is a good chance that this project will actually result in something tangible). Note that I was answering a very specific question: "What was the theme of the other releases? I thought the whole point of PyPy was that they could do everything a thousand times faster" and the truth is that, for the most of pypy existence JIT and speed was at best only one of the goals.
Ah sorry. Yes, I see your point very well now :-).
Batteries included. So many damn batteries that most people, including myself, don't realize how cool some of them are.
Unfortunately we don't have the benchmark suite that we should have: how do webservers act under weird load. How do they act when the app sometimes freezes? (and there's several kinds of interesting freezes) How do they act when a client uploads something really big? When it uploads something really slowly? How does it act with different mixes of CPU bound and IO bound applications? Everyone says "benchmarking is only valid with real-world applications" but it's not actually *that* hard to simulate real-world applications. Do `for i in range(10000): pass` and it's not a terrible simulation of a real-world application. I started work on this, and it's wasn't that *hard* really, but actually getting the testing rig automated was challenging. I've lost the code now. But I'd love to help someone else trying to make a really good suite.
why do I like Rocket? - it is WSGI, pure Python and as fast as a multi-threaded server gets - runs everywhere (Tornado for example requires epoll) - the source code is very readable - it comes in one file and runs with 2.x, 3.x and Jython - the API is compatible with CherryPy - HTTPS only requires the ssl module that comes with python 2.6 while CherryPy requires OpenSSL for example - HTTPS works with very large files (tested up to 2GB) while other python web servers are known to truncate downloads over HTTPS if the data does not fit in memory. Thanks to the author, Tim. 
2.7 times faster for django, if you don't have a dep on a CPython module, Pypy really deserve a test ...
You sound like you are working on PyPy. If this is the case congratulations on the new release. I like the project. My program is about deep searching a tree with exponential growth and is not for release but just something I investigate. What amazes me is that after all those Python years Psyco is still the fastest thing on Earth when it comes to raw Python speed and still Psyco was abandoned and not supported or improved for so many years now. Instead people are trying to rewrite over and over again without even coming close to Psyco. 
&gt;ZODB is cool no matter how you look at it. Unless I'm missing something, it's surprising that it isn't used in more applications as a standalone object store. Reading this book has put that on my list of things I intend to try. It seems as though it ought to be the "SQLite" of the NoSQL movement from a Python standpoint Yeah, except for the fact that only your python stack can get at it and there is no provision for live replication. Your ZEO server becomes a single point of failure. Which is sort of the opposite of the NoSQL movement in its natural habitat, seriously large datastores where you need horizontal and vertical scaling. I am not a generic hater of the ZODB, I actually like it quite a bit and am running more than one app using it right now.
...which is probably why he compared it to *SQLite*.
Yeah, okay. You're right. I think I am just looking for an excuse to channel my annoyance at the lack of live replication in the zodb. Although the new sharding thing I am looking forward to trying out.
Indeed, pretty cool cross platform library :) Syrupy looks good for *nix machines though.
You should really signal this to Cherokee mailing list. All the POST code handling has been rewritten recently, and all the handlers (uWSGI included) use this in the latest/trunk versions.
Yes, I am working on the project (so is gutworth, btw). And it's really not true that Psyco is better always, we now have a number of large programs that Psyco does nothing useful at all with. Psyco was a dead end, it's incredibly hard to work on, that's why its author stopped working on it. Anyway, if you can give us some small code example where Psyco is faster, we can try to help. Otherwise we can't.
Does it even support arbitrary indexes?
In theory no, in practice you plug in one of the catalog solutions for it, which provide that functionality.
Does anyone here use this? Care to share an opinion? Anyone compile from source on OS X Tiger?
I've played around with Mayavi2 quite a bit and like the GUI. It provides a very intuitive concept of data sources, filters and visualization modules which is a great simplification compared to the underlying VTK\* object hierarchy. Another thing I like is that you can script it from Python and then pass on the control to the GUI in order to let the user continue from there - compared to VTK which also has Python bindings, but is more cumbersome to make really interactive. \**Mayavi relies on TVTK which is more or less an abstraction layer wrapped around VTK.* Honestly though, in the end I only use VTK for in-situ visualization of data from large simulations and do all my post-processing using PyLab and VMD (specifically intended for atomic data). Primarily, this is because Mayavi2 relies on an ill-supported XML format for input files, and I have yet to code up full I/O functionality for this format. VMD and similar programs support widely adopted file formats, which are all better documented than the aforementioned XML. By the way, you can transfer numerical data between Python and VTK just using pointers to the allocated memory, so that's a lot faster and easier to get running.
From the [status blog](http://morepypy.blogspot.com/2010/03/introducing-pypy-12-release.html): &gt; Known JIT problems (or why you should consider this beta software) are: * The only supported platform is 32bit x86 for now, we're looking for help with other platforms. * It is still memory-hungry. There is no limit on the amount of RAM that the assembler can consume; it is thus possible (although unlikely) that the assembler ends up using unreasonable amounts of memory. Probably not quite ready yet. 
I can't comprehend how you still have doubts if you've already come across the actual docs on the site which are pretty damn thorough. And SA is not nearly as verbose as Hibernate. I'm not sure there is a common approach. typically what I do in my programs for the "model layer" is this... * db/meta.py holds a reference to the sessionmaker(scoped_session) and metadata * db/manage.py for initialization, usually has at a minimum an init_model function, and create_tables,drop_tables init_model is passed a session and metadata which it in turn will use to set the vars in meta.py and depending on how many tables/classes I have to map... * db/schema.py - tables that will be mapped to classes * db/model.py - classes to map and the mapper calls, if the database already exists and for some reason I am not using the declarative style. the above 2 for simple apps I'll collapse into db/model.py Other things: I typically have a base model class with some convenience methods on it. def qry(cls):... def _get_session(cls):... and others in a web app for example, config will be pulled from a paste.ini file and somewhere when the app is being brought up it calls init_model .The point is init_model is called at start up.
Get the SQLAlchemy book from orielly. It's worth the 35 dollars retail you'll probably pay.
it is very easy to write your own connection pooling.
Rather than a "get_session" function you might want to look at adding the query as a property, like Django ORM managers: http://lucumr.pocoo.org/2009/1/3/sqlalchemy-patterns-in-zine
i do both actually. just couldn't be bothered figuring out the comment formatting here to reflect that. That article has some good stuff in it however I think a qry class method in a base class leads to less code than the query_property idea. class BaseModel(object): @classmethod def qry(cls, *attrs): """ return a query for the class with or without specified attributes """ if len(attrs)==0: return meta._s().query(cls) else: return meta._s().query(*attrs) 
I don't know why this article is accompanied on Reddit by a thumbnail of Magnum P.I., but it's awesome, so I thought I'd mention it.
MagnumPy is listed on that page, with a picture ;)
Ah I see it! &gt;MagnumPy has to be the server with the most awesome name. This is still a very young project but its homepage is making some very strong statements about its performance so its worth testing out. Thanks for pointing out my lack of attention span so clearly.
It would be nice to add benchmarks for [Rocket](http://www.launchpad.net/rocket). It is new but has lots of interesting features, very clean design and seems to be faster than cherrypy on multiple concurrent requests.
wow, had no idea cherrypy performed that well. I'll have to look into that. 
really interesting ! great job !
Very interesting article ! When you know that to install uWSGI into your virtualenv you just have to do : pip install http://projects.unbit.it/downloads/uwsgi-0.9.4.3.tar.gz There is some dependency on python-dev and libxml2-dev to compile it. Enjoy, --yml 
Once again a benchmark is bitten by inconsistent methodology. To take an example: uWSGI and gunicorn are explicitly designed to *never* handle client requests directly. Both are meant to sit behind a proxy (ideally on the same machine, talking over a socket) which will actually deal with the clients. uWSGI was in fact set up that way for the benchmark, running behind nginx, but gunicorn wasn't. Which defeats the purpose of comparing them to each other or to anything else... *Edit:* and it's also been pointed out that the "benchmark" only allowed one worker for the preforking servers. Which is even more fail.
Putting Gunicorn behind NGINX will not magically increase its performance it will only add to the latency. 
It most certainly will make a difference in performance, because it (and several other preforking servers) are designed on the assumption that it won't ever deal with client requests directly. If the architecture's designed to be talking to a local proxy over a socket with a predefined number of simultaneous workers, it won't be designed to be fast at accepting and handling arbitrary numbers of connections coming in over a network. And either way, running one server in its intended configuration and not another isn't worthy of being called a "benchmark".
It always hurts my eyes to read the method names of the unittest test cases with camel casing all over the place. How are they going to manage getting it into Python 3? I was under the impression that libraries in the standard library of 3.x had to conform to PEP8, and hence use PEP8 style method naming -- even if it meant breaking backwards incompatibility.
I was blown away by the charts in that... try hovering over a line or an item in the legends!
Could those colours be any more the same? :(
Too bad they have not included [Rocket](http://launchpad.net/rocket) in the benchmarks. The [author benchmarks](http://groups.google.com/group/web2py/msg/a04d593fb423f76f) show it outperform cherrypy's.
I'm really impressed by uWSGI, and since I'm equally impressed by nginx, it's basically the best of both worlds. I don't think I'll be using Apache any more for running my web apps...
Some of those servers need to be configured a bit better. For example, from my experience, adding worker processes to uWSGI improves the performance (yeah, defending a leader...). Comments on the bottom say the same thing about Gunicorn.
My reaction was complete the opposite. I had no idea what line was what because they were too thin to differentiate between them. It wasn't until I saw your comment that I found that they were interactive.
ZEORaid should support live replication for ZODB, unless I don't understand something: http://pypi.python.org/pypi/gocept.zeoraid It's true that only the Python stack can get to your data. 
I'd say it supports arbitrary indexes (there are various BTree components included with it, though be prepared to use a catalog library or roll your own), just not arbitary *queries*. That's a drawback compared to many databases. Then again, it does offer arbitrary access to your objects on the Python level without you having to do any work for it. Actually, for arbitrary queries, there's this: http://pypi.python.org/pypi/gocept.objectquery but that last I heard needs a bit more maturing. 
Have you used uWSGI in production, what sort of loads, is it stable?
Why don't you try it in practice rather than succumb to theory? Putting the async nginx in front of the a worker based web server does in fact increase overall performance. Each request your dynamic webserver gets is handled and returned as fast as possible because you are no longer wasting the precious threads on spoonfeeding slow clients. In a production system with real loads, this makes a huge difference.
I'm missing flup with FastCGI behind an Nginx or Lighttpd server. I thought flup is one of *the* solution besides mod_wsgi. Is it obsolete now?
I use lighttpd + flup and I am pretty happy with this solution. I have never done benchmarks though.
Interesting data, thanks for posting the link. Seems a histogram would be a better visualization since the x-axis label ordering is somewhat arbitrary(?) 
Oh, I'm sorry, I meant I'm impressed by the benchmark. I haven't really been able to try it yet, since it's pretty new (I wanted to deploy my latest project in nginx but there was no good WSGI implementation at the time). If anyone has, though, I'd be interested to know their answers to these questions too.
Where did you get that impression about all standard library modules changing APIs in a backwards incompatible way for Python 3? In fact the opposite is true - APIs between Python 2 and Python 3 are to change as little as possible (only where forced to by the language changes - usually because of bytes / string differences). This is to make porting applications from Python 2 to 3 as easy as possible.
Well he does state: &gt;Below you will find the results as plotted with Highcharts, the line will thicken when hovered over. This will also work on the legend, which I find personally the most easy way to look at the results.
Coincidently I submitted [a Magnum P.I. clip](http://www.reddit.com/r/videos/comments/be3mb/magnum_pi_did_you_see_the_sun_rise/) a few hours ago.
This is definitely a cool set of benchmarks. And if you're serving an I/O bound app, these are good numbers to know. On the other hand, if you're just a normal shmoe that uses Django or Pylons or whatever to serve up a web app, the speed of the WSGI server is almost never the bottleneck. Most highly dynamic web apps wouldn't run any faster under uWSGI or HyperFastMegaWSGI or whatever as they will under, say, wsgiref, because they're usually CPU bound.
Usually CPU bound? I would have thought database I/O bound was the more common case.
Nicely done. Great scene. How well I remember that episode. I am one of those who completely un-ironically loves pretty much every episode of that show.
colors. FTFY.
I'd have to agree. The benchmarks are a little less useful when they leave out Rocket; guess someone should contact the author.
Yeah, except ZEORaid isn't ready for prime time. It is a new product that is still getting the bugs worked out and if you use it in anything serious, you're nuts. The only solution you can really go with right now is relstorage, which is going to cost you oodles of money.
Most often here we seem to be blocked on template rendering speed. Even using the fastest templating engines. YMMV of course. Although maybe in your case, your database is slower than your templates. At the end of the day, you're still bottlenecked on something not-the-server, though.
If you read the article you would have noticed that there are no slow clients. In the comments the author also notices that he tested BOTH approaches but didn't notice any difference. This is being affirmed by Paul Davis which i believe is one of the main contributors if not project owner of Gunicorn.
*Perl
The x-axis has partial orderings, but is not fully ordered. You're probably right about the histogram, I just generated the line chart because I was familiar with it.
The argument could be that one worker is not enough to fully maximize the CPU potential. However, than this should also be a problem with for example mod_wsgi. Look, I am not trying to bash Gunicorn or anything, far from it. I just think that the article puts a balanced and detailed overview, it also provides lots of detail how the benchmark was performed allowing everyone to verify the results and counter with coherent arguments. As the author notes it is on a very specific problem domain, it could very well be that Gunicorn does not correctly fit in this domain. But please lets not get religious about web servers just yet. I think the your web-framework beats my web-framework battle was enough already. And yes, I think its harsh to call it 'fail' or saying it is not 'worthy of being called a "benchmark". Edit: The post has been updated with added results for Gunicorn with 3 workers
Hey man, even Larry Wall says it's a Pathologically Eclectic Rubbish Lister. I stand by the Acronym. ;)
This benchmark is bad, and the comments here are worse.
colours FTFY
I swear by matplotlib. I'd like to know if anybody has any luck playing around with pygrace or any other python-to-xmgrace interfaces.
Don’t complain about British spelling. Yes, it’s weird and redundant. But no, you don’t get to fix it.
visual php.net on ponies
why would relstorage cost you money? 
Don't know how ready for prime time ZEORaid is or not - it's been around for a while but perhaps it needs more work. The ZODB guys should put this info on zodb.org if it isn't already. :) 
He probably means [ZRS](http://www.zope.com/products/zope_replication_services.html)
Ah - I must have misunderstood something then. I think I have been reading between the lines of [PEP 3108](http://www.python.org/dev/peps/pep-3108/) with regards to the "PEP 8 violations". 
I used a python interface to Grace with a lot of success back in 2002-2003, but since then Matplotlib has just been so much easier. I seem to recall it was by some Caltech folks and used a pipe for interfacing, rather than linking against the grace lib.
lxml - http://codespeak.net/lxml/ It's fully featured, fast and extremely easy to use.
ElementTree is quite adequate. lxml is very similar but with extra features that are nice. lxml performs somewhat better (including memory), which you'd only notice if your data is really large. Probably most people don't know this, but using lxml you can do CSS queries on XML, not just HTML, it even does namespaces.
The title should be "Benchmark of Python WSGI Servers".
lxml is a bit of a bitch to compile on a MAC. If you use [buildout](http://pypi.python.org/pypi/zc.buildout), then there's a [recipe](http://pypi.python.org/pypi/z3c.recipe.staticlxml).
Constructive
n.b. lxml is pretty easy to install with 10.6 (2.2.6 installed with a simple pip install for me). For 10.5, here's a reasonably close recipe which you might need to adjust for current versions of lxml, libxml and libxslt - take care to avoid the sudo step if you're using virtualenv: http://gist.github.com/167784
I've never had any data in XML, but I do work in Biology, and I love Python. ElementTree is almost certainly all you need, and its included in Python 2.5+ http://effbot.org/zone/element-index.htm http://docs.python.org/dev/library/xml.etree.elementtree.html Caveat: If you're working on really huge datasets (over a gigabyte or two of XML, you may not want to use anything but SAX, also in Python by default) 
I guess. Anyway, there are three solutions for replication, ZEORaid and Relstorage, both free and of varying degrees of maturity, as well as ZRS, which does cost money. Not bad. :) 
ElementTree = battery included.
use the mouse to hover the legend and see the matching line highlighted (does not work on touch screen devices such as iphone and android though...)
&gt; In the comments the author also notices that he tested BOTH approaches but didn't notice any difference. In the update to the benchmark the author put gunicorn behind nginx and gave it a couple more worker processes. And lo and behold: * Concurrent requests more than doubled * Response times dropped by 75% * Error rate dropped by 75% And yet you were here earlier insisting that running gunicorn *in the configuration it's intended for* wouldn't improve its performance...
I first used a single worker behind NGINX. The difference is not the placement behind NGINX but the usage of additional workers.
In real-world situations, though, nginx will make a *huge* difference (and, since all the requests were coming from a single machine, I'd suspect it still helped a bit); gunicorn flat-out isn't designed to talk directly to clients. And doing the benchmark initially with uWSGI proxied and gunicorn not basically destroyed credibility; any time you do a benchmark where you run one piece of software in its intended configuration but not another, the numbers you'll get out of it are useless.
Both etree and lxml have SAX-like APIs (iterparse) while still being reasonably sensible APIs (unlike SAX). In my experience lxml seems to take about 2x the amount of memory of the dataset itself (when using documents). It's much more compact than etree because it doesn't create Python objects except on demand. So you have a fairly compact XML memory representation that you can use, e.g., XPath on, and only the actual results you get back are turned into Python objects.
FWIW, Apache/mod\_wsgi was put at a disadvantage by putting the number of threads at the ridiculous value of 16000. Apache doesn't ramp up the number of threads in a worker process, it will actually create that many threads at the outset with that configuration. This is why Apache/mod\_wsgi had such a large memory footprint. That number of threads could even cause a reduction in performance. For a simple hello world application which has a quick response time, you could have got away with a handful of threads although using multiple processes would also have helped when concurrency starts to go up. I have added comments to the post, but you might find further discussion in time about it over at 'http://groups.google.com/group/modwsgi/browse_frm/thread/95cf698c1c8ded79'.
I agree, 16k is a ridiculous value. I did not actually use that amount of threads and that wouldn't really be possible as it invokes the OOM killer on my machine. The setting was a leftover from some experiments, i have updated the post accordingly. 
I found that out after I read the comments. Still, though, I found it really hard to follow lines.
Heh, how is it more redundant than anything else in English? :P
lxml is *by far* the fastest parser. Don't ever touch stuff like minidom or so. Just lxml. :)
I find your tone harsh and it defeat what you are saying and destroy your credibility. Building such benchmark is hard and no matter how much thought and effort you put in them it will trigger this kind of thread. There are 14 WSGI servers which are evaluated and each of them comes with dozens settings. So the complexity is great, instead of this kind of unfunded criticism by doing some hand waving, it would be much more efficient to pick 2 contenders and compare and contrast them. 
According to [jdberg](http://www.reddit.com/r/programming/comments/b5jya/i_gave_a_talk_at_pycon_about_reddit_ec2_python/) Reddit uses Paster (Pylons default) but he doesn't like it.
ram consumption is also a hard limit on many hosting solutions.
Start [here](http://docs.djangoproject.com/en/dev/). I just love this framework. Apache is good and all, but I've been a lot happier after I moved to [nginx](http://wiki.nginx.org/Main).
You may want to look into a micro-framework like Bottle before moving to Django, particularly if you've never used a web MVC framework before. Each has their own niche, and you'll understand why once you use both. As far as Apache goes, that's fine, so's nginx I hear, but you don't have to worry about setting up a webserver just to develop an app.
If proper benchmarks are too hard for the author to do, he should not continue to publish them.
Can you add Rocket to your benchmarks?
There are lots of factors which go into a good benchmark. But two which are absolutely critical are: 1. Consistency of methodology 2. Appropriate use of the tested components Consistency is necessary because without it you can't draw meaningful comparisons; without consistency you're comparing apples to oranges. Appropriate use is necessary because without it you don't have relevance; if you only report results from a configuration no-one would ever use, then your results won't represent the things people would see in the real world. As originally published, this benchmark failed on both counts: it was inconsistent, and it used certain components inappropriately. Criticizing that isn't "unfounded"; benchmarks which fail these requirements *cannot be trusted by anyone for any purpose*, because they're not "benchmarks" at all.
lxml third vote.
I don't see why this is hard to code, it'd be just a few lines of code with bottle.py. I'm confused as to why you can't use ab, though.
For some of it you can, but I don't think ab can do things like a slow upload. All the apps can be pure WSGI, no framework at all; each example is just a couple lines of code. Making it completely scripted and repeatable is the hard part. (But yeah, not really that hard.)
Even 1000 is way over the top. It is arguable whether one would ever in practice run a single Apache process with that many threads even if serving static files, let alone a dynamic Python application. You would always scale out using processes.
&gt;Applications that segfault. ctypes is specially designed for this. Haha.
Spend some time working with [this](http://diveintopython.org/) and then give [cherrypy](http://www.cherrypy.org/) a try.
Hmm, even JUnit 4 uses @Before, @After, @Test, ... annotations to denote UT framework methods. So why can't Python? Using name magics is so Python 1.5. I'm glad that `unittest 2` didn't attempt to win the race for the most sophisticated test discovery a la nose or py.test but kept this aspect simple and reliable. 
There's always [tc](http://linux.die.net/man/8/tc); so long as you can assume the benchmark runs on a Linux machine, you can use it to throttle the client and simulate a slow connection.
Obligatory: maybe if it weren't hosted on Launchpad, people could figure out how to get a copy of it... (I usually don't bother trying to figure out Launchpad's interface to get software hosted there, and it usually works out all right because someone else will have a similar package hosted sanely)
*waves at chromakode* I knew I'd seen you around sooner or later. (All but 2 people seeing this comment won't know what the hell is going on here)
Have to agree. Launchpad is an exercise in how to follow SourceForge into the abyss of anti-user interfaces. Although I may be a GitHub fanboy, even bitbucket manages to give a solid user experience. If your project hosting site is actually an MMO version of "where in the world is the download source code button" game, you lose.
Upvote fo the python challenge. I've spent a bunch of time there now and recommended it to friends as just plain fun.
yml, You're definitely right, testing this many different implementations is a huge undertaking. There's a large amount of knowledge that would be required for any person to adequately know about all the configuration options for this many servers. And gunicorn is a bit of a weirdo when it comes to processing models. We're neither thread based or event loop based. That can genuinely confuse people until they realize that we're much simpler than most servers. That said, our response times were reported as an order of magnitude slower than any other server. Generally speaking, if you're into the whole experiment and observation thing, orders of magnitude are important.
Spoiler: #python on freenode.
Take a look at [web.py](http://webpy.org/). When Reddit was rewritten in Python this was the framework they originally used.
Linux is a reasonable assumption IMHO -- it's not much of an exageration to say any serious deployment is on Linux, other machines are just for development. I must admit the tool is dense enough I am not at all sure how it would be used for this.
I don't really know either, since it is still beta and I haven't seen anyone using it substantially, so my natural fear of things with a 'b' on the end of their version numbers has kept me from trying to put it in production. My threshold for not ready for prime time is pretty low. But I think folks who are keeping track better than I am seem to feel that it is still a little premature to go full bore with it as well. http://n2.nabble.com/High-Availability-Plone-tp4461036p4465524.html https://mail.zope.org/pipermail/zope/2009-June/175211.html
Ack, this is what I get for not drinking enough coffee. I meant zope replication service costs a bit. But the mistake has turned out to be a good one, I haven't really looked at any of this stuff all that closely in the last year. And looking up stuff in relation to this conversation shows me that enfold has been using relstorage and then replicating on the sql servers and it's been working for them. Seems clunky and nasty and starts to make you wonder why you are using zodb in the first place if you are just going to be using a relational database on the backend anyway. SQLAlchemy seems like where you start to go in that case. Of course, if you are wedded to zope/plone . . .
I love it when this happens. :)
&gt; We’re missing good benchmarks. Don't call it that if you don't want that. What is described here is a wish for some realistic set of tests measuring: * load: how many users can the app sustain with decent response time * performance: how fast can the server be with some average load * stress: where does the app break * volume: how much data can the app manage * failover: how does the app recover from a failure Those are all different tests that can be orthogonal to each other. There's no magic there, you need a real application in a real infrastructure and use a dedicated tool such as webload, LoadRunner, or something equivalent. This is a consuming task. 
The man page is scary, but some of the examples I've found are pretty straightforward. This, for example, would add 100ms latency to all outgoing traffic from `eth0`: tc qdisc add dev eth0 root netem delay 100ms There are a bunch of examples showing how the options work [in this article](http://www.linuxfoundation.org/collaborate/workgroups/networking/netem).
&gt; since all the requests were coming from a single machine Uhm, did you actually read the article? He states several times that he did a distributed benchmark where the requests where coming from 3 different client machines. 
My Favorite [ElementTree](http://effbot.org/zone/element-index.htm). Light-weight and fast XML Parser!
&gt; General rule for python: whatever's in the standard library is the one that sucks. Bullshit.
either web.py or tornado http://webpy.org/ http://www.tornadoweb.org/
The advantage of using relstorage is that you get the transparent object persistence of the ZODB. I think SQLAlchemy is great, but when I use it I need to think hard about tables and relations and it's frequently hard to fit in the object models that I want. 
Actually, good point, you can code them in WSGI in a few lines as well (too much framework has rotted my brain). Repeatability is indeed harder, but hopefully it won't be that hard...
hey man, since you seem like a sheep, just follow what I do and use bottle, webpy, or django. 
 a=0 while a &lt; 5: a = a + 1 print a, "Hello" while a &gt; 0: print a, "World" a = a - 1 
The problem is in your while statement logic. Your second while loop is looking for a to be greater than but NOT equal to 5. If you simply change form while a&gt;5 to while a&gt;=5 the code will run ad infinitum. a=0 while a&lt;5: a+=1 print a, "Hello" while a&gt;=5: a+=1 print a, "World"
Instead of: a &gt; 5: use: a &gt;= 5 after the first loop, a == 5. Your second test (a &gt; 5) returns false because a ISN'T greater than 5. edit: for your second question. either use: while a &gt;= 5 and a &lt; 10: a = a + 1 print a, "World" or while a &gt;= 5: a = a+1 print a, "World" if a &gt; 10: break 
Even though I find django very useful it seems like OP wants to learn python. Learning django is mostly about learning django. I would rather recommend web.py or writing a wsgi handler from scratch. That will force OP to get used to the python standard library and doesn't involve to much magic.
 a=0 while a &lt; 5: a = a + 1 print a, "Hello" will print "a, hello" until a becomes 5, at which point you fall out of the while and get to while a &gt; 5: a = a + 1 print a, "World" at this point, a==5, so the test doesn't pass and you don't get in your while. The error you're making is not related to python. &gt; Secondly, this prints an infinite number of "Worlds" Well that sounds logical, you're executing the loop as long as `a &gt; 5`, a *starts out* being greater than 5 and only ever increases, what did you expect? &gt; what would I put in the code to make it print the word "world" 5 times? Remove the while altogether, you know what by the time you fall at the end of the previous while `a == 5` anyway, why would you need to re-test for anything? Also, iteration on integer ranges in Python is not performed through `while`, use `for` and `range`. Furthermore, I strongly suggest that you read through [the official python tutorial](http://docs.python.org/tutorial/index.html) at least once. Do you have any previous experience in programming?
Thank you,m this is exactly what I was looking for, am I right to assume that "break" stops the print function?
Hi thank you for your input. I do not have any previous programming experience, I don't understand very much at all. It's merely a hobby for me at the moment which I hope to gradually improve upon by asking stupid questions like this so I can better understand what I am doing wrong. Thank you for that Tutorial thread, I am reading another one currently, but I have bookmarked that one to look through as well.
You aren't, `break` stops the `while` iteration.
"break" breaks out of the while loop. If you had more code after the while loop, it would move on and run that.
Ok, I understand this, and i realised after I had posted the question that I needed to insert the a &gt;= 5, but I still could not figure out how to stop the word "World" printing into infinity, but after reading some otehr responses I think I get how to do it now by including " a &gt;= 5 and a &lt; 10"
I want to recommend to you the [CarlH Programming](http://www.reddit.com/r/carlhprogramming/) subreddit. His course is designed especially for people new to programming. His style of teaching is really unique, because he touches on subjects many would consider too advanced for beginners, but he does it in such a way that even a novice can understand it. Therefor one gets a good overall understanding how things work. The course is well built - there are tests you can take every 10 lessons. That way you can make sure you got everything to understand the following lessons. Dont let the number of lessons scare you. Just start at lesson 1 and give the first few lessons a try. Soon you will find yourself blazing through the lessons enjoying learning something new.
&gt; The other parsers lack basic shit like xpath I guess you haven't tried [amara](http://xml3k.org/Amara2/)
,,Someone said something so it is obviously true, no further argument will be provided except this list of these modules that are of good, field tested quality'' really requires a serious retort these days? I use all three of those when I can not be bothered to install additional packages (production systems or just lazy) and I don't think that they suck. Moreover I think that you, good sir, suck. And that no matter how many words you can pour in your comment this will not change. Should now say that I'm sorry, but I'm not.
Hey, thanks I've been doing his lessons, they are extremely helpful and I have decided to mix his lessons with learning python as I have decided it is the programming language I wish to use. But thank you for pointing it out, it gives me faith it is a worth while course to stay on.
Oh I see, thank you for clearing that up for me.
Ok then, thank you!
This is THE XML parser for Python. If you have this (and maybe stuff like BS for HTML) you can easily forget other tools. If you don't or can't be bothered -- use ElementTree, but embracing lxml is a matter of time.
&gt; runs everywhere (Tornado for example requires epoll) Actually Tornado will fallback to select if epoll is not available. &gt; HTTPS only requires the ssl module that comes with python 2.6 while CherryPy requires OpenSSL for example That's actually not quite correct with CherryPy 3.2 which supports both out of the box. 
Looks like it, useful link. The ZODB guys should really update their website with this kind of evaluation too. 
Hi, I typed ipython console program into Google and got a fuzzy mass of stuff I didn't understand. If you have the time, please could you tell me where to get it from and the basics of using it?
Are you learning both C and Python simultaneously? That doesn't sound like a bad idea to me at all. If not, don't worry overmuch about the language you start with. Once you understand “Programming” you can pick up almost any language in a day if it's in the same paradigm. (eg, functional languages like LISP and Haskell are a whole different game.) C is a smaller and perhaps simpler language than Python, and is perhaps better for learning about “computing.” Most of what Python does is provide trivial access to things you would have learned to do manually in C. That said, you can probably do everything in a C course in Python. I won't bash python, because it really is a wonderful language, especially for beginners, but it will allow you to avoid thinking about things that you perhaps ought to be thinking about when learning to program. (e.g., the "for item in collection:" syntax, strong types, and memory management) Don't let me dissuade you from Python, but keep it in mind. You will probably have to learn about some libraries to do some bit twiddling exercises that come naturally in C.
The first option is decidedly better than the second one, because it keeps the logic explicitly in the loop control. Even better, the `a &gt;=5` is unnecessary, because by the time your code reaches that point, the condition is already true, and will always be true. a=0 while a &lt; 5: a = a + 1 print a, "Hello" while a &gt; 5: a = a + 1 print a, "World" A good *gedenkenexperiment* to help you see what's going on is to manually unwrap your loop. Fire up python from the command line: $ python &gt;&gt;&gt; Now type the following: &gt;&gt;&gt; a = 0 &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "Hello" 1 Hello &gt;&gt;&gt; a &lt; 5 True The condition is true, so we restart the loop. &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "Hello" 2 Hello &gt;&gt;&gt; a &lt; 5 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "Hello" 3 Hello &gt;&gt;&gt; a &lt; 5 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "Hello" 4 Hello &gt;&gt;&gt; a &lt; 5 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "Hello" 5 Hello &gt;&gt;&gt; a &lt; 5 False The condition is now false so we skip to the end of the loop: &gt;&gt;&gt; a &gt; 5 False The condition is false, so we skip to the end of the loop, and the program is over. Change the second condition to a &lt; 10: &gt;&gt;&gt; a &lt; 10 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "World 6 Hello &gt;&gt;&gt; a &lt; 10 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "World 7 Hello &gt;&gt;&gt; a &lt; 10 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "World 8 Hello &gt;&gt;&gt; a &lt; 10 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "World 9 Hello &gt;&gt;&gt; a &lt; 10 True &gt;&gt;&gt; a = a+1 &gt;&gt;&gt; print a, "World 10 Hello &gt;&gt;&gt; a &lt; 10 False And now the program is over.
Windows, and I have found and downloaded it, now to install it. All I need to know I guess is how does it work? and what can I do with it?
Right I've installed it, but I have no idea what it does, how to make it appear and how to use it -.- hehe.
Ok ive downloaded it and unzipped it into my downloads folder, but I don't know what to do with it now. Sorry for all of these questions, as I say, I am totally new to all of this, and I'm here to learn and understand as much as possible.
In fact "a &lt; 10" is sufficient; you already know that a &gt;= 5, because the first loop ended (so a&lt;5 is false).
Not really answering the question, but instead of using while and incrementing a counter, you can use range(): range(5) returns a list of numbers 0 &lt;= i &lt; 5, so [0,1,2,3,4]. range(1,6) returns [1,2,3,4,5], and range(6,11) returns [6,7,8,9,10]. for a in range(1,6): print a, "Hello" for a in range(6,11): print a, "World" 
&gt; Also, iteration on integer ranges in Python is not performed through range Huh? Upvote for concisely pointing out the gap where a == 5, but this is confusing. Iteration on ranges of integers is indeed done with foreach and range(). Are you sure you meant to say "is *not* performed through range"? http://docs.python.org/library/functions.html#range
I agree that the first example was better, I just thought it was worth mentioning how to use break.
Erm... yes, my fingers wrote the wrong thing, I meant to write it's not performed through `while`, or that phrase is completely moronic in the context. Fixed.
Think of the flow of control as top-down, and line-by-line. When your program reaches a while loop, it will evaluate the condition and if it evaluates true (i.e. if a's value is less than 5) it will execute the indented bit just underneath. When it gets to the end of the indentation it will return to the 'while' line above and re-evaluate. Your code will print 'Hello' x 5 and then 'World' x infinitely. Run the following two lines and observe the output. for i in range (0, 5): print "hello world" You could also (for experimentation's sake) use a list or some other data structure. You could do this with a list of strings and three loops: one to add the *hello*s, one to add the *world*s and one to print the end results. Something like: list = [] for i in range (0, 5): list.append("hello") for i in range (0, 5): list[i] = list[i] + " world" for message in list: print message
I suggest looking into web2py. Its a great framework to start out with IMO. At least take a look. http://www.web2py.com. It also works with all major HTTP servers.
Thanks, up vote!
Remember, most people have at least a calculus level understanding of logic before they dive into programming. I'm sure some people will say "But I hadn't had caclulus yet!", but they are probably pretty smart too. edit: I'm not saying that calculus is needed for programming, but the ability to think about a lot of the logic and control structures comes from math learning.
I'd pass on BeautifulSoup too. I've found lxml.html works just as well on html in the wild (and often better - I've seen BS fail on cases lxml handles fine). You also keeps a nice consistent API with the rest of your XML parsing.
So would it be worth not bothering, at least until I know calculus?
Can you personally justify your "General rule for Python?" Edit: Please.
Or, just to neaten things up: while 5 &lt;= a &lt; 10: a = a + 1 print a, "World"
&gt; But I hope someone writes a benchmark like that. Here’s some things I’d like to see benchmarked: Maybe you could have written these largely-trivial synthetic benchmarks yourself? The blog post you are responding to had the course code.. just add in your while loops, etc and re-run them. That would have certainly added more value than your suggestions alone.
In python you can also write 5 &lt;= a &lt; 10 instead of a &gt;= 5 and a &lt; 10 
&gt;as I have decided it is the programming language I wish to use. It's good to stick to one or two languages while you're just starting out, but you should remain open-minded about others. Python is fantastic, but poorly-suited for embedded programming, for instance. Learning a functional language once you grok Object-Oriented will expand your mind and give you new ways of thinking about problems. Don't make decisions now to limit yourself in the future - lots of languages are fun and useful, not just Python! =)
the second loop needs to be while while a &gt;= 5: since the first loop only takes variable 'a' up to the value 5 and the second loop requires the value of 'a' to be greater than 5.
Another keyword to remember is continue for example: a= 0 while a &lt; 5: if a == 2: continue print a a += 1 the expected output from this would be: 0 1 3 4 You'll notice the number 2 was skipped. This is the continue statement at work. Basically, continue means skip the rest of the code and go onto the next iteration. edit: oops, that's what I get for giving advice. Code that doesn't put you in an infinite loop: a= 0 while a &lt; 5: a += 1 if a == 2: continue print a
TIL in python you can string together comparisons... I've been using python for 8 years now and I didn't know that...
Thanks for letting me know.
Good point. You can get a copy [here](http://launchpad.net/rocket/1.0/1.0/+download/Rocket-mono-1.0.1.zip).
Oh yes, I did mean to state that Python is my starting point for programming, I know that if I carry on, I will be using all sorts to accomplish what I need.
You can even enable and disable lines by clicking on the names in the legend. 
&lt;ot&gt; Why is it whenever someone somewhere on the Internet says something like: "cool. What I would love to see from someone somewhere sometime is something like 'XYZ'." ... that there is always someone who says: "well, you start; you're not helping any by whining. Put up or shut up." We can have conversations without having to put up or shut up. I don't think the author was criticizing, indeed he explicitly said "It’s a decent benchmark, despite some criticisms." At least some significant part of Free Software culture is talking about what we all need... having some hermit go up to the mountains and return with code is romantic and all, but might it not be nicer if we all worked out together what was necessary, then bit off a little piece of it and worked on it? &lt;/ot&gt;
I guess. I think that most of us pretty much get the idea that we aren't going to use beta software that hasn't been tested in large scale installs in any serious client projects. 
I personally wouldn't worry about it. You get into some higher maths stuff as you advance, but for most things I've seen anyone with knowledge of basic algebra can grasp programming principles pretty quickly.
a) So ,,jnoller said it, it must be true''? Yay, go spread the words of wisdom to the un-enlightened. b) ,,Reading comprehension fail'' achievement unlocked. c) You first.
I barely understand algebra, but I've been programming since I was 10 (15 years now). Programming is easy. There's just a lot of tiny little things you have to figure out first. You're a noob, that's for sure, but don't get discouraged. The more you play, the more the tiny little things (like &gt;= instead of &gt;) will come naturally.
You can do this: wget http://web2py.com/examples/static/web2py_src.zip unzip web2py_src.zip cd web2py python web2py.py -i 127.0.0.1 -p 8000 -a 'somepassword' then wait it starts and open your browser at http://127.0.0.1:8000/admin you get a web based IDE. You can also edit the app files via filesystem as explaned [here](http://gluonframework.wordpress.com/2010/03/02/shell-only-web2py/) [here](http://web2py.com/book) is the documentation. For professional development with apache+mod_wsgi you can use [this script](http://www.web2pyslices.com/main/slices/take_slice/29) Here is a minimalist application: def index(): return 'hello %s' % (request.env.remote_addr)
Is not compatible with Cisco's ssh server implementation, which makes me cry. :/
In plain English: Your first while loop stops when a = 5. This is because you have "while a &lt; 5:" When a **is equal to 5**, it is not "&lt; 5". But your next while loop only runs "while a &gt; 5". Since a is **still equal to 5**, it is not "&gt; 5". Change your "while a &gt; 5:" to "while a &gt;= 5:" (greater than **or equal to** 5). 
I think sometimes it's an unneeded, unconstructive criticism. But in this case, the person has the necessary skills and access to VMs and other tools needed to perform the test. He also has the time (as evidenced by the well-constructed, in-depth blog post). In this particular case, I think it's clear that Ian had the ability to add much more to the conversation about synthetic web benchmarking than he did and I want to push him to do so.
works for me.
Sorry, but no: this needs to be an open and repeatable process that does not culminate in one-more-published-benchmark, but in code other people can use and contribute to. And no, I'm not able to take leadership on that, I already have too many [open source projects](http://ianbicking.appspot.com/projects). A blog post takes maybe an hour of time, a project takes much more time, more commitment, and more consistency of effort than I can provide.
Okay, excellent. Restricting yourself to one language is a silly habit that some programmers seem to pick up somewhere. Good luck with Python, then, and with the next one when you get there. =)
http://www.tornadoweb.org/ FTFY
Can you please elaborate? I was struggling with this for a significant amount of time. When I posted my questions to the paramiko mailing list I was told that the problems I was running into were caused by cisco's nonstandard ssh implementation. Do you have any scripts you could share?
&gt; People unless you are a module in the standard library, this isn't a personal criticism. You're not being downvoted because people take what you said personally, you're being downvoted because what you said was stupid. Here are a few samples: &gt; The other parsers lack basic shit like xpath (eg, tell me what's at /html/body/table/tr[2]/td) First, xpath isn't exactly basic. Second, etree 1.3 supports paths as simple as this. &gt; General rule for python: whatever's in the standard library is the one that sucks You infer the wrong generalities from verifiable facts. The truth is the following: for a module to gain traction with the community it has to be noticeably better than the one in the stdlib. That doesn't mean the one in the stdlib "sucks", neither elementtree (even with the critical lack of maintenance provided by effbot in the last 2 years) nor unittest (especially with the 2.7/3.2 updates, which have killed the future of nose) suck. It's not a zero-sum game. &gt; * unittest? Everyone uses nose. &gt; * configparser? Everyone uses configobj. &gt; * elementtree? Everyone uses lxml. All three are definitely quite excessive declaration, especially concerning lxml, which has to pull in all of libxml2 and libxslt, is fucking huge and takes hours to compile. Is it an excellent library? Definitely, but so is ElementTree, and ET is useable in any situation. &gt; Source of 'where good modules go to die' quote was Jesse Noller from Python Core in September last year for stdlib SIG. You take a quip and you declare it the infaillible truth. And then you're surprised that readers aren't impressed?
I doubt the short list of simple benchmarks you included would take more than an hour to write up. On the client side you a correct in asserting that `ab` won't suffice, but you certainly wouldn't have to write anything, as there are a hojillion web benchmark tools ranging in complexity from Siege to JMeter that you could point at a list of URLs, one for each test or several at once for composite tests as you suggest.
No doubt. That's why I upvoted you. Just don't want to be teaching bad habits is all. 
xrange() is great, until he decides to try out python3. Of course, then his print statements would be broken as well.
This is probably the simplest example I can come up with that does something useful... You can use exec\_command, but that works kind of weird on IOS... read_until is implemented in the stupid/simplest way I could think of, it's worked for years though :-) I also have an expect like function that can handle multiple kinds of output, but that is beyond the scope of this example... import paramiko import getpass def read_until(chan, s): """Reads until s is found, returns data read""" buffer=[] while "".join(buffer[-len(s):]) != s : buffer.append(chan.recv(1)) return "".join(buffer) ip = getpass.getpass('ip: ') t=paramiko.Transport((ip,22)) t.connect(username='admin',password=getpass.getpass()) c = t.open_session() c.get_pty() c.invoke_shell() print read_until(c, '&gt;') c.sendall("show clock\n") print read_until(c, '&gt;') t.close() 
Thanks for providing a reasonable reply. 
This is *precisely* why people hate asking programmers for advice; they often approach the question as if the person asking has the same exact sphere of understanding as the programmer. The guy is beginning programming. He is having issues with getting started with a Hello, World program which uses basic flow control concepts. However, using terminology and concepts like "flow of control" and "top-down" means something to experienced programmers, but not to someone who's getting started with Hello, World. Not trying to be a bastard to you, but you're trying to teach additive color theory to someone who's just discovered paint. Cut that out.
print "Hello"\*5 + "World"\*5
godaddy and other VPS options exist, 30$ a month or so.
It's not much worse than SFTP in general. It was pretty bad against older versions of openssh (I think &lt; 4.4), because pipelining and prefetch weren't working correctly. SFTP isn't great for throughput, but it is convenient, easy, and secure.
didn't think of VPS. Thanks!
Does it talk to ssh-agent?
* GAE has scheduled tasks. Probably they can't do what you want anyway if you are doing video/audio/etc, but for lack of libraries not tasks. * Rackspace Cloud is substantially cheaper than EC2. (I feel crass mentioning it, but if you happen to sign up, maybe put in REF-IANBICKING) * Linode is [reported to be a faster](http://journal.uggedal.com/vps-performance-comparison), though not necessarily faster-for-your-buck. But Linode bills monthy, Rackspace Cloud and EC2 bill hourly. I think spawning new servers on demand is really handy, if only for testing, and hourly billing makes it affordable.
no it fails to do agent forwarding... someone needs to just write a simple Popen wrapper for open-ssh.
I think you're massively under-estimating the guy's ability to work through things or to understand english. 'Top down' and 'line-by-line' are fairly explanatory, and I made the examples purposely simple. Words like 'evaluate' and 'execute' are also just basic english. *'additive color theory to someone who's just discovered paint'*? Hardly. He's already happy with values, variables and messing with strings. Flow control is just the next step and as he works through his programming examples he'll soon get the cause-and-effect mindset and understand basic flow control and how variables are updated. One of the best ways to learn is to run and mess around with other people's code, and see how the output changes.
I think you misunderstood that I was not criticizing either the cognitive abilities of the poster or his knowledge, but your ability to communicate in a reasonable and effective manner. You are using book-fed CS terminology to an autodidact who also happens to be a neophyte. Poor choice of communicative methodology. Eschew the coloratura. 
1. Open terminal
&gt;I think you misunderstood that I was not criticizing either the cognitive abilities of the poster or his knowledge, but your ability to communicate in a reasonable and effective manner. Your assumption of his abilities is directly related to your assessment of the quality of my first post in this thread. I'm not suggesting you were critical of the OP's capability to learn or his facility for logic. I would like to advance that a) there's nothing stopping the guy looking things up or asking more questions and b) any programming resource / book / guide he uses will introduce terms like 'execute', 'flow of control' or 'data structure'. Particularly the official Python tutorials. Maybe you've misunderstood the intention behind my first post. If the OP was in the same room as me I'd happily sit down with him and take up a pen and paper, or fire up a debugger and narrate Python stepping through his code line by line. As it is, others have already answered in very simple terms what was his code was doing and how he could fix it. My main aim was to provide a few lines of code for him to run and look at; hopefully to play around with. Yes, I could have spent more time making the post more accessible. It was typed pretty quickly. I don't think it'll hurt though: even if some of the terms are at the moment unclear to him, their repeated use in context might trigger understanding later.
iterparse eh, that's good to know about, thank you! I only recommend etree because its so dead simple and in my experience scientific work of this kind is usually not performance intensive and implementation time is important. Outside of that context, I agree its pretty pudgy.
Yes, it works with ssh-agent just fine, and the SSHClient class checks for an agent first by default. As said below, it does not do agent forwarding.
I was just taking at look at the python docs for the RE module (regex) and I noticed the example "?iLmsux". I've heard that ILM (Industrial Light and Magic) use python, so it's kind of funny if they're taking a dig in the documentation. Anyone know the back story?
lxml is mostly a superset of ElementTree, for better or worse. So except for installation it'll be just about as easy.
As you can see from this thread, there are lots of options. Please, after you make a decision, let us know what you tried, what you did not try, and what led you to make your decision. We could benefit from it.
ummm... are you serious? what about SWIG? ... and boost.python?
I'm pretty sure the back story is that those are the available flags, in alphabetical order.
I tested it when I was waiting for a server admin to set up something when I gave him the choice between Perl and Python. He chose Perl of course. Paramiko is much nicer than Perl::SSH2 :(
Will do! :)
I started programming in second grade. Calculus is by far the least useful form of math for a programmer to learn. I have literally never used calculus to help me solve a programming problem, in spite of learning it twelve years ago. Calculus is only helpful when you’re dealing with infinities, slopes of lines, and such. This comes up a lot in physics, but basically never in programming. 
Wouldn't it be easier if Python supported Ruby style shell commands? e.g. in Ruby you can do: some_ruby_code `ssh some.host.net "echo 'hello from some.host.net'"`
=) thank you, this is great to know. I do have an "ok" grasp on algebra which I think is necessary to a small degree from what I've done so far. But I will push ahead with the courses and keep trying to better myself.
how do you get at output and exit status?
Some of the other pycon 2010 videos don't seem to play. In this case, clicking Download icon worked for me. 
that isn't much more difficult than can be accomplished with subprocess.
Alternatives to paramiko, for SSH in python: * [pexpect](http://pexpect.sourceforge.net/pxssh.html) * [twisted.conch](http://twistedmatrix.com/trac/wiki/TwistedConch)
I have had problems getting some of the pycon 2010 videos to play, but not with this one. In my case as well, clicking Download got the video to play.
Ruby has Special Variables like Perl. Return code I believe you'd get from $? and the output is just returned so you can just do output = `some_command`
My ears now hurt.
10x
Sorry for anyone who's trying to look at this article and can't get through. My poor VPS with 96MB of RAM is suffering mightily.
Are you using WP-SuperCache?
Hmm... too bad class methods litter the instance namespace. It's a bit silly that every vector instance can do "from_sequence".
I have been doing this consistently in order to create instances from a variety of known constructor data, and its simplified my \_\_init\_\_ functions considerably. If there's a better way to do this then the @classmethod way I'd like to know about it, but so far this has been working like a gem for me and I'll continue to use it as a standard in my coding.
holly crap i was just about to write something like this...
Check out [hachoir](http://bitbucket.org/haypo/hachoir/wiki/Home) for something similar.
First Pig, now Dumbo... Hadoop is turning into a circus.
Paramiko is great - I've been using it to help manage some systems at work. I use the ssh client capability to manage starting/stopping/upgrading our software, and I wrote an SFTP server with it that allows us to automatically kick off processes, etc when a file is uploaded. The SFTP server is available at bitbucket: http://bitbucket.org/timfreund/simplesftpserver/
Yes, but this doesn't actually take care of the unusual but not impossible situation of not actually knowing the types of your constructor arguments until runtime, which the code dowski was responding to does: http://pythonconquerstheuniverse.wordpress.com/2010/03/17/multiple-constructors-in-a-python-class/ This is a highly unusual situation, but when you do run into it, which I have in a couple of cases working with old web frameworks, you are going to have to do signature dispatch somewhere, and the only way I found to do it was isinstance. The classmethod approach, which is what is always brought up in discussions like this, works, but in the very rare situations when you really can't refactor to know the types coming in ahead of time, giving this solution is like handing them apple pie when they asked for apple sauce because they both have the word apple in them.
Yes, but also AuthKit kinda sucks - at least I found it to be restrictive. I ended up rolling my own, and even with some OpenID stuff added in it ended being simpler to get working than Authkit. http://tonylandis.com/python/openid-db-authentication-in-pylons-is-easy-with-rpx/
Well, you weren't expecting Django's level of documentation were you? (actually, I'm getting the same feeling from CherryPy and it's killing me, plus since it's much lower profile than django there are basically no resources outside the official documentation, which mostly blows goats and looks like shit)
No. True is the identity element for logical and, since for all a, True and a == a. Same reason a product of zero numbers is 1, or the sum of nothing is 0.
So, 0 x 0 = 1? You're talking logically right? If x = the AND operator, 0 AND 0 is 0.
Perhaps slightly counterintuitive, but the right result. http://en.wikipedia.org/wiki/Vacuous_truth
Another way of phrasing it might be "return true unless any element of the set is false".
0 x 0 is not a product of zero numbers, it is the product of the number zero.
And does anyone but me find it somewhat annoying when a conversation runs from a group, which is where the thread of this posting actually started: http://groups.google.com/group/comp.lang.python/browse_thread/thread/99e87afb58f3ef3d To a blog, for no apparent reason other than the vanity of posting on your own blog: http://pythonconquerstheuniverse.wordpress.com/2010/03/17/multiple-constructors-in-a-python-class/ To another blog, again for no apparent reason: http://blog.dowski.com/2010/03/17/my-take-on-multiple-constructors/ And finally here. Instead of having all the information in a thread where you can see the whole conversation easily? If the original posting was just a starting point for a long discussion on an overall topic that really made for an original essay, fine. But every step of this process has been just a simple reply to a forum that has a reply functionality just fine. And I actually tried to originally reply to this posting at Dowski's blog, but he has the comments for this discussion closed, making that impossible. So now we end up replying to something from a newsgroup 3 forums removed, for no reason I can actually figure out except "Hey! Look at me! I have a Blog!"-ism.
Don't use AuthKit (which is not itself actually "pylons"). Maybe try repoze.who.
What he's trying to say is: &gt;&gt;&gt; numpy.prod([]) 1.0 &gt;&gt;&gt; numpy.sum([]) 0.0 The identity of product is 1. The identity of addition is 0. The identity of logical-and is True. The identity of logical-or is False. 
Thanks! That makes sense.
&gt; 0 x 0 = 1? No. Read it again. Then reflect. Repeat that until you see that it is true. :-) 
ah yes, the old call-something-shit-on-reddit: the nuclear option for tech support
Protip: Not to be a downer or anything, but make sure you know the standard library before reimplementing it. You can do this with ctypes. No need to call a serialize or parse method, and no need for external libraries. http://www.dabeaz.com/blog/2009/08/python-binary-io-handling.html
I like Pylons. I was just wondering if i'm stuck at this because of my crappy programming skills or if the documentation is lacking.
&gt; You can do this with ctypes. Ah, yes, ctypes. The package in the stdlib [specifically designed to cause segfaults](http://blog.ianbicking.org/2010/03/16/web-server-benchmarking-we-need/). Seriously, there are a lot of installations (embedded devices, jython, etc) where this would be useful. 
Pylons isn't more complicated than Django. The source code is relatively small and easy to read. The documentation however is very lacking and out of date. This is somewhat complicated by the use of outside packages like SQLAlchemy which have their own documentation, which is fair enough, but even so Pylons online documentation is shamefully bad compared to Django. The Pylons book is good but is already dated for Pylons 1.0. I like Pylons and prefer it to Django for many reasons, but this is something that needs to be fixed - simply saying you don't need documentation because it's a "hacker's framework" isn't good enough. It's a good framework and has great ideas but it pisses me off that it's let down by the crap docs. AuthKit is a case in point - it's in the Pylons book as the "official" way to do authentication in Pylons, but if you ask anyone on the Pylons IRC logs they'll tell you to avoid it like the plague and use Repoze or a roll-your-own solution. That's very confusing to beginners. 
I was looking into bash scripting for OS X and found some python scripts that did what I needed, and we're a whole lot easier to modify and maintain. I'm still not a Pythonista but I've been poking at it ever since.
This is the answer that i was looking for. Thanks! And just curious, but why exactly do you prefer Pylons?
I always had a casual interest, then my boss told me I should be up to speed on it since we would be transitioning to it. It's really my "all purpose" language right now, use it for my research work as well. 
Mainly just a matter of taste - I find Django a bit too restrictive (which is not to say it's not a good framework for the right project). Generally as your project grows in complexity you'll find Pylons bends to your requirements more. That said I can understand how it can be daunting to beginners. Part of that is the fact that it is a glue rather than NIH framework, but it's mainly the documentation. However I'm not personally contributing anything to the project, so I've no right to complain really.
+1 for repoze.who. I found it far easier to integrate and understand, and even extend via their repoze.who.plugins namespace.
&gt; The package in the stdlib specifically designed to cause segfaults. Any package that lets you interface with C will be prone to segfaults. Quoting Ian Bicking does not make ctypes poorly designed.
I'm sure you do like Pylons, but wondering on the pylons maillist or IRC channel would be way more appropriate than wondering on reddit.
No plone-ness in repoze.who. that doesn't mean it doesn't suck (it does, and i'm allowed to say that because i wrote it), but plone-ness is hitting below the belt ;-)
&gt;&gt; The package in the stdlib specifically designed to cause segfaults. &gt; Any package that lets you interface with C will be prone to segfaults. Quoting Ian Bicking does not make ctypes poorly designed. Humor, gentle reader, it was humor. 
AuthKit is IMO one of the few unfortunate things in an otherwise awesome book covering the libraries that make up pylons. I would say it's less complicated than Django since you can cover the code in about an hour and actually keep it in your head what it's doing. Perhaps you meant that it doesn't do as many things for you like Django, that would be accurate.
&gt; Part of that is the fact that it is a glue rather than NIH framework It glues together NIH components. Consider the default recommendations -- SQLAlchemy, Mako, WebHelpers, FormAlchemy and Routes -- all of which were written by authors who chose to do their own thing rather than re-use, contribute to and improve the pre-existing best-of-breed components. I'm honestly *shocked* that there hasn't been more vitriol thrown at the authors of these tools for their selfish, short-sighted actions; it seems they're more interested in fragmenting the Python web-development community than in helping it to advance. (the sad thing is, of course, that projects which existed before many of these components are now the ones alleged to have a raging case of NIH... as Tom Lehrer said following Henry Kissinger's Nobel Peace Prize, satire truly is dead)
as I recall, everyone was recommending against authkit last year, and its inclusion in the book was only due to the author promoting his own project. Use repoze.who.
I'm a former perl junkie. A few years ago I started using Zenoss to monitor servers at work. Had a need to look under the hood of Zenoss and got sucked into learning Python. Now I use Python for all my scripting needs. It's a bit of an addiction, really.
well and I don't think repoze.who existed when the book was written but I could be wrong. 
What would you have us do instead?
It (via Zope) was my alternative (10+ years ago) to MS ASP for developing content-driven websites.
Dont call her that.
+1 for teh lulz
I liked it better than writing bat files. met zope once and ran away to C#, came back when I needed to code a web app to run on a commodity host, and php/drupal wasn't going to cut it. Enter turbogears 1.0. Since then I enjoy it very much.
Don't use AuthKit. Roll your own. It's easy to do, and the end result is far more flexible.
heh ! you sure you want to go there on this one ? SQLObject was a tremendous inspiration, but do you think it would have accommodated all that we have in SQLA ? im gonna tweet your comment there. too funny. django is super uber master of the universe, ill never understand why you keep trolling on everyone else.
as far as wikis go [MoinMoin](http://moinmo.in/MoinMoin) And you've already mentioned zope/plone, there's your cms. I got nothing for blogs. 
There's [PyBlosxom](http://pyblosxom.sourceforge.net/) for blogging. There should be plug-ins for a lot of what you're looking for.
Seriously? SQLAlchemy, Mako, WebHelpers, Routes, Beaker, those things *are* best of breed. They're written by people who love what they do, understand what they do, and specialize in it. Everything is standalone and stable on its own. You compare it to inbred monolithic monsters like Django, Rails, and others where the same developer who writes *everything* and much of it poorly until it gets revised by other people who dabble on their school's custom CMS newspaper platform. I'll take one specialist for each tool over "collective wisdom," lest we deal with another Wordpress.
From what I can tell by perusing the documentation, it's based on essentially raw HTML files with some meta-data. It may be great, but it's not what I'm looking for. Raw HTML isn't future-proof. Part of why I want Markdown or some kind of abstraction layer (hell, even RST would work) is because the rendering engines can be swapped out or tweaked to change the generated HTML for *all* of a specific markup tag. A code block could be a \&lt;pre\&gt;, or a \&lt;pre\&gt; embedded in a div with a rounded drop-shadow, syntax highlighting, line numbers, and a print preview.
Oh yeah, if only we could have more vitriol and spite, to help the community advance. :) As I continue to benefit from the short-sightedly superb design quality and documentation of SQLAlchemy and Mike Bayer's selfishly tireless support for it, you gave me a chuckle (NIH, indeed!). But your comment reeks of genuine spite. That's harmful stuff and you would do well to get over it.
Zine is too... NIH. ZEML? Really? With Markdown, Creole, RST, Pygments and about twelve other markup systems, they made one up? With no documentation I could find on how to actually use it? It has also not had a major release in over a year. I understand why they might want to stay away from a framework, but they have no documentation for all these nifty things they invented, so it's unusable. I'll try django-cms again after installing fresh ... everything in a local dir. Hopefully it's just the slightly older Ubuntu packages that threw it off. Unlike a boatload of other mutually incompatible Django projects, Django-cms seems to use bleeding-edge releases of every module they chose, but not everything complains when it should.
I thought about MoinMoin, but didn't test it out yet. I couldn't tell from the demo site if it allowed comments on the wiki entries. That would solve part of the problem, but so far as an Atom/RSS feed based on new wiki pages, not sure. I've been spoiled by our company's use of Confluence, which is like a CMS/Wiki/Blog all smashed up together. But Zope? Like I said, I couldn't decipher Zope/Plone's admin system. There's giant multi-selects full of hundreds of similarly named entries, each with its own configuration elements... set up a page, or a site, or a user, or a admin user, or activate a site user, page, contact... it makes no sense. Real CMSs allow the plugins to alter the admin interface so everything is in a dedicated area grouped by function. The Zope docs really didn't help here, or I was just looking in the wrong place.
Don't suppose you could actually provide any proof of that claim? What Python URL recognizing program worked in a similar fashion to Rails URL dispatching before Routes? What Python template engine was ported from the very slick Perl HTML::Mason template engine before Mako? What Python package contained a bunch of HTML helpers to help with everyday HTML tasks (in a similar fashion to Rails) existed before WebHelpers? What Python ORM implemented well thought out patterns like Unit of Work and Identity Map before SQLAlchemy? I'm familiar with everything along any of these lines, because before I created Routes and WebHelpers, and started using Mako (and its predecessor Myghty), I looked around in the Python world for a very long time for something else I could use INSTEAD of writing it myself. 
I ran across it first on Reddit. I can't remember the context, but someone posted code, and it was so easy to read, and I freaking *hate* fiddling with braces. I'll still do most stuff in Obj-C on the Mac, but I was able to slap together a cross-platform flashcard app on it fairly easily.
Yeah, I should have whipped out the virtualenv the second I noticed I was .1 behind on a package and *it actually broke horribly*. I've never seen anything quite that edgy. :) From what you've just said, it almost sounds as if they've abandoned Zine. Vanishing documentation, no work from major devs in a long time, etc. Or maybe they think it's so awesome they haven't looked at the site in a while and haven't noticed stuff is gone. :)
I use [Django Mingus](http://github.com/montylounge/django-mingus) for blogging. I like that I can hack it, while still having plenty features.
Was bored at work, so I read the tutorial and Dive into Python.
Check out the [PyMarkdown](http://pyblosxom.sourceforge.net/registry/text/PyMarkdown.html) plug-in. It appears to have not been updated since 2004, and I'm not sure how often Markdown changes. PyBlosxom is pretty easy to extend (I wrote an IntenseDebate plugin without knowing Python, for example), but development seems to be pretty slow, especially on plug-ins. 
I listed that one. The author mentioned he used django-basic-apps, but what he neglected to say, was that he used those componants before they were combined into a single project. And when they combined, they majorly refactored the codebase, so the stuff Mingus uses is no longer valid. It literally can't be installed anymore unless you track down deprecated libraries. It looked pretty good, but I couldn't get it to work. Django-basic-apps is similar enough to the original design that Mingus accepts it for install, but the second it tries to use anything, a bunch of stuff is missing. (It looks for blog.Settings, which doesn't exist anymore.)
That's the impression I got. Honestly, if I could figure out how to use the markup, it would have been near the top of my list. But you've been very helpful. I'll try django-cms again under a virtualenv and see where that goes. I've written Django apps before, so maybe I can move my plugins over once/if I get django-cms working.
Hah, it's actually really funny they have a plugin for that. Put a web front end on it, and it might actually be usable. :) I saw that someone submitted a web front end, but the PyBlosxom site made it sound like a huge security flaw. :p
About two and a half years ago, I got a Python script from a coworker to monitor some stats on a product in development. Feature creep sometimes works in your favor -- within days it was "Hey, can you make it do X?" or "It'd be awesome if we could also check Y." I found that I could poke at it pretty easily and make it do what I want. So I kept poking at it. Since then, I've written hundreds of scripts, learned something new about it almost every day (today was setting sys.setdefaultencoding() in sitecustomize.py), and written code that goes from scraping a data source directly to production results pages for one of the world's leading search engines. I'd say it's been a pretty big success!
Math research work and teaching. I used to use Mathematica quite a lot, but wanted something open source. Someone suggested SAGE (based on Python), and I got interested in Python as a result.
yeah mako was total NIH ! there was already HTML::Mason ! I guess that makes Python NIH over Perl ! Hey there's already a scripting language that starts with P, get over it !
Was doing research programming for visual cognition experiments in c and c++ using the [VisionShell](http://www.visionshell.com/Purchase_and_download.html) c libraries for Mac OS 9 back in 2001-2002. After they switched to OS X, we needed something to do the displays, and the options were basically: 1. code everything manually (e.g., SDL). 2. [PsychoPhysics Toolbox](http://psychtoolbox.org/) for Matlab 3. [VisionEgg](http://www.visionegg.org/) for python. After having done a substantial amount of graphics coding for the [EyeLink II eyetracker](http://www.sr-research.com/EL_II.html) in c++, I felt it was time to try something new. That, and I also fucking hate matlab with a passion. We gave VisionEgg a try, and it was actually a really nice platform. Everything was done in OpenGL, so python's speed wasn't really a factor, and we could set up a study in about a week rather than a few months of coding. Eventually, I came to see that I could do just about everything I needed in python. As [Eric S. Raymond](http://www.linuxjournal.com/article/3882) wrote: "This was my first clue that, in Python, I was actually dealing with an exceptionally good design."
As I seem to recall, you -- personally, and I can point you at places where you said this publicly -- were one of the loudest voices a few years ago calling for us to completely abandon any idea of writing a better ORM and just adopt SQLObject like everybody else. I don't seem to recall you ever saying anything similar about Mike when SQLAlchemy was just getting started. In fact, I don't recall *any* major non-Django library ever being subjected to that type of criticism, no matter how many already-existing wheels those libraries invented all over again. Why is that, I wonder?
&gt; you sure you want to go there on this one ? Yeah, I am sure, because I'm sick to fucking death of the double standard the Python community applies. If you or Ben or Ian or Mark go off and build a useful replacement for a pre-existing tool, it's lauded as a wonderful advance for Python. If Django does it, we're attacked from all sides as raging egomaniacs bent on fracturing the Python community. That's not right, that's not acceptable and that needs to stop; if an absurd satire of that attitude is what it takes to bring it to the attention of the right people, well, hell, I've got the comment karma to spare and no real reputation for civility to lose anyway.
&gt; What would you have us do instead? Write useful software, get shit done and get the fuck over the need to say childish things about other peoples' code.
I think you may be mistaking me for someone who hasn't done the above things? If not, alcohol *may* be to blame, and I'd need to be reminded of my old sins. ;-)
&gt; learned something new about it almost every day (today was setting sys.setdefaultencoding() in sitecustomize.py) I hope what you learned is that you should almost never do that. People think they want to change the default encoding all the time, but usually what they really want to do is set an environment variable in their shell to tell the interpreter what encoding to use.
Oh no worries, more tongue-in-cheek ;-)
Yeah, I should have whipped out the virtualenv the second I noticed I was about to install new experimental python packages on my machine because working in a sandboxed python environment is pretty much always a good idea. FTFY
I assumed you were asking in a general, rather than a personal, sense, and responded in kind :)
I wasn't using NIH in a derogatory way - just to distinguish between frameworks that have all components developed in-house as opposed to those that glue pre-existing ones together. Either can be a good choice depending on circumstances. Out of curiosity though - had these components been available when Django was developed, would you have used e.g. SQLAlchemy rather than develop your own ORM ?
You can sort of get comments by making an edit and entering the comment while saving. All the comments can be viewed in the "info" view. Edit: It comes with a cool package for creating a calendar - basically each calendar day becomes a wiki page. I think it is called month-calendar. What I like about it is that it is completely file-based, no need for a db backend although that is slated to change with 2.0. 
TBH I never saw the real benefit of either. You still have to write the logic to authenticate login parameters against the database (or however you do it). This includes, for example, encrypting passwords and so on. Add in a couple lines in the `__before__` method of your BaseController and a decorator or two and you're done, plus you have something that's completely configurable to your needs. Both AuthKit and Repoze seem to require the same amount of boilerplate in your config files to work, and then you have something you inevitably have to work around when it doesn't quite do what you need. Authentication is just one of those things that always seems to be different enough for each project that a catch-all solution never quite works.
At first I was using PHP for web dev, but then Rails came along so I learned Ruby. I heard Python was similar to Ruby, so I took a look. I really enjoyed the cleaner syntax and simpler grammar. Fell in love with list comprehensions and batteries included. Soon enough, Python took both Ruby's and Java's places in my heart. I still prefer Ruby/Perl/Javascript style regular expression literals, though. And Ruby's blocks and attr_accessors are nice, but sort of superficial. The only thing I really miss in Python is static typing. Not like Java, but something like Hindley-Milner or (to a lesser extent) C#. But that would be a new language altogether. 
There is nothing that competes with Wordpress and you won't be finding anything soon I expect. If you really want to work on your own blog software, i will applaud you for trying to go with something in Python, but just be prepared that you probably will be working more ON the blog than posting articles. I think your 'requirements' are still very modest and you soon might be wanting stuff such as: * OpenID authentication * Akismet spam filter (it really rocks) * Gravatars * RSS Feed * Pingback / trackbacks * Themes You mention the 'NIH' problem with Zine, well disregarding Wordpress because its PHP feels a bit like the same argument (i am not saying you are doing this). Everything you need can be found in Wordpress or one of its gazillion plugins which are just a click away. So, i really think that it depends on what you are planning to do. If you just want to be productive at blogging use Wordpress even if you want to get more into Python programming use Wordpress. As this will allow you to work on cool stuff instead of just-another-blog-thingy-implemented-in-python-that-noone-will-use-except-you. 
To put in some constructive criticism: Because of the way Django is put together, stuff written with Django in mind will only work with Django. It's a kind of walled garden in that respect. There's great packages out there - South and Pinax, for example - which benefit the Django community but are useless for everyone else. That was a criticism of Zope in its day - that it was an isolated island from the rest of the Python community. When Ian Bicking wrote virtualenv for example, that could be used across the entire Python community, including Django. There's nothing wrong with reinventing a wheel if you make a much better wheel. There's a difference between making a wheel that you can attach to any cart and one that can only be attached to just one kind of cart. EDIT: credit where it is due - the Django docs are a textbook example of how to do documentation right. Well presented, consistent, good examples, and up to date (with links to previous versions). Had I the time and writing skills I would love to do something similar for Pylons, which at the moment give the impression of a bunch of disjointed, out of date wiki pages thrown over the wall. Other packages like SQLAlchemy have excellent docs but Pylons does let the side down.
To be perfectly honest, I think it makes more sense to look at the history of Python web development as a sort of punctuated equilibrium: periods of rapid innovation interspersed with periods of consolidation and steady, incremental improvement. The first wave of rapid evolution coincided with the rise of Zope, which quickly came to dominate Python web development. Once Zope itself was relatively mature, though, a lot of work moved out into tools and systems built on or around Zope, resulting in a huge ecosystem of steadily-improving software but not much significant innovation. During that lull, a number of projects started percolating in the background, learning from what Zope had done right (and wrong) as well as from work being done in other communities. These projects -- SQLObject is a good example -- helped kickstart the next big jump, but many of them are no longer particularly active or widely-used. The second wave kicked off in 2005, the year Django, TurboGears and Pylons all had their first public releases. There followed another period of rapid evolution in which a number of now-common libraries were developed, and the newer frameworks started to take over from Zope (which also began to undergo serious evolution again, leading to not only the current incarnation of Zope itself but also Grok and Repoze). The last year or two, I think, has been the followup consolidation and incremental-improvement phase; the tools have settled down and grown into maturity, and there hasn't been anything dramatically new or innovative. If Django didn't exist right now and I were coming in brand-new, I honestly don't know what I'd do; I think we're coming due for another big evolutionary leap and I don't yet know what that's going to be. If cornered and forced to make predictions, though, I'd wager that: 1. Request/response is going to be standardized one way or another, but probably not via any evolution of or extension to WSGI. There's enough similarity now in the popular frameworks' default abstractions that it's more likely to be ad-hoc standardization of APIs which are already known to work. Since HTTP is unlikely to change drastically in the foreseeable future, I wouldn't be surprised to see a single implementation end up in the stdlib where it can stagnate as needed. 2. Database access is going to radically change as non-SQL data stores and mixed setups (some data in a traditional RDBMS, some in persistent queues or key/value stores, some in document-oriented stores, etc.) become more common. I don't think "ORM" as we know it will survive this change and I don't know what the tools are going to look like when we come out the other side. 3. Probably the safest bet: there'll be a new wave of template systems. Originally, many of the tools were XML-based or at least strongly XML-flavored, and the second wave reacted against this; I expect the third wave, when it comes, will be something else entirely, and will be motivated at least in part by HTML5. A similar evolution will probably occur with form-handling libraries (especially as developers need to support a range of feature sets from full HTML5 with useful client-side validation to older/incompletely-implemented UAs requiring traditional full-server-side handling). Historically, it seems that each big wave brings with it a new framework which becomes "the standard", but I have no idea whether that'll happen again, whether some currently-existing framework will take that role, or whether things will be more fragmented than they have been previously. So I'm not going to bet on any horse in that race, including my own.
The way I see it, there's a spectrum across Django, TurboGears and Pylons in terms of the trade-off between interoperability and component flexibility, and they've been remarkably persistent in their positions on that spectrum: * Django provides a full stack, tightly integrated, out of the box. This means you *can* swap stuff out if you want to, but the path of least resistance will always be to build on that stack. The tradeoff is made in favor of interoperability over component choice; being able to assume the use of standard components makes it much easier to integrate disparate pieces of software. * TurboGears provides a full stack by default, but not quite the same level of integration and fewer assumptions about use of that stack. The tradeoff here is somewhere in the middle; you have the option of assuming the default stack when you want to integrate things, but you also have the option of just yanking stuff out and replacing it when you need to. * Pylons tries to be as agnostic as possible about the actual components, focusing more on being a pure "glue" framework with few/no assumptions about or integration between particular components. The tradeoff here is, of course, in favor of flexibility over interoperability; you have as much freedom as possible to swap things out, but interop tends to be limited to what you can get WSGI to do for you. All three have merits, all three have cases where they really shine and all three have cases where they just fall over and suck, so I tend to be a bit put off by arguments that one approach is objectively superior in the general sense.
So the examples used are pretty quick and dirty. I'm curious though, why does the callback when the button is hit not trigger the message to be printed to the command line when I have it used in example b. I've been working on a notification tray icon for our ticketing system at work and it successfully notifies when new tickets pop up, but the button never triggers the callback method to be called.
Interesting points. The surge in Python web development which as you mention took place in 2005, came about largely in response to the hype of Ruby on Rails (although Django was already in development, it was arguably made open source in response to Rails). Early attempts (anyone remember Subway?) were complete Rails clones, but Django and Pylons were arguably the most "Pythonic" (although different in other respects) and took off. It will probably be the case that the next wave will come outside of Python - a lot of people are betting it will be server-side JavaScript, but it could also be one of the new JVM languages or some really obscure language (like Ruby before Rails). The next big Python framework revolution will probably start by slavishly copying elements of these external frameworks before settling on something that is more suited to Python.
the security issues are a good reason to get rid of wordpress tho
A useful replacement for a tool *that can be dropped in place of that tool* is a good thing. A useful replacement for which you have to adopt a whole buch of other tools, and replace others of your exisiting tools, not so good. Hence the appearence of raging egomanicalism. And calling Mako, WebHelpers, SQLA, etc NIH compared to Django is really bringing in to question your understanding of the term, IMHO.
Open python interpreter and insert import this
Around 2000, I was scholarship holder and another colleague was talking about Python and such and I had a look at it. For a while, I used it in small projects and personal projects. Little did I know that, 5 years later, I'd land me a job in Australia... ;)
It tests if any of the elements is False. If there are no elements, then no elements can be False. Correct?
Concerning the security issues, Wordpress is monitored by lots of security experts. But it is deployed on such large scale by so many users that a portion of that install base becomes an easy target. Wordpress in itself is not insecure though. I dare to say that when you have a tiny bit of knowledge it is easier to keep your Wordpress blog secure and updated then your own code base.
see /r/redditmakesagame if you want to tinker with some python code for a (simple atm) game
keeping up with wordpress security fixes is far more work than i ever want to put into management of a 'publish stuff' thing *edit* it would be a app that i just use, it should just work and never break, thats simply not the case with wordpress
zope/plone does indeed have a steep learning curve. and the docs are not all that great. nonetheless it is a real cms. 
"There is nothing that competes with Wordpress and you won't be finding anything soon I expect." I save the day with [drupal](http://drupal.org)!!!!! :)
seriously? You can upgrade any WP blog with a single mouse click. Posting this comment alone took me that same amount of effort. 
Ah yes, Drupal is another example of excellent PHP software. But it is not typical blog software. 
thats not don't care mode
&gt; There's great packages out there - South and Pinax, for example - which benefit the Django community but are useless for everyone else How would one expect those to work without Django. It'd be like saying "package X is totally great, but it's tied to SQLAlchemy, Jinja2, and routes", yes those are the packages it imports, that's not a bug, or a walled garden, that's the import mechanism!
Made my first website with Python. Blacklisting service for video shop owners. My brother recommended it.
Probably [bottle](http://bottle.paws.de/).
Not just the import mechanism - `DJANGO_SETTINGS_MODULE` anyone ? 
Try [WebOb](http://pythonpaste.org/webob/) and building your own. WebOb is great wsgi response/request layer. You can make a super simple web app or much more complicated ones. Everything but request/response is your choice. You have to put the plumbing in to make it all work, but that is generally very easy. For a great example a simple application, look at Ian Bicking's [post](http://blog.ianbicking.org/2010/03/12/a-webob-app-example/) from a couple weeks ago. 
 from django.conf import settings settings.configure()
Try [web.py](http://webpy.org). It doesn't dictate how you write your app, it gets out of the way.
You probably want [WebOb](http://pythonpaste.org/webob/) or [Werkzeug](http://werkzeug.pocoo.org/).
I'm relatively new to Python, but it looks like bottle functions exactly like sinatra for Ruby... simple URL routing. This seems like about the best choice for OP's needs as stated.
bottle is the simplest thing for your needs ... all is done thru simple decorators ... and you could easily use session too with wsgi/beaker, see the bottle's faq, there is an example : http://bottle.paws.de/page/faq. 
From my research the best two Django CMS projects for me were Django CMS 2 and FeinCMS. They both take a slightly different approach - Django CMS 2 is the one big out of the box ready to work CMS. Everything's a page, you define fields. The new admin refactor coming soon looks lovely, but somewhat similar to Wordpress if you build your site in Django CMS it is a Django CMS site. Fein is more of a CMS building toolkit enabling you to built a CMS to your exact needs really quickly, but without as much of the fancy content types and the like out of the box. You can still think of your published data as models of data rather than pages (like with Django CMS). You'll end up with something which does exactly what you want, but with perhaps a little more (or maybe just less obvious/standard CMS) initial setup. I've found no problem with any of the stable releases of Django CMS 2 - were you running from trunk maybe? I've found trunk broken sometimes. It's a shame you've found a problem with Mingus as I found it to be an excellent demonstration and starting point for how Django's reusable apps can work together to do what you need. Also maybe it could be worth taking a look at Pinax (http://pinaxproject.com/). It's a very big system and effort, but a couple of the newer starter projects in there sound like they may fir your needs. One for a company CMS and blog, and I know some of that other apps include a wiki (django-wakawaka). It sounds like much of the useful Pinax stuff will be in the upcoming 0.9 release, so you may want to check out trunk until 0.9 final comes out (soon I believe). If you're in no rush for a production system.
I came from the php/web world ... And in 2000, I wanted to make GUI app again ... I tested php-gtk ;-) ... But it didn't fit my needs. I had found python, which always fit my brain ;-) (started with wx/gtk libs)... nowadays : I can't imagine making a website without python ... python owns me ... It feeds all my needs : prototyping, web dev, gui dev, batch dev, os dev ... all with one language : perfect ! And there is always, at least, one library for your needs (don't remake the wheel !)
bobo---http://bobo.digicool.com/ ---feels "just right"
How about just the standard [cgi](http://docs.python.org/py3k/library/cgi.html) module then?
&gt; You mention the 'NIH' problem with Zine, well disregarding Wordpress because its PHP feels a bit like the same argument. Well, I've worked with PHP way back in the 3.0 days, and so I know how much the language has evolved. While Python has its little incompatibilities, PHP is a whole different level. I finally got tired of it with the whole 5.0 namespace drama (backslashes? Really?) and all the modules they broke with that release. Using PEAR kinda gets around that, but PEAR has its own issues. I actually don't mind PHP, I just want something a little more stable to develop on when I hack on the side. I also don't like how huge PHP has become lately. Even as a fastCGI, it's just gigantic now, easily 4 times more memory intensive than the 4.x branch. I know Python's not exactly anemic, but c'mon now. The last time I tried Wordpress (2001, to be fair) it was a mess. Even editing templates required actual raw PHP code instead of a good template language. And then there was the huge bit of [2005 drama](http://ma.tt/2005/04/a-response/) that really put me off trying it ever since. It's funny that I forgot to list "RSS/Atom feed" in my list of requirements, but that's one of those "so easy to do, it's trivial" types of things. Heck, with almost everything out there, you can do it with a template if push comes to shove, considering it's all just filtered XML.
Hey now. Usually system packages are more than good enough, especially on a newer release. Karmic hasn't given me any problems with developing until I tried Django-cms. :)
I actually wondered about Drupal, despite my usual disdain for PHP. Some Zope people were lambasting it as being "too small", which immediately piqued my interest. I seem to remember fiddling with it a few years back, but can't recall my final verdict.
First of all, protlib has powerful command-dispatch logging SocketServer classes with very advanced and helpful logging. This is protlib's main purpose, so it would be useful even if I'd built it on top of ctypes instead of the struct module. Second, ctypes is indeed powerful and I've happily used it to interface with C libraries in the past, but I find its API annoying and limited in several ways, especially with regards to arrays and logging and default/constant values. For example, here's an example of using ctypes to do some basic stuff: &gt;&gt;&gt; from ctypes import * &gt;&gt;&gt; &gt;&gt;&gt; # must define an array type for every type/length ... IntArray2 = c_int * 2 &gt;&gt;&gt; class Point(Structure): ... _fields_ = [("code",c_short), # can't specify a default value ... ("xy", IntArray2)] ... &gt;&gt;&gt; # can't just say Point([5,6]) ... pt = Point(1234, IntArray2(5,6)) &gt;&gt;&gt; &gt;&gt;&gt; pt # no useful repr &lt;__main__.Point object at 0x7f8895245dd0&gt; &gt;&gt;&gt; pt.xy # not a real python list &lt;__main__.c_int_Array_2 object at 0x7f88952450e0&gt; &gt;&gt;&gt; pt.xy[:] # this works but is annoying and ugly [5, 6] &gt;&gt;&gt; &gt;&gt;&gt; # not all file-objects implement the buffer protocol ... from StringIO import StringIO &gt;&gt;&gt; out = StringIO() &gt;&gt;&gt; out.write(pt) &gt;&gt;&gt; out.getvalue() '&lt;__main__.Point object at 0x7f8895245dd0&gt;' &gt;&gt;&gt; &gt;&gt;&gt; # this makes it difficult to perform good logging ... import logging &gt;&gt;&gt; logging.warning(pt) WARNING:root:&lt;__main__.Point object at 0x7f8895245dd0&gt; &gt;&gt;&gt; These problems are surmountable but aggravating. When building my SocketServer classes and implementing logging, I had to weigh these limitations against the downside of implementing my own library and duplicating some of the ctypes functionality in the standard library. I chose to make my own CType classes because protlib is designed to be drop-dead simple. I want my co-workers to look at protlib and immediately grasp what it's doing and how to use it. I don't want any unexpected, annoying limitations to crop up, especially since many of my co-workers aren't very familiar with Python. Compare the above ctypes code with this protlib code (the backslashes in the string literals seem to interact poorly with markdown, but you get the idea): &gt;&gt;&gt; from protlib import * &gt;&gt;&gt; &gt;&gt;&gt; class Point(CStruct): ... code = CShort(always = 1234) ... xy = CArray(2, CInt) ... &gt;&gt;&gt; # we can use Python lists as our arrays ... pt = Point([5,6]) &gt;&gt;&gt; pt.xy [5, 6] &gt;&gt;&gt; pt.code # we don't have to specify constant values 1234 &gt;&gt;&gt; &gt;&gt;&gt; pt # we get useful reprs Point(code=1234, xy=[5, 6]) &gt;&gt;&gt; &gt;&gt;&gt; # we can get the packed binary data as strings ... pt.serialize() '\x04\xd2\x00\x00\x00\x05\x00\x00\x00\x06' &gt;&gt;&gt; &gt;&gt;&gt; # this makes logging easy and useful ... import logging &gt;&gt;&gt; logging.warning("binary data: %r" % pt.serialize()) WARNING:root:binary data: '\x04\xd2\x00\x00\x00\x05\x00\x00\x00\x06' &gt;&gt;&gt; logging.warning("struct literal repr: %r" % pt) WARNING:root:struct literal repr: Point(code=1234, xy=[5, 6]) &gt;&gt;&gt; Now you still may feel that these advantages are not enough to warrant duplicating so much functionality from the standard library. I can totally understand that argument, even if I disagree. I just want you and others to know that I this was an informed decision on my part, made by carefully considering the advantages and downsides.
How did you install django-basic-apps? The version in http://github.com/montylounge/django-basic-apps should work. If you want an example of a current Mingus site which deploys cleanly (i.e. only pip install -r requirements.pip) I publish the full source of my site: http://github.com/acdha/improbable.org
&gt; I've found no problem with any of the stable releases of Django CMS 2 - were you running from trunk maybe? I've found trunk broken sometimes. No, I definitely installed the 2.0.2 tarball. But like I said, I'll try it again. The project is far too big for the 'example' site to be broken that badly. Something doesn't wash. If it still doesn't work, I'll fire off an email or search their bug-tracker. &gt; It's a shame you've found a problem with Mingus as I found it to be an excellent demonstration and starting point for how Django's reusable apps can work together to do what you need. It's not really a problem I had with Mingus. I liked his ideal of not using his own models and just gluing everything together. It's just that one of the libraries he used ceased to exist in favor of a new incarnation. I've found incompatibility is a major stumbling block with Django apps in general, which is a shame. It's so close to a true plugin architecture, I'm surprised more developers don't take advantage of that aspect. Using modules from someone else's project is an at-your-own-risk adventure I wouldn't really recommend. :)
We're finishing a FeinCMS project at work. It's been pretty smooth as long as you follow reasonably common practice (i.e. using virtualenv &amp; pip, Python 2.5+, etc.). I'd recommend taking a look since the flexibility has been pretty nice. As far as blogs go, I'd recommend looking at Django Mingus or Biblion: http://github.com/eldarion/biblion. Both should install easily on a reasonably mainstream setup - if you're not using a recent Python, virtualenv, pip, etc. I'd recommend learning those tools and, if necessary, switching webhosts.
I got the latest GITs from github for both Mingus and django-basic-apps. Mingus was calling out to basic.blog.Settings somewhere, and that just simply doesn't exist from my various greps through the source code. I found an older version of the standalone basic-blog online, and sure enough, there it was. I also was mildly annoyed that the devs for django-basic-apps actually said to someone who requested better (or any) documentation, "We're accepting patches!" Uh, great. So I have to read your source code to use your module? No thanks. As a side question, what's the deal with github? It seems like everything Django is posting up a google-code site that just links back to github. I thought Mercurial was the open-source source control *du jour*.
wow hes going with it, there goes our "he was drunk" theory... I think Django got the more vocal "NIH" critique because they were the most vocal about "everyone should be using Django ! Django should be in the standard lib ! Django is blessed by Guido! (who has to my knowledge never even used django except the template languages for a small project) hey i noticed you've built a website (reddit, for example). Why didn't you use Django ? (to which I present [exhibit a](http://i.imgur.com/T3E3al.png)) Don't you think you should have used Django ?" Try to view that kind of stuff from the perspective of everyone else. These days, with the exception of this thread, none of us really cares about this stuff. Tons of people use Django and a decent sized crowd uses other stuff. Can we put it to rest please.
I've got my own Linode, so that's not an issue. I do all local dev on my local machine and upload production-ready only. The last time I dabbled in Django, I was ultimately unsatisfied with the admin system, but I got a working app out of it. (I wrote a book authoring site, and had books-&gt;chapters, and there was no clear way to restrict the dropdowns so that selecting a book automatically listed available chapters from it, instead of just all available chapters ever. I'm still using it, but I'm looking to replace it with something where someone else solved that particular problem, hence the CMS.)
This is going to sound silly, but I've spent months trying to choose a coding style in PHP. My first language 10 years ago at Uni was C, so I learned the K&amp;R style and it morphed into a cross between that and the 1TBS. And all the good PHP web frameworks out there tend to drop their curly braces. And that bugged me. Silly..I know. I kept thinking to myself "Why on Earth do we even NEED curly braces? Why can't someone invent a language that doesn't use them?" That started my quest. That, and the fact that PHP is the Comic Sans of the programming world. I couldn't stand the jokes any more :D 
"it should just work and never break" Are you kidding? If this is your criteria for what software to use, how are you even posting this comment? You surely aren't using any operating system at all, since every single version of Windows, Linux, OS X, even phone OSes like iPhone OS and Blackberry OS have bugs and need to be updated now and then. Same goes for every browser, every router and modem firmware, etc etc etc. Did you mail your hand-written comment to someone who doesn't have such irrational standards? I kind of want to live in your dreamworld where it's even possible to attain such perfection, since it must be awfully hope-inspiring and optimistic, but you're setting yourself up for HUGE disappointments. All software has bugs. There's no such thing as an application that "never break[s]". Wordpress does occasionally need to be updated, but it's about as easy as it possibly can be to do so since (I think) 2.7.
Agreed with bottle. It's written in a single file and can be easily deployed.
Try Pylons. Bottle looks good too for simple projects.
A bit OT, but you perhaps wanted [ForeignKey.limit\_choices\_to](http://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.ForeignKey.limit_choices_to), or perhaps not.
Haha. That might not have been around when I developed my site. I was working back when Django 0.96 was out *forever*. But thanks! :)
The company I work for wouldn't pony up the $$$$ for Visual Studio.NET, so we looked at Open Source programming languages. We got into Perl. Then I stumbled on Eric Raymond's Why Python? article, Dive Into Python, ... 
This is kind of a general Python problem as opposed to a Django problem. At work, we solve this with TG2, BFG, and Django apps the same way Pinax guys are solving it for their Django app: (1) app is always installed into a bare virtualenv, (2) "pip freeze" pins the required packages along with exact version numbers, (3) we run our own package index (pypi) to make sure those package versions are always available.
FWIW, I would say that as far as your main goals go, I don't think you'll ever find exactly what you're looking for. Your options will be to "make do" with whats available, find something you can adapt to your needs, or roll your own soluion (which, with things like web.py, jinja2 and SQLAlchemy all over the place, isn't that difficult these days). In short, it seems that a lot of people who like python are perfectionists, and every perfectionist has their own problems to solve, and odds are the solutions other perfectionists have made are not a solution to your problem that would satisfy a perfectionist. At least that has been my problem.
That's a good idea. It's pretty clear the Django-CMS guys are having major problems of version-itis. I read through the Google groups a bit and there was a bug in South that was causing it to break the models during a fresh install. To get around that, and I'm not kidding, they suggested: # Remove South from settings.py python manage.py syncdb # Replace South in settings.py python manage.py syncdb python manage.py migrate --fake Really? Then someone noted that even after installing, links in the admin were 404-ing. To which someone said that's fixed in Django trunk. So, they're developing against Django trunk? I'm amazed any of that stuff works if that's the case. There's just so much flux and no feature or API freezes ever, so I'd be afraid of ever upgrading a Django project, especially one that ties into so many other contributed and external packages. 
It was slow at work and I wanted to learn a new language. I don't know what my rationale was for choosing Python, but I'm sure glad I did. We use a lot of python code at work now.
&gt; There's great packages out there - South and Pinax, for example - which benefit the Django community but are useless for everyone else. As a Django user, I'm all in favor of making Django more modular and flexible (and personally I'm not a fan of the "no outside dependencies" philosophy), but this kind of critique is just silly. In order to write something interesting that does useful stuff, you have to write to an API that exists, and that has the requisite functionality. Ergo, you depend upon that API. It would simply not be possible to write a tool like South that was ORM-agnostic, unless every ORM settled on an identical API (in which case, why have multiple ORMs?). Do you make the same complaint about the sqlalchemy-migrate project? "It benefits the SQLAlchemy community but it's useless for everyone else!" I think this point often gets missed in these conversations: the _reason_ there are great packages out there that "work only with Django" is that it's _really easy_ to write third-party stuff that "just works" with Django, because you can assume a lot more and write to a much larger API. One thing I hate about Django: the hardcoded User model. But guess what: the existence of a standard User model that almost everyone uses allows for a whole set of reusable code that simply would not be possible otherwise. With a Pylons-style framework, the API that third-party code can really rely on is basically WSGI. That's a pretty bare API; you certainly can't build a database-migrations tool on it ;-) I'm not saying that's worse; it has serious advantages in terms of flexibility and also sometimes quality of components. It's just that there are tradeoffs, and ignoring the benefits of the other approach doesn't help the conversation.
If you want to make a framework, not just an application without a framework, there's also [this WebOb DIY doc](http://pythonpaste.org/webob/do-it-yourself.html)
I'm not really that way, though. My needs are few. There are several solutions out there that have basically all the things I listed, and then some. To roll my own, I'd have to spend weeks or months gluing everything together, debugging the templates and adding in niceties like Ajax so it doesn't look like some crap a dude threw together in his basement. :) And it seems like part of the problem is interoperability. Several of the blog engines I tried out only work as is, and with whatever versions of external libraries the author happened to have lying around. If anything is a minor release too high or too low, suddenly it breaks. Heck, the Django-CMS guys are working against Django's trunk. This all reminds me of the PHP 3.0 days, when we had to get betas from the devs because 3.0.7 had some obscure flaw we discovered and they hadn't released 3.0.8 yet. Those were *not* good times.
Why not just use StackOverFlow?
It's worth noting that this site isn't so much for Python in general (for which StackOverflow is a fine place), but for users of Python in the fields of science, mathematics, engineering, and related subjects. People are asking such questions there, but it doesn't seem to have drawn the strong community of answerers that already exists on our mailing lists. I'm hoping that having a more focused site will provide a more comfortable environment for my target audience, many of whom consider themselves scientists/mathematicians/etc. and not programmers. Basically, I want the "optimization" tag to point to questions asking about finding the extrema of mathematical functions, not a flood of questions about making Django run fast. tl;dr [There's a FAQ.](http://ask.scipy.org/about)
Great idea! I've had tons of Scipy/NumPy questions over the years and no easy way to ask them; this'll really be helpful.
I'm not a StackOverFlow user; but I've heard users complain about the fact that it's not open source, and there are certain features (like community wiki-izing of individual's posts) whose internal workings are hidden magic. edit: spelling
My toilet seat is not open source but it does a great job of holding my ass while I am taking a dump, that's also magic on its own way but I nevertheless don't complain about it.
More benchmarks here: http://enthought.com/epd/mkl/
Not lose the python stuff in the noise of C# crap?
Webcam video processing experiments with OpenCV got me started. I've looked into Twisted and have some ideas brewing on mini server/client apps. Python is a joy to work with.
[http://stackoverflow.com/questions/tagged/python](http://stackoverflow.com/questions/tagged/python)
[bfg](http://bfg.repoze.org) is pretty simple but scales up pretty nicely.[example](http://docs.repoze.org/bfg/current/narr/firstapp.html#hello-world-goodbye-world-imperative) 
Ha! No, I sure didn't. But today's another day, so I'd love it if you'd share! 1. What's the difference between using setdefaultencoding() and setting the environ var? 2. What makes you say one should almost never use setdefaultencoding()? You could singlehandedly be responsible for today's lesson :) Thanks in advance!
That is about module naming not about APIs I'm afraid.
If you want to get up and running quickly, try using this pip requirements file: http://github.com/acdha/improbable.org/blob/master/requirements.pip Github has taken over most of the world which I interact with. A few projects use Mercurial but the Django side seems to have gone for speed &amp; features. Bitbucket.org isn't bad but it's a little slower, a little harder to use and that seems to have played into lower popularity for many projects.
You want limit_choices to or, depending on your needs, a custom queryset on your ModelAdmin - the canonical example being something like "qs = super(…); return qs.filter(owner=request.user)" to limit choices based on the logged in admin user.
Wht not just use StackExchange then?
Yup, it might work until that new site becomes popular. By then I don't see the climate will be much different than that of SO. I think SO was better before than now that there's pretty intense karma whoring going on there. I lately even had one reply to one of my questions later delete his reply as it wasn't 100% correct and I suppose he didn't want to risk getting downvoted. Jeez. :S It was still semi-useful to me despite not being completely on target, and could definitely have helped others. Not to mention those later editing their replies to instead say something much like the chosen answer said.
Most of the time I tend to ignore fanboys arguing with each other (though every once in a while, as in this thread, I stop and smack down something which looks to be in that vein), because there've been plenty on both sides. What bugs me is the continuing attitude from people like you, Ben (I've got some interesting IRC logs), Jonathan "Django is feeble" Ellis, etc., just outright bashing on Django for no good reason. A good example is the recurring argument you and I have had about connection pooling; I've explained several times why, from an architectural perspective, I don't think the ORM is the right place for that. And you've argued with me about it, but in the end your position seems to be that I don't like connection pooling because Django didn't invent it. See [here](http://www.reddit.com/r/programming/comments/7pwg9/djangos_orm_gets_aggregate_support/c072x61), for example, where you said: &gt; I think if Django had been provided with its own connection pool you wouldn't even be arguing this. There's a reason why my reply there tried to turn that on its head -- the implication of what you really think is pretty clear -- and why I basically gave up on discussing that with you afterward.
BeautifulSoup FTW!
I don't think numpy even has multithreading support, and I believe they only recently got 64 bit support on Windows.
Money.
Solace does not have it, and I am not inclined to implement it myself.
As I've stated elsewhere, the site is not for Python questions in general (for which I think StackOverflow is a fine place), but for the use of Python in science, math, and engineering. Tagging helps, certainly, but not particularly well. It helps when the user is asking a question about a particular package, like numpy or matplotlib or Sage. It doesn't help when the user doesn't know where to start. It also doesn't help scientists who don't consider themselves programmers to join in. I believe that having a focused community will help. It may not. We'll see.
You almost certainly want Werkzeug.
They're using [Solace](http://opensource.plurk.com/solace/), which is open source and written in Python.
Yep, Werkzeug is really great. It's very sleek and well-designed. It's the only toolkit I know, which allows you to do things the way you like. The documentation is also one of the best. You can find it here: http://werkzeug.pocoo.org/
I wanted to write an addon for xbmc. I now do it semi-professionally (as in it isn't my day-to-day job but I get paid to do it freelance on a fairly regular basis).
Bookmarked, lacking in content so far but I'm the sort of individual this is targeting (Computational Ecology of Populations) so I'm inclined to seeing it do well. 
Ha, clever.
Here’s an article explaining that [sys.setdefaultencoding is evil](http://tarekziade.wordpress.com/2008/01/08/syssetdefaultencoding-is-evil/) written by one of the Python coredevs. Basically, the problem is that it lets you forget that you need to explicitly cast things into and out of a particular encoding of bytes when doing IO. Read [the docs](http://docs.python.org/library/sys.html#sys.setdefaultencoding) on `setdefaultencoding`, you’ll see they say, “Once used by the `site` module, it is removed from the `sys` module’s namespace.” There’s a reason for this. Python itself needs to know how to do IO while it’s loading itself up, and for this it needs to be able to set an encoding. But once the interpreter is up and running, there should be no reason to rely on a default encoding. Just explicitly say what encoding you want to use by writing `mybytes.decode("TYPE")` and `mystr.encode("TYPE")`. The one tricky spot can be that you want to be able to do this in your interactive shell: &gt;&gt;&gt; print u'\\u30a8\\u30a4\\u30d3\\u30fc\\u30b7\\u30fc' エイビーシー Edit: Reddit screws up the text above. It should be a slash u style `repr` string. That’s fine. But you don’t do it by messing with `sitecustomize.py`. You do it by setting the locale/encoding of your terminal. I don’t know about Windows, but Unices do this with `LC_CTYPE=locale.encoding`. In my case on OS X, I have a `.bash_profile` in my home directory with the line `export LC_CTYPE=en_US.utf-8`. Your own settings may vary depending on what encoding your terminal expects.
It does seem like a dumbass thing to have to set in an odd startup hooky script, I admit. Thanks for the link! I'll definitely do more investigation into this and give the other approach a whirl. I'm a Linux / Mac user at home but work requirements involve Windows. I use Cygwin a tremendous amount just to be difficult, and as you point out, it's dead easy to specify encoding for the shell. As a side note, is the Katakana 'ABC' a Japanese equivalent of "hello world" or is that just your go-to example? ;)
"class" as in "class something:.." ?
Great! Who better to run a free site about making Python work than a company that has never made anything in Python work except when people pay them $99? I have a grudge against Enthought after trying to develop software in their environment and finding pure vendor lock-in. Software that you write using their libraries *will not run* except in their proprietary Python environment. Good luck finding any users that way. They grudgingly release "open source" packages, which I'm pretty sure they're required to do by the GPL, but those haven't even fucking installed correctly for two years.
What's the relationship of this site with http://advice.mechanicalkern.com ? 
Ah sorry, I thought you meant 'create a reddit account'
I stopped using SOF simply because someone would ask a good question that was related to another question, and some fuckhead would come kill the thread. Either that, or the first person to answer gets marked as the accurate question even if they are wrong. In other words, you get better bang for your buck searching the net. 
It’s just something I made up on the spot. A more Japanese-y example would be to write “[いろは](http://en.wikipedia.org/wiki/Iroha)”.
Nagios plugins are pretty cool. I used Zenoss (with Nagios plugin) to monitor my phone network at my old office. I released the source code. In fact, I made it really *really* easy to make new Nagios plugins in Python. Once you have the parameters right, building Nagios plugins is pretty easy. I think the module I wrote makes it pretty simple with the least amount of framework and overhead. Here's the link. http://code.google.com/p/pyswitchvox/source/browse/trunk/nagios_common.py
how is it?
is it just me, or is there no OS X installer yet?
It's just a shame that they use two-space tabs... Anyway, for a coder, that guide is quite good. Not very suitable for programming beginners.
`class Python(Google): pass`
wiki-izing is a good way to prevent people who post "What's your favorite programming cartoon?" from getting loads of karma.
Your post is so totally wrong it's made me quite cross. Anything you can run with their Enthought Python Distribution (the non-free distribution), you can also run by installaing the libraries separately. Or you can install a free scientific-targeted python distribution such as PythonXY. Enthought give a huge amount to the open-source python community (the Enthought Tool Suite, SciPy, Numpy development support), you really have no justification for a "grudge". So you don't want to pay for the convenience of EPD, just get PythonXY, or easy_install everything you need from PyPI, or build your own distribution. All the code *is* all Open Source.
Why would it be just you? There isn't an OS X installer...
now I understand the tagline
Funny. We've used Enthought libraries (Traits and Mayavi) in our code. They also contribute a lot of code to SciPy and NumPy, premiere Python libraries. The source to all their libraries is freely available and licensed under a BSD-style license. I've found the packages slightly more difficult to build than the average Python package due to a lot of dependencies, but not impossible. If your code only runs in their environment, I think you're doing something wrong.
btw it would be great if you could integrate the two, website and mailing list so you can benefit from your previous community without forcing them to reallocate.
I guess it would help to read the entire post.... &gt;The Mac OS X disk image will be uploaded soon.
Then why did you comment on that in the first place?
Why are you being an ass? Obviously because I hadn't read the whole post....I went to python.org/download and clicked on the link marked [mac installer image](http://python.org/ftp/python/2.6.5/python-2.6.5_macosx10.3.dmg), and got a 404 page, thus, I was wondering if it was just a problem for me. 
Well, yes, StackOverflow is noisy and full of dicks. There's that.
I don't think it will become as popular as SO, or even remotely close for a long, long, time.
Well, except some of the installation stuff on certain platforms, I think. And I can't hold that against them. They have to make money somehow. The entire Enthought Tool Suite is not only open source but very liberally licensed open source. You can build an application with Mayavi, Traits and Chaco (and do really cool shit [like this](http://travisvaught.blogspot.com/2009/08/multidimensional-data-visualization-in.html) in not very much code at all) without paying them a dime.
You have it all wrong. All EPD does is collect together a lot of software and make it easy to install. If you can't get software you've written in EPD to run on a machine without EPD, it's because you haven't installed the libraries right. Which is kind of the point of EPD, but still, if you can't get it working without EPD it's *your fault*. Even though I could use EPD for free (I'm in academia) I tend to build all the packages myself, and I routinely use their "grudgingly released" open source packages, which are absolutely top-notch. And *nothing* in EPD or distributed by Enthought is GPL except for PyQt (which has an exception for linking against BSD code); all of ETS is BSD-licensed, all of the code it depends on like [VTK](http://www.vtk.org/VTK/project/license.html) is BSD licensed. They were under no obligation to release *anything*, and their belief in liberally licensed open source has led them to give users of their packages the same freedom. They heavily sponsor NumPy and SciPy development and host the websites/repositories. There are free distributions that have the same or similar aims; SAGE, Source Python Distribution and PythonXY among them. With EPD they are selling their expertise in getting everything working together, making installation as painless as possible (I think they now also have licensed the Intel Math Kernel Library for fast linear algebra, and that costs money). They release a *ton* of very valuable, professionally developed code to the open source community when they are under no obligation to do so. I have nothing but praise for them. To be clear, I have no financial relationship with Enthought.
advice.mechanicalkern.com was a prototype that Robert set up during SciPy09 and a bunch of us seeded with questions. That site was built on CNPROG which is a bit of a nightmare at the code level, honestly, and not very stable. I haven't looked at the code for Solace but I've been led to believe that it's much better.
ETS is definitely not the easiest thing in the world to install, but generally the enthought-dev mailing list is very responsive. But yes, I've had my share of mysterious build issues; unfortunately nontrivial mixed-language code is often this way. The only reason NumPy and SciPy build so damned solidly are the heroic efforts of one David Cournapeau.
It usually takes them a while to get an OS X installer up. The process for doing that is separate from the process they use for making the tarballs and whatnot. With Python 3.0 it took months, as I recall.
They're rotating. I'm guessing you meant the "We're not all curmudgeons" one. :-)
PyQt is not part of EPD. We do distribute mingw on Windows to provide a compiler, and we used to distribute the MySQL bindings. Otherwise, I think we're clear of GPL packages. Naturally, none of our open source offerings are GPLed or need to be released because of GPL obligations. We release them as open source because we want to. (I am an employee of Enthought.)
I'm not sure how that could be technically achieved.
This is the first I've heard of PythonXY -- thanks for the tip. However, it sounds like a bit of a hurdle for downstream users -- "I already have Python, why do I need this PythonXY thing?" But your suggestion to "easy_install everything you need from PyPI" is just unworkable. The packages *do. not. easyinstall.* That was the whole point of my rant.
It sounds like you got lost in the Zope Management Interface of the Zope app server. This is strictly legacy stuff, you shouldn't need to touch it at all after creating the Plone site (the installers even create one for you). Once you are in Plone you are in the CMS, and things are tailored as you expect.
Sorry just learning python now...why would you want 2.6.5 as opposed to 3.0? Are they not congruent releases?
That's mostly the fault of setuptools being an absolute piece of crap written by a mediocre web programmer who refuses to take input from people with needs different than his, and actually refused to maintain it at all for a long time. Which is why Guido has officially [blessed a replacement](http://www.reddit.com/r/Python/comments/9rp6t/bdfl_supports_distribute_over_setuptools/). The situation with setuptools is so bad that [Enthought have their own package for the specific purpose of bootstrapping an ETS installation](http://pypi.python.org/pypi/ETSProjectTools/). That said, I know that Traits, TraitsGUI, TraitsBackendQt easy\_install just fine. Enable and Chaco typically don't easy\_install for me, but work if I grab the tarballs. The only problem with Mayavi is usually getting VTK built, but there are often Linux distribution packages that handle that.
[IPython](http://ipython.scipy.org/moin/)
Props in particular on the archaic Hiragana in the link. And thanks again for the references earlier. I appreciate it!
Point taken, and I genuinely appreciate the feedback and I will indeed look at your suggestion going forth. *However* for the application I referenced earlier this is absolutely not a problem. This case is at the divergence of doing something well vs. doing something good enough. My job depends only on *code* being good enough (many people on my team don't code at all, it's only output we're focused on), so it suffices. But I definitely want to strive for doing things well, so I'll keep this in mind in the future!
Meh, it was a stupid idea anyway.
I've done the same thing. It's ugly and awful, but you can hack something together just using the AST module -- there's enough information there (you mostly need the line numbers of the docstrings) to recurse through the parse tree then use those to edit a copy of the source. It will also make you feel so, so dirty.
There was a Python Magazine?
The first lecture is a bit inaccurate here and there. A declared variable is called a "value" and the sys module is purported to have "a lot of operating system stuff so you could access command like arguments...". Not a terrible tragedy, maybe I should be less pedantic...
You know, it's just resting.
it is a great magazine. the author says they haven't received anything since last august. I have issues up until November at least. So something is going on with his account. probably forgot to notify them of a move or something.:) 
&gt; Wouldn't it be nice if PyPI, or some other external service that gets package-upload notifications from PyPI via pubsubhubbub, could immediately validate the package by running 'setup.py install' and the test cases .. This would be indeed nice but it would grant the script authority in a public environment that it probably shouldn't have and there aren't any reasonable restrictions to it, being acceptable for script authors. Alternatively, a blame system could possibly work, once the package author subscribes to it.
The only idea right now is to use the AST module (first I thought that inspect can get everything done) to walk trough the whole tree and check if the node has a docstring: if hasattr(node, "doc"): # do some thing Then convert the docstring and than place it on the exact same spot where the whole doctring matched. It basically comes down to matching and replacing. (and taking care of the right indentation) It's a hack but hey ... get's the job done. 
*He's not quite dead!*
yes. but you know it's hard to compete against good docs, freely accessible code, conference videos, screencasts and etc...
python programmers assume too much.
The Python language has changed a bit - for the better: if you need things which haven't been ported to Python 3 (i.e. many libraries), you need 2.6.5.
I was in the same spot last year, I started with 3.0. I switched over to the 2.x line because the libraries were just not there at all. It's a little better now though. Stick with 3.0 unless you feel there are libraries that you need on the 2.x side. There's always 2to3 though.
I will be 100% honest in saying that I am so new that I don't even know what libraries I would use. I'm actually quite a bit lost right now with some things. Hopefully it will all come together as I keep on learning. I'm only 1 day in! 
I think they really are still hashing things out and have an intent to continue. I only say this due to a conversation I had at PyCon with a previous editor.
I read the ex-editors blog a while back. (Google for it) but he said that the reason for failing was due to the previous editor and times getting all messed up for publication. Anyways it was a great idea however it just lacks the real genuine interest from the community it seems.
Links to all these wonderful resources for python? I'm subscribed to ShowMeDo.com but they really need to update their site and maybe use something aside from flash...
This is not in any way specific to python. Authors using other languages should make sure their build/install scripts work as released too.
If you're into Twisted, inlineCallbacks has been around for some time: - http://blog.mekk.waw.pl/archives/14-Twisted-inlineCallbacks-and-deferredGenerator.html - http://twistedmatrix.com/documents/10.0.0/api/twisted.internet.defer.html#inlineCallbacks I wish you could do this in Javascript too... :)
ahh dear scientist, first rule in business is that suboptimal is ok ;) just make email threads (as in gmail threads) be automatically posted into the website and new questions on the website be new email threads, from them send back and forth every other email/post. just an idea maybe your people won't like it but it absolutely doable and yes, you lose the voting when on email mode but that's ok too.
I've been told by a friend that there are some issues with inlineCallbacks, something about strange non-deterministic errors. That being said I used them on my last project without issue, so much nicer than callbacks.
haha no I meant the "more calculus and less lambda" or something like that
Cleverness is not something that should be taught to beginners. Explain how to think about the problem.
This does not work; printing multiple times puts newlines in between which this neglects.
I know, I have never found the docs and examples to be lacking, but it would be nice to get an up to date account of what is going on in the Python community. But I guess r/Python is good enough.
It's pining for the fjords.
This is a nice idea, but it has less applicability than you might imagine because Python generators cannot be nested. In other words, if you yield from a function, you cannot also yield from a function that it calls; you'd be yielding back into the intermediate function.
You can use a "trampoline". See http://www.dabeaz.com/coroutines/ for details.
One of the aims, as far as I can see, of the ask.scipy.org website is to have a user-controlled FAQ that is structured, easily searchable (through tags) where the 'approved' or 'accepted' answer is highlighted. In other words, there's a lot of important metadata that you don't get with mailing list archives. Auto-posting mailing list traffic to ask.scipy.org would defeat the purpose in this regard.
I used python and cherrypy for my final year project at uni. I needed a quick turnaround and it was perfect for prototyping. And I haven't stopped using it since I graduated!
emacs and print statements
I like vim.
I use SPE, but I just do scripting and not GUI so I don't know about it's GUI capabilities. However, Eclipse, netbeans, Aptana, etc all have python plugins too... they're just not "made for it". 
I love both Pylons and Bottle. The Pylons book is open source too. http://pylonsbook.com
for example, you can watch pycon videos [here](http://pycon.blip.tv/) google also publishes many python tech talks. oh, showmedo sucks. (I have not found anything particularly interesting on it)
It's not in the repository, but I'm a fan of Spyder.
I use extensively vim, logging module, pdb, ipython, werkzeug for web. But you can take a look to these python-oriented IDEs: SPE or ERIC for glade replacement search for Gazpacho.
I agree with the SPE recommendation, but I also do no GUI development. It's very robust (especially the integration with pdb). 
I like vim or emacs, but eclipse with pydev is pretty good as an IDE. Glade and QT Designer are the main GUI designers. You can use QT with gnome. You could try gazpacho. It has a GUI designer with GTK and kiwi widgets. [Kiwi](http://www.async.com.br/projects/kiwi/) is a framework for pygtk that has some really interesting ideas about connecting variables to GUI input and output.
I like SPE and emacs. Boa Constructor has a nice GUI facility for wxwindows. It's kind of VB-like. but without VB. It's in the standard repos.
That's the way it's meant to be.
I hear everyone talking about vim and emacs, but I get the impression these are really for the hardcore coders. I'm new. I'm only just learning to program, and am actually teaching myself python. I get the impression that maybe i shouldn't be committing time to picking up vim or emacs just yet. I liked IDLE, but I started on windows and some time ago I slapped ubuntu onto my PC. I do everything in the terminal now. To run code, I write a script in gedit, save it, and then run it in a terminal. If something is wrong, I have to go back to gedit, save, and rerun my last command. I know there has to be an easier way. Help? EDIT: Wow...that was a strong response. Which package would y'all suggest I install? $ vim The program 'vim' can be found in the following packages: * vim * vim-gnome * vim-tiny * vim-gtk * vim-nox Try: sudo apt-get install &lt;selected package&gt; EDIT2: nevermind, decided to try vim-gnome to start. I don't need to get the community's input on *every* coding decision I make :)
gedit is really nice and pdb is very helpful for debugging. I've just recently learned vim and it speeds up your work 100x, plus the learning curve is not that hard. 
No, you really should. Neither are as difficult to use as some make it out be (you start with your normal, minimum set of keys and with time expand from that), but they're probably the most productive tools for development. I personally think it's best to start investing in a powerful tool as soon as possible. Five years from now you'll still be learning new things about Vim, but a week from starting you'll already be more productive than if you used a regular editor.
For anything I think is going to be under 100 lines, I tend to use something simple like nano. For anything over that, I'm a fan of WingIDE. The free version is pretty reasonable.
I wasn't trying to be clever. I thought I understood what he wanted, so I showed him how. I specifically I mimicked the code he supplied so he could compare it with his and see the difference. 
GLADE is about as good as you're going to get for 'drag and drop' interface design in Python. I'm not into those kind of tools, personally. I think the code they generate is frequently downright nasty. I actually really like PyDev (an Eclipse plugin) for developing Python. It does nice syntax highlighting, provides an interactive shell, etc etc. Everyone suggesting emacs and vim (for large projects) is crazy. Their python modes are light years behind even IDLE (Python's provided text editor). I say this as a long time emacs/ctags user for C and C++ development. Edit: I think it's amusing that people hold Eclipse/PyDev's project-oriented aspects against it. If you're writing something for sysadmin and scripting purposes then don't use it, that's not what the tools intended for. If you know the libraries really well, use emacs or vim. If not, use IDLE, since it'll show you the methods from the builtins and any imports you've done, at least. I assumed, though, that since the submitter wants to write something with a GUI, we were talking about more than a "simple single-file script". Do you all walk around with emacs-oriented factsheets in your wallets?
My bad, thanks for the clarification. I am pretty sure TraitsBackendQt is in there and just assumed PyQt would be too. Hopefully in a little while, when pyside is up to snuff on all platforms, it won't matter.
The basics aren't hard to pick up, but the tools have a lot of depth; as you use them you'll learn more and more shortcuts, write macros, etc. The important thing is to choose a tool that will grow with you. For some it's a good IDE (Eclipse, Vis Studio), for others it's vim/emacs/textmate. It's not notepad and it's not gedit.
+1
Keyboard shortcuts can make it faster. ctrl+s will save, alt+tab to switch to the terminal, up arrow or ! will rerun the last command. Also you can enable the terminal plugin for gedit and have a terminal running in the bottom pane of gedit. As others have said, personally I'm much faster with vim than with anything else. A quick run through vimtutor (just type it in the terminal) and you are well on your way to powerful text editing.
VIM is well-suited to shorter scripts in Python. Find a good mode, and you're off. It works very well. I don't use Python for larger more complex projects, so I can't comment on that. There is a steep learning curve to VIM and Emacs, but it's worth investing the time. Once you get the hang of VIM, you'll be using it for a lot of things.
with pydev, is it possible to create/edit a simple script.py without creating a project ?
 Issue #5237: Allow auto-numbered fields in str.format(). For example: '{} {}'.format(1, 2) == '1 2'. I thought Python 3.1.1 already allowed that? In any case, thanks for the hard work!
Have you actually tried to use IDLE on Linux?
Hmm, I'll stick with [Amara](http://wiki.xml3k.org/Amara2/Seven_days/1). Much more [fun](http://www.xml3k.org/Amara2/Seven_days) with it.
When I was working in an MS shop about 7 years ago, using Python + Win32 extensions to replace VBScript for our sysadmin needs. I then used it with Cheetah for a primitive CMS, building static pages with common layouts. Around 5 years ago started doing websites using CherryPy and Quixote, later Django and Pylons. Now I work with Python full-time (mostly Django). Two things I liked about Python then as now: the syntax and the "batteries included" standard lib. They say syntax isn't important, but if you have to work with a language day in day out it makes for a more pleasant experience.
You have a point there. That's why Python needs so desperately to see PEP-380 approved: http://www.python.org/dev/peps/pep-0380/ I've not tested it, but this is worth a look: http://code.activestate.com/recipes/576727-pure-python-implementation-of-pep-380-yield-from/
logging is not debugging
Komodo Edit is the best. Than come Gedit, Geany and if you are HC coder, Vim and Emacs. But seriously try Komodo Edit. You won't regret.
&gt; Everyone suggesting emacs and vim is crazy. Their python modes are light years behind even IDLE (Python's provided text editor). Emacs does syntax highlighting, comment/uncomment, indent/dedent, and can execute the current buffer in a Python process. It can also, if I ask it to, pop up the `pydoc` for the token at point. There's a bunch more stuff I could configure it to do but, well, that's about all I need from a Python editor. Last time I tried out an Eclipse "solution" for Python development, I found that it was churning a huge amount of CPU on practically every keystroke thanks to all the helpful "features" fighting to see what they could do for me as I typed. Not to mention that even simple single-file scripts have to be treated like any other project, and so involve a bunch of multi-step wizards to fill out before I'm even allowed to write a line of code (as compared to Emacs, where I just open a new buffer and start typing).
&gt; I hear everyone talking about vim and emacs, but I get the impression these are really for the hardcore coders. I'm new. Ten years ago, so was I. I took up a suggestion to try Emacs, put in the time to learn the basics (took a weekend) and was off to the races. Ten years later, I'm glad I did that; Emacs is still my editor of choice.
Is unloaded swallow included? 
I wish it was easier to use cython in python. Something like: import cython print "python" cython.start() cdef int f(cdef int a): print "cython %d"%a cython.end() print "python again" 
No, it’s slated for [3.2 at the earliest](http://www.python.org/dev/peps/pep-3146/).
I still have 3.1.1 on my system, and it worked.
I wish simplexmlwriter be in stdlib too
The NEWS file spans several releases, that was done for Python 3.1 alpha 2.
All true, all true. There is also the advantage that I can use it for almost every task I take up, and so what I learn once carries over.
I'm a big WingIDE fan. The paid version is pretty cheap, and it's worth supporting the guys who make it, IMHO. Support is good, with regular (free) updates. Give it a look-- [free trial is here](http://www.wingware.com/wingide/trial)
Can't believe nobody's mentioned [Pida](http://pida.co.uk/) yet.
Yes. I do it occasionally (usually a few times with each new release to see if I like it better yet). Seems to run better than on Windows, actually.
I assume you mean unladen swallow.
No, it's clearly un*load*ed swallow.
thanks for your advice. i checked bottle. at first it seemed like a very good framework, but while i'm building the application, i realized there were some deal breakers: * documentation. there is no api/reference or something like that, which i can quickly see list of classes/methods etc. only document they have has this text in the beginning: "This document is a work in progress and intended to be a tutorial, howto and an api documentation at the same time". while it's enough to get you started, it is really not enough to make something meaningful. i needed to get the request url, but i couldn't find it anywhere. then i found it in the docs of unstable, development versions docs. (luckily it was also implemented in the stable release, but then why not mention it in stable release's docs?) * assumptions. while not as much as django or web2py, bottle still assumes i am building application in a certain way. for example when you are using routing, you have to use '/' as delimiter between parameters. only way to override is to get whole request url and parse it yourself, which i did in the end. thanks for routing, but it's unusable. * then i wanted to implement sessions. only mention of sessions is in the faq section, with one example, which is using a library called beaker. no other mentions anywhere, not even in google groups. how is it possible that no one had any questions regarding sessions? * server autoreloads successfully when i update the files, but it sometimes stop working for no appearant reason (even with debugging on). * templating system is a mess. i still don't know what 'rebase' is. you can not just explain it in one sentence and then leave it like that. and templates have to be .tpl files. why are you assuming this? it also caches them automatically. why are you assuming this? in the end, i dropped bottle to find something else. while it's a good framework, i think it's not ready to use for real applications.
It's good to hear you did give it a try. Personally I'm using CherryPy, which you didn't seem to like either, not bottle. But overall, I'm not sure you can find any framework that will match your requirements as they seem to be rather orthogonal at times. Pure CGI?
Damn, just for the name I wish I had a use for this.
i dont know much about pure cgi alternatives, but i think i will try a few other options and then go with whichever has better documentation or userbase. it seems that i will not get what i want on the short run, so i have to compromise until i build my own framework :)
I have a feeling you will, too, force development in a certain way ;) Good luck nonetheless.
At first glance I thought that Kraftwerk and Tool are going to manage wsgi apps -_-
It turns out it's possible to use nested generators keeping a stack of generators. It's even possible for this nested generators to return a value to its inmediate caller if needed (raising an StopIteration exception, like cogen does). See: http://code.google.com/p/pysheng/source/browse/trunk/misc/asyncjobs_simplified2.py More on that: http://code.activestate.com/recipes/577153-yet-another-python-implementation-of-pep-380-yield/
Hey, I'm the author. Just updated the site with FAQ and contact pages.
What's the difference between this and Silver Lining? (The basic deployment pattern all looks pretty much the same)
Best. Server. Ever.
Emacs. But it's too hard for you, don't even try it.
I have to say, I agree with some of the point here, having used Python for small and large tasks, there comes a point at which having some sort of really good project management system; like that found in PyDev+Eclipse; becomes quite useful. You can use vim to write larger projects, it's just a bit of hassle if you haven't got it configured to a tee, and you do need to know more than your basic stuff. IDLE is something that I've barely used, along with Glade. I just haven't needed them. Personally, if something is going to take &gt;3 module files, I'll go for Eclipse + PyDev. Anything less and I find Vim perfectly suitable for me. Use the right tool for the job, Eclipse+PyDev is simply overkill for some things, but vim is a little limited for some larger things. On a side not, I find emacs down-right scary, but that's an entirely different flamewar ;-)
[Not according to google.](http://imgur.com/7F6wI)
Maybe he meant overloaded swallow constructors?
How do you find deployment of Python GUI apps? Is installer development difficult?
I work at a start-up and we were looking at all the software we had to interact with. Every single one was written in Python, so we went with it to makes things easier. It turned out to be a brilliant choice. Great web dev, system, everything language. Everything you need is there, the syntax is fantastic, and a huge productivity booster.
Taken from the recently amended FAQ section: Basically I liked Silver Lining so much I made my own. The server stack is a bit different (no Apache, no varnish, just NGINX and gunicorn). There is no library requirement on the servers (no kraftwerk support library). I also needed something that worked with EC2 - (my pull request with Silver Lining EC2 support didn't seem to go anywhere). I'm using argparse and yaml instead of optparse and ini files. Setup scripts are run through a template engine and the user can supply his/her own overwriting templates. The whole push model idea is completely ripped from Silver Lining. As is the services idea which is a great design. Maybe this sort of thing will become the new "roll-your-own" software category.
Personally, I use GTK with PyGTK as the python wrapper. It's nicely cross-platform for linux &amp; win32, renders exactly the same if I want (or mimics the OS if I don't), has decent python integrate and good documentation. However... while PyGTK has nice installers to download, getting a good GTK installer, along with Glade (the gtk ui designer) set up under windows, and then getting it packaged into a standalone using py2exe... was somewhat of a pain under windows. (I'd love to post the scripts and sources I've collected for doing all of that, but they're all over the place in my company's build process). Another drawback is that it's possible to use on OSX, but the installation is more complicated, and the integration isn't as good. The next option is wxPython. wxWindows is a cross platform wrapper for native gui. On windows, it uses the std windows gui; on linux, gtk (or maybe qt?); and it's even native on OSX. I haven't used it that much, but it's got a good gui designer (wxGlade), and does manage to be almost seamlessly cross-platform. The only catch is that the gui object model is much more complex, since it has to encompass the superset of all the guis it's wrapping. [Not familar enough w/it to say more]. Then there's qt / pyqt. QT's now LGPL, which is nice. PyQT is still GPL / commercial; but there's a separate workalike project that's LGPL (can't remember the name right now). QT is probably the fastest, cleanest (design wise), and most responsive gui of the bunch. It'll work natively under windows and linux. Not sure about OSX. I'm also not that familiar with it either. On the more esoteric side... there's XULRunner, the backend system which Firefox and the other Mozilla projects use (along withe Komodo IDE). It's an XML ui language, w/ css for styling, and natively uses javascript as it's programming language. BUT there's a plugin called PyXPCOM which lets you code applications in python. As demonstrated by Firefox, this toolkit is incredibly cross-platform. However, the toolchain is complex, and PyXPCOM is still "alpha" quality. It does give you nice separation of code &amp; gui, but I wouldn't recommend this chain except for personal exploration purposes. All in all, while I'm partial to GTK, I think I'd have to recommend QT. If you do go that route, the exceptionally nice [Eric Python IDE](http://eric-ide.python-projects.org/) is not only written in PyQT (and thus is cross-platform itself), but has extensive QT integration, debugging, and widget designing. 
&gt;(I'd love to post the scripts and sources I've collected for doing all of that, but they're all over the place in my company's build process) PLEASE DO THIS. I've given up on gtk/pygtk for this reason and started designing one of my programs in wxwidgets, but I'd rather do it in pygtk to be honest... 
Wow, thank you. Excellent food for thought. I was starting to look at wxPython, but I think I may take your recommendation and go with QT. I actually have dabbled a bit in pyqt, so it won't be completely new to me. Thank you again, warbiscuit. I appreciate the help.
I have only used wxPython, but have been very pleased with it. I like that it looks native in each OS. Of course, you may want to consider learning how to develop a web interface for your app. More and more things are run through the browser, even many local applications.
LGPL python bindings for Qt - Pyside - http://www.pyside.org/
&gt; Jonathan "Django is feeble" Ellis Let the record show that when I said "Django's ORM is feeble" in February of 2007, you agreed with me in the hallway afterwards. (And that's a long time to hold a grudge, dude.)
*Edited to remove my original response because:* on re-watching the PyCon forms panel video I see I recalled incorrectly and it wasn't you who made the "oh, so you *will* use other peoples' code" comment to Jacob. That whole exchange really rubbed me the wrong way, which is one reason why I decided to go after the NIH comment that started this.
There are a number of good [books](http://plone.org/documentation/books) available.
I've tried both Tkinter and wxPython, but PyQt eventually won me over.
I honestly would prefer doing this as a web app, but I'm pretty sure the customer for this job wants a native app running on Windows.
Screen and Vim are for you. Tips: Put the next line in your .screenrc file: caption always " | %-w%{= BW}%50&gt;%n %t%{-}%+w |%&lt;" Customize your vim with some plugins like nerdtree, taglist, snipmate. Very soon you'll use cplay (or another text one) to play mp3 music ;-)
didn't they announce that they're switching to Mercurial like 20 years ago? why is it still subversion
You can quite easily embed Webkit and a virtual filesystem to have the best of both worlds
No Windows support. ;_;
Another approach might be to use [pyjamas](http://pyjs.org). I believe that you can run it both as a web app and as a standalone. It strikes me as a great approach for intranet type applications, yet enabling usage from the net as well.
Read http://guide.python-distribute.org/
I'm not denying that. just making reference to the ["infamous z shaped learning curve"](http://faassen.n--tree.net/blog/view/weblog/2008/09/19/0).
In the __init__.py?
Thanks but after [this](http://guide.python-distribute.org/creation.html) i'm still none the wiser.
Cheers. __all__=['interface'] In my __init__.py works.
Another major issue is that you have a file and a package (read: folder) with the same name. Why is there a in your root Gereqi.py? I assume that is some kind of front-end script, which you shouldn't have, let distribute generate those.
I love Python too, but really, there isn't much point to writing a Windows app with Python. You'll get the job done much faster and with much less frustration if you just use .NET for the UI at least and then there's nothing stopping you from using Python for the under the covers / server-side business logic. 
Monthy Phyton?
Yeah, i'm always nervous about doing that. I try to differentiate by using capitalisations. It's not a [frontend script](http://github.com/regomodo/Gereqi/blob/master/Gereqi) as such. It can run locally or as the "frontend script" when installed without modification. [This](http://www.google.co.uk/search?hl=en&amp;client=firefox-a&amp;hs=LCC&amp;rls=org.gentoo%3Aen-US%3Aunofficial&amp;q=distribute+tutorial%2C+python+packaging&amp;meta=&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=) is why I haven't tried distribute. In any case, my issue is solved. A problem with not filling out __init__.py properly.
The best hackable blog software is Jekyll. It's Ruby software but you won't be deploying anything but static files so give it a shot locally at least. http://github.com/mojombo/jekyll
You should really be using distribute for now. Once distutils2 is ready that will be the way forward, but Tarek will take a little while to sort that out.
That example shows almost no advantage of just using rrdtool on command line. 
The [Daily Python-URL](http://www.pythonware.com/daily/) used to be great back when it was, you know, daily. Too bad they slowed down but I gather it was a lot of work.
they promised. i have it written down &gt;:(
.NET might be a good idea but I'm surprised and disappointed you completely neglected to mention IronPython.
I created [this Twitter filter webapp](http://queshuns.com) using CherryPy, Jinja2 and redis. I've got more info [here](http://bulkan-evcimen.com/building_twitter_filter_cherrypy_redis_tweetstream/)
&gt; Yeah, i'm always nervous about doing that. I try to differentiate by using capitalisations. Please do not do that. Windows FAT32 is case-insensitive, and Mac OS X's filesystem HFS is case-insensitive (but case-preserving). If there is some technical reason for excluding such a large portion of potential users, then by all means do it, but it seems kind of pointless to lose users over something as trivial as a file name. &gt; It's not a frontend script as such. It can run locally or as the "frontend script" when installed without modification. Yes it is. You even say so in the docstring of the file: &gt; The main script to run the application Rename it to something like main.py, and put it inside the gerenqi/ subdirectory. Then register an entry-point in your setup.py.
&gt; This is why I haven't tried distribute. http://pypi.python.org/pypi/distribute
Trouble is, I don't have VC++ or VB -- and I certainly can't afford to buy them. Plus, from what I have seen, the native Windows C++ GUI libraries have a pretty steep learning curve. I'm not sure I could develop such an app in a reasonable amount of time with no experience at all. Do you think I'm overestimating the difficulty?
A couple of tools you may want to give a try: - [mkpkg](http://www.tummy.com/journals/entries/jafo_20100302_003614): create setup.py for existing projects - [modern-package-template](http://pypi.python.org/pypi/modern-package-template): create Python project layout using distribute and buildout
One thing that might cause problems is that certain exceptions in `__init__.py` get swallowed (mostly I guess so if your `__init__.py` is hosed you still can import other things from the package). But maybe that's not it. Also your two names differing by case will break on Windows and Mac situations where they are case-insensitive. So don't do that, crazy stuff will happen. Maybe you are importing the `interface` object (which happens to be a module), and so then you can't do deeper imports?
SharpDevelop supports IronPython, and it's free and has a decent GUI designer. http://www.icsharpcode.net/OpenSource/SD/
I'd be tempted to start with [Iron Python](http://www.ironpython.net/) and find out what sort of tight integration you can do via that to the .NET bindings. I think it even contains tools for rolling an app that doesn't require any extra run-times be installed (just the .NET CLR).
as others have noted, the most suspicious thing is the gereqi/Gereqi naming. I suggest mkdir bin mv Gereqi.py bin/Gereqi and in setup.py change scripts to ["bin/Gereqi"].
I don't understand why, though. There's a piece of this I'm still missing. e.g. this works just fine: $ mkdir bestpackage $ cd bestpackage /bestpackage$ ls /bestpackage$ touch __init__.py /bestpackage$ cat &gt; foo.py class Foo(object): pass ^D /bestpackage$ ls foo.py __init__.py /bestpackage$ cd .. $ PYTHONPATH=$PWD python Python 2.6.5 (r265:79063, Mar 20 2010, 14:40:09) [GCC 4.4.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from bestpackage.foo import Foo &gt;&gt;&gt; Foo &lt;class 'bestpackage.foo.Foo'&gt; &gt;&gt;&gt; ...and that was presumably working for you too in development, before you installed it to site-packages? import semantics don't magically change when things are copied to site-packages, though.
you might want to give the free Visual Studio Express a look: http://www.microsoft.com/express/Windows/ I wouldn't bother with C++ (unless you have a good reason to) - you're better off with C# and the .Net framework whose learning curve isn't bad at all (i.e., stay away from the Win32 SDK or MFC). But since you prefer to develop on linux, it might be worth checking out Mono: http://mono-project.com/Main_Page to develop/test on linux, and then run natively on Windows. And I agree that IronPython is also worth a look.
Most important for me, you can use their designer software (Qt Designer) for free to lay stuff out. I hate making interfaces programmatically.
&gt;Yes it is. You even say so in the docstring of the file: Yes you are correct. It's a long time since i've touched this file. WHen you said script I assumed a .sh. My choice of dirnames seems to be controversial but it's only relevant to platforms I don't develop for. I'll change it anyway just to be *correct*.
I believe the switch was announced at pycon a year ago and I think it basically fell on one guys shoulders to do the port while getting everyone else to switch over when it was done. http://hg.python.org/ is where the repo is, I'm not sure if anyone is commiting directly or if they're just importing from svn still.
Incidentally, a PyQt Amarok 1.4 clone sounds like a really cool project. Good luck with it!
I'd use a web framework, deploy it locally, and fire up IEhta. Then code your GUI using HTML and smth. like Dojo, jQueryUI or similar.
starts off as an interesting idea but hidden input fields? Really? Yuck.
I've used wxPython to great success. I've coded w/both py2zip and py2app on the *same source code with minimal compiler directives for plaforms*. Compared to the Swing API, wxPython passes the blind os 'taste' test for native looking apps w/flying colors.
That's just not true. The opposite may be true, though. I code for a living in C#, VB.NET and Python. Learning curve aside, Python requires less code and less typing for the same functionality.
The learning curve is everything if you're just trying to get something done but, to each his own.
IronPython is a good tool and looks nice, but I just don't know how productive one would be while trying to use it for a Windows app, that's all. Also, I would think one would need some understanding of .NET CLI to make Python work correctly with the rest of .NET; though that may be more unintentional FUD on my part as I haven't attempted to suffer with it for a while.
.NET does not require you to use C++. If you want to use a nice garbage collected "brackety" language like C++, then you can use C# and it's very beginner friendly as well. The Visual Studio Express tools that five12 pointed out are the way to go for beginners. IronPython is a good tool and looks nice, but I just don't know how productive one would be while trying to use it for a Windows app, that's all.
As much pain as it has been in the past, a combination of Eclipse and its PyDev plugin is better than *anything else* I have seen. Even has an integrated GUI-based debugger.
That IS nice! I don't know how easy it would be to use to get real work done, but I would definitely look at it for a hobby project.
You have a better idea?
To the people who downvoted this guy: Stop it. I know this is the Python subreddit, but he's expressing a perfectly valid opinion. vplatt: Thank you; you've given me something to think about.
I have a shitload of C++ experience; do you think I can transition quickly to C# from that?
Hell yeah. [Andy Mc's C# FAQ for C++ programmers](http://www.andymcm.com/csharpfaq.htm) That said, if you're already hacking C++, you'll probably find getting Python to work with the likes of wxPython/Qt, etc. as the others have suggested, to be not too bad. So, it's decision time. PS - Never mind the down-mods. I don't troll and the fanboys aren't worth bothering about. :)
I have the most experience in C++, but that means I also know what a temperamental pain in the ass it can be. I am most comfortable in Python, and if I had my choice, I would use it for most or all of my development projects. So, yeah, like you said: it's decision time. Everyone here has certainly given me plenty to think about. I'll probably play around with some of the suggested tools and see how quickly I can hack together a simple GUI app, and then go from there.
FWIW - I did have a simple hello world message box app going in IronPython using SharpDevelop in about 5 minutes. If you already know Python, then you're just climbing the .NET curve (which isn't necessarily trivial, but what is?). 
Good point: they should use Microsoft Access or Apple Hypercard
debugger -&gt; ipython editor -&gt; vim in any linux distribution :)
just install vim package
Or conversely, learning curve is nothing and one should attempt to use the most complicated solution instead. Therefore he should use assembler for the project. Edit: Assembler? I did say most complicated, so let's just stick with binary effected through the use of magnets. 
[Cross-posting from /r/django because I thought it might interest folks who don't follow that subreddit as well](http://www.reddit.com/r/django/comments/bh64f/theonioncom_is_now_djangopowered/)
Twitter confirms: http://twitter.com/TheOnion/status/10921296161 Looks no different from the Drupal version. 
Can't the mappings be inferred by location and same 'name' values? The hidden fields just seem like they'd be harder to manage than it would be to just extract the strings from POST manually.
Thanks, that works for the installer.
Can you please explain what is IEhta ? From what I google, its a browser test plugin in selenium
not really. you can encode sequences and mappings in the form in arbitrary ways. it'd obviously be possible to infer that a set of fields that were in some way relative to each other that had the same name were meant to be part of the same sequence, yup. but the point is to be able to not just have sequences of primitive fields, but also sequences of sequences or sequences of mappings, mappings of sequences, etc. this cannot be done by giving fields the same name.
&gt;Looks no different from the Drupal version. I would guess that's the point...
Would have been nice if the linked article mentioned this advantage. Still, I wish you could use the API with regular function calls instead of having to build the ridiculous expressions RRDTool tends to use for everything. 
Using structured names, like the first examples? In particular, I don't buy this quote: "But writing and using the code to munge and demunge these keys is not much fun. It would be easier to decode, in general, if you used a stream in the form of a sequence of key/value pairs instead of a mapping." The code to munge isn't really that hard to write, and only needs to be written once. Then you get to put it in a library and call on it, in the meantime writing html that doesn't look like something out of the wrong end of a dog.
I'm probably really dense but I can't think of a compelling reason for CMIS to exist. Can someone explain with a real-world example?
Part of the site, the A-V Club, has been Django-powered for 2 years now. http://djangositeoftheweek.com/av-club/
I honestly don't understand why everyone loves Django so much. Granted, it does take a lot of the hard work out of programming a large scale web application, but it just seems so clunky and way too abstracted. Maybe it's just because I like having fine grain control over everything that I feel this way...
&gt; Maybe it's just because I like That's probably the difference. People tend to have a wide range of opinions about the tools they like to use, and I for one am happy that there are options available to suit just about anyone. Personally, the thing I don't understand is how many people elevate their subjective opinions about such things into a belief that they must represent objective reality, or that there's something wrong with someone who has a different opinion...
Why would anyone click on a headline that directs you to twitter.com. Are they going to show a twitpic of their server or something, because I'm pretty sure 140 characters is not going to result in an interesting "post" about a framework migration.
just let me know when whitehouse.gov goes to Django ... then i might care :/
You definitely haven't worked with it for any extended amount of time on something besides Hello, World! Clunky would be the exact opposite of what Django is. It's smooth, it flows, and just makes /sense/. Having to do projects in other languages makes me cry because of how ugly other frameworks are compared to it. It's no more abstracted than any other MVC (or as they like to coin it, MTV) Framework in the OSS community. Everything in Django (in theory) is modular. Don't like how something's done? Do it yourself, or fork their module a bit. It gives you complete control over your web application.
I'm with you. Building a site in Django the first time, for me, was awful. I moved to pylons after a month of banging my head against a wall, and have never been more pleased with a web coding environment. I need that fine grain shit.
I dunno, I just feel like "lighter" web frameworks are more my cup of tea, ones that really stay out of the way. [Web.py](http://webpy.org) and google's webapp framework are my favorites, just because they don't require you to "learn" how the framework works (except for a few of the basics like databasing, response objects, etc.).
I never really tried Pylons; after using Django and being unhappy with it, I found [web.py](http://webpy.org) and have fallen in love with it ever since because of it's "lightweight" and unobtrusive design.
&gt; Personally, the thing I don't understand is how many people elevate their subjective opinions about such things into a belief that they must represent objective reality, or that there's something wrong with someone who has a different opinion... This is exactly why I added that it was only my opinion, haha. I didn't want to get the django army on my ass...
I don't know what you're talking about; it seems to have served its purpose. That post took a few seconds to produce, and now we know something we didn't before. Given that we've all read it and genuinely seem interested, I would bet there is later an article that says much more, given that interest.
Complaining about frameworks being frameworks makes no sense. Web.py (albeit awesome in its own right), is a 75kb starter kit of a few files to make the first 5 minutes of starting that web app easier. It takes care of a few menial tasks and leaves everything else up to you. For what you're looking for, Web.py is great. For people looking for frameworks, Django is the answer.
Refer to ubernostrum's comment above about making subjective opinions into objective reality. Django is ONE answer. It's not the be all and end all. Some projects suit it better than others, and some people for various reasons don't like it or just prefer other solutions.
I'm curious what issues you had with Django over Pylons, considering how very similar they are.
&gt;I honestly don't understand why everyone loves Django so much. Granted, it does take a lot of the hard work out of programming a large scale web application... Umm... 
[See here](http://www.reddit.com/r/Python/comments/bh76k/theonioncom_is_now_djangopowered/c0mrqx5), I've never tried Pylons before.
So adding a form element (or a collection of form elements) to a sequence (think "multi file upload") should look like this: http://github.com/ish/formish/blob/master/formish/js/formish.js Rather than this: http://svn.repoze.org/deform/trunk/deform/static/scripts/deform.js What was that about the wrong end of a dog?
Why does it matter? Subversion works.
sqlalchemy versus the abomination that is django's orm? building your own authentication code versus django's cripped auth? there are many fundamental differences. it's been too long since i've touched django to give you a list of reasons why i did not like it.
Have a well-deserved upvote for an informative post!
contrib.auth definitely needs work, and I agree with you that better native sqlalchemy integration would be a great step forward. Neither of those have ever been a game-changer for me though.
or master the abacus. For Dr. Who fans, see Logopolis. I like where this is headed... Once Visual Studio &amp; Office (2012?) support IronPython as a first class language, this question is moot.
By the way, underscores are treated like asterisks by the Reddit markdown as far as text emphasis goes, so you need to escape them with backslashes to talk about \_\_init\_\_.py (thus: \\\_\\\_init\\\_\\\_.py) casually without it getting messed up / marked down. :)
and the Grammys and MTV etc. Anyway it's sad that Drupal lost this one but at least they chose again an open source CMS and for what everybody says a really good one. Congratulations to Django.
We have an army? Cool! (unfortunately, there are fanboys everywhere; some have latched onto Django, but I'm hoping they find something trendier to move to soon)
Six of one, half a dozen of the other: with an IDE you have to learn a bunch of wizards and workflows and other crap. And I guess your definition of "productive" is different from mine, since apparently you don't feel productive until you've learned every aspect of every feature of the software. I was quite productive with Emacs after learning very little about it, and since the standard keybindings are everywhere (anything which uses readline, for example), it was well worth learning them.
SQLAlchemy is not just an ORM. Its an entire toolkit of tools to work with relational databases, including a connection pool. The ORM builds on top of the SQL expression system and dialect system. The ORM itself doesn't know anything about connection pooling. As far as Django having a an in-client connection pool, I think it would be a very useful addition. They're super convenient, transparent, and solve 90% of the problems that a middleware layer does, and some that middleware does not (such as "initialize on first connect" issues). The Django ORM, unlike that of SQLAlchemy, *does* deal with the specifics of connecting to databases, so the low level DBAPI/connectivity logic is already there. SQLA's pool is BSD - feel free to paste the DBAPI layer that lots of Django users use already right into Django proper, I won't care and I doubt people would complain. Also as far as the attitude stuff I haven't said anything negative about Django since around 2004. I've certainly never called it NIH.
&gt; SQLAlchemy is not just an ORM. I don't care what noun you use to name it; the application layer itself -- which is where that `$NOUN` will be running -- isn't the place for connection pooling. I've made my argument for that quite clear. You've responded by insinuating that Django doesn't include connection pooling because SQLAlchemy got there first, and now you seem to be hinting, with your comment about copy/pasting SQLAlchemy's code, that Django won't include it because it would involve using someone else's code. You may not be uttering the specific phrase "Django has NIH syndrome", but you sure do seem to enjoy dancing around it...
I would've said that Microsoft wouldn't do that, but something tickled my memory and sure enough... Microsoft sponsors it. I guess I'm not too surprised. 
It's pretty much implicit that you sacrifice control for power with Frameworks. Some accomplish this tradeoff at different levels or with various compromises but that's the gist of what a framework does, it says "here, use x to do y" but now you're typically stuck with x because i, j, k, ad infinitum also rely on x. 
Is Django that open source CMS? Or are you talking about an open source CMS built on top of django? Django isn't a CMS. It's a web framework.
Just be careful with multiline docstrings, especially ones with blank lines, and even moreso of ones ENDING with blank lines. That is the only advice I can give beyond that.
I think "understood" deserves some quotes around it :) The syntax is pretty obtuse and hard to wrap your head around. Most people I've seen (eg: on the Cacti forums, or forums for other software that use RRDTool) just mess around with it till they randomly get it to do what they want. I think it's more of a status quo thing than it being good design. I've been longing for a better tool ever since I started using it.
Thank you for posting this in-depth article, explaining what django is, why the Onion wanted it, and why it matters.
I prefer Pylons myself, but for the Onion Django is probably an ideal choice. Their site was built on top of a CMS but they found the CMS was too inflexible for their needs. While Django is a framework and not a CMS, it has a lot of CMS-like features (due to its origins) such as the admin, users and groups and so on, while still allowing for more fine-grained control. Django was built for news sites and the Onion is essentially a (satirical) news site. As always, best tool for the job. 
Thank you for your comment. Next time keep it in capital letters because this comparison between django and drupal is going on my nerves. Makes me wanna turn to other web frameworks because n00bs think that django is soo easy, that is easier than drupal. C'mon!
Thanks for the critique. I'll work on that. * Bottle is relatively new, so is it documentation. I am currently working on a more complete documentation, you found it already: http://bottle.paws.de/api/ * I think *not* consuming the slash is a sane default for route parameters in most use cases. The route syntax however supports regular patterns so you can change that behavior. @route('/some/:path#.*#') @route('/some/:id#[0-9]+#') * Sessions are the number one feature request but I still think that beaker is a more complete solution than implementing sessions within bottle. I should document this better, though. * Server autoreloading is a mess. The new startbottle.py in the repositories works better, but is still not perfect. Some server backends simply won't shut down clearly or block other threads and make reloading impossible. It works best with WSGIRefServer and Linux. I didn't test this with windows at all. * The 'rebase' command is better explained in the [new docs](http://bottle.paws.de/api/stpl.html), but still is a non-trivial thing. It is comparable with (and meant to replace) the inheritance features found in most other template engines and has similar use cases, but works differently. Basically a template that uses the 'rebase' statement is rendered into a string and then passed to another template. The *base-template* uses an empty 'include' statement to mark the location the rebasing template should be rendered to. You can call this a *reverse include* or a *'Please include me'* statement. By passing state to the base template you can solve most problems template inheritance was originally made for. -- The hard coded '.tpl' extension is solved in 0.7rc1. -- The caching is disabled in debug mode, documented and the only way to make templates fast. I don't know a template engine that doesn't do this.
you should write your own Python web-framework. That is quite usual within Python programmers. Plant a tree, build a house, create a Python web framework.
Interoperability. Imagine that you need to create a light website on the top of a huge Alfresco-based or Nuxeo-based Java ECM system. You could use Pylons or Turbogears for instance and read and write Documents that are stored and managed by the ECMs, using this CMIS client. 
Why is this a problem when using the AST to find docstrings? This is trivial and already taken care of.
thanks for update. i will check bottle in the next versions (or maybe bottle 1.0)
That's right .. I'm glad I don't have to work in this space :-). Also good to know that if I do, such tools exist.
You make some sense here and in your comment below. I'll need to think about it some more to accept that the stream solution is the correct one, but it seems at least plausible. This really should be made clear in the article; the way it's presented was not compelling -- there was no example of anything made less difficult by the streams approach, which is why I and keenemaverick struggled to understand the point.
You must be new here.
[citation need...], oh never mind. You provided a link. Thanks.
**Onion Website Now Django-powered** Popular satirical news website The Onion recently switched from PHP-based CMS system Drupal to Python-based web framework Django. What do *you* think?
Nice [usage examples](http://trac.gispython.org/lab/wiki/Examples).
I think Django doesn't have one because they haven't bothered, and if they notice that bump in their request time due to connecting over and over again, they just go through the effort to roll out pgpool or whatever it is, and then its problem solved. The assumption, which you seem to agree with, is that having to run three process to serve a database web page efficiently is just the way it is. I'm just pointing out like I always do, that there's no need to start up a database, webserver, pgpooler process. Just the first two. I'm not saying it very often except to you, in these conversations, long after anyone is following anymore, so nothing becomes of it. None of this has anything to do with SQLAlchemy's existence. 
For some reason I was thinking on Plone when made that comment. Congratulations anyway.
There was no official announcement that I was aware of. The only slightly-more-official announcement is the one that [shaggorama linked above](http://www.reddit.com/r/Python/comments/bh76k/theonioncom_is_now_djangopowered/c0mqwyv) and guess what, that's on twitter too!
Let me know when such a thing exists, and I'll link it
I use Python every day and never knew of named tuple... Damn you standard library you have SO much to offer.. I need to start reading PyMOTW again edit: Of course there isn't a PyMOTW on named tuple :-)
Because it was introduced in python 2.6 and most people are still clinging to 2.4? Or because it introduces some requirements on the fieldnames which adds an artificial limitation that doesn't exists in redis? &gt; Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters, digits, and underscores but do not start with a digit or underscore and cannot be a keyword such as class, for, return, global, pass, print, or raise.
Downvoted for not being snarky and using a LMGTFY link :p
My theory is more that the people who design a lot of these tools aren't software engineers, or don't have a software engineering background. In my experience, tools designed by people with only a scientific or system administration background tend to suffer from major fundamental flaws such as this.
Redis is a totally different thing from using native Python objects - it's shared, so you can access it from multiple processes simultaneously (multiple web application servers, for example). It also handles persistence.
&gt; Those 100,000 python dicts that have just been created to store the rows are going to chew up a ton of RAM. This actually depends on the Python implementation and the number of dictionaries. In CPython, a list of structs for dictionaries is maintained in memory (for use in common dictionary-requiring things like function/method invocations) and they're simply recycled over and over rather than being freed once the Python-level dictionaries they represented are out of scope.
One thing, not with GUIs, ironically, if you're familiar with a C++ GUI lib. There's Windows Forms which is like Visual Basic, very straightforward - actually that's what you want probably - but the more sophisticated version does events differently than regular C++ GUis - you're either connecting data directly (which is nice) or, doing weird dispatch calls; the GUI is multi-threaded and going beyond the basics is not intuitive. 
I find the ORM causes me to think more carefully about what I'm doing when working with the database and it ends up paying off later. As for the auth, there's no reason you can't just build your own as you would with another framework, just don't expect it to work in the admin. Maybe it's been too long since you've touched Django to go listing bullshit reasons why it doesn't work in a public forum.
I would say the opposite about the ORM. SQLAlchemy makes you think like you're writing actual queries, the Django ORM just performs a bunch of magic for you. But hey, these are just my personal "bullshit" reasons. Expressing distaste for Django == Not understanding Django.
tried to explain a little more about it here [The Onion Uses Django And Why It Matters To Us](http://www.reddit.com/r/django/comments/bhvhz/the_onion_uses_django_and_why_it_matters_to_us/)
this is exactly true, and why I'm generally, personally, skeptical of overwhelming love for any web framework. in this case Django was indeed the right fit. and Python as a language, really an excellent base.
It's not just Python. The author has versions for Java, C++, C#, Ruby, Lua, Perl, and PHP. No filler, all killer.
And now I'll do you one better: [It seems the guys behind theonion.com posted about it in /r/django](http://www.reddit.com/r/django/comments/bhvhz/the_onion_uses_django_and_why_it_matters_to_us/)
In my day, we used to call it "Programming".
Anything that requires a bidirectional association, e.g., associating a shortened URL with its original version.
I could see a use with graph type structures...being able to map the path in both directions would be handy. 
not sure it's the desired implementation. Other uses : every time you reverse a dictionnary : - cache id / data (duplication must be avoided) - rowID / natural key equivalent ... 
Here is a link to the (small) section on it: [PyMoTW - Collections](http://www.doughellmann.com/PyMOTW/collections/index.html#namedtuple)
More than the examples used in the description?
It happened more than once that I inverted a dictionary, but always with really small dicts. It was no hassle, so I would use bidict only if it was in the stdlib.
Each node could be a list....so you'd have lists connected to lists
I've seen lots of tutorials on cherrypy popping up in here and I have no idea what all the fuss is about. In my experience cherrypy has been slow, inefficient and a complete memory hog. Of course that's just me.
That is some damn fine CherryPy. And hot too!
Shouldn't inverse be **~** or **!**?
TinyURL always gives you the same one (as it should, in my opinion)...
On reddit, a url and a link ID have a one-to-one mapping. This data structure would be handy for storing this list.
Can you use a list with this?
you can't think of a cache system where you *don't want* duplicated data? don't be lazy, you can certainly think of a use for that.
Indeed. &gt;&gt;&gt; h2w = bidict({'bill': 'hillary', 'barack': 'michelle'})
http://bitbucket.org/jab/bidict/src/8a2eb8d16607/bidict.py#cl-44 -the author (ducks)
they don't
this was just an idea i wanted to explore, with no illusions of its utility to anyone. raymond hettinger (core python developer) voiced practical concerns at http://groups.google.com/group/comp.lang.python/msg/34c4fea7062ff2f3. if anyone actually does end up finding it useful, i'd love to hear about it. -the author p.s. see http://groups.google.com/group/comp.lang.python/browse_frm/thread/785d100681f7d101/34703a66338abbd6 for the full discussion on comp.lang.python.
Hmmm. I guess somebody changed their mind, or I misread it. def __invert__(self): """ Called when unary ~ operator is applied. """ return self._inv inv = property(__invert__) def __inverted__(self): try: return self._bwd.iteritems() except AttributeError: # python 3 return self._bwd.items() This illustrates something that bugs me about Python 3. They turned items() into something that works iteratively and dropped iteritems(). I don't get why they didn't just replace iteritems(). Anybody who assumed items() returns a list is screwed now.
Chronic data structure confusion ITT!
this is really useful actually, all the time I want to go between keys and values. for instance, say I associate a genbank gene id with a refseq id, and i parse some other file that uses refseq to associate to gene ontology numbers, now i can look up by refseq id even though it's teh value. This iirc was an ability in perl which was really nice but I figure had to have various disadvantages to it.
I think the idea is that all functions/methods return iterators instead of lists.
the original comp.lang.python discussion veered in this direction starting with http://groups.google.com/group/comp.lang.python/msg/ed6121fdacbe9071.
&gt; A real-world example can be found in the htmlentitydefs module, which maintains a name2codepoint dict and an inverse codepoint2name dict separately. This could instead be modeled with a single bidict: 
Yes, I was simplifying. My point is, there is a use for this data structure. 
They're all shit, but at least it's a better practice to grab a URL from some algorithm than a huge ass database.
thats fairly *ad hominem* in relation to this point. you were told a situation in which this data structure would be relevant (unless i much missed the topid, that was exactly what you asked for), and instead of accepting that as a point of consideration, you commented on how much you disliked tinyurl, which is completely irrespective of the topic. congrats on being a fairly douche-y poster.
&gt; submitted 3 hours ago You must learn patience, young Padawan. I cited TFA's real world example. Others will arrive and show you theirs.
inverting a non-bijective dictionary is somewhat meaningless. the only reason you should have to transpose a dictionary (ymmv) should be to get a mapping that is ALSO injective.
judging from the discussion ITT, i feel fairly confident that the OP is not having a hard time looking for a reason to dislike this data structure. plenty of good examples of why this is useful have been presented, but the OP remains unconvinced. i am disappoint.