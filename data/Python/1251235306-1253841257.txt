+100
&gt; That is up to Debian naturally. oh, come now, really not fair pypy isn't ready to be included full-force yet; that's the answer he wanted ;)
&gt; pypy isn't ready to be included full-force yet; that's the answer he wanted ;) It is true that PyPy is a rather monolithic hunk of everything from a Prolog interpreter to a JVM backend, and we don't completely have the packing issue sorted out.
&gt; I know of no database search system that prepares a list of which files contain text matching which regular expressions. [Google Code Search does this.](http://www.google.com/codesearch) They've (or they used to, haven't check recently) been guarding the internals very tightly; I don't think anybody knows how they're doing it. Although [previous](http://www.reddit.com/r/programming/comments/8l0ta/ask_proggit_can_a_regex_be_run_against_a_huge/) reddit [threads](http://www.reddit.com/r/programming/comments/90jf9/askproggit_are_there_any_search_engines_that/) have made intelligent guesses.
This is the only reason I'm not doing my current project in/for 3. It does not involve NumPy directly, though I have some places in mind where I might want to rub up against it under the covers. Metaphorically. 
pg8000 and pypostgresql are usable for py3K right now.
i'd like to add scipy, but you almost did; i could hear it on the tip of your tongue. actually something has been bugging me, how did it work that numpy26 came out after scipy26?
2.x will be around for some time, i'd get used to it. much changes in 3, but it isn't that much and you will be able to transition when you get there.
Mind, blown. Anyone have a speed test on this? :)
Incredibly slow.
Can we expect any kind of compatibility between CPython C based extension modules and PyPy? 
maybe if it wasn't written in python....
AHAHAHAHAHAHAHA... So clever...
Try changing `x = random.randint(1,a-1)` to `x = random.randint(1,int(a-1))` randint can't accept floats as an argument.
Who says Reddit is a terrible place to hang out? :-)
That may cause problems with the accuracy of floating point inputs (which is somewhat laughable given the limitations of IEEE 754, but we'll assume that we're running Python on a processor that magically doesn't have these problems). Specifically, with your solution, root(1.5) returns 1, which is most certainly wrong. Change line 5 from x = random.randint(1, a-1) to x = random.uniform(1, a-1) I should probably mention that if you're running this on an integer, you're still using your computer's floating point unit, and I must warn you that *this is not necessarily a good thing*, even if the code is now *mathematically* correct. If accuracy counts (beyond about 5 decimal places), use fixed decimals for calculations so that you can use the integer processor on your computer instead. Financial software generally avoids the FPU for that very reason. Lastly, if you're doing this in a Windows environment (and given that you're running one last raw_input() there at the bottom, I'd say that's a fairly safe assumption), it might be best for you to use IDLE's shell to run your program instead of the standard Windows command prompt. 
gvim + terminal with tabs bpython, git, and manage.py runserver from django
Eclipse with PyDev is what I've been sticking with so far in the OS world. I tried Komodo Edit but it crashed so often that I eventually gave up. However, if you're willing to shell out a modest amount, I still find Wing to be the best I've used to date.
I participated in one of their sprints a few years back and they seem to have a bit of a shaky grasp at times. PyPy has lot of moving parts, you can't just dive into the code and expect to understand what's going on. You want documentation, they haven't made much so far; not a surprise when you realize what a shoe-string budget they're working with. If it works (PyPy produces a usable Python implementation meaningfully faster than CPython) the documentation will come. A perfect example is this is the [Animated slides from the Python UK conference at ACCU 2004](http://psyco.sourceforge.net/doc.html). The approachable "documentation" was created after the project was a success.
In PyDev, is typing the name of the function and opening parenthesis supposed to show anything? (This is what I call "intellisense"). This isn't happening for me with the Ubuntu 8.04 version. E.g. math.sin( simply adds a closing ")" and that's it. **edit** Never mind. Typing the dot started showing something (it didn't work right away)
geany + ipython + some command-line stuff (i.e., ack)
I'd go with: s = 0.0000001 x = random.uniform(1, a) while 1: print x y = (x+a/x)/2 if -s &lt; y-x &lt; s: break x = y 
Within the parends, hit Ctrl-Space (a standard eclipse command); you'll get a list of the parameter names. It can only do this when it knows the type, however, but you can help it by adding a line like: assert isinstance(someObj, SomeType) after that, it will know the type of the object and be able to show you this information. Wing does it a little differently; it has the so-called "source assistant", which is a small side pane that shows the arguments and doc string for the current object/method/func/whatever. It also does the list you're asking about as you type. Like PyDev, however, if it can't tell the type of an object it doesn't give help, but it will also respond to the assert trick mentioned above.
What it is doing is the equivalent of: def is_prime(n): if n in (0,1): return False for i in range(2,n+1): for j in range(i+i, n+1, i): if j == n: return False return True This is a very slow algorithm for testing primes :).
IronPython + Visual Studio have a great look and feel to it, and the intellisense and debugger are cool. The only problem is it's not fully compatible with cpython, so working around all those little oddities sucks. I really enjoyed Wing, and it felt closest to the integrated and smooth feel that Visual Studio gives. I probably will buy it once I get some cash saved up. Komodo Edit is my editor of choice right now. It keeps surprising me with features. For light and quick edits, I prefer Notepad++. It starts up quickly and has enough features to be useful, but not so much that it feels like a huge event. Eric4 is really good, but it's "intellisense" works using by using custom API files, and I've only ever been able to find API files for very few libraries. This makes it feel inconsistent. SPE used to be the best, but I haven't seen any good updates from it in a long while. Most people seem to like Eclipse and PyDev, but I just can't stand it. It doesn't feel intuitive at all. None of the features are where I expect them to be, or they don't work the way I expect them to. I'm sure it works beautifully, but it doesn't work *naturally*. Same goes for Vim and Emacs. There's enough mods and scripts and addons to make them the best possible tool ever, but they don't feel natural.
It should be noted that while `^1?$|^(11+?)\1+$` is a regexp in the PCRE sense, it's *not* a regular expression in the mathematical sense. That is, the language it recognizes isn't regular. Still a cool hack, though. edit: Backslashes don't need to be escaped inside backquotes, I guess.
Everytime I work with an IDE for Python, I end up getting frustrated (usually at bad indentation handling or something like that) and falling back to Emacs. So here I am, making the same argument for emacs. :)
True, but it's a kinda neat trick to use a regex.
^Camen. 
Oh I agree, the regex is very interesting. I was just putting into a form which made it easier to understand and assess the performance.
I'd prefer Vim if it really did what I need it to do. * Can you configure Vim to navigate the backtrace from python or ipython? * Can you make it show members and arguments?
I'd put it somewhere between probably and certainly yes, but I'd have to understand what you're looking for a little better. I'm sure you already know about the [vim scripts database](http://www.vim.org/scripts/index.php), or it's possible you'd have to write an extension yourself (which could be a disadvantage or a fun opportunity depending on your free time/interest/&amp;c.).
&gt; I'd have to understand what you're looking for a little better Regarding the backtrace: In PyDev, you can click on the items in the backtrace, and it takes you to the corresponding location in the source code Regarding "intellisense": when I type a = range(10) a. or math.sin( I want to get various help, like a list methods, arguments, perhaps documentation.
There's a google tech talk by pypy people from 2007 http://www.youtube.com/watch?v=GnPmErtqPXk
&gt; If it works
[Whoa!](http://www.bpython-interpreter.org/screenshots/). Does gvim give you "intellisense" and backtrace navigation though? I would imagine the situation is the same was with Vim (discussed elsewhere in the thread).
pida with vim
You may not have long to wait. :-)
pypy is too big to summarize its implementation details in one video. If you are interested in the rpython translation, you might be interested in the official videos that you can find on the website, although they are a bit out and probably are not 100% up to date: http://codespeak.net/pypy/dist/pypy/doc/video-index.html If you are interested in the JIT, there is the google tech talk that have been already mentioned: http://www.youtube.com/watch?v=GnPmErtqPXk if you speak italian, there is also this presentation by me: http://www.viddler.com/explore/python-italia/videos/43/ Both these talks are also a bit outdated now, but the general idea is still valid. However, for more detailed information I suggest to look at the papers we wrote: http://codespeak.net/pypy/dist/pypy/doc/extradoc.html
the name is pythoncomplete, IIRC. (its a vim script)
The progress looks good but the real thing would be the ability to mix Cpython code and PyPy code -for different modules. That's would be an easy (and less risky) path to complete integration and many Project Manager would accept using PyPy as a result. 
You can add partial intellisense with omnicomplete (:help omnifunc) and http://www.vim.org/scripts/script.php?script_id=1542 Example: import os os.&lt;CTRL-X CTRL-O&gt;
Oh wow, seems bpython now finally works with multibyte characters. That caused me a ton of problems in the past due to it not picking up encodings properly. ipython still has this problem though. bpython: &gt;&gt;&gt; a = u'愛' &gt;&gt;&gt; a u'\u611b' &gt;&gt;&gt; print a 愛 ipython: In [1]: a = u'愛' In [2]: a Out[2]: u'\xe6\x84\x9b'
I love vim, been using it for many years, but I am now working on quite decent sized project in Python for work and I find Eclipse with PyDev to be much more productive than I could have accomplished with (g)vim. Especially if you set up PyDev to hook in the pylint output. No matter how many scripts you bolt onto vim, it will remain an editor, not an integrated development environment.
I was going to call you out for being a gimmick account, but 2 years is a long time to be waiting to pose as Graham. 
As far as I know, Python doesn't have a certification program...yet. I would also be interested. If you want to add *something* to your CV, try the PHP exam, I've heard it's pretty straightforward.
It's certainly not a true certification, but one's level in The Python Challenge could be construed as a psuedo-quantitative comment on one's capability in the language.
Warning : procrastination ahead http://www.pythonchallenge.com/ 
I don't have a single one of those certifications and I list many languages on my resume...
Don't add Python, add a project you successfully completed using Python.
I dunno, the first few challenges all seem to be solved with regular expressions, rather than Python. And the challenge doesn't seem to involve anything specific to Python itself.
I'm not particularly disagreeing or agreeing with you here, but could you list what exactly you are missing in (g)vim compared to PyDev?
just add your python experience to your CV, it'll be worth far more than any certification
MongoDB does this with some interesting javascript syntax, if I understand this statement correctly. One can pass a selector to the engine with something like { &lt;field&gt;: /&lt;regex/ }. Its not as fast as the regular information theory model using an inverse index query with a relevance ranking (vector space, boolean, probabilistic, etc), but it gets the job done without having to build an index. However, regular-expressions solve an entirely different problem from an ad-hoc search. More explicitly, regexs are built to look at structure, whereas ad-hoc seeks to explore the concept of "relevance" between a query and a given document. I am not entirely sure this blogger presents an interesting description of the current state of search. If one is interested in python-based IR, I suggest taking a look at the [Whoosh](http://whoosh.ca) project. The creator has taken a canonical approach to IR, pulling concepts from Lucene and other well-established search projects. The code is fairly clear, but, more importantly, better organized than its Java counterparts, making it much simpler to grasp the underlying concepts of both IR and the data structures involved.
as far as CV's go you'll get more browny action with an open source project of some sort than some fly by night certification. Couple people have already suggested putting a project on there I'll say specifically thatopen source would increase the odds of usage and thus imply that what you're wrote is in _use_ which is a lot more important than that you wrote a project privately.
PyDev on eclipse works pretty well. It's what I use, mainly because I already had experience in Eclipse. 
not really, the python challenge is more like a game not a real evaluation (certified or not)
&gt; Can we expect any kind of compatibility between CPython C based extension modules and PyPy? We don't have short term plans for that, no. However if you're code runs 10 times faster than on CPython, you may have more motivation to port it to pure python. :)
I use vim for most of my programming. What vim scripts (or even .vimrc) do people use for python stuff? Right now I don't have any python specific scripts, but would like to add some since I've been doing more serious python programming recently.
Keep going. There are challenges that involve specific python modules. While you're welcome to implement their interfaces in whichever language you like, it really is best to just do them in python. :)
I hate that particular kind of riddle game. Not only do I waste hours on it, it gives me a headache.
I love PyDev + Eclipse. It has great project management.
Probably solid directory and code structure navigation.
There's one on odesk.com... I took it just to see whether it was any good for evaluating potential contractors. Long story short: I wasn't terribly impressed, mostly because the test writers didn't seem to be aware of things like list comprehensions. It was basically a test of python 1.52 skills. Sadly, I had the highest score of all time there, at least when I took it... But perhaps no other serious python developers were aware of it.
On further investigation, lots of people seem to be tied in "1st place" for the test: http://www.odesk.com/users/?q=&amp;ac=0&amp;test=600&amp;to=yes&amp;sort=cmp_score (I'm not on the list anymore because I'm not looking for work.)
The best way to add python to your CV is to actually do python programming, and contribute to some major projects. Certification is nice, but in many cases I find it is hardly the best indicator of talent in that area.
check http://diveintopython.org and then http://showmedo.com
The fifth puzzle I think ("peak hell") requires a very specific Python module. But that aside, so what? We already know that Python cannot compute anything that cannot be computed by any universal touring machine.
&gt; Here are some ideas for improvements: &gt; * Make it do something smart to prevent or recover from pickle blowups. Love it! In all seriousness. I think its really cool. I love the concept of a really simple web framework for simple tasks. Turn a basic python program into a nifty little web app with text inputs n' such, sweet!
I like. handy for debugging methinks.
It is pretty sweet. I like how the text inputs act like asking stdin for input, with a bit of intelligence thrown in w.r.t. data types.
That would seem to be enough really. I've never seen Python included on a CV/resume because it's considered super marketable. Therefore, if it's there, it's because they have that experience and/or are sending you the message they want more of that experience. Depending on what kind of shop you run, you could view that positively or, at worst, neutrally. I've never seen it regarded as a bad thing (assuming of course that your mention of it as a candidate is for real and not just skills inflation). Almost forgot my main point - I would think Python certification is not necessary because it's not particularly in demand at this point and there is no need for differentiation with an exam because not everyone is claiming to know it. Just knowing it at all is the potential differentiator.
Yes, very cool for debugging
The first example doesn't work unless I put a docstring in the module I created which contains the helloworld method
I like his method of commenting. class ExoFunction: """DOC DOC DOC """ def __init__(self, fn, exomod): """DOC""" assert not fn.__name__.startswith("_") assert "publishing_namespace" in vars(exomod.mod) self.fn = fn self.exomod = exomod def full_name(self): """DOC""" return self.fn.__name__
Could use Py3 annotation...
From statistical point of view it's highly unlikely. From aestetical one though it would be desired. This is ugly, so why?
makes perfect sense. malkovich 
Python wouldn't require this ridiculous abuse of with or decorators, nor either feature actually, if it had decent λ-expressions (or every statement became an expression, as it they be). In fact, when by fixing one feature you suddenly no longer need several others, you know you're on the right track.
For app. development Eric4, simply because I like the PyQT integration
Expert Python Programming
You are "above beginning" but don't know how to use def? Are you sure?
You just violate [pep8](http://www.python.org/dev/peps/pep-0008/ ) recommendation. That is all. &gt;Don't use spaces around the '=' sign when used to indicate a &gt;keyword argument or a default parameter value. I am not feeling pissed off.
O'Reilly's Learning Python.
start here: http://diveintopython.org/
Not at all.
I found this to be true also. Is scratch depending on a &gt; python 2.5.2 feature?
Or here: http://diveintopython3.org/
pythonchallenge.com
[Start here](http://docs.python.org/tutorial/index.html)
It's really a gaming class that uses Python, but check out http://synapse.cs.iupui.edu/Mediasite/Catalog/Front.aspx?cid=6d8a3243-451c-460c-8c15-fff771bc51f5 The first ten videos are a reasonably gentle introduction to programming in Python. They assume no previous programming experience. After that, the course goes more into gaming (which is fun, but maybe not where you wanted to go.) The course is taught using my book - Game Programming - the L Line. http://www.aharrisbooks.net/pythonGame/ You don't really need the book - you can use the videos and the notes online to get most of the content. Feel free to leave a question on my forum or show me your code if you have any questions. http://www.aharrisbooks.net
I just threw a chair! 
Nah, it just assumes there are docstrings in each module when it tests to see if there are any docstrings (!). Either put in a docstring as dgrant suggests, or fix the offending line.
 song = map(lambda *x: ' '.join(x), ['Work it', 'Make it', 'Do it', 'Makes us'], ['Harder', 'Better', 'Faster', 'Stronger'])]
It wouldn't be all that hard to use a single sqlite database (python &gt;2.5) to hold this stuff. Once you did that, it wouldn't blow up under these condition - Sqlite gets the locking right. 
Dive into Python is great if you are already a programmer, and just need to learn the Python language. If you are new to programming, I'd like to plug my own free, Creative Commons-licensed book, Invent Your Own Computer Games with Python. http://pythonbook.coffeeghost.net
Is there any indication that PyPy will run normal python code 10 times faster than CPython? Say psyco achieved 1.5-2 speedup on most real world cpu-bound apps (yes there were exceptions where psyco really shined, but average speedups were much lower). 
I learned Python from video lectures and wrote about it here: http://www.catonmat.net/blog/learning-python-programming-language-through-video-lectures/
Spaces around = in kwargs are ugly. Everywhere else I accept space around operators, not here though. It seems to be a waste of good... space. ;) (This is my 16th full hour in work, I'm unable to put a sentence together. Need. Sleep. Nao.)
Well you can't say that he forgot to write the docs.
This. First time I've seen Pida mentioned here on Reddit. I highly recommend it to everyone, although they haven't had a new release in a while... :(
I guess this is another case of the wrong answer getting the most upvotes. 
I was under the impression `L1 += [n]` would be equivalent to `L1 = L1 + [n]`. Seems not: &gt;&gt;&gt; L2 = L3 = [] &gt;&gt;&gt; L2 += ["a"] &gt;&gt;&gt; L3 ['a'] &gt;&gt;&gt; L4 = L5 = [] &gt;&gt;&gt; L4 = L4 + ['b'] &gt;&gt;&gt; L5 []
+= was introduced to the language precisely because x += y is not the same as x = x + y. += can be much more efficient, because it doesn't have to create a new instance, just like your example shows.
i released 0.6beta3 just a few days ago
Rrg, I really want Django to be ready... we're starting a totally new site in Django this Fall, and it's not only first Django project but my first major Python work as well. I'd like to be able to just start in Python 3 so I don't have to unlearn and relearn anything!
CherryPy now supports Python 3 :)
Why is that a wrong answer? The guy specifically asked for one-element appends.
Going from 2.6.x to 3.1.x isn't such a __huge__ leap, but it is somewhat significant. Still, I don't think you would have that much trouble getting into python 3.1.x. You wouldn't be 'relearning' everything. How Django handles python 3.1.x is yet to be seen, but I think it'll be okay.
+= is an "in-place" operator. For mutable types it is supposed to change the value in place for performance reasons. For immutable ones it is equivalent to addition, but short integers are cached in cpython, so id(3) is always the same, for example.
That was indeed because of the limitations of the django ORM. sqlalchemy is much more flexible and has decent support for things like inheritance and data partitioning. 
Zope has been doing something (but a bit more advanced) with its ZODB for over a decade. Underneath the ZODB somewhere there's still pickle. 
[Free online version](http://www.nltk.org/book) of the book.
I'm a masters students researching nlp and I found this book (with the nltk package) invaluable. However, I disagree with the author about it not being a good intro for nlp newbies. In my opinion, seeing what you can do with nlp techniques as demonstrated by the authors is a much better intro to nlp that reading a dry and equation-y book on various algorithms and things.... I know there's a free version but if you're in the nlp field, I strongly suggest to support the hard work of the authors by buying it!
This is gonna sound like a long shot, but I assure you, [This](http://www.youtube.com/watch?v=evZmpsl3jI0) will be interesting for you.
maybe line 216: chang "if len(self.mod.__doc__) &gt; 0:" to "if self.mod.__doc__:" [pastebin!](http://pastebin.com/f4df3ee27) scratch.py is so cooooooool, and don't know how to express my angry to reddit's "formatting help" with my pooooor broken english.
why don't you tell us how this went for you, since this is still on the front page of the Python subreddit? I'm curious.
"[An application] may not itself install or launch other executable code by any means, including without limitation through the use of a plug-in architecture, calling other frameworks, other APIs or otherwise. No interpreted code may be downloaded and used in an Application except for code that is interpreted and run by Apple's Published APIs and built-in interpreter(s)," -- iPhone SDK Agreement
Compile from source.
And feedback compiles to macports.
Pfft. Terminal &gt; vim. 
hah, just found that out this morning. i was sad.
Macports never worked for me on 10.5 (well, installs did work until I restarted the computer). The interesting thing for me would be if all ports or just python related ones don't work. If it's the latter then it might be something related to Python.
I managed to get it to build with the instructions from [here](http://trac.macports.org/ticket/20284). Essentially what you do is this: sudo port install zlib +universal sudo port install python26 +universal When staging Python the install crash with an error about trying to import Nav in EasyDialogs.py To fix this: cd /opt/local/var/macports/build/_opt_local_var_macports_sources_rsync.macports.org_release_ports_lang_python26/work/Python-2.6.2/Lib/plat-mac/ Comment out the "import Nav" line in EasyDialogs.py and do: sudo port install python26 That did it for me.
&gt; Macports never worked for me on 10.5 (well, installs did work until I restarted the computer). Never had any issue (apart from a few broken builds from time to time) &gt; The interesting thing for me would be if all ports or just python related ones don't work. Not only Python, but not general breakage either. [The project has a page listing ports whose installation is or isn't functional](http://trac.macports.org/wiki/snc/snowleopard). Problems come either from Python itself or from the port (as far as the project is concerned).
Python is extremely trivial to compile from source on OS X (no dependancies). With the Developer Tools installed, get the source from [python.org](http://www.python.org/download/), extract it, in a Terminal cd to the folder and run.. ./configure --prefix=/usr/local/python/2.6.1 &amp;&amp; make &amp;&amp; sudo make install ..finally add `/usr/local/python/2.6.1/bin` to your `$PATH` by appending.. export PATH=$PATH:/usr/local/python/2.6.1/bin ..to `~/.profile` It's less typing if you just do `./configure &amp;&amp; make &amp;&amp; install`, but using `--prefix` means it's a case of deleting a single folder to uninstall (and it's tidier, and impossible to mess up any system files)
I'm very experienced with python but was wanting an intro to nltk and nlp. After looking at the first chapter, I found myself wondering why things like "concatenation" were being defined and explained. This review seems to suggest that the rest of the book is like this...anyone here that's an advanced python user actually found this book useful?
Much too verbose compared to make syntax.
http://stackoverflow.com/questions/1338095/can-i-write-python-applications-using-pyobjc-that-target-non-jailbroken-iphones
[OT] so it looks like the SL update may have nuked the UNIX dev tools that XCode installs. I really ONLY want the UNIX dev tools (since I do all my builds through MacPorts.) is there a way to install without the "Essentials" which is almost 2GB of bloaty crap in /Developer? should I just go rm -rf it when its done? [edit] everything I've tried building (irssi, nmap) have complained about not having GLIB :(
Macports worked fine for me on 10.5 (though I only had a couple of things installed), but I couldn't make it work after the upgrade - `sudo port upgrade --force installed` failed, so I just `rm -rf`'d /opt and started again. Works fine now, but I've only installed texlive.
&gt;This, in turn, means you can't install e.g. mercurial (port depends on python26) or bazaar (port depends on python25) through Macports. You can edit the port files for those and remove the dependencies on python25 or python26 as needed. When it starts working again, re-edit the port files. That's what I did for WINE, because I had everything installed in fink expect WINE, which is horribly out of date in the fink repository.
http://bugs.python.org/issue6802
The real question is what's the difference between `extend` and `+=`.
Seems the problem is almost certainly PEBKAC then.
Then you don't get readline support. Building it with readline is tricky as shit IIRC
No problem 
There are some issues with the $PATH that Mac ports install to not being added to your $PATH, this specifically happens often if you don't use the default shell. PATH=/opt/local/bin:/opt/local/sbin:$PATH
Maybe if you concentrated?
Haven't actually used it yet, although I'll give it a whirl soon just for you. 
[Spyder](http://code.google.com/p/spyderlib/), Purely because of its tight intergration with Python, and the debugging/widget tools. Still in beta but shaping up nicely.
Downvotes for insulting myself? What a crazy world we live in...
Ahhh, that sounds very likely what happened to me.
what about taglist.vim
I would say a bit not much... doit is different from make. I wrote a [post](http://schettino72.wordpress.com/2009/08/31/a-make-example-using-doit/) with some examples to show how you could translate rules from make to doit. If you have a concrete example it would be nice to post it. Anyway, thanks for the feedback.
It's as simple as installing readline first, then compiling python. If you want readline in the system python, just check out: [this link](http://blog.zacharyvoase.com/post/174280299/getting-a-proper-readline-module-for-python-on-snow).
Is there anybody who could build html from the source?
It took me a while to understand the point. But I think I got it. Python 3 adoption is slow because it breaks a lot of things and there are still few python 3 compatible modules. 2to3 sorta works sometime but still requires a lot of fiddling and messing around. Making it a pita to do anything productive with python 3. There are few py3 module because module developers users are still "stuck" with py2 so they needs to produce py2 code or alienate the user base. 3to2 may very well help in this regards, allowing module developers to start coding primarily in py3, thus increasing the availability of py3 module and the attractiveness of py3 while still being able to generate py2 code (ugly one most likely). So yeah. upvote. :)
My thought process as well :)
Your post show that make solutions are about half the lines of do it solutions, and look much more clean - you don't see any [", in the makefiles. Doit files contains too much logic - all those for loops and conditional code, while the makefile contains only rules and dependencies, and some shell commands. Python is a good language for most things, but its syntax is not better then special syntax optimized for specific task. Last, you don't want to run "doit filename". You want to run "doit", and doit should load your dofile automatically from the current directory. BTW, I did similar (but much simpler) system in Python, which was based on functions for target, and decorators for registering targets and defining dependencies.
Try having some original thoughts, copy cat!
I didn't think it was that unclear - I guess I'll go re-read it and edit :|
Don't worry, I'm just a bit slow. To be honest I had never heard of the project and when I clicked the link I expected a rant on how python 3 blows for whatever reason and someone switched from 3 to 2. Then I saw the dog and I wondered if I was about to be rickrolled or bel aired... :) &gt; - good, wanted, needed: esp. by module authors Anyway, **awesome** job, I hope it catches up. I just love python 3 but I still pick 2.6 over it for convenience.
VISIBLE "LOL"
Well, I read about this on your blog and I was scratching my head about why someone would want this. The parent comment definitely cleared that up for me, so yes, I think some people may find it unclear :)
 Authors of LOLPython nonsense: Congrats on dedicating your time and effort to create something completely useless
Well, part of the reason I want this to work out so badly is that I *want* to use Python 3 full time, but can't. I'm happy with 2.6 and that's what I have to use in the day job because of external dependencies. 
 (LET-ME-SEE (FIBBING n) (GIMME-LIST-WITH-STUFF 1 1 (LOL-THE-OTHER-WAY (CAN-I-HAZ LOL-ITER ((f-2 1) (f-1 1) (r NOTHIN)) (CAN-I-HAZ ((f (SUM f-2 f-1))) (IN-CASE (BIG-LIKE f n) r (LOL-ITER f-1 f (TOGETHER f r)))))))) (EVERYONEZ (LAMDA (I) (VISIBLE I) (NOOBLINE)) (FIBBING 10)) Hmm... not nearly as fun as it should be.
as someone said on he blog "dude, you forgot the benchmarks!" :)
Not cute. Not cuddly.
Netbeans. I've bounced between a few, and I'm still looking but the python support in netbeans is coming along nicely and it is quickly becoming my default environment for all kinds of work as it now supports php, c/c++, javascript, groovy, ruby, python and even java. oh - and I like that it is pretty much the same on Linux or Windows, so I can move between the two platforms without a big jarring change.
Thanks - looks interesting.
I did a lolcano with lolpython. It only works with a terminal of 80x40 and you need to have the cursor in the last line before executing it. I guess I could have corrected that but I was sick of lolcode at that point. [Enjoy](http://quegrande.org/foro/download/file.php?id=1631)
Hope you make some cache dude, but I don't think /r/python is a good place to be hoofing your wares. :)
Seems like Lisp-likes would lend themselves more to Goatse.
 print &gt;&gt;_lol_sys.stderr, 'HAI WORLD!' Ew. That's deprecated in python 3, you know. Edit: wait, what? N = LETTERZ . get ( C , 0 ) + 1 
Please don't use pybench, it's a really terrible benchmark.
Upvoted because this is a good example for PLY.
One of the biggest issues with PyBench is it's inconsistent nature, I've heard of swings of up to 25% with no discernible cause.
Trolltech Qt.
I think it's actually the opposite of obsolete, but I don't know the word for it. As in obsolete is something that still works but is no longer desired. Whereas wxPython is desired, but no longer works on the latest Mac OS X. That being said... backing up files and getting ready to upgrade tonight.
PyQt/PySide
I'm quite fond of PyGTK, and the native GTK effors are coming along nicely on OS X: http://live.gnome.org/GTK%2B/OSX
They should have ported wxPython to Cocoa when they could have. Note how I carefully used the word "could", so in case it was never technically possible then they should have never done it.
Uh, how?
Um... QT.
Well, there's always Tkinter, even if it is as ugly as fuck.
Upvote for covering all the bases.
Broken?
About Qt, does Nokia really cares for anything else than C++ for Qt development? 
Given the PySide announcement I guess they do. On the other hand, orphaning QtJambi wasn't too nice — QtJambi is stuck in 32 bit land on OS X.
Upvote for explaining your upvote
It might be nice to see an argument for *why* this is nicer.
I've actually found Python Regex's to be really nice, you'll need to explain what about this is better than the re module which to my mind is pretty top notch.
I'm sure half the perl/ruby developers thought about writing something like this when they learned python. But they still have to learn the pythonic way to understand existing code. And as soon as you start sharing this code, look out.
while we can hold out hopes for PySide, it is not cross-platform yet. &gt; Microsoft Windows &gt; &gt; Unfortunately, PySide has not quite yet been ported to Windows. Stay tuned! &gt; &gt; Mac OS X &gt; &gt; Unfortunately, PySide has not quite yet been ported to Mac OS X. Stay tuned! http://www.pyside.org/downloads/ [edited to clarify only relevant to PySide]
its less readable and less explainable, not more nice at all
According to a recent post to the wxPython group Cocoa support is coming along nicely: http://groups.google.com/group/wxpython-users/browse_thread/thread/d422356b11a0efe6
Upvoted for... Oh fuck it! I never wanted to be part of this thread... I always wanted to be ... a lumberjack!
That unfortunately requires a pretty large download for Windows users and as far as I know no longer works for Linux....
Why would it not work? It should automatically fire up in 32-bit compatibility mode...?
No longer works for Linux? Say what?
I'm not sure how wxPython interfaces with wxWidgets exactly, but I do know that the current snapshot of wxWidgets builds using a sort of Cocoa/Carbon mix and appears to run fine, at least for the things I've had to port over after switching to SL.
If it were "obsolete" then you would use whatever has replaced it making it "obsolete." Do you ask how you are going to listen to your music now that vinyl LPs are obsolete? I think the word you are looking for is "broken."
Upvoted for leaping from tree to tree with your best gal at your side.
Could you post your config file?
Probably thought QT was QuickTime. Qt is usually written Qt ... Lowercase "t".
Downvotes to all of you for wasting screen space!
I don't think that the problem is wxPython, but wxWidgets itself. Qt made the port from Carbon to Cocoa but wx didn't if I recall correctly.
Ahhh. I bet you are right.
Only somewhat related, but TIL that MS UK asked wxWindows nicely to stop using "Windows" in the name and they agreed.
They also paid wxWindows for their trouble which was nice of them.
Nokia Qt.
Not really obsolete with Snow Leopard. Just use python2.5 bundled for backwards compatibility. The question is whether it is "future-proof". Also, it will still bundle as py2dmg, and noone's the wiser. Whether they will include a framework build for 10.7 is another matter, but that's a couple years down the road.
Not really nice, sorry. I really like `re` to be honest.
PyQt is cross-platform. And I don't think PySide is meant to be part of some combo with PyQt.
Considering that's a gcc3 option that was phased out in gcc 4.3 on Darwin, I would question why it's in the build configuration. But according to http://gcc.gnu.org/bugzilla/show_bug.cgi?id=35961 you're only seeing that particular error because of the real error, farther down regarding the architecture type. 
These instructions also worked for me.
I've started building an app based on the knowledge I picked up from just the first 3 chapters of this book. I think the book is very well paced, and the NLTK itself is a very good library. The review's fair, and credit is given to the quality of the material. However, I disagree with the opening. The reviewer lists three types of readers, and suggests that the book will only be of use to the first type (Natural language processing (NLP) researchers and students who want a learn a solid programming tool to help them with their work). I disagree totally, as I'd consider myself to be the third type of reader listed (Newbies in both Python and NLP who just think the topic sounds cool), and I've found the book to be worthwhile. In fact, it was just what I wanted: a focus for learning Python while learning something new and interesting at the same time.
David Beazley, known for his excellent writing, has some courses in his website: http://www.dabeaz.com/python.html
You shouldn't be using Python strings as buffers; use `ctypes`'s `create_string_buffer()` and `create_unicode_buffer()` instead. Also, it's better to specify the function [return](http://docs.python.org/library/ctypes.html#return-types) and [argument](http://docs.python.org/library/ctypes.html#specifying-the-required-argument-types-function-prototypes) types so that `ctypes` can do some type checking and [automatic conversions](http://docs.python.org/library/ctypes.html#type-conversions).
It's shorter and possibly less confusing? Also show_match looks pretty sweet. (note: i'm not the author, nor have I used it yet)
I don't think that word means what you think it means.
Exactly - it is the result of the two parties not being able to find a way to work together.
But why would we discuss QuickTime in a thread about a python GUI toolkit?
Geany works wonders.
Outside my job description. ;-)
Have you ever heard about csv.DictReader? 
This new generation of Python coders does not understand what ,,documentation'' is.
[all in one page](http://www.devx.com/opensource/Article/42659/1954?pf=true)
I had to edit /Library/Frameworks/Python.framework/Versions/Current/lib/python2.6/config/Makefile to have the appropriate build settings after snow leopard was installed. then again I think I may have edited this file a long time ago which perhaps was part of the problem...
But PySide is not finished yet, and it's not clear when it will be. So it might not be suitable to use in a serious project yet. 
nice. - thanks for pointing this out.
I just got my copy yesterday - I'm looking forward to reading it. The whales are nice.
Already downloaded and installed. Simply the best IDE plugin for Python development. Had used the free version for ages and now that all of it's free it's just amazing. Completely recommended for anyone doing Python.
I'm going to give it a spin - though Python support in my preferred IDE - netbeans - is coming along rather nicely as well. Always good to have options.
Holy shit, this is the best news I've had in ages. I love you all. EDIT: I installed it and immediately switched away from Komodo and NetBeans. My Python coding will never be the same...
How do you compare them both? For me, NetBeans' Python support comes out ahead a little.
came here to say almost the same thing, this is wonderful news
I just downloaded PyDev for the first time so I can't compare. I like netbeans though I've found that the code completion is spotty when I move away from standard stuff. Eclipse and PyDev would really have to blow netbeans out of the water though for me to move. I find a lot of value in being able to use one IDE for all the languages I work with. I know Eclipse can be that same tool - but I know netbeans better and tend to prefer it to this point. But I still give other products a look every so often to make sure I don't miss anything that would make me want to move to another setup.
Great, I buy something and then they release it for free :(
Maintainer of pydev sets it pretty well: &gt;First, let me say that we truly appreciated the support you've given to Pydev while buying a Pydev Extensions license -- those payments were what kept Pydev going on for a long time, and actually enabled Pydev to get to the point it is now... When I started developing Pydev, it relied only on donations, but unfortunately, it's much easier to get money from something closed source than it's from something open source, so, it got to a point where going closed source was the only way to go. &gt;Now, with the Aptana acquisition, and other sources of revenue, Pydev is now able to go to its original plan, which is being available for anyone... And existing users can treat that in 2 ways, as a loss or as a gain -- although in my view it's a bit unfair treating it as a loss, as it's mostly just a perceived loss, because you actually still have what you paid for -- and more because you now have source code access and will be able to use it for more than 1 year and will still have proper support, and as I said previously, that was the money that got it to be open source again. If you think about dollas being wasted just think of your taxdollars!!! :p
Snow Leopard upgraded the Darwin version from 9 to 10, confusing GCC. [This was reported earlier by Alan Quatermain](http://alanquatermain.net/post/124150829/iphone-2-x-sdks-on-snow-leopard), who fixed it by creating a symlink. Is it possible that that solution applies here as well?
Eclipse+Pydev is what I use all the time. This indeed is great news.
A software system containing one line of code, except the administration stuff. docutils.core.publish_cmdline(writer_name=writer, description=description) writer coming from sys.argv defaulting to html, description is a module global.
Thanks for the comment. I hinted at the problem of using a string as buffer. My point here was to make a minimal example of how easy it is to get *something* working with ctypes. I'll follow up with 'proper' usage in another post. I expect that will be twice as long...
someone made a comment about appengine working towards addressing all of these problems, and in a way i suppose that is largely true. but the idea that in the future a large majority of web apps will be hosted on pay-per-use clouds doesn't sit particularly well with me for some reason.
I've used both, and NetBeans is rather a subset of PyDev. It does most of what PyDev does (plus I like the visual renaming of variables), but PyDev does more things better. I'm sure the support of NetBeans will evolve, but right now there's nothing NetBeans does that PyDev doesn't (plus PyDev has no problems with Django where NetBeans messed up the imports a bit).
There is at least one open source implementation of the appengine system: http://code.google.com/p/appscale/ The programming model of appengine isn't particularly proprietary, so if it's a good model it can be copied.
It only claims to be a script too. Probably just some command-line glue. And it was released back in '06. Not sure why this just showed up. I'll note that once you start using a dependency management system along with PyPI it becomes a lot easier to distribute small bits of code separately. Stuff you might otherwise just plug in a recipe or make part of a bigger thing become installable and independently reusable. Whether this particular bit is useful, I don't know, though. 
Snakes on the motherfucking web.
Because it's bollocks, perhaps?
Unsubscribe from the python subreddit if you don't want to read about python, tard.
Fuck PHP in its ugly, nasty, messy ass. It uses far too many idioms and conventions from the likes of C/C++, and that's *not* how you should be coding for the web. I don't care what language takes it place, but it needs to go. 
parseopt? *edit:*Damn my being too lazy to check which way around it goes. It's a useful lib, though.
Nobody's saying that, and I hardly think that using python for web development is that ridiculous of a prospect.
optparse There's nothing really wrong with it either from what I can tell and it's in the standard library. I've only actually used it for a fairly small program though, with only a couple of options.
optparse feels too much like the getopt from libc. pyopt seems more pythonic, but I have one misgiving about it -- instead of using a decorator to indicate the function(s) to call, these functions should be passed to parse_cmds.
http://pypi.python.org/pypi/opster/
You call @CamelCasedDecorators pythonic? nowai
 def possy(archer:str, boulder:float, magic:int=42): I did not know we can specify type these days... 
Yeah, it's for 3, and the compiler discards it, so it's like a penis. It's great when someone knows what to do with it, but mostly it's for your own enjoyment.
* [Werkzeug](http://werkzeug.pocoo.org/) screencast - [how to build a wiki in 30 minutes](http://werkzeug.pocoo.org/wiki30/) * The [Django tutorial](http://docs.djangoproject.com/en/dev/intro/tutorial01/#intro-tutorial01)
argparse is the kiddy for command line handling.
CamelCase for classes are pythonic (see pep-8). A class is a callable that can be used as decorator. The no-pythonic stuff is CamelCasedFunctions ( http://code.google.com/p/pyopt/source/browse/pyopt.py#62 ).
It sounds like your interested in getting into a web framework. There are a couple shining stars, web2py, cherrypy, django, plone, etc. After trying them all myself, the best all around framework with the best documentation and community is Django. As a Django developer, I'm biased, but come take a look.
Could you give us some more info about your project? Until then, may I second the [Django](http://docs.djangoproject.com/en/dev/intro/tutorial01/) suggestion.
There's a book by Apress called *The Definitive Guide to Django*. Just walked through it. Very good for your first project. Edit: http://www.apress.com/book/view/1590597257
If you really want to do strict type checking on your function arguments, you can always use a construct a la: def funct(arg): if type(arg) != type(''): raise Exception("Function argument should be a string") **Edit**: child comments are right. Do **not** do it this way. Thanks for learning something new, Python subreddit :)
Yay runtime typechecking!
Of course it'll always be runtime type checking. This would have also been the case with the specifying of the type in the arguments list.
google's appserver is decently documented
Yeah, but I was talking about compiler caring vs not, not about ways to do type checking :P
This doesn't seem all that useful, since it does nothing for flags. I typically do this: def main(prog, arg1, arg2=default): """Documentation here.""" ... if __name__ == "__main__": sys.exit(main(*sys.argv)) On error, the user can just run 'pydoc' to get the help message. This all seems much more _pythonic_ to me.
*argparse* will be part of the standard soon. It's much more capable -- and flexible -- than *optparse*.
The django book offers a good walk-through: http://www.djangobook.com/
Huh, that's actually pretty sweet! Very Pythonic, well done!
Plone isn't a web framework, it's a CMS. Zope (which Plone is built on) is a web framework, but I wouldn't recommend starting a new project in it. It's too tightly coupled and has a steep learning curve. Django is a lot less of a closed box. The quality of the framework is pretty high, and it's not hard to find out what's going on behind the curtain and (when necessary) to override it.
I would try very hard *not* to do that. 
I guess it's also good for documentation purposes. And perhaps some the Python versions on the JVM or .NET runtime may be able to use this info? Looks like it could also work well with say, ctypes or Cython. Some day.
Very true, I expect some documentation generators and compilers will have some very interesting features with this addition...
[Commandlineapp](http://www.doughellmann.com/projects/CommandLineApp/) is pretty sweet, I've used it for a couple of projects.
Nice, but not good enough. You cannot specify command line arguments in single line. You need much more data for each argument: * Default value * Type e.g. "string" or "int" * Help string * Option name - it is hard to work with only positional arguments * You want to support both short and long options * How to convert a value from string to the real type. For example, when you work with the logging module, the user may like to specify a "debug" log level, while the logging module specify debug as logging.DEBUG, which 10. * How do you validate input? There is an optparse module that let you handle all this. Learn to use it before reinventing the wheel.
For pro website dev in python, django is the way to go. I'd suggest reading the book "Learning Website Development with Django" (packt publishing) wich definitely got me quickstarted when I begun learning. Otherwise, [djangobook](http://www.djangobook.com/) always helps.
You can get the [web2py book here](http://www.web2py.com/examples/default/docs).
You might like the [Grok tutorial](http://grok.zope.org/doc/current/tutorial.html)
Zope these days is a collection of (more or less related) web frameworks that surround the Zope Toolkit, which is a collection of Python libraries, some more frameworky and others more reusable. There's Zope 2, which has a very easy early learning curve if you use the web UI, but then you hit a brick wall of a learning curve. There's Zope 2 + Zope Toolkit, but that gets too complex, mixing legacy with more recent stuff. The Zope Toolkit can also be used independently. Traditionally that's done in the form of Zope 3. This is loosely coupled (probably more loosely coupled than any other Python web framework), but somewhat difficult to learn. Grok is a project I'm involved in to make this easier; I'd say Grok is the easiest entry point into the Zope Toolkit. Related to Zope and reusing some of its technologies and ideas is bfg from the repoze project. 
Don't be so negative. If you are using this for one-off scripts, it's pretty reasonable. Doing the whole optparse dance can be kind of tedious for a small script. And optparse doesn't even handle the positional arguments very well, you have to do that mostly manually.
Thanks for the feedback. I'm aware of and have used optparse before, but it feels like a little too much work when you're doing something small/simple. * Default values don't seem to be displayed inline by most Linux applications, and I was trying to say consistent with that. * Ditto on argument types. Most of the time, they seem rather self-evident. * I'm thinking about adding help strings (which the user include the type in if so desired) through function annotations, but once you have sufficient complexity that you feel you *need* to display all of that information to the user I agree that you would probably want to use `optparse` instead. * I'd rather not have my arguments automatically converted to different types. I often have parameters whose values can be set either with numbers or string constants, which I believe requires somewhat more configuration in optparse. It's not that much of a burden to manually write `a = int(a)`, and if you're doing something more complex like `a = a_consts[a] if a in a_consts else int(a)` the benefits of using `optparse` seem significantly reduced. * I agree that positional arguments can be a handicap, but I think that how much of one they are also scales with the complexity of your program, something I did not intend this to deal with.
That's a terrible system. For one thing, you have to bust your ass to get `--h` or `--help` to work. 
Not bad, but I still prefer optparse. It might just be me, but 'Small' scripts always tend to grow into something that suddenly needs --debug, --version, etc switches. A suggestion though: perhaps it's a good idea to not use "\_\_main__" as a function name. In the future it might clash with some builtin. Not entirely sure, but I think the python documentation discourages custom definitions like that.
If the code is bundled with the app, then it shouldn't violate this clause. Also: the writer of this blog is one of the main creators of apple-unauthorized iPhone apps so I don't think he cares too much about the Apple T&amp;Cs. ;)
You are entirely right, that slipped my mind while doing this. Thank you for the reminder, I'll fix it right away.
You might want to try Pylons's quick wiki tutorial http://pylonshq.com/docs/en/0.9.7/tutorials/quickwiki_tutorial/ Pylons is a great framework for building a web app on the top of a database, using SQLALchemy.
&gt; Writing a domain specific language DSL Aw, I forgot my personal identification number PIN again!
What is wrong with using a list of dictionaries for this? It wouldn't be limited to Python 2.6 (or require a third party named tuple function in earlier versions) &gt;&gt;&gt; rec = {} &gt;&gt;&gt; rec['title'] = 'Records in Python' &gt;&gt;&gt; rec['author'] = 'M. Simionato' &gt;&gt;&gt; rec {'author': 'test'; 'title': 'yay'} &gt;&gt;&gt; rec['author'] 'M. Simionato' (That example is using Python 0.9.1...)
1. Don't write your own HTTP Server. You'll inevitably get something terribly wrong and suffer for it. If you want to use an HTTP server interfaced to Python, use Apache with mod_wsgi. Trust me, you'll be happier in the long run. 2. If you must do this, then you should understand what virtual hosting is. It's essentially your response behavior switching on the value of the Host HTTP header. You probably want some sort of hash that registers all your virtual hosts (and a default vhost!!) as its keys and returns a DOPOST / DOGET tuple (or hash). You shouldn't need to dedicate a specific thread to every given vhost or anything silly like that. 3. Don't use threads in Python. The GIL will almost certainly make you regret it. Use the multiprocessing module, you'll be glad you spent the effort. 4. Listen on IP address 0.0.0.0 -- you won't need to make the call to gethostname and you'll listen on all available IP addresses. 
I'd never heard of the multiprocessing module before - and it looks great. I'm sure I'd have heard of it somewhere and sometime, but since I have the opportunity to say thank you, I'll take it. Thanks! :)
Thanks for the correction, I edited my comment to not recommend the mentioned method :)
Workaround for jinja: install without the speedups.
http://mtrichardson.com/2009/09/fixing-jinja2-and-pycrypto-and-probably-others-on-snow-leopard/ - thanks #pocoo for solving this.
$ python -m SimpleHTTPServer
Nothing. Though you might like the [speed increase](http://stackoverflow.com/questions/1336791/dictionary-vs-object-which-is-more-efficient-and-why#answer-1336890).
,,Let's change language syntax, because I got it wrong 'cause of my assumptions based upon usage of other languages.'' Well this approach to language development was already taken in PHP . No thanks.
Ability to use dot notation is another bonus.
from the docs * Trying to close the usability gap with Perl/Ruby. _R() is replacement for not having regex literal syntax builtin to the language. _S() adds convenient methods, conforming to our conventions, that the string class doesn't have. * I always forget re.search/match()'s argument order. Using either _R().match() or _S().match() is completely unambiguous. * Never use re.match(), always re.search(). What good is the former if you can use a caret? Having both only causes confusion. * Specify flags via a string of lowercase characters -- like open() -- but with the standard regex flags from Perl/Ruby/etc. * Python doesn't have a do-only-one-substitution operation -- in Awk/Perl/Ruby terms, it has gsub() but not sub() -- so make naming clearer. * Match objects have @property accessors like modern Python classes 
a barrel of otters and some hand lotion
Thank You for the suggestions. Unfortunately, I can't use Apache - writing this server is my homework, so I must create something simple in Python. I didn't knew about 0.0.0.0 - I will listen on this address. 
I might be slow this morning but how is it "Add operand" unsupported for &lt;int&gt; and &lt;int&gt;?? shouldn't the problem be between &lt;int&gt; and &lt;str&gt;?
P.S.: IPython seems to agree ---------------------------------------------- In [1]: def f(x,y): ...: return x+y ...: In [2]: f(3,4) Out[2]: 7 In [3]: f(3,'a') --------------------------------------------------------------------------- TypeError Traceback (most recent call last) \isb\&lt;ipython console&gt; in &lt;module&gt;() \isb\&lt;ipython console&gt; in f(x, y) TypeError: unsupported operand type(s) for +: 'int' and 'str' 
Well, the checker also agrees. I guess it's a mistake in the web only ------------------ In [33]: %run tchecker test.py loading: 'test.py' as 'test' modules not found: _symtable, _weakref, org, types.ClassType, types.CodeType, types.FunctionType, types.MethodType processing: 109309 108 processing: 109309 2 processing: 109309 7 processing: 109309 2 processing: 109309 1 processing: 109309 1 processing: 109309 2 processing: 109313 7 processing: 109313 1 processing: 109313 2 processing: 109313 2 total files=56, lines=16452 in 0.03sec === test === [test] ### test.py(1) # called at test.py(5) # called at test.py(4) def f(x=&lt;int&gt;, y=&lt;int&gt;|&lt;str&gt;): return &lt;int&gt; raises &lt;TypeError: not supported operand Add(&lt;int&gt;, &lt;str&gt;)&gt; at test.py(2) 
Oh, I don't, I hear they ask for your social security number SSN to use those...
Is there a list somewhere of what new features this brings to pydev? I can't seem to find an old list of pydev extension features anymore.
This would make the world a better place.
That seems.. convoluted. Perhaps a [WMD Editor](http://wmd-editor.com/) type thing could be made for rST? There's a [de-minified fork](http://github.com/derobins/wmd/tree/master) of WMD which could be a good starting point.. although it might be easier starting fresh, as WMD could use some structural changes, such as to allow multiple instances on one page
Upvoted, because I am your fan ;)
http://wiki.python.org/moin/CgiScripts and http://www.rmunn.com/sqlalchemy-tutorial/tutorial.html
I wouldn't worry about pickle when getpass keeps the unencrypted password in core. 
Pickle isn't meant to be "secure". It's a serialization format. The fact that you can alter it to "make it do whatever you want" is sort of obvious. The API even says "Never unpickle data received from an untrusted or unauthenticated source." By the same argument SQL is insecure, as are Python and Ruby, if you execute queries/code from untrusted sources. The "Safer Alternatives" aren't any better. You can still do evil things if you unserialize from untrusted JSON. 
Everyone knows pickle is insecure, hence the article uses the word "Why" in it's headline. Its not a given that every serialization format is insecure, and the actual method of executing arbitrary code used in this article IMO is not obvious at all unless you understand the inner workings of pickle, which is the point of the article.
Who are you arguing with?
Yeah but pickle is sooo easy and fun to use. :( Is there a way to determine if any arbitrary file is pickled? For example, say we want to convert a user's files to json. We'd need to know if it is in pickle or json format first.
So....what you're saying is, if I use an insecure object serialization process I may find myself in a real pickle? 
For a more secure alternative, give http://home.gna.org/oomadness/en/cerealizer/index.html a try. We've had very good experience with it.
All the idiots who think this article is in fact noteworthy, clueful or elucidating. Or think that JSON will save you.
Really, cuz it looks like you're arguing with yourself.
Can you point me to an article about what the dangers are when unserializing JSON?
Gaa! Why mess-up a nice, fresh clean Snow Leopard install with a bunch of install commands run as root? Installing with sudo is bad practice!
To access db2 from Python you can also use [pyodbc](http://mac.softpedia.com/get/Development/Libraries/pyodbc.shtml). That is what web2py uses to interface DB2 on every OS, including Mac.
As far as I understand it, it is safe to unserialize from untrusted JSON. It's also safe to persist the resulting JSON unserialized objects using pickle. And not safe to unserialize from untrusted pickles. And not safe to persist untrusted JSON unserialized objects using SQL without first cleaning the data for injection attacks. 
I could only find one and it's dependent on deserializing JSON in the browser at the same time an XSS attack on the Array object is underway. so duh in that case, not really the fault of JSON. a server that receives a JSON string and deserializes it, doing nothing else with it, has no inherent security vulnerabilities I'm aware of except for perhaps an out of memory condition resulting from a giant input string.
If you serialize the argument of a call to os.system to anything, and then de-serialize that argument you had better trust wherever that serialized object came from. The format you serialize to is mostly meaningless. (unless it provides you some means to verify the trust.) JSON, YAML, etc DO NOT solve the trust problem. They just change the nature of what you can and cannot serialize to. (I do not believe you can serialize functions to JSON/YAML, whereas you can in some cases with pickle)
And I maintain that this is akin to explaining why knives are sharp. And then claiming that scissors are safer.
then you have totally misunderstood the article (or I would hypothesize haven't read it at all). It is about security vulnerabilities *inherent in the serialization format*, meaning, the serialized data cannot even be deserialized safely, period, without special steps being taken to modify the pickler in use. Nothing to do with what you do with that data afterwards. This is the Python subreddit, not the javascript or PHP subreddit - yes we know you aren't supposed to "trust" strings from the outside world. not the point.
Yes, I know she unpickled a call to os.system directly. I was using a different, but similar example. But clearly you don't want to hear what I'm saying: **de-serializing objects from an untrusted source is insecure** One might be a sharp object, the other an explosive device. The insecurity is in the trust, not the methodology by which they cause harm. JSON is susceptible to attacks similar to, but different from, SQL injection.
No, I completely understand. Her quibble is with the fact that you can pass actual callables and invocations through pickle, rather than the more limited access that JSON (and jsonpickle) and friends give you by default. I'd argue that this is part of the feature set of pickle, is there by design, and that understanding the risks are your job as a programmer. If JSON provides you a more limited toolset (and by default it does, though there is nothing to stop someone from tacking this on to, and jsonpickle gets you part way there) it does not make it safer. This functionality, by the way, from my quick read of the situation is what enables you to send class and function *definitions* through pickle. You are still attempting to take untrusted strings and turn them into data structures in your running program. If you're doing this, then caution is advised. If you're insufficiently cautious, you get what you deserve.
My take on the issue: http://mumrah.net/2009/09/making-pythons-pickle-safer/
You are very right there my friend! One of the friends of my who used Django always used to code "around" the django way of doing things, and had a lot of headaches. Whereas just by reading the docs or asking on the irc could have pointed him in the right direction. The problem is not that Django does NOT do it - but that people are too lazy to find out or think about how to do with Django. They just end up writing everything from scratch or even worse, hacking the source code. If that is what you want to do - Why do you need the Framework in the first place?
it means you cant even safely *look* at an untrusted pickle string in its unserialized form. Any JSON string can be unserialized safely and looked at. totally different.
99.9% of Python web applications deserialize data. Unless it's a trivial "Hello World" application, deserialization is unavoidable. Python's JSON lib doesn't naively exec() the untrusted data to deserialize it. So one would be very hard pressed to construct a security vulnerability where arbitrary code execution happened upon deserialization of JSON data. Maybe it's possible, I have no idea how it could be done, it'd be quite an exploit. The data contained in the deserialized object is still untrusted data, so you can't just go ahead and execute that data in any form safely, but you can safely interact with deserialized JSON objects. Exploiting deserialization of pickle though is trivial to do, the code doesn't even attempt to protect you from it. 
Ok so all you're saying is that I shouldn't do this: os.system(un_json(string_from_attacker)) Surely the distinction is in whether or not the de-serialised string is going to be eval()ed (in the lisp sense), ie treated as code. Pickle actually does some eval()ing before returning objects. JSON doesn't. Or are you claiming that just the act of de-serialisation (even without eval()ing or os.system()ing or any kind of explicit execution on my side) is dangerous? What are the possible attacks?
Nope, you're still not quite there. Her point is *not* that you can pass callables *through* pickle, but that callables can be run *during* the unpickling (before you do anything, cautious or not, with the result). So input can be devised to cause arbitrary command execution by just the act of deserialization. Come up with a JSON string that causes command execution *during* deserialization, then you've proven zzzeek wrong. That's the difference between JSON and pickle being discussed.
No, you're wrong. Nearly all JSON parsers, in any language, are completely safe to use against untrusted data, or they are a piece of shit that you should immediately throw away. Because any JSON sent over the network is untrusted! That is the whole reason that json.js exists. Otherwise you would just use eval(json_string). **Pickle is inherently different than JSON**. That is the point of the article. If you don't understand that, then that you are **exactly the audience for whom the article is written** !!! Pickle is different than XML, different than prtocol buffers, different than basically any other serialization format. One reason is that it does more. It's meant to serialize objects. Not just dumb data. 
&gt;&gt; de-serializing objects from an untrusted source is insecure In case people haven't beaten this into you already, **it is not**. If I deserialize a JSON string, extract the "foo" key value, and save it to a file, that is perfectly secure. An attacker cannot craft data that will execute an arbitrary shell command on my system. In contrast, merely the act of deserializing pickle is insecure. My program can simply deserialize it and throw it away. I will never ever call os.system with it. But the attacker can force my system to do make this arbitrary call. It's a little hilarious to see someone so be so stridently and adamantly wrong about something. 
Try this: import jsonpickle jsonpickle.decode('{"py/object": "sys.exit"}') Notice that your interpreter has closed. I haven't had enough time to play with it to figure out if I can exploit this vector further. Yes, the basic simplejson dump/load cycle is insufficient to do this. BUT, that's inadequate for many many peoples serialization needs *in python*. Sure if you're going between a browser and python, straight JSON may be sufficient. But if you're going to replace pickle you need to be able to pickle more abstract objects. And inevitably that's going to let you do something funny.
of course any moron can piggyback "pickle" on top of "json" and get the same effect as plain pickle - that library is subject to the same caveats as plain pickle and it has nothing to do with json any more than pickle has to do with strings. most of the world using JSON with python serializes to python dicts and lists using simplejson or similar. Let's see your simplejson vulnerability.
Why not just read stdout/err in a separate thread? This is what I've always done. You have the same issue in most (all?) languages, and this is the best technique I've seen so far. 
&gt;My program can simply deserialize it and throw it away. I'm so glad to hear that you don't do anything at all with the data you read in from the net. You must be one of the lucky few people in the world who can throw away data that your users send you, unprocessed. You're right -- the JSON module will not do this for you. But it does not do what pickle does. It doesn't let you serialize/deserialize arbitrary objects. You either need to write shims or use a library. To do this means either picking up an off the shelf library (jsonpickle) -- which will have the same issues as pickle (and I show an example in another comment of an issue there) -- or writing helpers or trying to convert these lists and dicts into real objects. Once you try to do that you're back in the boat of having untrusted data. Are you really going to tell me that you understand every layer of your Object Relational Mapper (which is what 90%+ of the people deserializing JSON objects are sending this data to), DBMS libraries and so on well enough to be sure that someone can't craft a nasty string to make you sorry? That's been my point. JSON doesn't magically eliminate this security issue. It just moves the burden of responsibility. Is it harder to exploit? That really all depends. Yes, yes, json.loads is a string parse and pickle.loads is a string eval. But when you need to pass some of those strings to code you don't completely own, how do you know they won't be doing an eval of their own? 
It's the best current technique certainly, but if you want to be careful, you have to do this a lot and/or make your own utility class for it. Given it's so ubiquitous, adding it to the python stdlib would be useful.
You missed the oppurtunity to include a "*puts on glasses*" or a link to [epiconeliner.com](http://epiconeliner.com)
*whoosh* OK, point me to your Python app that I can send bytes to which you will unpickle. Then point me to some other app that runs my bytes through a JSON parser, and does other things with it. Put your bank account number on the box. Now let's see if you're going to use Pickle or not. Web apps generally save data into a database and spit it back out. There is nothing in that process that makes the box vulnerable to attacks like os.system('rm -rf /'), no matter how badly you screw up your parsing code. You can surely do poor things like cause SQL injection or XSS attacks. But that is hacking the app. It's not the same thing as compromising the systems that the app is running on. If an ORM allows data from a database to cause arbitrary code execution, then that's a P0 security hole. I don't think you understand how these things work. This is the same reason why you should never use eval() or exec() in response to user input, and never use os.system() with user input. Ever. And you should never use Pickle with user input. Never ever. No web apps with any hopes to be secure do this. A legitimate use of Pickle is to save and load data to local disk, with files only writeable by the user running the app. If you are on an internal network, you could possibly excuse loading it from the network (e.g. in memcached), but that opens yourself to attack escalation (a person breaks into your internal network, and then he has another vector to break into any box running this app). 
I hope you were being sarcastic... I really do.
couldn't you sandbox the pickle?
they misspelled LIEK
Tell that to Google.
rant by someone who has probably never really used Python... * unicode issue: unicode(data, 'ignore') instead of unicode(data); depending on what you want replace 'ignore' with 'replace' * simple calculator: -1.100...1 is the correct result depending on the FPU. The Python REPL defaults to using repr to display values. Try "print 2.3 - 3.4" if you want something human readable * significant whitespace: just personal preference. Most of the time your current indentation style, if you do indent, will probably be accepted by Python with only slight modifications so what? * explicit self in method declarations: I don't like it, too * parentheses: ever tried a lisp dialect? * return - 1: the example for initializing a class is really wonderful: The return value of __init__ must be None; * return - 2: blocks have no explicit value as in Ruby, that's fine with me * inconsistent naming: that's true, but xrange is again a bad example as it's no longer in Python 3. Without enforcing strict guidelines using the compiler / interpreter any platform will have inconsistent naming schemes when you use 3rd party libraries. 
Hi, I'm the pyopt guy, nice idea you have there, I'm gonna have to think about it. The only minus that comes to mind would be the distance between the function declaration and the proof that it's exposed to the command line. I still am gonna think this one over.
nice
I see where you are coming from; but if you think about ordinary function calls, the definition and call may be arbitrarily separated too. You usually use '#' in Vim, or grep or Ctrl+F or whatever to find a function definition from a function call. This would be similar here. Anyway, it's your software, do as you wish! (:
You're welcome :)
looks like fun
exactly. this is what beaker cookie sessions do.
Changed them just now, not that the new names are perfect. but if you have a better idea please tell me. @expose.args
Dmitry Dvoinikov wrote a runtime type checker decorator if you like, though it does seem like he's a bit over doing it. http://code.activestate.com/recipes/572161/
You can pull out the markdown to HTML converter from WMD and use it as you'd like. It's called Showdown.
In Russia, Python owns YOU. 
This kinda thing would have never been noticed on digg. Thanks reddit, I'm yours. --MrPyopt
Definitely rough around the edges, but looks like a great foundation. A few notes: - template.py: "Error-reporting is currently... uh, interesting." - url mapping looks primitive - no form helpers - database.py looks decent, but is mysql only - Very nice to see the security considerations in signed cookies, auth, csrf protection. Overall, it looks like they've done the trickier parts of building a web framework and left it to the user/community to add the parts web developers use most frequently (form &amp; url helpers, code organization, and orm). I love Facebook's enlightened approach to open source. If even one of their open source projects takes off, it will benefit them tremendously.
The comparisons are unfair. They use nginx with Tornado but Apache with the others…
Saying its "Facebook's" is a bit rediculous, they only bought Friendfeed last month
So how long until they ditch PHP altogether?
Well, technically you can (for some value of "safely"). As pointed out, you can override find_class and restrict it to a limited set (In fact forbidding everything should still allow unpickling strings). You do drastically reduce the capabilities to nothing more than unpickling known safe types (strings, lists, dicts, numbers etc) by doing so, but that's all JSON provides as well. Admittedly, using JSON would still be preferable. The format is less complex, and thus there's less possibility for actual *bugs* to exploit. Python makes no guarantees for security for pickle anyway, so bugs that bypass security are not going to be noticed as they don't affect normal usage. 
Thumbs up to friendfeed for opensourcing part of their server software. However it doesn't feel like it bring anything new, still the same callback soup like twisted but without unittests to validate the complexity.
I think the second number (which beats Apache, et. al) is for just Tornado without nginx.
I'd like to know where Pylons stacks up with the rest of them...
That *is* what bought means. If I buy a car it is mine. I guess that Facebook has a different philosophy regarding open source than Friendfeed did. Frankly, it probably makes sense for Facebook to open source it. If it's used more widely and they can hire engineers who already familiar with Tornado it is a real gain for them. The competitive loss of releasing a python web server framework is probably minimal/marginal. The reduction in training time and the community, innovations, and bug-fixes that I'm sure they're hoping come out of this are probably much more valuable to Facebook. After all, everyone needs a webserver. Others will figure out this solution themselves. It's not *such* a competitive advantage to keep it out of their hands. On the other hand, Facebook uses *this one*. People enhancing and building up this one directly helps Facebook make their operations better.
The nginx thing isn't so interesting to me. I'm wondering what about the WSGI situation; seems that tornado only has [limited support](http://hdknr.posterous.com/tornado-web-server-documentation-0) for WSGI. A lot of middleware WSGI tools have been built. WSGI is **the** Python webapp foundation. I don't know enough about the technical details of WSGI implementation/low level technical details. But, this information coupled with [this criticism](http://www.reddit.com/r/Python/comments/99810/lets_talk_about_wsgi/) of WSGI's technical limitations makes me think that WSGI is due for some clean-up. I guess the real bottom line is that it's very tough to make a general, all encompassing standard like WSGI that makes everyone happy. People will always have new use cases, innovations or ideas. My impression is that WSGI tries to be as agnostic/non-opinionated as possible. But even with that, there'll be cases like this where someone tries to do something (asynchronous IO) which the framework has unintentionally constrained.
tl;dr: Technically it is Facebook's; releasing yet another half baked async io framework supported by very dodgy benchmarks is a great idea FTFY
&gt; Objections to top-posting on newsgroups, as a rule, seem to come from persons who first went online in the earlier days of Usenet, and in communities that date to Usenet's early days. Until the mid-90s, top-posting was unknown and interleaved posting an obvious standard that all net.newcomers had to learn. Among the most vehement communities are those in the Usenet comp.lang hierarchy, especially comp.lang.c and comp.lang.c++. Top-posting is more tolerated on the alt hierarchy. Newer online participants, especially those with limited experience of Usenet, tend to be less sensitive to arguments about posting style. http://en.wikipedia.org/wiki/Topposting#Top-posting
Wow. I got downmodded for *that*?
Hmm, I definitely wasn't around in "the earlier days of Usenet". The reason I object to top-posting is because it's **really annoying**! :-)
Early on (about 4 years ago, when I just started programming ...), I tried using gettext but could not get it to work; I still use .po files (not the compiled .mo ones) but have written my own "translator". I suspect that it was more my own misunderstanding of the gettext module than anything else which prevented it from working ... but now that I have something working, I'd rather not break it. Here's the code if it can help you: http://code.google.com/p/crunchy/source/browse/trunk/crunchy/src/translation.py
My personal policy for some time now is 1) to bug top-posters until they fix their act 2) plonk those who don't 3) leave those lists where unreformable top-posters are the majority. That policy has worked very well so far.
Was their purpose to hide his eyebrows? Nice shirt too.
"Don't cross the streams!"
To hell with the glasses, look at that shirt!
This is why Python had such slow uptake in the '90s :P
Correct, he lacks a beard in that photo.
Well I think the main idea behind the project is scalability
Yes. However, it was explicitly mentioned that it orginated with FriendFeed. Furthermore, if not for Facebook, it might not have been open sourced. Thus, Facebook deserves due credit.
Introspection specs.
the lovely 90s
next, on fox news...
Unfortunately that would mean I'd have to killfile practically everyone I'm doing business with. Even worse are people from IBM who somehow manage to top this by randomly mis-topposting, inlining with color and then destroying the quoting by inserting fucking random ASCII art, despite the fact that the entire mail is in HTML. Seriously, if anybody at IBM is reading this: what the fuck is wrong with your email? Occasionally I get asked why I do not top-post, to which I explain that their convenience is not more important than my time or effort. That seems to piss them off enough to not email me any more. Americans usually don't get it or don't give a shit. Fortunately enough *some* of the more mentally gifted people get it after a while; longer exchanges take on a controlled nature because context is preserved over the time of the thread, instead of the usual n*n-1 duplication idiocy that makes the entire thread harder to read for everyone. 
Everyone knows that a proper technology god must have a "unix beard." http://www.s5h.net/unix/unix-beards/
I always thought Theo de Raadt to be a fat slob. 
His shirt is even awesomer!! &lt;3
In the Netherlands he probably blended in just fine. I love people watching in Amsterdam.
...this is Guido van Rossum, of Python, not Theo de Raadt, of OpenBSD. Theo, incidently, is really into mountain biking and nowhere near fat.
In our operating systems class there was a presentation about how Python could make you cooler. This was a 'before' picture.
I was there not too long ago... do people always wear that much purple?
As for me, I too used to get frustrated at people doing top-posting .. but the real reason for that frustration must have got to do with the [socialization process](http://actualfreedom.com.au/library/topics/socialidentity.htm) I went through with the mailing list "community."
Sorry, meant to reply under the unix beards link.
Only some people.
There are some well known eccentric artsy type people in The Netherlands who also wear those glasses.
Try pylons with the Cohen container. You will be surprised.
*cogen
That was when he was trying to get a part in Dark City.
Exactly how I pictured him
Ah, that makes more sense.
The 70s called, they want their unreadable hardcoded flags back.
I think he makes a fair point without whining.
&gt; My main point here is that if you're about to undergo a re-write of a major project because it didn't meet some requirements that you had, please tell the project that you are rewriting what you are doing. What? Code **is** criticism. 
Somehow I was expecting someone with an orange fake tan puckering his lips.
py.execnet from pylib/py.test is a interesting tool
Thanks. I'll look into Cogen. You know you can edit your comments, right?
&gt; If you've shied away from contributing to Twisted itself because of our aggressive testing and documentation requirements, well, Tornado apparently doesn't have any, so it would be a great place for you to start :) Ouch. I like the smiley face at the end, nice touch.
If he were a neutral party, I'd probably agree with you. From Glyph: &gt; My main point here is that if you're about to undergo a re-write of a major project because it didn't meet some requirements that you had, please tell the project that you are rewriting what you are doing. That statement sounds as if Friendfeed took Twisted and rewrote it. From Bret: &gt; We ended up writing our own web server and framework after looking at existing servers and tools like Twisted because none matched both our performance requirements and our ease-of-use requirements. This sounds like they rolled their own solution. You can't blame them for doing this BTW - Twisted isn't called Twisted for nothing. Dealing with deferreds is ... an interesting brain exercise, to say the least. I should know, we wrote a fairly complex web service with it. If the Twisted community wants better support from developers then I suggest they go on a massive re-branding effort. Get a new, faster website (not run on Trac dammit), and write up some simple web examples so LOTS of people start using it and writing about it. I should be able to hit Twisted's site and have a video show me how to get a website up on it in 5 minutes. In this day of Twitter and tweets, you've GOTTA have a polished elevator pitch for the product - and a quick start guide. I can't even find a simple example of this using the Google to search for "twisted web howto" for chrissake! For example: If you run a Debian distro you can install Twisted by doing: apt-get update apt-get install python-twisted Once that completes, fire up an editor and stick this in a file called *foobar.py*: from twisted.web import server, resource from twisted.internet import reactor class Simple(resource.Resource): isLeaf = True def render_GET(self, request): return "&lt;html&gt;Hello, world!&lt;/html&gt;" site = server.Site(Simple()) reactor.listenTCP(8080, site) reactor.run() Start the server by doing a: *python foobar.py* Now go hit http://yourserverip:8080 with your browser and you should get a page that says "hello world". Edit: added a few more choice comments, an indent block, and the 'apt-get update' just in case. ;) 
But Tornado doesn't have to explain to me why there's a `web` and `web2`. :-)
Shhhhhhh! The web2 is a secret.
I'll agree with you here, but from what I know about Twisted and Tornado (not much, that is), it sounds to me like they could have adapted Twisted to their specifications, helping both themselves (less code to write) and Twisted (more code to share) without reinventing the wheel. That's the impression the article gave me, but, as I said, I don't know enough to judge. Thanks for your mini howto, by the way.
I forgot to add that this applies to public mailing lists. When I deal with business people I expect lobotomized cube maggots who have to hearken to the coprophagate queen, dictating dysfunctional methods and expecting to be obeyed, or fired. So expect communication breakage without batting an eyelid. I even top-post, because likely they won't be able to find my reply if I don't.
I shall take a look, thanks.
[Exactly](http://dustin.github.com/2009/09/12/tornado.html).
Very pythonic!
I'm using Twisted in a critical piece of software. My biggest problem with it is the complete and utter lack of useful documentation. The bits and pieces that exist are out-of-date, or far too specific to be useful (let's build a finger server from scratch!). The docs needs to concentrate on teaching the ideas, instead of demonstrating ways to use them. Also, the examples (and Twisted itself) seem to target backwards compatibility with Python 2.2 over anything else. For example, the documentation recommends writing code like this: def someFunction(): # calculate arg1 and arg2 doSomethingThatReturnsADeferred().addCallback(doSomethingElse, arg1, arg2).addErrback(handleMyError) def doSomethingElse(result, arg1, arg2): # do stuff with result, arg1, and arg2 def handleMyError(result): # handle error It's awkward, hard to read, and completely unnecessary. As of Python 2.4, Twisted has a decorator that lets you write continuations: @inlineCallbacks def someFunction(): try: result = yield doSomethingThatReturnsADeferred() except Exception as e: # handle error # do something with result The Twisted community treats this HUGELY more readable way of writing asynchronous code as some sort of bastard child they are embarrassed to even have in the code base. I only found out about this after getting frustrated debugging callback-style code and thinking "there must be a better way" and googling. Eventually I found the original implementation of this, and discovered it was already part of twisted. The only reference to it in the mailing list is someone discussing it, and various people chiming in to say "well, it's neat, but I wouldn't recommend writing all your code that way". On the contrary, it simplifies and makes your code pythonic. There's another hack that turns any function into a deferred via deferToThread. Instead of a simple "from twisted.internet.blah import blah", you have to do this: from twisted.internet.threads import deferToThread deferred = deferToThread.__get__ @deferred def nowItsNonBlocking(): # do something These two ideas make writing asynchronous code nearly identical to writing blocking code. In my opinion, the examples should be rewritten to show how to use these two decorators FIRST, then explain what's going on under the hood. Another beef I have with Twisted that I mentioned is the refusal to deprecate Python 2.2. Some key Twisted classes are still using old-style classes, and thus super() doesn't work. Passing exceptions over Perspective Broker is also broken for new-style classes. I wish I had the time to join the Twisted project and help fix these problems, but I already work full-time+. Twisted needs some sponsors.
&gt; complete and utter lack of useful documentation. Couldn't agree more with you there. I posted a [similar comment](http://www.reddit.com/r/Python/comments/9jun8/what_i_wish_tornado_were/c0d2546) below, but I'm inside the "boo hoo" post seunosewa made. Boo hoo. Short and simple, Twisted needs a marketing makeover and the maintainers would do well to get off their podiums and join the rest of us. I'm not saying Twisted sucks by any stretch - it doesn't. It's just horribly presented to the masses. 
Thanks for the thought. I think loading .po files directly is probably the way to go, whether using gettext (afaict you can write your own loaders) or not.
I would love to give Twisted a chance in my personal projects. Is there any documentation outside the code that does not suck? 
Many thanks for these books, Mark. Any time someone asks me about learning Python, I point them your way.
Thanks a lot!! Hopefully this will help &amp; encourage more people to move to python 3...
Thanks a lot for the chapter about strings, I use it all the time to educate people about "plain text"!
Νο.
Haven't read this before, but the new content and awesome presentation has just put it in my bookmarks list. So, thanks a million for the awesome book. It's fucking fantastic.
&gt; they could have adapted Twisted to their specifications, helping both themselves (less code to write) and Twisted (more code to share) without reinventing the wheel This always sounds easy but it rarely is. It was probably much easier for them to write Tornado from scratch than try to understand Twisted and extend it. Most people assume that their decision was irrational and try to argue against it. Try instead to assume that the decision was rational and attempt to find the reason.
Are you Greek?
Does it sound greek to you?
Thank you, Mark. Dive Into Python was how I originally learned it and I'm looking forward to this one.
Your name? Yeah.
My name means "He who comes from the Internet". In a language that I just invented.
Well, it means "halfwit" in Greek.
This book may actually to convince me to finally switch to Python3. Cheers for the work Mark. Part of my 1st paycheck will be on this.
You're welcome. I think that's the strongest chapter in the book, technically speaking. And with the new split between strings and bytes, it's one of the most important chapters as well.
Thanks Mark. I loved DiP, I'll definitely be learning Python 3 with this. You rock!
I hope the author makes a fair income on the book sales, I personally prefer printed to on screen for long reads. But Dive Into Python is wonder contribution... I'm just happy that it is to a language I actually like and use. Thank you. BTW, if you're ever looking to book ideas, I would be interested in Python tutorials/learning materials with emphasis in use in general education from high-school to college: for use in Math, etc.
Not on the iPhone.
Thanks Mark!
Great books and very nice formatting for the PDF/HTML versions. Makes it very easy to read and follow compared to the walls of text that most books of this sort can be.
Thank you, Mark!
&gt; This site is optimized for Lynx just because fuck you. LOL
Thank you Mark! Your books are excellent and have been an enormous help to me. Love the site optimized line too!
Do you by any chance have a blog where I could read more about this? :)
So sad that I can only give an upvote and and an orange envelope for your work. Better yet, I can wait for October: http://www.apress.com/book/view/9781430224150
Thank you Mark for such a great book! I wish I could put it in the python manuals. Wouldn't it be a great idea to have a comments for the online version of the book? 'Django Book' and 'Real World Haskell' have this feature and it's really handy, especially for the newcomers. 
I've been following the progression of this book pretty closely for months and months waiting for it to be done. The first book was awesome, this one looks the same. One minor thing though, in the expanded TOC, the 16th chapter hasn't been filled in and the link on "12. XML" is missing.
Any real world tests? A static page aka hello world is way faster using something like nginx / lighty / ... I'm more interested to see tests which do some real work. My pages usually consist of a few DB calls and a bit of rendering code which are done synchronous. When using tornado these DB requests should also be asynchronous otherwise it blocks the whole server which is not acceptable. How does it perform in this case compared to Twisted?
You're welcome! Thank you for the compliment, and for enjoying it.
I'd recommend werkzeug.
Any idea on how it compares with [String Template](http://www.stringtemplate.org/)?
Is there a reason you prefer it over others? I took a look at web.py, but, to be honest, they all look the same for what I want to do (just a function), so this might be a moot point and I might just go with werkzeug.
it depends if you want to go the minimalist library approach, or the framework approach. for example, it wouldn't really make sense for a big site like facebook to use an existing framework (as much as the pinax guys would try to make you believe otherwise). However, for something simple like you're trying to do, even a simple web framework like web.py will do. If you want to get down and dirty a bit more, and perhaps more control over the request tree, check out werkzeug. This is the 'minimalist library approach'. I'm becoming a fan of this over using frameworks because it gives you much more flexibility in the long run.
Hmm, true. I don't think I'll need what werkzeug provides, but I'll use it just for the experience. I literally just want a function that'll run an sql query, encode the results and spit them out, so a framework would be overkill, thanks.
The tutorial ain't bad, but you're teaching a pretty core function of Python. Given your likely audience it'd be a good idea to use proper indentation (I know you used a python shell, but you don't mention that, so a newb might get confused). Throwing some syntax highlighting in there would be sweet as well, but at least proper indentation would be nice.
Everytime I find a good tutorial like this, I can never find a reason to use it. Then a couple months from now, I'll have completely forgotten about this, but desperately need it. Irony sucks. edit: good article btw :)
What have you tried? Have you used the import statement as in: import cTurtle
Haha, yeah. It doesn't come with it. I've been looking over my notes from class, and I know I have to save it to something, but I can't figure out what. I'm pretty sure I have to make a directory too.
You might have to modify your module import search path to include the directory where the cTurtle.py file resides. Or, just start python from the directory containing the cTurtle.py file, because the home directory of the main script is always included by default. I.e., cd into the directory containing the cTurtle.py file and start Python from the command line with this directory as your pwd. 
What about [ConTemplate](http://www.codeirony.com/?p=9)?
Dive Into Python was how I bootstrapped myself back into programming after being away for some time.
..indentation does rather help Python tutorials - `&lt;pre&gt;`! The code is correctly indented in the source code, if anyone's determined to read this.. but I'd recommend http://www.diveintopython.org/file_handling/index.html or http://docs.python.org/tutorial/errors.html
I wrote an "an absurdly small web-framework in Python" which might be suitable, [pyerweb](http://github.com/dbr/pyerweb/blob/master/pyerweb.py).. It's not exactly complicated, it's just under 100 lines, works with Python 2.x and 3.x, and is wsgi compatible. Other similar (but more comprehensive) option is [juno](http://github.com/breily/juno) which uses much the same syntax for defining routes, but has more features I like [web.py](http://webpy.org/), it's nice and simple, and will do most things you wish. Final thing, have you seen http://www.themoviedb.org/ (which incidentally I wrote a Python wrapper for.. http://github.com/dbr/themoviedb ) It's a similar site to IMDB, but provides a nice API, rather than IMDB's "we sort of have an API, but we don't want you to use it"-API (which has such features as Amiga, Acorn *and* OS-2 interface..) TheMovieDB doesn't have quite the level of information IMDB does, but the proper API is *much* nicer than IMDB's plain-text files
This is exactly the use-case for open data tables in YQL. http://developer.yahoo.com/yql/ You write some server-side javascript that runs on YQL's servers, and returns the object. They will do the JSONP and XML translation for you, and the HTML cleanup so you can use E4X. http://developer.yahoo.com/yql/guide/yql-execute-chapter.html An example one that I wrote to pull out all the badges from steam : http://metaward.com/yql/steam.xml And running it : http://developer.yahoo.com/yql/console/?q=use%20%27http%3A%2F%2Fmetaward.com%2Fyql%2Fsteam.xml%27%3B%20SELECT%20*%20FROM%20steam%20WHERE%20url%20%3D%20%22http%3A%2F%2Fsteamcommunity.com%2Fprofiles%2F76561198002401654%22 (or getting the xml): http://query.yahooapis.com/v1/public/yql?q=use%20%27http%3A%2F%2Fmetaward.com%2Fyql%2Fsteam.xml%27%3B%20SELECT%20*%20FROM%20steam%20WHERE%20url%20%3D%20%22http%3A%2F%2Fsteamcommunity.com%2Fprofiles%2F76561198002401654%22&amp;format=xml
sounds like web.py would be a good fit
Show me the source! Want to be able to reproduce the tests
In case you are going to use database, then check out SQLAlchemy.
A Hello world to to benchmark?
Should be in /r/django/.
Thank you for the information, both on the frameworks and on moviedb. I hadn't seen it before, but I've written a [command-line script to rename video files of shows](https://launchpad.net/episode-renamer), and I want a source of episode names, which it doesn't seem moviedb can provide yet :/ I don't like web scraping, so I figured I'd learn a bit about wsgi and SQLAlchemy and write an API for the textfiles, so here I am! I will definitely keep an eye on themoviedb, though, thank you.
Hmm, so it's an online page scraper? That sounds very interesting, thank you for the information...
I'm writing my model on that right now, the new declarative base looks quite good!
Impressive! Thx for sharing.
Only once.
Checkout the [related docs](http://docs.python.org/tutorial/modules.html#the-module-search-path) Assuming you're on linux, you can export PYTHONPATH=&lt;directory of cTurtle.py&gt;, if that directory has an __init__.py file located in it. Otherwise, do as chollapete suggested and run the python interpreter instance in the directory of cTurtle.py
it's like django's templates but more powerful
Ah, no. 
Great stuff, I have been a long time user of Jinja, I like it!
I'm an avid fan of Juno if it has to be this small :-)
The results are conclusive my friend, framework X wins by a long shot!
Man, this **is** small. Hmm, I wonder what the tradeoff is. I'm giving it a spin right now, it looks great!
Juno is also my choice for tiny webapps.
Any idea how to set it up for apache+mod_fcgi? :/
I have added the code as per your request.
wonderful typography... and contents of course.
Can you help me set it up? I've made the thing and can't run it :/
I remember String Template being terribly obtuse, similar to other language-agnostic templating libraries. I'm [not very impressed with the syntax](http://www.antlr.org/wiki/display/ST/StringTemplate+cheat+sheet)
thanks for giving suggestions I am gonna make changes now
Or [Tenjin](http://www.kuwata-lab.com/tenjin/)?
[Bottle](http://bottle.paws.de/page/start) is yet another option. I'd say it's about as complicated as Juno, but has slightly better/prettier documentation. 
You can compile in Python as well.
While I think @inlineCallbacks are more readable, I always found the tracebacks harder to read, which made debugging more complicated.
Well, this looks about as simple as Juno (unlike werkzeug, which has a lot of boilerplate) and it has an example of deployment on apache+wsgi, which Juno doesn't even mention, so I'll be porting my one function to it now, thank you.
Then maybe easiest way would be just simple .cgi? ;-) Or maybe wsgi application.
Bah, the example isn't working. Have you managed to get it running on Apache? All I get is an error with no information in the log :/
True, although I think that's an implementation detail that could be improved. 
I like the title of chapter 6.2 ;-)
Reminds me of http://github.com/facebook/tornado/blob/master/tornado/options.py I don't personally have much trouble using optparse but they both look friendlier for sure. I assume it only is a problem when you have lots of options which is seldom the case in my apps.
It is sure hard to compete with optparse because it's in stdlib, but really it is boring to write so many lines of boilerplate code just to parse options. :) Maybe that's problem just for me, but that's why I've written this lib. ;-)
Heh. Your lib sure looks cool and I much agree with your point about OptParse boiler plate. It's not just you :)
Sorry, I stopped using FCGI in favor of SCGI. Also, I stopped using Apache in favor of lighttpd for my personal stuff.
Hmm, how does lighty compare to Apache? I heard that it has a few memory leak problems... I wish nginx had a decent wsgi plugin so I could skip Apache altogether...
Does it support required options?
I've been reading through the book ever since I saw the link yesterday. You are a kick ass writer. In 90% of the technical books I read, I get bored with the authors voice, annoyed by the lack of examples, the vagueness of critical sections, or some combination of these. You have covered all the bases. For the first time in a while I am actually enjoying reading a technical document! Great job. Please, keep writing =)
how does it handle appending to lists? I use options on a few of my scripts similar to grep -e'value1' -e'value2' quite often, and optparse handles that fairly simply/well.
&gt; I don't personally have much trouble using optparse but they both look friendlier for sure. Depends what one needs really. optparse simply has no subcommand handling for instance, so you have to do that manually which is annoying.
That's exactly how lists works here, just do it like this: @command def log(revs=('r', [], 'revisions to display')): print revs and then use it like `./log -r 1 -r 3`.
Thanks! :-)
Only in form of arguments. But why would you need required options? Even name of option suggests that it is optional...
I've seen about four new argument handling libraries in the last couples of days. (Command line option handling is kind of turning into the same thing as Python web frameworks by now ;-) ). Can anybody enlighten me as to what's so bad about optparse? It may not be the most pythonic thing around, but does that really warrant all these new libraries? Especially given that some of them are not really compatible with older versions of Python?
Because the syntax of options is less susceptible to user error than arguments. And because python allows class/function arguments to be referred to as options by the caller for the same reason.
How did you integrate it with mod_wsgi? I see that the official docs go full-blown virtual server at once, but you could try a simple .htaccess first. &lt;Files bottle.py&gt; SetHandler wsgi-script Options ExecCGI &lt;/Files&gt; works for me. It's no different in this regard than web.py.
I think it should look like this: from mylib import optionparse # The -h and --help options will be generated at runtime, just like how optparse does it. usage=""" Usage: xmptr [OPTIONS] FILE.XM Get a text representation of a pattern. Options: -e, --expand expand loops -c, --compact use compact text format (easier to parse) -p, --pattern pattern number # -d, --debug hidden debug option (it is hidden because it is commented out) """ options, args = optionparse(usage, sys.argv[1:]) xmfile = args[0] if options.expand: blah.blah() ... other crud getpattern(options.pattern) # &lt;-- optionparse automatically converts numbers strings to int or float types. Yay! Now type 'xmptr -h' and you will see the help message: Usage: xmptr [OPTIONS] FILE.XM Get a text representation of a pattern. Options: -h, --help show this help message and exit -e, --expand expand loops -c, --compact use compact text format (easier to parse) -p, --pattern pattern number That is how my option parser works, except for the misaligned columns :( . It is a thin hackish wrapper for optparse. :P 
I have no desire to format help by hands. ;-)
Err, sorry. The example on the page worked for me, you have to remove run() from the script though (or only set it to execute when you aren't importing the script as a library).
To hell with optparse, there was nothing wrong with getopt. I used optparse once, and haven't returned since for such a trivial problem domain it doesn't warrant the effort to keep its idiosyncrasies in my head. In the meantime getopt's interface is similar across C, Python, Perl.. The last thing I want to be consulting the docs for is parsing command line flags. Instead with getopt there are 4 things to remember: it throws getopt.error, and you have BSDish getopt() or gnu_getopt(), and that sys.argv[1:] is the first parameter, not the second. :) As for type checking, building lists, generating help and whatnot, it hardly saves you much over a `for` loop and a `def usage(): sys.stderr.write(...)`. Besides, what if I want to build a set instead of a list, or pass the option value to some arbitrary API to validate? Guess I'll need to wait another few years for someone to invent the next One True Parsing library.
Best reddit submission evah!
[Um....](http://www.reddit.com/r/Python/comments/9hqja/pyopt_a_pythonic_way_to_do_command_line_option) How many libraries do we need to do one of the most mundane programming tasks?
If it was hard to write, it should be hard to understand. 'nuff said. Joke aside this is correct and not only for open source. In fact it's probably one of the main reason my company is still in business selling proprietary software. Our documentation kick the ass, stomach and chin of any open source software out there. Regarding twisted I used only the SSH client part (conch) and the documentation was weak. Vague out-of-date how-to and few working example. But it works damn well :)
I wished Twisted had been fixed instead of spawning a whole new project too, but I am surprised how... passionate people are about this.
I have written a fairly complicated app using Twisted. For the most part, I just skimmed through the documentation, and read the source code to find the real answers.
if i put myself in those shoes, i think i might be looking at a real chance my project / my pet project is dying. consider: a. twisted never really gained traction in a big way, b. founder recently shifts direction, c. big-name corporation with big pockets re-implements 90% of the functionality. it seems like it's time for twisted to die. it's like watching the open source model of evolution in real-time; one gets old and slow, accumulates too much dead weight, a lighter, better one comes along keeping the best ideas of the old and jettisoning the rest. 
well, they only reimplemented twisted.web, I'm not sure that counts for 90% of twisted.
I'm a bit sceptical if lacking documentation is the only issue of twisted's decline. I'm also sceptical if tornardoweb will really gain a larger user/developer base. Surely, the hello world examples show superior performance... But we have to consider that both twisted and tornadoweb are ASYNCHRONOUS. This means that you can't use all the established but SYNCHRONOUS web development libraries (db access, web service integration,...) with them... IMHO this is what twisted nearly killed. 
Is it just me or does this all sound like too much bitching and whining? I don't see how friendfeed/facebook or anybody else for that matter is obligated to contribute to twisted. If they want to implement their own servers that's their prerogative. Personally I think competition is a good thing, so I look forward to tornado and twisted from now on. Prediction: twisted.web will get much better much sooner now that tornado is out. 
&gt; This means that you can't use all the established but SYNCHRONOUS web development libraries (db access, web service integration,...) with them... Why can't you? The twisted guy clearly said they kept the db layer synchronous because there was no gain in making it asynchronous, it just made code more complex.
this applies to fast ad-hoc db queries... but what if my app wants to query ressources with higher latencies like external webservices (e.g. retrieve a list of the user's albums on flickr). Normally I'd quickly swap in a preexisting (synchronous) flickr library, but with tornadoweb this would block the entire webserver for seconds. To circumvent this, I'd have to develop and maintain my own asychronous flickr library.
I completely agree with you. More competition eventually leads to better software quality in all projects. Twisted will improve its codebase and Tornado will get better documentation than it has now in the (near) future :) And us developers are in the awesome position of being able to choose among a couple of frameworks!
In python3, this could perhaps be amended with argument annotations to preserve the current meaning of default arguments: @command(usage='[-l HOST] DIR') def main(dirname, listen : ('l', 'IP to listen on') = 'localhost', port : ('p', 'Port to listen on') = 8000, ... ) [Edit] Corrected order of annotation/default. 
You were joking, but it's worth noting that often it's more time consuming but easier to write something than to understand something else.
"no matter what they tell you, it's a people problem"
You don't have to do the formatting by hand! The formatting is handled by the optparse module! The formatting just got messed up when I cut and pasted the comment.
Tornado is just a web server. Twisted provides a whole asynchronous networking framework. In fact, I'd bet that more people use twisted for non-http networking than for implementing their own web server. I don't have any stats to back me up but I'd be willing to bet most python web apps run on an existing web server like lighttpd or apache. Friendfeed being the exception, not the norm.
wow, finally an alternative to using twisted.
agreed. I even had a few instances where I had a hard time to understand my own code after a few months.
The webserver in question is used for synchronous notification to the web browser; its purpose in life is to sustain tens of thousands of simultaneous open, idle HTTP requests. Normal httpds cannot sustainably do this. It's the same protocol, but it's a whole different game.
A simple thread pool would do the job just as well.
Great idea! When I'll bother with porting to python 3 I probably will support such syntax.
hm, but you need to define options in usage, which are parsed then, right?
Good point. Other web servers can do persistent connections but not by multiplexing connections in the way that twisted and tornado do.
If you're querying webservices over HTTP you can just use twisted's defered HTTP requests.
yes you can, if you read the docs: http://docs.huihoo.com/python/twisted/howto/gendefer.html#auto5 you probably can't do this with tornado though. everyone seems to be missing the point that tornado is a web server, and twisted is a fully featured networking library.
I'm going to take a guess that its a question of audience. If you've spent ten years doing J2EE development and trying to understand stuff like [this](http://java.sun.com/j2se/1.5.0/docs/api/java/nio/channels/package-summary.html), systems like Twisted are a walk in the park. Unfortunately it seems that the J2EE audience hasn't migrated to dynamic languages as much as some of us have hoped.
Isn't this more about twisted.web vs Tornado? Twisted as a whole isn't just a web server.
Python has modules to connect to every database you just listed. The only thing keeping you from switching to Python is your poor google skills.
WHAT? SQLite is built into the standard libraries! MySQL and PostgreSQL libraries are easy to find. I use them daily. Edit: Edit: obvious troll is not obvious troll, just noob. 
How do you define "poor"? cx_Oracle is excellent, a SQLite driver is shipped with python, can't say anything about DB2 but MySQL and PostgreSQL are very commonly used together with Python. I even made MS SQL and Sybase work decently with Python. And even if everything else fails, there is always pyodbc. Additionally, with SQLAlchemy Python even has the best SQL relational mapper I've seen so far. Please be more specific with your inquiry.
No. You can tell the MySQLdb interface to give you a dictionary by specifying a different cursor class: http://code.activestate.com/recipes/171463/ Edit: And now that we've done your homework for you.... 
Calling something "poor" just because you don't know how to use it isn't productive. You might want to try just asking for [help](http://groups.google.com/group/comp.lang.python/topics) instead.
_self.connection.type = MySQLdb.cursors.DictCursor_ What is the error? Please have a look at this recipe: http://code.activestate.com/recipes/171463/ You want to set `cursorclass`, not `connection.type`, and you want to remember to `import MySQLdb.cursors` 
I think you should `import MySQLdb.cursors` 
My guess is...take out that `unix_socket='/opt/lampp/var/mysql/mysql.sock',` bit in your `MySQLdb.connect` call. 
boosh
&gt; Twisted will improve its codebase That doesn't magically happen, someone has to actually do it
It's only an alternative to twsited.web
mysqld is actually running, yes?
Thank you. Yes, it is, but it's installed under a different directory. `/opt/lampp/var/mysql/mysql.sock` is where the MySQL socket is located.
SUCCESS! All I did was update MySQLdb! It was a known bug in MySQLdb that has been keeping me from Python. WOW! My main DB engine is MySQL and ODBC, so now I only have one more to go! THANK YOU SO MUCH!!!
You're quite welcome. Happy databasing.
Heh.. it seems we have similar project ideas.. I also wrote a script to automatically rename TV episodes, named ["tvnamer"](http://github.com/dbr/tvnamer), which gets episode names from www.thetvdb.com via an interface I wrote, http://github.com/dbr/tvdb_api (which currently contains the current stable 1.0 version of tvnamer)
On an unrelated note, how great is github? I wish bzr-git worked so I could use it in Windows...
Better off using the processing module, or for that particular case, xargs with the -P option.
True, but twisted.web is (or at least should be) a "gateway" app - HTTP is about the least subtle protocol out there, so you should be able to look at twisted.web and learn about just the twisted part, since you already "get" the HTTP part (and then apply what you've learned to something more interesting like twisted.words.) On top of that, [90% of everything is HTTP](http://en.wikipedia.org/wiki/Sturgeon%27s_Law) anyway...
:D
I understand what you mean. I was just kind of excited to check this out, only to find out that it (presently) only covers HTTP. I'll be working on a project shortly that will be deploying Twisted, but with no need for the HTTP stuff. Would have been great if I could have convinced the lead to ditch it in favour of a well documented alternative. *C'est la vie.*
I really like it, it's the main reason I started using git (had it not existed, I would have still being using either darcs, or maybe mercurial).. After using it for.. over a year, the only criticism I can think of is it could be a bit more stable (Github [is moving to better hosting now](http://github.com/blog/493-github-is-moving-to-rackspace), which should improve things - nearly all the downtime I noticed was due to GFS problems, which they will no longer be using), aside from that it's entirely great
Adaptation of Python 3 has been slow due to the inertia of existing 2.x third-party libraries. I would argue that it simply isn't the time yet for a Python 3-specific patterns-and-idioms book.
I don't know, I'm not sure. I've started using python 3 as well as 2.6 for simple standalone scripts and the likes, and I know I'm not alone. Also, I see more &amp; more libraries being ported to 3. for example, pyqt supports python 3. The next Blender, 2.5, will come bundled with python 3. And there are more. I know that if you ask around people will tell you not to start with 3, but if everybody will think that we'll never move to 3...
He's probably waiting for Python 3 to gain more adoption, I'd guess. I'm getting around to reading 'Thinking in Java' from 1998 this week, so I'm in no hurry.
ooh, lets have a "Diving into Python" burning!
I'm still waiting for the third version of his Java course on CD. Oh, just checked the web site - it's not going to happen, looks like. Too bad. His stuff is the absolute best. 
Well, my attitude towards Python 3 is, "Don't bother unless you're porting a library." I figure I'll use Python 3 once the libraries I need are available for that platform. Until then, 2.6 is just fine.
dive into python is overrated. The guy even called his factorial function 'fib' (for fibonacci)! The official python tutorials are MUCH better than this p.o.s.
* optparse - you have to remember or consult the docs each time you use it and it's always boiler-platish. * getopt - not magically awesome (casting/help/argument-count...) * [pyopt](http://code.google.com/p/pyopt/) is magically awesome yet only works with python 3. Also it's not as versatile, it just lets you expose functions to the command-line with a one-liner. So this one gets you farthest with the least amount of work. * opster - less boilerplate than optparse and as flexible and compatible. Though this all comes at the cost of strange looking python (the defaults as annotations trick), and it's still as explicit as optparse which is a tradeoff. 
Yeah, same here. Until My Favorite Linux Distro and Their Favorite Linux Distro are including py3k by default, I don't think I'll start using it.
I did that already so here's a shameless plug for (pyopt)[http://code.google.com/p/pyopt/] which is a python 3 only solution with options (required or not required), or positional arguments. It's not as flexible as opster (by design) it's a 1-liner option parser.
Hey, it seems Ruby and Python have that in common. Ruby 1.9 adoption is slowed due to the same issue.
No.
I bought a book on Python 3 because I figured I was new to the language and should start with that. However, I soon realized that pretty much every program or library I may want to use right now is for 2.x.... so the book that is a reference on 2.6 and 3 at the same time is a lot more useful!
My Linux Distro (i.e. Ubuntu, the average person's favorite I guess) includes Python 3. I just installed it from Apt the other day. So, I mean to say it's not the 'default version', but it is available by default.
No, Ruby is.
Even thinking about this makes me shiver... Python would soon find itself without functions except those the API provides because "Silly programmers can't be trusted with them". Soon after, even though it's (currently) built on C, it would stop you from interacting with C or any other language because only official Python modules will give the best experience. Python fanboys will start to look down on other languages...well I concede this one... No, I would not like this at all. Python &lt;3
&gt; so the book that is a reference on 2.6 and 3 at the same time is a lot more useful! Try [Python Essential Reference (4th Edition)](http://www.amazon.com/Python-Essential-Reference-David-Beazley/dp/0672329786/).
Yep! I meant that I had bought such a book, that one in fact. It's excellent! Now, if only I could find some time to work on some Python projects...
Yeah, that's pretty clear. We just have to observe: 97.4% of people who are drawn to MacBook Pros choose Ruby and TextMate.
[Crunchy](http://code.google.com/p/crunchy/) might work. Also, Michael Foord has been working on [Try Python](http://www.trypython.org/).
I have the older edition of this book. It is indeed excellent. Since it covers 2.6 *and* 3.0 I might just have to grab a new copy.
If its just a text-based game you could use a frontend for the python interpreter hosted on the server and just execute your student's programs without modifying anything. Google has a [pretty slick AJAX one](http://code.google.com/p/google-app-engine-samples/downloads/detail?name=shell_20080503.tar.gz&amp;can=2&amp;q=). It is kind of a security risk concern for you server though so take adequate precautions.
This blog provides nothing useful.
I would like to second the security concerns. They are going to be many and trying to tie down Python will probably be futile, there is no way for you (or us) to know the all they ways a user could harm a system. My best advice would be to run it in a jail like environment: http://en.wikipedia.org/wiki/FreeBSD_jail Can some Linux folks help me out on which alternatives are good for Linux? Then set up an environment per session and remove it once a session ends. This would take time to get working though and I am still not sure if I'd give anyone raw access to a Python installation on any box if there is a remote chance that the person may be hostile. I think I would rather give the kids accounts on a *nix server and then teach them how to use Putty to access it from Windows and then launch their program. That would also be a useful thing to know how to do.
Yeah that's right. Python is very hackable. The person writing this article perhaps does not understand Apple very well.
Sounds about right to me.
There's code to do something like this in [weberror](http://bitbucket.org/bbangert/weberror/) -- specifically [pdbcapture](http://bitbucket.org/bbangert/weberror/src/tip/weberror/pdbcapture.py) The pdb mode works by simply generalizing stdin/stdout capture. It's extremely unscalable, so things might get weird if you use this in a long-running unattended process.
Try Python - Install Microsoft Silverlight button....jeah right
This is probably not useful to you right now, but you may consider it for the future. I tutor first year programming at an undergraduate level at the University of Melbourne. We've developed an online environment for learning to use Python which we use in our courses. It's developed as open source software, and is available from http://ivle.sourceforge.net/
If they are graphic program you could setup something using a java applet x-server connecting to a "very limited" jail rooted guest account. [maybe that](http://www.jcraft.com/weirdx/)
Wouldn't running the interpreter and frontend in a virtual machine essentially sandbox the whole thing? Then if it does get compromised, it can be easily restored from a snapshot.
The problem is that if it is compromised the attacker will have full access to the whole box. Being able to execute Python code is essentially a shell. from subprocess import Popen print 'Simple Python shell, you get the idea...' while True: cmd = raw_input('&gt; ') p = Popen(cmd, shell=True) p.wait() So your idea is pretty much: "I may have left my car for anyone to use, but I can restore it." This will of course not stopping someone crashing it into your friends house which you can't restore.
I'm not sure I follow. I'm suggesting using something like Xen Virtualization and running (e.g.) a debian install in one 'slot'. Thus if the VM is compromised, the 'outer' machine can't be affected.
In what way is that better than the first situation? Virtualization does not add security. It makes it possible to move the "machine" between machines easily and to make back-ups etc. that can be restored without physical access. None of these addresses security. Sure, you can limit access to it, tie it down, but this is no different from a physical machine. If an ordinary machine is rooted, I restore it from back-up. If a virtual machine is rooted, I restore it from back-up. The problem is what can happen in between. Can the attacker use the machine for "evil" intents? It is possible to give code execution rights and still keep a system contained. But I wouldn't want to do that on my own, then I would rather look at app engine and have Google secure the environment (their environment even) instead.
Crunchy could indeed work, and it would probably be very easy to set up - except for the security issues mentioned by others. For each student, all you'd have to do is create an html page and have the student code inserted as follows: &lt;pre title="editor"&gt; student code here &lt;/pre&gt; To prevent complete strangers from accessing the site, you'd probably want to create either an account (username/password) for the entire class, or one per student.
[z3ext skin examples](http://z3ext.net/people/nikolaykim/blog/z3ext-skin-demo/)
I thought of Jython and found this.. http://code.google.com/p/jythonshell/ http://www.gnucitizen.org/projects/jython-shell/ Maybe it could be adapted to fit your problem. There's a few more options of you search for "jython applet". Possibly something like [Pyjamas](http://pyjs.org/) for translating Python into JavaScript might also be a possibility, but I imagine this might take more work. No idea if "raw_input()" works in Jython.
This wouldn't help for your immediate situation, putting an interactive command line Python script online. But if you have future assignments where a program can take a set of inputs and produce outputs, then http://utilitymill.com is an easy way to go. (disclaimer I made the site). You just make a username, click "create new utility", write a name, some documentation, set up what inputs it needs, and then put the code in. The inputs you set up become global variables available to your code, and anything you code prints becomes the output. (You can even output files) As an example, here's one I made that I think it cool http://utilitymill.com/utility/Keyboard_HeatMap You paste in text and it counts the occurrence of every letter, and then overlays a heat map over an image of a keyboard so you can visualize which keys were pressed the most.
Have you checked out the [SimpleHTTPServer](http://docs.python.org/library/simplehttpserver.html) module? It might be what you're looking for. [Here's an example of it's usage](http://effbot.org/librarybook/simplehttpserver.htm). Below is a modified example that might be close to what you want. If you've got a file called simple_server.py and game.py, you could set things up as follows: **simple_server.py** import os import SimpleHTTPServer import SocketServer import game # minimal web server. Calls a function (play) in module game with argument # given by second part of url. # e.g. http://localhost:8000/play/some_arg will show the result of # game.play('some_arg') PORT = 8000 class CustomHandler(SimpleHTTPServer.SimpleHTTPRequestHandler): def do_GET(self): path = os.path.split(self.path) print path[0] if path[0][1:] == 'play': self.wfile.write(game.play(path[1])) httpd = SocketServer.TCPServer(("", PORT), CustomHandler) print "serving at port", PORT httpd.serve_forever() **game.py** def play(arg): return 'playing game with arg %s' % arg Run it with $ python simple\_server.py on on your computer, go to [http://localhost:8000/play/some\_arg](http://localhost:8000/play/some\_arg) and you should see the output of the function. Obviously this is going to scale very badly, and I have no idea how well it would work with a few people trying to access it at the same time, but it should be more secure than other solutions (url params are just treated as strings for an argument), and it should be instantly visible over the web.
Absolutely. I'm not going anywhere until I get NumPy in Python 3. Additionally, Python 3 really doesn't run very quickly right now. There are some under-the-hood cleanups that definitely need to be made to get back near 2.5 (or even 2.6) levels of speed.
This was posted a few eeks ago might be just the ticket: [scratch.py](http://www.speakeasy.org/~lion/proj/scratch/)
He is blogging on Artima. If you check what he is talking about lately it is mostly business philosophy and such stuff. Seems like he takes a break from programming. 
Take a look at how [pylons](http://www.pylonshq.com) interactive debugger works. I'm not to sure of the details, but if you have a pylons app that throws an exception, you can have it serve a fully interactive prompt from the webserver for debugging. I imagine that their code for doing so would give you a good idea of how to accomplish this.
&gt; There are some under-the-hood cleanups that definitely need to be made to get back near 2.5 (or even 2.6) levels of speed. AFAIR Python 3.1 already has some impressive speedups, especially regarding IO
Silverlight allows you to run Python in a browser, in a similar way you would a Java applet.
Is this some sort of veiled Adam &amp; Eve reference? 
Yeah, the IO facilities were written in Python for 3.0 and then reimplemented in C for 3.1
Based on my own experience (with Crunchy), setting up communication between a browser and a python backend using raw_input() is not something that can be done trivially. So, the scratch.py idea mentioned and SimpleHTTPServer module one, for example, might be fairly tricky to implement. I would not spend too much time trying to implement those...
Not quite what you asked for, but py2exe (for Windows) is easy to get running. Email parents a bundled exe and the source code. Have them ask their child to explain the program's execution to them. For parents with OSX or Linux, the program should run with the included python interpreter. Crazy idea: write a twisted telnet service that can run each kid's program (with a top-level menu). Publish a java telnet client on your site and require a password for each classroom. Hell, if you are getting twisted involved you could also write an AIM chat bot (or show the students how).
Looks like Google's does a pretty good job &gt;&gt;&gt; import os &gt;&gt;&gt; os.stat('/') Traceback (most recent call last): File "/base/data/home/apps/shell/1.335852500710379686/shell.py", line 267, in get exec compiled in statement_module.__dict__ File "&lt;string&gt;", line 1, in &lt;module&gt; OSError: [Errno 13] Permission denied: '/'
&gt; hm, but you need to define options in usage, which are parsed then, right? You need to define options in usage, and then you call a function. FTFY. There is no 'hm, but'. You would have me write this: @command(usage='[-l HOST] DIR') def main(dirname, listen=('l', 'localhost', 'ip to listen on'), port=('p', 8000, 'port to listen on'), daemonize=('d', False, 'daemonize process'), pid_file=('', '', 'name of file to write process ID to')): I would have you write this: usage=''' test_opts.py [-l HOST] DIR Command with option declaration as keyword arguments Otherwise it's the same as previous command options: -l IP, --listen=IP ip to listen on (default: localhost) -p PORT, --port=PORT port to listen on (default: 8000) -d, --daemonize daemonize process --pid-file=PIDFILE name of file to write process ID to -h, --help show help ''' Your module even generates a usage string, why not start there? Why do you even bother to generate a usage string? Because it is all about usage. How do I use this thing? How do you use this thing? The usage string answers these questions. Your module is not very much different from optparse. It is a little bit more concise but that is not enough to make me switch. 
why is this even in python?
monitoring and intrusion detection can take care of these and should be a part of any security system anyway.
If doing python with apache, use mod_wsgi for a start... Otherwise, you might be able to use IronPython to get stuff working in a browser (I believe someone did a python prompt in the browser this way), and theres Jython with applets too.
This option isn't that wonderful if you want an interactive game. Check out the google python toy: http://shell.appspot.com/
And yet it's no surprise, because Python 3.0 wasn't really a general-use release. Ditto for 3.1. The point was to get the releases out there so authors could start the process of testing and porting, which was and is expected to take a couple years. Rene knows, or should know, that, and I'm getting kinda sick of people who ought to be better informed spreading this same stupid FUD over and over again.
Anyway it's getting there slowly. numpy is now working with 2.6 &amp; they're working on porting it to 3. SQLAlchemy svn version works with 3 also, I think. PyQt already works with 3. Pygame rewrite is working with 3 too (though it's still being written), and many others. TL:DR. Just wait, we'll get there.
I didn't really see the article as FUD. He just provides a look at different measurements of Python 3 uptake. He doesn't make any judgements, he just ends his summary with the question, "How well do you think the migration is going?" Personally, I was expecting that setuptools and buildout would have been ported within a year, but hopefully distribute+buildout will be out by the end of the year. I also expected to see a Python 3 web framework within the first year. Not a porting effor by a major framework, but there's been a few new minor and micro frameworks released in 2009, and disappointingly they've all been for Python 2. But he provides 241,363 as the number of downloads for Python 3.1 for Windows in August '09. Sure it's not as big as Python 2 downloads, but it's still a huge number! I have no idea what the download stats were for Python ten years ago, but I'd guess that all downloads for all platforms for all of 1999 weren't as big as just Python 3.1 for Windows in a month. Even if the migration is slower than many expected, Python's popularity continues to grow at steady rate. 
The real problem is that the changes are significant enough to make it a different dialect. But can a python script assert a minimum version of python to run against, or else run in a compatibility mode? Lack of planning for migration and only a feature on changing features has created a debacle. Python has had significant momentum to take centre stage as the general purpose/cross platform scripting language. In essence it's not dissimilar to the Perl 6 debacle - indefinite/unknown completion. The Perl monks are a bit cleverer about script version assertions and other such however in their language design. 
Why not? If all your trying to do is expose a text based game this method would work fine. To do the text input, you could add a tiny bit of html to the returned webpage adding a form, and implement a do_POST method in your custom handler to handle the incoming text, and pass it to the relevant function. Because all you're doing is entering text/responding to output this should be interactive enough. Plus it has no external dependencies outside the standard library. How would you get your game into it this python shell? Does it require learning how app engine works? Do you enter it line by line? Just curious, think the shell itself is pretty cool.
Easier and simpler, once you have the configuration set up, is to just do: from django.core import management management.call_command('syncdb') 
This why I love open source ...
Yeah, Silverlight is so opensource.
I was talking about python... So many helpful tutorials and tools.
Full source available: http://www.mono-project.com/Moonlight
FUD? I didn't see much FUD in his post, he's merely listing and wondering where things are at which is a rather sensible question at this stage. Sure Python 3 is still rather young in terms of official releases but it's not surprising that people start considering where they'll invest their resources right now for the future. The choice between 2.x and 3.x isn't trivial and if you bet your architecture on it you may need to know where things stand and feel the pace.
But it's still very interesting to see what the current state of the porting process is. This is important information when you're now looking out and have to decide what framework/language you're going to use. And, btw., a low progress rate (of ported libraries) is going to hurt python a lot, especially in the professional field and for larger applications. Python is still seen as a niche environment (whether that's true or not) and a low amount of available libraries for Python 3.X is going to give the nay-sayers just another nail for deciding against Python at all ("language and landscape in a state of void", I can just hear them).
Setuptools (which buildout relies on) has been virtually unmaintained for some time. Expecting it to get *bug fixes* much less ported to 3k is unrealistic. This is why tarek ended up forking it. As for web frameworks: There is no good story on how to maintain compatibility with older versions of 2.x and 3.0 - sure, if you drop support for anything but 2.6 and add 3.0 compatibility, you can do it - but that's unrealistic at this point.
&gt; The choice between 2.x and 3.x isn't trivial and if you bet your architecture on it you may need to know where things stand and feel the pace. The choice is very easy. Use 2.x. In eighteen months or so, look at the state of the library landscape again and think about migrating.
&gt; going to give the nay-sayers just another nail for deciding against Python at all ("language and landscape in a state of void", I can just hear them) That'll happen anyway. Besides, nobody declares Windows to be a dead platform just because it gets another new and incompatible and largely-unused way to lay out GUIs every 18 months or so.
hmm is it protected against the combinatorial recursion issues of an NFA regex compiler? &gt;&gt;&gt; re.compile('.X(.+)+X').search('bbbbXcXaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')
I agree with you but you know that changing things is usually much harder in a company than making the initial jump. 
yet so few job oppotunities (compared to other programming skills) sigh
which IDE for beginners/learners ? 
It takes one python programmer to write (in python) a program that would take five java programmers to write (in java) :)
and if you're going to insist on using Python threads rather than multiprocessing, a better implementation exists here: http://code.reddit.com/browser/r2/r2/lib/workqueue.py?rev=33fd4e9684ca7668b57aa32ab6a064cd2a86ef6d (and it's open source)
Try Python: Python Tutorial and Interpreter in Silverlight FTFY
He seems to be blogging quite frequently at http://www.artima.com/weblogs/index.jsp?blogger=beckel ... his recent posts read: * First Steps in Flex: 6 Screencasts Available * Disintermediation * We No Longer Need Power * Google Chrome Changes the Game * Upside-Down Examples * Podcast Interview with Linux Outlaws * Specs Without Tests Are Meaningless * Thinking Upside Down * Know Your Materials * Business Rules of Thumb * Inventing a New Kind of Business * Meta-Reframing * EuroPython Keynote Video Available * The Cathedral and the Pirate * What I Learned at EuroPython
Notice that the next distribute release will have py3 support. Should be released in a week or so. That might help a bit for py3 adoption
That's great news! Thanks for working on this!
Interpreted languages are run by feeding the script into a given interpreter. Put the right script into the right interpreter and all is good. This is the same for all interpreted languages, Perl, Python, Ruby, etc. I don't think the perl monks can be "a bit cleverer" in this regard since it's not a language design issue. It's simply a matter of how you set-up and manage your own environments. And I work with a bunch of Perl programmers (and help them install junk) and Python's Buildout kicks-ass on CPAN (the client, not CPAN the repository). 
why not use [scrapy](http://www.scrapy.org)? edit: also, using shell commands like curl is horrible (and reminds me of my perl days). why not use pycurl, which interfaces directly with libcurl?
Well technically Silverlight apps *can* run out of the browser, but I haven't enabled it for this app. Definitely in the browser at the moment. FTFY
Availability of Moonlight or not, this shouldn't be written in Silverlight....
Warning: encourages mindless loss of productivity. :) The code is by no means pretty. It was hacked up over about 30 mins to the point where it worked.
 for meh in lst: I like your choice of variable names.
Nice, I approve of this.
Ha - you go write your own then.
This is great, hope you don't mind if I add this to my IRC bot.
Hmm, not working ATM. 2009-09-17 19:45:07-0500 [OmegleBot,client] processing next! 2009-09-17 19:45:07-0500 [OmegleBot,client] next! 2009-09-17 19:45:07-0500 [OmegleBot,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/start&gt; 2009-09-17 19:45:07-0500 [HTTPPageGetter,client] connected: "S76tzH" 2009-09-17 19:45:07-0500 [HTTPPageGetter,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/events&gt; 2009-09-17 19:45:07-0500 [HTTPPageGetter,client] onconnect 2009-09-17 19:45:07-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/start&gt; 2009-09-17 19:45:07-0500 [HTTPPageGetter,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/events&gt; 2009-09-17 19:45:07-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/events&gt; 2009-09-17 19:45:15-0500 [-] Starting factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:45:15-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:45:27-0500 [HTTPPageGetter,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/events&gt; 2009-09-17 19:45:27-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/events&gt; 2009-09-17 19:45:28-0500 [HTTPPageGetter,client] recvDone: got empty lst: None null 2009-09-17 19:45:28-0500 [HTTPPageGetter,client] therefore diconnectery 2009-09-17 19:45:28-0500 [HTTPPageGetter,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/disconnect&gt; 2009-09-17 19:45:28-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/events&gt; 2009-09-17 19:45:28-0500 [HTTPPageGetter,client] ondisco 2009-09-17 19:45:28-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/disconnect&gt; 2009-09-17 19:45:45-0500 [-] Starting factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:45:45-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:46:15-0500 [-] Starting factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:46:15-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:46:45-0500 [-] Starting factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 19:46:45-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/count&gt; Any ideas?
Looks like it connected ok, but the person immediately disconnected? This is very common on Omegle if you don't say "hey I'm hot lets cyber". Try it in a test channel, typing "next!" a few times until someone says hi. Did the IRC side of things connect to your channel correctly?
The IRC channel connected fine. I'm getting a lot of connections. The problem seems to be that omegler is never sending feedback to the channel. It never says, for example, connected to 1 of whatever. The last one I tried, there was a lot of typing events and message received events, I just saw nothing in the channel.
I have the same issue as he does. 
I've tarred up my simplejson + twisted libs with a copy of the script. Try running omegler.py directly from the extracted directory: http://localhostr.com/files/1b64c1/omegler-bits.tar.bz2 I'm using Python2.5
I wouldn't bother with twisted unless you have something that really cannot be fulfilled effectively by some other combination of libraries., especially if it's not an enterprise-level project. too much pain.
Ah yes, the Twisted's "aggressive documentation requirements". What a load of crap.
[Still nothing.](http://www.ubuntu-pics.de/bild/25022/screenshot_083_G3AEO2.jpg) Python 2.5.2.
Aha! You need to add '#' to the channel name: `$ python omegler.py nick hostname \#channel` I've added an assertion to catch this in pastie.
Per the other guy's problem, make sure the channel name on the command line starts with a '#'. I've updated pastie to catch this.
See, what you do, is use Python to speed up your non-Python projects. Doing a Java or .NET project? Use Python to generate repetitive CRUD screens and/or data access routines. Or, use it to automate system administration tasks that work on a variety of Windows (and possibly *nix) servers without resorting to a mixture of very ugly batch files and/or non-portable VBA/Powershell scripts. Python - It brings joy to a developer stuck in the statically compiled tarpit. That's all I know.
Oooo. Uhm. Are those Pastie themes available for emacs? I'm liking Sunburst (Josh) a lot.
Yep, so do I. it works, but it keeps stopping HTTPClientFactory. 009-09-17 21:12:54-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/send&gt; 2009-09-17 21:12:54-0500 [OmegleBot,client] redct!redct@chat-solu-95D49DBC.dsl.austtx.swbell.net #iasc- omegle omegler next omegler 2009-09-17 21:12:54-0500 [OmegleBot,client] processing next 2009-09-17 21:12:54-0500 [OmegleBot,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/send&gt; 2009-09-17 21:12:54-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/send&gt; 2009-09-17 21:12:54-0500 [OmegleBot,client] redct!redct@chat-solu-95D49DBC.dsl.austtx.swbell.net #iasc-omegle omegler next omegler 2009-09-17 21:12:54-0500 [OmegleBot,client] processing next 2009-09-17 21:12:54-0500 [OmegleBot,client] Starting factory &lt;HTTPClientFactory: http://omegle.com/send&gt; 2009-09-17 21:12:54-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/send&gt; 2009-09-17 21:12:59-0500 [-] Starting factory &lt;HTTPClientFactory: http://omegle.com/count&gt; 2009-09-17 21:12:59-0500 [HTTPPageGetter,client] Stopping factory &lt;HTTPClientFactory: http://omegle.com/count&gt; Not outputting anything.
Thanks, works great!
You could ask him, [he's on twitter](http://twitter.com/dreamer3)
So, if you had two of these talking to each other.... edit: this would be really easy. have one bot prepend the others name to the IRC send command, and vice versa. also, in the ondisconnect function, add `self.doCommand("next!")` to force a reconnect.
I put mine in my /cgi-bin/ folder. Mark it executable, with #!/bin/python as the first line, and at the very top (first thing executed) print out an HTTP header. Then just access it in your browser.
Hah.. I've thought about this: after an idle period fire up 2 clients and connect them, and allow anyone who might be lurking in the channel to randomly interject messages to either side of the conversation or take it over. The downside of that would be waking up in the morning to an IRC backlog *full* of spam. It would be great to watch though. Edit: you do realize of course such plans are completely evil. Just because its anonymous doesn't mean its not a form of wiretapping. :)
Or join `#reddit` in irc.freenode.net. Liven the place up a bit :)
Yeah, exactly. I set this up for a minute, realized it was probably a federal offense, and killed the bots.
This is fucking amazing. Kudos, and thank you!
it works!!
I also made some changes that were interesting. One, I removed the omegle prefix restriction so the entire channel was live with the poor person. Two, I changed it so it prefixed the message to the omegle person with the nick of the sender. This proved to be most fun as people would suspect shenanigans and not conceive of how they could be talking to more than one person.
This has nothing to do with Word.
Any place where we can see this bot in action? Also, if your channel is getting boring, try xkcd-signal. There are less people than before, but it's still awesome.
Misleading title, but useful article on using Python for OpenOffice automation. Something similar could be possibly done using VBA in Word.
If OpenOffice was so nice, they would make it much easier to create OO.org calc function with Python. I was surprised when I looked up the process that it was so involved.
Having looked seriously at scripting OpenOffice with Python these past few days, I am amazed by the documentation: it's a maze of confusing little pages, all alike. :( You have a humongous API documentation, full of tiny interfaces and hundreds of links, and light on comments. You have a dev guide, focused on objects ("this object can do this and that"), but not on tasks ("how can I get the current selection"). So you can see that what you want to do is feasible, but you spend hours piecing it all together. As far as Python goes, it's still quite rough. No editing in OpenOffice, no debugging either, cannot embed macros in documents, and the log infrastructure described in C:\Program Files\OpenOffice.org 3\Basis\program\pythonscript.py does not appear to work on Windows. :( That said, it's still cool, and here are a few useful tidbits: - You should put your scripts in Documents and Settings\&lt;user&gt;\Application Data\OpenOffice.org\3\user\Scripts\python, rather than in the system wide scripts dir (unless of course you want to make a global install). Modules, apparently, have to go in Program Files no matter what. - The most important page: http://udk.openoffice.org/python/python-bridge.html Read it fully and carefully, and go back to it often, it will save you many hours - The API root: http://api.openoffice.org/docs/common/ref/com/sun/star/module-ix.html - Most script start by accessing the [Script Context](http://api.openoffice.org/docs/common/ref/com/sun/star/script/provider/XScriptContext.html) - A few pages from the Dev Guide: [Spreadsheet Documents](http://wiki.services.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Spreadsheet_Documents), [Spreadsheet Document Controller](http://wiki.services.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Spreadsheet_Document_Controller), [Conditional Formats](http://wiki.services.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Conditional_Formats) By the way, the examples in the documentation are in Java, and the Python equivalents are so utterly more legible (no translateInterface() crap) that it almost makes one forget the pain of working with said documentation. Example from the bottom of [Conditional Formats](http://wiki.services.openoffice.org/wiki/Documentation/DevGuide/Spreadsheets/Conditional_Formats), translated to Python: from com.sun.star.beans import PropertyValue from com.sun.star.sheet.ConditionOperator import GREATER // get the conditional format object of the cell range xCellRange = xSheet.getCellRangeByName("A1:B10") xEntries = xCellRange.getPropertyValue("ConditionalFormat") // create a condition and apply it to the range aCondition0 = PropertyValue() aCondition0.Name = "Operator" aCondition0.Value = GREATER aCondition1 = PropertyValue() aCondition1.Name = "Formula1" aCondition1.Value = "1" aCondition2 = PropertyValue() aCondition2.Name = "StyleName" aCondition2.Value = "MyNewCellStyle" xEntries.addNew((aCondition0, aCondition1, aCondition2)) xCellRange.setPropertyValue("ConditionalFormat", xEntries) 
Nice. I taught a Python class for a few years myself at a local high school. Good times. Try [GotoSSH](https://gotossh.com/). It's just a ssh in a browser, like what RightScale or CloudKick does in their interfaces. I was going to suggest using netcat as well, but I couldn't find a decent webified telnet program. Basically you'll ssh into the box. You could set up an account who's shell is the program to run. FWIW, I'm hacking on the Try Ruby code a bit to get it to make AJAX calls back to arbitrary methods in Python, which returns HTML or JSON, depending. Works like a regular shell, but is mapped to functions in Python. In theory you could wire it up to redirect popen's output to the browser... 
Moonlight is not SilverLight, why do people try to act as if it is.
For me, the issue with Twisted is the camelCase ;). 
Why have a separate usage? Just use whatever the doc string of main is.
Too late. I've been reading through source code for last few days and I got to tell you -- if I wouldn't try to write an async coroutine framework before I would be completely lost. But now I think I know what Twisted is about. There are two things I hate tho: naming conventions and too much abstraction.
Moonlight is an implementation of Silverlight, why on earth are you trying to pretend it isn't? *duh*
This is hilarious. Thanks!
Ha! Moonlight got a killer application! Of course you can also try to implement this using JavaScript, client-server connections and a shared, global namespace which can be polluted by everyone ( we are all brothers and share our stinking socks, aren't we? ). Very inspiring work and excellent implementation! Next we need a killer app for JavaFX :) *Edit: o.k. I checked it with Moonlight 2 and the only killer was the system monitor I used to terminate Firefox. We still have to try even if it's not Python ;)*
haha IRC = multiplayer notepad
No. Vnc + notepad = multiplayer notepad. You can't erase other's text in irc.
[yourworldoftext](http://www.yourworldoftext.com/)
No, [Etherpad](http://etherpad.com/nothisis) == multiplayer notepad
Hmm, still not working for me. Running Python 2.6.2, it seems to connect but I can't actually see the bot join any rooms. Nor can I /whois the bot. It seems that it's announcing that the connection is made, and that it's trying to join the room, before it even finishes connecting to the server.
I approve of #xkcd-signal. Haven't been in in awhile, but on the odd chance the channel gets off meta-discussion, it's pretty interesting.
Well.. if each one is better it's fine, in the end we can end up with some perfect solution and have it incorperated (or ported) into the stdlib
Some IRC daemons swallow the initial JOIN message. I hacked it so that it just waits 5 seconds and sends another, so you could try adjusting the delay in the line starting "reactor.callLater(5, ..." to something higher. If it still doesn't work, upload output to "tcpdump -s0 port 6667 or host omegle.com" to localhostr.com.
My next website will be filled with "hello world" pages. Beat that Google!
There is a bug in the Moonlight 2 Preview version that prevents it working. It should be fixed in the next release of Moonlight.
http://www.mediawiki.org/wiki/API http://www.mediawiki.org/wiki/API:Client_Code#Python Why not just use the Wiki API and not deal with HTML? I have not actually read anything about the Wiki API.
Upping the delay worked, thanks. I think it took longer than 5 seconds to connect. This is very amusing but people sure like to disconnect quickly on Omegle. edit: I don't think things are working correctly, because after 20+ attempts no one has said more than one sentence... are you sure it's not misinterpreting a disconnection somehow?
You could always do: &gt; re.match(r"&lt;div id="bodyContent"&gt;(?P&lt;content&gt;(&lt;div[^&gt;]*?&gt;.*?&lt;/div[^&gt;]*?)?.*?)+)&lt;/div&gt;", data).groupDict()["content"] (I just wrote that regex off the top of my head so it probably has some errors) Alternitively you could look into BeautifulSoup (http://www.crummy.com/software/BeautifulSoup/) NOTE: reddit's formatting thing is putting indentations instead of the "*"'s that are needed in the regex... user beware!
Try having a few conversions on Omegle proper first. Yeah we thought it was buggy too, but that's just Omegle. If people are asking "m/f?" before disconnecting then that's completely normal, especially if you reply "m". Again if you still thinks its borked send me a tcpdump :)
Regular expressions. I seriously need to learn about them one day.
Well, what I think is bizarre is that the Omegler will assume that an empty response is disconnecting. What if there is an intermediate state wherein you don't receive a response but that doesn't necessarily mean disconnect? (I am sort of talking out of my ass here because I've not tried a tcpdump yet.) Also I tried saying "LET US CYBER" and whatnot and people still wouldn't stay, hahaha.
too bad they're just slides
matlot: link to related text and code is http://bit.ly/pytalk
Beautifulsoup works nicely. Now. I found the root of my problem was urllib. I assumed it would work with wikipedia but when I just checked I saw a lot of GET errors in it's html output. Just tried it with pycurl. It's more verbose but it's working. According to lxml, beautifulsoup is slow which is why b'soup is a fallback tool which they call soupparser. I'll see if I can get get-element-by-id() to work.
Too bad it's not python3. :)
How did you do the first part (even the second if you've still got it around)? :$ I was trying, but I've been a while out of code and when I thought I had it worked out, I actually stopped next! and all functionality. I was just dealing with the privmsg function, so I didn't think I was ruining that much! EDIT: I got both working, god am I stupid. :$
Looks interesting. I've tried all the major Python GUI toolkits and none are as pythonic as I'd like. Hopefully this catches on. I wonder why they're using the old win32 libraries for Windows though. Something a bit more modern would probably make things a lot easier for them.
So functions is a class in Python? How cool is that!
Remove the if statement that checks for the msg to be prefixed with the bot's name (in privmsg), and pass msg directly to doCommand or whatever rather than slicing it. For the second part, I added a parameter to doCommand and related functions that takes the nick of the person doing the command, and just pre-pended that to the string sent to the Omegle person. the actual nick, removing hostname and mask, can be found by calling nick.split('!')[0].
:P Thanks for your help, I ended up getting a bunch of fun variants to work.
Thanks for the idea, I implemented it! [irc://irc.mountai.net/#omegler](http://tinyurl.com/omegler)
... I think I just got IP banned from Omegle, haha.
Well my point was that it's really running in Silverlight (which happens to be in a browser). It's certainly not running on my browser (which doesn't even have a Moonlight plugin).
Why not just use Traits: http://code.enthought.com/projects/traits_gui/ -- it's pythonic. See docs here: http://code.enthought.com/projects/traits/docs/html/TUIUG/index.html
OpenOffice is shit.
second that
The thing about this implementation that makes it funny is one side will disconnect and reconnect and the other side still thinks they're talking to the same person. I've been watching two reconnecting bots talk to each other for a while and it's really funny to have someone change their asl halfway through the conversation.
Not to mention this is based on PyObjC 1.x for OS X, which OS X ships with 2.x now, which could likely mean breakage. I'll have to try this tonight.
The difference is, you bright spark, that versions of windows are 99.9% backward compatible. Unlike a .py script, which may or may not run against your python runtime, and that .py script will be unable to identify what dialect of python it is written in. 
I really liked JP's [intro](http://jcalderone.livejournal.com/47954.html) for serving up static content from the command line: twistd -n web --path /tmp
That "age = msg = ..." thingy is imho not perfect but rather distorting / confusing. It's just used to give age some dummy value to make sure it fails every time, the value is abitrary as long as the condition holds. Sort of "exploiting" that you have to set the message for another reason to enforce this strikes me as just wrong. And what's the big deal with break? Just because that's sort of a jump it isn't intrisically bad. The only objectable thing is (as mentioned) that you throw the condition into the loop body, but beyond that it's the fast and direct solution. And returning / breaking out of something (function, loop) when you're essentially done instead of coding this into the (loop) head / doing crufty if/else constructs for to have one single return point in a function just for the sake of it seems to me to be the better way in general.
that's what i came here to ask. thanks mate.
Someone needs to make an emacs plugin that works like this.
I approve of this channel
Break isn't always evil. Now messing with the stack etc, that's a whole other level of malpractice.
He said it's not Silverlight, not "not an implementation of Silverlight".
cause it's more elegant to write c in c or asm in asm; however, a css python generator is likely
Compiling to JVM or .Net CLR is probably more useful than generating C.
even if the C code was cross platform? why would jvm or .net be preferable?
In a sense, that's what unladen swallow is attempting to accomplish. It's basically a plan to add JIT to python. It's not quite what you're calling for, but it gives 90% of the performance benefits you'd be looking for.
['shedskin'](http://code.google.com/p/shedskin) does that, somewhat. Dynamic languages though are always looking at the type of each value, _every time it's used_. All that extra work costs speed, and throws away a lot of optimization opportunities. Python uses C underneath to do everything anyway, so it already is compiled (somewhat), except what's compiled is the flexible, dynamic language (or layer of code) that is Python. Shedskin, above, requires that the Python be statically typed. Also, Jeremy Siek's compilers class writes a Python-with-types compiler for the course. Unfortunately it all seems reset, for another year :) But maybe you could get in touch with former students of the course or something. 
Because the byte code is for these VMs is auto-optimising for each individual platform it runs on. It also makes calling the libraries written in that byte code much easier.
I called it perfect because it's the only one that: a) Is not longer than the "usual" solution with break b) Doesn't repeat things (like having two raw_input calls) c) Works d) Doesn't use anything "evil" like inspect of Infix OTOH, it's pretty non-obvious
yeah but virtual machines are slow compared to c. the reason for wanting python to generate c is for speed. i would like to write a program in python because of the freedom and syntax, and then have it convert that program to c to be compiled. i know what i'm asking would be incredibly difficult, and some parts (like type inference) near impossible, but wouldn't it be something worth pursuing?
Compiling to VM bytecode is not only much much easier, but also much faster in many cases. But, sure, it would be great. Go ahead and try if you think it can be done.
very cool, i've never heard of this project.
i don't know enough to try anything so bold, but maybe one day :)
you can also use one of these [methods](http://www.scipy.org/PerformancePython) if performance is your main concern.
Take a look at Pyrex/Cython.
As an English-speaking Java programmer, that hurt my head. But the humour was still evident. :)
I tried to translate as much as I could stand. It's very boring for a post that long, specially translating code :-(
&gt; yeah but virtual machines are slow compared to c. Be careful with blanket statements like that; they're not always correct.
I must admit, I got drawn into this as if it were some sort of epic drama.
Blanket statements are *never* correct.
Also see: * [Cython](http://www.cython.org/) * [Pyrex](http://wiki.python.org/moin/Pyrex) * [RPython](http://morepypy.blogspot.com/2008/01/rpython-can-be-faster-than-c.html) (that's not a very good link explaining it, but you'll get the idea, it's from the Pypy project).
why do so many beginning tutorials use ipython instead of idle, or just python? this doesn't add anything to the lesson and i think scares people off that you have to download 10 packages to get python to work the way *I* want it to.
I'm sure it will in the end - I also was aware of using Moonlight **1.99**. Now I deactivated the plugin for not getting trapped. I really do appreciate your work but I don't see the constraints and ramifications yet. For example I'd like to see a wordpress plugin featuring interactive Python documentation. An author can upload a Python script which gets evaluated within Silverlight/Moonlight and objects are examined in the shell you've written. All tutorials could become interactive sessions. In my own case I'd contribute a particular Sphinx directive for another type of doc. Writing arbitrary documentation becomes some sort of literate programming. I find all of this very exciting.
Thank you for doing the translations - it was a fun read.
Maybe http://scrapy.org/ will work? I've never used it but it seems to be just the tool you need.
Maybe http://scrapy.org/ will work? I've never used it but it seems to be just what you need. Also, as for urllib not working (btw, you should use urllib2); its probably because wiki uses heavy mirroring and load distribution and urllib isn't dealing with the redirects. I think that URLLIB2 has the ability to follow through though.
could you give me an example of a virtual machine that's faster than c?
&gt; OTOH, it's pretty non-obvious This argument is why I feel like it's okay to use break (as long as you're not creating madness) - I want my code to be as obvious as possible. In this case it's most natural to say "Keep doing X until Y". I don't think it's as natural to say "If not Y, keep doing X", because (as in this example) the motivating factor is X, not Y. That is, Y is a result of attempting X. When I see X, I can easily infer Y; but to see Y first confuses me until I see X. To translate it to this example, I can tell exactly what your original code does - it gets input, then validates. In the case of the "perfect" example, I can't look at just the while loop and tell what is going on. I have to make a project of figuring out why "age" might not be a number. Of course, this is a trivial example, as raw_input is but a line below; but in a bigger project this is no longer as easy. Edit: There are many cases where "If not Y, keep doing X" will make more sense - such as pausing a thread until work has arrived. But that doesn't always apply, especially with actions like validation.
Like so many things, it depends. Keep in mind that VMs have a huge secret weapon: C/C++/etc. usually only undergo static, provable optimizations at compile time, while code running on a VM can undergo dynamic, heuristics-based optimizations at runtime. This opens up whole new classes of tricks for speeding up execution, and means that the relative "slowness" of running on a VM will depend heavily on the quality of the VM and the type of code you're running on it. And FWIW I expect that in the not-too-distant future, the big, well-known VMs will be consistently matching and beating C for speed; there's just so much extra stuff they can do that it's hard to believe they'll sit still.
i guess i just don't have a good enough understanding about how virtual machines work. i was under the impression that *by definition*, because they are emulating a CPU executing on a real CPU, the code that runs on them cannot be faster than code that actually runs on a real CPU (except in limited cases)
&gt; i was under the impression that by definition, because they are emulating a CPU executing on a real CPU, the code that runs on them cannot be faster than code that actually runs on a real CPU A virtual machine must, at some point, generate actual native code for the hardware on which it runs. The question, then, is whether it can take advantage of the additional information it has (runtime profiling and heuristics) to generate _better_ code than a static compiler which must emit that code in advance with no knowledge of what the runtime usage looks like. One useful example is the JVM: Java has classes with virtual, overridable methods, and so when a method is invoked the JVM has to determine which class' implementation will actually be executed and then go execute it. This is, superficially, not too different from what, say, C++ does: you set up a vtable for each object with pointers to the methods, and when a method on an object is invoked you follow the pointer to the method and execute it. If your C++ compiler can _prove_ that, say, in the line `someAnimal.walk()` the variable `someAnimal` will always be an instance of `Horse`, then it can do some optimization to avoid the overhead of method resolution. But if it can't prove that, you're stuck with the overhead. The JVM, on the other hand, has access to runtime information. If it sees `someAnimal.walk()` called a thousand times, and every time it's a `Horse`, then the JVM can start applying runtime optimizations: it can create a fast path directly to the `walk` implementation on `Horse`, for example, or JIT that method body to native code or even inline it. And if `someAnimal` eventually is some other type of object, it can fall through to normal method resolution. In such cases -- and such cases are common enough to take notice of -- the JVM's runtime optimizations can easily introduce enough of a speedup that it starts beating the equivalent fully-compiled C++. And cases like this are why I'm fairly certain that good VMs will be consistently matching and beating C and C++ in the future, and anecdotally why I'm pretty sure they already are in some cases. *Edit:* [this article](http://blog.headius.com/2008/05/power-of-jvm.html) describes the same thing I've outlined above, and a bit more about the tricky things that "slow" virtual machine can do to your code.
that was insightful, thanks :) one last question, do the heuristics required to do those runtime optimizations not incur some kind of overhead?
I'm wondering why [Psyco](http://psyco.sourceforge.net/introduction.html) hasn't been mentioned yet. It's probably the most widely used Python JIT compiler.
Cheers about urllib2. I just tried it but I keep getting *unhandled HTTPError*. It's hard to figure out what exactly the error is. [edit] Using URLError exception I find out i'm getting 403's
Depends. If it only takes you 5ms to work out and apply an optimization that shaves 10ms off execution time, you have a net saving of 5ms.
Converting Python to C would likely result in crappy C code (as implementing all Python's "dynamicness" in C would be complicated), which would probably result in code not much faster than regular Python.. Most of the time, the Python interpreter will not be the bottleneck - having it compile to C will not help crappy algorithms better, or make network requests faster.. The typical way of writing fast Python code is - write it all in Python. Profile it. Determine where the slow parts are, and rewrite that into a C module.. [Cython](http://www.cython.org/) makes this (almost) as easy as writing regular Python code, and the [regular Python C API](http://docs.python.org/extending/index.html#extending-index) is nice enough to use also
For even fairly sophisticated text based games it would be capable of running them *in the browser* - not needing any server side integration with the security and performance / load implications that come with that. Actually a very good option.
If you need multiple checks (never hurts having range check for user input) with their own error messages, you'll end up using "break" anyway. It might be a bit ugly but it's still the clearest solution. PS: there's a small typo in Pablo Zilliani's version. age = "%r is not a number!, %s" % (age, reset) should be msg = "%r is not a number!, %s" % (age, reset) 
Oops, fixed, thanks!
Bad news for sheep farmers.
Anyone know how it compares to Beautiful Soup?
What a waste of time. Using break is just fine - and pythonic.
Looks better to me, I really don't like Beautiful Soup, I found it pretty difficult and annoying to use.
Where be that thar place Sire?
I think it was. Additional dramatic effect is produced by the feeling of impending doom, like if the whole thread is spiraling down to the inevitable wreck and everyone tries to postpone that by producing more and more ridiculous solution, knowing that it only makes the disaster (when someone recites Python's motto) worse.
Looks really good, but unfortunately most of my scraping is done to automate crappy intra/extra-net services, which means I need http proxies to work, with authentication. Oh, and https too. Is there anything out there that does this? Currently I have put together a half-assed solution with bits and pieces I found on the net that fixes proxy authentication and https, but in a pretty crappy way..
He said in *the* browser, not in *your* browser...
That's being a bit disingenuous. It's sort of like saying "MS Office 2007 in Linux" and then giving an article about VMWare.
The big difference is that scrapy has also a crawler part. If you really want a good, fast parser better look at lxml IMO.
Uhm... wouldn't try: age = int(raw_input('How old are you?')) except ValueError: print "Not an age!" be more pythonic?
if you put the whole thing in a while loop, i think that would do quite nicely (almost as nice as 'break' IMHO) However, it *can* be problematic at higher nesting levels, so you'd have to possibly use a lexical closure to get it working.
Wait, what was a federal offense?
wiretapping?
http://doc.scrapy.org/faq.html#how-does-scrapy-compare-to-beautifulsoul-or-lxml
How is this wiretapping?
http://www.law.cornell.edu/uscode/18/usc_sec_18_00002511----000-.html 
Well, it was all in fun. Noone expects the inspect or Infix versions to be used in real life.
I'm confused - so what this bot does is 1) Initiate a conversation on Omegle 2) Log onto IRC 3) Pass messages between parties who don't realize they're talking to each other.
Well, my theory was to connect two of the bots via IRC, with the ability to interject messages to either side. surely this falls under that law.
I'm not sure how legitimate a concern that is. People on IRC already know that everything they say is logged, and people on Omegle surely know that they're going to be logged anyway.
How is it like that? Try Python can run in any browser capable of running Silverlight or Moonlight 2. That's most (by user numbers) however you spin it.
It's common practise in Python code to check Python version and use conditional imports where necessary to support multiple versions of Python. This technique is possible with 2 and 3, but a bit harder because of syntax changes.
Not quite the same thing, but I wrote a fractal program called Gnofract 4D (http://gnofract4d.sf.net/) in Python, which generates C code to do the fractal calculations then compiles it &amp; loads it on the fly. 
Ya, "while True" is the Python idiom for this type of stuff. That said, they were probably just enjoying themselves all along.
You'd have to put the break right after the assignment to "age." I prefer the isdigit() version in this case because it is more explicit and takes less knowledge to understand. It's not immediately obvious to everyone that the whole int(raw_input(...)) construct can only rise a ValueError if the user types something else than an integer.
You could have said the same thing for quite some time already by replacing Silverlight with ActiveX. It's still the most in user numbers.
 age = None while age is None: try: age = int(raw_input("How old r ye? ")) except ValueError: print "Don't fool around!" A little implicit, but look -- no break. And what do you mean `ValueError` source is not obvious to everyone? It's obvious to everyone who ever used `int()`. edit: `while` condition.
Silverlight runs in Firefox and Safari (and soon Opera I think) on the Mac and Windows. Moonlight 2 on Firefox on Linux. That's not true of ActiveX - but you know that, you're just trolling.
Does this supports python 3.x?
[I know!](http://www.reddit.com/r/programming/comments/9mc5y/pycuda_lets_you_access_nvidias_cuda_parallel/)
Dear everyone who wants a Python do-loop: while True: #do { something() ... # } until if not cond: break Done.
cool, but why he can't put the particle effect pics on web site just as the demo pic?
ahh python libs... is there anything you can't do ? 
Finally, an access to real database from python!
And it's pure/share nothing, since you can not modify Workbook in place! For reading you need to use `xlrd` and you can not do incremental changes, but rather have to save entire workbook anew! (On serious note: I'm using both libs at work and well -- it's better than VBA if it's enough.)
Wait, what? A VM is another layer of abstraction between the program and the host operating system. It's a sandbox. Running a monitoring daemon of some sort if the VM is compromised makes it easy to automatically restore from backup if something happens.
spam
I asked a Stackoverflow question regarding this, ["How would you design a very "Pythonic" UI framework?"](http://stackoverflow.com/questions/58711/how-would-you-design-a-very-pythonic-ui-framework)
The [screenshots](http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/screenshots.html) are from OS X 10.4
Software Carpentry logo can dance.
It's a good library. Needs a little bit of wrapping for CSV-like interface (keys, rows, etc) and to make using some weird stuff like dates/times easier. But once you put those wrappers in place, it's a great library. Check out its complement: xlrd
I didn't know it works like that... what needs to be done to make it work in windows ?
I use appengine on all of my projects, It's a great platform, and yeah, you have to write additional code to deal with datastore, but, it's worth it...
Can you really complain about someone else's tech when you can't get character encoding right in your own blog? �_�
Depends on how full a port you're after. 1) GUI is in GTK+, which I believe works on Windows, but some tweaks might be required. 2) C++ code uses dl, pthreads, a few more unixisms like / for path separator 3) You'd need a C compiler available on your Windows box. If that behaves differently from gcc the generated code might need to be altered. Could use cygwin/mingw or cl.exe, I guess. 4) tweak command-line to run the Windows C compiler. If you're volunteering I'll happily take patches :-)
Doesn't look like it's worth it.
Cygwin is obsolete. If you are "forced to use Windows although Linux so much more user friendly" then you can use [andLinux](http://www.andlinux.org/) which just works and can be installed without a hassle in a Windows partition. BTW Python comes with an own shell and if you hate to write batch files on Windows or don't believe the shiny new Powershell can hold waters ( yes, it can ) then on gods name, download [pywin32](http://sourceforge.net/projects/pywin32/) and use it for Windows automation. 
The performance of their 'memcache' is particularly interesting. It's so slow, it's hard to believe it's actually a memory cache. 
From my own experience it's faster than he describes. His performance table claims 80 hits/sec for both a read and a write, and he later claims 100 ops/sec. Writes cost significantly more than reads, though, and scale up much slower than reads in most real world applications. When measuring reads, my own performance hovers closer to 800 hits/sec. Higher when billing is enabled (his performance tests seem to have been performed within the free quota restrictions). EDIT: Missed the row in the table where he measures reads alone. My own experiences are still much better, though.
My talk from Google I/O 2008 about scalable webapps provides a much faster example of how to implement counters: http://sites.google.com/site/io/building-scalable-web-applications-with-google-app-engine App Engine scales very well, but some things that seem trivial with MySQL must be implemented differently (e.g., counters). Please also see my other talk from Google I/O on offline processing, which includes a vastly scalable counter implementation: http://code.google.com/events/io/sessions/OfflineProcessingAppEngine.html
The problem with memcache is that App Engine pickles and unpickles everything you put into memcache, and App Engine doesn't have cPickle! This means that the pickling and unpicling process hogs your CPU badly if you put big / complex datastructures into memcache.
I didn't know what TG is and the linked article didn't say either.
Agree! In the global village you use Unicode or get pointed &amp; laughed at. Edit: Firefox detects ISO-8859-1, Chrome seems to default to UTF-8. He doesn't specify encoding in HTTP header or in &lt;META&gt; tag. Also, no HTML entity escaping ... here goes quirks mode
I personally am leaning more and more towards lowering development time - I don't want to have to deal with random database failures every 100 requests, preferrably, I don't want to have to deal with databases at all. I also don't want to have to implement my own full-text search. I just want to be able to implement as many things as possible in as short time as possible. I run a few apps that go up in around a million hits per day every now and then on an intel x86 in my closet. If any of them became twitter, I would definately consider hosting it with some cloud provider, but until then, it stays in the closet running fast, easy to develop, no-nonse software.
I've seen your article before writing this article. This was not an example of a counter application. This was a read/write performance test to show some of the GAE issues (or peculiarities). GAE scales indeed, I am not declining that, but Datastore calls still take 100-200ms, and Memcached calls still takes 10-20ms. This makes it hard to implement most of real web applications.
Well, I am sending encoding header only when you switch to Russian language. Personally, I do not see issues with English text with default character encoding - it works since I've implemented it that way 8 years ago, and noone yet complained that one cannot use my site. I will consider to move to unicode with PHP 6 (hopefully next year). I do care to have things working. I would prefer to make it perfect, but this is not a requirement in a real world.
Don't blame me, [I write all my new modules for Python 3](http://repo.cat-v.org/snake_steak/).
[Efficient model memcaching](http://blog.notdot.net/2009/9/Efficient-model-memcaching), I haven't actually tried this out yet - but it should solve the problem for entities.
Conslusion -&gt; Conclusion I was going to make fun of your grammar, then realized you speak more languages than me and kept the snark to myself. Nice profile shot at the Hong Kong hotel.
As a counterpoint, forcing exception processing into your code from the beginning is a big win when (not if) your datastore randomly goes away in the middle of the night. At least if you've planned for it you'll display an Oops page and not random stack traces. 
This is not a sole memcached test. These are http calls, not memcached calls. Memcached have 10ms latency on google-s own tests. Probably I was not waited long enough to have my app distributed among more nodes.
Thanks for the typo, fixed. 
This is what I don't like. I am not sure I can trade rock-solid reliability for scalability which I don't need (I am quite far from 10'000'000 hits when I would need it).
Yes, I have read that, but that doesn't really address the pickling problem, just how extra bad things are when you put Model's into memcache. The only solution so far is to put strings, and do your won serialization / deserialization.
&gt; This might be awesome solution for “homepage” with some photos of your cat with rare changes and 0 maintenance and cost. Made me laugh.
&gt; Personally, I do not see issues with English text with default character encoding - it works since I've implemented it that way 8 years ago, and noone yet complained that one cannot use my site. ѓдвСЮЩУС ЮХ вСТЯдСХд, авЯнХ кСЫвйди. њСоХЭ ЩгЫСди авСзЩЬиЮеР дСТЬЩУе ЫЯФЩвЯзЫЩ ХгЬЩ е СздЯвС веЫЩ гЬЩлЫЯЭ ЫЯвЯдЫЩХ одЯТй ЩгавСзЩди авЯгдеР авЯТЬХЭе?
I'm not sure I agree with this assessment of Google App. Engine. I know for a fact that Best Buy is using it for some of their website's functionality. Maybe its the difference between the free and the paid version, but Best Buy certainly doesn't seem to see any issues with Google App. Engine.
You win :-) Now it says ISO-8859-1 in headers. Back in 2001, no one had idea that there will be Google with their own browser defaulting to UTF-8 :-D
I'm soooo impressed. Everything is better in sets of 10. 0\. Profile. (ZERO BASED INDEXING I AM A PROGRAMMER) 1\. Use C. 2\. Don't write unnecessary code. 3\. Use a better algorithm. 4\. Use a better algorithm. 5\. Use a better algorithm. 6\. Use a better algorithm that uses less memory. 7\. Here's an idiom that'll help you use less memory. 8\. Use the idiom to use less memory. 9\. Use list comprehension (yay, Python specific optimization) The big points in Python optimization are: * **Profiling**. Do not optimize code you have not **profiled**. * Do not optimize if you can use a better algorithm instead. * Avoiding the for loop in favor of map or filter if you can pass a native function, or list comprehension if you can't. * When you do need a for loop, avoiding dots by grabbing a local scope reference to functions you'll be using a lot in the loop. * Clever tricks to get rid of if statements can also help. I had a method that would do something only the first time it was run. We don't need to execute `if firstTime: ...` every time the method is invoked. We can instead write the method to do that initialization, and then replace itself with a method that skips all that stuff. See example. * When all else fails, optimize by rewriting the bottleneck (it's probably a for loop) in C. class StupidButLetsFaceIt_EasierToUnderstand(object): def __init__(self): self.firstTime = True def importantmethod(self): if self.firstTime: self.firstTime = False print "first time!" print "other stuff happens" class Clever(object): def importantmethod(self): print "first time!" self.importantmethod = self.__replacement self.importantmethod() def __replacement(self): print "other stuff happens"
I was there for the second one and watched you live, but it's good to see it again just now! :)
Also Django is a nightmare on AppEngine. Wait till you see how sessions work on there. (admittedly, django's sessions system blows)
Actually it was my Firefox that defaulted to UTF-8. Thanks, looks a lot better now. :-D
&gt; I'm soooo impressed. Everything is better in sets of 10. it's not about you. Seems like a reasonable article otherwise.
Everything is a class instance in Python. Why wouldn't it be?
&gt; I'm soooo impressed. Everything is better in sets of 10. &gt; 0. Profile. (ZERO BASED INDEXING I AM A PROGRAMMER) Originally, the zero index was there because it's preliminaries, and not a full-fledged issue. The same applies to the second point, which is why it's numbered 0.5. Things like that amuse me at 1 am. After I finished writing the issues, I wrote the number in the title. &gt; Use C. No, that's not what I wrote. &gt; When you do need a for loop, avoiding dots by grabbing a local scope reference to functions you'll be using a lot in the loop. That's a nice optimization that's covered in the basics. If you actually read my post, my recommendation is to do that only after you tried getting rid of the loop altogether. &gt; Use a better algorithm. &gt; Use a better algorithm. &gt; Use a better algorithm. Most of the issues are there because I found out these are *concrete* things you can do to improve your code. I tried to give actual examples based on my experience. &gt; Use list comprehension (yay, Python specific optimization) That was a joke. I even wrote "kidding!", if someone should have a hard time understanding.
This guy is fairly clueless about app engine. I have a non-trivial app on app engine and I just ran httperf from my laptop (saturating a cable modem) and got 91.5 requests per second with 300 simultaneous connections (no errors, etc.). Sometimes the first request after a deploy takes an extra second or two, so my guess is that he's doing a very small sample of requests and factoring in that initial slow request. Also, the scalability model of app engine is not that it's ultra fast per request but that it scales well horizontally. As for his critique of datastore reliability, surely it would be nice to eliminate the occasional failed request, but those are an artifact of the scalability design and there are easy work arounds (such as retrying a failed datastore operation again or using transactions :P ) I think the best thing about app engine is that the trade offs and constraints are laid out up front so you can build your app using some very solid, proven practices. If you are comparing app engine to an installation of django/mysql on your laptop and wondering why app engine is slower for some things, you should probably just stick with your laptop for a while until you realize the difference. 
Because performance and character encodings are totally comparable, right? I propose that anybody that has ever done anything wrong in their entire life never gets to complain about anything else, ever. ;-)
You may not have intended it to be, but your example application _is_ a counter, and as a result you see the expected issues with non-sharded counters: By updating a single entity in every request, you're essentially serializing all your requests.
How does Django's session system blow?
That was also my first impression. After scanning a bit, it appears to be "Turbogears". Unfortunately, I stopped reading after hitting "but seriously". _Thanks, up until now I thought you were being unbiased **AND** serious. Now you tell me this has all be a farce? A lie? My worldview of your article is shattered. Good day sir._ Or something like that... it only took an instant.
I guess what annoys me so much about this post is that it's called "10 Python Optimization Tips and Issues", but none of it is Python-specific, and most of the points are the same and all are common sense to anyone with a CS degree. Many actual Python-specific optimizations are not intuitive. It can be a difficult language to squeeze performance out of. My examples were based on experience too. Sometimes better algorithms are not available and then you need to trick the interpreter into doing less work.
'using it on part of their site' != 'having no issue with it' I'm sure a site can build some useful things on the app engine. As they could with django+EC2 or rails+rackspace or any framework out there. That's not the question. The interesting question is how easy is it to get it to do what you need and what trade-offs do you need to make. 
 from __future__ import braces
You are mostly right. However: 1. While 'use a better algorithm' is considered general good optimization advice, it's not too constructive. Happily, Python has the required data-structures built-in, and I can tell people "instead of nested loops, use sets". This might seem obvious to you, but I've found out it's not to a lot of people. 2. I didn't name it 'the 10 rules of python optimization", but just "10 python optimization tips and issues" for a reason :) I started out with a list of things I've seen people encounter, and went from there. 3. Your point: "algorithm improvements are exhausted, it's time to do Python specific optimizations" My point: "Python specific optimizations are exhausted, it's time to do algorithmic improvements" Rinse and repeat, both. I believe we are in agreement :)
no seriously import this do it.
&gt;are common sense to anyone with *a CS degree*. Yeah.
Yes, yes, it's a lovely list of thoughts. Good advice for any language. Py3: import antigravity
Please allow me to toss in this reminder... The First Rule of Program Optimization: *Don't do it* The Second Rule of Program Optimization (for experts only!): *Don't do it yet.* 
I have an app engine site which runs Ruby (on Java). It handles 5000 connections per second without blinking.
Good thing you fixed it. :-) [Mojibake](http://en.wikipedia.org/wiki/Mojibake) happens to more people. If I would be really nit-picky, I could say that your use of the ellipsis (byte value 133) technically means that you're using [Windows-1252](http://www.columbia.edu/kermit/cp1252.html) and not [ISO-8859-1](http://www.columbia.edu/kermit/latin1.html), but so many people use these interchangeably that not a single browser in the world doesn't display ISO-8859-1 as if it were Windows-1252. The only difference between the two is that ISO-8559-1 leaves 127-160 undefined. (... half an hour later ....) I should probably make a proper submission out of this, but I learned a lovely German word: [Óechtringen-Namenschreibungsuntersuchungskomiteerechtschreibungsprüfer](http://www.columbia.edu/kermit/utf8.html) which means something like "Óechtringen name spelling research committee well-spelledness checker" :-)
Life is about trade-off, programming too. You get very neat characteristics with App Engine but everything is not shinny. If your AppEngine application is dead slow read the doc, watch the Google IO talks, do caching (with the protocol buffer method described in this thread), go ask on the app-engine mailing list or ... give some money to Google and I'm sure they're gonna help you make your app faster (there's no such thing as free lunch)...
I understand that. But read-only speed isn't impressive too.
Huh, I thought Scrapy actually used lxml, but apparently they use their own libxml2 bindings. That seems odd and unnecessary.
They've been using it for experimenting with stuff on their site, I don't think it runs the main part of the site. Talking to them, they've certainly had issues but they've avoided so many other issues entirely (e.g., deployment) that they are feeling pretty happy with it. I think it's that there is a *different* set of problems on App Engine. If you don't care about the things you have to deal with in a more normal environment, or don't pay attention to all the stuff you can skip over when using App Engine, it'll seem like a loss. Focusing too much on scalability will keep you from noticing many of the other benefits of the platform. I think one of the guys at Best Buy noted that when App Engine went down a few months ago, he could just have another cup of coffee and relax a bit that morning, safe in the knowledge that there was a group of people at Google panicking on his behalf to fix the problem.
1. The first rule of Program Optimization is, you do not optimize. 1. The second rule of Program Optimization is, you DO NOT optimize. 1. If someone says stop, goes limp, taps out, use a profiler. 1. Modify one bottleneck at a time. 1. No guessing, no hacks. 1. Profiling will go on as long as it has to. 1. If this is your first night at profiling with python, you have to use import profile;profile.run("any-python-expression")
The [original](http://www.greenteapress.com/thinkpython/html/)
Does all profiling happen at night?
[ecl](http://ecls.sourceforge.net/) (a common lisp implementation) goes that way: lisp code is compiled to C++ code, and afterward compiled with your local c++-compiler to machine code and executed. Especially nice, if you like to embed into a native c++ environment. 
and cue "why didn't they use Twisted" posts now 
I was about to say the same, but their use of yield-statements makes for very readable code. I can imagine much more rapid prototyping with this than with Twisted.
Hardly. You're missing the big reasons why cygwin is used.
with @inlineCallbacks you can do pretty much the same thing with twisted
İ just read the documentation, the example code feels more pythonic
Take a look at gevent library. It is a succesor to evenlet and has C-coded libevent loop instead of the pythonic one in diesel, twisted
I really want to like gevent / eventlet, but the documentation for both is a mess. Worse, the source tree included all kinds of experiments / dead ends so that I was never sure what constituted the "official API." I understand that gevent is an effort to clean this up, and I appreciate that. The developers behind Diesel (and Tornado, and [Concurrence](http://opensource.hyves.org/concurrence/) ...) at least make an effort to put up a decent web site. Time will tell if any of these efforts manage to build a community.
One can argue that the monkey patching that eventlet does makes for more readable code... There's no 'yield' required by the developer. The socket API is wrapped/patched; you just use the socket API as before and anything therein that would block is wrapped with a yield. That's at least my (probably broken) understanding of it. It's not exactly documented well.
define "weird"...
I can use regex out of the box in AWK /my_pattern/ { print "found" } You have to compile regex in python.
Well the argument last time was more "why didn't they fix Twisted"
That's if you want your code to look like blocking code. I have been an advocate of this in the past, but I think that since we now have a natural language construct for non-blocking operations (i.e. yield w. return semantics) - then making that behavior apparent in the code might be A Good Thing.
&gt; You have to *compile* regex in python. Oh really? Try this: if re.search('my_pattern', input_string): print 'found' You do not *have* to compile a regular expression in python. 
ermmmm... no unittests?
&gt; The Python programming language is a loosely-typed language. What this essentially means is that any variable defined in a program can be assigned a value of any type. The opening sentence seems dangerously wrong to me. Python is strongly typed but dynamic as far as I understand.
Originally said by [Brett](http://mail.python.org/pipermail/python-dev/2009-September/092021.html).
Correct source code URL http://github.com/ctb/pony-build
[looks remarkably similar to 'cogen'](http://ionelmc.wordpress.com/2008/03/27/cogen-python-coroutine-library-intro/) and or [kamaelia](http://www.kamaelia.org/Home) Although the idea to hide the complexity of asynchronous IO behind using co-routines is nice, There is a specific problem with their kind of appoach. The problem is that python generators (hence all the 'yields' in the Diesel examples) are not really co-routines and are also not composable like normal function calls are... The trick of suspending the current generator when it needs to wait for IO only works at the first call-level (e.g. when your generator is called directly from the IO/event scheduler). But what if your generator itself needs to make a sub-call to some other 'blocking' component (memcache, mysql driver)?. Then you run in to the limitations of Python generators, e.g. they can only yield to their direct caller. The database driver would not be able to yield back to the scheduler when it needs to wait for IO.... The only way to do this is using proper co-routines which are available trough the greenlet module or by using stackless. [Concurrence](http://opensource.hyves.org/concurrence/) uses this approach. 
Actually, you can yield other generators, so a whole "generator stack" is supported; you can yield calls to client objects that work on a different socket stream, yield event notifications that wake up unrelated generators, etc, and do any of this at any depth on the "generator stack". So, in diesel at least, those limitations don't exist. (diesel author)
I can't test that now, but does it work? Python dispatches method calls from the class not the instance. 
The README says "Kumar suggests that I just use Hudson for chrissakes. He's probably right". I agree with Kumar. Titus says Hudson would be a problem on some platforms snakebite would build on (snakebite is Titus's big, open build matrix project) due to the JVM requirement, so he's creating an alternative I don't think creating a whole new buildbot system from scratch is worth the effort, instead of just maintaining JVMs on a few obscure platforms
what about a call to database?
I'm having difficulty comprehending these concepts into practice. Care to point me to examples?
I like what I see, but I have so many blocking libraries that I have to call from my application. So, don't take this as an attack, but what are the good alternatives in multithreaded/synchronous/blocking world?
I can't tell you how it works, but it works exactly as it should.
I'd appreciate that too. It's hard to see how you can work around the token coroutine nature of generator coroutines, to allow such general uses (unless cumbersome custom boilerplate is required)
Interesting, might make a nice prototype for a multiproc based rewrite.
I like the code, but Nagios already exists. DRY.
Well this sure looks like an excellent way to get banned very fast.
sounds like you want regex literals in Python. As it happens, so would I! It's just syntax though, they're really not so different to any other implementation and I wouldn't describe them as "weird". AWK is a special-purpose language. Kinda fun, but hard to compare with other languages. Your example implies an "if" that would be there in almost any other language.
It works. Here is the explanation: For regular functions this just changes the reference. For methods, it works like this: When you do: bla = some_instance.some_method You get a bound method in bla. That means that the first argument of some_method is bound to some_instance. Now you can do bla() and it is equivalent to SomeClass.some_method(some_instance). When we do some_instance.bla = some_instance.some_method later references to bla don't cause rebounding, as bla is now a regular member pointing to a bound method. Hope this explains it for you. (Note: in some more complex (and rarer) cases involving destructors, this might cause a memory leak, as now you have cyclic references: some_instance -&gt; some_instance.bla -&gt; some_instance (via bounding). If this becomes a problem, consider using weakrefs)
Old style classes, naming convention from Java.
This might be, but then every function in your call-stack will need to be a generator yielding either a result or another generator. Every component (database driver, memcache driver etc) will need to be written this way. It will be 'yields all the way down...'. Also note that this whole generator stack needs to be unwound whenever you need to do a 'context-switch' to the scheduler because you hit a point where you need to wait for IO. Then when the IO is finished you have to resume all the generators in this stack so that the work can continue... Compare this to Stackless which can suspend and resume a stack of execution just by changing a pointer to the next stack... (e.g. proper co-routines)
Been using this all morning, seems to work well. The git support was broken, so far as I could tell, but I think I fixed that. Anyway, check it out.
That's sweet. are the other scans quicker as well, like cargo scanning/ship scanning? 
I never tried.. the main idea is to show all the information returned by the server, not just the parts they want you to see ;)
404 :(
I really like the look of this. I'm an academic, so almost all of my coding is self-use. This means I want thin interfaces that are quick to write and trivial to extend. This is a good solution!
that looks like something you could get "quite" banhammered for :)
I think the best strategy for new projects at the moment is to try to write as 3.x-compliant 2.x code as possible, and port later.
You'd think they would only return stuff they want you to see.
I did not even know that this module existed!
I would think that by returning everything and filtering it client-side you save on some server-side processor time which I imagine is quite valuable.
A friend of mine ended up working for them after doing this sort of thing, many years ago. They dropped him during one of their purges because obviously someone like that isn't trustworthy *eyeroll*. Their loss - I'm told their security is still pretty feeble. During his time there they even had arbitrary code injection from client to the server; given the server can execute arbitrary code on clients, you can imagine the possibilities with that.
Yeah my own experiments with the client also discovered that the security in the EVE is pretty terrible. I imagine it's only a matter of time until EVE or WoW or something has some sort of epic code execution disaster.
Unittests? They have a benchmark putting them above Tornado!! That's all that is needed ;).
Yep, it's generators all the way down. It's the style you'd have to embrace to work with diesel. That I admit. Nope, you don't need to unwind it. The generators are popped onto a list to simulate the stack, and when the "current" generator returns a request for IO, the "reactor" immediately exits waiting for an I/O event. When that I/O event takes place, the current generator resumes. You don't need to go back up the stack until that generator exits. And yeah, I've played with stackless a lot (and I like stackless), but it has its share of disadvantages as well. Everything has tradeoffs.
How's it like working for them? He should do an IWasA.
While I can't speak for disaster, the WoW devs do routinely prune the WoW LUA api of functions and events that have led players to automate too much. It was always their philosophy that if you could do it with the in-game macro and LUA functionality, you were in the clear. Back in the day you could automate movement from scripts and automatically cast spells on people, etc. Nowadays it's a lot harder to do that sort of thing though.
This is a good question, and this kind of encapsulates the chief concerns with Async IO. For example, "How can I use this with SQLAlchemy (or insert synchronous library here)?". You'd almost have to mark the asynchronous calls with a yield statement, then thread the call in the back: def getdata(): data = yield synccall(dbcall, *args) This would allow you to block the getdata thread of execution, defer the call to a planner, then resume this function when the data is ready. I am not sure if there is anything like this (or if this is similar to inline callbacks), but this would be a reasonable solution to the problem of combining async/sync styles. That said, magic would have to ensue to gain the advantages of epoll or kqueue on these calls. Perhaps the library could introspect the sockets, set them up for event loop polling, then call the api function when the data is ready, if the request and receive are separated. I am beginning to ramble here, but diesel looks decent compared with some of the other frameworks. I would like to see a solid wsgi container, http client and some method of yielding on synchronous calls.
Generally you have to completely avoid blocking calls. This doesn't mean that things like SQLAlchemy can't be used, however. SQLAlchemy itself doesn't make any blocking I/O calls. It relies on the underlying database client library (e.g. psycopg2) to do that. One strategy you mention is to spawn a thread for blocking calls. The other option is to write a nonblocking API for your database of choice and use that instead of psycopg2. We tend to prefer the latter. Using diesel's generator syntax, nonblocking libraries can be made to work with libraries like SQLAlchemy without requiring too much modification, and, as you mention, you get all the benefites of epoll/kqueue. Right now there aren't any publicly available nonblocking database clients for diesel, but I think there will be soon.
Right now there are some good examples in the source: http://bitbucket.org/boomplex/diesel/src/tip/examples/ More complex examples are forthcoming.
we've been using Python Daemon in production for about a month now. No problems at all, nice work.
From the penultimate slide: 2009Q3: in progress * 20-75% faster than Q2 If they hit that then that's gonna be pretty fast seeing as they hit a 15-20% boost in Q1 and then a 10% in Q2.
Are there videos from PyCon online somewhere?
Nagios can be a bit much.
Sorry, I was thinking of this: &gt;&gt;&gt; class A(object): ... def method(self): ... print("First time, one time.") ... self.method = lambda: None #Notice, no self ... ... def __call__(self): ... print("First time, all the time!") ... self.__call__ = lambda: None ... &gt;&gt;&gt; a = A() &gt;&gt;&gt; a.method() First time, one time. &gt;&gt;&gt; a.method() &gt;&gt;&gt; a() First time, all the time! &gt;&gt;&gt; a() First time, all the time! &gt;&gt;&gt; a.__call__() &gt;&gt;&gt; You can change methods on the fly, but not `__call__`s.
I was thinking of changing the `__call__` of an instance dynamically, which can't be done in the same way.