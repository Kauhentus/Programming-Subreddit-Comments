Variables global by default? 1-based indexing? Having to type "end" everywhere? No thanks.
&gt; Q: What's the difference between a Ruby on Rails developer and a large pizza? &gt; A: A large pizza can feed a family of four! You have evidence that that is true? Or are you just looking for some easy karma? Because here I have my cousin who start a Ruby on Rails only company here. Now he has about ten developers and can surely feed family of four.
Do you feel undervalued if you are doing the work that was originally done by 4 people alone? Or has the scope of your work changed along with them being laid off?
In NYC, I've seen server-side Python anywhere from $80k to $120k.
$50/hr in NYC.
That article is pretty old now. Python is not what it used to be. Haskell is the new Python in this context :-)
The UI looks native to your OS though. Plus you can customize or derive a new class from any of the base widgets to look however you want.
On a Mac it's not even close to native looking. 
I'll be impressed when there's a C64 implementation, even a partial one.
This looks pretty native to me - http://2.bp.blogspot.com/_5N4Jto8F8q8/SvqQI09alyI/AAAAAAAAApQ/OyLs6So6baQ/s400/wxEasyGUI_Form_on_MacOS-X.png I guess it depends on the application though.
The microcontrollers I work on have about 128 bytes of ram, so not even python-on-a-chip can save me :P
&gt; I feel similarly about PyGTK, it's probably great if you have used C GTK. PyGTK + Glade combo has gotten better in the past couple of years, for what it's worth. I'm still annoyed at the size of the classes I need to build for a proper PyGTK application, though. Inelegant.
&gt; Glade was the tool that enabled me to do my first serious GUI application, and then several trivial ones. Ditto here :)
Take a look at `convert_files` function. It should take no more than 15 minute to whip up `render_to_response` that feed through this.
Yes, in a Cthulhuesque way. 
You must have seen my comment below, so you know I'm keenly aware of this. I would add that it's much better to be a pedant than to be pretentious, which is what people are when they try a fancier way of saying the perfectly fine phrase "raises the question." I don't know what sense of "correct" you mean, but I like the continuity that _historical_ correctness safeguards. The funny thing about this polarized prescritive-descriptive discussion is that both are equally "fascist", in one case you tell people how to speak and how not, in the other you are censored. I believe there is some kind of (pragmatic) middle road, where good arguments are heard and where some people are looked at with more (natural) authority than others -- in fact I believe that this is already the case.
well i don't know if this helps but i work in django and here is a nice forum... it's pretty basic http://code.google.com/p/django-forum/ but it works.
Did you consider a possibility of a telecommuting job?
£250-£400/day contract
There is one based on web2py (runs on gae too) http://www.pyforum.org/
That looks hideous and is obviously not native, maybe I'm too picky.
OK, but what about a family of five then? The best evidence for truthfulness of a joke is its ability to strike someone's soft spot, which in this case might be some sort of an insecurity about performing commercially equal to fellow programmers - this is what this joke is about, not the size of family one can feed. Now, Python/Ruby jobs might be harder to find than, for example, .Net ones - just run a search on random job postings site. Former developers being the geeks of programmers' world, I can see how this joke was made up by bullies to pick up on the geeks.
Cool! Can you reveal any details about what is it you do? And how often do you have contracts like these? Occasionally, I'm having side projects and they are better paid than my main job, but I'm getting them only like once a year.
Well, Python didn't seem to change at its core (if anything, it has become only better equipped with libraries and frameworks). What do you think *did* change? The fact that Python is no more esoteric, the Python community, or the state of computer science?
It's not *obviously* not native, but true enough, to OS X users, there's something that doesn't feel right. The problem is that these widget libraries make their stuff look *just enough* native so that non-OS X users can't tell the difference, thus leading to crappy-looking apps on OS X.
The writers of Grim Fandango and World of Warcraft disagree with you.
http://code.djangoproject.com/wiki/ForumAppsComparison http://djangobb.org/ 
Mostly large business applications with web front-ends plus some systems integration. Most contracts run from 2-6 months, there is plenty of work around although not all of it is python specific.
I recently wrote about [bootstrapping Python projects](http://robescriva.com/2010/06/16/bootstrapping-python-projects/) on my blog. It doesn't really discuss architecture best practices, but does give a good foundation (that I've discovered through much trial-and-error) for starting a new repository for a larger application including: * Documentation using Sphinx. * Testing using doctests. * Coverage of all tests. * Distributing with docutils. I know this will probably be lost in the noise, but I think it may help you with everything up until the point you must decide how to structure your code.
STEVE SAID NO!
Consider, yes. Found, no.
Even high end micrcontrollers only have something like 64kb of internal SRAM. So regardless of the size you will require external dram to run tinypy. Like sk1p pointed out, if you are looking for python on a microcontroller python-on-a-chip is seems like a much better option. The other question is do you even want to run a scripting language on an embedded system. The first thing I thought of was that it might be neat to have a python scripts to controller robotic platforms. For high school students, and maybe some first year students it would be useful as a teaching tool as they would learn how to program with a real language and see something more then just text output on a screen. 
The fact that Python is no more esoteric
&gt; OK, but what about a family of five then? What evidence do you have that Rails programmer have a hard time feeding their family? &gt; The best evidence for truthfulness of a joke is its ability to strike someone's soft spot. Soft spot doesn't necessary means it's true. Say, I make racist joke about all black people being crack addicted criminal, does people responding to it means it's true? If a joke is evidence about anything, it's evidence about how the poster is a jerk. 
wikipedia can.
wikipedia can.
wikipedia can
Most forum software has software to migrate from vBulletin. Your success with that might vary. If you just need a regular plain jane forum, I would pick a popular piece of software. Also, popular forum software usually has programmers who have made easy to use mods. If you do want gratis and Open Source, [ForumMatrix's](http://www.forummatrix.org/) wizard can give you some options (and tell you the programming language). The only one FM that is Python is [GroupServer](http://groupserver.org/). One obvious question, does the hosting have Python support? Many of the basic shared host packages only have PHP.
One of the biggest killers for me was the lack of documentation. A lot of the docs relate to using code to construct the GUI, then the rest is about libglade. Nowadays, I understand that GtkBuilder is best practice. The docs are largely from something like 2005 and it shows. Googling for answers wouldn't be so bad if I was more of an expert in GTK. If someone really overhauled the docs, I think it'd probably be pretty good. That said, I could say something similar for PyQt. &gt; I'm still annoyed at the size of the classes I need to build for a proper PyGTK application, though. Inelegant. I really agree about this kind of thing. When you think about how easy other things are in Python, GUI programming seems like a real chore.
[Release Notes](http://www.jython.org/latest.html)
They usually offer Python through CGI.
From my own experience (I have never done GTK in C/C++) the docs are quite okay if you find a couple of tutorials which teach you about how to get started with exporting from Glade as a GTKBuilder file and then tie that into Python/PyGTK. PM me your e-mail address and I'll send you the tiny little PyGTK app I did on Friday. It's very basic and should get you started.
Tried google yet? http://pyforum.org/
oh, sorry
Nah, they're just "normal" (although very good) Python programmers. They're working on the infrastructure of an exchange, but their title is programmer not architect. They *are* doing 'just' Python, although with the usual mix of sql, bash and a bit of C. Well over 90% Python though. I've been asked to apply for (and declined) similarly highly paid jobs working directly with traders. High stress job (and long hours), but very well paid. They were often interested in the skills combination of Python and C#. I was working with Python in London up until November last year. Now I'm contracting and working from home; more money (than I was on previously - which was considerably less than £100k!) and no commuting.
Speaking about crack, did you also feel offended when (if) you saw that scene from Office Space where software engineer poses as a former crack addict selling magazine subscriptions and then confesses to make more money this way than he did as a programmer?
Heh, the proper fix is for them to decode and *actually* work with characters...
We (SpiderOak) use snapboad: http://code.google.com/p/snapboard/ If you give it a try, we've got some patches that extend it's functionality a bit that haven't yet been integrated upstream. Feel free to mail me about them.
Here are some simplistic examples from my school: http://www.cs.umbc.edu/courses/undergraduate/201/spring10/lectures/classes.html#(1) http://www.cs.umbc.edu/courses/undergraduate/201/spring10/lectures/graphics_1.html#(1) Although very simple, they lead up to a really cool project where the students draw recursive fractals: http://www.cs.umbc.edu/courses/undergraduate/201/spring10/assignments/proj_recursion.shtml
Can't go wrong with the classics! **Inheritance**: class Animal(): def sleep(self, hours, is_dreaming=False): # code goes here class Pet(): def __init__(self, owner): self.owner = owner class Dog(Animal, Pet): is_flearidden = False is_mongrel = False breed = "border collie" _____ My favourite **polymorphism** example is booleans-as-integers, because you don't confuse the issue by introducing custom types/classes it should be intuitive to understand that True=1, False=0, and everyone knows that computers use 1s and 0s. Example; &gt; Problem: I have a tuple\* of votes (either True or False) called all_votes, and I want to know the majority/winner (tie goes to False). How can I do this quickly? The students will probably suggest a function with integer counters. &gt; Solution: number_of_trues = sum(all_votes) if number_of_trues &gt; 0.5*len(all_votes): majority = True else: majority = False Then explain the first line - they should understand that the `sum` function is typically applied to a numeric type, but you're using it for a boolean type (how can this be?). \* NB: A set would be more appropriate container type, but using a set incorrectly hints at a set-theory-based solution (eg, calculating majority using intersections or differences).
I'm currently teaching 10-12 year olds Python in order for them to make their own graphical games within a week. So far it all works out. Today I taught them about OOP. Not in a theoretical way, mind you, but in a completely hands-on way. I first showed them a simple Pygame window with a bouncing ball and went through the code with them. This is all the stuff you already taught yourself (if else, variables, etc). Now, obviously children want shit to get real. How do you make two balls? Obviously, copy all the checking we have in place for the first ball and so on for another. They will acknowledge that this is very tedious for lots of balls. At this point I taught them about classes and how you can put them into a list and iterate over them. They immediately caught on and in no time we had 150 balls in our small pygame window. Why not make a visual example yourself? It is great for trying out things.
Big upvote here. I just found djangobb the other day, and I remember the pain I went through looking for a forum just a year ago. djangobb looks clean and easy to use, so while I haven't used it yet myself, I'd definitely point you in that direction. You could also look at Pinax, but it's a reasonable departure from the "forum" norm.
GRATZ!
PythonWin/PyWin32 is still included; but we recommend that users pick Komodo (or Komodo Edit which is open source) as a Python Editor or IDE. IDLE is also included (idle.bat or "python -m idlelib.idle"), but just not in the Start Menu.
This sounds like the right way to do it. Don't teach them "object oriented programming". Teach them what a class is, and that it's often useful to use a class. Teach them a tool, not a paradigm.
I'm glad you pointed out examples. I agree that these are a valid use of this technique and it clearly provides a simple implementation for this multi-dict. However, though it may not matter in this case, the check for int and long excludes other types that might be a valid index into the list.
I have written plenty of functions like this, but its usually ends up like [this](http://xkcd.com/292/).
I've actually found this to be a great technique, typically ending up with methods like `from_foo` and `from_bar`. &gt; Instance / type checking just seems never to be the right way to go in python. And they have compounded this with deliberately ugly syntax ;).
I agree with you, and should have been more specific about this in my initial comment. You can accomplish a lot by worrying about which methods and attributes an object supports rather than what it is. In the OPs article, he used the `MultiMethod` object to dispatch methods to handle a dict or a list. But what if I want to give it an object that supports list and dict methods, but isn't a subclass of either? It won't work at all.
&lt;sarcasm&gt; This is because python is just a scripting language and java is a full-featured programming environment. &lt;/sarcasm&gt; ;)
I just finished up the first link you gave and I have to say it's quite excellent; I have a background in computer programming but it was still very informative and well done.
I do hope my /s was understood (:
Thanks a lot man! those links are amazing! 
That must be a great experience, I like your idea! At the end of the course we will hack on the sugar platform, programming educational apps/games for the olpc, thanks for the help.
No problem, good luck. Just make sure that people see an immediate use in the concepts.
It's popular to jump right into subclassing, type theory, categories of objects, etc. In my experience this has no relation to actual OO programming, where things like subclassing either require a significant amount of intuition to predict up-front (which you can't expect from a student) or it's something you add during refactoring. I'd be apt to skip subclassing and just focus on the idea of class, object, object as the container of data and class as the container of associated routines. The most common way *I* find to identify a what should be an object is to look for the same set of arguments to a bunch of functions -- that argument or set of arguments becomes "self" and the functions are methods. And... personally I'm not really sure if it makes sense to teach theory first, or just introduce the mechanisms, ideally using examples that are relevant to previous things you've done. At least in the case of recursive functions I think explanations always end up making things harder, but I haven't thought about it a lot with objects.
I want you to teach me Python.
I want you to teach me to teach my kids py.
I am fully aware of that -- since I pushed it at my workplace I ended up creating shortcuts to idle.bat on systems where it's installed. I still have no clue what is the point of PythonWin thought -- it's actually worse than IDLE for interactive editing.
First object that made me get OOP. A stopwatch object. It's a simple object with timeElapsed variable and start/stop/reset methods. I used it to time different sections of my procedural code and I immediately understood the power of OOP.
I did this same thing with University students (Artists/Designers) teaching them OOP in [Processing](http://www.processing.org) and it works really well. Bouncing ball code, make them copy it out a few times and then show them classes and how we can build an array of balls. You can build on that codebase in further lessons too, adding subclassed balls, interaction, more physics or whatever you want really. I'm no expert but I think the trick is making them realise something is broken (endless copy pasting) and then showing them a way to fix it that makes sense and that they've possibly had the glimmerings of thought about for the past 5 minutes anyway.
Sorry but I have never seen Office Space before. But if taken from context, no I would not feel offended. And to be clear, I used Python/Pylons/SA commercially and only checkout Rails in addition to other technology to keep myself updated. But I hate this hatre toward Ruby in Reddit community in general. It's alot more baseless than PHP hatre and make Reddit looks like Digg. Hell, I would also react if one claims PHP programmer have a hard time feeding his family, too. Talk technical hating the language all you want, but baseless claim like that really? Or may be if there is at least little concensus or context may be it would help. What can you give me a couple blog or link that people usually think of Rails programmer as not making income? Even black-people-is-criminal joke do have some background.
&gt; class date_range_query(object): &gt; def __init__(self, start_date=datetime.now()): &gt; &lt;initialize&gt; &gt; @classmethod &gt; def from_string(cls, start_date_string, **kwargs): &gt; start_date = datetime(start_date_string) &gt; return cls(start_date=start_date) Ahh, I see. I agree in this particular use-case that is prettier code :) Good catch with the `@classmethod`, I have written `from_*` "patterns" like these myself as well, but not always thought to make them class methods. However, this only solves the constructor problem, what if you're overriding `__getitem__`? Sure, you can make extra methods like `get_*` or `by_*` to get around having to type-check, but Python doesn't explicitly allow you to override `__getitem__` and mess around with `slice`s for nothing, right? For example, take the following code, it's from a class that manages recorded WiFi data, as a list of `Entry` objects that have a `datetime` timestamp and a `str` SSID. I wanted to be able to access and slice and dice and query this class either by ordinal number (`int`, the 523rd recorded `Entry`), or all `Entry`s with a certain SSID, or with a `slice` of two `datetime` objects to get all `Entry`s in some interval. So I ended up writing this code, which is riddled with ugly typechecking `if` statements. But on the other hand, it's incredibly cool that you can write a class that lets itself be indexed this way, and as I said, Python doesn't allow you to override `__getitem__` for nothing, yeah? def __getitem__(self, key): if isinstance(key, int): # get the 523rd Entry return self._list[key] elif isinstance(key, basestring): # get all Entry's with a certain SSID return WiScan(self._dict[key]) elif isinstance(key, slice): # get all Entry's in a time period start = key.start stop = key.stop if isinstance(start, datetime): start = bisect.bisect_left(self._list, start) if isinstance(stop, datetime): stop = bisect.bisect_right(self._list, stop) return WiScan(self._list[start:stop]) elif isinstance(key, Entry) and key in self: return key else: raise KeyError(key) 
I love how you effectively equated art students to 12 year olds.
If you were to teach art appreciation or sculpting to the average programmer, you would probably have to do the same. They're two different skills. Sure programming is creative but not until you get to a certain level of proficiency. Just as with art. You can't expect n00b artistes to have that heart-to-hand link the first time they pick up a paintbrush.
In fairness, Python 2.6+ supports Abstract Base Classes in such a way that you could make something called `AbstractedDuck` class and anything with a `quack` method and a `swim` method would automatically be identified by `isinstance` as a subclass of `AbstractedDuck`, whether the author of that class has heard of AbstractedDuck or not. That ability makes this more practical. So, instead of checking for `isinstance` of `dict`, you can check for `isinstance` of `collections.Mapping`, which will identified even classes that aren’t really subclasses of `dict` as being `dict`-like if they register the right methods.
I know I know. I wasn't trying to criticise you, just thought it was quite funny.
The best way to teach OOP is by deconstruction of patterns. OOP has no sense in it's form. Start with observer pattern, is the most fun. It helped me a lot learning OOP this way because it makes more sense.
start with metaclasses, don't let their heads rest
Python Programming: An Introduction to Computer Science by John M. Zelle, Ph.D. I think this should be the textbook
I always start with a PID, and have an Arduino board so newbies can see "result"
"artistes"
You could make a function that has a list of balls and iterates over the rules for each ball instance. But obviously making one ball and replicating it is much cooler.
&gt; They're two different skills. Paul Graham is really dead on reddit, isn’t he?
Please link to something like release notes or the homepage instead of directly to the download next time.
[Great paintings, for example, get you laid in a way that great computer programs never do. Even not-so-great paintings - in fact, any slapdash attempt at splashing paint onto a surface - will get you laid more than writing software, especially if you have the slightest hint of being a tortured, brooding soul about you.](http://www.idlewords.com/2005/04/dabblers_and_blowhards.htm)
Thanks. I'll have a look.
Thanks. Looks like there are some options, at least.
Thanks. But the project kind of looks dead...
&gt; Most forum software has software to migrate from vBulletin. Your success with that might vary. If you just need a regular plain jane forum, I would pick a popular piece of software. Also, popular forum software usually has programmers who have made easy to use mods. Thanks. I though as much. Unfortunately they're using an old version of vBulletin and have no money to pay for a newer one. Also the free shared hosting that they used went off the air without warning and they only have partial backups and no one to talk to. I know the guy in charge and it kind of went "Well we need some one to code us a new site and you want web programming experience, why don't you do it for free and we'll both win." &gt; One obvious question, does the hosting have Python support? Many of the basic shared host packages only have PHP. That question never crossed my mind. I see I have a lot to learn about web programming...
What is the meaning of all this?
arrivederci !
downvoto
oic
This is a pretty bad way to use patterns. I don't think anyone reasonable sits down and decides which patterns they will use during their design phase. Design patterns are common forms that occur in good code (or bad code, if we're talking about antipatterns), and they're things you refactor towards as you work. OOP principles (like encapsulation, and single responsibility) are fundamentally important to understand. Memorizing design patterns with get you nothing if you don't know why they're good and useful.
Upvoted for Processing :)
I am not a developer of pyforum. To my knowledge it is not dead but web2py has at least 3 different plugins to attach discussions to pages so most people use them instead of pyforum. Here is [one of them](http://web2py.com/plugins/default/comments). A simple complete forum with posts and comments would look like this: #in model db.define_table('post',Field('title',unique=True),Field('body','text')) db.post.id.represent=lambda id: A('read',_href=URL(r=request,f='read',args=id)) #in controller @auth.requires_login() def index(): return dict(posts=db(db.post.id&gt;0).select(),form=crud.create(db.post)) @auth.requires_login() def read(): post=db.post[request.args(0)] return dict(post=post,comments=plugin_comments('post',post.id)) views would be optional and would make things look better. EDIT: This approach works with web2py built-in authentication and can be easily be connected to facebook/linkedin/etc. for example, while I believe (but may be wrong) pyforum predated the new authentication modules of web2py.
In DFW, I make about $50/hour doing mostly Python work. I've been programming for about a decade now and I'm a pretty good C/++ programmer as well. If I lived in NYC or Silicon Valley, I'd probably have to be paid about an additional 50-60% to make it worth while financially.
It's a mistake to teach OOP to beginners.
I think it's rather a mistake not to teach it early on.
you just have to fight against paradigms.
I thought Python took list comprehensions from Haskell? In Haskell list comprehensions, besides "for" and "if", we also have "let", so we can do something like: [z for x in range(10) for y in xrange(10) let z = 100-x*y if pred(z)] In Python I emulate this with: [z for x in range(10) for y in xrange(10) for z in [100-x*y] if pred(z)] In Haskell, I can also have something like: [x if pred(x)] which is short-hand for [x] if pred(x) else [] I am not sure why it is forbidden in Python's list comprehensions.
&gt; Now, obviously children want shit to get real. quote of the month
How about [SvenHProgramming](http://www.reddit.com/r/carlhprogramming/)? :D
Note how they list the controversial stuff at the end or don't mention it at all: * the deprecation of the print statement. In most of the cases where you use print intead of stream.write(something), there's actually a reason for it. Making these cases uglier doesn't really help it. It's a thoroughly decent idea to have a print function in __builtins__ instead of a special bytecode; but I guess the 'nice' way to do it would be to leave the print statement (and maybe adopt Jython's modified syntax where you can access object attributes with the same name as a keyword (allowing something like self.is.print.not(), which would access attributes of attributes instead of complaining and is needed to access Java attributes with funny names) * Changing the default string type from "byte" strings (i.e. char strings) to "unicode" strings. With the buffer interface, we don't actually need byte strings, but every bloody time you read a file and want to get unicode strings out of it, you need to care about choosing the right encoding. And exactly those people who think that Unicode is a good thing will not be able to avoid a situation where (a) everything else than ASCII requires a lot of behind-the-scenes work, like Python2's default conversion mechanism between unicode and string, or (b) things depend on your locale settings, introducing subtle bugs when people suddenly use the Chinese Windows codepage instead of the UTF-8 and latin1 that you took pains to test for; this, of course, is how it is in Java, and despite the fact that N+1 people have to live with it, it's not quite what I want from life; or (c) you introduce a new type for bytestrings-with-an-encoding which can be smoothly casted to unicode strings whenever it's needed but yield a subtle combination of the headaches from (a) and (b). Some people complain about Ruby's string handling, which seems to be like (c). I find 2-5 pretty uncontroversial and could live with 1, 6 and 7. The string changes would require me to rewrite most or all of my code though, which means that I will not use Python 3 in the near future. Note that a past post from the list compared this with the Java 1.0-to-1.6 transition, which never broke compatibility with sources, to which someone said that there was no major number break in Java. Exactly that's the point. Lots of new features have introduced to Java, making it barely usable in 1.2 (with ArrayList and HashMap) and actually a workable alternative in 1.5 (with generics). Python also transitioned from the dark ages (1.4?) to 2.6 with only minor hiccups - the only incompatible change that I ever saw was the introduction of "as" as a keyword in 2.6 (since, of course, I had constructs like "for a in as: for b in bs: print a,b" in my code). Now we're all expected to make the transition to Python3000 (er.. 3.1) with, what exactly? The removal of multiple features with no great new things to be excited about is quite sure to repel anyone who has a seizable investment in existing Python2 code.
unfortunately, there was a wave of "Object First", which advocates for teaching OOP to beginners. Those who have done it know better that it was a big mistake. Those who learned OOP before or at the same time as procedural programming turned out to be very weak programmers. 
I'm not an an advocate of OOP any more than I am of procedural or functional programming. However, for some stuff, it *does* make a lot of sense and it simply comes naturally to do it the OOP way. For instance, games. Everything you see in a game can be described as a class so why not do it? I believe that visual stuff is the best way to get introduced to programming because it makes the concepts tangible. 
Java 1.5 to 1.6 has been a pain in the ass. A minor pain in the ass, but a pain in the ass nonetheless.
You can use games to *attract* people into programming (Agent Sheet, Alice, etc.), but I don't think it's a good platform to teach beginners to become serious programmers. 
And I still think it is. In game programming, you get to solve all kinds of problems and you get to deal with all groups of people. It requires you to have an extremely wide skill set and it is basically unlimited in terms of skill advancement. It involves most of the exciting things: graphics 2D/3D, maths, sound, architecture, network, debugging, profiling, efficiency, dealing with projects and people, packaging, dealing with feedback, cross-topic stuff like drawing and sound creation as well as game design as a whole which is a psychological topic. All things considered, I think it is a rather good choice. If by "serious programmers" you mean 9-5 code monkeys then this is indeed not the right approach.
As to your second point, Python 2 generally results in just pushing those issues under the carpet.
Most of the changes are painless except: the string issue, the except ... as, and the print statement. Almost all of the changes are purely semantic from the average developer prospective and none of them was motivated by the need to address the one major technical Python issue: scalability on multicore architectures. This is killing Python. Developer do not want to use 3.0 because they cannot find the libraries they need and do not want to use 2.x because it looks like this is the past and not the feature. Universities that have embraced Python 3-4 years ago are now thinking more about moving to Erlang, Clojure, and Lua. I only have anecdotal evidence perhaps somebody here has some data to support this thesis or the opposite. The only event that caused a Python bump was GAE but GAE uses 2.5. I really appreciate everything the Python developers have done and, from a technical point of view the move from 2.x to 3.x is a good one. No question about that. From a managerial point of view, it was a very poor a move. I am old enough to have seen a lot of excellent products sink businesses because they were not what users wanted. I'd hate see this happening to my favorite language. A language is a tool, it is not a goal. The goal is software you can build with it for the betterment of society. If the language becomes the goal it is no longer a solid foundation to build upon. Newton said he was able to look further because he was standing on the shoulder of giants. If the giants move too much it is hard to keep the balance on their shoulder. I still hope the core developers will declare this was an experiment and produce a 4.0 that treats strings as in python 2.5, understands "except ... as ..." as well as "except ...,...", understand print with and without braces, and includes all modules already present in 2.5.
(Or don't. Up to you. )
It is! 
That is a very cool name. I wonder if it was based off [Ferman/Firman](http://en.wikipedia.org/wiki/Ferman)
Glad to hear it! The woman who wrote the lecture has been teaching this course for about 15 years, and needless to say she's gotten quite good at it. 
The approach I would favour is illustrated in [these](http://www.cs.indiana.edu/cgi-pub/chaynes/a201/rurple/en/inter/30-dot.htm) [two](http://www.cs.indiana.edu/cgi-pub/chaynes/a201/rurple/en/inter/37-class.htm) [rur-ple](http://code.google.com/p/rur-ple) examples.
Arg.. wish I were there. =[ but, thanks =]
That's a problem that always stuck out to me with 3.0 also, but I haven't been very vocal because just as a hobbyist programmer I feel I don't know enough to comment. It does seem to me though that 3.0 should have been built to be fully backwards compatible. Even if they have to 'hack' the compatibilities in and they come with a performance cost it would still be far better off because then you can at least move on to the current version of the language and learn the new methods and incorporate them in time while still being able to use all of the existing libraries. I personally haven't even bothered to learn 3.0 because while I would prefer it as a language and it's obviously better many of the libraries I use are not supported.
It's really too bad you're wrong Massimo. We all know the dependencies aren't ported yet, and given the migration to Python 3 was supposed to be measured in years, not months, and 2.7 is about to be released no one on the core team expected uptake to be overnight. We're still plugging away, thanks. So, the stories of Python's Death have been grossly overblown. So has the "Scalability on multicore architectures" - if it was so easy to "just fix" it would have been done already. The fact is, it's not. We have plenty of promising speed work, and a shiny future with unladen swallow's JIT, and so on and so forth. So no - it's not an experiment, and the way Python 2 handled strings/encodings/bytes was a mistake, and one we're paying for in the transition. As for the OP? Terry did a good writeup. Python-Dev, and the PSF are actively working on supporting, and funding porting projects as needed and as they apply for funding. NumPy will be ported by the end of the summer, probably. So, no. We're not quite dead yet.
I find this a more useful summary of the differences between Python 2 and 3: http://twitter.com/gvanrossum/status/6272559755
No problem. Oh, and if you have any questions for me, fire away.
[Better link](https://docs.google.com/viewer?url=http://ptgmedia.pearsoncmg.com/imprint_downloads/informit/promotions/python/python2python3.pdf)
I think it's very premature to say python is going to fail, or anything approaching it because of this, it's a great language. However I do agree with the point that it seems like a bad idea in practice if only because it looks bad and to an extent splits the community. I know that it's going according to plan, the changes needed to be made and it's supposed to be a few years before it's standard, but this doesn't really change much to someone who isn't already using python and/or knows this. I don't think it would make people leave it, at least those who are comfortable using it, but there are many people that hold the viewpoint that this is a bad move and highlights a failure on the languages part. While I don't agree with them, for the same reasons you are arguing, many people will listen, and a language largely relies on its user base to create libraries for it. The availability of 3rd party support is one of the reasons I love python so much. So while the reason behind it is sound and I see no problem with in principle I am worried about how others will view it and the consequences it may have. *Probably*, and hopefully, few to none, but it is a legitimate concern.
While some of the way Python 2 handles encodings is definitely baroque (losing encoding information during implicit conversion being the primary), if you define that stuff as a mistake, it was a pretty good mistake as mistakes go. It certainly didn't hurt Python adoption, as far as I can tell, and while explaining the encoding and decoding story in Python 2 often feels like an apology, once folks understand it, it's actually pretty easy to deal with. Unfortunately, it's quite hard to recover from such mistakes (ones that actually work) in a bw incompat way without hurting both the bw incompat new thing and the old thing, because the old way was pretty much good enough. That would be just a wash if Python 3 was hippocratic. But I actually think some of the choices made in an overeagerness to port code to Python 3 are poorer (such as the features which cause http://bugs.python.org/issue4006, trying to treat all envvars as Unicode, and http://bugs.python.org/issue3187, dropping "invalid" filenames from os.listdir if they can't be decoded) and will eventually be viewed as even larger mistakes than the Python 2 encoding mistake.
&gt; I still hope the core developers will declare this was an experiment and produce a 4.0 that *(list of identical-to-2.X behaviors omitted)* I hope that if this is what you really want, you just stick to Python 2.x for as long as you can find support for it. Perhaps in six or seven years' time, when the last support cycle of something like RHEL finally drops it, you'll come back and re-evaluate Python. In the meantime, the rest of us have code to write and a better language -- Python 3.x -- to migrate our tools to, and will be doing that regardless of whether you decide to join us.
I teach computational finance and need to use NumPy and SciPy. I do not have a choice. I must stick to 2.x. I have students working on projects and they too do not have a choice. I write software for the Department of Energy and there too I do not have a choice for the same reason. The same is true for all my collaborators in the major national labs. If python were to be backward compatible I would not need to re-evaluate it but, by the time python 3.x will have the libraries I need, I will have to rewrite the code (because python has changed). If I need to rewrite the code anyway, I will be compelled re-evaluate the language. Not my choice. In Fall I taught Monte Carlo simulations for financial applications. I used Python for in-class example. Two of my best students chose to use Scala instead of Python. I have taught this class before and never anybody chose a different language. We also have a large number of students in gaming. Some intro classes use pygame but there is a push to move to Lua. I am not expressing a personal preference (although I said that 3.x is a better language and I try write my code so that works with 3.x when possible). I am stating some facts that should be of concern and more data should be gathered.
Hi Jesse, I agree these things are not easy and I appreciate everything you are doing in this regard. Python 3 is an impressive work. Perhaps somebody should start collecting data about adoption and retention of users.
Why? Its not important. We already know how many packages have been ported on the package index, and we know how many downloads a month we have. We know what, and how we have to do it - there's no need to panic about retention, despite arm waving about people running to erlang or ruby and so on. Everybody involved just needs to continue to do what they can, and teach and lead when they can.
Bugs can, and should be fixed
if you need to work on python 2.5, use it..no ones forced you to move to python 3.0! 
It was derived from the Latin [firmo](http://www.freedict.com/onldict/onldict.php) as one of the original goals (when it was just intended to be a Wordpress clone in Python) was to be secure. While it is definitely more secure than Wordpress today (granted, it does less), the name just stuck as it is pretty catchy/unique (try Googling for the "R" programming language to see why that matters).
It would be useful to publish the information you already have in some aggregated form. It would be useful to reassure users. 
So stop using Python. You've apparently made up your mind and no argument I can offer will change that, so just quit while you're ahead and move to doing Java on Windows, because they're designed from the point of view of the types of "we want to have an intern/grad student write this for free over the summer and not touch it again until the heat death of the universe" institutions you're talking about.
My subjective personal data refutes your subjective personal data. Listen Massimo - I can't even run python 3 in production, and I'd love to - but we're all in the same "we need our dependencies" boat. Numpy will port (by the end of the summer), SciPy will port, the dependencies will eventually all port or be left to the sands of time. The time of Python 3's ascendancy has not yet come, so to speak :) The point is no one is forcing anyone to upgrade - we don't want that. We want the migration to python 3 to be gradual and orderly, not a haphazard rush. So ubernostrum is right - stick to Python 2 as long as you need or want to, and when / if you decide to jump to the "next big thing" like Scala or Closure or Erlang or whatever - good for you. 
`ogrid` indexing stuff was cool.
[the resemblance is uncanny!](http://sphinx.pocoo.org/)
No. I like Python better than those languages that I have mentioned and I will continue use it even if you suggest otherwise. I expressed some concerns and a wish because I care about other users and because I feel I am entitled to express an opinion on this issue. Incidentally, what you say is not how universities work (students rewrite the same code every quarter in order to learn how to do it, and this is why Academia was among the early adopters of Python Java years ago and Python more recently). That is instead how some businesses work (write code once and - if it works - do not touch it until the end of the universe). Whether or not this is a good business practice this is part of what people call progress and code. If you were working for Python Inc. and you were to tell a client expressing a concern about the future of your product "so stop using the product" and "if you want to write code one and reuse it forever, go use Java", you would get fired.
I had the same problem. I fixed this by upgrading to the latest version of virtualbox. I also logged this [here](http://www.reddit.com/r/redditdev/comments/ckigm/new_installation_using_the_ubuntu_64bitvmdk_but/) for anyone who's interested
I want you to teach him to teach his kids to teach me python.
Misleading title. It was *re-*implemented in Python.
I downvoted because his code sample has inconsistent tab spacing
yeh, sorry, that happened when I was copying into the blog posting and trying to line things up. I'll be more careful next time.
maybe a course for *beginners* is not the place to consider whether or not they will become serious programmers? How about having fun? Kids, even geeky ones, still want to do fun things at the end of the day. 
Very, very cool. I like the idea of keeping all documentation inside the source code AND that all this does is shift the comments and documentation to the side of the code to be more legible.
One of those is marked wontfix (the envvar issue). The other one had the resolution of "errors pass silently" (the os.listdir issue). So they're both fixed, just really poorly.
You have, repeatedly, in threads related to the topic, stated your opinion that Python 3 is "killing Python". While you're entitled to your opinion and to express it, two facts remain: First: your expectations of the migration process do not match up to anything the Python dev team has ever said about it. See Jesse's replies to you for some pointers on this. Second: you're pushing for an unrealistic approach to compatibility and arguing dishonestly to support it. Code you've already written is going to continue to work, because Python 2.x is going to continue to work. OS vendors are probably going to be supporting 2.x Python and libraries for it until at least the year 2020 (RHEL has a *ten-year* support lifecycle). If that's what you need it's there for you and you should use it. You're almost certainly aware of this, but it's glaringly omitted from all your posts on the subject. What you seem to want, though, is to have your cake and eat it, too: instead of just having the ability to keep your existing code, you also want all the rest of us to stay behind with you so you won't ever have to adapt to, say, a Python 3 version of NumPy. But that isn't going to happen: upstream Python and the community around it are moving on and, over the next year or two, people who don't migrate are just going to get left behind. At which point, if you have such an aversion to adopting Python 3, the most logical thing for you to do is just stop using Python and switch to a platform like Java which bends over backwards to provide eternal bytecode compatibility (at the cost of stagnant development of the platform).
&gt; that treats strings as in python 2.5 I decide to believe that you're joking about that.
Please do not accuse me of dishonesty. Please do not put words in my mouth. I said what I had to say and other readers will form their opinion.
How dare you have doubted our love of coffee here in Texas, in Austin no less! I see you have been appropriately redirected :) We may not be Seattle, but you can definitely find the good stuff if you search it out.
No one is forcing anyone to do anything. Plenty of organizations are still using versions like 2.3 because it has been a rock for them in production and the cost of re-tooling their environment is not worth it. You know what they are going to do? They are going to keep using 2.3. However, when looking to start a new application, the next best module, the next web framework, etc., I don't think there's anything wrong with suggesting 3.x.
Really great insight in to the Python internals. Nice to see how logically structured the internals for the language syntax are.
Looks awesome. I'd love to try it, but where's the download link?
Very strange. It works as expected for me on OS X and Linux: &gt;&gt;&gt; len(file('test.txt').read().split()) 89686 &gt;&gt;&gt; f = file('test.txt') &gt;&gt;&gt; s = f.read() &gt;&gt;&gt; l = s.split() &gt;&gt;&gt; len(l) 89686
Not to be harsh either, but did you read the second half of my post? I know it's a lot to ask. edit: Oh good, downvote me for saying something totally reasonable. The second half of the post clearly shows that the file ain't empty.
Side point: you know you should be using open() here (and just about always) right? 
Let's start a flame war yay! ...
 &gt;&gt;&gt; f = open('test.txt') &gt;&gt;&gt; l = f.read().split() &gt;&gt;&gt; len(l) 5 &gt;&gt;&gt; l ['Does', 'This', 'File', 'Read', 'Properly'] Works fine for me on Windows Vista. (Edit: Ahh, forgot to say I'm running 2.5.4, which probably doesn't make a difference, but is different than your 2.6.5)
If you feel strongly; please please please bring it up on python-dev
I have avoided Python 3 like the plague. If I wanted to rewrite everything or have to jump through hoops just to use the latest and greatest that'd be one thing. I expect 2.6 programs to run without change on the newest Python. They don't all and therefore I will stop at the 2.x level of Python.
&gt;edit: Oh good, downvote me for saying something totally reasonable. The second half of the post clearly shows that the file ain't empty. because c:\path\to\file.txt really exists on your computer?
I noticed this is your first post on reddit. Be prepared of being accused of being me trolling. It has happened before.
I sure would like to hear some comments from the people who are downvoting this. Personally this is exactly the type of stuff I like to see when browsing /r/python and /r/programming
i need a php version...maybe I could write it in less than 200 lines
Yes, it does. Or maybe, just maybe, I elided the unimportant details like where in the filesystem that file lives.
I think this version can parse different languages, it just happens to be written in Python.
Don't you have anything better to do than respond to old comments I've made in unrelated threads? This started when you got mad at me for pointing out that you hadn't read the post you were replying to. Go fuck yourself.
Me, too. 
Correction - this started when you got mad when I offered a piece of advice. If the file was empty, then your problem would of made sense. I once spent an hour trouble shooting my internet connection only to realize the cable wasnt plugged in. Dont act like you are perfect and never make silly mistakes.
Why Python2 ? * NumPy * Matplotlib * Django * PyGame --- **edit**: I just want to be clear that I will have no problem switching when these are stable on Python3. Until then, I consider Python3 in Beta. That is all.
No relation to [this pocoo](http://pocoo.org)?
I totally disagree, I think half the point of 3.0 was deprecating code for a cleaner code base. They're still maintaining the 2.x series, so you're not forced to move.
That's just the typical Reddit down voting that happens with all submissions 
Why? These are already things that core devs (e.g. Guido) have said "it's done and we're not changing it" about. 
TIL that in order to make Python, you already have to have Python installed.
I definitely won't be doing *that*. People already did that, resulting in at least one turgid multiweek thread (and probably ten offshoots) needing resolution by the BDFL. There's no higher authority to appeal to for either bug. (See http://mail.python.org/pipermail/python-dev/2008-December/083856.html). IMO, the "everything human readable must be text" fascination in Python 3 is a design error, and nobody seems to be able to convince Guido otherwise. It appears that nothing is going to change this any time soon, so Python 2 is looking pretty darn good right now to me.
Why Python 3? * PyQt * cx_freeze * SqlAlchemy * PyGame * NumPy (soon) * Blender I can play this game too...
opps ..... Sorry ...... LOL :D
This little blog posting has some serious issues for any of the non-simple bits, and unfortunately has comments turned off... so the complaints land here. * Dynamic Import example is flat out broke; it only works for importing modules, pulling attributes from module space. timedelta is a type, not a module, thus the equivalent 'import datetime.timedelta' isn't going to work. * Object-dict hybrid is flat out broke... should be using __getitem__/__setitem__/__getattr__ ; further, it's bad design, use getattr/setattr/delattr instead (while that code forces old style class w/out much gain, new style is what makes sense and said functions would work seemlessly regardless of the class inheritance, or __slots__ abuse). * The Error Recovery Pattern swallows keyboard interupts, memory errors, and all sorts of other valid shutdown exceptions. Further, because it invokes start itself (meaning it recurses), it'll sooner or later blow up- due to it relying on self recursion to handle exceptions, it'll go deeper and deeper till it hits a stack exception trying to invoke 'start', then collapse all the way down. * Raising Meaningful Errors has a nasty gotcha in it's ValueError example (realistically in all of them, but ValueError is the most likely copy/paste/bite-you-in-the-ass); simply put, consider if 'v' is a sequence. It'll try to expand it, and... boom.
Many, many languages are self-hosting. As are compilers. For instance, Clang is now self-hosting -- meaning you build Clang with Clang (or, you can): http://blog.llvm.org/2010/02/clang-successfully-self-hosts.html
**NumPy** -- I've read in numerous places (including this thread) that it should be on 3.x around the end of summer. Maybe a GSOC project? **matplotlib** -- Depends on NumPy, also depends on PyCXX which already works with 3.x **Django** -- Here's at least one port: [Martin von Loewis' django-3k](http://bitbucket.org/loewis/django-3k). Mainline support of 3.x is probably far off, but it's not impossible. **PyGame** -- [this wiki page](http://www.pygame.org/wiki/PythonVersions) states that it works with 3.1
Actually, as far as a *web framework* goes, it might be a poor idea to begin writing it in Python 3. WSGI is the protocol on which most existing Python web frameworks have settled to do communication between applications and servers. The WSGI specification (v 1.0) does not really apply to Python 3 because existing WSGI applications are expected to return "str" objects that signify byte arrays; but this data type has actually been removed from the language. The spec hasn't yet been amended, and there's a good deal of confusion about exactly how it should be amended to support Python 3. http://lucumr.pocoo.org/2010/5/25/wsgi-on-python-3 is a good summary of the situation. Because of this, the most popular WSGI libraries such as Paste, WebOb, Werkzeug, and a raft of others don't actually work under Python 3. Indeed WSGI itself (at least as defined in any existing specification) doesn't work under Python 3. Even the stdlib CGI module, which is depended on by higher-level libraries for dealing with, for example, form input submissions, doesn't work 100% in Python 3 yet: file uploads in multipart encoded form posts can't be pulled out properly by the stdlib. So, sure, if you want to be on the very bleedingest of edges, you can indeed implement a web framework in Python 3. But if you do, you had best be prepared to write a lot of stuff yourself, or at least make continual changes to forks of existing systems.
&gt;Even if they have to 'hack' the compatibilities in and they come with a performance cost Performance penalties due to hacks would be simply unacceptable.
Thanks. I knew gcc was needed to compile itself (or a newer version), but I just kind of figured you could compile python with gcc. Now I know better!
[goto here](http://entrian.com/goto/) for another approach
At least the title's correct: (subtly-?) broken Python code is a common pattern.
Sorry.
man why the hell you don't allow comments on your page ? weird. Your "Dynamic Function Arguments" example doesn't seem to work (as advertised) on 2.6...is it because you're on 3 ? Python 2.6.2 (release26-maint, Apr 19 2009, 01:56:41) &gt;&gt;&gt; def somefunc(self, *args, **kwargs): ... print 'args: %s' % args ... print 'kwargs: %s' % kwargs ... &gt;&gt;&gt; &gt;&gt;&gt; somefunc(1, 2, thirdarg=3) args: 2 kwargs: {'thirdarg': 3} &gt;&gt;&gt; somefunc(1, 2, 3, thirdarg=3) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in somefunc TypeError: not all arguments converted during string formatting &gt;&gt;&gt; somefunc(1, (2, 3), thirdarg=3) args: (2, 3) kwargs: {'thirdarg': 3} 
his "Dynamic Function Arguments" example doesn't seem to work on 2.6
Technically, running Python to build Python is not required unless you change the .asdl file, because the pre-generated .h/.c files ship with the distribution.
Quite a different approach, however. The author of this "goto" module uses pre-processing of the Python source code to do his magic. It doesn't get anywhere near the source code of Python itself.
I stopped wondering a long time ago. It appears Reddit has bots that downvote everything to reach a certain % of "liked it". Even the most brilliant and obviously relevant articles with 100s of upvotes get enough downvotes to put them into the 70-85% range. **Needless to say, this makes the Reddit voting system close to useless.** 
It's called #python.
multiprocessing (the Python package) actually goes a long way towards solving the problems that better-working threads would solve (for the workloads I typically see). I don't *really* need to have contention for multiple data structures when I can really carry out computations in a forked process. (Multithreading is necessary for languages with a proper GC, aka Java and LISPs, if only because GCs and copy-on-write of application memory don't work together well.)
I appreciate that you were trying to help, and I do often make stupid mistakes. But I didn't get mad when you offered advice. I got annoyed that you hadn't actually read the text of my post, and then you got mad and went nuts when I called you out on it. Surely there is something in the reddiquette about not spamming unrelated comments from a user you don't like with irrelevant replies... But whatever. Feel free to keep downvoting all of my comments with your sockpuppet accounts. I'm dropping it.
Holy hell man. I've had plenty of problems like this where it isn't obvious how to fix it. You're getting more downvotes than the titanic. I'm just showing some love... ::furiously tries to upvote all reasonable questions / comments / replies in this thread::
I really don't know one way or the other, but you may want to consider this question as 'is there a C project that does X' and then wrap the project. Not sure on your level of python-c-fu, but without knowing c, I was able to wrap some basic functions implemented in c by using an existing project (I used http://pypi.python.org/pypi/python-Levenshtein/ )
Yeah I was definitely considering that. The problem is that my thing is for a coding contest in my company meant to show off the power of dynamic languages, with the goal of selling more dynamic code work to clients. I'm definitely going to lose points for resorting to C wrapping because the Python lib was too slow, so that's my last resort as of now.
I haven't look a lot, but the code seems to be on the right (just copy paste)
Could you resort to using subprocess.Popen and using a compiled binary instead?
Not sure on the rules of the content, but you could always create the wrapper code, create an open source project, get it working, and 'use' that package in your code. Your project would be all python *and* you create a project that will help others.
But what if I want the code with the comments inline? :)
If it comes to that, why not try Cython? You could write the decryption code in that vs straight C. That why you can show that there's a middle ground (ie: don't need to drop that low-level when required, and Cython does resemble python a good deal language-wise). Might come off looking better than wrapping C code. Although that's a good point too (like showing how easy it is to interface with legacy code, etc).
http://inventwithpython.com if you are new to programming as well.
Speaking as someone with access to all of reddit's voting records, this isn't accurate. Regular, real users downvoted this submission, not robots.
You may not have realized it but in your original reply to miles_g you really came off like an unappreciative hot-headed asshole. That's why you're getting all the downvotes. As a general rule, I try not to snap at someone who's just trying to help me. Maybe you were just having a bad day...
Thanks for pointing out the errors. I have tried to write them by heart in about 1 hour and obviously missed some important points in some of them. They should be OK now.
I don't allow comments because when I write something controversial I only get tons of destructive comments and not only a positive one. But I think I can do some moderation or allowing comments on some pages. I hope I would have time to try that.
Speaking as someone with no access to anything, this is accurate. Regular, real admins do seem to go around posing as users.
I'm going to guess it's tab completion by pythonwin. If you do f.read().sp&lt;TAB&gt;, it may be evaluating the command to determine the type of the result of read(), which of course will read the entire file. When you press return, it re-evaluates it, but because you're at the end of the file, it'll fail. Not sure if this is the case, since I haven't use pythonwin, but it's the only thing I can think of that makes sense of the observed behaviour.
The author of this "goto" module uses pre-processing Actually there's no preprocessing at all going on, or even a new statement added. "`goto .label`" is equivalent to "goto.label" - ie it's an attribute access, which of course you can overload to do anything. The same thing for "`label .name`"
This is the answer. Checked and it is correct -- if you do a completion on `f.read().` it will execute that code to see what object comes out of it. And then you do it for real but you get `""` out. If you close the file and repeat all that commands without completion (but still chaining `f.read().split()`) -- it works. I said it before and I'll say it now: PythonWin sucks. Use IDLE, seriously.
what's wrong with 2to3?
That's a lot of fun. I did: unless test: suite
It uses pygments which is a pocoo project :D But I call name fail.
This breaks when you specify more than one 'args' argument because you end up running the equivalent of: print "args: %s" % (2, 3) You can fix this by doing print "args %s" % (args,)
Object-Dict Hybrid should just extend dict: class HybridObj(dict): pass .. and then just override the methods you want, probably getattr in this example.
 ("That's very surprising." . replace(".", "!"))
2to3 translate existing Python 2 code to Python 3 (e.g. find and replace); six provides a compatibility layer between two (e.g. `from six.moves import cPickle`). I think six is going to help when you want to maintain only one version of code that runs on both 2 and 3.
I'm confused... How is this any different from while not(statement)?
It's not different, and the author is not (not really) recommending that "until" be added to the language. It's more a tutorial in how you go about adding something like that to the language.
It means that every time you want to test your package on Python 3 or distribute it, you have to run 2to3 on everything. You also probably have to maintain two code bases. Six's goal is to make sharing a code base on Python 2 and 3 easier.
zipfile uses zlib to do the heavy lifting (compression / decompression) but, as you note, the decryption algorithm is all in pure python. It's very short as ~ 50 lines including comments. Check the source code. This should be really easy to speed up with Cython. In fact, the critical method is ZipDecrypter.__call__ def __call__(self, c): """Decrypt a single character.""" c = ord(c) k = self.key2 | 2 c = c ^ (((k * (k^1)) &gt;&gt; 8) &amp; 255) c = chr(c) self._UpdateKeys(c) return c This is called for each character by ZipExtFile.read(). To get a real speed up would need to create a Cython extension class implementing the decrypter interface (just copy the python one), but add a "cdef" method equivalent to ZipDecrypter.__call__. This is, in effect, a pure C function. Then make a new ZipExtFile extension class, but replace the line newdata = ''.join(map(self.decrypter, newdata)) with a fully typed Cython for-loop (which will compile to a fast C loop) which calls the decrypter cdef method on each character. The point here is to avoid the overhead of a python function call on each character, but loop in pure C. Basically, with Cython, you start with normal python code, then add type defs to make the time-critical sections fast. BC
I like it. This makes lots of sense. Thanks!
Sigh. You're probably right. I didn't mean to come off like a dick.
What is the big advantage of Google App? Any secret sauce which is difficult to replicate on raw servers on your own?
At the cost of having ugly code, though.
so you want to explain why your example doesn't work ? hint: if you dont want shit comment , at least test the code BEFORE posting. 
Awesome, thanks!
It scales. That is all.
thanks, as new to python, i'm still puzzled by the comma from time to time so that trailing comma keeps "args" as a Tuple and from "expanding" ?
In which paradigm does it scale? More memory, more CPU, more nodes (and how does your code see those nodes)? Why should I be unable to scale my own servers that way? Or is everybody assuming bursty, unpredictable workloads these days?
 Multi-value return def somefunc(): return val1, val2 val1, val2 = somefunc() just a tuple is returned... the parens are implied or something &gt;&gt;&gt; def somefunc(): ... return 1, 2 ... &gt;&gt;&gt; somefunc() (1, 2) &gt;&gt;&gt; type(somefunc()) &lt;type 'tuple'&gt; and Removing duplicate items in a list print set(['a', 'b', 'a', 'c']) # prints: ['a', 'b', 'c'] But now you have a set and not a list. A set is unordered. &gt;&gt;&gt; type(set([1,2,3,1,2])) &lt;type 'set'&gt; &gt;&gt;&gt; type(list(set([1,2,3,1,2]))) &lt;type 'list'&gt; Overall, a nice collection of Python snippets for those that are new to Python. I'd shy away from the more complex examples because they resemble a solution looking for a problem. Nothing to see here if you do a decent amount of Python though. 
&gt; so that trailing comma keeps "args" as a Tuple Yes, sort of. It means that (args,) is a 1-tuple consisting of a 2-tuple :]
It is a platform as a service that leverages distributed services without you having to architect, configure or manage it.
Precompile? Unladen Swallow?
GAE is not a vServer, but a distributed CGI-Server with a giant job queue. Each single HTTP request is handled as an isolated CGI job by a different node. If your app receives 1000 requests at the same time, they are all handled by different nodes at the same time. If your app receives no request, you don't pay anything. That is the idea. And such load-spikes are not that unusual. Take a web-shop for example. You don't want to see your servers crash because too many customers try to buy your products (omg, a new Apple product. Must buy it now! &gt;.&lt;). You also don't want to pay the bill for 1000 servers running idle most of the time (at night for example). GAE is perfect for such scenarios. You don't need this to run your homepage or personal blog, though.
[The code is on github.](http://github.com/fitzgen/pocco/blob/master/pocco)
Then I really am stumped
Another benefit is that you don't have to setup and maintain any webservers or database servers. The free quotas are pretty generous, too, so you probably won't have to pay anything until your site is getting a decent amount of traffic.
OT: I wrote a precompiler for python last weekend to add an 'end' keyword and remove the significance of indention :) (used for templates)
&gt; Type Checking &gt; &gt; ... &gt; &gt; `if isinstance(obj, `... I find that with dynamic languages it's far more common to check for capabilities of an object than its type. E.g., you'll do stuff like: if not hasattr(obj, '__iter__'): obj = [obj] for foo in obj: ... `isinstance` seems to be more useful in strongly-typed languages where you inherit interfaces or (abstract) base classes when implementing certain bits of functionality. 
I think the situation is not that bad anymore. * mod_wsgi 3.0 added support for Python 3.1+ * wsgiref.simple_server kind of works, too * [bottle](http://bottle.paws.de/) is a WSGI framework that runs under 3.x and conforms to the wsgiref and mod_wsgi implementations. This is the closest you can get until an updated WSGI specification is released. * [multipart](http://github.com/defnull/multipart) is a new multipart/form-data parser that consumes bytes, can read from environ['wsgi.input'] even without a readline() size parameter and fully supports 3.x. It will soon be integrated into bottle to replace the broken cgi.FieldStorage() implementation. To make this clear: There is no WSGI spec for Python 3.x. I know that. I just think that "the spec is not clear enough" should not be used as an excuse for not moving forward. Graham Dumpleton (mod_wsgi) took initiative and did a great job doing so. I cannot wait for the other libraries and frameworks to follow.
You should really be checking if the user has actually entered a number for the parameters.
Yeah, fuck the person who wrote this blog post.
There is no such thing as "multi-value return". You are returning a 2-element tuple and then splitting it into two variables.
IIRC, KeyboardInterrupt and SystemExit should be avoided by catching Exception rather than BaseException, at least since some semi-recent Python release?
It happens. :-)
Sorry.. `mogrify -scale 640x480 *` :)
I have not found that it scales. There are an absurd number of hard limits in App Engine. Their hope is to eventually build a scalable service, but the current pre-beta version of app engine is less scalable than most hosting providers.
I wonder what kind of speedup you'd get from a `ZipExtFile` subclass that inlines the `ZipDecrypter.__call__` method in its `read` method. You could maybe also inline `_UpdateKeys`. Probably wouldn't do much, but it'd be interesting to see.
I didn't add the CC license to the source, but it is under a BY-NC-SA Creative Commons license, so feel free to put it on github! There's no sound because I haven't found a library that can play beeps at different frequencies and lengths that is cross platform. (Pygame can play MIDIs and other sound files, and I found one beep function in a Windows-only library, but nothing else.)
Holy shit. Thank you so much!
Awesome, thanks!
Just.. wow.
Well, the object of six is to to keep that at a minimum.
Awesome! Finally an alternative to CPython.
First, some stylistic things: * It looks like you're using variable names for non-obvious things. Why would you print out "count," when you want to print out a particular prime number. Maybe change the name of "count" to "last_prime" or something? * You may get better results if you set a flag variable, indicating whether the number is composite. Then, when you discover it is, break out of the loop and then handle conditions for when it's composite or not, and then move on to the next one. Basically, try doing what your program does on paper, for the first few iterations, to see what it's actually doing. In the above code, you'll get significant speedups when you learn about the "break" statement. Not that you need to worry about that with a non-worky program. Also, your code isn't exiting the loop because you're changing the iterator variable "divisor" in-loop. The first composite number you come to, divisor is set to 2, and then it goes to the next number in the range (maybe? I forget how Python does it) and then it simply never halts. 
This must have been the motivating factor behind the restructuring that NumPy is undergoing to separate the interface with CPython from the number crunching code. Luckily all non-CPython Python interpreters can benefit from that restructuring. Hopefully it won't negate all of the time I'm spending fighting with NumPy on PyPy for my GSoC project though. (If the restructuring yields a nice C level API to NumPy it'd probably be more useful to directly access that through PyPy's foreign function interface than to continue using CPyExt which has to pretend to be CPython)
[is this what yall wanted](http://pastebin.com/P0sXjr65) ~ as fast as I could think and type
Was CPython causing you problems?
I've had GIL issues, but I really want to see some performance improvements.
And IronPython is faster than CPython?
A few things... The first prime number is 2, not 11; so, prime\_start should be set to 2 if prime\_counter is set to 1. You say you want the 1000th prime but your while loop is set up for the 10000th one. You are using divisor as the variable name ... and you are changing its value inside. You should not have to do this. Your for loop should look like this: is_prime = True #see below for why it is needed for divisor in range(2, count+1): if prime_start % divisor == 0: # not a prime, so end the loop, but first note the result is_prime = False break Then, after the for loop, you update the counter if it is a prime number if is_prime: prime_counter = prime_counter + 1 Try to incorporate these ideas and see if you can make it work; there are more changes needed.
Doubtful it is at this stage, but it has potential.
Your declaration of awesomeness suggested that there was something to be gained immediately.
I'm just happy so much attention is being paid to NumPy/SciPy for a change.
Up-vote for pen and paper, arguable the greatest tool in a programmer's arsenal.
To be blatently honest, a computer scientist (I am one) would simply Google for an existing algorithm, come across the Sieve of Eratosthenes, and then translate the logic into their desired language. That's actually a good way to start programming. Don't worry about algorithms at first. Get a language (Python is an excellent choice) under your belt, coding up simple problems. Later when you become comfortable in a language, it'll be quite easy to use it as a tool to write algorithms. For now in lieu of a programming language, as another poster suggested, try writing algorithms with pencil and paper in pseudocode - it's a tool you're already comfortable with and won't get in your way. Keep the learning of algorithms and languages separate and you'll find the learning curve much easier for both, at least to start. This is what colleges do also, by the way.
I would have definitely split those and picked one or the other to use with `__getitem__`. One of the reasons I assume python doesn't allow you to do more funky things with `__getitem__` is that things like the code you've posted are a bit confusing. Maybe they're convenient, that I definitely agree, but I think the python beginner's tutorial puts it nicely, [paraphrasing obviously]: one can overload, say, + to do something that could be incredibly important, maybe your class' most used operation, but at the end of the day there's a point where what you're actually doing just isn't really + or anything like it, or at least not enough like + to feel comfortable, and beyond that point it's aesthetically ugly to try and shove something into the operator. Now I'm a math major so I have quite a large comfort zone on what can be called "addition", but that being said, I took that to mean that everything you do should be done in a way that someone using your code will feel that there's some intuition or harmony between what you've done and what they expect. Overloading indexing to take two different datatypes doesn't really fit with the philosophy (that's subjective obviously), at least partially because there's nothing python does out of the box that does something like that really. So yeah I would have used maybe a `by_ssid()` method or something. All of these things though are again highly subjective. A whole lot of people I'm sure feel that the convenience of one unified indexing is worth it. I should take a look at some ordered_dict modules. Wonder if they use [] indexing for both order and key.
I've looked at your code and I can't even begin to understand what you were trying to get it to do. Why did you set prime start to 11 instead of 2? Why did you set your while loop to end at 10,000, not 1,000? Why do you calculate the square root of prime\_start on every iteration of the loop, but never change the value of prime\_start? That could just as easily be outside of the loop, and you'd get the same result faster. Since count is always the same, why do you print it every time you run the loop? Since test range is always the same, why do you redefine it every time? Why do you define divisor before you use a loop which also defines divisor? For example, saying: x = 5 for x in range (10): print x ...will always give you the same results, no matter how you define x initially. The for loop defines x on every iteration automatically. After the for loop, x is whatever value that it was when it was last used in the for loop. Defining x before the for loop does absolutely nothing. Why do you redefine divisor at the ends of the loops when the for loop also redefines divisor at the beginning of the loop? Why do you use two print statements to say: print prime_start print "is a composite" When you could simply write: print prime_start, "is a composite" I would rewrite your code as follows, and keep in mind that this will produce the same results (except for repeatedly printing count), but faster: from math import sqrt prime_counter = 1 prime_start = 11 count = int(sqrt(prime_start)) test_range = range (2, count) while prime_counter &lt; 10000: for divisor in test_range: if prime_start % divisor == 0: print prime_start, "is a composite" elif prime_start % divisor != 0 and divisor &lt; count : pass else: print prime_start prime_counter = prime_counter + 1 Now that we've done that, it's pretty obvious why your code is getting stuck on an infinite loop. Count is rounded-down square root of 11. That's 3. It will always be three. Test range is the range between 2 - count, not including count, so test range is a list, and the only thing in the list is 2. This means your for loop does nothing, because it's just looping over a list that only contains 2. You could just define divisor as 2 and get rid of the for loop. So, every time you run the while loop, you're saying: Is the remainder of 11 divided by 2 equal to 0? If so, print that 11 is a composite. If not: If the remainder of 11 divided by 2 is not equal to 0, and 2 is less than 3, do nothing. If not: Print 11, increment the prime counter. Now, since we know that, we can simplify your loop even further. Repeat forever: Skip this if statement. Go to this if statement and do nothing. Skip the next statement. So, yeah, basically, you told your loop to do nothing except needlessly print 3 every time it runs. I'm worried this post is getting too long, so I'll show you how to do things correctly in a reply to this one.
This is fantastic!
Here is one I whipped up in Java, I'll let you translate into python (should not be too difficult). Have a happy stack overflow! public static void main(String[] args) { System.out.println(getPrime(1000, 2, 1)); } public static int getPrime(int nth, int cur, int count) { if(count == nth) return cur; return getPrime(nth, getNextPrime(cur), count + 1); } public static int getNextPrime(int cur) { ++cur; if(isPrime(cur, 2)) return cur; return getNextPrime(cur); } public static boolean isPrime(int num, int cur) { if(num == cur) return true; if(num &lt; cur*cur) return true; if((num%cur == 0) || (num == 1)) return false; if(num%2 == 0) return isPrime(num, cur + 2); return isPrime(num, cur + 1); } EDIT: Fine, I will switch over to linux and convert to python to please the audience.
&gt; Don't worry about algorithms at first. Get a language... under your belt. &gt; For now in lieu of a programming language... try writing algorithms with pencil and paper in pseudocode. Which do you think he should do first? I don't see how he's going to learn pseudocode without seeing a program run (how will he know if it works??), nor do I see how he can code without worrying about algorithms. Are you suggesting he translate prewritten pseudocode programs into python, and if so, can you suggest a good resource for these implementations to him? &gt; This is what colleges do also, by the way. He is on problem 2 of an intro programming course.
No, the problem is that you are not breaking down the problem at all. Using a better method like the Sieve of Eratosthenes would be a good idea as a next step, but for now, actually writing functions would help more. Try filling in the blanks here: def is_prime(n): """Return True if n is prime""" ... def gen_primes(): """Yield all prime numbers""" n=2 while True: if is_prime(n): yield n n+=1 def nth_prime(n): """Return the nth prime""" ... 
A prime number is an integer which cannot be evenly divided by any other integer except 1 and itself. We can test for primality very easily (if slightly inefficiently), like so: test_number = 57 is_prime = True for divisor in range (2, test_number): if test_number%divisor == 0: is_prime = False break print is_prime Divide the number by every number less than itself and greater than 1. It's prime unless one of those numbers can divide it without any remainder. Note that break just ends the loop early. Once I've figured out that test number is not prime, I don't need to keep testing it. So, put that code in a while loop, add a counter, and you're done. test_number = 1 prime_count = 0 while prime_count &lt; 1000: test_number += 1 #Note that this will skip 1, since 1 is not prime by definition is_prime = True for divisor in range (2, test_number): if test_number%divisor == 0: is_prime = False break if is_prime: prime_count += 1 There are lots of ways to make this more efficient, but I'd like to keep it simple so you can figure out how this works. If you're not already aware x += 1 is the same as x = x + 1
This is where I am right now ... I am reading your comments and am going to try and get this right. import math prime_counter = 1 # this is what i want to keep track of when to stop the program prime_start = 3 # this is what i want to be updated until I find the 1000th prime number which it will then print. while prime_counter &lt; 1000: # this is what is keeping track of the length of the script count = int(math.sqrt(prime_start)) # this is creating the number that is high as i need to search for a divisor that might determine whether or not prime_start is actually prime divisor = 2 # this is the starting point for dividing into the prime_start is_prime = True #this is a default value to be used in breaking out of scripts for divisor in range(2, count+1): # this determines the range of numbers that should be checked as possible divisors that can break a number away from being prime if prime_start % divisor == 0: # if this is true its not prime # not a prime, so end the loop, but first note the result is_prime = False # this changes the default is_prime to not false break #this cuts out of the loop elif prime_start % divisor != 0: # if the above is not true it make its to this part of the script divisor = divisor + 1 # at this point nothing is known other than it might be prime so the divisor is kicked up to try the next number continue # this allows the program to go to the next number test if is_prime == True: # if is_prime never became false this will still be true print prime_start # print this number because it should be prime prime_counter = prime_counter + 1 # set the prime counter up one prime_start = prime_start + 2 # go on to the next number to be tested print "is prime" # simple print statement break # break out to start the loop over That is where I am right now. Im reading over the comments and will be working to finish the code to completion. I spent some time observing the Sieve of Eratosthenes and visually it makes sense to me but it will take some time for me to translate what is happening in his logic to some kind of code that makes sense as a starting point. I really appreciate the insights and I am really enjoying the challenge, its just that with no one to tell me how terrible my code is at this point I think I am quite close when I am really quite far. Again thank you ... I will get this together. 
homg, I am so excited about this. :D This is most excellent new, sir.
This could open the flood gates. /crossing fingers
Here it is in Python. I haven't used Python for awhile, so I'm probably not using best practices, but this will work. import sys sys.setrecursionlimit(500000) def getPrime(nth, cur, count): if(count == nth): return cur return getPrime(nth, getNextPrime(cur), count + 1) def getNextPrime(cur): cur += 1 if(isPrime(cur)): return cur return getNextPrime(cur) def isPrime(num, cur = 2): if(num == cur): return 1 if(num &lt; cur*cur): return 1 if(not (num%cur) or (num == 1)): return 0 if(not (num%2)): return isPrime(num, cur + 2) return isPrime(num, cur + 1) print(getPrime(1000,2,1))
This seems to be something that i can work on the rest of the evening ... i just recently learned about functions and havent actually used them to solve the problem but i will revisit the problem and try your method to get better results.
Yes. IronPython runs on the CLR and is GIL-less.
Why do I get the feeling you would rather be writing lisp or haskell?
Indeed, this was one of the things that Travis Oliphant explicitly mentioned in his talk this morning. Creating a clean interface opens up the possibility of a number of backends, PyPy obviously being one of the possibilities. It's sort of taking the buffer interface to the next logical level: the array interface. (Last sentence is my wording, not his!)
Sounds flavorsome. 
yes, you really need to scrap what you have now and fill in those functions. Having one massive block of code will NEVER work out in the long run. as soon as you start having code that looks like while ..: for ..: if ..: break else ..: it is time to refactor. If you use functions, to update it to use the Sieve of Eratosthenes all you'll have to do is re-write the gen\_primes function and get rid of is\_prime. Was the first problem to write a program that tells is a number is prime or not? They are probably expecting you to write functions so you can have one program build upon the previous one. If you don't have functions, then you don't have any building blocks that you can reuse.
My response is HOLY FUCKING SHIT!!! But yours is good.
Shit, they're on to me.
Funny. I was searching for PySol for Android today. My prayers will be answered soon.
I do truly believe that the best way to figure something out is to google the answer, then figure out how they came up with that answer. I don't think it makes you any less of a programmer.
Before I start, I'd like to stress that none of my points are intended as criticisms of you in any way - you're doing just fine for a novice programmer. These are just some things you might not have picked up at this point in your programming (or math) career! _____ 1. Check out the [Ulam Spiral](http://en.wikipedia.org/wiki/Ulam_spiral). It's a cool trick that might let you skip checking a lot of primes. 2. If your problem involves constantly re-doing the same operation, you should be automatically thinking "*Ah, I must use [memoization](http://en.wikipedia.org/wiki/Memoization)!*". This allows you to use prime-discovery techniques like [Sieve Of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). 3. You can avoid `import math` by using `(prime_start**0.5)` - square-rooting a number is the same as raising it to one half. Also, if you are importing, (IMHO) it's a good idea to only use the bits you need. The general form for this is `from package.subpackage.subsubpackage import some_function as spam` - so for this, you'd use `from math import sqrt as math_sqrt`. Note that the "`as spam`" is entirely optional - however, it's usually a good idea to rename it to avoid name-space conflicts (eg, `foo` might be in `package1.foo` and `package2.foo`). 4. Instead of lines like prime_counter = prime_counter + 1 You can use prime_counter += 1 This is entirely a style thing; but if you're strictly observing [PEP 8](http://www.python.org/dev/peps/pep-0008/) and using 80-column lines, you'll find that the more verbose `foo = foo + something` will not fit! 5. You must try and design your code so that it uses generators/functions instead of while loops - a while loop might not break, which will lock up your CPU (and make testing a huge pain)! _____ Edit: Reddit's back, and here's my example solution (reads from first stdin argument) (ie; `$ printprimes.py 30`) #!/usr/bin/env python from sys import argv as sys_argv def generate_primes(stop): """" Uses "Sieve Of Eratosthenes" algorithm. """" non_primes = set() # Sets items are always unique for num in range(2, stop): if num in non_primes: non_primes.remove(num) # frees up memory continue for divisor in range(2, num): if num % divisor == 0: # num is non-prime break # the below "else" block won't be called else: # prime discovered for product in range(num, stop, num): # range(start, stop, step) non_primes.add(product) # adds "product" to "non_prime" yield num for count, value in enumerate(generate_primes(int(sys_argv[1]))): print(count+1, value) #count+1 because enumerate starts at 0.. 
yeah.. tail recursion in python doesn't work so well :-)
Here's my Sieve of Eratosthenes method in Java, no recursion this time, but now I really want haskell. public static int getPrimes(int nth) { int cur = 1; boolean[] nums = new boolean[cur]; int i,j; int primes = 0; while(primes != nth){ nums = new boolean[cur + 1]; for(i = 0; i &lt;= cur; i++) nums[i] = true; for(i = 2; i*i &lt;= cur; i++) if(nums[i]) for(j = i; i*j &lt;= cur; j++) nums[i*j] = false; primes = 0; for(i = 2; i &lt;= cur; i++) if(nums[i]) primes++; ++cur; } return nums.length - 1; }
I just finished downloading the Android SDK, Eclipse, and bought a book on developing for Android 2. This could make things so much easier!
This will be amazing. 
It's probably not only *just* for Python, but for pretty much any language ASE supports. (Pure speculation on my part, as it just seems the logical thing to do. If you're creating the bootstrapper for python, I don't see why another language couldn't be just thrown in there as well) So Python, Perl, JRuby, Lua, BeanShell, JavaScript, Tcl, PHP, and shell. On top of that, the next-highest starred item on the list is Parrot support. [List of the languages the Parrot VM supports](http://www.parrot.org/languages) (Although, it's a shot in the dark as to if this will actually ever be implemented, one can still hope) Each interpreter will actually be installable via its own APK so you're not having to download the entire ASE to each and every device that wants to run a specific interpreter. I did a little more searching around, and Alexey Reznichenko is actually the one adding most of the new stuff into the Wiki about implementing new interpreters, so I think it's pretty safe to say that this is happening. The floodgates, it seems, will indeed be opened.
I can already write APKs in ActionScript. Now, I can use Python too? Let's play how-many-mobile-games-can-you-develop-without-learning-Java!
Hey, maybe someone will finally make a decent music player app. :)
Damn it. I just bought an Iphone... But i can still use the Android emulator, right? Right, guys?
See also: [Cyclone](http://github.com/fiorix/cyclone) – a Tornado-clone built on [Twisted](http://twistedmatrix.com).
*crosses fingers for pygame port*
Eww. There's absolutely nothing wrong with `import math` if you only want to use a single function from it. It's still perfectly isolated from your module, and the origin of the function is obvious at every call point. You're not going to get conflicts since every module name is unique from that particular name-space. And it's not as though it even saves typing if you're going to rename everything from `module.function` to `module_function` anyway. Also; `sys_argv`, really?
Others have pointed out some pertinent points. I would also suggest that you try to factor out the code that checks if a specific number is prime into a separate function. This will help you reason better. Don't give up on programming
Give me a list of features you'd like to see, and what you *don't* and I'll see what I can do. Open source and not ad-supported of course.
Oh man... Also it wouldn't surprise me if this pops up as soon as this is released. That's one project I'd love to be a part of... I think I'll start reading some of the lower level pygame code...
I'm not thantik, but I would like one that is: * fast * FAST * Has **simple** playlist management (like adding tracks easily and saving the current playlist for later use). Easy means in as few steps as possible. * Also, it should be fast :)
Can someone explain why is it great news?
Your "for divisor ..." loop automatically goes through the values 2, 3, 4, ... so 1) you don't need to initialize divisor=2 above and 2) you don't need the "elif" clause at all. The "if is\_prime ..." test needs to be at the same level as the for loop (i.e. not inside) as it is verified once you have determined that the number is a composite (and broke out of the loop) or a prime (and tried all the values in the loop).
Oh that is a comfort to hear. I really don;t get alot of dev time and I'm a shockingly slow coder, but I like python. I wanted to play with Android and was kinda down about having to get back into Java. This could work for me.
fast in doing what? I'm puzzled.
Mostly UI responsiveness, but reading tag information fast is also important.
ASE only very basic GUI support, so you couldn't use this to write android apps like music players or games. (Ok, maybe very very simple interactive fiction games played on the console)
But will it do Objective-C? :)
I hope not !
All welcome. Open. yes?
Up for nerdgasm.
Why? Some people actually like the Obj-C language outside of the Apple realm.
It should be as much like Foobar 2000 as possible, but only in the ways that make sense for a phone.
ASE is pretty extensible from what I've gathered. As far as what I've read all it would really take is creating the proper bindings for the access to these things to exist; If it's available in Java there's no reason it can't be available elsewhere. You won't get the benefits of the JITing Dalvik VM, but I'm sure access could be developed none the less. On top of that, the work going into this should make it so anyone can package an interpreter in an APK, so maybe someone will create a JITing Python VM ala Psyco or something.
this!
you forgot to mention fast
I think—I... I think I just. I think I just (*whispers*) *had a pregnant*.
I love my Obj-c; so good for when working in a team as readability is awesome, no more guessing as to what parameter is doing what. Was planning on porting UIKit to the NDK, I don't think this will support it as Obj-c is a C runtime and not a scripting language.
Gapless playback. Thing is, I'm not sure of the framework supports this properly. You'd essentially have to have the next song in the list paused at the beginning and then play it x milliseconds before the current one is finished.
No, not really. ASE is entirely the wrong framework for GUI applications (it's designed around interpreter-&gt;ASE RPC calls). You're right that there's no fundamental reason that you couldn't build a GUI app in another language, but 1. it'd still require a java stub because of how Android works. 2. it would be very hard to do generically, the Android API is *big*. 3. ASE isn't the way to do it. Most of the GUI works by having the OS call methods on your classes, exactly the opposite of how ASE works. This APK-packaging of ASE scripts _is_ useful. It's just not useful for making GUI apps. 
Actually you only have to check all numbers between 1 and squareroot of the number, but you probably knew that and wanted to just keep it simple.
Well, here's to hoping that someone develops a solution for this next ;)
You're in the Python subreddit. Odds are, if someone is reading this, they can program in python or are at least learning to program in it. Discovering that you can use your favorite language (once you learn Python it becomes your favorite; trust me on this) to program an app phone is cause for rejoicing. Don't you think?
Well, feel free to donate a real phone and I'll get right on it. :)
The huge pile of libraries that comes with Python is written in... *\*drumroll\** Python!
You're sleeping 1, not -1, explaining the downvotes.
Of course. And you don't even need to check all of the numbers between 1 and the square root. You only need to check the prime numbers. If x is not evenly divisible by 2, it certainly won't be evenly divisible by four. When looking for candidate prime numbers, you don't need to bother with multiples of two, so, you can just start with an odd number and increment by two. You can take 2 out of your list of primes, and put it back in later, once you're done, so that you don't use it in the trial division process. It can also make things go faster if, instead of calculating square roots for every number you test, you simply take the square of your smallest prime, (assuming you don't use 2), and then compare every candidate number with that square. When you get a number that is equal to that square, you know that that number is the square of a prime, and definitely not a prime number itself. You then get the square of the next smallest prime. This allows you to trade one equality comparison per number for one square root calculation, and allows you to trade one calculation of a square for every square of a prime that you don't perform trial division on. Of course, for maximum speed, you want to use the Sieve of Eratosthenes. However, once you reach the limit of your memory, you'll need to go back to the trial division method. This is all a bit excessive if you just want the 1,000th prime, and probably complicated enough to avoid if you can't get the 1,000th prime already.
I'm not actually familiar with Foobar 2000, I'll take a look and make some notes. I'll have to setup a Windows VM to do it, but that shouldn't take too long.
What tags do you consider important during the initial play other than Title, Artist, Album. If I provided an additional screen to view all the available meta-information would that be satisfactory?
Wait I'm confused you're being ironic right? What you're REALLY telling me is that you want it too be slow as death so you have time for that important phone call before it starts playing the next track right?
So what good is it without a GUI? Can you think of some examples of applications that would still be useful?
Holy crap. I've written many ASE apps that I could pretty up and distribute, but never had the means. This is amazing.
For me the bullet points are that it has media-library-database features, but it builds that database from scanning a directory (or multiple), without doing any automatic moving around of anything (it is also nice that it is really easy to ignore the library stuff), and then the nearly-arbitrary configurability with sane, useful defaults (so one way I abuse this is that I have featured artists split off into their own tag, the support for customizing everything means that those show up in my music lists). The customization shows up everywhere, so, for instance, if you can think of a way to sort some music, there is likely a way to do it. The tagging features in Foobar are also really nice, but those don't seem so important on a phone.
awesome, thanks for trying out IncPy, pyry! i'm the creator of IncPy and just private-messaged you with a request. thanks!
amen, i would as well! that's why i'm trying to recruit new users right now! (i'm the creator of IncPy) the trivial examples i show on the webpage and video demo are merely for demonstration purposes. i don't think anyone would have the patience to read through my descriptions of running it on my friend's research data mining scripts :/
Yah, this is one of those cases where working on a existing project would have been more valuable than starting from scratch.
(i'm the creator of IncPy) the time.sleep() is in my regression tests and video demo to simulate a 'long-running' pure computation (e.g., grepping through a 1GB file). of course, in most real scripts, you probably don't want to artificially add in any delay, but for a demo, i wanted to keep the on-screen code as simple as possible, so i just used time.sleep() as a proxy for some real computation.
LARGE buttons for use in environments where you don't want to hunt for the right one (e.g., a car).
I'd really love a reliable way to skip to the next song without having to touch the phone. I have some iPhone headphones and I can pause by clicking the mic area but if I double click the phone(droid incredible) automatically calls the last person that called me which was a very awkward moment the first time I discovered that. Ideally, I'd like to recognize these events 1 click = pause 2 clicks = skip forward 1 song 3 clicks = skip back one song hold = Fast fwd through current song
You'll have to ask Steve.
Still would fix the following; main reason I'm pointing these issues out is if you're going to try and get googlejuice via listing 'common python patterns', they should at least be topnotch in code (else you wind up propagating bad habits)... * Raising Meaningful Errors: raise ValueError('Some error about val %s' % str(v)) misses the point of my original issue- it's a one time fix to the issue I mentioned instead of changing how you pass the args (so that the issue never occurs). Use raise ValueError('Some error about val %s' % (v,)) instead. * Dynamic Function Arguements has the same hacky workaround, instead of just wrapping the puppy w/ a tuple... * Error Recovery Pattern; aside from the 10s timeout being a bit screwy, the StringIO usage is pointless. import sys and give print_exc sys.stdout instead. * Error Recovery Pattern: You're still swallowing basically every exception under the sun. Exempt RuntimeError, KeyboardInterrupt, and SystemExit... when those occur, the app 9 times out of 10 should shutdown right then/there; Note if you're just targetting python2.6 (and make that point clear), poke at BaseException as Peaker points out further down...
Feel free to port it. You might get some distance with the Android NDK. You will still need to generate a Java stub though since that is how Android communicates to apps. But a clever person can make that transparent to the programmer.
`return 0`? Ew. You should always use `True` and `False` for booleans. A simple `if` statement should be written without parens. `if(condition)` looks like a function call. Keyword args shouldn't have spaces around the `=`; `cur = 2` should be `cur=2`. And, as noted below, recursion isn't the best way to solve this problem in Python.
I second looking to Foobar 2000 for inspiration. The biggest daw of Foobar2000 would be it's customization options e.g. I can choose what is displayed when a song plays and how it is laid out, I can install plugins to add DSP effects, etc. Some of this may not be possible, I have not delved that far into development for Android (yet!). You may also want to look at how [Rockbox](http://www.rockbox.org/) (custom firmware for ipods) works with it's simple template system.
Well here's my two cents, like others have said, gapless playback, LARGE buttons, perhaps as a car mode, when in car mode the screen shouldn't lock (or at least that should be optional) FLAC playback. I also would really like the ability to specify that a track is an intro for another track, so the intro would never be played alone. I think I might be the only person who cares about that though...
Niceeeeeeeee!
Amen. A decent music player app that has "love" and "ban" buttons for Last.FM. A decent search function that can do some level of regular expressions. A decent playlist editor. Dynamic playlists that update when you charge your phone. "Suggested tracks" based on the currently playing track, or a selected track. Why do ALL of the current (crappy) players have album art implemented before these things? All album art is good for is wasting resources and draining your battery. Functionality first, eye candy later. (Wow, I think this whole thread is going to be hijacked by the music app suggestion)
Why not leave that up to the user? I love the way the "Collection" section in the left pane of Amarok 1.4 had a 'flat view' option that you could configure. You pick the columns, and your search criteria applies to them. EDIT: I use the comment tag a LOT. Most of my tracks have moods or descriptive terms in the comment tags for building dynamic playlists.
Semi-related: A while ago I was interested in the performance of PIL compared to ImageMagick and MATLAB. I created a small program using PIL, ImageMagick ('convert' invoked from a bash loop), and MATLAB to rotate a 2560x2560 jpeg by 1 degree, 2 degrees, 3 degrees... 360 degrees, and write each file. I don't have the numbers off the top of my head (or the programs ;) ), but I remember the general theme. PIL =~ 10 second ImageMagick =~ 1minute MATLAB &gt; 3 minutes I was shocked to say the least. I expected PIL and MATLAB to be close, with ImageMagick a long way behind (because of the forking costs). I was happy though, because it validated my extreme distaste for MATLAB :)
I wasn't intended to make a perfect post, I still see and fix errors. Primarily, I tried to give some idea of doing things like how to make an application to continue even when an error occured. Some of the snippets are taken from programs I have written when I was new to Python. I felt that there is something wrong in some snippets but I just don't want to postpone publishing it and decided to fix the errors gradually after publishing. Still, I also don't want to propagate bad habbits. I plan to go through all snippets and look for anything I will not use if I have written them now. And again thank you (and other redditors) for helping me on that subject or I wouldn't have fixed them that quickly.
The lock screen should have audio control. Its what I miss about the iPhone the most ... actually thats the only thing I miss about it.
Here are my thoughts on the cases: * Dynamic Function Arguments: I don't think it is a hacky workaround. Because what I am trying to do is to get a string representation of the tuple object and the most common method to do that is str builtin. * Raising Meaningful Errors: Yes, it is more intuitive to use (v,) and it also allows addition of items without danger. * Error Recovery Pattern: I used StringIO because it is written to a log file through a funcall in the original program. I just changed it to a print for that post. Also, I am now catching Exception class like Peaker has pointed out.
Yes, it is just a tuple. But I included it because the pattern resembles multiple-value-bind in Common Lisp.
AFAIK there's an app for that.
I've tried MixZing, and as far as I know thats the only one. It was a bit jenky.
&gt;First, I ran the pure python test: the write took 83 seconds, the read took 202 seconds. Not good. &gt;Next I tested the same data in C++: the write took 4.4 seconds and the read took 2.8 seconds. Impressive. &gt;The obvious path then was to write the serialization code in C++ and expose it through an extension point. The read function, including putting all of the data into numpy arrays now takes 7.5 seconds. I only needed the read function from Python, but the write function should take about the same time. The thing that concerns me is that the Python code still takes almost three times as long to read as the C++ code, even after applying the obvious optimization. 
My big quirks with a music player app (maybe not for all, but this is my dream app): * Huge album art/nice jpg rendering. I am someone that likes to throw in very HQ album art, but the Android stock player seems to blur the jpgs more than the iPhone music app does (probably to save ram). It should look just as brilliant as the original source file. * Gapless playback with full support and scanning of open source formats, be it lossy or lossless. * Support for discogs/allmusic integration including catalog information and all other metadata associated. When pulling up a song, the user could, at the click of a small button when playing a song, read user reviews about said album or read a professional review. Discogs has a feature that is called a master ID for each album and supports listing reader reviews on each individual instance of an album. * Like the Music Mod player, widgets to customise the playback and usefulness of being outside the player and still being able to control what song (or album) to play. * In depth options menu giving the user control over the behaviour of the player, such as the disabling of the [following action](http://www.weownu.com/images/CAP201006281104.png). I cannot tell you how many times I hook up my Android to the call Aux In, accidentally bump the cable, only to have the very (bad) cable pop out of the headphone jack ever so slightly and the song change instantly. * A much nicer GUI, either minimalist or feature full, or at least the option to customise from a standard set of displays. That's all I can think of off of the top of my head, I hope this was somewhat helpful.
They are currently aliases to the same object, no?
Lock 2.0 can do that + some other stuff. [LINK](http://www.appbrain.com/app/com.google.code.p.slideunlocker2d)
Doesn't appear to have been mentioned, but an app that was somewhat skinnable would be awesome. Just having the ability to change color scheme would be nice. I'm a bit sick of the slick black media player.
More importantly about the list vs. set thing is that you lose the order on the existing list even if you convert it back. The ordering is unstable and may differ between Python versions, so you should sort the list afterwords if you want it in a known order. If you don't care about order, why were you using a list in the first place?
That seems incredibly inefficient. You're allocating the nums array for every integer, and sieveing the multiples of *every* number below the current when you only need to do the primes, and there's only actually a single new number to check. You'd be much more efficient with the naive approach of just keeping the primes in a list and checking `cur` against each prime. For actual efficient use of the sieve method, the array of booleans should either start big enough to reach all primes you're interested in, or, if you need to grow unboundedly, should expand on an as-needed basis by a larger amount than a single item. (Or just recalculate it based on the offset you've reached and you won't even need to reallocate)
Very cool! Also interesting is that the PSF is sponsoring this group in an upcoming [packaging sprint](http://montrealpython.org/2010/07/packaging-sprint-5/).
you can use nth*log(nth) (and a little bit more) to get a threshold, but he didn't say do everything for him.
Aroberge, I have this code right now ... I believe when "prime_start" reaches 9 reaches the number 9 it goes into a loop is_prime becomes "false" and then it just is never reverted back to "true" , so it just skips the entire "if is_prime" section and loops. How would you recommend reverting the "is_prime" variable back to "true" after it has been changed false for the first time? import math prime_counter = 1 prime_start = 3 while prime_counter &lt; 1000: count = int(math.sqrt(prime_start)) is_prime = True #see below for why it is needed for divisor in range(2, count+1): if prime_start % divisor == 0: is_prime = False # not a prime, so end the loop, but first note the result if is_prime == True: print prime_start prime_counter = prime_counter + 1 prime_start = prime_start + 2 print "is prime" 
What are some cool things you can do with python ASE?
Is is safe to just avoid java, keep getting pygame down and hope within 5 moinths, pygame will be able to run on Android? I really dont want to learn java to make my simple 2D apps. Advice please!
Seems interesting. For one thing, I fully agree with the author about [distutils being very complicated and hard to grasp](http://cournape.github.com/Bento/html/faq.html). I never understood crap about that Command thing. I'll check it out some time.
I understand old habits are hard to break, but print-as-a-function can save you 50% keystrokes. Behold: Python 3.1.2 (r312:79147, Apr 1 2010, 09:00:47) [GCC 4.4.3 20100316 (prerelease)] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; p = print &gt;&gt;&gt; p('fu!') fu! 
I don't think python 2.6 will go out of fashion anytime soon. Far too much legacy work for a rapid upgrade. It will hang around like the old versions of php.
Probably not. If it does happen it won't be happening for a VERY long time (Year or more, easily) -- You're better off learning Java.
http://brad.livejournal.com/2394707.html
These kind of things look nice, but what are the real word use cases?
Let's see: p, hold shift+9, ', fu!, ', hold shift+0 vs print ', fu!, ' Which one do you think is easier to write, and less tiring?
&gt; I haven't used Python for awhile, so I'm probably not using best practices
I think the idea is that any user request that take will more than a few milliseconds to return, (eg some sort of batch update on a heap of tables, manipulate images etc), you pass it off to a queue instead of making the user wait. Makes web apps or whatever seem more responsive plus it would scale a little better. 
Cool, makes sense.
Yay, yet another packaging solution that doesn't work together with the operating systems packaging solution.
That's true, I understood that. My point is that time.sleep() isn't a no-op, it's a side-effective operation. If I wanted to use time.sleep(), for example, to sleep between polling some resource, I wouldn't want it to be optimized out.
Erm, which operating system?
Nor does it seem to be possible to [use](http://stackoverflow.com/questions/2076381/making-an-android-python-service-to-run-in-suspend-state) alarm related routines.
Few questions (not criticism). Just want your opinions. * Support for py3? * distribute is being planned to be made a std pkg in py3.2, so I was wondering, should we be moving to Bento. It looks good, but it is converting a python code(setup.py) into a yaml-style config file. Why not just stick with distribute?
That sucks, they should rewrite them in C. It seems like it would increase the speed a great deal.
fuck java
&gt;distribute is being planned to be made a std pkg in py3.2 According to who? Distribute is just setuptools with a new name, which sucks. I sort of thought there was a GSOC that was supposed to build something actually useful from the ground-up.
This is awesome. It removes the virtual-env "dependency" entirely ... who-rayyy!
**/r/Python/**
http://packages.python.org/distribute/roadmap.html It's vapor, son. edit: fixed link ... it's broken on the pypy page too... I had assumed they didn't even have a roadmap.
distutils2 is planning to get into the standard library, not Distribute. Similar group of people working on the two things, though.
distutils2 is planning to remove setup.py, and have all metadata expressed in setup.cfg. Also, metadata can change depending on the platform with a micro-language in the fields (see PEP 345). see http://guide.python-distribute.org/introduction.html#current-state-of-packaging for more info on the current state 
your link is broken (miss .html)
There's an important work going on with 5 GSOC students. They work in distutils2, where we get the new PEP implemented and clean stuff from distutils1
Wow a lot of big statements here: http://cournape.github.com/Bento/html/faq.html &gt; Finally, the current development happening on distutils-sig is mainly the work of web-developers, who have a different vision of what packaging means. Most of their goals are specific to web-development needs, often against known good practices for packaging elsewhere. What are the examples of these poor practices, and have they been presented to the distutils/distribute developer team ? Also, of the six bulletpoints regarding Distutils flaws, at least three of them (documentation, code quality, adding tools to the build chain) could certainly be improved in a non-controversial way, given enough resources. Distutils2 could certainly address at least these in a non-"peripheral" way. 
&gt;I wonder how much of this project was conceived before Distribute was created and the distribution situation was a lot more dire. Distribute was probably the motivator for making this. After seeing the ineptness and hype around a failed api and implementation, he likely started. The solution the community came up to get around the failings of distribute and distutils was PIP, and Virtual-Env.... which both complicate the issues, and do very little to actually fix them. &gt;What are the examples of these poor practices, and have they been presented to the distutils/distribute developer team ? I've personally tried to explain very slowly and deliberately on IRC what is wrong with distutils.
Use a buffer for the audio.
I'm not sure that IRC is the most appropriate place to make an informed decision about a product as core as distutils. There's a mailing list that would attract a lot more public comment. It's not entirely clear, but it seems like part of the goal of this tool is to fork off the Pypi community itself, scientific libs that prefer Bento's approach would now only be on a new "scientific-specific Pypi" and begin draining from Pypi, is that not correct, or if it is, how is that not destructive to the cohesiveness of the Python community ?
http://ask.github.com/celery/faq.html#what-kinds-of-things-should-i-use-celery-for
&gt;It's not entirely clear, but it seems like part of the goal of this tool is to fork off the Pypi community itself, scientific libs that prefer Bento's approach would now only be on a new "scientific-specific Pypi" and begin draining from Pypi, is that not correct, or if it is, how is that not destructive to the cohesiveness of the Python community? I'd imagine he'd be happy to have pypi adopt bento. As it is pypi for any of my projects (web *or* scientific) is completely useless. I package and install everything by hand. &gt;There's a mailing list that would attract a lot more public comment. The response I received did not exactly make me think that would be worth my time. If you are in any way involved with these projects, I ask you to please take a look at prior art. This shouldn't be difficult. There are plenty of great packaging tools for other languages from where to draw inspiration/shamelessly copy. I will say the plans for the gsoc stuff for distutils2 look decent. Bento looks better though.
&gt; If you are in any way involved with these projects, I ask you to please take a look at prior art. I'm not. My agenda is threefold: 1. I would like distutils2 to have as much focus, attention, and resources as possible, so that Python can have a trouble-free and rock solid build/distribution framework that everyone agrees upon using. Total rewrites from elsewhere (edit: this does not mean "nowhere", or that the features/design of the rewrite are poorly considered or not taking existing work into account - it means, "not related to distutils development or such that we can all make use of without a huge loss of compatibility") just suck that focus away. 2. I really have no intention of packaging all of my projects under two or more separate distribution systems just so that everyone can use my libraries. That doesn't make life any easier for me. 3. I wouldn't look forward to having two or more separate sets of "hunting down why the C compilation/installation failed" skillsets, if 20 or 30% of libraries now install with an entirely different system. It's naive to think that any new, entirely rewritten approach isn't going to have tons of showstopping bugs for years to come (or that you're going to get anywhere near 30-40% of packages to move off of the built-in distutils approach or its variants in the next decade). Package distribution is extremely complicated, and having multiple approaches just means you now have N-times as many mysterious issues and incompatibilities making life miserable for everyone. Splintering the user and developer bases means coverage for each approach goes down. 
Thanks, such a topic seems to be rarely covered in a FAQ, I didn't think to look.
1. distutils is broken by design. I simply *can't* use it in its current implementation. 2. I don't use pypi. I *can't* use pypi. 3. See my responses for 1 and 2 I can't use any of the current "tools". If there is an alternative that works then I will use it. I have no interest in "keeping the community intact", if it means I have to continue packing up distributions by hand.
I prefer the function. It lets you easily change the separator and end character. Also, changing the output stream makes a lot more sense than weird double angle brackets. The only troublesome bit is pressing shift for the parentheses, but come on. 
I have deployed a few tornado apps and its not bad. The response time is very good and the reliability is phenomenal for such a young project. However, they haven't made a new official release for about 9 months, so to get bugfixes, you have to maintain your own branch. I have a feeling facebook just threw this one over the fence and don't plan to put much into it any longer. Yes, there is a little activity on github, but how about a version 0.2.1?
Perhaps, but there is something odd about the Twisted code base. I can't quite put my finger on it, but it's discomforting...
Justinsaccount, I wanted to write you to let you know I finished the code to find the 1000th prime. The results are not pretty but the final result matches with an online list of the first 1000 primes. I listened to aroberge and then fixed a loop that was never ending by updating the prime_start variable in the loop. I probably spent 6 hours total on these 20 some lines of code. What do you think of the final result? I didnt get into using function to create the code because I just today start reading about them and was told I should be able to finish the last code with simple loops and variables. I tried using the Sieves alogorithm but didnt know how to really translate it into code because I didnt know how to subtract entire lists of numbers from other entire lists of numbers. import math prime_counter = 1 prime_start = 3 while prime_counter &lt; 1000: count = int(math.sqrt(prime_start)) is_prime = True #see below for why it is needed for divisor in range(2, count+1): if prime_start % divisor == 0: is_prime = False prime_start = prime_start + 2 # not a prime, so end the loop, but first note the result if is_prime == True: print prime_start prime_counter = prime_counter + 1 prime_start = prime_start + 2 print "is prime" 
Aroberge, I finished the code with your help. What was tripping me up was the fact that in the "for loop" i wasnt updating the "prime_start" variable and was caught in an endless loop. Thank you for your time and coaching. I appreciate it. import math prime_counter = 1 prime_start = 3 while prime_counter &lt; 1000: count = int(math.sqrt(prime_start)) is_prime = True #see below for why it is needed for divisor in range(2, count+1): if prime_start % divisor == 0: is_prime = False prime_start = prime_start + 2 # not a prime, so end the loop, but first note the result if is_prime == True: print prime_start prime_counter = prime_counter + 1 prime_start = prime_start + 2 print "is prime" 
He'll need to write an interpreter. Not that that's so hard; it's just something that will need to be done.
Sorry for not replying sooner... Look at the line: prime_start = prime_start + 2 Should it not be executed each time you do an iteration of the "while loop"? If that is your conclusion, are you sure that it should not be placed elsewhere in your code, perhaps at a different indentation level?
the line prime_start = prime_start + 2 occurs at two different places; you could simplify this. One way to do this would be to set prime\_start=1 initially and then, right after the "while ...", include prime\_start = prime\_start + 2 Rather than writing if is\_prime == True: you can write: if is\_prime: Finally, I would suggest adding a comma after print prime_start, Try it and you will see why. ;-) Otherwise, I think that for a first program, you have done well. It should become easier as you write more code. Good luck!
(I am the author of bento) Those poor practices have been discussed to no end for several years. There is no agreement at all, so having several projects "competing" is natural. As for the context: I have been maintaing for three years now the NumPy distutils extensions. I know the distutils codebase extremely well, and I have already worked before on a way to extend distutils with scons (he numscons project). While it did work to some degree, the experience was horrible. Several people in the scipy community have tried to work around distutils shortcomings for almost a decade now - none of them succeeded. As for your other points: - code quality: you cannot fix distutils code. The distribute team went to the same conclusion. See Tarek's annoucement following pycon 2010 about the renewed focus on distutils2 to avoid breaking existing code in distutils. - extending tool: adding toolchains is extremely difficult. For example, if you want to add a new tool in your chain (say instead of .c -&gt; .o -&gt; .so, you want .pyx -&gt; .c -&gt; .o), you have to rewrite some commands, which become quite painful to handle once you have to deal with setuptools/distribute (because of monkey-patching). If you need to know some user option into a command, you need to repeat the option to each command, because you cannot share options. Distutils was a huge improvement over the previous situation (manual makefile), but the last decade has showed that you can do much better. Although bento is an implementation from scratch, its features are strongly inspired by things that work in other languages.
I don't intend to drain anything or force people to use anything I write. But the scipy community, in its majority, finds pypi near useless. So we want something that is useful for us - I don't think there is anything wrong with that. If you are interested in the rationale, you can see the distutils-sig mailing list for the thread following Guido's question about scipy's issues with distutils (http://thread.gmane.org/gmane.comp.python.distutils.devel/11359).
One of the goal of bento is to make packaging for distributions easier. So saying bento does not work together with OS packaging solutions is equivalent to saying e.g. autotools do not work with OS packaging solutions.
This rewrite does not come from nowhere, but from extensive experience trying to work within distutils beforehand. From my POV, starting from scratch, with our experience of what's wrong in distutils, is more likely to succeed than refactoring the existing code. Other people disagree, hence the two projects.
Bento is still in design phase, so I don't advise you to use it unless you know exactly why you want to use it. Using distutils/setuptools/distribute is certainly the way to go today. What's arguably better in bento as for today is the support for autoconf like configuration, a simple way to include data files, and a simple build tool for C extensions (with parallel build and automatic rebuild with files contents are changed). Bento does not support python 3, is not integrated with virtualenv, easy_install or pip, cannot talk to pypi. I intend to support all this, though.
So here are things I am observing about that thread, without having read the whole thing as of yet - 1. the responses to your ideas seem to be completely open to your suggestions, except that they'd like to integrate them into distutils, which possibly you think is impossible, or would dilute your own vision of things (and to the latter point I would suggest that compromise might be very constructive here, if applied judiciously). 2. I didn't see you making suggestions that are contrary to what "web developers want", but again I didn't read the whole thing yet. I would love to have the install prefix in setup.py, for example. The distutils code is certainly a total mess and I agree as soon as you need to do something, it lets you down. If distutils2 isn't planning on improving upon that, we have to start making lots of noise right now. 3. The FAQ on your site has a slightly hostile vibe to it (such as the statement I mentioned), which can only create divisions. We really don't need divisions in the world of packaging and distribution. You'd be better off just saying, "here, I wasn't getting my point across on the mailing list, so let me illustrate how I think it should be done. Distutils can learn from what I am doing here, or adopt these practices, or make itself compatible with this improved system." That would be a better outcome than, "we can't use distutils or pypi, you won't listen to us, so we're making our own system, bye." You'd do the community an enormous favor if you could keep trying to get your improvements into the mainstream core of distutils, or somehow make it so your improved system and distutils retain some modicum of compatibility, so that a project with lots of distutils-based dependencies can take advantage of your improvements without requiring repackaging of all its dependencies. I have nothing to do with the development of distutils, I'm a package provider, and I also appreciate having hundreds of packages used by my own internal projects that all package and install themselves in exactly the same way. So making sure I don't have to use two or three incompatible systems simultaneously for a single project, and that I can continue to release my own packages in just one way which is the same way as all the other packages that use them, is my only agenda here. Since my main package is SQLAlchemy, I'm fairly certain its used not just by the web development community but by at least some segments of the scientific community as well. 
if I wanted to do that I would use wget directly :) the problem is that wget's code is hard for me to contribute so I'd like to have a Python version to customize/improve as I want to.
Why don't you just make your own? You said you wanted to contribute; start a pyget project!
My fingers can't tell the difference when typing. I'm not exactly unaccustomed to typing parentheses.
well yes, if there's nothing like that already in progress I'll give it a try. I think the best would be a twisted-based daemon and CLI tools to schedule stuff, what do you think?
1. The openness is superficial. We disagree on the implementation issues. For example, options handling: there is simply no way to change this short of removing the whole command concept altogether. The compiler classes are also extremely hard to reuse (for example, MSVC compiler instances, although subclassing from CCompiler, do not share the same attributes - cc vs compiler_so, etc... And in some cases, they are strings ("cl /nologo ...") and other those are sequences (["gcc", "-c", ...]).). I am curious: what do you think would be the advantages of integrating with distutils2 (distutils will not change AFAIK) ? I mean very concrete, API-like changes. Also, note that I made the extra effort to split bento in separate parts, some of which could be reused externally. The build subsystem is actually a separate project, and the only reason why I went to the extra pain of doing so is so that distutils2 may use if it they want to. I am also working on extending wininst installers and eggs extensions so that you can convert losslessly between them - this will also be reusable. 2. I agree this part of the FAQ is badly written. It boils down to enforcing metadata vs not enforcing them. You can push any crap you want on pypi, even distributions without a name ! CRAN, Hackage enforce metadata, and they work much better than pypi in my opinion. I believe the later is a consequence for the former. Any discussion on that point was shut down - you will notice than neither enthought nor activate are discussing much on the mailing list anymore, and went their own direction. One of the activestate people was handled quite rudly, for example when making that point - and you would think that activestate would have some experience in packaging. I am tired of arguing, really. 3. I agree, I will lower the tone a bit. There is no denying that politics and person problem (of which I am partly guilty) play part in here. I would note that several people have mentioned to me privately that they stoped arguing on distutils-sig, because everytime they made a point which was not in agreement with the official policy, they were marked as trolled, non constructive, etc... Bento actually started as a proof of concept to answer to one particular person who kept shutting me down because I was not showing code. 
Well, I've never tried network programming in python beyond urllib...so I can't really make suggestions there. What exactly is your goal, anyway? A total wget replacement, or something merely similar?
&gt; to implement all http features and support recursive downloads, mirroring, resuming, retrying and everything else that wget is capable of.
But what would you be scheduling...? I can see how you might like to use twisted, but I don't get the bit about scheduling stuff.
wget's source is well organised and well written. I once coded a small patch to add a little something to wget having never seen the code. That took about 30 minutes.
ya, got that wrong. yes, distutils2 is going to be in py3. I know that groups overlap for distutils2 and distribute.
i know, i got the name wrong here. it's distutils2, not distribute.
If you aren't comfortable with the language, it doesn't matter how open source it is.
But, if you're not comfortable with C, patching wget should be a task second to getting comfortable with C. On second thought, patching wget should be a task third to getting comfortable with C, which in turn should be a task second to getting comfortable with Scheme. Follow me? :P
yes, for the first time. But now I have a ready-made .py file. and copy paste into my new package, change a few names and presto, i got one working. Even if one doesn't have the one ready, copy paste from an existing package. tweak few things for ur package. To get started, see the [expert python programming](http://www.amazon.com/Expert-Python-Programming-practices-distributing/dp/184719494X) book's packaging chapter, and you can get started.
I just reread that. You're right. I should go to bed. I've been taking too much Ephedrine.
wget should be the initial goal since it's the tool I curretly use and also the most popular one but after being able to replace it "as it is" it would be great to expand beyond its current capabilities. by example, one of the things I hate most from wget is that it's able to read from stdin *but* it doesn't start to download until you close the fd so you can't put it on the background and feed it urls as they come. that feature is only useful for wget to be able to participate in pipes but it doesn't allow you to distribute the tasks or to have it running as a daemon that you can drop urls to it as you browse, it's pretty annoying to start mirroring a portion of a site just to find another url to add to the queue; you either stop the current download or wait until it finishes. another thing that would be great to have is parallel downloads as it now it crawls with a single process wasting a lot of time on recursive downloads but any of these improvements are way beyond my abilities in C at this time.
Take a look at [scrapy](http://scrapy.org/). It's a framework for writing web crawlers. I think it would provide a great starting place for writing a command line utility like wget.
Scheme, Haskell and Erlang are in my queue (in no particular order) way before I even consider C but I guess it all depends on the goals, I'm not much of a fan of low-level stuff.
exactly, I'm not saying wget's code is bad it's just that Python looks much more *clean* and *focused* for this particular task; also [some of the things I would like to have](http://www.reddit.com/r/Python/comments/clsch/looking_for_a_python_wget_replacement/c0thb3v) are not vanilla and even with libraries I can estimate it'll be harder in C than a higher level lang.
C's not a [low level language](http://en.wikipedia.org/wiki/Low-level_programming_language). It's required reading. Assembly is low level.
I've worked with Scrapy in the past and while I'm not a big fan of it I guess it'll be a good starting point. back in the day reconfiguring a spider in runtime was a serious hack, but probably they got past that by now... I hope.
well yes, but even so it's certainly lower than Python I mean, there's no garbage collector nor objects or any other abstraction besides struct/union, everything is hand-made (but probably with the right libraries this would be barely noticeable). I may not have the best appreciation of the language since for that I need to learn a lot more of it :P but I think C shines its best when you use the high-level part while taking advantage of its proximity to the bone, am I right?
&gt; I think C shines its best when you use the high-level part while taking advantage of its proximity to the bone, am I right? I had been trolling you, but you've got this one right so I will stop. I still think you should learn C though, you'll be a much better programmer for it. And especially if things like hacking basic unix commands appeals to you. C doesn't shy around the deeper programming concepts. I really do think that you'll find learning C with the goal of patching wget a sufficiently stimulating task.
Ah OK. Well, get to it! :P
ohh well played, you got me there :) also thanks for the advice!
My problem is not so much with using distutils (I know, if you bang the keyboard long enough, it will work), it's more about accepting to depend on shoddy codebases. For example, I use py2app (which is based on distutils) to build my apps, and it works pretty well. Recently I looked into converting py2app to py3k, and I have big troubles understanding the code. I believe that part of py2app's messiness is caused by the fact that it's based on distutils (you know, custom Commands and all that crap). I haven't gave up though (I want to move my apps to py3k) and I'll try again, but I'm thinking more and more about simply extracting the relevant parts of py2app out of the package and make a non-distutils-based package (I can't use other packages, such as bundlebuilder because py2app is the only one that has a "plugin" building feature). All of this makes me uncomfortable for depending on distutils. I'm always interested in ways out.
I've heard that argument for pretty much every python/ruby/php packaging solution ins existence, but those claims very rarely materialize.
Yes. Why wouldn't I want my Python programs to work well with the rest of my system?
Your talking about apples and oranges here... and missing the entire point of why it's important to have a fully functional python packaging system.
I think such command line doesn't exists, because there's no need actually to another tool since wget does a great job and easily installable from any distribution. Anyway I can understand your point, to develop such application I will take a look to httplib http://docs.python.org/library/httplib.html and urllib http://docs.python.org/library/urllib.html (expecially urlretrieve) plus various scraping utilities like the great beautifulsoup http://www.crummy.com/software/BeautifulSoup/. It shouldn't be too much difficult, I guess. As you said twisted is a great network library (I still doesn't understand the daemon stuff) but maybe is too much power for such an utility, and much focused on network capabilities (just you don't need servers) than to scraping.
It's important in order to make sure I can never ever simply use a single command to install or update any application and all it's dependencies, regardless of source language?
I assume you haven't been deploying Python based webapps in the last few years...
Well, tell me what prevents integration of a bento package (i.e. what makes it harder than an autoconf package). I have contributed to a few non trivial debian packages BTW, so I am at least familiar with distutils issues w.r.t. packaging (bento allows full integration with the FHS, exactly as with autoconf - the only difference literally is bentomaker configure --prefix=somedir ... instead of ./configure --prefix=somedir. Data files can be installed in paths which are not harcoded ($mandir instead of /usr/man). The other big piece is easy compilation customization (CFLAGS, etc...). This is still missing in bento.
I was looking for donate button, but (luckily) they need other kinds of help. So to save you time this is what they need: &gt;PythonSecurity.org is a blossoming community, and we could use your help to make it grow. Here are a few ways in which you could help: &gt; &gt; * Write an article &gt; * Contribute fixes and patches to software projects to improve security &gt; * Spread the word! 
Oh, come on. :/ I was looking for a technical answer on why this particular thing is great news for the python community, because everyone is happy about it, and got a shitton of upvotes. 
Yeah. Or maybe not.
The track number is kinda important to me, as I tend to listen to full albums at once. The additional screen is absolutely satisfactory, because when I have time to read such information, I'll also have time to do those few clicks to reach the additional screen.
Why do people assume that packaging is not a solution to deploying web apps ? I find it much better than the alternatives - it allows admins to use the tools they know, and the tools are certainly more reliable. It allows for security to be handled effectively through the system tools.
Definitely the latter, the depression hit and we couldn't afford to keep them, we lost a lot of contracts at that point, and one of the few we kept was the one I was the primary developer on, so I got really lucky. And by then a lot of the primary development was complete so I just had to do maintenance. Now we're picking up a bunch of new work so we're looking at picking up a few more people. 
bento does not do anything with (or without or against) virtualenv. They deal with totally orthogonal issues. On the contrary, I intend to integrate virtualenv for automatic distribution testing - in scientific packages, it is relatively common for packages to require installation to be tested (some weird nose/sys.path/C extensions interaction that nobody has been able to track down). Virtualenv is perfect for this, as a lightweight, python-specific "build chroot".
Official release today - yeah!
I don't think anyone anywhere is denying that 2.6 will go out of fashion any time soon. Do a lot of us think that there are a lot of people out there who *could* move to 3.x sooner than they think? Yes. People seem to think jumping to 3.x is some crazy 6-month purely transitional period where you have to code 24/7 in order to get running on 3.x. I converted a 2.6-based framework including a about 8k lines using the C-API and about 15k pure-Python in around a day and a half and it works both on 2.6 and 3.1.
The print function/statement accounts for so little of my code that I could not care less how printing is done. Honestly, I don't really understand why so much of the discussion taking place around Python 3 on here, on python-list, on IRC, on blogs, seems to focus on printing.
yeah wget does a very good job but as explained elsewhere I think there's still room for improvement -specially on the mirroring capabilities- and I find it hard to do so on the current codebase. this is overkill if you think it on the "I want to download a file" scenario but I'm thinking more on a downloading station which can attend several jobs over time (automated, coming from other scripts) and also improve the currently-sequential downloading mode wget uses when it crawls an entire website. thanks for the comment!
Thank you! I have a Sansa Clip and use iTunes for podcasts and such. I'll try to report back when I have time to test it.
I finally made another script to synchronize the podcasts. It takes the latest ones from iTunes and copies them without exceed a max size. [http://gist.github.com/463649](http://gist.github.com/463649)
What autoconf package are you talking about? Autoconf normally generates a Makefile, which is used to build and install a program. It is very easy to make the install target for the Makefile work well with e.g.rpmbuild. But please enlighten me to how, exactly Bento makes proper packaging easier. If what you say is true, then I would obviously be interested.
Glad you asked. Yes I have, actually. And because of all this Python retardedness, it is really hard to simply build a deb package of our web apps, put them up in our repos and do an apt-get update.
Compatibility is a great thing.
Thank you to everybody who worked on this.
Cheers!
No autoconf package in particular: they are all much easier to package than distutils ones, everything else being equal otherwise. The reason it works well with rpmbuild is not because a makefile is generated, but because packages can be customized to fit exactly the FHS, and because each distribution can customize the compilation flags as needed. bento solves the first issue already (you have exactly the same install options as configure, with the exact same meaning), and intends to solve the second one in a near future.
Does this work with dynamic playlists, too?
I just tried, and it works. You just need to change the value of the variable MY_PLAYLIST with the name of the playlist...
Finally... dictionary comprehensions!
How come I've never heard of Tkinter before? I always thought GUI in python required silly libraries 
MemoryView looks interesting.
You think tkinter isn't silly?
Yeah, I was just being nit-picky.
Wasn't there supposed to be an overhaul of the re module for this release?
Sweet! Podcasts on my N800 again! Heck, using SMB sharing, I can do wireless syncing!
tkinter is very silly.
Virtual-env is a completely unnecessary requirement though. It adds complexity that serves very little purpose. I assumed that I could manually set the library-path with bento, easily... as I saw examples for the data directories... &gt;bentomaker configure --mandir=/opt/man If you allow for ... &gt;bento config --libdir=/path/to/project/lib Then there is really very little purpose for a 'virtual-env'.
So you won't recommended for app development? 
Absolutely not. I've had a lot of problems with cross platform compatability and speed. As well as a general lack of features. It was fairly easy to learn I suppose. It's much more sensible to just use GTK or QT4, since they are heavily documented, have many more features, and you can use them in pretty much whatever language you want.
Woohoo! Now anyone know when NumPy will support it?
What suggested that to you?
Second on QT4. QT4 sucks. PyQt4 is just peachy though.
https://launchpad.net/~pythonregexp2.7
Just FYI, this only works on Mac OS X (BDAF: confirm?) due to requiring AppleScript.
Just in time to port all my code back to 2.x! Wait...
That code seems to occasionally get pushed into http://bugs.python.org/issue2636, but after skimming the issue comments I don't see where that was ever accepted (nor have I seen a PEP about it).
&gt; QT4 sucks. PyQt4 is just peachy though. Isn't PyQt4 a wrapper of Qt4 or am I missing something with that naming scheme?
This is my first question whenever I want to upgrade Python.
Shame, re has some serious flaws that need addressing
Sweet. Though: * An ordered dictionary type This feels like creeping featurism to me. I've always considered dict to be unordered and any time I've read code requiring order in a dict, I thought there was a flaw in the expectations somewhere.
Well, how would you deal with stuff depending on different versions of the same library using tools like apt-get? I am hosting Django 1.0, 1.1 and 1.2 webapps on the same server, and it is not an option to just force an upgrade (the releases aren't backwards compatible). Also, you don't need many webapps to have this problem. It is enough if you have just one of them and a _staging_ server (with such a major upgrade you want to give it a week to thoroughly test it went smoothly).
Why, simply add a dependency on the specific Django version you need to your package. The package manager will install all the required Django versions. This is a very common situation, many linux systems have multiple versions of e.g. libstdc++, glibc and various other libraries installed in parallel. 
&gt; I've always considered dict to be unordered and any time I've read code requiring order in a dict, I thought there was a flaw in the expectations somewhere. Think XML. An ordered dictionary is great for holding an XML tree with attributes.
Numpy. And many of the packages that rely on it.
Also good for JSON, config/INI files and other, possibly user edited, files. Reading some data and then writing them back in their original order is better in those cases.
PyObjC and py2app (it's gonna come...).
Nose. I see there's a py3k branch, but they say it's experimental. I'll give it a whirl some time...
[PIL][]. [pil]:http://www.pythonware.com/products/pil/
PIL isn't on 3.x yet? Oh, man. That's another nice library I need.
try py.test, while nose is being upgraded. Heard py.test runs nose tests too.
Zope/Plone/Grok/Pylons/SQLAclhemy/Mako/VirtualEnv
Erm... I may be missing something, but how would you tell your Django webapp which version should it use?
By setting the path to include the relevant directory.
In response to the post's edit: &gt; If anyone's looking to contribute to the Python ecosystem, then grab one of libraries named below, fire up 2to3, and get hacking. It's not that simple. I don't think that those libraries are not ported yet because their authors don't want to. It's probably because doing so is complex and that you can't simply "fire up 2to3 and hack it". So what I'd suggest instead is to investigate what attempt have been/are being made and see if they need help with those attempts.
I suppose quite a few of them, for example Numpy and PIL, are largely implemented in C, too. Is that a problem?
I don't know for sure, but from what I could read in the docs, changes to the C API are minimal, so it shouldn't be much of a problem, no.
Some people think that the problem is that libraries keep changing in incompatible ways. The idea that installing multiple versions is a solution to avoid backward compatibility is really flawed. That's ok when developing, but for long term deployment, it brings more problems than it solves. It also encourages a thinking into ignoring backward compatibility, which really hurts the said communities IMHO. Maybe if you take a step back, and thought whether you really need three django versions on the same server, you would find yourself in a better position. And at least on unix, there are solutions like chrooted environments so that you can install multiple images in the same kernel. This gives you reliable, consistent and verifiable update (in particular security updates). Especially if you start handling tens or hundreds of deployments.
You seem to be under the impression that python has a system similar to the C loaded, where each program can request a specific version of a library. Python does not have such a system: you cannot request version x of foo, if you import foo, python will always takes the first one in sys.path.
SQLAlchemy has 3.x support as of [version 0.6](http://www.sqlalchemy.org/news.html).
This might be true if it wasn't implemented in a large number of third party libraries, including django. The standard library is where a well implemented and tested ordered dictionary implementation should go.
Which is why you have to set up the sys.path correctly for every app. You usually have to do that anyway since you probably don't want the modules of one application visible in another. 
FWIW many of the things Nose (plugin-less) did, unittest now integrates (see unittest2, which is the port of Python3's unittest to 2.x)
[Natural Language ToolKit](http://code.google.com/p/nltk/)
With some libraries I've also heard complaints that: * The developers don't have enough time and/or the project is essentially abandoned. * It would require rewriting a fairly integral portion of the whole thing. (Some low-level socket details changed between 2 and 3 that's causing headaches for CherryPy devs.) * Doing development in 2.x and autoconverting to 3.x for every release to support both versions would defeat the purpose of switching to Python 3.x. * The overhead of keeping separate and somewhat synchronized versions of a library aren't worth the trouble. * Previous point, but people are waiting for a working 3to2 tool, so they can keep main development in the Python 3.x branch while backporting to Python 2.x automagically for every release.
Cruel mistresses, these two. They seduce you with their charms and then with nary but a bump in the OS version they've got your cash and your Nokia and they're out the door. Hey, who needs trailing underscores anyways?
Also, it can be useful as a class's `__dict__` in various metaprogramming scenarios. Eg. various ORMS use class definitions to define tables. It's useful to retain the order of columns defined when created in the db.
There are some dev builds of NumPy for Python 3.1 here (Windows only): http://www.lfd.uci.edu/~gohlke/pythonlibs/
PyOpenGL.
That's a great tutorial, but if it's trying to be newbie-friendly, then why the hell doesn't it use QT's visual GUI design tools to make it *even more* newbie-friendly?
NumPy (and Matplotlib, Scipy, etc.) builds are out due to this kind soul: http://www.lfd.uci.edu/~gohlke/pythonlibs/
You're probably correct. The name might be come of as a bit too technical for someone who is looking to build their first GUI application. I think what I thought was that I didn't want to fool anyone that was starting to learn GUI programming to start out with PyQt since the development of the GUI is a bit tricky. At least if you compare it to .NET together with the Visual Studio designer.
It definitely can be used for app development. I would even go as far as to assert that if you need a quick &amp; dirty GUI --a bunch of labels, buttons and textboxes -- Tkinter might be one of the best tools around. It's Python, it's included by default, and if you have some minimal experience with it, you can throw the GUI together almost as fast as if you've used a real visual GUI editor. Also, the Grid layout manager is nice and Text control is incredibly powerful (Idle does all its syntax highlighting, autocompletion, and stuff using only the functionality it provides). However, as soon as you want something nontrivial, like, you know, a drop-down combobox maybe, things definitely turn to the silly side.
As Raymond Hettinger said at PyCon 2010, "Ordered dictionaries are easy to do well, but they are even easier to do poorly" (or something like that). The stdlib OrderedDict has the same big-O characteristics as the traditional dict, whereas most other implementations tend not to behave that way.
wxWidgets
I made a first attempt at porting scipy, and it was not really difficult. Hoping to get something working after euroscipy is not totally unreasonable...
The biggest difference that I've experienced was in module initialization/setup, but that was solved via a few #defines. There wasn't really anything else that came up and made me think "damn, how am I going to fix this one?" However, my use is much different than that of NumPy. They support a wider range of Python versions and are more than just a thin wrapper on top of another DLL (I think).
It is but it's also way more usable in my opinion. Minus the documentation. The documentation kinda sucks for it.
WSGI on Python 3 is broken and so we won't see any web libraries anytime soon.
Also, I don't miss much in Python 2 so I don't care about Python 3 current at all.
Just curious, how is it broken? And does that means we won't see Werkzeug on Python 3 anytime soon?
I don't understand the logistics of this situation due to Python 3.x's incompatibility with Python 2.x. Isn't there a daunting number of software packages written in Python 2.x on several Linux distributions? How will that work? Will every software package have to upgrade to Python 3.x before a Linux distribution can introduce it? Or will they somehow have both Python 2.x and Python 3.x running on the same distribution? SOMEONE TELL ME WHAT'S GOING ON!!?
I wrote about that a while ago: http://lucumr.pocoo.org/2010/5/25/wsgi-on-python-3 There is a spec mod_wsgi is implementing for Python 3 which however is based on abusing unicode strings which I don't want to implement because I still hope there is a way to change that thing over to bytes and abandon the standard library for the low level implementations. Werkzeug itself does not require the standard library for any of the things that are currently broken on Python 3 anyways regarding bytes.
[django](http://docs.djangoproject.com/en/dev/releases/1.2/#python-compatibility) &gt; A roadmap for Django’s overall 2.x Python support, and eventual transition to Python 3.x, is currently being developed, and will be announced prior to the release of Django 1.3. Extrapolation says this is gonna take until March 2011. (10 months total = 1.1 came in 29-July-2009 and 1.2 came in 17-May-2010).
Psycopg2 and Pycryptopp. and nose, even though there is a working nose3 branch it would be nice if it were supported.
So start using 2.7 then. You get plenty of the new features and you can still use the 2.x libraries. It's a win-win.
The authors of those patches seem to have taken the approach of completely completely rewriting, but not providing the changes in small, reviewable segments.
+1
Procrastination is a bad thing. Either we do the switch soon or else we'll be banging our heads against the wall since there won't be a Python 2.8.
Hint: functions are closures and decorators are very general.
Hint: functions are closures and decorators are very generalized.
Just out of interest what advantage does using eclipse give you here? I know the assumption is that newcomers want an IDE but eclipse seems a bit heavy for python development.
Would be nice to have a big colour coded page for this red - 3.x compatible not being worked on orange - being worked on, not all dependencies on 3.x yet yellow - being worked on and dependenies all on3.x green - available on 3.x
Hopefully once 3.x support is standard in numpy/scipy a lot of other things will be unblocked
2.7 is a nice upgrade but 3.x has a lot of niceties such as small consistency fixes here and there for nicer code, better unicode, function annotations, wider implementation of contexts in the batteries (with urlopen(...) as u:...), dict/set comprehensions, absolute imports as default... Now, I'll happily use 2.7, 2.6 or even 2.5; but I use Python because I like the clean code and the powerful/useful-without-complexity features like decorators, docstrings, generator{s, expressions}, list comprehensions... and 3.x improves all that. And of course the real reason for 3.x is to make the implementations easier to maintain, which everyone benefits from.
I should have linked it because that is what I was thinking of. Apparently, django did it the not so good way.
I believe they'll have 2.x and 3.x on the same distro
FYI: dictionary and set comprehensions [made it into 2.7](http://docs.python.org/whatsnew/2.7.html#other-language-changes).
For me, using eclipse together with PyDev helps out by adding code completion and by checking for errors while I'm coding. Is that possible in other IDEs?
The [README](http://github.com/mikeboers/PyHAML/blob/master/README.md) on GitHub explains in more detail, but basically I wrote a HAML implementation that supports nearly every feature, and tried to only make changes where I was forced to because I'm not working in Ruby. It cross-compiles HAML into a Mako template, so you get all the goodies that come along with that as well.
I suspect that if a distribution does ship (or is shipping) Python 3, they will ship Python 2 alongside of it for a very long time (maybe 6-10 years, perhaps even "forever"). 
Anyone else having trouble making test_gdb pass?
Oh I know, though if you're targeting 2.7 you're reasonably targeting 2.5 or at least 2.6 in most cases. Maybe in a year or so 2.7 will be widely deployed but at the moment it's not really deployed anywhere for any practical purposes. Most servers run 2.5 and most desktops 2.6. Seems Debian Squeeze will be 2.6 despite 2.7 being out for some time before Squeeze is stable, meaning 2.7 might not be deployed on many servers before maybe 2012. Of course it's easy to get dictionary and set comprehensions with constructors and generator expressions, we can get many 2.7 and 3.x niceties in 2.6 with future-imports, and some things like ordered dicts are backported on PyPI. But as I argued in my original post, I use Python for the cleanness and sensibility; 3.x just is more clean and sensible than all these hacks. TL;DR for both my posts I guess: I enjoy Python today and I'm looking forward to the 3.x line being the first choice.
To bad we don't have `#define` for Python code; that'd actually make it a lot easier to simultaneously support both versions.
Virtualenv was forked for Python 3 support: http://pypi.python.org/pypi/virtualenv3 (A general pattern: while it's not terribly hard to convert any one library, it's very hard to keep *one codebase*, creating a maintenance headache.)
Twisted. And it's not a priority for the team. Even, fiews dependencies of twisted are also unavailable in 3k. I supposed that it's true for many others projects.
[Nice idea](http://pypi.python.org/pypi/pypreprocessor/0.4.0)
For a long time py.test was really better than nose, but packaged poorly. I think they've figured out their packaging, and stuff like magic assert introspection they've always done better.
Interesting. I can imagine sticking primarily with: #if 3: except Exception as e: #else except Exception, e: #endif And then it would resolve to something like: #Python 3 version: #except Exception as e: #Python 2 version: except Exception, e: #end condition Then line numbers all make sense. Of course it wouldn't help with editing directly-importable code, which is nice during development. Actually, no, it should be re-runnable, so you can run it live in either environment and always switch back and forth, so the first example would just comment out one or the other section depending on your version. Then the code is also always syntactically correct for some version of Python.
It's not that heavy
For [my project](http://code.google.com/p/apsw/) by far the most amount of work was my test suite. I have 99.6% code coverage and have to do some fairly abusive things to cause various conditions to happen. If projects do not have good extensive test suites then I don't know how they do the port since how would they tell what is broken? My codebase (C for the extension, Python for setup.py and the tests) supports both Python 2 and 3. I did the porting during the betas of Python 3 and was embarrassed to be doing it so late. Now it seems like some sort of medal is due :-) A big problem at the time was poor Python documentation because if something didn't compile or run as it changed or no longer existed then none of the documentation would mention the old way. It is similar to the problem that you have to know how to spell a word in order to look it up in the dictionary. 
You should cross post this to ruby subreddit ;-)
Code completion should be standard in any half decent text editor. Vim, emacs, notepad++, geany etc. all have it. Emacs has error checking but is probably a little difficult to use for a beginner's python tutorial. There's a whole bunch of options [here](http://www.reddit.com/r/Python/comments/cbvns/your_favorite_python_ide_go/)
Take a look at a new module called [six](http://pypi.python.org/pypi/six). It provides a similar end-result to #define -- you use certain six objects which will work the 2.x or 3.x way depending on where you run.
I was about to link you to the bug report...but you made it :)
&gt; If projects do not have good extensive test suites then I don't know how they do the port since how would they tell what is broken? I think this is probably something that is holding a bunch of people back. There are plenty of projects which I'm sure *could* in some way support 3.x, but they can't even think about porting until they build up (or in some cases, start) a fairly exhaustive test suite. Have an upvote for supporting 3.x.
Right. Let's have fun with sys.path. When you have one dependency to manage this way, it's OK. When you have 5, it starts being a PITA, but still doable. When you have 20 of them, it becomes obvious to you that you've got a serious problem. Now add Other People (TM) to the mix, and you realize you are toasted. Fortunately, there were some clever people that realized that this may be a problem, and they made stuff like virtualenv or buildout. And, guess what? This tools use those awful Python packaging systems (actually, pip and distribute are sort of nice). Slightly inelegant? Maybe. But it does a great job conserving your sanity.
Well, in an ideal world people would get APIs and interfaces right the first time. Libraries would be backwards compatible, upgrades would be painless and everybody would do them asap. Unfortunately, this is not the case. Upgrades require non-trivial amounts of work (even for Django, which is really great in this respect). Some applications keep depending on older versions of libraries, and upgrading them just isn't cost effective (they work and you've got plenty of other stuff to do). Other applications are so important to you don't want to risk breaking them just because of an upgrade. Finally, if you decide to upgrade such an app, you want to test the hell out of it on a staging server before putting it into production. And in order to do that, you need more than one version of the library on your server. Now, chrooting and stuff would work, but for most Python or Ruby applications it's overkill. You can achieve mostly the same effect with virtualenv, which is a pretty simple script that does some magic with sys.path and symlinks. Why build a house when all you need is a little bit of duct tape? (Specially that, in this particular case, the duct tape is gonna have way less administrative overhead ;)
really! i am not sure what you are bitching about.
My show stopper is GAE and web2py :(
thanks, didn't search properly i guess. i needed this.
ya, i too feel py.test is better than nose. There's lot of magic going on, but is great once that's figured out
really! thanks for the info. But never got an opportunity to use it outside pylons/grok
Decorators let you do exactly what blocks do in Ruby - and more (proper functions = keyword arguments, docstrings etc). A decorator function can also take a lambda or a function reference. This seems to be an uncommon pattern in Pythonland; decorators are almost exclusively used to transform functions and methods defined in outer scope, but a decorator doesn't have to return a callable. I don't know if there are good reasons this isn't common in Pythonland, could just be a cultural or historical thing. Imagine: @re.sub(regx, text) def text(match): return match.group(name) @map(lst) def lst(element): return str(element).upper() Neither of these are implemented, but the language is not the show-stopper. As for assignment, what the decorator returns is what the variable holding the reference to the function becomes. Kinda ugly, admittedly.
hmm. Now I see what you are saying. but many are trying to write more readable code. Not that the above isn't readable. But many try to be more lenient towards pythonic idioms.
Yea, I'm not necessarily recommending this, just sayin' Python can do it and it's not that hideous. I'm not a big fan of the standard idiom of function definition first and function reference later: def substitute(match): return match.group(name) text = re.sub(regx, substitute, text) Notice how similar this is to the idiom that prompted decorators in the first place, though: def classy_shit(…): pass classy_shit = classmethod(classy_shit)
That's right.
You've got a point. I won't argue against either Vim, emacs or notepad++. They are great tools. I just find it easier to get eclipse running with debug, code completion etc.
How is SQLAlchemy on 3.0?
SQLAlchmey has py3k support, but not all drivers are upgraded yet, especially oracle and pgsql
Nonesense. We've never had a project dealing with that many dependencies, but if we did, it would be trivial to make a tiny python script that goes through the package dependency list and adds the relevant directories of each dependency to the sys path at startup - shouldn't be more than five or ten lines of code.
I was intending to make a crawler of sorts for my purposes -- with the ability to feed it urls, have it extract and categorize ones I want from the html DOM, bandwidth/connecting limiters. However, my goals are a little different -- as I want to use it for a website crawler that can run on it's own ... as opposed to a client-side app for small crawl jobs.
[just fine](http://buildbot.sqlalchemy.org/builders/postgres-pg8000-3.1/builds/313/steps/shell_2/logs/stdio)
It seems to me like the python team should have made python 2.x and python 3.x runtime compatible. Wouldn't it be nice if you could mark a file as Python 3 and have it work with 2.x code?
That page is a great resource. I've been using it for a while.
your goals seem to be more adequate for scrapy since that's what it was designed for.
What can I say? Good for you :)
The purpose of Python 3 is to be incompatible with Python 2.x.
The main point of Python 3 is maintainability of implementations.
cx_oracle supports python 3 as does pg8000
Use a language which can properly be sandboxed: Tcl, Javascript and Lua are worth looking at.
You can lock Python down pretty well. Just don't exec with any of the state shared: &gt;&gt;&gt; locals = {'__builtins__': {'True': True}} &gt;&gt;&gt; globals = locals.copy() &gt;&gt;&gt; exec('if True == True: some_value = 10', globals, locals) &gt;&gt;&gt; globals {'__builtins__': {'True': True}} &gt;&gt;&gt; locals {'__builtins__': {'True': True}, 'some_value': 10} &gt;&gt;&gt; exec('class Foo: pass', globals, locals) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;string&gt;", line 1, in &lt;module&gt; File "&lt;string&gt;", line 1, in Foo NameError: name '__name__' is not defined &gt;&gt;&gt; exec('import os', globals, locals) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;string&gt;", line 1, in &lt;module&gt; ImportError: __import__ not found Notice how changes don't propagate out to the actual global/local state. Just don't provide builtins that can be dangerous.
Anyone build psycopg for Postgres 9.0b2 and Python 2.7?
Magnificent! Is the intent for it to always be dependent on Mako, or do I misunderstand? Can one use the pythonic version to just render [X]HTML without any makoness included? Also, do you know how HAML could support XML? Or does it automatically support it by design?
The standard dict type is still unordered. You need to use OrderedDict from the collections module to get this behaviour. 
It is still experimental, but may be something useful for this scenario in the future: [PyPy Sandboxing](http://pypy.org/features.html#sandboxing). (I really hope that PyPy succeed as an alternative to CPython.)
Google app engine might fit your needs. They got a sandbox built in.
I've built it in such a way that it would not be impossible to add support for other template engines, assuming they have a few nessesary features. I think it is a relatively conservative feature set: expression substitution, control statements, the inclusion of arbitrary code into the execution context, and we need absolute control over rendered whitespace. I'm very familiar with the inner workings of Mako so that is what I built it against, but I was originally inspired by the similarly named [HamlPy](http://github.com/jessemiller/HamlPy) which builds Django templates. Without the help of another template engine, one can build only static markup with this. A minimal one could be relatively easily constructed for simple jobs, but I personally want all the power that comes with Mako. Could you be more specific as to the differences from HTML to XML that you see being a problematic? I think (though I am no expert) that I have been erring more on the XML side (either self closing tags or matching pairs, boolean attributes actually have values, quoting attribute values at all times, etc). I almost have the XML doctypes that come with Haml ready to go...
That's not very safe. Run these lines in your "sandbox": object = True.__class__.__class__.__base__ file = [t for t in object.__subclasses__() if t.__name__=='file'][0] The script now has full access to read or write any files it wants on your hard drive. Writing sandboxes is not something you should do on the spur of the moment; you need something like [RestrictedPython](http://pypi.python.org/pypi/RestrictedPython) that's actually had years of battle-hardening.
http://pypi.python.org/pypi/RestrictedPython
HTML 5 support is valuable, but I think that using mature Markdown implementation like Pandoc is better.
That looks perfect, thanks! I'm not sure why I didn't come across this while searching :-)
pylons
Is there any reason to do compiling HAML to Mako template instead of compiling HAML to PYC bytecode or interpreting directly?
I fully understand that it is possible to escape from a simple sandbox like that. Depending on carlio's needs the above would possibly work, although RestrictedPython is definitely the better choice. If he was having each user run the script on their own machine, the above would be sufficient; after all, the user already has access to their own machine. Then again, using RestrictedPython would still work. In the end though, a sandbox is not a magic silver bullet. Bugs in code will lead to points through which a user may escape. Even in a perfect sandbox, any Turing complete language will bite the sandbox user as it is impossible to provide both a Turing complete language, and prevent attacks ranging from the juvenile forkbomb to much more subtle attacks like writing to and filling ``/dev/shm`` (it's probably 0777 on your system). I retract my previous comment as you can always do: object = 'hi'.__class__.__base__.__base__
...ok, so this looks really cool (sensorpedia moreso than just `spylib`). But it would be awesome if I could browse the map/list of sensors available today. I see lots of screenshots of what I want, but how do I get there from here?
Why?
Markdown is more transparent and have much implementations for various languages than this.
Thanks.
Almost something suited for python subreddit [faq/wiki](/help/faqs/Python/)?
cx is partial and i don't use pg8000
I'm not sure you were responding to me actually, otherwise I don't quite get how your comment relate to mine :) In any case, the point I was making is not about the implementation of an ordered dict, but the fact that to me, requiring one is usually a design issue or trying to do something that shouldn't be done by a dict structure in the first place.
I like markdown and it is the one I used so far but I have some problems with markdown: uses underscore and does things_like_this, does not allow to put bold and italic into links, does not support html5, does not allow to specify alignment of figures, does not allow to specify the language it code blocks. More specifically about the markdown2.py implementation: it does not support tables, it is slower on small portions of text like this comment.
blocks
Yes, the tension between backward compatibility and sucky API is a tough one. I think that the web community does not value backward compatibility enough, though. I certainly agree chroot is overkill in many cases. But the duct tape becomes quite an overhead once your administrators don't know python that well, or when you start having dozens of servers to maitnain. My point is more a reaction to "you should always use virtualenv" than to virtualenv itself, which is certainly the right solution of many common cases. 
Yup. Then most of what I had to write dealt with markup generation, and not template rendering (which Mako is quite fantastic at, IMHO). It is a much smaller package for it; much easier for me to test.
I'd use QT if those asses didn't keep PyQT from being LGPL, or if somebody would port Pyside to windows.....
I am assuming you use a common networked share here for _ _file_ _? This way of doing things has been around since the Novell heydays. It beats a hardcoded path insert anyday.
No, what makes you think it's on a networked share? If a user downloads something I wrote and moves it to /home/user/some/obscure/folder/that/is/in/the/depths/of/hades and then symlinks it, the program will still be able to import the necessary libraries even if it isn't "properly" installed into the Python SITE path.
It is bad practice, yeah - It's fair to assume that the environment is setup before hand. Failing that, you should be attempting to import, and catching an import error. What you really should be doing though is using virtualenv to create app specific environments.
This makes it easier for moderately sized applications to be run with user privileges because you can symlink the main executable which can be placed where you want without having to adjust any of the code.
Don't think of it as being for applications, that'll help :) I've used it to count how many music files I had on my SD card (python's os.walk works pretty nicely for this) and as a hacky way to make a GPS logger. 
It looks cool, but I couldn't work out what it is
I agree with you about tables, and _eventhis_, but my original question of: &gt;Why? was directed towards hongminhee. He was ready to snuff out your markmin without providing any reasoning. &gt; Using Pandoc is better Im sure a lot of people, when first presented with markdown, said: &gt; why? [ existing markup language ] works fine! you know? No playa hatin from me
I dunno, it would be nice... javascript does some interesting stuff with anonymous functions
Surely that should work without your insert? /weird/path/to/test.py: import sys from os import path print sys.path[0] print path.dirname(path.realpath(__file__)) when run: $ python /weird/path/to/test.py /weird/path/to /weird/path/to $ ln -s /weird/path/to/test.py /other/test.py $ python /other/test.py /weird/path/to /weird/path/to I haven't done any custom setup or anything, it seems like it should work out of the box. Maybe I misunderstood the problem...
That would definitely work... if I had a team of minions they would be working on it now. (And they'd all live on teamofminions.reddit.com)
Is there a reason these markup languages use regex instead of trying to parse out tokens? I haven't read SICP so forgive me for sounding naive. *Im not criticizing the design, I am just curious as to why regex are better suited here*
Fair enough, I'm just bitter, hehe. Yeah, totally true everybody should be allowed to do what they want, I don't have to read Objective C or Perl if I don't want to and they don't have to read python :)
Wait, you are confusing something. I've just checked: when I execute the symlink (either directly or as `"python test.py"`), the real path (`"/home/.../depth/of/hades"`) is automatically prepended to the `sys.path`. Did you mean hardlinks maybe? But then `realpath` wouldn't help...
Requires clicking through an obnoxious ad.
Coming from the author of pip and virtualenv... If it's a "program" and that it is implemented in Python is incidental to the user, *and* all your dependencies are pure Python (no C libraries), then I personally consider this path modification to be good practice (assuming also you distribute a zip/tarball with the source plus dependencies, etc). When I'm doing things like this I often use a virtualenv environment for development, but then have a script to build the zip with everything in it. This gives me the virtualenv benefits of being able to easily install things and make sure I'm using only what I've explicitly installed, while not placing that same management burden on the user. The way pip installs packages also makes it relatively easier to rearrange libraries, or to cleanly upgrade. One small change though, I do: `import site; site.addsitedir(path.join(path.dirname(path.realpath(__file__)), 'lib'))`
... Is it frowned upon to do export PYTHONPATH=$PYTHONPATH:/path/to/my/package in /path/to/my/virtualenv/bin/activate ?
As far as I see it, this only gets you halfway there. Ruby's blocks can return values: test = [1,3,5].inject(10) {|sum, element| sum + element} # (test now is equal to 19) It seems impossible to do that with the decorator trick. It can certainly be used to do some interesting stuff, but the more advanced uses of Ruby blocks still seem to be beyond Python's grasp unfortunately. EDIT: Formatting
If you're putting that in your main script, it's actually unnecessary. Python already puts the directory containing the script in the first place on sys.path.
Even if it's a symlink? What version of Python? EDIT: So it does; see my OP edit.
You're right. See my self.post edit.
You and viscence are right. See my post's edit.
&gt; What version of Python? Er, from 1.4 and up, if I recall correctly.
&gt;which is certainly the right solution of many common cases. I would strongly disagree with that assertion. Because of the nature of python's (ruby, perl, etc) pathing system, it would be better to build your applications in such a way that you can deploy them atomically. Not to mention on most other languages this has become the *best practice*, ask a ruby-er and they will laugh at your "virtual-env". You can make a "distribution" that lives in a sub-directory of your project. ~/libraries, etc. The main issue with a virtual-env, is that when I get pulled in to fix your project after you got fired... I have no idea how you set it up. If you have a ~/lib directory in your project, it works immediately ... on my local machine... and it's impossible to break consistency between machines, because it's atomic. Which turns out to be incredible useful in this place I call reality.
It is a tradeoff. With a tockenizer you scan the code only once but in Python, with regex you scan the copy multiple times but in C. If the rules are not too many regex is faster, at least in my experience.
http://www.reddit.com/r/Python/comments/ck9tj/why_python3/c0taz1u
Python is not younger than Java. http://python-history.blogspot.com/2009/01/brief-timeline-of-python.html http://www.java.com/en/javahistory/timeline.jsp Depending on how you read things Python is a year older than Oak and several years older than java. 
&gt; refactored Flask internally. *It now consists of more than a single file*. The beginning of the end.
That's a side effect of the excessive documentation. We have 4 times the documentation in the files than the implementation. Concatenated into a single file we are way past the 1500 lines of text, so breaking that up into separate files makes it easier to look over it I think. There was some discussion about that and it was about 50/50 so I just threw a coin :)
You can always do what jQuery and SQLite do and have the build process spit out a monolithic file.
Why does he not use eric4?
Thanks, I was just going to post this. Strange the the person who wrote this works for activestate. I would think they would know about the history of one of the languages that they support.
You also took micro out of the title (which im not sure it ever was). I thoroughly enjoy your product but i really hope it doesnt lead to more complexity as it grows.
But what would that give us?
Wouldn't it be easier to be able to pass your library path to easy_install/pip? easy_install --where=~/app/libs/ PIL Seems like that would be ideal. That way, if you were to say write a web framework; you could easily wrap pip and force a common pathing scheme on your users. For all you django users out there, it would go something like this... &gt;python manage.py install PIL and bob's your uncle. edit: Please don't downvote this because you don't understand how bad of an idea virtual-env is. If you think I'm wrong respond.
Yes, this is actually best practice in most other languages. Virtual-Env is an un-holy abomination.
not really "Pythonic" - too wordy (no graphic) 
I haven't tried eric4. Seems to be nice though, what are the benefits compared to eclipse?
 Python: the way fixed. (edit: corrected bad indentation)
too many spaces
Tiny bit easier to embed in an app, same reason SQLite and jQuery do it.
That seems to be mocking python to me. 
Flask itself never refers to itself by name so you can put it directly into your application's package and do "from yourapplication import flask" instead of "import flask". Can't get any easier :)
Sure, its just nice to have a single link and say "Download this flask.py and drop it into your app". Its not a huge difference, but if the imports are all relative it probably wouldn't be hard to make a little script to "compile" it. Maybe I'll look tonight, will poke on Twitter when it stops exploding.
In that case he could have worn a t-shirt with the text "Python is for Guidos".
Zope corporation sold them a long time ago. (I bought 2.) Also, someone (Google?) was handing them out as schwag at PyCon a couple of years ago.
Care to elaborate on your distaste for virtualenv? It seems like most Python developers love it (or at least find it useful during development), and I've never heard anyone talk bad about it, so it'd be interesting to hear a different perspective.
 Python: Ni! done.
Why should flask *encourage* bad organizational practices? This isn't 2005 anymore, python packaging mostly works. Setting up a virtualenv with pip and doing `pip install flask` is trivial.
That works for a dev, but 1) AppEngine doesn't work like that and 2) for a little end-user app it is nice to bundle dependencies. Look at Django if you need an example of this.
&gt; import site; site.addsitedir(path.join(path.dirname(path.realpath(\_\_file\_\_)), 'lib')) from os import path For those wondering... (like /me :P)
1. **I'm a minimalist.** Virtual-Env, pip, easy_install/distribute... just to install packages and manage your projects? No thanks. 2. **I hate magic.** Virtual-Env means you are supposed to be using a bunch of symlinks to *simulate* a python distribution that is isolated from your other projects. Though depending on how you (or in many cases someone else) setup the environment, this isolation may or may not be there. The development box may differ in ever so slight but horrific ways, and it will be transparent. *Hooray magic!* 3. **Doing it right is slicker.** Doing it in the way I just described, allows for a number of rather useful things to occur in addition to quarantining projects as *simply* as possible. The simplest and most rewarding is that your "project" directory is working. If you decide to rename it, it doesn't break because it works on symlinks. If I want to get my new computer illiterate designer going on my project, I don't have to take over his laptop for 2 hours and pray that github is up... I just send him a zip of the latest code we have on our development machine, and write down on a paste-it note what the command is to run the web-server. You can even check the whole thing into your source control. You can manage your dependencies with sub-repositories. It slices, it dices. I think forcing, or at least strongly encouraging people to use a consistent layout for projects (ie: ~/vendors *cough* ruby *cough*) ... would be good for the community at large, and by extension... me. ps. What is with the down votes? It's uncouth.
Google gave them as a donation at EuroPython to every participant, guess 2007 or 2008.
I don't think you could make anything with ASE that's useful enough to sell. It's kinda pseudo-commandline, targeted towards small scripts that don't need a UI (or much more than a single-line input). I've used it to count how many mp3 files are on my SDcard and as a crappy location-tracker, there's not a whole lot more that you can do with it. 
 Yes, but the reason behind the unavailability of libraries/support for NATIVE GUI stuff is because (at the moment) you cannot pack your scripts as .apks (and thus, cannot put them on the app store); As soon as this is available (soon) I'm sure that Python and other langages that ASE supports will become first class citizens in the Android world. Here's a list of some ideas: (Some of these, you may need to layer over a teeny python web-server and launch a browser for making a GUI -- so that's an easy solution to the "OMG I DONT HAVE A GUI API!" problem.) * Remote Control for HTPC (using web interface with buttons) * Automatic Garage door opener/porch light activator; ASE includes a Locale plugin which allows executing scripts via Locales situation engine. For example, you could launch a script when you arrive at work, or at 5PM, or when a particular Wifi network is in range. * WiFi scanner/logger for wardriving. (Interface or not, both can work fine.) * Tethering app via mechanize/beautifulsoup/python-based proxy server * Remote-check a website for a "stolen" flag, and activate a stolen mode. (Front camera on EVO anyone?!) * Use TTS to speak incoming text messages to you (or to whoever stole your phone, haha) * Sound-board (Web interface)(I'm sure SOME idiot has paid money for one of these.) * HTML/AJAX/CSS 2D Game. Python back-end serving up the data, HTML/Javascript for rendering. * Push-notification client similar to growl (Python DOES have access to MakeToast()) It really just takes a creative mind to think this stuff up. Even without NATIVE gui capabilities there are a lot of things that could be made. Give it about 2 months and I'm sure there will be plenty of availability to use Python to create GUI apps in Android using the normal API (albeit, it will probably be through some sort of java/dalvik back-end, but you'll be able to program in a pythonic manner - probably without much noticeable performance hit).
Why the hell cant google invest some money for the 2d developers? Damnit!
I wish Guido walked over to the Android Dev team and kicked them all in their balls for not taking advantage of Python and things like pyglet/pygame. Fuck this ghetto Java shit, its HELL.
easy_install kills kittens. Please stop using it and use pip instead. The ministry of packaging appreciates your support.
These were given out by Google at EuroPython in Birmingham July 2009. You had to complete a wire puzzle to "earn" it. The front has the Google logo on it, which is cool. I love this shirt. EuroPython is in a couple of weeks (July 19-22, again in Birmingham), perhaps you can get one there? 
Yeah, after working with python I can't STAND semicolons or curly braces at the ends of lines. I know, small, trivial little crap...but it really does bother me. &gt;=( Same for statically typed languages. Python is *strongly* typed, but you don't have to define it each and every time. You look at x = 12 -- What the hell is 12? -- It's an INT, obviously! So why the hell should I need to declare what it is? If I want it to be a string, I'll put quotes around it...ugh &gt;_&gt; Yeah, I know; I'm a damn diva aren't I?
There's no browse in the prototype at the moment, but updates will be forthcoming. Edit: Here's what you can look at so far: http://www.sensorpedia.com/blog/sensorpedia-sneak-peek/
I got one of those at OSCON when Guido gave a talk in 2005.
fuck james gosling
why not creole? 
I'm with orangesunshine on this one, and I don't think the downvotes on his/her comments are warranted. For my larger projects, I use a *real* environment, not a virtual one. Because I've got root on my development machines, I create users and home directories for them (you know, using the `adduser` command). I can then customize the users *real* environment by setting `PYTHONPATH` in their `.bashrc`, install libraries specific to that project, symlink scripts to `~/bin`, etc., etc. And because it's a separate user account, I'm free to set it up to match a production environment much more closely. (Think about it, your production deployments should *always* be under a different account than your personal account, and this approach decouples the development environment from your personal one). The biggest plus is using multiple interpreters --- download pythonX.Y, untar it, run `./configure --prefix=$HOME` and you're set; no mucking with your package manager and no clobbering your personal setup. There are a few drawbacks, all easily fixed. Running GUI apps? Run `xhost +` before sudo-ing to the development account. Heavily customized `.emacs` or `.vim`? Put those in source control and check them out, too. 
I think I got one from Google at PyCon 2007 too.
&gt; On the project page located here you can see that the .exe for 2.7 still hasn't been uploaded. Any ideas? Have patience? 2.7 only came out a few days ago...
[This photo](http://www.flickr.com/photos/derlok/2684539390/) was also posted. Where can you get THAT t-shirt? I'm getting a bit tired of my all-black t-shirts.
I've uploaded one now.
You can also build one yourself from the .tar.gz; it doesn't include any C code, so the .exe is just for convenience.
As soon as I submitted, I looked at the word "still" in my original post and wondered if I was going to get called out on it As pje noted, (and thanks for the upload!) there doesn't seem to be any real issue with it working on 2.7 it just needed to be built (something which I wasn't sure how to do). 
You are awesome! *Edit Just downloaded it...how I missed that sweet sweet installing action. Thanks again!
If pip reached version 1.0 I'd consider it. As it is, I'm not proficient enough with Python to be mucking around with packages that are not robust (in the sense of idiot-proof, not in the sense of being full-featured). Unfortunately the internet kills another kitten...
Hm. It'd be very handy to make a Chrome Sync and Mozilla Sync converter. And someone should add Opera Sync to get real awesomeness.
&gt; it just needed to be built (something which I wasn't sure how to do). 1. Download http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz 2. Unzip the file and open a command prompt into that folder. 3. C:\python27\python.exe setup.py bdist_wininst That'll create a dist folder, and inside you should see the executable. You could also just do "setup.py install" to skip building an installer and just install it locally.
[Here ya go](http://www.google.com/products/catalog?hl=en&amp;q=iron+on+transfers&amp;um=1&amp;ie=UTF-8&amp;cid=4534371841252104990&amp;ei=4tQzTPPqGYaKlwfl9v2-Cw&amp;sa=X&amp;oi=product_catalog_result&amp;ct=image&amp;resnum=4&amp;ved=0CEIQ8gIwAw#)
Version numbers tend to be misnomers in real life. 1.0 is just as arbitrary as 0.1 and may not give you an indication of quality. In my experience, i've found pip to be a wonderful and robust tool to use, however the developer does not own a windows box and explicitly states that windows support could be limited, so you're probably better off using easy_install.
Flask itself has two dependencies, werkzeug and jinja, so its not like you could bundle flask.py in your project and expect it to work anyways.
obligatory: http://jcalderone.livejournal.com/39794.html
I made a short script to scrape http://sorbacsra.org/ for the status of my favorite trail system.
What you describe is a good pattern, but just a paranoid warning to those following: watch permissions. There's no need for the user processes run under to have write permissions to the code base -- another user (or group) for this makes more sense.
 Python: foo.spam()
That's a helpful link. Thanks!
Erm, we don't use foo in Python sir. Python: eggs.spam()
This follows the docs almost exactly, only with more tedium and less authority.
This would be a terrible abuse of the whole idea of the 'with' keyword. You shouldn't try and tidy your code simply by hiding some of the variables in another scope - you should instead start using functions with names that do want you want them to do, and then call the functions.
&gt; uses underscore and does things_like_this There’s a backquote syntax: `rendered_like_this`. &gt; does not allow to put bold and italic into link Allowed. `[It _works_ **well**.](...)` &gt; does not support html5 Agreed, but it isn’t a problem of Markdown, but implementations’ problem. I think there will be Markdown's HTML 5 supported implementation soon. &gt; does not allow to specify alignment of figures Agreed also. &gt; does not allow to specify the language it code blocks. This feature makes the markup language bloated. Because it requires implementations to include syntax highlighter.
the outer scope is "polluted" anyway... in your example: with self.my_long_variable_name['craplong key name'] as x: do things with x x would still be available after the end of the 'with' block . see: class withify: def __init__(self, arg): self.arg = arg def __enter__(self): return self.arg def __exit__(self, atype, value, traceback): return False # do not swallow errors a_long_dict={"monkey's name":"Geoffrey"} outer_variable = "outer_variable: I might change!" with withify(a_long_dict["monkey's name"]) as name: outer_variable = "outer_variable: I changed in the 'with' statement" within_with_variable = "within_with_variable: I was created in the 'with' statement" print name print outer_variable print within_with_variable outputs: Geoffrey outer_variable: I changed in the 'with' block within_with_variable: I was created in the 'with' block much simpler to just say: name = a_long_dict["monkey's name"] no wrapping class, no excess indent... much cleaner.
WikiCreole sucks. [Bitbucket][]’s wiki uses it, but I really hate it. Its syntax is not orthogonal. For example, it does not allow to put `**bold**` and `//italic//` inline markup into link `[http://...|//like// **this**]`. [bitbucket]: http://bitbucket.org/
in short, `with` is no `let`. I'd like it to have `let` semantics, but yeah..
You are doing it wrong. Try `//**[[http://...|like]]**//`. The advantage is the learning curve. If you used any wiki before, you probably know a bit of creole. And if you're building a wiki, please use creole. Nothing against different markups. I personally dislike Markdown, Textile, BBcode etc, and prefer to stick to creole and reStructuredText for most stuff. But I dislike non-creole syntax for wikis. Like, "don't make me learn another one".
I personally write a lot of Markdown and/or DokuWiki-flavored wikitext and/or MediaWiki-flavored wikitext, and prefer Markdown over various wikitexts due to its resemblance of plain text. I still agree that the (probably only) advantage of wiki syntax is extensibility, of which Markdown mostly lacks, but this does not explain the variety of similar-looking and differently-behaving syntaxes. (Have you counted the number of different link formats in wiki syntaxes, some of them are identical except for the order of anchor text and URL?) Creole clearly lacks this (again, perhaps only) advantage of wiki syntax, and still fails to unify the most popular wiki syntaxes in the world: they continue to use their own syntax, not Creole. For me Creole is the most ill-conceived lightweight markup language.
Thanks for the clarification. For me the last issue is the most important. Because it allows me to capture the content of the code and process it in different ways. I am not so much interested in syntax highlighting (although markmin will ship with web2py and web2py includes a syntax highlighting module so this works out of the box) but because I want to be able to embed other stuff that I call widgets. It is explained in [this thread](http://groups.google.com/group/web2py/browse_thread/thread/5b8481c48478eed9#) 
I think you're getting confused about the purpose of `with` due to a similarly named (but differently purposed) construct in VB. In python, `with` is to control context - to do something at the start, and finish with it at the end, rather than just to create a namespace alias. To get a shorter version of a name, there's already a *very* simple and fundamental method: assignment. Just do: x = self.mylongvariable_name['craplong key name'] do things with x This already acts exactly the same as the with statement (even if you create a context manager, the name will still be created in the enclosing scope - `with` only controls the context, not the variable) 
You can buy it from [Cafepress](http://www.cafepress.com/pydotorg/1418066) but no black t-shirts at the moment.
I love DokuWiki syntax and used that wiki engine for years. I don't miss much of it with creole, and think that DokuWiki should implement it. If the various engines don't agree on using/planning to migrate to a pretentious standard like Creole, it is not Creole's fault. They are feeding the mess. ;) What I dislike in Markdown and Textile is that they are too dubious and hard to parse. Much easier to make a mess than a wiki-like syntax.
That came up for me and I hit X.
And the minusses as a flamebait: * established collaborative methodology and tools * established static code checking methodology * zillions of webframeworks to choose from, which battle against eachother, and randomly die. * problematic threading and multiprocess support * interregnum between 2 and 3 * packaging and distribution problems edit: packaging 
*Exactly* the post I was looking for. Thanks
indeed, a let equivalent is what I was after. Oh well!
You can have something resembling a `let` by using `class`: def insult(thing): print "You have no taste in %s!" % thing value = make_shrubbery() class Spam: value = make_eggs() insult(value) insult(value) insult(Spam.value)
Gcc does tail recursion optimization. The equivalent python code is: def fact(n): c = 1 for i in range(1, n+1): c *= i return c The result of 10.000! overflows a c int. The c code don't give you the correct result :-( But ctypes is cool anyway ;-)
I wrote a python login script my freshman year for my campus wireless connection. Ported it to ASE (by dropping a third-party library), have it set to run via Locale whenever I get within range of the wireless network.
Here's the same thing as a little C extension module: http://paste.pocoo.org/show/234636/ from distutils.core import setup, Extension setup(ext_modules=[Extension("factext", sources=["factext.c"])],)
dear Python God (and I know you are there (you wrote the antigravity module)): Please take all of the libraries mentioned here and port them to 3.x.
Np, I'm glad it helped!
Looks like he didn't test that code much, the timeit module is being used incorrectly. He probably made the python example overflow because he didn't see a speed difference.
I am just getting into python now to do file and folder manipulation for a large amount of simulations that I run in c++ (the simulations are very computationally intensive). Does anyone know of an easy to follow tutorial / documentation?
lol@downvoting that
... except that his C function does not have a tail call (it's *n* times the result of the recursion call, which a scheme compiler would not be required to optimize). The essential bit is: The iterative Python code would give you the right result because it would autoconvert the numbers into big numbers, whereas C would keep using 32bit (or 64bit) ints and you'd be limited to getting the factorial of 0 through 13 (probably up to 20 or so using 64bit), at which point it doesn't make a difference. For n as large as 10.000, you could also use the Gamma function from scipy.special (gamma(n) == factorial(n+1)). Edit: at about 180, factorial exceeds the range of double-precision floating point numbers. Morale: if you need factorials that high, use scipy.special.gammaln to get the logarithm of that factorial. Which once again proves the point that running away to micro-optimize things is often less useful than thinking about the problem at hand.
Remember that Python has a ``del`` statement that can clean up your namespace. Then suddenly we have something that could make sense for a context, but I don't know if ``__exit__`` could clean up *your* namespace… Imaginary code: with temporary(self.long_variable) as x: assert 'x' in locals() assert 'x' not in locals()
I'm currently working on a datetime extension that makes it easier to record and compute time. #examples: a = time(1,30) # 1m, 30s b = time(1,0,0) + (30,0) # 1 hr, 30m c = time(1,0,0,0) + a + b # 1 day, 1hr, 31m, 30s I'm also creating modules for these time pieces, so instead of saying 24 hours = 1 day, I can say 8 hours = 1 day to figure out how long projects might take and how to bill accordingly. 
you are reimplementing datetime.timedelta ?
I never looked into timedelta, but I was trying to make creating times fast and easy which kind of looks like the datetime.time module. After I did that I started adding operation functions for various class objects. The second line in my example is not a typo. I am adding a plain list to the time class I created.
you should really look into timedelta, it will save you a lot of work
Wouldn't you want to use xrange instead?
I recently used ctypes to interface with a Windows DLL, and it worked great. Speaking of which, I have a highly specific question for anyone who has more experience with ctypes than me: I'm using ctypes' [prototype support](http://docs.python.org/library/ctypes.html#function-prototypes) to handle memory allocation for me, and I have a function that takes a pointer to some data and then modifies it inplace. Is there a way to have ctypes handle this all transparently, so something like `new_data = mycfunc([1, 2, 3])` will work (there's a `paramflags` argument that lets you specify if a parameter is an input or an output, but not both apparently)? I can do it by wrapping my code in a custom Python function, but I'd rather ctypes do it and this seems like a common thing.
http://docs.cython.org/
Why not [Cython](http://www.cython.org/)?
For comparison: i ¡ N¡!
What are you, stoned?
No. * xrange disapears in [Python 3](http://diveintopython3.org/porting-code-to-python-3-with-2to3.html#xrange) * The optimization is not needed: In [1]: timeit for i in range(180):pass 100000 loops, best of 3: 6.61 us per loop In [2]: timeit for i in xrange(180):pass 100000 loops, best of 3: 5.22 us per loop * wally_fish is right. With scipy.special.gammaln no range or xrange is needed ;-)
what does this have to do with python?
You're right. This C function does not have a tail call. I need learn more functional programming and execute *gcc -S* before write wrong things. Thanks for see my error.
¿¡qué te fumaste?!
This subreddit is for Python the programming language, not Monty Python the comedy troupe. Now go get me a shrubbery. One that looks nice but is not too expensive.
good one
Does NLTK's [HMM tagging module](http://nltk.googlecode.com/svn/trunk/doc/api/nltk.tag.hmm-module.html) offer anything useful?
I tried compiling the code and I got the following error: /usr/lib/gcc/x86_64-linux-gnu/4.4.3/../../../../lib/crt1.o: In function `_start': (.text+0x20): undefined reference to `main' /tmp/ccArUQj7.o: In function `factorial': test.c:(.text+0x26): undefined reference to `_fact' collect2: ld returned 1 exit status 
Ni!
Hows this: http://gist.github.com/467639
Yes, right here: http://github.com/csherratt/showtree/blob/master/showtree.py 
There's probably better #crap to tree myvar = ["test", "test2", "test3", ["test11", "test12", "test13", ["test21", "test22", "test23"], ["mebe"]], ["try again", "ok", ["another", "last one"], "lawl i lied"]] #type(var) is ListType #isinstance([], list) def myfunc(arg, tabs): for i in arg: if isinstance(i, list): tabs += 1 myfunc(i, tabs) else: print("%s%s" % ("----"*tabs, i)) #endif #endfor #enddef myfunc(myvar, 0) 
[ActivePython 2.7](http://www.activestate.com/blog/2010/07/activepython-27-released) already includes Distribute (a fork of setuptools, with the easy_install script), virtualenv and pip, so you don't have to install them manually.
uoɥʇʎd
You can use `easy_install --prefix=~/apps/libs/ PIL` I suppose, but you'll have to fiddle around to make sure the installed libraries are findable (if you don't want to have the installer reinstall dependencies) and of course you'll have to fix up the path to import them.
TLDW summary?
Thanks!
You're right. Bad assumption on my part. But the logic still applies. Sort of like installing a windows app while dll hell applied.
* We all enjoy coding in Python; * We want to continue coding in Python; * We don't want a wasteland of failed deployments (leave that to Java (snarky)); * Make useful tools; let those change minds. 
Indenting a tree is easy enough. I want fancy node lines.
Perfect, thanks!
I create a simple ctypes wrapper to full interface Tokyo Cabinet database ([py-tcdb](http://code.google.com/p/py-tcdb/)). Also reading the OpenCV Python interface I learn two good tricks. * In TC some functions return 'void *' and I must free this manually. This is error prone, so I create a 'new' ctypes datatype that free it automatically: class tc_void_p(c_void_p): """Automatic garbage collectable ctypes.c_void_p type.""" def __del__(self): if self and libtc: libtc.tcfree(self) * Also, in OpenCv wrapper I learng this trick to handle your problem: create a new class and use it as a param: class ListPOINTER(object): """Just like a POINTER but accept a list of ctype as an argument.""" def __init__(self, etype): self.etype = etype def from_param(self, param): if isinstance(param, (list, tuple)): return (self.etype * len(param))(*param) * If you want to handle variable arguments, use a closure (I think that this approach is mine, and not from OpenCV wrapper): def cfunc_va(name, dll, result, *args): """Build and apply a ctypes prototype complete with variable arguments. This functions is similar to cfunc, but use a closure to variable argument ctype conversion. """ def create_closure(func, fix_args): def call(*args): var_args = [_ctypes(type(arg)) for arg in args[len(fix_args):]] func.argtypes = fix_args + var_args return func(*args) return call fix_args = [arg[1] for arg in args] func = getattr(dll, name) func.restype = result return create_closure(func, fix_args) There are more tricks in [tc.py](http://code.google.com/p/py-tcdb/source/browse/tcdb/tc.py) and in [opencv-ctypes project](http://code.google.com/p/ctypes-opencv/source/browse/trunk/src/ctypes_opencv/cxcore.py) 
upvote &lt; downvotes? You know, I would like to point out that for using a programming language that is inspired by the python, you guys aren't too pythony. Also, I would like to point out that the [subreddit spokesman](http://www.reddit.com/r/Python/comments/cn3j3/ni_is_funny_because_i_looks_like_an_upside_down/c0trbj7) was wearing the British Psychiatric Association Dinner Dance Club cuff-links.
There's a function in PyFilesystem which prints a coloured tree to the terminal. Its designed for filesystems, but could be adapted. http://code.google.com/p/pyfilesystem/source/browse/trunk/fs/utils.py Search for 'print_fs'
Thanks!
Hi, it is unclear to me what exactly cube2py (cu29?) is. Is it something in the web2py realm or is it something new that is just using web2py ?
And when you say that it'll be available soon, [6 days ago the developer said it'd be available in the next couple days](http://code.google.com/p/android-scripting/issues/detail?id=55&amp;colspec=ID%20Type%20Status%20Priority%20Milestone%20Owner%20Summary%20Stars). &gt;Remote-check a website for a "stolen" flag, and activate a stolen mode. (Front camera on EVO anyone?!) This interests me. I might try and code it up. if(stolen): logGPS() takePic() wifiEviron() What other data would be useful? 
&gt;you'll have to fiddle around to make sure the installed libraries are findable http://peak.telecommunity.com/DevCenter/EasyInstall#custom-installation-locations You have to modify your global pythonpath though... not sure how the quarantine will work. It also has hard-coded sub-paths. So it ends up installing the libraries in apps/libs/python2.6/site-packages/imaging ... One of the methods actually works ok-ish if you intend to only have a single project per user. Though the setup is a bit tedious, and ideally it would be nice to have a granular enough approach to allow for setting up distributions per project. One of my main goals in fixing the python packaging mess is removing any sort of machine specific setup...
Meh, you know developers. They say days, they mean weeks.
you could always add svn_trunk to the PYTHONPATH environment variable. That's sufficient for developers. Presumably for installation you are actually installing helperpackage so that's not an issue. I'd say that your repo structure makes sense for a repo, but it isn't necessarily an install directory, and you probably shouldn't assume you can just check out the program and run it without doing any sort of install or path setting.
Upvote for using Python 3 Another cool password generator is https://oplop.appspot.com/
Slides are available as a PDF here: http://conference.scipy.org/scipy2010/slides/lightning/peter_wang_python_evangelism.pdf
Indeed. The description is confusing and doesn't say what it is, maybe assuming some familiarity. It is "already much much better than T2/T3". Sounds good. But what is T2/T3?
If they're giving me code for free, I ain't complainin'
Ok, I hear you. Trent too agreed that PythonWin is worse than IDLE; so we decided to replace the PythonWin Start Menu shortcut with that of IDLE (PythonWin is still included; WIN+R and then type 'pythonwin'). This is done in our recent release of 2.6 and [2.7](http://www.activestate.com/blog/2010/07/activepython-27-released). Note that we also patched `idle.bat` to launch IDLE using the appropriate Python interpreter. So if you have multiple Python versions installed, it will use the appropriate python.exe instead of the default Python. Index: python/Lib/idlelib/idle.bat =================================================================== --- python.orig/Lib/idlelib/idle.bat (revision 73697) +++ python/Lib/idlelib/idle.bat (working copy) @@ -1,3 +1,4 @@ @echo off -rem Working IDLE bat for Windows - uses start instead of absolute pathname -start idle.pyw %1 %2 %3 %4 %5 %6 %7 %8 %9 +rem Start IDLE using the appropriate Python interpreter +set CURRDIR=%~dp0 +start %CURRDIR%..\..\pythonw.exe %CURRDIR%idle.pyw %1 %2 %3 %4 %5 %6 %7 %8 %9
or jump to 14:53 in the video.
Thanks apd! Haven't tried your code yet, but it looks very useful.
can you share it please?
Awesome, sir! :)
cube2py is a web2py app, which can be used to build up more complex apps through the browser interface. It is not clear if the stuffs inserted via the webbrowser will get translated to the back end. In other words, can I quickly use cube2py to cook up something and the go to the back end and fine tune it? I hope the web2py team focuses on building interesting core features instead of building icing on the cake. :-)
In the Python world, nose and mechanize are probably a good pair.
Selenium
Just wanted to tell you personally how much I enjoyed your talk: |--------------------------------------------------------------| this much.
&gt; you probably shouldn't assume you can just check out the program and run it without doing any sort of install or path setting It's true that in the more complicated case, you can't assume that you can just check out and run. But in the earlier, simpler cases, you actually *can* just check out and run. That simplicity is nice, and in my opinion, it would be nice to maintain that simplicity even as the software grows bigger.
 import base64, hmac, hashlib print(base64.b64encode(hmac.new("SECRET", "URL", hashlib.sha1).digest())) 
edit: pastebin link since code snippets seem like they wouldn't copy paste well.. http://pastebin.com/7ShKYV0c #!/bin/env python2.6 import urllib import sys from BeautifulSoup import BeautifulSoup def get_FATS_status(): sorba_url = urllib.urlopen('http://www.sorbacsra.org/sorba.html') html = sorba_url.read() soup = BeautifulSoup(html) marquees = soup('marquee') #clean up strings and save just the ones containing FATS statuses = [ ' '.join(marquee.string.split()) for marquee in marquees if 'FATS' in marquee.string] if len(statuses) == 0: return 'FATS Status Not available' return '\n'.join(statuses) if __name__ == '__main__': try: import android # if not running on android, simply print status to stdout except ImportError: print get_FATS_status() sys.exit() droid = android.Android() droid.dialogCreateSpinnerProgress('Please wait...', 'Fetching current FATS Status.') droid.dialogShow() try: status = get_FATS_status() except: droid.dialogDismiss() droid.dialogCreateAlert('Error!', 'An exception occured when ' 'fetching the FATS status.') droid.dialogSetPositiveButtonText('Continue') droid.dialogShow() droid.exit() sys.exit() droid.dialogDismiss() droid.dialogCreateAlert('Done.', status) droid.dialogSetPositiveButtonText('Continue') droid.dialogShow() droid.exit() 
Nice! For extra credit, choose a challenge: * Make it non-interactive, taking command-line arguments instead * Modify it to conform to [PEP 8](http://www.python.org/dev/peps/pep-0008/) ([easy way out is a script](http://bazaar.launchpad.net/~vcs-imports/pep8/trunk/annotate/head:/pep8.py)). * Remove type casting/conversion, like the function calls wrapped in `list()`. Maybe `split`ting the string on periods would suffice? * Use regular expressions to validate the website address ([reference](http://stackoverflow.com/questions/226505/question-about-url-validation-with-regex)). * Find a way around having `verifyWebsiteFormat = list(website)` both inside and outside the `while`. * Write some unit tests with [nose](http://somethingaboutorange.com/mrl/projects/nose/0.11.2/) or just the included `unittest` or `doctest`.
[twill](http://twill.idyll.org/)?
No.
I think this is on purpose. The problem is if you allowed it on anything and you used with 10 as x: print x then later what if it was decided to add an `__exit__` to int? Now your code does something new and its broken.
I'm helping ramp up testing for my companies PHP web app. We are using: -Grinder(Jython) for some minimal functional testing combined with stress/load testing. It's distributed and really does a great job at larger level stuff. The python/java scripts for testing aren't the easiest to make, but they do work. -Selenium for great functional testing -PHPunit for unit testing Hard to really choose just one that handles everything.
Well... It all depends on what you mean by "End of the Line." &gt; Python 2.7 is scheduled to be **the last major version** in the 2.x series before it moves into an extended maintenance period. - from http://python.org/download/releases/2.7/ Yes, in the sense that there won't be 2.8. But, no, in the sense that it'll be still supported.
WHAT exactly the fuck is this ?????????????/
coding in Java sucks
good lord, yes. who are these people so content to publish such poorly written, over-specific and over-documented rubbish code? Oh yes, academics.
Heh, thanks! I had the idea for it in the morning, was jotting down ideas throughout the day, and assembled the slides during the last hour or so before I gave it. I'm glad I found OmniGraphSketcher, because it made my completely-made-up graphs look so much better than some hand-drawn Inkscape thing. :) I had no idea that bashing "Enterprise Java" was so cathartic - now I know why everyone does it!
@lordkoba I did find the time difference between Python and C version but it was very small. Overflow was an accident I was trying big numbers and all of a sudden Python complained and program exited with "Stack Depth Exceeded" then i added try: except: block to see what happens with C and it worked fine. I'm still a python learner and this was just an experiment I did :). And guys thanks for the all comments I'll try to fix mistakes I made in this post 
Try [`doctest`][1] for unit testing and [Selenium][2] for functional testing. [1]: http://docs.python.org/library/doctest.html [2]: http://seleniumhq.org/
Someone compares this with [LEPL][] for me. [lepl]: http://www.acooke.org/lepl/
the [benchmarks](http://imgur.com/gr4aJ.jpg) are very promising 
They should have frozen the 2.x series a long time ago. All this backporting has helped either the old or the new versions. 
that's nice, how about a regular expression literal syntax?
For myself i use trial. It's a part of twisted so, a lot of protocols are supported, even your own :) Exemple: database operation via http post, a web page that must send an email... Stress/concurrency test is also wrtable. But i supposed that writing a selenium test is easier. Twisted must be learn before all. But it's like python, you try, you adopt!
I assume you meant either "has not helped either" or "has helped neither"?
Yes, it does mean the end of line for 2.x. There will be no 2.8 version as decreed by the Python committers and release managers. Only bug and security fixes will make the cut which will result in point releases of the 2.7 branch.
This has already [been done](http://www.perl.org/).
json parser in 66 lines? i like this.
I honestly think [WebTest](http://pythonpaste.org) is still the best HTTP testing, and you can use it locally (the automatic way, unit-test-like) or [over HTTP](http://blog.ianbicking.org/2010/04/02/webtest-http-testing/). It doesn't do logging, but I it wouldn't be hard to add that on top of it. [webtestrecorder](http://bitbucket.org/ianb/webtestrecorder) might also be useful.
Thank god it does. Developers are finally forced to port their software over to 3, this should've happened earlier.
Don't directly compile it it doesn't has main function use this gcc -fpic test.c or just gcc -c test.c then create shared library using this gcc -shared -o libtest.so test.c
&gt; While creating Codetalker, I looked at those two documents and thought "there's no reason why defining a parser should be any harder than this." What's wrong with [pyparsing](http://pyparsing.wikispaces.com/)? 
Just because they say one thing now, doesn't mean they won't fall back later and release a 2.8 anyways. In fact, there has already been comment among the committers and release managers about a 2.8 possibly still.
And the comment has generally been about not doing it. Can you point to a specific case of interest?
Not only alternate, but aims to replace `re` in 3.2
Regex is an optional part of the language. I don't think optional things should affect Python syntax. Besides, something like `re(r"pattern")` isn't all too much boilerplate, while making it obvious where the special thing came from. Idiomatic syntax does not give hints as to where it came from.
&gt; That simplicity is nice, and in my opinion, it would be nice to maintain that simplicity even as the software grows bigger. Agreed.... but I just haven't found a way to do that. Let me know if you find the magic combination.
How does this compare/benchmark against [re2](http://code.google.com/p/re2/) and [Irregexp](http://blog.chromium.org/2009/02/irregexp-google-chromes-new-regexp.html)?
I'll assume you are not one of these.
Hm, it seems to just add a whole bunch of obscure features with bad syntax. Regexps are a mess. 
Nice. Dividing your own community by drawing feature and maintenance lines across a backwards incompatible upgrade path: truly impressive. Shades of Zope 3. We all know how well *that* turned out.
Does this have any implications for pypy I wonder, (i.e. would this implementation be transferable?).
Bad syntax? How do you mean?
You know what would be awesome, but I haven't found it yet? A context free grammar module that worked somewhat like the re module.
From Jeffrey Yasskin on python-dev just a few minutes ago, after someone suggested the same thing: "While the re2 comparison might be interesting from an abstract standpoint, it intentionally supports a different regex language from Python so that it can run faster and use less memory. Since re2 can never replace Python's re module, it doesn't make sense to hold MRAB's new module to that standard."
http://www.freewear.org/?page=show_item&amp;id=FW0038
Not really fair to compare against re2, since it implements a different regexp language.
its not mine, but its awesome!
This is the best thing ever.
This is the best thing ever.
In case people think he's being sarcastic: he is not.
What? From the doc: &gt; Unlike most automata-based engines, RE2 implements almost all the common Perl and PCRE features and syntactic sugars. It also finds the leftmost-first match, the same match that Perl would, and can return submatch information. The one significant exception is that RE2 drops support for backreferences¹ and generalized zero-width assertions, because they cannot be implemented efficiently. The syntax page gives full details. &gt; For those who want a simpler syntax, RE2 has a POSIX mode that accepts only the POSIX egrep operators and implements leftmost-longest overall matching. It's the same [widely used] languages, only without backreferences. As far as I know, that single removal is the only sacrifice -- it's not a different language.
Pythons `re` is not PCRE. So you can not drop-in-and-use `re2` instead of `re`. Therefore it's not the same language.
I've used [PLY](http://www.dabeaz.com/ply/) for parsing before, and while it's reasonably nice to use it does seem to be very slow. This [video](http://python.mirocommunity.org/video/1603/pycon-2010-ply-and-pyparsing-9) from PyCon 2010 compared PLY to PyParsing, which I haven't used but which also looks interesting. If you've been looking I imagine you've already found these, though. There are actually tons of parsing tools out there, just no obvious winner.
At least the Python devs have the balls to do it. Things were wrong, now they're fixed. PHP desperately needs an overhaul but won't be getting it for numerous reasons. All of them should be completely irrelevant when taking into account the current state of the language though.
&gt; Not only alternate, but aims to replace re in 3.2 Here's the [python-dev thread](http://mail.python.org/pipermail/python-dev/2010-July/101606.html). Since 3.2 is not too far away, it *may* only be included in 3.3. [Nick](http://mail.python.org/pipermail/python-dev/2010-July/101609.html): *Off the top of my head, I would say that this won't have enough time to bake properly for inclusion in 3.2, but if the potential benefits and intended backwards compatibility are borne out by real world usage and the code fares well under review then it may be a contender for 3.3.* 
I think there have been several attempts to remove the GIL, and basically each time they have either switched their goals after realizing it is too hard, or they've stepped back from having that as a goal (unladen swallow). One process per core (with the multiprocessing module) is not really a huge overhead over one thread per core when you think about how much overhead python already has by virtue of being interpreted and dynamically typed. Compared to all of the breakage that apparently (I don't know first hand of course) is caused by taking out the GIL, multiprocessing is apparently an acceptable stopgap measure. 
The BDFL actually suggests setting up multiple python processes and developing some sort of messaging system between them if you want to better utilize multiple cores.
:( It makes me so sad when people say this. Multiprocessing is great perhaps for people who use the stock interpreter. But try embedding Python inside a browser, [game](http://python.eventscripts.com), [GUI tool](http://blender.org), or [other large apps](http://us.pycon.org/media/2010/talkdata/PyCon2010/053/How_are_large_applications_embedding_Python.pdf) and that approach is simply worthless. I asked Guido about this at a keynote the other year and he pretty much just said "use Jython or IronPython". Great. No, I want to use CPython. And multi-cores. Please. Don't dismiss me. I'm out here in the cold. *cry* 
It would be cool to not have the GIL, but it literally is so much work it's better to look at what you can reasonably achieve given the limitation of the GIL. As a commenter pointed out on HN, one address space per core is probably a really great way to go about multi-core concurrency since there doesn't need to be cache invalidation and snooping etc.
Nobody is dismissing you, but we don't have the answer as to how to have: freethreading, backwards compatibility, reasonable single threaded performance; do you?
Unless I've missed something it's a C implementation, so PyPy would need to convert it to RPython (or make similar changes to our implementation). And just as Armin was finishing a small rewrite of our regex engine... ;(
There has been a *successful* attempt to remove the GIL, but it slowed down the base python case of one process on one thread by about 1.5x and was therefore removed.
&gt; But try embedding Python inside a browser, game, GUI tool, or other large apps and that approach is simply worthless... &gt; No, I want to use CPython. And multi-cores. Please. Don't dismiss me. Look, I love python, but maybe you just need to accept that in these cases it's not the right tool for the job?
For those that don't know, GIL means [Global Interpreter Lock](http://docs.python.org/c-api/init.html#threads).
Complaining about complaining about complaining? Downboat. The GIL argument is like a reply to all thread at a large company, where some douche accidentally emails the whole company, then people reply to all telling him not to send to all, then people reply to all to the replier to tell him not to reply to all about sending to all, and so on and so forth. It's certainly just as productive as that sort of thread is.
Speed improvements aren't an obscure feature.
if only companies come to their fucking senses
why you dont have "__init__()" in class Animal() ?
I don't mind what was done in 3. I do mind the decree of end-of-lineness of the 2.X series; it's too early. Putting all the carrots in 3.X and leaving all the sticks in 2.X won't work either. We've seen how this movie ends already.
Complaining about the GIL is like complaining about how badly the bear is dancing. (and you do have all kinds of solutions (my favorite being mod\_wsgi))
It was actually intended as a drop-in replacement for PCRE. From [the announcement](http://google-opensource.blogspot.com/2010/03/re2-principled-approach-to-regular.html): &gt; Today, we released RE2 as an open source project. It's a mostly drop-in replacement for PCRE's C++ bindings and is available under a BSD-style license. Again, the only notable feature missing is backreferences. It implements the same language, but removes that one feature.
If you want to step up and work on 2.x, feel free. My time is better spent on 3.x.
I can never remember that. This article did write it out eventually, but many don't. 
Yes. It was intended as PCRE replacement. Python `re` is not PCRE.
I think he's making a valid point: all the complaints point out that there is a real problem with your product, and being dismissive of the complainers is counter-productive. Sure, it's open-source and it would be better if people made useful contributions instead of complaining, but that is rather utopian.
But you can turn off the Perl extensions, the same as POSIX egrep.
I didn't want to muddle the issue with inheritance (Animal.\_\_init\_\_ would be overridden by Pet.\_\_init\_\_) and/or explicitly instantiating the Pet instance with Animal's instantiator. Technically speaking, both of these classes are metaclasses/superclasses (you don't have an instance of "Animal" or "Pet" so much as you have something with their properties), but I needed to put something in the Pet method. Perhaps it could be changed to __del__(self): tell_kids_you_gave_it_to_aunt_agatha_to_live_on_a_farm(self) ;)
Thank you ! 
why do you want to use CPython ? Is it to benefit from all the C extensions ? Then what you are asking for is impossible IMHO. The only way I can see to remove the GIL is to get a real GC and get away from reference counting. Doing so without breaking 100 % of C extensions out there is near impossible. I love the GIL: it makes writing C extensions much easier. The GIL really is a feature: that's a tradeoff to make writing C extensions easy. Most discussions about the GIL assume you can consider everything else being equal (what if we could remove the GIL and still get everything that python gives us today). But you can't get everything else, you have to give up something, be it performance or compatibility.
This is really exciting! Comparing the [regex-dna test](http://shootout.alioth.debian.org/u32/program.php?test=regexdna&amp;lang=python&amp;id=1#log) re took 27.8s and regex 22.4s. That's a nice improvement considering all i had to do is rename the "from re import" to "from regex import". Results in detail: darjus@linux-6j1x:~/Downloads/regex-0.1.20100709&gt; time python regexdna-re.py &lt; regexdna-input-5000000.txt agggtaaa|tttaccct 356 [cgt]gggtaaa|tttaccc[acg] 1250 a[act]ggtaaa|tttacc[agt]t 4252 ag[act]gtaaa|tttac[agt]ct 2894 agg[act]taaa|ttta[agt]cct 5435 aggg[acg]aaa|ttt[cgt]ccct 1537 agggt[cgt]aa|tt[acg]accct 1431 agggta[cgt]a|t[acg]taccct 1608 agggtaa[cgt]|[acg]ttaccct 2178 50833411 50000000 66800214 python regexdna-re.py &lt; regexdna-input-5000000.txt 27.81s user 0.89s system 99% cpu 28.720 total darjus@linux-6j1x:~/Downloads/regex-0.1.20100709&gt; time python regexdna-regex.py &lt; regexdna-input-5000000.txt agggtaaa|tttaccct 356 [cgt]gggtaaa|tttaccc[acg] 1250 a[act]ggtaaa|tttacc[agt]t 4252 ag[act]gtaaa|tttac[agt]ct 2894 agg[act]taaa|ttta[agt]cct 5435 aggg[acg]aaa|ttt[cgt]ccct 1537 agggt[cgt]aa|tt[acg]accct 1431 agggta[cgt]a|t[acg]taccct 1608 agggtaa[cgt]|[acg]ttaccct 2178 50833411 50000000 66800214 python regexdna-regex.py &lt; regexdna-input-5000000.txt 22.48s user 1.34s system 99% cpu 23.839 total 
Which other interpreted languages have a GIL (in the C-implementation)? Which ones do not?
[Blog of JP Calderone (exarkun)](http://jcalderone.livejournal.com/tag/twisted) and one of [Duncan McGregor](http://oubiwann.blogspot.com/search/label/twisted). Both found through Twisteds planet. Other than that -- source code.
`from x import *` imports are generally a bad idea (imports unnecessary things, makes code harder to understand) - `from skein import skein256` would be better, if not just `import skein; skein.skein256` Lines where you construct strings, such as.. print("Your Username is: " + userName + " ; " + "The Website is: " + website + " ; " + "Your Unique ID is: " + salt) ..can be made much tidier using string formatting: print("Your Username is: {} ; The Website is: {} ; Your Unique ID is: {}".format(userName, website, salt)) (you may have to use {0}, {1} in earlier versions of Python 3, or you can names, such as `print("{abc} {blah}".format(abc=1, blah=2)`) The last line (`main()`) should be: if __name__ == "__main__": main() Trivial, but the prefixing the function names with `Function` is quite redundant
The multiprocessing module has significant [restrictions on Windows](http://docs.python.org/library/multiprocessing.html#windows);it's not elegant to program with in this environment.
It's actually for the ease of cross-platform embedding. Jython requires Java preinstalled and Mono wasn't a reliable option last I investigated. I would need the default C extensions but nothing additional. 
FYI your lead_in function can be reduced to: def _lead_in(out, level, horiz): out.write('{0}{1}'.format('|' * level, '-' if horiz else ' ')) EDIT: Or just: def _lead_in(out, level, horiz): out.write('|' * level) out.write('-' if horiz else ' ')
Is it wrong to find an interpreter sexy?
Eric4 is light and fast, runs on os X, linux, and windows. Written in python using pyqt. Has nice Qt integration, visual threaded debugger and python interpreter, Qt dialog and other wizards. One thing you will notice it that the toolbar has everything enabled, choose hide all and add the tools you want, "quick search", "debug and step buttons" etc. I love vim so I use gvim for large edits then I use the built in editor while debugging it has pylint integration and little python code helpers.
Still... I don't think it behaves the same under linux and windows. Also, it's still fairly expensive to move data between the processes... so all is not rosey.
I also don't accept this. In the future these will be solved... If everybody is fine with the status quo then it will never change. Measurement is the key, the Pypy guys have http://speed.pypy.org/ To measure speed, maybe something similar for multicore would help progress.
Very cool, thank you!
I prefer "Your Username is: %s ; The Website is: %s ; Your Unique ID is: %s" % (userName, website, salt)
Try pip install PIL on windows.
NumPy/SciPy support was one of the requisites in another PyReddit thread about when Pythonists are switching. Maybe other big packages will follow sooner than expected, too?
Actually, many of us knew this was coming - this is why all the yelling about "python 3 is dead no one is porting waaagh" was simply wrong, it takes time, and these are two very, very big things to port.
YEAY! -- Only 300 more projects to go! :) But seriously, this is great!
Oh, I knew it was too, but, these are definitely 2 of the most important ports to Pythonists right now.
Huzah! A turning point for sure.. :)
Yuppiee! This is indeed a great news and a cause for celebration for me. 
How many other Python libraries with the popularity of numpy/scipy have as extensive a set of C extensions?
 [...] File "C:\Python27\lib\distutils\msvc9compiler.py", line 295, in query_vcvarsall raise ValueError(str(list(result.keys()))) ValueError: [u'path'] ---------------------------------------- Command C:\Python27\python27.exe -c "import setuptools; __file__='C:\\Users\\user\\build\\pil\\s etup.py'; execfile('C:\\Users\\user\\build\\pil\\setup.py')" install --single-version-externally -managed --record c:\users\user\appdata\local\temp\pip-thevc6-record\install-record.txt failed w ith error code 1 Storing complete log in C:\Users\user\AppData\Roaming\pip\pip.log 
Or, as Guido was saying, even if Python is right for the job that doesn't mean it has to be cpython. The other Pythons are also real Pythons!
May I ask why? I never liked the sprintf formatting, and I find .format much simpler to understand. 
Why not just install a linux partition? Seriously it will change your life as a Python developer. I couldn't imagine using Windows now.
Though that would require 2.6 and 2.5 respectively, just worth noting.
I had no idea. Is SciPy also Python 3 compatible?
And within a half a year PyQt will work with python3 with PySide (AP I2 seems nice), and then I will switch directly. I still do a couple of stuff in py3, but for all my bigger projects I use qt.
[PyQt](http://www.riverbankcomputing.co.uk/software/pyqt/download) has had support for p3k for years.
Good riddance!
"Very, very big" perhaps but not very very difficult.
My mom has an extensive set of C extensions, but how did you know this?
whatever! 
While I agree with you he was asking for Windows help...
&gt; Seriously it will change your life as a Python developer. How? I use Linux at my job and Windows at home, and I can't say I see much of a difference, after adding a nice amount of GnuWin32 goodness.
While I don't think your suggestion is a bad one it's hardly an ideal. These tools were designed to be cross platform but they just don't work on windows. It's not only virtualenv, PIL is broke on windows too, at least when you try easy_install or pip. There's a ticket on bitbucket where a guy has the same problem as me, ticket just got written off and closed. No patch, no solution; windows developers just don't get sympathy from the community and I think that sucks.
&gt; Porting Scipy to work on Python 3 has proved to be much less work, and will probably be finished "soon". (Ongoing work is here: http://github.com/cournape/scipy3/commits/py3k , http://github.com/pv/scipy-work/commits/py3k ) I know it's hard to make it to the third sentence.
Because: 1. it is typesafe 2. it has less characters to enter 3. {} are not Pythonic ;-)
I do prefer the `"%s" % a` syntax purely for brevity, but the `str.format` is much more flexible and easier to read
Dev binaries are here BTW: http://www.lfd.uci.edu/~gohlke/pythonlibs/
Does from django import core work on the python path? Or import django?
import django works in the shell launched after I've activated the virtualenv but the imports in the script file result in an error.
Can you pastebin that log somewhere?
I use it daily and it's fine. Switching operating systems to overcome some virtualenv issue is hilarious.
Matplotlib too please!
Oops, must have skipped over that paragraph. Thanks for the reply, and congratulations on your mastery of such unique and witty sarcasm.
http://paste.pocoo.org/show/236151/
9 lines http://paste.pocoo.org/show/236155/
Whitespace is not mandatory though. "4 2+" would be valid.
this might be cheating, but it seems to work. import re v=0;vals=[] for t in re.findall(r"\d|\+|\/|\-|\*", raw_input()): if t in "/*+-": v += eval(t.join(vals));vals=[] else: vals+=[t] print v *edit: squished it a little more. 
Reference implementation: http://paste.pocoo.org/show/236162/ [spoiler :D] Without eval: http://paste.pocoo.org/show/236168/
Great minds think alike? :) our solutions are pretty similar. 
How about the same challenge but without use of eval? :-)
Eval is not cheating, but that won't work well for more complex examples like "1 2 3 4 * + -" i think.
I dont even understand how "1 2 3 4 * + -" would be done. 1 * 2 * 3 * 4 + ? - ? don't get it. *edit: just looked u p RPN on wikipedia, now I understand :) does that mean that: " 1 2 3 +" is not valid RPN? can it ONLY operate on the previous 2 numbers? 
heh, yes re for tokenize is good — there is my variant without eval http://paste.pocoo.org/show/236164/ 6 lines
Yes.
Does your local `site-packages` override the root `site-packages`? 
Time to feel stupid. Thanks.
yup. that's where I got mine.
a mixture of bsdemon and re solution with a kind of ugly hack too ;) http://paste.pocoo.org/show/236187/
Rarely one needs 300 libraries to do his Python work. NumPy is one of the most important libraries out there, however, since it serves as a base for a lot of other libraries. It's the basis of the whole "scientific Python" stack
Yep, one of the benefits of its being a partly-commercial project. A serious deficit is its clinging to GPL even when Nokia released Qt itself as LGPL.
SciPy is much simpler to port, IMHO, since it contains much less extension code and is mostly based on Numpy itself.
Hey, it's reddit. You got your answer, didn't you? Just relax ;-)
or with a char less http://paste.pocoo.org/show/236192/
Awesome, I've been looking for a good web based plotting system. Anyone know of any web based alternatives for comparison? 
Link to that ticket? 
I don't know why you'd need the entire build log. This is actually a known bug in distutils: http://bugs.python.org/issue7511
A virtual machine would be more convenient. I've seen people with Macs use Ubuntu VMs for Python development.
What if instead of running the script directly you ran python django-admin.py ...?
https://bitbucket.org/ianb/virtualenv/issue/43/windows-neither-no-site-packages-nor-package-override
`python: can't open file 'django-admin.py': [Errno 2] No such file or directory` It's still on the path.
if you use `--no-site-packages` you'll need to reinstall Django inside the virtualenv
I'm aware of that but `django-admin.py` still looks in `C:/Python27/` for django rather than in the virtualenv.
Ah, missed that. At least they know about it
I think there's versions of the python interpreter inside the virtualized folder, those might get the paths right
dojo toolkit has extensive plotting lib if im not mistaken
Surely, that should be frontend (im on my phone and cant verify that but...) edit: Huh, well look at that... html5/canvas backend... alrighty then.
Can't find anything about Python 3 on the linked page. I know it's a long shot, but maybe???
For those not in the know, "1 2 3 4 * + -" unpacks thusly: 3*4 = a a + 2 = b b - 1 = c And thus, the result should be 13.
Don't think they support 3 yet. Now that NumPy does, I'm sure they will soon.
My instinct is to start with the grammar for RPN: &gt; E -&gt; EE+| EE- | EE* | EE/ | \# But that's me.
Way too long to compete, but I decided to try it without the re module: http://paste.pocoo.org/show/236218/
No, these feelings are just in time
Does it work if you include your site-packages? I know this no real help, I am just curious.
Mostly a matter of dependencies, namely NumPy. That said, I haven't found any compelling reasons to move to Python 3. "Guido says you should" isn't a compelling reason, to my mind.
http://raphaeljs.com/ has some useful plotting utils from the look of their demos.
Thanks for this. I had not heard of dojo. Looks very promising. The [100 point process](http://dojofoundation.org/about/hundredpoint/) for openness is a nice idea as well.
Actually Guido does not say that. Guido says move your shit to python 2.7 and then when you're ready, start porting over using 2to3 and porting your c libs.
My point is that Py3 doesn't add anything that I find terribly compelling. Breaking compatibility (and more to the point, breaking the C API) doesn't seem remotely worth it.
It's worth it when you realize that they're going to be able to further the language instead of doing damage control. I'm sure people had your feelings on the last break in compatibility. Honestly I'm looking forward to it and as soon as they figure out what to do about WSGI for python3.
I got mine down to 190 bytes (7 lines), but it requires whitespace between tokens (as it only uses `split()` and not `re`), which I believe disqualifies it. It doesn't check for an imbalance of operands and operators, either (among other bugs). It may have been shorter if `__getattribute__` wasn't so damn long: I wanted to use a `dict` with the indexes of the four operations from `int` (via `dir()`), but couldn't get it to actually find the savings in doing so. If it had been shorter, then none of the names of the operations would have been needed. [Lodge It: Paste #236243](http://paste.pocoo.org/show/236243/) *edit*: I cut it down a bit more using some of the techniques from others' submissions. And this time it does use the indexes for the operations, along with `getattr()`. No longer loops for successive use by the user, since that wasn't required. It's now 159 bytes (5 lines): [Lodge It: Paste #236248](http://paste.pocoo.org/show/236248/). 
Minor improvement: http://paste.pocoo.org/show/236250/
Ruby 1.9 added a GIL (there referred to as a GVL (Giant VM Lock)). Prior to this it used green threads (which have the same "only one core" issue as the GIL).
http://code.google.com/p/flot/
You're correct there are and when I launch the interpreter in the virtualenv folder it prints the paths correct which confirms that activate.bat is working but django still doesn't see it.
With or without the argument `--no-site-packages` it doesn't include them.