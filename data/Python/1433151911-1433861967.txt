Anyone done this?
You couldn't care less
Excellent, thank you so much!
For text mining+scraping I've been looking for a reason to use https://github.com/grangier/python-goose or https://github.com/rodricios/eatiht
I needed this for a project I'm working on, very cool stuf! Saving for later
I've never encountered anything I couldn't use in 2.7.
I've never found myself missing packages, I mostly just find that Python 3 makes more sense from a consistency perspective.
From a different perspective.. In that wall suds, twisted, mysql-python, m2crypto are all red. What would be good 3.x alternatives for those?
Those are probably tests for their unicode handler: http://www.crummy.com/software/BeautifulSoup/bs4/doc/#unicode-dammit
while True: or while 1: is more readable
If you reply/PM me the site, I'll look if I can bypass it.
I thought it was a quick tutorial or blog post. Turns out it's a detailed, well-structured introductory book.
sorry about that. won't happen again. Thank you.
PyPy 2.6.0 - "Cameo Charm" since PyPy looks best in profile (well, vmprof anyway)
do check Dryscape also.
Thank you! I've added a license file. The code isn't very pretty I'm afraid, I wrote the example first then developed around that so it could do with some re-factoring.
ha ha nice catch (I am not the author btw). You should send a PR (or shall I do it?)
well, make sure you are following PEP8 guidelines. 
Honestly, I thought this was just terrible. It's a typical SEO/clickbait styled article that does just the bare minimum to try and drive traffic and revenue to their site. The article author seems to have zero domain knowledge that they rely on when putting this list together. If they did, they'd realize that they missed [Theano](https://github.com/Theano/Theano), which, by their own metrics should be pretty high up in the list (Theano is a deep learning library in Python that interfaces with GPUs). I don't claim to be any sort of expert in the field, but if I can spot big and important projects that they've missed, I wouldn't be surprised at all if they've failed to mention/include a lot of good/big projects in the ML space.
PyPy devs, please hear this out. Please.
&gt; mysql-python Getting rid of mysql and going for Postgres would be my first choice, the sane utf encodings go well with the unicode in python 3 :D 
Write a simple executable script using the great "Requests" library. It just needs to submit your fake vote and then exit. Get yourself a free Amazon AWS account. Write a shell script to include in the user-data that downloads your vote script and executes it. Write some code to use the AWS API. Each hour you want to fire up the max # of allowed micro EC2 instances. Then terminate them so you're only billed one hour for each. The free plan should cover you. 
So can anyone give me a rundown of the differences between this and Selenium?
Well, if PyPy continues to basically ignore Python 3, that will only delay the migration. I can't see how that is good, it's just harming the language we all love. PyPy not supporting 3.3 means that people can't even try running asyncio on it.
"Basically ignor[ing] Python 3" is just about the exact opposite of what he said, no?
&gt;Well, if PyPy continues to basically ignore Python 3, that will only delay the migration. I can't see how that is good, it's just harming the language we all love. Not as much as creating a Python 3 branch of the language. The bulk of the demand is in Python 2.6+. The fact is that for most people there isn't enough incentive for abandoning Python 2 for Python 3. I already migrated to Python 3 with very little problem, but my colleagues still insist on remaining with Python 2. Sometimes I think the language would have been better off if the improvements were incremental without requiring the need to split the language in two.
The desire was there to clean up long-standing warts; and as simple as it is to say "just make incremental improvements", anyone who's dealt with a large system knows that just because something looks simple to implement doesn't mean that it's possible (let alone practical) to achieve given the implementation. The transition is happening, both slower and faster than many people thought or would have liked it to take.
Yeah I couldn't really see any differences in use cases. But I'd be happy to learn if there are any.
First, I don't want to somehow offend core pypy devs. My respect to them is just enormous, and I think that PyPy is a marvel of engineering. I have no words to describe my excitement every time there is a new blog post about STM or some crazy new JIT technique. OTOH, it seems that there are some issues with Python 3 implementation in PyPy that aren't easy to fix if you're not Armin or Maciej. I just wish that they would in general have a bit more time to help with and encourage work in py3k branch. I maybe very wrong about this, but that's my understanding of what's going on based on passively following PyPy mailing list and their work.
I have a strong urge to write a native python gui toolkit using this asyncio stuff to do event loops and non-blocking uis... make calls to libxcb through ctypes or something. Ah well, only so many hours in the day.
the hello world in cx freeze is 2.5 mb when dlls n exe are upx compressed , i can make the single exe , but it becomes sort of a time memory trade off thing if i reduce the size of exe the extraction time increase and hence execution is delayed and if i don't make then into single exe using 7z , even a hello world in py2exe becomes 4.5 mb . i thought maybe nuitka could give me single EXEs just like we can compile a c program to an executable with 0 dependencies :| , i do appreciate your help VERY MUCH ^_^ as i am still a newbie to Python
Apathy is very negative.
Yeah, it's a bit strange, but I do think it feels slightly simpler, and kids won't notice the weirdness. My first idea was that the API would be this: def on_mouse_down(pos, button): ... which I think is more readable than def on_mouse_down(event): ... especially when you don't use all of the event properties. The first form makes it explicit what you're getting, and every program you see reinforces in your mind what the shape of each handler is. The optionality of the arguments came later, when I decided I wanted to be able to write def on_mouse_down(): ... as my first introduction to handling clicks. I don't think kids will notice the magic until they're into writing and calling their own functions, and by that time the crutch will have done its work.
Yes, you are bumping up against some very real limits to Python desktop application development and for now I don't think there is any way to get around them. That said, 4.5 MB is really not that much anymore. It's like downloading a song. Hard drive space is no longer an issue for most people, and transfer across the internet isn't either. Even if it is 20MB for a bigger application, it's not that bad. Yes, it feel "wasteful" as compared to what it could be if it were compiled to native code (a few hundred K?), but, well, that comes with the territory for an interpreted language instead of a compiled one. I went through all of this too and in the end decided not to even think about it, just used py2exe into one single (10MB) file, and that was that. I did some consulting work and put these executables on a Dropbox shared folder and file size was never once mentioned, nor would it ever be at this point. Yes, it would be great if Nuitka compiled to a single executable that was native code. That's just not their priority now (or maybe ever), though I get the sense that if someone jumps in and makes it a priority and volunteers the work, Kay would integrate that. Happy to help!
Don't be hyperbolic. Yes, installing Pygame is a bad experience on some platforms, but it's **still** better than the other options. As I said, I have discovered over 9 Pyweek competitions that sticking to Pygame as a single dependency is just the simplest way to distribute Python games. Pygame is great: get it installed and it Just Works. Every time I try to do something more clever with OpenGL or Pyglet or whatever, people complain that they can't get it installed and/or I get sent tracebacks, and it hurts my game's ratings. So yes, I'm going to be conservative, because I have learned my lessons. If Kivy works reliably cross-platform on a wide range of hardware then great. I'd love to be using Kivy but I'm put off by the way that it appears to tightly couple useful, cross-platform OpenGL ES/windowing/input bindings, with a fugly UI language and resource management system. Give me exactly the same APIs as Pygame Zero built on Kivy, and make it not a 200MB download, and guarantee it won't fall over with obscure messages if the drivers or hardware are unusual, then I'd happily take it.
Please post questions to /r/learnpython! Here is your link to PEP8: https://www.python.org/dev/peps/pep-0008/
But the learning models are learned from a context - - in most contexts it is a rather negative statement. Learning models should inherit the biases of the samples, which is why properly selecting training data is important.
Apathy in itself is negative. I'm not saying that being apathetic is being negative, I'm saying that being a apathetic is a negative trait. Apathy in all situation leads to nothing good, and to no progression. Even apathy towards where you want to eat is a bad thing (Because you can easily end up somewhere you didn't want to go). I was just making a joke, and not attempting to defend the fact that python thinks not having an opinion is mutual (Also, kudos on the futurama reference)
I just ran into something where I had to try to continue to support Python 2.4...and make things compatible with Py3k. I cried a little.
1) That's not how Kerberos works. You never, ever provide your username and password to the service. That only goes to the AS to obtain a TGT. However, there's a certificate on your computer that's necessary. The TGT is almost certainly generated when you login into your computer. 2) Look at the method signature for HTTPKerberosAuth. You need to know the service name, which your IT department will know. 3) You're not using your auth object: kerberos_auth = HTTPKerberosAuth(mutual_authentication=OPTIONAL) r = requests.get(url, auth=HTTPKerberosAuth(username, password), verify=False) It should be `auth=kerberos_auth`. 4) Attempts #1 and #3 aren't even trying Kerberos auth. They'll never work. I haven't used requests-kerberos or even kerberos in Python before, but it seems like it takes care of most of the stuff for you (e.g. finding your TGT and using DNS SRV records to obtain a service ticket). (There aren't enough configuration options in requests-kerberos otherwise.) I think you need: auth = HTTPKerberosAuth(mutual_authentication=OPTIONAL, service="ask_IT") r = requests.get(url, auth=auth, verify=False) 
"Darling, I love you! I adore you! I want to spend the rest of my life with you!", Tom said. Mary looked down at her fingernails. "I have no strong feelings one way or the other," she said. Tom turned his head just in time to conceal tears raining down his rakishly unshaven cheek. But Mary knew. Seriously, though, if this were applied to new products, stocks, or political candidates, pegging it at 60/40 to the negative side wouldn't be too bad at all.
&gt; newspaper Goose is pretty good. It is not perfect though. Given the crazy markup in lots of websites and the amount of irrelevant non-article content on them, article extraction is a hard problem. 
Goose example: &gt;&gt;&gt; from goose import Goose &gt;&gt;&gt; g = Goose() &gt;&gt;&gt; article = g.extract(url="http://www.irishtimes.com/news/politics/same-sex-marriage-on-course-to-be-approved-by-ireland-1.2223646") &gt;&gt;&gt; article.cleaned_text[:100] u'(From left) Anne-Marie Meenagh, Hannah Byrne and Emma Banks join supporters gather in the court yard'
I recommend [Think Python](http://www.greenteapress.com/thinkpython/thinkpython.html). It's quite a friendly intro and it is way more systematic than some of the other options, imo.
Ah my sweet `pathlib` how I miss you so at work.
How well does it work with 2 factor authentication? Use an app password?
I really hope you meant 24 hours, otherwise you won't be getting much sleep ;) In all seriousness, this looks really cool. Nice work!
Click baity title is click baity. Not gonna lie. But after thinking about it, yagmail spares me having to copy over my own code to work with smtplib. It's a snippet of code, but it's one less step. It also does things that are not (yet) useful to me but might one day be. Also, it being supported by someone else is, in itself nice. Thanks!
 for i in range(1, 5**2): pass Edit: Off by one.
How is this compared to Scrapy?
You just downloaded the `yagmail.py` script? It is actually a package that should be installed with `pip3 install yagmail`. Then this error shouldn't occur ;) My apologies if something else is going on, I'd have absolutely no idea. 
You're very welcome!
Actually I am asking, keep the math.sqrt() as it is. What if I need to check math.pow(i, 2) + math.pow(i, 3) &lt; 20 Or some conditional logic.
Great, ty.
Interesting. I did pip3 install it. My entire code looks like this: import yagmail yag = yagmail.Connect('myEmail@gmail.com', 'mypw') contents = ['This is the body, and here is an embedded image:', 'http://somedomain/image.png', 'You can also find an audio file attached.'] yag.send('myEmail@gmail.com', 'My Subject', contents) Not sure what the issue is but this isn't the computer I primarily code in. I'll try on another when I get home &amp; see what it could be.
Also Doob is obviously Neil deGrasse Tyson.
Either that or Bill Nye
 contents = ['This is the body, and here is an embedded image:', 'http://somedomain/image.png', 'You can also find an audio file attached.', '/local/path/song.mp3'] That is *way* too magic-y for my tastes.
Now available in [pyenv](https://github.com/yyuu/pyenv/blob/master/CHANGELOG.md#20150601)!
you kinda sorta almost got it, except that IMHO your final solution is probably the most non-pythonic way :) I also don't like that word, "pythonic" but that's a personal thing of mine. Generally when you create a construct, you can choose to use imperative style (i.e. example from your original question) or a functional style (i.e. don't use mutable state, like loop counter 'i' and instead use transforms and iterators), which is kinda where you were going in your final answer, except you put in a loop in there with mutable state, which made it neither here nor there. But you were on the right track, if you want to use itertools, you can do: def foo2(): return dropwhile(lambda x: math.sqrt(x) &lt; 5, count()).next() And some people might call that method more "pythonic", which I don't know if I would personally agree with. It is definitely more functional. But keep in mind that: 1) seems like it took longer to write than simple imperative statement 2) personal thing, but I'm not sure if it's necessarily clearer than your original code, and lastly 3) if you use timeit module, you'll discover that the new way is ~50% slower Welcome to Python! It's a great ecosystem but don't get hung up on that stupid word. On the other hand keep in mind that there are language constructs, like comprehension which will make your code, smaller and faster than old-school imperative style. I'd argue it's those cases that you should learn to identify and practice.
PEP8 is good, but its better to focus on being pythonic https://youtu.be/wf-BqAjZb8M
Scrapy seems more rigid, you have to define a class for each type of data whereas cyborg just passes dicts through the pipelines. I've never used Scrapy though as it doesn't support Python 3, but it doesn't have anything like the pipeline system this project has (I don't think, correct me if I'm wrong). Scrapy is also a lot more mature, obviously.
How much of the lectures cover things that are no longer applicable in Python 3? And thank you for sharing!!! 
Not sure if OP is Philip, but I enjoy Philip Guo's writings as well as his projects. I believe the online Python tutor used in Berkeley's CS61A SICP course was written and is currently maintained by him, and it's really neat for understanding concepts around environment diagrams, functional programming, closures, etc. Will have to bookmark this for a later read.
How bout both... [Python tools for Visual Studio](https://www.visualstudio.com/en-us/features/python-vs.aspx)
You came to the right place for an unbiased opinion. 
Actually, I was hoping that Python users would have the best arguments for using Python instead of Visual Studio.
This is very much true! If you need to build a great GUI quickly then C# is probably the way to do it. If you need to write a script to perform some mundane task then python will do that. They all have strengths and weaknesses. 
This is neat! Was using cv2 vs something like mpl a design choice? I think this method is much simpler and more efficient, I'm just curious. I'm a beginner myself and have hit a slump in projects to take up, but you've inspired me a bit!
:) imo depends on what you need it for. I live in a Linux world, so python has larger application than it does with Windows. But visual studio vs tkinter for Windows, I might actually lean to visual studio.
Right now $$$ can buy elections. Solomon Kahn wants to bring transparency to campaign finance by developing software tools to visualize campaign donations. [Here is a link to his Kickstarter on Exploring Campaign Finance.](https://www.kickstarter.com/projects/12095995/explore-campaign-finance) Kahn is great, so I copied him. 
Try running on port 8888, you need to sudo for ports 1024 and lower.
ok. So I had a similar problem with output for a sqlite database, as well as a mysql database. Using the .replace tool worked for me. So It looks like you want to separate each line, and each line ends in ',' i'm assuming you've got your output saved to a variable, lets call it base. spaceout = base.replace("','","\n") print(spaceout) and you can use .replace to clean up anything you don't like
No idea what example it is but if it's a web server you may have to run as root to get permission to open port 80. Try sudo.
Right on. Although I'd say that Go, Rust, and possibly even Java 8 have all stolen quite a few users from Python. The python 3 fiasco put the whole language in stand still for years while the competitors have gone ahead. Python's performance is not good enough for the server or mobile. And of course we aren't forced to use it like JS. Sticking to JS is probably a safe choice for you if you'd like to focus on webdev.
how do I do that?
The build-in lib Zed Shaw wrote (lpthw.web) specifies that for you, it will use 8080 by default. I ran your code with a small modification: __name__ == "__main__" In Yosemite with no issues, without invoking sudo.
sudo python app.py ....... then it will ask for pass. See if that works
I just went and read the exercise you are doing. Are you running *python bin/app.py* from the parent folder of the app.py? Also the change /u/hav_ mentions.
Gotcha. I hear ya - customizing mpl can start to look like css files so I think cv2 for graphs like yours is a great method. Thanks for sharing the data, I'll look around!
`np.uint16` covers the numbers `0` to `65535`, while `np.int16` covers the numbers `−32768` to `32767`. Note that they can both represent numbers that the other cannot; the unsigned version cannot represent negative numbers and the signed version cannot represent "high" positive numbers. You need to promote to a higher size if you want to merge them. The same is true of the two kinds of 32-bit integers and any other size of integer you care to use.
The project sounds very similar to PhantomJS (a headless webkit browser), which I've been using along with Selenium to get the same functionality. The fact that this setup doesn't rely on JavaScript is a bonus for me, so I think I'll be using this package instead.
Oh hey, look at that. I can confirm an app password will work.
Why is your main class called `Connect`?
Here's my completely blunt opinion: 1. Your coworker is an idiot. Visual Studio is an IDE, Python is a programming language. They are not even the same type of tool. 2. Visual Studio is a bloated, 5 GIGABYTE, piece of shit. It has every feature under the sun, and much like Eclipse before it, is a crutch that poor programmers use to fill their lack of ability to design a good application. It is proprietary and expensive. It is slow. Do not waste your time learning it, because you can never fix it or hack on it. 3. Python is an excellent language. C# is an excellent language. I assume by "Visual Studio" you meant C#. God save your soul if you are even attempting to do Visual Basic. If you must do Visual Basic, kill yourself now, and when your soul has come to rest in the dark pit of hell, create a tunneling engine fueled by the souls of dead IT middle management to bore a hole back into this world. Then, with your new found dark power, purge and banish every bit of the Visual Basic code into the darkest, deepest pit of hell, never to be seen again. 4. Python is great at many things, but especially good at solving math, science, web, and system configuration problems. It's also one of the best cross platform languages out there. Python's performance is less than stellar in comparison with some faster languages (c / go / erlang). Python isn't the best language for pretty GUIs, but in the age of the web why aren't you using HTML / CSS / Javascript for that anyway? 5. Learn to code using a real (open source, hackable, changable) editor. Pick from vim, emacs, Atom, Sublime Text, or (new kid on the block) Visual Studio Code. (Visual Studio Code has nothing to do with Visual Studio and is actually mostly Atom under the hood). 6. More important than python is Python. Or I should say, the philosophy and culture around Python is a zen unto itself, that's probably more important than Python. I find that Python programmers (and many functional programmers) are *FAR* superior to others in their care and understanding of systems and code. Design patterns matter. Style matters. Readability matters. Complexity matters. And so on. 7. You may run into people who say, "There is no best programming language, right tool for the job, all programming languages are good, yadda, yadda, yadda". These people are mostly wrong. There *are* better programming languages (we don't program on PDB11's or in Fortran anymore do we?), there *are* better ways of doing things. Python has many of these features that make it one of the best programming languages around today. See also: Go, Elixir, Rust. Still, we're in the proverbial dark ages of programming. In 20 years you will be laughed at if you still program in Java. 8. Python is a huge power language right now because two of the major configuration management tools (Ansible / Salt) are made with it. Put Ansible in your toolbelt along with Python and you can really power your infrastructure. 9. Python has, in my opinion, the #1 HTTP framework out there, Requests. http://docs.python-requests.org/en/latest/ 10. My personal experience with Python is this: Any code I've ever spent real time on, in Python, will just work. It just keeps working. It's easy to read, even for people who suck at Python. It's easy to understand, even when things get hairy. Here's the joy of Python. Let's write a generic wrapper around some API and implement our own custom SSL mount. Sounds hard? It's EASY! class AbstractAPI(): def __init__(self, username, password): self.base_url = "https://example.com/api" self.set_credentials(username, password) def request(self, request_type, api, params=None, data=None, files=None, is_binary=False): """ Return the xml result returned by a GET or POST call where one or more parameters can be a file. """ url = "{}{}".format(self.base_url, api) """ Mount a new SSLAdapter to the session """ s = requests.Session() s.mount('https://', SSLAdapter(ssl_version=ssl.PROTOCOL_TLSv1)) r = s.request(request_type, url, params=params, data=data, files=files, auth=self.get_credentials()) if is_binary: return r.content else: return r.text from requests.adapters import HTTPAdapter from requests.packages.urllib3.poolmanager import PoolManager class SSLAdapter(HTTPAdapter): """A HTTPS Transport Adapter that uses an arbitrary SSL version.""" def __init__(self, ssl_version=None, **kwargs): self.ssl_version = ssl_version super(SSLAdapter, self).__init__(**kwargs) def init_poolmanager(self, connections, maxsize, block): self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize, ssl_version=self.ssl_version, block=block) 
Hmmm.... Don't we all like magic.... Though I'm really curious: how could it be improved and cater to everyone agreeing with it being too magic-y? I was thinking to prepend like `in:http://...`' where `in` would mean inline, and `att:` might mean attached. But that does not seem pythonic to me at all. 
Yea, I agree it is not the best. I simply chose it before I had thought about the naming of things. It will definitely have to change as I also have plans to make it easy to receive emails (which would need an IMAP connection). Would you have a suggestion for naming the class?
It's better to *explicitly* state, that you want to attach a file, instead of trying to guess (which *will* undoubtly fail at some point), if something *might* be a filename (or possibly just coincidentally a path, that you want to send as text).
It's not a good practice to launch scripts from the root anytime you get a permission denied error. You should fix the code. OP is clearly a beginner, and such advice is just harmful for beginners.
Your code is very readable and follows PEP8 and docstring guidelines extremely well. Nice work. 
I thought I'm quite following some style guides (and pylint). Could you point to the things that are not PEP8? 
If you would want links/urls not to be loaded, you just put them with text around it. `contents = 'This is the body, and here is just a link http://somedomain/image.png'` will not be automatically embedding it! Only when they are a separate entry in the contents will they be loaded. It does need a bit of explanation, but it is very powerful like that in my opinion!
Don't base it on the formatting of a string at all. Maybe have some sort of attachment class. So, for example: import yagmail yag = yagmail.Connect('mygmailusername') contents = [ 'This is the body, and here is an embedded image:', yagmail.ImageURL('http://somedomain/image.png'), 'You can also find an audio file attached.', yagmail.Attachment(open('/local/path/song.mp3')) ] yag.send('to@someone.com', 'subject', contents) 
The whole point is that I'm going to assume you just send a blob of text including filenames / urls if that's what you want. Who would have only simply formatted text in a list? `['I'd', 'never', 'write', 'contents', 'like', 'this']`.
That certainly could happen, especially if you're combining data programatically. For example: Say I wanted to embed an image from my site into the body of the email, then follow it with a link directly to the same image? [ 'Please take a look at this image:', 'http://www.example.com/images/blah.jpg', 'http://www.example.com/images/blah.jpg' ] A library that is explicit is easier to program, easier to use, and less likely to make false assumptions.
&gt; contents = ['This is the body, and here is an embedded image:', 'http://somedomain/image.png', &gt; 'You can also find an audio file attached.', '/local/path/song.mp3'] contents = 'This is the body, and here is NOT an embedded image: http://somedomain/image.png. You can NOT find an audio file attached /local/path/song.mp3'
Then to use the library I'd need to know that I need to do something other than what is obvious to make it work. That's harder to learn, harder to remember, and harder to program. It can also lead to totally unexpected outcomes when you're not directly controlling what is being passed. And even here in your example I have to do something other than what I want.
I'm seriously reconsidering this issue based on these comments. However, you'd have to look up how my implementation of yagmail.Attachment would work. I don't think anyone would think to send a list as "content" (always a string), so that when using a list that would be the rationale for explicitly showing they are different "contents".
Or just pass a file descriptor as argument, if you want to send the textual content of a file (or something like `list(f)`, if iterators are not allowed)
The camel case of variable and function names aren't very Pythonic. For instance in https://github.com/kootenpv/yagmail/blob/master/yagmail/yagmail.py PEP8 suggests using lower case and underscores https://www.python.org/dev/peps/pep-0008/#method-names-and-instance-variables
We've spent most of the 60k (I think we have 8-9k left) of Py3k funds on exactly that. We got from nothing to 3.2 using what essentially amounts to half a year of a decent salary in the silicon valley. Now I'm really sorry you're disappointed, but as far as volunteer time go neither you nor me has a say what people should spend their time on and continuing insistence that **my** free time is best spent doing Py3k is something I really do not enjoy about the transition. Now, as far as I know, people are not leaving Python over PyPy ignoring Python 3. People are leaving Python over Python ignoring what matters to a lot of people - performance (whether this problem is real or not is up to discussion) and support for multi core and good concurrency. Deprecating C API would be a good idea to move forward for PyPy to take more of a meager 0.5-1% market share of Python deployment. Addressing multicore **without** needing to rewrite your software to py3k would also be a good thing to do. When people are faced to transition to py3k they would rather just rewrite it in Go and be happy to explore new technology.
What's the difference between an inline image attachment and an attached image?
Look, I'm really sorry you don't think your money was well spent. We did put effort into making Py3k happen and my personal interest is along the lines of "does it pay bills?", which is maybe a bit too pragmatic, but it definitely does not pay the bills. I'm speaking only for myself and there are others on the PyPy team who care about py3k and has been putting tons of effort there, but not up to your standards apparently. My business clients **definitely** care more about multicore python than py3k and they even care more about random small optimizations than py3k even. That said, I can obviously spent my free time to work on other things and I choose to spend it on e.g. vmprof, which is what I care more about, cffi etc. While it's not in line with the vision of "python 3 everywhere", it's in my personal opinion more useful. Again, disclaimer - I'm speaking for myself and not for the pypy team. While you might find other people who share that sentiment, let them speak for themselves. I would offer you the refund if I could, but I did not take any of the py3k money myself.
Well..for one, it's always been easy to send e-mail in python. It's practically [baked right in](https://docs.python.org/2/library/email-examples.html). Secondly, it's *grossly* over-engineered and doesn't follow Python module naming and access conventions.
It's not pythonic.
This is what I use for 90% of my data mining projects...be warned, however, their documentation doesn't match the implementation. SO! If you're getting into weird errors, it's probably different under the hood.
This is amazing! Thanks!!
I'm sorry, but needing so many lines to send an email is not easy for anyone just wanting to send a simple email. 
`True = bool(1)` `True = not True` `True = 1 == 1` Or `ctrl + d`
Or alternatively use the file:/// method of specifying a file to include.
From what I understand of the Email spec (I had to dive into it once a while ago, my memory may be fuzzy) there isn't really a difference between inline and "attachment" media - it's the email clients that decide to pull out certain media and show it as "attachments". The email is just formed from a list of content chunks that may be text or may be other content (including html) - so I think your abstraction makes a lot of sense. The only real concern is that you have to "guess" when bits of the content are actually URLs or file paths - although a URL follows a well defined pattern so I don't see that being very ambiguous, you could make things extra clear by requiring the "file" protocol for local paths i.e. `file://path/to/content`, and also allowing file objects instead of paths. Something that might be a bit of a pain though is if you want to support both embedding remote content from a url AND converting URLs into clickable links (i.e. you give an address and it gets converted into an &lt;a href&gt; tag). Perhaps helper functions like 'embed()' and 'clickable' would be useful? 
A `for` loop would offer a more idiomatic transliteration of your code. It's a bit neater than the `while` version because you don't have to provide an initial value for `i` or manually increment its value during the iteration. You could write something like: import math from itertools import count for i in count(1): # note that `count` can take a start and also a step parameter. if math.sqrt(i) &gt;= 5: break # code to process the `i`s goes here. Similarly, for your second predicate, you would write: for i in count(1): if (math.pow(i, 2) + math.pow(i, 3)) &gt;= 20: break # code goes here.
I hope someone can help me, I'd really appreciate it
Fail? pish posh. Now, I left my /etc/passwd on your machine, would you mind installing this package?
Not Philip. Found this on twitter and thought it was rare enough to submit here.
You should also check out docopt, my personal favorite cli parser tool.
Given the wording (Python Vs "code with Visual Studio"), I don't think your coworker knows what the heck he's talking about. Besides, one can write Python IN VS. But, let's assume he's talking about C#, F#, etc. There's no one language to rule them all. Not Python, not C#, not Java, etc. Each language is suitable to certain tasks. Being able to figure out which tasks a language is suitable to is the difference between being a good developer and a poor one. Developers can have their favorite language (of course mine is Python), but developers should be able to be productive in more than just one language. Windows has a huge market share, but there's a whole world of programming opportunities out there that don't rely on Windows and Python is a part of that. Tell you coworker he needs to expand his horizons. 
Next time you ask for answers, please do it on /r/learnpython. Also, mind linking the site that contains the problem? 
There's no debate. My response was directed entirely to the comment that suggested PyPy's lack of support for Python 3 was somehow hurting the Python language.
/r/Python is for news and releases. You'd do best to post this over at /r/learnpython, which, despite the name, is for questions. Look at your question, though, it seems more algorithmic, not necessarily tied to Python, so perhaps /r/learnprogramming might serve you better.
Yes. This smells like PHP.
Is something supposed to happen when running this code? All I see is a sine that stays exactly the same and the time changing in the title. Apart from that can't you just calculate np.max(np.abs(Cxt[t])) - np.mean(Cxt[t]) for every frame, put that into an array and plot it over time?
I have to agree. The API is globally good, by guessing attachements is too risky and confusing.
If he can't figure out how to get defaults from argparse, he'll never figure out the docopt syntax.
I'd recommend click for building cli apps. Using it has been quite pleasant. http://click.pocoo.org/4/
The reason is simply backwards compatibility, as mentioned in the [logging cookbook](https://docs.python.org/3/howto/logging-cookbook.html#use-of-alternative-formatting-styles): &gt; So you cannot directly make logging calls using str.format() or string.Template syntax, because internally the logging package uses %-formatting to merge the format string and the variable arguments. There would no changing this while preserving backward compatibility, since all logging calls which are out there in existing code will be using %-format strings. Though not directly "supported", the cookbook also gives workarounds if you still want to get the {} syntax by [using another LogRecord factory](https://docs.python.org/3/howto/logging-cookbook.html#using-logrecord-factories) or [custom message objects](https://docs.python.org/3/howto/logging-cookbook.html#using-custom-message-objects).
I didn't even know you could do #1. I always do `logger.debug(Foo: {}'.format(foo))`. Is there an advantage of having the format functionality duplicated in the logging functions?
Yeah they are not very pythonic (and don't look very nice with the compulsory \), but I can't think of a better way to represent them. I think I'm going to re-write most of the classes to be a lot cleaner, there is tonnes of ichy isinstance checks.
Man is EVERYONE making these now? I thought I was so cool when I made [autocommand](https://pypi.python.org/pypi/autocommand/2.0.1), but now I'm learning that *everyone* has aparently made made their own argument parser. argh is the only other one I've seen that uses a function signature to generate the command-line arguments, though; good on them. One of the main reasons I don't use click is I don't like the boilerplate of adding all those decorators for each and every option.
Nice summary. However, most of the matplotlib examples are rather quirky and inefficient. For example, consider the first histogram code snippet: fig = plt.figure() ax = fig.add_subplot(1,1,1) ax.hist(df['Age'], bins=7) plt.title('Age distribution') plt.xlabel('Age') plt.ylabel('# of Employees') plt.show() This can be more succintly written as: fig, ax = plt.subplots() ax.hist(df['Age'], bins=7) ax.set(title='Age distribution', xlabel='Age', ylabel='# of Employees') plt.show() 
What? This is terrific. 
to be fair, docopt syntax is just POSIX syntax which has been around for, ya know, ever. maybe he'd be more familiar! =P
On the same note, I might just create my content as a generator, since you support adding content as a list: def dear(name): yield "Dear " yield name yield ",\n" Obviously this example is far too trivial, but it's easy to imagine something larger (perhaps with loops or conditionals) being done this way. If your library suddenly decides that name looks like a URL or path, then suddenly there's an embedded image instead of a name in my content.
I have tried few CMSs (django-cms, mezzanine) but still they only have something like Manager for adding Pages, Blog posts, Forms which are defined in code. There is no web UI for creating Models/content-types and Views. Or at least I haven't see one yet. And I was looking for an app rather than CMS.
Subparsers can handle that. Though, if your CLI starts getting so complex that even subparsers aren't enough, it might be time to rethink that CLI's design.
I suppose I should point to the docs, http://argh.readthedocs.org/en/latest/. It's actually a lot more flexible that I was using - anything you can do with argparse you do with argh... but quite a bit cleaner
It would appear so, autocommand doesn't appear on their "similar" page: http://argh.readthedocs.org/en/latest/similar.html. I think that shows how bad they all are... even click (which is often praised). &gt; One of the main reasons I don't use click is I don't like the boilerplate of adding all those decorators for each and every option. I think this is the reason I've never quite moved from argparse. I think argh has won me over...
I love click. The ability to easily nest multiple levels deep is so clean.
distutils is deprecated. setuptools is what you want.
Yep. Let's say you're using some sort of log aggregator (eg: sentry). If you call the same log statement twice without interpolation (ex: ``logger.debug('Error: %s', 'argh, I crashed')`` and ``logger.debug('Error: %s', 'something bad happened')``, then both records will be grouped as two occurrences of the same log message, with different values for ``%s``. With interpolation, you'll get one instance of two *different* log messages, which is less useful.
Make. Small. Commits. If that doesn't work, make commits on temporary branches. This will only promulgate a bad idea, that commits are large. Imagine you noticed you changed some small thing some time ago. There is no mechanism in your tool that makes it easy to find an anonymous change. A better way is instead of saving the file and then letting magic software autocompress and back it up, you actually commit the change, however large or small, with a commit message that lets you describe what it was that you were doing. For all changes between commits, editors have undo functions....
http://nedbatchelder.com/text/kindling.html My personal GOTO when I need an idea for a project.
I found hangman to be super easy and fun to code! I highly suggest you give it an honest attempt, I think you'd surprise yourself. Maybe use one from someone else as reference when you get stuck or can't think of the command or structure you need. 
Sorry, I mean. If I want to produce the following: * Text * Embedded image * Link to image * Attached image What's the syntax I have to use? All the image related ones are a straight up URL as string. It's ambiguous what is intended by the user. 
So does it save deltas ? If not then thats wasting resources. How do I control when to backup and how do I label a backup or look at what has changed, so I can find the right version again ? Version Control Systems are there for a reason. Git especially can fullfill pretty much every obscure use case imaginable. 
&gt; Or will they wait until the old-style format is removed from Python? The old `%` notation was removed in Python 3 but was then added back in again because `print('I am a {}.'.format(thing))` is too verbose for simple messages. I doubt it will be removed again. It's much more powerful and flexible for complex output, but for the above, it's much worse. However, I support your wish to get {} notation into logger.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
:)
This is cool. For what I need to do, this is *perfect*.
Since you're so committed to this idea, maybe I can spin it in such a way that you won't notice the difference. *ahem* Check out these sweet-ass backup utilities for source code! * https://git-scm.com/ * https://mercurial.selenic.com/ * https://subversion.apache.org/ * http://darcs.net/ * http://www.perforce.com/
Setuptools used to be buggy and caused problems, so many people (including me) avoided it in past. But now it is well-maintained, provides many small usability features and enables wheels which can be helpful if you're building Cython/C/C++ extensions, so use setuptools.
One thing I discovered from trying to optimise some project Euler challenges is that %-style formatting can be orders of magintude faster, especially when using pypy instead of cpython. $ pypy -m timeit -c "'{}'.format(5)" 1000000 loops, best of 3: 0.927 usec per loop $ pypy -m timeit -c "'%s' % 5" 1000000000 loops, best of 3: 0.00168 usec per loop 
I watched the first one last night. It was very clear with good pacing, this looks like this will be what I've been looking for. Although we'll see how much a of knowledge he requires of C. Thanks for posting this. I plan on watching all of them.
1) Cafe is acceptable, though only if they have the room and good acoustics. A loud, busy, crowded, bumping-into-hipsters-and-spilling-scalding-mochaccino-on-them scenario while trying to install virtualenv is not a good time. I'd myself prefer some kind of back room or quiet nice space, with an option for beverages/snacks. 2) Non-issue. 3) Guided &gt;&gt; non-guided. I don't think people do well without any structure. 4) Some *good* brief (25 min) speakers are great. Long not-good speakers aren't. 5) The meetups I've attended (non-Python) make me feel like the organizers should do all they can to quickly meet and greet people and get them introduced and integrated. Don't be shy or reticent about it. "Hold their hands", so to speak. Unless people are natural people persons, it can feel awkward to walk into a room of strangers. Do what you can to eliminate that, have something to focus on, etc.
Agree. Whatever happened to "All the code written in Python pales in comparison to all of the code yet to be written"?
For all you commenters saying that this is pointless and we should just use a VCS, here's some of the upsides explaining why this might be more useful than a VCS: - It works offline - The size of your project/code is only limited by your hard disk, not your VCS account - You don't need to make/have a VCS account - It doesn't have to be public (as many VCS services are for free accounts) - Its less effort than committing every single little change - It's written in python so you can tweak it to your heart's desire
All of those things are features VCSs have. Git does not need to be online, have an account, etc. Mercurial is written in python too. Don't mix git and github.
`x = 'I am a', thing` doesn't really work, an example is just an example
By new-style formatting, I meant using the format string and then passing the parameters to the logging method, not to `str.format`.
I'm not saying that you're spending your money wrong (I don't even want to know the details, I trust you guys). I'm saying that you're complaining here and there that there is no interest in py3k, but I can see a different picture when I look at dollar amounts people have donated to PyPy.
&gt;Mercurial is written in python too. TIL &gt;- Its less effort than committing every single little change &gt;- It's written in *simple-ish* python so you can tweak it to your heart's desire - It also doesn't require as much setup as far as I can tell
Use setuptools. Distutils is 💩 by comparison.
This tool promotes bad practices. You can make a cron job that runs `git add --all` and then `git commit -m "{timestamp}"`, which would be safer, faster, and easier than the gaggle of compressed files this would make.
Eh, fair enough, each to their own, just thought I'd add the other side of the argument, seemed a bit one sided and unfair ^((also on a side note I wonder which has more cpu impact, your method or this tool, with the same delay of course (including the impact of running a git server for full offlineness etc)^))
Do you check PEP8?
Yes and no. We have some checks, that are also in the PEP8 standard. Right now, we focus on logical and functional code checks that go beyond PEP8. Adding PEP8 isn't a problem though.
I feel PEP8 should be first, then everything else.
There is a malformed attribute with a unescaped quote symbol on the line 24, lxml clearly saying this: &lt;camera url=""Enter URL above"/&gt; Looks like your device generating invalid XML.
They were expecting people to move on more readily. Sadly, many have not seen the light.
That's probably my fault, I took out the camera url because internets...
I ran this with SUDO and it worked
will do, thank you
setuptools can make many mores... `find_packages helpers`, `entry points` (mainly console_script), and `python setup.py develop` You should use setuptools if you can.
Fair enough, thanks for taking your time to explain and stuff :)
It's look nicer :) I tried something like this but didn't find a way to break the loop. from itertools import ifilter, count for i in ifilter(lambda x: math.sqrt(x) &lt; 5, count): pass 
&gt; Once you get more sophisticated though, and need commands, actions, etc it can become a PITA. It's the opposite actually. All those wrapper libraries around argparse work reasonably well up until certain level of complexity, beyond which they break down. With subparsers, custom actions, custom types, etc., argparse supports even complicated CLIs very well.
https://www.jetbrains.com/pycharm/help/configuring-folders-within-a-content-root.html
I am currently using landscape.io, this seems similar but less mature...
got to make the list a string first. try this: base = ['see', 'cat', 'run'] strbase = str(base) removeQuotes = strbase.replace("'","") removeOpenBracket = removeQuotes.replace("[","") removeCloseBracket = removeOpenBracket.replace("]","") splitLine = removeCloseBracket.replace(", ","\n") print(splitLine)
Simple, just do `print('I am a', thing, '.')` /s
 print('I am a', thing, end='') print('.') There, solved it! No string interpolation necessary! /s
Well, there goes my evenings this week.
Why? There's things that are damning of someone's code quality than if they strictly stick to 79 character lines, use snake_case, etc. PEP8 is a *style guide* for code formatting. Not writing Pythonic code.
&gt; and frankly, god help you if you want to do anything with SOAP. Yes, I've figured that out the hard way. However, my company needs data from other companies, and currently four of them only provide SOAP API. When in ~~hell~~Rome.. Suds have been really janky to work with now and then, but it has actually worked and been pretty stable once the quirks were hammered out. As for the others.. Sounds like PyMySQL have matured since last time I used it, that's nice to know :) And haven't heard about asyncio yet.. Guess I got more reading to do.
If you have any questions - just drop them here and I'll make sure to respond promptly!
Since I've gotten used to unicode being standard, I have a hard time going back. I do a lot of math, and I'm no longer afraid to use symbols like θ to represent an angle in my code in a way that is consistent with the math text I'm following. It improves readability a lot, and is more easy to verify against the original source equation (at the expense of being able to print to the terminal in windows without calling `chcp 65001` first). I just insert a little warning at the top of the code saying: 'This program uses unicode - if you are running on windows and don't see a snowman ☃, make sure you are using a unicode font'
&gt; Not having to distinguish the types (e.g. %d vs %s) is handy, too. Is that necessary though? &gt;&gt;&gt; print("Hello number %s!" % 1) Hello number 1!
Sorry, my words were a bit harsher than his. He called it a "Ho Hum Change", said it was "considered too verbose; % will never go away" https://www.dropbox.com/s/83ppa5iykqmr14z/Py2v3Hackers2013.pptx Note that this didn't load for me in the web UI, but I was able to download the file. The differences in capability between `{}` formatting and `%` formatting are negligible, but the [price we pay for it](https://xkcd.com/927/) will last forever.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1600 times, representing 2.4265% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_crti4eu)
https://www.dropbox.com/s/83ppa5iykqmr14z/Py2v3Hackers2013.pptx "Ho-hum changes", slide 18. Words not as strong as mine but it's clear that he doesn't consider to have been a successful improvement.
More services like PythonAnywhere should be there. Others like WebFaction try to be everything for everyone, for supporting Ruby, Node.js, etc. Such unpythonic setup scares Python newbies, and it turn existing Pythonistas off. Instead, we need more Python-specific hosting services for ease, fun and profit.
Fine, but that doesn't mean pylint, which attempts to implement PEP-8. If Pylint didn't have way too much cruft, I'd agree with you. These rules seem to be ignored. &gt; When applying the guideline would make the code less readable, even for someone who is used to reading code that follows this PEP. &gt; To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style). &gt; Because the code in question predates the introduction of the guideline and there is no other reason to be modifying that code. Also, pylint doesn't even follow the recommendations perfectly. &gt; If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator. Yes hypot2 = x*x + y*y No hypot2 = x * x + y * y Also, who invented the 1000 line file requirement or x number of functions/variables per class/variables per function? I have an IDE. Why does it matter how many lines in the file I have? I'd also really love to figure out how to abbreviate classes that use acronyms. Should I use`docxReader`, `DOCXReader`, `DocxReader`, `DOCX_Reader` or `docx_Reader`. They all suck, but only one follows PEP-8 (`DocxReader`) and it's not how it should be written if PEP-8 didn't exist, which is `docxReader`
Well, thanks and I guess you are right. It was an old data, and I could not bare keep track of the changes made, and do fact check, so it was meant to be reviewed as opposed to impress. #2 I agree. I tried to omit the country initially, but afiak the community prefers to do it the other way, so I went with the flow. I'll give this some thoughts. Thanks for the typo too. 
Should add in some of the data from http://www.naturalearthdata.com/downloads/10m-cultural-vectors/ Specifically, would be cool to be able to get a set of lat/long coordinates that describe a country's borders, to determine if a given lat/long is in a country, or be able to determine which country a lat/long is in. 
1. Sometimes I like to split apart a big line into several subcomponents in multiple lines for readability and maintainability. Each line feeds into the next by an intermediary variable. Unfortunately, coming up with these variable names gets tedious and the names can be long. E.g. runConfigID -&gt; runConfigDict -&gt; runConfigDictFiltered -&gt; etc... Is this the best way, or can it be improved? 2. A gripe of mine is that variables get declared throughout the script. Sometimes when you want to refactor code, you simply want to find a variable you've defined already, take that as an input parameter into a new feature, but you don't remember what the variable was called. So really you're searching through all the variables to find the name that rings a bell, and for a long script this can involve quite a bit of reading. Is there a simple way to output all the variables of a script? I'd like to output the local namespace basically, but without running the script ideally. So this mechanism would probably need to exist outside the python compiler, as it's dynamically types variables, I assume. 
I think you meant to use the `sep` keyword argument instead of `end`. EDIT: I apparently don't know how to read.
I'm not sure why this should really matter too much. Maybe I'm missing something? Logging shouldn't be used so much that it becomes a bottleneck. And string interpolation isn't really that intense. The wasted CPU cycles is kinda insignificant IMHO.
I'm a little curious what open source library this is and what you were relying on exactly. Depending on the use case, `__slots__` may be perfectly valid and would be preferred for what you're trying to do. Not to say I don't get where you're coming from though...
Some of them are wrong, like: {"country" : "Brazil","city" : "Bras"}, Brasília is the capital. {"country" : "Dominican Republic","city" : "Santo Domingo de Guzm"}, Santo Domingo is probably sufficient, but the lack of the "án" in the name tells me something is not right with unicode characters or something.
Also, all these: {"country" : "United Kingdom","city" : "London"}, {"country" : "United Kingdom","city" : "Edinburgh"}, {"country" : "United Kingdom","city" : "Cardiff"}, {"country" : "United Kingdom","city" : "Belfast"}, {"country" : "United States","city" : "Washington"}, It should be "Washington DC" and just London, not the others.
You should consider dropping this in /r/SampleSize too.
When I'm looking at a repo and click one of the issues, I'm prompted to sign in with github. Is that trying to submit a bug on my behalf or just asking me to sign-in to see what the issue is?
Done, look forwards to seeing the results :).
Why I have to sign up to view the issue details? You analyze open source projects to give you input (BTW for free) on your "linter" tool and people have to sign up to see the details!? It seems like a "good" idea that happened in a "how to be evil" brainstorm. =/
Thanks for participating! Looking forward to sharing them :) 
Yeah, 99% of old-style formatting for me is either %s or %r.
Not exactly. Python lets us start with direct attribute access which we can replace with properties later if we need to decouple. We get the best of both worlds: no boilerplate getters and setters and we can still have separation if we need it.
We've done something similar for client pre-screening systems which can justify their reasons for either accepting or denying an applicant. Program entrance criteria can be expressed in a boolean-expression-ish python DSL ala: (age_greater(client, 18) &amp;&amp; is_male(client)) || (is_female(client) &amp;&amp; not lives_in_montana(client)) Each expression term is actually a reference to a object whose __call__ returns a similar sort of object. The __and__, __or__, and __not__ methods of these objects end up doing the right thing by evaluating the contained sub-trees and so on. Result objects can be inquired as to if they're ultimately truthy or not, and can produce pseudo-english explanation of the ultimate true / false path. So, nearly a mini-lisp hiding as a DSL implemented in Python. If you're writing such a thing, start with all-encompassing unit tests over the core classes and methods. You definitely don't want subtle bugs there.
Yeah, Theano builds expression trees out of expressions too. I disagree with this approach in general. I prefer to parse the code using the ast module to get the AST. Then transform that into the DSL.
Arve wants me to use that solution in quamash, but it seems so superfluous since quamash has a handful of publically exported classes in it.
As /u/kemitche mentioned, the advantage is that "interpolation" or "formatting", whichever term you prefer, only occurs when the logging level and other configuration values call for that particular logging message to be emitted. This matters because calling str() on an object may or may not be an 'expensive' operation. It's a bit contrived, but what if calling str() on a given object involves a DNS lookup? Some sort of complicated mathematical operation? Even if `YourObject.__str__` isn't phenomenally expensive, if you have a large codebase with extensive logging calls (say, twice as many logging calls as API function calls which isn't all that unreasonable if you consider that you might want to have entry and exit messages for important blocks of code as well as logging arguments to said blocks, the values of important calculations, etc etc), that's a lot of relative overhead.
Numpy is the obvious usecase, and indeed, was the main rationale for allowing this, as discussed in the [PEP](https://www.python.org/dev/peps/pep-0207/). Here, using comparisons for an array will apply that comparison elementwise to the two arrays, returning an array of booleans with the results. Another common usecase is in metaprogramming. Eg. in sqlalchemy you can do stuff like: for post in session.query(Post).filter(Post.author == 'brian'): Here that `Post.author == 'brian'` section returns a BinaryExpression object, that sqlalchemy then uses to construct the corresponding SQL when it's querying the database.
sqlalchemy makes use of this in a few places, specfically in defining queries in the orm layer. So session.query(TABLE).filter(TABLE.ROW == VALUE).one() is a common idiom, and `TABLE.ROW == VALUE` isn't a boolean, it returns a `&lt;class 'sqlalchemy.sql.elements.BinaryExpression'&gt;` which is used elsewhere.
AFAIR, that's something that they borrowed from the R language (which R may well have borrowed from S): &gt; x &lt;- 1:5 &gt; x &gt; 5 [1] FALSE FALSE FALSE FALSE FALSE
heh, you beat me by 7 seconds.
Someone proposed using the @ operator as compose arguing that since @ composes matrices, and matrices are linear transformations, then @ should compose all functions. He argued that it was consistent with decorators. I know that `|` is used on the shell, but while you're in the Python world, I think it's better to stick with Python-like code. People expect `a | b` to be an expression that returns a value. The other problem with your example is that (a | b | c | ) doesn't work. It does with commas. Anyway, I think the shell is kind of a hack. You have tee this and output to `dev/null` that. It would be better to break chains of compound expressions into declarative statements. It would be much better to treat all of these tools like `grep` and so on as functions with multiple inputs and multiple outputs.
Yeah, this is really useful because you can index with that: `np.sum(x[x&gt;2])`
What kind of data are we talking about? Is it numeric, textual, objects? If you can represent it as numeric then the [HDF5](http://www.h5py.org/) file format is a good choice for data sets reaching into the gigabyte or larger ranges. If you're really just working with a couple hundred MB, pure numpy arrays are a good choice, and they can hold arbitrary data types easily, too. I believe I've seen libraries for treating files as numpy arrays that get loaded into memory incrementally, but I haven't used any personally.
"Explore code quality" -- made me think I could read some certified beautiful code. Or sort the other way and feel superior! But nunh-uh, can't find a quality sort at all. Me sad.
I guess someone decided to include the capital of every country which constitutes the United Kingdom.
Yeah, you'd have to do something like move everything out of `quamash/__init__.py` except for the config variables, then use some proxying nonsense to make the things you moved out visible again in the package namespace somehow. It's not pleasant if you've already got public API stuff at the package level. Clients subclassing your classes to strip off `__slots__` is the more sensible thing to do, as you noted below.
1. you could reuse the temp variable `temp = f(temp)` or shorten the fuck out of the established context, runConfigID -&gt; rc_dict -&gt; rc_filtered. If the processing is perfectly sequential you could cram the stuff into a id2dict_filtered() helper function and be done with it. Intermediary implementation details are not that interesting that they should pollute the main paths of program logic. 2. for quick and dirty job grep/regex for `\w+=[^=]`? for fancy stuff you'd probably want to use the `ast` module. A not so pretty example (got a bit tired tracking the tree paths through myriad of different classes to get to relevant ast.Assign objects to make the prog solidly recursive but it shows the principle and it could be extended to track context of these variables knowing their parents) #!/usr/bin/env python3 import ast import sys # test stuff (a, b), c = [[0,1],2] [i, j], k = [[0,1],2] d = {} d[1] = 4 class TestStuff: attr = 1 def variables(node): # print('-- variables():', node) ret = [] if isinstance(node, ast.Name): return [((node.lineno, node.col_offset), node.id)] elif isinstance(node, (ast.ClassDef, ast.FunctionDef, ast.If)): children = (ast.iter_child_nodes(node)) for n in [ch for ch in children if isinstance(ch, ast.Assign)]: ret.extend(variables(n)) elif isinstance(node, ast.Assign): for n in node.targets: ret.extend(variables(n)) elif isinstance(node, (ast.Tuple,ast.List)): # tuple unpacking for n in node.elts: ret.extend(variables(n)) return ret if __name__ == '__main__': py_file = sys.argv[1] ast_tree = ast.parse(open(py_file).read()) file_vars = [] test1 = 'a', 'b' for node in ast.iter_child_nodes(ast_tree): file_vars.extend(variables(node)) for (ln, col), name in file_vars: print('{}:{}: {}'.format(ln, col, name)) test: $ cat example.py #!/usr/bin/env python3 a = b = 1 x, y = (1,2) $ ./ast_test.py example.py 3:0: a 3:4: b 4:0: x 4:3: y $ ./ast_test.py ast_test.py # prog testing itself 7:1: a 7:4: b 7:8: c 8:1: i 8:4: j 8:8: k 9:0: d 12:4: attr 17:4: ret 33:4: py_file 34:4: ast_tree 36:4: file_vars 37:4: test1 
I like the concept, but I agree with the others that attachments/images should be marked explicitly with a function or class (instead of just parsing a string). Also, I couldn't help but notice one little thing in `yagmail.py` on line `231`: home = os.path.expanduser("~") with open(home + '/.yagmail') as f: ..which is the same as: confpath = os.path.expanduser('~/.yagmail') with open(confpath) as f: That's what `expanduser()` does. Just a little nit pick. I would much rather see the `Attachment()` or `Image()` classes implemented.
Here's the link: http://code.activestate.com/lists/python-ideas/33156/ Huge discussion followed.
I know I may have nothing to be here to ask as for, but what is a webkit web client ? what does it looks like ?
Nice list. I have seen the "Transforming Code into Beautiful, Idiomatic Python" video, and found it to be useful even for a newbie like me. But the others seem to be beyond my level of understanding. Which ones should I watch next?
Or Matlab
The best approach I found in this page is: false; until [[ $? -eq 0 ]]; do YOURCOMMAND; done There's a shorter version on StackOverflow(http://stackoverflow.com/a/5274386/2175968): until YOURCOMMAND; do echo "Trying again"; done If you want to use this interactively, you can add some delay to make &lt;ctrl&gt;-c work: until YOURCOMMAND; do echo "Trying again"; sleep 2; done
nice compilation. you can also check out [pyvideo.org](http://pyvideo.org) for python talks. cheers!
Convert this function into a generator, which makes your life easier! You get line for line, without putting your logic into the IO-function. for line in datafile: do_something(line) 
I am very familiar with that feeling of being stuck in legacy hell. I want to find out if anyone is already feeling that with 2.7. It seems that the answer so far is no. While there is useful stuff in 3.x the 2.7 ecosystem and community is still thriving and commercial users are not feeling the pressure to move forward because of lack of support. 
I especially liked RH's [Beyond PEP8](https://www.youtube.com/watch?v=wf-BqAjZb8M). Every PEP8 zealot should be made to watch this, to at least the half-way point, where the already quiet audio starts to get too faint. Watch out for the gorilla! TL;DW: [A Foolish Consistency is the Hobgoblin of Little Minds](https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds)
Basically anything from Raymond Hettinger. He is a great teacher, and usually keeps it low-level/general enough that anyone can follow (maybe with the exception of his talk on inheritance).
That was an incredibly informative presentation, great work!
What about [Super considered super!](http://pyvideo.org/video/3413/super-considered-super)?
thanks. upvoted and saved.
Neither, celerybeat just adds tasks to queues based on your defined schedules (so `timedelta(minutes=1)` would add that task every minute, regardless of the previously added tasks’ states). Yes, tasks Are Just Python™, you can do whatever you’d like with them (complex task dependencies can be modeled with [the canvas primitives](http://celery.readthedocs.org/en/latest/userguide/canvas.html)).
I hadn't wanted to start an argument with the author, but it is [pycparser](https://github.com/eliben/pycparser). Essentially, my thinking is that if I wanted a fast and efficient parser I'd have linked to libclang. I used a complete Python implementation for its flexibility, which is undermined by `__slots__`. Yes I can hack around the use of slots, but my ideal outcome was that I could work out a way to make it optional and then pycparser gains "standard" and "memory efficient" modes.
Yes I actually implemented something similar to what you suggest by overriding `__new__` in the `Slotted` class to either return itself, or a generated NonSlotted subclass if slots are off. This very nearly works, but as I said in my question, the library is peppered with if `obj.__class__ == Slotted` rather than `isinstance(obj, Slotted).
Don't forget that `__slots__` prevents pickling, something else I need. I know there are functions that you can implement to allow a slotted class to be pickled, but the module does not implement these, and I'd rather spend effort on removing the slots :) Regarding your solution, yes you're quite right. My "first attempt" was more like what you suggest and less like I typed above, however I suspect that I messed something up. Thanks for the pointer to PyOpenGL. I'm going to have a look at their setup as that may work well. The slotted classes are only in a submodule of the main library.
&gt; I was wondering if there was any examples of people taking advantage of this in a clever way? In general you shouldn't be clever. Clever code is mostly far from readable and/or quickly understandable.
No? Using `sep` is of course also possible, and allows you to only use one call to `print`, but the end result is the same.
PyCon 2015 videos to be added soon! :)
There is one base class and many dozens that descend from it. Rather than manually defining non-slotted versions of all the descendants I'm doing the following in `__new__` of the base class: clonedict = dict(cls.__dict__) for m in clonedict['__slots__']: del clonedict[m] del clonedict['__slots__'] clonedict['__class__'] = cls Repl_Class = type(cls.__name__, (cls,), clonedict) rv = Repl_Class(*args, **kwargs) return rv So you see I dynamically create a new class which is a subclass of what we are being called to create. This removes the slots. I copy in the dictionary of the original class, minus the slots and descriptors, and then construct an instance of this new class. This very very nearly works, apart from the following: t.__class__ == SomeClass #True type(t) == SomeClass #False Do you know of a way to get around that final issue? Is it possible? I worry it is not!
Why do you think he is kidding? [Armin](http://lucumr.pocoo.org) does invest a lot of time in Rust, to me it seems (partially, of course) exactly because of horrible choices done with Python3 "splitting". Also, Rust is a nice language overall.
Oh, I missed that second line. Actually, I don't know what I thought I read. :/
I assume you are talking about type(t) not being equal to SomeClass!? Yeah that you can't change. type(t) will always be the actual type of the class, you can't fake it. Also note I would use `t.__class__ is SomeClass` instead of `==` but that doesn't make any difference. Given that you want type(t) to be the your changed type without slots, I don't see much option than actually changing the type assigned to each name in the module.
Or the original source, APL.
With only tens of thousands of rows, you'll probably be fine with SQLite: https://www.sqlite.org/whentouse.html Just keep backups like you'd backup anything else.
Thanks, that looks to be for how to configure a specific project. I'm basically looking to change the default location of all pycharm projects. If I just move the pycharm projects folder. It no longer thinks I have any projects etc... Is there a way to change this? 
That's okay. Sometimes I don't either. :)
| I tried something like this but didn't find a way to break the loop. No wonder :-) The code `for i in ifilter(lambda x: math.sqrt(x) &lt; 5, count())` will never terminate. This can be seen by rewriting it as a while loop: def foo(): i = 0 while True: if math.sqrt(i) &lt; 5: yield i i += 1 In both cases, once `i` is greater than 24, Python will blindly continue searching the infinite set {25, 26, .... } for an integer whose square root is less than 5 -- i.e., it doesn't "know" that such a search is pointless. If you were operating on a finite set, say xrange(100000), then `ifilter` would work, albeit very inefficiently, as it would still need to examine each integer in the set {25, 26, ..., 99999} just to confirm that no other elements satisfy the predicate. The appropriate higher order function for your use-case is `itertools.takewhile`, which I see you've already used succesfully.
I'm a big argh fan and use it in all my projects.
It'd be useful to see the country on the job list page, unless you're just going for a US market.
Someone in #python@irc.rizon.net made `cin` and `cout` classes so he could pretend he was using C++. I called him an idiot.
I won't be able to tell you which one is better for your situation, but you might also look at Pylons (more lightweight) and web2py (less boilerplate code, a lot of built-in stuff) as alternatives to Django. Generally, though, I'd say that yes, Python would be very good for replacing your old applications.
Really, though, anything's better than using a TN5250 emulator/screen scraper written as an ActiveX control. ;) (This is what [looksoftware](http://www.looksoftware.com/) does to "modernize" character-based business applications - the hotel I work for uses one such application. It's awful and memory-heavy and slow as molasses. Most users just stick with the green screen.)
Awesome talk, should go on the must-watch list for all programmers.
That was a great talk. I'd like to repeat the question from the talk, could you recommend bloomfilter library for python? I did a cursory search and this one seems the most promising as it's also written in C: https://github.com/axiak/pybloomfiltermmap I'm currently using sets, and as the number of objects increases, it less and less usable.
Honestly, a metaclass is going to be your best bet. However, you're not going to be able to toggle `__slots__` at runtime because it's too late by then. The class has been built and it either has a `__dict__` or it doesn't. You *could* do dynamic class creation if you really needed to, maybe something like this (I've not tested it, so theres that): def make_slotted_child(base, *slots): return type(base.__name__ + 'Slotted', (base,), {'__slots__': slots})
[The zen of CherryPy](http://pyvideo.org/video/281/pycon-2010--the-zen-of-cherrypy---111). Very powerful and much larger than [CherryPy](http://www.cherrypy.org/).
The adoption rate for Python3 is low while some features are being back ported to Python2. In the end, it looks like Python is slowly progressing through incremental updates regardless.
I've been using Python and Django as a basis for Enterprise development for the past 7 years. Just about everything you list comes familiar to me and is something (sometimes a hurdle) that I've crossed. One major (very major) benefit of using Python and Django is that you will be cranking out applications very fast. You can go from idea to prototype to production use in a couple of weeks. The largest drawback is the shift your people will need to make from a .NET or Java mindset. Classic patterns can be translated to Python but often shouldn't. Be careful when you are used to the getters/setters, interfaces, singletons, etc. For best benefits you should commit to Python entirely and be pythonic :-)
If you are really talking about lots of apps that need to work together, have a look MicroServices. They are currently being hyped a lot so there is a lot of material out there. A very good source is Martin Fowler. When building your applications with MicroServices it doesn't really matter what technology is used by which application. You could even keep some giant monster applications that you currently have, expose their data and functionality via a REST service and use them together with new and exciting Python apps! 
You would like the [`toolz`](toolz.readthedocs.org) library. Check it out, it's awesome.
As an added note: Don't use Pylons, it's a dead project as far as web frameworks go. But the upside is that it was reincarnated as Pyramid (which is run by the Pylons Project). Having used both, Pyramid is much better and the documentation is top-notch.
I would rather have a PEP8 zealot than a moron who doesn't have any coding standards, though. But I get it, kind of. Having a tunnel vision focused on PEP8 is kind of stupid, and there are plethora of reasons why you might stray from PEP8 here and there. And if all someone is capable of contributing to a project is pedantic PEP8 patches, then that person is a liability. But making a project PEP8 compliant (and adding/fixing documentation and comments along the way) is a *great* way of getting used to the codebase, so there's that. But I will maintain that a PEP8 zealot is a godsend when compared to someone who writes inconsistent and ugly code.
Was cool to see another raymondh video I hadn't seen in [API Design: Lessons Learned](https://www.youtube.com/watch?v=heJuQWNdwJI) but the audio quality is so poor :(
Django apps can be retrofit onto existing tables provided they meet a few criteria, like each table having a primary key field. It's definitely a little more work and it makes the code a bit uglier, but it can be done.
ok, thanks. Great to know.
I haven't used it, but glancing over the docs, it looks like it doesn't do much to alleviate boilerplate. It's weird to me that it's so performance-oriented but still tries to be so lightweight. It's fine that it doesn't include an ORM, or template engine, or form helpers (as boasted on its [Introduction](http://falcon.readthedocs.org/en/stable/user/intro.html#how-is-falcon-different) page), but I don't see why I would use Falcon over, say, bottle or flask. There are plenty of better ways to improve performance in your webapp other than trying to make the Python go faster, especially in a RESTful interface. For instance, here's their "Getting Started" example: # things.py import falcon class ThingsResource: def on_get(self, req, resp): """Handles GET requests""" resp.status = falcon.HTTP_200 # This is the default status resp.body = ('\nTwo things awe me most, the starry sky ' 'above me and the moral law within me.\n' '\n' ' ~ Immanuel Kant\n\n') app = falcon.API() things = ThingsResource() app.add_route('/things', things) ----------- $ gunicorn things:app And here's the same thing in bottle (flask is similar): # bottle_things.py import bottle app = bottle.Bottle() @app.get('/things') def things(): return ('\nTwo things awe me most, the starry sky ' 'above me and the moral law within me.\n' '\n' ' ~ Immanuel Kant\n\n') ----------- $ gunicorn bottle_things:app In short, based on a pass through the docs, I'd judge it as "not better enough."
You can find videos of all talks given at Python conferences at http://pyvideo.org/ They're less curated but the majority of them are very good anyway.
Totally doable in Django, or in other tools like Flask+WTForms, etc.
Thanks for that - lots of interesting discussion there.
Not only doable in django, but very easy and fast if you leverage the built-in tools of the framework.
Comment out ln 20, and see what happens.
Yeah, I had a similar thought, but when I do that I am unable to use a keyboard command to release the job. In the script above the live stream window needs to be the active window in order for pressing 'q' to quit the program.
We've published a blog post about how we did usability testing of our library for a pair of platforms (including Python), some of you might be insterested, as it covers not only how nice our library is (it is a work in progress), but more of an approach how to test your libraries against fellow developers (specifically when you're a rather old-school, C-coding dev team trying to reach modern developers) [read it here](http://cossacklabs.com/02-usability-testing.html)
If you want to modify fields inline from a list, then you may need to get dirty with Javascript. ASP.NET Webforms does a lot of things for you that are not possible in other frameworks without Javascript. Not saying it is a bad thing, just that it is going to be very different.
much appreciated the reality check. I don't want to get too excited too fast. these are big app systems we need to build with concurrency in mind when updating database data, and complicated/messy business logic in many of the web pages we'll need to build so i'll take the gotchas list any day. many thanks.
well, that's a nice opinion and everything, but that's not Python.
How is it not Python? PEP8 isn't the end-all, be-all of Python.
I tried. Didn't like the API. Switched back to Bottle.
Congratulations! We need more library developers like you. For generating waveforms, you can use PySynth A.
&gt; Python is not typed. I think you still have some learning to do.
You may be able to recreate C's STRCMP. Just make &lt; and &gt; throw an exception telling you to use ==. That would be clever.
&gt; We also need to be able to generate reports to be displayed in web pages, export them to pdf, csv, excel. I've done something like this in several of my applications. You might want to look at weasyprint, which can generate PDFs from HTML. It's resource-intensive, but it saves alot of work if you've already got logic to put the report into HTML. CSV support is built into the standard library, and I believe there is an excel library out there too (I just do do CSV on mine).
SQLite is just fine for storing millions of rows. The question is: How are you going to query the data? If you're planning to build a multi-user web interface, [PostgreSQL](http://www.postgresql.org/) might be a better option.
sorry about the input let me change some of the stuff 
I'll say it again: &gt; PEP8 isn't the end-all, be-all of Python. What's more important? A nice interface to an API or that the implementation of the API is fully PEP8 compliant? I'll take a nice interface with a somewhat messy implementation any day of the week over a shoddy interface that is PEP8'd.
we'll keep that in mind and take a look at it. thanks.
I found this to be a terrible article, rehashing the same, atrociously made and incorrect infographics that we've already seen here in the past. Even if I set aside the fact that the site is obviously biased towards R (heck, all their tutorials are in R), let's look at some of the shockingly bad conclusions/graphs: But first - Repeat after me - "Correlation does not equal causation". 1) Most of the plots and figures are meaningless. Sure, let's compare "R" as a search term against "Pandas" because that's a completely fair comparison /sarcasm. Because obviously everyone working on Data Science in Python tags their posts with pandas on SO right? 2) Salary comparisons are also completely meaningless, and I find that especially rich after the author states earlier in the article: &gt; Comparing adoption and popularity numbers for Python and R is not that straightforward. Since Python is used as a general-purpose language, its applications are more numerous (mainly web development) which inflates some of the numbers. Did it perhaps occur to the authors that because Python is a general purpose language and is used across multiple areas, the salaries will also be varied and looking at a mean/median value across the entire cross-section of Python v/s R programmers would be a dumb comparison? Do you really expect a trained Statistician who most likely has a M.S. or Ph.D. to earn the same or less than a web developer who codes in Python? The R user base is largely dominated by statisticians, academics or data scientists and of course we'd expect them to earn well compared to a much larger and varied user base in Python spanning a whole range of salaries and expertise/skill sets. 3) Perhaps the most shocking piece is this: &gt; In addition to the figures above, other figures indicate that more people are switching from Python to R, than from R to Python Really? I'd really love to see these figures or a citation if you're going to make general statements like that with nothing to back it up. The only figure copy pasted from the equally terrible KDNuggets infographic shows 18% of Python users switched to R but 26% of R users switched to Python. How that equates to more Python users switching is anyone's guess :-/. http://blog.dominodatalab.com/content/images/2015/06/RvsPython.png Would seem to indicate that R popularity dropped in 2015 just as Python saw an increase. Taking a page out of the author's book, I could easily claim - "The figure clearly shows that people are switching to Python from R", but I know better than to draw bad conclusions from random correlations ;-) I'll get off my soapbox now. Frankly, I'd be skeptical of trying to learn anything from a site that applies so little rigor in analyzing data and drawing conclusions.
This is nice, much easier to get started than Sphinx, and the autoreload is need, but how do I embed a class I documented in my code for exemple ?
I think "Python is not typed" is close enough to correct that its ok to say that when speaking in short hand. There are nuances, and its more correct to say Python is strongly, dynamically typed but has no compile-time type checking (but has a very strict implementation of run-time duck typing). This makes it feel "untyped" compared to something like C# or Java, for example. 
that spells relief :)
Postgres has a feature called foreign data wrappers that can be used to query external datasources.
Thanks for these comments and feedback! * I updated the question to tell people to use either imperial or metric and that we would convert them. Thanks! * I hear you. With so many different options, we decided to make a primary set and then use all of the "other" responses to tabulate all of the responses possible. * Correct. A monitor that you would plug into a laptop or a second monitor on a desk. 
If, like me, you are a bloke - then it's a good starting position leaving you open to her further explanations. If no explanation is made or you are unconvinced then you might want to switch that opening position/ - No Python here - Except w.r.t. conferences and exhibitions where if a woman says something at a conference or technical exhibition is sexist then she's most likely correct ;-) 
Lists are a specialty of Python and one of the many reasons why it's so popular. Python lists take any kind of datatype and are just a pleasure to work with, you're gonna love it :)
&gt;I think "Python is not typed" is close enough You think "Python is **not** typed" is *shorthand* for "python is **strongly** typed"? Not to put too fine a point on it, but one of the hallmarks of terrible code is badly misnamed concepts. Being precise and accurate is key to being a good programmer. It probably helps your code base even more than static typing does.
I haven't really had a chance to do a lot of actual work with bloom filters. I built my own to test it out and make sure I wasn't full of lies for the presentation; if I were looking to do something big and production-facing, I'd probably look at the redis-backed [PyreBloom](https://github.com/seomoz/pyreBloom).
i think you didnt actually read my whole comment and are trying to start a flame war because you're mad at life or something.
Thanks for the list. I've been trying to find good links for content about intermediate to advanced concepts in Python, and this perfectly fits that criteria.
Let's face it, OP: "almost lost respect for" == "lost respect for"' right? I concur it's a goofy and unhelpful idea. (Said as a staunchly egalitarian man).
First, /r/learnpython. Second, use an `OrderedDict` if you need ordering preserved in the structure itself, or if you just need it sorted on iteration, use [`sorted`](https://docs.python.org/2/library/functions.html#sorted).
No, that's not more readable or pythonic. The pythonic way would be to use namedtuples. Also, you're setting a class attribute instead of an instance variable, so your way doesn't even do the same thing (hint, if you had two colors they'd all have the same attr values).
Fun! A minor nitpick: the syntax would be easier to grok if the syntax for "has function" was "foo()" instead of "#foo" I think.
I did a brief look round for Python doc utilities a while ago and basically decided that Sphinx was the only option. It seems to be just so pervasive. The problem is, I think it's awful. It doesn't seem like writing documents should be as hard as Sphinx makes it. I'm a fan of markdown so I think I might give this a try. I would really like to see docstring integration though. If I could write my module/class/function documentation in markdown inside the docstring I would be such a happy person.
I would start with looking up or figuring out how to convert a character to it's ASCII value in Python. It is most likely a common problem that has already been solved.
That's very generous of you. Thank you for PySynth, I'll sure check it.
I suppose this is as good a place as any to shamelessly self-promote. I wrote an [alternative to namedtuple](https://github.com/brandjon/simplestruct) that is based on metaclasses instead of instantiating textual code templates. The upside is that it supports a few more features and is easier to extend (see the feature matrix in the readme). The downside is that it should be a bit slower. Use namedtuple if you don't want an extra library dependency, or if you need raw speed / memory efficiency. But if you want a little more extensibility (inheritence), mutable fields, and possibly some type checking, consider SimpleStruct.
I can see why there'd be philosophical objections to evalling, but why does it kill performance?
&gt; Is using a local DB file the best approach? This is not an answerable question. You should use whatever the simplest solution that solves your problem. The data has value and costs you money if you lose it then figure out what the cost of recovery is. If its cheaper than spinning up a tiny RDS cluster or learning a DBMS then go for it. If you just want to monkey around with something industrial grade then install `postgres` or `MySQL` locally, install their back up tools, and spin the backup files to dropbox or s3. its all about you OP what do you want to do? &gt; As time goes on, I expect the number of rows to grow to the tens of thousands. Is using a local DB file the best approach? Tens of thousands of rows you might be able to use a spreadsheet.
Just a reminder, stay clear from business logic in your views! Split your presentation and business rules. Your applications will be much cleaner, easier to maintain and change. With Django, it's easy to get caught in a fast development flow and pack your views with business logic. Don't, you'll thank me later.
Performance? There's plenty of reasons not to use eval, but I didn't think performance was one of them.
I guess I wonder why a scoped class definition (or even an explicit call to `type`) wasn't used instead.
&gt; Falcon only supports very simple URL routing, while both django and flask support complex expressions for routing. I assumed I just hadn't seen it in the docs yet... this is a HUGE missing feature.
Please improve the documentation. And make reference to related prior work: - [PEAK RULES](https://pypi.python.org/pypi/PEAK-Rules) - [Reg](https://pypi.python.org/pypi/reg) these are called "generic functions" if I'm not mistaken. 
Yeah, if I recall, `Dict` is explicitly not to be used for ordered lists.
Dict comprehension are in 2.7, but not in 2.6
It's a great way to start learning the syntax and some simple things, but after a while to do some progress, I think you'll need something more.
I'm fairly sure the Sun's arRays do this too.
http://www.mkdocs.org/user-guide/deploying-your-docs/#read-the-docs
Thanks for the test! I'll have to look into this more.
That's not what happens for me. I create my projects wherever I like, and PyCharm remembers recently used project folders. If a project for some reason would not be in the recent list anymore, I would just open that specific project folder manually.
It indeed works fine in 2.7. Python 2.7.8 (v2.7.8:ee879c0ffa11, Jun 29 2014, 21:07:35) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "copyright", "credits" or "license()" for more information. &gt;&gt;&gt; import string &gt;&gt;&gt; {k: v for k, v in [(c, ord(c)) for c in string.ascii_letters]} {'A': 65, 'C': 67, 'B': 66, 'E': 69, 'D': 68, 'G': 71, 'F': 70, 'I': 73, 'H': 72, 'K': 75, 'J': 74, 'M': 77, 'L': 76, 'O': 79, 'N': 78, 'Q': 81, 'P': 80, 'S': 83, 'R': 82, 'U': 85, 'T': 84, 'W': 87, 'V': 86, 'Y': 89, 'X': 88, 'Z': 90, 'a': 97, 'c': 99, 'b': 98, 'e': 101, 'd': 100, 'g': 103, 'f': 102, 'i': 105, 'h': 104, 'k': 107, 'j': 106, 'm': 109, 'l': 108, 'o': 111, 'n': 110, 'q': 113, 'p': 112, 's': 115, 'r': 114, 'u': 117, 't': 116, 'w': 119, 'v': 118, 'y': 121, 'x': 120, 'z': 122}
Ah I think I meant if you need to create namedtuples with variable field lists on-the-fly then they're not good, because you have to repeatedly eval(). If you only need to create a single type then it makes no difference, obviously.
probably because one requires some trickery to muck with (need to rename the class at the least), the other requires an inverted class (functions defined, then pulled into the class definition when the type (which has a slight wtf itself, with the get-the-type-of-an-object / create-a-type dual usage) is called) at least with the eval approach, its obvious which sections are pulled into the template (`{thing}`) as opposed to standard identifiers
An impressive difference, but you're not measuring the time to eval the textual definition, you're measuring the entire call to namedtuple(). There's like 50 lines of code in that function's body, so it's going to cost more than instantiating the class. Arguably this performance difference would still be present even if the implementation constructed the class symbolically instead of textually.
Check out /u/jambox888's post [here](http://www.reddit.com/r/Python/comments/38ee9d/intro_to_namedtuple/cruli5f). There's significant overhead to executing the namedtuple() function itself, so that should be excluded from the timing loop, along with other setup overhead (like import, and the call to type()) for good measure.
This is a nice list. A little clarification on #3: &gt; 3 Chained comparison operators &gt; Because I was so used to statically typed languages (where this idiom would be ambiguous), it never occurred to me to put two operators in the same expression. This has nothing to do with static typing. It is related to the semantics of Python, which allow for what is essentially rewriting of expressions. So, for example `a += b`, when the `+` operator is defined, but `+=` is not, gets executed as `a = a + b`. Similarly, `a &lt; b &lt; c` is converted to something pretty much the same as `a &lt; b and b &lt; c` -- except that `b` is evaluated only once. Both of the above kinds of rewrites could have been used in a statically typed language like C++. (Yes, there are reasons why it might have been a bad idea; but it would have been *possible*.) And, by the way, if we really miss the C++-style semantics for chained comparisons, the we can still get them in Python by adding parentheses: `(a &lt; b) &lt; c`.[1] ---- [1] A note for the inexperienced: that last paragraph, while it is correct, is a bit of a joke. Yes, the semantics are as described. No, this is not what you want to do. It will result in bugs that are difficult to fix. If you wish, write it as an experiment, to check whether my description is correct. Do not write it in production code.
I'm not timing any of those; just the attribute lookup.
This or metaclassing will be the easiest. If one is really perverse, a combination of compile() and ast.* can be used. But that's like making a nuke to kill a mosquito. 
Don't you think that may confuse people that we are calling the method as a predicate? Otherwise it seems better your way, '#method' was a ruby-ism, because I developed a ruby variant of the library too.
Number 10 is interesting. Does anyone know the origin story and/or how it works?
Maybe a silly question, but what is Arrow() in your example?
\#7 might have also mentioned defaultdict from the collections package.
Reversing dictionaries should be done with caution. What is the reverse of `dict.from_keys(range(10))`? If your data should go both ways, it might be better to store it in a different format (though I do this all the time with translations between api and database)
Here's a POD class where you can just create members directly from named arguments. &gt;&gt;&gt; p=POD(hue=170,saturation=.1,luminosity=.6) &gt;&gt;&gt; p. p.hue p.luminosity p.saturation or &gt;&gt;&gt; p=POD(r=(1,0,0),g=(0,1,0),b=(0,0,1)) &gt;&gt;&gt; p.r (1, 0, 0) Here's the implementation class POD(object): def __init__(self,**kwargs): for k,v in kwargs.iteritems(): self.__dict__[k]=v 
I had thought so too, but apparently it doesn't: in the above code eq1 will just be assigned the value False. (using sympy 0.7.5) The way to do it in sympy would be: eq1 = x**2 - x - 1 solve(eq1, x)
also available in the standard library (`argparse.Namespace`) also worth noting, while this is a more dynamic approach, it does use a lot more memory. (trade-offs and all)
Can one add a field to a namedtuple after creation? Or is the list of possible members frozen on instantiation?
its frozen unless you create a new definition instances are immutable by definition
That's how C string literals work.
I made a *cute* range constructor that resembles algebraic inequalities when I realized I could use comparison operators that don't return booleans. import itertools class Range: def __init__(self, *, step=1): self.start = 0 self.stop = 0 self.step = step self.low_inclusive = True self.high_inclusive = False def __gt__(self, value): self.low_inclusive = False self.start = value return self def __ge__(self, value): self.low_inclusive = True self.start = value return self def __lt__(self, value): self.high_inclusive = False self.stop = value return self def __le__(self, value): self.high_inclusive = True self.stop = value return self def __bool__(self): return True def __iter__(self): start = self.start step = self.step stop = self.stop if step &gt; 0: if self.high_inclusive: def pred(other): return stop &gt;= other else: def pred(other): return stop &gt; other else: if self.high_inclusive: def pred(other): return stop &lt;= other else: def pred(other): return stop &lt; other iterator = (start + step*i for i in itertools.count()) if not self.low_inclusive: # Exclude first element next(iterator, None) return itertools.takewhile(pred, iterator) Ex. for i in 1 &lt; Range(step=0.5) &lt;= 5: print(i) # 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Maybe overloading the bit shifting operators would be a cute way to do step...
My bad, I wasn't familiar with the command line syntax for timeit.
A class I define, which allows me to start the composition chain (functions are a privileged type in Python - unlike in Ruby and a few other languages, I don't think you can monkey-patch methods onto a function in Python). class Arrow: def __init__(self, function=lambda x:x) def __rshift__(self, func) def __or__(self, fund)
Main issue is it doesn't have the equality semantics of a POD class. Create two of them with the same data and == will fail.
You can also use `vars(p)` instead of `p._asdict()`, which is most useful in cases like `map(vars, p_list)`, but if you're on python2, you need python 2.7.6+.
Reading these comments - so much negative, where's the love for Falcon? Falcon is awesome. I've done alot of development with it. If you are building REST APIs then you can't do better than Falcon. I've used Bottle and Flask and Falcon extensively. I like Falcon for REST API's because it carries no legacy cruft needed to support building of HTML apps. I recommend Falcon wholeheartedly.
Parentheses in Python always have implicit line continuations in them, which is why you can do some_big_function(arg1, arg2, arg3, arg4) Instead of some_big_function(arg1, \ arg2, \ arg3, \ arg4) The same logic applies here.
In general I love `namedtuple` and use them quite a bit. Only place where they are lacking is when serializing/deserializing them to/from json (they become lists). While it makes sense why it happens (tuples are treated as arrays), it is still annoying and one place where classes make more sense.
A pass through the docs *qualifies* my recommendation- it indicates that it should be taken with a grain of salt. At the time I made this reply, the OP had been up for more than an hour with no other replies, and I figured something was better than nothing. My opinion was that I didn't see anything to strongly recommend it over libraries that're both simpler and better established. I'll be honest- I dislike it anytime a framework requires me to make a class where a function will do. It's purely a personal preference thing- they just feel too heavy 99% of the time, and they encourage statefulness in a way I try to avoid as much as possible when creating HTTP APIs. Falcon looks like a fine library, and the benchmarks are undeniably impressive, but as I said, it doesn't look better, let alone better enough, than anything else I've actually used.
Upvote for someone who's actually used it. What do you mean "legacy cruft?" Is this something you see in other libraries?
Good point. Let's add that. And let's also add a test for subtype equality. class POD(object): def __init__(self,**kwargs): for k,v in kwargs.iteritems(): self.__dict__[k]=v def __eq__(self,other): for k in self.__dict__.keys(): if not k in other.__dict__ or self.__dict__[k]!=other.__dict__[k]: return False return True def IsA(self,other): return frozenset(self.__dict__.keys()) == frozenset(other.__dict__.keys()) Which gives: In [19]: c1=POD(r=1,g=2,b=(3,3)) In [20]: c2=POD(r=1,g=2,b=(3,3)) In [21]: c3=POD(r=1,g=2,b=4) In [22]: c1==c2 Out[22]: True In [23]: c1==c3 Out[23]: False In [24]: c1.IsA(c3) Out[24]: True 
Falcon doesn't require you to map routes to classes. You can invoke functions from routes if you want.
Next time you have a question: /r/learnpython
I don't understand. There's hardly even an API there for Falcon. There's almost nothing between your code and the web. Minimal, pure, clean.
Is it bad that I cringe when I see subprocess with `shell=True`?
 &gt;Next time you have a question: /r/learnpython Which part of my specific question do you deem to be beginner? I'll give it a shot though, thanks for the input
You are correct.
I think it's more about being able to extend strings across \n, e.g. " SELECT *" " FROM" " table_1" " LEFT JOIN" " table_2" " ON table_1.id=table_2.f_key" instead of having to do it on a single line
Just an fyi, enumerate accepts "start" as a kwarg
There is also namedlist, which I also like: https://pypi.python.org/pypi/namedlist/1.4 Mostly the same except mutable.
Why do you need to simulate browsing if you don't need javascript? If you're just parsing it seems like lxml should be you're go-to.
Maybe if you cringe every time. If you need shell features like wildcard expansion, then `shell=True` might be a good choice! That said, yes, `shell=True` is discouraged in some cases. Using a shell could introduce a shell-injection vulnerability, as pointed out in the [subprocess docs](https://docs.python.org/2/library/subprocess.html). And I suppose we shouldn't ignore the overhead of making the shell process. 
I've used two versions of Falcon now. It started off as a project from a guy at Rackspace and used in some OpenStack components to build REST APIs. Not sure if that counts as production for you but it's certainly been used. Is there anything in particular you wanted to know about it?
I agree, and this is also why I do if not x is None instead of if x is not None
You were so preoccupied with whether or not you could that you didn't stop to think if you should...
I remember trying to use this, but it doesn't serialise with cPickle which was a problem for me at the time. Otherwise, it's pretty great. 
What's wrong with shell=True if there is no injection? 
It's not just for beginners.
Doesn't work as well as a tuple for unpacking: h, s, l = p
Instead of the large nested if, I recommend doing a check and exiting early. Like this. if not results: print("No results") exit(1)
I hope those secret keys aren't real keys...
Installing Python Software – https://py-generic-project.readthedocs.org/en/latest/installing.html
You're right after moving the pycharms folder where I wanted If I reopen a folder within that, pycharm understand it as a project as adds it to the recently opened list. The only thing I can't seem to configure is change the default location when creating new projects (I can change it - but it would be useful if it started looking in the new root folder for projects I have set up - rather than the default pycharm projects one and each time having to navigate across). 
Nothing much. I use it all the time in python scripts that are basically drop in replacements for shell scripts that got big and unwieldy. It's not ideal from a multiplatform perspective, but you don't always care if your code runs on windows.
Brandon Rhodes - Oh, Come On Who Needs Bytearrays - PyCon 2015 – https://youtu.be/z9Hmys8ojno
The method .items() actually returns a [view object](https://docs.python.org/3/library/stdtypes.html#dictionary-view-objects) which is iterable but is not an iterator itself. Views are a best of both worlds in that they're lazy (making them doesn't consume O(n) memory based on the original data) and iterating over them doesn't consume them. Also changes to the original data is reflected in the view object. These views and view-like objects were implemented for some methods and functions in python 3 (the dict accessors, range at least).
Been great so far - I'd love to get the assignments so I can get the full experience but otherwise super enlightening and fun to see and study along!
/r/learnpython 
Also see the sidebar for resources
this course just started last week. https://class.coursera.org/pythonlearn-005
"Explicit is better than implicit."
Code length is significant, a dozen lines at least to do `__eq__` and `__hash__` alone. More importantly, if you change the fields, you have to update these methods (and the constructor). If you don't, you can end up with hard-to-debug issues relating to your class's equality semantics. namedtuple is also based on built-in tuples so it's memory efficient and presumably fast (at least for operations implemented by the base class). So to answer your question, code size, boilerplate, DRY, and performance.
yes, I'm one of the tech/developer/database leads in this project. We are looking to figure out our strategy within the month if possible.
THIS TIMES A THOUSAND. Seriously I wish more people would start using it, its soo useful.
Exactly ;-)
No. The first assumption is correct.
Try: ls /usr/local/bin/virtualenv
Fuck #10. Sure it might have a place when you have paragraphs of text. But if you have an SQL statement that was built with an external editor that parentheses without commas still makes it impossible to copy past back into an external editor. I'm much rather have: '''SELECT Name, Add, Phone, Birth, FROM People LEFT JOIN Addresses ON People.Name = Addresses.Name ''' than: ("SELECT " " Name," " Add," "Phone, " " Birth," " FROM People" "LEFT JOIN Addresses ON People.Name = Addresses.Name" ) Modifying that 2nd' query is a giant pain in the ass. 
Does it work with virtualenvwrapper the same way as 2.7?
Yes. Here's how it works: You have to have an installation of the Python version that you wish to make a virtualenv of. In my case, I have several system installations of Python: py2.6, py2.7, py3.2, py3.3 &amp; py3.4. If I want a virtualenv of a py2.7 installation, I simply do: mkvirtualenv -p /usr/bin/python2.7 $ENV_NAME And virtualenvwrapper will make a virtualenv of Python 2.7 for me. This is ONLY possible if you already have an installation of Python 2.7 available. If you do not have Python 2.7 on your filesystem, you CANNOT make a virtualenv of Python 2.7.
I was under the impression that he was Tyson because both Doob and Tyson have "normal" last names, but have a persona tied to a fancier "Frenchy" sounding name, deGrasse, Dubious and both have longer than normal names. I also think Doob is black. But yeah, the character has a lot of similarities with both Tyson and Nye.
That is just like I imagined. But I'm a bit confused about pyenv itself. Is it the same thing as the virtualenv I have installed, or is it a clone?
 {c: ord(c) for c in string.ascii_letters}
It's not 100% the same thing, but extremely similar. `virtualenv` is a tool created by someone who likes Python. `venv` is a clone of that tool, but integrated into the Python 3 standard library. `pyvenv` is a command line tool distributed with Python 3 that uses the `venv` standard library. It's basically the same as `python -m venv`. Because `venv` doesn't exist in the Python 2 standard library, I personally use `virtualenv`
&gt; /usr/local/bin I get: "2to3 clover-genconfig partutil pydoc3.4 python3.4 python3.4m-config 2to3-3.4 easy_install-3.4 pip3 python3 python3.4-32 pyvenv bdmesg idle3 pip3.4 python3-32 python3.4-config pyvenv-3.4 charm idle3.4 pydoc3 python3-config python3.4m" 
Sorry I'm not sure how to capture a log in the terminal. bash_history doesn't seem to have anything in there from today. which virtualenv gave no output unfortunately. ?
Python in a nutshell? :p
 &gt;It's not just for beginners. Right, then /r/askpython is for whom? I'm not being rhetorical, either. I would love to find a happy medium between the fastidious SE/SO crowd and the newbs, mate If you need context, I'm curious [why the code review given to my code](http://codereview.stackexchange.com/q/87538) does not outperform the new [hashlib.pbkdf2_hmac](https://github.com/jvarho/pylibscrypt/blob/master/pylibscrypt/pbkdf2.py) EDIT: you can downvote but not reply?
Thanks for the detailed overview. Will the same installation of virtualenvwrapper work on both 2.7 virtualenv and 3.4 venv?
You can have a look at these: https://github.com/almost/asyncboto (pretty old and hacky) https://github.com/yyuu/botornado (still old) https://github.com/nanvel/tornado-botocore (more recent)
I viewed some videos with some people who seems to be involved with this: https://www.youtube.com/watch?v=8Xrdt3-YVz4 and https://www.youtube.com/watch?v=fAG3pgKqjXI This lead me to find their webpage: https://www.pypa.io/ To answer your question: things are evolving quite fast
I wrote a similar system to yourself using metaclasses though I didn't take it as far. Was just a side project. https://gist.github.com/Matthew94/9ba0dd2e8379e6883723 I think mine also ran a lot slower but it was intentional. I replaced the internal dict with an `OrderedDict` so if the user added attributes at runtime, it would remember the order when you used ``__iter__`` on it.
I like using virtualenvwrapper. Works both for python 2 and 3. If I need to use stand-alone venv (i.e. for deployment) I go with native python's 3 venv (and it will provide the pip tool for you).
Since you already know other programming languages, the [tutorial from the official documentation](https://docs.python.org/3/tutorial/index.html) should be enough to get you started.
Python 3.4 ships with pip, and virtualenv automatically installs it into your virtualenv. You generally shouldn't have a systemwide pip.
The subprocess model with `shell=True` is about as non-idiomatic as it gets... :)
The sh module will automatically generate something close to this
For packages that it has, they will be up-to-date, at least within a day or two of a new release. But it doesn't have every package, so you should install pip (`conda install pip`) into all your conda envs so you can pip install any extra packages you need. The tools work great together.
Currently developing a falcon application. I agree with your statement 100%. I dont have as much experience with bottle or flask, but I've worked with many different API frameworks in many different languages and I can safely say falcon is one of the simplest, and it does exactly what I need. I actually was a django dev for years and its refreshing to go into a project just adding what is needed for the problem you're trying to solve. I think frameworks like django have their place for rapid prototyping and for budding engineers as a learning tool, but for a production ready app I would pick falcon hands down.
Maybe try adding this to your $PATH: ./Library/Python/3.4/lib/python Since it looks like you have a standalone Python interpreter in your home directory in addition to one that was installed in /Library
Can you clarify this statement? What boilerplate code was hindering your process? I would think that the class-based nature of falcon would alleviate most issues with too much boilerplate code.
Also ChainMap is very handy.
I take it you don't use an editor with macroing because going from a copy paste to setting it up for another editor is easy. 
The 80 character rule really blows my mind all by itself. Seems like a throw back to the days of fortran, punch cards and tiny monitors. I often wonder what it would take to get That PEP updated to reflect reality as of today. By the way I realize that long lines of text have their problems but conversely a long line of text offers the ability to concisely and verbosely code a bit of logic. I'm a big fan of verbosity in code as it makes it far easier to come back to a piece of code month or even years later. 
Start by looking at PRAW the reddit API for python. 
Yeah, agreed. In this case (as in most cases), it should be omitted. I just wanted to make sure that /u/billsil wasn't cringing *every* time they saw `shell=True`. (I might have just misunderstood their comment.)
I know this flies in the face of current management practice at many corporations but you really should find some training for your team for a major break from tradition. Your tradition here being the MicroSoft way. In the end to be successful you need to change the mindset of the developers on your team before you start to generate a lot of code. 
The funny thing here is that I would consider Python a better choice for batch work that it is for the web work. This considering that Python is an excellent language for Web. In some ways Python is an almost perfect cross platform scripting language. 
Of course they have overhead... *How much* is the important thing. Every single thing has overhead. What about the overhead of threads? Context switching? How does it affect the CPU cache? Memory? Obviously none of this was considered in this idiotic blog post. This post is a total waste of space and time and has no place here.
As it hardly loads: http://webcache.googleusercontent.com/search?q=cache:http://opencv.org/opencv-3-0.html
Thanks for posting, the enumerate function has done wonders for my code cleanliness... Now I just need to get more practice with slicing numpy arrays and getting rid of loops there.
&gt; greatly improved Python support, including Python 3.0 support, many new tutorials &amp; samples on how to use OpenCV with Python. I quoted this because OpenCV was mentioned frequently as one of those projects which prevented Python programmers to move to Python 3.X.
This would be fantastic and our company has started giving us web training over the last couple years, but we still run very tight on resources/time so it's always a challenge breaking out of what we know. We want to, but resources get in the way.
Get a specific account with the user = reddit.get_redditor() https://praw.readthedocs.org/en/v2.1.21/pages/code_overview.html#praw.__init__.UnauthenticatedReddit.get_redditor Then on that object you can: comments = user.get_comments() to get a comment generator.
Is a Python 3 build not included in the default Windows OpenCV distribution? I only see a 2.7 pyd file. Also it appears that they're still using the `cv2` namespace?
The python documentation is pretty clear, and it's hard to draw the line between "help with homework assignment" and "do homework for him". If you're a java developer, you ought to be able to figure this out and help your cousin.
I hope it's Python 3.4 though (not below that).
Man that's a great article. Their other stuff is great, too- they're going into my feed reader.
 &gt;First of all, `basestring` is an abstract class. It can't be used for anything concrete, i.e. you can't create a variable of type `basestring`. Its sole use is to act as a common base class for both `str` and `unicode` so that you can write things like `isinstance(foo, basestring)`. Gold coming your way for being helpful. Thank you mate
oh no I'm not a java developer I just write things in java. And yea he's really stuck with this one question.
Hmm.. maybe.. you could do @on.has_method('foo') if you want it to be really readable.
It's a standard side effect of software bundles. When they released Python 3.4 they added the latest pip version they could find. When the Py3.5 will be released, it will also be shipped with latest pip version. And so on...
try this loop to get a list of numbers representing the string text = "The string to convert" nums = [] for letter in text: nums.append(ord(letter)) You should be able to figure the rest out.
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
wat
ah I see ty.
this is what I was looking for thanks:) 
Yeah, that code snipped made no sense to me; couldn't it just as easily have been a list?
Yes, that would be odd :)
Fantastic news! The 2D/3D shape and text detection sounds awesome!
yeah, or `@on has('foo()')` and `@on has('.baba')`, I think that would strike the balance (it should be `@on has` because we dispatch on multiple arguments)
Clever :)
I've been working with Excel spreadsheets programmatically, and the only thing I can say is: there is *no* sane way to work with Excel spreadsheets using APIs provided by MS. The best way I know would be to: - save the file in `XLSX` format - open it as a ZIP archive - inside that archive you'll find files `xl/worksheets/*.xml` - parse these files and try to recover the formula you need These files look like this: &lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt; &lt;worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" mc:Ignorable="x14ac"&gt; &lt;dimension ref="A1:C1"/&gt; &lt;sheetViews&gt; &lt;sheetView tabSelected="1" workbookViewId="0"&gt; &lt;selection activeCell="C1" sqref="C1"/&gt; &lt;/sheetView&gt; &lt;/sheetViews&gt; &lt;sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/&gt; &lt;sheetData&gt; &lt;row r="1" spans="1:3" x14ac:dyDescent="0.25"&gt; &lt;c r="A1"&gt; &lt;v&gt;1&lt;/v&gt; &lt;/c&gt; &lt;c r="B1"&gt; &lt;v&gt;2&lt;/v&gt; &lt;/c&gt; &lt;c r="C1"&gt; &lt;f&gt;A1+B1&lt;/f&gt; &lt;v&gt;3&lt;/v&gt; &lt;/c&gt; &lt;/row&gt; &lt;/sheetData&gt; &lt;pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/&gt; &lt;/worksheet&gt; 
Just a guess, but likely they didn't think it was with the effort if they already planned the next release to support 3.x.
You sound like a programmer to me. Good job yo! Edit: debug, debug, debug
Yes, this should generally improve Python 2 performance since it is an improvement to a big switch statement that is used when executing Python bytecode (think compiled Python code). Personally, I've noted general performance improvements of 10-20% on Python 3.3 and 3.4 over 2.7, so this could be a good explanation of why that existed.
After 5 seconds of googling I found this: https://openpyxl.readthedocs.org/
The very first link is a table of benchmarks and relative performance with this patch. The benchmark names seem pretty self-explanatory to me. Are there any you are having difficulty understanding?
Thanks, I just uploaded the code a min ago. I didn't know I needed to add 4 spaces to ever line to format it here. 
I like it haha
Ive been trying to get this shit to work with the 3.4.1 scipy stack and pure python 3.4.3. The shit just doesnt work. The 2.7 pyd file doesnt work. Dll errors.
Yes, it does :)
if thats the case, do you know where on tyhe website it lists how to install the library so that it works on python3?
an example of standalone python/pyobjc app with various tricks to make it both a script runnable from the command line and an regular Mac OS X app. dev takes place here: https://bitbucket.org/rndblnch/osx-presentation
It's an open source project, so if people are willing to work on 2.x it would be silly to forbid them that in the name of progress. Also, no new features are added - but abandoning development completely right now would leave many people with potentially vulnerable interpreters.
But I need my scapy :(
Install Miniconda first, then you can use it to install 64 bit python I think the direct conda staller auto-installs 32 bit 
seems like all the best performing computer vision is done using deep neural networks and GPUs these days. strange that openCV doesn't include it. maybe v4.
Well-written post, but definitely the wrong place for it, as others have pointed out. Move it a little away from python, and towards pseudo-code, (which isn't hard, they're both easy to write), and repost on /r/learnprogramming for better results.
Wonderful you just invented Scala, congrats.
This is great news indeed, we have been waiting for this release for a large Python project. One thing that is a little annoying is that OpenCV is not "pip friendly", you can't just create a virtualenv and "pip install opencv", you have to manually copy some .so and .py files into the virtualenv after installing opencv from apt which is a bit hacky.
Can you use conda though?
In this case, someone from an Intel team contributed the patch, so it wasn't created with man-hours from the core python team. It was decided after much discussion on the mailing list that this is a good thing in general- as the Python team continues to move toward Python 3, commercial interests will pick up the slack of Python 2 development, as is the ideal for an open-source project: &gt; Giving the nod to an increased corporate developer presence in Python 2 maintenance should eventually let volunteers stop worrying about even Python 2.7 bug fix changes with a clear conscience, confident that as volunteer efforts drop away redistributors and other folks with an institutional interest will pick up the slack with paid development time. "Do the fun stuff for free, figure out a way to get paid for the boring-but-necessary stuff (or leave those tasks to someone else that's getting paid to handle them)" is a good sustainable approach to open source development, while trying to do it *all* for free is a fast path to burnout. \- Nick Coghlan &gt; However this talk of "wasting our time with Python 2" needs to stop, and if you think that making Python 2 less attractive will encourage people to migrate to Python 3, think again. Companies like Intel are *contributing* by offering this backport up publicly. \- BDFL
/r/learnpython
This answer is ... ... epic
Read the article
Does this maintain a reference to cv? Some libraries like tesserct still need iplimage 
I mean.. it's in the docs [here](https://docs.python.org/2/library/collections.html#collections.Counter) It really isn't that crazy 
Is there anything OS X specific in the actual code or is it just the packaging? Could this be easily adapted to a Linux / Windows system?
Why not use `all`? if all(this_parrot_is_norwegian, this_parrot_is_blue, this_parrot_has_been_subjected_to_a_droptest, droptest_failed): print "This is an ex-parrot!" It's a little cleaner, and many builtins are optimised in ways that would be too verbose to do manually - in this case it stops evaluating on the first False and returns.
Can anyone link me on how to install this for python3 in ubuntu-arm? Is there an apt-get or do I need to compile things?
Flann has direct Python bindings and a decent user manual. 
scalability has more to do with everything else rather than what framework you use to make a web site. The framework allows you to make a web site, it's your ability to use it, to engineer solutions, that makes it scalable. You can't just "import scalability framework" and be ok.
A common method of scaling python web apps is to use nginx as a reverse proxy and use a caching layer. With uwsgi, any framework with support for wsgi should work fine.
One fallacy of your assumption is that your first "they" is different from your second "they". Another is that (despite the internet's apparent desire to reduce everything to a binary choice) these two goals are not mutually exclusive.
So both django both pyramid will be OK? I know that Instagram is running on django and dropbox on pyramid and they are serving millions pageviews daily. 
Brandon Rhodes explains that in [All Your Ducks In A Row: Data Structures in the Std Lib and Beyond](https://www.youtube.com/watch?v=fYlnfvKVDoM#t=34m02s).
To throw another data point out, Twilio runs their API on Flask.
I mean yeah, at this point it'd be counterproductive to target 3.0 or something. 
No documentation.
Well, /r/askpython is defunct. It's for nobody. Don't be afraid of the newbies, they're harmless. The most obvious reason for a performance difference is that the review code is recalculating the hmac with the salt every time around the loop, while the pylibscrypt code caches the result. Other potential causes are creating a new bytearray instead of mutating the old one, using `range` instead of `xrange`, and calling out to the `prf` function instead of inlining.
This looks pretty cool, thanks! This relies on celery internally? 
it is totally specific to mac os x: it uses heavily the cocoa toolkit through the pyobjc bindings. 
full disclosure: I'm the main developer. But yes it does use Celery, it's the way the way work is dispatched to workers. There's a BaseExecutor class that can be extended to use other means of execution, currently we have only LocalExecutor, SequentialExecutor and CeleryExecutor, which is the one we use in production. We are considering using Yarn by writing a YarnExecutor, but Celery with a Redis broker has been working very well for us.
It seems that OP thinks that /r/python is /r/askpython.
dou you have any personal opinion (pros/cons) versus Spotify's [Luigi](https://github.com/spotify/luigi)?
There should be links to various free job boards on the sidebar of /r/python
What does the example even accomplish? And why can't I use `functools.partial` if it does what I think it does? The code doesn't exactly reveal intent or purpose.
Kinda. In CPython, `deque` objects [use a doubly linked list wher each item is an array of 64 objects](https://hg.python.org/cpython/file/f86678551af2/Modules/_collectionsmodule.c#l26).
&gt; You can’t use `functools.partial` for class instantiation because it doesn’t work on classes, only functions. Yes you can. Anyway, I see now what's different from `partial`: you look at whether or not enough arguments have been given to the function, which is interesting, but I prefer normal `partial` behaviour, where `partial(f, a)(b)` is always the same as `f(a, b)`. So then you'd get: from functools import partial @partial(partial, partial) class Test(object): def __init__(self, name, count): if isinstance(name, int): name, count = count, name for i in range(count): print(name) Anyway, I'd prefer to leave out the `if` and using kwargs for supplying the count first: `Test(count=5)('foo')`.
I have installed OpenCV 3.0 + Python 3 on Ubuntu and my Raspberry Pi. I'll have install instructions coming on the PyImageSearch blog in the coming weeks for sure.
Can't say for sure. It looks powerful and well done. You have to know your own needs though. The last time I wanted something like this, my own requirements were simple enough that I knocked up a good-enough version in twisted in about the time it would take to learn the new framework. It will come down to how complex your task actually is, how experienced you are with alternatives, and how many more tasks like it you envision doing in the future (is there a benefit to spending time learning a new framework?). The documentation and api does look very well though out though, so the barrier to entry may be relatively low here. Good luck!
The 2.4 series Python bindings are fantastic (on Linux). I guess the problem is windows, not C / C++ having a priority.
It has been literally less than a week since this was released.
Wow... That's pretty cool! Can't wait to give it a try :-) It's usable even on Android, right?
The query is ok. You might be hitting some sqlite memory limits based on your settings. You should check sqlite log.
The problem is that it doesn't work for python 3 (at least 3.0.0 rc1 doesn't). I've tried there shitty tutorial and it didn't work. Every other tutorial I've seen has been different. No one seems to know what the fuck there doing. Shit just refuses to work and is causing me not to progress in my project.
Be sure to catch the Brits giving their weight in stones.
&gt; there is no sane way to work with Excel spreadsheets using APIs provided by MS except VBA ? 
What are you doing that you need all 70000 rows? You're definitely hitting memory limits. If you're running Linux, open up another terminal and run top (or htop if you have it). Or if you're on Windows open up the task manager. And then run that query. I would definitely suggest gathering only the rows you need using where, group by, and having. Potentiality limit and offset (but there's known issues on bigger data sets using limit and offsets, but this is pretty much universal). Hand in hand with that is selecting only the fields you need. `*` is handy, but should be used sparingly. If sqlite supports them, look into using cursors. Look into pandas for manipulating your data once it's in Python. If None of that works, it's time to look at something like Postgres. Especially if you're doing some transformation that's hard to write in SQL but easy in Python. There's PL/Python that'll allow you to embed a Python interpreter in Postgres (as a warning PL/Python only has an unsafe package, so you'll be able to do everything there you can in regular Python). Embedding Python in this way adds considerable overhead, but sometimes it's the best thing to do. However, without more information like what you're trying to do, what your schemas look like, how big the average row is, it's hard to give specific advice. 
what if a formula refers to another formula ? You have not really described your issue and what you want.
Dawg, I heard you like currying functions so I put a currying function in a currying function in a currying function so you decorate classes and make them curryable. On a more serious note, putting that partial monstrosity in a metaclass's `__call__` method works better than just decorating the class. 
You are a gentleman and a scholar.
Yes. It's the easiest way I've found to do push notifications for free.
is knowing C required to understand ?
from collections import defaultdict customers=defaultdict(list) for index,coord in enumerate(coords): customers[site_ID[index]].append(coord) Not fancy, but should do it. Will need some error checking, etc. Alternatively: for id,coord in zip(site_ID,coords): customers[id].append(coord) looks a bit cleaner.. 
Works to do exactly what I want. Thanks for the help. Where was the main error I had? 
Yes, I know classification is cool, but &gt; it's the frontier. is opinion....
No problem! umm.. if it was exactly the line you pasted in, then you compare num (=?) to count.. if by num you meant ID, then the logic in your count is a bit funky.. on the first run, count = 0, and ID = 1 .. it will take the count+ branch in the next iteration, count=1, ID=2.. then you should get count=2, ID=2, so dict insert. then count=2, ID=3. If you'd started with count at 1, and indexed at [count-1] it might have worked. Best to rethink it :) There is almost always a really clean way to do it. 
Try inheriting from that partial'd class. That's when a metaclass becomes a better solution. 
Thank you! I kept seeing the printouts looking wonky but I couldn't put my finger on it. When I was 15 lines in I thought there must be a better way. 
Fair enough. I never consider issues around subclassing because I tend to not do inheritance and favour composition (or just foregoing classes altogether). (Although I should have realised in this case, because `partial` won't return a class object, which means no class methods etc either.)
Nice work. Suggest that you provide a section in README about Google security settings to check for this to work. I kept getting the freaking "smtplib.SMTPAuthenticationError" with both gmail package and yagmail. Turns out it is [this rather obscure setting](https://www.google.com/settings/security/lesssecureapps)
let me guess...it's that pep8 talk at pycon2015 
 yag.send('foo@bar.com', 'Title !', 'Try this out') Why the heck is it insisting on putting body text in attachment ???
My guess is that Eclipse is using Python 3 and your command line is using Python 2. `func(a, *, b)` isn't supported syntax in Python 2. Trying running `python3 my_script.py`.
This kind of stuff is used all the time in visual effects, mostly for managing the 'rendering' pipeline. All any visual effects artist does is author some sort of description for the location and color of 3D geometry, cameras, volumes like smoke, lights, and other things. "Rendering" is the process of taking those descriptions and actually turning them into images. It can be extremely resource intensive, and is massively parallel, so every studio uses a 'farm' of computers with a system like this managing render jobs on top. The rendering process often has many complex dependencies. For example, shadows must often be calculated before the final image can be created. The dependencies are predictable but, for example, the number of shadows varies for each artist and each scene. There are many other dependencies too, so doing all that management by hand becomes ridiculously slow. Apart from rendering, all sorts of other jobs need to be run to get assets through the pipeline, and many of those can be run through the same framework. Even if they aren't parallel tasks, running them remotely frees up the artists' machine. So very useful in that context. I'm not sure what other businesses use it for, but I imagine similar problems come up.
Looks pretty good. But I can't find if this works on Python 2 or Python 3. May be I am not reading the right documentation. The reason I am asking this is - on python 3, I am running into exceptions while issuing airflow initdb Which throws the following error: ImportError: No module named 'airflow_login' And also: ImportError: No module named 'ConfigParser' It's the last errot that seems to be related to python 2, as the module is renamed to "configParser" in python 3 to adhere to pep8.
Airflow is for batch jobs. Typically large jobs that run hourly or daily. Our scheduler triggers every minute (it's configurable).
Arflow is for Python2.7 at the moment. I have a branch somewhere modernizing my code, but many of the libs that Airflow depend on aren't Python3 ready yet.
So it's a change to PyEval_EvalFrameEx?
I'm looking for a position. Please [review my resume](https://docs.google.com/document/d/1aHCWj5l18-yxwaXnBTOKdMOsQLxD-B9mMavxycb7juU/pub). If it meets your needs, I'd love to talk!
Pymel in maya has an interesting node connection syntax Node.attr &gt;&gt; BNode.attr will connect those two attributes in that direction. // will disconnect them 
I've been using it since OpenCV-3.0.0-alpha with Python 3.4.
Ah gotcha. Thanks for the reply, and more so for open sourcing this. Now I need to figure out how I can use this (with pyhonn 2.7) while my other etl code is running on python 3. *EDIT*: Say, I install airflow with python 2.7. Is there any way I can use airflow.operators.PythonOperator to execute a python 3.x script/module that's sitting in it's own virtualenv?
Was just looking into OpenCV two weeks ago for Python3. Excellent timing!
Airflow has a BaseSensor class that you can derive to define any type of sensors, you just have to override the `poke` method and make it return a boolean. So I guess you could write an LsfSensor, or just use some sort of trigger file in HDFS, S3 or elsewhere.
My knowledge of Luigi is limited, I retract my statement!
Interesting. PythonOperator runs in-process and receives a callable and args + kwargs. The easiest thing to do is to use BashOperator and call your script explicitly with a python3 binary.
&gt; write a script every day for a year, and each script depends on one or many scripts you've written before that year and times &gt; Now think of a data team of dozens (or hundreds!) of data engineers That's called a catastrophe. One of the first things you learn in writing these processes is that they can't be quickly slapped-together "scripts", regardless of the language used. I find that Python works great in these cases - but the tasks should be well-tested, somewhat bulletproof. And if you have 10,000 tasks with many interdependencies - it's unmanageable. It takes constant refactoring &amp; grooming to keep a system like this simple. And if you invest in a high-performance, well-curated adhoc-friendly data store, then you can eliminate an enormous amount of redundant tasks, producing redundant (but seldom consistent) data - and replace them with much smaller queries against that consistent data store. Between the above two strategies you can reduce 10,000 tasks down to 50 - which is a totally different kind of problem. And doesn't typically need a huge, or complex framework.
Django, hands down. Not necessarily because of Django itself, but rather because Django REST Framework is awesome, and as the name indicates it's only available for Django. DRF has displaced TastyPie as the go-to framework for creating REST APIs. As of last year it's even listed in ThoughtWorks' influential Technology Radar: http://www.thoughtworks.com/de/radar/languages-and-frameworks/django-rest However, since you mention MongoDB as a hard requirement, Django and DRF might not be the best option, as Django is still heavily oriented towards relational databases. In that case you might want to use Flask + TastyPie.
Let me emphasize that both are extremely good choices. The difference is rooted mainly in their different philosophies and design. Flask is a micro-framework. It basically gives you a router and a small debug webserver, based on [werkzeug](http://werkzeug/). All the rest would have to be implemented through plugins, other 3rd party packages and manual coding. On the other hand, Django brings more to the table, notably an ORM. You can then use [Django Rest Framework](http://www.django-rest-framework.org/) to expose the models through a REST API. Note that the ORM is extremely oriented towards SQL databases though. So in the end, my advice is: if you can use all of what Django brings you, you're probably using it. However in your case, as you're using mongoDB, and Django is kind of an SQL-only-framework, I think it's safer to use Flask, and will be *easier* to integrate with it. I emphasized "easier", because you can use Django with mongo, it's just more work. My 0.02$ 
I wouldn't go as far as to say you need to be an expert. Having a cursory knowledge of C concepts is useful. He isn't assuming his students are C expects, and even explains some C concepts, but others are glossed over as assumed knowledge. If you understand arrays, structs, pointers, and some control flow mechanisms (functions, loops, switch statements, gotos, etc.), you should be fine, even if you learned them in another language.
it would be nice if there was a job board mega thread. nothing wrong with bringing opportunities to the python-reddit community. 
Thanks again - that's what I thought. So the way forward would be to have multiple virtualenvs, and make use of venv path while calling python 3 scripts/modules over bash operator.
Even if you're not familiar with Go, I think it's interesting to see how you reproduce generator functionality in the language. Python is still significantly easier and more clear, in my opinion. But the approach in Go is easier than many other languages.
[Bond](http://www.thregr.org/~wavexx/software/python-bond/) can let you call Python 2 from Python 3 and vice versa (as well as PHP, Perl, Javascript).
Flask all the way. Flask-Restful is handy but not absolutely necessary. You can go a long way with just blueprints and class-based views. Flask extensions for all needs are plentiful and they're easy to write if you need custom functionality. Mongo support is ridiculously easy to integrate. If you end up bringing in a relational database (please consider it), it's easy to integrate SQLAlchemy. I think you'll find if you build an API in Flask, you'll gradually add in things you need and you'll develop an understanding of how the system fits together. With Django, assuming you even bother, you'll end up peeling things out that you *don't* need, and you'll find there's a degree of opacity to the "magic" of Django that makes it more challenging to understand how the pieces fit together. As an aside... "MongoDB" and "financial" appearing in the same sentence makes me worry for your data. Think very, very hard about that decision. source: have written many APIs with Flask, Flask-Restful, Werkzeug, Django, and DRF
If you're curious what a currying metaclass looks like, [I wrote a blog post about building one](http://justanr.github.io/currying-and-memoizing-metaclasses) a little while ago.
weird your problem, check this link : https://www.friendpaste.com/6jdXdYPdC6YFffwNL6lqpq I have created 100000 records and I can list them with no problems. 
Is this allowed? Seems like it should be against the TOS or something. Cool idea though. 
Ha - you learn something new everyday! Though I wont be able to use it in the above situation (for various other reasons), this look very interesting module! Thanks for sharing.
I bet it takes longer to read all of those comic than it took you to write this app. 
Yeah, it's pretty simple. Just something I felt like writing up one night.
[Relevant XKCD](http://xkcd.com/1319/)
[Image](http://imgs.xkcd.com/comics/automation.png) **Title:** Automation **Title-text:** 'Automating' comes from the roots 'auto-' meaning 'self-', and 'mating', meaning 'screwing'. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1319#Explanation) **Stats:** This comic has been referenced 186 times, representing 0.2803% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_crwqwlr)
We have reached the singularity.
I'd feel comfortable basing any new project on Flask.
this is like building a house foundation out of toothpicks. Possible. Interesting. Doomed to fail.
Ugh. Yup, my bad.
It sounds like a lot of the results of API calls are going to be calculated, rather than an expression of relational data. I would go with Flask. Much as I adore Django, it can kinda get in the way. Flask will not get in the way. And it sounds like a lot of the cool stuff Django has just won't be that useful to you. I generally tend towards thinking of Django as being for sites, Flask for APIs.
PM me for resume if I can work from home.
please add facebook &amp; tumbrl, much more data integrity.
Ditto. Chrome 40.0.2214.94 (64-bit), Linux.
You, and I, and the rest of "internauts", are just individual neurons on another brain we call Internet. I wonder if that brain has already become self-aware.
I asked a similar question, some of these may be of interest: https://www.reddit.com/r/Python/comments/25njwl/which_python_projects_do_you_see_as_the_gold/
Here's another vote for Flask. There's so little clutter and with uWSGI it works pretty solidly.
You could build a proxy in Python that *could* filter content for you. But you are probably asking about something along the lines of a browser extension (like an ad blocker) which would have nothing to do with Python.
I'm very sorry It works well 
I'm very sorry It works well 
Its just a rehash of GmailFS(http://en.wikipedia.org/wiki/GmailFS). I'm sure reddit will be equally thrilled.
Thanks. Which would be the best tool to use for such?
Here you go. Strart hacking! https://code.google.com/p/python-proxy/source/browse/trunk/PythonProxy.py http://stackoverflow.com/questions/10650016/local-python-proxy-for-web-browser http://stackoverflow.com/questions/4773093/python-intercept-web-traffic-from-browser
I like pyenv a lot. What do you like better about pyvenv?
That's useful.
You should check out [Miguel Grinberg](http://flaskbook.com/). His "Building Web APIs with Flask" video could be exactly what you are looking for. He has also recently attended PyCons giving some great talks about building REST APIs with Flask.
Bottle also, look at the SQLite Test Suite
I wrote a proxy in Tornado in like ~30 minutes. This is completely doable.
He kills it with Python man. He's killin it so hard.
Can you expand on the Mongo concerns? Is it not particularly safe as far as transactions go, or some such? 
I'm not sure why you'd want to do that but it may work as it can run arbitrary code on a schedule.
"from &lt;module&gt; import *" Where &lt;module&gt; is the name of the file.
Off/on topic: how was PDX Code Guild? I'm considering taking a run through one of the local code schools.
If you want smaller, peewee is another ORM you might check out.
I actually really like (post 2008) SSIS of all the ETL tools I've tried. What don't you like?
The for loop is O(n), I doubt there's anything faster than that.
Thanks! Just wanted a quick test drive!
They're both great options, so I don't think you can go wrong either way. I'd probably go with what you know better if it won't cause negative impacts on shipping the app.
Those ublications are really impressive! 
So, was it you all along ? https://www.reddit.com/r/A858DE45F56D9BC9
&gt; I wonder if the scripts should actually be invoked via a programmatic API instead. But that would kill the possibility for distributed programming that Airflow solves. Can you explain that? I'm not following how their framework rules out various methods of distributing the code. In my opinion the biggest difference between scripts &amp; programs is simply the mindset of the developer: is this piece of code considered a "quick &amp; dirty" small program with a dozen probable failure modes? If so, then it's just a script. Alternatively, is this program have a good organization of classes &amp; functions, a lot of exception handling, smart reuse, and defensive programming? If so, then it's a program.
/r/jobbit 
You can do a generator object and cleanly loop using the dict constructor over all the tuples. Also, empty strings are False in python, so you can make a tiny if statement in the generator. In code: new_d = dict((data for data in d.iteritems() if data[1])) Also, [stackoverflow is your friend](http://stackoverflow.com/questions/6307394/removing-dictonary-entries-with-no-values-python)
dict = {k:v for k,v in dict.iteritems() if v != ''} it's probably not more computationally efficient, but maybe more syntax efficient.
Nice! I like this. Elegant :)
Can your jobs be event-driven rather than run hourly or daily? Say a job that runs sometimes not at all for hours, at other times a few times a minute, driven perhaps by the existence of a file in an input directory?
Driving code out of a graphical environment is generally a poor way to handle any kind of complexity. Graphical-diagram-driven ETL is a vestige of 1980s CASE tools. One of the few areas still about. Alternatively, one can write ETL code using custom-code, perhaps following some tight conventions, and generate diagrams if necessary.
they're not all python specific
If you're using Python 3: sorted_dict = {k: v for k, v in server_dict.items() if v} `iteritems()` was replaced by `items()` in Python 3.
What area you want to offer your expertise in, is completely preferential but for those who study, work, and reddit python, I would suspect they have interest in python careers
it's misrepresenting to call it desperate, considering theres a jobbit thread with 7k readers. reddit job posts &gt; ambiguous search results 
Good thing to practice, but you could just use the [API](https://xkcd.com/json.html). 
If you want to read the value of the page it's going to be a request. You get 83 hits in an hour; do you really bed to check more than once a minute? 
Get the page body (aka the JSON), then use the json.loads function to parse the json string to python. 
Not an issue, it's a great practice exercise in a space that interests you. **That is always a great way to learn!** Are you wanting to do this manually, or use a lib? Via the fantastic requests library: # Get the JSON payload r = requests.get('http://xkcd.com/1/info.0.json') r.raise_for_status() # Just in case you get a non 2xx status comic = r.json() # Comic will be a dictionary, the json will be parsed for you. # Build the local path to the image, ./comics/&lt;image_num&gt;_&lt;comic_image&gt; file_name = './comics/{}_{}'.format(comic['num'], os.path.basename(comic['img'])) # Download the image if we don't already have it if not os.path.exists(file_name): comic_image = requests.get(comic['img'], stream=True) with open(file_name, 'wb') as f: for chunk in r.iter_content(chunk_size=1024): f.write(chunk) f.flush() # You may also want to save the title text, comic['alt'] somehow. Alternatively, you can just: import json # doc will be a dictionary. doc = json.loads('{"img": "http://whatever"}') The perk of the API is that it should be a consistent interface, so you shouldn't have a bunch of special cases to worry about :) 
I think his concern is centered around the use of a NoSQL database for what is typically structured, homogenous data. Mongo is an unstructured document database, which certainly has its uses, but is often used incorrectly and far too often, presumably because of the very flexible "anything goes" rules. While the setup needs more time and thought put in, relational databases outperform document databases massively, and provide far greater data integrity as well, and should generally always be a serious consideration. Aside from being much slower, document databases often become more inconsistent over time as the schemas get relaxed or changed, and accessing the data becomes more complicated and fragile.
I think you could do this with GreaseMonkey. It would be done in Javascript though, not python. It would probably be the easiest way to do it. [Here's](http://www.techradar.com/news/internet/the-beginner-s-guide-to-greasemonkey-scripting-598247/4) a script that will substitute one string for a different one. You could just change "Kardasian" to something else.
Is the jQuery script actually reading a file, or is it making a second call to the server? Why not create an api that returns the boolean value? No need to parse anything. Just ping your API at whatever frequency you desire.
If you go with mongoDB, you might want to check out Monary. It's a fast implementation of the DBAPI specifically to pull data from MongoDB straight into numpy arrays. It does not wholly replace pymongo, but it might be useful if you are trying to improve performance.
There's a chrome extension called Silencer that does this
If he succeeds he will never return to this page as it will be blocked due to the reference in this thread.
Function annotations were added in Python 3.0 (see [PEP-3107](https://www.python.org/dev/peps/pep-3107/)) so they've been around for more than six years and work with any version of Python 3.x. The feature was intentionally left vague — the annotations can be any arbitrary Python expression, they don't have to name types or have anything to do with type checking. They are completely optional and are ignored by the language, other than being evaluated when the function is defined (i.e. if you use an expression with side effects, they will be visible.) And that doesn't change in 3.5, where the language continues to ignore them — you can pass a float to your example function and it still works. The point has always been to let third party tools invent their own semantics for what annotations should mean. The only thing that's changed in 3.5 is that now the language has a suggested set of semantics to be used for type checking, but the annotations are still completely ignored by the language and you're still free to invent your own arbitrary semantics.
If we don't hear from OP again, mission accomplished.
This, is the only logical outcome, if op actually get the right answer. 
His twitter-clone tutorial for Flask newcomers is great as well. I walked through that a couple of times, before trying out Flask for the first time.
Abathur, is that you?
You could write it yourself in python, but you could just use an existing filtering proxy like [privoxy](http://www.privoxy.org/).
just stego the torrent/magnet into an image on imgur...
Automating aws with Python?
Thanks. I will check that today. 
If you use chrome, you can make extensions using javascript, html/css and the chrome api.
Bottle, it has one less dependency than Flask and works just as well for a simple REST API. 
Unless am on phone.
Just asking, but have you considered Tornado?
No, our team hasn't worked on Tornado and I don't personally think tornado support for rest api is that good when compared to flask.
Fuck yeah I've been meaning to find a way to block phrases like "SJW" and "don't real".
i am
~~Tornado is a web framework so it's more on a level with nginx or apache. While you could put request processing logic into it, that's not necessarily what it is intended for.~~
Finally a good use case
Sadly i think your only recourse would be to find a cave to live in that doesn't net access. You will never be able to filter 100% as guys will corrupt spellings just to frustrate you. 
Heads up this won't work with SSL encrypted pages because the proxy can't see the end result.
[dnspython](http://www.dnspython.org/). 
You can use [py2exe](http://www.py2exe.org) to generate the executable and, for example PyQt, wxPython, or Kivy for the UI, you can find some tipps for using different libraries with py2exe [here](http://www.py2exe.org/index.cgi/WorkingWithVariousPackagesAndModules)
You can also check out Morepath. http://morepath.readthedocs.org It is designed to do REST well instead of being secondary on top of a classic web framework.
The most obvious thing is that you no longer can write: print "hello" - but rather print("hello"). Other than that there are a few libraries on python2 that doesn't exist on python3 yet, such as Mechanize. However, there usually exist alternatives such as Robobrowser, so most likely you'll be OK as long as you don't advance too far in Python2 before switching over. Edit: what I mean about that last part is that the syntax is pretty much the same (so you don't have to start fresh when you switch over) , but you shouldn't get used to writing applications in Python2 as some mechanics are different and you would most likely have to port your applications to Python3.
&gt; I don't personally think tornado support for rest api is that good when compared to flask Can you elaborate? I'm asking because I've tried flask quite some time ago, and having taken a look at the current docs there's not much changed since that time. Also I did not notice anything specific to implementing REST APIs other than routing via decorators &amp; automatic parameter passing based on URL templates. Features also found in Tornado. One thing that I like about flask is that I find compelling about flask is the ability to specify parameter type in URL. In Tornado, the routes are just regexes, so you'd have to use [named] groups (IIRC it's the same in Django). As for the things that I like in Tornado more is reasonable support for async I/O, clear main loop handling and built-in WebSocket support.
Nice one. I recommend this talk by David Beazley on the intricacies of module loading, including .pth files: https://youtu.be/0oTh1CXRaQ0
Huh, you are right. Somehow I thought tornado is more an alternative to Twisted and an HTTP server is just one application of tornado. 
Pyramid
I've been using pyinstaller and PySide for desktop gui applications and that works really well.
Word of warning about topic modelling: it's a great technique, but requires a large amount of documents for it to work properly. (Plus topics are not always interpretable.) Maybe better is to build a reference corpus from different forums and then extract keywords that occur relatively frequently in the particular forum you are looking at. You could implement [this](http://ucrel.lancs.ac.uk/llwizard.html) relatively easily in python. Or search for other ways to do *keyword extraction*. Also see /r/compling or /r/languagetechnology. Maybe /u/FoolofGod can comment on the domain they are using gensim for and the results they are getting.
np. here's another good read through: http://www.bytefish.de/blog/local_binary_patterns/ this repo will have pretty much everything you want: https://github.com/bytefish/facerec
I like how you threw the word theoretical in there as a euphemism for saying "I don't know but this is what I think."
I've been using virtualenv all along. Should I move to venv?
Annotations are not quite *ignored*, they are recorded in the function object and available for introspection.
Python 2 and Python 3 share about 99% of the syntax and 95% of the standard library. They are not different languages (like French and English), more like different dialects (like British English and American English). 
In what way is that a sorted dict? It's just a regular dict. Oh, and to be pedantic, iteritems() wasn't replaced by items(), it was iteritem's lesser-known cousin, viewitems() (yes, really) that got renamed as items() in Python 3. Python 2 has *three* "items" methods: - dict.items returns a list - dict.iteritems returns an iterator - dict.viewitems returns a view and in Python 3 the first two are gone and viewitems is renamed plain ol' items. (Same applies to keys and values.)
Yes `python3 -m venv` is much more lightweight
I'm going to risk the downvote brigade, and say 'Why not just upgrade to python3? '
Just add the file to your web server. If you're using nginx it should be pretty easy. 
As always... dependencies. We're working on it, currently we have a 90% compatible codebase, soon we'll be moving to use `six` everywhere so we can test on 3, but I'm not so optimistic that all of our ~60 dependencies are compatible.
I'm mostly learning python 2.7 because there are more tutorials and sources on the internet
I like cxfreeze and use wx for the GUI library.
Having worked in large analytics team for 15+ years I'm also very familiar with these challenges. There's definitely a need for a single source of truth, a core team managing core datasets in the warehouse, and clarity/namespaces around areas that are certitified/SLA/data quality checks, .... There's also a need for people (data scientists, analysts, software engineers) to have sandboxes where they can analyze data and sometimes schedule jobs to say curate training datasets for machine learning, create aggregates for a dashboard, scout on newly instrumented tokens... A new trend I've seen emerged while working at Facebook was "analytics as a service" or "data science infrastructure" which often means that data pipelines get built dynamically. Think of an config-driven "aggregation framework", "anomaly detection framework", "cohort analysis framework" where data workers can plug in datasets (through a config file or a UI) set up a few parameters, and pipelines get generated for them dynamically. Airflow can power such frameworks, and the number of tasks generated dynamically can seem overwhelming at first, though they are really just different instances of the same pipeline. When I threw the number 10k out there, it doesn't mean 10k shitty shell scripts written by people who don't know what they are doing, I meant 10k useful nodes in graphs of dependencies. It includes data ingestion / staging jobs, sensors that wait for external partitions to land, many HQL scripts, data quality checks, triggers for reports (Tableau) to be refreshed, an entire experimentation framework where the unit of work is an experiment, things that feed back into powering the production website, a stats collection framework that build database statistics off of Hive where the unit of work is a partition. All of these task need to run on a schedule, in the right order, need to retry when they fail, send email alerts when they fail, ... It's a large complex orchestrated ballet that takes place and succeeds every day. This is what Airflow does. I don't now what kind of data environment you work in, but "big data" (as much as I hate using this term) is moving in the direction I'm describing, and tools like Airflow (as part of a much more complex stack) empowers big data teams to perform modern analytics. If you are interested an live in the Bay Area, come see my talk at the Hadoop Summit next Wednesday.
Upon reading this post I remembered that FFFFF.AT (a contemporary artists collective) actually thought of the same thing and did it by making a browser extension. I haven't tried it out myself but you could look into the source code. http://fffff.at/dash-out-kardashian-blocker/ https://github.com/gleuch/dash-out
By that logic, you should learn C, Javascript, and PHP.
Having started with 2.x and moving to 3 I agree with what the others are saying. It's very similar so even if you do find docs/tutorials on 2.x, it will usually work. Many of the packages used in the wild are also supporting python 3 at this point and there are alternatives for the ones that haven't made the switch yet.
You could also do print(*(x for x in range (10)))
Thanks for the help Kopachris. All references to "array" have been corrected! Thanks again. :)
An old version at that. 
The sad thing is if everyone committed to upgrading, I'm sure the dependencies would be upgraded in no time. 
Saying proxies don't worry with https is wrong. In-line text manipulation won't work, but you can proxy https traffic no problem.
It doesn't result in an an iterable when using del. That's exactly the special case.
*In general*, proxies aren't specifically built to speed up the browsing experience. Although such examples do indeed exist, like Opera Turbo and Squid, *in general* unnecessary proxies will slow you down.
No?
You're right, but del has a special case implemented here where it acts like using del on each member
I'm gonna build an OAuth library for dolphins.
Python 3's `decimal` *is* `cdecimal`. I can only guess the packaged version is slightly worse in some way.
I'd suggest using [mitmproxy](https://mitmproxy.org/) or [Burp Suite](http://portswigger.net/burp/). Both support proxying and modifying HTTP and HTTPS traffic.
https://youtu.be/cNU-eF-LlUo
Data pipelines = ETL 
Found some of the previous discussion on this: https://groups.google.com/forum/#!topic/cython-users/aNTUcsUHXoE
Hey! Thanks for your reply! &gt; How do you feel we are failing you? What can we do to improve it? What prompted this post was my earlier goal of migrating totally to Python 3 on both Centos 5 &amp; 6. I scoured the web for Python 3.3 or 3.4 RPMs for Centos 5 i386, but found none. IUS stops with python2.7 on Centos. So I built my own packages which is not the worst thing, but out of reach for some. That was what I meant by "tantalizingly close". I don't mean to indicate that IUS has "failed" me. I very much respect your project. The brainstorm I had was - what if there was a repo that supported a recent version of Python3 on Rhel 5-7 with both i386 &amp; x86_64 architectures. ALL the same versions of packages across ALL distro versions. Would that ease the transition? *(Of course I realize that it's getting increasingly hard to support Rhel 5 because of other compiler &amp; system package issues, so it won't be 100% possible...but it could be better.)*
but `a[x] = exp` doesn't call `__getitem__`, just like `a[x:y] = exp` doesn't.
You might be keen on a library like http://sqlalchemy-continuum.readthedocs.org/en/latest/version_objects.html Though a simpler way is to design it fit for purpose. Ie changing the updates into inserts (add) rows to the database and having an active flag per movie. And having functionality to moderate the changes and tick the edits as acceptable. See https://github.com/miguelgrinberg/flasky and take a look how it use moderate comments. 
&gt; https://youtu.be/cNU-eF-LlUo Ahahah good one :+1:
Very nice list although I think Pro Python should have been there too
Preach! 
More than that, you can ask for atomicity, write quorum, and even do compare-and-swap updates but none of them are *truly* safe because of pretty awful bugs. /u/brianbaq's links below go into a lot more detail. Suffice it so say, the hype in the marketing material doesn't hold up in practice. If your use case is storing lots of relatively small, well-structured, non-critical documents, and you have only loose consistency requirements, MongoDB can sling a shitload of data pretty well. As soon you have strict consistency requirements, MongoDB isn't appropriate.
I can't speak to Ubuntu, but my experience downloading and installing Python from the source tarball has been that it works and installs pip perfectly. The one exception is on an ancient Solaris 10 machine we have at work- it doesn't have _ssl so pip doesn't get built or installed.
If your values are reasonable, you can probably get away with some basic memoization. Or just make it all a generator. Do you need a specific N-th number or the entire sequence? 
That's fair, perhaps I should have been more precise: ensurepip is broken when Python is installed via the Ubuntu package manager.
I appreciate everything that might save me from writing JS.
The best explanation I've seen for that is this one [here](http://stackoverflow.com/a/2921893). The star unpacks the iterator which makes print behave like you gave it all the elements as seperate argunents.
Some people just expected it to, because that's how the code reads. That is all.
Thanks for the kind words. Currently IUS is maintained by two people (including myself), so we try to focus our limited resources where there is demand. That means we are selective with what we package. We don't typically create new packages until they are requested. We used to ship Python 3.1 for EL5, but we stopped when 3.1 went EOL. As best I can remember, none of the newer versions of Python were ever requested for EL5. You hit the nail on the head by stating that EL5 support is getting difficult in regards to packaging current software. Most of our work lies with making the compilation and test suite cooperate with older libraries; this task continues to get more and more difficult with EL5. EL5 is now in "Production Phase 3", commonly known as "maintenance only" mode. Red Hat isn't even backporting all CVEs anymore, just the ones they deem severe enough. We followed suit and declared our EL5 packages "[maintenance only](https://lists.launchpad.net/ius-community/msg01207.html)" mode as well. Basically that means we won't create any new packages for EL5, just maintain the existing ones until they reach their upstream EOL date or EL5 itself goes EOL. We are very much interested in helping the overall Python 3 transition, but we are going to continue to focus our efforts on EL6 and up. We currently package 3.2, 3.3, and 3.4 for EL6, and 3.4 for EL7. That said, we would be happy to accept pull requests for our existing spec files to help them build properly on EL5. Instead of building Python 3 rpms from scratch, you may be able to save some time by starting with our existing [spec file](https://github.com/iuscommunity-pkg/python34u) and trying to build it on EL5. Troubleshoot what fails, then let us know via pull requests. If you do decide to push forward with creating a new third party repository, good luck!
Subclass it and overwrite the readGIF method, mostly copy and pasting from the original code but skip the file opening part.
If you don't use --prompt, then yes.
There are two tricks going on here. The first is exponentiating the matrix with the [repeated squaring algorithm](https://en.wikipedia.org/wiki/Exponentiation_by_squaring), which is where the binary iteration comes from. A more direct translation might look like this: from numpy import matrix def fib(n): base = matrix('1 1; 1 0') power = base.copy() for rec in bin(n)[3:]: # perform fast exponentiation of the matrix (quickly raise it to the nth power) power *= power if rec=='1': power *= base return power[0,1] The second trick is to use some simpler arithmetic instead of a matrix class (which is kind of overkill). The original Fibonacci matrix is symmetric, and its powers will be too, so you can represent them with 3 numbers. Then we just figure out how to represent the squaring and *base operations: [v1 v2][v1 v2] = [v1^2+v2^2 v2v1+v2v3] [v2 v3][v2 v3] [v2v1+v2v3 v2^2+v3^2] [v1 v2][1 1] = [v1+v2 v1] [v2 v3][1 0] [v1 v2] BTW, the closed form solution didn't work out because you're asking Python to do floating point math. Python automatically does integer calculations up to arbitrary size, but it won't (and can't) do real-number calculations to arbitrary precision.
This isnt my project, I stumbled upon it and thought it was cool enough to share. Code is on github: https://github.com/rlfriedm/VR-Programming
&gt; I'll be using PyQt4 with python 2.7.10 but there are no major differences between PyQt and PySide or python 3 versions of those, so if you already have PyQt5 or PySide installed there is no need to downgrade/switch.
Then you should definitely make a generator. I'm on my phone right now, so here: http://www.python-course.eu/generators.php
This is awesome. Thank you for this. Please keep us updated. 
I don't know why [Eve](http://python-eve.org/) hasn't been mentioned yet?
spruced your code up a bit. but /u/ingolemo/ answered well already: you weren't returning the value. You need to return them together (they are an implicit tuple). once you return, it's out of there. why would it ever go to the next line? anyway, code spruce: https://gist.github.com/anonymous/d5aef92bd54cffbdf389
Alright, I changed the format for each of my returns to be something like: if CompHand == none_alike: return 0, Comphand but now I get an issue of when I'm trying to call back to it later as that I can't submit it as a tuple. I try to assign CompValue to something like computer_hand[0] and CompRoll to comp_hand[1]. I'm just getting errors. 
You can't enter data into a column that doesn't exist. When you created your db, you specified that it should have two columns: CREATE TABLE temps (timestamp DATETIME, temp NUMERIC); If you really wanted to add the data from sensor 2 to its own column, you'd first have to recreate a table with another column or alter the existing table (see http://stackoverflow.com/questions/4253804/insert-new-column-into-table-in-sqlite) 
You need to unpack the values again on the outside side of the function call like I show on line 5 of my first code block. If you don't understand this technique then you should be able to search for the phrase "python tuple unpacking" and get lots of examples and explanations. If you're still having trouble, make sure you mention the code you tried and the error that you got.
Awesome materials. Thanks.
Thanks, mate.
&gt; With Django, assuming you even bother, you'll end up peeling things out that you don't need, that is an excellent point...+1
Some things that might be helpful: * [Server-sent events](https://developer.mozilla.org/en-US/docs/Server-sent_events) * If you want to use Flask (or something like it) instead of just writing to files, you could do [streaming responses](http://flask.pocoo.org/docs/0.10/patterns/streaming/). Basically, have an infinite generator feeding into a HTTP response that never closes. * [Websockets](https://developer.mozilla.org/en-US/docs/WebSockets)
Python Essential Reference by David Beazley Fluent Python by Luciano Ramalho (O'Reilly early release, apparently it's not finished yet) Python Cookbook by David Beazley &amp; Brian K. Jones
Very cool. I used to play math games when I was younger, so why not have programming games like this?
Seems like a newbie question, a piece of advice then. Take a look at absolute imports `from __future__ import absolute_import`. This will come in handy later on.
Very nice tutorial! Sort of perfect timing as I wanted to get back into PyQt using the designer and this is exactly the tutorial I was looking for, going to give it a run through tonight :)
[Image](http://imgs.xkcd.com/comics/python.png) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 150 times, representing 0.2248% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cryb3gl)
I'd probably suggest making it not verbose by default (i.e printing nothing to stdout or stderr and just giving a return code) so people can use it in pipelines to test output? Completely up to you though, unix philosophy isn't for everyone.
Books are a great way to learn.That said I think one of the best written resources is the official Python documentation, which you can read like a book. Every programmer who is serious about learning Python should start with the [Python tutorial](https://docs.python.org/3/tutorial/index.html) IMO.
I see what you mean now. I figured this out a little bit ago, and was able to toy with it and got it to work as intended. I really appreciate the help!
sorry, I should have mentioned I have altered my table to have a third column
Why does yahoo have it's own OAuth? The whole point is so there's only one way
@graingert, every single OAuth API providers implement OAuth (wether it is OAuth1 or OAuth2). It happens that sometimes they may add something more ( in the headers, ...). And if you ever tried to work with Twitter API, Google API or Facebook requiring OAuth, you will notice that it differ a lil bit even though it's still OAuth. Since i'm not the ***only to implement OAuth for Yahoo API***, i just made the implementation to help the others. Knowing that in our beautiful **Python** language, we like ***defining one way*** to do things. That's why the project is on Github. Thus if someone finds lacks to this library, he will fill them. I remember having a hard time finding how to implement OAuth for Yahoo with Python. No module was available on the *Python Package Index* anyway. I managed to implement OAuth for Yahoo, and it works. Since it works i just made it available to the community so people won't have a hard time trying to implement it. 
You need to provide more context about the program. What's the point of SSL cert in this context?
The font used for the code examples is tiny.
What would be really cool is if you wrote a program that crawled the web and classified if each page was about machine learning or not.
Oh ok sorry, i misunderstood you. Yeah it seems like there are people who needed that. Hope they will report some issues though. 
Better post this in /r/learnpython and read the sidebar and wiki.
Part of my python script needs to download a file from a secure (HTTPS) server, this needs to pass an SSL check. The problem is that after i create an exe from the script it stops working, i was told that disabling ssl isn't a good idea, and since i'm in an enterprise environment i would like to keep it. So now i need to create a certificate for the site i'm trying to access, but have no idea how to do that, and haven't found anything online that helps.
You can add a self-signed certificate for your proxy, and make your proxy MITM every request, signing certificates on the fly. NOT recommended for proxies other people control.
To an extent it is. I want to have the ability of folks to offer edits and then approve/reject them or auto-approve depending on the person
http://statweb.stanford.edu/~tibs/ElemStatLearn/
If it's not, the ToS will get an update shortly
Use four spaces before each line of code to make it display in code format. There is no "code" block like in some forums. As for your error, "SyntaxError" means you wrote something that the language can't handle. In this case, the problem is that you are missing a comma in the line with the error. So replace: print (x "is not a prime number") With: print(x, "is not a prime number") I also removed the space between "print" and "(". Having a space there is allowed, but is considered bad for readability. 
Very nice. Qt Designer is really neglected in most PyQt tutorials.
 def is_prime(x): x = int(input("enter a number to be tested: ")) if int(x) &gt; 1: for n in range(2, x): if x % n == 0: return False print(int(x),"is not a prime number") print(x, 'divided by', n ,'is' (x % n)) else: return True print "x is a prime number" else: return False print (x, "is not a prime number") I think that should look better, and thank you for the help can't believe I overlooked that commas and the indents won't save when edit'd
I have been waiting to see something like this for a while! My thoughts for programming while wearing a VR headset have been a lot like this, but with more code buffers. I like the idea of "physically" grouping buffers together and creating places to work on specific projects. I see this being more useful with an AR system like Microsoft's since it would make collaboration easier, teams could pull up lots of windows and place them all over a meeting room, for example. Teaching material is great and all, but I'm really wanting an environment for me to do my work in.
Looking at it now, there are a few other issues with the code. First, you convert x to int several times. You only need to do that once. Second, once the function reaches a return statement, it stops. Nothing after that point is executed (including all of your prints). Third, it is easier to short-circuit your "1" test. Fourth, your code will return True in the first item of the loop. It has to wait for the loop to finish. Also, this is a relatively slow algorithm, although that is another issue.
Ignore this, saving for after the exams... 
will do.Thanks for suggestion
Head on over to /r/MachineLearning
put returns in wrong priority, and converted to int twice okay thanks one more question: what exactly is wrong with this command: print(x, 'divided by', n ,'is' (x/n))
&gt; This gives you the power to use actual classes with actual types in your code instead of confusing tuples or confusingly behaving namedtuples. I don't know what exactly is confusing about namedtuple, but I don't see how this library has "actual types". If you need more strictly defined data structures, something like [Schematics](http://schematics.readthedocs.org/en/latest/) would probably fit the requirement better.
Have a look at [LxmlLinkExtractor](http://doc.scrapy.org/en/latest/topics/link-extractors.html#module-scrapy.contrib.linkextractors.lxmlhtml). import scrapy from scrapy.contrib.spiders import CrawlSpider, Rule from scrapy.contrib.linkextractors.lxmlhtml import LxmlLinkExtractor # Import all the other shebang you need class YourSpider(CrawlSpider): name = "name_of_your_spider" allowed_domains = ["domain.com"] start_urls = ["http://www.domain.com/"] # Determines which pages the spider should crawl rules = ( Rule( LxmlLinkExtractor( allow_domains=allowed_domains), callback='parse_item'), ) # Method to process each page def parse_item(self, response): """Do amazing stuff""" 
Wow, I was not aware of this one, but it looks very cool! It certainly has a lot of useful functionality, and honestly, many features that are not even planned for `climactic`. In my physical toolbox, I have a power drill and a small unpowered screwdriver, and they both have their purpose. Whatever tool works for the job at hand!
Which API is that? The newer gmail API is HTTP and the google-api-client-library should work in py3. 
You're defining is_prime with an input variable 'x', but you're overwriting that with x = int(input("enter a number to be tested: ")) immedately, making is_prime(x) irrelevant. As for efficiency, range also has a step argument. so: &gt;&gt;&gt; range(1,10,2) [1, 3, 5, 7, 9] You can use this to your advantage and at this point halve your computation. You know for a fact that 1 is never prime, so skip it completely, and you know for a fact that every even number greater than two is never prime. You can also reduce your computation by using [this rule](http://stackoverflow.com/a/5811176) Also everything /u/TheBlackCat13 said. 
You're still missing a comma :)
Creator here, I apologize for the quick movements in the video. I should have recorded slower head movements for the video!
I will try to get something out from that forum...meanwhile i read wiki on learnpython.its very informative thanks for suggesting me
It's a fun proof of concept. 
&gt; Even so, the second case is as much a special case as the `del` case is, and both are situations where you wouldn't just read it and intuitively know exactly what it's going to do. Propose your own, more intuitive implementation. As I see it, you have very limited options. You can go the Java way and just don't have `[]` operator on collections, at all. That would suck, though. You can go half-C++ way and allow a readonly `[]` operator. So that `x = a[0]` is valid, but `a[0] = x` is not. Do you think that's intuitive? You can allow assignment but not slices. So `x = a[0]`, `a[0] = x`, `del a[0]` are all valid, but you don't have a slice syntax. Would that be intuitive? Are you sure that someone with even less experience with the language than you wouldn't be entirely puzzled by `a[0] = x`, since they know that `a[0]` returns say 42, and `42 = x` doesn't make sense? Would you be OK if we had the above but without `del` at all? I, for one, would be OK with that, by the way, I think that `del` is unnecessary, rarely used, and therefore every use seems like unfamiliar magic. And it is mightily confusing for the people coming from other languages, because they assume that it deletes an object itself somehow, not removes the object from whatever collection. Not to mention its original use, `x = 10; del x` "deletes" the local variable named x, and I guarantee you that even moderately experienced Python programmers would reel a bit at that, "deleting a local variable" is an inherently weird thing that is about never needed. Would you allow `a[0:1] = range(30)` however? Is that counterintuitive? Wouldn't allowing slices on the right side but not on the left side surprise someone who'd expect them to work everywhere? &gt; I get it, but it still feels like a special case to people if you ignore implementation for a moment and just think of it in language terms. It's not an "implementation", it's how it is actually designed. You're using a wrong word, is what I am saying. Like, there's a design that actually was pretty constricted in what it could end up being, the things must work in such and such ways, if you allow `a[0] = 42` and `print a[0:1]` then you should allow `a[0:1] = [42]`. But there could be a disconnect between the mental model of a person who saw a few examples of the underlying rules in action and the rules themselves. That's unfortunate, but, you see, a lot of times the problem is that the mental model of that person doesn't make any sense actually. It's like something you figured out in a dream: makes total sense only because you never actually thought about it. I'm really not sure what we can do about that, we can't make the rules that follow the dream logic.
If you value Twisted and value Python 3, please consider contributing to Twisted's python 3 support! That's the only way it will happen; if people who care about both chip in.
Understood. I wish I could contribute.
Running `caniusepython3` made me sad, here's the list of dependencies I'm waiting for to migrate to python3: dill flask-admin flask-login hive-thrift-py librabbitmq mysql-python pyhive sasl (which is blocking pyhs2) thrift (which is blocking pyhs2) pysmbclient protobuf (which is blocking snakebite) sphinx-argparse sphinx-pypi-upload
I'd go with Python/flask. You can get it done in no time with that combo. 
 x = int(input("enter a number to be tested: ")) if (x) &gt; 1: for n in range(1, int(x**0.5), 2): if x % n == 0: print(int(x),'is not a prime number') print(x, 'divided by', n, 'is', (x / n)) else: print(x, 'is a prime number') else: print(x, "is not a prime number") decided to scrap the function I don't need to hear a true or false answer to the in(input) being prime or not, think I'm just about finished
Wordpress is fine. I know that static site generators and new blogging platforms such as Ghost are very trendy right now, but the contents of your site is much more important than what platform it runs on. I assume what they would really want to see is good Python-focused posts on there. Full disclosure: my blog runs on Wordpress.
Thanks! Yeah I really think there is a lot of potential in using VR as a tool for teaching abstract concepts (like many you would learn starting out in computer science). I am currently without an oculus for a bit, but when I get another I'm planning to keep working on this to make it a more complete and polished learning experience.
thanks. It looks like Cyclone is dependent on Twisted and seeks to provide functionality to twisted based on Tornado. Tornado itself appears to be a serious competitor to Twisted and has had support for Python3 for a long time.
Ugh, parsing html for this? I'd do it in vim way faster, then just load a csv into python. Edit, sorry, paste as a list into my script, not csv.
You are most welcome.
I certainly wish the team all the best, but this is not my choice to make...just something I have to deal with in the best way I can.
Wordpress is absolutely fine. I used to self host wordpress for a while to make it seem like I was doing at least some of the work, but it's still a pain. I like development, but when I'm writing, I don't want to have to deal with a CMS just to feel cool.
More I,pedant than Wordpress is the content and the template. You can have a wordpress blog that is the default template, or you can spend some time choosing a good theme and making the site reflect your personality. 
You're being downvoted because you should have posted in /r/learnpython. You should probably delete this thread so as not to encourage others to ask questions like this in /r/python.
2 fails that code, it'll return as not prime. Negative numbers will break it. You can start your range with 3, instead of one, and you can make an if statement Testing for two and testing for anything equal to or less than one. 
Thanks so much!
Sweet! Nice layout.
Programming collective intelligence by Toby segaran. Machine learning book code is all python. Strongly recommended.
Cisco is very different depending on what group you're interviewing with. I've worked in two different groups and interviewed with several others and they've all been different to the point of feeling like a different company. Some Cisco groups still believe that Cisco workers are top 10%, and it shows in the interview. They can really grill you an come off as kind of arrogant. I've also had interviews that were completely based on fit with only basic technical questions. I've had interviews that split the difference. Don't sweat it. Cisco is nothing special. Just answer questions to the best of your ability. Ask questions that show you're thinking and try to turn it into a discussion. Just don't BS. 
That's almost definitely going to require a client-side JavaScript solution
&gt; Obviously, huge sites like the obvious suspects employ highly paid teams of brainiacs to program their sites, so that makes me think that my idea is ludicrous. And yet, when I come back to the idea that Reddit is basically a sort of well done Wiki, in a way... I have to wonder if the average Joe Python could bang something out in a year or so that would at least get a little off the ground. You're way overestimating how long it takes to do something like this. I built a site with a lot of custom modules (...poor planning...) in a couple weeks, as a complete noob to web frameworks. Django is designed for stuff like Reddit, CMS sites, etc. You could do it very, very quickly.
I checked out the Reddit repo on Github. It has about 60k source lines of code in it. That would take a while to write, for sure. However, Reddit has a lot of non-core functionality. There are wikis, ways of editing flair, special moderator functionality, etc. How much of that do you need to get started? Not that much. It would take a reasonably experienced Django programmer a few days to knock up a basic version where users can register accounts, create subreddits, submit posts to different subreddits, comment and vote, edit and delete comments and send private messages, subscribe to different subreddits and get a newsfeed that shows posts from them.
Thank-you! I'll have a read :)
I think tornado is a good alternative, in case if you only need http.
&gt; instances are immutable by definition you mean tuple instances ?
At least one of these is a false positive -- dill claims it runs on Python 3, but doesn't include the right classifiers on pypi: https://pypi.python.org/pypi/dill
I just started playing with the new stdlib asyncio module. It's pretty sweet. I don't know if it's complete enough for you though -- I had to use a third party library just to do simple http requests with it.
yes and also subclasses of tuple which define the `__slots__` attribute (which is what namedtuple does)
Gotta ask... Why no spaces after dots? 
I don't believe it makes a difference what it runs on, just the content and what it looks like. That said... WordPress has security issues all the time with exploits to the comment and plugin systems to turn them into spam cannons and litecoin miners.... So... There's that to keep in mind... Was the reason I dropped WordPress and wrote my own and hated it and then replaced it with static site generator and haven't looked back.
Isn't this what the HTTP 1XX codes are for?
[I'm a socket guy myself.](https://docs.python.org/3.4/howto/sockets.html)
Hi there. You have posted a beginners question to /r/python, however it is far more suited to /r/learnpython, where users are actively interested in helping with beginner topics. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Cheers &amp;amp; best of luck!
As a systems guy, I'm glad I never bothered to try to shift to Python 3.
Like! I agree with you on trouble getting other frameworks to work. Got yours to work on the first try. Like it a lot. Will start playing around with it.
&gt; The hard part is scaling when you have a bazillion users. The hardest part would be **to have** bazillion (active/regular) users. The easy part start with the [install guide](https://github.com/reddit/reddit/wiki/Install-guide) from reddit themselves. 
Thanks! I started reading fluent python .... what an amazing book. I suck at python apparently ... ;-) 
Seriously? A cache whose default implementation is a non threadsafe dict with unlimited numbers of keys? It is begging for a segfault, corruption, and drastic loss of performance over time. And all this javalike boiler plates? What's wrong with all the people plussing these kind of project and not even reading the source code? Please, if you are seriously considering being pythonista, don't revinvent the wheel: https://dogpilecache.readthedocs.org/en/latest/ EDIT+ : fuck : a simple memoizer does the same kind of job for 10 times less SLOCC and it is so simple that you can understand it is wrong. Even the stdlib is better. https://docs.python.org/3.3/library/functools.html#functools.lru_cache 
Well yeah but they don't want to just install reddit, they want to build a reddit-like to hone their programming skills.
I was going to mention Falcon for the same reasons. I haven't used it yet, but it does seem like the best tool for a REST only service. If you were returning HTTP too, Flask or Pyramid would probably be better options. I haven't used Flask, but I have used Pyramid, and I believe they are quite similar. You could definitely make a REST service with either, although the 'structure' of Falcon and the way it uses classes for views is better for REST IMO. From my research, Falcon will outperform either at handling REST requests.
Use a static site generator like [Pelican](http://docs.getpelican.com/en/3.5.0/) and host on Github. It is simple to set up (not trivial, but not too difficult either) and once you are done, writing a new article is simply puting a new txt file in a folder. It is also fully CSS-customizable, and you can generally add widgets in an eyeblick by just switching these on (twitter, g+ buttons, Disqus comments) The reason I gave up with wordpress is that they had ads on their hosting platform, they didn't have nice themes for free, and no way to make the code blocks look really nice. I never looked back (shameless plug: [my blog](http://zulko.github.io/))
"Wordpress is the worst form of blog engine, except for all the others" - Churchill. Seriously, it's a pain to use, but you no other blog engine offer this set of features, community, documentation, plugins and themes. 
Thanks. It turned out that I must have originally installed virtualenv at the user level and this was setup in the separate python folder you saw. (I assume this is the default behaviour for pip to install downloads within a python interpreter folder). S to fix it I just used pip to uninstall virtualenv and then reinstalled it normally with pip and this fixed everything. Thanks for your suggestion as this helped me realise the fix 
What's funny is the developer seems to think it's an improvement on the lru_cache! I bailed after I saw all of the unnecessary method declarations inside of each class that overwrite Python methods and do nothing.
I've alway really liked [TiMBL](http://ilk.uvt.nl/timbl/) and it's [reference guide](http://ilk.uvt.nl/downloads/pub/papers/Timbl_6.3_Manual.pdf) which is both an API documentation and an introduction to the most common ML algorithms. There's also a [python wrapper](http://nlp.pwr.wroc.pl/redmine/projects/wmbt/wiki).
Or run the it as a job in something like celery, and set up a websocket for pushing status updates every x seconds.
In the *Some companies using Flask* section, it mentions Pinterest, Twilio and Reddit. I'm sure Pinterest uses Django, Reddit uses Pyramid (or one of its version like Pylons), and Twilio I'm not sure about, but I always thought it was Rails (I maybe wrong). Are there any references?
The versions in the official distro repository should work fine together.
well actually, the problem i'm having is i'm using mod_wsgi from standard os repos, but the python in my virtualenv is not the same as on system, it's compiled by me. Just looking for some confirmation if mod_wsgi needs to be compiled against a specific version of python.
I would prefer these as tooltips or overlays in an IDE rather thanactual source code transformation. My concern is that it's not sustainable to have this long term, and you need to promote transfer to an authentic context (English centric, I know and apologize, but such is life). If it was at the IDE level, you could fade this scaffold away as users learn the terminology. But then, if the translation is indeed fast, bidirectional, and automated, then it would be simple to wrap this into a user interface. Kind of like Blockly.
Does it have to run under mod_wsgi? Can't you just run gunicorn from your virtualenv, then proxy it to nginx (or apache if you really must)
It's like watching a road kill: it's revolting, but you can't look away. I had kind of the same feeling with [dogelang](http://pyos.github.io/dg/).
This is an awesome idea for people to get started with python. Anyone mashing languages more accessible to NESB people is worthy of respect. There is no reason for locking others out of starting, however, as they go there needs to be some encouragement to learn the lingua franca for at least the keywords. I've dealt with all sorts of codebases with varying language backgrounds, and while it is hard to learn what's going on when all the variables and comments are on Cyrillic text, that's the lingua franca of the project, so why should I get some sort of imbued advantage by having happened to come from a country with English as the first language?
What's the difference between this newsletter and pycoders weekly? In the last issue of bite python are the same links i think. 
UTF-8 is the default for Python 3 source. Code will work fine without the encoding line, but I understand why you might want to add it. It's not uncommon to see non-ascii characters in source code.
The page makes it quite clear it's not meant to be a coding solution for actual practice, but for teaching programming without having to teach the English language first. In that regard it is admirable.
Why is it terrible ? For educational purposes, it could be really useful. You can teach programming before children have learned English. In a lot of computer science class, you write pseudo-code in your native language. Maybe you don't realize that you understand all the keywords because they are in your native language (or you knew English before the language) and you can understand the flow of a program by using the same logic words in your head than on your screen. 
It's not the same language if you change the keywords. Education should prepare people for the real world.... if you want to teach how to think like a programmer then use a visual programming language (unless you would then need to localise the flow chart icons!)
I have used wordpress in the past and hated it. Its bloated for what it does. For my own blog I use pelican (static site generator http://blog.getpelican.com/ ). When ever I need a more featured CMS/Blog site I use mezzanine (http://mezzanine.jupo.org/) both of these I highly recommend. 
I tend to disagree with the "real world preparation" arguments cause they may imply that nothing more than additions and multiplications should be taught in mathematics course (cause 95% of people don't need more). But for the real world, you're right anyway : you have to learn English :) I was talking for young children. I can imagine that a "verbose" (not sure that it's the correct word in this case) language where you can read sentences can also be useful for learning. I admit that I'm a fan of deriving programming language from the mathematical world and you do learn mathematics in your native language. 
Yes, Django is a high level web framework written in Python. You can host a Django application on any server using either mod_wsgi or uwsgi.
Thanks!
I am undecided on whether you should localise error messages. For the user it helps a lot if the error is in a language he can read. But when you get back an error message in something you don't read, it's not that helpful. I figured the way to fix it is bilingual errors or error codes. Display it in english and have the translator put in an extra one in local. I've never seen anyone else do this satisfactorily though.
/r/learnpython
I find myself having to make Python 2 files be utf-8 quite a lot, as when I'm working on my UK Mac, the #, which has to be added using ALT-3 (a little frustrating for a programmer), it isn't added as ASCII #, but some other utf-8 equivalent.
You could use a method like the one shown here: http://datamelon.io/blog/2015/secure-symmetric-encryption-in-python.html The example is very simple and has everything you need to implement it. &gt;&gt;&gt; from cryptography.fernet import Fernet &gt;&gt;&gt; key = Fernet.generate_key() &gt;&gt;&gt; key 'BP04_l7C3wByNiEaEiseNiP0ZrqZ7s3qL-mkG8eHlJY=' # from cryptography.fernet import Fernet import os crypto = Fernet(os.environ.get('SECRET_FERNET_KEY')) def encrypt(plain_text): if isinstance(plain_text, basestring): string_text = str(plain_text) return crypto.encrypt(bytes(string_text)) else: raise Exception('Only strings are allowed.') def decrypt(cipher_text): return crypto.decrypt(cipher_text) # encrypted_spoiler = encrypt('Snape kills Dumbledore.') print encrypted_spoiler # gAAAAABVLTmsBrJWKMzjn4pDlRwtk1j3TFcF1lrRlXo8_ASbR42vEiAcagNK # R3cqp6ypSdPPyMozGi2T10pxqKISxwVYqMqoEIaScr310glx55vUk_l6eLc= plaintext_spoiler = decrypt(encrypted_spoiler) print plaintext_spoiler # Snape kills Dumbledore.
I would consider grabbing the whl file from Christoph Gohlke's website: http://www.lfd.uci.edu/~gohlke/pythonlibs/ pip can directly install whl files: pip install &lt;whl_file&gt; or check out the free conda/anaconda if you need more of the scientific stack and a nice way of isolating different environments: https://store.continuum.io/cshop/anaconda/ http://conda.pydata.org/miniconda.html
Have you tried the Django Girls one? It assumes zero knowledge, so it explains some things a bit more than the official one. http://tutorial.djangogirls.org/en/index.html I am also learning Django right now--this sub has been fairly helpful (it's where I found the Django Girls link): https://www.reddit.com/r/djangolearning
Yeah but then you create just another secret you have to deal with.
When you find your local env folder, you have to take it one step further. Find the python executable in the /bin of that env. You will have a python2.7 or python3.4 or similar in the /bin. Click on that and it will register the entire env with all the packages. 
Are there any examples and how hard is it to use?
You could try [Anaconda](https://store.continuum.io/cshop/anaconda/) which comes with lots of packages like numpy pre-compiled. It's what I recommend for Windows users because setting up developer tools on Windows is a pain. Edit: Heh, just noticed joshadel said the same thing - consider this an endorsement of his suggestion. :)
I think it's more likely because windows doesn't use UTF8 as encoding itself.
&gt; For educational purposes, it could be really useful. You can teach programming before children have learned English. In a lot of computer science class, you write pseudo-code in your native language. But we're already teaching maths, physics, and chemistry before children have learned English (or Latin). And all of those subjects use the same symbols to represent variables and constants no matter the language. `v` is *velocity*, `F` is *force*, and `t` is *time* in English, German [1], Dutch, Russian, or Chinese - and yet all those languages have their own words for these variables. The latter two languages don't even use the Latin alphabet. Likewise, Greek symbols are widely used in maths. Similarly, symbols for chemical elements are also uniform across different languages. This doesn't stop their understanding, because the explanation of concepts is still carried out in their native language. Localizing everything would only slow them down and create confusion rather than introduce clarity. If children can handle `F`, `log`, `β`, and `H2O`, they will handle `if`, `else`, and `while`. Also, some languages don't have the concept of semicolons or brackets. Should we translate those as well? [1] - they also use `K` for force, but they do so rarely and more commonly in older texts.
Is it possible to securely store anything in a computer? Well, you can encrypt it with another password or a public key.
I feel like just using Google Translate won't produce the correct meaning for "for" in many languages - not every language has one word to cover "for (the sake of)" and "for (each element)". Similarly for the other keywords. It might even make things *more* confusing, since now instead of *not* understanding, they understand the *wrong* thing! Cool idea and implementation, though!
 I think a lot of the problem people have when starting with frameworks is trying to understand the reasons these frameworks choose to do things the way they do. The answer is you won't know unless you try to do those things on your own. If you tried to implement your own framework all of the bits and bobs of Django would rapidly make sense. In essence, its one group's conceptual model of how to organize a web application. With all of that said I can't think of anything better than the tried and true "Writing your own Django app tutorial"(https://docs.djangoproject.com/en/1.8/intro/tutorial01/). It takes you from nothing to a working web application. With a full discussion on how the Django team thinks you should approach any web dev problem. But it suffers from chicken and egg syndrome. Only by doing the entire thing and building a mental model of each component will you truly understand how they all work together. More importantly you will have imprinted on you a recipe for how Django thinks you should solve problems. If you find yourself saying things like "I don't understand how to make django do the thing I want." then you are barking up the wrong tree. You have to be prepared to abandon your idioms and adopt those of the Django project. The real question "With the blocks Django has given me how do I build what I want?"
I do quite a bit of python dev on my windows machine and have run in to this issue before. My solution is that I have MINGW [](http://www.mingw.org/)installed. It has bunch of fun UNIX tools included, one of which is gcc the gnu C compiler. The problem you have, I believe is that python cannot find the compiler you wish to use to build all the C binaries. I fought a bit with the solution where I deal with the compiler included with VS 2008 and that turn out to be smarter than me. So once you install and understand MINGW (which is super simple) you configure distutils to point to MINGW. This check list that I stole explains it pretty well: 1.I have Python already installed 2. I installed mingw32 to C:\programs\mingw\ 3.Add mingw32's bin directory to your environment variable: append c:\programs\MinGW\bin; to the PATH 4.(create if not existing) distutils.cfg file located at C:\PythonXX\Lib\distutils\distutils.cfg to be: [build] compiler=mingw32 Your mileage my vary.
I always prefer the Pro books, but I'd recommend torrenting the books, scan through them, see what you like and then buying that. Another option would be to create a list of tasks you would want to solve with python, then check each book's table of contents to see if they cover everything you have listed.
Use anaconda! https://store.continuum.io/cshop/anaconda/
This is only really an issue if you want to include fabric in your projects (as in: `from fabric import ...`). As long as you use fabric as command-line tool, it does not matter which Python version it supports.
[Examples](http://nucleic.github.io/enaml/docs/examples/index.html), two clicks away from the linked page.
Enaml is great and something I am strongly considering using in some of my projects. However, I am a bit concerned that development on it seems to have stagnated as the last commits were almost a year old. I do recall that the dev was working on it at full steam for several years. Unfortunately, it doesn't look like anyone else has joined in to pitch in with developing it further like with other projects such as pandas. IIRC, the primary developer used to work at Enthought where Enaml originally started, but he left Enthought later on and forked it and has done a lot more work on it since. Would be great to know if anyone else has any knowledge regarding the status of Enaml and whether it is still being maintained/developed.
Yes, python 3 is supported with rcontrol. I will add this information in the README file, this is good to know. :)
Nope, I'm pretty sure mod_wsgi will work with virtualenv once configured properly.
do you want self-aware applications? because this is how you get self-aware applications.
Yeah, Python development in Windows is a major pain in the ass. Some things (including installation of NumPy via pip) that Just Work in *nix or OS X will either fail miserably or require annoying workarounds for Windows. If you can, try to get an [Ubuntu](http://www.ubuntu.com/download) VM set up on [VirtualBox](https://www.virtualbox.org/wiki/Downloads).
I guess I am following more or less this http://nikolak.com/pyqt-qt-designer-getting-started/
LOTS of warnings when installing on Mac. conversion from string literal to 'char *' is deprecated 
David Beazley mentioned to me on Twitter that he's working on a fifth edition, targeted for next year: https://twitter.com/dabeaz/status/607245687793844224 Not sure if it will upgrade to Python 3.x, but given that he made Python Cookbook use Python 3, I suspect he might do it. The differences between Python 2 and 3 are not huge -- one can learn them in a day or two. A very comprehensive list of differences can be found here: http://python3porting.com/differences.html
[**@dabeaz**](https://twitter.com/dabeaz/) &gt; [2015-06-06 18:00 UTC](https://twitter.com/dabeaz/status/607245687793844224) &gt; @amontalenti great! A new edition of the essential reference is in the works. Maybe next year. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Thanks for your point, I appreciate the clarity. You cannot limit the teachings of maths, physics, and chemistry only by the symbols or variable names students use. The logic between the symbols, foreign words or conceptual words ("electron" for example) used is taught in the native language of students. I'm not sure that children can handle the symbols that well ! How many students fear mathematics and physics and thus fail/disregard them after ? Is it possible that the usage of theses symbols may be part of the problem ? Sure a lot of people here, like me, was not afraid of greek symbols ; we handled F, log, β, H2O, if, then, else but what about the others ? What about teaching programming to a wider part of the population ? A lot of my past teachers insist that we wrote pseudo-code in our native language. Maybe they are old school, maybe they think that it is a good way to not force one specific language ... but maybe it's also because reasonning with your native language is so much easier and writing/reading source code is reasonning. edit: in retrospect, I'm so glad we used `v` for *vitesse* (speed in french) in our physics course :)
Your question has nothing to do with python but more with sql, relational databases and google charts ;) I'd encourage you to learn about database design and joins, that stuff comes always in handy. Assuming the data is in the form I mentioned before, you'd need to somehow join the data on itself. You could either query the database two times and join the results in Python or with the join method of Google charts or you could join the data directly in sqlite. Python example: data1 = [[1,2,3,4],[1,2,3,4],[1,2,3,4]] data2 = [[4,5], [4,6], [4,7]] data3 = [row_data1 + [row_data2[1]] for (row_data1, row_data2) in zip(data1, data2)] SQL example SELECT a.ts, a.temp as temp1, b.temp as temp2 FROM (select datetime(timestamp) as ts, temp from timetest where sensor == 1) as a INNER JOIN (select datetime(timestamp) as ts, temp from timetest where sensor == 2) as b on a.ts == b.ts; print(data3)
Hi, author of Enaml here. Development of new features in Enaml has slowed in the past year as my work focus has shifted. Enaml is fairly stable however, and is currently in production at multiple Fortune 500 companies, including a top 10 investment bank. Happy to answer any questions about the project. Also, Enaml seems to be trending on [Hacker News](https://news.ycombinator.com/item?id=9677375) today, if you want to read the comments there. Edit: Here is my most recent talk on Enaml, which will answer most of the "what is this?" questions: https://vimeo.com/79536617
terrible for you, as you can take english for granted because it's your own language. 
I had the same problem (with python 3.3) and had to solve it... twice. So the second time around I made a batch script with the steps I took. This script also sets it up in a virtualenv so you will need to adjust it for your needs. The prerequisites may have some overlap as well... I sometimes used easy_install for easy to get windows binaries, keep an eye out for those requirements. Again, you will need to adjust this script for your needs... Here is the script! REM Prerequisites: REM git http://git-scm.com/ REM Visual C++ 2010 Express (For Python 3.0+) https://app.vssps.visualstudio.com/profile/review?download=true&amp;family=VisualStudioCExpress&amp;release=VisualStudio2010&amp;type=web&amp;slcid=0x409&amp;context=eyJwZSI6MSwicGMiOjEsImljIjoxLCJhbyI6MCwiYW0iOjAsIm9wIjpudWxsLCJhZCI6MSwiZmEiOjAsImF1IjpudWxsLCJjdiI6MjEyMTY5MzIyMSwiZnMiOjAsInN1IjowLCJlciI6MX01 REM Windows SDK for Win7 and .NET Framework 4 https://www.microsoft.com/en-us/download/details.aspx?id=8442 REM Windows Compiler SP1 Patch http://www.microsoft.com/en-us/download/details.aspx?id=4422 REM Fortran Compiler g77 provided via Windows Binary from MinGW http://sourceforge.net/projects/mingw/files/Installer/mingw-get-setup.exe/download REM Add C:\MinGW\bin to Environment Variables REM Create virtualenv @echo off SET virtenvdir="C:\VIRTUALENV FOLDER LOCATION" SET scriptdir="C:\VIRTUALENV FOLDER LOCATION\Scripts" SET repodir="C:\VIRTUALENV FOLDER LOCATION\Repos" SET sdkdir="C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin" cd %sdkdir% SET DISTUTILS_USE_SDK=1 call setenv /x64 /release cd %virtenvdir% echo Activating virtualenv call .\Scripts\activate.bat echo Installing dependencies cd %scriptdir% REM Cython is a required as C compiler dependency for Numpy and Pandas call easy_install.exe "%virtenvdir%%\Prereqs\pyodbc-3.0.7.win-amd64-py3.3.exe" REM Rpy2 dependencies call pip3.3.exe install wheel call pip3.3.exe install "%virtenvdir%%\Prereqs\rpy2-2.5.6-cp33-none-win_amd64.whl" call easy_install.exe "%virtenvdir%%\Prereqs\pywin32-219.win-amd64-py3.3.exe" call pip3.3.exe install singledispatch call pip3.3.exe install -U Cython call pip3.3.exe install -U SQLAlchemy echo Pulling required repositories cd %repodir% REM clone repos from github call git clone https://github.com/numpy/numpy.git REM call git clone https://github.com/scipy/scipy.git REM call git clone https://github.com/ipython/ipython.git call git clone https://github.com/pydata/pandas.git REM Compile each repo and install under current virtualenv echo Compiling repositories cd "%repodir%\numpy" call python setup.py build call python setup.py install REM cd "%repodir%\scipy" REM call git clean -xdf REM call python setup.py install REM cd "%repodir%\ipython" REM call python setupegg.py install REM cd "%repodir%\pandas" call python setup.py build_ext --inplace call python setup.py install echo Deactivating virtualenv cd %virtenvdir% call .\Scripts\deactivate.bat 
I work like this, but I have a Makefile or something similar which makes it very simple to recompile the .ui files whenever they change.
Just took a quick glance... was is it really necessary to *extend* Python? Could the tree structure have been implemented as a nested dictionary structure that could be read in from JSON/YAML? (Not trying to criticize, the answer could easily be "no", just trying to understand the design decisions behind this type of project)
In terms of interview topics, you might look at a previous thread with similar questions: http://np.reddit.com/r/Python/comments/2b4ytx/python_interview_questions/ It's not specific to Cisco but does have some general information about some questions you might expect. It would help to know more about the positions if you want more specific information.
**Linux System Administration Handbook** http://www.amazon.com/Linux-System-Administration-Handbook-Edition/dp/0131480057 **Introductory Python Books** http://corepython.com/ http://www.qtrac.eu/py3book.html **Python Reference** http://www.amazon.com/Python-Essential-Reference-Developers-Library/dp/0672329786 http://www.amazon.com/Python-Standard-Library-Example-Developers/dp/0321767349/ 
If your file is legitimately in ASCII, then yes, use ASCII encoding. If you don't know, you should probably be using utf-8. Still, utf-8 breaks horribly for most of my files. My go to is latin1.
Well, it solves the problem of having credentials in your source code. By keeping your plain text password out of the source, you at least make sure of that. Especially since the credentials are not to a server you own.
The talk is basically about how useful they are as bit vectors, reusable buffers, accumulators, etc. So definitely don't assume anything from the title.
&gt; Don't you think that localizing them could make their semantics easier to understand for somebody whose english level is not high enough? True. But on the other hand it would complicate things once people with different native languages start to collaborate with each other. How could a Chinese programmer have understood code where functions, variables, classes, and comments were written in Arabic (and from right to left)? Should we not bother at all and divide the programming community by natural languages even more so? Should we teach the Chinese programmer Arabic? What if the Chinese programmer finds a GitHub project and the code is written entirely in French? Who is going to pay for those language lessons? And it's not just about money; opportunity cost tells us that in the same time instead of learning French or Arabic one could learn another programming language or a new JavaScript framework. I suppose we could start them in native language and then switch teaching materials to English, say in high school or college. But old habits die slow. Look how many people still use `print Hello World` in Python 3 (or even `printf`), just because they were used to it since they've started coding.
thanks that did it!
More or less...I hate SEEING my passwords written down. I'd much rather type "broccoli forests golfball eyes" than Hunter2
Thanks for stopping by to post Chris! I remember viewing one of your videos from (I believe) Pycon where you introduced Enaml. Great to hear that Enaml is indeed being used in production code and has reached a fairly stable point. This was all that was primarily stopping me from diving head first and investing time into familiarizing myself with it. As a side note, I was stalking you on Github as a result of OP's post and noticed you've been working on PhosphorJS for quite some time now. I couldn't really tell what it is about... could you clue me in? Just curious. Cheers
Of course I find this the day after i spent 5+ hours trying make a shittier version of this.
You are 100% correct with everything you've said, but I do want to mention it's really common for people to treat FTPS, SFTP, and FTP as being the same thing, and just call them all FTP. They're not the same, but it's possible OP is using one of the encrypted ones, and just calling it FTP.
You're inventing problems that don't exist. Chinese programmers who don't read and write Arabic will have no more interest in contributing to Arabic software projects than Americans who speak only English are interested in writing poetry in Malaysian. You hang around a tiny section of the world where English is widely spoken, and you imagine that the whole world is like that. It is not. There are over five BILLION people in the world who do not speak English, and never will. There are parts of the world where the lingua franca of diplomacy, science and trade is Chinese, Hindi, Arabic, French, Spanish, not English. It is foolish in the extreme to think that those five billion people, who don't need to learn English to run their businesses, govern their countries, buy and sell goods, send spaceships into space, and do science, need English to program.
&gt; It's not a sorted dict. so please correct it
No more secure than having it as plain text in your source and VCS? Obscure would be if you stored it as a Base64 encoded string. In this case though, it is encrypted (symmetric encryption). https://cryptography.io/en/latest/fernet/
Django follows the MVT pattern and by understanding this pattern, you will understand how Django works. If you can't find documentation about the MVT pattern that is clear enough for you, you can look at the MVC pattern, which is similar and it is much more documented. Of course, there is some magic performed behind the scenes, mostly by means of the `manage.py` command, and you have to keep this in mind.
These problems absolutely exist because international trade exists. It's not like Chinese speakers are restricted to do business only with other Chinese speakers. And you're right - if companies from China and the United Arab Emirates start trading with each other they don't need to learn English. But they do need to find a common language. And if some coding is involved, then Chinese programmers will have interest in collaborating with Arabic software, even if it's just reading the API documentation. And once again, while Chinese, Hindi, Arabic, French, and Spanish scientists write papers in their native language, they still use the same symbols, nomenclature and units of measurements. If it's not a problem for scientists, why should it be a problem for programmers? 
Good idea.
I second the Django Girls tutorial, I did it right after the official Django tutorial and it really helped. Once I got the hang of things I bought Two Scoops of Django, which is the bridge between tutorials and knowing how things are done in the real world. Buying that booked helped me land my current junior position job, as I found out later they took interview questions from it.
I think Flask is just functions with decorators, which are simpler than OO boilerplate. I don't know for sure because I'm a noob at programing. 
OMG five billion programmers that don't speak english! Oh wait a minute. 
That sounds really awesome! I'll look forward to when it ends up being released. Starring it for now so it stays on my radar!
Life is hard! I'm currently living in a non-english speaking country speaking German as my first language, so get off from your high horse. That said, in the research institute I work we program in English because that is the way the world works.
How many of these 5 billion are programmers.
http://www.quokkaproject.org Python + Flask + Mongo
Maybe I'm an asshole, but wake me when it supports the "current" version of Python released **7 years ago**.
"It's not a big deal, they just have to learn enough English to understand the keywords." "What if we make the keywords in Hindi. You'd only have to learn eno-" "This is terrible."
Kind of. I've done something very similar in the past and I tried to make it look like what the above comment asked for.
Yeah, I know, definitely dumb to complain. Thanks for the project, what I saw of it before I discovered this issue looked pretty awesome, I hope to use it sometime.
&gt; it's basically a low-level toolkit for building large desktop apps on the web yes I looked at [an example](https://github.com/phosphorjs/phosphor/blob/master/examples/boxpanel/index.ts) and I noticed that it had the same procedural UI generation that Enaml was built to rectify. So I guess "low-level" is an accurate description of it. Perhaps you intend to write an Enaml back-end to generate javascript/phosphorjs? &gt; my day job is architecting a large pluggable IDE-like application which needs to run in a browser. There was nothing in the JS-world which suited my needs for that Did you take a look at [Elm](http://elm-lang.org/) for this purpose? 
Thank you for your constructive criticism, all points are well taken. I wouldn't get a chance to *make some snarky comments* as I was rejected for the job, but I wanted to hear some feedback on this test, so thank you for that. Q1. Well, the question is to basically squash two lists so that for every key from the first list there is a corresponding value from the second. If there is no value, the key should equal None. If there is no key for the value, the value should be omitted. I know I could combine zip and map and my solution wouldn't rely on *magic*, however I wanted it to be really short (I don't know why, actually). Q2. I don't think they wanted me to implement actual login functions (with all the security precautions), but yeah, with Yandex you never know. By comparison I understood time difference, but again, it sounds ambiguous even in Russian. And yeah, the following isn't right: if len(login)&gt;=1 or len(login)&lt;=20: Thank you for your correction. Q3. You are a lucky, seriously. I don't know whether I'm a pythonista or PostgreSQL admin at my current project. Q4. I really didn't see the probability of huge log size. It could be a question with a twist, yeah. 
Another way to use the .ui files is to load them on the fly rather than compiling. I don't know why this is so poorly documented, but [this Stack Overflow answer](http://stackoverflow.com/a/2500905) shows you how to do it.
In the wild example usage? Also what made you start this over the existing py qt libs?
As an aside to OP's complaining, I'm curious if there is any appetite/push for upgrading to Python 3 within the financial sector or if everyone is happy to continue with 2.7 for the foreseeable future? I'm frankly quite okay with using 2.7 although I do find the lack of `nonlocal` keyword functionality in 2.7 annoying every now and then. Not sure why there has to always be that one person complaining about Python 3 support like they're owed something by authors of open source projects.
When I work with unicode, 99% of the time I read files that have been spit out by programs that are localized differently and largely use latin1. If I use utf-8, it will crash. Rule #1 for Python 3 IO is don't guess. If I'm parsing data from a file, I should know the encoding, and I don't change it. If I don't know, I don't specify it and I let the system tell me what it is. If the system thinks it's ASCII, then shoot, I'll use ASCII. If it's not ASCII, I punt the burden to the user or whoever is localizing our software. It's not my job to guess at your encoding and it's not my right to change it just because. I'll end up doing it wrong and have a buggy code because of it.
Well I couldn't honestly ask because that question is already answered in the bug report.
if x &gt; 1 means negative numbers will not break it...
This isn't for a thesis :) It comes from personal interest and a general care for the development community. The only thing being written about this is a summary and analysis of the results posted publicly with open sourced data for all to view and use. This isn't getting turned on for a grade or degree. I hope this clears things up :)
Yes, I gave up and got anaconda...does everything I would want it to do. Thanks a bunch!
Seems relativley solid to me. Although I'm kindof a beginner though. Only thing I find weird is that you have a method named "main". I can see why you named it that, but I still find it fairly odd. Still, nice work (in my opinion at least)! I wish I had the creativity to come up with stuff like that, so I could beat my laziness and gain some programming experience myself.
 def is_gm(text): if text.find("Panda Cub") != -1: return True else: return False This can (and should) be replaced with: def is_gm(text): return "Panda Cub" in text Always use `in` over `find` or `index` when just checking to see if a substring exists. And if-else when you plan to return a bool is redundant.
Having ascending section numbers next to descending version numbers is a little confusing at first glance.
No I haven't. Just got assigned this today for work. Appreciate your suggestions! I'm watching NB's video now.
Do you have 64 bit Python? I gave up using it on my Win64 and went back to 32bit.
Good point about "main"! It was actually an entrypoint once, then I decided to add command line options and it ended the way it is now :) Fixed it.
I didn't spend much time analyzing the logic, but at a more cursory level it looks quite good. I noted just a couple little things. data = { "realm_slug": char.realm.slug, "char_name": char.name, "region": char.realm.region } You're allowed to put a comma after `char.realm.region` too. This is quite useful because later, if you add another item to the dict, you won't need to worry about remembering to add the comma after `char.realm.region`. It makes life a tiny bit simpler: Just always leave trailing commas at the end of each line in a dict/list/etc., and you'll never have a crash due to a forgotten comma. No special cases.. the last item is the same as the other items, with respect to commas. except Exception: print("Could not submit character data to http://wow-gm-track.website/api/add_char") `except Exception` is a little redundant; it's basically the same as just `except`. It's also a little over-zealous to catch all possible exceptions, so if you do so, you should at least do `except Exception as foo` and include some info from the exception in the error message, like: except Exception as e: print("Could not submit character data to http://wow-gm-track.website/api/add_char: " + repr(e)) unfortunately, using repr or str to format an exception can sometimes not give enough useful info, for example a socket.error just prints as `error('timed out',)`. I wish there was a simple way to get an unambiguous string representation of an exception but I always end up with a few lines of ugly logic to do so.
I'm glad you like it! I started with a free course at Udacity. I think one of Reddit cofounders was teaching it. Then I started doing little projects, things that I could use myself. Web crawlers, chat bots, automation tools, simple websites. I learned mostly by doing. It's a shame, but I haven't read any programming books. I should though.
That's not odd - in fact, it's standard practice. See the final two lines of `main.py`? ``` if __name__ == "__main__": main() ``` That's standard procedure to make the file executable as a standalone script.
Link to that free course? I'd like to take a look myself. 
i remember attending the talk at PyData NYC and was very interested . 
for me the "current" version is 2
After looking it up, it seems I started with this course for total newbs: https://www.udacity.com/course/intro-to-computer-science--cs101 The one with Reddit cofounder is this: https://www.udacity.com/course/web-development--cs253 I took it after the first one, as it requires some basic knowledge. It was a few years back, so they blended in one in my memory.
 except Exception: # as e: is definitely preferable to a bare except: because SystemExit and KeyboardInterrupt don't inherit from Exception. They inherit from BaseException, which a bare except will catch. So catching them is code-breaking.
Good catch. 
Lookup the `traceback` module, it makes it pretty easy to get tracebacks just like the interpreter produces in string form.
Ah yes! I have dabbled with sys.excepthook and sys.settrace in the past but I had completely forgot about it. That is a great idea and it would make the usage much simpler. Thanks! Be sure to see that in later releases :)
Not looking for a traceback; just an unambiguous exception class name/message.
why not a chrooted sftp provided by ssh as a starter? And then why not use ldap to store your credential, a two stage binding and a drop of priviledge? 
Solid. I've heard that doing projects is a much better way of learning compared to reading a programming book. 
There are only 2 uses of `in` in Python: * A preposition used for `for` loops * A binary operator which checks to see if an element is contained within an iterable or if a substring is in a string, returning True or False I'll assume you know the `for` case. Here are some examples of the second use: 1 in [1, 2, 3] # True (4, 5, 6) in [(1, 2, 3), (4, 5, 6)] # True "a" in "abc" # True "abc" in "abcdefg" # True [1, 2, 3] in [1, 2, 3, 4] # False You shouldn't feel uncomfortable using it. It's easier to read, write, and understand. And it's quite a bit faster than the alternatives. You can also define custom behavior of `in` for an object by overriding `__contains__`, but this is usually not very common.
Looks pretty good, on your Api calls you're always assuming that something is coming back 404 or otherwise, may want to catch no Internet connection or fail gracefully with a note to the user. You might want to call .lower on the args your user passes in, get away from dealing with case insensitivity. Also I saw a try, except raise where a try, except, else would have been better (don't remember the line) .. it's generally a good idea to raise explicitly and not generically as well. Oh and if you don't need the while looking library but you're cherry picking functions/methods don't load the whole thing in with a blanket import :) - from &lt;library&gt; import &lt;feature&gt; is your pal :) Keep it up!
I believe a request object has a .json() method that you could use inside load_json_from_url and a few other functions instead of doing a json load on the r.text. Generally I see a pattern of assigning a variable right before return it, in which case there isn't really a need to assign it. get_realm, load_auction_data, load_json_from_url, etc., all do this. I think it's cleaner just to return the value you need. If you need to print it out, you can always do that after calling it and assigning the return value to a variable in the calling function. Finally, I prefer using .format() instead of the %s, but that's is personal preference. http://stackoverflow.com/questions/12382719/python-way-of-printing-with-format-or-percent-form 
Why not just store the hash?
The passwords would be used to connect to an FTP server. As fasr as I know, it can only be done with a password and not a hash.
The idea of using some secure storage is part of a habit I have/am trying to force of not cutting any corners. This is something that likely only I will ever use, yet I want to build it so anyone could use it (given a set of basic instructions). 
Since no one's mentioned it, I'll go ahead and comment not on the code but the intended uses. It's kinda a dick move. If this catches on, you'll have both non-blizzard employees and blizzard employees being harassed. Blizzard employees don't advertise their account names for a reason. While this information wasn't hidden- and you did find a really clever way of trying to determine this- the scale of your program and the subsequent ease of use you are enabling is going to put this information in the hands of a lot more users who wouldn't normally have the technical know-how to get it themselves. If this catches on, you'll probably see parts of the API changing, data getting scrubbed, etc. With great power, comes great responsibility.
Oh, the idea was that anyone could run a script, and their results would be harvested on the website :) Besides, bogus data should not be displayed there, as I do checks that it is valid server-side.
&gt; It's your file, even if it came from me. You can delete it, modify it, encrypt it, compress it, replace every "a" with "z", or change the encoding. As the main author of a large &amp; popular interface library, if you want to use utf-8, then tell me. If you want to use latin1, tell me. If you want to read in as latin1 and write it out as utf-8, then tell me. If you want to read utf-16 or utf-32, or utf-32 big endian, just tell me. If you don't care, why should I? If you do care, then you want control and I'm not going to take it from you. It helps to avoid bugs. Python passes the buck to the user. Notepad++ passes the buck to the user. WingIDE does as well. Why shouldn't I? If I'm the user of my own code, I will use the correct encoding and I see no reason to change it. Just pass the data around. It's not a big deal. &gt; Such old legacy systems will eventually be retired or replaced, and if the replacement uses anything but UTF-8, then (generic) you really is part of the problem. And when that day comes, I'll stop adding an encoding to my file open commands. I'll also stop writing: $ encoding=latin1 at the top of my text files, where `$` is my favorite comment character. You talk about the day everything will be utf-8. Maybe it will come, but I still use Fortran 90 programs that have 80 character fixed width fields and `1.0E3` is the same as `1.+3` and `1000.` is different than `1.0D10` as well as `1000`. I'm not holding my breath.
I think the part that's somewhat confusing here is that a substring is considered an element of another string.
&gt; What is a non-blizzard employee? A non-"blizzard employee" then- what are you, a bash shell?
I'm sure I'l get corrected pretty quick if I'm wrong, but I think that is doing: 1 == [2,3] # FALSE 2 == [2,3] # FALSE 3 == [2,3] # FALSE 4 == [2,3] # FALSE 
Good catch. Wouldn't that just be an ex-employee though? :)
&gt; If children can handle F, log, β, and H2O, they will handle if, else, and while. But it's not just those keywords. It's also function names for everything in the standard library, and also error messages (which are hard enough to understand already).
then why do strings work that way? I assume if ["h","i"] in ["s","h","i","t"] doesn't work then? Even though strings are "somewhat like" lists of characters?
Okay yes that's a great point
&gt; Just always leave trailing commas at the end of each line in a dict/list/etc., and you'll never have a crash due to a forgotten comma That bit of advice is also useful when you use version control, and don't want to see this kind of diffs: \- "region": char.realm.region \+ "region": char.realm.region, 
I'm not against using this as a teaching tool I am for them ultimately learning English and disagreeing with your statement that they needn't learn it. 
Actually if other programmers overwhelming spoke mandarin most programs were written in it and most literature was in it I would learn mandarin and encourage others to do so as well. 
Actually, you are right. It is not what would be considered completely ethical. I knew it from the start. But I did it anyway. Why? After carefully considering my motivations, I came to a conclusion: I did it for internet points.
While learning languages is both intellectually and socially great we can't all learn more than a tiny sliver of the thousands of existing languages so we should standardize on a finite subset of them. The question is what small subset covers the largest portion of the population. Picking the top 3 Mandarin Spanish and English only covers 26% of the population. Upping it to 5 brings in Hindi languages if we can group them and Arabic and still only covers 35% of the population. How many languages do you expect people involved in intellectual pursuits to learn? 
But [1, 2] in [[1, 2], 3, 4] #true
&gt;There are only 2 uses of in in Python You can use it however you want by overriding `__contains__`. In [1]: class WeirdContainer(object): ...: def __init__(self, container): ...: self._container = container ...: def __contains__(self, obj): ...: for i in self._container: ...: if obj in (i+1, i, i-1): ...: return True ...: return False ...: In [2]: wc = WeirdContainer([1,5,9]) In [3]: 4 in wc Out[3]: True In [4]: 3 in wc Out[4]: False Of course, it can be abused like hell like any operator overloading, but there will be situations where it makes sense for some strange reason. I could see it being used in a networking library with a CIDR class, where you can check if `'192.168.2.159' in CIDR('192.168.0.0/16')`... but I'd use `netaddr` regardless.
What parts of Twisted do you need ported? Many core APIs already are, and it's definitely possible to write many kinds of interesting applications on the subset of Twisted that runs on py3. Many of the things which aren't ported, like IMAP, XMPP and OSCAR support, simply don't exist in other frameworks.
You're right, there are a lot of things which could go wrong, which is what makes it even more important to handle the exceptions gracefully. 
I have to assume you meant billion*
&gt; &gt; What about teaching programming to a wider part of the population ? &gt; Unpopular opinion around here, but we shouldn't. Or if we do, we should also teach dozen other non-essential but good-to-know topics. I don't think it's so unpopular if you explain it that way. &gt; And we don't have money nor time for that. Concerning my country (France) you're absolutely right. I like to hope that is just a political matter. &gt; Unless we cut something out, like physical education or arts lessons. Despite I really love mathematics, I can see a small cut in mathematics teaching in favor of computer science/programming as I think they try to achieve the same goal for the student (reasoning about conceptual objects) and programming can be a little more fun (you build something that "works", you can work with others, ...) than mathematics. 
That's not the same comparison as with a substring, though. You can put lists inside of lists, but you just concatenate strings. 
Nice, thanks. That should be a sticky somewhere because this is not the first time this question has been asked. I am going to try this out tonight and if it works I will write it up at least on my blog.
"A foolish consistency is the hobgoblin of little minds, adored by little statesmen and philosophers and divines." from "[Self-Reliance](https://en.wikipedia.org/wiki/Self-Reliance)", an essay by Ralph Waldo Emerson.
That's true, but strings are special. The substring in string syntax exists for readability. 
The biggest reason this is a concern is because of SystemExit, which will likely lead to someone down the road coming in your sleep and murdering you wondering why something like exit(0) isn't quitting or is hanging because someone did: except: pass
Which other threads does locally encrypting the password protect against then an attacker with access to your pc?
Wow, that's actually a pretty neat trick I didn't know about. But that's just another element of the list, it's inconsistent in the fact that a part of a list doesn't return true for being inside another list, but a part of a string returns true for being inside another string. Consider this for example: #returns true strung = "hello" print(strung in strung) #returns false lost = [1, 2, 3] print(lost in lost) Both are iterables, and you can easily see why the string one returns true. But if lists have the same container behaviour, shouldn't they return true in the above example as well?
a few semesters won't necessarily make you fluent enough to communicate much. 
&gt; The idea of using some secure storage is part of a habit I have/am trying to force of not cutting any corners. I completely agree. When something can be done securely it should be. But it is as important not to lull oneself or other in a false sense of security. There is no such thing as perfect security. You should think about the different attack vectors and what you can do prevent them. If you don't, you won't know the possible vulnerability your system still has. You further have to weight your security concerns against the features you want to have. For example you can choose to build a system which authenticates without user interaction OR you can build a system which prevents other people with access to your computer from authenticating them self. Your security can furthermore only be as good as the weakest link. If you send your secretes over an unencrypted public connection, anyone in between will be able to read and modify the data stream. You should use secure alternatives or an end-to-end encrypted tunnel.
But at least you would know if sb were threatening you and forced you to give them your password.
I agree. It seems that every talk is his best talk.
Is there anything related to python in this question?
NEVER SUDO PIP INSTALL
Highly disagreeing with (a). Seriously? So developers who use windows are stupid? and Linux people are geniuses? It's just not part of their philosophy to bundle open source software. That's it. No one is stupid.
I'll give 2 slightly different recommendations that may help. Part of the issue is Django has everything included and so is a bit heavyweight for achieving simple tasks and also for learning for the first time. http://radar.oreilly.com/2014/04/simplifying-django.html There is a great first tutorial by the authors of lightweight Django which will get you up and running much quicker than the official Django tutorial. Another idea is to look at Flask it's a micro framework rather than the everything included approach of django. It also fits in with the style of Python better so may be less jarring to learn first after learning some python. Have a look at miguel's flask tutorial (he also recently did a 3 hour intro video tutorial at pylon 2015 - on youtube (or his site). http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
He said Windows users, not Windows developers. Most Windows users don't know Python is. 
I think that what you have now looks clean and nice but if you haven't had a look at it already I'd suggest looking at PEP-8 that defines a standard python style. https://www.python.org/dev/peps/pep-0008/ Running it through the pep-8 linter in sublime text pretty much only highlights issues with line length which is arguably a matter of preference. Some of your lines though are so long that my editor starts wrapping when I have 2 of your files side by side - and I'm pretty sure it's not wrapping as well as you could have made it manually. If you're not using any tool to manage style then awesome job for keeping consistent and being neat. If you're not using a style plugin then I suggest using Anaconda for Sublime Text, it's very nice. edit: Love the use case though, I started out experimenting with building stuff towards the wow apis :)
I don't think developers who use Windows are stupid, and never said that I did think so. Nor did I say that Linux (or Mac OS) people are geniuses. What I ACTUALLY SAID is that Microsoft treats its users as if they were stupid, because it's part of their monopolistic strategy to appeal to as many people as possible, no matter how dumb those people are. IN POINT OF FACT, Mac OS and Linux people have AT LEAST MADE A DECISION not to use the most common operating system, in the same way that people who don't use Times New Roman in all their documents have made a typographic decision. It may not be the best possible decision, but at least it's something other than going with the default. This at least weeds out some of the dumb people, because one of the characteristics of dumb people is that they don't make choices, they just go along with the majority. There are reasons to go along with the majority other than being dumb, but any majority includes a number of people who belong to it just because it's the majority. That drags down the average level of intelligence. But, then, the average measure of any quality in a group is not a fair predictor of the measure of that quality in any individual member. &gt; It's just not part of their philosophy to bundle open source software. That's it. Bullshit. The part of the assertion that's bullshit is the "just." And that "That's it." There's no "just" about it. It's not random; it's motivated. Saying "just" in that sentence obscures the fact that it's motivated by making it seem whimsical. It's not whimsical; it's a conscious decision that makes life harder for Windows users but benefits Microsoft. For reasons (b) and (c), which I talked about before. &gt; No one is stupid. Wrong. Lots of people are stupid. It's just that that particular characteristic doesn't map neatly onto operating-system choice. There are stupid people using every operating system imaginable. Microsoft, however, has made the decision to market explicitly to stupid people, and to design their operating system so that stupid people don't have trouble using it.
I know that. I actually meant that more in a sense of "odd" that the method wasn't if __name__ == "__main__": main() but instead if __name__ == "__main__": start() that's what I meant :)
I can't find the reference, but I recall that I read somethere a microsoft employee saying there is an internal policy on shipping windows only with microsoft created products. Python is not created by MS, hence they will not ship it. Though, MS is not anti Python, as Azure and Visual Studio both have good Python supports. And it does makes everybody's life harder : - mac and linux both ship with it, and as a sysadmin or a casual dev, having a way to reliably make powerfull scripts for any major OS would be nice. - ms employees can't rely on any big player tools for scripting. They have to use either a compiled language (speed of execution is not the goal of scripting, so it's a sad choice) or powershell (miles away from having the tooling and capabilities of Python). - computer providers can't rely on any scripting capabilities for automation. Same stuff. - dev like us can't assume basic tooling. See, with the same good scripting language everywhere, one can automatically installed tools such as grin, ffind, pyped, etc. So you know anywhere you land, you can at least grep, locate, filter, consistently. Even people not coding in Python would benefit from it. - right now scripting effort is splitted. Powershell, Ruby, Python, PHP, bash, perl... Ressources are spent on a bit of everything. With one common ground, the quality of tooling and doc would increase tremendously. So I don't loose hope than one day somebody at MS will decide that 20Mo of added runtime to the 15Go of Windows would have a tremendously positive effect.
You could use a program like calibre to convert each pdf into whatever ebook format you need.
To make us cry
If you want to improve this you might want to take a look at naive bayesian filters. They are a great and easy way to create spam filters. They do require a training set of good and bad comments however. If you want to check if your approach is good, get yourself some reddit comments, label them manually and do a test :-) Have fun!
If you want a system that doesn't reject communally-built, FLOSS solutions beloved by millions, switch to Linux. AppleSoft do what pleases them; ours is not to question why.
True, but I didn't want to confuse someone new to the language. `in` isn't overloaded all that often.
Actually they are russian. Initially I scanned only russian-speaking realms, as it's where I used to play. I am scanning other european realms now, but the process is slow - around 1.5 characters per second. I tried speeding up, but was throttled by ip.
You can kind of concatenate lists too. [1] + [2, 3] # [1, 2, 3]
Do what? The link says you want a sleep to avoid going over the 1250 requests per day. The solution is simply download all 1250 possible requests you have; save whatever you already downloaded in a cache by its reference (I'm using the link, you can use whatever you have); keep doing that once per day till you get all the images in the gallery. Also, just wondering: If you're unfamiliar with Python, why use it? Why not use a library from a language you know? And if you're using this specific problem to learn Python, why not try to understand the above code (and the mentioned API library)?
Qt
/r/learnpython
Many (Most?) distros have python because it's a required dependancy, not just for the hell of it. Remove it and see what breaks.
I dont know where to put this in :O, i know how to do it with cronjob. BUT theres not any informations in your script (imgur api secret/key etc.) :D
What is AppleSoft?
Since you've been using `if not X` quite a lot, why don't you just stick with it. realm_name = member["character"].get("realm") if realm_name is None: continue by default return of `.get()` is None. Also, you seem want a boolean return for this. def is_empty_db(): realm = session.query(Realm).first() return realm is None I suggest you to use `return True if x else False`. 
Moving from CentOS 5 to 6 is a pain too, as is upgrading Puppet... or for that matter, when our company moved from FreeBSD to Linux. Still worth doing!
Good that you rephrased your previous answer. You clearly didn't assume the first time. Your expanded answer makes much more sense now. Windows is great as an operating system for the general demographic. We know why Windows is used by so many people. It's piracy. Now I am not stating that every Windows user is a pirate, but it's hardly bought, atleast in third world countries. Regarding functionality, Windows a higher level of comfort. There is a reason they moved away from a traditional desktop, and re-invented everything. People hated that but did they stop using it? No. Why? Comfort zone.
Honestly, I think it would be kind of bad for Python for MS to ship it with Windows, because that would effectively bless whatever version they pick as the de facto standard Python for a long, long time. This isn't a problem for Apple and Linux distros, because of their market share and because of their frequent updates. They can change their system Python every year or so and be more or less certain that most of their users will get the OS release that has it. But Windows versions hang around for years if not decades, and people don't upgrade until they buy a new computer. And it's on every PC in the world. Devs will target whatever lowest common denominator gets them on all those PCs. And that won't be anything close to what the latest and greatest Python is, which seems like it would chill development at the leading edge quite a bit. 
Because Microsoft doesn't make it? Why doesn't Windows come with perl?
the only other built-in type for which this would make sense could be sets, so &gt;&gt;&gt; {1, 2} in {1, 2, 3, 4, 5} True on the other hand everyone with a mathematical background (including me) would kill you for this and {1, 2} &lt; {1, 2, 3, 4} is pretty straightforward too, especially of you come from a mathematical background.
not `return bool(x)`?
this made me thinking the paranoid way for securing the remote app. here's what i would do... 1) set the app to read environment for passwords/keys. something like FOO = os.environ.get('FOO') BAR = os.environ.get('BAR') 2) execute the remote app from a screen/tmux session by passing some environment keys/values over SSH. in order to do this, i must modify SSH server and client configuration (`AcceptEnv` in `sshd_config` and `SendEnv` in `ssh_config`), then do... ssh user@remote "FOO=foo BAR=bar" this will cost me a lot if the app failed and requires a restart. but hey, i'm a paranoid freak!