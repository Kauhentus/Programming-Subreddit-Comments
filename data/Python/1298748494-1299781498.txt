&gt; \&gt;&gt;&gt; for i in range(len(food)): # unpythonic++ (makes a Pythoneer's brain snap) This was a standard idiom before the `enumerate` built-in appeared, and as such makes a very poor counterexample for what 'Pythonic' might mean. The majority of the remaining examples seem to be simple variants on this one. Author seems too inexperienced to be writing this guide. I believe if that oft-abused term has any meaning, its is better illuminated by the output of `import this`. Concrete examples of what is or isn't "Pythonic" are far too subjective to be of any value.
The author says this page is about Python 3. Since `enumerate` came into being with Python 2.3, I think it's a correct statement. Generally, shouting out somebody is inexperienced based on a short assesment seems rather immature to me. Rather, get in touch with the person and tell him your critics so things can be improved if necessary. That's one of the main principles of free software and a healthy community around it.
Not really relevant, but wtf? His TLD is .name? such things exist?
Yeah, noticed that too :) Seems more than all right http://en.wikipedia.org/wiki/.name (see box at the right: "Intended use").
Hell yes... http://www.cherrypy.org/wiki/WhatsNewIn32#Python3Support
If you are a beginner please be careful with the first example. Using "file" and "dir" as variable names should be avoided. Both of them are [builtin functions](http://docs.python.org/library/functions.html). 
Thanks for the info, will look at that.
Thanks a lot! That's great info!
My main complaint appeared in the last paragraph - these posts on code style are ultimately content-free and rank close behind web framework microbenchmarks on the list of spam I hate seeing on this subreddit. Real code is rarely "Pythonic", unless an exorbitantly unreal amount of time is spent designing it, and even then, it rarely stays clean once a small army of maintenance programmers get their hands on it. As for social responsibility, as far as I'm concerned I already fulfilled that by downvoting the article and explaining what I thought was wrong with it, if the original author found a public review offensive then they shouldn't be publishing online.
&gt;My main complaint appeared in the last paragraph - these posts on code style are ultimately content-free and rank close behind web framework microbenchmarks on the list of spam I hate seeing on this subreddit. Ok, fair enough, but that's your opinion. Others might be interested in those subjects, just as much as you aren't. And calling such subjects *spam* just because you don't like them isn't right. I am sure everybody here is mature enough to decide for himself what's spam and what's not. &gt;Real code is rarely "Pythonic", unless an exorbitantly unreal amount of time is spent designing it, and even then, it rarely stays clean once a small army of maintenance programmers get their hands on it. Again, you assume that your idea and experience is true for the whole Python world. There are many OSS projects out there which in fact adhere all kinds pythonic and as such write code that's generaly considered pythonic. Also, there are many companies which in fact write perfectly good pythonic code. At Google for example we have the so-called buzz factor (meaning that no piece of code is only maintained by a single person) and we still manage to crank out pythonic code, every day. So, please, don't make it look like as if the majority of Python programmers out there write ugly/unpythonic code once they work in teams, that's not true. &gt;As for social responsibility, as far as I'm concerned I already fulfilled that by downvoting the article and explaining what I thought was wrong with it, if the original author found a public review offensive then they shouldn't be publishing online. I agree on that one, in part. See, if you're not interested in seeing benchmarks and coding style posts then that's fine. However, only because YOU don't like that kind of information does not give you the right to insult somebody (that author) &gt; ... Author seems too inexperienced to be writing this guide. ... and expect others (readers here) to be interested in that opinion. And no, I am not that author :)
OK. Look, you're on Reddit. We decide the relevance of content by the summation of our clicks. I took the time and effort to explain my click - I thought - in a quite uncontroversial manner. That the author is inexperienced is not opinion – it is clear he has never run into the `range(len())` idiom, which means he has only been using Python since around &gt;=2.3. Despite that, he's writing posts deliberating on what is and is not good Python code, which I find objectionable, since he's calling out huge bodies of code that were written for the language before he had ever used it. That this is objectionable is further influenced by the fact that these ideas are oft mistaken by those of lesser acumen and in control of budgets as quantitative measures of code quality, and applied as such, to people such as myself as I currently seek my next contract. It is my prerogative to discourage the spread of this corruption where possible, as it directly impacts my income, and the quality of my peers when I finally secure work. The remainder, while an opinion, is mine to have, on a forum where I expect to be allowed to share it to the benefit of others, and as such I'd appreciate it if you stop telling me what to do or making guesses at the offence I may be causing (assuming you're not the original author). Edit: &gt; Also, there are many companies which in fact write perfectly good pythonic code. At Google for example As an ex-Googler I find this hilarious, Google is probably the world's foremost bastion of terribly Javaesque Python code. Anyone can dip into the App Engine SDK or Python-gdata internals to see what is meant by this.
Excellent!
Have a look at http://diveintopython3.org as it covers pretty much all the basics so you'll see what you might miss in terms of basics and then you can drill down on those particular areas. For example, something that doesn't surprise me is that folks seem to have a hard time understanding Django models as Django uses metaclasses to create models based on a class you provide in your source code. If you don't know metaclasses and their intended purpose you won't be able to figure out Django's model machinery ... One thing however that often surprises me is that many experienced Pythoneers often lack quite a bit of knowlegde when it comes to packaging and distributing their software, something you would loose a bet over if you had to guess. Maybe this has to do with the fact that using GitHub and friends makes it superfluous for some folks to know about packaging and distributing because they would just tell you to clone it from GitHub... just a guess but that's the best explanation I could come up with :)
but that's for python 3 that's not going to help with django dev at all, it will probably likely confuse more than it helps.
Well, sure, but then really, if you use `__future__` and Python 2.6, the difference isn't really big enough anymore to be significant enough to not have a look at some Python 3 based book (I am sure many folks will object to that but, well, that's what I think; http://diveintopython3.org/porting-code-to-python-3-with-2to3.html). Plus, there are plans to port Django to Python 3 this summer so ...
Python 2.3 was released July 2003. It's fair to say anyone who writes new code using `range(len(container))` instead of `enumerate(container)` is not writing Pythonic code. What major libraries still target 2.2? It doesn't even have "new" style classes. 
For Django Dev:http://prodjango.com/ || For Python Dev:http://propython.com/ ||
I clicked that link and said to myself: "Well, *that* was awkward." :) I love CherryPy. It should be included in every Python book as an example of good library design.
 for item in somecontainer: # pythonic a_callable_consuming_list_elements(somecontainer[item]) I think that second line should be: a_callable_consuming_list_elements(item) 
[Programming language shootout](http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=go&amp;lang2=python3). The areas where Python is faster involve Go libraries that are not well optimized in comparison with Python's C level libraries.
check out web2py i have found it to be the easiest and well documented web python platform
Hmm, You have to adhere to the low-level style-guide type stuff, and avoid the gotcha's type stuff as mentioned in the article, but what constitutes Pythonic on a larger scale is harder to track down. I've always thought of Tims Doctest as being Pythonic, and I don't have to look at the code - its the result that is Pythonic! It could mix tabs and spaces for indentation in its implementation, that's not the point. Addressing the problem of "not enough tests" by allowing one to turn explorations of functionality often carried out in the shell into tests and documentation by innovative use of an existing python feature - docstrings is Pythonic genius. 
&gt; Do not use from foo import *. Go *here* and *here* for more information. I looked at the "here" and "here" links (btw linking the word "here" is a cardinal sin of web design, imho), but the content he linked did not explain why "from foo import *" was bad. Anyone care to explain?
&gt;##How Long Did it Take? &gt;Less than one work day. Oh. That was unexpected.
I've gone through both of these; I recommend starting with Pro Django and then doing Pro Python. Good luck.
It pollutes the module namespace. If you import * from several modules, names might get overwritten and cause bugs that are hard to find.
I think the best thing you can do is pick a library and outline writing a game step-by-step. You can do a decent tetris with pygame in ~100 LOC.
It links to http://www.markus-gattol.name/ws/python.html#import_matters which explains it (last indented paragraph).
To be fair, the author is not comparing `range(len(foo))` iteration to `enumerate`, but to ordinary `for item in foo` iteration. In that situation, using `range(len(foo))` is certainly completely unnecessary.
&gt; Hmm, You have to adhere to the low-level style-guide type stuff, and avoid the gotcha's type stuff as mentioned in the article, but what constitutes Pythonic on a larger scale is harder to track down. Something fast and easy is to use `pep8` but then that's not so much about pythonic as it is about making sure formatting is PEP 8 conform. But as mentioned, it's very quick and easy to do so ...
So I totally answered your question. Not even the courtesy of an upvote nor a thanks? I'm gonna have to bill you. 
http://inventwithpython.com/ perhaps look around here...
I do plan on adding some to the tutorial pools, but actual comparisons/information about each library doesn't exist. Especially in a pros and cons format. Python gets suggested to first time game designers all the time, but they have practically zero literature to get them started.
don't know which post you're looking for, but here's another one: python -c "import SimpleHTTPServer;SimpleHTTPServer.test()" it servers the local directory via http
 python -m SimpleHTTPServer
This seems to be the one liners post http://www.reddit.com/r/programming/comments/13amb/powerful_python_oneliners/ But this is the one you're probably referring to: http://www.reddit.com/r/Python/comments/fofan/suggestion_for_a_python_blogger_figure_out_what/
&gt; I only have first hand experience with pygame Thats fine! Start by explaining pygame. Entire games can be made with it and there is a lot of documentation about it. My advice would be worry about other tools later and focus on teaching pygame.
How about one line that give the lyrics to 99 bottles of beer on the wall? print ''.join('%(pre)s%(num)s %(bot)s on the wall, %(nul)s %(bot)s,\n%(tak)s\n' % (lambda c,b: {'pre':['','%s %s on the wall.\n\n' % (c,b)][abs(cmp(c,'Ninety-nine'))], 'num':c, 'nul':c.lower(), 'bot':b, 'tak':['Go to the store and buy some more... Ninety-nine %s.' % b,'Take one down, pass it around,'][abs(cmp(x,0))] })((lambda x,o: [(['Twenty','Thirty','Forty','Fifty', 'Sixty','Seventy','Eighty','Ninety'][x/10-2]+'-'+o.lower()).replace('-no more',''), o][int(x&lt;20)])(x, ['No more','One','Two', 'Three','Four','Five','Six','Seven','Eight', 'Nine','Ten','Eleven','Twelve','Thirteen','Fourteen', 'Fifteen','Sixteen','Seventeen','Eighteen','Nineteen'][[x,x%10][int(x&gt;=20)]]),'bottle%s of beer' % ['','s'][abs(cmp(x,1))]) for x in xrange(99,-1,-1)) (this is not my work it is from http://99-bottles-of-beer.net/language-python-796.html)
Thank you for [bottle](http://bottle.paws.de)
Hi. Have you thought of giving Linux a try? I've found it a good way to make my life easier learning new stuff. My suggestion: grab VirtualBox, grab an Ubuntu (or Mint) iso, install the bastard with the standard settings. Oh, and don't forget the guest additions. That's what I'm doing to learn Django, currently. Works like a charm - I don't feel like I'm stuck in the 90's on the desktop front thanks to Windows 7, and I get a proper Unix-y, JustWorks dev environment from Ubuntu 10.10. And this is even on a 2 year old laptop with no CPU virtualization support. I full-heartedly recommend spending the less-than-two hours it takes to set it up - it's worth it.
&gt; Can you also recommend other stable, game libraries that use python? http://code.google.com/p/newpy/
Yes. The second one is it. Thanks very much! :)
A problem with range() is that it generates a list on Python 2.x, so for efficiency you have to use xrange(). But xrange() isn't supported in Python 3.x, in which range() now works like xrange(), and getting the old behavior requires list(range()). It's better to avoid this mess by using enumerate() when you need the index. However, if I'm modifying the original list in place to pop() elements out, I want to enumerate in reverse. For that, I wrote a little function that returns a generator: def r_enumerate(iterable): '''enumerate iterable in reverse''' r = reversed(iterable) end = len(iterable) - 1 return ((i, r.next()) for i in xrange(end,-1,-1)) Is there a better, more 'Pythonic', way?
Generators are great and this is a great addition to generators. I just wish generators wouldn't be used to model concurrent actions, stackless tasklets are much nicer.
http://www.python.org/dev/peps/pep-0380/ the pep in question
Here's a contrived example: x = range(4,10) for (n,y) in r_enumerate(x): print "(n,y):", (n,y) if (y % 2) == 1: print "popping:", x.pop(n) print "x =", x (n,y): (5, 9) popping: 9 (n,y): (4, 8) (n,y): (3, 7) popping: 7 (n,y): (2, 6) (n,y): (1, 5) popping: 5 (n,y): (0, 4) x = [4, 6, 8]
This library isn't the kind I'm looking for really. I don't think it has any tutorials or guides, and barely any examples. To learn to use this, you'd have to crawl through the source code. It also isn't being actively developed. I should have been more specific, but I wanted libraries accessible to new users.
My favorite python one liner is this: python &lt;script&gt; That will run ANY python script on your file system. It's crazy powerful.
You are welcome :)
Two years already? Wow, that was fast.
Well, I plan on writing a few pygame tutorials. But, of course, I think pygame is the only python game library with more than adequate documentation and tutorials. It's every other library that desperately needs them.
Thanks, I'm already linking to that in the guide. It's a great book.
Python's not a good one-liner language because of the whitespace-sensitive lexer.
Wait, the moratorium is over already?
one liner, eh? how about "Your mother was a hamster and your father smelled of elderberries." Oh wait... *that* python...
Can someone give a few practical examples of how/why one would use that?
That's really useful, but god, python is getting to be really hairy. 
I have just started teaching myself Python about 2 weeks ago. I started with [Think Python](http://greenteapress.com/thinkpython/html/) and like most beginners thought, "Well now what do I do with it?". So I have been reading almost anything that says Python, getting deep into forum discussions on things I have no business knowing. A few days ago I started with Panda3D and it is super easy to pick up and start making things happen on your screen. [This](http://www.mygamefast.com/volume1/issue1/?nopages=true) site helped me quite a bit with starting to understand how to use my letters to make pictures. 
Because manually iterating over and yielding each element or a sub-iterator is less efficient and less readable and -- more importantly -- it fucks up getting values when the current generator is [used as a coroutine](http://www.python.org/dev/peps/pep-0342/). It makes passing iterables straight through much simpler and less prone to mistakes. Finally, it makes extracting several `yield` statements into a sub-function or method much simpler: move them there and `yield from` the newly created function or method.
one liner, eh? how about "Your mother was a hamster and your father smelled of elderberries." Oh wait... *that* python...
That is an excellent tutorial website. It made 3D game writing look rather easy. Thank you.
nice one. :)
Awesome. Do you mind if I created a gist on github containing this list you've provided? I will provide a link to it in this thread.
Meaning, particularly, that newlines are mandatory for multi-statement blocks. In other languages you could do this while(cond) { stmt1; stmt2 } Fitting such a thing onto one line in python is impossible afaik. Correct me if I'm wrong.
 while True: print "herp" You are wrong.
Let me add a relevant node from the Haskell side: In Haskell, generators do not require a special language feature and they can be implemented as [a library](http://hackage.haskell.org/packages/archive/generator/0.5.4/doc/html/Control-Monad-Generator.html). The existing library for generators already has this.
Yeah, you can get a bunch of "small statements" in there... stmt: simple_stmt | compound_stmt simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | nonlocal_stmt | assert_stmt) ...XOR if you want any of the statements with colons (if, for, while, def, class, try...) you need a "compound statement," which contains a "suite": suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT So no luck.
Celery seems really awesome but I have a little bit of difficulties to see how the various parts (i.e celery itself, carrot, kombu, etc. (which are all mentioned somwhere or other in relation to celery)) all fit together. 
I thought some modules are designed for this kind of import?
and: `pip install e; python -me`
`python -m unittest` (Python 2.7 or 3.2) runs test suites.
from [PEP 3003](http://www.python.org/dev/peps/pep-3003/): &gt; moratorium would include Python 3.2 [...] but allow Python 3.3 [...] to once again include language changes
from the [References](http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html), there is a [Binary Tree](http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yf_current/Examples/binary_tree.py) For comparison, I shamelessly copy it here: # # Here is a binary tree that produces an inorder traversal # of its items when iterated over. (Courtesy of Scott Dial) # class BinaryTree: def __init__(self, left=None, us=None, right=None): self.left = left self.us = us self.right = right def __iter__(self): if self.left: yield from self.left if self.us: yield self.us if self.right: yield from self.right # # For comparison, here is the same thing using for-loops # instead of yield-from. # class BinaryTree_ForLoop: def __init__(self, left=None, us=None, right=None): self.left = left self.us = us self.right = right def __iter__(self): if self.left: for node in self.left: yield node if self.us: yield self.us if self.right: for node in self.right: yield node 
WHAT? How did I miss that one?
am i the only one who thinks that moratorium should be extended for another 2-3 years instead???? Python3 has enough problems catching up, allowing to change the language at this time seems like a spectacularly bad idea..
Haskell is lazy by default and needs syntax for strictness. Python is strict by default and needs syntax for laziness.
Don't confuse the moratorium on the transition from P2 to P3.
stackless tasklets stackless tasklets stackless tasklets ... =D
It's a change that adds syntax and breaks nothing. I don't see any reason it shouldn't be added since it makes using coroutines that a bit more than trivialities (e.g. code that is large enough that it should be factored out) easier.
It's not something that a newbie needs to understand. I think it makes python a bit easier in some ways, because I'd like to be able to think about generators more like regular functions.
yada yada Scheme yada yada yada proper tail call yada continuation yada yada streams yada yada yada. I could make logical arguments on how the Python language designers should consider the past, that mechanisms like this have been done before. But Guido and friends seem to be actively hostile to such input. "Yada yada" is all that was heard last time around, so I might as well save on the typing. I say let Python reinvent the wheel, rediscover past mistakes and successes. Why interfere further? 
I wish they would just have real coroutines instead. This feels like an awful, hairy hack.
That's exactly what I thought! I remember when the language moratorium, it seemed like a big mistake to lock things down for so long, but time really has sped by, and a ton of progress has been made in other areas. 
just got this email, i'm pretty bummed. it looked like a really cool and promising platform. i was just getting ready to launch my first django project using djangy+s3 for file uploads. guess i'll just have to shell out the $10/month for webfaction :/
You could also checkout ep.io and gondor.io.
They even quote alternatives in the blog entry: We encourage you to look at the other promising offerings in this space: ep.io, gondor.io, djangozoom.com, and dotcloud.com.
It may be more effective for you to ask this question on StackOverflow, as it is designed for such a thing, as opposed to Reddit, a social news site.
Yes, modules can define a list `__all__ ` and this pattern is used in some popular Python frameworks such as SQLAlchemy. However, according to http://docs.python.org/tutorial/modules.html#importing-from-a-package this is still discouraged: &gt; Although certain modules are designed to export only names that follow certain patterns when you use import *, it is still considered bad practise in production code.
I have no reason to mind, this list is just the result of trawling through the stdlib's `__main__`, it's not like there's anything secret about it.
ANY script!? That sounds even more dangerous than eval()!
Fianally! We’ve lost one reason not to switch over to Python 3.
There is an old tool for CherryPy and OpenID. You may give it a look, it's not perfect but might help. https://svn.defuze.org/oss/oidtool/
Great news!
Hope this is a good adoption-wave starter.
Pitty they aren't opensourcing it, a lot of little djangys in the wild could have been fun.
Made this for codegolf one time long long ago. (99 bottles of beer.. ) `i=99;j=98;a='bottles';b='bottle';k=' of beer on the wall' while i:c=(b,a)[i&gt;1];print"%d %s%s, %d %s of beer."%(i,c,k,i,c);print("Take one down and pass it around,","Go to the store and buy some more,")[i&lt;1],;i-=1;print"%d %s%s.\n"%(j,(b,a)[j&gt;1],k);j=(99,j-1)[j&gt;1]`
Run away!!
if you really find beer (as in: is there any microbrewery near?) please write it on one of the open space information flipcharts. 
This is great news, but I'm hopelessly confused with all the HTML parsers. They have so much overlapping functionality, it's hard to know which to use. What are the advantages of BS 4 over lxml, which, if I recall correctly, also contains 2-3 parsers (surprisingly including BeautifulSoup).
Good idea, I think it introduces less skew than counting PyPI downloads as many people currently do.
Note that I generated multiple types of counts, you can see more statistics if you download the full results.
BeautifulSoup accepts and works better with malformed xml/html, i.e. it does a better job when the data you get is invalid. That is not to say it magically fixes the data, just that the way it parses is different (~~regexp iirc~~), and because of that works better with malformed data [[1](http://www.crummy.com/software/BeautifulSoup/ "Beautiful Soup won't choke if you give it bad markup. It yields a parse tree that makes approximately as much sense as your original document. This is usually good enough to collect the data you need and run away")] ed: note that this is what is written on the main page - I've always worked with lxml and never had to deal with BeautifulSoup, so it's not personally verified. ed2: see reply further below
That agrees with what I've experienced in practice, but how does it use lxml or html5lib, then? Aren't they parsers as well?
Ah that's because it's BS4, which is a big leap from BS3. Here, quoted from its author: &gt;The story so far: the most recent release of Beautiful Soup (3.2) uses a custom parser based on Python's standard-library SGMLParser. This was a really good parser back in 2005. Here in 2011, html5lib is better at handling bad markup, and lxml and ElementTree are much faster if the markup isn't too bad. Beautiful Soup's parser is no longer a competitive advantage. &gt;What's more, SGMLParser goes away in Python 3, and its replacement is awful at handling bad markup. I tried to switch over in early 2009 and it just didn't work for anyone. So, Beautiful Soup has had the specter of death looming over it for two years. &gt;Beautiful Soup 4 will *not be a parser at all*. It will be a tree-builder. You will plug a parser into Beautiful Soup, and you'll get an object tree that reflects how that parser sees a document. I have this working reasonably well for lxml and html5lib, which is why I'm comfortable announcing the project now. Emphasis is mine. You can read more at http://www.crummy.com
Ah, I see, so you specify a parser and get a Soup object back for traversing the tree. Thanks, I understand now.
I am flying down from Canada. Let's meet! 
That's true. However, you should only import * when you do stuff interactively (just like it says in Python documentation), and only import * from one module. Otherwise things tend to get out of hand. 
any way to control the output of the formatter module?
Beautiful soup was useful in the days before html5lib but it was a huge hack. Today you want to use html5lib which parses whatever your browser accepts and let it parse into an lxml tree. lxml has both xpath and css selector support, so it's a breeze to work with. Beautiful soup (used to have?)/has a special unicode string which unless you are careful can result in some nice memory leaks because it keeps a reference to the document it originated from. Would not recommend it at all these days.
Isn't that also exactly what lxml also does?
agreed. I'd be interested in meeting up too. if anyone does this, note the reddit angle on the flipchart.
Indeed, I got a mail today, notifying me that my 1.3 years old bug is fixed. Yay :D
You have a comma there, which makes the link goes nowhere.
Hmm, BeautifulSoup's UnicodeDammit class *is* pretty helpful, though, yeah... lxml is amazingly fast, though.
Figures defuze.org would have already gotten this :) Seems like a very nice design, will have to look at what I've got and see if I can merge the two together.
I'm new to python, what exactly do all of you use this for? Building better search engines? Rating the effectiveness of an advertising campaign?
Fair point. :) It's also worth noticing that these approaches aren't semantically equivalent, one is using the iterator protocol, the other the sequence protocol. That doesn't matter for built-in types, but I've no doubt there are many objects in third party libraries that either break or act differently when interchanging the two . 
According to the [2.7 what's new](http://docs.python.org/whatsnew/2.7.html): &gt; Python 2.7 is intended to be the last major release in the 2.x series. The Python maintainers are planning to focus their future efforts on the Python 3.x series. 2.x being in bug-fix maintenance mode now, I don't think it's likely that new language features will be getting backported.
Yes. I seem to remember I created a module that you imported within a config file (which was just a python script). I used the '\_\_all\_\_' to control what functions where imported; If I added a new configuration option it would be added to '\_\_all\_\_', and the old scripts would import the new function.
Bad practise to design modules this way? Or to make use of those modules (in this way) in production code?
Hmm, that seems like more or less the most obvious way to do it. I think I would probably do something like def r_enumerate(container): "Warning: Container must have a length!" i = len(container) for item in reversed(container): i = i - 1 yield i, item but that's basically the same. Remember, no one is saying you can't use `len` and `range`, just that you shouldn't write `range(len(container))` when you can just as easily write `enumerate(container)` instead. In this case, your solution seems just as clean as any other.
One of the advantages of `yield from` is that it will be implemented with a trampoline, so you don't have to worry about possibly blowing the stack when going down the branches of an unbalanced tree. So, it would also be possible to implement a queue or stack this way without dying on item number 1,001.
regex works far better with malformed html in my personal experience
I sent the page(s) through HTML Tidy using [this lib](http://countergram.com/open-source/pytidylib) to get LXML to work right. Maybe it was an old version of LXML, maybe it's a limitation of LXML, or maybe the html5lib would solve everything.
disappointing, I expected *python* one-liners. here's my favorite segfault-in-a-tweet: tuple(type('', (), {'__iter__': lambda s: s, 'next': lambda s: type.__delattr__(type(s), 'next')})())
&gt; What is the best book to learn Python from? I recommend [Programming in Python 3](http://www.qtrac.eu/py3book.html). Scientific computing learning resources you can find at [stackoverflow](http://stackoverflow.com/questions/4375094/numpy-learning-resources/4375429#4375429). ... and of course the most important: [NumPy and SciPy Reference Guide](http://docs.scipy.org/doc/). &gt; is there a resource for learning commands and usages specific to R and ArcGIS? [Thesaurus of Mathematical Languages](http://mathesaurus.sourceforge.net/) should be useful. 
huh? which codes? my source code? it's not so much that it's proprietary or that I want to keep it to myself, just that before I'd present it to the world I'd have to make sure it doesn't look stupid and doesn't contain any personal data (passwords or I dunno, perhaps stupid rants I made in comment sections if I made them).
huh? which codes? my source code? it's not so much that it's proprietary or that I want to keep it to myself, just that before I'd present it to the world I'd have to make sure it doesn't look stupid and doesn't contain any personal data (passwords or I dunno, perhaps stupid rants I made in comment sections if I made them). so it's more like how it's not quite worth the effort of cleaning it out, to me. one day (hah) I'll make a nice portfolio website, and it will have lots of code for anyone to abuse. and yeah I'll link it on reddit, I guess.
Actually parsing python is no fun in any language. It is completely nonsensical to do it manually and even with basic xml libraries it remains a plainly annoying task. The best way is to generate classes from the XSD of your XML files and then deserialize them into instances of these classes. For python these links might get you started (quick google search): http://www.rexx.com/~dkuhlman/generateDS.html http://pyxsd.org/ http://pypi.python.org/pypi/rsl.xsd/0.2.3 Unfortunately I don't have any experience with this in python. For C# I can wholeheartedly recommend this: http://www.thinktecture.com/resourcearchive/tools-and-software/wscf
Dead easy. I do this sorta thing lots. I like [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) for a variety of reasons. It has glaring downsides (slow, DOM, etc.) but I find the syntax to be quite smart and easy to work with. You've got few enough and small enough files that you shouldn't encounter speed / memory issues. The BeautifulStoneSoup parser expects well-formed XML input; should be just what you're looking for. [EDIT: Worth offering -- feel free to drop me a line if you encounter any issues along the way. Good luck!]
Now that I think of it, if you simply want to convert the data to a CSV file it might be easiest to just read up on XSL. A bunch of stylesheets should do the trick.
I use R lots, but have never really come across a situation where I needed Python. I do most of my spatial analysis with R though, using the rgdal and sp packages. I only really use ArcGIS for making the final maps. Can I ask what specific situations you've come across where Python would have really helped?
Dive Into Python has a whole chapter on [XML Parsing](http://diveintopython.org/xml_processing/index.html) and it's probably enough to get you started, without having to track down any additional python modules. I personally always seem to fall back to parsing with minidom.parse(), but probably because I'm usually interested in doing something that is easier with an object representing the DOM.
Thanks, your version is more 'Pythonic'. It's more readable and less prone to bugs without having to set up xrange (not a problem here, but a better style in general). The length issue was also something I hadn't considered. Shouldn't a valid container type implement the `__len__` method? I suppose it can implement `__reversed__` without having an accessible length. I haven't come across this, or designed a container without the basic `__len__`, `__getitem__`, `__setitem__`, `__delitem__`, and `__iter__` methods. But my overall exposure to other's code is limited as I use Python basically as a replacement for MATLAB with SciPy, Numpy, and Matplotlib.
I'm curious, what was that bug?
Looking at the format of that sample XML label, this very well might be a whole lot easier than trying to do it with Python.
Ew. There are a few limited cases where that's true, but HTML-related regexps quickly become unwieldy.
Given the state of the old BS, I've taken to using PyQuery; Would BS4 be a better choice now?
I assume bad practice to use them. There's nothing wrong with having the `__all__` list in your module. I find it's mostly handy for prototyping or using modules in the interactive console. For production code it's a maintenance liability.
@pagingdrfaggot, Yes I have. It took a lot of digging. A combination of Wireshark and Psi helped a lot with this. For the Facebook webchat, of course Firebug is helpful too, although that gets into some other technologies besides XMPP.
Interesting perspective, considering Psi is used by most of the Ejabberd devs themselves.
There's no real advantage IMO, PyQuery is backed by lxml as-is the new BS 4.0. He sounds to be working on BS very reluctantly and the BS API isn't pretty, its main advantage in the pre-lxml days was its parser from most people's point of view.
&gt; I recommend Programming in Python 3. I recommend that you do **not** read Programming in Python 3, since ArcGIS 10 uses python 2.6, and reading about python 3 will just confuse you.
ArcGIS 9.x ships with Python 2.5, so if you learn python 3 be prepared to backwards-translate some of the commands. If you're using 10.x then this may not be a problem.
Seconding BeautifulSoup for this sort of problem. The ease of scripting more than balances any performance issues on only ~800 files. There are other options (lxml etc.), but I've gotten comfortable with BSoup. Just to get you started: from BeautifulSoup import BeautifulStoneSoup import urllib2 url2req = 'http://www.accessdata.fda.gov/spl/data/5ba0911f-d780-4bd7-a487-a6a3c8d2ab1c/5ba0911f-d780-4bd7-a487-a6a3c8d2ab1c.xml' xmlData = urllib2.urlopen(url2req).read() #print xmlData soup = BeautifulStoneSoup(xmlData) #print soup.prettify() title = soup.find('title').renderContents() print title [Edit: also happy to help, as per dodongo, with any problems. Not an expert by any means, but am often doing this sort of thing.] [Second edit: I've received a few downvotes for this contribution. Not that bothered, but I am curious as to why anyone would downvote without bothering to supply an argument? What I've suggested will work for the OP. If you don't like it please say **why** you don't like my suggestion, then we all learn...you click happy silent folks.]
Eh I could be wrong. I have two major problems with Psi. One, Psi just does not act as intuitively as I would like it to, thus frustrating me to the point of hating it. Why does it default to hiding broacasts/PMs from being immediately seen? instead it holds them on the status bar on the contact list window I never have open or in front of other windows? Even when I changed it to pop up, it jsut didnt feel right. Another problem in terms of usability (which I admit is probably something wrong w/ my computer or myself) is that when I use it on my laptop and moving tabs sometimes it will never release a tab from being dragged around. And if i alt tab and then go back to jabber to type something, simply moving the mouse over the active window it goes back to having a tab stuck on the mouse and removes the ablity to type. The only way of fixing this is by closing Psi and opening it again... ...which brings me to a third problem with how it acts, if I disconnect from the server, it takes anywhere from 10 seconds to an hour before it is able to reconnect. Once again, its probably me, but I cant figure out why. And then problem two, like I said before If I disconnect from the internet (which happens a bit because my ISP blows), or psi tries to connect before I have a connection, it becomes completely unresponsive until after an internet connection is established. Miranda just doesn't give those problems, So i recommended that instead. It might be a PEBCAK, but a chat client shouldn't be something I am stressing over to fix, I have code to write and games to play, so I just switched.
I 100% agree.
I'm trying to maintain a wiki about the lists you are talking about called [Pyrates are cool](http://pyratesarecool.appspot.com). This is just lists, i'm not commenting much about how relevant it is. You're right about being difficult to find recent tutorials so i've updated most of them adding the date when it's been updated. I'm going to do the same thing for the engines list as well.
I'm currently in a python class at City College San Francisco. CS131a. Half way through that class and will be signing up for CS131b which is more advanced and structured around django development. www.ccsf.edu
This way you get BeautifulSoup's tree traversal API, which is arguably better. If you have an existing project using BeautifulSoup 3, you can now upgrade it to Python 3 without having to rewrite the soup bits.
It should be easy to catch them all as only one is active at any given time :P
&gt;This year, we organized the talks in ten different virtual tracks. For the most part, the talks in each track should be sequential, so that each person can see most or all of the talks in one virtual track. isn't it?
I do most of my work in R and Python. Trying to move away from Arc, though... Anyways, Python is a much better language but doesn't have R's packages. In short, Python is very good at what R can't do, and R is quite good at what Python doesn't really do. The two together are extremely powerful when setup to work together. O'Reiley's "Learning Python" is good and serves as a great reference long after you've read it. The most recent edition covers Python 2.x and 3.x.
here is an example decorator, which demonstrates a bound method class method(object): """represents a method of a class, using a descriptor""" def __init__(self, function): self.function=function def __get__(self, instance, cls=None): def boundmethod(*args, **kwargs): return self.function(instance,*args, **kwargs) return boundmethod class Example(object): @method def foo(self, x): print 'self', self print 'x', x e = Example() e.foo(1) 
http://rpy.sourceforge.net/ 
Yes, you've got it. An object that supports `__reversed__` will probably also support `__len__`, but not necessarily. I can imagine someone making a quick and dirty doubly-linked list that supports forwards and backwards iteration but not length. 
matplotlib is still unsupported, though, so not really.
I know why you hate regex, but the issue is these parsers can't correctly detect the content encoding and they often crash if they guess it incorrectly. A re.search does not crash because of the wrong encoding. 
if you like slamming your head against the wall go ahead, pyquery is how a parser should be imo
Indeed :(
A word of warning though, lxml's CSS selector support is *damned* slow on some very common selectors like ".header". It generates an xpath that essentially normalizes every class attribute with spaces to try to see if it exists. It does this every time a selector like it is called, with no caching.
I'll be there with a few coworkers. 
Feel free to chip in when the Cape Town Python Users group works on changing that [this weekend](http://pythonsprints.com/2011/02/9/matplotlib-porting-cape-town/).
I will have a look around and hopefully someone might chime in if they have any experience :) What are the open space information flipcharts? This will be my first Pycon (first Conferencein generally actually :) and I haven't encountered such things before!
Sounds good! I'll be checking Reddit leading up to the conference, so feel free to send a PM along or I will get in touch with you :)
Sweet! Where abouts are you guys from? I'd love to know who your company is, or just what you guys are doing would be really interesting :)
I've read 1 or 2 select chapters from the first release of this book. It was very readable and explained sockets in a way a beginner could understand. Definitely would recommend it to anyone experimenting with netcode for the first time. 
Love BeautifulSoup. I actually just wrote a scraper and used [PyQuery](http://packages.python.org/pyquery/), which is like using JQuery. Most JQuery expressions map perfectly onto the PyQuery python expressions. It is fricken sweet. BeutifulSoup is definitely what I'm most comfortable using to parse non-html xml though.
Atlanta resident here. I'd love to meet up with some of the r/python crowd.
Atlanta has a fair number of good brewpubs and microbreweries, though I can only think of one that is walking distance from the hotel (my current stomping grounds are well North of there these days). Some of the others are easy access via MARTA (Public transit here) and I will probably have a vehicle, as well.
[lxml](http://codespeak.net/lxml) is the fastest and most versatile module (it is based on the fast and almost de-facto standard libxml2) 
Yes, though if you're already in a position where you want to take advantage of Python's abilities and you think you might want some R too, check out SciPy and matplotlib and see if what you need is now natively available. It's nowhere near as extensive as R yet, but for basic numerical and analysis work, it's solid and it's growing quickly.
Sounds awesome! I saw your comments above regarding beer above also, sounds like you're the man in the know! Let's get something sorted out.
**Brewpubs** [Max Lager's](http://maxlagers.com/) is a block from the hotel. I haven't been in a few years, but the beer was definitely good when I was there last. They also have (had?) some delicious root beer brewed on premises. It's a pretty sizable facility (so it should hold any of us who want to go). The food is solid bar fare. [5 Seasons Westside](http://5seasons.info/) is nearby as well (but more of a taxi/car trip). I haven't been to the Westside location (it opened after I graduated, sadly), but I've been to the original location and the Alpharetta ('burb north of town) location, and the food and the beer are outstanding. 5 Seasons is more likely to have something a little out of the ordinary on tap. Here's the [current list for Westside](http://5seasons.info/index.php?option=com_content&amp;view=category&amp;layout=blog&amp;id=35&amp;Itemid=71). [Twain's](http://www.twains.net/) is a popular destination amongst beer aficionados. It's a fun place to shoot some pool and have a pint, but they didn't start brewing their own until I had moved away, so I can't provide a personal opinion on it. This is a straightforward MARTA trip from the hotel. **Pubs in General** [Brick Store Pub](http://www.brickstorepub.com/home/) is easily accessible via MARTA and is a quintessential no-crap-on-tap kind of place. The selection of Belgian ales, in particular, is outstanding. [H Harper Station](http://www.hharperstation.com/index.html) is fairly new, but it comes highly recommended if you're a fan of fine spirits or a classic cocktail. I've heard good things about their Sazerac and Vieux Carré in particular. Some quick work with Google Maps indicates this is another job for a car/taxi. **Restaurants and Miscellaneous** I don't know too much about the restaurants around the hotel, but I can add a quick rundown of some of the bigger name restaurants in the city if you'd like. BTW, it's on my TODO list to update the bars page for the PyCon blog. If any other Atlanta people can chip in, that would be great. **UPDATE** Since I couldn't sleep anyway, I went ahead and updated the [relevant page on the PyCon site](http://us.pycon.org/2011/venue/bars/). Let me know of any spots that I skipped over (or horrible typos I left in).
why?
to the best coder goes the most karma! ... and people could pick up fancy idioms and trade protips/best practices
"best practices" start with not trying to write your code in the fewest lines. Anyway, here's my entry: import scrapy
+1 for BeautifulSoup - lxml would be faster, but you're not dealing with much data, and I find the interface to be nicer. Personal preference though!
[Marine Geospatial Ecology Tools](http://code.env.duke.edu/projects/mget/export/736/MGET/Trunk/PythonPackage/dist/TracOnlineDocumentation/Documentation/ArcGISReference/ArcGISReference.html) has many tools integrating ArcGIS and R and it's mostly written in Python. Check out the tool [Evaluate R Statement](http://code.env.duke.edu/projects/mget/export/736/MGET/Trunk/PythonPackage/dist/TracOnlineDocumentation/Documentation/ArcGISReference/R.Evaluate.html?format=raw) for example. There's a bit of a learning curve with the framework architecture, but it might be useful for you.
I used ElementTree, which is included in Python, when I was pulling apart SVG files. Was very natural and easy for me.
Oh I see lxml is listed here and there is a link to it... if you are just going to use ElementTree that is inside lxml, consider just using this: http://docs.python.org/library/xml.etree.elementtree.html As it says there, you need Python 2.5 or higher.
I find that python is nice to do loads of other stuff which is not necessarily mathematical or statistical in nature (getting data to and from the net, system tools, etc). Having gdal/ogr available makes arcgis pretty much redundant for my needs (mostly raster data). cython and f2py make glueing C and Fortran codes very easy. No doubt you can do the same with R too, but I just feel more comfortable with python. 
If you dont know any frameworks yet i would go with Django just for the extra bonus of experience with the bigger/popular web-framework in the python fauna.
Off topic. I live in Iceland and would like to exchange offices for a few months. Does a website exist that list these offers?
Good luck with this! You might also want to consider posting to /r/London 
Have you checked out http://www.techhub.com/? It's a tech-oriented space next to Old Street station with desk space for rent.
http://desksnear.me/ http://wiki.coworking.info/
Dude, you should totally check out the hub in islington, or hackspace in shoreditch. The hub is just above angel station and full of self employed web workers. edit: http://the-hub.net/
I have, but I was not impressed. They are almost full and screening applications for the remaining few desks, which gave it a country club vibe.
Good idea. I will.
Out of interest, what kind of programming do you do? You said you use Python, but what kind of applications are you building?
Is it just those 5 desks?
I will check it out, but from the website, it looks like the hub doesn't have a "resident" option, so you have to pack up everyday, which wouldn't be ideal. Thanks for the tip though.
I am building websites and webapps using django at the moment
I had no idea Old Street was being touted as London's Silicon Valley. Last summer I was working at Bloomberg in Finsbury Square (and will be returning there this year) and lived 5/10 minutes walk away on Old Street. I wish you the best of luck finding something, I'll upvote this to help raise awareness.
Yeah, they are trying really hard to get the name "Silicon Roundabout" to stick... lame name, if you ask me. Thanks for the upvote
Hi there, I'm a programmer, also based in Old Street. I'm afraid I have to stick with my 9-5 at the moment, but keep me posted about how things turn out for you. Cheers
I wish. I have thought of moving to London plenty times, this was one of the things holding me back. Sadly though, there are more :(. Best of luck in any case!
What kind of programming? Will do.
Is it also the weather? I don't blame you. I miss California... \*sigh\*
I came here to mention the hub in Islington - I've worked a few days up there and found it really productive. Great bunch of people there too.
For work? Java. Dabbling in Python and Lisp at home now and then. 
The hub is already on my 'to visit' list (per simonvc's recommendation) and now the trampery is too. Thanks.
What's the deal with that place? You just go with your laptop or what? How much does it cost? Can I just turn up there and check it out, or do I need to arrange a visit? I'm just looking for like-minded people at this stage - networking, which I have been pretty successful at by just drinking in Camberwell Green. My sister used to have a loft flat in Hoxton, and I met a lot of Nathan Barley types and gay coke fiend lawyers in the area, and *everybody* had Apple Macs and PowerBooks - I felt so alternative/rebellious/outcast/corporate with my ThinkPad.
I am currently at the trampery and I subscribe to what dsingleton (hey David) said: great place and great people. In the medium long run I am also looking to share office space in that area and I do a lot of python, so maybe we could start talking about it over some coffee. :) -- Norman
There is a new alpha version of BeautifulSoup available. It will use the lxml backend if you have it installed. 
How many of the sessions will be available online after the conference?
This is pretty sweet stuff, so basically we have 30 some odd rooms and people will write down something they're doing in that room. It can go from writing python code, to discussing robot technology(and demonstrating), playing board games, or in case of the Eve Online guys generally just getting drunk. 
Alright, I'll keep you posted and maybe we can grab coffee regardless.
Damn, I'd be up for this but I'm moving to Brighton not London.
Wish I lived in London instead of here in Italy. The best idea I have come up with is taking my laptop to the pub. Good luck!!
I read your headline and got excited because I think it would be pretty sweet to have an office exclusively for Redditing. Then I read the text and found out you want to do work there. That's just not how I roll, thanks though and good luck.
what do *you* do at work?
I wish I could, but I don't live in UK :( You may have better luck/want to xpost to: http://www.reddit.com/r/London
importthis made the same suggestion, but my [/r/london post](http://www.reddit.com/r/london/comments/fv2dl/london_redditors_do_you_want_to_share_an_office/) didn't fare well. I think it might have something to do with me not having a verified email address.
Yeah, I've been working with those libraries for ...hmm.. ~4 years now. IMHO, stats capabilities are ...dull. (Though, both are very very powerful, don't get me wrong, I love coding with these tools). I think that Matplotlib, in particular, has improved a lot in the past few years. It has great capabilities for basic plotting, but still has quite a ways to go for me to consider it against something like R's [ggplot2](http://had.co.nz/ggplot2/), which is very very sexy. I could code my own functions, but who really wants to re-implement linear mixed effect models... Devs (in many languages, not just Python) have had the attitude: "You need stats analysis? Go use R!" This is because R is a good language with a solid community of statisticians who use the language as the cutting edge, so I can't really blame them for saying this. [As you know, the other end of this is that R sucks at gathering and parsing data... it really only handles analysis and plotting. And it doesn't fit your brain the way python does.]
well dammit, that was the only thing I had to say.
I'm coming to the end of my stay with Mendeley at White Bear Yard in Farringdon this week. For the last 6 months I've had a permanent desk for £300/month, no real restrictions on length of contract. There's a whole bunch of exciting startups in the building, a number of them use Django. Let me know if you want more details.
+1 - Would be amazing to have a base to build similar services
&gt; What's the deal with that place? You just go with your laptop or what? How much does it cost? Can I just turn up there and check it out, or do I need to arrange a visit? anybody got an answer to this?
It's not just drop in, you sign up for different levels of membership, last time I was a member (a couple of years ago) it was £10 for basic membership which entitled you to a day or so's usage a month. Rates went up from there. I don't think they mind if you just drop in to check it out and have a chat.
You are probably right in using Miranda if your objective is a good end-user XMPP application. I would generally only recommend Psi for development and debugging, to which it is better suited.
Just taken it out of the spam filter mate, sorry about that. As another Django dev you should definitely come along to a [Reddit meetup](http://www.youtube.com/watch?v=KuuD9ftoeQM) sometime. :)
I've been (almost ironically) to two Microsoft hosted conferences in Seattle, and gotta say I'm now really looking forward to pycon since seeing the running sheet. And spending time with Eve Online's team hopefully. I'm the other aussie, by the way, joining Norther. I don't like beer, so anyone pointing out the best place to get a double single-malt scotch gets to be my friend for life.
There's a microbrewery about two blocks from the hotel, but I can't remember what it's called. It's not that great and it might actually be a chain, but they do have a big selection, brew their own beer, and the food was good. [The Porter Beer Bar](http://www.theporterbeerbar.com/) is a cab ride away. I went there last year and it was awesome. It gets crowded though.
I went to [The Porter](http://www.theporterbeerbar.com/) last year and it was awesome.
A few Intermediate (maybe a bit Advanced) talks by Alex Martelli... Python Design Patterns: Part 1: http://www.youtube.com/watch?v=1Sbzmz1Nxvo Part 2: http://www.youtube.com/watch?v=tJXhtncDBu4 Callback patterns and idioms: http://www.youtube.com/watch?v=LCZRJStwkKM
That's the same flawed logic as I am complaining about in the original benchmark. I'm not arguing that a single thread of python is faster than a single thread of GO.
All of them should be available. Side note: I just interviewed the PyCon video guy -- should be up on the PyCon blog shortly.
Are all the meetups organized on [r/LondonSocialClub](http://www.reddit.com/r/LondonSocialClub/)?
That's what I hear. I added it to the PyCon page last night, but if you could add a bit more info than the one sentence I wrote, I'd appreciate it.
I thought you could only get a space if you were funded by the group? 
Hmm, I've been thinking about starting up a "Tech Space", a mixture of a co-working space, fused with living quarters, and some kind of "social" space. Basically a one-stop shop for startups, programmers, hackers, makers, cyclists and more. Ideally to run as a limited co-op. Interested?
Rather keep the company I work for out of reddit but we're a sponsor. I'm sure you'll figure it out by my posts though. 
There was a pub down the block from the conference hotel, had a decent selection of beer and liquor. I don't remember the name but if you head down the hill(you'll know the hill) and turn right it's there. 
nur zwei tage ?
Start all code on reddit with four spaces...
I already asked enricom what he has found so far, but this sounds more interesting. Have you done any research?
&gt; only two days ? It's intended to be a barcamp, so that shouldn't be too surprising. I think the official barcamp wiki even suggests it.
Sounds like a hi-tech hippy commune or Israeli kibbutz. I've met a few old guys that lived in communes back in the late '60s and early '70s. One of them stayed in a squat in Regents Park, for years. It's crazy to think that it was so run down those days, when the same houses cost many millions now.
You posted the wrong link. The code is more interesting than the video. Remember the saying: give a man a fish...
Code is coming up. I discovered a few bugs that I have been working out the past couple hours.
vim
If you're just learning, I wouldn't bother using and IDE. One might help once you start working on a big project and need to keep a lot of modules organized, but seriously just a solid text editor (emacs, vim, gedit, notepad++) and a terminal is all you need. I've used Eclipse's PyDev a long time ago. It had OK completion features and the debugger is pretty good. I never used any of the other features, and these days I just use Emacs.
Here is [a list](http://stackoverflow.com/questions/81584/what-ide-to-use-for-python) with python IDE's. Personally I'm using pycharm. Not free but an excellent IDE.
[Komodo Edit](http://www.activestate.com/komodo-edit) by ActiveState is supposed to be good and it is free. Edit: Fixed link
You might want to use http://www.vpython.org/ to make it 3D or even somewhat interactive.
I'm pretty much using gedit for everything these days.
Don't bother explaining why
Sounds like interesting concept, but I am looking to separate my living and working spaces, so it's probably not for me.
If you are just getting started a text editor and a command line are all you need to start learning. One tool I will recommend is the [IPython](http://ipython.scipy.org/moin/) interactive shell. I find it to be a great tool with many nice features, some of which you can find [here](http://ipython.github.com/ipython-doc/dev/interactive/tutorial.html"Some documentation") and you can find the full documentation [here](http://ipython.github.com/ipython-doc/stable/html/index.html).
I use Kate
I love Komodo Edit for Python.
IDLE still works for me.
looks like a useful lib. wondering 1) how well this library is supported / active and 2) if it can handle large data sets. any good videos that shows off this lib? thx. 
Ive tried most fancy IDE editors but always came back to vim after a while until i found PyCharm 
I would not recommend vim to someone who is new to Python.
Most start there yup, however we still xpost. 
Came here to say the same thing with no explanation. Now I feel like this deserves an explanation... VIM has boosted my productivity immensely. It has a very steep learning curve, but once you understand it, you will find that you never want to use anything else. Also, you won't have to switch editors every time you start a new language. [VIM cheat sheet](http://michaelgoerz.net/refcards/vimqrc.pdf) [another](http://www.viemu.com/vi-vim-cheat-sheet.gif) Oh, also, make sure to grab ipython. It provides a much improved interactive programming environment compared to the basic python command line. You can even [stop your scripts](http://stackoverflow.com/questions/1126930/is-it-possible-to-go-into-ipython-from-code), pop into the command line, and test your variables to find bugs, etc.
What better time to learn VIM than when your productivity is a bit low anyway? 
I agree with this list because I'm using Eclipse with PyDev, it needs a bit of tweaking but it's working pretty well.
I clicked the link knowing I'd be able to upvote VIM. Didn't expect it to be the top comment though.
New ťo python or new to dev ? If you are familiar with an ide why don't try to keep it if he supporte python. I use eclipse+pydev because i use eclipse first, or editra because it's lightweight
I work for a small tech company that in the uk is presently just me. A new guy will be starting soon. We have an office with regus on euston rd and it is shit. They charge 60 quid a month per person for the internet and its slower than the hsdpa on my phone. We need to renew in 3 months so this could be an interesting idea if the costs were right. 
It was corrupting some javascript inside &lt;script&gt; tag: https://bugs.launchpad.net/beautifulsoup/+bug/419568
That argument sounds fishy to me. I still remember the first time I opened vi (more than 10 years ago). I spent the next half-hour finding out "how to quit the damn thing". Nowadays I can use vim, but recommending it to someone who has to wrap his head around a new language is ... not very practical.
Emacs has a good python mode and interactive buffer.
An IDE is not as necessary for python as it is for other languages. I am not sure why, but you usually find out that you are just as productive (or almost as productive) with a simple text editor as you are with an IDE when it comes to python. I've used [SPE](http://pythonide.blogspot.com/) in the past, but nowadays I just use notepad++. In the beginning you can just use a text editor (choose something that supports python syntax highlighting) and a command prompt. When you install python you already have IDLE for that.
When I was learning Python I used an IDE and it allowed me to ctrl-click on any function (my own or a Python API function) to navigate to the source. That was very helpful during the learning phase. I use PyCharm now and its ability to highlight stuff like undefined variables has saved me many times.
Oh no. Not this again!
None. Just use a regular editor (Notepad++, SciTE, gedit Emacs, VIM, textmate, fraise, textwrangler, bbedit, Kod, ... whatever floats your boat) and learn the language. Once you know the language, you may consider an IDE.
Gedit. Then emacs.
I've used NetBeans in the past for python projects. It's sorta sluggish being a Java-based IDE. Nowadays, it's Vim all the way.
scite is also fine if you don't want a IDE. But the OP specifically asked for a IDE - he should look at Komodo IDE. Also, PyCharm seems to have a lot of fancy features (more than komodo) but it can't work on networked drives and it really wants SunJRE on linuxes.
This person's right. And when the time comes, if you want to consider an IDE, and works specifically with Django, look at PyCharm, otherwise ActiveState have one general purpose Python IDE. But do not jump right into an IDE.
Mind that, IT'S ENTERPRISE ... Seriously now, git has submodules - why not use them ?
I dunno how you Notepad++ers do it. Before I used Vim, I had to always have a background script running in order to get the key binds I wanted. Caps+ijkl for movement, Caps+u/o forward/back words, Caps+s+(motion) for different selections, etc. Just tons of Autohotkey stuff. The advantage was I could use it anywhere (even in web browser!) By themselves, the non-1337 text editors just don't seem to do much. You have to jump around the keyboard to the arrows and/or use the mouse to get anything done. :(
I really like Emacs. I'm still getting the hang of some of the more advanced features, but even at a basic level of understanding I feel like it gets out of your way more than vi/vim do. I recently installed ipython and integrated it with Emacs using this guide: http://pedrokroger.net/2010/07/configuring-emacs-as-a-python-ide-2/ So far, I'm very pleased with how it works.
Great! The idea is still only half-baked, but I will keep you updated if/when it moves forward.
Alright, good to know. I will keep my eyes peeled.
If you have Eclipse already, try PyDev. I would not download Eclipse just for it though.
WingIDE, my favorite IDE, Pro version is not free, but easy to use and a lot of powerful features. you can try it, and there is a free 101 version too.
[Aptana](http://www.aptana.com/products/studio2) with python plugins.
vim + ropevim + pyflakes
I've been using vim for a long time to work with Python, but now that my projects are growing larger I've switched to Sublime Text and PyCharm and I am not regretting my move. The IDE is lightweight and fast and has a responsive team behind it. The autocompletion features help a lot in maintaining code. I have used Eclipse with PyDev in the past and it simply, in my experience, is unwieldly compared to PyCharm.
Whatever you end up using, remember to install ipython too!
Vim and ipython.
As far as I'm aware vpython isn't really a plotting package (though I'd be happily proven wrong), so the OP would have to do alot of work. Perhaps mayavi2 might be better for this, of matplotlib can do 3D plots but I found it to be a little slow. Just hijacking the thread, anyone have any reccomendations for python plotting packages, which can handle high framerates, or should I roll my own?
Blog post needs examples.
If you're new to Python I would strongly recommend to spend time with some **interactive Python shell** for a bit so you get instant feedback which will help you a great deal in learning Python. It's also quite a productive way to quickly test some ideas ... Only after that would I jump to some fully-fledged IDE. There are many interactive Python shells out there e.g. iPython. Personally I found bpython the best one. It shows you function signatures etc. and the documentation (what's in `__doc__`) when you play around with objects etc. Also, quite important imo, bpython works for Python 2 and Python 3. Have a look at http://www.markus-gattol.name/ws/python.html#bpython which explains how to set things up and get running quickly.
Wing IDE is my favorite one , although the pro version costs , as an alternative you can go with Eclipse + Pydev , its free and feature wise is as good as Wing.
Page Not Found
I'm keeping my moral balance and upvoting both you and the vim guy.
I have not tried many others, but I use [PyScripter](http://code.google.com/p/pyscripter/) on Windows. I'm not sure how popular it is, but I think it's good.
.. or python 2.6 implementation that I can try.
Always the correct answer: vim (nerdtree + snipmate) + ipython and pretty soon you'll be flying.
WTF?
Notepad++ has an awesome python script plugin as well.
Schrödinger or Schroedinger but not Schrodinger. 
Yeah PyCharm is an excellent IDE for big monolithic projects, and it improves significantly with each release. Still waiting for support for other template languages than Django's though. The corresponding tracking bugs are currently set to [2.0 for Mako](http://youtrack.jetbrains.net/issue/PY-1030), [2.0 for Jinja](http://youtrack.jetbrains.net/issue/PY-1032) and [Post 2.0 for Genshi](http://youtrack.jetbrains.net/issue/PY-1031) (with Mako and Jinja both being very popular, whereas Genshi... not quite).
http://www.activestate.com/komodo-edit
I like PyCharm as well. Good price point for the individual developer. They are very responsive to bug reports and continue to add cool stuff.
Reads like an ad for ActiveState. Here's all it says about "improved" multithreading: &gt; concurrent features module, which abstracts processes and threads to enable better concurrency That's it. I'm guessing this is just a reference to CPython's attempt to point people who need multithreading to multiprocessing instead. No reason to rush to 3.x yet.
It (vim, at least ... dunno about vi proper) has a very good help system built-in, and bound to the [F1] key by default. Learning the basics won't take more than a few minutes these days thanks to the tutorials provided. But yeah -- it's a bit like emacs the first time you open it up. "What the hell am I looking at and how do I make it go away once I inevitably get frustrated with it?" :)
Mendeley are subletting their spare space
This tools are very ingenious !
Upvote for SciTE for simplicity and reasonable language support. Best of all, SciTE works on both platforms I use (Windows and GNU/Linux) without any issues. I enjoy consistency.
Well, assuming you are on Windows, WingIDE and PyCharm are the best pro choices (not free) with Pyscripter probably the best free choice. There are many Python editor/IDEs but not many of them offer integrated debugging which is extremely helpful for a Python newbie.
Would doing that really make your programs run faster?
I don't understand why I would want to do any of this by writing Python... why not use Python as the programming language to create tools that do this more easily? Trying to avoid a DSL or CLI in favor of using Python's syntax seems cumbersome. Can anyone tell me what I'm missing?
I fail to see an actual improvement.
Agree. (but fix the link)
Guess fail. Python 3.2 contains a new standard library namespace "concurrent" and an implementation based on the Java "futures" paradigm (not "features" - the article even got that wrong!) which makes coding either thread or process-based concurrent processing easier. The namespace is poised to eventually include all concurrency-based modules (since there's quite a few it makes sense they're in their own namespace) but that's too huge a change for 3.2. The documentation is [here](http://docs.python.org/py3k/library/concurrent.futures.html#module-concurrent.futures) I used it today, and its pretty cool. I like that it makes the mapreduce algorithm almost inherent. Of course, for my app, it failed miserably because ActivePython's tk is not thread-safe :( 
learning DSL for small time sysadmin sometimes can be a too much overhead. I personally tend not to overhelm my brain with garbage knowledge, which will be useful for me just in tiny enviroment. :) 
I'm not following -- what's the use case considering the existence of optimized .pyc?
Everytime I use Notepad++ my thumbs get tired from hitting space too many times. Actually what happens is I get a billion indentation errors. IDLE spacifies tabs, so does PyDev + Eclipse (those are the 2 I use). 
if matplotlib isn't working for your need, you may want to look at enthought's [chaco](http://code.enthought.com/chaco/).
Thanks, I hadn't considered the possibility of managing just a few systems with these tools. If you already know Python then that would definitely be a good use case.
It'll be great for codegolf.
`print db.execute_sql('concat "&lt;html&gt;&lt;head&gt;&lt;script type="javascript"&gt;function hello { alert('", your_name, "'); }&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;)" from tUser where id=1')[-1]` Better than a python one liner! It's a Python, HTML, Javascript, SQL one liner!!! I win!!! :-p
What do you mean by 'spacifies tabs'? I know you can customize how tab working in Notepad++, I changed mine so that it represents 2 spaces on python files... ...I also wish I was a good enough programmer that my fingers actually got tired from typing too much...
&gt; I changed mine so that it represents **2 spaces** on python files… BAD!
I can see it being a good idea if running a class. You could introduce good habits and convenient shortcuts pretty easily while introducing the language. When learning alone, it sounds like a poor idea to need two manuals open. Furthermore, someone who is at a stage where they are only editing and working on a few lines at a time is likely to never leave edit mode and always use the arrow keys, and therefore unlikely to encourage learning the features that make it useful.
I'm a fan of Sublime Text myself. It isn't free but I just put up with the nag on save as I can't justify $60 for a text editor. It is amazing though.
Why? I was following Google's internal style guidelines :(
No. It *might* make it load/tokenize slightly faster, but once it's a .pyc it won't give any advantage. I'm really struggling to figure out why you'd want to do this at all. 
That's because you probably haven't looked and are comfortable just constantly negatively commenting about it all the time. You even have negative posts about documented improvements in PyPy because they didn't work on *your* #1 priority. Do something about it. Waiting on the sidelines isn't helping you.
rly? http://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Indentation#Indentation
You are confusing three separate things. 1. Improved multi-threading refers to an improved GIL implementation. A simplified explanation is that thread switching is now time based, rather than instruction based. A bunch of benchmarks have shown improvement, but as 100 people are going to point out, it's still a GIL. It's not perfect, it has its downsides, but it is a step in the right direction. 2. `concurrent.futures` is new and does what your quoted text says. 3. `multiprocessing` is `multiprocessing`, and unrelated to your post.
&gt;I know you can customize how tab working in Notepad++ I use notepad++ more as a viewer than editor, so I never did this. May start. Although I also use linux a lot. But what I meant was exactly this, on any editor designed for python pressing tab inserts 4 spaces rather than a tab.
Understandable. Which is why simply saying 'vim' is probably not a good recommendation. Though "check out vim, make sure to start vimtutor first though" would have saved that 30m.
I'm a vim die hard, but it lacks a few things that would make me hesitate to call it an IDE. You can approximate a lot of IDE functionality to a fair extent with plugins, but it's never felt like a full blown IDE. And I don't think it's supposed to. For example, omnicompletion simply isn't in the same league as intellisense like IDE completion. It'll only know a completion if the file for that method or variable is in a buffer from what I can tell and is fairly poor at completing library methods. I have it set up and never use it, sometimes 1/2 is more frustrating than not at all. It's also pretty much dead in the water (no syntax coloring, no auto indent, nothing) without a fairly extensive .vimrc that a newbie would have no idea how to set up if not just handed to them. I recommend vim as an editor very frequently, it's light weight, runs everywhere, and fits into "the unix way" of doing one thing and doing it ver well. Love modal editing too and I think everyone should at least try it. But an IDE it is not.
I'm amazed there aren't as many mentions of IDLE. It comes with Python, it's bare-bones but it has little things that help, and it works on all major platforms. It also uses docstrings for tooltips and incorporates all the true "Python-y" things natively. In my Intro CS course, I strongly recommend IDLE, as I think it's a great IDE for learning the language. One complaint I have about it is the standard shortcut on Windows causes issues with Turtle graphics/TK in general, but that's easily fixed by modifying the shortcut to start IDLE in "no subprocess" mode. (Hint: change the target to **C:\Python31\pythonw.exe "C:\Python31\Lib\idlelib\idle.pyw" -n**) 
tfa suggests it's for obfuscation/fun.
&gt; The Python 3.2 release also has a stable ABI ... Any ideas about what is being referred to here?
It could have changed? I was learning Python by watching Google's Code University lectures on Python with Nick Parlante, and he routinely says that internal style guidelines at Google are that proper indentation is 2 spaces. http://www.youtube.com/watch?v=tKTZoB2Vjuk Thanks for pointing to the actual documentation though.
You have criticized Python3. Prepare to be downvoted into oblivion....
[http://www.python.org/dev/peps/pep-0384/](http://www.python.org/dev/peps/pep-0384/)
Criticism is welcome. Trolling isn't necessary.
Trying to obfuscate Python is like trying to make low-fat suet. Somewhat pointless and counter productive I would think. As for *fun*, well I have nothing to say about that, it's entirely for your own amusement. 
I've been using notepad++ and IDLE for learning, my plan is to switch to an IDE after I have something to write. Thanks for the suggestions!
Is Python the right language for this? I've got some experience in stimuli-response measurement software. I've worked with Java (nono!), C# and MATLAB with the Cogent Toolbox, created specifically for these matters. I considered Python at some point, using Pyglet to represent audio and graphics. But I feared whether it would be reliable in terms of timing... What do you think about this?
I'm interested. I'm in a similar situation as you -- working from home on Python (and C / C++ work). I think that a more stable routine would make me more productive. Feel free to message me for a chat about it.
sink or swim
good if you can find it ha, likely they'll be in insert mode before they know it
just look at the battle between Chef and Puppet for arguments on both sides of this. It generally comes down to 'clarity' vs 'power'. For me, the simplicity of the above solution is very attractive. 
PyCharm can win in your choice.
I'd recommend [Komodo Edit](http://www.activestate.com/komodo-edit). It can be used simply as a notepad-style editor, but with Python (and lots of other language) syntax highlighting, etc; but once you advance, it's got project tracking, split panes, and lots of other useful features. (Note: ActiveState also has a for-money Komodo IDE, which is a more advanced version of the free Komodo Edit. As a beginner, you don't need that one). Another one I used to use was [Eric](http://eric-ide.python-projects.org/), which is a very nice IDE, but was rather python-specific, and didn't handle other language types as well.
ya rly. It was 2 spaces at one point. I don't understand why 2 spaces, as it is hard to read. They probably changed it to match PEP8.
+1, vim is the most powerful IDE for python work.
Trying to obfuscate things in general is pointless and counter productive. Everything can be reverse assembled, the moment someone with motivation gives it a shot. If your program is worth stealing in whole or in part, it will be. My company sells a number of commercial programs written in python. We release only the pyo files, and cryptographically sign it to prevent simple modifications, but anything past that ... I figure any hacker would blow past any protections I write even if we wrote the program in C. 
[The Eric Python IDE](http://eric-ide.python-projects.org/)
Oh really, for how many, we're looking for room for 4... Can you put me in touch with them?
Great! I am researching the idea this week, but I will message you as soon as I have something more tangible.
I believe [PsychoPy](http://www.psychopy.org/) wraps pyglet to produce sounds. As Notnasiul mentioned, you should be careful with timing. The good news is that it's not too hard to measure with a videocamera, etc!
&gt; and he routinely says that internal style guidelines at Google are that proper indentation is 2 spaces. Sounds like a rubyist infiltration &gt;_&gt; No, seriously, pep8 says 4 spaces, I see no reason to diverge from that, and I find that 2 spaces is unreadable.
It's a good idea to learn vim generally, and probably you can be very productive with vim and some plugins programming python, but I think when talking about an IDE, wing or pycharm are more feature rich. Especially wing is has great introspection and the interactive debugger is the bomb.
I sincerely despise Python 3.
This is true. I want to work on PyPy and I hope I will be able to do this. If I ever find out how.
the issue at hand isn't the number of spaces, (which really doesn't matter as long as it is more then 1 and you're consistent), but your mixing of tabs and spaces. By setting notepad to display tabs as 2 spaces, when I open your code in something else that display tabs as a different number of spaces, the indentation is all wrong if you ever used spaces instead of tabs. You want an editor that replaces the tab character ('\t' in the 'raw' string) with some number of specified spaces (' ' in your case). 
I was about to reply that I don't agree, but while writing I changed my mind ;-): Yes, for learning the basic syntax it's probably best to keep the additional complexity of an IDE out of the way. But once you start exploring the standard lib or even start your own little project I would recommend using an IDE. Code introspection, completion, auto-indentation, source assistance (doc strings while typing) are really useful features to help you focus on the main problems. Some IDEs like Wing (my favorite) have an interactive debugger (a python console on the current stack with code completion etc.) which is truly awesome.
Hehehe! Possibly :) But I think the old habit of hitting [F1] hoping for help is still present today, even if it's been weakened by the passage of time. Old habits die hard...
Considering you're likely going for an evoked potential of some sort, timing will be everything. It will be important to preload all stimulus material into memory. I have had good luck with [PyAudiere](http://pyaudiere.org/) in doing this, but you'll want to verify your timing before go time. I've learned that timing is very system dependent, so test, test test.
This is the only "IDE" you'll ever use or want for python.
I'd point out the obvious again: preloading stimuli, and logging everything to be sure of the timing, or recover somewhat useful data if the timing is off. In the fmri experiment I wrote last year the log files have proved invaluable for recovering from various kinds of errors due to problems with hardware.
I have a mac at home, so Komodo edit is my other "IDE". 
what? No love for pydev?
Great book, congrats.
A suggestion, use this to extract the extension of a file. basename, extension = os.path.splitext('/path/to/somefile.ext') good work. 
I think a very important fact is that it is Python. I am only doing Python and a tiny bit of shell anymore so I never liked having no Python alternative to Chef and Puppet which is why I am very happy to see * https://github.com/sebastien/cuisine and * https://github.com/sebastien/watchdog in addition to what might hopefully soon be merged into fabric's master branch * http://tav.espians.com/fabric-python-with-cleaner-api-and-parallel-deployment-support.html
&gt; Caps+ijkl for movement For some reason I never thought of doing this. Are these the same keys as Vim uses? (I know nothing about Vim).
I vote for spyder - even if you're not doing scientific computing. Spyder has a matlab-like lay out, such that you can write a script in one pane, run portions of it in an interactive shell (ipython) and then inspect any variables/structures in the variable viewer. 
Is there a good place to find the book for cheap or a place to get the pdf? This book sounds awesome and i want it!
I've tried a bunch of different IDEs but I always end up back at just a simple text editor. Right now I'm using Sublime Text and absolutely loving it.
I have my vim set up similarly but the defaults are different, vim uses hjkl instead.
vim has a learning curve that can't be dismissed. It sounds like the OP is used to working in an IDE, so I wouldn't recommend learning both Python and vim at the same time.
I agree, and I would add an additional recommendation: get a nice Python shell like [bpython](http://bpython-interpreter.org/) that will make exploratory coding easier.
Application Binary Interface: http://stackoverflow.com/questions/2171177/i-never-really-understood-what-is-application-binary-interface-abi
Yours sounds better to me. I looked at the Vim 'cheat sheet' posted in this thread and it just strikes me as unnecessarily arbitrary. I would personally prefer to build up my own keyboard shortcuts, and using a global script (Auto Hotkey?) seems like an advantage.
[The official web site](http://www1.idc.ac.il/tecs/plan.html) has large portions of the book for download.
Here's the script if you're interested: [script](http://dl.dropbox.com/u/119549/SourceryKeys/SourceryKeys.ahk) It's a work in progress.
Vim has code completion, interactive debugger, pydoc integration, and even refactoring for python... Its pretty feature rich. But I do agree you have to tweak it, it doesn't come that way out of the box.
I can't tell from your post whether you are trying to further specify something or whether you understand that you can exactly replicate your desired behavior, so I'll further clarify: Settings &gt; Preferences &gt; Language Menu/Tab Settings Tab Size: 4 [x] Replace with Space (Check this box) You have achieved your goal.
I did understand that that was possible (although I didn't before urracas post), although I didn't know the specifics. 
[The Elements of Computing Systems](http://books.google.com/books?id=THie6tt-2z8C&amp;lpg=PP1&amp;pg=PP1#v=onepage&amp;q&amp;f=false) i believe this is the same book that the person who created a vm inside minecraft referenced as a motivation for that project. edit: link fix
Komodo Edit with vim emulation turned on.
Good start. Keep going.
Any chance of posting it online in some format after the conference?
very nice! can be really useful with a little work. I'll post more feedback when I get back to work on Sunday.
I've never used type with three inputs like that before. Is there any value in using it over just defining a class?
I'm very new to Python too, programming in general really. I use Aquamacs. Is that an IDE?
Ooh? Does it have debugging support?
Vim is incredibly customizable also, so don't let default keys turn you away from using it. If you do decide to remap the keys, make sure to bind them in a "vim-like" way, where you have different motions and operators. I prefer to have all the motions on the right side of the keyboard. So (with my config) if I want to copy the next word its 'co' where c is copy and o is the motion to the next word. or select to the end of the line with 's;' where s is select and ; is the end of the line.
[My beloved east london might be the next silicone valley](http://www.bbc.co.uk/news/uk-england-london-11689437)
By all means, feel free to point out how to do things mire efficiently and pythonic
The timing will be a problem, we wanted to move away from commercial software, not just because of cost and python seems to be widely used in this area. We are out of our comfort zone so we will just have to see how it goes. Thanks
Thanks I'll look at this.
I tried pyaudiere but wasn't able to get it to work with recent versions of linux. Either it of the underlying library looks for a device (/dev/dsp) that is not on current releases.
A good point that we need to address, thanks
Sounds very interesting- near old st?
&gt; Combines imports into a single line that are defined in a row &gt; Eliminates unneeded whitespace &gt; Minimal parenthesis usage (mostly) all seem fairly useful, but the other things don't. But then, maybe this would be better as a text-editor plugin. 
Regardless of the underlying libraries (i.e. wxPython for the GUI, PyAudio for playback) you will still need to synchronize the acoustic and visual signals. Instead trying to speed up the slowest signal, calibrate the system introducing latency (a delay) in the fastest signal, so the user receives both stimuli in sync.
Start every new line of code with four spaces... This code as it is can be copied and pasted in one line.
No, not yet. It's on our list. 5.0 will focus on the GUI and hopefully will include such things.
making the code valid Python means less magic, more familiarity, and more power than most DSL's offer.
The debugger is active in the screen shot so there are more items. Also it's a very small screen size so it normally would not look like this. In addition to F1/F2 and Shift-F2 (maximize editor area), perspectives can be useful for this also -- set up the GUI for a particular task (unit testing, debugging, editing, refactoring, or whatever) and save the GUI state under a name you can switch to w/ key binding or from a menu. In any case, we try to make the GUI configurable to work reasonably with both large and small monitors. 
Ideally, yeah. Very early stages but basically, think artist warehouse, but with tech, film nights, hackathons et cetera. 
Django setup assistance for the project, some Django-specific tasks like generating SQL, Django template syntax highlighthing, and setting breakpoints and stepping through Django templates. See also http://wingware.com/doc/howtos/django
1. Bug fixes. 2. New features (new stdlib modules, etc.) 3. Faster 4. New syntax (with statement by default, class decorators, etc.) 5. The open source projects you use want to drop 2.5 for all these reasons, but they can't if most of their users are on 2.5, so help us out.
Can you elaborate on #1 and #3? That's what they'll be most interested to hear.
Out of curiosity, which versions did you try? I could run some checks to see if I can't get it to run on a linux box.
http://docs.python.org/whatsnew/2.6.html#optimizations and http://docs.python.org/whatsnew/2.7.html#optimizations Describe the optimizations pretty well. I can't think of any specific bug fixes myself, but obviously each release features a ton of them (just read the release notes).
The thing is, I would like to have the benefits of an IDE (integrated debugger, etc.) but with the convenience of Vim-like controlling. I think it's a case of me being able to learn from how Vim works rather than actually using it. Thanks for the script by the way!
Heh, I did the same thing a while ago. (Well, nearly the same thing: I plotted field lines rather than showed the field at a grid of points as you did - it was as part of a short writeup on animations of electric &amp; magnetic field lines for pedagogical purposes). If anyone's interested, [here's the video for a Hertzian dipole in 2d, quite close in](http://home.btconnect.com/geoffwoolf/files/hertzian2dsteady15fps.avi) (it's precisely one cycle, so for best results, save it to your hard drive and play it on repeat in a media player that can repeat without glitching (e.g. mplayer)). And [here's one in 3D from a bit further out](http://home.btconnect.com/geoffwoolf/files/hertzian3d20fps.avi) (which I actually don't like as much -- unlike the other one it doesn't show all the exciting near-field behaviour, as I had to use less field lines to make the 3D work; and the 3D doesn't really add much, as it's axisymmetric.) I've also got one of a pulsar (i.e. a dipole the principle axis of which is rotating around an axis at some fixed angle -- think a double cone) for which the 3D is a lot more useful as the field isn't axisymmetric. But I'm not going to show you because it would *blow your mind*.
From the recent [trip report](http://morepypy.blogspot.com/2011/03/us-trip-report-popl-microsoft-ibm.html) EDIT: fixed link markup
As for #1, there are 1482 and 2130 entries in the `NEWS` file for 2.6 and 2.7 respectively. That includes new features and bug fixes. I know that doesn't really *tell* you anything, but 2.6 has been through 6 patch releases and it's currently in security-fix mode, meaning there will be no more bug fixes, it's at the end of life. For actual details on what was fixed or added, you'd have to look in the `NEWS` file, which is 5004 lines long. Additionally, as linked by kingkilr, the What's New files contain a more concise version of that info. As for 2.7, November was the 2.7.1 release. It has obviously been around less than 2.6, but it carries all of the same features and bug fixes, plus more new stuff. My opinion is this: run all of your tests on 2.6, see how it goes, see how stable it is. Whatever your application is, put it on a test server and run with it on 2.6 for a bit. If it's all good, put it through the same steps on 2.7 and see how it goes. If you're comfortable with the results, then you have your answer. If you're considering making a move and you have the ability to do so, I encourage you to investigate it. Sure, you could run on 2.5 for 50 more years and everything will be wonderful, but you can likely do better, you just have to look before you leap.
Another one to try in Windows:Pyscripter . Pretty good light IDE, better than Idle IMO. You could use the command mode inside. It include a debugger.
1. attributes 'file' and 'dir' are poorly named; they are builtin values, but not shadowed in your case because of the class namespaces. you should change their names. 2. you usually don't need to set attributes in a class definition if you're also setting them in `__init__`. 3. method names beginning with capital letters are just... jarring. try to follow PEP 8 if it suits you. 4. you call `self.file.write` a lot, and attribute lookups are fairly expensive. try setting a value like `write = self.file.write` and using that instead. 5. i see no reason why to put double underscores in front of some method names. if there isn't a good reason, remember one of the Python philosophies, "we're all consenting adults." 6. `input` is another builtin. you should avoid it using that as a value name. 7. other than my minor picking of nits, very nice! 
"Any editing, reproduction, publication, rebroadcast, public showing, internet or public display is forbidden and my violate copyright law." No internet showing, huh?
Anecdotally, I can tell you the analytics app I work on is significantly (~30%) faster on 2.7 than 2.6. 
If you're gonna move now, I'd start looking at porting to 3.2.
Large if/else constructs can be replaced by dictionary lookups. For example, much of the code in WriteAritmetic can be cleaned up with judicious use of dicts like these: binary_ops = { 'and':'&amp;', 'or':'|', 'add':'+', 'sub':'-'} unary_ops = { 'neg':'-', 'not':'!' } comparison_ops = { 'eq': 'JEQ', 'lt': 'JLT', 'gt': 'JGT' } then you can do if arg1 in binary_ops: line = 'D=D%sM' % (binary_ops[arg1],) elif arg1 in unary_ops: line = 'M=%sM' % (unary_ops[arg1],) elif arg1 in comparison_ops: line = 'D;%s' % (comparison_ops[arg1])
one potential problem i see is that the function ThreeWaySplit takes an argument key, and on the first line you assign key to the empty string. Edit: Also, if I'm reading the directions correctly, shouldn't you be printing the values you generate in ThreeWaySplit?
I implemented the algorithm based on the wikipedia article: http://paste.pocoo.org/show/347286/ Maybe it will be useful for you. Feel free to ask questions.
Some of the highlights we got from going from 2.5 to 2.6... fix for `**kwargs` when `kwargs` contains dictionary keys as unicode. In 2.5, this was broken: &gt; kwargs = {u'mykey': 'myval'} &gt; myfunc(**kwargs) 2.6.5 or 2.6.6 finally fixed this -- most apps won't care, but we use keyword arguments a lot via URL strings and had a boat load of glue code to manually deconstruct unicode to string when needed. The `with` statement cleaned up a lot of boiler plate code we had with try/except/finally. The advanced string formatting is damn nice. While a bit more verbose than `%` formatting, it's much easier to mix/match positioninal/keyword arguments, and nested items. Class decorators again reduced a lot of boilerplate code. You could do them before, but the syntax wasn't nearly as obvious as the `@decorator` syntax.
Unfortunately, the majority of the libraries we work on don't support 3.x, otherwise I'd love to.
Thanks for pointing that out....and yes you are correct about printing the value...I forgot to replace it before pasting it in....thanks for the feedback. 
I am going to take the next hour to go through this and comprehend what you just did there....but thanks so much for the feedback....this will def help. I'll probably be asking a question or 2. Thanks again! 
For starters if you're not keen on 3.2 I'd be going with 2.7 not 2.6 as 2.6 is EOL, and 2.7 is the same thing but better. 2.7 actually is a good tradeoff as many of the language features in 3.2 are also in 2.7 as they got backported; so you get the benefit of maximum library support (not everything has been ported to py3k yet) plus dict &amp; set comprehensions, views, extended context manager support (and the 'with' keyword), print as a function (forward-compatible) and str.format(), plus all the module updates (collections, argparse, ttk, elementtree, unittest, ...) and the thousands of other bug fixes and performance improvements (new i/o system, some improvement to the GIL, etc) Some of the new language features and module improvements can also make the code more readable and hence easier to maintain (reducing perhaps the largest cost in software development) Python has been designed so that multiple versions can coexist on the same system, so you can easily retain 2.5 while testing 2.7 or better. 
It's a link to a post with a different solution, not a self post or question....
I use vim with pyflakes and [indent-objects](https://github.com/vim-scripts/vim-indent-object) for python and it's awesome. Check out [Conque Shell](https://github.com/vim-scripts/Conque-Shell) with ipython - you can open an interactive shell in a tab, split, or new buffer! 
I think IDEs are a lot less useful when you're working with dynamic languages. All they can really give you is the equivalent of the output of a lint tool, plus "best-guess" completion. On the other hand, I wouldn't even consider using vim with Java, for example, even though I use it for everything else. BTW - vim actually has multiple completion modes, you can set it up per-language to complete from tag files and custom functions. But it is a bit of a PITA.
Definitely agree on lxml. If you're pulling out the same data every time, I'd look into using [XPath](http://lxml.de/xpathxslt.html#the-xpath-method) - I've found it makes parsing XML much easier for certain tasks and results in more readable code. YMMV though.
I don't mean to be offensively ignorant, but what the FUCK are you guys talking about? 
Unless you've got loads of compiled extensions which need rebuilding, what's the reason to *not* upgrade? 2.6 and 2.7 are backwards compatible so you should not need to modify any python code. v2.7 is the "springboard" from which you can plan porting to 3.x. Many 3.x features have been back-ported and where there is new syntax in 3, 2.7 support both old and new, giving you a migration path.
True enough. I just remembered that [this guy had done some cool physics demos with it](http://www.visualrelativity.com/vpython/) so I thought the OP should take a look at it.
A friend of mine posted this out on facebook. Not sure if it's any use to you? http://www.gumtree.com/london/66/74951766.html
Thanks for looking, I'm using recent versions of ubuntu, 10.x. Linux dell3 2.6.35-27-generic #48-Ubuntu SMP Tue Feb 22 20:25:46 UTC 2011 x86_64 GNU/Linux pyaudiere-0.2 libaudiere-1.9.4 running it: In [2]: audiere.get_devices() Out[2]: {'null': 'Null output (no sound)', 'oss': 'Open Sound System'} In [3]: audiere.open_device('oss') /dev/dsp: No such file or directory There are similar reports on ubuntu forums with no resolution. 
Hi, I'm going solo from London. Would be great to meet other chaps :)
Microsoft still hasn't fully understood what internet is about :)
Very interesting, thanks for posting! It's very nice to have detailed explanation of what pypy is about, with good explanations to put things into context for the non-specialist I am.
Moving to python 2.6 or 2.7 will make it easier for you to transition to python 3. See the [porting guide](http://docs.python.org/dev/howto/pyporting.html): &gt; While not possible for all projects, if you can support Python 2.6 and newer only, your life will be much easier. Various future statements, stdlib additions, etc. exist only in Python 2.6 and later which greatly assist in porting to Python 3. For more immediately useful reasons, read the "what's new" for [2.6](http://docs.python.org/whatsnew/2.6.html) &amp; [2.7](http://docs.python.org/whatsnew/2.7.html). It probably won't take much effort to move to 2.7, the only difficult part might be reinstalling or rebuilding any C extensions you use.
I would possibly be interested in this. I currently work from home, but wouldn't mind a place I could go to work from a few days a week. Pricing will probably be a determining factor. Anyway, let me know if you get this off the ground.
I too work from home here in London (although I work in affiliate marketing/seo not as a programmer) and have thought about getting myself set-up into a part-time office space to improve productivity. The only issue is that I would realistically only use the space a few days a week. So, if after finding a (or several) full time partner(s) you still have some space left over, I may be interested in some sort of part-time arrangement, depending of course on cost.
The code for controlling an Arduino with python is here: http://www.stealthcopter.com/blog/2010/02/python-interfacing-with-an-arduino/ Ideally I'd like to treat it like a USB device, instead of sending characters blindly down the serial pipe, using something like pyusb.
lag as hell
&gt; For example, omnicompletion simply isn't in the same league as intellisense like IDE completion. It'll only know a completion if the file for that method or variable is in a buffer from what I can tell and is fairly poor at completing library methods. That's a limitation of Python more than a limitation of vim. PyDev's completion is no better than that of ropevim. &gt; It's also pretty much dead in the water (no syntax coloring, no auto indent, nothing) without a fairly extensive .vimrc that a newbie would have no idea how to set up if not just handed to them. That depends on the vim distribution. The .vimrc that ships with many linux distros, and the Windows distribution of vim have syntax highlighting and indenting on by default IIRC. And it's pretty easy to copy the 3-4 lines of vim script that would enable those if yours doesn't have it. All that said, I would definitely not recommend vim to someone starting out with any language unless they are already familiar with vim.
Thanks, I will.
Thank you. I'm looking forward to your feedback.
The arduino only has USB-&gt; serial support because that's all the FTDI chip on it can do. If you want real USB support, you need a better microcontroller. If you want a nice dev board that's easy to use like the arduino, you should check out Teensy (http://www.pjrc.com/teensy/).
&gt; And it's pretty easy to copy the 3-4 lines of vim script that would enable those if yours doesn't have it. Of course, but most of the users I know who declare their hatred for vim had it recommended to them without any caveats. E.g. "Just use vim" instead of "Vim is great, you should go through vimtutor first and, here, let me get you a minimal config going."
Well, I attempted this on an Ubuntu box and I got the same issue you have. That sucks... sorry I can't be of more help!
better player here: http://research.microsoft.com/apps/video/default.aspx?id=144687&amp;l=i
I have 2 degrees in computer science from one of the top ten British universities. Don't fucking ask me whether I've used Google. Do you not understand that the opinions of a group of intelligent people are worth more than some dumb algorithm? 
Was certainly fascinating. I didn't realise that pypy was being developed with the aim of the VM underneath it being language agnostic.
with statement is worth it alone for db transactons, file operations, etc. even debian stable has 2.6 included.
That's not exactly the case. The PyPy Python VM is python specific, however the translation toolchain (the thing that turns RPython code into a binary) is language agnostic. So we can take any interpreter written in RPython and automatically apply a JIT to it (so when you download the PyPy Python binary you actually have 2 JITs, one for Python and one for regex).
\3. Is testing iframe/frame heavy sites easier (with selenium it's a bit too complicated) ?
Is there a benchmark that tests pypy's regexes? How fast are they?
I don't know that we have any benchmarks that specifically test regex, however a few of the benchmarks in our regular suite invoke regexes (and might even be bottlenecked by them), here are the ones I know off the top of my head: http://speed.pypy.org/comparison/?exe=2%2B35%2C1%2BL&amp;ben=6%2C10%2C12&amp;env=1&amp;hor=false&amp;bas=2%2B35&amp;chart=normal+bars
Hey Carinthia: Thanks for this. Just so you know, there is also /r/django
Can anyone play the video from Linux? What plugin?
Yeah.. I did a bad job of wording my parent comment :) I didn't really expect anyone would be working on a language agnostic toolchain. Will be interesting to see how things progress, both with PyPy itself and with the possibility of other languages using it.
I think that 2.7 uses 3.1+'s C-based I/O routines - so you will get a performance bump there.
+1 for texteditor. They are best when you're starting out so you can really see how the language works.
Try web2py. It offers a downloadable package for Windows that includes everything you need to run a database-driven web site right from your windows box. Then when you get some learning under your belt you can deploy to a cloud or shared server somewhere. And learn more about packages and stuff. It's really a great way to start with Python for web development. Also, the web2py docs include a chapter that summarizes the basics of Python.
[from pycon blog](http://us.pycon.org/2011/blog/2011/03/03/welcome-qnx-and-thanks-all-our-sponsor/): &gt; QNX will directly support Python in future products. Similarly to how we have participated in open source tooling with Eclipse, we plan to invest in developing Python, both for utilization within QNX products and in open source contributions back to the Python community. To that end, we’re interested in hiring Python developers and working with companies who do Python work.
So short...
Yay! Jython 2.6 development starts)
If we are going to pull in other components I can do it in two lines: #!/bin/bash /usr/bin/firefox 
He went over this. Sure, the rendering is done outside, but he produces a decent amount of ui on top of that, in few lines of code.
It'll just take some time and a little after that everything will be just fine, everything will be alright ♫ For example I was pretty excited to learn that numpy has finally been ported. That in itself would have pended pretty much every graphing library in existence. Moving to 2.7 now would give you some time to re-write to the current Python standard (e.g. print-as-a-function) while the other dependencies play catchup, so when the timing is right you can shift to 3.x pretty seamlessly. BTW I went through ActiveState's pypm repository the other day and the sheer number of libraries that don't matter any more is astounding, e.g. people's own personal implementations of what is now included by default in Python. Hopefully some of your dependencies may fall into that category.
128 lines of code, 22 megabytes dependency and shit. How about 2 lines, only need standard python runtime and library? import webbrowser webbrowser.open('http://reddit.com') 
all I can say is that I have tried windmill twice on 2 single page apps and both times whatever js initialization windmill needs to take place in the browser is defeated by the js gwt initialization. I would love to make it work rather than bring selenium into our toolbox but I have not managed to figure out how.
Right, because that doesn't require a web browser.
&gt; Right, because that doesn't require *installing an extra* web browser. FTFY
RTFA: "I always suspected that if you assumed PyQt was part of the base system, most apps would fit in floppies again." Things have contexts. And in any case, compare it to, say, Arora. It also uses Qt's webkit and is ... 1MB!
Might be useful for learning purposes.
FTA &gt; What I liked about that 42-line browser was that it was not the typical example, where someone dumps a Webkit view in a window, loads a page and tries to convince you he's cool. That one is only 7 lines of code:
Yeah, I'd definitely be up for helping out, sounds awesome.
It creates an iterable class that deletes its own .next() method while iterating over it, then causes the python generator algorithm, which is implemented in C, to iterate over it and triggers an error (or performance optimization) in the C code resulting in a segfault. Very evil, indeed. 
I've not been following closely. What are the major features of this release? 
Wish I'd known about this 3 months ago. :P This is fantastic. $570 for PyQT is way too much money. I went with wxPython. I'll do my next project in PySide.
Check here: http://docs.djangoproject.com/en/dev/releases/1.3/
Looks to me like most of the UI that he's providing is actually functionality that is provided by the WebKit component. His lines of code are just enabling the features one by one.
I'm getting kinda fed up with these "Look I can import the lib and do complex stuff in a single line". I mean yes, it was cool the first few times, but it just get's old. That's what libraries do, folks. Besides that, I think I'm going to extend [HQ9+](http://www.esolangs.org/wiki/HQ9) into HQ9+W with the command W, which reads the input, interpretes it as an URL and displays it.
Yes and no. For example, the web view provides a signal for progress, but I had to create a progress bar and add it on the window to make it visible. It provides a way to search for text, but I had to create a line edit, add it on the UI and hook it to the search. Same for the URL entry box. In fact, the completion of the URL is actually kinda tricky! (look for QCompleter) The parts that are used as-is out of the box are the toolbar buttons.
PyQT cost $570?
You are buying 1 PyQt commercial license at £350.00. That is about $518 at the current rate.
This is nice to know, and the PySide team are to be congratulated on their hard work, but I notice that [bug 693](http://bugs.pyside.org/show_bug.cgi?id=693) is still there in 1.0.0. Maybe it's not that important, but I do get worried when I see things like RuntimeError: Internal C++ object (PySide.QtGui.QColor) already deleted. *** glibc detected *** (program name here): double free or corruption because memory corruption errors can be a real pain to find :-( Note that I don't get these errors with PyQt. This could either be a genuine bug, a misreport by PySide, or something that happens with PyQt but which doesn't get reported. Not sure which it is at this stage, but the PyQt version is Out There and no-one's reported any issues.
The link title may be a little misleading. IMHO, it should be PySide 1.0: Python for Qt released! I've been using PySide for some time and it is working fine. However I did only small projects for myself
Sure - there're other crasher bugs as well. However, all of them were reported after our rc1 release, and we had adopted the policy of only fixing regressions and really critical bugs between rc1 and final, to ensure as high quality as possible. Also, I'm not sure whether the comparison to PyQt is completely fair - they don't have an open bug tracker, so you really have no way of knowing about their issues.
You only have to pay for commercial use, which is totally fair considering how much you benefit from using the probably best application framework with the most productive programming language. I think it's worth the invest (over GTK or wxWindows wrappers). I mean, you don't sell a proper application for a couple of dollars ... 
&gt; Sure - there're other crasher bugs as well. Okay, but to me quality implies no crasher bugs ;-) or at least where you can work around them. Don't get me wrong - I'm not dissing PySide at all. It's just that I can't release with PySide while these sorts of issues remain, if only because I'd want to avoid lots of support calls :-( But I do internal tests with both PySide and PyQt and will continue to work with both. &gt; I'm not sure whether the comparison to PyQt is completely fair Sorry, I'm not trying to compare the two - it was just an observation and data point, as the code of my program is exactly the same other than where things are imported from. The lack of a public bug tracker for PyQt is not a factor in the sense that I didn't find the bug because of PySide's public tracker, I came across the bug in practice with my code. IMO it's a plus point for PySide that you have a public bug tracker. Like I said, there could be similar bugs in PyQt which are not being detected or reported.
This is great news. Thank you guys! There has been a lot of talk about the future of Qt at the Nokia forums, as Nokia has choosen Windows Phone 7 as their main plattform. We should not forget that Qt is also (mainly) for desktop apps. I hope Qt for the desktop and PySide will still get some love without the prospect of being a plattform for mobile apps for bazillion of Nokia phones.
It's not Python but I had fun doing the same excercise in Lua with the luakit browser framework: https://gist.github.com/855103
&gt; It's just that I can't release with PySide while these sorts of issues remain OK, a fair point. Rest assured, though: all known crasher bugs will be fixed in the 1.0.1 release. :-) The rationale for focusing on fixing only regressions between rc1 and final was that regressions break existing code, while newly unearthed bugs "merely" require a workaround or, in worst case, prevent some functionality. The inflow of new bugs was low enough and the feedback from the community was sufficiently encouraging that we felt safe to do the release now. It's certain that new bugs are still to be found, but the PySide core dev team has done a tremendous job at fixing them, and we'll continue making frequent bugfix releases in the future.
&gt; all known crasher bugs will be fixed in the 1.0.1 release. :-) That's great news :-) &gt; PySide core dev team has done a tremendous job at fixing them Sure - it's shaping up very nicely. &gt; we'll continue making frequent bugfix releases in the future. I'll throw in my $0.02 to help where I can by submitting bug reports when I find problems.
&gt; I'll throw in my $0.02 to help where I can by submitting bug reports when I find problems. Much appreciated! We want to have the outstanding bugs fixed as much as the next guy!
Awesome guys!
I'm still confused as to why the PyQt folks didn't change their licensing when Qt did. PyQt has been awesome, and I continue to use it for Python 3. But with PySide, it's only a matter of time until PyQt becomes irrelevant.
If you want a non-GPL'd version, apparently yes.
VIM is the path to master hackery.
There aren't a lot of huge features; the focus for 1.3 was polish and lots of little improvements. There've been an astounding number of bugs fixed since 1.2 — over 8,100 closed tickets thus far — and the vast majority are small improvements and bug fixes. There are a few big-ticket items, however: * [Class-based generic views](http://docs.djangoproject.com/en/dev/topics/class-based-views/) * A new contrib app for [better handling of static files](http://docs.djangoproject.com/en/dev/howto/static-files/) (i.e. CSS, JavaScript). * [Configurable on-delete handling](http://docs.djangoproject.com/en/dev/ref/models/fields/#django.db.models.ForeignKey.on_delete) for foreign key fields. For the rest, see [the release notes](http://docs.djangoproject.com/en/dev/releases/1.3/). 
PyQt is a one man show. The creator and maintainer has probably spent years of work in the wrapper and makes (at least parts of) his living with PyQt. That's a different situation compared to Nokia. 
Good news ... one more week then it's time for putting goodies at http://code.djangoproject.com/wiki/Version1.4Features :)
Can anyone explain some of the larger differences between PySide and wxPython? I was working on a small project and learning python using wx, and it's been progressing amazingly fast thanks to elixer and SQLAlchemy. For my next project, what sort of requirements might make me want to leave the simplicity of wx for PySide?
depends on how long each line is
Qt
Does Qt Creator support Python/PySide yet? I just installed it, and I still only see C++ project options listed.
&gt; PySide and wxPython MySide is a binding to Qt, a clross-platform software toolkit. wxPython is a binding to wxWidgets, a cross-platform GUI toolkit. The two are different enough that it's difficult to compare (for me at least). In my opinion, Qt looks better more consistently across platform than the other toolkits that offer GUI. The other tools you get are pretty nice as well. I ahve never used wxWidgets, so I am not sure how much easier it is than using Qt through Python.
Isn't Qt 1.0 obsolete? They should have done it for 4.6 or whatever the current version is. Related: Poor product naming.
Both are wrappers of c++ GUI / application frameworks. WxPython wraps wxWidgets (fromerly called wxWindows). PySide and PyQt wrap Qt, which is most famous for being the framework for the KDE Linux desktop. You could argue a lot about which is better. Both are very good, GTK is another one to mention. In my opinion Qt stands out as * it's an application framework (brings a lot of other stuff in addition to GUI widgets). * it has in addition to the usual event handling the concept of signals and slots, which is very handy. * it has very powerfull MVC support for item views (trees, tables) and graphic views. * overall performance is amazing; I have treeviews with &gt; 1 million elements; expanding all elements takes some seconds but then scrolling is smooth. * Rendering is flawless; e.g. on Windows 7 it looks completely native. * Very robust, never had any crashes. * A lot of people say it's well designed, personally I can't comment on it has I have no comparison.
No, and AFAIK there're no plans for it. But no worries, all good Python IDEs support PySide / PyQt. I use Wing IDE and have full code completion and source assistance (overloaded constructure signatures) for PyQt. Very smooth. Without it you go nuts with massive libraries like Qt.
What about Qt Designer? Some people don't like doing GUIs entirely in code.
In case you're after the graphical GUI designer (Qt Designer), there're tools to integrate the generated *.ui files with PyQt. They should work with PySide, too. I can't provide more information as I don't use GUI builders. The layouts are so smart in Qt, that I never had the urge to use one.
Okay, so I guess I can't move (at least entirely) away from PyQt.
I just found this module: http://www.pyside.org/docs/pyside/PySide/QtUiTools/index.html Also, there seem to be a tool pyside-uic; I couldn't find it in the docs but I'm pretty sure the PySide guys have provided a solution to integrate *.ui files or to convert them. 
Well google books isn't what I was looking for. They leave out sections of chapters (usually necessary parts). Thanks anyways.
Yeah but whats the point if you cant get all the chapters? Thanks anyways.
GTK doesn't look right when you get it outside of gnome. Qt looks good everywhere but gnome. Wx looks good just about everywhere, and has a large set of widgets and controls that aren't available in other toolkits.
You use Qt Designer to design the GUI, then run a command like pyuic4 on the .ui file Qt Designer creates. This results in a class in a .py file, which you then import in your python code. 
Cool idea, but ... guy has to work on his python skils. 
django source is a mess.
Which libraries are you considering? I don't have a whole lot of experience with ML libraries in Python, but last I used PyML, it was pretty friendly.
Yes, pyside-uic is the equivalent of pyuic4. One thing you need to be aware is that PySide's bindings behave like PyQt4 when you do import sip; sip.setapi('QString', 2); sip.setapi('QVariant', 2) and PySide does not support the older version-1 API bindings of PyQt. That's not a problem, though - it's better the version 2/PySide way.
I spent an hour or so looking at the source code for the ORM in django. I pretty much just started by looking at the base class for all Models. The caching makes the code harder to read. I don't know whether or not it is worth your time to do this.
It gets a bit twisted at times but otherwise than that it's quality code: readable, doesn't rely on bad practices - I wouldn't call it a mess. It's just the huge amount of code that discourages people. Just start anywhere.
wxWidgets has an impressive set of cross-platform widgets, and wxPython is a great binding for wxWidgets. But the devil of cross-platform development is in the details. I recently released a Qt-based [viewer for Python logging](http://plumberjack.blogspot.com/2011/02/desktop-log-viewer-released.html), but the initial version (not released publicly) was written using wxPython. Even though I used wxFormBuilder to design the UI (and it's a very nice GUI builder), my UI looked and behaved differently on Windows, Gnome and OS X. One trivial example: with wxWidgets, tooltips on disabled controls behave differently on the different platforms, whereas on Qt the behaviour is consistent. Why that is important to me is - when a button is disabled, I like to tell the user why, through the button's tooltip. That's a small point, but there are a whole lot of little inconsistencies with wxWidgets that you don't have to suffer with Qt. Furthermore, the Qt model/view architecture, though it appears daunting at first glance, is a real time saver. There's nothing close to it in wxWidgets. Oh, and if you need an embedded browser in your application, QtWebKit is industrial strength. wxWidgets has an HTMLWindow widget which can do basic HTML rendering, but if you want JavaScript, full CSS support you're out of luck with wxWidgets. There will be situations where wx is a better fit (footprint, licensing etc.) and I will continue to use both toolkits, choosing the best one for each project on its merits.
A newcomer ML library that I tend to like is MILK: http://packages.python.org/milk/
You could try gensim and NLTK if you are in natural language processing.
I've been keeping an eye on this situation for a while and it really needs to be sorted out. About 6 libraries have popped up and not gotten any real momentum. This: http://pybrain.org/ Has a publication in Journal of ML Research in 2010, so it looks like a good candidate, but i haven't used it.
I get that, but that just seems to emphasize my point. Qt is still selling commercial licenses, after all.
why?
Cool, now do it following PEP 8 standards.
i've used [MDP](http://mdp-toolkit.sourceforge.net/) successfully in the past.
I'd go first for scikits.learn, not just because it has very fast linear classifiers (which is necessary for most natural language processing tasks) but it is also improving a lot, and getting a lot of momentum and contributions from serious ML researchers.
Thanks for the only way I can use Python at work!
It is a project based on Flask, gevent, celeryd, gunicorn and so on. It has been under development for quite a while. Please leave some comments or suggestion if you would like. And if anyone could tell me why I am having this weird 502 error from nginx? I am using gunicorn with gevent for flask ... Thank you for your time.
i read this as pypy and i was like oh maybe i should switch to python 3. what a letdown
If you just want to train and run a supervised classifier, it's probably better to use a C++ implementation that has python bindings. I find LibSVM, LibLinear and Zhang Le's MaxEnt toolkits work fine for most of my supervised needs.
its very snakey and requires anybody that works with it to have too intimate a knowledge of how it all fits together. if you ask the django crew they will tell you that you should never have to look in there, but in practice there is always some reason you have to. every time I have to mess with the admin (yikes), forms, fields and widgets I find myself having to traverse a huge web of interconnected responsibilities and assumptions about what part is going to do what and when. so it makes the whole system quite brittle. I've used django a LOT, like thousands of hours and many complex sites and still when it comes to the widgets/fields and forms I have to do tedious pdb stepping to try to follow my poor form DATA through the snake pit. I've coded stuff of similar messy complexity, so I understand how things get that way. but bottom line: it doesn't make for a good public codebase. 
PyLab? Honestly, data analysis might be handled better in R. I've read somewhere people using Python with Twisted to handle large amounts of data and R to run an analysis. 
Choose one, train it to make a choice for you. :)
Dude, http://ep.io
I'll second this. They're in closed beta, but it's an awesome service.\ Not that I'm trying to deter competition/rolling your own, mind you.
What do you mean by secure? Here are some ideas: * Use HTTP basic auth * Use HTTPS * Use rate limiting * Force clients to make a call to authorize themselves before they're allowed to interact with the service * Make each call require a key / token as a parameter * Make each call require a HTTP header with a key / token * Whitelist the IPs / ranges that can make calls to your service * Use OAuth
Seconded.
Why not? Just jump in and poke around. However, it is a large project, and it can be disorienting to try and navigate large projects.
I saw this and was so hopeful too. Not to say this is pointless, just that I was hoping for pypy not pypi.
I expect with PEP8 it would turn into about 400 lines, so no thanks ;-)
after a little search, there is a somehow[ high definition 600 * 675](http://i.imgur.com/zcQuN.jpg) and a [funny one](http://i.imgur.com/zb9pa.jpg)
Try orange http://orange.biolab.si/ You get a visual interface and a fully documented python library http://orange.biolab.si/doc/reference/
Very cool! Thanks for posting.
It's part of Open Book Project: http://code.google.com/p/openbookproject/#Lovely_Python
Wow, stunning documentation.
I thought it would be cool to try to build and open source something that did all the things djangy, ep.io and all the others are doing. We could debate the pros and cons of control vs. simplicity forever but I stand on the side of control and independence if we can make it simple enough. Maybe it will never be as simple or as feature rich but it will allow you to choose your platform and how you want to build your infrastructure.
... that was my point. It's easy to do if you're cramming 800 things into a single line. But when you follow standards...
Just don't pick one capable of self-awareness and deception...
link for the lazy: http://scikit-learn.sourceforge.net/
Worth noting: &gt; There is a strong emphasis on speed and low memory usage. Therefore, most of the performance sensitive code is in C++. This is behind Python-based interfaces for convenience.
the only "important" part of pep8 that's being violated is not breaking lines where I am passing many arguments, which is really not an important break if you are using a reasonable text editor. I also am not using the right spaces around = and similar violations but that wouldn't change the line count. BTW: that's like saying "sure, it would be more efficient if the golfers just took their balls in their hands and dropped them in the holes, and it would result in fewer lost balls" ;-)
Um, how about the 80 characters per line part?
Did anyone else read that as "Toronto"?
Yes, the only lines that are too long are because I am passing many arguments (and some of those arguments are very long). As I said, nothing a decent editor can't help you with. Currently the only violations are that and a multiple import in one line. BTW, I added bookmarks in about 8 lines without adding any PEP8 violations, if you want to take a look: http://devicenzo.googlecode.com
imp.load_module has never closed these files, see its docs: http://docs.python.org/py3k/library/imp.html#imp.load_module What has changed in 3.2 is the addition of the ResourceWarnings
I had just recently noticed that this hadn't been completed. I'm glad to hear the move was finally made. Out of curiosity, does anyone know why this took about 2 years? I seem to recall at least initially that there were some issues with how hg behaved on Windows?
Cheers.
They had issues. Afaik particularly with commits to tags. Althouhg only 3-4 people were involved in the transition and you need to change bugtracker, continous nitegration and stuff like that.
What do you plan on using the database for? For ease of learning, I would say start with MySQL. If you need to abstract your software to work with other database types, then tackle it when the need arises.
It will just hold some data. It's just so I can learn. Nothing important
With the release 1.2 there is a SimpleAsyncHTTPClient that removes the dependency on pycurl (although CurlAsyncHTTPClient is still the default). It seems the plan is to make SimpleAsyncHTTPClient the default in some next release.
There was a big problem with line endings on Windows, something Subversion handled well. More here: [http://www.python.org/dev/peps/pep-0385/](http://www.python.org/dev/peps/pep-0385/)
AFAIK, they are waiting for the Release of Python 3.2 (20 Feb 2011) and the transition has some issue with end of line before.
You could of course use Samba in an Ubuntu VM, or a phisical Ubuntu box you have access to locally. I think there is a SshFS equivalent for Windows (it may cost money). But it would let you develop on a remote Ubuntu machine seamlessly. In any case I would recommend dev-testing on your target architecture.
Just for you, I did a strictly pep8-compliant version, with tabbed browsing, bookmarks and random other stuff, in 115 LOC: http://code.google.com/p/devicenzo/source/browse/trunk/devicenzo-pep8.py 
I'm using it as a bookmarklet in Chrome
You, good sir, are an awesome dude. Challenge completed, and I shall never doubt you again. :D
I must admit that the PEP8-compliant version's code is still ugly as hell, though :-)
... so it's *not* PEP8-compliant, then... I kid, I kid. :)
sqlite3 is built into Python ("batteries included") and is therefore easy to get started with. It's very lightweight and easy to use for even small programs. Here's a simple introduction. http://docs.python.org/library/sqlite3.html For larger projects, I would recommend PostgreSQL and the psycopg2 database adapter. http://www.postgresql.org/ http://initd.org/psycopg/ If you're using a web framework, you should try an ORM that works with the framework. After trying many, my company has settled on Django and its terrific built-in ORM -- by far the most expressive we've found; it's a joy to use. We've tried SQLAchemy several times and each time ended up scratching our heads when trying to deal with complex table joins or very large record sets. There's much flame-war bait in this paragraph so understand that this is only my opinion. We've used Zope, Plone, Pylons web2py, and Django commercially with PostgreSQL for various projects over the past eight years. I started by learning SQL but it's probably more common now for people to start by learning with an ORM. 
Mostly just people getting bogged down in real life.
&gt; Yarr! How to convert text to **Pirate** talk with Python FTFY
No line is over 80 characters anymore: http://code.google.com/p/devicenzo/source/browse/trunk/devicenzo-pep8.py
Learn about [database normalization](http://en.wikipedia.org/wiki/Database_normalization). Simply knowing the mechanics of how to create a table and whatnot is not enough if you don't want an unmaintainable mess on your hands.
I've never really worked with any large codebase that this could not be said about. 
Oh no, not another software project that uses a common English word/phrase.
With ~20 col and 1500 row dataset the window gets too big and is unusable.
Fixed
Fabric is a Python (2.5 or higher) library and command-line tool for streamlining the use of SSH for application deployment or systems administration tasks.
D'oh! Thanks
It seems you need a small patch to be able to build it: $ diff bcrypt_python.c.org bcrypt_python.c 70a71,72 &gt; char *password_copy; &gt; char *salt_copy; 76,77c78,79 &lt; char *password_copy = strdup(password); &lt; char *salt_copy = strdup(salt); --- &gt; password_copy = strdup(password); &gt; salt_copy = strdup(salt); The tests ran OK. What's the easiest way to send you the binary? Email? If so, send me a PM with your address. *EDIT*: the patch is available here: https://bugzilla.mindrot.org/show_bug.cgi?id=1830
About damn time.
Also, indexes.
If you want to learn how to work with relational databases, you should first learn SQL. Learn how to manage the database outside the scope of an application, _then_ you can worry about how to integrate it. It's a bad idea to use raw SQL inside a project. SQLAlchemy is a good way to abstract away lots of the database access, but in order to use it properly, you must first understand what it abstracts (granted, if you followed this to the logical extreme, all software engineering classes should start with a soldering iron and a circuit board, or possibly even with a chunk of silicon ore, but you can only keep so many layers of abstraction in your head at a time and it's a good rule of thumb). Good databases to start with are SQLite, PostgreSQL or (if only because of its ubiquity) MySQL. SQLite is special in that it only needs a single executable for the shell and doesn't use a server (i.e. a daemon process running in the background). In either case, as soon as you are connected to a database, they all behave quite similarly. When you got the basics down (creating tables, inserting, updating and deleting rows, database normalization, indexes, primary and unique keys) you can either jump directly into using SQLAlchemy or you can first write a small throw-away app that interacts with the database directly via SQL queries. Don't do this in practice, though; even if you know how to avoid the security risks (google "SQL injection"), it's just not the best way to do it (if you decide you don't want to work with ORMs like SQLAlchemy nevertheless, at least do us all a favour and learn about prepared statements aka parametrized queries).
Please help me understand - can you actually compile code for python without MSVC++ when you need something in windows?
There's a free command-line-only version of VC++ called Visual C++ Express. You can use that. You need to get the version that matches the version of VC++ that was used to compile your Python.
...not on reddit.
The latest master branch defaulted to pure Python implementation of AsyncHTTPClient. Also, Tornado fallback to select() on Windows. Don't hesitate to try it, it's simple and fast. =)
its asking me to register even before looking at a demo.. dont we have openID and A demo video would be great ...
&gt; You need to get the version that matches the version of VC++ that was used to compile your Python. VS2008 for the last few versions.
Actually, VC++ Express includes the IDE, but it does have other limitations. For Python 2.6/2.7, you need the 2008 version. You can download it here: http://www.microsoft.com/express/Downloads/#Visual_Studio_2008_Express_Downloads 
I worked at a large-market TV station, who had recently purchased a new weather system. The system ran on Linux, and was quite far removed from the public website. The Wx system could be programmed to spit out images based on pre-programmed templates. Unfortunately, the template-builder system was separate and very costly. So I used ctypes to write some slick Python scripts that were able to pull raw data from the Wx system, generate its own graphics, convert, animate, and export them to the public website. That was about 7 years ago. I still know my script is still running, as one of the last steps on the exported PNGs was adding a iTXT chunk to the PNG with my name in it -- and they still have my name embedded in the images. Additionally, the XML manifest file I built to announce to the site that new images were available is still being uploaded every 8 minutes on the dot, and contains the same SHA1 value of the script. The whole setup is maybe 400 lines of code total, yet drive one of the largest tropical WX systems in the south east, and hasn't changed one bit since I wrote it, aside from some configuration file changes to alter some things, like resizing a few image exports.
just finished this project with my brother: http://www.fresk.co/the-beergenius probably the funnest python porject i've worked on so far, especially because of all the 'testing' that was required to fully understand the problem domain. ;)
[cryptacular](http://pypi.python.org/pypi/cryptacular) is a nice implementation of bcrypt and compiles under windows with no issues. You will of course need [Visual Studio 2008 (express)](http://www.microsoft.com/express/Downloads/#Visual_Studio_2008_Express_Downloads).
Here is the code being typed: http://groups.google.com/group/web2py/browse_thread/thread/dee3f0f1f8c37908
Learn zodb first to get something working first. Move to sql types when you need to.
Fantastic design work. Did you do the design yourself?
yeah, my brother did the graphic design / photography, and I did the coding.
Interesting question. Work: Probably a build system I rewrote a couple of years ago. Fun tree traversals, topological sorts, parallelism, etc. Of course make already does all this, but for various silly reasons I had to reinvent the wheel. Home: Project Euler problems. I like getting to write small, sharp, standalone code. And I like learning more math.
Project Euler is the best. Without it, I don't think I'd hone my skills at functional programming
I expect to see that at PyCon next weekend. Don't disappoint.
How to what?
@fabzter: "How to create...", "Want more?...." Think.
This is awesome! I've been bouncing between things like djangy, ep.io, appengine, or just managing servers myself. I think this is perfect :)
some of us will wear it ;)
A social web-app. Yeah, I know it sounds cheesy but it's a lot of fun (still working on it).
I actually like that the video uses "text to speech" rather than a real human narrating since the real humans who narrate programming type videos are not presenters and are horrible to listen to. It is something I would be happy to see become a trend.
Awesome artwork.
Very cool, what's the general idea behind it?
Very nice. What libraries did you use to build the UI?
Thank you for that. I was wondering.
Whoa, that's your work? I recently came across some press about it, and thought it was such a fantastic idea. Congrats!
Egads. No offense, but that seems very counter-intuitive to my experience. I've come to regret every bit of data I've relegated to a ZODB, Plone data in particular. Starting with simple relational tables will keep your life simple.
Use GtkBuilder (glade) for creating the GUI. That will save you a lot of time and code.
Sorry, but passing text to a command line app by using popen is not using python to convert text...
was just about to post the same comment, awesome stuff!
I guess whatever clicks in your head right? I don't know about plone - but getting started in ZODB was much easier for me compared to sqlite3 module tutorials they had. ZODB was just a better pickle for me.
I've done some [App Engine stuff](http://xercestech.com/app-engine-server-monitor.geek) in the past, but right now i'm having a ton of fun using Django to write a [web interface for small ARM plug computers](http://plugapps.com/index.php5/Plugapps_WebUI). I've never done python for work but I do write Obj-C for the iPhone App Store.
Touché. For sure it's best to have an actual problem to solve first rather than learning from a generic tutorial. And when something clicks, take it as far as you can. 
I worked at core security, kind of metasploit. We developed exploits
2nd. Yes, what libraries?
A while back I wrote an HTTP long polling server with Tornado, a jQuery plugin for connecting clients to it, and a Django app for sending event-triggered messages to clients via the long polling server. Now that App Engine has the Channel API, I plan to write wrappers for the channel API that have the same signatures as my django app and jQuery plugin. Then any applications I write for AppEngine could easily be migrated off without significant changes to my application level code. So far I haven't actually done anything with the framework I've put together, but putting it together was a fun project.
the best idea is to unlearn eveything you have learned from using java
I agree with your first statement. I find Python to be a much better language for a large class of work projects. So what do people in the Python community do when they want to properly implement object persistence, e.g., to/from a database? Do they just use the SQL support provided by the Django framework?
Check out [SQLAlchemy](http://www.sqlalchemy.org/) and [Elixir](http://elixir.ematia.de/trac/wiki). Python classes and objects are a lot more powerful thanks to dynamic typing, so the ORM pretty much takes over the role of what you're describing.
Probably short, simple personal projects. They make me feel like I actually have a valuable skill that is capable of producing something tangible. Longer projects are vital, of course, but they drag on for so long that I feel more like I'm being pulled along by them rather than the other way around. Honestly, very few work projects have been fun. Most of it just involves trudging through badly-written code and implementing mundane business logic. There's the occasional infrastructural improvement, which can be more gratifying. The funnest thing I can recall was recently moving a MySQL dataset into redis. This was storing a simple ID-to-ID relationship with two columns in MySQL. The disk consumption was ballooning out of control due to the exponential growth pattern of the data. It went from well over 100GB in MySQL to about 2-3GB in redis, because redis can store each relationship as a single bit. Also, because redis compresses the data when it's swapped out to disk, the long stretches of zeroes in this bit-string get compressed down to hardly anything. It's all quite CPU-friendly as well and seems to be performing well so far. There's still the possibility that the data will grow to an unmanageable size, but at least the situation has been improved for a while.
Just scanned the docs., SQLAlchemy and the Elixir layer seem to be exactly the functionality I'm looking for. Thanks! 
Ignoring my many super awesome school projects, I wrote a charting library in CoffeeScript and Raphael.JS for work. That was pretty fun.
This thing again? I know the author means well (or at least I hope he/she does), but this isn't helping anyone. If they want to help the packaging community they should get involved in distutils2 since that will become the de facto standard for many years. Whole thing reminds me of the exocet project, and just about as useful to the community in the end.
Been working on a search engine for hackers: http://www.shodanhq.com The system is almost entirely written in Python: website (Pylons), job server, search crawler (love that Python has many standard libraries for dealing w/ popular protocols) and tons of small scripts that glue information together from various sources. And the information itself I also find very fun to browse through, so it's been great to have a project that's fun to work on and then use.
Where/how is it hosted?
It probably is the most well-known benchmark about WSGI servers.
pydra.com is what I am working on now. Funnest because it involves so many servers and that i get to make lots of little sites to test it. There are a lot of problems to solve about scale which really just involves a lot of logic problem sets :) logic puzzles I think is what drives hackers.
&gt; If they want to help the packaging community they should get involved in distutils2 I think this was considered, but rejected. From [Bento's FAQ](http://cournape.github.com/Bento/html/faq.html#what-about-distutils2): *"[...] most efforts in distutils2 are peripherical to our core issues as described above, and won’t improve the situation for the scipy community."* There was [a discussion](http://www.reddit.com/r/Python/comments/clk0x/bento_a_pythonic_packaging_solution_for_python/c0tgluj) related to this on reddit a few months ago.
I use textmate, eclipse, and komodo regularly. Komodo is really great - awesome for python web dev.
Generally, that means most of the time: I agree. Especially on a low level. In this special case: Not necessarily. The question has mainly language unrelated, higher level design aspects.
Well, you need to "abstract away" the specific kind of storage you use. Someone mentioned SQLAlchemy. That's a good choice for RDMS abstraction. Django ORM is popular, too. But how about xml, object or JSON storage? If your solution needs to be really general, e.g. be able ot handle swapping from MySQL to MongoDB, you need to implement an abstraction layer on your own. By the way, when using business objects (rather than transactions directly) to work with your data, you need a good strategy for CRUD. E.g. track which objects have been modified compared to the persistent data. Or when you delete an object you have to make sure that all references to that object are deleted as well. Then all objects that held those references are modified and their corresponding persistent data needs to be updated too. I wouldn't copy this Java stuff "class by class", but I think it gives a good overview of what needs to be done for a certain abstraction.
[Here is a discussion](http://www.reddit.com/r/Python/comments/es7g7/diving_in_to_python_from_java_what_should_i_know/) from two months ago about getting to Python from Java which expands on your point plus lots of other good pointers.
Here's the soundtrack: http://www.youtube.com/watch?v=f-mPnmfrm6I&amp;feature=related P.S.: Didn't find a longer version ;-(
For a few tens of thousands of objects, XML or JSON as you suggest is probably a perfectly reasonable solution. And if the system scales in the manner we hope it will, we'll need a strategy for migrating from something like JSON file and/or MySQL to NoSQL solutions like MongoDB, Cassandra, SimpleDB, or HBase. So we'd like to sort of get that for free, or with a minimum of pain through the ORM layer. CRUD is also an important aspect as you indicated, we're still determining which portions of our schema require transactional semantics and which portions are ok with an eventual consistency model. Your comments are all valid.
Nice work.
Hosted on my own machines running mostly FreeBSD and OpenBSD. For the actual data collection I have a few dozen VPS boxes running Ubuntu with the spider crawling scripts.
Wow, this is pretty cool. Tell us more... 
wow amazing -- I want one
It's a small project, but I'm working on a website that shows a new Chinese character each day, to help me with learning Japanese (the Japanese language uses lots of Chinese characters). [KanjiToday](http://www.kanjitoday.com) Mainly what I had to do was, parse out two different dictionary files (one plaintext, one XML), store the data in a postgres database, write a script to pick a random character, and then have cron run that script every day at midnight. I'm also using the syndication framework to make an RSS feed, and I think I'll work on something that tweets the new character every day. It's been fun since I've never had a live website before, and my two main hobbies/passions are Japanese and computers. I wasn't really satisfied with the current options for daily kanji (the first result for "kanji of the day" on Google is covered in ads and not very nice looking), so I'm happy I'm working on something that I will actually use.
You have to remember that the Zen is pretty old. When it was written, Python was still recovering from the time when it was impossible to do closures. That said, the basic underpinnings of Python are still just a bunch of dictionaries that get tossed around in crazy ways.
ok so... now... we're going to click this button right here... *breathe into microphone* I'm not sure what it's called...uh... um. Anyway SO.
Still, seems like namespaces thing is the only part of the Zen that isn't relevant now... But okay, anything has its own imperfections, and explicit imperfections are better than implicit ;-)
I tried a simple example with Python 2.7 on windows and it worked fine. Tried the same example with the standard Python 2.6 installed with MacOS 10.6.6 and I got the following: iMac:Documents michael$ ./testpyside.py Traceback (most recent call last): File "./testpyside.py", line 4, in &lt;module&gt; from PySide.QtCore import * File "/Library/Python/2.6/site-packages/PySide/__init__.py", line 2, in &lt;module&gt; import private File "/Library/Python/2.6/site-packages/PySide/private.py", line 2, in &lt;module&gt; from QtCore import __moduleShutdown ImportError: dlopen(/Library/Python/2.6/site-packages/PySide/QtCore.so, 2): Library not loaded: QtCore.framework/Versions/4/QtCore Referenced from: /Library/Python/2.6/site-packages/PySide/QtCore.so Reason: image not found iMac:Documents michael$ This is with the following code: #!/usr/bin/python import sys from PySide.QtCore import * from PySide.QtGui import * app = QApplication(sys.argv) label = QLabel("Combat 4") label.show() app.exec_() sys.exit() Anyone got any ideas? *EDIT for formatting of code
Solo traveler from germany here, will arrive at heartsfield in the evening, lets meet for a beer in the regency!
Yup, honking great idea. Laziness would be another one, yet totally impracticable for Python.
It's not about variable namespacing, usually known as "scoping". It's about module namespaces, and the ability to import modules into hierarchical namespaces in your code. E.g. import x import x.y import x.y.z as z_shortcut ... x.function() x.y.other_function() z_shortcut.third_function() This allows explicit[&gt;implicit], obvious references to what code you are using. It's as opposed to the Java/C/C++/C# way of include/import/using where everything is imported into the current namespace in a collision management mash-up nightmare. edit: grammar
scoping != namespacing, see my other response :)
Hey guys! Let's seal a plan and all go out on a pub crawl thursday/friday night :)
I recently made a web framework. I realize there's already a million of them, but I wanted to make one myself for the experience. It also has a simple template system that supports python expressions (in most places, anyway).
And a very debatable one: http://www.reddit.com/r/Python/comments/be1q1/benchmark_of_python_web_servers/
Not sure if it's the most fun Python project I ever worked on, but one of the rare projects I actually use now for myself. I'm an avid reader of [Fanficiton](http://www.fanfiction.net/); One thing that really annoyed me though is that I didn't have some kind of watchlist for the stories I'm reading, which would then automatically get converted to \*.mobi files once a new chapter was released and sent to my Kindle e-Mail address. Well, you couldn't really expect that from the site itself, so I took it into my own hands. What the resulting script does is basically read a \*.ini file containing the unique story IDs contained in the URLs, adding a bit of metadata to the \*.ini file about the story to make it easier for me to recognize the entry and keep track of the metadata. I execute this script with cron every 30 minutes, it then scrapes all the stories contained in the \*.ini file, checks the local chapter count against the external chapter count, and in case the story got updated, caches the new chapter(s), assembles them into one huge HTML-file specifically formatted for the Kindle and then sends it. At last the chapter count in the *.ini file is increased. Doesn't work too great on Linux though, due to problems with encoding – works now, but not perfectly, I currently run it on my VPS.
And you have no problem with this one: &gt; Although that way may not be obvious at first unless you're Dutch. ? Maybe it's time to update [this PEP](http://www.python.org/dev/peps/pep-0020/)...
http://vim.sourceforge.net/scripts/script.php?script_id=663
paster is the default in pylons? /fud paster is recommended for development as a convenience since you can bring it up with --reload and your file changes will take effect immediately, it would be insanely stupid to put that into production though. 
It's telling you that in Python you can easily tell the difference between Thread, Thread, Thread and Thread by the fact that one lives in the namespace "concurrent", one lives in "email", one lives in "Scientific.Physics.PhysicalQuantities" and the final one lives in "goblin89.textiles" You can't do that in a lot of languages which only have global namespace, which results in horrible hacks necessary to work around this. Oh, and its also for lulz =) That's the beauty of Python - useful AND funny. 
When the Japanese build a garden, they always make sure to leave [some minor imperfections](http://en.wikipedia.org/wiki/Wabi-sabi) here and there. It's the Zen of Python after all.
What do you have against [Dutch computer scientists](http://en.wikipedia.org/wiki/Edsger_W._Dijkstra)?
But "abstracting away" can be done incrementally if you're primarily hoping to maintain some adaptability for future requirements. You can start with separate classes for persistence that do little more than run your SQL, potentially through an ORM, then later abstract it even more if necessary. That avoids spending too much time up front having to think about XML, JSON, etc - and different kinds of transactional models. And I made the point about ORM's being optional for a reason - for very small apps, they can be a distraction. For apps that need to get the very best speed out of complex analytical queries they're a limiting factor. For just about everyone else they're great of course.
And quite a dated one, almost a year old.
A quick example of something which does not adhere to that line in PEP20: from mymodule import * Here you are basically ignoring python's namespaces and importing everything from some module. This is mitigated some by use of dunder-all but even then I prefer to import explicitly (explicit is better than implicit).
You'd better let the Reddit and Quora guys know: http://www.quora.com/What-are-the-advantages-of-using-Paste-instead-of-Apache-nginx-as-a-Python-web-server 
Maybe I'm just incredibly boring and narrow minded, but I don't see how the benefit of having lots and lots of different ways to specify where to find your main method outweighs the pain of having to look at all those places trying to figure out just where the code that is being executed lives. I have a co-worker who insists on monkey patching in chunks of code into classes defined in other modules, e.g. he patches up the user class with lots of statistics related methods from the statistics module. He insists that it makes more sense to put all the code related to statistics in one place, regardless of whether the code in question is a method of the User class. The problem is that I regularly end up spending a minute or two grep:ing the entire source tree to figure out just where he happened to define that specific method. Hate.
Yes. OP, the way other these other languages import modules is roughly equivalent to from x import * Using this method is frowned upon by experienced python programmers , because it may cause name conflicts.
In Firefox 3.6, I get a blank page with "[object Object]". What should I be seeing? I do have some talks bookmarked.
Turtles all the way down.
The Zen of Python is more about the design **of** Python itself (the language) than about writing code **in** Python. There is some overlap, but the difference should be kept in mind.
The speed of query execution is not affected whether or not an ORM is in use - the simple and complex query are both just SQL strings passed to the cursor's execute() method. ORMs have a speed hit in fetching rows, and some ORMs have a speed hit in that they limit the range of possible queries that can be emitted (so perhaps this is what you mean). An application that uses complex analytical queries is exactly the app that *should* use an ORM the most, so that the complexity of constructing and maintaining those queries can be managed. I can write heavily nested queries with a SQLAlchemy query much faster than I can with straight SQL (with the usual disclaimer that I wrote SQLAlchemy).
I've always thought it was a reference to how ubiquitous the dict-as-namespace implementation strategy is in Python, and how useful that proves to be. &gt; One of the things that makes it interesting, is exactly how much Guido has managed to exploit that one implementation trick of 'namespaces'. &gt; &gt; Steven D. Majewski, 17 Sep 1993 http://quotations.amk.ca/python-quotes/
Thats weird, firefox redirects when you do it... You can do: javascript:$($($($('.bookmark')).parent()).parent()).empty(); alert(""); to get it to work... Annoying.
Not really up my alley, but thanks for open sourcing this!
Very strange, but that does work, thanks. Running just the code from the Firebug console also works, so I'm not sure why that redirect is happening.
Well, I thought that one is surely for lulz...
Yes, thats why I said "again" :-) Just because the option was considered and rejected doesn't mean they aren't wrong. 
&gt; It's as opposed to the Java/C/C++/C# way of include/import/using where everything is imported into the current namespace in a collision management mash-up nightmare. The most annoying thing for me so far in Objective-C! *Now* I get it. (Yes, I thought about scoping at first...)
Already there! As for what to do with my time... I'm writing my talk ;)
what is your talk on? any how's the weather down there?
Given a specific run-style there is still a very small number of places that code can be (at most you need to search sys.path to find the module). As for the use of everything other than `python main.py`, that requires that all the needed code be setup in the current folder which is inconvenient from a packaging perspective. These allow apps to not worry as much about shipping console driver scripts themselves.
Good work!
I just about wrote that you might want to post this in /r/finance then decided to look up what MTGO was.
I arrive tomorrow night :) 
Please consider that people behind bento have tried fixing distutils before: I have been working on numpy distutils extensions for several years, and other people smarter than me tried and failed before that. The consensus in the scipy community is that anything short of a fundamental redesign will not improve our situation - bento is my attempt to do just that. Time will tell whether it is a good solution or not, but bento already has features such as waf integration which are very difficult to do with distutils (I know because I have done something similar in the past for numpy).
why was this down voted so much? 11up/15down votes - I enjoyed it :)
I'm not concerned about the speed involved in fetching rows as much as the limitation on sql functionality. You don't normally see this in simple CRUD applications - even if they're huge apps with vast amounts of data. But if you're doing analytics on large amounts of data then you might really want to use features such as: * table functions aka parameterized views * temp tables with common table expressions * recursion with common table expressions * temp tables * olap functions Our developers are writing adhoc queries that might need to become canned views on dashboards and are crunching anywhere from millions to billions of rows, ideally in seconds. That's a hard performance challenge, and one of the best ways to succeed is to really understand SQL, and have the database do most of the work. Hadoop isn't an option since we want fast query times and don't want to have to buy 100x as much hardware. And letting the ORM decide how to assemble the SQL isn't an option since either it won't support the feature or it will produce SQL that the optimizer will make poor decisions with.
You can still do laziness, just not implicitly (e.g. Haskell). Generators and itertools FTW.
I live in ATL so I'm already here but definitely going to be at Pycon! :D
They will be in source history forever though :-) VCS 101... (which applies equally well to a DVCS like git) The passwords are known now. The OP needs to just change them at this point.
Hells yeah! I fly out tomorrow, put me down under "super excited".
Nope, not with some git magic : http://help.github.com/removing-sensitive-data/
And what do you have to say that further fragmenting the already tenuous Python packaging world is entirely unhelpful? Maybe someone should rethink why NumPy needs such a complex build system?
" proxied by..." in case you don't get it, or anyone else here who's up voting you for no reason. the link you give implies that it's behind a proxy if it's being used at all in production. that's a load balancing technique. load balancing is necessary because paste.httpserver is not meant to be used in production. now, since reddit is built on pylons it uses paste most likely and the part it probably uses is the piece to create a wsgi app from an ini file. but what gets the requests to the wsgi application can be anyone of the http servers mentioned in the above article. 
... but of course.
I'll be there. Arriving Thursday night.
I'll be there. Arriving Thursday night.
"So yeah, I'm gonna go ahead and click this now.."
&gt;I slung Java for many years before I started with Python I'm sorry
 Not being Dutch, is like having a crutch.
Your definition of imperfection is paradoxical.
my experience is plenty of people new to python have been confused by the whole 2 vs. 3 thing. it's unnecessary overhead for someone who is new to it. They download the latest and find a tutorial and get caught up in the differences but don't understand that it's python 3 vs. what they are reading in python 2, they get an error that isn't what was expected what they were reading. they give up and go back to java. YMMV
Flying out from SF at ass o'clock on Wednesday morning!
wish I could go
MTGO: Magic The Gathering Online, for those who don't want to Google.
I recommend you learn the following: * data structures (the concepts that the college level courses of this name cover) * how programmers use and parse flat files (or pickle) * relational database concepts * object oriented database concepts * read the mission statements of a few different ORMs, they are very different then think about if you are doing it for personal understanding, hobby, or money. At that point you will know which part to pursue. Using abstractions like sqlalchemy without understanding how the database works scares me. From your statement it seems that just pickling an object for persistence would more than meet your needs.
No, it's too late for that. As soon as people have seen the compromised passwords, it's too late. If it was just on his local Git repo, then doing some magic before pushing to github would work. But it's too late now; he must change his passwords.
Pickled objects are fine then. If you need portability then use text (think csv), json, or xml.
+1
Heading down on Wednesday. I can't wait! Anyone else here part of the TiP community?
you can edit your local repo, delete your github repo, then recreate and re-push. 
Testers, ya'll are crazy.
That mean you're not coming to the Open Space, Brant? :)
And none of that matters, because people have already seen his GitHub repo with the passwords in it.
Indeed, thought the info might be useful for people in future.
Haven't been since 2005 but I"m too busy with projects to go this year :-(
I'm coming in Thursday night, representing Chicago's own Narrative Science.
I shall be there. I had a great time last year, and I'm really looking forward to it this year.
i asked the exact same question somewherte before, never answered
I'll be there, flying in Thursday night. And as for things to do, you won't lack for things to do at PyCon. There are open spaces happening into the late evening, and always impromptu groups getting together to go out, play board games, dance, drink, etc. It's a great time and one of my favorite conferences.
Same here! OK, actually, I live a little north of ATL ...
I would buy this as a poster to hang in my cube :P 
tees will be available soon to be purchased online
Flying in tomorrow.
Color me jealous, or green...
Thanks! That's encouraging
pyramid, for your purposes, consider pyramid to be pylons 2.0 and pylons to be pylons 1.0
You're all bastards..... &gt;:(
I'll be there, falling behind on work things from Fri to Thur. Extremely excited.
Already got a few folk interested in a meetup [here](http://www.reddit.com/r/Python/comments/fu038/hey_rpython_is_anyone_heading_to_pycon/). If anyone else is keen be sure to post and we will have a mini Reddit meetup :)
awesome, will a portion of the cost go to help develop Pyramid? 
I fly out Wednesday night. I would rather fly out at "ass o'clock", though.
I'd love to, especially since I'm only ~2hrs away, but sadly I cannot afford it. :(
When I have to get up at 4AM I'm sure I won't share your opinion ;-)
Dotcloud is amazing.
Even when explicitly importing your class with the help of your IDE, you can have problems. One of the most encountered one is: import java.util.Date; import java.sql.Date; You can't actually import them both in Java. If you need to write code that uses both classes (quite common), then you need to import one, and use the other full qualified name in the code. Don't you wish you could give another name to one of the two, as you can do in Python?
Ok, cool, so if that's the case, it sounds like I should consider starting with Pyramid. Would you say that's right?
Limited edition available for online purchase, http://laflamme.storenvy.com/products/66831-pyramid-not-built-by-aliens-t-shirt
For sure it helps develop Pyramid, on different levels, not just code.
Can you help make it better?
I might not be making it to PyCon at this rate. Wedding is killing the mood.
Does anybody use YAML anymore, or does JSON fill the same need?
YAML is fun except you always need a separate library for it. JSON is a javascript standard, built in to Python, and just a generally good format.
yep
Sorry if I butcher this but basically Pyramid is apart of the "pylons project" which is aiming to consolidate efforts from Pylons and repoze.bfg (I think turbogears too not sure). Pylons is no longer being developed, it's only being maintained. Pyramid is actively being developed and it's community is blowing up in size. Also, Pyramid's documentation is awesome!!!
Agreed. The only reason I'm holding off moving to Pyramid is due to 3 years and thousands of lines written for Pylons already. I believe that Pyramid can wrap a Pylons 1.0 and no doubt I'll move in that direction for a migration. But this is for people with active Pylons projects.
Flying out from SF thursday morning :D Hooray pycon.
[citation needed]
I'm presenting "The Python That Wasn't". And now, with a little Googling, you know my name! Weather is high 50s / low 60s during the day, and down in the high 30s / low 40s at night. Chance of rain. All temperatures Farenheit.
I hope videos will be all right. Last years' are great but those from 2009 suck real hard.
Same here, but luckily videos of all the talks should be posted online after the conference (as they have been the past few years). Miss out on the networking but still get the knowledge.
Like the reason I chose Sikuli for scripting the bot, I chose Github because I want to learn Git. Thanks for the alternatives though.
Yep, on the AV team again. Literally about to board my flight from Melbourne, Australia.
&gt; I believe that Pyramid can wrap a Pylons 1.0 [yep](http://docs.pylonsproject.org/projects/pyramid/1.0/api/wsgi.html?highlight=wsgi#pyramid.wsgi.wsgiapp) not sure how that would help a migration, but it is cool.
I wish! Work won't pay for it and my wife won't approve the expenditure ;-) I'll be watching the tweets though, and maybe next year it'll happen. 
I'll be arriving Thursday evening for my first PyCon! I'm pretty psyched to be speaking on Sunday!
So the poster says he is familiar with Django - how does that factor into the mix? As I understand it, Django seems to be more focused at specific types of apps such as content publishing - are Pylons/Pyramid/Repoze.bfg more for general web app development?
Also, github supports organizations. You can have an active list of core contributors. And, github's pull requests are pretty powerful. 
Do what I do, all nighter!
I'll be there
That somewhat defeats the idea of being on a sane sleep schedule so I can be awake enough to talk about C on Thursday ;-)
I can cannot say enough good things about you guys. Listen up everyone, if you see someone in an AV shirt buy them a drink. The buy them another because they kick that much ass.
Hello Mr Hastings.
I wish. Despite working only a few blocks away, I'm stuck working on a big upcoming event :(
I will be at your talk!
Count me in for a beer!
Not this year, but I really enjoyed it last year and I hope to go again next year!
I'm volunteering during registration but working instead of attending (not a python dev.) I'll be hanging out w/ you people though - wining and dining - esp w/ our member and client companies.
I recommend starting with a 12 gate into the expand, but make sure you have a solid base of sentries and stalkers or they'll just steamroll you. Oh wait, this isn't /r/starcraft ... heh.
Use [setuptools](http://packages.python.org/an_example_pypi_project/setuptools.html) and to package them and share them via PyPI. Putting the source up on [Github](https://github.com) or [BitBucket](https://bitbucket.org) is a great way for people to use and get involved with the code. Creating a setup.py is pretty simple. Look around for some [examples](https://github.com/jsocol/bleach/blob/master/setup.py) and feel free to ask questions!
are the talks recorded and viewable online at a later date?
Yep, I'm leaving on Wednesday and I'm really excited. Not only is it always a good time but I have some cool new stuff to show off too!
I'll be there as well Wednesday afternoon. First time, so I don't know what to expect.
Worth noting that the re-raising being slow is being considered a bug in PyPy ATM, so eventually it won't be an issue. Edit: At this point the re-raising bug should be fixed.
this is handy. There's something up with the C code formatting on this blog. Looks like it's getting turned into HTML entities (&amp;amp;amp;?)
Here's an [example setup.py](https://github.com/robbles/rad/blob/master/setup.py) I wrote for a little command-line tool. Look at the end for an example of how to get setuptools to install automatic executable scripts along with your package.
I'll be there doing a poster session about my book for kids and other total beginners. It's also free online under Creative Commons. http://inventwithpython.com
But then NO MORE DRINKS. Wouldn't want shit to blow up because some shit-faced AV guy thought the equipment needed a drink.
Right. I should be more precise. My statement stems from my situation, that right now I have to refactor some huge code-base where every once in a while a major reshuffling of the code is in order because of cyclical imports. This is a idiosyncrasy of Python which does not help me get the job done. I imagine that laziness would magically do away with this irk. :)
From my quick browse at setuptools, it appears to make a package that is to be installed to an existing python folder. Sorry, I don't think I made my question clear. The users may or may not have python installed. And even if they do have python, they may not have the version that I require (2.6). Is it possible to package python, along with other python libraries and my scripts easily?
Maybe it's implicit from the context for people who follow PyPy religiously, but as a Python coder who occasionally checks out PyPy's progress, it's pretty far from obvious _what_ has become 3x faster. Turns out that the blogger is rewriting a text parser as pure Python, and currently, CPython is twice as fast as PyPy and he's trying to figure out why.
Have a look at http://diveintopython3.org/packaging.html
Sounds like you need to "freeze" your scripts into a stand-alone package. The standard tool for this on windows is [py2exe](http://www.py2exe.org/), but if you're looking to do it cross-platform you might prefer to use [cxfreeze](http://cx-freeze.sourceforge.net/) which runs on several platforms. Or, if I can plug some of my own software, you might consider [esky](http://pypi.python.org/pypi/esky). It's a wrapper around py2exe/cxfreeze/etc that adds easy auto-update capabilities for your frozen app. I recommend the [video](http://pyconau.blip.tv/file/3840197/) if you're interested in getting started with esky.
I wonder why the author didn't use a [context manager](http://docs.python.org/library/stdtypes.html#context-manager-types). It seems like that would be the more pythonic route so you can just say "with Lock(/path/to/file) as l:"
I recommend taking this concept slightly further: - Package your application code as an egg - Write one or more launch-scripts which import from the egg. Build these scripts into stand-alone executables using py2exe/bbFreeze/cxFreeze/py2app etc. You can think of this as a custom python runtime environment, containing all your binary library dependencies etc. The reason for keeping your application code outside of the stand-alone executable is that this makes it easy to upgrade or replace the code (just replace the egg). Constantly rebuilding the python runtime every time you change your python code is tedious. This approach means you keep a mostly unchanging runtime while making it easy to ship updates and easy to revert between versions.
I saw it recommended in some docs regarding migration from Pylons. But good point none-the-less. We're not looking to migrate this year. We want to see how the Pyramid project develops.
This is false. PyPy is generally faster than CPython, but happens to be slower on some programs. Note that in the blog post the author says that PyPy is *faster* than CPython.
For example: Consider 5 nested loops: outer loop has range(6), then range(56), then 3x range(74) - totalling about 136155264 iterations. On my 2GHz core2 duo it takes cPython 2.7.1 about 30s - 40s depending on other tasks. cPython 3.2 it takes around 46s and is less dependant on other processes. On PyPy 1.4.1 it took less than 3s. All I'm saying is for some tasks pypy is definetly faster - may be for some other tasks it is slower. Best way to see is test it :)
Because Numpy needs C extensions, Fortran extensions and, in the future, maybe cython extensions. Numpy and especially scipy are some of the most complex packages for python. Building scientific packages is a pain in the ass with distutils, and as he said, they tried to change it. cournape: Thanks for you work (you also did numscons?) !
after a quick nap, it came to me how this would be useful. since pylons controllers are wsgi apps you could use the wsgiapp* decorators to wrap one controller from your pylons project at a time. 
I suppose that's part of what makes it Zen, isn't it?
The article is not about avoiding `if __name__ == '__main__'` because it is "ugly". Working around this is childish. The problem goes deeper. Pythons module system is an accumulation of PEPs on top of something more ancient ( and simplistic ). So one needs tricks and special knowledge to do something as simple as running a module as a script. It's not "one way to do it". 
&gt; Seems nobody bothered to mention that PyPy is actually slower than CPython. I've read a lot about PyPy and I don't think I've ever read the developers or users misrepresent anything in relation to speed. In the places where PyPy is faster, which is a lot of places, that's what's said. They are also not afraid to say that CPython beats them in a few areas. Almost all of those statements are accompanied by numbers and examples.
I don't really think this is fair. Pyramids is much less opinionated than Pylons, and the new user expirience between the two isn't that comporable. TLDR: Pylons has sensible defaults, Pyramids lets you figure it out...
No, paradoxical definitions are bad.
I would ask them to install Python. That part of the set up will be very OS dependent (and even within an OS sometimes people disagree). Unless you can use something like rfkelly's esky. If you absolutely can't say that Python 2.6 is a prerequisite, I'd do that.
Already there and looking forward to the tutorials.
Thanks, something that's really useful and becoming more and more important. The fact that it's semantically close to unittest's look and feel surely is nice. Also, kudos for Python 3 compatibility :) 
If bento is so unhelpful, there is nothing to worry about: nobody will use it, so it won't fragment the elusive unique community that everbody should follow. As for the reason why numpy needs a complex build system: it does not. It needs a *proper* one, with dependency handling, and the ability to customize compiler options. You may think that the ability to add configuration option, or customize installation paths are complex features. Yet, those are present in virtually every system out there but python, for some reason.
Yes, I did numscons (which is what convinced me that distutils was a dead end). But let me re-emphasize an important point: bento is also quite usable to package simple softwares. A few people outside the scipy community already told me that bento was the first solution that they understood and could do what they wanted
That's a great way to ensure your tools never get used. And what if the tools also depend on one or more non-standard python libs? Should end users install each of those too?
There's also [PyInstaller](http://www.pyinstaller.org/), which I can strongly recommend. It has good cross-platform support, and works amazingly well with 3rd party libs (if you have any). It's easy to use, and flexible enough to handle almost any distribution configuration.
I've ended up with driving over Friday morning, not looking forward to it.
Ah, of course, of course. Isn't the cyclical imports issue partially because of the nature of Python modules (executable code goes into a module's \_\_dict\_\_)? Would a compiled language not *necessarily* have this problem? P.S. Come on people, don't downvote someone (luckystarr) because they made a point you don't understand!
setuptools/distutils provide ways to specific non-standard required packages. It depends on your audience. If you are making tools for very non-technical end users, then the single-click executable is necessary. If you're writing libraries for developers or technical people, just saying "have Python 2.6 installed" isn't that onerous, and they can use source/yum/aptitude/homebrew/macports/whatever to install it. Odds are they already have it.
someone experienced with django and appengine apps I would hardly call a new user though. 
http://www.python.org/community/jobs/
Thanks for the tip - as a redditor (on a different account, obviously), I wanted to give the Reddit community the first crack at the position. I plan to repost to places like the python.org job board in coming weeks.
What about Djangos, CherryPys, Flasks and Bottles?
Thank you for not spamming a link to your company website. :)
| and unlike its precursors it is really liked by programmers Oh, god, that just reminded me of Pascal and Modula 2... I'd love to have had python at university.
SQLAlchemy of course supports textual SQL directly at any point as well as the definition of any SQL construct as a Python expression using the @compiles extension. But we seek to add more support for these things as built in constructs: * CTE and "with" support is one of the big features coming to SQLAlchemy in an upcoming release. The difficulty is in creating a construct that is agnostic of the very different syntax used by Oracle (i.e. CONNECT BY). Taking our time on this one until we really have a chance to think hard about it before taking the leap. * Googling the meaning of "OLAP function" generally appears to refer to window functions as used with DB2 (i.e. OVER with PARTITION BY, ORDER BY). SQLAlchemy 0.7 includes this construct as a built in component (and I'm using this one on the day job now with SQL server and Postgresql): http://www.sqlalchemy.org/docs/07/core/tutorial.html#window-functions * A usage pattern for a "parameterized view", i.e. a function that returns a selectable: http://www.sqlalchemy.org/docs/07/core/tutorial.html#functions The notion that "ORMs decide how to assemble the SQL" is a misconception that you've probably gotten from working with some of the tools out there. SQLAlchemy is nothing like that. While it has some automation features that are used to generate column lists and many kinds of joins, those features are only invoked explicitly. The contents of a SELECT statement can be controlled down to each individual detail, including compiler hints and other database-specific features.
There is no Numpy for PyPy. Actually PyPy doesn't support Python's C extensions and this is bad. Very bad. To be exact this makes PyPy unusable. Maybe it has some academic value, as a funny project maybe. Who knows?! 
[PyPy](http://en.wikipedia.org/wiki/PyPy) was originally designed as a way for Python developers to experiment with the language itself. I don't think it's really intended to compete with cpython.
A better way to do this is to register a Pyramid NotFound view that wraps the PylonsApp object entirely. Then Pyramid will always fall back to Pylons for things it doesn't know about and you can migrate a little bit at a time. Need to find time to write up a cookbook entry about it.
The company's product category is so incredibly narrow in such a specific niche market, that it would do absolutely no good to spam a link to it. On the other hand, we are essentially the only player in this market, so we have that baby cornered!
Thanks for the response - I'm looking forward to starting a project with SQLAlchemy next month. Regarding your points above, I don't think the functions that you point to are the same as a parameterized or table functions. I'm referring to the ability to write what are essentially stored procedures that return multiple rows &amp; columns, but can be referred to as a normal table. The best reference is probably Graeme Birchall's outstanding DB2 SQL Cookbook - which is freely available [here](http://mysite.verizon.net/Graeme_Birchall/id1.html) [pdf]. See page 192. Regarding CWEs - this is highly recommended functionality. We've found that they not only dramatically simplify our SQL, but give us a great tool to improve performance as well. 
I meant new user as in new to the framework. At least that's been my experience. I've tried to learn Pyramids about 3 times at this point and it's just not clicking. The doc, frankly, sucks. Sure there's a lot of it, but it's very abstract, with very little actual guidance. 
Thanks for the info. Just want to double check. Will pyinstaller incorporate my own command line excutables? And py2exe/cxfreeze/eksy seems promising as well. Do you have any opinions? How do these two differentiate? Thanks.
Sounds like a deuzy with SQL database support included. Sets it apart from Google App Engine. Only, why do people insist on offering MySQL instead of Postgres? Is it not generally accepted that Postgres offers a safer and more scalable engine? What is at play here?
I wish I had the Python experience needed for something like this. Sadly, I only get to use Python about once every few months. Good luck!
I'm sure it's not your fault. I mean you almost got the name right even.
second job posting today ... is /r/Python now becoming a job board? *plonk*
No reason python hosting should be more expensive, but not as abundant as PHP. If you have your own (virtual) server, anything is possible. Many solutions exist precisely because there is no "best" way. It depends on your demands what the best solution is. Some make it easy to deploy django apps (gondor.io, ep.io etc), others offer a virtual server (slicehost, linode). Google App Engine is built around a nonSQL database, something you could imitate (but do you need to). You need to figure out your demands.
Sorry if it's not appropriate for the board, I would just love to add more redditors to our team here. Want me to add some Python content? I can talk about scaling Twisted :-)
http://www.python.org/community/jobs/ and I favor *ligther* stuff like gevent and celery ^^
Thanks, sent a posting there.
Using CPython extension modules with PyPy is [often possible](http://morepypy.blogspot.com/2009/11/using-cpython-extension-modules-with.html) and has been for years. I don't know exactly how well this works. You're right that it doesn't currently support NumPy, though. I've seen some work done on it (at least for a subset of NumPy), but the ongoing NumPy refactoring project should help here, eventually at least. edit: The above linked article is about an old PyPy-to-CPython RPC bridge. [This](http://pypy.org/compat.html) page suggests that some CPython extensions can be compiled and used directly with PyPy. Still not enough for NumPy, but it's something. 
&gt; Long time Pythoneer Tim Peters succinctly channels the BDFL's &gt; guiding principles for **Python's design** into 20 aphorisms, only 19 &gt; of which have been written down. source: the interwebs
Surprisingly the namespaces are still relevant, since a lot of languages still lack a proper implementation.
The GAE SDK allows you to run your app on your local system. Couldn't you use that to host the site yourself if you were in a pinch?
http://jobs.github.com
Still waiting for uno (libreoffice) to be updated for Python 3. Until then it's 2.6 for me.
Writing stored procs themselves is outside the domain of a tool like SQLAlchemy, though SQLA can help organize and automate the CREATE/DROP process. The example I illustrated shows how to make SQLAlchemy consider an existing column/row-returning function, once created, to act like a table within Python code, which can also be mapped. 
How did you implement expressions in the template engine?
Right - but I wouldn't consider a table function a stored procedure. It's similar to one - but unlike a stored procedure can be easily integrated into normal sql. The upside on using them is that they're easy to write, easy to work with, and the ability to accept a parameter solves certain performance problems very nicely.
Thank you for the info and clarifying what I wanted: "freeze". remig mentions PyInstaller, which also seem good. How does py2exe/cxfreeze &amp; esky differ from this? 
What city are you in? Longmont? Could someone live in Denver and easily commute to your office?
&gt; Will pyinstaller incorporate my own command line excutables? Sure - any decent packaging tool allows you to include arbitrary files in the package. py2exe is strictly for windows. If you need to support other platforms, ignore it. My only experience with cxfreeze: it did a terrible job at packaging third-party libs (for me, Qt &amp; PyQt specifically). If you have few / no additional python packages to include, cxfreeze may be good enough. I don't know eksy, but it's a tool that facilitates updating your app distribution package. You still need a packaging tool (py3exe, cxfreeze). If easy auto-updates is important to you, then it's definitely worth looking at, along with cxfreeze.
/r/jobs, /r/forhire, and /r/work are also good places to post. I think /r/forhire has the largest community of the three.
Wonder if I'm the only person who at first glance read that as "to work on escorts video"... Definitely triggered a double take and a bit of a "WTF...?"
Thanks for this. I'm coming from a Perl background to Python, so it should be quite helpful. 
I was thinking about it, but context managers did not come around until version 2.5. I wanted something compatible with older versions.
Thanks! I did’t notice, it got beat up by the tool to generate HTML for the snippets.
Okay that makes sense. i wasn't sure if I was missing something or not.
I'd be interested in hearing more about your experience with Twisted...
Each of the template tags in the html are matched using regex. I have it so I can simply get the expression out of the tag using MatchObject.group('expression') and parse it with python's eval() function. I am wondering though, If it's possible to reimplement all this using something else rather than regex. Sometimes the endif tags overlap eachother and things get messy.
`google.appengine.ext.webapp` is built on WSGI as well. You can serve your webapp on any WSGI servers.
I've never used PyInstaller personally, but my understanding is that it's broadly similar to py2exe/cxfreeze. One advantage of PyInstaller is that it's very good at creating "single file" distributions - your application, the python runtime, and all dependencies packaged into a single executable file that users can just download and run. Py2exe has something similar but PyInstaller's is supposedly better. Since you mentioned having multiple command-line scripts this is probably of little value in your current circumstance. Esky is a higher-level layer above these, it needs to be used in conjunction with a "freezer module" such as py2exe. Currently esky does not support PyInstaller, but there's no fundamental reason why support can't be added. I just haven't needed it. Personally, I tend to use a different freezer module on each platform: py2exe on windows, py2app on the mac, and cxfreeze on linux. I consider each of these "best of breed" on their respective platforms. By using esky as a wrapper, I not only get auto-update for free but I can also write my freezing scripts against a common API, then can pick-and-choose the best freezer module for each platform.
&gt; My only experience with cxfreeze: it did a terrible job at packaging third-party libs (for me, Qt &amp; PyQt specifically) FWIW, the latest cxfreeze has been working well for me with Qt and PySide. But I have heard of it giving people trouble when trying to include Qt plugins (e.g. jpeg support). It also works well on Python3, if that's important to you. So yes, I agree that PyInstaller definitely has the edge in working well with random third-party libs. I should really look at adding PyInstaller support to esky...
Oh man, I'm doing my Master's (research-based) degree in medical imaging, specifically ultrasound and MRI. My bachelor's is in ECE. I use Python exclusively in my data analysis. If I were in a position to be looking for a job, I would jump on this. Also, another caveat is that I'm in Canada. 
Still waiting on seeing a package of python bindings for that last one, or particularly comprehensive documentation. SciPy and NumPy are fascinating, and I'm sure Quantlib would be, too, if only I could play around with it in Python and find my way around the code.
&gt; we have that baby cornered! You shouldn't corner a baby, that's when they become the most vicious and can attack without warning.
In college I wrote a program to look up anyone's class schedule. I used python-ldap to connect to the schools directory service, look up the info. I used a SVG weekly calendar module I wrote to create a pretty schedule page in svg. I used vobject and dateutil to create a iCal output of a class schedule for calendars/phones/outlook. I used sqlite3 to hold the class schedule info that I scraped an the holidays for each semester. Also re to parse the schedule output. Finally I used BaseHTTPServer to host it, because flask didn't exist yet.
A very old project. And Python only has 85.43% coverage. OCaml and Groovy have 100%. 
I thought that was the point of displaying tabs as spaces. That way if one guy prefers 2 space tabs and another 4 space tabs, that each would see it formatted the way they wanted to.
An integrated environment for developing Python in VS2010 # Advanced editing, Intellisense, browsing, “Find all”, REPL, … # Supports CPython and IronPython # Local &amp; Cluster/remote debugging # Profiling with multiple views # Interactive parallel computing via integrated IPython REPL # Support for HPC clusters and MPI, including debugging support # [NumPy &amp; SciPy for .Net](http://pytools.codeplex.com/wikipage?title=NumPy%20and%20SciPy%20for%20.Net) # Support for Cloud Computing (soon) # Support for Map/Reduce and Big Data (soon) # Free &amp; Open Source (Apache 2.0) 
see also: http://www.codekoala.com/blog/2011/follow-weighted-sorting-python/
Famous last words...
Looks very nice. IronPython Studio showed that there was a lot of promise for developing in Python from Visual Studio, and I'm glad to see more work in that area.
so someone new to the framework shouldn't use the framework? that makes total sense. it clicked with me immediately when I tried it as bfg, because the docs were thorough and the nature of the framework is to not hide requests/responses behind a bunch of opinionated abstractions and instead showed you exactly how it worked...no magic. 
Does anybody know how dropbox do it?
Is there ever going to be an IronPython 3.x?
[Nobody puts Baby in a corner!](http://www.youtube.com/watch?v=vciEDI3dD8I)
VS Express doesn't support plugins like that, right?
As someone new to programming and learning python, how would I use this? By that I mean in what situation would I find this useful? Websites? Offline programs? I'm just trying to get an idea of the tools available and when I would want to use them.
I'm here today and tomorrow, mostly for the beginner/tutorial sessions. Anybody else? 
Same here.
I'm down after sessions on Thursday -- unfortunately I'll only be attending some tutorial sessions on Wed and Thurs. :( I'll keep watching this thread, however. As far as what's near the Hyatt... The Vortex, Gordon Biersch, 5 Seasons (Train ride + taxi...) Edit: If you're coming to Atlanta for the first time, make sure you check out The Clermont Lounge before you leave!
I am here now. Still finishing my poster - so that's my free time for today and possibly tomorrow. I'm surprised this isn't getting more play on Reddit... would have thought there'd at least be 100 upboats.
Can you not post this to *every* single thread on reddit that covers PyPy? We're aware and we're trying to fix it and so on.
We are in Longmont - some folks here commute from Denver but it's a bit of a bear. Most live north of the city.
shoot me a message with your contact info - I'd like to keep someone with your qualifications in my file for future reference.
Seems your array storage might be disposed once you leave the Python function, just as would do any other Python object storage (http://stackoverflow.com/questions/1453776/ctypes-memory-management-how-and-when-free-the-allocated-resources). So your options would be to use malloc/free like functions in C, or just move the storage scope to global (a third option might be to use malloc/free like system functions from Python).
No, I'm saving the casted pointer and the array, but I didn't write out the example quite right. I found my problem, which was that ptr.contents and ptr[0] aren't the same thing. Instead of passing a `t_struct**` from C, I need to pass the address of a `t_struct*`, and assign the casted pointer to ptr[0].
Turtles all the way down.
I didn't even know dropbox uses python, but [stackoverflow](http://stackoverflow.com/questions/2678180/how-does-dropbox-use-python-on-windows-and-os-x) (now stackexchange?) has a tidbit. I'd be curious to know more about it as well.
I am both angered and aroused by this.... Is that normal?
This looks cool, but can someone tell me how the coroutine is actually an improvement over a normal function? I get it that you could for example keep a total count without needing to declaring a class variable, but I don't see in what situations I should go for the coroutine and when I shouldn't. 
I'm still not 100% sure, I definitely could have done this with a regular function, but I think it would show its use in more complicated situations. Especially if you start chaining generators together? I'm hoping someone might comment and clear that up for us :)
Wow!
You can host your GAE apps on [TyphoonAE](http://code.google.com/p/typhoonae/) or [Appscale](http://code.google.com/p/appscale/).
This is really neat. I think you could complete the VS experience and have something of a killer feature if you included a way to compile the python directly to an .exe.
Probably not. Maybe it works with "Visual Studio 2010 Shell"? (That's what I use for F# development without problems.) Link: http://www.microsoft.com/downloads/en/details.aspx?familyid=8E5AA7B6-8436-43F0-B778-00C3BCA733D3&amp;displaylang=en EDIT: Yes, it does work with the free "Shell" version! :)
Twisted has been awesome for us. We used Twisted Words (the IRC module) to bootstrap our custom IRC server, for example. At this point we've had to replace most of it for scaling purposes, but the fact the bootstrap existed let us get it up and running in 2 weeks. The best part about Twisted is that they care so much about speed. If you're smart about how you code with it, you can write epoll driven servers that are just shockingly fast. Also, @defer.inlineCallbacks is amazing. Best reason to upgrade past Python 2.4 ever.
Thank you, I'll check it out.
My current senior design project where I try to identify high level topics in tweets and graph their popularity. Kind of like a super abstract 'trending topics' from Twitter.
esky seems amazing -- Thanks for the post
esky looks very nice. how would you go about creating a frozen app that also offers windows installer (like the one created by a python.exe setup.py bdist_wininst )....
I'm also unclear what the advantage is here. FWIW, David Beazley - who knows more than a few things about generators and coroutines - advises that you treat them as different concepts. (see slides 31 &amp; 33 https://docs.google.com/viewer?url=http%3A%2F%2Fwww.dabeaz.com%2Fcoroutines%2FCoroutines.pdf) http://www.dabeaz.com/coroutines/ I only mention it because you seem to be intermixing the terms somewhat loosely. I'm no expert but I have an understanding that you want to be careful about how you're using these two paradigms in your code. There are some limitations you'd want to be aware of before you just start hooking things together if you're planning on utilizing coroutines.
This was made by the Technical Computing Group at Microsoft. It's open-sourced under the apache license. Pretty cool real-world open-sourcing by Microsoft. Microsoft paid people to build this, then released it open-sourced. I can't even imagine what they had to do to convince the suits this was the right thing to do. Good job Technical Computing Group.
yes
no
when you want to write Python code
I've got something hacked together for a commercial project that works pretty well, I hope to spin it off into an esky "recipe" when I get around to setting up a wiki etc. It uses [NSIS](http://nsis.sourceforge.net/Main_Page) and its [zipfile plugin](http://nsis.sourceforge.net/Nsisunz_plug-in). The key is, an "esky" is just a zipfile containing your app in a certain layout. So you generate a stub installer using NSIS that basically says "unzip yourself into the selected install path". Then you just append the zipfile produced by esky to the end of the installer .exe file, and you've got an installer ready to go. What's nice about this setup is that the installer exe can also be used as a package for automatic updates, so you only have to generate and distribute single file rather than an installer *and* a package for the auto-update mechanism. Maybe that's a job for me this afternoon, to set up a proper mailing list, website, wiki etc for esky... 
Well, I mean... on the one hand... it's Visual Studio... which makes me angry... So. Very. Very. Angry. On the other hand, it's a very beautiful thing being done *with* Visual Studio.... And I'll admit I've honestly *really* wanted to have something *like* Intellisense but for Python modules for a while now (I'd just rather have it in another development environment :-) 
You are right ... Why reinvent the wheel... NSIS is a proven install maker for windows. And as it seems you could even make the nsis installer load the latest zipped distribution from the internet. This makes sense if your installer is distributed on many downloadsites.... Looking forward to your wiki :)
Yep, I just tried it with 2.7.1: Intellisense does work with CPython.
thanks sunqiang for posting this! im one of the team members and will be happy to answer any questions you might have...
wozer's correct. VS is also relatively easy to get, especially if youre a student, faculty, startup, ... see [getting VS.](http://pytools.codeplex.com/wikipage?title=Installation%20-%20details&amp;referringTitle=Home)
thanks nailer! as wozer says, CPython is fully supported. Other flavors to a certain extent (ie intellisense, but no debugging - yet). our stance motto is 'we love python - pick a flavor!' edit: sorry i wasnt very clear - IronPython/CPython 'fully' supported, PyPy, Jython, ... partially: no debugging/profiling, etc.
criswell - i read your comment while enroute to PyCon and almost spilled my water on the keyboard :). thanks for making a long flight more bearable... regarding VS - well, its a big complicated beast w some annoyances, but does many things well too. perhaps you want a skinnier version (express/integrated shell/etc). if there are specific issues that i can address pls let me know. 
Awesome. I will check how it works with Django shortly...
good
Honestly... I'm just a Linux-guy. There's not much you can do to make me enjoy Visual Studio :-) That being said, I have (as I mentioned before) often pined for something like Intellisense for Python modules in my editors. Also, I do *love* the idea that if I am ever stranded on that deserted island that is Windows and am forced (presumably at gunpoint) to work in Visual Studio, I will have some great Python integration waiting for me.
pohatu - thanks for the kinds words. yup, this is from the TC group at msft that also produces Windows HPC, TPL, PPL, parallel portions of the VS debugger, MPI, and next year a bunch more cool stuff! and youre very observant that this this took some work to pull off :). i have a few bruises to show. but if this project is successful we hope to build on it and do a bunch more stuff. for this year we're locked in for several more OSS projects which is great. 
fire
no worries - i grew up on solaris &amp; linux. funny story, way back in the day, for small projects we'd use Quick C then port to Sun compilers (cause the latter was soooo slow). i havent kept up w the latest IDEs on linux but from what ive heard there are a few very good ones w good intellisense, refactoring, etc. support. just checked out http://www.jetbrains.com/pycharm/features/index.html -- looks pretty good and crossplat.
I'm not going to lie, I've tried and tried, and I don't get how decorators work.
Thanks for the great work!
With web2py it's easy to deploy to google or your own server or even run a whole web site off your mac or pc. The cloud can be a little overwhelming at first but it's easy and cheap to try out. I like amazon, backspace and linode. For more traditional hosting, webfaction is particularly good for web2py.
Yeah, see, Linux engineers who consider themselves more "hardcore" (like I do) tend to avoid any development environment that prefixes itself with the term "integrated". As for PyCharm, firstly, it seems wrong to me to be coding Python in something Java-based somehow... Secondly, PyCharm never seems to integrate well with my desktop color schemes, which skew more towards the dark end of the spectrum (zenburn and the like). As an example, [here is what PyCharm looks when it first boots up on my system](http://i.imgur.com/Y8e15.png), and [this is what PyCharm looks like in project mode](http://i.imgur.com/Y8e15.png).... ick. Thirdly, PyCharm costs money... I wouldn't be opposed to paying for it, if it were *good*, but as you can see by my above examples it *really* has issues. Plus, there are oodles of exceptional Open-Source/Free-Software editors (and *gasp* even IDEs) that I have to choose from. The only thing they lack is a complete Intellisense replacement (though there are several projects attempting it... given time there will be success). 
Or web2py.
Check out the DAL from the web2py framework. It can be used independently of web2py.
Web2py is an excellent way to learn database programming. It comes with sqlite, a web server and a simple database admin tool. You can use web2py's data access layer or raw SQL. The docs are easy to follow. You can get rolling in a matter of minutes. And it's a terrific python framework.
I will try. I also post in every Lua thread, that their indexes start from 1. 
Sqlite is quite a bit easier to work with for a new user. You also might consider a free db tool like navicat lite.
yup, know exactly what you mean... lots and lots of editor+compiler+ocaaaaaasional debugger-GUI folks at msft as well. it's a very personal thing, and in few decades probably grep'able down to a person's DNA. a genius friend of mine until a few years ago still preferred terminals... terminals! 80-chars wide! 
Getting on a plane tomorrow morning. So excited. Best part is the testing BOF.
I'm also presenting a poster and demo at the poster session. Getting that all prepped tomorrow then flying in Friday morning.
You mean [integrating this](http://www.py2exe.org/)?
I founded SpiderOak; we ship desktop software on every major platform since 2007. PM me and I'll share our scripts that build a full library tool chain (i.e. compile every dependency, including python and all the libs, from source) and make standalone executables for each platform. It will save you quite the effort, especially on Windows and Mac. If there's general interest in this, we could publish a detailed blog about it. 
I've noticed PyPy seems to be faster than CPython when it comes to extensive numerical computations, which is great and all, but that kind of code is typically going to end up being written in C anyway, which destroys PyPy in performance. So I'm not sure what the net gain of using PyPy is really supposed to be. 
Here is a nice explanation (2nd answer): [Link](http://stackoverflow.com/questions/739654/understanding-python-decorators)
Thanks for the tip, this looks handy for a number of related applications beyond ORM scenarios.
True you are!
I still prefer bpython and ipython, but this is a pretty neat trick.
Did anybody else expect some retro-goodness with Python 1.x?
most of this is from http://docs.python.org/tutorial/interactive.html
That's nice, but it prevents me from using tab for indentation, which is quite annoying. Any idea about that ? (without removing the completion, of course)
I am staying at the Holiday Inn at the airport(the Hyatt was all booked up :(). I rented a car but I'm not sure if that's the best way to get around. What should I plan on for traveling around town?
Yeah, actually. Having used VS at work, a huge part of the workflow is being able to grab that exe when everything is working. Integrating that with a python programming experience might just be awesome.
The long answer is incredible.
Cool, I guess. The only use I see for this is when you can't install ipython for some reason. I wonder if this guy is snooty about his shell -- "*but I generally prefer just a plain old python interactive interpreter.*" It sounds like he's saying "*you might need colors and tab completion and documentation features and the ability to ls and cd and all that jazz, but that's actually for chumps. If you were 1337 you'd use the regular python shell and do the rest of that stuff in your head.*" Sounds dumb. Just use iPython.
Awesome! I've been using [Paramiko](http://www.lag.net/paramiko/) for ssh/telnet connectivity (logging in and sending simple commands), but this looks much easier!
I would apply for this job in a second, if it were in NY.
This look nice. How did anybody using this(and VS2010) managed the problem that python 2.6 needs VS2008 to compile extensions ? 
Cool, also make sure to check the tutorial out, it shows some features that make your life even easier.
If anyone ever tests this on a Windows box, please let me know how it goes. It should, in theory, work, I just don't have a Windows machine to test with.
thanks for this - Python Noob. 
Probably not news to anyone but [Fabric](http://docs.fabfile.org/en/1.0.0/) also does a good job at this.
IDEs like Wing, PyCharm and PyDev will give you good intellisense support for Python.