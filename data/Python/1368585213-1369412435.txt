I write sysadmin tools. When the distros port their tools and ship with 3, I'll be able to switch.
If I could get libspotify to work with python, I would add Spotify support
The [Python 3 Wall of Shame](http://python3wos.appspot.com/). Ok, technically it is now renamed the Python 3 Wall of Superpowers - &gt;Note that this subdomain's called "python3wos" - when the status was below 50%, the title of the site was "Python 3 Wall of Shame". I kid you not. 
I haven't worked for Rackspace since 2010. Joshua is my cofounder at Piston Cloud.
Stop telling people to migrate. You make it sound like it's so easy. It isn't. I maintain a 10 year old python application and only just recently moved to Python 2.7 from 2.4. Migrating isn't easy and extremely expensive. Instead you should encourage people to start using python 3 for new projects and pressuring people to update their tutorials to be targeted at python 3.
* https://github.com/rtfd/readthedocs.org * http://read-the-docs.readthedocs.org/en/latest/ * https://github.com/openstack/horizon * [EDIT] https://github.com/xenith/django-base-template
http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface
Why? No, seriously. 
The platforms I write for still don't come with it, and getting IT to install *another* interpreter is like pulling teeth. I'm stuck with 2.7.3 for the forseeable future. 
Exactly. When RHEL comes with Python 3, I'll be migrating to Python 3.
My browser does not play any music although trying with mplayer seem to play the music - mplayer http://localhost:8080/serve/my-song.mp3 Browser - 24.0.1312.56 Ubuntu 12.04 (24.0.1312.56-0ubuntu0.12.04.1)
I have it up and running on Debian 3.2.41-2 i686 with Python 2.7.3 and have connected via Chrome on my phone(Android 4.0.3) as well as Chrome(Win 7) and it works great. Also only took me literally maybe a minute to setup. Ill leave you more details once I get to play with it some more. Well done! 
The ability and relative ease with which developers can extend the language through modules is a feature. I'm referring to the actual language details of being able to create a module, not the widespread availability of such modules.
In the Python docs, "extending Python" referrs to writing Python modules in C — C extension modules. It's not extending the language itself (syntax, constructs, etc), but it does let you interface Python with libraries written in other languages. (mainly C or C++, but using C as a bridge you can call other languages as well that provide C interfaces.)
I'm interested in running this on my box that currently holds my plex server. I have a question about how it handles large music collections with known absolute dups (the same folder of mp3s appearing atleast twice on a file store). What does it do? index the two instances in its internal DB? or weed out dups somehow?
Comments like this just make it obvious that technology decisions are made based on popularity, trendiness, and peer pressure, not the actual merits. All of the real improvements in Python 3 could have been added to Python 2. Everything else is just differently bad.
"update" is kind of a fake word to use here. Python 2 and Python 3 are different languages.
It's easy to say "upgrade to Python 3.x" if you don't have to deal with the realities of enterprise software deployment.
Awesome, all working perfectly running over port 80 on my server. Didn't have to change anything on the nginx config I showed early, just added the -c server.rootpath=/cherrymusic to my supervisor command. Good work.
I dunno, dude, but the numbers don't lie! http://paste.ubuntu.com/5666561/ Those numbers are the total length in seconds that it took to evaluate the python code one million times, which is basically the same thing as saying that it's the number of microseconds it takes to evaluate the code once. So as you can plainly see there, it takes 4x as long to instantiate a list as it does a tuple with the same contents. Granted, five one-hundredths of a microsecond is not going to be a noticable slowdown if you only need one, but if you suddenly find yourself needing a billion of them, it makes sense to prefer tuples.
That makes absolute sense! Thank you!
Maintain dozen of codebases, all deployed in different environments with dozens of python and c library dependencies which are not python 3 compatible... And then tell me why not.
&gt;PHP 4 was shit. I was trying to stay positive, but taking that into consideration, Py2 is likely going to be a around for just a "tad".
I'm thinking you have that exactly backwards. Use == for non boolean values like strings, lists, etc - where you're checking to see if two values are equal. But booleans are singletons (there is only one value of True no matter how many labels point at it) and the Pythonic way to express the idea "Is x a boolean True?" is "if x is True:". Of course it might better not to obsess about types and simply say "if x:" but I would argue its always a bug if you see "if x == True:" in your code.
Well if that's the case there are a bunch if polyglots that you can make for them.
Yeah, how dare all those people have different real-life requirements than you? The nerve!
You haven't worked in very many programming languages, have you?
3.1 is in EPEL.
This is for more granular reloading. The use case seems to be intercepting exceptions and then splicing new bytecode in while saving the stack frames and locals from the before the exception call site and then resuming the computation with the fixed code. Kind of an odd use, but the implementation seems solid.
I'm curious, whycome?
Certainly possible with python, I'm working on something similar myself using [django](http://www.djangoproject.com). You'll probably need to do a fair chunk of javascript on the client side too. Have you seen [rosterplanner](http://www.rosterplanner.com.au) or [shiftplanning.com](http://http://www.shiftplanning.com/)? I'd be very interested to hear your thoughts on the features &amp; shortcomings of those?
Downvoted in the hopes that pressure from your peers will cause you to reconsider the importance the tracking the trends of popularity.
&gt;Are some of its definitions easy to modify/re-implement? Yes. Basically anything in Python is easy to modify or re-implement. I think str sucks and want to replace it with a better string type: str = MyStringType I'm not happy with how os.fdopen works either, so I can replace it os.fdopen = improved_fdopen In fact I think the whole windows os library sucks and would rather use something else import unix_simulator as os And in fact I don't like the way importing modules works at all come to think of it __import__ = better_import_method Extensible enough yet? &gt;Is the syntax extensible in some way I've never heard of? Oh, well, that's a little less flexible. Here's one you can try: from __future__ import braces 
Confirming this course is awesome. Very comprehensive, and doesn't gloss over "hard" topics (how to store passwords, how to sign cookies).
No python-ldap, no upgrade. It can't be migrated automatically because it's partly in C.
* http://scipy-lectures.github.io/advanced/interfacing_with_c/interfacing_with_c.html * https://cffi.readthedocs.org/ * http://doc.pypy.org/en/latest/cpython_differences.html#extension-modules * http://www.python.org/dev/peps/pep-0343 * http://docs.python.org/library/contextlib.html
Not the person you replied to, but here are two that are used in *many* of my applications: * Flask * gevent Once Flask/Werkzeug and gevent have full Python 3 support, I'll probably make the full switch. Until then, I don't have much choice.
Fabric, MySQL-python, South, nltk, boto, paramiko, sentry, django-debug-toolbar, django-social-auth. 9 packages I used in my last project, all of which don't support Python 3 (according to Python Wall of Shame). The first 3 are extremely useful and I wind up using them in almost every project. So nope, I'm waiting for Python 3 support. 
A few of them: * Pyramid: http://pyramid.readthedocs.org/en/latest/#tutorials * Bluebream (new Zope): http://bluebream.zope.org/doc/1.0/tutorial1.html * TurboGears: http://turbogears.org/2.0/docs/main/Wiki20/wiki20.html * Web.py: http://webpy.org/docs/0.3/tutorial An many many more Python web frameworks to search for: http://wiki.python.org/moin/WebFrameworks 
* http://pandas.pydata.org/pandas-docs/dev/dsintro.html#column-selection-addition-deletion * https://github.com/pydata/pandas/blob/master/doc/source/dsintro.rst#indexing--selection * http://pandas.pydata.org/pandas-docs/dev/indexing.html * http://pandas.pydata.org/pandas-docs/dev/reshaping.html * http://pandas.pydata.org/pandas-docs/stable/indexing.html#basics &gt; You can pass a list of columns to `[]`[*] to select columns in that order. If a column is not contained in the DataFrame, an exception will be raised. Multiple columns can also be set in this manner: df[['B', 'A']] = df[['A', 'B']] [*] Where `[]` is http://docs.python.org/2/library/operator.html#operator.getitem
That's just for one language. 
Do you do *anything* else than posting links?
You really dont want to develop an app without any framework in python. If you want something else than django: http://pyramid-blogr.readthedocs.org/en/latest/ - thy this one, it's tutorial iv'e made for pyramid - should get you started quickly.
Look at [his userpage](http://www.reddit.com/user/YouNorker), it answers that question in the most definitive manner.
No, but if you are slightly insane, this might work: import sys import unix_simulator sys.modules['os'] = unix_simulator
EPEL isn't supported by Red Hat. There's no SLA for these packages. Might as well be the source tarball.
But my text editor isn't just for one language, come on, this is a shallow argument. If you really do only develop in one language and can't be bothered with ST2, I suppose this is a fair python only option.
 False = 5 True = False * 2 - 5 True == False
Overwriting [specific methods](http://docs.python.org/3.3/reference/datamodel.html#basic-customization) such as `__getattr__` and the like gives you a lot of flexibility. 
you can extend it with plugins
additionally, check out monkey patching: http://en.wikipedia.org/wiki/Monkey_patch python's flexibility and capability to be reworked is pretty outstanding.
I just made public my first Python project, the Authomatic authentication / authorization client package for Python WEB apps. It allows you to log users in to your application with OpenID and 26 OAuth providers. The usage is incredibly simple.
Gotcha, thanks. I'm fairly new to the python ecosystem and I hadn't even considered that.
Now you need to write a web framework and Python will be complete!
I merely suggested checking it out, you can still use another tool for the other languages (like Emmet for those working with web).
Great answer! Thank you! Now that's what I call extensibility. The more I know about Python the more I love it.
Wow. Actually when I read about extensibility I thought about macros and Lisp. Macropy seems awesome. It says it had been used to implement algebraic data types, pattern matching, etc. Cool!
i see what you did there
I have.
Could you please try the newest devel release; This should be fixed now. If that doesn't help, please report back :)
As of now CherryMusic probably lacks the modularity to include other search engines... But that is subject to change in the future. As long as spotify would give you a direct link to a mp3 file, this is totally possible. But I worry about the playlists working properly with such external links...
What kind of browser is that? Firefox, Chrome or Opera should work fine... There has been an issue with Midori somewhere down the road, but AFAIK this should be fixed as well. Maybe you need to whitelist flash in your flashblocker to make it work. Also, I have experienced issues with some mp3s; It seems that the browsers are somewhat picky depending on the encoder used to create the files...
Thanks, that's nice to hear!
Does it support embedded cue sheets?
you could just use curl to spider the webpage and save it on a usb stick as static webpages. try googling for "curl recursive"
Finding duplicates is a very hard issue, since two songs may sound the same, but they might be completely different files (different bitrates/encoders etc). We have discussed about using some sort of audio fingerprinting for that in the future... So as of now, all files will be indexed, even if they exist twice.
We have discussed a lot about this issue. Firstly, it is very hard to determine if a certain file is the same as another; If they are the 100% identical, then a simple hash would suffice, but most of the time, you'll have files that sound the same, but which are, from a programmers standpoint completely different. Maybe we'll Include a Audio-Fingerprinting mechanism somewhen in the future.
* https://en.m.wikipedia.org/wiki/TiddlyWiki * https://pypi.python.org/pypi/tiddlyweb * https://github.com/bergie/create
This looks really cool, awesome job. 
You don't need to be afraid of installing python 3 next to python 2. You won't run into any problems.
If I am using Django and say a third party app like django-allauth, what are the benefits of using this instead?
/r/IPython supports { Markdown, ... }
There is also an [autoreload module](http://ipython.org/ipython-doc/dev/config/extensions/autoreload.html) for /r/IPython : %autoreload? %aimport? The autoreload module does not auto magically make functions [idempotent](http://en.wikipedia.org/wiki/Idempotence) or version the API like `/v1/` and `/v2/` or `/api/201305151700/`, though. Are there differences between these approaches?
I'm going to phrase this slightly differently to the other responses. What feature or features in Python 3.x are worth the cost of porting all of my code, and all of my dependencies, and all of my dependencies' dependencies, and all of my dependencies' dependencies' dependencies to Python 3.x?
Metaprogramming is probably the coolest but also scariest new feature for Python.
Have you looked into [python-social-auth](https://github.com/omab/python-social-auth)? It's by the author of django-social-auth.
MoinMoin used to have a MoinMoinDesktopEdition which was intended for just that sort of use. I bet the project still exists. Nice plugin system too. btw (and I swear I'm not trolling), why Python? It sounds like you want a program you can use, rather than something to hack on .. is the implementation language really that important?
The directory structure of a standard Scrapy project is necessary to run your spider with Scrapy's own CLI script. You can organise your project any way you want if you do the initialisation and start the spider/reactor by hand.
How does this compare to something like Velruse: https://github.com/bbangert/velruse ?
crap spam
Ugh, how can I forgot to put the word chromium at the front. I don't remember using any flashblocker.
Ehhhhh, some of that isn't all that. For example, changing `str` to another type won't work as well as you might want: all string literals will still be of the built-in type, and many operations will result in normal strings if even one of the operands is a normal string. A string literal concatenated with a string subclass is going to be a regular `str` because `str.__add__` is always going to be called and is always going to return a `str`. There's nothing you can do about it except, I guess, to write a class that has all the methods of `str` but is not derived from it, so that `str.__add__` doesn't know what to do with it and your class's `__radd__` gets a chance. But that is going to break some stuff too.
It's really, really hard to monkey-patch built-in objects. There's a module called [Forbidden Fruit](http://clarete.github.io/forbiddenfruit/) that lets you do it but I'd definitely call it a hack.
[Here](http://stackoverflow.com/questions/10903702/i-need-to-append-a-dictionary-to-a-dictionary-of-dictionaries/10905313#10905313) is a StackOverflow answer I wrote that shows how to abuse metaclasses to create arbitrary objects (a `dict` in this case) that have a `__name__` attribute that records the name used to declare them. Basically this particular metaclass lets you declare dictionaries using class syntax. I guess that's more a perversion than an extension of Python, but you may find it fun.
This is (one reason) why frameworks suck. Reactor/Scrapy/Twisted, all take over of your script and mean you don't have control of the app. Give me a library with some function calls anyday.
Well, this is r/python, so desktop applications are on-topic. But it would be nice if there was a good and easy way to make my Python code run its GUI in a browser.
hey, no problem, this is great! ok, ran latest devel, same problem, got this: [130515-19:11] ERROR : [15/May/2013:19:11:48] HTTP Traceback (most recent call last): File "/usr/lib/python2.7/dist-packages/cherrypy/_cprequest.py", line 656, in respond response.body = self.handler() File "/usr/lib/python2.7/dist-packages/cherrypy/lib/encoding.py", line 188, in __call__ self.body = self.oldhandler(*args, **kwargs) File "/usr/lib/python2.7/dist-packages/cherrypy/_cpdispatch.py", line 34, in __call__ return self.callable(*self.args, **self.kwargs) File "/home/mike/temp/cherrymusic-devel/cherrymusicserver/httphandler.py", line 256, in api return handler(value) File "/home/mike/temp/cherrymusic-devel/cherrymusicserver/httphandler.py", line 430, in api_listdir return self.jsonrenderer.render(self.model.listdir(dirtorender)) File "/home/mike/temp/cherrymusic-devel/cherrymusicserver/cherrymodel.py", line 114, in listdir sortedfiles = self.sortFiles(allfilesindir, absdirpath) File "/home/mike/temp/cherrymusic-devel/cherrymusicserver/cherrymodel.py", line 69, in sortFiles sortedfiles = sorted(files, key=upper_case_filename) UnicodeDecodeError: 'ascii' codec can't decode byte 0xbd in position 6: ordinal not in range(128) 
I'm a little late to the party, but this'll make some of you double-take: &gt;&gt;&gt; 256 is 257 - 1 True &gt;&gt;&gt; 257 is 258 - 1 False
It lacks macros, so its syntax is sadly not extensible. The VM is easy to extend, though.
What's the stability like on Android now? I tried about 6 months back and found the demo apps crashed frequently on me. Also is it possible to have Kivy apps on Androids store, or how do you distribute them?
I have set my desktop wiki on moinmoin. It's really good
I know its not the point of the article, but its amazing how far a little knowledge of command line tools gets you. It took about 1 minute to write this: curl -s http://www.dell.com/support/troubleshooting/us/en/555/servicetag/GWQN141 | grep -A1 TopTwoWarrantyListItem | tail -n 1 | awk -F "[&lt;&gt;]" '{print $7}'
The [tiddlyweb](http://tiddlyweb.com) (disclaimer, I'm the author) thing mentioned above can be used as a quite flexible framework for creating small wiki-like things. It might work as a starting point for your creation. There are a [ton of plugins](https://pypi.python.org/pypi?%3Aaction=search&amp;term=tiddlywebplugins) that add or adjust functionality. I'm not sure what you mean by "must be able to run scripts" but the pages in a TiddlyWeb can be any content-type so it is possible to assemble javascript, html, css to create single page applications using other pages as the content and data. There's a robust [HTTP API](http://tiddlyweb.tiddlyspace.com/HTTP%20API). (Apologies if this is a bit too much of an advertorial, but the use case does (with what little is explained) seem to fit quite well with TiddlyWeb.) A tiddlyweb contributor has made [TiddlyWeb At Home](http://tweb-at-home.tiddlyspace.com) which might be relevant. You've put this under Python so I assume you've already or will solve the problem of getting a useful Python environment on your usb-stick. If not then you might consider [TiddlyWiki5](http://five.tiddlywiki.com) which can operate as a nodejs server and do various wiki things.
Don't show that to the Javascript guys, they could write it as a one liner!
&gt; Does anyone know of any resources that show how to make a website without using a framework? *Gets a lot of framework tutorials in return...
Hmm... so I seem to have had a massive stroke while coding this. The only IO methods that are working at the moment are `read` and `write`. I'm working on fixing the rest.
Coconut, drawer, lamppost, Arabia, dog food.
[WikidPad](http://wikidpad.sourceforge.net/)
http://en.wikipedia.org/wiki/Python_(programming_language)
If you want to go to lower levels without going insane, Wekrzeug http://werkzeug.pocoo.org/docs/tutorial/ It's what Flask is built on.
I would point out these advantages of Authomatic over django-allauth: * Works with any framework thanks to adapters. * `python-openid` is the only **optional** dependency. * **No user model**. It only provides info about an authenticated user and credentials for accessing his/her protected resources, and **leaves it up to you where and how you store or process the data**. * Allows you to **call APIs of 26 providers** very easily and even asynchronously. * Supplemental JavaScript library.
Beetle, Hesten Blumenthal, Combinatoric, Jesus, Bricklayer.
I haven't, because I was searching for something which would work on webapp2 on GAE. I stumbled upon [Simpleauth](http://code.google.com/p/gae-simpleauth/) and got an idea how to make it better. But it has a quite impressive list of providers. Actually adding new providers to **Authomatic** is very easy, I just could not find more of them. Adding framework adapters is even easier. This should be done in near future. As I said in responses to the other comments, the main advantage probably is that you can **call provider APIs on behalf of the user** just by calling `authomatic.access()` if the user is logged in with OAuth 1.0 or OAutt 2.0. 
It's funny you mention this. I was just looking at Scrapy a few days ago and it seemed perfect for my purposes, but when I tried to understand how I could integrate it into my own library, my neurons started to steam. I just chalked it up to my noobishness. In any case I ended up writting a lightweight library using Twisted that just implements the *exact* functionality I wanted from Scrapy (which admittedly wasn't much). It even uses many of the same constructs. Even if we're both wrong and there *is* a way to integrate Scrapy into a library/script, it's good to know I'm not alone in my failures. =)
+1 on the certificate error from Chrome
What about [**pyfpdf**](https://code.google.com/p/pyfpdf/) for generating the pdf and maybe [**PyPDF2**](http://knowah.github.io/PyPDF2/) for manipulating it.
You might prefer to use the wayback machine as an intermediary: http://web.archive.org/liveweb/https://www.bel-epa.com/posts/taking-quepy-for-a-spin.xml
Open-source intelligence? What a bunch of crap and downright word abuse.
You should probably study your notes instead of cheating.
Web2py runs out of the box on USB stick. It incudes web server, database, web based IDE and sample apps. You just unzip it on the stick. You can install apps on it. It comes with "welcome" which includes a bare-bone wiki but there are many others you can find online and add. You can ask the web2py google group.
Difference with http://rg3.github.io/youtube-dl/ ?
I would expect a human. Since I've used good APIs that are chainable, I expect all object APIs to be chainable. That is, return the object being acted on except when some other value is expected, e.g. len(list). Returning "None" is a waste.
Some really interesting examples, thanks for the link
ah, http://en.wikipedia.org/wiki/Science
Why not? Used with moderation, metaprogramming is an amazing tool. Love it in ruby. Also, this is the only way to learn advanced programming stuff - by diving in it.
dependency management is one of the sucky things about programming.
That's oddly reassuring. As I'm going through all of this shit, I find myself thinking "Well, hell, if I can't handle something as simple as installing a few libraries, should I even be trying to learn Python?"
I've never had an issue with it, but that's in no small part to the OS that I use. Arch handles installation of both Python 2 &amp; 3 by treating Python 3 as the default program (`python`) and Python 2 as a secondary program (`python2`). Each supporting program for Python follows the same naming scheme (`pip2` vs `pip`, for example). It's hard to screw up when there's such a strong naming scheme.
AFAIR projecteuler is about solving the problems individually...
You might wan to check out http://pagerduty.com 
Yes, there's certainly an overlap between the virtualenv functionality our solution provides and that which Tox provides. In addition to the needs we've outlined above, we also have a separate need to test non-Python code with Python tests. We decided this need was better served by a custom virtualenv bootstrapping solution. However, we could be wrong in this approach and maybe Tox is the way to go. (Earlier versions of our code actually used Tox.) It also wouldn't be too difficult to use Tox *instead* of our custom virtualenv bootstrapping solution.
Tox also does not currently build the package inside of a virtual environment. Tox builds the package, enters the virtual environment and then runs the tests. There is nothing wrong with using both Tox and Defend Against Fruit as they are largely orthogonal. EDIT: Just finished updating the FAQ page to address this question: https://github.com/teamfruit/defend_against_fruit/wiki/FAQ
No, just pointing that this is not the point of projecteuler. Also problems there are quite poor at collaborating. If you want to do something like that try to create some real-world application. There components are more independent (and thus allow for collaboration).
good point. thank your pointing that out!
Matt and I (James) don't know. We are only visitors in the land of Python, who built Defend Against Fruit because we had to. I believe the question you're asking has nothing to do with python packaging. (In the world of Java, the answer to your question would be a WAR or EAR file which is not the same as a JAR file.)
Defend Against Fruit is not a CI tool; it is a build tool that a CI tool such as buildbot will invoke. See our updated FAQ for more details. https://github.com/teamfruit/defend_against_fruit/wiki/FAQ Thanks for the question. Our FAQ is improved because of it.
We seem to disagree on the meaning of these words then: &gt; continuous deployment style build system
Use homebrew. brew install pyqt 
There is no standard. Plenty of people use SCM in production and that approach is good enough for simple cases. If you go this route, I'd recommend using [fabric](http://www.fabfile.org) to automate updating the repos and restarting the application on your servers. For sophisticated cases, you need to think not only about deploying your own application, but also arbitrary other software that may be needed (nginx, java, etc), so that usually leads to packaging your python software as if it were a public application and treating it like the rest of the software on your system. That means building it into a RPM, a DEB, a source tarball or whatever, hosting it in your private repository (perhaps an S3 bucket) and installing it using a configuration management tool or your OS's package manager.
MacroPy is basically finished in its current state, as a proof of concept and bundle of demos. Next steps include breaking the macros themselves into separate project and polishing the core into a solid foundation for others to build upon. We also very nicely wrote up and documented both the demo macros (case classes, pattern matching, etc.) as well as the macro writing process, so hopefully others will have an easy time getting into it We welcome any feedback and contributions =D
What do you dis/like about PsychoPy? It's been around for a while, I think. It's got a slick website. It seems pretty flexible. 
Gold standard is deploying from git, either via Chef/Puppet/Salt or using Fabric's folder push mechanism. Slightly more advanced from that is using fpm on virtualenvs or pip's pybundle mechanism, but most apps are not built to be installed as packages. No direct equivalent to a war or jar exists, though I've spoken with the authors of a few major WSGI servers about it at great length, and we would all love to see a tool that can take a virtualenv and package it up such that it can be mounted into a WSGI server. Something like this could probably be built on top of the egg format, but eggs have a lot of other cruft and no one has wanted to tackle it so far.
I'm kinda sad they missed out on the opportunity to call it PsyPy.
It's funny you mention this: str = MyStringType Because "literal" will always create a str, not that string type, unfortunately. But by and large you are correct.
You can't brew PyQt4 for Python 3. It will default to Python 2. For Python 3 you have to download the source for SIP and PyQt4. Then run configure.py with the python3 interpreter. Then make, make install, and you're done.
I hade a poke around the wiki. I understand you're not necessarily trying to build a PaaS, but that world could help answer some of the open questions about how your approach could go beyond Python. Polyglot becomes easier if you can constrain the apps in some reasonable ways. http://12factor.net/ is a good set of constraints that enable building PaaSes like Heroku, http://gilliam.github.io/, https://github.com/globocom/tsuru, or the one I'm responsible for, https://bitbucket.org/yougov/velociraptor/. I'm excited by an even more recent development, http://www.docker.io/, though I wish it had been around a year ago.
Python 3?
We use this at the Allen Institute to create visual stimuli during electrophysiology and two-photon microscopy experiments. I prefer it to VisionEgg because it has a pretty responsive and active development community, and its main advantage over Psychtoolbox is that its free. 
Why not just run 331to332 ?
I want installing a Python webapp to be as simple as Jenkins. Their install process consists of: 1. Download jenkins.war 2. Run ./jenkins.war 3. Open it in your browser That level of awesome should be doable in Python, just not there yet.
I think this could turn out to be a great resource for people looking to solve Project Euler in the future.
It is really amazing work, well done! I was idly wondering whether it would be possible now to write a macro that allows one to write Python with Lisp syntax (maybe with a little Clojure syntax added), eg: (for x [0, 1, 2] (print (+ x 2))) This would be read into an AST more-or-less unchanged, then executed in Macropy's usual way. *Why... why would you do that?* Just because! Well, two reasons: some people like Lisp syntax, but Python + batteries + ecosystem is hard to beat. Also, it seems like the best way to do a specific task that I often do, which is generating code with a context free grammar. At the moment I have to generate it in text form, manually keeping track of indentation etc, and then exec it.
I'm porting the Python engine. Each new sub-release involves changes to the configure script and patching the interpreter source. Not so easy to automate. I literally finished catching up to 3.3.1 this week.
What are you doing exactly ? Sounds interesting. 
Oh, porting 3.3.1, not porting to 3.3.1. My mistake, I misunderstood.
Using git with a cron polling job on a production branch has been the defacto way of doing it. Its pretty easy to set up, just have a simple bash script that polls a git repo every so often and pulls automatically and restarted the any needed services. Then deployment becomes as simple as a: git push origin production 
Thanks, I didn't know about that! 
It's not super clear in the FAQ entry, you want tox to be invoked by DaF? Which means DaF might be replaced by just a clean CI env and a script to install tox?
If you change syntax that much you'll see _less_ than no help with indentation, highlighting etc from your editor (in that it will actively try to confuse you, at least it wouldn't do that with a multiline string constant). On the other hand writing a Lisp-like frontend for Python AST is pretty trivial, so you can do it yourself. If you want to generate code, why don't generate AST in the first place? It should be looking exactly like generating s-expressions, only without the need to do escaping.
assuming of course: * No pypi external libraries * No compiled modules * No additional config for your environment That's one of the only thing's i'm jealous of java devs for, the ability to update their settings on the fly... (please!, prove me wrong if this is possible in django)
I briefly worked in a two-photon lab where they used Psychtoolbox and it was a true nightmare to program new stimuli. Now I'm helping to set up a new lab and am trying to convince them to use PsychoPy but I've been told it's not yet entirely mature particularly for more complex stimuli. Do you have any experience to dispel that claim? 
that sounds like herokus model. and then there's the application format for app engine apps where all dependencies are contained in the directory. and a yaml file points end points at wsgi applications. if it were all zipped up it would be roughly equivalent to a war/ear. 
Anyone notice that ActiveState hasn't released a Python in a long long long time now?
You're right. After a bit of a think, it's the ast module which enables what I want -- Macropy just happens to be the thing that opened my eyes to ast. Re indentation and highlighting in the editor, I think I would just tell Emacs that I was writing Lisp, and it would be happy. Seriously, a front-end would be enough to give us the equivalent of Clojure for the Python VM/ecosystem. Lisp syntax, nice literals for dicts and lists, performance maybe coming via Numpy and/or Pypy... Obstacles: defmacro would need some thinking about. Also not sure about the fact that Lisp allows arbitrary subtree placement, the equivalent of this kind of thing: x = if y &gt; 0: 3 else: for z in [3, 4, 5]: z + 2
What about adding a fully featured extensible parser for Python (PEG?) to allow to extend grammar with custom grammar rules like camlp4 does?
For anyone that's curious, this is because Python keeps a pool of constant `int` objects for values between -5 and 256 (inclusive). If you ever create an `int` within that range, it'll point to the same exact memory as any other `int` object with that value. http://docs.python.org/2/c-api/int.html#PyInt_FromLong
Very interesting. &gt; if you want to compile Clojure to Python you don't even need that -- Clojure lacks setq and friends, right? I wasn't clear -- I don't literally want to compile Clojure code -- I want a new language analogous to it, with Python replacing Java. Actually I am probably out of my depth here. What does `let` expand to?
This is indeed something I missed in python, and is not unique to LISPs. Scala has the same thing, as does Coffeescript. The important thing is an equivalence between Expressions and Statements, or at least a path to conversion between them. I'd very much like it, but Python doesn't seem like it's going to unify its expression and statement syntax and semantics anytime soon =(
&gt; Actually I am probably out of my depth here. What does let expand to? `(let (variable value) body) &lt;=&gt; (lambda variable: body)(value)`
Neat.
I'm sorry, but your project name is terrible. Is that a Monty Python reference? 
What you describe is basically a Three Address Code: http://en.wikipedia.org/wiki/Three_address_code Location tracking is indeed annoying; we bumped into this problem too. Not sure what our solution is going to be; maybe we'll just put a monotonic filter over our line numbers so we get *some* reasonable line number.
On top of my head, these are the "C related things" I did as backend/devops developers: * rewrote lib/ code to C and bind it to Ruby/Python using FFI. * Extend Nginx, which is written in C, to be able to run Lua code. * Rewrote scrapers from Ruby/Python to C using libcurl. * Wrote extremely simple http rest+json daemon on top of mongodb. * Custom compiling Linux packages. * Debugging Ruby/Python runtime using gdb, strace, etc. So yeah, there's a lot of benefits in knowing C even though most of your day job is using dynamic language.
For my future reference, is your code online somewhere please?
It is indeed [a Monty Python reference](http://en.wikipedia.org/wiki/Self_Defence_Against_Fresh_Fruit), bitter_redditor.
I would call that a true statement on some level. I've spent time with both Psychtoolbox and VisionEgg and I'd say that both of them have more features, especially for 3D or perspective-warped stimuli (for example barrel or pincushion distortion or spherical texture mapping). However, at the Allen Institute we don't currently require any features that Psychopy lacks (we use mostly gratings, noise, wavelets, videos, image sequences), and because the viewport is simply an extension of the Pyglet window, it is fairly easy to embed some OpenGL code if necessary. I'd say its biggest strength is its fantastic documentation and ease of use. Also it has some great automated monitor calibration features. If you have a particular example stimulus in mind, let me know and I'll tell whether or not that is possible with Psychopy.
I'm sorry if this is a dumb question, but how can I contribute to PyPy? 
Yes, very similar to ddollar's new Anvil build system that Heroku is hypothetically moving to, except that packages up a whole VM whereas this would just be app code minus Python itself.
The only reason you would need to stick with py2 is if there was a library you are using which is not ported yet, or you are in an environment where it is not supported (Google App Engine)
gotta link for that?
DaF seems to overlap with 12factor points 2 and 10 (maybe 5 which mentions versioning every deploy), plus running only tested code.
https://github.com/ddollar/anvil and the related anvil-cli.
Thanks, that's about what I expected. The lab being set up here will also be doing two-photon work (on mice) so I really don't see them using any complex 3D stimuli. I'll try my best to talk them around to use PsychoPy but sadly too many people are stuck in a Matlab world.
I guess it depends on what you mean by "contribute". Money contribution: http://pypy.org --&gt; Donate Code contribution: http://pypy.org/contact.html --&gt; Mailing list, etc. 
I don't run your code. But why don't you rely on `_TemporaryFileWrapper` class defined in the code of the `tempfile` module? I think you're gonna save some time if `EphemeralFile` inherits from it. See: http://hg.python.org/releasing/2.7.4/file/9290822f2280/Lib/tempfile.py 
The framework definitely needs some more supporters/tutorials. I've been able to figure most of it out on my own, but I guess my lack of understanding the reactor, or the pipelines inner workings, is what's slowing me down. Anyone know the most popular support channel for the framework? The IRC blows and it takes a day to get a response to any question.
Note that Werkzeug is not Python3-compatible - and by extension, neither is Flask. It's not a deal-killer, just something to be aware of for a newbie.
&gt; Gold standard is deploying from git (*shudder*) So I push the wrong stuff by error, and my site goes down? Whoa.
Pretty nice, I've been planning on doing something similar but with a GUI. Just an off-topic question: Are there any big advantages to using BitBucket over GitHub? I've only ever really used GitHub.
Bitbucket's free accounts offer unlimited private repos for up to 5 users. 
As I see it, I can either ssh to my server(s) and pull the branch/tag I consider good, or have a cron on my server(s) do it. ssh-ing is not scalable (although that's what we do). cron-ing has the downside that if there's a bad push it brings the app down. In Java, I would push my changes to SCM, my push would trigger CI (Jenkins/Hudson) build, it would compile and run tests/coverage/anti-bug/whatever, if all ok it would package a deliverable (jar) and push it to a repository (Artifactory), and a cron on a server would pull that deliverable and deploy it. If CI has a problem there's an email/red traffic light/dashboard/air raid sound alert going all anal on you, but no upstream changes happen, and my site is safe.
Sure, you can do the same with Python, but instead of a jar file, you usually have Jenkins update a branch or tag and then that is what you deploy from in exactly the same way.
Haven't used you-get but at a cursory glance looks like it supports more asian sources (and less porn). Compare you-get supported sites to youtube-dl supported: $ grep "^class" youtube_dl/InfoExtractors.py ... class YoutubeIE(InfoExtractor): class MetacafeIE(InfoExtractor): class DailymotionIE(InfoExtractor): class PhotobucketIE(InfoExtractor): class YahooIE(InfoExtractor): class VimeoIE(InfoExtractor): class ArteTvIE(InfoExtractor): class GenericIE(InfoExtractor): class YoutubeSearchIE(SearchInfoExtractor): class GoogleSearchIE(SearchInfoExtractor): class YahooSearchIE(SearchInfoExtractor): class YoutubePlaylistIE(InfoExtractor): class YoutubeChannelIE(InfoExtractor): class YoutubeUserIE(InfoExtractor): class BlipTVUserIE(InfoExtractor): class DepositFilesIE(InfoExtractor): class FacebookIE(InfoExtractor): class BlipTVIE(InfoExtractor): class MyVideoIE(InfoExtractor): class ComedyCentralIE(InfoExtractor): class EscapistIE(InfoExtractor): class CollegeHumorIE(InfoExtractor): class XVideosIE(InfoExtractor): class SoundcloudIE(InfoExtractor): class SoundcloudSetIE(InfoExtractor): class InfoQIE(InfoExtractor): class MixcloudIE(InfoExtractor): class StanfordOpenClassroomIE(InfoExtractor): class MTVIE(InfoExtractor): class YoukuIE(InfoExtractor): class XNXXIE(InfoExtractor): class GooglePlusIE(InfoExtractor): class NBAIE(InfoExtractor): class JustinTVIE(InfoExtractor): class FunnyOrDieIE(InfoExtractor): class SteamIE(InfoExtractor): class UstreamIE(InfoExtractor): class WorldStarHipHopIE(InfoExtractor): class RBMARadioIE(InfoExtractor): class YouPornIE(InfoExtractor): class PornotubeIE(InfoExtractor): class YouJizzIE(InfoExtractor): class EightTracksIE(InfoExtractor): class KeekIE(InfoExtractor): class TEDIE(InfoExtractor): class MySpassIE(InfoExtractor): class SpiegelIE(InfoExtractor): class LiveLeakIE(InfoExtractor): class ARDIE(InfoExtractor): class TumblrIE(InfoExtractor): class BandcampIE(InfoExtractor): class RedTubeIE(InfoExtractor): class InaIE(InfoExtractor): 
Yeah, it makes more sense. What it doesn't do is producing a *build artifact*. (My question would be better phrased as "what is a standard for build artifacts in Python?")
That was the meat of my comment, there isn't one. The standard for build artifacts is just what I said, a tag which you deploy. Yes, this is awful. I was just talking with some other distutils-sig folks last night about how we can leverage the new wheel metadata to improve this, but we need support for wheel in the build and install tools before we can really talk about improving it. If you are interested in improving this, definitely join the SIG and put together a proposal and see what people think. For now the closest I've seen to a standard for build artifacts is "Make a folder with everything working, and put it through fpm".
ORLY? https://docs.djangoproject.com/en/dev/howto/deployment/ damn there's a whole chapter on it. http://www.djangobook.com/en/2.0/chapter12.html but really I think this is the correct information. https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/ But yeah you are right it's as simple as those 3 steps you listed.
Thanks for the input! As others have noted, Bitbucket offers unlimited free repos for up to 5 users.
Good point, changed.
It wasn't, but I figured I might as well put it there. I would have, eventually, and it's an opportunity to document it a little. [This](https://github.com/breuleux/ug/blob/master/ug/compile/topy.py) is the file where I translate from my own AST representation to Python's. Start with `evaluate`. Unfortunately, it's part of a project that has about 15 kloc, so I'm not sure how intelligible it is without context. For all intents and purposes, `hs.Name`, `hs.Call`, etc. build Python AST objects (well, my own precursors to them, actually). 
I feel like the name might make it harder for you to gain traction. Which is already a difficult task. But what do I know? I thought Ruby on Rails was a weird name too when I first saw it.
I finally figured this out and my pipeline is now getting called (Still not adding items to my sql file, but I don't have time to verify if it's related ATM.) To anyone having this same issue, the secret is to import your projects settings rather than using the default settings, which the documentation tells you to do. In order to do this I had to implement the following code: from project import settings as project_settings spider = ProjectSpider(add, your, spiders, arguments, here) settings = CrawlerSettings(project_settings) crawler = Crawler(settings) crawler.configure() crawler.crawl(spider) crawler.start() log.start(loglevel='DEBUG') reactor.run() I have not fully tested this yet, but it seems to be the solution
In yes or no def why can't you just say reply in affirmatives, that loop isn't needed
I have started writing a module that provides wrapper classes for PsychoPy that make it simple to create and show stimuli: https://github.com/sloria/stimulus.py Here's a simple example: par = Paradigm() text_stim1 = (Text, ('Hello, world!',)) video_stim = (VideoStimulus, ('hello.avi',)) text_stim2 = (Text, ("Press 'q' to exit.",)) wait = (WaitForKey, (['q'], 'exit')) par.add_stimuli([text_stim1, video_stim, text_stim2, wait]) par.play_all() I will be adding more stimuli types in the future, and I encourage you to please fork and modify as you see fit. I also welcome any feedback!
you should try to make it export to gif!
Isn't QuickTime dead yet?
Depends on your definition of dead.
Line 41: return yes_or_no(…) Also, this bit of code: for item in items: if something == item: … can be written like this: if something in items: …
Ableton Live 9 Autocad 2013 Maya 2013 Sony Vegas Pro 12 Quickbooks Premier 2013 Reason 5 Nero 12 Pixologic Zbrush Camtasia Studio 7 Corel PaintShop Pro X5 Final Draft 8 Microsoft Office Project 2013 Mastercam 5x Sibelius 7 Dragon Naturally Speaking 
there you [go](http://stackoverflow.com/questions/3290522/urllib2-and-json)
You could use requests for that, it would make it very straighforward. Take a look at the [documentation example](http://docs.python-requests.org/en/latest/user/quickstart.html#more-complicated-post-requests)
I read that, I just don't know how to deal with the part `"params" : [ { "account" : "xxxxxxxxxxxx"} ] `. If it were { "method" : "something", "params" : "somethingelse" } I think I can handle it.
I've found using gevent websockets + d3 works wonders
The player is. The framework is still used in mac land.
Pass the params into urlenocde() and add to the end of the url. import urllib url += '?' url += urllib.urlencode({"param" : "somethingelse"}) If the order matters (it shouldn't) then you can use a list of 2-tuples instead. 
I mean, the part I don't know how to do is "params" : [ { "account" : "xxxxxxxxxxxx"} ] I know how to deal with it if it's `"params" : "somethingelse"`
So you do: import urllib url += '?' url += urllib.urlencode({"account" : "xxxxxxxxxxxx"}) If you're asking how to treat a dict as an argument, then you need to translate it into a string yourself.
A Comment
Very true. "Camel is a horse forked and modified by a community." (Hi Kenneth! Enjoyed your talk at DevconTLV the other day.)
The main purpose of yes_or_no is to see if the user answered yes or no and return the value. The part at the the end is only there if they did neither. Edit: I didn't understand your suggestion, now I see you were referring to syntax. The change has been made and I appreciate the help.
I'm still too new in Python for me to join sig(s), but TIL about wheel.
I've heard of spyder but haven't tried it yet myself. Any feedback from folks who have used it for scientific computing? Would love to get more coworkers to consider alternatives to MATLAB. 
I used to plot live data with Qwt, but found it not very convenient in the end, mostly due to how the data is handled. In our lab we have switched to plotting with chaco from the enthought tool suite, which i can highly recommend.
I work with mechanical and electrical engineers in R&amp;amp;D. We lost the funding for our Matlab licenses and I was on the team to find a cheaper or free alternative. We settled on Scilab after looking at Spyder/python. I love Python myself, and use it for my own personal stuff, but Scilab was A) closer, almost identical in syntax to Matlab, and B) seemed like a more comprehensive installation package. Both are nice, but in the end the Matlabrats liked Scilab better. I was a big fan of Python(x,y), which created an all in one installer for Spyder and the scientific/math packages.
Why not GNU Octave?
I haven't looked at Octave in a while, but I don't recall there being an all in one installation package with the IDE, help, and general structure of Matlab. I could be wrong! When deploying for non-programmers, such as engineers, we were looking for something that was easy to deploy (not a hodge podge of several libraries that would be out of sync from one user for the next), a solid IDE, good documentation, and familiarity. Scilab seemed to be the fit for that. They're all great tools, but the corporate world puts emphasis on some things over others. It made IS happy and that's half the battle.
Neat! I still prefer iPython and a text editor though. 
ipython is one of Spyder's supported consoles. It has a built-in text editor too, though you're welcome to use your favorite of course.
Spyder has an all-in-one for Mac that I really like. I installed Anaconda as well but for most projects the standalone Spyder usually has everything I need. I haven't tried it but I believe you can open the Dmg and stick extra modules you need in there. https://code.google.com/p/spyderlib/downloads/list 
The standalone application for Mac is great. It comes with most modules in the Python scientific stack by default. I can use it for about 80% of projects, the rest are mostly web server projects which Ive been using pythonanywhere for, so no biggie. I believe Python(x,y) is similar for windows. https://code.google.com/p/spyderlib/downloads/list https://code.google.com/p/pythonxy/
Great, glad you could use it!
god i love requests
If spyder looks interesting to you, you may be interested in python(x,y) it's the only thing other than pycharm that I like working with on Windows. Otherwise of course, anything, and pycharm is great on whatever.
not bad, but I am actually somewhat appalled that Sublime Text 2 is not listed in the "editors" section
I prefer iPython notebook witk --pylab inline
PDB! http://www.youtube.com/watch?v=vfPtGsSJldg
I'm a big fan of [winpython](https://code.google.com/p/winpython/). By the same guy who did python(x,y), but it's a little easier to finagle, more portable and has a 64bit distribution. (still includes spyder too)
Relevant username
pdb++, mostly because of sticky mode https://pypi.python.org/pypi/pdbpp/#sticky-mode
I concur with this statement. PyCharm is great for debugging.
Sometimes I want to zoom into a plot. Apart from that, iPython with pylab inline is great. And the notebook is pure gold for teaching! 
seconded
pdb. [pudb if i feel like treating myself.](http://ahye.ventolin.org/s/d1bb2ade3cb01cfbbfa8fec3367b09e6.png)
winpdb
Is your question about the syntax of the statement? Your example looks like a list or array only containing a single element rather than multiple elements. mapping = {key: value, key: value, ... } array = [ element, element, element, ... ] array_of_mappings = [ {key: value, ... }, {key: value, ... }, ... ] In python, we'd call that array a list (mutable) or a tuple (immutabe) and the mapping we'd call a dictionary.
thirded. PyCharm is just awesome. Switched to it over a year ago (from a mix of Eclipse/vim/Sublime), and I'm so happy I did.
I’d used [Werkzeug debugger][1] for web application programming before, but now I use [wdb][] instead. Use pytest’s `--pdb` option for unit testing. It opens a pdb session when a test fails. [1]: http://werkzeug.pocoo.org/docs/debug/ [wdb]: https://github.com/Kozea/wdb
Not in a habit to use debuggers at all. I just do regular print statements until I figure out the problem. Slow, but idk, works. :&gt;
Debugger? Pfft! I leave my bugs in!
It may sound like we're all just paid by Jetbrains - but seriously, it's just so fantastic.
I was that way, too, until I had to learn Java for a job. Now, it's just frustrating to go back and write print statements in code.
After using tar.gz archives and manual installation of dependencies for way too long, I finally decided to build OS packages (deb at the moment) and regret that I didn't start doing that earlier. I didn't move to building a repository for hosting the packages yet, but that will definitely be the next step. Automating installation tasks is hard and painful at the beginning, but totally worth it, because it prevents making the same mistakes over and over again and saves a lot of time on the long run.
Try [OpenCV](http://opencv.org/downloads.html). *Bindings for python 2.6 &amp; 2.7*, and it plays nice with PIL if you need it to. import cv2 im = cv2.imread('image.jpg') # type(im) is numpy.ndarray cv2.imwrite('out.jpg', im)
I use matplotlib with real-time plotting, but to get it to the half second update speed I needed, I had to do some blitting magic and selective plot updates. I was going to use PyQwt, but at the time the maintainer had decided not to support the newest version of Qwt and PyQt but now I can't find the version information on the website.
Scilab isn't too bad. Another up and coming alternative is Julia, which beats Matlab on speed. 
An excellent tool with an unfortunate name that kept me from trying it for a long time.
Thanks, this would probably work fine as I'm not really stuck on using PIL since I was only using it to open the image. I actually got the code to work by using the numpy.flatten() method and then the array.reshape() method to reconstruct the original array. My problem now is that the covariance matrix of my data is way too large and I get a memory error, I'm looking into SVD now to solve that problem, but thanks again.
Correct spelling is "debuggerer". It's for when your code gets buggered up.
I use the print function/statement.
In case you weren't aware, pycharm has a vim extension as well. I use that to emulate a more complete vim setup. 
I use an excessive amount of brackets
Is this the same as `import IPython; IPython.embed()`?
TIL r is the default. Mine is stuffing things into one line. str(line).split(" ")[6]
Definitely the same with me. I'm constantly fighting with PEP 8's eighty character limit. Edit to people rattling against the PEP: I fight it because I like squeezing in characters, not because I'm forced to use it.
The Pycharm debugger has saved me countless times. 
TIL there is an 80 character limit :). Will have to start cleaning up my code more. 
I agree - I've used Wing for a while and like it a lot.
Meh. I'll stick with an explicit context manager. Best not to rely on implicit, implementation-specific behavior.
No, it's not. `ipdb` provides `IPython` REPL extensions to the standard Python debugger, `pdb` (which extends the barebones Python debugger `bdb`). Debuggers in general allow you to set up breakpoints, step through programs at the line or instruction level, and analyze memory of the state at which the program is stopped.
I usually use `ipdb` from the `IPython` project, but I once used `winpdb` in the past to help debug an issue with forking (something that the other debuggers either cannot do or cannot do easily).
Not really python-specific but I tend to put parentheses around all mathematical operations for explicit order of operations ... e.g. (x * y) + z instead of x * y + z ... even when the order is painfully obvious. I consider it a good habit. 
&gt; I'm constantly fighting with PEP 8's eighty character limit. I'm constantly ignoring it because I'm an adult, with free will, and I don't take such orders from strangers when I don't want to.
I do the same, I think it is due to my inherent distrust of anything or anybody.
I'm constantly abiding by it because it's nice when people agree on friendly standards. It's a fucking PEP, dude; not a Gestapo drill.
Totally true. I'm a hobbyist running solely on CPython so sometimes I get lazy :)
Ideally, this is the cleanest way to ensure that order of operations is clear. For more win, remove the white space between operands in high precedence operators, i.e., x = (a*b) + c. This helps to make precedence clear for future readers of the code.
"A foolish consistency is the hobgoblin of little minds"
I'm trying to use this at work for our experiments. I used VisionEgg previously and I'm finding PsychoPy easier to use for me. Specifically, the environment is much easier to setup, the documentation is a bit better, and I found the structuring of modules much more straightforward. And while I prefer my choice Python editor to make the scripts, the GUI it provides is very nice to use IMO (though it could use a makeover). However, I am having a problem with it's video-playing feature (required for our experiments) in that it seems to be very picky as to what videos will work and what won't, even though it claims otherwise. It seems to be a problem with AVBin, the media lib used by Pyglet and therefore PsychoPy. If I can find a way around this hurdle then I would try to use PsychoPy for everything we do.
Fuck it, let's all have different page widths and shit all over our tab formats. Also my functions use uppercase and my constants are single characters.
This is one of the first things I noticed it lacked, glad someone else noticed! There seem to be concepts like this built into the Builder GUI, but when you compile the scripts it's all just kinda thrown together bits of code rather than objects.
iirc its 79, and its pathetically low. 120 is where its at.
My favorite part of Python is that you don't need an IDE to work on a large project.
Or do the opposite to screw future readers up! `x = a * b+c` Bwahahaha.
If on windows, try http://pytools.codeplex.com. 
I stick a line of: from pprint import pprint as pp At the head of new scripts - I'll need it during development.
I sometimes go to unusual lengths to make my objects preserve eval(repr(x)) == x
I've always used pdb inside of emacs. Definteily going to give this a shot. 
I am using matplotlib's qt backend to do some realtime plotting. Not that I need to refresh plots quicker than 1s, I am curious as to what blitting stuff you did there.
To get a numpy array: import numpy as np im = PIL.Image.open(fn) im = np.array(im, dtype=np.uint8) And back to PIL: pil_im = PIL.Image.fromarray(im) pil_im.save(fnOut) Notes: 1) You are correct about the channels. Note that you will probably want to just use a single channel for PCA, or convert to grayscale first. 2) To do the actual projection, I recommend using scipy.linalg.svd(X) 
They aren't bugs! They're features!
Yes, they do. And they were always great about granting that license - no problem at all. It was a speed-bump for students who wanted to get set up on their personal computers, however, and it made me a little sad that after they finished the class they couldn't just keep using it indefinitely.
All whitespace is actually the default for `split`, so you could change that to `.split()` and get the same effect.
How do you know that if statement you just wrote won't swap your consequent and antecedent code blocks?
This looks pretty awesome. How would I compile, for instance, a WSGI webapp?
 pip install pep8 then pep8 your_file.py ;)
list comprehension to filter lists [x for x in some_list if x is like_something_else] should use itertools more often ~~TIL: itertools.ifilter() does the same as itertools.takewhile()~~
Thanks for the input! Others are suggesting the same thing. I really want quizzes to be human-readable - something a 5th grader without computer experience could reasonably make. JSONs, though fast, seem a bit much for a non-programmer. What's the most readable format that's well supported by Python?
I played a bit with Nuitka and it looks promising. Try this: http://www.nuitka.net/posts/support-for-portable-standalone-programs.html
Joshua is talking about Infrastructure as a service, through OpenStack. Part of it is in fact "instant" provisioning of servers.
&gt; Infrastructure as a service AKA the real meaning of the "cloud" thing. Thanks!!
In CPython *open(name).read()* it will be reference-count closed immediately, no garbage collection needed. In PyPy it will be garbaged collected .... some unspecified time later! *with* actually makes it consistent.
I think YAML suits well (as long as it's okay to have a dependency on PyYAML). It's characteristics are similar to Python : 'as obvious as possible to the human eye', and 'significant whitespace'. It looks like - What is the answer to life the universe and everything: - 42 - 42.0 - "42" # needs to be quoted, otherwise it will be interpreted as a number rather than a string. - forty-two - Some other question: - valid answer - another valid answer To adapt perrygeo's example. Loading this returns a list of (dicts with a single key (a question) and the value being a list of valid answers). that is, `[{"What is the answer to life the universe and everything": [42, 42.0, '42', 'forty-two']}, {"Some other question": ['valid answer', 'another valid answer']}]` for the above input. If the order of questions is unimportant, you can instead simplify slightly so you just get a single dict: What is the answer to life the universe and everything: - 42 - 42.0 - "42" # needs to be quoted, otherwise it will be interpreted as a number rather than a string. - forty-two Some other question: - valid answer - another valid answer Which is slightly easier to read. I suspect that you don't care about distinguishing the `type` of answers, so you could just leave out "42" in this case since it would be equivalent to plain `42` -- ie. no need for the quiz writer to deal with quoting. this second version would return `{"What is the answer to life the universe and everything": [42, 42.0, '42', 'forty-two'], "Some other question": ['valid answer', 'another valid answer']}` Caveat: the question text can contain ':' but cannot contain the string ': ' (unless the entire question text is "quoted"). This is because it creates a parsing ambiguity.
So the first optimization you can make if you haven't already is by using matplotlib line's "set_ydata" instead of recreating all of the objects, if you aren't doing that already. I would suggest googling "matplotlib qt blitting" for more examples, but I found this one right away: http://matplotlib.org/examples/animation/animation_blit_qt4.html. Some are out-dated and I found some that didn't work for my system so I had to tweak them a little (copying the whole figure instead of just the axes). I don't remember what example was most helpful and my code is kind of a mess to show you. I ended up subclassing the FigureCanvasQTAgg and providing a drawing method that automatically did the blitting when I needed it to. Hope this helps.
 True if x == 'spam' else False The ternary is entirely redundant since the `==` operator returns booleans anyway.
My first example showed an array-based setup. Read the two listings again and note the difference. The first returns a list of dicts, the second returns a single dict. I've made some edits that make this more explicit.
The entire post is redundant since, as a commenter points out, it's just an implementation of `not 'spam' in a` :)
It's helpful to cut down redundancy in the middle steps too since not all code reduces to nice built-in syntax. `'spam' not in a` is the PEP8 endorsed one I recall.
For those examples, I put the content into a file `/tmp/foo`. Then I did the following: import yaml with open('/tmp/foo','r') as f: data = yaml.load(f) When I speak about having dependencies I simply mean that [PyYAML](http://pyyaml.org/wiki/PyYAML) must be installed before you can 'import yaml' -- simple enough with the usual methods : `easy_install` or `pip`. Alternatively, you can include a copy of PyYaml in a place where Python will find it, so that a particular version of PyYaml's code is packaged with your project. If I intended to do this, I'd first make sure it was installed into Python (as described before, and verifying that I can 'import yaml' after installation.), and probably just copy the directory `/usr/lib/python3.3/site-packages/yaml` to the same directory my main script resided in. (I'm running Linux and Python 3.3; adjust paths as appropriate for your OS and Python version) The only thing you will miss by doing that is the speed of the optional C-based parser. Which will be unnoticable anyway on inputs as small as I expect your quizzes would be (&lt;100 questions) That said, if it is possible, a proper installation using `pip` or `easy_install` is what you should do. Bundling PyYAML with quizzer is a measure I'd only take if I, say, had to install quizzer on many different machines, or machines in which I did not have the administrative privileges necessary to install packages.
Yeah, people tend to point that out. `'spam' not in a` looks like an operator precedence error to me, though. Unless `not in` should be considered a distinct single operator, separate from individual 'not' and 'in'. I realize now that `is not` is probably a distinct single operator.. heh.
`not in` is a distinct operator. If it wasn't, `not in` would be a syntax error.
Well... at least it's a fair reference for a baseline github repo and python package.
Will that mean a user that hasn't installed PyYAML will be able to use the program without installing PyYAML?
How useful.
I used to use PyCharm for everything django/python related. But I recently started to use Xmonad in Ubuntu. That's when i started to run in to a lot of problems with it so I switched to Emacs. But PyCharm is a really good product and I recommend it to anyone who works with Django/Python. 
Bah! Everyone knows the best NoSQL database is dcramer's [MangoDB](https://github.com/dcramer/mangodb)! (seriously check it out, it's hilarious)
that's just awesome.
No self respecting Mac hacker would be caught dead in a Starbucks.
&gt;Mongo Totally over it, brah. It's all about LevelDB now.
you know, that whole repository is a joke, right?
I'm pretty sure that should have been in ALL CAPS.
That pup definitely uses a mac.
I laughed.
Wait, really? I had no idea!
[Finally, /dev/null supports sharding.](http://www.youtube.com/watch?v=b2F-DItXtZs)
print all the way!
Heh, I specify the *other* default argument. I'm happy to rely on the read mode default, but whenever I read the rest of the file I spell it `f.read(-1)`.
Missing functionality to create zip files with a _MAC_OSX folder.
The best part: https://github.com/emre/macster/blob/master/macster/.DS_Store
If you use sublime (and if you can afford it, its well worth it), there is a lint plugin that will show any pep8 conflicts. Very handy.
Wow, never knew about that. We're all learning so much!
Reminds me of this http://html9responsiveboilerstrapjs.com/
Great, so I get to have fewer files open on my screen because of you? get fucked.
3 F bombs dropped over the 80 char limit (in this thread)... I'm starting to think it may be a seriously irrational trigger.
I use Python Tools for Visual Studio. Absolutely zero effort. Look forward to using PyCharm in the future though.
I've found PyQwt to be more trouble than it's worth. As an alternative, I'd promote [pyqtgraph](http://www.pyqtgraph.org/), which seems to be more actively developed, and has fewer dependencies. 
Yes, that's the whole point of bundling it.
How about this, you can have your extra characters, and I'll sneak in tabs.
meh... its all just whitespace. :)
That is great... Thanks... I'm almost tearing up... 
I probably overuse generator expressions.
We have one site that uses mongo and its the most breaking site ever. Also thanks for sharing I love the nodejs video
* http://wiki.python.org/moin/PythonDebuggingTools * http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/
I overuse classes as namespaces with @classmethod and @staticmethod
&gt; AUTO SHARTING ALGORITHM 
Well of course. That's why they try to visit Starbucks while still living.
&gt;with a new and improved AUTO SHARTING ALGORITHM. I chuckled.
I once wrote a blog generator where the entire program relied upon a single function containing a multi-dimensional list &amp; dict comprehension. It was obscene; I feel your pain.
That was glorious.
Step 1 is admitting you have a problem :-). 
Thank you for this. There will be 20 people laughing their asses off at work tomorrow!!
&gt;import ipdb; ipdb.set_trace() This is so much nicer than my hacky implementation, commenting here to fix a few personal libraries ;-)
&gt; I do the same, I think it is due to my inherent distrust of anything or anybody. Yeah I do this too... the best (worst) part is there's a production SQL view at work which only "works" because nobody considered the order of operations (and in reality, the WHERE clause does NOTHING... but I am too afraid to touch it since that is apparently the desired output!)
As a Linux user, I feel like there is a joke here that I'm missing. Can someone explain to me what this does?
Ditto 
[.DS_Store](http://en.wikipedia.org/wiki/DS_Store) OS X spams these little hidden files everywhere.
That sounds scary. Black Box it - and turn around - nothing to see here!
Generators are cool. One of the reasons I code in python.
Could this not be solved with an internal DNS server entry or proxy server redirect rather than playing around with host files? Not a network guy but I thought DNS was supposed to solve the host file headache.
Python is not hipster! Someone should implement this with using Ruby.
It's useful if you use dhcp in different locations that have their own dns, for example.
Obviously you are looking for a Python solution since you asked here. But I seriously recommend to have a look at [Simbad](http://simbad.sourceforge.net). It's Java but it's really great. It's dead simple to get started and when I used it, I even got it working with Jython. Try it.
Since its an exact copy in 2 functions, I'd think about moving read and write operations into their own functions. I'd also flip the compare operation to look for windows since everything not windows is going to be etc hosts. Makes it a little more flexible with very little effort
Perhaps I misunderstood your comment, but are you suggesting hardcoding the path to the hosts file is a bad idea? I'd love to see your reaction after you try moving it …
Maybe the turtle module will get you part of a way there. See http://docs.python.org/3.3/library/turtle.html This is a builtin module, so should simplify deployment
This code: if hostname[0].isdigit(): return False if hostname[-1:] == ".": hostname = hostname[:-1] Could be rewritten as: if hostname.endswith('.'): hostname = hostname[:-1] That's of course assuming Wikipedia is correct and digits are allowed as the first character of a hostname (source http://en.wikipedia.org/wiki/Hostname): &gt;The original specification of hostnames in RFC 952, mandated that labels could not start with a digit or with a hyphen, and must not end with a hyphen. However, a subsequent specification (RFC 1123) permitted hostname labels to start with digits. Otherwise: if hostname[0].isdigit(): return False if hostname.endswith('.'): hostname -= hostname[:-1] 
epub format too, please!
I do that, it means that the code is not dependent on my (probably faulty) recollection of the precedence rules. Same goes for when I read it in 10 mins time.
this is bad python: links = [] ent_length = len(planet_python.entries) # capture the number of items in the FeedParserDict # Now we can iterate through the list for i in range(len(planet_python.entries)): # The structure of the FeedParserDict Nessistates iteration with integers links.append(str(planet_python.entries[i].link)) This is how you should make it: links = [] for entry in planet_python.entries: links.append(entry.link) and do not convert unicode urls to string. Unicode characters are allowed in domain names. https://en.wikipedia.org/wiki/Internationalized_domain_name
while not a high priority for this project, this will become available once the latest [nbconvert](https://github.com/ipython/nbconvert?source=c) comes out.
You're right about `/etc/hosts`, but this is an accident waiting to happen: filename = 'c:\windows\system32\drivers\etc\hosts' It comes out ok because `\w` `\s` etc. aren't actual escapes, but it's just plain bad form. It should be `r'c:\windows\system32\drivers\etc\hosts'` or `'c:/windows/system32/drivers/etc/hosts'`.
try formatting data in json first, i had to do this last week. payloaddata = { "method" : "something", "params" : { "account" : "xxxxxxxxxxxx" } } then r = requests.post(url, data=json.dumps(payload))
Mac? Pssh, I have my Underwood with me. I seem to be having compatibility issues with the Python interpreter, though. Help wanted.
pip install debug import debug
Ok cool, didn't think of that
Python is so much more hipster than ruby.
Because I am a docstring style nerd: http://www.python.org/dev/peps/pep-0257/#one-line-docstrings &gt; The one-line docstring should NOT be a "signature" reiterating the function/method parameters (which can be obtained by introspection). Don't do: def function(a, b): """function(a, b) -&gt; list""" &gt;This type of docstring is only appropriate for C functions (such as built-ins), where introspection is not possible. However, the nature of the return value cannot be determined by introspection, so it should be mentioned. Obviously your docstrings don't *actually* ruin your program or anything. Glad to see more people using Python!
Sure. Forward slashes instead of backslashes--but nothing inherently wrong with putting a path into the source. (To be perfectly fair, it should probably be %windir% too, since that location can change.)
Or use Augeas when available: (from http://augeas.net/tour.html) set /files/etc/hosts/01/ipaddr 192.168.0.1 set /files/etc/hosts/01/canonical pigiron.example.com set /files/etc/hosts/01/alias[1] pigiron set /files/etc/hosts/01/alias[2] piggy save There is a Python library for it as well: https://github.com/giraldeau/python-augeas 
I'm sort of new to python, but is it generally considered bad practice to have multiple return statements in a single function?
Does this work on Windows?
Oh well, ill stay with velruse then, as its older and mature project. (Please dont look as an attack on you, because of this question) Was there any particular problem with it, that you decided that you need to make another library that duplicates the effort? I don't think it's because it had less providers - and adding the ones you were missing would be trivial, so im wondering if it was worth fragmentation.
I don't think it does its stated goal is "Provide a local configuration API for Linux". So far I have used it on Redhat (RHEL), Ubuntu and CentOS. It is supposed to work on Debian and SuSE and other Linux flavors.
Good call. I thought about that when dAnjou mentioned hard coded file paths. 
I tend to develop on OSX, but for Linux servers, so most of my dev is in vim via ssh, ruling out most graphical debuggers, but they went through the trouble of showing how to get it working via the exact tools I already use. http://www.jetbrains.com/pycharm/quickstart/configuring_for_vm.html Bonus points.
I order my imports alphabetically, 1 per line, with stdlib at the top, thirdparty after, then my own project's imports like so... import os import sys import requests import mypackage.foo
Thanks. I'm very new to python and haven't programmed since college. Did I restate the function? When I learned about docstrings, it said to put the input types and out put types, ex: str -&gt; bool. Is that wrong? 
Good call. Fixing. 
What is your target audience ? You might want to look at [FOSSEE](http://python.fossee.in/stvideos), though they might be too basic.
Ooo, even more flash-crashes!
CodeSkupltor looks cool, though dont forget IPython Notebook.
How?
Just thought of another one: colons always have to line up vertically in my code. 
The use case seems pretty rare. What is a node.js developer doing in starbucks without his mac?
Oh! I have never tried it! what are the pros about it?
This is completely bad ass. When my kids go down for nap, I will check this out!!!
* You can have pre made notebooks. * Code is written and run within the Notebook, eliminating any need to switch between an editor and the command line. * As in the standard interactive Python prompt, code and output appear next to each other and it is easy to see the effect of changes to the code. * Unlike the standard interactive prompt, the Notebook allows for easy editing and repeat running of multi-line code blocks. It also has some of the convenient features of code editors such as syntax highlighting, auto-completion, and automatic indenting. * Notebooks have multiple ways of showing docstrings that can be viewed while typing code. * Notebooks have a consistent appearance across browsers and platforms so that students see instructors demonstrating concepts in the same environment they are using.
PEP 8 should really have standardized on tabs over spaces.
thanks I'll give it a try! so what about the syllabus? What topics or functions do you think I should explain?
I was thinking more of a boolean defaulted to false that is altered with a bool. But I see your point about breaking the for loop early. Thanks. **e:** good link, very informative as to WHY you would want more than one exit point.
I would recommend starting with basics of any programming language i.e Syntax, operations, loops etc maybe throw in a demo of python interpreter and IPython. Than move into domain specific things which might be useful to them like matplotlib, numpy and scipy.
Looks pretty clear IMO. Some pointers and nitpicking, mostly about style: - Some comments are redundant, e.g. the ones for imports (especially re) and in the main function. - hosts file location should probably be refactored into its own function (or into the global namespace), so you don't have to change it in two places - validIP and isValidHostName should probably follow the same naming format (start both with "is", or neither) - Positive indexes, instead of negative ones, would be more clear when getting the args into variables.
I'm on mobile right now, what does the escaped code say/do?
IIRC, it makes a big ascii art animal that says "O HAI!!!1"
Live, stock trading? Or livestock trading?
Agreed. This is an awesome looking project, thanks for sharing!
In english you'd say, 'it has the most breakage', or 'it breaks the most'. The way you said it, it means it is the most recent site ever! Which doesn't make sense.
You can always have seperate files, then in your __init__.py import the other modules into the current namespace. To anything calling into the current module it will look as though the other modules are defined within the init.py file (I hope that made sense)
ruby is OFN. Sure it's newer than Python, but nobody's even talking about ruby anymore. TBH the most hipster language in which I write regularly would have to be clojure.
I'm totally new to python and I was searching for an authentication package for Google App Engine. I found gae-simpleauth, which seemed what I was looking for, but I just got an idea how to make it more object oriented. When I started the project I knew little about OpenID and OAuth and didn't expect it to grow to this extent. I don't know why, but I somehow didn't stumble upon Velruse.
Hi there, you could follow our workshop materials if you like. They are designed for afternoon workshops, and go-at-your-own-pace. http://opentechschool.github.io/python-beginners/en/index.html From http://www.opentechschool.org/ :)
ok, thanks for your answer
Anyhow, if you get the escapes right, this might work: open('foo','wt').write('import os\\nos.system("ls")') or execfile('foo')
I tend to put way too many empty lines between lines of code, to make stuff more spacious. It's probably a habit I started when I moved from C++ and JS and wanted to make the scopes clearer. But now I just like it as a way to make the code "breathe" more, between "paragraphs" of code. you can find 2-3 empty lines all over my code, sometimes even 4. 
That's sort of why ruby is hipster, even though it's been around too long. Dated hipsters are STILL waiting for it to become cool. Clojure has also been around too long at this point to really qualify. 
Good looking stuff
probably a little introduction 10 min max and straight to guess the number not bad
thanks a lot! I will check your material!
As I first started reading this I thought, "this is all stuff you can do with a corpus!" But actually, this is much more complex because you set the parameters yourself and made your own corpus, and exactly the reason I (as a linguist) am trying to learn Python. Very cool stuff.
Sort of. The PEP I linked to is relatively quick to read and gives some good guidelines. In general, the very first line of a Python docstring should read like a command, and be short and descriptive. For example, for your `exists` function, I would write def exists(hostname): """Check if `hostname` is defined in the system host file. This function will check if the current system is Linux or Windows, then open the appropriate hostfile and scan it for a definition with the given hostname. """ In programming in general, your documentation should avoid talking about its implementation in specific details, although I don't know how well this applies to you since this seems more sysadmin-oriented (I myself am a software guy). But the first line of the docstring should be a nice, brief, command-style sentence, followed by a blank line. That PEP has got some solid advice if you're interested to read more
sadly, this does not work, as I don't have import, and execfile() only works on python files; however, with the line: **type(vars()['__builtins__'])('os.pyc']** I can get a hold of the module itself, I just need to know how to get execlp() from that so that I may pop the shell
PyQwt is currently not maintained. For now the original maintainer is recommending to use pyqtgraph instead. Check their mailing list to see if anyone has picked it up before starting any new projects with PyQwt.
Matplotlib is not (yet) suitable for realtime work, except with datasets smaller than ~1000 samples. There are some efforts underway to fix this, but it is not yet clear that matplitlib's architecture can be streamlined enough to support data in the 10k-10M sample range. I would recommend looking at Chaco, pyqtgraph, visvis, and galry for faster solutions.
Until Mongo corrupts your data. :/
jeebus that is cool.
Nifty! I would like to see if there was a way to do this that wasn't as subjected to cultural bias (e.g. what is a "feminine" word).
I think it's only minute resolution updates, so probably not.
That's for historic data. Their live trading is a very new pilot program without a lot of public details. I wouldn't assume the live trading would stay on the same frequency as the historic data. That said, the hardcore automated traders who end up involved in flash crashes sit as close as possible to the exchange and make every millisecond count. They're probably not writing their trading algorithms in Python, for speed if nothing else.
CentOS 5 comes with Python 2.4. `yum`, the package manager, runs on Python, so I'm *extremely* nervous about changing the system Python.
Check out [Software Carpentry](http://software-carpentry.org/) They specialize in group training of python and related tools. They publish a lot of their materials for free.
Right, but we *do* have a support contract from RedHat. Thousands of boxes. Writing python in an "enterprise" (I hate that word) environment means writing Python 2.
People care enough to analyze publications and you are proving my point. According to you it's the right thing to do to victimize women. Anyone who says otherwise *must* be a sexist themselves, right? Also, nice on spinning my post as "starting a gender war". Slander tactics much? And what's with the "retweet"? Is it meant as some sort of shaming incase I were to delete my post, everyone knows who "tried to start a war"?
Certainly running the government is worse than being raped or being domestic, amirite?
Because men are never raped or domestic, amirite? And there are definitely 0 women in government.
I don't even need to say who walks fearlessly of a rape and who doesn't. It's about proportions, dude. And yeah, women in power are a lot more rare than men.
The conclusion only comments about the frequency of certain related words in *Times*. It does not make judgments about the roles of men and women in society and the words related to them.
This comment has been linked to in 1 subreddit (at the time of comment generation): * /r/SubredditDrama: [Gender role drama in /r/python](/r/SubredditDrama/comments/1eqqqn/gender_role_drama_in_rpython/) ---- This comment was posted by a bot, see /r/Meta_Bot for more info.
&gt;To be honest, I was a little shocked at how stereotypical the words used in the women subject sentences were.
I'm presuming you are the author of this - if so, there are some coding style issues that might make your code a little nicer: `if len(some_data) &gt; 0:` is best done as `if some_data:` - Python evaluates all non-empty containers to `True`, and empty ones to `False` - this is considered the Pythonic way to check. (In some cases, you also store the length rather than the entire set of data, in those cases, anything non-zero is also `True`, and `0` is `False`, so you can just do `if some_data_len:`. You also use `set([...])` to construct a set - unless you are using a really old version of Python, set literals exist, you can just do `{...}` to construct a set. I also notice that at one point you try to use a dictionary value, then catch the exception if it fails. This is good (*easier to ask for forgiveness than permission*), but you catch **all** exceptions, rather than just the `KeyError` - it's best to catch a specific exception as doing otherwise can mask errors. It also looks like you could do this more easily using `dict.setdefault()` or `collections.defaultdict`. I realise that this isn't meant to be about the code, particularly, but I spend too much time on StackOverflow, so I can't help but comment.
Nope, the case was that the value was another dictionary - so if the key didn't exist, using `.get()` wouldn't work as it wouldn't add that new dictionary to the outer dictionary. An exception is an allright way to handle this, although as I note later, `dict.setdefault()` or a `collections.defaultdict` are better ways. Edit: for an example of this, [see my comment below](http://www.reddit.com/r/Python/comments/1ep9vy/using_python_to_see_how_the_times_writes_about/ca2u4j2).
Oh, I see. Although, I still don't agree with exceptions in that case. A better solution is seen_cases = proper_nouns.get(word_lower, {}) seen_cases[case] = seen_cases.get(case, 0) + 1
You've fallen into the trap - that doesn't work. `proper_nouns` doesn't contain that new dictionary if it didn't exist. `dict.get()` returns the default if it doesn't exist, it doesn't add it to the dictionary.
Oh, you're right of course. Jeez.
Isn't the whole point to show that cultural bias?
This is fantastic! I've been trying to do some basic language processing, like dispersion plots and text concordances, hoping to move to more interactive visualizations like [word trees](http://www-958.ibm.com/software/data/cognos/manyeyes/page/Word_Tree.html). Python is good for the former, but Javascript seems more suited for the latter (as far as I know). I am decently comfortable with Python, but a complete newbie to Javascript. Any pointers on an appropriate pipeline would be really appreciated.
i do exist. i specialize in applications for marketers so i built up a reputation on forums in that niche, made a professional webpage, and beefed up my github account now most of my work comes through word of mouth and recommendations from satisfied clients
I usually just run it from interactive mode. Have you tried running it with sudo? Like `sudo python` then just copy paste the loop and it should work, I would think?
No, the point of this is to show word association. You might be able to make deductions about cultural bias from the results, but there are lots of ways for that to go wrong.
This is actually part of pep8 http://www.python.org/dev/peps/pep-0008/#imports :)
You actually made me chuckle.
shit shit shit, whoever posted http://html9responsiveboilerstrapjs.com/ I'm so sorry I miss clicked and reported it! Hilarious!
You're not detracting from the article, only adding to it. Correct away!
Checking in! Beer money mostly but here's [my oDesk profile](https://www.odesk.com/users/~01587b14659ae3e769). It's not as steady as I would hope for but I'll admit I tend to be picky.
They could go to another, more general corpus (like just a corpus of American English or something), and do a similar study (find all the words that are found with "hers" versus "his," or "women's X" versus "men's X"). Then they could use those findings as a base against which to judge the findings in the Times data. That's just my first thought, but I'm sure there are other ways. 
I exist! I think I'm the only one here that's employed by someone else... I do Django mostly, and I work part-time for the university from home. I only go in for meetings... well, I used to, until I had a baby. Now I call in to meetings. (I tried those freelancing sites and didn't get much traction with them.) There's another guy that does similar work to what I do at the university and works fulltime at it, but just all different projects; there are a lot of research projects that need their own programmer. I'm only on one project so it's a lot fewer hours. But once you get in, you can pick how many projects you want to work on and it determines your hours. My review: most awesome way of working ever. It's very satisfying because you get to work on "whole" projects- not just building cogs. 
&gt; but you catch **all** exceptions, rather than just the `KeyError` - it's best to catch a specific exception as doing otherwise can mask errors. Aside from the other good points you make, this bears repeating. There are only two cases when you should ever write `except Exception`. They're both exceedingly rare. The first one is if you need to annotate all exceptions with some contextual information before re-raising them. The second if you are writing a debugging interface like you can enable in Flask. I really can't think of any other reason.
 if DrZealot is None: sys.exit(1)
I noticed that you have path. On my system at least, path imports os, which means you can just do path.os.system("ls").
 if dr_zealot is None and mr_pedantinc: sys.exit(1) :O
Thanks for searching the plug-ins for me :D
We don't disagree. 
Algorithmic trading doesn't need to be high frequency trading. There is also quantitative trading which operates in longer timespans where the lack of speed in python doesn't really matter. 
I'm a C# developer by job definition, but the application makes heavy use of ironPython as a core functionality*, and a fair part of the build process uses python - both of which I wrote and maintain. I work in an office, but medical reasons prevent me from working the 8:30 - 5:00 the rest of my colleagues do.
Those oDesk rates seem awfully low. One wants a technical writer and pays $1 per 500 words. That's about 32 lines wrapped at 80 characters. They're budget is $600, but to get that you'd have to type 19,200 such lines, or 300,000 words. That's 55 non-stop hours of typing at 90WPM, no pee breaks. That doesn't include all the reading and editing you'd have to do. I feel like this would work out to about $1-$2 per hour over time.
Why do they release 2 versions?
I'm a developer with my own company and I hire with freelancers. And I review code. :) Message me if you're looking for work. I need someone with some Django and some general web skills.
Rates on oDesk vary massively and so does the competence of the contractor. The relationship between the two variables, however, is loose to say the least.
I wish I could exist. I'm a full-time employee now at a company that has some Python projects, but it isn't really taking off because of a lack of other Python developers. Kind of a vicious circle. But when looking at job boards, it doesn't look any better.
It's been a bit up and down (mostly down, recently) but I've been part of a 2-person design+tech partnership designing, implementing and maintaining Python-based web sites for nearly 20 years. How did we find work? Initially, we had a lot of contacts, that helped enormously. We also got lucky (e.g. mildly entertaining case study [1]) - but we had prepared the ground first, so it could be argued that we made our own luck to some extent. After that, it's all been "word-of-mouse", as they say. &gt; most cases your code isn't reviewed or critiqued by another developer As observed, beefing up your github account is one means this end. If you get involved in a good open-source project relevant to your programming interests, that can be hugely beneficial in many ways, including reviews and critiques and sometimes, it can even lead to jobs. &gt; definition of part-time is anything that isn't in an office and/or with regular hours M-F. &gt; what would be a major reason not to hire a part-time developer? See the discussion surrounding the new Yahoo CEO's decision to cut back on working-from-home, there are genuine pros and cons but they are mostly context-specific. By and large, you'd be well-advised to at least know these pros and cons and have worked out an answer for your own circumstances and, if presented with a part-time employment opportunity, how they might apply to the situation and how you might structure things to minimise the risks to both yourself and your employer. PM me if you like, it's always good to talk. [1] http://www.higginsandmacfarlane.net/about-us HTH.
This is some awesome advice and experience! I hope the porting of flask to 3.x is going well!
Indeed, it's a good way to turn debugging into a hellish task.
My colleagues recently held a one day python workshop. They have hosted their notebook at: https://github.com/fbkarsdorp/python-course
Add a `#!/usr/bin/python` line to the top.
Yes, Flask on Py3 would be awesome.
yeah, was wondering the same
If you're trading the CME, porque no los dos?
I sort my imports by length: import os import sys import time import foobar import hashlib 
Werkzeug isn't a server. It's a WSGI abstraction layer.
Werkzeug provides a WSGI server for development. Werkzeug isn't a WSGI server though, that is just one of several things Werkzeug provides and it is by far not the most significant one. You cannot replace Werkzeug and port Flask. So a Flask port is held back by Werkzeug and that is impossible to change.
some time ago here on /r/python i created some preamble that does much of what he mentioned, e.g. `from io import open` for a python3-open in both python2 and python3. either prefix with `if PY2:` or don’t, who cares. and armin’s vitriol towards the changes is imho largely unwarranted. so much stuff got much nicer, and he just bet on the wrong horse with `2to3` instead of an unified codebase.
Or you can say "Meh I don't really need Python 3 to do my work in particular" and continue with Flask and just wait it out. It all depends on your project and how badly you need Python 3 features.
Or even use the sum of all papers as a baseline, so that you're deriving deviation from the newspaper average, so to speak.
People always say things are nicer, but give me one or two things that are really advantageous (the why rather than the how). I've read the Python 3.0 "What's New" stuff and understand some of the changes, but nothing sticks out as "holy crap this would make things a lot easier."
* no other API other than the well-defined and specified one * we remember all of the decisions for all of the code So we start with admittedly unrealistic assumptions and then conclude we can test less. But since we can reasonably reject these assumptions, it seems like we can reasonably reject the conclusion as well.
I use PhantomJS everyday with Python using JSON encoded output to communicate. One of my big issues with PhantomJS is tracing Javacript execution and the outdated JS engine - is phantompy just bindings to PJS or is it wholly seperate? If the latter, do you intend to add tracing abilities? If former, what's the difference between PJS and this? Can't load the github page on AlienBlue...
&gt;I thought it would be a shame to turn it into a gender war. So stop trying to turn it into a gender war. You clearly are. &gt;I'm trying to keep the post on topic. As am I. Did you even read my post? This is a pseudoscientific data mining study. It attempts to glean knowledge by analyzing the data of a publication. One idea the author "learned" is that the publication is stereotypical against women. This statement ignores the entire other 50% of the results. Care to comment on that fact? I would guess no since you aren't actually interested in the topic. The only reason you commented was because I commented on the subject rather than the technique. Would you have commented otherwise? I know that you are too interested in gender issues to see this in any other light. So this is truly futile. But it's people like you who have taken light off of my actual point and slander me as a sexist that derail threads and point fingers stalling discussion. &gt;I retweeted There is no retweeting on reddit. Writing my name like that accomplishes nothing.
Or move to a better framework ;-)
"for what you know" - really check it out yourself, because you have all the right to be wrong, but seeing that you try to argue with me without checking your facts, will make you look spreading FUD. Nothing what you wrote in this post is correct im affraid.
Well thanks for replying with any correct information at all, rather than just repeatedly telling me I'm wrong and nothing else. /s
Was there a particular / applicable-not-only-to-you way of how you got in / started programming for them? Sounds nice (simply coding for uni and getting paid)!
Ok, if you are too lazy to go and actually read ANY documentation or at least my tutorial (which takes a moment to read) and dont value my time, don't expect I'll value yours. It's perfectly fine to be ignorant, covering it with "sarcasm" wont make any difference.
well, it is possible actually, using storm as a module rather than a cli script. https://github.com/emre/storm/blob/master/storm/__init__.py I will try to document it in my free time 
Yep. I see a lot of odesk links, I personally prefer the community around PeoplePerHour. My profile is [here](http://www.peopleperhour.com/freelancer/jerome/python-software-engineer/145291). Django is a very active area to work on, I've gotten a lot of offers from companies that want to scrap their PHP system and rebuild one in Django, Ruby, or whatever the hip new thing is at the time. Also lots of offers for taking up work from a previous developer that started the project in django and/or joining a currently-django-based team. You should look at PPH, though I think it's more popular in Europe than the US.
well, strings vs unicode for a start. in 2.x, we lazily handled text as byte strings, which is fine as long as they happened to contain ASCII, but everything started failing miserably as soon as we were starting to let a bit of unicode text flow around. also much scope leaking got cleaned up, leading to less error-prone code [once the exploits of that behavior were fixed](https://github.com/halst/schema/pull/6). (observe how it suddenly gets clear what x is in the fixed version) iterating over dicts, map, filter, and range gets faster since you get views and iterators instead of memory-heavy lists. truncating division, long, narrow builds, classic classes and all that unintuitive default behavior got fixed. also the stdlib module names got cleaned up. head, *tail = my_list
Or not because I read your link and it's incredibly confusing and a lot of code is being written for no added value.
In that case, I have to politely but firmly disagree based on the two assumptions I highlighted above. Let me start by stating my bias, while I've written a ton of awesome code, I've inherited just as much legacy over the years. I'm going to tell a story. It's not true, but it's not exactly unrealistic, based on my years and years of watching painful things happen on my team. This is about the "It's Overkill" section and specifically the tag_strip() function. If we toss out the restriction that only your one API will ever touch this code and that we forget things (especially over a period of a year or so) then let's imagine you have a new team member who's adding a new API. This team member is still a good engineer, and as such, rather than reinventing the wheel, they take a glance at your code and find that you've already coded a solution for this, but your helper function is maybe 40+ lines with some dense regex statements that's hard to immediately internalize. They see that the documentation + the name suggest that this strips tags. Killer, that's just what they need. Except that they actually do have a case where a single character is passed (something you didn't have) and now they got a bug flagged in QA against their code. Well that's what QA's for! Awesome, they go back and take a look at your code, it's still some dense regex that's difficult to reason about what inputs and what outputs are valid. In this case they might well 1) Write all of those test cases that you didn't write, just so that they can understand what it is, exactly, that your code does. In this case, you didn't really save time by going to the next big thing, you created technical debt for someone else, and probably took more time for someone to re-read your code than if you had just written the test in the first place. 2) Maybe they aren't as careful as they should be, there's a culture of minimal testing at this python shop, so instead of testing the boundaries to understand the code, they just add a comment in their code "Doesn't accept single character inputs or null inputs" (since maybe they discovered both of these) and then start checking their inputs before they pass them to tag_strip(). Groovy it passes QA and they're good to go. Another month later someone adds another API, they /also/ need to strip tags, luckily the prior team member lets them know they found a great helper method to do this, just call tag_strip(). The engineer sees this, and the comment that this code doesn't accept single characters or nulls, cool, that's documented, someone has explained the system. Too bad he's got multi-line inputs that then fail. It's fine QA to the rescue, he also adds to the comments section and adds more checks in his code for inputs. And then DiomedesTydeus joins the team, since this is vaguely the story of my life. The first thing I see is that there's a function that does almost everything I need it to do but I need XML tags. Seems like the right thing to do is consider updating the function. Can I do that? The function is dense, but I'm okay with that, I believe that this is the right thing to do, except I don't know how people are using this code. If I add the ability to strip XML, do I also need to retest every other code path calling this? I start looking at the callers and I find that people are checking all kinds of inputs before calling this function, different inputs, so the impacts of my change might be a lot larger, and worse the logic of tag_strip is now not only in the method, but also spread out across a variety of the methods that call tag_strip in the form of input validation. Realizing that I'll have to raise this to QA to retest not just my new API, but 3-4 other APIs too, my coworker leans over and says "Dude just copy+paste it and call it tag_strip_XML() and modify that one". And there... right there at that moment is when your system crosses over into the pit of legacy hell. (in my defense, if I was told that I'd probably get angry and have a very polite discussion about why that's the wrong solution, but I've inherited this code before) Okay way too dramatic and involved a lot of people making bad decisions along the way, granted, but I'm sort of sticking to my guns that in my experience, you either pay for that test time up front, or later with interest, but I think it's a mistake to think that "It takes too long". One other point I want to touch on and my apologies because this is getting long and TDD fan fic esque. "It’s inflexible". This is, in my mind, sort of the point. If I'm doing that level of refactoring and function changing that breaks 50 tests, that's awesome, I know exactly what systems and boundaries I need to check before I can ship this. Anyhow, lovecraftian tale of software dev over. 
&gt; armin’s vitriol towards the changes is imho largely unwarranted Vitriol about what changes?
Python development is just a swiss army knife on my cluttered tool belt.
umm this ain't mine...i justed posted it.
On oDesk you play on a global level and that means competing with people in geographic regions that have lower costs of living than what you may be used to.
please tell me what to improve then and what is being written for no added value - note it is a tutorial and it's supposed to illustrate some concepts though. I would also love to hear what is confusing so I can improve my tutorial. EDIT: Still waiting for some constructive criticism.
All my dictionaries must look like this: some_dict = { 'key1' : 'string1' 'key2' : 'string2' }
import random drink = random.choice(['wine', 'poison']) return drink 
http://youtu.be/s0F3LKaGN2A
You make a strong case. I'm sold.
&gt; EDIT: Still waiting for some constructive criticism. Get your flair right.
How do you handle insurance for your family?
mitsuhiko _is_ Armin Ronacher. ;-) (and yes, nearly all of the good changes in Python 3 could have been done in Python 2 but weren't.)
In your scenario, no one is writing tests except QA. I don't think it should be taken that far before tests get written. Each person that inherits legacy code should make sure it handles the input they require. And then refactor the legacy code if necessary. Legacy code and third party modules should always be treated with skepticism. And that messy ball of regex code? Well, I've seen more messy code because the author tried to make a function bulletproof and handle all cases. And code that handles input that is never used is more likely to bit be maintained properly. If people practice a bit more YAGNI, there'd be a lot less opaque code. However, I did forget to mention that I really appreciate your perspective and I'm enjoying the discussion. Thank you for keeping it civil. 
&gt; mitsuhiko *is* Armin Ronacher. ;-) …i know. did i say something different? /edit: i’m dumb: i didn’t read the reddit username, and didn’t unserstand what you tried to tell me XD still nothing i wouldn’t have said if i knew. &gt; (and yes, nearly all of the good changes in Python 3 could have been done in Python 2 but weren't.) not the string/bytes change. not the builtins cleanup. not the renaming of stdlib modules. not the scoping rule fix. not the change of map/filter/dict.keys()/… to views instead of lists. so no, i disagree.
Béranger Enselme also did a single code base port of Werkzeug, which he [reported](http://benselme.blogspot.ca/2013/04/porting-werkzeug-to-python-3-experiment.html) a little while ago. Reddit thread [here](http://www.reddit.com/r/Python/comments/1cdwuk/porting_werkzeug_to_python_3_an_experiment_part_1/). 
I thought 'sending messages' was what OOP was all about? 
string/bytes change was trivial and uninteresting, it was the removal of implicit conversion that really helped, and it's not clear this was impossible to do in python 2. builtins/stdlib cleanup is a nice idea in theory but they seem to have stopped halfway. Scoping rule fix totally could've been done in 2.x. Changes to map/filter/etc were nice-to-haves not crucial. I'm not saying there was zero benefit to the compatibility break. Just that it was all out of proportion to the cost.
&gt; string/bytes change was trivial and uninteresting, it was the removal of implicit conversion that really helped you have no idea how much it *helped me* as a python noob *to shoot myself in the foot*. and how much better i instantly got when starting to use python 3 instead. &gt; , and it's not clear this was impossible to do in python 2. builtins/stdlib cleanup is a nice idea in theory but they seem to have stopped halfway. Scoping rule fix totally could've been done in 2.x. how? all those were breaking changes. &gt; I'm not saying there was zero benefit to the compatibility break. Just that it was all out of proportion to the cost. maybe. now way to tell now, though…
apart from what OP said: scraping of JS-dependent sites!
github says it’s a lib (libphantompy) around Qt5/QtWebkit, and a python binding to it. so it’s likely something different entirely, and dependent on the (quite up-to-date) webkit bundled with Qt5.
I really dislike this for the following reason: It's actually pretty easy to test the full boundaries of an API and even get full code coverage if you write **Pythonic test code**. For a simple example, you have a function with three arguments. Each of these three arguments has some set of conceivable inputs. You don't want to do some crazy combinatorics problem to test all combinations of each input? Just wrap the shit in the product function of the standard library. Even better, write a few clever generator classes to generate lots of test inputs and reuse them all over your unit tests. This way, changes to the API result in minimal changes to the tests. Testing is like everything else in life - it's only hard if you never do it.
Then don't use it. Really. We shouldn't have to convince you to use it. If you like Python, Python3 is the future and you will need to move "eventually".
Which one does it use? I always think of Webkit without a JS engine because it has so many.
 Is $12 an hour in Portugal a livable wage? 
That does sound nice. I have a "full-time" gig as a Firefighter... just looking to get some part-time work for my days off. Note to self: go to the university and ask around. 
Thank you for the reply and advice about github... been meaning to push more code there and not just on my blog. I may just take you up on the offer to PM.
When you take work, how do you structure the hours if you need to work with a remote team. Does your contract work tend to be solo missions? 
[hmm, they used their own at one point… and then JavaScriptCore (webkit’s native one), and tried v8.](http://www.mail-archive.com/development@qt-project.org/msg04121.html) no idea.
pow(x,y,z) takes 3 input floats. What range and precision should I use I completely generate a set of tests for this function? How long will it take to run? Is it worth testing if its in the standard library? Probably not. If you write your own function that takes 3 floats, the problem is equally large. If I use generators to come up with my test input, how do I generate the expected answer? If I've got a function that takes one string, how large is the input domain to fully test it? Is size the only consideration? If we also care about what's in the string, then the domain for input is all combinations of all characters allowable in strings. Is that realistic or possible? 
I.....three weeks of......so much Thank you kind sir.
By hand-made, I mean that absolutely no lexer/parser generators were used in the creation of this compiler. In fact, no regular expression libraries were used. I'm pretty sure the only python modules I import are the collections library (for namedtuples), argparse, and subprocess (to compile my intermediate C representation into a binary). This was a semester's course project. The language syntax/semantics were provided so don't complain about the strange language features. Nothing I can do about that. If there are any questions/criticisms/comments, fire away.
make sure to kill python nice and good from task manages. it probably left a process running somewhere which prevents the IDLE from making the network connection to itself it needs. I used to run into this all the time.
Just to let you know, as someone who's made apps in both Pyramid and Flask, and has looked over your tutorial, it's not really like Flask at all. It's much closer to Django. For instance, Flask doesn't come with scripts to create and serve content like `pcreate` and `pserve`, it doesn't come with an SQLAlchemy extension, and it doesn't enforce how you specify requirements. Your tutorial was probably aiming to have a similar-looking finished product, but the frameworks themselves are much more different.
Do you know about [llvmpy] (https://github.com/llvmpy/llvmpy)? I've written a few Python compilers and I must say that is much more pleasant to compile to IR and let the LLVM optimization pass take care of the heavy lifting ( SSA conversion, tail recursion, DCE ) as opposed to targeteting C or Fortran. Can also use Clang you can compile whatever C libs you like to IR and link against it.
Why? Editing the config file is so simple?
Python 3.0 itself didn't bring anything awesome, but it enabled developers to continue, unhindered, its development. Changelog from 3.3 and 3.4 are rather interesting. In the end, the aggregation of all the shiny new things that came since 3.0 will make it worth it for pretty much anyone.
I've always found it weird that a whitespace-significant template language came from the Ruby community and not Python, and that Python didn't seem to have one of its own. Just backwards. Though I love Ruby and Haml, so I'm OK with it. ;) 
I mean, your point is "don't want it? don't use it!" which is very true, but Flask takes the opposite approach in that it gives you basically nothing and you plug in what you want. For instance, I could strip Django of its admin, ORM, sessions, and middleware, and it would basically be Flask with a few handy django-admin.py functions, but that doesn't mean Django is the same type of framework as Flask. Django is "batteries included," Pyramid is "preferred batteries included," and Flask is "wtf are batteries?" &gt;Pyramid doesnt come with sqlalchemy too and never did to my knowledge, you have a premade project template (one of few possible - you dont have to use it) that gives you something like Flask-SQLAlchemy - are you saying its a bad thing? I was referring to `ZopeTransactionExtension`. which is supplied by `zope.sqlalchemy` after you "install" your app.
 head, *tail = my_list Cool! I wasn't aware of this new feature. The PEP is at http://www.python.org/dev/peps/pep-3132/ if anyone else is interested.
TransactionExtension is NOT for sqlalchemy - well not only for it. And nowdays you actually have pyramid_tm if memory serves me right, it can be used to lets say queue an email to user with pyramid_mailer and the email ONLY gets send after everything is "commited" and response is returned to user - sqla CAN be a part of this though, or mongo, redis or whatever you like to use. http://docs.pylonsproject.org/projects/pyramid_tm/en/latest/ Have a read - its an awesome thing to have in any framework. "Django is "batteries included," Pyramid is "preferred batteries included," and Flask is "wtf are batteries?" Thats actually reasonable description ;-)
I was just about to write one of exactly these. However, this is only half useful to me, as I need the other half: Being able to police keys set up on other machines, creating new keys for new machines/replacing old keys, and a way to back up your keys (into something like a encfs partition perhaps). I'll bookmark this and see if I can get some time to hack away at it and offer some patches for additional support.
Editing linux config files is a pain in the ass anytime you're doing stuff in scripts instead of doing it by hand.
Pissing everyone off isn't gonna convince them to use Pyramid ;) - another fellow Pyramid user
Really nice. Had you used a parser generator, I don't think it could have been cleaner.
Ummm, platform, requirements, examples? Or, shall we start making comments featuring the word "headless"?
Have you seen the output of most parser generators? They're hideous, haha. Even so, thanks for the compliment.
I mean it looks better than the input to the parser generator.
So you can distribute your coursework freely?
This is a very small, high-level course and online repositories are allowed.
This is a very good point that I forgot to mention, the realtime plots that I make for my GUI are only 200 to maybe 1000 samples max, where there is only one 1000 sample plot and the rest are ~200. We can get quite a few plots on one Qt window (~15-20) before seeing performance hits, but it is also important to note that we currently don't allow any user interaction.
Can I see an example of some sample code and what your compiler will spit out? (I'm interested how you do looping which looks like goto statements to me)
i checked everything there's no python process running. thanks anyways. 
Did you know that there are no compilers for non-made-up languages?
When you say you have a webserver running, what kind of webservers? Apache? If it is apache, you'll need to proxy requests to your python app. What are you using your webserver for other than to serve your python app? If you aren't using it, you might be better removing apache entirely and looking in to nginx to proxy to your uwsgi or gunicorn process.
&gt; verything started failing miserably as soon as we were starting to let a bit of unicode text flow around. Of course now things are failing miserably when python tries to treat non-unicode text as unicode (e.g. filenames, environment variables).. Basically you gained some, you lost some. Overall, you are not really better off (if at all) while you paid enormous transition cost :-(. 
This is great! I've been learning to write a compiler in python and so far I've only got a lexer written from scratch that uses DFAs. I'll probably use your compiler as a resource.
I am using apache and really just using it as a tool to learn how HTML works. I will try the first thing you told me! I just have to find were web2pi is installed right?
This reminded me of compiler for Java-like language I wrote last year. It includes most of the key features in Java and also extends the language with support for a matrix data type and operations (multiplication etc.). https://github.com/WillSewell/jaml_compiler/tree/master/jaml_files/jaml It's a toy project, but may be of interest to people who want to see an example of: * how to structure a compiler in python * how to use the spark parser generator * how to target the JVM and generate Java bytecode * matrix multiplication (naive) in Java bytecode * how to implement the visitor design pattern in Python * how to test a compiler Enjoy!
Very nice, I've been interested in something like this for a while. A couple of notes: You don't need to inherit from `object` in Python 3. Also, you can call `super()` without arguments. (Scanner)
You also need to delete any .pyc files. I couldn't tell if you knew this based on what you wrote. 
always wellcome to see some contribution :)
Do try the [SublimeJEDI](https://github.com/svaiter/SublimeJEDI)
I understand this is a fairly epic request, but it would be great if you could connect to each host and parse *their* `.ssh/configs`, connect out from there, resulting in a graph of hosts. This would be really handy to answer questions like, if I delete this key from my `authorized_hosts`, will I cut off access to a certain set of boxes? Do I have redundant keys? Can I rationalise my key use? etc.
Haha I suppose so. I just wanted to get across the idea that this wasn't an existing language.
Woah, I didn't know that at all. Thanks for the tips. I'll make those changes when I get around to it
AIUI, the expression ``a+b&gt;c`` is parsed as ``a + (b&gt;c)``. Is this correct?
That's right. The language puts comparative operators at a higher order of operations than addition/subtraction.
Is that a good idea?
I didn't create the language, I just implemented it. In my opinion, comparative operators should have lowest precedence.
We should have a wikipedia page "list of software called storm". Please please, be better with naming.
Holyshitt!! that was it.. thanks so much.. im forever in your debt!! 
I recomend trying to fiddle around with Twisted
I just tried SublimeJEDI and it works very nicely. Didn't know about that one, thanks!
How about GitTip? Or Requests Pro? You can find both for KR on [his webpage](https://medium.com/kr-metadata/1350f97eeda6)
It's a bit odd -- why did you do it like that?
GitTip was what I thought of when I first read it too. But I think what the author was trying to say is that no one is going to become a millionaire with the GitTip model (as it currently stands), and that there might be a more optimized way for organizations and individuals who choose to support open source financially to passively make small financial contributions to the developers who's code they use. It's an interesting, if imperfect idea.
You should check out /r/IPython if you haven't already.
You can use web2py as a standalone server - which is the default way during development. This starts web2py on potr 8000 which will not collide with your apache on port 80. Or you can use apache to serve your pages -- see http://web2py.com/book/default/chapter/13 for details. Or use apache as a proxy to the web2py server - also described in the above link. 
&gt; I really think that something like this will be great for innovation. It will spur more people to contribute to “OpenSource” Yeah poorly probably. By the way, there are ways to thank people you think deserve it. Buy them books, send them postcards, donation. &gt; But he should be. The question is: would ~~he~~ **you** care as much with millions in ~~his~~ **your** pocket? Edit: For the downvoters, I'm not attacking Kenneth you muppets. I've written open sources software for years and everyone has their own reasons to spend so much of their time doing so, but I do believe, if you absolutely want to make money off it you already can through various mechanisms. And similarly, if you want to thank someone, you can quite easily do so already. I fail to understand the point of saying Him or Her should be a millionaire? This falls into the same category of people calling some coders "a fuckin rock star". It's so inane.
 SyntaxError: 'return' outside function
I couldn't agree more. Requests just blew me away so thoroughly that when 1.0 released last December, I was more than happy to [drop $50](http://i.imgur.com/f8sNBJT.png) for "enterprise support." But let's be honest, Requests is just so damn good, I couldn't imagine ever needing support. Fucking Armin Ronacher too, that dude should have a yacht. Incidentally, he [wrote about](http://lucumr.pocoo.org/2012/8/27/open-source-financing/) this very subject last year.
I wouldn't be so quick to dismiss pay once. I think in the example the author chose, for example, pay once works. I agree that it's complicated and that subscription might work best in some cases. 
Interesting. When you say that we've tried this already, what are you referring to? I'd like to read about it.
Looking at http://www.flickr.com/photos/kennethreitz/sets/72157633447625802/ it seems that Kenneth has a 8000 USD Leica, so Kenneth has a "yacht" :) Great photos!
Who will do the same for logging?
The proposal isn't for a "long term business" model per se, it's for a "better than nothing" model. It's a way for open source programmers to see more than $0 and a few handshakes from fat guys for their work. although, once money is involved, it does introduce problems that didn't exist under volunteerism. Projects with many programmers may struggle over where the money goes, and invasive entrepreneurs might try to game the system.
Great question! I manage about 20 mac mini servers and would love a little more automation as well to get me away from having to use ARD all the time. Specifically: * Updating the OS on the Mac Minis bound to my 10.8 Server * Installing programs across all or a subset of macs
Maybe it's because oDesk has something about 3M registered users. People hours has something like 50K as I see on their front page. 
Money is a negative motivator, actually. chub70 is right.
I think it's warty, but not that important as doesn't generally bite people. I accept it as part and parcel of using an "old" language. 
searching gittip for the OP github and twitter accounts returns: &gt; JONATHAN TUSHMAN HAS NOT JOINED GITTIP.
Since installing apps on Macs is usually just a case of copying the .app folder to /Applications, it should be a doddle with Python. No idea about updating the OS programmatically.
Very true but not in all cases... I was more thinking about .mpkg applications I suppose. Specifically we have some Lab View stuff we have to install on multiple machines, as well as drivers... 
He pays for "Requests Pro" https://gumroad.com/l/RRZc
If you really want to go the Python route the [Appscript Module](http://wiki.python.org/moin/MacPython/AppscriptModule) could be what you want. Also the [os module](http://docs.python.org/2/library/os.html) could be of help, though that would also involve some bash scripting. As was already mentioned installing Apps often means copying a folder to /Applications that can easily be done through os.system(). As you can see it could be done, but I personally think you would be better off using another scripting language. If you are really looking for something like PowerShell on a Mac, you could look into bash. You can do everything from there. Other than that you could try Applescript which is integrated into the Macintosh operating System and lets you do quite a lot of stuff.
Commercial software.
So web2py is excellent for people getting started. What you want to do is ditch any sort of web server for now (nginx/apache) and just focus on using web2py. It has a built in webserver that will be fine for any rpi based project. Next you want to work with the [source zip](http://www.web2py.com/examples/static/web2py_src.zip) version of web2py from their site. This is the simplest way to get everythign you need. After extracting the files, you can easily launch the web2py server (which includes an IDE/Debugger for writing your apps as well as the application container/http server for deploying them) using: $ python2 web2py.py -a 'tmp_admin_passwd' From here you can open a browser and navigate to http//:localhost:8000 and you will be shown the welcome app. This is all fine and dandy, however not the best route for actuall development. You would be better off again, downloading the [source zip](http://www.web2py.com/examples/static/web2py_src.zip) and then develop your application on your desktop/laptop and when done, compile and pack the application. Then you can just deploy it in web2py running on the rpi. Also, if you keep your project code in like an hg repository, you can then "clone/pull+update" to deploy. This makes pushing new code trivial. Let me know if you have any questions, I would be glad to help. 
What you've done there is completely miss the point.
This is a good idea. This is not a promise but I will try to work on that in the future.
I'd love to know what this is *for*, as opposed to what it *does*. I understand all the features it talks about, but I still can't see why I would want this in my app, especially given I never need all those features and don't necessarily use them together anyway.
so, how do you exactly list the servers in your config with vim? Yes, editing config files are just the way to go for most people out there, but not all the people :)
Several people have thought about the impact on the creator's motivations, but what about the user's? Would I go and try out random Github projects, and submit pull requests for the odd spelling mistake, if every new project I tried would cost me a dollar? What's really valuable is being able to fiddle with lots of things without ever thinking about money. I don't think an automatic payment trigger is really the best way, even if you opt in to the system as a whole. There are lots of ideas about how we can fund open source development. Gittip has already been mentioned, [Catincan](https://www.catincan.com/) takes a crowdfunding approach, and there are others I can't remember just now. No-one's really hit the nail on the head yet, though.
Sure it makes sense, but i'd prefer it otherwise. Using the global keyword never feels good!
At first glance it looks like it might be useful for communication between a client app and a webserver.
so never use globals ;-)
This is the consequence of not having a `let` or `var` keyword to distinguish variable creation from reassignment.
Maybe. It's just... bizarre documentation. For example: &gt; Once registered with Teleport, a custom data type will become a first-class citizen of your application. Defining an array of widgets is just as easy as defining an array of integers, provided that you made the Widget class serializable. ... but that already exists in Python. A list of objects doesn't care if it's integers or widgets. And even if you're not in Python, you don't need to make an object serialisable for it to be a 'first-class citizen' of your application. Not in any language I've used, anyway.
Very nice script. I modded it a bit: #!/usr/bin/env python import os import pip dists = [] for dist in pip.get_installed_distributions(): dists.append(dist.project_name) for dist_name in sorted(dists, key=lambda s: s.lower()): cmd = "sudo pip install {0} -U".format(dist_name) print '#', cmd #os.system(cmd) Packages are sorted in ascending order by name in an ignore-case way. I use it to update packages globally, that's why the "sudo". If you execute it, it will simply print the commands (dry run). If they are OK, uncomment the last line.
The config file is a list of servers. A GUI app would make more sense. But I'd say that's overkill as well.
Well, I suppose nothing *has* to be a generator. You could just have an iterable class. But generators will definitely save system resources if there's some complicated data structures involved. I think the biggest advantage is when there's some sort of numerical processing, like computing statistics. There are a *ton* of different scenarios where not only insufficient data length but the contents of the data can cause bogus answers or raise some sort of numerical error. Rather than try to capture all cases where the algorithm breaks individually, you come up with sets where each individual input violates some assumption, and test over the product of all those bad inputs. Then test for your code to raise the proper exception. It's very bad for it to spit out bogus answers in these situations. Then, create a set of valid inputs for each argument that border some boundary condition similar to the idea with floats. Then iterate over these and validate the output. Almost always, the first time I've done this with reasonably complex data, there's *some* combination of input that breaks things because I didn't adequately validate the input or incorrectly computed something outside the boundary of valid data. It's much, much easier to diagnose bugs upstream where some type of InvalidData exception is raised instead of a math domain error. I've found these bugs will also *really* piss off customers because they make you look dumb for not considering totally plausible situations. I do agree that customer APIs take precedence over internal functions. I'm not a TDD lunatic who'll argue that you must have 100% coverage before even writing code, but it's still something to strive for even after shipping. An extra week spent refining the tests after shipping will make life so much easier if there's already a fix checked in for the inevitable bug reports.
Thank you for your feedback! I'm going to address that in the docs after work today. To answer your question, it is best suited for web APIs. The dream is to be able to pass around native data from client to client without an *explicit* serialization/validation stage. If you have a Python application that needs to serialize and deserialize data without passing to around, you would be better suited using something like pickle.
That's exactly right.
btw: /u/kennethreitz and /u/mitsuhiko are both redditors :) /edit: But the idea to pay for open source sucks D: You wouldn't pay for a friend inviting you for a kebab neither, would you? You'd but him a beer or something, right? This is the case with open source: just build something he'd like, or send a pull request making his stuff better.
I think the article was suggesting something more like a tip jar.
Morning everyone. As promised: - [Main archive link](http://malone.cc/?tag=leviathan), earliest at the bottom. - [Second post](http://malone.cc/blog/looking-at-leviathan), discussing the elements needed. - [Third post](http://malone.cc/blog/levity-leviathans-templating-engine), talking about building a templating engine. - I'll be tackling the next component (the socket server) tonight. 
I think that's where donations come into play as well as crowd funding like kickstarter.
This comes up every few months by people who didn't bother to even do basic research about the number of times this has been tried. 0. You need to look at the mobile app store numbers before assuming it solves every problem. No one makes any money except the most popular handful. It's a hits based business, like movies. You are trying to incentivize people away from "scratch my own itch" to jumping on the latest bandwagon and hoping to land in the top 3 or 4 projects out of a thousand and make some money. Like we need a Zynga firing out well marketed but shitty libraries that steal marketshare from projects like Requests. 1. This has been tried, it was so awful that Free Software was created as a direct attack on this kind of licensing structure. It won precisely because it was against this suggestion. 2. Read about the differences in behaviour when operating under social norms vs financial norms. Even if this was in place most fairly popular libraries wouldn't make very much money. People will do a lot of work for popularity, respect of their peers, and love of the craft and for free. People will not do much work at all for all those things plus 5K a year. People are irrational. If step one for implementing your idea is changing human ~~behaviour~~ nature then your idea is bad. 3. So no more github forking? Because why don't I fork requests and then add that one to the dollar store? How do you reconcile encouraging forking and encouraging putting up a paywall in front of a project? 4. If you push for changing *the* core feature of FOSS then you better have thought it out ... and at least been involved in some FOSS projects in a non-minor capacity. 
Then the [nonlocal statement](http://docs.python.org/3.1/reference/simple_stmts.html#the-nonlocal-statement) is for you
'Open' does not necessarily mean 'no cost'. The spirit is that anyone can view the source code. Theres a great documentary on netflix about this. The idea of paying for open source software is valid, I mean, these people put work into something that is useful so they should reap some reward. The 'problem' (if you want to call it that) is that you cant let someone have your code without 'giving away the farm'. I find it interesting that this, along with other content (like movies) all fall under the umbrella of 'an idea'. I do not believe an idea can be owned or held in place once it is in the wild. tl;dr; support our 'idea guys' because you can, not because you have to.
except never use pickle, ever.
It is easy to embed code in pickles so you should not accept them from outside 
Well, I think it'd make at least as much sense if `three()` did return 3 -- that is, used the value of the global if `x` was accessed before being assigned as a local. Not that Python is going to change now, but couldn't the Python compiler easily determine that `x` hasn't been assigned yet and use the global value? Then again, one should probably never write code like this, so an error is probably just fine.
Sure, giving something in return is good. I'm just saying that paying isn't. Paying means to me having or being strongly encouraged to give something. That's a bad idea. Free open source lives because you own it, no strings attached.
Great! Just what I was looking for, thank you!
Hmm. I was really trying to keep my first webserver up while also using web2py. I guess I could bring it down, but I have spent hours building it to the point to which it is now. I will try out your steps. Thank you very much!
As an extension to this, I think my comment on the article applies: &gt; I disagree. As a teenager interested in programming one of the great things about open source (in my opinion) is that I can instantly check something out and play around with it. Meanwhile, if it costs money (no matter how much), there's also the added problem on top of the money it costs, there's a constant amount of work consisting of pestering someone with a credit card to act as a "proxy" for the payment since, at least where I live (Sweden), pretty much all means of paying over the internet are 18+. When it comes to "frictionless" payment, what for you might be an effortless way to pay what you consider to be essentially nothing, might just make matters worse for people like me. &gt; PS. Before you mention prepaid store-bought internet payment cards, these have only recently started actually appearing over here, and they still charge ridiculous fees for it (if memory serves me right a 200SEK (~£20) card would cost about 240SEK (~£24)).
I like using a proper Python [distribution](http://continuum.io), because this kind of problem is solved much easier, e.g.: conda update More examples [here](http://docs.continuum.io/conda/examples/update.html). 
The trouble is, Python accesses locals and globals differently, so it kinda has to know at compile time what kind of variable it is.
`nonlocal` is brilliant but, sadly, [python3 only](http://stackoverflow.com/questions/3190706/nonlocal-keyword-in-python-2-x) (the answer describes one way to get around that, though).
&gt;If step one for implementing your idea is changing human behaviour then your idea is bad. I think this is only right sometimes. For example, a lot of open-source projects are tools to make developers' lives easier, changing how they do their work. For example, Bower came out and now I use that to track all my Javascript dependencies. It changed my behavior, and I don't think open-source authors should try to shy away from that.
Already found a bug I think? On here: http://malone.cc/blog/maelstrom The "quick sketch" link is going to: http://malone.cc/malone-dot-cc/scratching-out-an-idea But should be going to: http://malone.cc/scratching-out-an-idea
&gt;be more like buying a beer the guy. I will leave this.
Thanks for spotting that, I recently migrated from WordPress to SquareSpace and some of my links are getting mangled. Fixed now.
In the end, those parameters would still have to be stored somewhere. It's true that pure functions are better conceptually but we're presumably describing a scenario with state, for which closures/classes have to be used at some point.
Slightly off topic here - but what is the difference between requests and BeautifulSoup?
Just a little English tip: you can use "this is **how it looks**" or "this is **what it looks like**" but "this is **how it looks like**" makes no grammatical sense. You've used it twice so I thought I'd point it out.
Sure, if the variables are attributes of classes, you've got the "self" name, and in simple scripts you normally keep your variables in the global scope. But as for other cases, I'm just saying: if you keep the assignments of nonlocals out of your functions and avoid global variables (which you should be doing in the first place), that problem with the scoping system is negated. 
What you're saying sounds a lot like "if you don't use [a problematic aspect] of [a language], then it's no longer a problem." While true, not necessarily the ideal answer. I also disagree that this is a "problem" in the first place; it's more the consequence of certain design choices. IMHO, not being forced to declare initialization is well worth this minor headache (although perhaps if the interpreter put a "this variable is shadowing another" warning unless you explicitly declared it local or nonlocal, that might be a good solution as well).
I think this is an attempt at protobuf-on-top-of-JSON. An attempt at static serialisation types with a non-binary format.
nice! I've found it super useful, plus you get the bonus of getting to use python itself to do the updating :P Mind if I add it to my gist for linux users?
What a load of rubbish! Not only is this the example given in the PEP for enum itself, its also the most common use of enums in any language - to be able to give semantic names to members of a set. http://en.wikipedia.org/wiki/Enumeration Try comprehending an issue first before hitting the downvote button. There is absolutely no point to a separate 'enum' type in Python when Python already has existing ways to label set members, like named tuples and explicit set/dictionary types. This solely satisfies the whims of people coming from C/C++ who want to continue to code in C/C++ instead of Python. 
hello fellow portlander! great read and a topic I have been interested a lot lately so thanks on the awesome article. by the way, ski or snowboard?
&gt; The spirit is that anyone can view the source code. No. The spirit is that anyone can take that source code, modify it for their own needs, and distribute their modified version to others free of care for lawsuits of copyright infringement by the original author. And preferably, free of charge like the manner they received it (but not always the case, e.g. the BSD license doesn't invoke economics, and BSD-licensed code has been used in many proprietary software sold to consumers) Common sense would dictate if your modification is useful to you, it could also be useful to others hence you would contribute back "upstream". But sometimes you've just got a niche problem and need to completely fork instead. But you can, and will walk out of court with a smile on your dial if /u/kennethreitz tried to sue you over "provideanupdation" (your fork of requests). TL;DR: Just being able to view the source code is NOT open source. What makes it open is the right to modify and redistribute.
You don't like the `global` keyword but you're okay with *implicitly* using globals?
This is awesome. I love it!
Requests is the mechanism to get the "stuff", BeautifulSoup helps you search and format the "stuff" that you got.
I'm guessing that he's not a millionaire yet, but he is one of the nicest, and most approachable people that I have met. If you see him, give him a dollar, or better yet, tell others about how awesome Requests is! The more people that know about it and use it, the more the Kenneth Reitz brand value is increased.
thank you.
You're right, but that doesn't mean there's anything wrong with allowing or encouraging optional donations.
If you pickle anything that is derived in any way from user input, then unpickle it later, you may unintentionally be allowing users to run arbitrary code on your server. JSON is completely safe for serialization and deserialization, which I think is one of the many things that makes it so great. For purely local applications, pickle is of course fine (with the exception of applications running as root). For web applications or other remote services, you have to be very careful to avoid security issues.
Now that you've done some work with PyPI. I have a question, what is the feasibility to get good, actionable dependency information from PIP and thus PyPI when installing a package? 
pprint should really do some hackery so I can just do import pprint as pp
I put too few according to pep8, I have a small screen and like my code concise.
You can use it freely :)
You guys do know, that Python is normally interpreted and not compiled. So, there is not really a compile time. 
logging is perfectly fine as it is
From what I understand (correct me if wrong), although python doesn't "compile" per say, it does run/create all classes and methods at indent level 0 before executing main(), Which can create pre-execution or compile type errors
Assignment creates or modifies a local value. Accessing a value that is not assigned locally falls back to the global. If the same function appears to do both Python refuses to guess which one you meant and gives an error. Yes, it's different from other languages, but perfectly consistent and less error-prone than any alternative that does not involve having to first declare everything.
No, it is not. The CPython interpreter can only interpret bytecode, not source code directly. You may elect not to store the bytecode in a pyc file, but the compilation must happen internally for any execution to take place. It's just a less visible step than with languages like C or Java. Note that this applies to CPython specifically, although I believe most python implementations function the same way.
This one ;-) from __future__ import braces
to wow them: functions are objects, classes are objects.. everything is an object! and why that matters: my_fancy_func(my_class): #do some magic new_object = my_class() # put that in your pipe and smoke it also, ask the java guys how to read line by line from a text file :D
Be prepared to answer why you don't need getters and setters in Python.
&gt; But what if 15k people were buying you a beer? lol, i think if devs would get too many beers, they’d complain: that’s a very constructed argument. sure, everyone doing great stuff should get more money for it, but i’d rather not receive any money for my OSS than paying for every OSS i use.
Interfaces and abstract classes. Duck typing removes a lot of boilerplate.
To add to this: If you want to add custom behaviour, you don't need to subclass `my_class`, just pass a wrapper function that does the right thing: def my_special_class(): o = my_class() o.foo = 1 return o my_fancy_func(my_special_class)
Seconded. I shit you not I have 86 entries in my work ssh config. If people can't imagine a use for this then they're not thinking big enough.
Here's from someone with a background in Java. * How do you pack your program on a USB stick and send it to a client who then runs it off that stick? * What comes instead of Maven, the tool that understands your project dependencies and their dependencies, and brings you all of that from the internet while making it all make sense? * If you change your code but have no compiling stage, how do you make sure you didn't break anything? (I still try to figure these out myself.)
You said you are still trying to figure them out, so here are my takes on that: * Create accompanying .bat/.sh files that run your scripts (and tell the user to install python if he hasn't) * Usually, projects come with a requirements. txt and/or a setup.py which contain the dependencies. Install via pip, and if you don't wanna clutter your system, use virtualenv * You write tests. ;)
Don't want to hijack OP's thread but: In Java, you can do $ CLASSPATH=1.jar:2.jar:3.jar java com.acme.demo.Start and after five minutes, $ CLASSPATH=5.jar:6.jar:7.jar java com.acme.demo2.Start In Python, to achieve that I seem to be in need of creating two virtualenvs, pip install-ing the respective packages in them (provided they are pip install-able which majority is but a minority isn't) and then pip uninstall-ing them to clean up after myself. Wrt #1, I want to include everything (think of numpy/scipy). Not sure .bat/.sh gonna cut it. Wrt #3, I write tests in Java as well, but first line of defense is a compiler. 
Use comments to insert trendy hashtags into your code! def fire_ze_missiles(city): #YOLO pass
That's just not how F/OSS works. Software is available to no cost, with no strings attached. Developers create software because they're passionate about what they do, and maintain it because it benefits the community that they're a part of. Open Source isn't a direct way to make money - it's a direct way to establish credibility within a community. Kenneth would not be "Python Overlord" if he'd not written Requests, but Heroku isn't paying for Requests; they're paying to have his skills put toward with their product, and for the visibility within the Python community that he brings through name recognition and through his speaking at conferences.
You can use `PYTHONPATH` to manually control what directories are searched for libraries. Not that you should, virtualenvs do the heavy lifting better than humans, abstracting away any little details you may need. Packages that include compiled code must be built for the platform that runs Python. Python on Linux isn't the same Python as the one on Windows, in this sense.
Maybe you should ask over in /r/java.
you don’t? but properties have getters and setters, too ;)
mixins! much better than interfaces.
I think the important things are the changes in mentality. Java developers tend to be in the mindset of 'everything should be a class', while in Python, everything is an object. In Java, if you want to pass some functionality around, you make a class that acts as a container for that functionality. In Python, you'd just pass the function around. Java developers tend to think exceptions are evil and should be avoided. In Python, the mantra is *it's easier to ask forgiveness than permission* - catching exceptions is generally better than looking before you leap, as it avoids race conditions, makes code read better, and allows you to just let the error flow up to the caller naturally if you can't handle it. Likewise, it's good to note how this means you never have functions returning `null` (`None`) on failure, which means less hard-to-debug NPEs. The main attraction to Python is often development speed and maintainability. Show them some examples of Python code, and how short and effective they can be. Parse some XML and show off how easy ElementTree makes it. Show off how properties mean you don't need to make getters/setters all the damn time. There are some things they might find disconcerting. The lack of data hiding, the awkward syntax for iterating over numbers (`for i in range(...):`, the lack of a `++` operator, etc... These things are generally all disconcerting for them because they are use to Java, where these things are core to the language. In Python, we don't need them, the different philosophies and structures of the language mean they are really just not useful.
Normal life insurance for the family, nothing special, I also have (I'm in the UK) public liability insurance (say, I drop a laptop on someone's foot and break a toe) and professional indemnity insurance (say, I type "delete from customers" by mistage) for £5M. The latter is the expensive bit, the liability and the indemnity come to about £350/year.
You won't and that's why python is so good: it doesn't have wows and magic (mostly). Python best feature is the almost (in)ability to hide logic in the code.
About 1/3 is solo, or effectively so. The rest is one contract, really with only one other person. Generally its quite flexible so a lot of the time I can pick hours to suit (look after the kiddies, fix my Landy ....).
Cool. I'm inspired.
* Use IPython &amp; show them autocomplete &amp; embedded images * Use [requests](http://www.python-requests.org/) to connect to a service using HTTPS, ignoring any HTTPS errors * Returning multiple values. This example maybe useful image_files = [os.path.join(root, f) for root, _, files in os.walk('.') for f in files if f.lower().endswith(('.jpg', '.gif', '.png'))] * Function &amp; class decorators * Django admin They will ask some of these questions * Indentation * No IDEs for Python * Python is slower than Java * Python is open-source, and open-source is not supported * Open-source is not secure * Interpreted means that they can "View Source" and see my source (Yes I heard this one) * It's not object-oriented * It's not object-oriented enough (no private/protected)
 with open('filename.txt', 'r') as f: print f.readlines()
This creates the ability to assign an arbitrary class to the object in the function. For example, if we pass "Foo" to my_fancy_func, then new_object will be of type "Foo", whereas if we pass "Bar", new_object will be type "Bar". I'm sure you see how that could be useful.
Advantages: * You don't need something like Eclipse, a good editor is enough * The development time is *a lot* quicker * You can still test your code with unit tests and various code checkers * Python is arguably more widespread than Java on OS X and Linux, and installed by default on every distro I can think of * You can deploy Python applications on Windows without requiring users to install Python first * The special functions (`__add__` etc) makes it easy to make beautiful container classes * Reading a textfile is easy, not painful * Functions don't have to be wrapped in classes * Easy to browse the documentation and use a new API. No need to dig up what kind of type that FactorySingletonGenerator needed as the third argument and then use the FactorySingletonArgumentGenerator to make it. One short line instead of five long ones, with more clarity. * Less code is less room for bugs. With Python you can get away with less code. * The speed of the resulting programs is not a problem and you can write your own C-modules if it is. Python connects easily with C. There's also Cython and PyPy. (Remind them that JavaScript (asm.js) is now faster than Java, so if speed is an issue, they should switch to JavaScript). * No Oracle Edit: typos and clarifications
Good to see some ethical programming... 
No I do, and I actually feel kind of silly for asking. I was too quickly jumping to the thought that this might be doing some unique behavior, when it's actually just doing exactly what it looks like. x_x
&gt; You can use PYTHONPATH My issue seems to be in having to *install* libraries, not configuring where to search for them. Where in Java you download a jar, in Python you download a library and have to install it then. Take something like scipy that takes 40 minutes to install (Fortran '77 compiler and all that), think about 60 AWS instances ... etc. My today's issue is this: $ time pip install --upgrade "lxml&gt;=2.3,&lt;2.4" Requirement already up-to-date: lxml&gt;=2.3,&lt;2.4 0.64s user 0.51s system 0% cpu 5:50.81 total So it's 6 minutes to figure out that ... nothing should be done? &gt; Python on Linux isn't the same Python as the one on Windows Which raises the question, is Python cross-platform? To which the answer seems to be: yes, it mostly is. To be fair, Java also has a way to invoke non-portable (native) code, but no one seems to use it.
&gt; I don't think two virtualenvs are that bad Neither do I; it's just more work. &gt; I'm sure there's a wonderful packaging solution I sure hope one is at least being created as we speak. &gt; you can change your code in faster iterations I'm not sure I see where it is faster.
Just out of curiousity, what is awkward about for i in range(...): compared to java?
Most people I know argue that the `for (int i=0; i&lt;5; i++) { ... }` syntax is better. I think it's most likely just a familiarity thing, but either way, 90% of the time, when people complain about that in Python, it's because they are looping over lists the wrong way. 
I swear, if we do ever go into all out nuclear war, and one of the head of countries uses #YOLO after launching, that would make my day.
Would you not have to return the object at the end of the function?
You would if you want to use the object outside of the function...is that a problem?
&gt; Tests. Lots and lots of unit tests. Which you should have anyway. I do. But for fragile code changes, I think having static type checking *and* an extensive set of unit tests is better than having just an extensive set of unit tests.
&gt; You can't, but you can't be sure that changed code that is compiled won't break anything either. You're right that one can't be 100% sure. But being 99% sure beats being 80% sure.
I agree with familiarity. I heard a lot of complaining from 1st year CS students about how weird Python's syntax is, because they had been exposed to C in highschool.
I'd be happy to read it. Though I would probably not pay for it, as most of the information should be available online anyway.
No, I just got the impression the function was being used simply as a way of creating new objects.
You ought to mention Jython near the end of your talk, and sell it as a great prototyping tool for Java programming. Jython is, as a last resort, the thin wedge ;-)
&gt; * Use IPython &amp; show them autocomplete &amp; embedded images /r/IPython notebook may be a good starting point for existing programmers. As would def main(): '''Prints "Hello World!"''' print("Hello world!") return 0 if __name__ == '__main__': import sys sys.exit(main()) * http://scipy-lectures.github.io/intro/language/python_language.html &gt; * Use requests to connect to a service using HTTPS, ignoring any HTTPS errors * http://urllib3.readthedocs.org/en/latest/ * http://docs.python-requests.org/ * http://wiki.python.org/moin/SSL * http://docs.python.org/2/library/ssl.html * http://docs.python.org/3/library/ssl.html &gt; * Returning multiple values. This example maybe useful This returns a list() created by a list comprehension. It could also return a generator expression by replacing the enclosing square brackets `[]` with parentheses `()`. http://scipy-lectures.github.io/advanced/advanced_python/index.html#iterators-generator-expressions-and-generators &gt; * Function &amp; class decorators * http://docs.python.org/2/howto/functional.html * http://docs.python.org/3/howto/functional.html &gt; * Django admin * https://docs.djangoproject.com/en/dev/ref/contrib/admin/ * http://en.wikipedia.org/wiki/Scaffold_(programming) &gt; * Indentation * http://docs.python.org/2/reference/lexical_analysis.html#indentation * https://pypi.python.org/pypi/pep8 * https://pypi.python.org/pypi/flake8 &gt; * No IDEs for Python It is possible to learn and program in Python without a tools dependency. * http://wiki.python.org/moin/IntegratedDevelopmentEnvironments#IDEs_with_introspection-based_code_completion_and_integrated_debugger * http://www.pythontutor.com/ &gt; * Python is slower than Java * C is faster than Java * Python development is faster than Java development * PyPy and Cython are, in many cases, as fast or faster than Java. * http://en.wikipedia.org/wiki/Software_metric#Common_software_measurements * *Bugs/LOC* metrics -&gt; less LOC =&gt; more maintainable components &gt; * Python is open-source, and open-source is not supported * Java is open source * Can you fix it now? &gt; * Open-source is not secure * Most web sites are delivered by open source web servers, routers, and operating systems. * Most of the Top 500 supercomputers in the world run on open source. * [FUD](http://en.wikipedia.org/wiki/Fear,_uncertainty_and_doubt) is what people who can't code do. * It appears that "open source security" has been search-bombed. * http://www.coverity.com/company/press-releases/read/annual-coverity-scan-report-finds-open-source-and-proprietary-software-quality-better-than-industry-average-for-second-consecutive-year * https://en.wikipedia.org/wiki/Open-source_software_security#The_debate &gt; * Interpreted means that they can "View Source" and see my source (Yes I heard this one) * http://en.wikipedia.org/wiki/Input_validation should, at a minimum, be performed on the server side. * https://en.wikipedia.org/wiki/Security_through_obscurity doesn't work. Expect that someone has the source. Who has the source code? Where are the backups? &gt; * It's not object-oriented * ["Python is a multi-paradigm programming language"](http://en.wikipedia.org/wiki/Python_\(programming_language\)) * http://www.reddit.com/r/Python/comments/1e35ki/convention_what_are_the_advantages_and/ &gt; * It's not object-oriented enough (no private/protected) Read-only properties can be accomplished by annotating a getter function with [`@property`](http://docs.python.org/2/library/functions.html#property) and not defining a setter. 
How do I make code that is extendable without requiring it be modifiable? How do I create interfaces in python, or the equivalent of writing an implementation that conforms to an interface? What build system do I use? 
If you're using a virtualenv why are you uninstalling? You can just blow the virtualenv away, or pretend it never existed.
* Why you don't need getters and setters, and why public variables are not the devil. * Being able to pass functions rather than an instance of an object that implements Callable. * Not needing classes to hold functions. * Multiple classes per file
I usually find that the type of bug that is found by the compiler is the type that is easy to find with or without a compiler. It is the ones that compile perfectly fine, run without error, and give the wrong answer that are tricky.
Portable GUIs?
You're right.
&gt; No IDEs for Python Pycharm!!
&gt; I'm sure there's a wonderful packaging solution &gt;&gt; I sure hope one is at least being created as we speak. * [PEP 427: The Wheel Binary Package Format 1.0](http://www.python.org/dev/peps/pep-0427/) * http://www.reddit.com/r/Python/comments/1785dd/ipython_notebook_workshop_report_one_of_the/c83lg8u * https://github.com/cloudmatrix/esky/ (How do you update a USB drive?) [EDIT] http://pythonhosted.org/distlib/tutorial.html#using-the-wheel-api 
* [Cross-platform](http://en.wikipedia.org/wiki/Cross-platform) [Repeatability](http://en.wikipedia.org/wiki/Repeatability) and [Reproducibility](http://en.wikipedia.org/wiki/Reproducibility) * http://stackoverflow.com/questions/15762943/anaconda-vs-epd-enthought-vs-manual-installation-of-python * http://docs.python-guide.org/en/latest/scenarios/scientific.html
Think about giving a demo of pagan worship to a bunch of Southern Baptists and that is about what you should expect. I believe that many different problems have different ideal languages. Java people tend to believe that there is only one true language. So I would focus on what Java is really really terrible at which is short sweet programs. Bring in a csv file. Noodle it. Pop it into a database. All in 5 lines of code. This is the sort of thing that is a total pain with Java. This way you don't waste your time trying to convince them that Python is a good replacement for Java but that Python will make their Java better. Then after a while their Python programs might start to grow. 
If you separate your data from your code, you could update your image once and spawn that? * http://docs-v1.vagrantup.com/v1/docs/base_boxes.html * http://en.wikipedia.org/wiki/Amazon_Machine_Image#Types_of_images * http://docs.openstack.org/trunk/openstack-compute/admin/content/creating-new-images.html
This might have made my week. I'm going on vacation shortly, and leaving the reigns of our application in very capable hands. However, they aren't capable in python. My scripts are click-to run anyway, with simple variable configuration. This tool will allow me to lazily build a CLI without having to package an executable....I can't wait to try it out.
Looking forward to it. :)
Thanks! I do have a mailing list on the site if you want updates, though I'm sure I'll be posting here too.
Is that really where your thoughts will be in your final moments?
If you provide all three parameters for range, it's not that different. 
Classes are objects in Java too, so that's not a great example: public void my_fancy_func(Class&lt;T&gt; clazz) { #do some Java magic Object newObject = BeanUtils.instantiateClass(clazz); } Lambdas would make a far better example, but only for a limited time (when they finally release Java 8 next year, it will most likely have lambdas). Reading line-by-line seems pretty easy too: File file = new File("filepath"); Scanner input = new Scanner(file); while(input.hasNext()) { String nextLine = input.nextLine(); } input.close(); I make heavy use of both Java and Python, and there are pros and cons to both; each is useful in different situations. Try explaining why you don't need static typing to a Java programmer working on a million-line behemoth project with 10 developers, and you will most likely be laughed out of the room. You should laugh the same way if a Java developer tries to explain to a you why a 10,000-line prototype needs static typing. It's all relative to the task at hand. 
WingIDE too (though it feels a bit bloated at times)
Agreed. I'm not sure I'd pay for a book on Flask, but I'm convinced it'd be valuable. Finding all the right answers online, and the conceptual info to join the dots, takes time, and time is money.
I appreciate the validation on the value. I hope other people agree that it's valuable, though I hope they disagree about not paying!
relevant: https://github.com/kadirpekel/komandr
Yeah. As opposed to java, where by running $ mvn assembly:single you get an executable jar, containing everything ever needed. You then copy/publish/scp it to your destination on any platform, and run it by $ java -cp myjar.jar 
Why don't you?
I guess I don't believe you: did you mean you mean to say instead "most people I know *claim, without presenting any argument* that `for (int I=0; ...` is better"? Because that I would believe. If you really meant what you said, would you mind sharing their arguments?
We're going to have a python-vs-java pissing competition... ...on /r/Python? Is your point, "java is purpose-built with platform independence and easy packaged shipping mind?" if so, you're right! Yay! That's why it's so widely in use in production in giant multinational corporations with mercenary armies of outsourced programmers. Python is built with things in mind too - readable, concise code, easy prototyping and fast development, good-enough object oriented design and fast implementations. You want to talk about the frustrations of having to compile numpy and scipy? What about the frustrations of not having them at all? Java has a variety of ok math libraries but I haven't found anything nearly as fast or flexible or widely used as those. And now you have things like pandas for data manipulation that are just blindingly quick, thanks to cython and general close integration with c code. One of the reason the math and science libraries are so good in python is that it's a fantastic language for environments like finance and science where many of the developers are not software-architects-by-training or even software-architects-by-profession: it's readable and relatively easy to write casually. And it's in plenty wide use at very well regarded engineering firms as well - certainly Google uses Python heavily, though at this point I think they use pretty much everything. I understand that this thread is about "talking about python to java developers." Obviously, there are places where java is more appropriate and places where python is more appropriate. Still, I think we can agree "Ways in Which Java is Better Than Python" would be a lousy title for a "quick introduction to python for java programmers" course. 
I'm sure that the Python powers-that-be have a good reason for not doing this, but I always thought it would be nice if you could do, for some array myArray, for value,index in myArray: ... 
&gt; Regarding 3, that's just what can happen in my opinion. On the upside, you can change your code in faster iterations. Syntax errors are analogous to compile time errors here.
&gt; I do. But for fragile code changes, I think having static type checking *and* an extensive set of unit tests is better than having just an extensive set of unit tests And usually Python programmers think having a dynamically typed language is preferable to having a statically typed one.
Using pip commands you can speed up pip installations. set a timeout with '--timeout' and use mirrors with '--use-mirrors' or '-M' http://www.pip-installer.org/en/latest/usage.html
Security by being closed-source is a broken concept. But some people still just can't understand why.
Thanks for explaining I just did that this week. But when I looked at the example I went like "say what?!?"
Hey, OP asked what questions to expect from Java programmers, I chimed in on what I would ask. It's the kind people of /r/python who suggested the solutions for my pain points, and I then answered why these don't help me. No "pissing competition" here, and I certainly didn't want to hijack the thread. I merely suggest topics that are likely to arise in any "python to java developers" talk.
Must be different here (in the US). A company that pays for the various insurances saves me about $1500 per month, which is about half of the average person's take-home. 
Practical yet simple example from my current project: if user.is_authenticated(): form_class = ContactForm else: form_class = AnonymousContactForm form = form_class(request.POST) if form.is_valid(): form.send_message()
Compile time errors are much more comprehensive than simple syntax errors. The Java compiler enforces the contracts imposed by interfaces, guarantees member accessor validity, and (to some people's chagrin) attempts to ensure exception safety. The best the python interpreter can do is tell you when you have invalid syntax. All the other issues emerge at runtime.
I would like to see the issue of organizing larger Flask projects addressed. It's really simple to build a toy flask app and then keep adding stuff on. It's more difficult to build a well-designed and maintainable Flask app. 
In Java, you use getters and setters so that everybody codes against them. Later, you can add code to setter or getter, doing other things. That's impossible (in Java) if you write or read directly from members. No one knows if this code addition will in fact happen later, so the convention is to create getter/setter for everything, just for the case. In Python, you can program writing to or reading from attributes. If you need to add code later, you override `__setitem__`/`__getitem__`. Since it's so easy to add later, nobody bothers with setters/getters.
 for idx, value in enumerate(myArray): .... This is how you do that. 
&gt;boxes that don't even have Java installed Which should be all of them ;-)
Unit tests are great, but they don't help here. I'll tell you what I don't like. I don't like chasing down stupid bugs by busting out the REPL to figure out what the properties of an object that I have no control over will eventually be. Unit tests don't help me with this. In Java, the class is self-documented, at least insofar as I know what members it has, or the method is self-documented insofar as I know what exceptions it can throw. Writing unit tests in Java is *easier* for this reason. 
No disagreement here. OP needs to explain that to Java programmers though, and these do not necessarily think that.
You're after the built in [enumerate](http://docs.python.org/2/library/functions.html#enumerate) function.
Thanks for the great tips guys. I plan on doing my demo inside iPython notebook (something I picked up attending local python meetups), I think that alone should be able to "wow" them. My plan is to show them how to perform everyday tasks pythonically and rather than comparing it to java directly, make them think about how they would do the same thing in java.
Be prepared for them to complain about all the boilerplate you're not writing. No, I am **completely** serious. "What, you're not writing private properties and giving them getters and setters? WHERE'S THE ENCAPSULATION!? HERESY!!!" Seriously, they'll have 1000 preconceptions about the best way to formulate an object model and how to use it, and they'll all be from java; python has a lot of subtle and not-so-subtle differences of opinion to java, so you should be prepared to defend it. Also, be prepared for them not to see *any* of the advantages of dynamic typing as worth it.
It does have its place, though. For example, if you're a country trying to keep your communications to spies secret, then while security through obscurity can't be relied on, it doesn't do any harm not to let slip the algorithm. The only reason this case is valid is because you can trust that there aren't any deliberate backdoors. However, if you want someone to trust your code, then open source is the only way.
Welp, time for me to go home. Thanks!
&gt; I’m setting the goal of publishing the book on August 1, 2013. I have June and July to write, edit, market, and launch the book. It may be slightly ambitious, but I plan to have a lot of time on my hands. Sounds indeed ambitious but all the best nonetheless :)
Show them generators.
Better to give a new function of the same name the `@property` decorator.
Yeah... microsoft's code is all proprietary, and they've never been hacked, amirite?
Or Netbeans, or PyDev.
Good code does exactly what it appears to and nothing else. 
I upvoted you for bringing performance to the table, especially in the java crowd who have a thread pool for everything. However I'm having a hard time grappling with "clarity of intent". I find the immense brevity of pythonic code vs java(itic?) code to be much easier to read and clearly understand the business logic. You seem to be coming at this from a type checking perspective, so by "Clarity of intent" do you mean that you can just stare at a method signature and know what it's after? If that's your position I can sympathize, but sort of as others have mentioned, I think this is mitigated heavily by testing. Need to consume a function from another team and want to know the inputs? You should be able to just glance over their unit tests as another form of documentation. But in a massive massive system sprawling hundreds of thousands of lines of code, it's going to be a pain. To that end (and I've never worked on a python project that size) I've just noticed that python projects I've worked on don't reach that size. I'm not sure if it's the mindset of the team, or the language just does the jiggy with your brain, but I notice when my python projects reach a certain size that they start to separate themselves off into other services or components so that hopefully you're never dealing with a single project of that size. Of course, I'm possibly just lucky that my team has worked this way, people can write horrible code in any language, and you're probably right that badly written java is easier to read than badly written python. 
Interfaces don't DO anything. They're just there to enforce type safety which starts out silly but gets progressively nicer as your codebase and development team grow. There is no universal better. 
Some more proof: http://programmers.stackexchange.com/a/136944/63889
&gt; How do you pack your program on a USB stick and send it to a client who then runs it off that stick? I use http://www.pyinstaller.org/ Basically it creates a single executable binary for Windows, Mac and Linux that includes everything you need to run the app.
I gave such a demo (actually held a workshop to teach python to Java/C# programmers) a few years ago. Hopefully [these](https://docs.google.com/presentation/d/1TkXXcRfQy716YgE0aVsLLPIMiF2kPt0DgxRP2545NhQ/edit#slide=id.i0) slides help.
I haven't tried it, but some people I know who work on both Java and Python say Idea is a dream.
See, as a C# developer, I disagree. A subtle but important advantage of Python over C# - or Java - is how expressive the language is. My example is there to demonstrate how Java's syntax tends to be unnecessarily verbose - Python can use half the words to describe the same operation. Being succinct is a huge win when you have to read someone else's code, because shorter code is more readable. As for your second argument: once upon a time, I would have agreed with you that static typing is nice and convenient. But having seen some really gnarly generic type definitions, I'm not so sure anymore.
By clarity of intent, I'm referring to the contracts Java's compiler imposes on you. Yes, unit tests help with this, because you can just look up the intended use of the module in the tests themselves, but when you've been coding for 6+ hours, and you're trying to deliver an update by a deadline, having to go back to look up the usage for the obscure method for the nth time is just a pain, especially when you factor in that Python code is so dense that it can be rough to track down *exactly* what you're looking for. I'm not just talking about number of arguments, but their types. In Java (even without an IDE), the compiler lets you know when you've goofed. Furthermore, with static typing, and member access control, a well designed API can make great strides toward ensuring that, if you have a reference to a value of a given type, and it's not null, then it's a valid object. It's not perfect, but it usually works in your favor. With regard to brevity, I don't really care one way or another. I find the "ceremony" of Java's type system refreshing. It leaves nothing to the imagination. If you see: int x = getTheThing(); You know x is an int. If getTheThing doesn't return an int, the compiler won't let this program be, you know, a program! In python: x = getTheThing() You have no implicit idea what x is. If the code was well written and well tested, it's probably an int, but you can't be SURE it's an int. What if there's an errant, untested corner of the function/method that returns a float? Or a string? Or None? Surely it won't do that? Are you sure? In Java, I'm sure. The only thing I have to test for is null, and with functions that return primitives, I don't even have to do that. To write python code that is as safe as the Java code, I have to do this: x = getTheThing() assert(isinstance(x, int)) Compared to: int x = getTheThing(); Python's looking pretty verbose :)
&gt; However, when you've crossed the paging threshold for your mental working space, you need constraints to remind you of how things work. Things that Python programmers often dismiss, like static argument types, interfaces, etc, help keep these constraints in place to keep you from inventing strange new error conditions. * [interfaces.py](https://github.com/Pylons/pyramid/blob/master/pyramid/interfaces.py) * [exceptions.py](https://github.com/Pylons/pyramid/blob/master/pyramid/exceptions.py) * [HTTP exceptions .py](https://github.com/Pylons/pyramid/blob/master/pyramid/httpexceptions.py)
I don't think `global` would really help here anyway. It indicates that *modifications* to the variable will be made to the global, which I doubt is what you'd want (unless you actually intend the global to be changed). One option would be to use the globals() dictionary. Ie: x = globals()['x'] + 2 But really, I'd say by far the best option is "don't call the variable x" - it's generally a good idea to avoid variable shadowing in general, and *especially* if you actually intend to *use* the same name for both variables in the same function.
&gt;Bring in a csv file. Noodle it. Pop it into a database. All in 5 lines of code. Dude. That's a Perl one-liner. People are doing something about it: https://github.com/gvalkov/python-oneliner
Bad programmers will always write bad code, in spite of the tools. I've seen some *GNARLY* stuff written in Python. Also, noting your C# development experience, I should point out that Generics in Java are nowhere near as crazy as they are in C#. They're implemented using type erasure, at compile-time, so the complexity can only go so deep.
https://pypi.python.org/pypi/PySide
* Show off the closures and first-class functions, as well as an an example of implementing a class via a closure * The [various object methods](http://docs.python.org/2/reference/datamodel.html#basic-customization); the fact that you can implement a \_\_str\_\_, \_\_lt\_\_, \_\_cmp\_\_, etc and have it "just work" should be wowering. * Don't forget [properties](http://docs.python.org/2/library/functions.html#property) in lieu of the disgusting getters/setters * Generators! `yield` a few easy iterators. Better yet, compare them with some java equivalents. * List comprehensions (maybe)
OP was about Pythonic succintness. Templates and generics are cool. Python has `isinstance`, but `hasattr` is much preferred: http://www.canonical.org/~kragen/isinstance/ * http://en.wikipedia.org/wiki/Duck_typing#In_Java * http://en.wikipedia.org/wiki/Duck_typing#In_Python
You're right, using hasattr is more idiomatic in Python. I was just using the matter to make a point. Writing succinct code feels cool and elegant, but I've found its value in larger projects lacking. Even though verbose, Java's syntax leaves little to the imagination. (There are exceptions, of course.)
&gt; With a bit of cleanup afterwards we were able to come up with a nice codebase that runs in all versions of Python and also looks like regular Python code for the most time. I kind of think this would have been a better way to go with Python 3 in general. IIRC such a polyglot approach was discouraged in favour of the 2to3 method, but I think the transition would have gone much more smoothly if the changes were designed to support such an approach. Maintaining two codestreams is a pain, and even if one is generated from the other since the conversion slows you down (and in practice, you generally *do* often still need to tweak the source to get it to translate correctly *anyway*. Having a subset of python that was legal for the most recent (even if this version was newly released at the same time) 2.x stream and also 3.x would still allow breaking with a lot of backward compatibility issues where this provided gains, while still making the transition process a lot closer to the minor version upgrades. They do seem to have backtracked in this direction somewhat (eg. adding back the u'' prefix as a no-op), but I think they maybe missed a trick in not designing the changes around such an approach rather than the hard break that actually happened.
Considering he mentioned "I think it's most likely just a *familiarity thing*", then it's reasonable to assume it's the former, not the latter.
If it's appropriate to your audience, show them how Python can integrate into their Java ecosystem. Jython will let you write Python programs that access Java libraries. I've got a project going on where the only database driver available is a JDBC one, so using Jython gives me all of the goodness of Python plus the huge library of stuff that's available for Java. The dynamic typing lets me eliminate a lot of code that would have been required to do this job in Java. Once you get them started down that path, they'll sell themselves on it.
… and you don't have to argparse everything anymore. This is quite awesome!
I haven't laughed that hard in a while, I need sleep!
This isn't my repo, but it looks super useful. 
In this case yes, but when you need a function to add one to x (because that's insanely useful, I know) public interface MegaIncrementModuleOfGoodLovin() { public int incrementMyXBaby(int x); } public class MegaIncrementModuleOfGoodLovinImpl() implements MegaIncrementModuleOfGoodLovin { public int incrementMyXBaby(int x) { return x + 1; } } vs def incrementMyXBaby(x): return x + 1 I think this is part of the verbosity I'm talking about. But then we talk about factory methods for properly composing your java objects with that interface vs importing modules and we can go at this for a while, but I'm specifically thinking about non-class specific methods that get handled with a strategy pattern and a bunch of factories in java are a lot shorter as a free hanging function with an import in python. EDIT: and we can talk about coupling and DI for a while too, this might make my head hurt 
IntelliJ IDEA Ultimate includes all the features in PyCharm.
Less lines of code is less chance for error. For me, writing succinct code is more about reducing the chance for programmer fault. It goes without saying that there is much value to leveraged and maintenance costs to be reduced by utilizing already-implemented patterns; hence frameworks. Scala is really cool in this respect.
Well, if we're going to do that, your python code doesn't do *exactly* what the Java code does: Since you used an interface: public interface MegaIncrementModuleOfGoodLovin { public int incrementMyXBaby(int x); } public class MegaIncrementModuleOfGoodLovinImpl implements MegaIncrementModuleOfGoodLovin { @Override public int incrementMyXBaby(int x) { return x + 1; } } vs the Python code that does the same: import zope.interface # use whatever interface lib you like, I guess class MegaIncrementModuleOfGoodLovin(zope.interface.Interface): def incrementMyXBaby(x): pass class MegaIncrementModuleOfGoodLovinImpl: zope.interface.implements(MegaIncrementModuleOfGoodLovin) def incrementMyXBaby(x): assert(isinstance(x, int)) return x + 1 Yep, nice and succinct. (Sorry, couldn't help it!) EDIT: Also, did I do the zope.interface bit right? I'm not sure. I could look it up, but I'm *sure* I did the Java one right.
I will not defend more, It's just a preference at some point :)
I disagree with the loc/error argument. I chase down more errors in my Python code than in my Java code. The main culprit is the lack of constraints, but my code golf itch can be blamed from time to time as well ( I love generator comprehensions, but I do not consider using them wise :) )
Woah woah woah, are you telling me Java really *does* have some way to handle dependencies? I think I need some new java friends, they all just bundle 7 year old jars with everything and say "that's the java way." I'm gonna read about this Maven thing right now..
Now this is an argument that I hate. There will always be bad programmers everywhere, therefore differences in languages don't matter? For this sort of discussions, I think it's more productive to ignore what 'bad' programmers will do, and focus on how a 'good' programmer might use the language. 
I don't know, honestly I don't feel the need to use zope.interface. The reason to use an interface is to satisfy all of the static typing guarantees of java. When you get a MegaIncrementModuleOfGoodLovin, you KNOW that it promises the functionality of incrementMyXBaby(int x). Moreover even if you passed just an object in java, you'd /still/ have to downcast to (MegaIncrementModuleOfGoodLovin) before you can use it. This is the blessing and curse of strongly checked static typing. I don't bother with that interface with python because due to testing/project scope/readability and everything else I mentioned in my first post, I just don't think I need it. But again, I'm totally willing to grant you that if I inherited a legacy mess from an enterprise solution that was hundreds of thousands of lines of badly written code, I'd rather that was in Java than python, because as you mentioned, you can easily determine what type you're dealing with. In python, structuring your projects carefully so that this sort of situation arises is important, and people who don't do it will probably end up with a difficult to maintain mess, I agree.
Yes, generators. [This talk](http://www.dabeaz.com/generators-uk/) by David Beazley contains many great examples, such as this one: # genlog.py # # Sum up the bytes transferred in an Apache server log using # generator expressions wwwlog = open("access-log") bytecolumn = (line.rsplit(None,1)[1] for line in wwwlog) bytes = (int(x) for x in bytecolumn if x != '-') print "Total", sum(bytes) 
Of course you don't. A java programmer wouldn't use an interface, either. The reason I pulled in zope.interface was because you created an interface in Java. I wanted to make sure that the two bits of code did the same thing. There's no "idiomatic" way to do something silly like this, in Java, but an "idiomaticish" way to do it would be: public class MegaIncrementorRedux { public static int incrementMyXBaby(int x) { return x + 1; } } That's it. The *equivalent* python code would be: def incrementMyXBaby(x): assert(isinstance(x, int)) return x + 1 I find both equally readable.
You are correct and more accurate.
You can easily see this in action using the `dis` module. from dis import dis def greet(name): print ("hello, %s" % name) dis(greet) You typed that function at the interactive Python prompt... there's no `.pyc` for it. That bytecode was generated entirely in memory. You can actually generate bytecode yourself and have Python run it (I've done it) or modify the compiled bytecode of a function (there's a `goto` hack that does this).
What about this code is unknown at compile-time? If the global x is accessible in expressions in one() for "y=x" then it (seemingly) should also be able to determine that the x in the expression x+2 is the global x, and the x being assigned to is a new, local x
Right, but if you have to use a library to get this safety, you reduce the likelyhood that people will use these features. Java has all of this baked into the language itself. I'm very familiar with the stuff you're posting. No need to spew documentation links at me. I don't need to be "educated". I'm just making a point that writing safe, clear code is more natural and idiomatic in Java than in Python. 
I'm developing an app in Python. It needs nothing more than a Python install (just the folder even on Windows), the sources and a .bat launcher to click. So I hg up to the rev to demo and zip everything up, done.
Right, because everybody follows the style guide, or even knows it exists. There's no need to link to documentation. I'm not asking questions.
I suppose theoretically it could, but the way it actually does that is a lot simpler. Variables in a given scope are either local or global; if a variable is assigned to within the scope, it is local, unless overridden by a `global` statement in the same scope.
I guess I worked on one too many spring projects, but I absolutely saw virtually all reused functionality delegated to an interface and then composed into the classes. The reasoning largely revolving around the relative simplicity of later mocking out dependencies for testing or just "good style" in general. Could just be the java shops that I worked at. In python you don't need that equivalency, you don't need an interface to mock and swapping out composition is much more trivial. But I guess I'm willing to admit that the projects I was writing java for, many years ago, may not have been the best on the planet.
Just an FYI, Java has "for i in x" syntax, too: // Given x is implementer of type Iterable&lt;int&gt; for(int i : x) { ... }
We're all adults here.
That's just like, your opinion, man. Pardon the [topic-] relevant resources; OP asked a question and we helped the community.
Frankly, I think it's insane.
* Exceptions are only unchecked. You have to know what exceptions your functions you call can throw. (Bad) * Generators are easy. (Good) * Python has some magic (bad) but only barely enough to make things comfortable (good). One shouldn't normally try to emulate fancy syntax. Being explicit in Python is a virtue. Conciseness is a virtue too, but less than being readable and obvious. * Multiple return values are awesome. * Var-args are simple. * Keyword parameters are awesome-er. Default values make unit testing dead simple.\* * The motherfucking interactive interpreter is the most awesome thing ever. \* Like this: import urllib def download(url, urllib=urllib): result = urllib.urlopen(url) return result.read() And test with doc = download(test_url, urllib=mockurllib) 
"The trouble is, we didn't implement that"
With executable JAR files containing no native code, you only need to ensure that the *minimum* version of Java is installed, not the same version. Also, if you *do* have native code, you can setup resolution parameters to ensure that the correct native library is loaded for the currently running platform. This, of course, requires that the development environment be able to build for all intended platforms, but it's usually much easier to modify development machines than the machines you intend to deploy to. 
&gt; If you change your code but have no compiling stage, how do you make sure you didn't break anything? [Testing](https://en.wikipedia.org/wiki/Software_testing) and [static analysis](http://en.wikipedia.org/wiki/Static_program_analysis) ([flake8](https://pypi.python.org/pypi/flake8)). http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/c9tfxgd
"We chose not to implement that to make things simpler."
http://docs.python.org/2/library/itertools.html#itertools.izip http://docs.python.org/3/library/functions.html#zip [`from six.moves import zip`](http://pythonhosted.org/six/#module-six.moves)
What is a good way to [verify](http://docs.zope.org/zope.interface/verify.html) the [object composition](http://en.wikipedia.org/wiki/Object_composition) of a [Python](https://en.wikipedia.org/wiki/Python_\(programming_language\)) [class](https://en.wikipedia.org/wiki/Object_\(computer_science\)) made of [mixins](http://en.wikipedia.org/wiki/Mixin) and/or [traits](http://en.wikipedia.org/wiki/Trait_\(computer_science\))? 
Yes, the `abc` module also provides this capability. You can define a class that causes `issubclass()` to return true if, for example, the class being tested implements the necessary methods, even if it is not a direct descendant of the class.
Yeah but they don't look like it
"We're all adults here." Mention the leading-underscore convention for "private" attributes (i.e., implementation details). You can access these when you need to, but you're forewarned that your code may break if the implementation changes.
Or eclipse+pydev
Except that the tried-and-true algorithms are, at this point, unbreakable. As long as the key is secure you're fine- there's no reason to use a potentially broken algorithm.
I would talk about how the "magic methods" interoperate with the global functions, e.g. `len(obj)` calls `obj.__len__()` and how this enforces (or encourages) consistent naming, so you don't have some types implementing `x.length` and others implementing `x.get_length()` and others implementing `x.size` and so on. Also `str.join()` is a good one to talk about, as this way you don't have to worry about implementing the join feature on all container classes or, again, what it should be named. This is one of those things about Python that seems weird at first but makes a good deal of sense when you think about it.
&gt; Use virtualenv to create an environment into which to deploy your program, and use pip to fetch and install all dependencies into that environment. Now you have all your dependencies *and transitive dependencies* in requirements.txt with arbitrary versions that were available at the time you installed them and your setup.py dependencies are out of sync. Also the eggs you depend on have to be duplicated for each of your projects. Do you depend on for example psycopg2? You need to recompile a C module for every project as a bonus. The Maven equivalent for Python is buildout not virtualenv. 
Yes. I'd been using a bunch of `for i,x in zip(count(), lotsofx):` but I should have just ben using `for i, x in enumerate(lotsofx):`
It's not much different. In Python, the language supports iteration over objects that contain a given set of methods. In Java, the language supports iteration over objects of a class type implementing a given interface, i.e., a given set of methods.
of course the information is available online....but the whole point of a book is to curate that information and present it in an organized way. The reason you pay for a book is not because the information is locked up, but you are paying for someone to curate the info for you.
Even worse there is that in 2.x, zip returns a list, not an iterator, so all that crap gets loaded into memory.
Be prepared to: - (attempt to) defend the lack of threading in Python. How do you use 16 cores, 32 cores, etc. - answer questions about being "lost in indents" (off-screen start depths) - performance issues (generally, specifically, uselessness of pypy for production work) - when you bring up expressiveness, they will counter with scala and clojure which often has shorter code that python, and even more expressive - why do all the best python libraries depend and/or are written in C (could turn this positive, "because it is just that easy to use C") - where are the IDEs (counter with PyCharm, others) - dependencies in Python are awful, what is the alternative to Maven (I recommend you dodge this one, python deps are icky, icky) - how do you ship code (jar, war, etc equiv) - how do you deal with being type-lost. x = somethingOpaque() --- how do you write a quarter million line application like this? EDIT: (addition list items) - be prepared how to explain how to get your application on mobile devices. 
I think with this type of book, most of the information is valuable because you look at it and say, "Oh, that's how you do that!" rather than on a "true or false" factual basis. There are some things, like security considerations, that require a little more attention to the credibility of the guy behind the book, but I do plan on having several technical reviewers go over things before I publish it. I appreciate your concerns!
Thanks! I'm really determined to meet that deadline, but my main concern is writing an awesome book. If that means I have to push back the launch date, so be it.
This pearls could help: [Transforming Code into Beautiful, Idiomatic Python, by Raymond Hettinger](http://pyvideo.org/video/1780/transforming-code-into-beautiful-idiomatic-pytho)
It wasn’t pulled 4M times from GitHub, it was downloaded 4M times from cheese shop. This isn’t even barking the right tree. 
Re 1, setuptools has never failed me. I end up running "python setup.py bdist_egg" and an egg appears, do "easy_install myapp-1.1.egg" on the destination machine and it installs, including missing dependencies, globally on the system or locally in a venv. Just make sure you manage your dependencies well and accurately, especially try to use version indicators of the oldest version possible for every package to not have debian administrators kill you.
&gt; rather than on a "true or false" factual basis For me it is more about, "Is that the *best* way to do it?" or, "Is that the community accepted way?". &gt; but I do plan on having several technical reviewers go over things before I publish it. That is definitely good to hear. Is there a way we can get notified when your book is out? I would be willing to pay $5-10 for an eBook.
Thanks for the feedback! Teleport, the library that I linked to, was originally a module in Cosmic, the framework advertised on the front page. Because it was a self-sufficient library, we decided to decouple it completely and give it its own repo and documentation page, hoping that: 1. People would use it for other projects 2. People would port it (it's actually very small) Cosmic is still undergoing major changes, but we plan to start writing more tutorials for it/advertising it soon :) To answer your questions: 1. Internally, Cosmic uses [Flask](http://flask.pocoo.org/). If you would like to integrate it into a Flask application, the API object has a `get_blueprint` method (see Flask [Blueprints](http://flask.pocoo.org/docs/blueprints/)). We will also write a tutorial on Django integration, which, with a healthy dose of magic, should be as easy as Flask. 2. I'm glad you asked! Cosmic makes heavy use of Teleport, to the point where the API object itself is serializable (The schema is `{"type": "cosmic.API"}`). So `/spec.json` simply dumps the *JSON form* of the API object. `API.load` is the inverse of that, it deserializes the API object. The result of the `load` operation is a Python object almost identical to the one that is powering the actual API, minus the actual functions at the endpoints. Our goal is to make them behave as similarly as possible. That is why it is so important to us to make serialization and validation completely transparent. 3. The `serialize` and `deserialize` methods of the serializer objects should, perhaps, be called `to_json` and `from_json`. What you do with that JSON is up to you. Gzip it? Dump it into Mongo? Turn it into BSON? Teleport doesn't care. If you have any more questions, please ask away. It will really help us to improve our documentation :)
Can I email someone a file that they can double-click and run, requiring nothing more than they have the interpreter installed? Can this be one file, complete with native library resources, regardless of platform? Does Python have that, yet? EDIT: Furthermore, can I, with PyCharm, or Wing IDE, or PyDev, click "File &gt; Export as wheel application", and expect all necessary non-core libraries to be neatly bundled, reducing my iteration time when doing remote testing with a client?
Dynamic typing like Python's gets harder to work with as your project grows in scope and number of developers. When you write the code, you know what each method expects to receive as parameters, but that knowledge is not explicitly defined anywhere, so passing it along (to future developers, or even future-you) becomes fairly difficult. The usual advice is to write a lot of unit tests and good docs. That's great to do, but it doesn't always help you, especially if the person working on the project before you was not so kind. The projects grow it also becomes necessary to do large-scale refactoring, which is trivial in a strongly-typed language with a good IDE. In Python you will be in for a world of hurt, especially if you write idiomatic, duck-typed Python. In Java you don't have these problems, because everything is explicitly defined in the interfaces and method signatures. You can certainly write hard to maintain code in Java, but it's a lot harder to do. That is the reason Java is still (and probably always will be) favored for large-team "enterprise" projects. On the other hand, strong typing slows down the initial development, so you would prefer to use a dynamic language like Python for rapid prototyping. That's why iPython/scipy/numpy/matplotlib/etc are so popular, with no serious counterparts in the Java world. 
I have programs with plenty of dependencies that install just fine off pypi. And I don't have to ship jar files around. Personally, I prefer this *a lot*
because a clean compile == successful test?
&gt; Try explaining why you don't need static typing to a Java programmer working on a million-line behemoth project with 10 developers, and you will most likely be laughed out of the room. You start that conversation by explaining that you probably won't need a million lines or 10 developers or 10,000 files if you're using Python, Ruby, etc.
Would be an interesting academic project, I think. I never came across the need yet. I think I had one bug coming from conflicting mixin methods, and that one was pretty obvious, making Python crash instantly because the signature of the wrong method didn't match the call targeting the right method.
Would absolutely love to get some feedback from you on our tutorial based on flask, here: http://opentechschool.github.io/python-flask/ It's designed to be roughly completeable in an afternoon.
Be prepared for questions on method overloading. When python methods don't care what types are being passed into it, things can get tricky.
It was a joke. Java [g|s]etters and Python ones fulfill the same purpose (enabling transparent transition to more complicated behavior), but are entirely different things: Java [g|s]etters are simply methods following a convention, while Python ones are defined by the language and alter behavior of field access.
Check out Python for Data Analysis from O'Reilly. Haven't read it yet but tools and packages recommended there are: * NumPy * pandas * matplotlib * IPython * SciPy 
My swiping keyboard doesn't, though -.-
If you don't like reading: https://vimeo.com/pydata/videos
&gt; Interpreted means that they can "View Source" and see my source (Yes I heard this one) If they work at it, yes they can look at your source code if they have the executable (but not using View Source).
There is a concept in software engineering known as "conservation of complexity." If you write the same enterprise application in Python, and take less time and LOC to do it, you're probably trading off maintainability in the process. Python is not a magic bullet.
Relevant: http://docopt.org
Is that before packaging or after packaging?
You can do that using buildout, or by moving around a virtualenv.
How so?
https://github.com/search?p=1&amp;q=pyinstaller&amp;ref=cmdform&amp;type=Repositories
It's java-side interoperability pales in comparison to something like, Groovy. Its performance is so-so, and its compatibility with working python code leaves much to be desired. It's come a long way, but it still has a long way to go. 
"How do I check the type of an object?"
Not necessarily. I like both, but only if done consequently. Java's half hearted generics bother me to no end.
Maybe someone can answer this for me. I've played around with Numba and really liked it, but I always hit a roadblock when I tried more complicated cases. The problem is that if autojit or jit doesn't work, the error messages are often not very helpful. I can't fix it when I don't know what is wrong and it seems like the error messages are pretty generic. So, how do I troubleshoot?
Pretty high chance your day would end in a sea of nuclear fire before you found out. But yeah man, if you live through it there's gonna be some serious LOLs!!
Start with this: http://qz.com/81661/most-data-isnt-big-and-businesses-are-wasting-money-pretending-it-is/
If this is true we would take the same amount of time and LOC to write the application in assembly. But we don't - we know that we can write the same application with less code &amp; time in Java. Likewise, we can write the same application with even less code &amp; time in Python. The lack of getters and setters is not a maintenance sacrifice. Nor is the ability to write a function rather than a class. Or to use yaml rather than XML for a config file. Where Python slows down is in the code that borrows from Java - logging &amp; unittest. Both modules are slow, cumbersome, and error-prone to use in comparison to more pythonic alternatives (twiggy, pytest, etc). And there's no maintenance upside to using them.
We had a discussion on best practice for python framework development with a guy coming from Java. He was really dogmatic about using setters and getter everywhere. A real pain in the ass. Now I finally understand why.
Ruby is probably one of the biggest users of mixins in the modern language landscape, and there's been a lot of talk about overuse and abuse of mixins recently. When you have 15 mixins added onto your object and magical methods, behaviour and resolution coming out its wazoo, its less easy to reason about its actually working.
check out the multimethod decorator: http://www.artima.com/weblogs/viewpost.jsp?thread=101605 does that do what you are getting at? 
Wait, you can put a value of any type in a variable? Why would you ever want to do that?
it can't hurt to show some respect that python has shown for java stuff, including respect to the canonical unit test interfaces, epydoc (which looks a lot like javadoc, see http://epydoc.sourceforge.net/api/ for an example), etc. don't come at the java community with hate, come at them with respect and you may find them more receptive. 
What's your target audience? If it's a more in-depth book, then you should probably cover things that are not so obvious, but nevertheless interesting and significant for a Flask app. One example I can think of is the ["Pickle vs. JSON issue"](http://flask.pocoo.org/mailinglist/archive/2011/8/15/security-of-secure-sessions/). If you read the mailinglist and visit the IRC channel you'll learn a lot about things people are trying to do or struggling with - and of course solutions to most of those problems.
Nothing to contribute, just wanted to say I'm loving these posts!
If you're looking for simple deployment for end users Pyinstaller is freaking fantastic. Almost all one-off projects I do for people can be packaged up with python pyinstaller.py --onefile --name="Program Name" myscript.py Bam. Pyinstaller does some kind of black magic and you're left with a single executable file. You can run it from a flash drive if you want too! It's not cross platform like a jar would be, but is a nice, compact, and polished way to deliver things to windows users. 
True, indeed it is a preference. Anyway, once again, thanks for open sourcing :)
Sure, if you compare apples to elephants, you get nonsense. The bottom-line is that Python has a lot of issues when it comes to very large projects, large teams, high performance, multi-threading, etc. All of that has been discussed elsewhere in the comments here. All I'm saying is that Python has many legitimate uses, and so does Java. You can't expect to replace one with the other completely, you have to use the correct tool for the job. There are many, many factors to that decision, but the differences in implementing a text file parser is certainly not one of them. 
&gt;Use requests[1] to connect to a service using HTTPS, ignoring any HTTPS errors Requests will probably blow their mind ;) HtmlUnit is simple enough to use, but by god is it verbose. If the page you're connecting to doesn't need javascript, Python is the way to go in my opinion. 
Practical yet simple translation to Java: // provided both forms have parent Class&lt;IForm&gt; clazz = user.isAuthenticated() ? ContactForm.class : AnonymousContactForm.class; IForm form = clazz.newInstance(); form.setRequestType(RequestTypes.POST); // passing parameters to constructor is more verbose than that if (form.isValid()) { form.sendMessage(); }
There are dynamic proxies in the Java world.
holy crap your reply was extensive. awesome. (and I dont even do nearly any python, java in college -- i do php daily) ...
Welcome to the world of never having to deal with a classpath. ever! 
Following that idea, maybe also mention that Python multiprocessing and threading modules were based off Java's. So, that's a pretty clean transition (for the most part). 
That looks great! Thank you
I have programs that I deploy on servers that have no internet access whatsoever, and I have to open file transfer ticket for each file transfer. Personally, I prefer *what you have* a lot. I think I'm gonna mention it next time my opinion is asked for (which is gonna be like ... never?..).
Also relevant: https://github.com/jmohr/compago
That all is great; the problem is, no one uses that, because *the golden standard of build artifact delivery to production in Python is `git pull`*. (Or that's what they told me here the other day.) No one uses that, so [no IDE support exists](http://en.wikipedia.org/wiki/Network_effect), no one takes care building these zips/eggs/wheels, and since these are not available, [no one uses that](http://en.wikipedia.org/wiki/Metcalfe%27s_law). Note that my problem is not with the esoteric tools that may exist; it's with complete absence of its use. Why basically any download page on Pypi only offers me a tar.gz, sometimes with Windows installers? Where are the zip files, the eggs, and the wheels?
Hi sandwichsaregood (author of the article here). Your best reference will definitely be the numba-users [discussion list](https://groups.google.com/a/continuum.io/forum/#!forum/numba-users). You can also try PMing me through reddit to get ahold of me. We are definitely interested in improving this aspect of numba, and we're working on ways of both removing the errors/bugs in the first place, and making them more meaningful to new users. Feel free to also raise these as issues on the GitHub site as well.
Oh, it uses like 10 external and some internal libs. Not much of a big deal, OTOH I only have like 5k of markdown to document it. Maybe I'm just not enterprisey enough.
Eh, actually you can force reification in java if you want to. Most people don't though.
it might be a good idea to extract which arguments are required. it might make more sense to show an error on the CLI than passing `None` to a required parameter.
Lots of options exist for pointing pip to local repo, file system, etc as well as for running a local copy of pypi.
&gt; The speed of the resulting programs is not a problem and you can write your own C-modules if it is. Python connects easily with C. There's also CPy and PyPy. (Remind them that JavaScript (asm.js) is now faster than Java, so if speed is an issue, they should switch to JavaScript). Really don't care for this argument: * If they need close to C level speed, why are they leaving java? If they absolutely must leverage c, why not use JNA or JNI? * asm.js is a severely restricted subset of JS, which is not meant for humans to write and which has type annotations that look worse than those in java. Lets also not forget that it tosses aside the garbage collector. https://github.com/dherman/asm.js is an example of asm.js code.
You can use a lint like pylint, pyflakes, to make sure you didn't accidentally misspel stuff or left out imports. They don't catch everything though.
How is that local repo replenished then? What process brings a newer version of a file from pypi on the internet to that local repo/copy?
Not setting a keyword default does make arguments required, and will generate an error if one isn't specified. Setting a default to None is a actually a mechanism for explicitly specifying that the parameter *isn't* required.
Absolutely, where there's a will, there's a way. The point I was making is that generics aren't the minefield they are in C#. They're a completely different minefield :)
start by getting some big data
I do it as well for about a year and a half remotely. I've found work through Elance and Odesk and have a pretty flexible schedule (I work when I want with almost no deadlines). The biggest thing that you can do is improve your GitHub profile. If people see that you've contributed to important projects, your chances of getting jobs will increase dramatically. You can PM me if you have questions.
Not true at all. I was working on a project that used awesomium, and the number of bugs that arose from using a mildly complicated system without types was astonishing. One of the more painful bugs to fix was when someone was passing "a string" from c++ to a js function and the JS was interpreting it as a variable name and failing silently.
hmm, in the blog post, this @command('greet') def Hi(name, title='Mr.', times=1) seems to get converted into that &gt; All options without default values must be specified &gt; &gt; Current Options: &gt; --name=None &gt; --title=Mr. &gt; --times=1 sure, if you leave it out, it gives an error, but the info message about options doesn’t seem to reflect that, showing a default of `None` instead.
Ok, I see how that's confusing. The "Current Options:" section lists what parameters have been provided (which is useful e.g. if you combine positional and explicit parameters). What that output is saying is that 'name' has not been specified, not that its default value is None. Actual default values are printed at the bottom of the usage help, in the "Options:" section.
I always vote for pylab for visualization. It's pretty great.
There is a mailing list on [my site](http://robert.io). That's where I'll be posting updates on the book's progress and announcing the launch. I'm not sure what the pricing will look like yet, but that will depend on what the book ends up looking like. I encourage you to subscribe and make your decision about buying it when it's actually done. :)
The mailing list and IRC ideas are pretty good. I'll have to keep an eye on those to see what people could use some help with.
I'll try and take some time to go through it later.
veering a bit off topic: I find TDD, although it involves changing pretty ingrained developer habits, pays off for me because of something in the human nature realm. Its so easy to get into flow state and get ultra focused when you have a bunch of failing tests and a little scoreboard showing your progress. Call it "gamification" or look at it as giving yourself a dopamine hit every time you hit save and the test numbers go from "5 failing, 20 passing" to "4 failing, 21 passing". It's the same psychological trick that game designers use to make people keep grinding for imaginary points in games like WoW but used to encourage you to do something productive. That part alone pays for the up front work of writing tests. Factor in the better design that just happens and the fact that you are never scared of changing something anymore because your tests will tell you exactly what you just broke and it's a big win. All that said, I still haven't kicked that "I just want to write some damn code!" habit completely. Stupid habits (thinking about this a lot because I just quit smoking after 10+ years and 8+ years of trying, on and off, to quit)
very relevant, docopt seems a much nicer and better designed abstraction to solve this problem. My subjective opinion of course.
I agree with these guys in terms of not having a use case for the cli tool, BUT I will be bookmarking your project so I can use the ssh_config.py classes as tools for when I need to automate this stuff. From my quick look those are decoupled enough to use pretty easily. So I might not be using storm itself, but thank you for open sourcing. 
Dependencies: Everyone's telling you to use pip to install this and that. No. Create a setup.py that uses setuptools and it will handle ALL of them for you in one shot.
I'm sorry that you're having to defend yourself in this thread, it's embarrassing to see Python programmers acting this way. The OP asked for the type of questions that they'd receive from Java programmers, and you've responded properly.
Big Data world? I can't take you seriously.
I personally feel that the aim of Python shouldn't be to produce one line solutions. Perl and shell scripts are great at that kind of thing, so allow them to handle those tasks. I feel that Python should focus on readability, which has long been its strong point. Complex one line solutions are not always desirable. The point that Python has less boilerplate than Java, and maintains readability, is what should be stressed.
The idea is that we can preserve our API in Python even after making changes. In Java, if you want to do some preprocessing when someone changes a value, and you didn't have accessor methods for it already, get ready to change the API and piss off your users (in most cases). /u/maratc give an [excellent description](http://www.reddit.com/r/Python/comments/1ew4l5/im_giving_a_demo_of_python_to_a_bunch_of_java/ca4ft3z) of why that is the case, but it's all about maintaining an API.
I would argue that that quote is in relation to there not being private and protected variables in Python. Not using accessor methods in Python has more to do with the fact that we can define them later without changing the API.
Translating from one non-machine language to another one really isn't what people think of when they talk about "compiled". 
&gt; Take something like scipy that takes 40 minutes to install (Fortran '77 compiler and all that), think about 60 AWS instances ... etc. Use a distribution like Anaconda and the install is much faster.
Buildout is Python's loose equivalent to Maven, in that it handles dependencies and also install/configures assorted bits of your application or project. Like Maven, Buildout gives you options for pulling packages from assorted repos. Buildout shines over Maven in it's recipe system - it fetches the equivalent of Maven plug-ins automatically and makes it really easy to re-use other developer's installation/configuration recipes. It also is more flexible than Maven in that things like test runner's are installed via recipe, so you can use a recipe like 'zc.recipe.testrunner' to create a default ./bin/test behaviour or use a complete different recipe to manage your testing environment. Python has the advantage over Java in that you can express the dependencies in the setup.py, and then those dependencies can be consumed by whatever installation/build tool suits your need (be it pip, easy_install or Buildout). 
&gt;When you write the code, you know what each method expects to &gt;receive as parameters, but that knowledge is not explicitly defined &gt;anywhere, Sure it is. Documentation is a core part of Python, down to docstrings and unit testing. I should hope the parameters are expressly defined in the docstrings and in documentation being generated as the project goes along. Whether you're using static or dynamic typing, you can't just not document work and expect to have an easy time of things. &gt;The projects grow it also becomes necessary to do large-scale &gt;refactoring, which is trivial in a strongly-typed language with a good &gt;IDE. In Python you will be in for a world of hurt, especially if you write &gt;idiomatic, duck-typed Python. It's somewhat the opposite, isn't it? Change a class from SomeClass to SomeModifiedClass and now you need to change types in a zillion places. With duck typing, you don't have to refactor all that stuff except as it may specifically affect a particular function. With static typing, if "x" becomes a float instead of an integer that screws up everything else. 
I don't disagree, but that saying has only been applied directly to the fact that Python doesn't have private and protected members (that I can find). That accessor methods are related to that fact doesn't mean that the saying applies. One might also argue that the saying is a generic description of the whole philosophy of Python, but I might call that equivocating. In the end, it doesn't really matter; I just wanted to point out how it has been used by the devs.
&gt;Sure, if you compare apples to elephants, you get nonsense. The &gt;bottom-line is that Python has a lot of issues when it comes to very &gt;large projects, large teams, high performance, multi-threading, etc. What are the sources for some of these claims? IronPort testifies on the Python page that they've got over a million lines of Python in their products. It's all over ILM, CERN, etc. 
I believe you. I was having a discussion with a Delphi developer, complaining that for legacy and other reasons there are now at least 10 different ways to read or write a file in the language (and even the most recent/capable method consists of two different objects, TStreamReader and TStreamWriter plus you need to use a TFileStream with them). I pointed out how over the years Python still has one simple way to access files, "open", and how much simpler/easier this was. I got back this as a response: &gt; Python supports Named Parameters, which means that any or all of &gt;the seven (SEVEN!) optional parameters to Open can be specified, or &gt;not. And if you do, at least some of them are going to interact with &gt;each other, sometimes in unexpected ways. The upshot is that you &gt;don't have one file open command--you don't even have the 11 you &gt;claim are so difficult to understand in Delphi--no, in Python *you have &gt;2^7 (128) different file open commands that are all called the same &gt;thing! &gt; &gt;Complexity can be moved around, or swept under the rug, but it &gt;doesn't go away. Python doesn't deal with that complexity better &gt;than Delphi; it just has a different idiom that looks simpler on the &gt;surface. I had to school him on the difference between "power" and "complexity", to which he has yet to reply. :-) Someone else did join in, though, talking about how hard and complex the "open" function was because of all those parameters and how having ten objects with less functionality was a much better idea. :-( Fortunately some agreed with the point that the standard library has become cluttered with legacy constructs, but it is amazing to see the tortured justifications some people come up with to defend shortcomings in their favorite development tool. I've seen type inference compared to self-modifying code, the idea that developers can manage memory better than any automatic memory management method, the notion that four string types and three char types (!!!) are essential to a language and immutable strings destroy performance, etc. 
&gt;but I notice when my python projects reach a certain size that they &gt;start to separate themselves off into other services or components It's not just you. Python development tends to follow the Unix/Linux mantra of "do one thing really well" and thus a complex problem becomes a series of interlinked smaller solutions. Java tends to use a "one program to bind them all" type of development with mega-programs as a result. 
And some of us learned some things we didn't know before!
Wish Wakari worked better on iOS devices :(
type(), but if you find yourself typing it a lot you're doing it wrong...
Any comments or corrections are welcome. I am still new to RPython. :)
Found what I was looking for. http://michaelochurch.wordpress.com/2012/04/13/java-shop-politics/ It's a great read all around, especially the list of problems caused by Big Program Development. But regarding the difference: &gt;When Unix and C were developed, they were designed by people who &gt;had already experienced firsthand the evils of Big Software, or &gt;monolithic systems comprising of hundreds of thousands of lines of &gt;code without attention paid to modularity, that had often swelled to &gt;the point where no one understood the whole system. ... The idea &gt;behind the Unix environment, as a reaction to this, was to encourage &gt;people to write small programs and build larger systems using simple &gt;communication structures like pipes and files. Although C is a strictly &gt;compiled language and no Lisp-style REPL existed for it, C programs &gt;were intended to be small enough that the Unix operating system was &gt;an acceptable REPL. This was not so far from the functional &gt;programming vision, and far more practical in its time. The idea behind &gt;both is to write small programs (functional “building blocks”) that are &gt;easy to reason about, and build more complex systems out of them, &gt;while retaining the ability to piecewise debug simple components in &gt;event of failure. This style of development works extremely well, &gt;because it encourages people to build tools for general use, rather &gt;than massive projects that, if they fail, render almost all of the effort &gt;put into the project useless. As more code is written, this leads to &gt;the growth of generally useful libraries and executable utilities. In the &gt;big-program model of development, for a contrast, it leads to &gt;increasing complexity within one program, which can easily make &gt;whole-program comprehension impossible, and make decay (in the &gt;absence of forward refactoring) inevitable, regardless of programming &gt;language or engineer talent. &gt; &gt;I adhere to this small-program mentality. I’m not saying “don’t be &gt;ambitious”. Be ambitious, but build large systems while keeping &gt;individual modules small. If a file is too big to read (for full &gt;comprehension) in one sitting, break it up. If “a program” is too big to &gt;read in a week, then it should be respected (even if it runs as one &gt;executable) as a system, and systems are harder to manage than &gt;single modules. While it is harder, up front, to develop in a modular &gt;style, the quality of the product is substantially higher, and this saves &gt;time in the long run. 
I actually like that change. You can now refer to Ellipsis in a nicer way. Ellipsis (...) means intentionnaly omitting something. I find it a nice alternative to replace "pass" def something(): ... than def something(): pass
Probably because of the transition from the Julian calendar to the Gregorian calendar: the last day of the Julian calendar was Thursday, 4 October 1582 and this was followed by the first day of the Gregorian calendar, Friday, 15 October 1582. So I'm guessing the "loss" of eleven days is messing up the calculations.
What documentary is this?
There's a better explanation of what's going on [over at StackOverflow](http://stackoverflow.com/questions/772124/what-does-the-python-ellipsis-object-do). `...` is an built-in object named `Ellipsis` that's primarily used for slice notation, but can be used on its own in Python 3. You can use it in lieu of `pass` in a function the same way you can use, say, the number 4 instead of `pass`. This is not a good idea though, because Python has to resolve the `Ellipsis` and then throw it away which is slower than just writing `pass`. Example: [1]: import dis [2]: def fpass(): pass [3]: def fellip(): ... [4]: dis.dis(fpass) 2 0 LOAD_CONST 0 (None) 3 RETURN_VALUE [5]: dis.dis(fellip) 2 0 LOAD_CONST 1 (Ellipsis) 3 POP_TOP 4 LOAD_CONST 0 (None) 7 RETURN_VALUE
Here's a few good links: http://brizzled.clapper.org/blog/2008/07/28/why-is-python-more-fun-than-java/ http://bitworking.org/news/Python_isnt_Java_without_the_compile And a presentation by a "recovering Java addict" about Python: http://archive.org/details/SeanKellyRecoveryfromAddiction
What's wrong with the built-in cmd module?
&gt; Buildout shines over Maven in it's recipe system - it fetches the equivalent of Maven plug-ins automatically and makes it really easy to re-use other developer's installation/configuration recipes. Not really sure what this means. Are you saying it adds plugins to projects automatically or has a large group of builtin plugins or what? As far as I'm aware, most maven plugins can be fetched by adding them to the pom.xml, but I'm more familiar with SBT, which has easy to add plugins as well. 
That's a pretty funny quote considering how monolithic unix and linux are.
Renaming is one of the simplest refactorings that every IDE can handle for you, and it's syntax-aware, not just a find and replace. I never flinch renaming a class in C# or Java when using an IDE, it always Just Works.
Your reply makes me more interested in your book - you obviously consider things carefully and have an eye for detail in explanations. This will be key to a successful book. minor minor nitpick about string substitution: the % syntax is being deprecated in favor of [str.format()](http://docs.python.org/2/library/string.html#string-formatting) - definitely worth using if you're writing a book!
I write empty *pass* methods when I don't want to think about that problem at this time. And usually I come back to fix it in the same programming session. Writing a *doc string* defeats the purpose because it would force me to think about it enough to be able to describe it in a *doc string*. *pass* allows me to encapsulate (in my head) the new function away from the problem I am currently working on. 
I'm really glad to hear that feedback. I think anyone who is writing anything of length (even just a longer-than-normal comment on Reddit) is a little worried that their prose will be an enigma to anyone who reads it. I think I've already plugged it here, but if you're interested in the book make sure to sign-up for the mailing list on my site (robert.io) so you can keep up with the progress of the book. That's not minor at all! That's exactly the kind of thing that needs to be noticed when writing a book that emphasizes best / accepted practices. Thanks!
that's Armin Rigo of PyPy fame.
C# has LINQ which is similar, in case you didn't know.
There are many ways to do it, but honestly that is probably the easiest idea. If the only thing you need to do with the interfaces is change their IP addresses, then go for it.
If you create an empty function, then you already have a purpose in mind for it, so might as well put your immediate thoughts in it right away.
Obvious ways. `...` is not obvious. But don't forget def h(): return
 def something(): pass or def something(): raise NotImplementedError() But don't use `Ellipsis`. That's incorrect and now what it's for.
Well, the claims are my opinion and the source is my experience. But it's an opinion shared by most of the industry. As far as I can tell, almost everyone who seriously tries Python loves coding in it, at least compared to Java. It's fun, addicting even. But what about the poor schmuck who comes after you leave and has to read through your piles of documentation and unit tests in order to make any little change? When I'm put into that kind of situation I vastly prefer to fire up Eclipse or IntelliJ and let it to do work for me. As for performance, it's commonly known that Java is [really fast](http://benchmarksgame.alioth.debian.org/) these days. Python just doesn't measure up, especially in terms of multitasking. Yes, you can use Psyco, Jython, etc, but that's another thing to juggle. 
Seems like the editor doesn't support scrolling with touch, so unfortunately it's basically unusable on the iPad. Would be great if there was a way that would be fixed. Also an extra row of keys like PythonAnywhere has would really be helpful. 
Yeah, that is the point I make at the top of the post. It is very difficult to learn where the lines between RPython and Python are. However, after a while I learnt what will work and what won't and my code required less and less modification to get working.
Coming from a long time developing in Delphi, and very very recent Python convert, my compulsion is taking any Delphi code I read or see anywhere and rewriting it in python just to marvel at how much shorter, simpler, clearer, powerful and beautiful the resulting Python code is. :-) Sometimes I look for code just so I can rewrite it. 
Nope, python has language specific features that allow you to follow YAGNI rather than needing to write horrendous amounts of boilerplate from the start, because you *might* need encapsulation on your properties. Need encapsulation on a property? Give a new function the `@property` decorator.
I think, this one is the best: def f(): """actual doctring""" raise NotImplementedError # optional 
Thankyou so much for appraising this! I'll be making some commits in the very near future :) Files don't need to be executable if you run them through the python interpreter, as in `python catseverywhere.py`. You only need an executable flag if you add a hashbang at the top of the file and run `./catseverywhere.py` instead. This tutorial is also designed for windows users as well. I believe we wouldn't have used string substitution yet because the people we're teaching this too wouldn't have learnt it yet :)
Probably time to rethink your design if you are having this problem.
Given that to find out I would apparently have to register online to be able to watch this guy's talk *next week*, I suppose that I will never know...
I came across this a while ago, and was wondering about it. Even if there wasn't the performance difference, the problem is that someone's going to inevitably look at your code, and think, "why are there three dots here?". And end up at the stack overflow question. Then waste another 20 minutes trying to figure out why they even included it. Which they'll eventually resolve with, "ok, it's *something* to do with numpy. I don't even care anymore.
As someone who's good with both C and Python (and learnt C first), I don't understand why anyone would prefer the C/C++ way. Obligatory boilerplate that breaks the entire loop if you forget it (`i++`)! Loop variable that has to be explicitly created! HURRAH! The Lua way is best for simple range-loops though, `for i=1,300,2 do ... end`. Same abilities as range(), less characters, only slightly less obvious. 
Ah yeah, fair enough.
The performance difference is trivial of course; whatever you would eventually fill the function in with is undoubtedly going to take longer to execute than Ellipsis. &gt; "why are there three dots here?" "Because two is ambiguous, and one means something else entirely." If they can't infer the meaning of an ellipsis from it's context in the code (or, you know, the fact that IT'S AN ELLIPSIS), I certainly don't regard their code comprehension highly enough to bother accommodating them.
Let us not forget: def h(): None for even greater bewilderment. or even: def NO(): raise NotImplementedError() def i(): NO # no parentheses, cause that would actually make the code make sense and do what it's supposed to.
Oh well, if that's **now** what it's for, I'd better start using it straight away!
Yeah, makes no sense does it? Python 3 accepts Unicode identifiers, so why isn't there also `…` besides `...` and `Ellipsis`?
Yep, my employer has no objections against manual time. 
&gt; you can only hope you client code doesn't touch these fields and mess up your object state. If client code *really* wants to write to private properties in java, they could just edit the source code and modify it to be public. Python drops this pretence of security. Just *tell* your users that you don't want x, y and z properties to be touched by prefixing them with one or two underscores (python's convention). If they *still* want to touch them, then it's their own fault if things go bang. You can't save a bad programmer who won't abide by an interface from himself. &gt; If you reveal your internal fields to the outside world, then whatever changes you make to your code must keep those fields the same. Python has the syntactical ability to actually do that. Java doesn't. I'm sorry, but I'm not going to write python code within the confines of Java's inabilities that it pretends are standard practice. I'm going to make full use of python's expressive power. &gt; Yet another reason you might want to use encapsulation is not to have your object state spill all over the program and the ability to design classes that are inherently thread-safe. How do you do that in Python? Python isn't really thread safe to begin with. It has a global interpreter lock, if you hadn't heard. Threading in python is mostly useful for dealing with multiple IO streams, where one part of your program is almost always waiting. Even then, its now accepted there are better mechanisms than threading, like green threads and the multi-processing module for IO bound applications, which are mostly what people are writing when they write servers. If you *really* have a mathematical wont to use all four cores of your processor, its better to call down to C or another fast language. &gt; Anyway, Python is a nice language with a lot of good features, but the unwillingness of its community to accept established principles of language design and OOP derived No, there's infact hundreds of implementations of OOP, and none of them have been proven "most correct" or "best" or "established". Implicitly taking Java's implementation as the best, and telling everyone else that they should conform is purely dogmatic tripe.
PyTables is often the best starting point depending on the characteristics of your datasets.
Cython is good for that. I don't think the PyPy devs want RPython to be used outside of language implementations (the interpreter specifically).
Raymond is great. This talk by him is also very good: [Python is Awesome](https://speakerdeck.com/pyconslides/pycon-keynote-python-is-awesome-by-raymond-hettinger)
Whats wrong with: def func(): # TODO pass 
I presume that includes health insurance? Ah, well, the US is a bit third-world there :)
Thanks for explaining that, makes more sense now.
Really don't care for your arguments either... * If they need close to C level speed, neither Java nor Python is a good fit, unless they exend it somehow. Java isn't at an advantage here, but Python arguably is, since it's easier to exend it or improve the speed (cpython, pypy, pycuda, psyco, using C libraries directly is easy). If it's easier or not is possibly subjective, but Java sure isn't at an advantage here. * Nobody should write asm.js directly, and I never implied such a thing, just that the world has changed, and that JavaScript (asm.js) is now faster than Java. 
It's not really intended for such uses. It was actually legal syntax in Python2, but only in the context of slices, so you could write: somearray[0,...] It was used by the numeric extension, basicly acting as an "All other dimensions placeholder.", so the above on a 2d matrix it'd return the first row, on a 3d matrix it would return a 2d matrix corresponding to the first slice (ie. the surface "cube face"), on a 4d matrix would give a 3d matrix of the elements in the first dimension, and so on. Python3 just regularised this, allowing it to be used anywhere else as well, rather than as a special case in slices. This means that things like using it in a variable are now consistent with using it directly etc. I don't think there's any intent for it to be used for similar cases like "pass", though the connotations of "..." may lead to it being repurposed.
How about: def j(): not implemented Or for the more verbose: def k(): this is not implemented (yet) Or why not make C programmers feel more at home: def l(): { } 
\#3. Well, that's rather against the spirit of it. There's no point if it's not valid -- if confusing -- Python. \#2 certainly gets maximum evilness points.
What masklinn said. There's no reason you wouldn't just write def func(): "TODO" if you were going to do that.
Yes, that's what I mean. Those who come from static typed languages use it a lot at the beginning because there are no type hints. They never heard about duck typing.
Was somewhat joking. I do use it with NumPy, so I'm familiar with its 'Proper' use. I mean, if you were really going for 'confusing abomination of syntax', you could use function annotations, like this: def foo(baz=..., *bar:...): ... I feel I may be getting a little too far into morbid curiousity, though :)
TODO isn't a docstring but a comment in my mind. But fair enough.
I suspect that the actual hazard in making that guess is quite low. :-)
I almost screamed then. You win.
I'm probably going to use this one. Fuck the haters.
&gt; And the difference in readability between pass and ... is none whatsoever. It never occurred to me we were missing anything in the first place, `pass` was quite enough. &gt; Hell, using informal writing rules ... actually expresses that something should go here. Yeah sweet, without a comment to explain it, I'll have no clue deciding if it's on purpose or something that was forgotten. In fact, I'll have no clue why you've not implemented the block anyway. 
True!
Thanks
&gt; (provided they are pip install-able which majority is but a minority isn't) Could you give an example?
I personally would put the main function after the GraphEq(). I don't know if everyone does this, but I always have the main function at the bottom and usually try to have called functions declared above the calling function. Don't use globals, especially this many and in a simple program like this. I've never used pygame for any real kind of application so maybe it's a common thing in pygame. If you had to use pygame I would have liked them to be declared outside of any of the functions so I could see right away that "oh these are globals and will be used in multiple places". I don't think it would be too hard to pass them as arguments to the GraphEq() function. I was pleasantly surprised that your code was that easy to read, good job.
What are the X... chapters? Are they not available yet?
&gt; PyPy devs want RPython to be used outside of language implementations (the interpreter specifically). Well a lot of people outside of PyPy are building new compilers and interpreters for subsets or full Python, it would be great to use the existing PyPy architecture. I suspect that many people (myself included) are or will reinventing work that has already been done. Cython is just as an unspecified as RPython if not more, even the typing semantics of Cython are unsound and can transparently degrade to C-API Object Layer calls without warning, not so great for a compiler target. Probably better off just targeting C.
Oh man, this a gorgeous use of IPython Notebook.
In my list of un-pip-able requirements, I have scipy, rpy, matplotlib, python-igraph, gensim, and PIL. Some of them are there not because they can't be installed by pip, but simply because it has never been successful for us.
Check [this comment](http://youtrack.jetbrains.com/issue/IDEA-57233#comment=27-472038) for the possible solution.
I added these lines to my ../pycharm/bin/pycharm64.vmoptions file: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true -Dswing.defaultlaf=com.sun.java.swing.plaf.gtk.GTKLookAndFeel 