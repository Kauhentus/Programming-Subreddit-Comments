If you're on Unix you might be able to use [termios](http://docs.python.org/py3k/library/termios.html) to turn off local echo -- see the example at the bottom.
I've considered it but the key thing in this case is something that's going to be open all the time and want quick access to, faster than even another tab on a web browser. And none of the interfaces I've seen that run them as desktops apps have impressed me.
[gevent-websocket](http://www.gelens.org/code/gevent-websocket/)
I use emacs but I've nothing against vim :) Anyway, [is this close to](http://www.emacswiki.org/emacs/LaTeXMathPreview) what you mean?
It's okay. Not as nice as Qts, but usable.
Ok, then you don't know the *previous* API, where you had to specify strings with C++ signatures to decorators so PyQt knew what kind of slot you defined.
Good work!
[Tornado](http://tornadoweb.org) includes one: https://github.com/facebook/tornado/blob/master/tornado/websocket.py
Is there any documentation?
Hm...this would've been useful to stumble upon yesterday. I created my first Python GTK+ program with PyGObject, but did it mostly from a PyGTK tutorial and converting the syntax to with with the PyGObject code...it did work out though, just took a little while.
I've never used Python to create a GUI and I'm curious, is Qt or GTK the way to go? I'm leaning towards Qt, though the majority of the applications that I use tend towards GTK.
Awesome! This actually reminds me: the pygooglevoice module does a similar password check on Windows. I'll see if I can learn anything from there, too.
Quite. Well good luck on the final next week. :) 
I didn't know you could do a lookahead for a pattern or end of string/line! Awesome!
Great work! User interface is also very good looking. I created a virtaulenv, I can see that it lists "Python 2.7" as a package. I think that can be excluded from the list.
&gt; It's close enough though for most purposes and switching should not be a major chore I recently tried IPython's qtConsole and immediately noticed a bug: text selection disappears when I press left arrow (while holding shift). What's interesting, I immediately found out that this bug was fixed about a year ago. After looking at the code for a while I more or less understood what's going on: they (qtConsole developers) have to use some custom processing for that case to make left arrow skip the prompt, and the fix was simple enough: if selection is active, pass an additional parameter to `cursor.move` (or whatever it's called) to specify that selection anchor should not be moved as well. Except that: 1. The developer decided to write a nice, self-documented code, and passed the parameter as a keyword argument. 2. The name of the argument is different between PyQT and PySide. 3. PySide apparently doesn't support keyword arguments, nor even complains about them (which is inexcusable, in my opinion). 4. At the time of the fix qtConsole did not officially support PySide, I guess. So I wouldn't be very optimistic about the ease of switching. Of course it's incomparably easier than switching between different frameworks, you don't need to write any code in most cases, but it seems that there could be enough subtle incompatibilities still (and it's this unnecessary subtlety which bothers me in this particular case).
The example code is extremely informative: https://github.com/facebook/tornado/tree/master/demos/websocket
Not really. Python lends itself to easy coding, so it very rarely matters what editor you use. The "features" of more advanced editors will probably get in your way. For what it's worth, I use Vim. I have a lot of associates that use Notepad++ in windows, and I heard Sublime Text 2 is pretty awesome. 
If you think you will spend a lot of time programming, yes, it is worth learning emacs. It will take time, in the process you will most likely ask yourself why bother, but in the end you will find yourself much more efficient at programming. If you're not going to code more than a few hours a week at most, then it's probably not worth it. Just find a confortable IDE (other than IDLE) and use it. There are good user friendly IDE out there, you can find something you actually like.
[ws4py](https://github.com/Lawouach/WebSocket-for-Python) has server and client implementations for gevent, tornado, cherrypy and threaded python.
This looks awesome and I have never heard of it. 
I just went to http://pyjs.org/examples/ and all the demos were failing in chrome. Do they not support chrome or are they just having issues right now?
Yes, it's definitely worth it to learn either vim or emacs. It may take a while to become proficient at it, but it only takes a few days to get used to the basic editing chords. Print off a [cheat sheet](http://devcheatsheet.com/tag/emacs/) and keep it next to your desk, set up a [good configuration file](http://www.saltycrane.com/blog/2010/05/my-emacs-python-environment/) for emacs, and try to use it for a simple project. If it seems like it's taking a while to do something or you're using a lot of repetitive commands, spend some time Googling to see if there isn't a better way. Also, and this isn't strictly Python-related, but emacs also has excellent support for LaTeX which is kind of a big deal in Physics and other math-heavy scientific fields. And Org-Mode is genius.
Confirming that Sublime Text 2 is awesome, it's what I use on both machines I have ( Windows 7 and Ubuntu )
I know that it was worth my having learned Vim. I've never used Emacs, so I can't say, but as there's people who think that it's better than Vim, it must be good. I say go for it. Edit: Terrible English fixed. Now it's just bad.
While I'm a big fan of vim and emacs, I don't think they can really beat the best GUI's when it comes to LaTeX. Kile is my editor of choice for LaTeX. It is insanely customizable, has customizable hotkeys, has excellent project handling, the ability to view the document structure, a huge table of symbols (for the times you need an odd one), and is just all-around good. You can even put it into vi-mode so that it acts like vi, only with all the cool extras provided by Kile. Don't get me wrong; vim or emacs are excellent for programming, but Kile is the king when it comes to LaTeX.
If you plan on editing a lot of text (like writing some python, writing some latex...) then learning vim or emacs is pretty good. They both have commands other text editors only dreams about. Personally I prefer Emacs but have started to like the modal editing...so I use vim emulation in emacs (evil-mode), which is pretty nice. But Emacs is pretty easy to learn, the most important keystrokes are like 10 in total and there's a lot of logic to it. Try the Emacs tutorial (`C-h t`, that is, press Ctrl-h and then only t) to learn the most basic.
Oh, I used that as well. As far as I understood this, SINGAL("timeout()") etc. was just a dict (string-to-function) lookup. I thought it was necessary in case of multiple overloaded signals/slots which would make it ambiguous in Python. I was probably wrong and this was the only way to do it before :)
Wow, this is super useful, thanks!
http://robots.thoughtbot.com/post/13164810557/the-vim-learning-curve-is-a-myth
didn't you just start this last week? damn! that's awesome!
Qt is an abomination. Use GTK+. 
In what way? I'm interested in it as there appears to be a book on Qt, and I do like books.
Indeed, though for Tornado it relies on the built-in coming with Tornado itself.
Oh god, the same codebase? They're using kludges. They must be using kludges.
Emacs is amazing for Python development: * With inferior python mode, you can run your Python REPL as a subprocess of Emacs, then use quick keyboard commands to mark and send classes, functions, etc. from your source code into the REPL for interactive development. * Using Emacs tramp mode, you can even do the above when running Python on remote systems over SSH. * Emacs integrates with the Python debugger, so if you start an interactive debugging session Emacs will help step you through the execution in your source code. Emacs will even automatically recognize a pdb session started from a program running in the shell (e.g., if you use `pdb.set_trace()`). * Intelligent auto-completion, refactoring, etc. (as well as the ability to evaluate Python expressions from Emacs Lisp) is provided by Pymacs/Ropemacs. And the best part is that the Emacs knowledge you'll gain by using it for Python development transfers to anything else you might want to use Emacs for – and as you probably know, Emacs can be used for quite a lot of different tasks. It's a bit steeper a learning curve than you'll encounter with most editors, but I think learning Emacs is well worth it if you want to work effectively as a programmer.
Emacs will teach you incidental aspects of lisp, which will help you if you ever dive into computer science. Otherwise, focus on learning to read FORTRAN.
There is nothing you can put in the update function to get the result you want. The widget is being displayed in the child process, but you're setting the new values in the parent process. Processes are separate unless you create an explicit communication channel. Basically, you need to set up a pipe and write `'l1'` to the pipe, reading it from the other side. That code is needlessly complicated given the job that it does. What exactly are you trying to do?
Oh... oh my, that's classy lookin'. I'm not sure I have a use for it but the bright highlight colors and tasteful UI make me want to find a reason to use it anyway.
Exceptions are fine, you're not reading with attention. They're even explicitly checked for performance. It's just sys.exc_info() usage. I claim pypy's JIT predates this hack even. What I was trying to convey you in those few messages is that it *is* a problem in practice. The resulting behavior might not be that your benchmarks run slow, but say your response time is very erratic and sometimes you have a huge latency. This hack makes performance very unstable and I'm sure I can even provide examples using django where *this is* an actual problem.
There is a UI element, l1, that is found within the SimpleFrame class. That element initializes to 'l1'. In a process that is NOT a GTK event, I am attempting to update l1 to a different value. I need to know how to change l1 so that it shows up within the UI frame. The code I've given you, if you run it, demonstrates that l1 holds the new value, 'hello'. So the data is already there. Don't be confused by the multiprocessing. The UI does not update itself when I do a "self.l1.set_label" or a "self.l1.set_text". But, if you do a "self.l1.get_text" you will find that the data has been updated. So I am missing the piece (command?) that updates the UI's display window. 
Remove the multiprocessing and your code works just fine; if __name__ == '__main__': widget = SimpleFrame() widget.set('l1','hello') widget.main() The reason you get the right answer when you do `self.l1.get_text()` is that you're making that check from within the parent process which is the same place that you made the change. The change is successful but it doesn't display because it's been changed in the wrong place.
I think you're missing it.... I don't want to update it once and forget about it. I want to update it periodically. I changed the code and removed the multiprocessing to make it less confusing. I'm now using a gtk timer to simulate the updating, and I still don't actually see the display updating...
while gtk.events_pending(): gtk.main_iteration_do(True) That's what needs to be executed.
Chiming in here; I am a vim user; but it is definitely worth it to learn emacs. The basic idea is that you will become more proficient over time and the code will come out faster; so you will have your mind interupted less; so you will be able to stay productive longer. Generally a good way to learn an editor is to read a tutorial; vim has an official tutorial built in; I am sure that emacs has something similar. Spend the 30 minutes to an hour doing it; then whenever you need to do something that seems like there might be a way to do it faster/automatically; learn how to do that. In all likliehood you will probably only need 2-3 hours of actual learning the editor until you are at least as proficient in it as you were in what you were using; from there on you will definitely save yourself time and mental cycles. 100% worth it. Especially if you think there is any chance you will be coding after you finish this project (which you are crazy not to; hard science+programming skills = $$$$$$)
I'm going to say NO. And wait for the hordes of Emacs users to descend upon me. But their numbers count for naught here. I've worked full time in Python for years, and I've always used an IDE (Eclipse, Komodo etc). Most of my colleagues have used IDEs, a handful have used Emacs -- and there is no discernible difference in 'efficiency'. If you have mastered whatever tool you prefer then you will be able to enter text and navigate your project as fast as you need to. Learn Emacs if you like. You may prefer it. But if you don't, and the Emacs users blot out the sun (with their beards), you can code in the shade. **Edit:** But don't use IDLE. Take it out and leave it to die on a hillside somewhere.
Not sure, I didn't use it at that time. Actually, I'm happy it is not neccessary. But I agree, there's some things you can do to make it more pythonic. But the more you change, the less the C++ documentation applies. And the Python documentation is not as good, I think. BTW, I'm also happy that the wxPython API got more Pythonic and less C++ like it used to be (with binding stuff to integer IDs that represented the widgets).
I usually prefer to add code to `idle_timeout()` instead of running the GTK+ main loop by hand which strikes me as ugly.
I don't know.
Emacs, Vim, try both, configure both, learn the basics, keep one.
Another vote for Sublime Text 2, has replaced both Visual Studio and XCode for me.
I slightly prefer gtk+ architecture/way of doing things but Qt is a more complete solution : run on windows, much more graphic stuff (canvas, opengl integration and such), used in very big app (maya, 3ds max). 
Oh yes, I love LaTeX! :) (that would sound so wrong out of context) It makes writing equations so much easier than the nightmare that is Microsoft Word. Although I've been using TeXworks so far which has been OK for me. 
I agree as someone working fulltime with eclipse/pydev as well. There is a learning curve for IDEs also, not only for vim, emacs and the sort. Knowing to use pydev efficiently isn't as easy as to press buttons, contrary as to some vim users might want to have you think. I also use vim from time to time when remoting into linux servers, but that's about all I am willing to use it for.
I don't think anybody in Physics uses FORTRAN these days, certainly not outside of Astrophysics (I'm in Condensed Matter)...I hope not anyway! I think the university used to teach FORTRAN up until about six years ago, when they switched to Python.
&gt; Exceptions are fine, you're not reading with attention. Sorry, I wasn't being clear. What I meant was that, some of those 404 paths currently lead to a call to sys.exc_info() in my Django port. &gt; What I was trying to convey you in those few messages is that it *is* a problem in practice. I'm not saying it isn't a problem - I'm just saying that we don't yet know *how bad* a problem it is.
If you ask me I say no. Because Emacs and Vim are such that if you do need to use them you'll clearly feel the need. That's when you feel the editor you are using isn't fast enough to quite catch up with you and you are jumping up and down and doing all sorts of crazy stuff. Otherwise something like Notepad++ is more than enough for scripts or projects with a couple of files or if you are doing serious full-time development (big projects, lots of files in crazy folders) tools like PyCharm or WingIDE.
A twisted way of doing websocket : http://www.tavendo.de/autobahn/tutorial/echo.html I successfully used it because I needed both redis and process communcations on server side. Twisted seems to be the most versatile web-socket async server.
Exactly, the cult of Emacs is pretty ridiculous.
That's good to hear. NumPy will still use the FORTRAN libraries lapack and blas for the linear algebra module if those libraries are available at build time though.
Crappy internet access, yes. Devoid of humor, no. I thought that my way of replying would properly convey that *I got it*, and hopefully add a bit of humor (albeit a tad black) in it self. Did I failed miserably? Let's blame my self-taught English. :-)
Having used vi/vim for over 20 years and doing python for more than 10, and finding that emacs gives me RSI, I'd say give no. Instead, I'd suggest using pyCharm, from the intelliJ people. http://www.jetbrains.com/pycharm/
No. Use PyCharm from http://www.jetbrains.com 
I'll check that, thanks for the feedback.
I did this once and I just iterated over a list of 1s and 0s.. but then again my code was sort of terrible. Anyway, I think OOP might be overkill for this, since all you need is a true and false attribute and a neighbour count, which you can just calculate for each cell iteratively. I'd be interested to see how some of the proper (hashlife, etc) implementations work. 
OMG. Maybe it was *me* who didn't get it :)
The learning curve argument against emacs was never really clear to me, especially if you're coming from something like IDLE. Really, what do you do with IDLE? Open files, save files, run files? C-x C-f, C-x C-s, C-c C-c, respectively. There: now you are as proficient in emacs as you were in IDLE :) From day 0 in emacs, you already have all of the proficiency you had in IDLE. Because you can't really do anything in IDLE anyway. Therefore you have nothing to miss. 
Do definitely learn either emacs or vim. You'll be investing into skills for the long term.
(I'm an IPython contributor, but not working on the Qt console) We've had various problems with PySide, which seem to be mostly the result of it being still very new. I think recent versions of PySide behave a lot better, but it may take some time for those to filter through into distributions etc. If it's possible for you to use PyQt, that's probably the most reliable at present. EPD ships PySide for licensing reasons.
What comes with Python is called Tkinter. It's a Python binding for the Tk UI libraries written for Tcl. I've used it before, and it's actually not bad - simple, lightweight, and doesn't need anything beyond Python itself. The main downside is the aesthetics - Tk applications look like they're about 15 years old. Of course, depending on what you're doing, that may not be a problem.
If you run vim as "evim" you start vim in easy mode.
But there are many things you wouldn't use Arch for, because of exactly that (rolling release). Say you're running an air traffic control tower with a control server using Linux and Python. The last thing you want is an automatically installed update breaking something critical. So you use a 'stable' version until you're ready to update to the next, very well tested stable version. That's an extreme example, but for most servers, stability is more important than new versions. If you doubt that new versions can break things: a couple of years ago, I tried to use some old Python 2.x code. All Python 2 releases were theoretically backwards compatible. But this code used the word 'as' as a variable name, and in recent releases of Python (2.6, I think), that became a reserved keyword. So the old code couldn't even be imported without an error.
I doubt the majority of vim/emacs users think that they're coding with something "cool", but instead with something powerful. Then again I'm overtly cautious of recommending vim/emacs to other people. If they pick it up themselves, then I will encourage them to continue
I'd say Qt is the better cross platform toolkit. GTK can be used on other platforms, but it's primarily designed for Linux. A lot of new Python GUI projects seem to be using Qt now - e.g. IPython's Qt console, Spyder IDE and Ninja IDE.
As a side note, what python mode do people generally use these days? It used to be that there was one distributed with emacs, one with python, and one of the two had problems understanding triple-quoted strings, and one was better at something else, and that's when I started feeling grumpy. Has a clear winner emerged?
I love PyCharm...and I use Vim.
&gt; I agree as someone working fulltime with eclipse/pydev as well. Kind of the same here, but on the other hand, sometimes I need to do some general text manipulation, especially when I want convert some external data into Python code/data, I start Vim somewhere and do it there. It's just a couple of decades ahead of what Eclipse can offer.
Is your prof the one telling you to use Emacs? (it sounds like you're a grad student in some capacity) If that's the case, then I'd learn Emacs. If you're using IDLE, even notepad++ would be an improvement in your workflow, so you might as well learn *some* editor, and if you've someone you can ask about more advanced usage of (ie your prof and fellow grad students), it might as well be Emacs.
Only if you don't know LaTeX or programming. The point of editor is to edit text. If you don't know what you want to write, and need something to hand hold you to help you say something, then get crutches to limp along. 
I'm going to agree - and I'm a part-time Emacs user. I use Emacs for Lisp programming, because it is very good for that. But for Python, actually I use GEdit. Because, like Python, it just gets out the way. I'm sure I could learn Emacs 'better' and be faster with it, but I find that the speed of the editor, or my ability to manipulate text, is much much slower than the ability of my head to output code. And that is what matters.
emacs has auctex, which I think does most of the things kile does -- however, I really just prefer to write my LaTeX with syntax-highlighting only and then compile every now and then.
http://code.google.com/p/spyderlib/
A lot of Emacs / Vim users use these kind of editors because they don't have to use the mouse. If all you do all do is work at your editor and various terminals not having to reach for the mouse ever really decreases repetitive strain. 
Also have a look at the [getpass](http://docs.python.org/library/getpass.html) module. It turns off echoing to do a password check. In fact, there's a good chance anything doing a password check at the terminal is using that.
Same here. PyScripter + it's dev(s) are pretty cool and doesn't afraid of Emacs. I tried Emacs, I just couldn't get a decent workflow set up with it.
It's not worth learning Emacs only for coding Python. It's worth learning Emacs if you want to have one (in my opinion quite efficient to use) editor for coding mostly everything (i.e. C/C++, Assembly, XML, Javascript, Python, Perl, csh/Bash, octave, LaTeX, Lisp, Haskell and much more).
Probably not a good idea. You don't know what HP tools are using that installation of Python. Go with the changes to PATH suggested elsewhere.
Structural biologist here. FORTRAN is still used a lot in our field.
I like vim, but it's the same difference. You should learn a little of one or the other if you're planning on working in a unix environment. At the least you should know how to use nano. You probably won't use any of these editors so much for your day to day code. For that an IDE like Eclipse is typically more convenient. But good skills with a terminal editor make it a lot easier to muck around with system configurations and do quick fixes on remote machines. 
If you don't want to set up and configure all the individual packages that make emacs amazing, checkout [https://github.com/pdee/pdee]pdee which bundles everything you could want (such as autocompletion etc) into one nice package.
Of course not. You should use a real editor: VIM. ;)
IDEs have shortcuts, too, but for those situations where you haven't memorized what those are, the GUI is there to guide you.
Is the poster the OP of the article, he mentioned he worked for HP. I also work for HP and wonder if he could get in touch with me.
GTK works on Windows and Mac OS. It's annoying to build, but once built it works pretty well. But there are sometimes little features that don't work everywhere, or performance problems on less-loved platforms. IMO GTK has a nicer API. Qt is a do-everything C++ framework with its own strings and sockets and whatnot, which means the API is bloated. GTK is designed to provide a GUI, not to take over your entire program. IMO Qt has a more polished implementation. GTK is currently going through the 2 -&gt; 3 and PyGTK -&gt; PyGI transitions. So you have to choose between an old version that's stable and documented but no longer maintained, or a new version that's unstable and not very documented but improving. Qt is currently in the process of being abandoned by Nokia and thrown over the wall to the community. I think it'll turn out fine (the KDE team won't let Qt die), but there might be some hiccups.
&gt; Python development transfers to anything else you might want to use &gt; Emacs for – and as you probably know, Emacs can be used for quite a &gt; lot of different tasks. I came here to basically say this. I am a long time emacs user and have used it for perl, python, C/C++, java, etc etc development. It is cross platform and extermely broad and powerful. I can read my email and I used to. IRC clients abound. org mode is awesome. There are a billion problems to be solved with emacs. I don't think it is worth learning emacs for python. But if you are interested in emacs as the above kind of platform then check it out.
I randomly opened a few examples in Chrome(on Linux) and I had trouble with any of them.. weird. 
Very nice looking! 
Been looking forward to this! Really enjoyed the last few! Thanks.
No. Use something like Sublime Text 2. It gets out of your way. For legacy reasons, if you know emacs already, then by all means use it. But if you don't know it, there are various better options. I have used emacs for years. And it is still a mystery to me.
I'll chip it for Sublime Text 2. Just tried it, loved it and bought it right away. You can also extend it with Python.
&gt; Oh yes, I love LaTeX! :) (that would sound so wrong out of context) Probably for that reason, it's pronounced la-tech (la as in "do re mi fa so la")
Y'welcome! I'll try to get the next one out earlier, before Christmas--I fear it'll be impossible to get anything done before Christmas and New Year's.
That makes more sense, plus it's relatively easy to just edit the path back if need be.
Seems interesting, if you want my feedback is that every time I see a project on launchpad I know I will not fill any bug reports or send pull requests because it is so painful to use. Bitbucket and specially github is so much better.
As a VIM user I know you can do it better.
Thanks ! excellent comment. BTW, if you have info to build gtk, please pass it around. We scratched our heads when we had to build goocanvas on win32. 
What version? I never saw this.
Well, I guess I can try out github. I still don't get the complaints about launchpad however. To fork something you just branch it, do some changes and push it elsewhere. Then, if you want to submit a request for review/merge, you go to the branch page and click that.
Python really needs this! =)
I'll be enjoying this one on the way to school this morning, I do appreciate it. Keep up the excellent work.
I have much left to learn :)
Aren't there quite a lot of modules for this? PLAC is one I found to be particularly good.
PyCharm is the only Python IDE I've found that's worth even trying.
I used to used emacs, but am trying to use gVIM because of the problems I was having w/ emacs. I dislike Pymacs, and have found it to be hard to use and develop. There are even cases where I have been unable to save my buffer because a pymacs save hook is unhappy about a non-existent process. Python support in vim isn't great either, though I do like the interaction with ipython, which actually uses zmq to properly communicate with the (ipython) kernel.
 syntax on set bs=indent,eol,start set expandtab set sts=4
That's too bad.
By looking at the PLAC doc, I would say my script situates between it and unpacking into function arguments. I like the idea of using annotations, it could bring aliases away from decorator arguments and closer to the function arguments themselves. Maybe coercion functions too. As for numbers, I did not look around much before getting started, I just had this idea and wrote it.
All the tools are terrible if compared to those other sites, and at least with the code I have to use bzr for the repositories are so big it makes everything slow. And that is not old bzr, that is me using the latest stable bzr and taking only two weeks diffs that amount to 60mb. The code review tool is terrible, it is just a box where you write stuff, you can't even see the diff in the same window. And then there is the junk folder that only makes sense if you live in launchpad.
So ok, you're a born presenter. Really good job. The guest however, I don't know how people his age will be received by a larger audience. Myself, I do not care, the guy plays a clear role in the community (even if behind the scenes) but maybe a few old hackers won't like their ears filled with people a third their age? He was an entertaining guest nonetheless. Make more please!
Thank you; I checked and pygooglevoice indeed uses the getpass you linked to. I'm checking out the source of the getpass, termios, and tty modules ... It looks like terminal programs actually work by sending information to streams, which the terminal then prints to the screen. I feel like I'll need to do research into how tty and these streams (stdin, stdout, etc.) actually work before I can wrap my head around the termios and getpass source and examples in a way that will let me apply them to my project. So far, I've only been able to to turn off both input and output entirely, versus creating a buffer for stdin and only printing that buffer to the screen after the print / for loop has completed. Any reading material that anyone can suggest on this would be greatly appreciated. BTW, I was able to test my program on Windows, and it buffers the output in this fashion, displaying it only after printing is complete. I guess that the Windows command prompt only has a single stream?
&gt; since I think there is no point to start a project in Python 2 now Since you can't find anything that works with Python 3, it seems like there is a really good reason to use Python 2. And if the big boys aren't Py3 compatible right now, don't you think you're going to run into the same problem with tons of little packages and utils? There is absolutely nothing wrong with using Python 2.7 right now. What features of Python 3 do you need? Or is it just that 3 is a bigger number than 2?
If I could use bzr on github, I guess I would have jumped ship a while ago. So on that, you have a point. However, as for repo sizes, you must be doing something wrong. Bzr is not the storage champion, but 60MB??? epsy@xknt ~ : du -hs $(find CODE -name '.bzr')|sort -h|tail 468K CODE/armagetron/trunk-armagetronad-eevent-thook/.bzr 484K CODE/armagetron/armagetronad/.bzr 632K CODE/armagetron/trunk-armagetronad-fortress_ai/.bzr 724K CODE/zthread/2.3.2/.bzr 748K CODE/zthread/trunk/.bzr 1.2M CODE/vectron/trunk/.bzr 6.9M CODE/armagetron/0.2.8-home/.bzr 14M CODE/armagetron/trunk-svn/.bzr 27M CODE/.bzr 31M CODE/armagetron/0.2.8-utf8-svn/.bzr Maybe it could be an importer's fault? The svn branches in there are space hoggers.
[clize on github](https://github.com/epsy/clize) ~~edit: uh oh, it isn't using &lt;pre&gt; formatting on the code in the readme...~~
I wouldn't worry about Benjamin being received by the Python community--he's already well-established. One cannot swing one's dead cat on c.l.p-d without hitting one of his posts. And you heard his credentials! I think older folks should draw inspiration from Benjamin's achievements and push themselves. I know I already have ;-) And thanks for the compliments!
Great! Also, there was a pause from him for a good two minutes whilst you essentially accused him of being autistic, maybe it's just me but that was uncomfortable. What are your thoughts on that? When can we expect the next? Any ideas for a guest?
Your bullet objects should have X and Y (position) as well as angle towards which you're shooting (and, optionally, speed). Then, using atan2(), you calculate the angle: alpha = atan2(Ymouse-Yship, Xmouse-Xship) and every frame you add V*cos(alpha) to obj.X and V*sin(alpha) to obj.Y If you need to know more, read about converting from and to polar coordinates.
Very nice. Thank you.
There are as many opinions as there are people. wxWidgets/wxPython is my bet (and many fellow coders share my opinion)
He did start out by saying "If you know how to set your environment variables, you should check out the PATH variable in your windows configuration." Only in the 2nd paragraph did he mention Python environment variables, so your original response was ambiguous with regards to that. But thanks for solving the problem in 3.3. I [raised this 4 years ago](http://groups.google.com/group/comp.lang.python/browse_frm/thread/ed6a6699c1eefc0e) and basically got shouted down by people who felt the sanctity of their PATH variable was more important than the fact that Python on Windows is pretty much worthless until you change it manually.
Since it looks like this is homework, I won't give you a detailed answer (so you can at least learn something). It looks like you are using the same code someone wrote in a previous post anyway. However, you can pretty simply add this feature by using a dictionary to map from something like ALA to 71.0. Once you have your amino code, you can just look it up in the dictionary and you should get the mass. You should look up [dictionaries](http://docs.python.org/tutorial/datastructures.html#dictionaries) and [raw_input](http://docs.python.org/library/functions.html#raw_input).
Get a copy of the Python Game Book. It starts very gently. Video of the bullet shooting chapter: http://www.youtube.com/watch?v=SDsomsEWl7E
That's perfect, thanks!
Looks interesting, will take a look, thanks :)
Yes. It's pretty much the reason why I'm getting anything done in Python. 
I am the hordes of emacs users (my name is legion), but I have to agree. Emacs is my weapon of choice for pretty much everything, I write prose and docs in it, I keep my organizer in it, and I code multiple languages in it. If I am really pressed for time I send it out to walk my dog and pick up my drycleaning. That said the direct answer to the poster's question "Is it worth learning emacs for coding in python" is no. You can code python in tons of things and if that is the only reason you are learning emacs, there is very little to no compelling argument for emacs over whatthefuckever. Note that the posters question is not Is It Worth It Learning Emacs. The answer to that question is a resounding yes. Emacs' learning curve is insane and to get *really* proficient runs many months. But the payoffs just in orgmode alone are huge, much less the other amazing things you can do really, really efficiently once you learn to use the parts you need as second nature. But if your only point in the exercise is to code python in it, fanboyism aside, one of the bazillion other things that competently edit python will work just as well and in a couple of cases better and all of them will have a shorter learning curve. And I personally don't share Willm's hate on for IDLE. It is a perfectly competent small editor for python only work. Use the IDLEX extensions, which are being highly actively developed by Roger Sewry at U of I, and it does a bit of fun stuff.
For those who are unaware what Cubes is and are too lazy to click through, taken from their page: [Cubes](http://databrewery.org/cubes.html) is a light-weight framework for online analytical processing (OLAP). Main features are multidimensional analysis and star and snowflake schema preparation and abstraction.
That is completely correct, but to be fair, none of them I have used have shortcuts that have the flexibility of emacs or vim. Really proficient emacs users who drank the whole drum of koolaid create macros on the fly and assign them to shortcuts as they code. It isn't that you can't do this with other tools, but you can't do it basically as quickly and easily as you think about it. Nothing I have used even comes close to the flexibility of emacs on this front. Vim would be next, and then there is everything else with these basic facilities. Which makes sense when you realize that pretty much all of emacs is just a really, really elaborate collection of macros.
Oh, pshaw. I would have edited out any two-minute pause ;-) Seriously, the audio you're hearing has been heavily edited. There's a lot more pausing, "um"s, "err"s, throat-clearing, "Sooooo..." and the like in the original. I leave in some pauses just to capture breath sounds to make it sound more natural; also, Benjamin would often pause when he needed to think, rather than saying "um" or "welll...." or something. Anyway, if there was a long pause there, either it just sounded better that way or I was asleep at the editing switch. Anyway, I certainly didn't mean it like that, and I don't think Benjamin took it like that. But I do have a nephew diagnosed with Asperger's, and I think the men in my family all have at least a touch, so it's a topic that comes to the surface pretty easily for me. And clearly Benjamin doesn't have Asperger's; he's very chatty and outgoing, two things which Asperger's patients rarely are IIUC. As for the next interviewee--I'm hoping it'll work out with MvL this month. Barring him, I dunno. But so far nobody's said no. So the sky's the limit!
Oh, I totally understand. I was just throwing a friendly heads up out there.
I've never done this before, but I believe that you can actually plug emacs or vim into an IDE, so that your editor in the IDE is actually emacs or vim. So you could conceivably have your cake and eat it, too, right? Or maybe I just completely made that up. I just tried a quick search for "vim ide" and I keep getting results like "vim as an ide."
I'll admit: language chauvinism and evangelism really "make sense" to me. _C++_ as a runner-up language of the year really _doesn't_ though.
&gt; The guest however, I don't know how people his age will be received by a larger audience. If anyone cares about his age enough to think negatively about him for being younger, then their opinion is not worth listening to.
I live in emacs, and I'd actually say no - not *just for Python.* Learn Python to learn Python. Use IDLE if it works for you. Use Notepad if it works for you (TextEdit, nano, GEdit, etc). Focus on getting work done in Python first. When you run up against limits, when you feel like something is slow, when you start asking "isn't there a better way to do it?" - *then* you should reach for emacs (or a vi-lineage editor). Not until then. The emacs ecosystem is full of awesome things. Many of them are geared towards Python in particular. But unless there is something about *emacs itself* that you want to learn, it's probably not a great choice. It's full of interesting side quests that can take up a lot of time, and if you have something that you need to get done *right now,* that's probably not a good thing. This is pretty much true of vi-lineage editors too. However, once you start needing them, oh man, they are so awesome. :D
You don't find them friendly because they aren't even remotely friendly. If anything, they are actively hostile. They are the M1 Abrams tanks of coding (quick nod to Neal Stephenson). Nor are they cool. If anything, they are highly non-cool at this point. As Masse points out, what they are is insanely powerful general purpose text processing technology. But friendly they are definitely not. 
Thanks for adding more description. Btw. if anyone has any questions about the project, let me know.
Look into TextMate for LaTeX editing; it's good, and really nicely integrated with Skim. But for coding nothing beats emacs for ease of split screen editing -- Ctrl-x 2; Ctrl-x o 
Totally agree.
It also won 'Best scripting language', with the runner-up being Bash
I think their poll is conflating 'most popular' with 'best'.
Create another dictionary where the keys are the values of x for each item in the first dictionary. Since you'll need to loop over every element in the first dictionary to create the second, you need to be searching more than once to benefit.
&gt; Emacs' learning curve is insane and to get really proficient runs many months. I'd like to take issue with this, a little bit. It's true that achieving God-Mode with emacs can take years. But that's just because there's no upper bound on how much emacs can do for you. At any point you are free to step off the space elevator, and you'll _still_ have a more productive tool than you did before you began learning. The time it takes you to get _as proficient as you were before_ is usually quite low.
Very good point. I have that in mind and will do that. To make things very simple and understandable to the end users, it requires quite a work on the internals. I am going bottom-up, from low level stuff, as it is being stabilized and useable. I am not quite sure about Django, but I will definitely prepare a simple web app. I am not a web developer, but i will try. Please, stay tuned :-) Meanwhile, you can browse a php app thah uses cubes slicer as a backend: http://tender.sme.sk/en/report/all?cut=date:2011,11 Slicer url (testing data, same model): http://slicer.democracyfarm.org/vestnik-preprod
You could implement this simple lookup myobj =[obj_dict[n] for n in obj_dict if obj_dict[n].x == 1] 
I suggest using the [all-in-one installer](https://github.com/dieterv/pygtk-installer/) It includes GooCanvas. 
You could use sqlite with a memory store.
that's not a "lookup" it's a linear search. and you're iterating over the dict twice myobj = [n for n in obj_dict.values() if n.x == 1] 
* [requests](http://docs.python-requests.org/en/latest/index.html) * [redis-py](https://github.com/andymccurdy/redis-py) * [pyzmq](https://github.com/zeromq/pyzmq) * [git-python](http://gitorious.org/git-python) All very clean, pythonic APIs.
because every POS app on the internet is written in python and not php... oh wait
I sometimes wish I could use Python to customize Emacs.
You have to do a traversal to find it with a dict. It's not made for this sort of search.
What do you think the 'best distro' should be?
I see your point, but disagree with it. Yeah, you can get equally proficient in emacs as in your previous tool in a very short time, assuming your previous tool was a very simple text editor. If you are coming from anything more advanced, you have to start learning some emacs-fu to get up to your former speed. Figuring out tramp is more complex than hitting a pulldown option for textmate to do remote editing, getting ctags and that ecosystem working requires some learning whereas the same functionality is configured out of the box in eclipse, etc, etc. And if you actually want the tool to be more productive, as you say, then you are at a minimum going to need to understand at least the rudiments of s-expressions and keybinding, among some other things. Yeah, okay, months is pushing it. In a matter of a very few weeks you can get pretty far along and step off the train if you choose. I dunno, it is like crack tho. Once you start getting to the point where you can say "more productive tool" you already have the addiction, and then start figuring out crap like how to do capture into org mode directly from your browser and start thinking that you would really like to ask Sasha Chua out to coffee someday. I do see your point and you might be right. I just remember my first experiences with emacs where I had to hop over what seemed like stupid barriers for quite a while undoing the muscle memory ingrained by every other program in the known universe at this point for the basic editing commands, learning antique emacs terminology for things that the rest of the world has settled on calling files and windows, and generally finding a major pain in the ass everytime I tried to do something simple like sane word wrapping (fixed now, but stupidly annoying when I started), only to end up with a little less power than I had in my previous solutions. If I hadn't watched a couple of emacs wizards do insanely complex things in no time at all with zero apparent effort, I wouldn't have returned to the platform determined to push through the learning curve until I could do at least a couple of the things they could do. So I am probably channeling some of my early frustration and assuming that others hit the same frustrations. Which very possibly isn't the case.
it's a "readers choice" award...only noobs read LJ
It's reader's choice and C++ sounds important.
IMHO, as of right now, Unity is the most usable modern interface. Mint and Fedora both use Gnome Shell which is hardly stable and not mature at all. I'm a fan of both Debian and Arch Linux, but would definitely not qualify them as 'the best' as they aren't usable for new users.
No mention of KDE?
Some IDEs can use vim (maybe emacs) as their editing component. Eclipse has a few of plugins that do that. A couple: * http://eclim.org/ * http://vrapper.sourceforge.net/home/
You know about pymacs, right?
Does anyone know a torrent client with a fun to use python api?
Yes, and every operating system on every desktop is some linux distro and not Windows... oh wait. There's a difference between being popular within a group and usage by groups.
I'm really starting not to believe that there are as many users as people think there are that have abandoned Ubuntu for different OSes. It's just a bunch of bailing from the band wagon hype.
There's been a gigantic push over the last 2/3 months for, 2-&gt;3 changes and library updates. Maybe you could roast (lightly) one of the non-conformant devs? Someone off the wall of shame, possibly? MvL could be interesting, definitely looking forward to the next episode. Credit to the community!
Interersting, though I fear the stuff you *actually* want to do with scripting a client is already there to do it. Mostly regex with incoming filenames, scheduling and automatic error handling.
Yeah, that. Also dispatching destination folders and controlling bandwidth/priorities/ratio. Do you know a client that allows that?
Not at all, but a lot of functionality is like that in uTorrent. There'll be *some* kind of plugin system for one though.
uTorrent has almost nothing of the above (it has very basic scheduling and no scripting at all). It doesn't even have a cli. There used to be a daemon to control it through the web interface, but it's abandoned.
I could talk about many reasons such as modal editing, but you'd really need to see an experienced vim user to see what I mean :)
Naah, RFP doesn't *do* roasting. We're non-confrontational and enthusiastic. But thanks again!
There's file regex, there's an error handling interface and afaicr there's scheduling.
Ah, I can tell you would enjoy it but I get your point ;) I would love for possibly a community section? Posed questions? Kind of like a higher level /r/learnpython? Something quite abstract (I can has metaprogramming?), nothing dealing with actual code, since it'll transfer to audio pretty poorly. I'm thinking like a "You can do X with Y feature, here's what I managed with it.". What about a 'Book Review' corner? An overview of a book or two, some esoteric topic that rarely gets covered (Python design patterns?). Just some ideas to attempt to ensure I get my RFP crack!
Scheduling is very basic, like I've said. As for file regex, could you tell me how to find it? Frankly, I think you've mistaken. Also I don't think I understand what you mean by error handling interface (the log tab?).
I'm at work and I don't have it in front of me but I'll be sure to look when I get home. There's almost certainly options for file regex and error handling, check your preferences pane. Possibly in the advanced options?
Nope. And the app site doesn't know anything about file regex.
I think of RFP as being closer to entertainment than education. A sort of Python-flavored conversation that you get to listen in on. So I don't think educational materials are in the cards. If I got inspired to do a book review, maybe that would work. I'd be open to doing Q&amp;A from listener questions, but my stodgy no-comment-form website doesn't lead to me getting much feedback. Maybe I should ask for questions in the next episode?
[This](http://i.imgur.com/BEkG4.png) is what I was talking about. It's not super-duper powerful, but I guess you could rig it to do what you want? Maybe something with AHK? It'll do a quick hack job. I'm looking through for the regex I was talking about, maybe it's the same pane since there is a file name option in there.
Also, [wikipedia](http://en.wikipedia.org/wiki/Comparison_of_BitTorrent_clients#Applications) has a comparison of clients, there's one or two with remote control, and one that says it has an XML over HTTP remote control API. Maybe try that?
http://eventlet.net/doc/modules/websocket.html Eventlet has a built-in module. I guess gevent is a branch of eventlet, so maybe they have a similar module ... though I'm betting the built-in came after the branch happened. There are also lots of cool examples in the repo.
I really like the current format, don't get me wrong. I was giving a few ideas considering I want the next episode and I want the whole series/show to succeed. You're currently doing a great job. Having said that, Q&amp;A could be quite good. Maybe if we knew the guest speaker, then we could submit a few questions, vetted by yourself, obviously. That'd give the keyboard facerolling idiots like myself the chance to interact with these mysterious figures that I hear and revere about on the web.
I've tried it and for some reason it sucked for things it shouldn't (like, didn't always execute the command). And I'm mostly interested in controlling active torrents, which run upon completion cannot handle even in theory. Like raising priorities for certain trackers or for torrrents with few seeders, moving files while seeding them, sorting by content type and so on. AHK wont do, nope. As for file regex, it's not there. There is something like regex for rss, I think you might be confused by them.
That's the last resort that I'm trying to avoid. Having a ready to wear python library to do the dirty work for me would be nice. That is what my question is about.
Hmm, indeed. Is there not an FOSS one you could try it out with, I noticed on the feature matrix that there was one with a Python license, maybe it's written in Python, too? If you *do* end up doing that, give us a bell could be quite an interesting project to work on.
As I mentioned in my other post, there could be a FOSS client that you would feel comfortable in hacking out a light API for the few features you require?
There are that are written in python (the table in wikipedia has this info too). Maybe there is a deluge plugin that would do. As for writing one, I'm not sure. I'm not a programmer really, but that might be fun. If I do try to write it, I'll make it known.
I was *just* reading about Deluge, looks like it could fit your needs. sudo apt-get install deluge Have fun!
I maintain my own "secret" list of Python libs/APIs at: [https://gist.github.com/797129](https://gist.github.com/797129)
Looks great. Never heard it before.
If it were a tool like a hammer, which is an extension of your hand, you would still perhaps be wrong, because it also requires a mental ability to do it well. But since we are talking about tools that are extensions of your mind, you are completely wrong. 
Arch+KDE = Sublime
Very interesting, my evening sorted then :D
1) Web technology is not *true* cross-plattform. 2) Web technology can't replace a UI framework like Qt. User experience and performance can't be matched.
I guess [PyFilesystem](http://code.google.com/p/pyfilesystem/), which is a module I started to ease the pain of working with files and directories, but has since turned in to something much bigger. Odd thing is that although I use it frequently for hobby stuff, the majority of the people that use it are working for big companies in the filesystem (cloud, backup) field. For applications, it's great for building a painless plugin architecture.
Mint's upgrade path is to do a complete reinstall. This is a joke. xubuntu seems to be alright to me - at least there is an upgrade path.
If only there was some form of single file database that came bundled with python, that would be perfect for this situation! Oh wait, hello Sqlite3
http://bottlepy.org/bottle.py &lt;-- always points to the most recent version on github.
I like the part where you're getting downvotes for being real about Ubuntu. Have my upvote.
I hope the keys in your first dictionary are not really consecutive integers?
Well there aren't any new ones to replace it yet. Python is great but has many shortcomings that a new language could fix.
WTF is this?
LJ has always had a Python bent...
I don't know why you were downvoted, but this is precisely what should be done when creating a large dataset that needs to be queried in different ways. 
[Deluge](http://deluge-torrent.org/) is written in Python, supporting extensible plugins written with Twisted, GTK+/Glade, and Javascript for its WebUI. Performance is somewhat iconic of what one would think of clunky Python applications, sadly.
Who won the best soda category?
You have to consider that the language is the sum of many things: the language itself, the libraries available and the community support. I use python most often for coding, but as a language I will tell you straight up that Lisp is far far superior. But if you meet a problem, you are likely to find Internet help in seconds for Python - that is a big bonus.
Given that it's - you know, a poll, you would expect the most popular language to be voted "best". The people who like it and vote for it do so because they think it's the best.
Agreed. I also contemplated learning emacs, but then I figured, why the hell would I want to do that? Got me a copy of PyCharm, which is a fantastic IDE, and never looked back. 
Yeah, funny how that works.
Thanks for the feedback. The reason for the google sign in is simply so you can save any changes you make to either the exercises or the examples provided in the text. Using google app engine was an easy way to do this in time for me to use the text in class this fall. During the break I'm going to look at making the login optional.
Web technology can't replace Qt but he is trying to write an app to replace a CLI app for taking notes. Surely, you are not saying there are no note-taking web apps.
I will probably end up using this. I tried testing a few methods, and although searching with a for loop at 50,000-100,000 objects is about half a second, the amount of RAM required is just insane [for what I need] (~150mb for 50,000 objects with 6 short integers).
For a start I'd head towards PEP8.
I would say if you're likely to edit lots of text based files in the future, whether that be code, csv files, xml, your novel then spending the time learning how to use a powerful editor will eventually pay off. Personally I use vim for no other reason than that's what I started with, emacs can do everything vim does and vise versa. Is it worth it for just programming python? probably not. Would learning python and emacs (or vim) at the same time be easy? probably not If you want to learn emacs, just start using emacs to do everything text based and take the hit on how long it'll take you to do things until you've learnt a few things.
this is a prototype of an idea I had to use generators (basically, coroutines) to allow an event handler function to schedule more event handlers when it runs. the prints are all there to test that code flow is what I expected it should be. The class GeneratorCallback defines a wrapper for the created generator. The multiple() function is a decorator that turns a generator function into a multiple-handler. When a multiple-handler yields a callable, that callable is called with the generator callback as the argument. when the generator callback is called, it resumes executing the event handler with the arguments passed into yield until it yields again or finishes. This was just a crazy idea I had. it seems to work beautifully, though, so much so that I think I'll use it in serious code. Experiment success!
Can you address the other posts in this thread?
Like what? (shortcomings, I mean)
A new language like Python 3.
the first line is a reply to "wtf is this", and as I said about prints, the print in your copy and paste was as part of the test. In any case, I should mention two things: - **apparently twisted already had an implementation of just such a thing** (twisted.internet.deferred.inlineCallbacks) - I wrote this at 11 pm last night and it is currently nearly 11 am. I posted this because I thought it was a cool idea. It seems I may have erred in doing so, as the code seems to confuse everyone I show (ie, it is not fit for public viewing).
no, callable would be the instance that is passed to the function. being defined in the function signature overrides the builtin for that scope. &gt;&gt;&gt; def p(callable): ... print callable ... &gt;&gt;&gt; p("ohai") ohai &gt;&gt;&gt; It is quite obvious you did not read his 'output' section of that gist. The print statement in the very add function you posted would have showed you this! 
I'm not sure I understand this 8 by 8 list. Are we talking about something like this? &gt;&gt;&gt; g = [[b for a in range(8)] for b in range(8)] &gt;&gt;&gt; g [[0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 6, 6, 6, 6, 6], [7, 7, 7, 7, 7, 7, 7, 7]] 
because if yes, then why would a Dictionary would be far more useful compared to this? What is your purpose with this data structure? What is the problem you want to solve with it? Without knowing the underlying problem, there is no way to tell whether a dict would be more useful
Perhaps in the future, you could choose not to troll. But based on your feedback elsewhere, you do appear to suffer from this affliction. So, I am not all that hopeful. Your response was about as necessary as this one.
Based on my post history I guess? People looking at this post please, I urge you to read my post history and realise this guy is literally grasping at straws with that. Have fun with feeling vaguely superior about something that's vaguely important.
Kind of, however in this project those spaces are populated with 'None' and instead of integers we must insert Tiles, or pieces, the project goes into further detail such as how pieces connect to each other, so I am trying to figure out how to search for specific spaces faster a tutor gave me the notion that my idea of using a dictionary was on the right track but wouldn't go into further detail.
A list is the most common way to implement an 8x8 grid. For a beginner, unless you have a specific requirement where a dictionary makes more sense, you should use a list. The 8x8 grid can be thought of as a normal X,Y grid from geometry. So, X=0, Y=0 is the first cell, X=1, Y=0 is the cell to the right of that one, and X=0, Y=1 is the cell below the first one (or above it depending on how you think of the grid). In terms of Python, you would access the above cells via: grid[0][0] grid[0][1] grid[1][0] or in other words: grid[Y][X] You can think of the grid in Python terms as two nested lists. The first list has other lists as it's contents. The first part, grid[Y], is accessing (or indexing) the first list. The second part, [X], is indexing the second list. FYI: You can arbitrarily nest lists, so you could have something like biglist[0][3][6][8][3]... etc.
Love requests. Also, [Tablib](http://docs.python-tablib.org/en/latest/index.html) by the same author ([Kenneth Reitz](http://www.kennethreitz.com/))
So you would use integer keys in your dict of dicts like this? With actual Tile objects as values instead of strings? dgrid = {} for a in range(8): dgrid[a] = {} for b in range(8): dgrid[a][b] = 'Tile'+str(a)+str(b) print dgrid {0: {0: 'Tile00', 1: 'Tile01', 2: 'Tile02', 3: 'Tile03', 4: 'Tile04', 5: 'Tile05', 6: 'Tile06', 7: 'Tile07'}, 1: {0: 'Tile10', 1: 'Tile11', 2: 'Tile12', 3: 'Tile13', 4: 'Tile14', 5: 'Tile15', 6: 'Tile16', 7: 'Tile17'}, 2: {0: 'Tile20', 1: 'Tile21', 2: 'Tile22', 3: 'Tile23', 4: 'Tile24', 5: 'Tile25', 6: 'Tile26', 7: 'Tile27'}, 3: {0: 'Tile30', 1: 'Tile31', 2: 'Tile32', 3: 'Tile33', 4: 'Tile34', 5: 'Tile35', 6: 'Tile36', 7: 'Tile37'}, 4: {0: 'Tile40', 1: 'Tile41', 2: 'Tile42', 3: 'Tile43', 4: 'Tile44', 5: 'Tile45', 6: 'Tile46', 7: 'Tile47'}, 5: {0: 'Tile50', 1: 'Tile51', 2: 'Tile52', 3: 'Tile53', 4: 'Tile54', 5: 'Tile55', 6: 'Tile56', 7: 'Tile57'}, 6: {0: 'Tile60', 1: 'Tile61', 2: 'Tile62', 3: 'Tile63', 4: 'Tile64', 5: 'Tile65', 6: 'Tile66', 7: 'Tile67'}, 7: {0: 'Tile70', 1: 'Tile71', 2: 'Tile72', 3: 'Tile73', 4: 'Tile74', 5: 'Tile75', 6: 'Tile76', 7: 'Tile77'}}
I use vrapper and like it a lot. Installing it is just dropping a file into a folder and you can toggle the whole thing on or off with a button in Eclipse. The only thing I don't like is that Eclipse in general is so much bigger and slower than using "real" vim, especially when you open a bunch of large files on a remote machine and java starts to cry. Vrapper isn't actually vim, just a keybinding wrapper, but the only place you'll notice is the performance lag, plus I think it's missing a couple of advanced features. Overall it's pretty cool and a much easier way to get started with vim if you already happen to use Eclipse for anything.
what about simply: {(0,0): "origin", (0, 1): "first square to the right", (1,0): "first square down", (1,1): "farthest square out"}
TIL. Thanks for blowing my mind.
Does Scipy.ndimage do what you want? http://docs.scipy.org/doc/scipy/reference/ndimage.html There is also scikits-image: http://scikits-image.org/ (I haven't used either of them but had looked at the documentation for both recently and thought maybe they would help)
Yeah, I'm using that all the time in the game I'm developing. That allows me to have sparse grids for the areas where the player cannot go. And better still, that allows me to use negative indices and removes any need for resizing the grid. For example I can set the center of my map to (0, 0) and then my procedural generation algorithms can build the world around that point without bumping into arbitrary borders.
I'd be interested
Yea, I'd be interested. 
We definitely need more of this.
I'd be super interested~!
Interested!
Anything with a hashcode can be used as the key for a dict! Also, to OP, if your list is "sparse" (only a few of the squares in the 8x8 grid are filled), then a dict is the better choice. If everything is filled, it's better to just use a 2d list.
I'd like an excuse to program in Python.
How about OpenCV ?
My upvote says yes
Yes
8 by 8 is very small... I'm not sure why you would want to use a dictionary for this. Keep in mind that 'size' is not too much of a problem here, and dictionaries have their own overhead which is much higher than that of lists. "Useful" is a very vague term here. Personally, I see basically no difference in foo[x][y] and foo[(x,y)], other than knowing that the former is somewhat faster than the latter. You'll have to define some kind of default behavior for accessing x,y if it isn't already in your dictionary, and at that point you're either using foo.get((x,y), default) or just prepopulating foo with default for every (x,y), and now that we've gone this far, please just use lists: they're made for this. Lastly, unless you're putting millions or billions of these grids in memory, I don't think the time and brain power used to sort out dict vs list is even worth spending: let Python do it's thing and don't worry about this kind of performance optimizing minutiae. If you need to scrutinize it that closely just use Numpy, Java, or C.
I'd definitely be interested. I can make and review problems as well, I have a few that might be good.
interested
This is right, except I think you meant (7, 7): "farthest square out" (One cute thing about using dicts is that since the keys are arbitrary, you could use 1-based coordinates instead of 0-based coordinates and it would still work. I would not recommend that, though, because if you later switch implementations you'll have to change your coords.)
Wait, how did I miss these! These look very promising - thank you!
Hm, I'd seen reference to OpenCV before but had misread it as OpenCSV which I thought was not relevant. But this totally is.
I would be interested in this, if not to actually do it then to read the solutions others have come up with/discuss those solutions...
How about investing an equivalent amount of effort in attempting to port some packages to Python 3? It would be a great way to get some Python experience and maybe even gain you some kudos in the community...
Sounds fun
I bet you give out raisins for Halloween
I'd do it...but I'm a beginner so I'd need beginner-moderate level quizzes.
I would love this.
I too would be interested
Sound sgood to me.
I live in emacs, so I should be kind of biased: but I don't think you need to learn emacs just for coding in Python. Don't bother. Of course, if you need to interact with your computer for any other task as well, that would be another matter altogether. 
Sign me up.
This is not a Python specific website but reading the responses I get the feeling a lot of you would like to check it out: http://projecteuler.net/ There's nothing stopping you from completing the problems in Python. There's a high range of difficulty and lots of discussion to be found after you solve a problem and are interested in different or better methods.
Best advice I can give is to read [this](http://docs.python.org/library/index.html) a time or two and attempt to use some of the standard library. There's also [PEP8](http://www.python.org/dev/peps/pep-0008/), the standard syntax and style guidelines. Above all, just keep on making programs. It's literally the best way to learn. Read the docs and source for some popular modules (like [Twisted](http://twistedmatrix.com/trac/) or my favorite web microframework [Flask](http://flask.pocoo.org/)) and try to use whatever modules you find for *something* even if it's trivial.
no, dateutil is not a standard library. So, it's not "already there". 
A good example of the "one obvious way" emphasis in Python.
Oops. It's actually there in OS-X, I didn't think it would not be there in a standard distribution. Thanks for the clarification (the author here). I'm going to change the article and I'd like to credit you, if you'd send me an URL I'd link to you. 
Thanks man, I just tagged all those sites in my Delicious account. Right now I have some videos I pulled down from my company's Lynda.com account. They are mostly Python 3 though, and most things in production (we are a huge Mac shop) run Python 2.6 I think out of the box. 
...I can't tell whether you're agreeing with me or missing the point. I'm saying, they're not "conflating" anything - it's just the expected behaviour of a poll. Although maybe I took your comment too literally in the first place...
Yeah no problem at all. It seems as if Python 3 is right around the corner, but most major modules are still using 2.6/2.7, and most systems include 2.6.
Cool, that looks like a great resource for problems. Thanks.
no need to credit, but plz do change it. But I actually found a good, and usable dateutil library thanks to it.
Done.
* [Good to Great Python Reads](http://jessenoller.com/good-to-great-python-reads/) * [Google Python Class](http://www.youtube.com/watch?v=tKTZoB2Vjuk) * [Python by Osmosis](http://www.youtube.com/watch?v=_XpD71zR6kI)
http://www.spoj.pl has also a lot of "problems" you can solve if you're interested.
I'm a system admin RHEL 4&amp;5 have python 2.4 or earlier RHEL 6 uses 2.6 I wrote an blog post about this topic here: http://russell.ballestrini.net/a-system-administrators-guide-to-installing-and-maintaining-multiple-python-environments/
thanks for this
thanks
You would need to use a regular expression to remove multiple instances of white spaces and collapse them down into a single space (or no space at all). 1. Read line from file. Hint: for line in file: 2. Use a regular expression to remove multiple spaces. Hint: use [\W]+ This looks suspiciously like a homework assignment so I'm not going to give you the actual code. But that should get you started.
Are you sure they aren't tabs? It ought to be very simple to split on tabs (you'll have to find the python escaped tab character). If they are actually spaces look here: http://docs.python.org/library/re.html there is a re.split() method that should work perfectly for you.
Is there a list or some way to find out names of packages that need help getting ported to python3? I will have lots of free time during winter break and would love to contribute. 
Count me in as interested. I've got a few python problems which 'I'm struggling to find a good approach toward' that could be cast as more general, entertaining or thoughtful questions than your average stackoverflow question. And I've got some 'ahhah!' moments that I'd like to tell others about it. There's a definite niche for this. Some problems are too complicated for /learn_python; too simple for the gurus on stackoverflow (and I'm ignoring the tsunami of 'how do i connect to a db' type questions that SO is struggling with). Using reddit for this sounds like a winner. I'm in. I'll post an unanswered puzzle that's been on my mind (in, I hope, an entertaining way*) and in return will do my best to help out. Again, not a guru, but not a newb. More interested in the fun and the interchange. *It will involve Zaphod Beeblebrox.
 for line in open(filename).readlines(): line.split() will give you the required answer. it will remove the whitespace, and give a list with words (no whitespaces in the returned list)
http://docs.python.org/library/stdtypes.html#str.split check out string split documentation. default is all whitespace characters (includes tabs, and spaces)
stockholm syndrome
About the verb/verb.py, import all the necessary things into verb/__init__.py, that way you don't have to change the code. (I am still reading, I will comment as I go)
instead of __all__, do \__slots\__ and do from verb import *. that way you can skip unnecessary things
TIL that `str.split` has different behavior if you omit *sep* or pass in `None`. +1
&gt; It's actually there in OS-X Are you sure you didn't install it yourself, or as a part of something else? It's not on the Mac I just dug up (10.5, semi-old) and I haven't heard of it being installed on newer ones.
You have my upvote.
Read [The Python Cookbook](http://code.activestate.com/recipes/langs/python/) - I can't recommend it enough. O'Reilly do a book with some of the best ones in as well as explanations of how and why they work. I can confirm that this is very good as well. Finally, it sounds trite, but grokking [The Zen of Python](http://www.python.org/dev/peps/pep-0020/) makes an appreciable difference to the way you express yourself in the language. Good hunting!
Yes, very much so. May I suggest having and easy and a hard problem of the week? Or perhaps an easy and hard version of the same problem? That way newbies like myself and more experienced people can all participate.
yes, readlines will give you lines. do a split on each line. it gives you a list of words (anythings seperated by whitespace) in return I didn't get the point of your comment. What is it? if you do &gt;&gt;&gt; [line.split() for line in open(...).readlines()] [['Michael', '95'], ['Jason', '75'], ['Tom', '86']]
are you elaborating my points. Thanks for that.
Essentially this boils down to how sparse your grid is, i.e. how many squares have no value and don't need a representation. If your grid is not sparse at all, then using a dict is a **humongous waste of memory.** On a 32 bit system: &gt;&gt;&gt; from sys import getsizeof as sz &gt;&gt;&gt; l = [[1 for a in range(8)] for b in range(8)] &gt;&gt;&gt; sz(l) + sum(sz(x) for x in l) 576 &gt;&gt;&gt; d = dict((x, dict((y,1) for y in range(8))) for x in range(8)) &gt;&gt;&gt; sz(d) + sum(sz(d[x]) for x in d) 4680 &gt;&gt;&gt; 4680 / 576 8 An 8x8 grid of integers took 576 bytes using a list of lists, and 4680 bytes using a dict of dicts, eight times as much. On a 64 bit system it's more like 1224 and 9432, or seven times as much. The only way that the dict solution can possibly win is by being sparse, not having to represent some values. Here's a dict with 50% sparseness: &gt;&gt;&gt; sparsed = dict((x, dict((y,1) for y in range(0,8,2))) for x in range(0,8,2)) &gt;&gt;&gt; sz(sparsed) + sum(sz(sparsed[x]) for x in sparsed) 680 Even with only half the amount of data, it's still close to 20% larger. The actual break-even point will probably depend a lot on the actual data being stored, but if it's expected that your grid will be not be that sparse then drop this dict idea. dicts are also going to be slower to access than lists, but it will probably be only marginally so. 
Thanks for the info it is appreciated.
&gt; Good books on Python or programming in general? "Python Cookbook" and "The Art of Computer Programming" &gt;Worthy for-pay IDEs WingIDE, my personal favorite Python IDE.
I support a HUGE Macintosh deployment and we have lots of back end technologies on our servers. SQL, .NET, eDirectory, Open Directory, MySQL and I want to start tying these things together and using their APIs to develop in-house solutions. As of right now everything is still separate, and I have to do manual import/exports from one database to another. We use the databases for policies and inventory and things like client management.
Aww snap! Yes, multiple levels of difficulty! ...but that would be quite a bit more work... Love the idea though!
 I renamed __init__.py back to verb.py in the verb folder and made a new __init__.py call from verb import * This probably wants to be from verb.verb import * As it stands now, it is doing a relative import which is causing confusion.
Here is a comparison of that function and my naive method: $ python getsizeof.py size of 8x8 list of lists, naive: 576, sophisticated: 588 (1.021x) size of 8x8 dict of dicts, naive: 4680, sophisticated: 4776 (1.021x) I'm not entirely sure where the discrepancy is coming from, but their method seems to recursively call `getsizeof` down to each individual element, whereas mine takes the size of each list/dict itself. In either case, the ratio of the two (dict vs list) remains nearly the same. 
Are you loading the entire dictionary into memory at once? You could partition it in some fashion or, if it's deserialized, run it through a generator Do you have control over the conditions under which these objects are getting created? If your criteria don't need to be ad hoc, you could inject some kind of middleware and filter out objects that don't match
The implementation is far from without faults. The whole idea of offset-aware datetime objects [was a big mistake and leads to lots of pain.](http://lucumr.pocoo.org/2011/7/15/eppur-si-muove/) 
This is a good book: [Python Essential Reference](http://www.amazon.com/gp/product/0672329786/ref=pd_lpo_k2_dp_sr_1?pf_rd_p=486539851&amp;pf_rd_s=lpo-top-stripe-1&amp;pf_rd_t=201&amp;pf_rd_i=0596100469&amp;pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_r=1J5408H76D83AGRW29FQ). If you're looking for gift ideas for new programmer my advice is always one of the three things: * A good keyboard. * A good pair of headphones. * Good coffee and mugs. Those three things usually go over well with programmer-types.
do it
Very interesting - Forgive me for not having dug too deep before jumping into some questions, but is the user expected to write their own "helper" methods for interfacing with the original data, and how would they be any better than what you provide in your tutorial? What do you mean by "light weight" - i.e. what limitations do you expect? Some analysts consider that pivot tables provide similar functionality as a "lightweight" OLAP cube... and for Python there is pivot table methods for pandas DataFrame objects. Where do you suspect Data Brewery fits in with respect to pandas, numpy, etc. tools? Thanks! 
This is pretty simple. Itertools helps out a lot. Use the standard library! from itertools import permutations, chain def get_dictionary(fn): """Return list of all words. Change it to load your dictionary """ return ['a', 'abc', 'aee', 'aff', 'ass', 'bbb', 'bad'] def find_possibles(s): """this would be clean but I use crazy list comprehensions""" ret = (["".join(c) for c in permutations(s, i+1)] for i in range(len(s))) return set(chain(*ret)) def find_in_dict(s, fn): possibles = find_possibles(letters) return [i for i in get_dictionary(fn) if i in possibles] fn = 'something.txt' letters = 'abcd' print find_in_dict(letters, fn) #edit: oops, I guess I'm not following directions precisely (not outputing longest, but all words that match).
Running 10.7. I don't have it in any of the Pythons I tested. Edit: See below. It's not in my `/Library` Pythons but it is in my `/System/Library` Python. Of the two, I think the `/System/Library` is more fundamental to OS X. I believe plain `/Library` is where new software gets installed.
Redditor Rhomboid helped me in another thread with some articles on how the terminal functions. The big thing was that I had never seen/used bit operators in Python before (just barely starting using them in 6502 hobby stuff). I ended up using a method similar to what getpass uses; use some bit operators on the terminal settings that are returned by termios.tcgetattr(sys.stdin.fileno()). I couldn't use the getpass method exactly, as it would still allow typing over the display. Instead, I had to tell it to ignore input entirely. The downside to this is that what is typed during printing will not appear at the prompt after printing is completed as it does without termios under Windows (at least I can't figure out how to make it do so), as nothing typed is being saved to a buffer (note: sorry if I'm misusing terminology, as I'm just making my slightly educated guesses). Because I couldn't find it anywhere else, here is the relevant source for the benefit of future generations / Googlers: def echoOff(self, hos): # Input will not be stored until echoOn is run; if someone is able to figure out how to make input go to a # non-printed buffer or something instead, please let me know -DefectivePrinceNaoto if hos == 'posix': # determined via platform.platform() try: self.fd = sys.stdin.fileno() self.oldattr = termios.tcgetattr(self.fd) self.newattr = termios.tcgetattr(self.fd) self.newattr[3] &amp;= ~(termios.ICANON|termios.ECHO) # Similar to how getpass does it; compares lflag vs static values in termios module termios.tcsetattr(self.fd, termios.TCSANOW, self.newattr) except: os.system('stty sane') # Just in case ^^; def echoOn(self, hos): if hos == 'posix': try: termios.tcsetattr(self.fd, termios.TCSAFLUSH, self.oldattr) except: os.system('stty sane') # Just in case ^^;
I'm curious where you see Bottle is going broadly speaking and in terms of specific features. Or Bottle is essentially "stable".
Definitely.
You could add &gt; print max( find_in_dict(letters,fn), key=len )
I think you missed more directions than that. You're supposed to use the dictionary he linked to and make a script that uses it.
 Using a set for the dictionary and using '\n's like blanks to get different sizes of words. Not rigorously tested (and therefore most likely wrong! Yay!) def theProb(dfile, *letters): #'\n's are just used like blanks letters+=('\n',)*(len(letters)-1) with open(dfile, 'r') as f: dictionary=set( f.read().split('\n')) maxword='' for wrd in permutations(letters): word=''.join([wrd[i] for i in len(wrd) if wrd[i]!='\n']) if word in dictionary: if len(word)&gt;len(maxword): maxword=word return maxword
max will only return one item but as per the instructions the solution should find all the longest matches
In retrospect this is terrible. I wasn't aware that permutations had a size parameter. Swap out for wrd in permutations(letters): word=''.join([wrd[i] for i in len(wrd) if wrd[i]!='\n']) with for r in xrange(1,len(letters)+1): for wrd in permutations(letters,r): word=''.join(wrd) and also eliminate the letters+= line.
 from sys import argv allowable = set(argv[2:]) with open(argv[1]) as f: words = filter(lambda w:(len(set(w)-allowable) == 0), (s.strip() for s in f.readlines())) maxlen = max(map(len,words)) print filter(lambda w:len(w) == maxlen,words) In a nutshell, the code creates a set of allowable characters, filters out the dictionary words that use forbidden characters, then pulls the words that are as long as the longest word. **EDIT:** whoops. I misread the specs. My solution was using the input as the set of allowable characters, so it ignored how often they occurred. Here's a more correct, but slightly uglier solution: from sys import argv allowable = sorted(argv[2:]) def is_valid(w): def helper(w,i): if len(w) == 0: return True elif i &lt; len(allowable): return helper((w[1:] if w[0] == allowable[i] else w),i+1) else: return False return helper(sorted(w),0) with open(argv[1]) as f: words = filter(is_valid, (s.strip() for s in f.readlines())) maxlen = max(map(len,words)) print [w for w in words if len(w) == maxlen] 
Simplest method I could think of. https://gist.github.com/1441352
True. Then f=find_in_dict(letters,fn) m=len(max(find_in_dict(letters,fn),key=len)) print filter( lambda x: x==m, f )
This should probably be the standard way of posting solutions to avoid unwanted spoilers.
permutations is just way too slow. There is no reason to spend exponential time on this. Assuming the library you are reading has no structure to it, then no matter what you do, it is going to have to involve looking at every member of the dictionary, and looking at letters for matches. The straightforward approach therefore is just O(n * w * log(L)) for *n* words of length less than *w* and *L* letters in the set: letters = set(argv[2:]) length = 0 results = [] with file(argv[1]) as f: for line in f: word = line.strip() if len(word) &lt; length: continue for letter in word: if letter not in letters: break else: if len(word) &gt; length: length = len(word) results = [word] else: results.append(word) print ', '.join(results) Maybe not pretty, but this uses hardly any memory and it's hard to see how it could be much faster. *Edit: replacing the (for letter in word) loop with a regular expression would move more code into the c layer and therefore speed things up a bit, I guess.*
Agreed.
Nice one. I like your solution. It's readable and concise. 
In more modern python: words = [s.strip() for s in f.readlines() if len(set(s.strip())-allowable) == 0] You can add whitespace to your allowable set to leave off the second strip if you want.
When is the deadline?
Whenever. As you can see, people have already started posting solutions. Take your time though.
I like it, although this doesn't satisfy the requirement: &gt; Note that each letter may be used only as many times as it occurs in the list of legal letters.
I like a lot of things but mostly stuff which interacts with the web although not limited to this. Maybe games too. Although some times, one of my major problems is not having any ideas on what to make, something interesting, something cool. I coded a version of genetic algorithms in matlab to adjust the data of organic solar cells to a theoretical curve (work related). I'm planning in recoding it from the ground up in python. 
I don't think you can use a set for the input letters because the set elements are unique. E.g. \&gt;&gt;&gt; a = ['a','a'] \&gt;&gt;&gt; b = set(a) \&gt;&gt;&gt; b set(['a']) 
Very nifty. I didn't know you could do that. Python keeps surprising me with how awesome it is.
No, it's not a very efficient method, especially if you start passing in a huge letter set since things grow at n!. To be fair though, this method holds up very well up to 9 characters (at least on a modern machine), and the domain appears to be scrabble (in which players only play with 7). In fact, this method blows http://www.reddit.com/r/Python/comments/n3arf/python_quiz_of_the_week_1/c35yq8n out of the water in execution time for the &lt;8 tiles (we compared answers in IRC, and we used /usr/share/dict/words as the corpus). In any case, I treated this as a whiteboard problem and solved it with the simplest method I could think of. While it explodes your machine at high tile sizes, I think the code is pretty clean and simple to understand. I'm definately not selling it as the best solution :)
I'll look into these things. Thanks.
I'll test it out. Thank you.
The problem is that the developers have more or less abandoned their packages. They have the ability to port, but just don't. As such, nobody knows what needs porting. Give me a package, and i'll port it 
I may edit this when I have more time later. But I did this once a while back with *a bash script* as a proof of concept. The gist: 1. Use a regular expression to restrict the dictionary to only words with the letters in your list. I used: $(egrep "\^[$LETTERS]{4,16}$" /usr/share/dict/words); so the python would be very similar usage of the re library. 2. Sort the list by word length, most to least. Reject any word longer than your letter list. 3. For each remaining word, walk through your list of letters, removing each as a single match from the target word. Both must run out at the same time for a match. (all the letters, right?) Alternatively, you can make this more fuzzy by letting the word run out of letters first, because there may be cases where your list can't produce any word that uses every specified letter. 4. Repeat step 3 until you reach a word length threshold (so you don't exhaustively scan everything) or build the code to stop once the next word match has less letters than the previous match. The problem is "longest matches" after all. I used this to cheat at Bookworm. ;) It's surprisingly fast, since it weeds out most of the dictionary in the first pass. You can see my example RE weeded out anything less than 4 letters long automatically because... well, if you can't anagram 4 letters on your own, you've got problems. I'll see if I have more time later to flesh this out in python if someone else doesn't first. **Edit:** And now the equivalent python to my approach: import re, sys word_file = sys.argv[1] word_source = open(word_file, 'r') letter_list = sys.argv[2] pattern = re.compile("^[%s]{,%d}$" % (letter_list, len(letter_list))) candidates = [] maxlen = 0 for word in word_source: word = matcher = word.rstrip('\n') if not pattern.match(word): continue for letter in letter_list: matcher = matcher.replace(letter, '', 1) if len(matcher) == 0: candidates.append(word) if len(word) &gt; maxlen: maxlen = len(word) print [ word for word in candidates if len(word) == maxlen ] Called with: python find.py /usr/share/dict/words ighlpra Returns: ['grail', 'graph', 'phial'] I'm sure there's a better way, but I'm not a python guy. It's basically a faithful representation of my bash script, though. :p **Edit 2:** The bash script was *way* faster... :( Here it was: LETTERS=$1 [ -f /tmp/working.txt ] &amp;&amp; rm /tmp/working.txt for x in $(egrep "^[$LETTERS]{4,16}$" /usr/share/dict/words); do echo -e "$x\t${#x}" &gt;&gt; /tmp/working.txt done IFS=" " FOUND="" for x in $(cat /tmp/working.txt | sort -nr -k 2 ); do WORD=${x/$'\t'*/} BITS=$LETTERS for (( y=0; $y &lt; ${#WORD}; y=$y+1 )); do part=${WORD:$y:1} old_len=${#BITS} BITS=${BITS/$part/} new_len=${#BITS} [ $new_len -eq 0 ] &amp;&amp; [ ${#LETTERS} -ne ${#WORD} ] &amp;&amp; break [ $old_len -eq $new_len ] &amp;&amp; break [ $y -eq $[${#WORD}-1] ] &amp;&amp; FOUND=$WORD done [[ $FOUND != "" ]] &amp;&amp; echo $FOUND &amp;&amp; FOUND="" done echo $FOUND 
Running OS X 10.7.2 with Python 2.7.1, have it installed and didn't install it myself. Edit: [screenshot](http://i.imgur.com/bGaRH.png)
 #!/usr/bin/env python from itertools import combinations def sort_letters(string): return sorted(char for char in string) def main(dict_filename, *letters): words = {} with open(dict_filename) as f: for line in f: word = line.strip() step = words.setdefault(len(word), {}) for char in sort_letters(word): step = step.setdefault(char, {}) anagrams = step.setdefault('anagrams', set()) anagrams.add(word) solution = set() current_len = len(letters) while current_len &gt; 0: for subset in combinations(letters, current_len): len_subset = len(subset) if len_subset in words: step = words[len_subset] for char in sort_letters(subset): if char not in step: break step = step[char] if 'anagrams' in step: solution.update(step['anagrams']) current_len -= 1 if solution: return solution if __name__ == "__main__": import sys print main(sys.argv[1], *sys.argv[2:]) ~~it gives more results than your example, did I miss something?~~ *ninjaedit!* 
In our Computer Vision class, half the assignments were written in Matlab with image-processing and half were in OpenCV. It's a very powerful library and is widely used. It's written in C++, but has Python bindings which are fairly usable once you've installed it.
Eh, I'm pretty content with [Pinboard](http://pinboard.in), the spiritual successor to Del.icio.us. It [has an API](http://pinboard.in/api/) that looks decent enough (on top of plain ol' import/export), and will continue to be developed and supported for some time.
Also 10.7.2, but my system default Python is only 2.7.0. You must have done something to your system to upgrade it? Also, why do you run `py` instead of `python`? Edit: Did some poking around. `/System/Library/Frameworks/Python.framework/Versions` is not the same as `/Library/Frameworks/Python.framework/Versions`. The `/System` one is 2.7.1 and has `dateutil`.
Maybe the version I have is because I've got XCode installed? `py` is just a bash alias for `python` because I'm lazy.
&gt; for s in f.readlines() for s in f:
https://gist.github.com/1441624 Bare-bones, yet elegant and sophisticated. The `collections.Counter` class is used to represent histograms of words (letter-frequency counts) and check if a word is a subset of the available letters.
So my initial post was just a quick thing I spit out. Here's a more thoughtful implementation that doesn't explode on a high number of tiles as well as also supports wildcards (pass them in as ?): https://gist.github.com/1441582 I forked off of sixthgear's base since he already did the work getting command line arguments and did the logic to find the longest results in the same way I would've.
Not as sussinct as others have posted, but simple and faster than I expected from itertools import combinations root = dict() def build_dict(f='ospd.txt'): with open(f) as src: for line in src: insert(line.strip()) def find_key(s): key = sorted(s) d = root for c in key: if c in d: d = d[c] else: d[c] = dict() d = d[c] return d def insert(s): d = find_key(s) if 'words' not in d: d['words'] = set() d['words'].add(s) def search(chars): l = len(chars) words = set() for x in xrange(1,l+1): for cmb in combinations(chars, x): d = find_key(cmb) if 'words' in d: words.update(d['words']) m = max(len(x) for x in words) return [w for w in words if len(w)==m] if __name__ == '__main__': import sys, os if os.path.exists(sys.argv[1]): build_dict(sys.argv[1]) else: print "Dictionary file not found: %s" % sys.argv[1] sys.exit() print sorted(search(sys.argv[2:]))
Using list comprehensions, built-in functions, and lambdas: l = filter(lambda x, y=sys.argv[2:]: all([l in y and x.count(l) &lt;= y.count(l) for l in x]), [word.strip() for word in open(sys.argv[1])]) max_len = len(max(l, key=len)) print [word for word in l if len(word) == max_len] Execution time: real 0m0.409s user 0m0.393s sys 0m0.016s Edit: Much faster execution using regex (also updated with useful user feedback): #!/usr/bin/env python import sys import re if __name__ == '__main__': letters = ''.join(sys.argv[2:]) pat = re.compile(r'^[%s]+\n' % (letters)) l = filter(lambda x, y=letters: all(x.count(l) &lt;= y.count(l) for l in x), [word.strip() for word in open(sys.argv[1]) if pat.match(word)]) max_len = len(max(l, key=len)) print [word for word in l if len(word) == max_len] Execution time: real 0m0.095s user 0m0.089s sys 0m0.007s Interesting note: I was playing with different regex patterns and noticed that using pat = re.compile(r'^[%s]+\n' % (letters)) was a lot faster than using: pat = re.compile(r'^[%s]+' % (letters)) The latter expression took nearly twice as long to evaluate.
Here's my solution: https://gist.github.com/1441776 It's simple, readable, reasonably efficient and doesn't use any "advanced" features that might obfuscate the algorithm. **Edit:** as expected, this code is still fast when run against a very large set of input letters. It is guaranteed become slower with a larger dictionary, though. I'm on Windows ATM so I don't have access to such a dictionary. Someone on a UNIX system might try running this against /usr/share/dict/words (or /usr/dict/words on some systems). Note to OP: you are a wonderful person. Please keep doing this quiz.
Sublime Text 2 is amazing, I've used Emacs and Vim before but I've come to prefer ST2 over them. I'm just as efficient on ST2 as I was on either Emacs or Vim.
I like the idea of keeping a tally of the longest, it allows you to get through the word list faster. My solution kept a dictionary of all results keyed by length. But also I copied the original letters each search and then removed a letter if I found it, this will make the searching in the letters faster each time. results = {} for word in words: length = len(word) ls = orig[:] result = "" for letter in word: if letter in ls: ls.remove(letter) result += letter else: break if result and len(result) == length: ls = results.setdefault(length, []) ls.append(result) lengths = results.keys() lengths.sort() if lengths: print results[lengths[-1]] 
Fascinating. I have checked in two OSX machines with three versions of Python each, and all find it in their own paths, &gt;&gt;&gt; sys.modules['dateutil'] &lt;module 'dateutil' from '/System/Library/Frameworks/Python.framework/Versions/2.6/Extras/lib/python/dateutil/__init__.py'&gt; I do have XCode installed, but I doubt it has bothered to add dateutil to all my Pythons (2.5, 2.6 and 2.7).
Hum, one week ?
Video tutorials and training videos are ok but, IMHO, the best way to do it is to find something to do, like a bigger project. Learning to program GUIs might be another option to polish your skills. Install wxpython and The Demo and just look around it. It has live coding so you can test things inside it. 
Interesting - so which part was done in Matlab that couldn't be done in OpenCV, I wonder?
[Here's mine](http://codepad.org/EAM9c2nd). It's... a touch slow, but it's not too bad. I'm definitely brute-forcing things though. At 71 lines, it's a lot longer than most of the ones here, but I do have some error checks and I use the argparse library.
`False not in [...]` is more succinctly spelled `all(...)`.
I've never constructed one of these for myself, but would a trie be useful for this? After adding every word per line into the trie you'd just find the longest path in it maybe?
No. I give out hot coins from the grill.
Take a look at the [Python 3 Wall of Shame](http://python3wos.appspot.com/) for a list of popular packages which need porting.
I came here to write this as a solution. I'm happy you did it already. =D I'm not sure if you should just iterate through the whole list of words instead of reading in the whole file, but Counter is the thing that really matters! If there were not limits of how many times a character is found, we could just use set() and if we'd be looking for exact number of characters, we could use sorted() instead of Counter!
Can you post the code?
&gt;Here is how the part of every application looks like that talks to other services: Bytes come in, unicode goes out. You can explain that. I'm wondering if this was a [deliberate reference](http://knowyourmeme.com/memes/bill-oreilly-you-cant-explain-that). Also: &gt;Why do I have a one megabyte regular expression in Jinja2? Because the Python regular expression engine is unable to match on unicode categories. And without that essential feature I am left with two choices: limit myself to ASCII identifiers and not support Python 3's new unicode identifiers or generate a huge regular expression with all the character definitions by hand. That doesn't seem right at all. \b, \B, \w, \W, \s and \S are locale- and Unicode-aware with the appropriate flag passed to `re.compile`, and I can hardly imagine what else you'd need to parse an identifier.
As an alternative, may I suggest PyQt. I feel it's got a much more polished API. But most of the core idioms carry over.
I second the "Python Cookbook".
Dateutil is incredibly powerful, and not just for parsing dates. It can effortlessly create recurring dates and set up seemingly complex filters for future dates. I created a task tracker for work for some reporting schedules using the `dateutil` module and I was pleasently surprised how easy it was. If anyone wants the code for that, they are more than welcome.
WingIDE? Man, I'd love a go with that or PyCharm but do you have any idea how the hell I would ask my girlfriend for a copy? Please write back, I'm genuinely interested in how one would accomplish this feat.
It's not yet complete; I still need to write a function to determine if the network has reached a stable equilibrium or not. At the moment it just continues computing until it hits an arbitrary time limit. But sure, why not. What's the preferred method of sharing? EDIT: Actually, maybe my supervisor/etc would not be so happy with my sharing the code, especially since the project is unfinished. But I'd be happy to discuss details...? Sorry!
PyCon ticket for travel, conference fee and accomodation. Worthy experience.
Depends on your contract. A lot of places where I've worked do not allow sharing of code at all. Considering this code might not even be *yours* to begin with. Go and ask, and read your contract, this is something you should know. Some places even go as far as to limit the kind of things you can work on in your spare time, and it seems you're pretty excited about this field so I assume you work on this kind of stuff in your spare time. It's pretty important to know your limitations.
&gt;&gt; I shudder to think how craptastic the job would have been were I working in C++ or similar. I love python (and c++) but I think you will regret that when switching to a 19x19 input space to train you network on real problems, in a manageable time. Python is awesome for coding fast, not that awesome to be run fast... I know you have to (like anybody trying ANN feel the urge to, but that's ok, this is the only way to understand really how it works ) re-implement MLP, there is some good NN implementation around : [fann](http://leenissen.dk/fann/wp/) is one of the most known, it has a python interface. I think google has plenty of other offers. Anyway have fun with your project ! 
 #!/usr/bin/python dictionary = 'ospd.txt' secret = 'chocolate' primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101] def get_val(word): return [j for j in [1] for i in word for j in [j * primes[ord(i.lower()) - ord('a')]]][-1] magic = get_val(secret) print sorted([word for word in open(dictionary) if magic % get_val(word.rstrip('\n')) == 0], key=lambda word: len(word))[-1] 
As a newcomer to Python web development, that have tried both python3 and python2, learned django and flask, I agree with this guy.
Instead of letters = letters[:pos] + letters[pos+1:] you could use letters.pop(pos) But I would probably go slightly other way, that is: for w in word: try: letters.remove(w) except ValueError: return False
Not on a contract, I'm just working with a professor at my uni. However I know he's keen to publish after we're done, so I'll need to respect that he might not want our code shared. It's my implementation, but uses a fair bit of his pseudocode, mostly in the learning rule. 
&gt; I can hardly imagine what else you'd need to parse an identifier. &lt;XID_Start&gt; and &lt;XID_Continue&gt;.
Agreed, but I'm starting on a 9x9 board, and reducing the input space from 81 down to 27 by taking statistical information over 3x3 segments that are grid-arranged in such a way that the individual information for any one board position could potentially be reconstructed from combining three adjacent segments. The learning from this input might converge slower than it could, but I hope that it'll result in a stronger end product, because it more closely parallels how a human looks at the board as a whole when planning strategy, rather than the simple square-by-square approach. I hadn't heard of fann. This is pretty cool, thanks heaps :). I certainly am having fun with it, probably more fun than any other programming project I've done. AI in general is pretty fascinating, most significantly the potential for NNs to *implicitly* learn categorizations. That's some pretty intelligent-appearing behaviour for a computer.
Nice - but the line: [j for j in [1] for i in word for j in [j * primes[ord(i.lower()) - ord('a')]]][-1] with j used twice seriously confused me. I take it that it's essentially just to give j an initial value before use in the inner loop? ie equivalent to: j=1 return [j for i in word for j in [j * primes[ord(i.lower()) - ord('a')]]][-1] Though I suppose if we're not *trying* to confuse, something like: return reduce(operator.mul, ( primes[ord(c) - ord('a')] for c in word.lower())) might be clearer. **[Edit]**: Also, you're not matching the problem description of printing **every** word that's the max length. I suggest: print list(next(itertools.groupby(sorted([word for word in open(dictionary) if magic % get_val(word.rstrip('\n')) == 0], key=len, reverse=True), key=len))[1]) 
Can't you shoot him an e-mail and see what the deal is with it?
I would and will, but it's nearly 10pm where I am. It'll have to wait till tomorrow.
Ahh, understood squire. Good evening and goodnight. o7
WingIDE's Code Completion, GUI Debugger(Set BreakPoint, Debug probe) really impressive, and the extend script(PyFlakes, PEP8) helps a lot too. I don't want install JRE and/or dotNET framework, so I only give PyCharm a shot as soon as I want to reinstall Operation System, It looks PyCharm needs a more powerful machine than WingIDE. Is there anything particular abnormal with WingIDE and I just missed? why it's a "feat" to use a IDE?
Here's a clean solution in just 7 lines of code: [http://pastebin.com/NstqW1mS](http://pastebin.com/NstqW1mS) I love brevity in code because it often yields simplicity. The gist of the idea in my solution is to test whether or not a word can be spelled entirely using a subset of legal letters. I was able to correctly test for this condition using Python's set.issubset method.
Hell yeah. I want to start doing hack days and this seems like a great entry point.
Haha, no, it'd be a 'feat' to convince my girlfriend to get it me for christmas!
Does python 3 support \P{Letter} or whatever the syntax was to select a sub-range of unicode, like Letters, Latin or Cyrillic ? It does not on my machine.
You also could be interested by this http://www.python.org/dev/peps/pep-0342/
Still, be prepared to wait for your network to warm a little when you train. This also depend on the size of your training set. Well, don't wanna cool too much you enthusiasm, but NNs have been around for a long time and from my experience they are often disappointing as soon as you get out toy experiments. (and a 30 years old literature is there to back me ..). It is especially to tune correctly the learning parameters and network topology. Anyway, they are just fun. You might also want to give a try to Reinforcement Learning, there are plenty of funky variants in the literature, best start is SARSA. There is some good application to board games (backgammon: an implementation is better than human world champion) and it is equally fun than NN. 
Though it saddens me to say it: amen.
Oh, by the way, my contribution to the list of things that would make porting easier: just support the u'' literal syntax in Python 3.3+. It would cost almost nothing as far as maintenance burden and would allow for a non-2to3-using-but-still-2-and-3-straddling codebase to use more of the same code without stupid runtime casting hacks.
Python is used in almost(?) all fields where general-purpose programming language can be used. That is, web applications, cli applications and daemons, applications with gui, "system" scripts. Beyond that, python's command line (or perhaps some enhanced version such as iPython) is very useful for doing simple operations on file system, doing quick calculations or testing code snippets.
having read Hiraku no go and being a fan of the game itself i am interested to see how this turns out. As far as i'm aware the overall ai implementation on go is rather more complex(maybe not complex just harder) than chess, even though the rules are potentially more simplistic. As i one of my friends once put it, it is harder to learn chess than to learn go but it is harder to master go than to master chess due to the nature of each turn and the possibilities represented.
Oh, I see. Spend more time with her is more important, buy a IDE or not is not that import, happy christmas~
I've been using python for about 7 years, do it for a living and I have no motivation for moving on to 3K. Some syntax changes are nice I'll admit, the packaging changes etc but if I'm being honest I just don't see the incentive. Changing the unicode thing was a mistake and I'm saying that even though I work with a minority language with strange symbols. I'd rather hit an encoding problem in development than on a client's server. Comparing the incentive of porting to 3K vs Pypy and makes me think that something needs to be done for 3K to survive.
I would call it "stable enough". Bottle is not 1.0 yet, but most of the planned changes are internal and do not affect the API very much. We add new features now and then, but only if they are very useful and at the same time add very little complexity to the framework. We manage backwards compatibility for one release and provide bugfixes for two releases (at least). As an example: 0.10 is backwards compatible to 0.9 but adds a lot of DeprecationWarning. You have a full release to fix these warnings and prepare for the next one. Bugfixes are backported to 0.9 and 0.8 and even earlier versions if someone provides a patch. Even the development version is stable most of the time. I never push to the repository without running all the tests. 
This post really resonated with me. I used to look forward to each new python release, learn what is inside, being giddy and all - nowadays it is just - meh a new python doing something that I don't make any use of.
My solution [http://paste.ubuntu.com/762637/](http://paste.ubuntu.com/762637/).
Combining clarity, briefly and optimization, this is what I would produce: import sys, re word_file = sys.argv[1] legal_letters = sys.argv[2] filter_pattern = re.compile("^[%s]+$" % legal_letters) candidate_words = [word.strip() for word in open(word_file) if filter_pattern.match(word)] def is_legal(word): for letter in legal_letters: word = word.replace(letter, '', 1) return word == '' legal_words = [word for word in candidate_words if is_legal(word)] max_length = len(max(legal_words, key=len)) longest_legal_words = [word for word in legal_words if len(word) == max_length] print longest_legal_words
 def valid_words(dictionary, valid_letters): input_length = len(valid_letters) valid_letter_set = set(valid_letters) bad_letters = set(letter for letter in string.ascii_letters if letter not in valid_letter_set) valid_counts = { letter: valid_letters.count(letter) for letter in valid_letter_set} for word in dictionary: if len(word) &gt; input_length: continue if any(letter in bad_letters for letter in word): continue if all(valid_counts[letter] == word.count(letter) for letter in valid_letter_set): yield word That's the speed optimized version. If you don't care about speed, just do: def valid_words(dictionary, valid_letters): valid_counts = { letter: valid_letters.count(letter) for letter in valid_letters} for word in dictionary: if { letter: word.count(letter) for letter in word} == valid_counts: yield word 
Python can do anything, like Mattho said. Now it is an interpreted language so if performance becomes a concern it might be not appropriate. Also if you want to redistribute a program, you have to ensure that the end user will have the interpreter (or distribute with it ala py2exe). And things becomes messy when you want to be closed source. I feel that python is really good for an introduction to programming since : the syntax is easy, you don't need that much boiler plate code (as in java for instance), and you don't need to compile as well. + with all the std lib goodness you can do really cool stuff (as in high level, not only printing prime numbers on stdout) in matter of minutes. + there are plenty of good tutorial for it on the internet ( just look on the right under Online books..., I do love Learn Python the hard way, but this is personnal)
10x. [this](http://pastebin.com/diff.php?i=rZv7UT6i) was fun :) !
&gt; For someone getting their first real taste of programming, which directions would it make most sense to take. Don't worry - it's not like a natural language where it will take years to learn. Whichever programming language you start with, you will learn concepts that transfer quickly to other languages. Most programmers end up being competent in 3 or 4 programming languages, and some in many more. The most important thing is that you start learning.
There's also [pyrasite](https://github.com/lmacken/pyrasite).
The overall impression I get from reading the changelog is basically "now we will have to code more to do less". Btw is it just me who particularly miss the print statement?
I was making a joke really. I'm quite happy with my IDE at the moment (PyScripter) and the only 'IDE' I want to use fully is emacs, but I think my brain is too small for it.
This always uses all the valid_letters instead of using a subset of them and hence is not an answer to the question.
So......by "multimethods" you mean "overloaded methods"?
That's partly because the language is so mature now, there's no obvious, low hanging fruit that's missing.
Generator expressions are faster than list comprehensions. p.s. s/briefly/brevity/
Wow, what an intellectual discourse we had. Ad hominem attacks and complete inability to express a coherent thought. No go back to sucking dick you retarded monkey. 
Thanks, updated.
Here's mine, in Python 3 fwiw: import sys filename = sys.argv[1] letters = sys.argv[2:] letters_set = set(letters) found = [] max_length = -1 for word in open(filename, "rt", encoding="ascii"): word = word.strip() if not set(word) &lt;= letters_set: continue letters_dup = list(letters) for letter in word: if letter not in letters_dup: break letters_dup.remove(letter) else: max_length = max(max_length, len(word)) found.append(word) print([x for x in found if len(x) == max_length]) It has a minor speed optimization: before doing the full check that the word is legal, check that all the letters of the word are in the allowable letters using sets. I do like the approach using sets where you append the count to the letter--very deft! And using Counter is a good idea too. Those are almost certainly faster than mine. *I,* however, snuck in for/else ;-)
Don't use the same codebase for 2.x and 3.x. That's what I was doing out of the gate, and I felt really clever about it too, but I realized *that* was more of a maintenance nightmare than maintaining two branches. Git makes that easy enough. I develop on the 3.x branch, pull changes to 2.x, and tweak the code where necessary.
&gt; I'd rather hit an encoding problem in development than on a client's server. Python 3 makes it less likely that you will find an encoding error on the client's computer. It forces you to think about encoding at programming time rather than just throw around byte strings and pretend that everything is ASCII.
The `print` statement? Is there something I don't use (easy to believe) that makes it superior to `print()`?
As your code bases diverge, git's merging will degrade.
[Generator Tricks for System Programmers](http://www.dabeaz.com/generators-uk/index.html) is a great presentation by David Beasley (a great Python developer) that covers using a feature of Python called generators to create command pipelines similar to those you would create with shell commands. This is an intermediate level topic but extremely powerful for log parsing and other traditionally shell-based scripting tasks.
If you know a bit of Python, the logical next step is to learn how to make something that resembles what an average person would consider a program. I would learn either wxPython (for desktop applications) or Django (for web applications) and build an application to do something useful.
Thanks! I found that. I actually used send() in this code.
Saves two characters, both of which require a shift?
The line that really resonates for me: &gt; Because as it stands, Python 3 is the XHTML of the programming language world. It's incompatible to what it tries to replace but does not offer much besides being more “correct”.
Whoa, cool. I've used WinPDB before, but I think I'll be using both these tools often.
That's utterly trivial to me, though I guess everyone is different. I was looking more for some possibly obscure but powerful feature.
or hs.spoj.pl, competition for high school students.
Here's my solution: https://gist.github.com/1443009 I think it's OK, I think it's fairly readable but might be optimized a bit more. I'm not thrilled about using copy.deepcopy(). For what it's worth, my original solution was object oriented. I kind of have this problem ever since I learned C++ and Java where I see objects everywhere (I totally hear that in the voice of the kid from the Sixth Sense). Also, for the sake of brevity here, I took out the usage/error handling that I had originally included. EDIT: one other thing, I changed my solution to just take two arguments, the dictionary file and the letters with no spaces between them. I didn't like how it was originally stated - it's easier to type them that way. 
glad you r happy with your IDE. my brain can only handle a very basic level of vim too
That's true, but hopefully this dual codebase situation is a temporary thing until python3.x is available everywhere, even if installed alongside 2.x for legacy code. Happy cake day.
Oh bad ass, thanks a lot man! I sometimes use regex or awk/sed in my Unix commands and a bit of perl so I have definitely piped out a lot of commands. Appreciated!
As a System Administrator really my coding skills are about automation and under-the-hood scripts that the end user never interacts with and it makes life easy for them. Though, I have been thinking about using APIs tied into our Inventory/management system with a web app to create some end user apps. Things like submit a ticket to help desk that generates a report of disk usage, users on this computer, up time, etc etc etc, and then emails the help desk, or the user can request a remote support session. Thanks for the suggestions. We are also an iOS developer and have about 1,000 iOS devices so I am sure down the road I will be creating something for them since iOS managed is not that flexible. Perhaps I can find some Python projects in that?
Some of the complaints are pretty specious. Python 3 made the choice that the default encoding would be platform specific, I don't think that was a wonderful choice - but the solution is _really_ simple. Don't use the default encoding. Using the Unicode api for accessing filenames and environment variables on platforms that don't have encodings for them (i.e. Linux) is the wrong way to do it. That isn't the fault of Python, that's a problem with the platform. Using the bytes api is the right thing to do and Python provides an api for this. The Unicode regex problem is genuine - but there is a fix for it. https://code.google.com/p/mrab-regex/ http://bugs.python.org/issue2636 The problem with bytes / Unicode is partly that Armin doesn't want to do the right thing (he wants to go back to a Python 2 string type) and partly that Python makes operations on text oriented byte protocols unnecessarily hard. Note that Java and .NET, both more widely used than Python, are more similar to Python 3 than Python 2 in this regard. Python 3 can, and probably should, add some bytes methods or a module to make those operations easier. Specific issues, or even specific suggestions, would be much more helpful than a rant.
So if things don't improve with porting things from 2 to 3, what should we expect to happen to the Pocoo projects? I have some projects coming up that I want to base on Flask and Jinja, but if things are going to stagnate or never get past Python 2, should I plan on using something else? I understand the post isn't an "I'm not using Py3K" rant, but I know if I'm unhappy with a project of mine, I hate working on it, and I don't want to do a complete rewrite, I'm not going to be interested in working on it for much longer.
That's handy for the REPL, but I use REPL hacks for that kind of thing anyway, and I've been typing print() since 2.6.
I think you meant http://code.google.com/p/mrab-regex-hg/ ?
Serious programmers don't guess and pretend (I guess), they always know what their code do. Besides if python 3 looks into system locale/env to "guess" the default encoding, that might not be precise and consistent on all supported platforms. Also the author's point in the link.
Just for reference: &gt; but the solution is really simple. Don't use the default encoding. I promise you that people will miss that just as much as they miss .decode() calls in 2.x &gt; Using the bytes api is the right thing to do and Python provides an api for this. Bytes are crippled to the point where it's nearly impossible to work with them.
&gt; So if things don't improve with porting things from 2 to 3, what should we expect to happen to the Pocoo projects? A slower migration. Basically not before we can drop 2.5 support in Flask/Werkzeug? It's hypothetical since right now. &gt; I understand the post isn't an "I'm not using Py3K" rant, but I know if I'm unhappy with a project of mine, I hate working on it, and I don't want to do a complete rewrite, I'm not going to be interested in working on it for much longer. I will have to maintain the 2.x version for a long, long time. Regarding 3.x support it's a tradeoff thing. If suddenly people would be really, really keen on 3.x support I might invest more time into it. But as it stands right now a port to 3.x would break 2.x code since I would have to change APIs. And I am not quite ready for that yet.
Ah, thanks.
Would you be willing to write up specifically which "text like" operations would be needed to make them not crippled (in your opinion)? (Noting that bytes already have the current "text like" methods - 'capitalize', 'center', 'count', 'decode', 'endswith', 'expandtabs', 'find', 'fromhex', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'. Certainly a good start if all you're working with is filenames.)
Pinboard looks very interesting, tank you for the link (before starting NoFussBM I found other Delicious replacement, but not Pinboard); w.r.t. my simple proof of concept for sure it has (a lot) more features and it is bound to stay. On the other hand, it's payware (albeit quite cheap I admint) and closed source, so if you want your very own solution (say a private installation), or to hack around it, you are pretty much out of luck… Of course, as a user, I will go for Pinboard without any doubt!
It's not ideal, and not especially nice or clever, it's just pragmatic to have the same codebase. What makes it *more* of a maintenance nightmare?
Strings are immutable :)
I just hope someone that "can" will listen.
Also ipython can do something like this with IPShellEmbed from within your code if you want to drop a shell somewhere instead of adding debug log entries or something.
lmao
You laugh, but as someone with some wrist pain issues, any characters that involve a stretch are not really a lot of fun to type. 
You should probably also leave out the square brackets - `all` can take a generator expression, and this will allow it to short circuit and stop at the first failed letter, rather than having to evaluate every letter to construct the list before it starts checking.
It's just tiring to read people slamming the `print` function when their major justification is that it's not a statement, that it's new, that it was changed "for no reason", etc. You didn't do that, so I apologize for the dickhead response, but character counts or shift usage aren't really a factor when bringing the `print` statement in line with the rest of the language. `print` as a function just fits so much more nicely, but maybe it just takes a while to get used to it. I've been writing Python 3 at my day job for almost two years now and it makes me wonder why `print` was ever a statement.
The biggest and major problem with Python 3 is that print need braces. There was a promise in Python about no chance for braces and it was broken. In Python 3 we have 4 additional key presses just to open and close the stupid braces. Guido fucked-up big time with this one. And I write a lot of print statements instead of debugging, that I later delete from the program. I guess many people do the same. 
Thanks!
how much of stdlib is happy to accept bytes? hash() seems like a thing I would happily use. Oh wait bytes are mutable. bummer
what sort of question is that? The code is larger, in places has twice as many lines, because of PY3 hacks, has to be tested using both interpreters before you can do anything. Sounds like effort to me.
Yeah it's a pain in the left pinky finger due to the heavy use of "a" and shift keys and "Ctrl+Z". Coding in python was less painful to me compared to C++, sadly this good deal is being taken away with python 3.
You can get rid of the length calculations etc and avoid having to filter the whole list for words of the right length every pass with itertools.groupby. Ie: words.sort(key=len, reverse=True) for wordlen, curwords in itertools.groupby(words, key=len): possible_words = [ word for (histogram, word) in ( (Counter(word), word) for word in curwords ) if all(histogram[letter] &lt;= letters[letter] for letter in histogram) ]
With that said, well, how about make it sys.out.print, pointing to an instance of python.io.PrintStream. Maybe we use it for some ten years and start to wonder why it was ever a builtin.
I do do the same. Let me guess if someone is ever going to down vote, he is either having problem with you saying "the biggest and major", or doesn't use print as often, otherwise he just enjoy verbose programming more like C++ or Java (feels more industrial). Anyway python 3 could have simply added a new function "printf" something, instead of messing up with print.
&gt; what sort of question is that? It's a question that's trying to elicit information. Running sloccount on the Django port I'm doing (which has the u()/b()/sys.exc_info() hacks that no-one likes, including me) gives me 134147 lines of Python, as against 132739 for the 2.x-only Django - an increase of around 1% in this case. So in terms of "larger", I'm not sure that's really a compelling argument for many projects. As for testing on both interpreters - is that really an issue if you want to reach both Python 2 and Python 3 users? Even using 2to3 to avoid hacks, you'd still need to run the tests on 2.x *and* 3.x, right? Sure, some specific discipline is required to run under a common codebase for 2.x and 3.x , but AFAICT it's not any more onerous than, say, following PEP 8. If you're new to it you might break stuff (that's what tests help you to get right, after all), but once you get into the right habits, it's doesn't seem to me to be especially hard. That's why I asked the question: it doesn't sound dumb to me, though it perhaps does to you. 
My take on this: https://gist.github.com/1444311#file_q1.py It is very similar to taybul's version, checking on what others have posted.
&gt;into a list, removing the spaces in between them? If possible, how would I read each line into its own string? You have two items on each line. Exactly how many strings do you want to generate per line of the input file? Exactly what do you want in each string?
Good point! Here's my fix: def valid_words(dictionary, valid_letters): input_length = len(valid_letters) valid_letter_set = set(valid_letters) bad_letters = set(letter for letter in string.ascii_letters if letter not in valid_letter_set) valid_counts = { letter: valid_letters.count(letter) for letter in valid_letter_set} for word in dictionary: if len(word) &gt; input_length: continue if any(letter in bad_letters for letter in word): continue if all(valid_counts[letter] &gt;= word.count(letter) for letter in valid_letter_set): yield word 
do you want it done symbolically or numerically? numerical is easy -- try something like this: def derivative(func, x, h): return (func(x+h) - func(x))/h derivative(lambda x: x**2, 5, 0.1) symbolically is a much trickier thing. but luckily there's [sympy](http://www.sympy.org).
The fact that `u''` was removed seems particularly puzzling to me. Python 3 kept support for `__future__` imports such as `with_statement`, even though they are now no-ops. That policy re: `__future__` has always seemed rather sane and well thought-out to me, creating a very easy way to ensure backwards-compatibility. I would have expected `u''` would be kept for similar reasons. It's not in the way of any new features, or preventing some wart in the grammar from being fixed. As far as I can tell, removing it did nothing but break backwards compatibility. Maybe if Py3 would just issue a `PendingDeprecationWarning` until Python 4000 :) --- edit: Aha, found it... GvR removed `u''` support via revisions [7d49038e99c9](http://hg.python.org/cpython/rev/7d49038e99c9) and [c8400096d2d7](http://hg.python.org/cpython/rev/c8400096d2d7). Hacking up my python 3.3 checkout to add back in the relevant code seems to work (and was only 6 lines of changes)... but I have no idea how to propose such a change, or to whom. --- edit2: for the fun of it, here's my [patch](https://gist.github.com/1452842) against py 3.3
Thanks
Well, first, do you want to evaluate them numerically or symbolically? If numerically, then it's simple: you don't write the formula in some special magical way to make it wait for you to supply the values. You get the values first, and then evaluate the formula. If symbolically, then you have a hell of a lot more work to do. You need to be a **lot** more specific about what you're trying to do, and show what you've already tried.
You're thinking of `bytearray` (mutable), not `bytes` (immutable): &gt;&gt;&gt; hash(b'hello') -1267296259 
 import sys words = dict.fromkeys(map(lambda s: s.strip(), open(sys.argv[1]).readlines())) letters = ''.join(sys.argv[2:]) is_valid = lambda word: all(word.count(ltr) &lt;= letters.count(ltr) for ltr in word) words = filter(is_valid, words) max_len = max(map(len, words)) words = filter(lambda s: len(s) == max_len, words) print ', '.join(sorted(words))
I'm gonna have to disagree with you on that. I think it's alarming that there's no call for language-level concurrency constructs, and that the awkward monkey-patching of `gevent` is seen as the greatest thing since sliced bread. Call me crazy, but implementing concurrency at the library level feels very ham-handed to me. That's the specific reason that I spend my nights researching Go and not Python 3. Language-level concurrency constructs would be a huge win.
Do it numerically. If you want to do it symbolically you are in a for a world of pain unless you use a nice library.
As some people have said, doing approximate derivatives numerically is pretty simple. To expand, you can make a higher order function that takes in a function and returns the function's approximate derivative as follows: def make_derivative(func,h): def derivative(x): return (func(x+h) - func(x))/h return derivative This returns a function that behaves like a derivative, and of course the smaller your h, the better your approximation. This is nice because you don't have to enter the function you are differentiating every time you compute a value of a given derivative. For example: def square(x): return x*x d_square = make_derivative(square,.0000001) &gt;&gt;&gt;d_square(1) 2.0000001010878066 &gt;&gt;&gt;d_square(2) 4.000000091153311 
What about if you want to distribute for OSX or Linux? Do you compile the program for them or do they get the source and run from that?
Every programming language in a sense can be used to do anything you think a computer could do. That being said, there a better languages for different tasks. Python is a good easy to pick up general language that can do most anything, however if you need speed you're going to want to use something else like C.
yeah I have no idea why this showed up on reddit and hacker news. maybe i'm not being computer sciency enough about this.
Without resorting to high-order terms, a better way to approximate f' is by using (f(x+h) - f(x-h))/2h. It has better convergence (error is O(h²)) than (f(x+h) - f(x))/h (error is O(h)).
&gt; There was a promise in Python about no chance for braces and it was broken. Uh, what the hell are you talking about? Python has made a point of not using curly braces for delimiting blocks. It has not made a point of avoiding parentheses by any means. Besides, it's not that print "need braces", it's that it's a function rather than a statement now. It being a statement to begin with was the horrible idea. For example, the bizarre syntax for suppressing a newline: print 'foo', or the syntax for writing to a file: print 'foo' &gt;&gt; bar Both of those are wholly inconsistent with all the other input/output functions. Not to mention, also being someone who uses print() as a first-line debugging tool, I often find myself testing decorators and whatnot with lambdas. print being a statement meant it could not be used (directly) in a lambda.
&gt;Im fairly new to python, and programing in general, so i had no idea there was a difference. ?! The difference is a mathematical one, not a programming one!
bytes aren't mutable (and are hashable). bytearrays are mutable.
Here's a guide, which do you need? Symbolic derivative: &gt;&gt;&gt; diff(sin(x), x) cos(x) Numeric Derivative: &gt;&gt;&gt; ndiff(sin(x), x, x=1) 0.54032 Numeric derivatives are easy to do since it's just numeric calculations. Symbolic derivatives require a lot more machinery ( term rewriting, expression parsers, etc...) and in Python that amounts to a lot of code. People have done it ( google Sympy or Sage ) but its a lot of work. If you have your heart set on symbolic calculations you might want to look at a language like [Haskell](http://conal.net/blog/posts/beautiful-differentiation) or [Pure](http://code.google.com/p/pure-lang/source/browse/pure/examples/symbolic.pure) which can do this sort of thing in a surprisingly little amount of code.
&gt; What is POSIX you are asking? I have no freaking idea. Seriously? Edit: I'm retarded.
[sympy](http://docs.sympy.org/0.7.1/tutorial.html#differential-equations) makes this very easy to do
So far, this has been the most helpful one. Now all i have to do is find a way to make h irrelevant.
That makes all of no sense to me. Making `print` a builtin makes it more in line with the rest of the language (as briancurtin correctly put it). In what way would `python.io.PrintStream` make it more in line with the rest of the language?
Even with an open-source project, I have to pay for hosting, so the ~$7 I paid for a lifetime account was well worth it. I can make bookmarks private, so no worries on that front. And I can write any frontend or UI I really want using the API - basically using their service as a database. So, even as an open-source hacker, I'm not terribly concerned.
 #!/usr/bin/python import sys words=[w.strip() for w in open(sys.argv[1], 'r').readlines() if len(w) &gt;=5 and set(w.strip()).issubset(set(sys.argv[2])) and False not in [w.strip().count(c) &lt;= sys.argv[2].count(c) for c in set(sys.argv[2])]] words.sort(key=lambda x: len(x), reverse=True) print ", ".join(words) Not my most readable python ever, but fun!
Indeed. Also, the few times I had to battle against encodings in Py2 were pretty painful. From what he describes, Py3 is even worse in that respect. Not looking like a good choice. Let's just keep ignoring Py3, it will go away just like XHTML :)
Why not use the debugger? Pdb is perfectly capable of handling such things.
Ignore Py3 and use PyPy?
&gt; The biggest and major problem with Python 3 is that print need braces. This is a total non-issue for anyone who has actually used it for any duration. No one I've ever talked to who moved to Python 3 has had an issue with this - only people who don't want to give up Python 2 seem to have issues with this. Also, it is perhaps the most trivial of all changes, and conversion is easily automated, so it really can't be *that* much of an issue. Key-strokes aside, what else is wrong with `print`-as-a-function? &gt; There was a promise in Python about no chance for braces and it was broken. That promise has yet to be broken. You are confusing parentheses with braces - there is a huge difference. Try `from __future__ import braces` some day. If you still haven't figured it out, { and } are braces. ( and ) are parentheses. &gt; And I write a lot of print statements instead of debugging, that I later delete from the program. I guess many people do the same. I don't know anyone who does this.
 #!/usr/bin/python from sys import argv words=[w.strip() for w in open(argv[1], 'r').readlines() if set(w.strip()).issubset(set(argv[2])) and False not in [w.strip().count(c) &lt;= argv[2].count(c) for c in set(argv[2])]] words.sort(key=lambda x: len(x), reverse=True) print ", ".join(w for w in words if len(words) != 0 and len(w) ==len(words[0])) I guess my previous post didn't make it, ahh well.
My understanding is that "multi" methods work on the runtime type, and "overloaded" methods work on the compile-time type. This distinction is obviously meaningless for languages like Python. But consider Java, which supports method overloading but not multimethods. abstract class A { } class B extends A { } public class Driver { public void spam(A a) { System.out.println("One."); } public void spam(B b) { System.out.println("Two."); } public void eggs(int x) { System.out.println("Dead."); } public void eggs(double x) { System.out.println("Parrot."); } public static void main(String[] args) { B realB = new B(); A sortOfB = new B(); spam(realB); //Two spam(sortOfB); //One--Java does not support multimethods. Compiler thinks it's an A and uses that method. eggs(1); //Dead eggs(1.0); //Parrot--Java supports overloading. Compiler can tell it's a double. } }
&gt; Using the Unicode api for accessing filenames and environment variables on platforms that don't have encodings for them (i.e. Linux) is the wrong way to do it. I'm puzzled by this. If I want to make a program that performs `os.listdir()` on a folder and print the result under Linux, what am I supposed to do, use the bytes API and convert it "manually"? If I can do that, why can't Python do it out of the box?
&gt; Don't use the same codebase for 2.x and 3.x. I barely did anything to make a 25k line project at work 2.6-3.1 compatible in the same codebase, including a C extension. It was mostly `try/except` import dances if I remember correctly on the pure Python end, and simple `#ifdef`s in the extension. I actually gave up on 2.6/2.7 usage of it for ~6 months, then tried it one day and it took one or two small changes to get the 2.x support back. 25k isn't very big compared to a lot of things, but it wouldn't have been much harder if the same app was 100k lines. If you can do a single codebase *without* needing super clever tricks, which you can avoid by bringing your lowest support version up as high as possible, I highly suggest you do so. It is by far the easiest way to manage the port.
Well if you want to evaluate the derivative of any given function numerically, you will be approximating the derivativeyou are going to have to use some value of h,. You can use more accurate methods, as caks pointed out, or use extrapolation to reduce your error, but if you wish to numerically evaluate the derivative for an arbitrary function, there is going to be some error depending on your step size h. If you know you are only going to be differentiating polynomials, you can create function that does not depend on h because polynomials have a straight forward differentiation pattern. You can simply look at the polynomial coefficients and corresponding degrees to create a new polynomial that is the derivative of your input polynomial. Let me know if you want more clarification on this part, but it might not be what you are looking for.
&gt; It has not made a point of avoiding parentheses by any means. And if you're looking for that, try out Ruby.
You can't make h "irrelevant" if you're doing numeric derivatives with a finite precision. The value you're going to get is always an approximation, but you can quantify the error and propagate it if needed.
I generally hear that vim is a good text editor for people with wrist pain, though you may need to remap the &lt;ESC&gt; key to something easier to reach.
This is what i meant. To get it so small it doesn't matter.
Usually *nix users just get the source because they have Python interpreters already (and in a sane location, etc.). This really only changes if you're trying to hide the source.
This guy wrote Flask.
Could start by posting what you have.
You can do something like: def add(a,b): return a + b ops_list = [add, ] print ops_list[0](1, 2) # prints 3 You can also do things like: def apply_operator(a, b, op): return op(a, b) print apply_operator(1, 2, add) # also prints 3 That is, you can pass functions around like any variable. So you'll just need to use similar kind of mechanism that you used to get all the permutations of numbers so that you try the various operations with the numbers. 
Well the value of h will always "matter", since its an approximation. Think about it this way, the exact numeric value of the derivative of f(x)=sin(x) at x=1 is cos(1)=0.540302306 which is a infinite transcendental number. But if you're calculating numerically you're only ever doing: f'(1) = (sin(1+h) - sin(1))/h If h = 0.01 then f'(1) = 0.536086 If h = 0.001 then f'(1) = 0.539881 .... If h = 0.0000000001 f'(1) = 0.540302 The numeric derivative keeps getting closer to the exact value but on a computer you'll never be able to get the exact value of cos(1) because you can't take limits when working with finite precision numbers. The minimum value of h is a small but quite finite number like the 64-bit machine epsilon [1.11*10^-16](http://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics) Does that help?
I can't upvote you enough. When dude said : &gt;I had the situation that when I logged into my remote server the locale was set to the string “POSIX”. What is “POSIX” you are asking? I have no freaking idea. But the end result of that was that Python was about as clueless as me and decided to go with “ANSI_X3.4_1968”. This also marked the day that I learned that ASCII goes by many names. I almost stopped reading right there. If he learned about ascii encoding by using Python 3 then I'd argue that Python 2 was holding him back about not knowing the difference. Also if you think reading environment variables are bad then I'd argue your platform sucks. 
This. Sympy is increadibly easy to use.
Python code should run identically on all platforms. Python has a pretty useful os module for interacting with operating systems that adjusts itself based on whatever os you're running on. This includes Windows, OSX, Linux, and even Android(which is technically a portable version of Linux).
This is what I have so far, Which is good enough for what im trying to do right now. This is just what MarshingMyMellow did, I just added the inputs. Thanks for the help everyone. print("equation is x**n") p=int(input("What is n?")) def make_derivative(func,h): def derivative(x): return (func(x+h) - func(x))/h return derivative def Func(x): return x**p d_Func = make_derivative(Func,.00000001) x=int(input("What is the value of x?")) answer=d_Func(x) answer=answer//1 print(answer)
I just edited my post to include the code. Thanks!
Did you actually read that section? He was talking about the *locale* on his machine being set to "POSIX". Can you really say you understand what a "POSIX" locale could possibly be?
He's obviously talking about POSIX as the locale, which in the other conversations I've seen on this, no one else knew what that'd produce either.
But do you compile it, in a similar fashion to a .exe (or I imagine .py), or do you install the whole source tree?
We've all been right here all along. It just takes some communication which has just now occurred.
if you know you will always be differentiating `x**n`, you know that your answer is going to be `n*x**(n-1)`, so why not just code that?
This was just a jumping off point. I'm already working on functions involving sin and cos, and i think it wouldnt work for the way I'm doing it those, which is by using taylor and Maclauren series.
I like the use of regular expressions to filter out non-candidates, but when you use {4,16} you won't catch 1, 2 or 3 letter words. Also, 16 is too high - len(letter_list) is sufficient since you can't make any words longer than that.
Not as well as I had thought. I was debugging some code while skimming it, absolutely my bad.
You're right - I did not read the question correctly. Thanks for the correction. I originally had reduce, but then I read that it was unpythonic - and in the interest of trying new stuff, I experimented with the generator expression that you see above. I also thought, at the time, that the 'reduce' was more elegant (and readable).
I moved to Python 2.6 in 2011, as it is the default stable/robust version in many systems, including Linux and Mac OS X. I love the language, everything works as it should (and on several platforms), coding is a pleasure, and there is no thought whatsoever about moving to Python 3.x. By all means, the 2.x line should be continued and maintained. It is a bit sad to mention, but this situation reminds me about the migration Microsoft triggered from Visual Basic 6 to VB .NET, that was simply a different language: in my case the code was never rewritten/ported as there was no advantage in doing so. The decision was then made to use an open source language, Python, with the expectation that the code was going to be able to run with no issues for the next 10 or 15 years, just like plain vanilla C. I still expect and trust that that will be the case.
Think of it this way. You started off by getting every possible order of the numbers (which, for 4 numbers is 4! =24 orders). For any given calculation, you need three mathematical operations to combine the four numbers, and they can be any combination of the four, so it could be.. + + + + + - + + x + + / + - + + - - etc.. So you need a way of determining all the possible sets of math operators. (EDIT: fixed auto bulleting)
So, an expression like `22 * 71 - 13 + 1` would be one of the combinations?
Exactly. You can have any of the 4 operations at any given point, but I have to use all numbers once. I can't use just a couple of them.
1 + 1 is actually broken down into a function similar to **add(a, b)**. 2 * 3 / 7 would end up like **div(mul(2, 3), 7)**. Math side of this problem is that you have 9 variables (as the ordering of the numbers isn't static). num1 op1 num2 op2 num3 op4 num4 The really cool thing about functions in python, are that they can be put in lists really easily, as they are [values not magic constructs](http://www.penzilla.net/tutorials/python/functions/). So you could make a list of functions with two parameters, that perform the specified operation. # A simple example of calling a value that's a function. def op(a, b): return a + b f = op print f(2, 3) #More significant in your case: Having a list of operators to call at will. ops = [op] print ops[0](2, 4) Also, you could use the build in add/mul/etc functions in the operator module: http://docs.python.org/library/operator.html
Neural net training is mostly matrix multiplication, so I hope you're using numpy and a BLAS package instead of writing nested loops. You should look at http://deeplearning.net/tutorial/ for an intro and sample code to do MLP (and DBN) training using Theano, a package that compiles Python code to CUDA GPUs. It will be several orders of magnitude faster.
I was aware of the complexity issue, but I decided that permutations would actually be faster given the context. It's a scrabble game; the dictionary is going to be preloaded at the beginning, once. Most queries will contain 7 letters; the search space of the permutations is 5913 combinations. If the dictionary has more words than that, scanning the dictionary might be slower than scanning the permutations. That was my thought process anyway. Of course, that doesn't mean my *implementation* of that idea would be fast in the least.
If you don't want to muck with the parse tree, look at Theano. It does autodifferentiation by requiring you to declare variables as its objects. The the operators are overloaded, and the result of 'A + B' is an object, building a tree of operations. These have methods to compute symbolic derivatives. There's also a package called sympy.
Typically, you'd just send out the source code, which is all a .py is, and expect the user to install Python for themselves. If you don't expect your audience to have Python(OSX and many Linux installations have Python installed by default), then you can compile it to an .exe with py2exe, but that version will only work on Windows.
that's a really cool way of referring to the math functions -- as list items
We can make this a bit more pythonic for you, as your code is hard to read and won't expand well. Firstly, don't use global variables. Try and use classes instead. I have written a little scaffolding for you to start off with. I have written a working version of the magic in the middle, but I don't want to do your homework for you because I think it won't help you learn. Let me know if you get stuck and we can work from there. class solver: def __init__(self,numList=[]): self.numList = numList self.solSpace = [] def solve(self,sol='', n=0): ""MAKE YOUR MAGIC HERE"" self.solve(sol,n+1) test = solver([22,71,13,1]) test.solve() print test.solSpace Lastly the problem is a bit under defined, specifically if all permutations of the number list are to be used or how to address order of operations.
Alternatively, you could use functools (part of the standard library) to do the same thing. For example you could define: def derivative(func, h, x): return (func(x+h) - func(x))/h And then use functools.partial to get more specific: f = lambda x: x**2 # or more generally ``def f(x):`` df = functools.partial(derivative, f, 0.1) Now, df can be called with df(x). The advantage is that you can alternatively define df = functools.partial(derivative, f) which then takes both x and h as arguments. 
My solution from earlier today (when reddit was down), before I looked at any other solutions: https://gist.github.com/1444495 It looks like consensus is using permutations was a bad idea, but you can't deny how simple it is :)
If you use Visual Studio, you need this.
Lol, that's what makes this class so frustrating at times. He doesn't really explain his assignments or how to do them very thoroughly. I spoke with him earlier today and I am supposed to use every permutation of the list that involves all numbers contained in that list, and I'm supposed to be able to pick any operation at any point, so the amount of results I'm guessing will be quite high if I put more than 4 or 5 numbers in the list. The professor never gave me any information on how the order of operations are supposed to be handled. 
It's "making commonly used routines fast/short" we're suggesting. You could use sys.stdout.write and append a line end when you need a function to wrap in lambdas. But you wouldn't like it because it requires too much typing. Now "print(x)" compared to "print x" is the same too much typing to people who makes heavy use of print. All in all, print function could have been added instead of replaced. Digging into python source code will reveal there are several print related opcodes in 2.x. Guess these are the incentive 3.x tries to eliminate print. 3.x went so far as to break unnecessarily too much in the name of "while we break". I recall it even took away callable() at first, then people started suggesting "if hasattr(obj,'__call__')" instead..
I really appreciate the help. My prof. has not done a great job of teaching us this semester (we only started python about 5 weeks ago) so I'm reading up on classes right now to try and follow what you have wrote. Is the n variable there to do a loop of some sort?
Nice find!
You would propose it on the [python-ideas](http://mail.python.org/mailman/listinfo/python-ideas) mailing list.
I imagine that operations are not so restricted, and that you could, for instance, have one combination of '1 * 13 * 22 * 71'. If this is true, the following ugly-assed hack might be of use: from itertools import permutations from itertools import product ops = ('+', '-', '/', '*') nums = ('1', '13', '22', '71') numbers = permutations(nums, r=4) operations = product(ops, repeat=3) for group in numbers: for operation in operations: expression = '' # That's two single quotes; an empty string for index, number in enumerate(group): expression += number try: expression += operation[index] except IndexError: pass print(expression) print(eval(expression)) Of course, instead of printing the evaluated expression, I'd add it to a set and print a sorted version of that set to solve. I'm not positive that this is correct, but it seems proper. Did I say that it was ugly? And it ain't recursive, but it might help.
Newbie here. I am a little confused what is going on in the last bit of code. Could someone explain it to me? for r in find_words(sys.argv[1], str.join('', sys.argv[2:])): print (r)
I just shopped it in python-dev, FWIW.
Yeah, I'm not sure how to give you more clues without giving away the whole problem. Here is the code expanded to do all permutations, with other bits removed. I also can't figure out how to leave in the code comments without giving away the answer, so I removed them. If you need more help just ask. class solver: def __init__(self,numList=None): if numList==None: numList=[] self.numList = numList self.solSpace = [] def solve(self,sol='', n=0): if n ==0: self.solve(str(self.numList[0]),n+1) elif n==len(self.numList): self.solSpace.append(eval(sol)) else: """This is the Magic Part""" sol = """Change this""" self.solve(sol,n+1) def all_perms(myList): """Make all perumtatuons of the list here""" if __name__ == '__main__': all_possible = [] for i in all_perms([22,71,13,1]): test = solver(i) test.solve() all_possible.extend(test.solSpace) all_possible.sort() print all_possible 
I really don't understand the up votes. I live in asia where shift-jis, euc-jp, euc-kr, gbk, big5 encodings are common besides utf-8 and utf-16. Python 2 doesn't enforce me to think about encoding, nor does it prohibit me from doing that. It just comes in handy and keep itself out of my way. In fact I think about encoding all the time, and I agree with pocoo.org guy's idea that estr utility (str with encoding) has real needs.
Or, for a one-liner, this will give a dict: dict(l.split() for l in open(filename)) I love the fact that file objects can now be iterated over. And generator expressions are &lt;3.
Absolutely. Once I learned the glory and power of the standard logging module, I haven't used print() as a debugger since.
Firstly, your code as it is now can be made much simpler: - That `n` variable is not doing anything useful, it's always equal to the length of `list1` plus one -- there's no reason to track it separately. - Using 0-based indexing is much easier, and will eliminate all of those `-1` terms. - Your `not in` check makes this fail if some of the numbers in `listp` repeat. - If `pop` automatically pops from the end if you don't give an argument. - You can use the `enumerate()` function to get the values and their positions in a list. This can be written as: def main(): global list1, listp for k,x in enumerate(list1): listp.append(x) del list1[k] main() list1.insert(k, x) listp.pop() But I would strongly like to convince you not to use global variables. It's not pythonic, and it won't serve you well in the future. Ideally your function should take a parameter and return a list of all the resulting permutations. (And it would be good if it had a meaningful name and not `main`.) You can still do this recursively, however: def permute(list): thisperm = [] allperm = [] def worker(curlist): for k,x in enumerate(curlist): thisperm.append(x) allperm.append(thisperm[:]) worker(curlist[:k] + curlist[k+1:]) thisperm.pop() worker(list) return allperm result = permute([22,71,13,1]) print "\n".join(repr(x) for x in result) The difference here is that everything that `permute` needs to do its job is kept locally, hidden from other functions. To the outside world, it's a function that is passed a list and returns all permutations of that list of any length. No more global state. As to the operations, if you have a list of `n` numbers, then there's space for `n - 1` operators, so you can just treat that as if you are told to find all combinations with repetition of length `n - 1` of the set +, -, \*, /. Then it's only a matter of combining them and evaluating them. Finally, I'd like to point out that the `itertools` module provides built-in combination and permutation functions. Using those I was able to solve this in about 22 lines total, including the part where multiple equations that produce the same value are coalesced. I don't know if you're allowed to use modules, but if so I would definitely look into it. It's probably not ethical for me to post my solution but if you want to see if after you've turned in yours, then just ping me later. 
If you want to distribute to OSX you use py2app. And anytime anyone distributes binaries for linux, a kitten goes to bed hungry.
&gt;however if you need speed you're going to want to use something else like C This is one of those things that is completely correct, but heads people in the wrong direction. Who doesn't want speed? We all want speed! I, new person who has never programmed before in my life, will throw away this slow and dumb python and get me all up on some of this fast C!! If and when the poster needs the kind of speed you mean, it is going to be a long time, a lot of algo theory, and a few languages from now. And the odds are high they will never need it. They might need to use well written libraries that took this thinking into account, like Twisted or Numpy, etc, etc, but the odds they are going to have to write tuned C code themselves are actually pretty friggin thin. Unless of course, they enjoy it or want to write kernel or embedded stuff. Again, a long time from now. Love me some C, and completely agree with your statement, but I think without qualification it's the kinda thing that leads new people off into some deep weeds that don't contain a lot of the ducks they are hunting.
This line is the equivalent to the following, just with less temporary variables: word_file = sys.argv[1] # grabs the first argument passed to the command line letters = str.join('', sys.argv[2:]) # grabs the rest of the arguments and mashes them into a string results = find_words(word_file, letters) # does the real work for r in results: print r # print each result on a line
What I would do is start by making a series of functions that can generate this by permutations not of the input list but of the operators. You should probably brainstorm or otherwise write down, on paper, all the possible ways you can combine the abstract unique integers a,b,c,d. You need to come up with a way to make sure that however you define this is un-ambiguous. Can you use ()? How does order of operations work? I would try to get your professor to generate this list in front of you for 3 numbers (5,2,1) and ask him how he expects order of operations to work from this example. I suspect what you will end up with is the "every possible order" thing that ckaili, suggested, plus some more data. One thing I would strongly recommend is to use a set of some kind to process the data. A set will automatically remove duplicates of the numbers you find FOR you, which is really awesome. I also agree with the previous posters that you want to have a function that does it and returns the resulting list. For example, I would have a structure similar to def potential_numbers(list_of_numbers): potentials=set() #compute all potentials on the list and insert them with potentials.add() return sorted(potentials) 
nice!
Oddly, I've been programming for some time now (scientific data analysis) and was wondering the same thing. I heard a lot of good things about NumPy so spent some time learning it, but I feel it's stuck between R and C/Fortran - for most analysis applications, not fast enough for me to sacrifice the terseness of R and verbose enough to make it wonder why I'm not proramming in Fortran in the first place... I've been told it's good if I ever want to connect my analysis to a web framework or GUI (admittedly, Python GUI-building has been useful), it's a good language. So maybe that's where it fits in, I've decided - while not a dedicated for a particular task, it's good for building a prototype system that combines a lot of things - in my case, that would be a shell commands, text processing, data analysis, and possibly GUI/web for the user interaction. And, in most cases, that prototype is good enough to serve production purposes... until it isn't.
I dunno, pypy is daaamn fast. Well tuned pypy code can give C a run for it's money (as can most advanced JIT VMs).
Dug up from 4 years ago, wow http://www.reddit.com/r/programming/comments/1iihk/guido_shows_how_to_do_multimethods_multiple/
ya,based on the question, I assumed he is kind of new to python, if not programming. So I made it clear enough for him to get an idea.
 funcs = [ lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y, ] funcs[0](1, 2) # 3 funcs[3](10, 2) # 5 give you any ideas?
no shit? :)
Do you have an example input-output for this problem? I have a solution I would like to test.
It looks like the best bet would be to learn HTML5 and some JS maybe. You could create some sort of web app that would be available for the iOS devices as well. Look into stuff like [Cappuccino](http://cappuccino.org/) 
PyPy has stackless, which has channels like Go. I'm anxious for PyPy to become widely adopted (and, ironically... to support Python 3)
Seems like the obvious choice for Quiz 2 is "quiz 1, but by the way the word list is in utf-8". Most of the solutions given will need changes :-)
Yeah, pypy has been doing some good stuff, and java can, in certain cases, run with C pretty well. No argument at all and I am hoping pypy keeps going great guns. Although I don't see either embedded or kernel development changing over to those options as a primary toolset anytime soon :)
Yeah this is what I meant, I took that for granted.
Yeah - I know it's moved from builtins in python3, and reduce *can* sometimes end up fairly ugly, but I think it's certainly clearer here at least. You could maybe go with an extra function if we want to make it a bit more readable at the point of call, which seems a good use of partial functions. Ie: import functools, operator product = functools.partial(functools.reduce, operator.mul) ... return product(primes[ord(c) - ord('a')] for c in word.lower()) 
Python tries to do it out of the box, but Linux is a Wild West and Python can't guarantee that it will work. Then people complain about that.
Print statement was awful. The print function is awesome. People who don't like parens are just lazy. Try doing `print(*list_of_strings)` using the print statement.
Environment variables are unreliable, simple as that.
[Here's a start](https://gist.github.com/1446540). It doesn't consider order of operations and it uses integer-truncating division, which you might want to avoid by using a rational number class and filtering the results for integers. 
How would that help?
But we are talking about years here, not months.
&gt; but the solution is really simple. Don't use the default encoding. His argument is not that it is hard to work around it, but the fact that it is *not* default and hence not "documented".
You can make the check_word function shorter/easier to read [like that](http://pastebin.com/AzjWZfji). Edit: also, probably better to use the with statement to open the file so it gets closed again when you are done.
Some points: * words = [line for line in open(filename)] is just list(open(filename)) * Unsanitized user input used in regular expression. I can make the program crash that way. * w[:len(w)-1] is just w[:-1] * your regex would reuse a certain letter, for example, the world "hello" would be matche with the letters h,e,l,o (but you would need to "l").
Sorry, but changing the letters to append an index to the string is definitely not clean. Even disregarding that (you could use tuples instead), it is not an easy solution. Definitely requires a bit more thinking on the reader's side than a straightforward solution, that might be a bit longer (e.g. see top post in this thread). Also, f.read().splitlines() is just list(f). Or better yet, iterate with "for word in f" to reduce memory usage.
Also note that f.readlines() returns a list (memory inefficient if you just want to iterate it) while f.xreadlines and f itself (iter(f)) are generators.
I understand that learning the basics of python will set me up well for other programming languages, while maybe having a more gradual learning curve, or if not, maybe seem that way anyway.
This reminds me P(HP/erl) 6. PHP 6 was dropped b/c Unicode was hard and I can't see Perl 6 on any of my machines. Python 3.x on the other hand is here and I think it is a good thing. Sooner the issues are cleared quicker adoption will be.
He is not iterating over the dict twice. He is iterating it once and making a lookup everytime (a lookup is efficient). &gt; myobj = [n for n in obj_dict.values() if n.x == 1] This copies all values and wastes much memory. Use this instead (if the dict based representation should be used): myobj = [n for key, n in obj_dict.iteritems() if n.x == 1] This does not make a copy of all values in the dict. 
This is true. I would recommend Python as an entry-point for almost everyone (unless they're doing extensive number-crunching exclusively). 
And I had similar experience with porting simplejson using a single codebase - of academic interest only, since Python has the json module. It helped establish that Python 3's json module is (by and large) as speedy as simplejson.
Ignoring what's not understood is almost always a bad idea. Mitsuhiko came to his conclusions from dealing with Python 3 in theory and praxis. We all should do this before labeling Python 3 a bad idea.
Ah, I missed the str.join when passing the arguments and thought it's a list of strings (chars).
Most of what's helpful has been said, but you could take a look at itertools.permutations or, if I'm misreading the slightly vague description, itertools.combinations. Might make your life easier. For what it's worth, I feel for you. Ambiguous preconditions and incompetent instructors make sad coders :( 
AFAIK, any sane Linux from at least the last few years should default to utf-8, which Python should handle fine. For the corner cases which are using something else, Python's effort is probably as good or better than most of the Python 2 code written to handle that.
FWIW, I went the other way round working on the Python 3 port of IPython. Initially, it was a separate codebase, with changes merged across. Now, it's merged in to a single codebase (using 2to3). It's certainly possible to maintain two codebases, so long as you've got a good DVCS to handle it. But I've definitely found it easier with a common codebase, because I don't have to spend the extra time copying and re-committing changes.
Though I am not the OP this statement reassured me. Thanks for the words of wisdom..
that's largely because of the memory and startup overhead of a JIT :) also that carefully hand-tuned code can outperform a JIT when compiled for the exact platform it's meant for and such.
You might consider a chunks system, like minecraft uses. dictionaries aren't really designed for such things, I only provided this as an example because use of a dictionary was a requirement to begin with.
&gt; I really don't understand the up votes. I live in asia where shift-jis, euc-jp, euc-kr, gbk, big5 encodings are common besides utf-8 and utf-16. So what? Python 3.0 makes it trivial (in fact automatic) for you to be able to compare a gbk string to a shift-jis string. It helps. &gt; Python 2 doesn't enforce me to think about encoding, nor does it prohibit me from doing that. EstebanVelour complained about finding encoding problems after deployment. Python 3 does force you (or strongly encourage you) to think about encoding and that reduces delayed encoding time bombs. &gt; It just comes in handy and keep itself out of my way. In fact I think about encoding all the time, and I agree with pocoo.org guy's idea that estr utility (str with encoding) has real needs. I have no problem with that proposal. It doesn't invalidate Python 3's strategy of separating character strings from byte strings though. 
My point isn't really "Why can't Python do it?", but rather "Why are you saying that unicode API shouldn't be used on Linux?" and also "What's the benefit of using the byte API under Linux if it implies doing something myself that Python could do?", and also "What Python doesn't do currently in its unicode filesystem API under Linux that I could do myself by using the bytes API?".
We get this all the time in hobbyist game development. "You need to use C++ for performance." "But I'm writing a simple 2D game." "But what if it's too slow?" "Oh, ok. I guess if it's too slow, we can't play it. C++ it is then." The spectre of performance looms large over people who write Pacman while dreaming about Modern Warfare 3. So instead of actually getting their games done, they end up posting on forums wondering why changing one char* string ended up changing their earlier copy of that char* string, or having to spend a week writing their own OpenGL wrapper just to get an alpha-blended sprite on the screen.
&gt;Key-strokes aside, No! The key strokes are the issue here! If I needed a language where I have to type more and have less I would work with Java. It doesn't matter if it braces parentheses or brackets. it is useless. If you need a print function make you self a print function. Don't fuck with the print statement. There was a language that didn't have statements. It is was called Lisp. Edit: fixed useless English grammar. 
Too slow. No editor support.
Wasn't that for the paid version of Visual Studio? 
What is chuffed? Is it good or bad? 
You know what I mean. A *lot* of people work on Windows and a lot of them use a slew of other tools. PTVS is damn near a perfect drop into the Visual Studio environment. I do a lot of C and C++ at work through VS and started using PTVS a few months ago and haven't looked back.
The default is not the default and the documented default is not "documented"? He just wants the default to be different. I can appreciate that (I would prefer a fixed utf-8 default over a platform dependent one too), but I don't think it's a huge deal given how easy it is to specify the encoding.
You can use the Unicode api, which gets you strings decoded from the filesystem using the surrogateescape handler for undecodable names. To display to the user you either encode with an appropriate escape handler or display the repr. There are many different use cases (for example to get the original bytes back use os.fsencode), so Python doesn't guess what your use case might be.
Well, it can be used. You just need to understand what it is doing. It uses the surrogatescape handler for undecodable bytes (which is what Armin ran into) - so either use the bytes api or be aware you may have surrogate escapes and handle appropriately. (For example by using the repr, or re-encoding with a different error handler like the 'replace' one to replace unrepresentable chars.) And yes, this does need better examples (or a howto) in the documentation. Note that Python 2 does the wrong thing as well - it isn't a panacea and Python 3 is still *better*. If you call os.listdir with a Unicode path you can get back a list of *mixed* Unicode and byte strings (with byte strings for the undecodeable ones).
The world is not black and white :-) There are things to be appreciated about in Ruby, that's what I was referring to. And if nothing else, the *language* design of Ruby is for the most part a good one. Do I prefer Ruby? Look at the number of open source Python projects I wrote and the number of Ruby stuff. I wrote a rack utility library and made the logo for Rack, that's about as far as I went there.
The web apps are already there, part of a software suite. They are basically like an app store so to speak, where users can interact with it and manually trigger software installs or policy to do whatever to their machines. It is tied into the suite's database. I want to use the API and the web app + Python to do some custom stuff.
I can't take this seriously. You use parentheses everywhere else in your code, probably 100 times more often for things like function calls or tuples, than you type `print` (statement or function). `print`-as-a-function makes line ending choice a whole lot easier and more obvious with the `print(x, end="")` instead of `print x,`. That also removes the need to have blank `print` statements just to get a blank line - just do `print(x, end="\n\n")` and you're good. `print("error", file=sys.stderr)` argument replaces this *really ugly looking statement*: `print &gt;&gt; sys.stderr, "error"`. Want to tab-separate a list? Old way: `print "\t".join(lst)` - New Way: `print(lst, sep="\t")`. So clean...
ah, better yet would be myobj = [n for n in obj_dict.itervalues() if n.x == 1] but I think it is moot because in python3 .values() is .itervalues() 
PTVS does not install into VS Express Editions (Express editions aren't pluggable) - however PTVS + the Integrated Shell essentially gives you a "VS Python Express". [more info](http://pytools.codeplex.com/wikipage?title=Installation%20-%20details&amp;referringTitle=Home)
Aw, crap! Didn't know it format this. Stoopid noob.
The only niggling problem with this class code is that the "numList" variable is set to a list. This list is seen by Python as something like: &gt; def __init__(): &gt; # get arguments &gt; self = first argument passsed in &gt; numList = [] # only list used!!!!! &gt; # the above parrt is executed only once!!!!! &gt; self.numList = numList # meaning: use that reference to a list named 'numList' that was already set at the beginning of this function. So lets suppose I change the numList from outside: &gt; test.numList = [...] &gt; a = solver(L) # L is a different list &gt; a.numList == L # True DO NOT DO THIS. Do this instead: &gt; def __init__(self, numList = None): &gt; if numList is None: numList = [] &gt; self.numList = numList
Also, pop quiz - what's the default encoding in Python 2 for opening files and reading text as Unicode?
I wish I could WYSIWYG-edit the WinForms in Visual Studio, and then code it in Python. 
You should take this seriously. Why do you think Python 3 adoption is slow? People don't want to type more. The print statement was to debug your code and remove it in the ready program. It was not for string formating. By the way your example with separator as argument to the new print function is really ugly. Not only this is a function, now I have to remember its arguments. And this for code that i don't need in the end. Maybe someone will make: from __past__ import print Then I will move to Python 3.
&gt; gives me 134147 lines of Python, as against 132739 for the 2.x-only Django - an increase of around 1% in this case. Out of curiosity: did you perform a benchmark of Django with, and without runtime hacks on Python 2?
I don't get it. If I install Visual Studio Express and this Visual integrated shell and ptvs will this work? 
&gt; The print statement was to debug your code and remove it in the ready program. That's not the focus of it, but it's a use case. However, it's a somewhat poor use case given the huge amount of other ways to debug your code. If you really like `print` as a debugger, use the `logging` module with debug-level logging on when debugging, off when not...but that involves function calls with parentheses.
I think it was mainly done to give us a taste for both. That being said, each has its own pros and cons. For instance, the Matlab code generally looked more friendly (especially for the many matrix manipulation tasks you will almost certainly be doing), but if you're used to traditional programming languages, language design choices like 1-indexing will throw you off. The OpenCV API took a while to get used to, but on the plus side, it's free and can be integrated into larger C++/python projects. I forget about which advanced features each provides, but both are very powerful. I think the choice of which to use depends largely on language familiarity and what other code you want your work to interface with.
It's **ONE** more character to type. I'm at least ever-so-slightly sympathetic to the claims of not wanting to use the `Shift` key because of wrist pain, but complaining just about the number of characters is beyond asinine. Furthermore, if you really have such horrible wrist pain that typing parens for function invocations is a problem, then you should probably be choosing your programming languages with that in mind. Look into things like Ruby and Haskell.
In what way is there not a default?
Or you could use a database that doesn't perform like shit in the first place. NoSQL master race.
And yet, how do you accomodate the case where a machine's locale settings are intentional. This sort of thing is the entire reason they *HAVE* locale settings. Ignoring it is patently wrong.
Single-dispatch is where what function body to run is determined off of one parameter. Multiple-dispatch / multi-methods are where it is determined off of one or more parameters. Static dispatch is where the function to be called is determined at compile time. Dynamic dispatch is where the choice of what function to run is determined at run time. So: C++ function overloading is "static multiple dispatch" C++ virtual functions are "dynamic single dispatch" (dispatching on the implicit "this" parameter) Guido's code allows for "dynamic multiple dispatch". C++ Visitor pattern tries to emulate "dynamic multiple dispatch". I don't use Guido's code often but when I do it is a big help. A great example is walking the objects of a tree to render it for various mediums (whether the tree is an ORM, etc). I've modified the code slightly. I've added a "AnyObject = object" to make the intent of the code easier to read when I want a wild card for a parameter. I also changed the rules for ambiguity slightly. Rather than finding all matches and throwing if multiple exist, I chose the closest match with precedence determined by parameter ordering.
Granted, it's not anything near what SmallTalk (Squeak) offers so far as debuggers go, but you can always insert breakpoints about troublesome spots. Similarly, Python offers trace, which I would imagine is much better at handling debugging than print statements. Many IDEs (even Vim, with the right plugins) allow debugging from within the editor. But then, if you don't mind going back and deleting all the print statements, then I suppose it works. I can't say that I never throw in a print statement or two when developing.
I agree that PyPy is more deserving of the title of successor to Python 2 than Python 3 is, but I have my doubts that it will catch on. Python (and Ruby, too) seem to be rapidly losing ground in popularity due to their poor support for asynchronous programming. PyPy has features to help in this area, but many of the more important features are available to Python 2 programmers with gevent. I haven't used PyPy personally, but it doesn't look significantly more usable to me than using gevent, and I'm convinced this is a usability problem. I think the failure of Twisted, Tornado, and Ruby's EventMachine to gain widespread developer interest while node.js is exploding in popularity is the writing on the wall.
It requires a few external modules and you need to put the path to the connections.xml. But then you can modify it to execute custom sqls and schedule it to run periodically. 
But Python has never been about minimising the amount of typing needed. Its core principle is clarity and consistency, and print as a function is more consistent with the language as a whole. It's not a special enough case to break the rules. Or look at it this way: "print " is 6 keystrokes. "print()" is 9 (if you press shift twice). If it's a big deal, put "p = print" at the top of your file, and use "p()"...five keystrokes!
no, you can just install visual studio shell and ptvs.
ironpython?
I have [Python Module of the Week](http://www.doughellmann.com/PyMOTW/) in my to-read list. Seems worth checking out.
You're typing () all the time anyway. I have a Python script open in my editor now, in fact. There's maybe 60 lines of actual code, and I count 8 which don't include at least one function call - and 4 of those are imports. print as a function is a minor friction in switching, that you soon forget about. The big issue for Python 3 adoption is library support, and that's improving rapidly.
Yeah that will do. In fact I feel a little sad the guys from PTVS decided to make their project from scratch instead of colaborating with the ironpython guys.
Makes sense. List access is in O(1) but dictionary access is in O(log(n)). Then again, if I needed speed I wouldn't have used python to begin with. I profiled my code and that's not where the bottleneck is so I'll keep the dictionaries for now. Chunks sound cool though, I'll definitely keep that in mind.
Thanks for this as well. My new goal is to try to automate myself out of a job with Cron/Launchd/init.d and bash/python/objc/applescript and see if it is actually possible to completely automate myself out of my job. This is sounding more and more fun and I like the challenge of it every time I think about it. 
Nice. I am far from running in any memory problem, but I'll keep that in mind for the future.
Every IDE I have used puts the matching paren when you type the first one. Any good editor allows you to do the same by configuration. So at most you type 1 more character. Even if you choose type both...two characters is arduous? Really? Python 3 may have done some things wrong but the print() function was not one of them. It is awesome.
Also...setup the freaking IDE/Editor to auto-match! If you type one you get the other. It can be as simple as this in Vim: inoremap ( ()&lt;Left&gt; inoremap (&lt;cr&gt; (&lt;cr&gt;)&lt;Esc&gt;O inoremap (( ( inoremap () () This is a little more "functional": " The following function inserts the closing brace only when the " cursor is at the end of the line. Vim 7 needed. function! ConditionalPairMap(open, close) let line = getline('.') let col = col('.') if col &lt; col('$') || stridx(line, a:close, col + 1) != -1 return a:open else return a:open . a:close . repeat("\&lt;left&gt;", len(a:close)) endif endf inoremap &lt;expr&gt; ( ConditionalPairMap('(', ')') inoremap &lt;expr&gt; { ConditionalPairMap('{', '}') inoremap &lt;expr&gt; [ ConditionalPairMap('[', ']') 
This particularly sucks for newbies coming to the language. Just do a search for "Should I learn Python 2 or Python 3?". Ugh.
If nothing else, Python 3, Perl 6 and PHP 6 have shown that making this kind of big leap with a language is very difficult, painful and occasionally embarrassing process. Under the circumstances, I think that Python has done a significantly better job than any of its peers.
Well, you can run PTVS with IronPython. They're not competing. IronPython is an interpreter, PTVS is IDE integration.
Note that in recent versions of Python, next(x) is preferred to x.next(), because it's moved to a special method (double underscore) for Python 3.
The reason for the difference in print output is because Python 2.x is parsing the print statement as the *print* keyword followed by a tuple, instead of treating it as a function call. Python 3.1 is calling the print function with two arguments - the values of the expressions *testObj.x* and *testObj._propGetX()*. Not sure why there's a different number of print statements, however.
I think he was asking about why the second print in Python 2 gives "(10, 20)", instead of "(20, 20)", not the formatting difference.
I am going to say becuase: print('_propSetX') causes it to print again. So in P3, the print function to call the function is calling the other print function. If that makes sense. It does in my head.
It appears that when you do "testObj.x = 10", Python 2 is replacing the property with a plain attribute, instead of calling the setter. Python 3 behaves correctly. I'm not sure what's gone wrong in Python 2. EDIT: I see it now. It's an old style class in Python 2, and properties only work on new style classes (so say [the docs](http://docs.python.org/library/functions.html#property)). In Python 3, everything's a new style class. It works if you change it to: class TestClass(object):
That is correct. I understand the difference with the print and print(). But in Python 2 it seems like these are setting two different values when they should be the same: testObj.x = 10 testObj._propSetX(20)
Read the [wikipedia article about finite differences](http://en.wikipedia.org/wiki/Finite_difference). The central difference (f(x+h)-f(x-h))/(2 * h) is a better approximation to the derivative than the forward or the backward difference. 
Whoops, I totally overlooked that :)
You may consider [this pdf article](http://www.geometrictools.com/Documentation/FiniteDifferences.pdf) also.
Noted, updated and am grateful. Thank you!
KTorrent http://ktorrent.org/wiki/index.php/Writing_Scripts
I was thinking about this http://ironpython.net/tools/
no, dictionary key access is also O(1). however, selecting part of the dictionary based on area will be *very* inefficient, as will similar operations. and to make it appear infinite, you have to unload parts. therefore, chunk systems (which are a similar concept to indexes, and indeed would work well when used in conjunction) will be a necessity for a game which requires an apparently infinite world. that said, the dictionaries idea isn't a bad one for a finite but highly shaped and dynamic world. non-euclidean space, anyone?
Tornado is catching on quite nicely among startups community. To my knowledge: Quora, HipMunk, Greplin... More [here](http://www.quora.com/Tornado-web-framework/Who-are-some-famous-users-of-Tornado?q=Who+uses+tornado).
I can only give you one upvote, but it is a fraction of the number you deserve. I've been pulling my hair out for a days over a bug in my code, eventually distilling it into the test code I posted. Thanks!
Well, it's a fraction of the number I've received - so far one eighth. ;-). You're welcome.
WinForms is pretty difficult to accomplish this with. We did do it early on w/ IronPython but it involved adding lots of decorators to the code and special doc comments which preserved enough information for the designer code to be round tripped. It was pretty ugly, but unfortunately you need to be able to give the WinForms designer a good deal of information about the types that are being used. The WPF designer is much easier to do because of the seperation between code and UI.
We didn't start from scratch - infact we're pretty much the same guys (me being the main dev who worked on IpyTools and PTVS) and the same code base. We just took IpyTools and made it work for Python in general instead of IronPython in particular. We also talked to Jeff Hardy who is the lead developer on IronPython now about how we should best proceed going forward and that's why IronPython no longer installs it's tools by default - in general PTVS is just a superset of IpyTools so that's now deprecated. 
That even points at PTVS now instead of being IpyTools.
You have to have X11 for WingIDE.
So, I went through and actually solved this, and I might want to warn you that a lot of my permutation-based approaches simply didn't work at all. Its hard to get the right result using only permutations. For example, what is the difference from an operator permutation perspective between (a*b+c)/(d+e) and a*b+c/d+e and a*(b+c/(d+e)) All of them have the same numbers of operators in the same order, but the groupings are completely different. This gets even more nasty when you consider that you have to also account for out of orders and non-commutative operators, such as (d+e)/(a*(b+c)) What I ended up doing was a little bit nasty, but mathematically what I did is I sketched out the full EBNF grammar for expressions with parenthesis, then I recursed that grammar, generating all expressions I could, not stopping until I had used up all the integers in the list. Then, I used eval on the expression I generated when all the integers were used up and returned the result, inserting them all into a set. Its slow as hell but it works. There may be a faster way, but thats the only way I could think of to verify a correct result. You may want to go to your professor and tell him that you asked for help to figure it out and a computer scientist told him that this problem is probably NP-hard. He'll know what that means. Generally, NP-hard problems aren't considered "introductory programming course" material and he should consider giving you a new problem.
since this is a pedagogical exercise, I'm just going to come out and tell you that making a class whose only role is to call a `solve` method is totally pointless, and that any strategy that involves `eval` is wrong. You should never use `eval`, unless you are building a repl or writing a developer tool. is this the solution you're getting? [-20305, -20293, -20284, -20235, -20020, -19383, -18744, -2484, -2450, -2414, -1847, -1826, -1764, -1620, -1574, -1571, -1562, -1553, -1550, -1549, -1548, -1527, -1504, -1478, -1334, -1298, -1277, -1276, -1275, -1254, -1218, -1208, -1196, -1116, -972, -944, -932, -923, -914, -902, -901, -900, -888, -874, -830, -710, -686, -650, -648, -640, -639, -638, -637, -636, -630, -624, -588, -568, -356, -344, -335, -286, -237, -228, -216, -215, -214, -202, -193, -142, -132, -131, -121, -119, -115, -109, -105, -93, -88, -84, -81, -80, -79, -73, -72, -71, -70, -69, -63, -62, -61, -58, -52, -49, -44, -42, -40, -39, -38, -37, -36, -35, -28, -26, -23, -22, -21, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 26, 27, 28, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 49, 52, 58, 61, 62, 63, 69, 70, 71, 72, 73, 79, 80, 81, 84, 88, 93, 105, 106, 107, 109, 110, 111, 114, 115, 118, 119, 120, 121, 125, 130, 132, 142, 193, 202, 214, 215, 216, 228, 237, 286, 335, 344, 356, 357, 358, 370, 379, 568, 588, 624, 630, 636, 637, 638, 639, 640, 648, 650, 686, 710, 830, 874, 888, 900, 901, 902, 914, 923, 932, 944, 945, 946, 958, 972, 1016, 1116, 1196, 1208, 1209, 1210, 1218, 1222, 1254, 1275, 1276, 1277, 1298, 1302, 1334, 1478, 1504, 1527, 1548, 1549, 1550, 1553, 1562, 1571, 1574, 1575, 1576, 1597, 1620, 1646, 1764, 1826, 1847, 1848, 1849, 1870, 1932, 2414, 2450, 2484, 2485, 2486, 2520, 2556, 18744, 19383, 20020, 20235, 20284, 20293, 20305, 20306, 20307, 20319, 20328, 20377, 20592, 21229, 21868] That seems wrong to me. I have no idea how the hell 21868 could be a valid solution. Edit: no, it's correct. I see now how you could arrive at 21868 (I annotated every solution before executing it this time around), but it isn't obvious when annotating the solution space in infix notation. I recommend you avoid infix notation for this problem. `(1 + 13) * 71 * 22` will yield 21868, which is impossible to arrive at if you're using eval, unless you're also evaling every possible placement of parenthesis. It's more obvious if you think about the problem in postfix notation. Did your professor give you an earlier assignment where you implemented a reverse polish accumulator? You should probably go over that lesson again. I arrived at this solution in 19 lines, including import statements, with only a single function, no explicit recursion, and no classes, but the use of the standard library may mean that it's not a valid homework solution. A solution without the standard library would be longer but possible. A recursive solution is also possible. I say it has no *explicit* recursion because I use generators in the solution that come from the standard library, which are out of scope for this discussion but fulfill the same roll that recursion would fill. Talking about the size of the program and how I didn't use any of those extra things is really just to say that you don't necessarily need them, so if you're struggling to come up with the right class definition, then maybe it's not the best strategy. What's absolutely imperative is that you learn to think about functions as objects and that you don't use eval. Not using eval should be an explicit requirement. I will post the full source once you post a working solution.
If parens are allowed I'm pretty sure this doesn't cover the solutions, because there are also a large number of groupings of parens, such as (a+b)/c+d vs a+(b/c)+d vs (a+b)/(c+d)
Since you are an open-source hacker, I will not need to advocate here open source w.r.t. closed source, or proprietary solutions, just a note: you can host the web app and database for free on _many_ providers, I'm using Heroku + mongolab, but Dotcloud, Ep.io… and many others will do. Completely for free (up to 240MB of bookmarks, that is quite a lot)! Moreover, when talking about a private deployment I meant really under your full control: private bookmarks on shared services are private to other users, not to the service owner… In some cases, hosting your data on a public/commercial service is not what you want, or can do (think to some government agencies). This is why Google offers their appliance, or GitHub offers a similar solution… just to name few examples. So even if I admit that my software is just a proof of concept probably worth no more than the few hours it took me to develop it, I still think it can be interesting to some other users, if not to you. 
you can build amazing things with Tornado, but I don't think that's a great indicator. 99% of developers aren't solving problems that hard and don't have the money to hire the talent that the example companies do. Node.js and Tornado both started in 2009. One of those has 4,599 questions tagged on SO. The other has 267. Which is which? I'm not saying you can't do async programming with Python or that nobody is doing it, I'm saying that Python has lost its cool, which is bad in the long run for the Python community. It's worth noting that Twisted has 756 questions tagged. Great. Our community is almost a quarter of the size and significantly more fractured. People don't actually care that node.js's concurrency is fake; they can make a chat room using ideas that fit inside their head, and that makes them happy. That's what matters. Python's async options have formidable barriers to entry as a result of the language's poor support for concurrent programming, and I think the sad reality is that at the end of the day Python will lose out, and that experienced Python programmers will be left saying "but I'm right" to an empty room.
A little copy-editing: &gt; Users's can create Drop the 's. It's just "Users can create". &gt; just disattach it The proper word is "detach".
Ha, I actually had this edited.. must have overwritten it again. Thanks!
Your local installation *is* the repository, and you can push changes to and pull changes from other repositories (like github, or your second PC). That's the magic of distributed RCS (revision control systems), as opposed to server-based RCS like SVN. Read http://hginit.com/, it's a great and well-written introduction by Joel Spolsky (of Joel On Software fame). Even though it is for hg not git, they are both very similar and the basic concepts are the same.
I don't know that this satisfies the requirements of the assignment. If you call eval on that string you'll invoke Python's operator precedence features as a side effect, rendering it impossible to create the appropriate solution set without also injecting parenthesis. E.g. the strings `6 - 5 + 2 * 3` and `2 * 3 + 6 - 5`, when run through eval, will both compute to 7. If you ignore operator precedence, they come out to 9 and 7, respectively. Presumably the exercise is to find all possible solutions that can be applied given a set of functions and a set of values to apply them to; invoking the interpreter will cause you to consider two different solutions as being the same. Besides, if the professor says "now here's some arbitrary binary operation. Add it to the list of candidate functions" you're totally boned.
So the best practices would be to develop on my local machine, even if its a web app and to push from my local repo to the webserver to make changes?
For a crash course, I recommend reading "Pragmatic Version Control Using Git" by Travis Swicegood.
Can someone show me a practical usage of generators? I understand how they work but not how to use them "in the real world". 
&gt; Were should my versioning software be On your workstation. &gt; Does the software keep track of all changes I've made to an application Yes, but it needs your help. You generally organize individual "commits" like diary entries. &gt; and then upload them to the live servers when pushed? That's deployment, which is something version control isn't really intended for; however, it can be used that way. It's a matter of requirements for the project and personal preference. My personal opinion is that deployment should be left to deployment-specific tools. In the simplest case that's often just rsync.
Thanks for the answers. So versioning helps me keep my project documented and on track and in the event I destroy something I can revert changes. Deployment would then be left to another software. Thanks!
&gt; Is it best practices to develop on my local machine and have the software push to the web when I have everything in check? Only when it passes all the unit tests. :)
or perhaps it is because they are adding all the new stuff to a language that I don't use even though it is called python - just as I don't get excited because something new got added to perl for example 
I'll be following up this article with a practical use next round
Now we're talking. Thanks!
As for operator precedence, the given specs don't seem to really mention it, so I assumed that it would be the usual precedence, which Python abides; at least so far as addition, subtraction, multiplication and division are concerned. So yea, it isn't perfect, but it works for that. And sure, it's brittle: it's a five minute hack. I'm not going to do the assignment for him (I already came close enough here). Given the specs listed by the OP, I still think that this solves the majority of the problem.
Infinite series are one of the fun uses: def infinite_multiples(x): i = 0 while True: yield i * x i += 1 for multiple in infinite_multiples(3): print multiple if multiple == 3 * 10: break Not the most obviously usefull constructs, but they have their uses.
Don't we agree on the log for the dict? As for chunks, sure. I don't need them in my game but I would do that if needed.
for the input [22, 71, 13, 1] I arrive at the following output: [-20020, -19383, -18744, -2414, -1826, -1562, -1553, -1527, -1504, -1478, -1298, -1277, -1276, -1275, -1254, -1196, -932, -923, -888, -874, -830, -710, -650, -640, -639, -638, -637, -636, -624, -568, -344, -335, -286, -202, -193, -142, -132, -119, -115, -105, -93, -84, -81, -80, -79, -73, -72, -71, -70, -69, -63, -62, -61, -58, -52, -49, -42, -39, -37, -36, -35, -28, -23, -22, -21, -18, -17, -16, -14, -13, -12, -11, -10, -9, -8, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 21, 22, 23, 26, 27, 28, 35, 36, 37, 38, 39, 40, 41, 42, 45, 49, 52, 58, 61, 62, 63, 69, 70, 71, 72, 73, 79, 80, 81, 84, 88, 93, 105, 106, 107, 109, 110, 111, 114, 118, 119, 120, 121, 125, 132, 142, 193, 202, 214, 215, 216, 228, 237, 286, 335, 344, 356, 357, 358, 370, 379, 568, 624, 636, 637, 638, 639, 640, 650, 710, 830, 874, 888, 900, 901, 902, 914, 923, 932, 944, 945, 946, 958, 972, 1016, 1196, 1208, 1209, 1210, 1222, 1254, 1275, 1276, 1277, 1298, 1478, 1504, 1527, 1548, 1549, 1550, 1553, 1562, 1571, 1574, 1575, 1576, 1597, 1620, 1646, 1826, 1847, 1848, 1849, 1870, 2414, 2484, 2485, 2486, 2556, 18744, 19383, 20020, 20235, 20284, 20293, 20305, 20306, 20307, 20319, 20328, 20377, 20592, 21229, 21868]
Or develop on the server and simply check-in changes as you make them. There's no requirement to push them anywhere (remember its distributed meaning every repository is itself is a server). Or setup a local server on your computer so you can have a development environment and setup a deployment script on the server. Or setup a cert environment, or continuous integration, there is no single "best practice" for how your sole developer environment should look, just understand the ideas behind them and why people use them and you'll be fine. You should NOT be doing version control because everyone else is doing it. I introduced version control before to my colleagues before, and wasn't getting check-ins, proper merges, or pushes to the cert server... They were still creating tons of .old and .bak files which they'd accidentalky push to production (bad) and copying/pasting the changed files from their environment to the servers (extremely bad). Yes everything was in repositories but because they didn't understand /why/ it didn't make a single difference. 
The usual use is if you've got some big collection, e.g. millions of records from a database, and you need to process each item individually. You could return a list and run through it, but that will load everything into memory together, which slows it down. Using a generator, you load each thing, process it, and release it from memory.
Typically you do use your versioning software to upload your changes somewhere though - I guess that's what you meant. It's like a backup on a server then. 
I do not think your solution is complete. I get [-20305, -20293, -20284, -20235, -20020, -19383, -18744, -2484, -2450, -2414, -1847, -1826, -1764, -1620, -1574, -1571, -1553, -1550, -1549, -1548, -1527, -1504, -1478, -1334, -1298, -1277, -1276, -1275, -1254, -1218, -1208, -1196, -1116, -972, -944, -932, -914, -902, -901, -900, -888, -874, -830, -710, -686, -650, -648, -640, -639, -638, -637, -636, -630, -624, -588, -568, -356, -344, -335, -237, -228, -216, -215, -214, -202, -193, -105, -81, -80, -79, -63, -62, -61, -37, -36, -35, -8, -4, -2, 2, 4, 8, 35, 36, 37, 42, 61, 62, 63, 79, 80, 81, 105, 106, 107, 193, 202, 214, 215, 216, 228, 237, 335, 344, 356, 357, 358, 370, 379, 568, 588, 624, 630, 636, 637, 638, 639, 640, 648, 650, 686, 710, 830, 874, 888, 900, 901, 902, 914, 932, 944, 945, 946, 958, 972, 1016, 1116, 1196, 1208, 1209, 1210, 1218, 1222, 1254, 1275, 1276, 1277, 1298, 1302, 1334, 1478, 1504, 1527, 1548, 1549, 1550, 1553, 1571, 1574, 1575, 1576, 1597, 1620, 1646, 1764, 1826, 1847, 1848, 1849, 1870, 1932, 2414, 2450, 2484, 2485, 2486, 2520, 2556, 18744, 19383, 20020, 20235, 20284, 20293, 20305, 20306, 20307, 20319, 20328, 20377, 20592, 21229, 21868] Without checking all of them for the source equations, I get -20305 as "1-22*71*13" and -1620 as 13-((1+22)*71) as two examples where I believe you are missing answers. However, also, you seem to get some answers that I do not, such as 0,1,3,4,5,6,7. Can you post how you arrived at those? 
everything is an object in Python, even a class or a module. You could, if you were so inclined, create a dictionary where the keys are strings, and the values are classes. This is a very useful technique when parsing xml, for example. That is, you key your dictionary by the open tag for a given element in your document and get the proper class, then construct an instance of that class using the contents of the element.
Yes. It's almost like a backup/history log. (but make sure you backup your repositories!). One of the beauties though is easy to see if you read comics or generally understand alternate timelines. Let's say you create a stable application, and you see yourself doing a few months of work to redo the templating engine. Create a timeline for your stable application and branch an alternate timeline from this for your templating work. Now if you need to make a minor update to application logic you could do it in the stable branch, merge the stable branch to the templating one and now have to redo either of your code changes. The ability to easily maintain and compare these development timelines is an extremely strong reason to use version control. 
Understanding the theory behind the methods are big deal to me, which I think is somewhat detrimental because I over think the process and end up confusing myself which makes implementation of a new process daunting. So thanks.
This really hits home...A lot of us (like myself) do not actively contribute to Python core, but that doesn't mean we shouldn't voice our concerns with the direction the language is heading. We are all users of the language and we collectively help make Python what it is. I myself have Python to thank for putting food on my table and beer in my belly, and I really hope I can say this 10 years from now. 
the assignment doesn't explicitly state a preference for infix notation. Most likely there was an earlier assignment to compute arbitrary RPN arithmetic expressions using a stack-based accumulator. This is a very simple problem once you give up on infix notation and start putting functions inside lists.
Well I was thinking the versioning software controlled which version of the software was live and which was in development. I think that's not the case though. So I guess I have a bit to read about.
I didn't think about using RPN to simplify the infix expression generation, thats clever. However, it's still an NP hard problem.
This sounded exciting until I looked up what "firebird" was and realized it was... a database.
You're right, my solution is incomplete, back to the drawing board. I'll PM you the source, so as not to give it away. update: here's what I'm getting now: [-20305, -20293, -20284, -20235, -20020, -19383, -18744, -2484, -2450, -2414, -1847, -1826, -1764, -1620, -1574, -1571, -1562, -1553, -1550, -1549, -1548, -1527, -1504, -1478, -1334, -1298, -1277, -1276, -1275, -1254, -1218, -1208, -1196, -1116, -972, -944, -932, -923, -914, -902, -901, -900, -888, -874, -830, -710, -686, -650, -648, -640, -639, -638, -637, -636, -630, -624, -588, -568, -356, -344, -335, -286, -237, -228, -216, -215, -214, -202, -193, -142, -132, -131, -121, -119, -115, -109, -105, -93, -88, -84, -81, -80, -79, -73, -72, -71, -70, -69, -63, -62, -61, -58, -52, -49, -44, -42, -40, -39, -38, -37, -36, -35, -28, -26, -23, -22, -21, -18, -17, -16, -15, -14, -13, -12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 26, 27, 28, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 49, 52, 58, 61, 62, 63, 69, 70, 71, 72, 73, 79, 80, 81, 84, 88, 93, 105, 106, 107, 109, 110, 111, 114, 115, 118, 119, 120, 121, 125, 130, 132, 142, 193, 202, 214, 215, 216, 228, 237, 286, 335, 344, 356, 357, 358, 370, 379, 568, 588, 624, 630, 636, 637, 638, 639, 640, 648, 650, 686, 710, 830, 874, 888, 900, 901, 902, 914, 923, 932, 944, 945, 946, 958, 972, 1016, 1116, 1196, 1208, 1209, 1210, 1218, 1222, 1254, 1275, 1276, 1277, 1298, 1302, 1334, 1478, 1504, 1527, 1548, 1549, 1550, 1553, 1562, 1571, 1574, 1575, 1576, 1597, 1620, 1646, 1764, 1826, 1847, 1848, 1849, 1870, 1932, 2414, 2450, 2484, 2485, 2486, 2520, 2556, 18744, 19383, 20020, 20235, 20284, 20293, 20305, 20306, 20307, 20319, 20328, 20377, 20592, 21229, 21868] seems you're missing a few. Your move ;)
If your goal is to find a single result out of all of the combinations, couldn't a "smart" approach instead of a brute force approach be used? If OOP doesn't matter, that essentially the same as using nothing such as parentheses but instead simply using all permutations of the numbers as well, meaning: For example, if they're all integers and you're looking for the largest result, toss division. Mutliplication would have preference if both are the same polarity and either &lt; -1 or &gt; 1. If dealing with different polarities, subtract the negative from the positive. If one of the numbers is 0 or 1, subtract. Of course, there are other things to take into account–if there are an even number of non-"-1" negative integers, multiply them all. Otherwise, refine the rules. If you have to keep the numbers in order, you just need to alter the rules.
You can use it to *record* that information (commonly done with branches), but it's not usually *in control* of what's on the server.
Not a scientific one in terms of requests/sec, for example; nor has any effort been spent on performance measurement or optimisation (too early for that). However, if you're interested in whether the hacks exert a run-time penalty, one can perhaps get a rule of thumb from how long the regression tests take to run (FWIW): Django on 2.x unported: 4482 tests in 368.972s, skipped = 90 Django on 2.x, with u(), b(), sys.exc_info() etc: 4478 tests in 367.635s, skipped = 90 Django on 3.x, with u(), b(), sys.exc_info() etc: 4423 tests in 372.946s, skipped = 96 These are just from the log files I have lying around; you can't infer much from them, but they do give a vague idea.
Thanks. That looks pretty promising.
The lesson to be learned: always use newstyle classes :-)
Also `x.next()` (for Python 2) or `x.__next__()` (for Python 3) is a method provided by *any iterator*, not just generators (which are a special case of an iterator).
I'm glad I asked then, it seems although ultimately very helpful theres a fairly decent learning curve between a files + ftp development environment and something you would see in a conventional professional setting.
You need to fix your formatting, first of all. Flat Python means nothing.
ugh it was formatted when i typed it, then reddit took it all out. edit: fixed.
Python is reference based: all "non-primitive" types are "passed as a reference". Since 10 is an "primitive" integer, it is "passed by value". b and c are not "primitives", so they're "passed by reference". If you want to talk about mutability and argue over what a primitive is, earthboundkid's answer is pretty good. *Edited for clarity of my point and added quotes because I'm a liar and my pants are on fire*
The way I'm going to be using them in a node-based list-operation-chain system I've been designing is to allow one-at-a-time flow through the whole chain. Traditionally, you'd have to modify a whole list, then pass it to the next procedure. With generators, you can have each list modifier yield its next item, so instead of: 1. get whole file list 2. do string operation to remove file extensions 3. wrap file basenames in a command 4. append command to file You would have: 1. file append command asks for next item to write to file 2. wrap command asks for next basename to command-wrap 3. string operation asks for next string for extension removal 4. file list reads next filename and sends it up the list This allows for things like stepping through operations, setting breakpoints, iterating only so many times, and even poking into the middle of the operations at an arbitrary point to make changes to nodes mid-operations.
Just to give you a sense of one possible work flow which my team uses for each project (not the only git workflow, but a common one, I think): * each developer works on their own machine, with their own local copy of the repository, committing locally * each of us pushes to and pulls from a hosting service where the authoritative copy of the code lives (we use github, which is slick, but not free for private repos; there are other options or you could run your own) * we have a staging server, from which we check out code from the central repo, that follows the state of the main repo pretty closely, which we use if we want to show off pre-release code to others within our organization * we have one or more production servers that also run checkouts from the main repo, and are updated each time we do a release There's a little more to it than that: we make heavy use of feature branches, for example, and maintain separate branches to keep track of what the current state of development is (the thing usually running on staging) vs. what should be in production (so that if we need to hot-fix production bugs we can do so without having to pull production up to the current development state), but that's probably getting into 200-level git, for which a book might be more helpful. Our workflow is also maybe a little bit more complicated than you need if you work alone. In particular, you can almost definitely get by without a staging server if nobody has to see the current development state except you, and you may not need a separate host for your personal repo, either, and could instead just push changes from your local repo to production. The important things, though, are that everything you write for your app lives in version control, and that you never, ever change things directly on a server; version control should be the only means by which code makes it into production.
You wouldn't have to deal with Py3, and you get the continuing development of Python by PyPy (not stagnated as Cpython 2.7 will be).
"if you want to be taken seriously as a developer you should probably use the tools that developers use right?" Nope: use the tools that help *you* do *your* work as well as possible. If the whole world uses a wrench to drive nails and you work better with a hammer, by all means, use a hammer. Look at what tools can do for you instead of blindly using them because errbody does.
All previous python versions had some enhancement, minor ones maybe, but some. Py3 seems to only have minor anoyances and no advantage. Why would I switch?
Ahh, that does make sense. Thanks.
Came looking for a book recommendation, left with a book recommendation. Thanks.
That's pretty neat and clever
I don't work with anybody else, except myself, so there is one thing I don't understand. When you all have your own local repos, changes and updates, what happens when you push to the main repo? For example, what if Person A changed line 250 in `example.py` and so did Person B, but with something else? What if two files were edited in two different places? I love git for what it does for me, but I just don't get how it can manage these sorts of conflicts. I'd imagine it comes down to something external to git, i.e. "Barry is working on the multithreading, whilst Gizmo is doing the interface.." ?
*Someone's* still using CVS. ;)
you need to use a return (return a, b, c) inside the function and get the value back, something like a, b, c = f(a, b, c)
I think it has more to do local vs global with scope? The c inside f is in the local scope and is bound to the same object as b, initially [11, 12, 13] then [2, 12, 13]. In the global scope the variable c still points to the same object ([13, 14, 15]) http://stackoverflow.com/questions/291978/short-description-of-python-scoping-rules [Edit] Clarifying examples: http://www.saltycrane.com/blog/2008/01/python-variable-scope-notes/
The way github's servers are configured, you can't push if it's not a fast-forward (that is to say, if the version in the central repo has changes your copy doesn't have, your push will fail). So if someone else has changed something since you last pulled and it fails, you have to first pull down their changes with a "git pull" before you can do a push. If you and the other person didn't both change the same thing, it merges in their changes without you having to do anything, after which you can push again and it will succeed. If you *did* make conflicting changes, git will complain, and flag the portions of the file that have been changed by both people. You can then resolve the conflicts by hand however you want, do a commit to complete the merge, and then do a push as you would have otherwise. It's a little daunting at first, but pretty painless in practice.
I'm all for *trying out* new technologies, just not blindly using it because it's new. DVCS &gt; VCS.
I see that happen when I've made changes at home, and then try to push again at work. Usually I just `git stash` and the error goes away. I'm a total noob with git, seriously. I'm just using it to easily work with the same code at work and at home. Whilst also not having to care about a local branch getting nuked because it's always on a server. There's a book recommendation in this thread that I'd seen before. I really want to get good with git because it seems like there is so much functionality that I'm missing out on. So, if you *are* editing the conflicts by hand, won't you have to get it perfectly like the central repo copy anyway? Also, why doesn't your crew have their own git server? A lot of people I know who work for professional programming places seem to shun using github due to the perceived privacy and availability concerns, however unfounded they may be.
That is very hopeful post. It seems that version control comes in different levels of extreme. I guess for my own projects a less complex solution would make sense. Now I'm a product manager and former designer that has a background in code that I'm slowly building on. If I were to start looking for entry level gigs - how much knowledge with version control would you say I might need for a basic startup gig?
Overall though, for the small parts of git I use, I find it way simpler than anything else I've used. Git works for a variety of use-cases whereas other version control software packages are just monolithic control regulators.
A pretty obvious example is `xrange()`. The `range()` function generates an actual list of numbers, `xrange()` is just a generator. This means a saving in terms of memory, and possibly execution time, especially if `xrange()` is used to control a loop which may be exited before the end of the range.
X11 only for MAC. and maybe it'll have a better solution.
Some of the worst code and standard operating procedures I've ever seen have come from conventional professional settings.
&gt; So what? Python 3.0 makes it trivial (in fact automatic) for you to be able to compare a gbk string to a shift-jis string. It helps. Yeah while this is a veery common use case, it's no less trivial to achieve in Python 2. &gt; Python 3 does force you (or strongly encourage you) to think about encoding and that reduces delayed encoding time bombs. Python 3 does so at the cost of removing functions that are widely needed. It tries to pose as an expert and tell me what to do on what I'm really good at! If I'm a stylist, I would hate my scissors to stop functioning and teach me how to cut better. 
there's nothing ambiguous. Given a list of binary operators and a list of operands, produce the permutation of available candidate programs. Execute the programs, and for all programs that do not fail, store the result if it unique. Then sort the collection of results. That's pretty cut-and-dry.
I used a generator recently in building a Markov chain. It took an argument for a filename (text file to read) and the number of characters to return at a time. Since it's a generator, I can loop over it with a `for` statement and count the results. It was simply a practice in teaching, but certainly a valid use. I could have stuck the entire file in memory and returned a list from a normal function, but the generator is lazy, and only computes/yields the next chunk when I ask for it.
dude, you're living in a [Kingdom of Nouns](http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). A class whose only role is to call a "solve" function might as well just be... a function. If you need to store stuff between calls, pass the container in as a parameter.
So sweet you go through all these troubles for your users. Big thanks!
How did you go about implementing that?
Iterators are next. The problem is trying to teach generators and then throwing this concept of iterators. Focusing on one use case then being like "That thing you just learned... NOW DO THIS!", I believe, is a better way to handle these more advanced Python topics. Lay the base coat!
You need to read about the PYTHONPATH. It's an environment variable, listing the folders from which you can import things. The easiest way to see it is to start Python, then do: import sys sys.path If you put your module or package in one of those folders, it can be imported from anywhere. You can make a [setup script](http://docs.python.org/distutils/setupscript.html) to install a package to the correct location.
My upvotes for I think it is awesome, solves my problem to some extent. Yet my question is still open why the change and expect people to work around it... Also, being a long time EmEditor user on Windows, it is not that much fun to switch :(
nah, Python will pass it by reference. You can use the `id` function to test this type of thing. Here's an example: In [1]: def modify_list(a_list): ...: a_list.append('a') ...: In [2]: a = [] In [3]: id(a) Out[3]: 4324829088 In [4]: modify_list(a) In [5]: a Out[5]: ['a'] In [6]: id(a) Out[6]: 4324829088 It's a bit... weird, since it's not *exactly* by reference *or* by value in the way that you would think about it coming from C. There's a long discussion on SO [here](http://stackoverflow.com/questions/986006/python-how-do-i-pass-a-variable-by-reference). The exact details of it are a little mysterious to me, so I just fiddle around in IPython to check how things work. Essentially you are passing a reference to the object... by value. Weird, right?
You don't complain because it does not matter to you. How about if you program in shell script and one day "echo" is changed to "ECHO", if you are a vim user and suddenly "hjkl" requires shifts, or if you are a rich taxpayer and the rate increases by ONE percent? Someone has to stand up and ask "why" and "is that necessary?" And seems I'm not the only one that asked in this thread.
Well, every IDE you have used probably auto matches braces as well and some people (not me!) think braces are awesome too...
I was messing around with that too, but if f(a,b,c) is the last line before print, I was confused how a could be anything other than 1 since that is what the function specifies.
Basically the same as "pleased" or "happy". eg: "I am pleased with the progress I am making." "I am chuffed with the progress I am making."
It's not overly complicated: # Python 3 def feed_chars(filename, step): with open(filename) as data: for line in data: for start in range(0, len(line)): res = line[start:start + step] if len(res) == step: yield res if __name__ == '__main__': record = dict() step = 2 # Number of chars to use in each chunk for group in feed_chars('pkglist.txt', step): # Your text file here record[group] = record.get(group, 0) + 1 print(record) It's not the most beautiful implementation. Keep in mind that it was used for teaching generators, dictionaries, and the idea of iteration to some other students looking to learn Python. It could certainly be improved upon, but it does work. We focused here on simply building a record of occurrences rather than to create strings of output based on that record. That's Friday's task/lesson. If this were a more important bit of software, I'd append an `else` statement to the end of the function for concatenating remaining characters from a line to the next, if another existed. And I'd probably filter newlines.
This is a nice thing about Python 3: No "old style classes" nonsense. For those who aren't familiar, the issue here is that `property` only works in "new style classes." All classes in Python 3 are new style, but in Python 2, you need to either inherit from `object` or inherit from a class that inherits from `object`. It's a common bug to forget to inherit from somewhere and screw up your properties.
One advantage of the new style `next` is you can provide a default: first_match = next(match_generator, None) if first_match is not None: ...
His answer was 100% wrong though. See my reply.
Nope. There is no such thing as pass-by-value or pass-by-reference in Python. Python's system is different than either. Python also doesn't have a difference between primitives and non-primitives (at least not in this sense). Instead you should think of Python as having a "tag and value" based system. Some values are mutable and some are immutable. What happened here is that the second array was given the tag `c` inside the function, but that didn't change its tag outside of the function. Meanwhile the value of the second array was mutated, so that changed its value for all the tags pointing to that value.
You should think of Python namespaces like a series of dictionaries pointing to objects. Here we have two namespaces, module level and function level. What you have here is the equivalent of this: module = {} function = {} module["a"] = 10 module["b"] = [11, 12, 13] module["c"] = [13, 14, 15] function["a"] = 1 function["c"] = module["b"] function["c"][0] = 2 print module["a"], module["b"], module["c"] When you look at it this way, it should be obvious that module c never changes, but module b gets mutated.
This is a huge problem over in r/gamedev. It's painful as you can almost see people's dreams being inadvertantly crushed by well meaning people saying "use c++/c# if you need speed". The newbies are largely going away and getting trashed by the learning curve of c++ and c# and never getting anywhere with their game.
I don't know much about it yet, but I believe what I'm doing is related to [lazy evaluation](http://en.wikipedia.org/wiki/Lazy_evaluation), as used often by functional languages like Haskell.
Somewhere out on the internet, there's a great description of how Python namespaces work like tags, and it even has little ascii art showing the names pointing to objects. Does anyone have the googlefu to find the link?
Hi. I see you point. But to most people "print x" is probably faster to type and has clearer intension than "p(x)". In my opinion "print" wasn't that bad to deserve elimination. In fact I am a little sad when python 3 went "new way or old way" instead of "quick way or alternative way". And well we already have "sys.stdout.write" so "there is only one way" doesn't apply. On the subject of consistency, I could only wish python 4 wouldn't force us to use import as a function: search, match = import("search", "match", module="re") 
&gt; There's a book recommendation in this thread that I'd seen before. I've also heard good things about this book, though I've mostly just learned by doing. &gt; won't you have to get it perfectly like the central repo copy anyway? No, you can resolve the conflicts however you want. When git has a merge conflict, it just put both versions of the conflicting line in the file with big "&lt;&lt;&lt;&lt;&lt;" signs around it. You pick the one you want and delete the others, or write a new line or lines that combine the two, and commit the result, and that becomes the new canonical commit, which you can push. You can still retrieve either of the old versions from the history, so it's not like it does any permanent damage. &gt; why doesn't your crew have their own git server? A couple of reasons: we like the ancillary features that Github offers (issue tracker, wiki, etc.), and, more importantly, the [organization I work for](http://sunlightfoundation.com) is a non-profit and all of the code we produce is open-source. Github has private code management available, too, though, and I could see a lot of use cases where it would be a good fit. We've also never had availability problems with github (or, if we've have, they've been considerably less significant than those of Amazon AWS, where our servers live), and even if we did, every developer has a complete copy of the history, can commit locally, and could conceivably push to production from their local copies if they had to, so git availability is generally less critical than SVN availability would be, say.
Not much. Committing, being able to view history and revert changes, pushing and pulling would get you a lot of benefits without taking much effort. Beyond that, you continue to gain benefits from putting more effort in, particularly if you're collaborating, but you don't really absolutely need much else. Branching and merging, for example, is probably a nice added bonus for someone in your shoes. With our style of development, each new feature lives in its own branch, and isn't merged into the master branch until it's done, which means the master branch is pretty much always in a state where it could be deployed if we wanted to, and we never find ourselves in a situation where we can't push feature Y into production because we've also started work on feature X and it's only half done, which seems to be a common problem when everything shares the same codebase. But like I said, that kind of thing is a nice extra, and even without taking the time to learn it, you can still derive a lot of benefit from version control, just from keeping a log of your history and making your deployment more sane.
I mentioned the use of 4. :) I build it originally to cheat at Bookworm, and I could reasonably anagram anything five letters and under. It was the longer combinations that screwed me. The maximum number of tiles you can have is 16, so... :) But you're right. Remove that part so the regexp is just \^[someletters]{,length}$, and you'd be set.
With CVS in particular, I would actually argue that in some ways, CVS is worse than nothing. It makes it really easy to make history-destroying changes without realizing it, so it gives you a false sense of security that it's keeping your history for you when it might actually not be doing so. At least people without a VCS probably make backups of old versions by some other means... With just about anything else, though (SVN, etc.), I agree that something is better than nothing. I happen to think that git makes a lot of workflows easy that used to be hard, but versioning is certainly a problem with more than one solution.
Thanks for your thoughts. About the array indexing though, since in math and set theory, the first element is indexed as 1, I am much more comfortable with the 1-indexing - I'm surprised that other people find it otherwise, unless, of course, their (non-fortran) programming background is stronger. Yes, NumPy array notation and operations are indeed verbose in comparison to Matlab, but if the libraries can keep up I'd be willing to put up with a small hit in elegance. But thanks - I'll be looking into calling OpenCV from python.
oops! writing things after nearly a day of sleep loss can mess you up. I meant O(1). corrected :) I should note that O(1) is the best case, with no hash collisions, and a 2D grid will have some hash collisions if you make it large enough. However, it will be close enough to O(1) for small grids (due to the fairly long hash() keys). Admittedly the dict lookup time is higher than a list due to a list just being a memory lookup but a dict requiring a hash first; but for a tuple of ints, that will be a pretty fast hash.
&gt;I mentioned the use of 4. I missed that. Also, myself personally, I wouldn't be able to come up with all legal Scrabble words that you can make with 3 letters. 
I registered only to say: This one f-g ugly hack. Uglier even than Python's multiprocessing library.
All the examples you gave just proved the old print is **easier** and this easiness is among the reasons why python thrive. Everyone likes their job easy. Except for bosses! While the new print does make you feel more joyous when supervising someone else's code, someone else has to work harder to create that joy for you than before. No offense but since you're among those who "can" I hope that position has nothing to do with your consideration that user's extra efforts are trivial.
Well, to be fair, lots of scrabble words are *such bullshit!* :) (There are only six possible permutations of 3 letters, by the way.)
Understood ! Thanks :).
Cool!
https://gist.github.com/1ad069497f0c0e506982 This is a prototype use of a generator as an event handler which can yield and "wait" for an event to happen. I wrote this at midnight, so perhaps not the best code ever ...
Do it backwards. Don't try to get the URL from Firefox after you launch the python app... Give it as you pass the arguments to the python script. Does that work cleaner? 
&gt;Well, to be fair, lots of scrabble words are such bullshit! Ain't that the truth. I know there the set of permutations is small, but it's still a challenge if a given permutation doesn't look (to me) like a "real" word.
Yet it is another step of a great progress.
and now 1/43 my good sir
But how could I get it to automatically pass the url? What I'm aiming for is to open a youtube page, launch my program from its icon, then it will do the rest. 
Maybe you should just copy the url to the clipboard, and then simply import it with your script... Not really what you were looking for but close... Hope this helps. m
Thanks this is what I was looking for.
Your question cannot be answered without knowing your OS.
As far as I know, Armin already uses (or at least makes sure of success on) PyPy for a few things.
Linux Mint. I'm thinking maybe there's some kind of info firefox has stored that python can access, or maybe just read text straight from the address field, I'm not sure how to go about this.
&gt; There is no such thing as pass-by-value or pass-by-reference in Python. No, but that's how Python behaves. For someone coming from C++ with little experience in other languages, it's easier to explain it in terms that they already understand so they can create their own mental model.
Yes, this as well. Since the OP's expected outcome seemed to take the scope into account, I didn't elaborate on that. But yes, you're right.
Welcome cynic, you'll fit right in here.
Good luck!
Getters and setters are kind of discouraged in the python world. How about using attributes instead, so that the caller would write `shape.width = new_value` instead of `shape.set_width(new_value)`. Then you can write a `__setattr__(self, name, value)` that checks if `name` is in a list of attribute names that should trigger a redraw when changed. 
In addition to what Rhomboid said, you should also almost always use functools.wraps() when creating a decorator so introspection will show you your actual function and not fn_wapper() http://docs.python.org/library/functools.html 
versioning simply keeps track of versions. that can mean whatever you want it to mean. if you only want to call something a new version when you push it to the server, that's cool. if you want to call something a new version every time you change anything, that's cool too. personally, i like to make a tag every time i pull a release up to the live server, and commit (aka make a new version) every time i have the code in a state where it's not broken.
yop precisely. it still can be done though and it's not uglier than any other way to interface with libraries like matplotlib that use CPython C API and all private APIs.
Generators may be very helpful when you need concurrency (you can send data both way when using yield). Check out this presentation: http://www.dabeaz.com/coroutines/
generators are amazing. most recently i used one to process records from a variety of sources. basically i made a base class generator then subclassed it for each data source. then i can easily iterate through each record completely ignorant of what was actually underneath, whether it was a file, a web request or a database request.
This is what I was thinking.
i don't get the same result as you -- it works for me. In [9]: r, N, B = symbols('r,N,B') In [10]: J11 = diff(r*N*(1-N/B), N) In [11]: J11 Out[11]: ⎛ N⎞ N⋅r r⋅⎜1 - ─⎟ - ─── ⎝ B⎠ B In [12]: J11.subs(r, 4) Out[12]: 8⋅N 4 - ─── B 
(Reddit's markdown formatting will mangle code unless you do as the sidebar says and put 4 spaces at the beginning of each line.) I tried to reproduce this, but I can't: &gt;&gt;&gt; from sympy import * &gt;&gt;&gt; r, N, B = symbols('r N B') &gt;&gt;&gt; J11 = diff(r*N*(1-N/B),N) &gt;&gt;&gt; J11 r*(1 - N/B) - N*r/B &gt;&gt;&gt; (J11).subs(r,4) 4 - 8*N/B If you can reproduce the behavior like this outside of a larger script, then it would seem to indicate a bug. If not, then there's something else going on in the script that you're not accounting for that causes the difference. I was using python 2.7.2 and sympy 0.6.7, if it matters. 
Thanks! will have to try this out on its own again without the rest of the script. And check my version of Sympy. 
Is it just Python that is INCEPTIONesque or all programming? Programming noob here too lol
Ok. Btw I am a django developer currently working on few projects. And i really want to get into flask world. If you are comfortable working remotely, do ping me. 
I came from C++/Java, and that mental model screwed me up until I learned to think of it the right way. I kept wondering how I could get functions to modify the namespace of their callers and whatnot. I don't think it's a helpful simplification to keep thinking that way. Nested dictionaries is also technically untrue, but I think it is a helpful simplification because it gets you asking the right questions.
I have to think more about this, before I decide if I like it. But already very interesting!
I think you misunderstood PyPy. It aims to be fully compliant with the standard Python specification. PyPy won't introduce new language features that are not part of Python (and implemented by CPython). PyPy will move to Py3 too.
Could it ever be possible to do this the other way round? Run a CPython process and embed PyPy? It would be great to be able to have a few speed-critical bits running in PyPy, in a larger project which used CPython extensions. While I'm daydreaming, maybe we could even have an "@run_in_pypy" decorator, to make speeding up a function trivial.
So could this be a replacement for cpyext, or is it complementary? Is this solution any faster than cpyext? Why do you need numpy installed for the python2.6 if you are using pypy's numpy? 
Yes - otherwise, any change you make is immediately live, whether it is complete or not. That might be fine when no-one is using your app, but not later, so you may as well create the setup you will eventually need from the start. You will also want to be able to run tests, which could be CPU/memory intensive - you are writing tests, right? - without affecting your live server.
You can skip the whole downloading part. The flash plugin already does that. It tries to hide access to the data by unlinking the files but you can still access them. This will print the file name(s) of any currently playing clips: flashfiles() { lsof -c plugin-contain -F nf | perl -nE '/^p(\d+)/ and $pid=$1; /^f(\d+)/ and $fd=$1; m{^n/tmp/Flash} and say "/proc/$pid/fd/$fd"'; } From there it's just: for F in $(flashfiles); do ffmpeg -i "$F" -vn -acodec copy output-${F##*/}.m4a; done ...and you have a copy of all the audio of every active youtube tab. You do have to ensure that each tab has fully buffered the video to the end, though. 
Thanks! This is actually on the getter method of the width property- the method is only public because I was using PyDev to generate getters/setters and hadn't made set/get private yet. set_width will be __set_width in a moment. I like the \_\_setattr\_\_ idea, that's a lot easier to maintain. I think I just really wanted to make a decorator, and outside of caching I haven't found a use for them in what I've been working on. But you're right. Thanks for the feedback! **edit:** Is it still worth keeping around if you want to trigger something off of a method that isn't a setter?
That's a lot nicer, thank you! I was wondering why I couldn't get wrapped function names when I'd seen them in a library I used...
I like your idea of laying the base coat, although I think iterators are closer to "the base coat" than generators because generators are a special case of iterator. It makes more sense to explain the general case first, so when you introduce the special case everything that has gone before still applies. Imagine Python had no generators: an explanation of iterators would still make perfect sense.
why no warning? 
it's different than cpyext, it's not complementary. It's probably a fair bit faster than cpyext, but it does not matter in this case since matplotlib/scipy are not heave on the interface. You actually need numpy on both sides in order for it to work nicely.
I'm not aware of any sane way to do this - you can sometimes use DBus to interact with applications, but I don't think this will work with Firefox You could probably do something with the accessibility stuff, [but it's not exactly.. simple](http://forums.mozillazine.org/viewtopic.php?f=27&amp;t=2042999) One easier way would be to use a Firefox extension like [FoxRunner](https://addons.mozilla.org/en-US/firefox/addon/foxrunner/) which can launch the command with the URL as an argument As for downloading the flv, [youtube-dl](http://rg3.github.com/youtube-dl/) seems like the most robust way (and it's written in Python)
well it depends what you mean. First-class functions, that is, the idea that you treat a function like it's just any other variable, is supported in a variety of languages. I'm not so sure how wide the support is for doing the same with classes. but that's a pretty fundamental concept, the idea of passing functions around. Let's say you wanted to apply a function to every item in a list (or tuple). You could write a for loop, and call the function on the inside, or you could just use the [map](http://docs.python.org/library/functions.html#map) function, which takes as its first argument a function, and as its second argument an iterable (a list is an example of an iterable). So if you had a list of numbers and you wanted to add one to every single one of them, you could do it manually like this: mylist = [3, 9, 4] for i in range(len(mylist)): mylist[i] += 1 Or you could pass a function to `map`: def addone(x): return x + 1 mylist = [3, 9, 4] mylist = map(addone, mylist) Or since this example is so small, you could use a [lambda](http://docs.python.org/tutorial/controlflow.html#lambda-forms). I'll save it as a variable first so it's a little more clear: addone = lambda x: x + 1 mylist = [3, 9, 4] mylist = map(addone, mylist) But since a lambda expression just returns a value that *is* a function, you don't need to bother to save it anywhere: mylist = [3, 9, 4] mylist = map(lambda x: x + 1, mylist) That's a pretty contrived example, since in Python you could just use a list comprehension anyway: mylist = [3, 9, 4] mylist = [x + 1 for x in mylist] And what is a list comprehension? It just creates an anonymous function out of the expression preceding the `for`, in this case `x + 1`, and then maps it over the list. It might seem like splitting hairs right now, but it makes a big difference if the function you want to use is already available to you, or is something you imported, or if you have a lot of them. If the function already exists in a package and you're just importing it, you can use the named form with `map`. It's quite handy! JavaScript has good support for using functions in this way. That's why this works in JavaScript: var addone = function(x) { return x + 1; } Same thing, different language. If you've ever used jQuery, you've probably been passing functions around for a while without even knowing it. Oh and to your statement about programming in general being INCEPTIONesque, [yes, it's always like this](http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach).
As I accumulate more and more code in Python 2.7 using a variety of packages, the idea of porting is scaring me. 
I suppose something like this would have to happen if projects like Blender want to have embedded pypy right? Sounds like it would be a nightmare for scoping if you had a decorator to hand over to pypy though.
More 2.7 code isn't much of a problem. 100,000,000 lines of good 2.7 code would be an easy port. More code covering wide ranges of versions would be a reason to be a little scared.
This is highly unlikely to be created by any pypy devs. Having such thing would also be a performance debugging nightmare, since the interface speed would matter far too much. Besides, who wants to actually look around and do it? Most python programs are not "few pieces that are too slow" but a complex mess.
That's exactly the point which pops up on the mailing list any time somebody asks about a Python3 port of mercurial: Mercurial support goes back to Python 2.4 (due to RHEL &amp; derivatives still having supported versions running 2.4, and the mercurial crew not wanting to have a *command-line tool* mandate that *tool users* update their distribution), which makes porting to Python 3 much more challenging.
Composable utilities are rather nice (think shell functions). David Beazley has a number of nice presentations on the subject, I *very strongly* recommend perusing his stuff. You can also implement limited coroutines via generators, especially with the newish [enhanced generators](http://www.python.org/dev/peps/pep-0342/)
I'd suggest going one step further and creating a custom descriptor (basically what `@property` does, but with more stuff in). That way you don't have to create a messy `__setattr__` with a bunch of check/dispatch code.
I am quite scared that if there's not a more clear reason to port to 3, and that an official 2.8 never ships, that some enterprising and well meaning folks will make their own fork to be 2.8, and will cause far more damage than good to the community.
Enterprising folks are using 2.5/2.6 :)
Never even heard of EmEditor before now...but...after a quick search the snippets plugin might do what you want. I got that from here: http://www.emeditor.com/modules/newbb/viewtopic.php?topic_id=1054&amp;forum=4
If they're lucky. *mutter mutter 2.3 mutter mutter*
How is having 2.8 going to help with this though? Do you target 2.4-2.8 and then transition to 2.8-3.X down the line? You're still going to have to rewrite all of your 2.4 code for 3.X down the line anyhow and you still can't support both 2 and 3 branches.
I have said before and will say again that Red Hat is one of the biggest blockers in porting more useful tools to Python 3.
Well, a lot of Python packages currently have a few bits written in C or Cython for speed. So I would imagine there would be some demand for using PyPy in a similar way.
&gt; How is having 2.8 going to help with this though? It won't.
SciPy already supports Python 3. Matplotlib will with the next release (not counting bugfix releases). I'm almost beginning to think that the biggest hurdle to Python 3 support is people assuming that there's no library support. The automated tools like python3wos don't help unless people use the correct classifier on PyPI (and they have some other major flaws). I'm manually tracking the status of some key packages in [a google spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AqIElKUDQl8tdC1lR29XZFlxZUxOU1VlZ1JRQ3ZRanc&amp;authkey=CPLS9KMF) - feel free to update it and add to it.
I think that overriding `__setattr__` for that end is bad, for various reasons. The fact that the attribute is special is removed from the place where you initialize/declare attributes, if you try to do something else of a similar nature your getattr will get crowded with stuff, it's not easy to reuse the code, your getattr gets called every time any attribute is changed... Here's how I would go about it: def set_flag_on_modification(private_name, default_value = None, doc = None): '''Creates a property and a function which returns True if the property has been modified since the last call. &gt;&gt;&gt; class Cls(object): ... field, field_modified = set_flag_on_modification('_field', 'default') ... &gt;&gt;&gt; o = Cls() &gt;&gt;&gt; o.field_modified() False &gt;&gt;&gt; o.field 'default' &gt;&gt;&gt; o.field = 'asd' &gt;&gt;&gt; o.field_modified() True &gt;&gt;&gt; o.field_modified() False &gt;&gt;&gt; o.field = 'asdf' &gt;&gt;&gt; o.field_modified() True &gt;&gt;&gt; o.field = 'asdf' &gt;&gt;&gt; o.field_modified() False &gt;&gt;&gt; o1 = Cls() &gt;&gt;&gt; o1.field 'default' &gt;&gt;&gt; o1.field = 'default' &gt;&gt;&gt; o1.field_modified() False ''' private_flag_name = private_name + '_modified' def value_getter(self): return self.__dict__.setdefault(private_name, default_value) def value_setter(self, value): old_value = self.__dict__.get(private_name, default_value) self.__dict__[private_name] = value if value != old_value: self.__dict__[private_flag_name] = True def check_modified(self): value = self.__dict__.setdefault(private_flag_name, False) if value: self.__dict__[private_flag_name] = False return value return (property(value_getter, value_setter, doc), check_modified) if __name__ == '__main__': import doctest doctest.testmod(verbose = True) 
based on Nick Coghlan's comment I'm pretty sure this will never happen. There's always all kinds of "this will happen! that will happen!" from those on the outside but it's the people who spend their time deep in the actual code who really know what's up.
There is not a single argument in that post about why the +1. A 2.8 release seems ridiculous to me to be honest and here is why: The 2.7 branch will be maintained and bugs will be fixed for a long time. So nothing changes on that front. People who do not want to upgrade to 3 will be using 2.7 or lower versions as always. A 2.8 release would bring new features, changes and most importantly another version maintainers of software and packages would have to support. So more work for Armin and everyone else, not less. Now these language changes and new features are packed into Python 3, which makes a compatibility cut that has been long coming and wanted by many. Sure it would be convenient to keep writing only Python 2 code and only having to maintain one code base of your software(s). But my question here is "who says you have to upgrade to Python 3"? Nobody forces you to go Python 3. Stay on the 2 branch. Keep maintaining your 2 branches if you hate Python 3 so much and say it is unusable. Many other people meanwhile stand ready to go Python 3 and are happy to get their code out. Personally I find just the syntactic changes in python 3 very elegant. I always hated the old "%" string formatting and print as a keyword like return didn't really make sense. I like the Unicode support. And I am sure that the Python core maintainers will do their best to iron out some of the problems there are now. I would have preferred for Armin and some others to file bug reports, or feature requests against Python 3 instead of proposing another Python 2 release that would further complicate and split up things. --- Also on a widescreen computer it was very hard to read this post due to the very long lines, I had to resize my browser window. 
I am with Armin on this one
VC is meant to help more than one person work on a specific codebase at the same time (without things breaking), and to make it easy/possible to save/undo your changes to it. 
I'm new to Python, but this is my attempt: def add(x,y): return x + y def sub(x,y): return x - y def mul(x,y): return x * y def div(x,y): return x / y def example(input): assert len(input) &gt;= 2 results = [] for nums in itertools.permutations(input): for ops in itertools.product([add,sub,mul,div], repeat=len(input)-1): i = 0 total = nums[0] for o in ops: i += 1 total = o(total,nums[i]) results.append(total) return results 
Looks like I'm too late, but here's mine anyway: import sys import iterutil dict_file, letters = sys.argv[1], sys.argv[2:] words = {s.rstrip('\n') for s in open(dict_file)} for size in range(len(letters), 0, -1): found = [''.join(a) for a in iterutil.permutations(letters, size) if ''.join(a) in words] if found: print found break else: print &gt;&gt;sys.stderr, 'no matches' I love these little quizzes. Keep 'em coming. :)
&gt; I'm almost beginning to think that the biggest hurdle to Python 3 support is people assuming that there's no library support. The number of people who I've seen use NumPy as their only reason to stay on Python 2 is shockingly large.
Cool - I was just thinking the other day that something like this should exist !
&gt;The number of people who I've seen use NumPy as their only reason to stay on Python 2 is shockingly large. For anyone unsure, NumPy added Python 3 support with version 1.5, released in August 2010. That said, a bit of love from distro packagers wouldn't go amiss (e.g. [Ubuntu](https://bugs.launchpad.net/ubuntu/+source/python-numpy/+bug/795605), [Debian](http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=601593))
You won't see mee disagreeing. And it's not restricted to Python (let alone 3) either, [Perl regularly hit this wall as well](http://www.reddit.com/r/programming/comments/myk9y/goodbye_ill_miss_you/c34w80s?context=2)
Then why should RHEL continue to be supported? Is it better to support 100% of legacy platforms, or might it be better to support 99% of platforms and also move forward aggressively with Python 3? At a certain point, isn't supporting RHEL (and not even the current version, just an old version that hasn't been fully retired yet) doing more damage to Python and Django than abandoning 100% backwards compatibility would? Especially in a world with virtualenv, why should RHEL users who don't want to upgrade hold the community hostage? Even if support for 2.5 were abandoned in future Django versions, legacy RHEL users would still have options: - Stick with Django 1.3 or 1.4 or whatever the last 2.5 release happens to be (presuming that security fixes would be back-ported). - Use virtualenv and install python 3 locally to run your Django daemon (is this so hard?) - Upgrade to a newer version of RHEL (obviously I think this argument applies to other Python libraries as well, not just Django)
If you use Linux it's great knowing python. Half the stuff is written in python and it's all open-source so it's very easy to make changes to correct an issue you may be having, or to tweak something in your desktop environment.
I happen to agree with a lot of what you said. I have to think and read up a bit more but I most likely agree that 2.8 is unnecessary and wouldn't really help things. As for your arguments at the end though, most of them miss the point of mitsuhiko's post. There's *very little* in py3 that made things worse (though despite being small in number some may in fact be quite major inconveniences). Otherwise, yes of course. Everything that was done was in some way done to correct mistakes that were made. One of his main points though was that that doesn't imply any incentive to port, especially when there are little nagging remaining annoyances. &gt; I always hated the old "%" string formatting Well, then py3 won't really help you, since it didn't do anything to it :). Also, people coming from C-like languages probably appreciate the familiarity. (I happen to agree with you though personally, I prefer str.format). Things like, the nonlocal keyword fixed a bit of the scoping issues we had in py2 (partially. Still some rough edges). `print` being a statement made it harder to mock / redirect / test code that used it, besides not really having any good reason to be different. &gt; And I am sure that the Python core maintainers will do their best to iron out some of the problems there are now. I would have preferred for Armin and some others to file bug reports, or feature requests against Python 3 instead Oh? But people have. http://bugs.python.org/issue3982 is the most prominent example that comes to mind since it came up again recently. There are other examples if I thought for a moment. Of course each example bears judging on its own merit, but certainly there is more that needs to happen.
I agree, but I think people encounter the yield keyword versus iterators which are more implicit with for loops and use that as the Google term to learn more. 
Third-party maintenance fork my ass. The people with the technical skills to make that happen are *not* the ones whining because they're too lazy too port their code.
I rarely use anything with X server, but I've been doing a lot of work with multithreading recently and I seem to remember on my blazing trails with google that X does not handle multithreaded applications too well. I may be completely incorrect, and remembering it wrong. But that idea is there! Haha. So, is your application multithreaded? EDIT: Just thinking, that it may be multithreaded without you realising, I can't find where I found the mention of what I'm saying, so put it to the side for now.
The python tutor mailing list is extremely friendly and will be a good place to start while you wait for a mentor Best wishes
&gt; Well, then py3 won't really help you, since it didn't do anything to it :). Also, people coming from C-like languages probably appreciate the familiarity. (I happen to agree with you though personally, I prefer str.format). I know % formating is still around and everytime I use it in C I wish it wasn't. I feel like it should be deprecated sometime in the future as soon as everyone is on 3. After using str.format() for some time now I don't think I would ever want to go back to %, as format is sooo much more readable and pythonic.
Thank you, I was unaware this existed. I will use it while waiting :) 
As a sysadmin you might be acustomed to certificate programms. There is a fully featured Python certificate course on oreillyschool.com. This course was written by Steve Holden who is the chairman of the Python-Software-Foundation. I have a similar background as you and this course made me a programmer, i loved it and it taught me a lot. If you go that way then google for promo codes before purchasing the courses, this can take off 20 or more % if you're lucky.
&gt; I feel like it should be deprecated sometime in the future as soon as everyone is on 3. I would prefer it remained available. The new string formatting is much more powerful, but for the many trivial cases, % saves a fair bit of typing. Removing it would also kick off another major round of backwards incompatibility.
OK, sure RHEL sucks. How does Python 2.8 change that? If you can't run 2.7 on Red Hat, you're not going to have any better luck with 2.8. I haven't seen any clear explanation of what problem 2.8 would solve, since all the problems come from wanting to be able to support 2.3 and the newest version at the same time. The core to all of the complaints about Python 3 come from not wanting to support a 2.x version and a 3.x version of the same thing. Otherwise, it's just a matter of pushing through the pain of porting and you're done, no more complaints. If anything 2.8 makes the problem *worse* because it extends the amount of time you would try to do a simultaneous 2 and 3 release.
You might have a point here. I tried very similar C++ code and got the same error. :(
Wow. That was very well said. Thank you very much. I'm just finishing up finals week and take my lab test for Python soon. :)
Have you looked at sympy? It does symbolic algebra calculations in python.
No matplotlib support. Havent tried with sympy in a while, but last time I did, it did not work. Then for us biologists, the legions of more specialized tools. 
Side note for anyone considering learning emacs past the basic text editing level: in my opinion, comparing emacs to other text editors is misleading. Emacs comes with many built-in primitives that make it amazingly convenient and flexible for editing text, but "primitives" is the point: emacs is not a text editor, it's a realtime lisp interpreter. A simple cheatsheet can totally eliminate whatever learning curve a new user would have to master to be able to edit basic text; but learning a little bit of very intuitive emacs lisp and the few commands you need to modify your running emacs with your own lisp is...a totally different paradigm. I'm not saying it's better or worse than other text editors, I'm saying it's a lisp interpreter that's particularly convenient for working on text. Being able to rewire your editor in realtime to do exactly what you want it to do with your own files, whatever they are, makes the whole keystroke-learning-curve question seem to me to be almost beside the point. Again, I'm aware that these observations are a little outside the scope of the OP, but if s/he/anyone else is curious about emacs for coding, hopefully this helps.
It's not in an official release yet, but 3.x support was recently merged from [this fork](https://github.com/matplotlib/matplotlib-py3) to [the main repo](https://github.com/matplotlib/matplotlib). Edit: [this great site](http://www.lfd.uci.edu/~gohlke/pythonlibs/) has a matplotlib [1.2.x Windows installer for 3.1 and 3.2](http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib), probably based on the above repo.
best of luck! If this stuff is new to you, read more code. Most people spend all their time *writing* code and never *read* code. You can learn a lot by reading the source to libraries you use. I like to read the Django source, because I use Django a lot. Whatever you use, read the source! You'll learn a ton.
Use [virtualenv](http://pypi.python.org/pypi/virtualenv). You can create a separate environment for each version of python, and pip will use the one with which that environment was configured.
I'm not sure how you can proceed, there's also a possibility of *not* using QRubberBand, or looking on the bug tracker for any work arounds for it. This is presuming this is even a bug with X and not your code/install. What I suggest: Try using a VM of your OS *inside your OS* running the same file, *from the same location*. What I'd suggest, 11.10 Ubuntu in a VM, inside Ubuntu 11.10 with the prerequisite packages for Qt and the rest of your app, then just access the same application using the host filesystem, if it runs and there's no problem, then it's *your* install and not a bug, if it still doesn't run. Link me a to a repo with your application and I'll run it. If it's the latter option, please, for the love of $deity please include a dependency list.
What are you talking about? This sounds like complete FUD. There are thousands of multi-threaded/multi-process applications that run on X without issue. I don't know what the problem is here, but you can be pretty confident that X 'doing threads' is not one of them.
numerically 2.8 is nearer to 3 perhaps sp feel that is a smaller gap to bridge
Hence me saying to take my advice with a monumental grain of salt.
Cool. I am using Windoze single-boot right now but just haven't gotten around to fixing that since I got the new laptop. Windoze/Linux/OSX triple boot is what I'm going to go for. Just 'cause... I don't need it for anything in particular!
Sympy also has support coming in the next release. Biopython mostly works with Python 3 already. More specific tools probably haven't been ported, but it will probably be easier to get them working.
The need to keep 2.6/2.5 support in libraries is one roadblock to getting more community support. It's much easier to write code with Python 2.7's stdlib ports (io) and 2to3 hints (e.g. b""). 2.6, not so much. 2.5, horrible. Oh CentOS, why did you have to use Python 2.6 in your latest release. :(
I don't think this is remotely correct. I don't think a fork will happen, but I don't agree at all with the assertion. There are plenty of developers talented enough to do so that aren't porting their code, and it's disingenuous to call people "lazy" for not porting.
How is the performance of a Pyramid app running in Python 3 compared to the same app running in Python2?
If it is multi-threaded, are you calling setGeometry outside the main UI thread? That's a no-no if you are doing that.
From what I understand, Python 3 uses a bunch more RAM. Not sure about speed though. I don't think pypy supports python 3 either which is probably the faster version of python.
I think my question was not good. Is there any issue with the port to Python3 from a performance point of view? edit: "?" instead of "."
Supporting 2.6 is mostly not too bad - it has things like b'' and the io module. For IPython, we support 2.6/3.1 and above without too much hassle. Supporting 2.5 and older quickly gets very ugly, though.
What's the main UI thread? I have one QApplication running one QMainWindow. This QMainWindow contains a QWidget which in turn contains a QLabel. In this QLabel, I have implemented mouseMoveEvent to setGeometry of the QRubberband.
That's how I tested on Ubuntu 11.10 and 10.10. I mounted the folder and ran the same file. No bug. However, the program is not installed per se, I simply run main.py. The dependencies are python-qt4 and python-poppler-qt4 (no package, I installed through pip) and they were exactly on the same version I tried in the 10.10 VM. In any case, you're welcome to take a look. The code project homepage is [here](https://github.com/cako/notorius/tree/experimental) (experimental version), the specific file is [window.py](https://github.com/cako/notorius/blob/experimental/src/window.py) line 412.
If it's just what you might have heard or what you definitely don't know about, why even speculate about these things?
Why was Python 2.5 support removed? The 2.7 runtime is still not really useable on GAE. Were there irreconcilable problems in adding the 3.2 support or something?
&gt; Also on a widescreen computer it was very hard to read this post due to the very long lines, I had to resize my browser window. Poor you. I suppose a max-width attribute might have been useful, but it was refreshing to see a page which actually filled the browser window and with text that flowed properly.
I hate that meme.
Mostly this was to ease the Python 3 port. Pyramid 1.3 isn't out yet, maybe GAE will be ready by the time it's released. Regardless, you can always continue with Pyramid 1.2.x if you must stick with 2.5.
You're right, it was probably a useless comment... Oh well.
sorry but you lost me there...
I will check all of this. Just a quick question though, is it possible to add new paths to the pythonpath?
One line. import sys, itertools; print(reduce(lambda a, b: a + [b] if (not a or len(b) &gt;= len(a[0])) else a, sorted(set(w.lower()[:-1] for w in open('/usr/share/dict/words')) &amp; set(''.join(w) for w in (itertools.chain(*[itertools.permutations([c.lower() for c in sys.argv[1:]], i) for i in xrange(1, len(sys.argv))]))), key=len, reverse=True), []))
&gt; Poor you. Oh, don't worry about me, I can handle. There is always a way for me to fix websites so even I can read them. ;) Seriously though: Line length is even in PEP8 for a reason. Here is a [Link](http://www.wmich.edu/writing/typography.html) about the topic, see the paragraph "Line length". Full width text on websites really only works on smaller screens. On my widescreen it is unbearable (for me at least) to read what should be a paragraph all in one line.
Syntactically it's correct, and also I'm at fault because I'm trying to write code that works on both Python 2 and Python 3 without any changes, as opposed to having separate .py files for Python 2 and 3. There's no way to gauge the intent of the developer, which is why there's no warning.
Upvote for teaching me about an awesome feature of the lambda syntax.
&gt; Removing it would also kick off another major round of backwards incompatibility. Yeah, that's the real reason it won't go away any time soon. 
Awesome. I'll have to try this out! Thanks for all of your contributions, Al.
 import sys sys.path.append("path/which/i/want/to/use") 
Funny this pops up today. I just started with Tkinter 8.5 in Python 2.7, and I getting frustrated. This also happens to be my first adventure into GUI programming. I look forward to a few responses. BTW Here's my calculator I'm building: http://i.imgur.com/ldoDQ.png 
I've heard decent things about wxPython, but I'm a big KDE user so PyQt feels a lot more at home for me. Designing forms in QT Assistant is fairly easy and the program I'm working on looks good on Mac, Linux, and Windows (although Mac support requires Fink or MacPorts to get PyQt working properly).
People also work their hardest to defend the right to be lazy.
First off, congratulations to you and the rest of the Pyramid team...you guys are fucking awesome and it's apparent you guys put your blood sweat/beer and tears into this project. I was wondering if you could weigh in Armin's [post](http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/) from the other day regarding Python 3 porting. Did you guys experience the same type of hardships Armin talked about in his article? For example, did you find yourselves having to work around Python 3 rather with with it? Or was it a pretty successful transition? 
since the old style classes were entirely removed in Python 3, i would think that they would get deprecated with warnings first.
It's an editor with elegant unicode support and unicode display. Thanks for the tip anyway :)
While I agree that there probably won't be much reason to create a 2.8, I think things like PEP 404 that insist there will absolutely never be a 2.8 are a bit premature. It seems to me it would be good enough to say "We have no plans to ever release a Python version 2.8," leaving the possibility open if there's ever a very compelling reason to create a version 2.8. As it stands now, if someone ever has a very compelling reason to create a version 2.8 it still probably won't happen. Regardless of the technical merits of the potential update, too many people would have egg on their face to admit that it might be a good idea.
If you're doing string handling, Python 3's ubiquitous use of 16 or 32 bit arrays can be a problem. Python 3.3's new use of the smallest possible array type solves that problem. Edit: Python 3 support for PyPy is a work in progress. They need more funding, though. It's an immense task.
I occasional stalk the OP, apparently. Here's a previous post of his where he describes the overall [2 to 3 porting experience](http://www.reddit.com/r/Python/comments/krk9w/how_many_people_actually_use_python_3_on_their/c2mnmsp), including Pyramid's. I haven't read Armin's post as of yet. from the link: &gt; Because the result has to run on Python 2 as well, I don't get any immediate benefit from being able to use new language or library features. The work itself was a pretty thankless slog, too, not much fun at all.
Tkinter is probably the worst choice if you want its appearance to look native on other platforms. Most everyone is on board with wxPython (which is decent, and has lots of good sample code, and good docs, looks good cross-platform), PySlide/PyQt (lot of users developing Mac and/or KDE stuff as Qt is native, decent quality cross platform), or GTK (built-in on most linux desktop distros, good native look on Gnome, not bad cross platform)
It's a single codebase so it's written in a subset of Python 2 and Python 3. To that extent, we obviously don't use any Python 3 only features. Porting to the subset language was not rocket science but it was frankly harder than it needs to be and the result is uglier than it needs to be. I'm not much looking forward to porting all my code to that subset, but I'm not sure I have much choice if I want Python to be around for years to come. That said, the port has actually been finished now for about 2 months, and I haven't had much of an issue maintaining Python 2+3 compat while making changes in the meantime.
What are some of these tutorials for wxpython? The video series I am watching on youtube has examples that dont work.
Small Pyramid apps running on Python 3 seem use about twice the memory and run slightly more slowly than the same app on Python 2.6 or 2.7.
How about web based UIs?
I've spent the last year on and off (mostly off) learning python before doing any GUI stuff. At first I tried Tkinter and thought it was terrible. I then quickly switched to wxPython and I've been using it since. 
No real tutorials, but if you install wxPython-demo it comes with tons of sample apps of all the widgets and features. Documentation comes with the package, and the demo code is documented decently enough. There's been a book or two written around wxPython as well. And the C++ to Python translation is fairly 1-to-1, so if you can read C++ code samples/documentation that's out there, you can generally translate them pretty easily into Python.
I like PySide (QT4). Doing various searches such as "python gtk vs qt" always turned me to QT. 
Bad thing with wxPython is that still it does not have py3k distribution. The Phoenix project is active but afaik there is not an official roadmap for that. If the situation persist much longer the risk for wxpython is to lose users in favor of pyQt the other decent framework that has had py3k version from many months ago. That really bad in my case as wxpython is my choosen framework and the one I am proficient. Unfortunately, in this computer, I only installed py3k. If Robin Dunn is around maybe he could update us on the situation...
Mi advice is to get a copy of the book wxPython in Action. That is the wxPython Bible. The New Testament would be the wxpython demo that comes in the wxpython docs and demos package
Larry Wall and others have made the haha but serious joke that laziness is a virtue for programmers, and that is, sort of, true, but the laziness should be in terms of saving effort by making things easier. That's what the print function is! It saves you the effort of having to use the awful print statement. But what about the parens? Well, that's not just a problem for `print` of course. Python is littered with parens! Ah, but here is where laziness helps. Laziness causes you to expand the scope of you expand the scope of your problem. The solution to parens being a pain to type is to use autocompletion for functions and autopairing for parens and other kinds of brackets. Laziness can be good but laziness has already solved the printing problem. Further laziness beyond that is counterproductive laziness. ;-)
pyjamas (pyjs.org). Write code, run on both desktop and web.
I disagree, if you use Tkinter wisely, for small applications you can get a native feel.
wxPython is very popular but personally I don't like it. I always found that coding in it felt unintuitive, although I'd struggle to explain why. More importantly, I have noticed when working with wxPython that some errors can cause the interpreter to segfault rather than produce a traceback. This is extremely frustrating and you lose one of the main benefits of Python, which is excellent error handling. Personally, I quite like tkinter, or at least I don't think it quite deserves all the hate it gets. I find that it is easier to code in than wxPython. Furthermore, it works on Python 3 (unlike wxPython and pyGTK), and because it's part of the standard library you can use it without introducing an external dependency for your program. The main concern raised against tkinter is its look and feel. First of all, I have found that even in its default setting it looks pretty okay on Windows and Mac, it's only really Linux where it sticks out as looking non-native. Second of all, tkinter is highly customizable so you can get it looking just how you want it to look.
Unfortunately it isn't possible since the same syntax used in Python 2 for the old-style classes is used in Python 3 for the regular (formerly called "new style") classes.
&gt; Oh CentOS, why did you have to use Python 2.6 in your latest release. :( Because its an improvement over their September 2011 release of CentOS 5 with Python 2.4. If you don't want to be a decade behind, don't run Redhat/CentOS. (you can always install a current ActivePython or EPD on a CentOS box, because Python is designed for co-existence) 
Maybe the downvotes reflect the lack of any real criteria and information towards evaluating the choices? Just a thought.
You guys are worried about "Native Look". I just want to hack something that works, so I'm using EasyGui. It's very limited, but really easy, and does the basic stuff.
A hundred million lines?
Fine. Maybe just 90,000,000.
Classic strawman. sporkexec is calling the people calling for a 2.8 &amp; generally having a whinge about 3.x lazy, not those who have deliberately decided to stick with 2.x. There is nothing wrong with sticking to Python 2.7, it'll be supported for a long time. 
In particular, Python 2.5 does not support b'' notation (for bytes), so it's pretty sucky to need to support it. There are other issues too, but they're too boring to talk about. ;-)
I like your's the best. I came up with the same thing except I didn't use Python's find method and used a hash map instead to lookup if a word's letter is in the set of the given letters - which is faster. https://gist.github.com/1454697
well done :) looks awesome.
PySide. wxPython is probably the easiest to get used to. But, and this is a big DAT ASS of a but, it's starting to show its age. No decent GUI editors, and beyond the basic stuff it really has its limitations. Has a good following though, plenty of documentation out there. When I started getting frustrated with wxPython I moved over to PyQt, and then finally PySide. PySide is LGPL, and it is the best effort in making a Pythonic GUI. Check out "Rapid GUI Programming with Python and Qt". Also don't forget QtDesigner where you can create ui files that are easy to import in PySide. Much more modern work flow compared to wxPython. Plus Qt is much more maleable than wxPython.
There're three top candidates. All are bindings to C or C++ frameworks: PyQt/PySide (differences mainly in matureness and license), wxPython and PyGTK. All three are proper GUI frameworks in opposite to an web-technology based ui, therefore user experience and performance are superior. While all of the three are good choices, I absolutely prefer PyQt/PySide. Performance is unbelievable (you can handle trees with &gt; 100000 rows easily), huge featureset (stylesheets, ActiveX support, Signal/Slots, GraphicViews, ... lots of cool stuff) and great documentation. Wether you choose PySide or PyQt mainly depends on your license restrictions. PyQt is certainly more mature, but on certain circumstances you have to pay for it, which (under certain circumstances) makes sense. EDIT: I have to add that there is a certain learning curve. For PyQt there's a very good book http://www.qtrac.eu/pyqtbook.html and some nice online tutorials http://zetcode.com/
pygobject with gtk3 and gobject-introspection works with python3
Resfreshing to see the positive attitude.
As a side note, I think we're working on similar stuff. I'm currently creating a pdftotif converter with some business specific features, I'm using ghostscript for the heavy lifting, is there any reason you chose ImageMagick over ghostscript? I'll clone that repo later today.
The way you are doing paths with only work on windows. Instead of using "\\\" use os.path.join().
But why would you want huge browser windows full of not text? Much better to have two side-by side windows with actual information. Optimally, I think pages should be written to flow within the available space, but with a max-width attribute to avoid text that forces you to swivel your head and reach for the readability button. (BTW, I massively break the 80 character column limit of PEP8. My ultra-portable 12" laptop comfortably shows 120 characters with a system navigation on one side and an IDE navigation panel to the other. But that's not continuous text and you don't read it as such)
I'm using matplotlib in python 3. There are already packages for windows from some months ago.
All those have python 3 support at least in windows
Qt Designer is great and mature tool for visually designing your forms. It saves as a QML file and can be 'compiled' into python classes using pyside-uic script (or the pyqt equivalent). So while this Qt SDK tool is not python specific, PySide comes with the necessary tools to allow you to make use of it. Which is a win for PySide. I've never found any mature GUI designer for GTK (Guile comes to mind, but not that great.) Did I mention full windows, mac os X and linux support (the toolkit AND most important the developer tools!)?
Just noticed that there is a separate download for the docs and demos. Thanks for pointing it out.
Good :)
I prefer PyGtk, but for a few specific reasons which won't apply to everyone. Firstly, PyGtk is very close to the C library in terms of how you structure your code. If you're a C-style programmer rather than C++/Qt, PyGtk will be much easier to get into. Next, PyGtk seems fairly standard on any Linux box you come across. It is, however, a PITA to get it going on Windows, but once you've got it, works fine. Finally, it's good enough. I can't speak about performance, but if that's super important, Python/C is pretty easy. PyGtk gets the job done, and the toolkit is pretty mature. Their python binding has better or as good documentation as the C side, and there are buckets of tutorials. I haven't had any experience beyond hobby coding, and none with GUI designers, so take my recommendation with a grain of salt, but itworks fine, and the documentation is great. 
Qt on KDE is just sublime, IMHO. There are tonnes of extra widgets than on other platforms, I get a bug on ArchLinux with QtDesigner though that I've still not managed to fix. It crashes on save/load dialog.
Don't you think that that signal/slot mechanism of Qt is literally the greatest thing ever?
This. I remember a while back I was lazily using `\\` to join paths on Windows, cue 3500 lines of code, get cross-platform feature request and my life was literally hell going through and changing that.
Look up PIL, it can save a region of an image to a separate file IIRC.
First I started using imagemagick a as fallback, but then I started using it because it can add borders to the image. The Windows version doesn't use imagemagick, it only uses dvipng (because I couldnt get it to work properly with imagemagick). Is there a way to do something similar to convert -bordercolor white -border 10x10 filename_png filename_border in ghostscript? (Or even the standard library!?)
You could try installing [distribute](http://pypi.python.org/pypi/distribute), after that you will have an easy_install.py script somewhere, and then you can use that to install numpy with something like this: &gt; cd portable-python &gt; python scripts/easy_install.py numpy
Sadly it isn't maintained anymore..
What exactly will that do?
I made an application that needed to be cross platform(linux/mac) and integrate with matplotlib. I ended up with Tkinter. It was a little painful at first but it ended up having everything I needed. There was no GUI builder, etc but it was a fairly simple app and Tkinter(8.5) ended up having everything that I needed.
would I need to specify the coords in a tuple or by clicking on them? 
How exactly would you click on the image *inside code*? I hate to be blunt, but of course it'll be in the code, via a tuple or what ever the library requires.
[This](http://www.pythonware.com/library/pil/handbook/image.htm) is what I was talking about, the crop method.
I'm using Portable Python with numpy, scipy, matplotlib, etc. You can just copy the libraries to your site-packages folder and add them to your path file. I dk about doing any of this with python 3 though. I'm still on 2. I'm pretty new to python, so sorry if anything here is wrong or stupid. 
Ah yes I know about that method, what I'm looking for is an easy way to find the coords that specify the box to crop out
I matplotlib you could zoom in on a part of an image, I am looking for a way the get the coords of the zoomed in image automatically. 
Are you using some GUI application with matplotlib that you got from somewhere? If so, I'd reimplement the zoom so that it displays the top-left co-ord when you zoom in. A link to some code would make it easier to help.
I presume you're using [this](http://matplotlib.sourceforge.net/examples/event_handling/zoom_window.html) as a way of zooming in on the picture. Right, the centre co-ordinate is already there for you, I'm sure it would be trivial to work out how to go from there, to the top-left x,y and bottom right x, y. 
This is exactly what I was looking for! :) thank you. you just made my saturday
No problem! :)