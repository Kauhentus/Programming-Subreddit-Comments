Thanks! Something similar... I really like [wxGlade](http://wxglade.sourceforge.net/) simplicity. It can generate Python, C++, Perl, Lisp and XRC wxWidgets/wxPython bootstrap GUIs. Changing the GUI after a bunch of code has being added to the generated project might get tricky though. Fortunately the code generator adds some helper comments (something like wxGlade code starts/ends here lines) on the hard GUI parts, so merging an upgraded GUI is not really that hard. Not quite WYSIWYG during layout (as the sizers settings for relative layout GUIs is not handled perfectly), but there is a quick 'Test' button that shows you the real thing before generating anything ;-) Best of all, it's coded in Python, feels easier to create custom widgets, some few [here](https://sites.google.com/site/lvmarcoux/Home/wxglade) ) Just make sure to use the Mercurial repo code for the latest and greatest fixes (BTW, in case you didn't nottice, it uses [wxPython](http://www.wxpython.org/)). 
The computer science course at mit. ocw. Edu is also an awesome resource for cs and its in python. 
Boa Constructor is great in my opinion but it stopped being updated and people recommend against using it.
I would look at **Pelican**, It's a static blog generator and uses both Rst and Md for the content. Its fairly easy to setup and has decent theme support. Also, there are a few people on irc that can help out, I'm usually on there myself. You can go to #pelican on Freenode. If you have any more questions, PM or feel free to message the dev via Email or message him on his Github page, he's good at getting back to people.
Yes! You could design your UI with Qt Designer and QML/Qt Quick. You could then reference this code from your Python application and add the relevant logic (in Python). This was my idea at first though. Anyone have a better solution using Qt?
No probs mate, sorry wasn't calling you out! Its just that after 10 years of php... it seems the easier route.. and it is.. until things get slightly more complicated.. then bring on a real language/framework cos even the best of breed php frameworks (symfony,codeigniter,cake.. perhaps not so much symfony2 tho) are quite lacking. I code php for bills and django/flask for fun (and other bills) and i wish I had gotten into python 5 years ago! :)
That's because the poster is looking for a Python take on the one good part of MS VB (the V) and not the awful parts (the MS and the B).
why is having a single file a "feature"? sounds like a bug to me
a brief but nice article about using memory mapped files with the mmap package.
Exactly. Why write a proxy when good ones already exist? I'd go for squid and a simple python ICAP server which would serve all of the image manipulation, 'inject()' functions, etc.
Memory is addressed in bytes, not bits. One combines shifting (&lt;&lt;, &gt;&gt;) and bit-level logic operations (~, &amp;, |) to get/set a subset of bits from a multibyte register. For little endian, bytes are addressed from lowest to highest. So a 16-bit word is byte0, byte1, and a 32-bit long is byte0, byte1, byte2, byte3. If you're making a bitstring, you can simply reverse the order of the bitstrings for each byte (after padding with 0s), and then concatenate (i.e., 0..7 + 8..15). Then index 0 is bit 0. &gt;&gt;&gt; b = b'\x01\xD0' # 0b1101000000000001 &gt;&gt;&gt; bin(b[0])[2:].zfill(8)[::-1] + bin(b[1])[2:].zfill(8)[::-1] '1000000000001011' #or simply &gt;&gt;&gt; from struct import unpack &gt;&gt;&gt; bin(unpack('&lt;H', b)[0])[-1:1:-1] '1000000000001011' Edit: As you know, you'll need to also use `ord` for Python 2. 
Glade is pretty nice :)
I've written a few different applications using Glade, both in C and in Python. I like it a lot and it keeps getting better all the time! Hopefully it'll be easy to use with Python 3 soon thanks to GObject Introspection.
I suggest learning Tkinter as it works out of the box. ---------------------------------------------------- Here are some options you might want to look at if you need a program to help you layout your gui. Page http://page.sourceforge.net/ Rapyd http://www.bitflipper.ca/rapyd/download.html Here are some other resources I posted previously. http://www.reddit.com/r/Python/comments/i9rzj/are_there_any_good_python_3x_books_for_tkinter/c221yc5 ---------------------- What exactly do you want to code up? 
Just noting that if you have multiple jobs it *might* not be `%1`, but something different altogether
But if you don't have the GUI interface it is useless
[sprintf](http://us.php.net/manual/en/function.sprintf.php)
I gave up after struggling through versions 0.9, 1.0, 1.1, and 2.0. (Not even counting 1.5!) I'm glad your experience is better these days but I got tired of nobody having a clue what it should be doing and never being able to agree on a consistent strategy that would last across upgrades, meaning the docs were always out of date and lacking.
Wordpress, 'a bloated piece of crap'? What? It sounds like you didn't even spend 2 minutes trying to configure it. If wordpress (probably without caching) is too slow, nothing will prove fast enough. Learn to use some kind of caching or everything will be painfully slow.
This is all fine and dandy, as long as you're not writing code that's going to get delivered onto someone else's RHEL 5.X host. You can't really say with a straight face that my Python script now requires its own install program that builds and installs Python 2.5+. 
Probably Powerpack, as it is under active development, and I think more modular and flexible.
This kind of thing has been done before as an art project, probably in Python, as Stani Michiels, the creator of the nomadic "Copacabana Cybercafe", is a Python programmer too. If I recall correctly it would change numbers, yes would become no, right left, etc. It's hard to find much in English about it, but this has a snippet: http://www.mysouthend.com/index.php?ch=news&amp;sc=&amp;sc2=news&amp;sc3=&amp;id=67453 and this too: https://yummyapplepie.wordpress.com/2006/12/19/pun-meeting-at-a-farm/ 
I wasn't really talking about performance, but yeah, if you compare a Wordpress app and a django app clearly django will win (even with caching, wordpress is slower, at least from my experience) But that wasn't really what I meant when I said bloated, maybe bloated is the wrong word. Have you tried writing a wordpress plugin?
&gt; I can't think of any reason why you would want to allow execution of one opcode to see an inconsistent interpreter state due to concurrent execution of another opcode. It's not that you'd want to allow that as such - it's that disallowing it is expensive. Hence 'have the liberty of not being atomic'. In theory the opcodes don't interact directly, so they could operate in parallel, if you're careful with the stuff they operate on.
i never had an experience with tg 0.x and 1.x. i used 2.0 back in the day without any problem and couple of days ago i have just typed a "paster quickstart myproject" (tg 2.1.1) and it went very well so far. it's gonna be up and running next week. the current turbogears project team is determined. they will provide better sources, better documentation, better tutorials, better tips and tricks. they will release often, release early so turbogears is getting way much better. all i can do is supporting the team, encouring python web developers to use turbogears. let me talk about pyramid too. i like pyramid, it is really good with it's "pay for what you eat" philosophy and its awesome documentation. also the support on both the mailing list and irc is great however i don't know why but pyramid feels like something's missing. i know it's stupid but this is how i feel. however while django, ruby on rails or turbogears is overkill for a project, i know i'm definitely going to use pyramid.
Yep, in fact UTN as linked above uses Squid.
That's what I'm using ATM. Add Aptana Studio to the box, and you have a really good development toolbox. OTOH, PyQtDesigner would be a badass invention :)
You can match on different type constructors of the same type. data Tree a = Leaf a | Branch (Tree a) (Tree a) descendLeft (Leaf a) = a descendLeft (Branch left right) = descendLeft left 
Now updated to the main KA site, along with a site makeover. Nice!
Sockets and HTTP requests would be a great place to start. 
Yeah, twisted is really annoying in that it doesn't abstract any of its tools really. :(
When the internet connection has no password everyone can connect to it but that doesn't neccessarily mean the router doesn't have a password either. The router can be password protected whilst the internet connection is open.
InstantPress is fantastic: http://code.google.com/p/instant-press/ 
Just a side note. "%.2f" is not actually rounding; more of specifying a display representation...
Privoxy could probably be modified to some extent to point all images to a server that is controlled by a python script which could handle fetching of images and stuff. Maybe a couple trolling privoxy scripts would be a better route?
Nope, just setting the gateway through DHCP is enough.
If you are working with databases, you should check out Dabo: http://dabodev.com/ It is actually designed to be like Microsoft Foxpro and uses WxPython. It has a GUI editor to build your forms and link controls/fields to the database. A GUI report editor is also provided. It even has an appwizard that you can point at your database and it will build you a working database application in less than a minute! Then you can go customize it to work the way you really want it to.
Requires Python 2.7 for the new collections module.
This is called *string formatting*.
screen ! it allows you to disconnect and reconnect to "terminal sessions." it also has features such as multiple windows within a screen. i use this constantly with computational chemistry runs (take quite a while)
screen would be ideal if you want to monitor each one's output individually. Or you could redirect each one's output into a log file and then use something like multitail to watch all the log files at once. Or you could even run them all in the same terminal by appending an ampersand to each command -- this will run it in the background. However, their outputs will all be mixed together and it would probably be confusing.
Comparing a full-featured blog platform with a django app is comparing apples and pears, since the django app is usually only a few of the features covered by WP. It's a bit like writing a 10 line php-mysql blog and comparing simple page load times (or the number of sql queries *etc*) with wordpress and making the conclusion that wordpress is slow. If wordpress is that bad, *why is everyone using it?* Srsly. Yes, I have. It was quick and very, very simple. Except for the PHP part, tho. Btw, I've tried a few django blog engines, I've written on or two myself, and I've tried the static site generators. Nothing really compares to WP in terms of features, ease of use (not just *user friendly*, but *how hard can it be to write and publish an entry?*) and deployment. I hate php, but wordpress rocks.
exactly what I was looking for, thanks!
Consider the possibility of folks *not* preferring Python for UI development and leaning towards C#/Java.
Twisted is a huge toolset that simplifies the crap out of networking. I've done low level sockets, its fun, but its really easy to get lost among the details. http://krondo.com/?p=1209
That is how you do it. Design in Designer then use pyuic to generate the python for the form. Then in the application file import the form and write the functions and the main loop. With this separation one can change the form design in Designer with out effecting the written code. I do a lot design changes to my apps, they evolve. Eric ide ties all this together nicely with dialog generators etc.. It is a very productive environment I have written a Point of sale system with it. In very little time. 
[tmux](http://tmux.sourceforge.net/) is an alternative to screen. I've since stopped using screen altogether.
I +love+ screen. I've not used tmux yet - why do you like this more? I've read the FAQ but would be glad to hear why you switched.
Well, first off I'm a BSD guy and this is included by default in the OpenBSD base install. Second - it's BSD licensed (I try to avoid the GPL as much as I can). As for the technical merits, there's a [few](http://is.gd/2d99Xc) [posts](http://is.gd/9eQZKk) that elaborate on that better than I could. tl;dr bsd-licensed and IMO is cleaner.
Boa was always heavy on potential. I don't think there was ever a time when there wasn't one glaring bug or another which kept me from really wanting to distribute anything made with it though. 
while screen is a good idea, it does require you have screen installed and once screen is closed, all your output is lost. so a more basic (possibly more reliable) approach (as mackstann mentions) would be to redirect each of the scripts' stdout to files and simply tail/cat the files to see what's going on. also you would have a nice record of everything that happened for later. of course you could also adapt your scripts to write proper logfiles with timestamps per line and what not using the logging module (http://docs.python.org/library/logging.html).
are you double buffering?
[Kiwi](http://www.async.com.br/projects/kiwi/) allows you to hook up code to a glade-generated interface very easily. Basically you write a class that represents a form/window and define methods on the class that correspond to the events. For instance, an interface with a reset button called "btn_reset" would be handled with a method "on_btn_reset__clicked(self, widget, data)" Developing applications with it is very rapid, I've found.
Not that I know of, I'm directly updating via [engine.screen.py redraw() and update_window()](https://github.com/Teifion/sequtus/blob/master/engine/screen.py#L33). How would I go about double buffering, just create a new surface each time and draw everything afresh to that (thus I assume causing a notable performance hit)?
Keep in mind running processes manually in screen means they won't come back up if the server has to reboot for some reason. A more reliable solution is using logging and possibly PID files or process monitors.
Uhm, write them all to a buffer then flip the buffer. import pygame SCREENSIZETUPLE, BGCOLOR, FRAMERATE = (640, 480), (0,150,0), 60 pygame.init() clock = pygame.time.Clock() surface = pygame.display.set_mode(SCREENSIZETUPLE) while True: surface.fill(BGCOLOR) #doLogic() #drawStuff(surface) pygame.display.update() clock.tick(FRAMERATE) There you go, some really short runnable example code.
The idea behind double buffering is that you have two virtual "screens", you show screen A, and write to B, then you flip them; the graphics code will draw B and you write to A. this prevents flickering. http://en.wikipedia.org/wiki/Multiple_buffering#Double_buffering_in_computer_graphics http://pygame.org/docs/tut/intro/intro.html (search for "double buffer")
Very useful, thank you for that, it combined with Leav's post solves my problem.
This combined with Ran4's post has solved the issue, thanks.
A slightly different but related question: is there a way to send a signal to a running program and have the program trap it and print a status message? Something like using Ctrl-C to generate KeyboardInterrupt, except that it wouldn't interrupt the thread, just temporarily pass control to a callback function.
Wow, thanks a ton. I was planning to look into your code for a research project on neurofeedback. Transforming low-frequency EEG measurements into audible regions isn't easy, and paulstretch gave me the best results by far. Being a C++ noob, I spent the last 5 days examining your code (and learning C++ terminology). I was ready to give up, when I saw this entry. The python version is sooo much easier to understand! The Matlab implementation should be finished tonight, contact me if you're interested in the result ;)
If anyone has suggestions or feature requests let me know. Or just fork.
just out put to a file, and when you want to check just "tail filename" remember to unbuffer or flush your output and you should be good to go. prompt$ nohup ./proga &gt; proga.out &amp; prompt$ nohup ./progb &gt; progb.out &amp; prompt$ nohup ./progc &gt; progc.out &amp;
Nice. I am working on something similar except it's analyzing friends' data using FQL. I haven't released it yet but here are [some screenshots](http://imgur.com/GzjUG&amp;lCS12l).
Great idea, will be looking at this later!
Cool. I think it might be cool to make one of these libraries more generic, allowing someone to hook in data from any service and easily analyze it.
I've ripped out the ExtJS library and replacing it with jquery + jquery UI. ExtJS is nice, but I don't have time or interest at the moment to learn the newest version.
Yessir, it's even in the standard library. Check out the docs http://docs.python.org/library/signal.html Some care is required though, as signals inherit many of the same problems as threads because of the GIL. 
I need to revisit QT as an option. Are there any other good Pyside links you could provide?
What's nice about Django is that you can then go and change whatever the hell you want. You could even write your own CMS in a reasonable amount of time (or edit the existing one, seeing as how it is all just python code.)
You should use vizster (http://vis.stanford.edu/jheer/projects/vizster/) if the downloaded fb profile has "Your friends" in a sane format. Does it? Else you could make an fb app to read your facebook friends and make a nice visualization using vizster. 
It's not the same as calling `str(round(x, 2))`, but it does round to the given precision according to platform/version rules: #win32 python 2.5 &gt;&gt;&gt; print '%.0f' % 1.5; print '%.0f' % 2.5 2 3 #win32 python 2.7 &gt;&gt;&gt; print '%.0f' % 1.5; print '%.0f' % 2.5 2 2 
If you consider a HTML &lt;table&gt; a sane format, then yes. The problem is that when you download a Facebook profile the it only gives you a list of your friends, and no data about those friends' friends. So to create a network graph like vizster you'd need to get more data via a Facebook app (not sure if you can access friends' friends in an app?) or do some good 'ol scraping. 
So are you just saying that where two threads don't happen to access the same memory it would be better if there was no overhead? That sounds great, but in Python two threads emphatically can accesses the same memory, and in general interpreter can't know whether it's possible for another thread to be active in the same area at the same time. (Actually there were some comments on TFA that suggested PyPy's escape analysis would help with this). If the interpreter doesn't make efforts to make sure that all threads see a consistent view of the interpreter state at all times, writing threaded programmes would be impossible. In other words, in theory the opcodes *do* interact, regardless of whether they do in practice. Your choice is fine grained locking (Jython), course grained locking (CPython) or STM (hopefully PyPy). But I think you do need something!
Remove the %p directive at around line 146: time_object = datetime.strptime(time_text, "%B %d, %Y at %H:%M") You don't need this if Facebook uses the 24 hour system. 
Oops. Facebook doesn't actually use the 24 hour system. So I need to %p, but it should be %I:%M instead of %H:%M. Fixed: https://github.com/carmi/facebook-analyzer/commit/8cd99902f4a1af59332a76a4fe852f2792d0e38c#L0L146
Really? When I downloaded my Facebook data, it was in the 24 hour system so I only had to remove the %p. I suggest to support both systems.
Interesting, and thanks for the links. ps 3 lines and a tl;dr! :-)
After you're familiar with PyQT or PySide you don't need a GUI builder. Qt has excellent layouts, it does almost always what you expect. Basically it's always the same: 1) You have some parent widget, e.g. a dialog derived from QDialog. 2) Then you create an empty layout, e.g. a QGridLayout. 3) You add your widgets to the layout, e.g. QLineEdit, QPushButtons 4) You add your layout to the parent widget. 5) You can nest different layouts, add spacers and stretches ... Once you've done this a couple of times you won't miss a gui builder. Regardless of what I said, Qt Designer is quite sophisticated. Some resource to get started with PyQt: * PyQt Wiki: http://diotavelli.net/PyQtWiki/StartPage * PyQt4 and much more nice tutorials: http://zetcode.com/ * Very good, lots of good examples: http://www.qtrac.eu/pyqtbook.html * Quite old, but still useful and free: http://www.commandprompt.com/community/pyqt/ 
Well, unless it was a change in the last week or so. I have dates like: &lt;div class="timerow"&gt; &lt;span class="time"&gt;June 15, 2011 at 10:31 am&lt;/span&gt; &lt;/div&gt; Maybe it depends on country/language or something. Are you not US/EN ? I'll try to make it support both. Can you give me an example time string here (Or on github)
Here is a sample: &gt;&lt;span class="time"&gt;June 12, 2011 at 22:50&lt;/span&gt; 
Thanks. It should now handle both formats. A little ugly work around. Let me know if this works for you. https://github.com/carmi/facebook-analyzer/commit/cfdba9bb96cda54cc8972fcf5e905e77d7ebc5a0
I run a bunch of background scripts in 'screen' sessions started by /etc/rc.local. I quickly discovered that if a script crashes, it needs to be manually restarted, and the screen session closes right away, destroying the backtrace. To fix those two issues, I've been using this code: log_fn = 'dostuff.log' log_fmt = '%(asctime)s\t%(message)s' log_dfmt = '%Y-%m-%d %H:%M:%S' logging.basicConfig(filename=log_fn, level=logging.DEBUG, format=log_fmt, datefmt=log_dfmt) console = logging.StreamHandler() console.setLevel(logging.DEBUG) fmtr = logging.Formatter(log_fmt, log_dfmt) console.setFormatter(fmtr) logging.getLogger('').addHandler(console) while True: try: do_stuff(sys.argv[1]) except KeyboardInterrupt: raise except: logging.error(traceback.format_exc()) time.sleep(60) pass 
Log files would be the best solution to this problem. Log everything. And send critical events and exceptions to your email address. 
It really depends on what you're trying to do with these scripts. If you want them to live for more than a few minutes/hours/days, then I suggest having the process [daemonize](http://code.activestate.com/recipes/278731-creating-a-daemon-the-python-way/) and then use the logging module to log information to a file and write a SIGTERM handler for clean shutdown. Note that logging is going to buffer the file output unless you tell it to flush on each line. If you're not needing something to be very long lived, the easiest way is to do something like screen -d -S [session name] "[script + args] | tee [some file you're going to save stdout to]" which will create a screen session with the process. Note that when you 'go back to look at it' or read the file you're writing stdout to, the pipe from python to tee is going to get buffered, and so the output file will most likely be a little behind the actual output of the process.
That's pretty much the same way I got into Plone. I'm not absolute about my opinion, there were some very nice things about it, but quite simply the way we used it was pretty retarded, no use of archetypes, etc. We pretty much built SQL apps in plone using ZQL (or whatever it was called) When I did get t use the ZEO, I liked it a fair bit. Sadly because of the requirements, my 2 and a bit years was pretty much daily torture, so when I got the chance to jump o Django &amp; TurboGears I didn't look back. I know they work as hard as they can on docs and the like, but even the commercial books I saw were either already outdated or simply not deep enough to give you a good fuzzy warm about things. That was 4 years ago though, so thing may be quite different now.
yeah it works.
That or a hand written WSGI or CGI application!
I don't think the GIL is as big of a problem as everyone else seems to, but I do wish there was something like the `multiprocessing` module but more lightweight (without creating new processes). For example, if you could use something like stackless or gevent, and you could tell the interpreter that each task is only allowed to see local function scope, (you'd get a NameError when trying to refer to a global variable) then you could map the tasklets across a thread pool. You'd also need erlang/goroutines style message box with locks to share messages between the tasklets. I'm guessing this doesn't exist because it isn't easy to limit the memory a thread has access to or something? I'd be happy if someone could enlighten me.
Totally. I love getting the stack trace in the error email so there's not even any digging to be done, you get the report right there.
Kill it with fire. It's the only way to be sure.
The email thing sounds awesome, how would I go about setting that up? EDIT: Ok I see that I have to use [SMTP](http://docs.python.org/library/logging.handlers.html#smtphandler). I want to stick with Python 2.6, though, and it looks like the 2.7-only *secure* argument is necessary in order to use gmail. Maybe I'll try [this](http://mynthon.net/howto/-/python/python%20-%20logging.SMTPHandler-how-to-use-gmail-smtp-server.txt.)... 
Can you 'round trip' with it, i.e. make changes to the generated code and see them in the designer? Otherwise it seems you'd better get it right the first time because there's no way to change it after the code has been generated.
I think we're misunderstanding each other here, based on terminology. Opcodes themselves don't interact - the data they operate on does, however. Therefore the mutual exclusion can, in theory, occur at the level of the data, not the level of the instruction, meaning there is no intrinsic need for individual instructions to have to execute atomically. That's all I was saying, in trying to clarify vsymm's point.
Ok I've been going through the logging tutorial and it is seriously awesome. Thank you for this. So, do I get this right: 1. write logging into my python scripts 2. run python scripts with '&amp;' so they run in background 3. 'check in' by opening log files If a python script is running in the background and hits an error, what happens to it? Does it automatically shut itself down, or do I have to do that manually? 
It's rather direct wrapper to SDL which in turn is rather old C-library. Because of that, it's not the most 'pythonic' thing in existence. 
I only had 2.6.1, but downloading the [collections.py](http://svn.python.org/view/python/trunk/Lib/collections.py?view=markup) file directly worked to get the Counter class.
Thank you, I'll start working with it.
I wish they had a run a dedicated audio line to the camera. The standard set for video recording of Python Conference has to go to Pycon2011. 
You can implement multiple handlers at the same time, e.g. one for stdout, one for a file, another for email, etc.
No because you never edit the generated code you just over ride the functions where you inherited the form. It works really well.
execnet does what you want (except it does spawn processes at the end)
Atomically doesn't mean two can't happen at the same time! It just means that they either completely succeed or completely fail, and no other thread sees a partial result.
[pyblosxom](http://pyblosxom.bluesock.org)
You should create a thread for doing the script work, and keep the script status in module variable. In the main thread, register a signal handler and enter a wait loop. When a right signal is received, print the status. To send a signal, use kill: kill -SIGUSR1 pid For example: import signal import time import threading status = 0 def main(): signal.signal(signal.SIGUSR1, report) t = threading.Thread(target=worker) t.setDaemon(True) t.start() while 1: try: signal.pause() except KeyboardInterrupt: break def report(signo, frame): print 'status: %s' % status def worker(): global status while 1: status += 1 time.sleep(1.0) if __name__ == '__main__': main() 
I always thought that [Zine](http://zine.pocoo.org/) had a beautifully implemented system for plugins, but that's just me of course. IIRC there were certain central points in the script, e.g. "before_submit_post", that were triggered when the script's execution had reached that exact point and then ran all plugins that previously registered a handler for the given event, gaining access to certain runtime objects, like a dictionary containing the settings of the currently running Zine instance and a context variable, containing in this example maybe the text that the user entered for the new post. Maybe this sounds like a good system, for what you are trying to do, to you.
No, but enforcing atomicity effectively requires mutual exclusion when you don't have any other way of ensuring consistent state. Which is exactly what the GIL does. If you have other ways of ensuring consistent state, or a protocol that dictates something else is responsible for it, then you don't need to enforce atomicity in this way. This is pretty much how most other languages work, allowing the possibility of inconsistent state, but being faster and more amenable to concurrenct performance.
crap! 4 of the videos I want are not there Error 404: Cannot find the requested page.
Based on my limited experience, I'd probably implement something middleware-ish, kinda like what you see with WSGI.
In my line of work, I will probably never use a python web frame work so I don't have any horse in this race. I'm just wondering though, Why all the down votes with no comments? Genuinely curious. 
Me too. I think there is some potential here. Moreover, its a guy giving away his codebase to the community. Why all this down voting? I would assume people will talk about their issues by commenting.
Hey again! I've been doing more dissecting of the winGuiAuto script, breaking it down to further my own understanding of the concepts being used and how it's working behind the scenes with the windows. The line you provided `hMenuItemCount = ctypes.windll.user32.GetMenuItemCount(hMenu)` obviously works without a hitch, but now I'm curious as to why you used a ctypes access (I'm not sure how to word what you're doing there, in my mind I consider it a ctypes dll function call, is this right? if not could you suggest where I could learn more about programming vernacular?) The reason I ask is I noticed a win32gui variation of this function by the same name `hMenuItemCount = win32gui.GetMenuItemCount(hMenu)` which allows the script to function much in the same way as this ctypes access allows. Is there a specific reason you went the ctypes route? I also noticed the author of winGuiAuto uses a ctypes access for his `getTopMenu(hWnd)` function: `return ctypes.windll.user32.GetMenu(ctypes.c_long(hWnd)`, which also has a win32gui variation `return win32gui.GetMenu(hWnd)` that seems to work fine as a replacement. I did notice the ctypes access returns just the integer value, whereas the win32gui variation returns the same integer value but with L appended to the end, example: `ctypes access return: 67472` `win32gui variation return: 67472L` Again, both allow the script to function as it should as far as I've tested it. Also, if you're beginning to feel I'm being a pest, feel free to let me know!
nice idea! trollnet can be real!
Looks more like an RPC version of multiprocessing.
Is there something better? For someone who just wants to play at making 2d RPGS, learning 3d seems overkill. But like I said, I'm not exactly advanced...
Maybe because there is nothing to view. A blog post to see a gitbut project : no demo, no tutorial, no doc, and no README. Juste code. It's not enough.
Not that I know of. And that's probably the reason for thantiks comment. But you'll probably be just fine with pygame, don't worry. 
Thanks so much, I've worked with wordpress so I've worked with action hooks before but I hadn't thought of that.
 screen -L that's a better way of getting a log of stdout. 
Check out [Django's Signals](https://docs.djangoproject.com/en/dev/topics/signals/), with [code here](https://code.djangoproject.com/browser/django/trunk/django/dispatch/dispatcher.py)
Either way works, but using pywin32 will generally be easier, especially for functions that want a reference to a structure. For example, `GetProcessMemoryInfo` in the process status API requires a `PROCESS_MEMORY_COUNTERS` structure that contains fields that specify process memory usage. Using ctypes requires you to specify the structure, instantiate it, and pass it by reference. On the other hand, win32process handles all of that internally and returns the data in a dict: import ctypes from ctypes import wintypes import win32process #start a notepad process (hProcess, hThread, dwProcessId, dwThreadId) = win32process.CreateProcess( None, 'notepad.exe', None, None, 0, 0, None, None, win32process.STARTUPINFO()) #get memory info using win32process pmem_info = win32process.GetProcessMemoryInfo(hProcess) print('\nwin32process\n' + '='*32) for key in sorted(pmem_info): print('{0}: {1}'.format(key, pmem_info[key])) #get memory info using ctypes #specify the structure class PROCESS_MEMORY_COUNTERS(ctypes.Structure): _fields_ = [ ('cb', wintypes.DWORD), ('PageFaultCount', wintypes.DWORD), ('PeakWorkingSetSize', ctypes.c_size_t), ('WorkingSetSize', ctypes.c_size_t), ('QuotaPeakPagedPoolUsage', ctypes.c_size_t), ('QuotaPagedPoolUsage', ctypes.c_size_t), ('QuotaPeakNonPagedPoolUsage', ctypes.c_size_t), ('QuotaNonPagedPoolUsage', ctypes.c_size_t), ('PagefileUsage', ctypes.c_size_t), ('PeakPagefileUsage', ctypes.c_size_t)] def keys(self): return [f for f, t in self._fields_ if f != 'cb'] def __getitem__(self, item): return getattr(self, item) #pass a structure instance by reference pmc = PROCESS_MEMORY_COUNTERS() ctypes.windll.psapi.GetProcessMemoryInfo( hProcess.handle, ctypes.byref(pmc), ctypes.sizeof(pmc)) print('\nctypes\n' + '='*32) for key in sorted(pmc.keys()): print('{0}: {1}'.format(key, pmc[key])) Output: win32process ================================ PageFaultCount: 12 PagefileUsage: 139264 PeakPagefileUsage: 139264 PeakWorkingSetSize: 77824 QuotaNonPagedPoolUsage: 440 QuotaPagedPoolUsage: 6076 QuotaPeakNonPagedPoolUsage: 440 QuotaPeakPagedPoolUsage: 6076 WorkingSetSize: 77824 ctypes ================================ PageFaultCount: 12 PagefileUsage: 139264 PeakPagefileUsage: 139264 PeakWorkingSetSize: 77824 QuotaNonPagedPoolUsage: 440 QuotaPagedPoolUsage: 6076 QuotaPeakNonPagedPoolUsage: 440 QuotaPeakPagedPoolUsage: 6076 WorkingSetSize: 77824 
Check out TinyHTTPProxy: http://www.oki-osk.jp/esc/python/proxy/ It's really simple to extend.
Great example, as always, thanks very much!
If they're background processes that run all the time, use [supervisord](http://supervisord.org/).
I also added an IMDb plugin and a TinyURL plugin, just to kick things off.
I guess we're not getting anywhere here. As far as I can see vsymm's suggestion that opcodes don't need to be atomic seems to imply that the interpreter doesn't need to be threadsafe and should be allowed to segfault when multithreaded code isn't written carefully enough. But I'm sure that's not what he means, so as you say, we're misunderstanding each other here, based on terminology. 
Great. IPython is something I really want for every programming language.
It's pretty easy now.
I don't really care for IPython; the whole thing seems a bit over-engineered. You can get the auto-complete and history across Python REPL instances by adding a couple of lines to your pythonrc file, and that covers the most useful features. The rest I cannot imagine really using that often. IMHO it's usually better to stop using the REPL and start typing in an editor once your interactive sessions seem to involve too much typing. You can always get the REPL after executing a Python script by adding the -i option.
sounds rather like you might just not be the target Python audience that would have a lot of use for IPython. I do agree with your second paragraph. Though I like to use the REPL to play and test until it does what I want and then copy that to an editor*, re-run the script and start playing again. I love it, personally. Especially the way it interacts smoothly with PyLab, basically creating a free and Python-based MATLAB environment. Also, just a few lines to enable auto-complete? I just googled and it's not quite as simple as setting `autocomplete=true` or something. And as soon as you actually need to write more than a few lines of code, why not get IPython to get a whole bunch of useful functionality? Sounds to me like you just don't really care for a powerful REPL *at all*, which is okay, obviously you're doing things with Python that don't require you spending a lot of time in a REPL but if you would, you also would want to use IPython :) It's a bit like saying Vim or Emacs is over-engineered cause GEdit already does syntax-highlighting ;-) [which is a perfectly valid thing to say if all you need is a plain simple editor] *I'm sure there must be a way to streamline this process in IPython but I haven't quite figured out the best way yet--anyone?
Sounds cool, lot of improvements. Anyone know what's the easiest way to upgrade to this RC? I don't believe I tweaked my config files *that* much, so if I lose them because of the overhaul of the config system, that's okay.
Us lispers have been cackling about the REPL thing for awhile now.
Python comes with a REPL built in, and always has. iPython takes that and adds LOTS of additional features - it is way beyond a simple REPL.
IPython's tab completion goes beyond what the builtin python can do - for example completing import statements. As for editing a file, you can do that from iPython. the command "ed" will open your editor of choice and automatically run the code you enter when you exit it. "ed -p" will open your editor with the previous edited text. "ed 1 5 10:12" will open the editor with the python that you entered at prompts 1,5,10-12. This is often much more convenient that cutting and pasting between editor and the python REPL. Also using "python -i &lt;filename&gt;" means you can only execute &lt;filename&gt; once - if you edit it then you have to exit python and re-run it. In IPython you can do "run &lt;filename&gt;" at any time. 
it depends on the kind of error and if/how you handle it, what happens. an unhandled exception could crash the whole thing. you could/should try to catch them and do something appropriate. if you have open file handles or database connections it is a good idea to try to close them, even on fatal errors somewhere else in the code. with more harmless or expected errors: eg. a script reading lots of files could have some kind of io-exception... you could catch it and make it continue with the next file. same works well on network/socket errors. put you "main" function inside an infinite loop and catch all exceptions. then decide whether you want to *continue* or *break* out of the loop. it probably *should* exit when something really bad happens, that could make more damage than good, if it retries/continues. btw: you can use signals to interrupt (restart, kill, ...) you background process with the signal module (http://docs.python.org/library/signal.html) and: you can use &amp; to send anything to the background, but you could also make the process daemonize by itself. this should help: http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/
&gt; I'm sure there must be a way to streamline this process in IPython but I haven't quite figured out the best way yet--anyone? See my other answer. Use either the ed command to edit &amp; run python code on the fly, or the run command to run the code in a file and keep the result in the context of the current session.
&gt; I love it, personally. Especially the way it interacts smoothly with PyLab, basically creating a free and Python-based MATLAB environment. Do you know about spyder? I am just testing it since a week and it really gets a reasonable Matlab-like work environment done.
See the [rlcompleter module](http://docs.python.org/library/rlcompleter.html) for completion in the normal Python REPL. My Python startup file looks like this at the moment: import os import sys import shutil import math from math import sqrt, sin, cos, tan, asin, acos, atan2, pi, exp, log import readline import rlcompleter import atexit history_file = os.path.expanduser("~/.pyhistory") readline.parse_and_bind("tab: complete") def save_history(history_file=history_file): import readline readline.write_history_file(history_file) if os.path.exists(history_file): readline.read_history_file(history_file) atexit.register(save_history) del atexit, history_file, save_history, readline, rlcompleter 
I'm not sure if that's what you want, but import re text = '"I need your help," she said, "But I don\'t want to pay for it"' regex = re.compile('"([^"]+)"') print regex.findall(text) --&gt; ['I need your help,', "But I don't want to pay for it"] For matching repeated instances of a text, look at the (?P=name) syntax in the re documentation 
".+?"
Like vbgunz said: import re text = '"I need your help," she said, "But I don\'t want to pay for it"' regex = re.compile('"(.+?)"') print regex.findall(text) --&gt; ['I need your help,', "But I don't want to pay for it"] ? is the modifier for non-greedy matching. Of course [^"]+ does the same, but I think that's just an unreadable hack.
To be honest, I find all but the very simplest regexes to be pretty much unreadable. **Edit**: I did a quick test: import re from common.utility import StopWatch text = '"I need your help," she said, "But I don\'t want to pay for it"' regex1 = re.compile('"([^"]+)"') regex2 = re.compile('"(.+?)"') clock = StopWatch() clock.tic() for i in xrange(1000): regex1.findall(text) print "First regex: {:.2f} ms".format(clock.toc() * 1000) clock.tic() for i in xrange(1000): regex2.findall(text) print "Second regex: {:.2f} ms".format(clock.toc() * 1000) (StopWatch is a helper class for measuring times with time.time(). The toc() method returns the time in seconds since the last call to tic()) The output on my machine with Python2.7 is: First regex: 0.81 ms Second regex: 2.09 ms Lazy quantifiers are not always a good idea when matching delimited stuff.
I hate this sort of segregation. Why do these women feel like they need a separate entity to set them apart from the rest of the community? What can we do as a generally male populated field to help the ladies feel more at ease?
I'm pondering the use of "love the Python" as a new catch phrase.
Maybe hold a Miss Pylady pageant?
Ooh. I haven't had a chance to try this out, but I've been wanting to do something similar for a jabber/xmpp connected bot. This might give me some ideas to start.
The features I most want: ability to grep the history, and to import modules that weren't installed when ipython was started. It looks like the sqlite history database might be easier to work with than the old history structure. I don't know if it's possible to rehash the dist-packages directory but it would be nice.
No I didn't. Looks very interesting, I'll give it a go, thanks! (Even though currently `ipython -pylab` fullfills all my MATLAB-like needs, I'm always open to see what new stuff has to offer)
I think that's a pretty big step backwards. Honestly, what we need is to not even mention that there are ladies in the field and just assume everyone is a 'person' rather than their respective gender role. That way we can all gang up on the Python writing robots!
Okay, yeah I tried that. Still doesn't quite feel "streamlined" enough for me. I'm using GVim and that makes it act kind of weird, since IPython thinks the editor exited immediately, as GVim pops up its own window. Optimally, I'd like to be able to do `:w` (or some other custom command) in GVim, saving my source file, then IPython would pick that up somehow and execute that file immediately. Then I'd return to IPython, check out the results, play with it a little bit and write a few lines of code in the REPL, and somehow be able to transport the lines of code that I like back to the source file in GVim. Also the `ed 1 5 10:12` stuff doesn't always seem to work for me. Can't reproduce it right now, maybe I've been doin it wrong, though.
I get your sentiment, but I see their goals differently. I see what they're doing (much like GDI groups) as "gentle introduction to the larger (python) community through known compatriots". Nothing that PyLadies has done (other than form a group..like a 'distributed user group') has been secessionist, it's been more about actively bringing more women into the fold. Take some time reading what they're doing, and play "follow the leader" with the people doing it. (twitter.com/audreyr is the only one I know personally)
OK, how about this then. We create an IDE just for ladies to make them feel welcomed by the community. It could be called PinkPython, and have a colour scheme composed primarily of shades of pink. Maybe a Hello Kitty face here and there. Ladies love Hello Kitty.
&gt; Why do these women feel like they need a separate entity to set them apart from the rest of the community? I don't think they do. From what I understand, it's a gateway organization to bring women into the Python community.
No, I get that. That's precisely what I was getting at. Why can't have it where women feel comfortable learning equally from men, or women? Obviously, the *idea* is great. I just feel it *should* be redundant but ultimately isn't. Which is kind of my whole point. Why aren't we doing more in general to make women feel more comfortable coming into fields like this? I've begun training a few ladies around my office in the use of VBA, and a few males as well, and I can honestly say that teaching the women is a lot easier, but this might be too small of a sample size to take any conclusions from. It is a great idea, of course, I just wish it wasn't necessary.
Read my response to issakelly above.
I've used it a couple times. As a male, I realize it comes off as kinda gay, but hey, maybe I should start a python users group, because obviously as a disadvantaged middle-class gay male with programming jobs, I'm not getting the encouragement I need. 
Oh dear! Not much of a sense of humour in this subreddit then?
&gt; What can we do as a generally male populated field to help the ladies feel more at ease? How about not getting too worked up when women want their own support group? You need to understand that from many woman's perspective's programming isn't a very welcoming field: it's probably 90% male, many of the males within it have a very difficult time with women, and there are quite a few stories of very public creepy behavior towards women. And don't get so wrapped up in "theoretically, we're all equal" - because "practically, we're not". And as a member of the super-majority it's just possible that your perspectives aren't anything like the minority's. So, if it makes some women feel more comfortable to talk to other female programmers - then great, support them. Because this field needs more female programmers, and clearly the current methods of attracting women into it aren't working.
Well that's great and I'm really glad you're joining the community. I just feel a little annoyed that there is a gender divide in the community though.
No, I agree. I was asking what we could do to close this gap. To remove the stereotypes held of female programmers. I don't know it just irks me that certain fields have these 'designed for men' stickers on them.
&gt; Still doesn't quite feel "streamlined" enough for me. I'm using GVim and that makes it act kind of weird, since IPython thinks the editor exited immediately, as GVim pops up its own window. Launch gvim with -f it should fix that But [Reinteract](http://reinteract.org/) look more like what you need.
&gt; I'm using GVim and that makes it act kind of weird, since IPython thinks the editor exited immediately, as GVim pops up its own window. Configure ipython to run gvim with with the -f flag so it will not run as a separate process and will work the way that ipython expects. Alternatively configure it to run vim instead of gvim. 
&gt; What can we do as a generally male populated field to help the ladies feel more at ease? Well I did nothing to the opposite, did you?
That MIT lecture is one of the best! If I'm thinking of the right one, it's the one where they go into all the theories behind computer science, too? Do you have any books? I find it's a great thing to have a decent reference book and a hardcore theory book.
No I didn't but that's just how things go with fields like this unfortunately.
Out of curiosity: Do you have an idea what's happening? Why is the first faster?
people who foment divisiveness piss me off. heck even the python philosophy is to use what works and not obsess about a language purity ideology. It attracts a fairly laissez faire, pragmatic community. if you refuse to learn from anyone but women that's your problem
Thanks, I'll check out both your suggestions.
&gt; Optimally, I'd like to be able to do :w (or some other custom command) in GVim, saving my source file, then IPython would pick that up somehow and execute that file immediately. Then I'd return to IPython, check out the results, play with it a little bit and write a few lines of code in the REPL, and somehow be able to transport the lines of code that I like back to the source file in GVim. When I am unable to use ipython (e.g. when programming in jython) I use gvim with the [Conque Shell extension](http://www.vim.org/scripts/script.php?script_id=2771). This lets me run a terminal session inside a vim window, and send either a block of text or the entire file from another window to the shell with a single keypress. Alternatively run python/ipython in screen and use something like [this script](http://www.vim.org/scripts/script.php?script_id=2711) to send lines of text from your vim session to the shell running in screen. 
so you choose to see them as men and not simply as helpful experts? seems like the fault lies in you rather than the community. 
a) this isn't ruby. b) this behavior usually doesn't pop up and is discouraged, unlike many other groups
&gt; I can't think of ever seeing creeper syndrome that's common in the other communities (ruby? linux?) I don't think this is about "creeper syndrome". If you've been to PyCon, you know that of the ~1000 people there, there's maybe 20 women in the audience. Of the almost 100 talk slots each year, maybe one or two are women. I don't remember seeing any tutorials taught by women. At the sprints afterwards, there are usually no women at all. When I go to my local user group meetings, of the roughly 40 or so attendees on average, there is one semi-regular female and occasionally one or two pop in but never return. If you look at the list of committers to large projects like CPython or Django, between those two you have almost 200 people. One Django committer is a female, and zero CPython committers are female. I think this PyLadies program is *awesome*. Females are such a minority in this industry (software) and this community (Python, open source, etc) that although they are certainly welcome to just join up wherever, I can't imagine being in their shoes being outnumbered by the thousands at PyCon, by the hundreds in open source projects, etc. It's nice to go into those things with friends, with an easier introduction. Whenever I talk about contribution, one of the most important points to me is that early success is very important to keeping people interested. If PyLadies can help females feel more at home in the Python community, then they get my support.
[Here](http://blog.stevenlevithan.com/archives/greedy-lazy-performance) is a good explanation. 
It's a general societal issue that's the problem: why does it matter to women what the gender of the programmers they're talking to is? When it comes to gender, we don't seem to have a quite gotten passed "separate but equal" and so we really don't have equal at all. &gt;And as a member of the super-majority it's just possible that your perspectives aren't anything like the minority's. And it's also possible they are. Let's not be gender prejudiced. Ultimately, we should encourage everyone, men and women, to approach things with an open mind. We haven't done well, and in the long term, "women for women" groups are going to be counterproductive. Short term, they might be effective, but we need to be wary of instilling or reinforcing gender prejudice.
I think we all wish it wasn't necessary, but sadly it is. The number of women studying computer-related fields in college is dwindling. The number of women doing the same in high school is probably reaching zero. My college used to host a summer "camp" to get high school and college girls interested in computing and I think it shut down a recently because no one signed up. As for what's being done, I don't have a specific answer for that, but diversity is a huge topic for the upcoming conferences. There has been a lot of chatter among the PyCon organizers about what can be done, and I'm hoping to see a much better situation next spring.
if women have to be coddled at every opportunity they will never be a part of the community, because they are by necessity handled differently. what's next? pyblackies for all the black python programmers who can't bear to use python without a black face leading the charge? this is creating divisiveness where none existed. the community has strongly supported anyone with the skills to make good contributions. yech, whatever. if some people need coddling that's fine, they're just never going to be treated the same once word gets out that said coddling exists pyladies have now become the joke and sore spot they so wished to avoid being. 
No. It's a real issue and your jokes were stupid.
What level is *How to think..* at? I've been looking at it, but I don't want it to be all fluffy nonsense..
Somehow I can join any server, bot doesn't join any channel, help?
Well, I'm *okay* with OOP. So I might hit it up, or at least download a pdf prior to buying it to make sure I'm not stuck with a paperweight. Those MIT lectures are damn good tbh, make sure you don't miss the class notes that are on the same page! Really useful for seeing the code as sometimes the video isn't too good.
I redid the test using timeit and got similar results Win32 Python 2.7/3.2 and Cygwin Python 2.6.5. The 2nd regex with the lazy quantifier took 1.86 times longer in 2.6.5, 1.88 times longer in 3.2, and 1.96 times longer in 2.7. import re import sys from timeit import timeit text = '"I need your help," she said, "But I don\'t want to pay for it"' regex1 = re.compile('"([^"]+)"') regex2 = re.compile('"(.+?)"') setup = "from __main__ import text, regex1, regex2" t1 = timeit("regex1.findall(text)", setup, number=1&lt;&lt;20) t2 = timeit("regex2.findall(text)", setup, number=1&lt;&lt;20) sys.stdout.write("t2 / t1 = %.2f\n" % (t2 / t1)) sys.stdout.flush() 
Consider me discouraged :)
*Shut up* and love the Python!
Ooh, nice. I didn't know it was available online. Thanks.
A great initiative, best of luck to the women at PyLadies!
Why do you feel it's segregation? Why do you feel it's a separate entity? The goal is simply to increase participation -- in the broader Python community -- of a demographic which traditionally does not participate. And, typically, "hey, people like me who I can hang out with to get started" is a strong way to do that (see: regional user groups, tool/library/framework-specific groups, etc., which people don't seem to view as "segregated"). Is there something you saw or read on the site which led you to believe otherwise? If so, please explain it and perhaps it can be remedied.
Well, blame the neckbeards. They may create awesome things, but they can be elitist douchebags. I don't really like being excluded from anything, so when there's a python group that I cannot join because I have male parts, it makes me feel decidedly uncomfortable. However, after reflecting, I think things like these are a necessary evil until the community as a whole is mature enough not to need it.
See it as a symptom, not a cause.
We'll get there, eventually, but for now, gender unfortunately still plays a role.
isn't gvr the only neckbeard in python? and the last time I saw him he was sporting an i love ponies t-shirt 
apparently we can't have a single community on this earth that's not split by gender race and creed. i give up
&gt; pyladies have now become the joke and sore spot they so wished to avoid being. No, you're trying to imply that they're that. There's an issue with women not becoming part of the IT field, especially the "hard" edges like programming. Forming a user group for women who are a massive minority in order to enable them to get into the field is a good thing. You act as if people are purely self-determined. Whilst that is idealistic, it is untrue - culture and social conditioning have a massive effect on our reasoning and our attitudes towards thing. An active effort has to be made to make culture more egalitarian, otherwise nothing changes. You can't just remove all the blocks and hope people diffuse into some androgynous pool, because that's simply not how culture works. Consider it this way - in a male dominated field, it would take a woman to be brave and confident in order to "break into" that field. Fair enough, you say, however - men do *not* have that barrier of entry. To imply that anyone that "deserves" to be in a field should be brave and confident in addition to being skilled is elitist and naive.
I was talking generally, and figuratively. And even if it isn't anything on the existing community members' parts, it's basic psychology that it's daunting as hell to break into a group of people who are different to you for some reason.
Http://tinyurl.com/regexdbg
if you have trouble breaking into a community of gentle programmers, I hesitate to think what would become of you in any business setting and just forget about your chances on wall st
&gt;Fair enough, you say, however - men do not have that barrier of entry. really? because I'm far more surprised when I see blacks at any of these events than when I see women, and as far I know they didn't feel the need to get a support group 
&gt;it's intimidating I'm going to say this is 99% of the reason for this website, and I'm fine with that. In a male-dominant field, it would be intimidating asking for any kind of help. Hopefully though, the website will cease to exist in the future.
&gt; so when there's a python group that I cannot join because I have male parts, it makes me feel decidedly uncomfortable. Either this isn't one of those groups, or the folks in their IRC channel forgot to check my chromosomes when I wandered in. Take your pick.
Was I imagining things, or did he wear a "Python is for little girls" t-shirt at a recent PyCon?
Social darwinism. Fuck yeah?
+1 on Pelican. Nicer docs than hyde which I also tried.
&gt;Python comes with a REPL built in, and always has. iPython takes that and adds LOTS of additional features - it is way beyond a simple REPL. Thank you for that but I've been working in Python professionally for years. And no, it's not beyond a "simple" REPL. Until you've experienced something like slime/swank with Common Lisp or Clojure in Emacs you have no idea what I'm talking about.
If it makes it more comfortable for women to get into developing and the community then I think it's a good thing. Once they're settled into development and comfortable if they still segregate themselves then yeah that's when they're not really any better than the guys that scare different people out of a community.
The most valid answer! :)
If you want to write modern OO code you have to use [Moose](http://www.iinteractive.com/moose/), it beats pretty much any other OO implementation out there. I know this sounds like an exaggeration, but it really isn't and yes I do know Smalltalk. ;) Just don't say Perl is bad for OOP if you didn't try Moose. However and this is probably a huge con, Moose isn't a core library, but usually available on any platform.
That's not true in real life. Try Django and then try Mojolicious or Catalyst. Which framework allows you better maintenance. Also Perl has an extremely good testing framework.
Perl is named after Ruby. Or is the other way round? Oh btw. what about Ruby? I am usually using Perl, but I know some people think differently. I usually recommend Ruby, since it seems to fit for a lot of people.
Another fact that might be interesting is the community and culture. If you care for any of them you have to use Perl. Sorry, but that's simply true, especially when comparing these languages/communities. However, I honestly don't know the current state, so this might be wrong, but Python used to have a very bad community and I am not talking about the Reddit part of it. Yeah I know, this comment will cause down votes, but well...
I think the only way for now is to grab the tarball from github, unpack, and do "python setup.py install". If you don't care about old config files, just delete them. There's currently a warning, we're planning to refine that before the final release.
That's great! I worked through that course last summer and it was super helpful. My only advice is to do the assignments, and code along with the person lecturing.
first off, this site is a great regex reference. http://www.regular-expressions.info/ build the regex something like this: options = '|'.join(mylist) # with more logic for spaces and special chars in your mylist items regstr = '(' +options + ')' regex = re.compile( regstr ) then, for each sentence, either match = regex.search(sentence) or matches = regex.findall(sentence) and use match.group(1) to check the type of item, match.start(1) to get the start position. Don't try and embed all of this stuff into a single regex parse. Yes, you'll be able to do it. From my experience you won't be able to read it afterwards.
I had no idea this existed! Thanks for posting it :)
One thing that is interesting is that it connects towards your non-interactive-session code as well, via the editor. And there it features pylint integration. It also shows the docs for every function immediately after I open a bracket. Haven't installed sphinx with this yet, but I hope it will also integrate that so that my own sphinx doc are available to myself in interactive mode :)
For simple page requests and reading, use urllib2. I'd recommend you start with that. Twisted is not *too* complicated to use, in that the documentation isn't too bad, and there are usually good example templates for doing various things. I'll be damned if I know what it's really doing under the hood, though.
Well, I'm presuming that the intention is for it to be for females, but if they're liberal on the rules, that's great.
See the whole race thing is an issue unto itself. That doesn't mean this isn't.
Well those places can go fuck themselves. 
I think it's more that these women remind me of don quixote tilting at windmills that they imagine to be dragons
&gt; And it's also possible they are. Let's not be gender prejudiced. Sorry - I feel absolutely zero sympathy for members of a super-majority that feel threatened by minority members helping one-another get a leg up. It doesn't matter if it's race, religion, politics, gender, sexual orientation - it seems that we always see the same pattern repeated: the minority group has a hard time being accepted or getting opportunities, they try to work together, and the majority attacks them. Now, if we get to the point where we've got 30% of the programmers out there locking up shops by turning their teams into female-only organizations then I'll definitely be concerned. But if what we're talking about is 7 women trying to work to promote programming for women and some guys in the 95% are getting defensive - then my response is for the guys to just deal with it. full disclaimer: I'm an old white male programmer who's been writing code for 30 years, and seen too many shops run like a men's locker room.
 def foo(a): print '%s %s' % (a,a) def bar(b): print 'bar - %s' % b x = { 'f': foo, 'b': bar } x['f']('abc') abc abc x['b']('abc') bar - abc
Yes, you can do this. Functions are just another type of object and thus they behave so. You can try the following to see for yourself: &gt;&gt;&gt; test = print &gt;&gt;&gt; test("hello world") hello world &gt;&gt;&gt; test == print True The parenthesis are the elements that "cause" the function call. Following your example: &gt;&gt;&gt; x = dict() &gt;&gt;&gt; x["test"] = print &gt;&gt;&gt; x["test"]("hello world") hello world &gt;&gt;&gt; x["test"] == print True Hope that answers your question. (examples assume that "print" is a function, not a keyword, so either Python 3 or Python 2.6+ with "from \_\_future\_\_ import print_function") EDIT: Corrected the comparison/assignment mix-up.
You can grep the history inside ipython with "%hist -g pattern". It's simple wildcard matching, not regex, and it will add wildcards to the start and end. AFAIK, you should be able to import packages that were installed after starting, but tab completion won't work for the import. I could be wrong on that, though.
&gt; so when there's a python group that I cannot join because I have male parts, it makes me feel decidedly uncomfortable Hey, great, now you know how people with lady parts feel when they interact with 80% of programming groups.
&gt; why does it matter to women what the gender of the programmers they're talking to is? Because it turns out most male programmers don't treat female programmers in gender-neutral ways.
Whilst I understand the issue, as reflected in my other posts, generally communities don't actively label themselves as "male only". I'm not quite sure why you're being defensive about this, I was merely trying to illustrate an innate reaction when faced with exclusion.
The reason communities don't actively label themselves as "male only" is because male is the expected default; you only face discrimination if you vary from the default. If you need a discrimination 101 lesson, I'll point you to geekfeminism.org for pointers.
&gt; &gt;&gt;&gt; test = print &gt; True Don't you have to write "print(test == print)"?
The `re.VERBOSE` flag enables the use of whitespace formatting and `#comments` in the expression. 
"&gt;&gt;&gt;" implies interactive shell
I think it was just "Python is for girls" and yeah it was this PyCon.
pics ?
Completely forgot about that, haven't used IDLE in a while. You still have to use the == sign though.
guys need to do this for Yoga.....I'm rather tired to see yoga classes where they are like 90% female
So you've changed "host" (to a str), "port" (to an int) and "bots" (to a list of strings) in config.py and the bot isn't joining? What's the server &amp; channel? I'll work on it and see what's going on.
It is true in real life non-web applications, I don't have experience with Mojolicious or Catalyst so I can't compare them fairly.
Is this supposed to be real?
geekfeminism.org holds no authority; it contains mostly subjective content and doesn't properly cite its sources. It also fails to establish its underlying principles, instead directing you to other feminist blogs; you end up having read lots of blogs but none the wiser, and even having found contradictions.
I know this is a prickly subject, but why does "this field needs more female programmers"? It's one thing to fight discrimination and try to expand the field by introducing new people to it; but why is it that female programmers are needed more than any programmer in general?
what exactly does that do? prints a boolean? could someone break this statement down for me please? thanks.
I don't see it as a gender divide, per se. They're not saying "oh let's make our own little club and let the boys play over there". As stinieroo said, many women feel intimidated when going into programming because there's this mindset that programming is a man's field. Unfortunately, there are *very* few women in this field. Pyladies is a gateway. Women come in not knowing any programming, but *wanting* to learn and the group teaches them. When the men and women in Pyladies feel like they have a good grasp, they're more than welcome to "go elsewhere". According to the website, Pyladies even has a talk at DjangoCon, so it's not like they're creating their own isolated community.
That's a very good point. It's really no different from a local user group, except based on some criteria *other* than physical location.
SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR SIDEBAR
You must be using the Windows console. Add the following lines to the top of your program as a quick fix: _input = input input = lambda msg: _input(msg).strip('\r') This calls the old input function (renamed `_input`) and strips out any carriage returns ('\r').
Agreed with jonpv. But to answer your question, it looks like you need to read about the difference between input() and raw_input(): http://en.wikibooks.org/wiki/Python_Programming/Input_and_output#raw_input.28.29 Also, the result will totally depend on which version of Python you're using. In 2.x there's a difference between input and raw_input (as in the link), but in 3.x `raw_input` has been renamed `input` and the original `input` is gone.
Great its working as it should now. Is there a permanent fix for this? or am i just using the wrong version of python for my pc? I"m running windows 7 64 bit.
There's a typo. It should be `test == print`, which returns a boolean. The interactive REPL (read-eval-print loop) automatically prints out the return value. Since test was assigned to the print function (`test = print`), it prints `True`. 
okay I kenw that, I realize I was looking at the wrong line cause of his ninja editing/correction.
I think what jonpv is trying to say is: http://www.reddit.com/r/learnpython
No you have the right version for the book you're using, which uses Python 3. The closest to a permanent fix would be to run your script with IDLE instead of in the Windows console. Two interpreters get installed, one that uses a Windows console (`python.exe`) and one without a console (`pythonw.exe`) for GUI apps. IDLE uses the latter and manages its own console. Unlike the Windows console, it doesn't end lines with '\r\n' (carriage return, line feed) but just '\n' (line feed). The `input` function correctly strips line feed characters; it's just the carriage returns that it ignores. 
To answer the question in the write-up, this is similar to how it works in Go: f, err := os.Open("file.txt") if err != nil { return "could not open" }
I fucking love python. This seems kind of crazy to me. I get how it works, but the fact that it does is pretty neat...granted I'm coming from bash. Do other OO languages offer the same versatility?
No. Having a try block is a nice visual cue that the code you're executing in this block, whether it is a single line or whole block, has exception handling. It also makes handling more manageable in a sense. More importantly, you can easily use try/except blocks as a catch-all of a certain exception instead of assigning a separate variable and adjoining if-check to each line. Also, consider the following: x = range(10) if x[10] == 10: print "This isn't supposed to execute" How would you add this style of exception handling to this code?
Yes I am aware of Go. But in Go that is the *only* and default option - because they eschew exceptions. What I'm proposing is a simple syntax change that lets you use Go's semantics when you only need to wrap a single statement. The advantage is that you don't *have* to tag on except at the end of the statement and exceptions will then propagate upwards as usual.
Honestly, if anyone ever actually answered the posts over in /learnpython I'm sure more would post there. There's 1/20th the exposure.
Python's syntax is indeed versatile, but yes, this can also be accomplished in, say, C++. Granted, you've got about 10 lines of STL to set up your dictionary/map, and you'd either want to use pointers or something from Boost, but yes, you could do this.
You can use function pointers (which is essentially what this is in python) in C/C++ but it's not as pretty: Code: void printNext(int a) { cout &lt;&lt; a+1 &lt;&lt; endl; } int main() { printNext(5); void (*f)(int) = &amp;printNext; (*f)(5); return 0; } Output: 6 6
oohay_email2004 seems to be doing just fine answering all of the questions on /learnpython.
You wouldn't. For the above you would just use the standard try/catch block. I'm not proposing removing the standard try/catch. But in many cases (I chose the file open example for a reason :), I find the try/catch syntax too clunky. To get the semantics of the proposed except clause, you'd have to use two keywords and two nested blocks - and possibly one or more `foo = None` statements. What makes this useful is the guarantee the `err` will be `None` if there is no error - you can use this variable at multiple points in the following code. The standard except block gives you just one block to handle the error case.
You can rehash your modules list running %rehashx in your ipython session. This works for the 0.10 series, I don't know if it's still valid for the new 0.11 one.
On further thought - my beef with the standard try/except is not with specifically with the syntax but with the assumption within functions that certain operations are *exceptional*. The standard try/except is more useful when you want to return or branch in the except clause. Very often I need to continue execution with a default value or with the knowledge that a specific operation failed. That is when the except clause is useful. Some synthetic examples to illustrate: i, err = int(s) except ValueError if err: i = -42 f1, err_opening_f1 = open('file.txt') except IOError f2, err_opening_f2 = open('file2.txt') except IOError if f1 and f2: #... #.. more code if f1: #... #..more code if f2: #... I haven't created examples that are far from reality. Try doing the above with the usual try/catch - each `except` line explodes into 3 or 4 lines.
Isn't that a bug, though? Shouldn't *input* strip *os.linesep*?
Thanks eryk, I really appreciate the clear response and not getting ragged on for being a "retard that can't understand the simplest concepts". 
*people who foment divisiveness piss me off.* http://www.youtube.com/watch?v=PivWY9wn5ps
As others have mentioned, functions are just another type of object, which is great, because you can manipulate them just as if they were a string or a dict: &gt;&gt;&gt; def a(): ... pass ... &gt;&gt;&gt; b = a &gt;&gt;&gt; type(b) &lt;type 'function'&gt; &gt;&gt;&gt; b.func_name 'a' Following this, unbound or bound methods are just functions, wrapped in code that passes the class instance as the first parameter (commonly named `self`). Check it: &gt;&gt;&gt; class A(object): ... def whoami(self): ... print self ... &gt;&gt;&gt; A.whoami &lt;unbound method A.whoami&gt; &gt;&gt;&gt; A().whoami &lt;bound method A.whoami of &lt;__main__.A object at 0x1004cce90&gt;&gt; Without brackets, `whoami` is just another object, either unbound (associated with the class) or bound (tied to a particular instance). &gt;&gt;&gt; b = A() &gt;&gt;&gt; b.whoami() &lt;__main__.A object at 0x1004ccd10&gt; &gt;&gt;&gt; A.whoami(b) &lt;__main__.A object at 0x1004ccd10&gt; You can call the bound method without any arguments, because the instance argument is implied. You can also call the unbound method with an explicit instance argument, and get the same result! &gt;&gt;&gt; A.whoami('Boink!') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unbound method whoami() must be called with A instance as first argument (got str instance instead) You can't call the unbound method with just any argument -- the code that wraps around the inner function expects the first argument to be an instance variable. &gt;&gt;&gt; A.whoami.im_func('Boink!') Boink! However, if you call the inner function directly (bypassing the method wrapper, using the `im_func` attribute), you can pass any ol' thing you want as the first argument!
Stoat sounds delicious. My sentiments exactly about django CMSs. 
It's a [known bug](http://bugs.python.org/issue11272) that's fixed in 3.2.1. You're welcome to install [release candidate 2](http://www.python.org/download/releases/3.2.1). To me it's not a big deal. I don't use the console interpreter much. I use IEP with Python 2.5, 2.7, and 3.2 in tabs.
Or maybe they made an exception for you, as they're obviously interested in Django.
Another one, in Debian source code: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=477454
Great question: my answer to this is that women are 50% of the general population, and generally bring slightly different perspectives, values and approaches to solving problems, communicating, and evaluating objectives &amp; requirements. In my experience the very best teams that I've worked on always had women on them.
And one wonders why you do not see very many females at Python conferences. 
Holy shit I got stupider reading those comments, just fucking remove the lines, it would take 30 seconds.
If you're suggesting that it's because of the occasional instance of ribald package naming, I don't think your point is very well supported.
Since the question uses `print` as a function, I think it best to point out that Python 3 does away with unbound methods. Also gone are `im_func`, `im_self`, `im_class`-- and the `func_` function attributes such as `func_name`. Instead, for methods use `__func__`, `__self__`, and `__self__.__class__` -- and for functions use `__name__`, `__closure__`, etc. These names are also available in version 2.7.
[Official website](http://webpy.org/), for the lazy.
As 'bc' mentioned on the original link - this significantly simplifies generator/list expressions if you intend to catch exceptions. I think (s)he means this - instead of writing: error_items = [] for item in items: try: verify(item) except VerifyError: error_items.append(item) You can write: error_items = [verify(item) except VerifyError for item in items] error_items = [item for (item, err) in error_items if err] 
Unless I'm grossly misunderstanding the premise, the problem stems from the fact that Sebastian would not only like the the code to be changed, but that the Debian release itself be repackaged with the change reflected. Given that the offending line is in a single application, not in Debian itself, and that the line was removed fairly quickly in the application, there's something to be said about not wanting to repackage the release due to such a small change.
To be fair, my impression of the Python community (in person, especially) has been of one that is particularly open and welcoming to everyone, but that isn't true of the programming community as a whole. I'm not suggesting Python should follow the Ruby way of turning everything into drama, but the dragons are real, even if they're not as widespread or powerful in Python as they are elsewhere. Programming does tend to be a sausage fest for various reasons so if there are groups that try to bring in more women by giving them an easier point of entry, more power to them.
The naming is due to the culture of the open source programming groups. 
unlike pyglet pygame is a c based extension, which means there is most likely need for some porting/extending cpyext work
You're saying that Pyglet works in PyPy? I had never bothered to try. Thank you very much! 
its pure python, ctypes based, and given that jittypes2 (jit support for ctypes calls) got merged, you really want to run it on pypy instead of cpython *edit* i was just hinted, that i should back that claim up with some evidence, i'll make some perf tests when i get time
What is even cooler is that you can assign lambdas to the dict so instead of having a hell of if/elif/else you can have a dict. For example if you have the var status that can be a string just use: dict[status]() and it will know what to do :)
You could roll your own: def tryFunc(exception, func, *args, **kwargs): try: result = func(*args, **kwargs) return result, None except exception, e: return None, e &gt;&gt;&gt; def f(x): ... return 1/x &gt;&gt;&gt; tryFunc(ZeroDivisionError, f, 1) (1, None) &gt;&gt;&gt; tryFunc(ZeroDivisionError, f, 0) (None, ZeroDivisionError('integer division or modulo by zero',)) As far as I can see this gives all the advantages of your proposal with no changes to the language. **edit:** BTW you can use this function to catch more than one type of exception - pass them in as a tuple: &gt;&gt;&gt; tryFunc((ZeroDivisionError, TypeError), f, "x") (None, TypeError("unsupported operand type(s) for /: 'int' and 'str'",))
Windows doesn't have nightly PyPy builds. So you're already handicapped by running a months old version of PyPy. And secondly as far as I know they have yet to get PyGame working on PyPy. I've installed it before, there were a few lines to change in the pypy stdlib. But attempting to import pygame once installed will segfault.
I tried pygame under pypy on OS X this week, and ran into the following issues: * Compiling dependencies with the correct bitness. (My problems were mostly OS X-specific -- much of what I had installed was i386 and I was using x86_64 pypy.) * Passing a Python file object to pygame.image.load_image() segfaults because pypy doesn't implement the PyFile_AsFile() C extension api. (This can be fixed fairly easily in the pgame code, but I'd prefer to have more stuff fixed before submitting a patch. The workaround is to just pass filenames instead of open file objects in your code that uses pygame.) * Windows created by pygame don't seem to be focusable. (This happens in OS X and Ubuntu, but I haven't had a chance to do any investigation as to why this happens.) pygame depends on a bunch of binaries, and if you're compiling it yourself (which is what pip does) you need all the devel headers for these. Also, I seem to recall pip trying to grab a binary package instead of the source and getting confused. Try downloading the source tarball and telling pip to use that. I'll try dig into the window focus issue in the next week or so. I hang out in #pypy on freenode, so you may be able to get updated information there. Edit: Forgot to mention that I used a recent nightly build of pypy.
On the other hand, Sebastian could really have just let it be and have less people thinking he should choke on a bucket of cocks. It's the first rule of being insulted: be above it. A quiet note to the upstream and waiting it out is much more mature. As it is, his actions to quash the minor offense has exposed the offending words *and* his inability to deal with it maturely to way more people than just ignoring it would ever have. Streisrand effect, if you may.
Still no DynamicForm. Meh.
Unlikely. There are quite a few guys hanging out there right now.
A counterexample: Law is, by any sort of useful measurement, an incredibly unfriendly field in which it's very difficult for women to succeed. Women make up a tiny fraction of partners at US law firms, a tiny fraction of judges, etc., and the field itself has a long and well-documented history of being a classic "old boys' network". And yet women attend law school in droves. The gender gap in enrollment has been shrinking steadily for years, and if the current trend continues, there won't *be* a gap much longer. Which raises a question: law is arguably much more hostile to women than programming, yet women flock to law and not so much to programming. Why?
It's a route into the community for people who otherwise might find it difficult. Like it or not, admit it or not, the Python community (like almost all programming and open source communities) is heavily skewed towards the male. Like it or not, admit it or not, that's going to make it less appealing and less easy for women to get involved. Having groups like PyLadies lowers the barrier to entry and will lead to *more* women in our community. Not less. Less segregation, not more.
I don't think that would work - if verify throws an exception then item will be None. You could do it with: error_items = [item for item, (_, err) in zip(items, error_items) if err] I don't think it's a bad idiom, but as steelypip points out you can do this easily with a function. It doesn't need extra syntax.
Hmm, I suppose that could be true, but that's a very vague answer; Do you have any examples? Would you say the same is true of subjects like mathematics?
What's the status of the Qt front end?
Yeah, but it's more cumbersome to use than the proposed syntax, especially if you want to wrap an expression rather than a function call. Before list comprehensions came along, we had `map()` and `filter()` and it worked just fine. That being said, I'm not sure about the proposal. True, exception handling is a lot of noise, but it's not necessarily a bad thing. I'm curious about the comments a PEP about this would generate.
[This should be all you need](http://learnpythonthehardway.org/book/index.html) *-hopefully* Good luck!
I took a look at it, but I'm not a fan, it seems too slow, and assumes I'm an idiot :P A lot of the stuff I can work out for myself D: Right now, I'm reading http://doc.pyschools.com and it seems pretty awesome. Also, I'm not a fan of Learn Python The Hard Way's design, makes it harder to read than necessary :) Thanks anyway
**Videos** Python Osmosis Pycon(Blip.tv) **Books** Byte Of Python Dive Into Python http://wiki.python.org/moin/IntroductoryBooks 
Cheers for the videos, I'll check them out as soon as I'm no longer shaped D: 
I think a PEP would get rejected pretty promptly since it can be implemented current in python as shown above. The proposed syntax change would make it a bit more readable, but not a whole lot more. Is f, err = open('file.txt') except IOError that much more readable than f, err = tryFunc(IOError, open, 'file.txt') The latter is only two characters longer and contains exactly the same information in a different order. To use it with an arbitrary expression you would need to use a lambda which is going to be a little messier, but I doubt you would need to do that very often. 
My 2 cents is to start with [Dive into Python](http://diveintopython.org/) then checkout [this thread](http://stackoverflow.com/questions/2573135/python-progression-path-from-apprentice-to-guru) on stackoverflow. Khan Academy just started doing [video tutorials](http://www.khanacademy.org/?video=for-loops-in-python#computer-science) as well. Oh, and [this](http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained) is by far the best description I have ever read concerning generators. May you long enjoy the glorious bounty that is Python! 
Thanks :) I'm having second thoughts though, the language constructs are incredibly wierd. Seriously, wtf is a 'tuple' D: Why not just stick with calling things arrays like other languages D: Eh, I guess I'll stick with it though, might as well.
 Then you might like: http://diveintopython.org or http://diveintopython3.org The first one is a little dated, the latter is pretty new but written specifically for python 3. Python 3 is the newer version of python that everybody likes but is slow to transition to (there aren't nearly as many libraries available). In any case, these books assume you know some programming so they move faster than most and I really liked them.
Well, yes, that is part of it. Part of it is that people are socialized to self segregate based on gender.
The amount of sympathy you feel for people you choose to group together isn't relevant. Don't be prejudiced, it's that simple. That doesn't mean assume everything is hunky-dory. It means don't assume that that all shops are "run like a men's locker room." (Very colorful, good emotive content. Not sure what it mean's exactly, but I know that's not really the point.) I agree that there's no need to be defensive. The group is well enough intentioned, but when we start creating groups that are built around race, gender, whatever, two problems occur. People who don't fit into that's group's assumptions but meet their labels (women who prefer men's locker rooms, for instance) get marginalized. And the prejudices by the majority against the minority and vice versa get reinforced, because they don't deal with the counter examples to their prejudices.
Looks neat, thanks. 
What's not getting answered at /r/learnpython? I'm not there for a long time now, but it seems everything gets answered just fine.
I've had 3 days pass multiple times before I eventually delete a bunch of the stuff that I originally post at /r/learnpython and then repost in /r/python...
Vut iz DynamikFowm?
Power, status and a higher probability of financial security. [citation needed]
They fixed ^L; yay!
list == array tuple == immutable array(can't be changed) 
Tuples aren't unique to python and are not arrays. It's fine to not understand them yet, but don't assume they're useless or silly or meant to be confusing. Also, once you have the basics down, check out http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html for tips on how to move up to the next level. Good luck!
If you know another language already, check out the official tutorial: http://docs.python.org/tut . It teaches you to program in python rather than how to program.
Because the formatting bothered the hell out of me when I saw it: car = input("Lamborghini Tune-Ups: ") rent = input("Manhattan Apartment: ") jet = input("Private Jet Rental: ") gifts = input("Gifts: ") food = input("Dining Out: ") staff = input("Staff (butlers, chef, driver, assistant): ") guru = input("Personal Guru and Coach: ") games = input("Computer Games: ") total = car + rent + jet + gifts + food + staff + guru + games print("\nGrand Total:", total)
Thanks! I suppose I'm just not used to them yet. Still, after using Python for about an hour, I'm already hooked, I love how easy it is!
From everything I've seen of him, Joe Wreschnig seems to be a genuinely unpleasant person.
Like half the other commenters I actually had a working prototype of this. Basically every gif was flipped upside-down with PIL, every .flv was replaced with a Rick-roll, and every jpeg was replaced with a random lolcat. It also did a find replace on HTML for https:// to http://. I just used squid and a local BaseHTTPServer. I wanted to make the whole thing a standalone python project but I got caught up trying to implement HTTP/1.1 for it, which I thought would be better for some reason. I used to have a blogpost with screenshots but I didn't back it up when I switched hosting providers.
As a woman I gotta say... Dirty or Ribald packaging names really isn't that big of deal to most women. Calling a package 'Panty Shot' with the addition of an 'Upskirt' parser is, pardon my french, fucking hilarious. And, hell, if I can name my package, ha!, 'Big Bag of Cocks' and use the 'Dingleberry' parser well I might never go back to standard naming conventions again. Far more damaging then dirty names for packages is the patronizing attitude many women get especially as beginners. In my experience when a male is a beginner he might get a bit of ribbing and a bit of 'jfgi' but he can pretty quickly assimilate into the general group. As a female when I join a group as a beginner there's a lot more 'What, you don't know this yet?' followed by a patronizing response that may or may not be helpful. So, for many women but probably not all, there is this increased pressure to not open you mouth or ask questions until you are coming from a place of knowledge and experience. There's a fundamental flaw in that reasoning if you'll notice - namely that if we don't participate until we feel confident enough to not receive patronizing comments that rarely do we get the experience to reach that level of confidence. 
There's nothing quite like the simplicity of Python for function evaluation, AFAIK. There might be an idiom like this in Haskell, but in other functional languages --- Common Lisp and Ruby --- the syntax is more complex: **LISP** (*) (setf d (make-hash-table :a #'print)) (funcall (gethash d :a) "hello") **Ruby** d = {"fn" =&gt; method(:puts) } d["fn"].call("hello") The reason Python works this way is the beautifully simple evaluation semantics. (Almost) everything gets evaluated, and any expression of the form X(...) represents a function call. Python does the following: 1. Evaluate X 2. Treat the result as a function, and call it with the arguments (...) So *any* evaluatable expression can be used for X, even another function call. For example: def f1(a): return a*2 def f2(): return f1 def f3(): return f2 f3()()(3) =&gt; 6 Which is evaluated as follows: f3()()(3) f3() =&gt; f2 f2()(3) f2() =&gt; f1 f1(3) =&gt; 6 * * * (*) Though I'm not sure why the CL designers didn't allow: ((gethash d :a) "hello") Since this works: ((lambda (x) (print x)) "hello") 
Is it automatically assumed that called packages 'upskirt' and 'PantyShot' is 'hostile' to women? Would a packages called 'cocksneeze' be hostile to men, or maybe this would be rounded to the nearest minority - gay men? I was thinking of calling a program I'm writing 'pimp'; should I watch out for assumptions of some underlying immoral philosophy on my part? 
oauth2 is still a mess; someone needs to just start from scratch on that.
What's wrong with it?
http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/ Haven't used, but it been under active development. The problem may be there are too many options. 
others have suggested some great links to documentation, i think another point is to start writing lots of stuff in python. small scripts to automate or ease everyday tasks up to full blown desktop ready gui apps. this has helped me become more comfortable with python.
Did a little searching: &gt;The original `libupskirt` is the amazing work of Natacha Porté and may be found on its Fossil repository at: http://fossil.instinctive.eu/libupskirt/home Isn't the original author of 'upskirt' female? Or can 'Natacha' be a mans name? EDIT: actually, it's all in the comments.
It is a puzzling question. Maybe girls are taught from a young age to avoid math?
http://docs.python.org/library/stdtypes.html#string-formatting http://www.reddit.com/r/learnpython
The percentages are python's way of putting arguments inside a string. For example: If you wanted to make the string: &gt; a = "Mary had a little lamb" and the string "lamb" is received from somewhere else &gt;def get_animal_name(): &gt; return "lamb" You could write: &gt;a = "Mary had a little " + get_animal_name() or &gt;a = "Mary had a little %s" % (get_animal_name()) Known as [String Formatting](http://diveintopython.org/native_data_types/formatting_strings.html) 
The mod operator is overloaded for string formatting operations: &gt;&gt;&gt; "number1: %d, number2: %d".__mod__((5, 10)) 'number1: 5, number2: 10' 
On the one side, it is offensive to assume that juvenile humor implies causing active harm to women. If one is amused by the names "upskirt" "pantyshot", this does not imply that we are talking about a fellow who doesn't cherish and support the women in his life. To assume the implication is inescapable is hysterical. One the other side, "political correctness" is simply a tool, it is not good or bad in of itself, it is only good or bad situationally. Sometimes political correctness can be used to attack the well meaning, and score cheap points through cynical lip service. When it is helpful, it communicates that a community differentiates itself from other communities by tolerating this and being intolerant of that, to the benefit of the vast majority of the community, by stopping the actually destructive behavior and by pushing the actually destructive people out to other communities (with the possibility of collateral damage taken seriously, because no rule can compensate for the fact that we do not have access to the internal motives of others.) Those who wish to wield "political correctness" could prove their sound judgement by always making it clear that potentially offensive speech does not inescapably imply bad motives or willingness to take bad action, and can be quite compatible with good motives and good action. Make the case that using "political correctness" to advertise differences between our community and other communities ultimately benefits the vast majority of people in our community. The other thing is that these type of comment threads attract idiots. Case in point: me.
also once you get the basics, this is the place to go: [Code Like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)
&gt; arguments inside a string That's a bit confusing to a newcomer, try to avoid ambiguous language! To be clear, strings *are not* functions :P
Check out the search feature and/or search engines such as Google or Bing.
The right-hand object is the argument to the string method `__mod__`, but mod only takes a single argument. You should clarify that multiple objects need to be passed in a tuple. For a single object, the parentheses are redundant. You can simply write `"Mary had a little %s" % get_animal_name()`. A tuple is formed by commas, not parentheses -- but the latter are necessary for expression precedence. For example, `"Mary had a %s %s" % 'little', 'lamb'` would result in a `TypeError`. However, the following works fine with no parentheses: &gt;&gt;&gt; subs = 'little', 'lamb' &gt;&gt;&gt; "Mary had a %s %s" % subs 'Mary had a little lamb' 
Do stuff and you will grow. You have to have things to do and the dedication to get them done.
Couldn't agree more with what you wrote. But we live in an era which phrases such as "like a little girl" are considered offensive to women, so better continue programming than argue with childish liberals. That being said the maintainer of pypi has the right to ban any package for whatever reason. Their service, their rules.
Wait till you discover lisp.
I used it to connect Yahoo, Google, Etsy, and Netflix with the same code. Basically there's too much common boilerplate that it doesn't handle especially well. It's missing some features that like 20 different people have implemented in 20 different ways and simplegeo wasn't pulling any of them (this was last October, maybe everything is better now). Also the name is super misleading due to OAuth 2.0 and httplib2 seems to be buggy.
Because women are much more logical than men, and they glimpse the glass ceiling (Not the sexist one, the one that keeps programmers from raking in the big buck$) in programming from afar. The people who don't have those restrictions are business majors and lawyers. So, we're seeing a lot more women business majors and lawyers. 
Ah, thanks for clearing that up. I was just wondering... fake edit: And thanks for mentioning IEP. Didn't know about that one.
"string formatting" would've sufficed but thanks for the great answers everyone!!
FYI, since objects are really dicts too, you don't actually need the mapping, you can just write: fname = "read_inventory_from_%s" % ext adapter_func = getattr(self, fname, None) if adapter_func: ... 
That may be true. OAuth client libraries tend to be incredibly overwritten. I've only used oauth2 to create a provider and it worked well enough, though there definitely are some warts.
Yeah you're right - I didn't think that one through. The idiom would work for non_error_items though.
I agree with hsoft that using a tryFunc function is more cumbersome. Like you mention - it also can't be used for expressions such as: s3, err = s1 + s2 except TypeError total, err = int(t1) + int(t2) except ValueError I think if I had the except clause, I would implement error handling more often :)
omg! you skipped step 1! **step 1**: First learn Python. or optionally, *learn any fucking programming language* Why couldn't you do this: http://lmgtfy.com/?q=python+percent+sign+in+string 
&gt;Python 3 is the newer version of python that **everybody** likes I wouldn't say that.
&gt; sometimes you want to bind multiple events to one handler Don't! Just don't do that! That's like trying to scratch your left ear with your right hand behind the back of your head. Just don't do that. If you care about the identity of the event, it should have its own handler. If you want to add preprocessing to a class of events, just create a decorator. If you want a dispatch map, use it at the event binding step rather then the event handling step. 
You should worry about scaling after you have the customers ;)
If you are not experienced with this, you might want to check out GAE alternatives. I found a nice blogpost about the options for django: http://kencochrane.net/blog/2011/06/django-hosting-roundup-who-wins/
If I get customers you mean :) Sure but on other hand I would like to be prepared and have some kind of feasible road map.
&gt; learn any fucking programming language You're implying the percent syntax for string formatting is universal? Sure, it's widespread because of C, but I don't see how the OP would be any wiser if he first learned, say, LISP or PHP.
Remember, though: `str.format` is the new thing all the cool kids are using. The percent syntax is old and ugly, `str.format` is new and awesome.
http://agiletesting.blogspot.com/2005/01/python-unit-testing-part-2-doctest.html http://agiletesting.blogspot.com/2005/01/python-unit-testing-part-3-pytest-tool.html -- my favorite
What do you specifically dislike about 3.0?
Whenever I take on a new language I head over to www.projecteuler.net and do a few of the challenges to see how the language deals with algorithms etc. Then I'll do some general file I/O, CSV manipulation, GUI stuff. Test the waters and get to know the tasks you would do in a previous language.
And yourself!
The trunk is faster? We should expect a release soon then? 
tldr: "It depends."
tldr: on average it's 3.9 times faster.
It's not that crazy. It's been used since C to emulate a sort of object oriented programming where you've got data and pointers to functions in the same struct. Take a look at the Linux kernel; it uses it extensively. They're called "first class functions" when implemented in programming languages. Basically that means you can not just call functions, but you can store pointers to them in variables, pass them around (for instance, as a parameter to another function) and return them, just like with normal variables. In python you can, for instance, do this: def foo(): print 'foo' def bar(): print 'bar' def getfunc(t): map = { 'foo': foo, 'bar':bar, } return(map[t]) cb = getfunc('foo') cb() # prints "foo" It's quite useful for implementing callbacks/event handlers and implementing factories.
I'm actually seeing this from another perspective: let's say you're at a party. You know no one except the host, and they're too busy entertaining the guests. If you're like me, you may awkwardly try to start a few conversations, but everybody's already having more fun in their pre-existing friend circles. Now if there's another guest that you know, you feel less awkward. If the other person additionally knows almost no one at the party, you are pretty much compatriots - you're in the same situation and can work as a team around the conversations, filling the awkward pauses with conversation between one another. And I think this is maybe what it feels to be female in the largely male-dominated tech field. Bonus hurdles being the lower average social skills (creeper syndrome) and easily bruised egos. While these may not apply to the majority of programmers, the vocal few end up creating a rather unwelcoming atmosphere. As for being a separate entity and segregation, I'd prefer to view the group as a introductory committee to the tech world. Start in a group where you'd feel more comfortable, and go out in the real world afterwards. As others have said, there's nothing stopping members from participating in the larger community, and the group itself is not exclusively female. Now if only there was an awkward white guy dancing lessons group somewhere nearby...
I don't get it. It talks about speed, but I don't see any graphs or tables comparing it to CPython at least.
Charts aplenty on [PyPy speed site](http://speed.pypy.org/)
That's a very valid point, and probably the main reason it exists. What I am asking is how we can curb 'creeper' behaviour or things like this.. In your example, the host shouldn't focus on specific guests, whereas they should make sure to individually address each person and make them feel welcome. Great reply though.
Will look it up, thanks! Also, what does it mean when there's a number like so: print "%15s: Error...." like in the above? 
No experience with any of those code checkers. But I do use a pep8 checker which can be found here: http://pypi.python.org/pypi/pep8 
Quakenet, #welive (irc.quakenet.org) Malvager #welive (irc.malvager.net)
I've checked them out and I've copied the Signal class and related receiver and id function into my own project, but I still can't figure out how Django uses it. I come from a PHP background and have experience in procedural event hooking from Wordpress. So I'm not exactly sure how to use the Signal class. Does Django just instantiate the Signal class in bootstrap and reference to that instance whenever they create a listener/receiver?
correct for lisp. PHP has a (s)printf function. Regardless, who tries to learn a language by posting to a forum that may take hours to get a decent response when they can get the answer in a few minutes by simply looking it up in the documentation. Or simply search on google. Answering this question here is not teaching a man to fish. It is teaching someone to be an idiot. Always read the docs first, then ask for help, not the other way around. This is obviously someone who needs to be taught how to learn, and how to do things for themselves, not how to program. Anyone who replies with anything other than "read the documentation" does a huge disservice to the OP.
pyglet DOES work under pypy 1.5 i assure you - tried some demos that worked just fine
Thanks I'll check it out.
&gt;the host shouldn't focus on specific guests, whereas they should make sure to individually address each person and make them feel welcome. I agree. Best case scenario would be the host doing proper introductions so as to have the outsider integrated into one or more conversation groups. Curbing the creeper behaviours is a hard problem, on the other hand. Having a balanced gender ratio would largely fix the problem, but that just leaves us with a bootstrapping problem. I guess incremental improvement? Start normalizing gender ratios in one community and extend to other communities via member osmosis. The Python community seems like a good start, as * the "means to an end" nature of the language is more pronounced and you get a wider diversity of members - e.g. all the sciPy/numPy users in all sorts of science fields. * the diversity prevents forming big idealogical camps and the ensuing flame-wars * shit's just easy to get started with. * community's not large enough to start exhibiting large-group alienation ("oh, just another php coder" vs "ooh, a python dude - let's form a user group and do some sprints") * it's a nice gateway community to webdev (buttloads of CMSs, frameworks), low level devworks (CPython code is surprisingly readable), algorithms (something as simple as substring search turns out to be implemented as "a mix between Boyer-Moore and Horspool algorithms plus couple of neat tricks"[1]), machine vision [2] and many other directions I see this group as a very needed step in the right direction. And I hope it will do its job well enough that we won't need it in the near future - girls having female role models in programming, enough female conference visitors/talks to not feel out of place and etc. I think the gaming world is already further down that road, with casual games and MMORPGs leading the trend. Being a girl gamer already isn't as big of a deal as it used to be and I hope one day it will be a "meh, irrelevant" fact. Here's to hoping this group will spark followers to speed up the process in the programming field as well. [1] http://www.laurentluce.com/posts/python-string-objects-implementation/ [2] http://stackoverflow.com/questions/4502656/how-to-sort-my-paws DISCLAIMER: I am neither female nor well engaged in the Python community, nor formally educated in social dynamics. I am legally talking out of my ass 95% of the time :-) 
I use PyFlakes (or rather one of [forks](https://github.com/kevinw/pyflakes/network) -- I believe I use kevinw's but I use other packages from dcramer and his fork looks more up-to-date). I've integrated it into emacs and it's saved me a tremendous amount of time. I can't imagine *not* using it at this point.
Check out how they're instantiated with models [here](https://code.djangoproject.com/browser/django/trunk/django/db/models/signals.py) and how the pre_save signal is sent [here](https://code.djangoproject.com/browser/django/trunk/django/db/models/base.py#L487). There are also some [test cases](https://code.djangoproject.com/browser/django/trunk/tests/modeltests/signals/tests.py) you ca browse.
I use pep8 and PyFlakes integrated into WingIDE on both Windows and Linux. I think they are very helpful. and [DISQUS say:All languages need PEP8.py and PyFlakes](http://www.slideshare.net/zeeg/pycon-2011-scaling-disqus-7251315) 
I'll keep an eye on you for those perf tests...very interested myself.
I use the [pyflakes plugin for Vim](http://www.vim.org/scripts/script.php?script_id=2441). This catches a lot of problems while I am typing which would not otherwise be caught until I ran the code (e.g. missing imports, unused imports, typos etc). We have a policy at work of running pychecker and/or pylint on python code before committing, but it is not strongly enforced and not everyone does it. This means that some files will produce a huge list of warnings and style comments which can drown out any useful information. If you are going to use either pychecker and pylint you need to make sure you (and anyone else working on the code) uses it consistently otherwise it degenerates into noise.
I use pyflakes with emacs' flymake mode - it's good at highlighting errors (things like using undefined variables), and untidy things like unused imports, without complaining about too many irrelevant things There's a [faster and more maintained pyflakes fork](https://github.com/kevinw/pyflakes) pylint finds the same things, but is more comprehensive and finds lots of convention violations (like names that match pep8)... but this means it's much louder, and tends to produce lots of noise on existing code (unless you disable a lot of messages) There is an errors-only mode for pylint, but I find pyflakes is a better balance Not used pychecker, but I have used pep8 - it's the most pedantic of the lot, and complains about things like blank lines between functions.. It's usually impractical for existing code (unless you plan to pep8'ify it), but for new projects it is quite possible to use For one project I made a Rakefile (yes yes, slightly odd to use that for a Python project) which [runs pep8, pyflakes and nosetests](https://github.com/dbr/tvnamer/blob/master/Rakefile)
I use [pyflakes plugin](http://www.vim.org/scripts/script.php?script_id=2441) for VIm as instant checker for instant checking, and also have pylint + pep8 as a commands for deeper checks. You can find [my config on bitbucket](https://bitbucket.org/gryf/.vim/). I always do the checking before releasing the code. Unfortunately, pep8 utility doesn't check naming convention for functions/methods, so I has to combine pylint (because it can do it) and pep8 into one tool at my work. 
PHP has a sprint function, but it doesn't have the percent syntax. I came from PHP via Java and I certainly didn't recognize it until I read the docs. I agree that this is the kind of question you should usually be able to sort out yourself, though. Bothering real people with a question like "what does the modulo operator do when you use it on strings?" is a bit disrespectful, though I wouldn't expect newbies to necessarily know about operator overloading (not all languages have it, also not every Python newbie has programming experience in another language).
Going by [the most relevant Google search result for Python string formatting](http://docs.python.org/release/2.5.2/lib/typesseq-strings.html), I would say this is probably the minimum field width. I've never used that, though, so this is just a guess based on the given syntax.
On some set of benchmarks that may or may not be representative of your application :) That's sort of the point.
Excellent question, I think we want to pull in the 2.7.2 stdlib first at least.
I really hope there is a fast base matrix/array class that works like C++/Eigen library. With that as the base class, I am willing to switch from C+++ to python for numerical coding any days now
I'm not familiar with that class, but if you use array.array as your starting point the JIT will like you just fine. For example https://github.com/jtauber/minilight/blob/pypy/image.py#L28 shows an efficient way of represening an image.
tldr: There is no meaningful definition of "average."
1. PHP's sprintf *does* have % syntax in it: http://us.php.net/manual/en/function.sprintf.php 2. This isn't even a newbie question. this is an, "I'm too lazy to do my homework" question. The correct answer to such a question is, "Go do your homework!" :)
Very nice. I'd like to see this single comment as the big takeaway from this thread. The bit about Python being both a gateway drug to programming and easy to get started with are the two big things I think that will help Python being a leading member in the curbing of gender divide in the programming field. If something is easy to do and can be done in small bursts (i.e. something like in gaming with casual games such as Farmville.) then I think a lot more people in general will take up the hobby, many being female. If programming python teaches someone the basics, then I believe that they can take the basics to any other language and use them there since Python has pretty much every major idea used in other languages. All in all, I think Python is, or at least *should* be the go to language for any newbie.
pyflakes is good and fast and safe and everyone should use it. pychecker is slow and works based on importing the module then introspecting it, which can be dangerous if the module has top-level side effects. Also, it's kind of dated. And it gives a lot of false positives. So I don't recommend pychecker. pylint is very configurable, and can do things that pyflakes doesn't do, but in its default configuration it gives way too many false positives. I don't use pylint but I can see how it would be useful for someone. pep8 just checks style, and does it quickly and concisely. I recommend pyflakes and pep8.
The high overview of the library is that Eigen is a c++ matrix expression library that support lazy evaluation and highly vectorised matrix routine. [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page) It seems that expression-oriented library is the future of vectorised calculations
Ah, so you'd probably be interest in our work on a high performance numpy reimplementation.
How far along is that? Is it possible (or worth it) for me to try to move all my numpy code over to pypy?
Depends how much of NumPy you use, it's unlikely (although it does support all of the stuff my company does, we use *very* little of numpy), it's very easy to contribute to though, so if you're only misisng one ufunc or something you can easily add it.
I guess it is not the ufunc that I am not able to implement. It is more like the operator overloaded for optimize matrix and multidimensional array slicing. For example. something like A[:-1, :-1] * x[1:] 
ATM we only support 1D arrays (of floats). n-dim and proper dtypes support are being worked on. We have most operators for arrays though, so you can do: d * x - v / z and it's super fast :)
Look up fabric, requirements.txt, virtualenv and/or puppet/chef. Learning all of them is easier than buildout IMHO.
How about printing 10^googolplex? Check out this topic on stackoverflow... http://stackoverflow.com/questions/4676011/print-1-followed-by-googolplex-number-of-zeros
1. No, it _doesn't_. It does share the _formatting language_, though. It has a function instead of overloading the modulo operator -- mostly because as usual PHP likes to be verbose about it and define a function for every possible thing you might want to use `sprintf` for. 2. I would argue that it's less about homework and more about knowing how to use a language reference properly so you can look this kind of stuff up. The docs are pretty straightforward once you get past the fact that it's actually overloading the modulo operator to do the trick.
1. No, it _doesn't_. It does share the _formatting language_, though. It has a function instead of overloading the modulo operator -- mostly because as usual PHP likes to be verbose about it and define a function for every possible thing you might want to use `sprintf` for. 2. I would argue that it's less about homework and more about knowing how to use a language reference properly so you can look this kind of stuff up. The docs are pretty straightforward once you get past the fact that it's actually overloading the modulo operator to do the trick.
o_O
If you're not familiar with sockets, I'd go with that. Twisted might have some really cool features, but understanding the socket API is ridiculously valuable.
1. No, it _doesn't_. It does share the _formatting language_, though. It has a function instead of overloading the modulo operator -- mostly because as usual PHP likes to be verbose about it and define a function for every possible thing you might want to use `sprintf` for. 2. I would argue that it's less about homework and more about knowing how to use a language reference properly so you can look this kind of stuff up. The docs are pretty straightforward once you get past the fact that it's actually overloading the modulo operator to do the trick.
In that regard, I'd recommend reading [Foundations of Python Network Programming, 2nd Edition](http://www.apress.com/9781430230038). This is an almost complete rewrite of the first edition, and while it covers more than just socket programming, I found it to be a great resource for low-level network communications as well.
Some useful general links: http://www.reddit.com/r/gamedev/comments/ackhu/seeking_multiplayer_networking_design_patterns/ http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/ Some helpful Python libraries: https://code.google.com/p/legume/ http://mccormick.cx/projects/PodSixNet/
Certainly, but this is not a comparison of technologies. Buildout and the Python buildout are just more tools for your Python shed if you are interested. If you aren't, that is fine too. :-)
I built a socket server in Python a few years back with a buddy of mine who creates Flash games. I think I might have some valuable tips for you. I'll be honest with you up front - I spent hours and hours and hours on Twisted and never got a grasp on it. I've heard this from others too (you might have better luck). Personally, I don't feel there is a need to use Twisted. As a programmer buddy of mine says, "now you have two problems" i.e. wanting to create a socket server as well as having to learn a huge framework. I think it probably makes sense in some cases, but I could never understand it. Fortunately, for what we were doing, we could use basic Python modules, keep things very simple, and still get a relatively high performance socket server. I researched all the main Python books (using Safari Books) and tested the various socket server implementations - multi-threaded, asynchronous single threaded, etc. I even tested Stackless Python, since that's what Eve uses. I eventually just wrote a simple single threaded server that would (I believe this is the terminology) multiplex multiple users using the select OS call. I haven't read through it all, but [this](http://www.nightmare.com/medusa/async_sockets.html) site seems to explain event driven programming in detail. This is essentially what Twisted is only on a much simpler level. What I found was that we could handle 100s of clients easily using just one thread (even into the 1000s). The code for this was VERY simple too (especially relative to Twisted). You should be able to find example code somewhere. I might even be able to dig up some old code somewhere and send it to you if you're interested. Another thing we did was create a custom JSON implementation (our communications protocol) that made a lot of assumptions to save bandwidth. For example, we removed all spaces, quoting, etc. We also abbreviated commands and arguments to numbers to reduce bandwidth, so argument "command" would be 1, the command name might be 2, and so on. Surprisingly, this worked very well. The raw JSON looked something like this: {1:2,3:Blah Blah blah} Before substituting arguments for numbers (compressing the JSON string, essentially) the JSON string might have looked something like this: {command:sendMsg,data:blah blah blah} Coming up with a protocol is pretty easy too, by the way. Everything we did was in the very basic format of {command:cmdName,args:...}. I coded a basic handler that took whatever he sent as a command, and ran the Python method do_cmdName. Pretty simple stuff. As for authentication, we came up with our own system that I know is basically something else (I can't remember what) but it had to be (hopefully) unbreakable, because Flash gamers always like to hack scoring systems (probably a lot of bored kids with lots of time). This is how it worked: * Client connects to server, issues "sendToken" command with a username * Token is generated (just some basic text, like a random password) and sent back to the client * Client takes token and some other data and hashes/encrypts it with a pre-shared key (like a developer or API key) * Server users PSK to decrypt response, and if everything matches up, user is authenticated As far as we know, the games we did with it have run for years without being hacked. We only did a couple, but this method seemed to work great for what we did. So again, I wouldn't use Twisted or any other framework. I would just use basic Python for what you're doing and keep it simple. Building a fairly high usage socket server is pretty easy with basic Python modules. Let me know if you want any more info or some sample code. I'd be happy to share.
Interesting post particularly the notion of peoples expectations on speed. I've been running quite a few monte carlo simulations recently on pypy vs cpython and the results often seem to surprise me. I'm glad to here Maciej is welcoming of slow benchmarks :). I wonder if might be nice set up some site, to act as a sort of open benchmark comparison for different implementations of python ?
Wow! This is exactly the reply I need. Your thoughts about Twisted seemed to mirror mine. I didn't want to have 2 problems instead of one. As for the auth, that was the other thing I was thinking about. I wasn't sure I wanted to veer away from Twisted that quickly because they offered an authentication framework as well, but now with what you say I may just continue using sockets alone. It's a learning experience anyway! And example code would be awesome if you could provide it, I'm just starting out with Python sockets, I've done a decent amount of Java socket coding, but examples are always great. Thanks!
Thanks, I'll check out those links! So far from what I've read, they will be useful for me :)
Yup, that's what I was thinking as well, I've decided to push on using sockets, and let Twisted go to the backburner for now at least.
I used twisted for a realtime online Go playing server. Where people could join and challenge other users. It can take a few days to master but it's really worth it. No other networking framework will offer you what twisted gives you. And you don't know when you will need one of that features.
I'll check that out! I love having new books to reference while I'm attacking a project.
OP asked about the percentage sign**s**. That means the OP doesn't know what "%s" means.
Might I be able to see the source, or maybe get some links to suggested tutorials if you know of ones you used? :) I really WANT to use Twisted, I just am having some trouble wrapping my head around it enough to start writing my own server/client implementations.
The modulo operator is used several times in that code, so it's valid either way. It's a moot point anyway. What exactly are we arguing about? sprintf is ugly unless you're used to it.
You're welcome. Since you seem to be set on using Twisted, here's a link to a tutorial: http://krondo.com/blog/?page_id=1327
http://speed.pypy.org/comparison/
BUILD ALL THE THINGS
post back when they're available.
Valve has some nice articles on they're SDK wiki about tips and tricks when it comes to networking in games. It is not excatly what you are looking for but they are well worth the read. http://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking http://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization http://developer.valvesoftware.com/wiki/Networking_Entities
It'd be great if you could dig up your code!
What are your scalability needs? For example a solution that copes with a million users is every different than supporting 8 players total. There are also issues with what you need to defend against. Cheating? Stealing credentials? Snooping? If you are doing this on a very small scale and don't have to worry about bad things then regular sockets will work just fine. What I recommend you do is use multiple threads and use the [Queue](http://docs.python.org/library/queue.html) to send messages to a master thread and the various connections. Eventually you'll be able to grow a design that passes messages around to work across servers and plumb in things like security.
Can you list some of the advantages you found in Twisted? What exactly do you mean when you say "No other networking framework will offer you what twisted gives you"?
I am using pylint and I love it for being so picky :-) Does the job well. Having somebody complaining "your code can be better than it is" and pointing fingers at it is motivating, even it's a lint program, not a human being who does pair programming with me. I do refactorings more often. Yes, I have to do them myself, I can't cheat by saying "yes, be my guest and show me how would you do it" which works with a pair programming mate. Another tool I love dearly is CloneDigger. It has a different purpose (finds redundant code blocks AKA clones) but finally it helps me as well to get my code in a better final shape.
[GalaxyMageRedux](http://galaxymageredux.googlecode.com) is implemented in Twisted.
http://twistedmatrix.com/documents/current/core/howto/index.html
I bet I could build 100 Pythons.
I would recommend using Twisted, and understanding the Event Loop and Event Driven Programming. Essentially, you have players connect and do what they will, and any output that will be sent to them gets accumulated in a buffer, and then at set intervals (Perhaps every .5 seconds), you send the entire buffer the the player. Twisted is fairly complex, but once you get the hang of it, it's really powerful.
I built a multiplayer web game server in python, using tornado. pretty straightforward stuff.
So here is one of my college projects... I don't know if this will be a good read because it's *not* documented. Here it is http://code.google.com/p/goplay/ Backend uses python with twisted. Frontend uses Flex. Edit: If you venture into reading the source and have a doubt. Just ask me.
Because of this, I just discovered the interactive interpreter's help(&lt;object&gt;) method. It's awesome.
could still use those docs though! btw, also check out [inspect.getsource](http://stackoverflow.com/questions/2055110/is-there-a-way-to-view-the-source-of-a-module-from-within-the-python-console)
r u looking for something like Factory Method used in software engineering? see the think in python book. may help u
You can just use google to find the page you're looking for and press the link to the cached page.
...and that's why you should always download docs.
If you use Linux, this helps: sudo apt-get install python-doc open file:///usr/share/doc/python2.7-doc/html/library/index.html in a browser 
I'm sure there's a mirror somewhere. Go download it.
`help()` is so useful. Whenever I can't remember the syntax for a method belong to a builtin, I fire up a new shell, start python, and run something like `dir("")` followed by `help("".join)`. It's awesome, and probably one of the reasons I try to be conscientious about writing docstrings.
I'm not quite sure, but I don;t think so (knowing factory in php). What I'm trying to understand in python is how extensible classes and method/function over rides work. I have the concept in my head of how to do something, but no concrete examples. Lets says you have this: MainClass: Every class extends this for new feature Handles socket data Class the extends MainClass: When subroutine is called in MainClass is called, the method in this class over rides it. 
http://readthedocs.org/projects/python/
Just want to say thanks for everyone posting answers and replies. There's a ton of useful information in this thread.
I don't know if i fully understand, so i am just gong to start typing and see if it is close to what you are looking for class BaseDoer(object): def connect(self, host, port): #create a connection def send(self, message): # send messages to our connection def handle_stuff(self, stuff): raise Not ImplementedError class FooDoer(BaseDoer): def handle_stuff(self, stuff): #do some foo type stuff here class BarDoer(BaseDoer): def handle_stuff(self, stuff): #do some Bar type stuff here def give_me_some_doer(Doer): doer = Doer() doer.connect('127.0.0.1', 8080) doer.send("Hello") doer.handle_stuff('stuff') give_me_some_doer(FooDoer) give_me_some_doer(BarDoer) wow the word doer is really weird
&gt; sometimes gets to speeds of C. I see what you did there!!! :p
This is my favorite tutorial starting from scratch, building with MVC pattern, and including Twisted for over the network event handling. [sjbrown's Writing Games Tutorial](http://ezide.com/games/writing-games.html)
It's a little bit late but... [Learn Python in 10 minutes](http://www.korokithakis.net/tutorials/python/) is quite nice if you have a background in another language. I also found [PEP-20 by example](http://artifex.org/~hblanks/talks/2011/pep20_by_example.html) to be beautifully written. (this might still help you grasps various aspects of python.)
Completely off topic, but the name made me think of this: http://www.youtube.com/watch?v=6hcoT6yxFoU
Note that you can also use the command pydoc which show the doc directly. Ex : `pydoc str` or `pydoc module.submodule.object` 
Looks neat, thanks
For Python 2.*...
And if you're looking for help on a builtin (e.g. `dict`, `str`, ...) they live in the `__builtin__` namespace.
So, the only advantage over MySQLdb is pypy support?
Operation Fail.
Blasphemy &amp;#3232;\_&amp;#3232; 
Better be honest about it than let the situation rot further.
You had me at "Facebook is discontinuing".
I'm glad that I've discontinued my use of Facebook.
[Stats functions](http://office.microsoft.com/en-us/excel-help/statistical-functions-HP005203066.aspx) such as average, geomean, correl, covar, var, skew, stdev, rsq, linest, and logest.
Nice one thanks i'll take a look into those.
[Link for Python Osmosis](http://python.sourcequench.org)
I've discontinued my use and support of Facebook. (Actually, I've never used it much; just to get in touch again with IRL people from a long time ago then I ditched it for email and telephone.)
Someone can just fork the project on Github.
I guess Google will release a great Python SDK for Google+ ;-)
Yes, marketing executives.
http://www.doughellmann.com/PyMOTW/select/ This is great start for select and socket, I use it almost as is.
Another vote for this book. It's the best Python book I've bought in a couple years.
Ah well, Google+ it is.
I've done a multiplayer game with Twisted Perspective Broker. It's fantastic. The catch is that both sides need to be in Python with Twisted. And Twisted is definitely a framework not a library; it's in charge and you have to do things its way. But my opinion is that it's probably worth it, if you know that your server and all your clients will be Python. There's a tutorial [here](http://twistedmatrix.com/documents/current/core/howto/tutorial/pb.html)
Twisted is invaluable. For the price of an amazing network library, you also get an excellent concurrency framework.
If you do your own socket protocol, you have to think about things like: 1. Do I use TCP or UDP? 2. If I use UDP, what happens if a packet gets lost? 3. What if my TCP send gets split into multiple packets? How do I detect that and stitch them back together? 4. What if multiple TCP sends get merged into one packet? How do I detect that and split them apart? 5. How do I handle multiple clients? One thread per client, one process per client, or a single loop using something like select() calls? 6. Is all that code portable? Twisted has already solved this low-level stuff for you. If you want to learn about networking, you should solve it yourself. If you want to get a game done, you should learn Twisted. I don't know of another networking framework that offers everything Twisted does, though of course there are always more frameworks appearing.
If anybody actually uses these, I really would love to hear about it :). The second script is very much a hack and smash, but it works fairly well (at least it does for me).
Yes, I believe so. Basically, the class handling the connection will parse everything that comes in to the client. Such as receiving 0x05 could tell you "a new player entered", so you would call newPlayer(), which does nothing in this class. However, in another class , maybe one that just greets the player, would use this to send them a hello message. There could also be another that just loads info stored about the player, and when they enter grabs the data or something. The point is, I will have about 4 different bots, so these other classes I want to just be able to import, instantiate them and let it roll from there, as I did with action script version. So pretty much, when you instantiate one of the imported classes, they are what start everything. No need to touch the main socket stuff again except possibly to add future updates from the game. Again sorry, really horrible at explaining this :D Thanks very much though, I think what you have given is prob what I'm looking for, just gonna play with it a bit.
There's no Python SDK for Google+? What are they waiting for, the platform to be finalized and opened to the public or something?
I don't think there was one in the first place.
The reason is that Ruby (and Rails) have pretty much won. I know I'm going to get massive downvotes for this, but please read on first - this is coming from someone who spent 4 years using Python. I started using it in science (where Ruby doesn't hold a candle to it), and figured it was an easy step to use it for the web. I used Django and Twisted, and I love Python's elegant functional syntax. I can't think of a more elegant function evaluation syntax (except maybe Haskell), and the way it's mated with the module system and dot operator should be a case study for any new language designer. But, I got tired of looking for libraries (e.g., Redis, MessagePack) that were out of date, had low update frequency and were missing features only to look over in envy at the Ruby world and see the hum of activity that makes everything work. I started wondering why are all the best deployment tools (Chef, Puppet, capistrano) written in Ruby? I switched over, and was just stunned by the quality of the tools. RVM blows away virtualenv for ease of use. I originally chose Django over Rails because of a perception that Django is more modular, consisting of several loosely coupled, but well-designed components. But then I met the monolithic authentication system which loads up your user model with all kinds of broken assumptions that simply don't work for modern web systems. Then, the huge anti-pattern of the ORM, beautiful magic that leads people down a SQL-join scaling hole they'll never climb back out of. After all of this,I peered over into the Ruby/Rails world. Folks, if you haven't looked at it, you should. Ruby authentication is beautifully designed. Check out Devise/Omniauth. You'll spend a week or worse mucking with getting OAuth working in Django, where you could get this up and running in 15 minutes in Rails. And then there's Rack - the standard for Ruby webservers that enables interoperability between frameworks. Keep digging, and you'll find more well-thought out and industry-tested patterns throughout this framework. Interested in non-blocking code? How do you make your current Django webapp into a non-blocking service? You'll have to rewrite it in Twisted, or use a clumsy message queue. But, go and check out Fibers and Eventmachine in Ruby, super light-weight and efficient approach which enables you to instrument existing views in a snap. Just a few examples. The point is, like it or not, that the heat has moved over to the Ruby world. I spoke with a Ycomb alum recently who hit it on the head - "the main success factor in the web is getting things out fast. At this point, Rails has moved so far ahead that if you're not building a new project in it, you're just doing it wrong". Rails has won. The ecosystem of tools in Ruby world is just so much greater (for web development) than Python. And you're seriously hurting yourself (unless you have some really unusual compelling reason for staying in the Python world) if you're not starting out with Rails.
Nice post, but slightly off-topic if Facebook doesn't have a Ruby SDK. As an aside, Python is my favorite programming language, and I use it a ton at work, but to learn Ruby I'm redoing my personal site with Sinatra. You've made me question whether I should have jumped into the Rails world.
I think you might get massive downvotes because **there has never been an official Ruby SDK for Facebook**, and there are no signs that they plan on creating one. I am glad that Ruby and Rails work for you, and that you enjoy working with them. I feel the same way about Python and Django. However, we differ in that I do not believe that my language and web framework of choice need to "win" some battle over the hearts and minds of developers, or that they are even competing. You might see this story as being about the decline of Python for web development. I think it is about Facebook's lack of a good relationship with their developer community, their failure to understand how distributed version control works, and their inability to communicate effectively. Since Facebook is seen as relatively successful, it is possible that their behavior could have ripple effects across other companies (who might begin to think that rapidly changing APIs and ignoring developer concerns will not have serious effects on their bottom line).
I think your is very skewed at this point, python web development does not end on django. In fact there are greater more interesting offerings like pyramid and others - that take completly different approaches to webdev than django. Massive amounts of libs and applications for linux based systems are written in python, not ruby.I've also used redis and many other systems in my work, they "just worked"TM. If you enjoy ruby that is cool, but saying that it has "won" is just FUD. I could try to look for ***** bindings for ruby that suck compared to python, just to prove something opposite, but that is not the point to be silly. Don't be a fanboy its bad for your virtual penix.
im pretty sure it will land in python-gdata package ;-) maybe lets wait for any apis get public first.
One huge advantage of Python is the sheer number of scientific and numerical libraries for it. This doesn't affect most webdevs admittedly, but it is nice to always know that you can do everything you'll ever need to in a single language. 
I don't know. All the job posts where I'm at are Django.
Now I feel , I miss even less not using facebook
So looking forward to it.
&gt; There are 129 different versions of the python-sdk floating around on github 
Nice troll. I've seen shitty projects in both Django and Rails, and excellent masterpieces. The difference in productivity, as always, comes down to the strength of the team more than the tools. I've tried Rails and found its magic maddening and its lack of stability (hey, Prototype! No, jQuery ! Wait CoffeeScript !) in pursuit of the next best thing irritating. But some people love it, and if it works for them, great. I really don't give a shit about the YC crowd; Hacker News has the occasionally interesting article these days but the dimwit memes repeated ad nauseam by college kids playing entrepreneur just makes me grit my teeth. Reddit can be idiotic at times but even on bad days it has a sense of humor and healthy self-deprecation.
nice interesting article
I usually stick with the Python docs on the official website. After you've learned the actual language itself, which the docs are amazing for teaching you--newer ideas should come from various websites regardless of what language they teach you with.
Great advice. Thanks a lot.
Exactly the reason I chose python initially.
Agree - the other frameworks are better, but the attention they get is small, which overall means less support.
That's a bit of an oversimplification. For example, Twisted doesn't solve "Do I use TCP or UDP?" - usually you still have to pick one or the other, and handle the consequences. Or are you talking about some specific high-level part of Twisted? In which case, the original poster is going to need a lot more guidance than just being thrown into Twisted for a few days. EDIT: I see from your post below that you seem to be talking about PerspectiveBroker. That's fine for certain applications but for many games applications you won't want what it offers. In particular, any kind of RPC system just changes the problem from a complicated networking problem to a complicated interface problem, when sometimes it's easier just to pack some simple values into a message and send it off, doing the reverse on the other end.
Google's made a huge commitment to python (including hiring its creator), I'd be surprised if a python SDK wasn't in the works.
they are diffrent for sure, better for me doesnt mean better for you ;-) but you are again wrong saying they dont get support, things like pylons are rock solid for years now - in case you dont know reddit is built on a very old version of pylons. 
by Excel plug-in you mean a VBA "add-in" ?
&gt;reddit is built on a very old version of pylons I don't completely agree with what abudabu is saying, but I think he makes a valid point for some people. Reddit switched from Lisp to Python for many of the same reasons abudabu is suggesting some people should consider moving from Python to Ruby. 
that one is fine...actually reddit seems to love it. if you want a quicker/shorter one there's "dive into python", "byte of python" BTW your question is like "I'm soooo thirsty since 7 months ago, which bottled water should I get...." 
I've been on it for 3 hours straight. It's helping out quite a bit. Thanks.
nuke
Well everyone can use their set of tools, but information abudabu provided here are in my opionion incorrect.
Good for you! Never would have thought of using python and opencl with office myself... sounds like oil and water :-) 
What are PyPy plans regarding support of Python 3? 
If you have a slow benchmark you can literally file it as a bug, that's what we consider it.
For your first networked program, you're probably best off using the raw sockets async style to get a feel for what it's like. After you start understanding the common patterns used in network programming, the design of Twisted will make a lot more sense. As you gain more experience, you will probably find yourself re-implementing concepts from Twisted like `Deferred` and stacked network protocols if you don't take the leap and switch over.
That was my objective in writing it, I claim it's also more maintainable, easier to hack on, and someone told me it was faster than pymysql on CPython so it may be faster as well.
I didn't say they don't get support. I said the Ruby world gets more support. Personally, I like the Python language better than Ruby. Envy of the Ruby ecosystem made me switch. 
I think they are trying to port everyone to their Javascript SDK. They should probably support python, even their tornado open source stuff is in it. 
Exactly. The site with docs can go down, but also your internet connection can go down and you're toasted without a stashed pile of offline docs. I knew a guy who always used to crack his knuckles when the internet connection was going down, display an evil grin and say "Well, time to actually do some work, lads!". Such a positive attitude always helped to overcome the stress. 
there is so little explanation about what the point of this is, so I may be wrong, but I doubt its better than just using the standard lib and scikits.learn
After you read "Learn Python the Hard Way", go over [Think Python](http://www.greenteapress.com/thinkpython/thinkpython.html). The book covers some useful information not found in "Learn Python the Hard Way". After that, you should be pretty well equipped to start coding whatever you want. I also suggest reading the [Python Style Guide](http://www.python.org/doc/essays/styleguide.html) before you start coding though. Always good to follow existing conventions. If you want to start web development with Python, the [Django Book](http://www.djangobook.com) has been great.
let me see if i can wrestle some data from the excel or a sister team for you (i work for msft, but no promises... ).
I'm working through [this](http://www.amazon.com/Python-Programming-Introduction-Computer-Science/dp/1887902996), right now. Its intent is more to teach general CS concepts. There's a good chance that once I'm done, I'll want to work through something that's more about *thoroughly* learning Python. I guess you'll have to tell me whether this book fits that bill or not. If it does, I'm definitely game.
Thank you so much. This helps a lot.
The feeling is mutual.
Yup am going through this myself inbetween work and child wrangling (and minecraft when I'm burnt :-P )
they switched because they couldnt find people who use lisp and there many more people who use python than use ruby so no, it's not really the same reason
Sorry, of course it's an Add-in.
Great, whatever you can get is appreciated.
this works as advertised but make sure you are using python 2 and not 3. this knowledge would have saved me a few headaches
Hmm, gonna try to get some bindings working for Speex using that ctypesgen...
"Think Python" is an amazing guide, especially for a person who has never done any programming before. It was the first guide I read and after that I was familiar enough with the language to do whatever I wanted. I'm currently reading http://diveintopython.org/ which is a nice step up from "Think Python" as it goes a bit deeper into the code, but I feels it assumes some prior knowledge of Python or other languages.
Apologies, I didn't mean to challenge what you were saying, it is still good advice.
but how do you measure the level of support, can you back that up in a meaningful way ?
You like Rack? You know it was inspired by wsgi from Python, right?
Django is Python. You use Python library support heavily when using Django. In reverse, you will not lose whatever Python libraries you use when not using Django. When using esoteric platforms, you may need to write a little more glue and know a little more about the underlying libraries, but the heavy lifting you never need to repeat.
I recently started integrating it into a toolkit I'm writing that is focused on data migrations. I was looking to build in some data flow aspects and this library matched pretty closely with what I had in mind. My goals are more focused on building a Django-centric declarative framework for specifying data migrations/conversions and so the data brewery lib is serving more as scaffolding at this point while I hash out the more interesting bits. I spent a bit of time looking through the code and docs and debating about whether some of the abstractions are a good idea. I'm happy with it for now but will see how I feel about it once I do some real world testing. I don't think some of the Node implementations will scale well with large data sets (for example the SQL Source selects the entire table). I'll probably end up writing my own Nodes, Source/Targets and Pipes - at which point the lib won't provide as much out-of-the-box value. I'm not a data miner and my understanding is that the Cubes project is supposed to complement the Data Brewery lib so I can't speak to how suitable it is in this problem domain. I agree that the docs could use some more in-depth examples. 
I'm working through it. It's a great way to grasp all the concepts. What book would you suggest after that? I'm interested in web dev using Python, but book I found are either topic specific ("Python: Doing Blogs In Django For Dummies") or too advanced for me.
How do you use them in WingIDE?
You don't look at the source code before you run random scripts on the web? All the print statements gave it away for me.
[pep8panel](http://bitbucket.org/stj/pep8panel/wiki/Home) and [PyFlakesPanel](http://wiki.wingware.com/PyFlakesPanel) after turning the CONFIGURATION part, and you can find them by menu:Tools -&gt; PEP 8 etc. 
I am working through Zed's book and [this](http://www.amazon.com/Practical-Programming-Introduction-Pragmatic-Programmers/dp/1934356271/ref=pd_sim_b_3).
I just discovered this from him as well. Pretty neat, imo. You can use it for slicing lists as well, although I think it gets a little unintuitive if you use it for that. &gt;&gt;&gt; l = range(1,11) &gt;&gt;&gt; l[:~2] [1, 2, 3, 4, 5, 6, 7] &gt;&gt;&gt; l[::~2] [10, 7, 4, 1] &gt;&gt;&gt; l[::-(~2)] [1, 4, 7, 10] &gt;&gt;&gt; l[::~2] == l[::-3] True &gt;&gt;&gt; l[::-(~2)] == l[::3] True And also: &gt;&gt;&gt; l[2] == l[~(~2)] True
This is a bit of a hack, why not just use the normal syntax of -1 for the last element, -2 for the 2nd last element, etc? The only reason this works is because negative numbers are represented in 2s compliment, which means that -X can be represented as ~X + 1. Maybe I shouldn't be trying to understand this after a few drinks on Friday night but to me it seems very hackish to me to use 2s complement binary logic just so that you can avoid adding 1 to an index.
I think you just volunteered.
Why not just set an accurate shebang line?
What do you mean? As in python2 / python or python3? The issue I see with that is that for some distros, "python" symlinks to Python 2, others Python 3, and python2 is not a common enough symlink that it can be relied upon, especially on older distros.
This article is 2 years old and should probably be ignored, pyPgSQL stopped being maintained long ago and psycopg2 has had several releases since then and has a new web site that documents what used to be confusing at the time this was written. The only thing to take out of this article is that you should use psycopg2, but don't listen to what it says about psycopg2, go to the source or read a newer/better article about it.
&gt; As with pyPgSQL, the transaction-as-default-behavior thing is thoroughly brutal. As far as I can tell, this is not something the DBAPI2 PEP demands. Yes, [it is](http://www.python.org/dev/peps/pep-0249/), I've been explaining this to people for years: &gt; .commit() Commit any pending transaction to the database. Note that if the database supports an auto-commit feature, this must be initially off. An interface method may be provided to turn it back on. auto-commit feature, what's that ? Psycopg2 supports it just fine: conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT) Also as the comments point out psycopg2 certainly supports explicit cursors through named cursors. 
Disclaimer: I wrote the article. I still see some confusion about what exactly closures, first class functions and anonymous functions are, so I decided to write this. 
I think your blood/alcohol content just hit the Ballmer Peak. Yeah, he's just trying to avoid an off by one thing. He can easily do X[-2], but he wants to do X[~1] so the last elements in the list start at 0 instead of 1. X[-1]==X[~0] X[-2]==X[~1] X[-3]==X[~2] In python ~x is defined as 1-x. 
I think that distros and Python should name the binary to the relevant version of Python. "python2" or "python 3", but no "python" binary.
This sort of magic and underspecified solution violates the Zen of Python ("In the face of ambiguity, refuse the temptation to guess."). It's not a very good idea. Whenever people try something like this it invariably fails in some unpredictable sort of way.
There should be no "python"...it should be "python2" or "python3" or the specific version like "python2.7.2" etc.
More exactly, closures make codes like following pattern able: &gt;&gt;&gt; def account(n): ... def add(m): ... nonlocal n ... n += m ... return n ... return add ... &gt;&gt;&gt; a = account(0) &gt;&gt;&gt; a(10) 10 &gt;&gt;&gt; a(5) 15 However `nonlocal` was supported from Python 3, so you have to work around it from Python 2: def account(n): n = [n] def add(m): n[0] += m return n[0] return add 
This could be really useful...
no magic, explicit, simple succinct and correct.
Thanks for writing this! I understood the mechanics of closures before reading this, but not the 'why', so thanks for including the use case! All of the other examples I've seen are of this variety: def example(x): return lambda: x+1 ...which just looks like a complicated way of doing something simple, though I may just lack the imagination to see the applications. Could you be persuaded to give a few more use cases? Either on here, or on your blog? I personally find them very useful. Either way, good work!
The absence of a README will deter a lot of people from wanting to check out your project. A brief description and a sample code snippet would be a big help.
`~x` is not equivalent to `1-x`. It's equivalent to `-x-1` (not valid for floats). It's the logical complement of all the bits in the number. Recalling that negative numbers are in 2s complement form (i.e. take the complement and add 1), then the complement itself is like subtracting 1 from the negation.
Yeah, took me a while before I clued in and looked at `test.py`
Well I'm glad it worked :). I didn't even think to mention that it was python 2.x -- I don't really know anybody actually using python3 yet.
Ya… Unless it promises to save me a *lot* of time, I ignore basically any repository without a README. I feel like, if the author hasn't spent the 15 minutes it takes to bang together a quick README with a couple examples, then either the project isn't very mature yet, or the author is just throwing some “internal” code online… And I don't really care to spend my time on either.
Sorta; I think it should be only to the second level, "python2.7" for example. The last one is just a patch level; any version (hopefully the latest) should be fine, right?
This is specific to Windows, but the points it tries to fix are already existent on Linux: http://www.python.org/dev/peps/pep-0397/
why not [Simple, elegant HTML, XHTML and XML generation.] (http://pypi.python.org/pypi/html/1.16)
I am brand-new to python, so I may have done nothing right here.
1. Close your input lines with ) 2. The output will be in days, you have to divide by 365 and convert to integer for the year value. 
you're close. a is an int object. b and c are also int objects. today is a datetime object. bday is a date object. unfortunately you can't subtract a datetime (today) from a date (bday). There's no really good reason for that, but you can't. you can fix that problem easily, by making today like this: &gt;&gt;&gt;today= datetime.date.today() then when you subtract them,you get a different type of object again - a timedelta object. You'd expect this to have things like "years" and "months" and the like, but it doesn't - it basically gives you days, seconds and microseconds. if you print it, you'll see something like this: &gt;&gt;&gt;age = today - bday &gt;&gt;&gt;print age 9999 days, 14:32:10.12345 &gt;&gt;&gt;print type(age) datetime.timedelta it might boggle the mind, but this really is a bit of an awful omission in Python. There are various libraries around that give you much better date/time/difference classes to work with, so you could look for one of those. Alternatively, if you're trying to learn python, take a look at how to "do it properly". The fact this kind of code isn't in the datetime.timedelta class by default really annoys me, but hey ;) http://code.activestate.com/recipes/498062-nicely-readable-timedelta/
Unless you want to use a third-party module (see link), the following seems to work: import datetime a = int(input("enter birthyear: ")) b = int(input("enter birthmonth: ")) c = int(input("enter birthday: ")) today = datetime.date.today() bday = datetime.date(a, b, c) # http://stackoverflow.com/questions/765797/python-timedelta-in-years/765862#765862 age = today.year - bday.year if today.month &lt; bday.month or (today.month == bday.month and today.day &lt; bday.day): age -= 1 print("You are,", age, " years old") # see that same page for other solutions 
Sure, it was just an example.
He mentions code is on Github, but there's no link to it in the article. Anybody know where it can be found?
 #!/usr/bin/env python import datetime now = datetime.datetime.now() birth = datetime.datetime(1968, 1, 1) delta = now - birth print 'you are {0} years old'.format( int(delta.days / 365) ) # *"you are 43 years old"*
... or the also recently announced [DataTree](https://github.com/bigjason/datatree) (and [reddit discussion](http://www.reddit.com/r/Python/comments/i7251/datatree_a_new_dsl_for_creating_structured/)) which also tries to use Python context managers to create the "DSL". What really annoys me though about these types of libraries is two fatal flaws: it's not a perfect mapping between Python names(identifiers) and XML names and, secondly, they can't handle XML namespaces. You'd think they would at least use Python context managers for namespaces, but let's ignore that and look at some valid element names that cannot be represented in Python: # -*- coding: utf-8 -*- from lxml import etree print etree.tostring(etree.fromstring('&lt;x-/&gt;')) print etree.tostring(etree.fromstring('&lt;_.../&gt;')) print etree.tostring(etree.fromstring('&lt;_À/&gt;')) 
woops. I did in the code, just not when I rewrote it for this post. Thanks. 
but what If I want it to accept any date as input?
At what point is the resulting free variable removed from scope? It seems like a program could end up with a ton of these floating around and unnecessary. Good write-up. I have a better grasp on the ideal -- I still don't like it, but I understand it better. The whole thing seems geared towards making code shorter, and often more obscure than your OO example. 
 YES! This works the way I need it to. Thank you.
on kivy.org they have a link to it.
Note, if you're born on 2/29, you'll typically celebrate your birthday on the 28th, except for leap years. I like the following approach that I found on [Stack Overflow](http://stackoverflow.com/questions/2217488/age-from-birthdate-in-python/2259711#2259711): def calculate_age(born): today = date.today() try: birthday = born.replace(year=today.year) except ValueError: # bday is 2/29, and it's not a leap year birthday = born.replace(year=today.year, day=born.day-1) if birthday &gt; today: return today.year - born.year - 1 else: return today.year - born.year 
I know how to fix the solution in general. This was addressing the debate of handling python2 and python3 scripts simultaneously on a system.
Presumably when there are no more references to that function.
Love this! If I ever have the misfortune of writing SOAP interfaces again this is how I would de-serialize incoming SOAP messages into Python objects.
This is actually one of the few use-cases I ran into, and it's the first time I've actually needed closures because I didn't know the OO example at the end of the article also worked. I assume other examples of closures are all more or less the same: avoiding global variables.
This sounds like a perfect opportunity to use a decorator: def tryFunc(*exceptions): def decorate(f): def inner(*args, **kwargs): try: result = f(*args, **kwargs): return result, None except exceptions as e: return None, e return inner return decorate @tryFunc(ZeroDivisionError, TypeError) def myFunc(foo, bar): return foo/bar &gt;&gt;&gt;myFunc(1, 0) (None, ZeroDivisionError("integer division or modulo by zero",)) &gt;&gt;&gt;myFunc(1, 2) (0, None) &gt;&gt;&gt;myFunc(1, 'x') (None, TypeError("unsupported operand type(s) for /: 'int' and 'str'",))
What really annoys me though about these types of libraries is two fatal flaws: it's not a perfect mapping between Python names (identifiers) and XML names and, secondly, they can't handle XML namespaces. You'd think they would at least use Python context managers for namespaces, but let's ignore that and look at some valid element names that cannot be represented in Python: # -*- coding: utf-8 -*- from lxml import etree print etree.tostring(etree.fromstring('&lt;x-/&gt;')) print etree.tostring(etree.fromstring('&lt;_.../&gt;')) print etree.tostring(etree.fromstring('&lt;_À/&gt;')) 
Read everything you can about Python: [http://learnpythonthehardway.org/book/](http://learnpythonthehardway.org/book/) [http://diveintopython.org/toc/index.html](http://diveintopython.org/toc/index.html) Watch/listen to pycon videos, e.g.: The Mighty Dictionary [http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-the-mighty-dictionary-55-3352147](http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-the-mighty-dictionary-55-3352147) Try to do Project Euler using Python: [http://projecteuler.net/](http://projecteuler.net/) Try the Python Challenge: [http://www.pythonchallenge.com/](http://www.pythonchallenge.com/) Google for and read the suggestions for this question which gets asked with regularity, e.g.: [http://stackoverflow.com/questions/17988/how-to-learn-python](http://stackoverflow.com/questions/17988/how-to-learn-python) Write lots and lots of code! You learn Python the same way you learned to do everything else you did in life: practice.
A lot of people will send you to "Learn Python The Hard Way" (Google it) which is definitely worth checking out. Others might send you to "Dive Into Python" (Google it) which, as the title suggests, dives you right in. There are some other interesting interactive approaches such as learnpython.org and trypython.org You should of course learn your way around python.org. I like to have something worthwhile to do when I'm learning and so it was helpful to me to use the Web2py Python framework to very easily create a database-backed web site. And the Web2py Book is very good and includes a very brief summary of Python: http://web2py.com/book
I just saw a previous post on "Learn Python The Hard Way". I am checking that one out now. Cool that is it free. Thank you for the suggestions!
pure awesomeness!!
Use the Reddit search functionality and/or your web search engine of choice. Lots of information available to you.
You never explain the title. Why is it an unfair comparison?
It's the title of the blog post.
Is there not a len() function of some sort you can use to determine the size before you start checking N's?
Free variables are usually garbage collected. As for readability, I would argue that closures not only result in shorter code, they result in clearer and much more readable code. I believe the reason why you don't feel that way is because you're not used to the idea. Once you get a hang of the pattern, it turns out to be a very elegant way to solve a surprisingly large number of different computational problems, including caching and various types of function decoration and annotation. 
You can use closures to create function wrappers for caching the output of an arbitrary function.
I took my Java class this winter and this is pretty much what we've been taught. Reading from a file was even worse. If there's a nicer/shorter Java implementation then nobody told me about it. And I sure did voice my dissatisfaction with the (over)verbosity of Java (my previous experince being in Python mostly). I don't think the comparison is unfair.
While that's really neat, and thanks for pointing it out, wouldn't it still be simpler to do that with an object? &gt;&gt;&gt; class account: ... def __init__(n): ... self.n = n ... def __call__(m): ... self.n += m ... return self.n ... &gt;&gt;&gt; a = account(0) &gt;&gt;&gt; a(10) 10 &gt;&gt;&gt; a(5) 15 Edit: fixed per frutiger
You're probably right, and I'm probably guilty of think that what I know is simpler when it's not. But today was the first time I've seen a use case for closure. I think we need more. See, I want to be programming one day and have some problem and think "well, I guess I need a closure here". But right now, I can't see that happening. Perhaps, like some other things, I should try a different tack: try to recognise every time I could potentially use a closure, and then use them instead of the object option, just to get in practice.
The best way to learn Python is to program in Python. Pick a small, contained project and code it up. You'll learn heaps.
Once you get a hang of the basics, don't wander aimlessly. You will lose motivation. Pick a project. For example code a simple game. You will be much more driven this way.
 String raw_input(String prompt) { System.out.print(prompt + " "); Scanner question = new Scanner(System.in); return question.nextLine(); } ...somewhere in main... String age = raw_input("How old are you?"); So Python has a built in function for it. Whoop dee doo. I support Python for freshman-level CS courses, but this post was content-free.
Aside from the small issue that your code exactly as above won't work (either rename `add` to `__call__`, or change your calls `a(10)` to `a.add(10)`), they are the same. A closure is a function along with its environment, that is, any non-parameter names it refers to. You can implement them with classes. A more interesting scenario (and a little more hassle to emulate with classes) is the case of two closures referring to the same object. For example, in Javascript 1.7 and later: let get_size, set_size = function() { let size = 0; return [function() { return size; }, function(new_size) { size = new_size; }]; }(); get_size(); // returns 0 set_size(24); get_size(); // returns 24 This is an example of how closures can actually implement everything non-inheriting classes implement (and one way of getting equivalent functionality to private members in Javascript). What do you think is more complex, classes or closures? **Edit**: and I forgot to add, if these uses are one-off, creating a class for them seems awfully heavy-weight, whereas passing a function from one context to another seems more natural.
It's possible to do realtime stuff using [pycairo](http://cairographics.org/pycairo/). See the examples section for some neat usage. 
Let me google that for you: http://code.google.com/p/pyprocessing/
Why bother? You can just use -1 or ~0 to get the last element instead.
You didn't make one.
Learn the concepts and basics. Then Code. Code and code and code and code.
Fine for your own scripts, not fine for anything else.
Here's my shameless plug for my own library, its more useful for prototyping things. Its not as pretty as processing but it is very easy to do interactive things. Its based on a scene graph instead of redrawing every frame. http://people.csail.mit.edu/rasmus/summon/index.shtml 
Absolutely agree. Dont worry about doing it "right" right away, learn from your mistakes instead.
You shouldn't learn python as a first language. Python is designed as a practical language for people who are already experienced programmers. It combines lots of different ideas from computer science and language design, and you have to understand them all for it to make sense. To really use python properly, you need to understand functional programming (scheme/lisp/haskell/lambda calculus), object oriented programming (smalltalk), imperative programming (pascal/oberon/turing machines), and the difference between reference types and value types (pointers, garbage collection, machine architecture). You also need to understand how an interpreter/compiler works to have a deep understanding of the syntax and semantics of Python. There's also a whole load of other stuff you need to understand properly in order to not write completely retarded code. The best way to learn how to program is to choose two languages - one a high level language (If you are doing maths, you might be interested in a lambda calculus, as a lot of the stuff is equivalent to stuff you might do later on in your degree, eg Gödel's incompleteness theorems and undecidability are strongly related along with model theory) and one low level language. The high level language should be a very simple one that only uses one idea - which are all the ones I listed in the previous paragraph in brackets. You might be particularly interested in Haskell as it is a pure functional language (one of the only ones, in fact) and relates very closely to the typed lambda calculus. Other alternatives are Scheme (the book SICP, which you can google for, is excellent) and smalltalk. As for a low level language, you might be interested in turing machines (an abstract mathematical idea), or you could learn a simple machine language (almost an implementation of a turing machine) like MIPS, and then you would actually understand how computers work. You could follow this up by learning C or pascal, to see how imperative languages map closely to the machine. If you learn both a very simple high level language and a very simple low level language, learning python will be trivial and will take about half an hour.
the thing is, if you actually had a real, properly taught computer science degree, by the end of your degree you could learn java in a day and be really really really good at it in a week
Thanks for the plug. :) I've been thinking of developing that tutorial into a book.
there is a right answer to this question: nodebox it is a complete processing style environment and library built in python 
Just be aware that "Learn Python the Hard Way" is extremely slow and tedious--it works for a lot of people but I personally found it too painful to wade through. There are so many Python resources out there though, you shouldn't have a hard time mixing and matching until you get a good understanding of the language.
This. Every time I want to learn a new language or library, I pick a project, typically smallish, and use that to motivate me to figure out what ever I need to know to write the program.
&gt; My question is how can I learn python? What is the best approach/method that I can take to learn python? The trick is to think of a project that you want to do that's not insurmountable. Then, fucking do it. When you're done with that project, do another one. Keep doing projects, no matter how silly they might seem. For a start, you may want to check out Project Euler. I never really got into it, but that's how a lot of people start learning a new language. It's a good fit in that the problems start easy and get progressively harder. On the other hand, I don't really care about prime numbers, y'know? That said, if you like math, you'll probably find solving interesting math problems that suck to do by hand interesting. If this is the case, check out numpy and scipy. Keep in mind, a lot of computational math is linear algebra based. Finally, might I suggest looking into github? It's not really something you need to learn a language, like, at all, but it's pretty cool to have all your projects in one place. The more projects you have on github, the more like a badass hacker you'll feel. No, really.
PHP is a piece of crap. I'm probably a bit biased, but if you have experience with both, you know PHP is a lot more crufty, and can be hard to work with in comparison to python. Python is a great language, doesn't take that long to become proficient in, and is definitely a strong choice for web development. tl;dr fucking python.
I make well over 100K a year as a consultant. 60% comes from PHP, 15% from Ruby, and the remainder is c# or Java. I absolutely loath PHP, I've told recruiters and anyone who will listen that I would take a 30% cut in rate to do a project in Python; I've been saying that for 4 years now. My advice, is learn Python but be prepared to make most of your money with PHP. I feel that Python may have more opportunities in the near future but right now Python is not as popular with businesses due to lack of information on the part of non-technical decision makers. The exception to this is some part of southern California where I've had companies practically offer their first born child to get me to relocate. Edit: Also, a competent Python dev. has a rate structure that may start at 45$/hour and go upto 90$/hour. Ruby seems fucking crazy where Jr Ruby dev's are offered 80-120$..... meanwhile PHP dev's is a crapshoot of 15-75$/hour. Non-tech savy people only see the price and think PHP is superior or try to cut corners, without awareness of the concept of technical debt leading to a company losing initiative and eventually income.
https://github.com/dennda/python-for-iphone
Dennda. Y U NO Python 3?
uh no, it is not
you can't
stupid title, no explanation, no context supplied. - Downvoted.
lol what point ? by copy/paste some blog title and adding a "not" ?
yeah I fucking bumped into the outage. at first I thought my network had a hiccup, then i thought the fucking DNS is out...then I went to google.com......
it might be more fun to muck around in blender's built-in console, if you're into 3d stuff. thats what got me started on python, anyway.
PHP wouldn't be so terrible if it wasn't for the oddities of it, you can type cast with objects but not string or integers ( today I learned a child class breaks type casting when a parameter uses the parent class ); consistency isn't in places; non-catchable errors in a system that has exception handling; and those fun filled quirks you don't know about until you lose a couple hours of your life diagnosing them.
Um, I might be missing a nuance of your situation, but why do anything to the script itself? Why not just run it using the *nohup* command in your shell?
You don't want to make it a daemon, you want to run it as a background task. Also look at the comments about nohup. http://www.dreamincode.net/forums/topic/34623-unixlinux-background-processing/ http://www.unix.com/unix-advanced-expert-users/42558-nohup-background-process.html
Have you tried backgrounding the process, either with Ctrl+z then bg or `./yourscript &amp;`?
I'm new to python and didnt know difference so i figured the newest is the best. Now i know.
Yep, I've backgrounded it, but it still seems to stop when I log out... is that not right? 
awesome, was no aware of nohup, thanks
very helpful, thanks! 
Yes.
list == array, tuple == immutable array ftfy
just get started and worry about "get good" when you really need to
I thought python was first devised as a teaching language? 
Google's Python classes are a great primer if you want to literally dive in: http://code.google.com/edu/languages/google-python-class/ I've used it to start some small projects and it's been an awesome jump off point.
Absolutely. Multiple Python frameworks exist to make building websites easy. For instance, Flask and Bottle are quick to learn and set up, while Django and Pylons are heavy-duty and useful, and there are many more other frameworks out there I don't feel like listing. IIRC, Reddit uses Pylons.
(I tested the code this time...) class something: def __init__(self): self.size = 0 def get(self): return self.size def set(self, s): self.size = s def closures(self): return self.get, self.set get_size, set_size = something().closures() get_size() set_size(24) get_size() What do you mean by "more complex"? What do you mean by "heavy-weight"? To me, I'd have to say that the class implementation is more explicit in its intention to maintain state. (Of course you lose some of that when you call something().closures(), but I'm not sure why you'd need to.) Or do you mean more verbose? I guess the class is, a little. But then your javascript example creates two closures and then forgets them. If you want to create another closured size variable with corresponding set_size and get_size, you'll end up being more verbose too. (I honestly don't know how you'd do it, but I'm sure you can. Possibly write a function that returns the function you wrote.)
This is exactly how I feel. I'd encourage anyone who hasn't written a quick site in Flask to do so this weekend — it takes little to no time, and is incredibly easy to set up.
My company just picked up a bunch of python work since no one else really does it on a small budget in my city. So learn it and carve your niche. People will have to come to You for upgrades and updates. giving You some good long term clients before python picks up more speed. 
That doesn't work as it will still be attached to your ssh login session. You need to nohup-it and background it. nohup ./yourscript &amp; 
 int((datetime.datetime.today()-datetime.datetime(a,b,c)).days/365.25) Python 3 edit: ok mark from stack overflow's solution is actually elegant and robust def calculate_age(born): today = date.today() try: # raised when birth date is February 29 and the current year is not a leap year birthday = born.replace(year=today.year) except ValueError: birthday = born.replace(year=today.year, day=born.day-1) if birthday &gt; today: return today.year - born.year - 1 else: return today.year - born.year
What is wrong with: int((datetime.datetime.today()-datetime.datetime(a,b,c)).days/365.25) I don't see the issue with converting from days to years.
this is way more complicated than int((datetime.datetime.today()-datetime.datetime(a,b,c)).days/365.25) or not in compressed form age = datetime.datetime.today() - datetime.datetime(a,b,c) yearsofage = int(age.days/365.25)
Why is everyone afraid of timedelta objects?
Not if you want to remain small time. :-) Python can be serious business! PHP is a simple templating language. "Learning" it should be a joke. Get a VPS... like $20/mo. and do your experiments.
No reason to get a VPS to learn python.
There are two types of clients: 1) I want a website and 2) I want a website built with X. They roughly fall into a rough 40/60 split. Most don't care or know what you're using. Do you know the name of the companies that make your cars parts? Or your water heater? They run a salon, law office, or trendy new restaurant. They don't give a crap where your computery thingy stuff was "made". But simply, yes. Disclaimer: I too make my living off Python based websites Edit: for the record do zero PHP, Ruby, Java. Find a niche you like and specialize in it. Who makes more per client/project, the general practitioner doctor or the specialist? 
Have you looked into [Supervisord](http://supervisord.org/)?
He isn't asking about learning python. He is asking about web development.
Python was first developed as a systems language for the Amoeba distributed OS.
Book that really helped me, coming from a "never programmed before" perspective: Head First Programming + Head First Python (the former teaches you programming concepts using python, the second specifically teaches you the python language)
It's misplaced and overwhelming to a newcomer. But it was an interesting read nonetheless, anyway learning lambda calculus as a first language is rather uninteresting. A CS course will cover computation from first principles among other things. I think the question was a little confusing because it seems like the OP wants to learn CS in the form of a language (which is the rookie mistake of pretty much everyone entering CS these days, since CS has very little to do with programming languages and more to do with computing and application).
I took some of my small C codes and re-wrote them in python....4 months later and I don't ever want to program in C again.
Thanks again for all your comments everyone! I am still not sure why you feel Python is not a good language to learn first? I have tried C++ before but it seemed to tedious and confusing. Should I go back to C++ then? 
&lt;3 django =) 
If I am making a mistake please elaborate. I want to work with CS rather than CE (designing chips never really interested me). I guess you could say what is the best way I can prepare to be ready for college with a CS degree. I am a senior in high school and want to prepare as best I can.
That was interesting.
I think python is perfect for the first language.[Almost all of the undergraduate CS courses (of MIT) are moving from Scheme or Java to Python...](http://news.ycombinator.com/item?id=2730929)
You lucky bastards ;)
I prefer the 2nd variety, especially when they want red to replace their blue website. ( Ruby's homepage is red, PHP's is blue, by the time I figured out what they were talking about I was trying to figure out how to escape the room as efficiently as possible. )
Still, he can do web development without installing anything but python and a few packages on his computer. If he wants to practice deploying to a server, he can setup [VirutalBox](http://www.virtualbox.org/) and install whichever OS he likes. Might as well save money where you can.
While I am extremely sympathetic to the sentiment of the OP's comment (understand the lambda calculus! understand Turing machines!), the details, and their translation into practical advice, are harder to interpret charitably. A brief parable: I used to teach banjo, and students would ask what they should do when they practiced. The single most important element of the practice regime, I explained to them, was never to put the instrument in the case. If you put the instrument in the case, then the next time you had an urge to play, you'd have to find the case, open it, take the banjo out, &amp;c. This introduces friction between the inclination to practice and the practicing itself, which inevitably results in less practice time. So, leave the banjo out. In order to learn to program, you need to write a lot of code and attempt to solve a lot of problems which are just beyond your current ability, either succeeding or failing in instructive ways. When you first learn to program, you need to iterate rapidly in order to resolve all of the misapprehensions and ambiguities which lie between the language's semantics and your mental model thereof. Hence, there needs to be as little friction between inspiration and implementation as practically possible. Python is excellent for this. I have had 10 year olds writing "guess the number" and even sorting algorithms (!) within an hour or two in Python. Think about what you need to understand about programming in order to write "guess the number": variable assignment and reassignment, boolean expressions, control flow, IO, type coercion, binary search, &amp;c. Does that mean they get everything that's going on under the hood? Of course not, but that's precisely the point of well-designed abstraction. The notion that you should simultaneously investigate the internal representation of numeric types, reference passing and garbage collection, let alone _the collected works of Church, Turing, Gödel and Tarski_, is kind of silly. If you start out in C, to say nothing of assembly, the chances are much lower that you'll ever get to write programs on your own large enough to motivate topics like OO design or algorithmic analysis. I write this as a firm proponent of functional programming, with some background in model theory (which, by the way, straggles in pretty much dead last among branches of mathematical logic in terms of direct applicability to functional programming). Learning haskell or another lisp is a great idea. In fact, I can't recommend it strongly enough! But to say that you need to understand lisp in order to understand Python, however, is just silly. The influence of lisp on Python is largely indirect, in the form of the mostly lexical scope: lambdas are impoverished one-and-a-half class citizens, and map and filter have been stuffed into the closet. There's eval, I guess, but the entire point of eval is lost in a language where code and data are represented by different structures. Like, say, Python. While we're on it: "scheme/lisp/haskell/lambda calculus" makes no sense. Scheme is _a_ lisp, as is haskell, and lisp is just executable lambda calculus. Anyway, kylepotts wants to learn Python, let him learn Python. I actually agree with jonpv that haskell and scheme offer you fundamental insights into the nature of computation that Python doesn't exactly go out of its way to show you, but that was not the point at hand.
You should look at some test cases involving a delta of several days (e.g. `today - delta - born`) -- recalling the rules for leap days (e.g. a 48-year old will have 12 leap days). I think it's ok to use timedelta objects if you use the average Gregorian year of 365.2425 days and round to 2 decimals of precision before converting to an int, but I haven't evaluated all of the possibilities. But rather than mess with all that I think it's far simpler to subtract the years and possibly subtract 1 if today's date is before the given birthday, with special handling for leap birthdays. 
I wonder wether the use of mutable objects as default parameters could/should be precluded by language design. A syntax error could be raised. **Everyone** stepped once in his life into this trap ... Somewhat related to protocols: It's generally not clear to me what special methods you need to overwrite when subclassing a build in type, e.g. a list. What methids do I need to reimplement to get most of the under the hood magic like the iter() or len() functions. I ended up with subclassing an ABC (collections.MutableSequence). Anyway, awesome article. Much appreciated!
By heavy-weight, I mean the introduction of a new type. If I wanted to re-use it, then I would just name my outermost function appropriately (as you have had to do, since classes must be named), and the introduction of a new name is justified, but perhaps not the introduction of a new type. Python is a very rich language, and closures don't give us much there. In a language like Javascript, where all you really have are functions and prototypes to do all your higher-level constructs, concepts like closures help tremendously. It also makes us re-think assumptions about ways things can be done. e.g. this is an oft-repeated use of closures in Python def cached(func): cache = {} def cached_func(*args, **kwargs): if (args, kwargs) not in cache: cache[(args, kwargs)] = func(*args, **kwargs) return cache[(args, kwargs)] return cached_func Now you can use `cached` as a decorator: @cached def factorial(n): if n &lt; 0: raise Error() if n == 0: return 1 return n * factorial(n - 1) Again, you could quite happily create a class and provide a `__call__` method that did exactly what `cached` did, but it seems rather unnatural. It's just another tool in your toolbox. After all, there is nothing that closures can do that assembly language can't - most languages we use are Turing equivalent.
That's really neat, thanks. I think using a class in that example would be much less clear.
Never subclass list, dict, or any other builtin like that, it's headaches all the way down, just use the abcs.
Typo in the article: `x.getLenght()` should be `x.getLength()`.
It's a valid case, but on the other hand I've learned a lot from my VPS. If it's just going to be a sandbox, find another dev to split the cost and go for it... there's a lot of things you'll learn about Apache, caching/performance, etc. that you'll never hit in local experiments.
Yeah, fuck a bunch of PHP. You can always pick it up later.
Damn, I didn't know that Ruby makes so much... why?
Take a look at screen or tmux. Very helpful in such situations as the tool can remain interactive and you can inspect the output of your script.
It's already been said by pretty much everyone. Three years in to Python webdev now and I won't be looking back...
And then when he actually has a client he will do what? Save money where you can?!? You are such a miser that you can't spend $20/mo on your own education? No private local server can equal the bandwidth of some single-hop datacenter. Sometimes you actually want to make something and 'put it out there'. Hard to learn to be a web dev unless you are actually participating in the web.
Wow, that is quite enterprisey and OCD. I think most of us laypeople can use the average Gregorian year. People can be the wrong age for a couple hours of the year when we are experimenting with what is possible. Basically, there is a long answer and a short, simplified answer that is good for 99% of the world. Just get it done.
Unfortunately, this **is** the reality with most small business clients. Makes me want to pull my hair out. It's like they **want** to throw away the site in 2 years and start over...
Rails.
In English: I paid eighty to one hundred dollars. Ok, see why some people do that?
Despite my love of Python, I do agree this is valid for small, quick, cheap websites which is what many clients want. I also agree with getting a VPS, not necessarily to learn Python but if one wants to deploy it and use/test it online. Shared hosting is too limited since one will inevitably require their own Python build (2.7 isn't available by default at many hosts), virtualenv's and/or access to httpd.conf
&gt; Default parameters to functions are bound at function create time, not at function evaluation time. The positive side effects are that it's faster, and also that it's quite easy to understand how it works with the scoping rules once you're aware of that behavior. The downside is that if you have a mutable object as the default value in that function and you attempt to modify it, you will notice that this modification survives the call. That confused me, basically the default values are *copied* into the function when the function is created. If you mutate the object you will not be mutating the same object as used by the function. But how often do you put mutable objects into default parameters. Usually it's just a literal integer or string of some sort. &gt;&gt;&gt; s = "bla" &gt;&gt;&gt; def prints(str=s): print(str) &gt;&gt;&gt; s = "stringy" &gt;&gt;&gt; prints() bla &gt;&gt;&gt; 
You seem to have misunderstood me. You should at least be able to understand PHP if at least for the purposes of migrating sites. I recommend Python as Python can be a serious career. A VPS or private server is a necessity in order to be a small business and host client data.
Especially when are already good sub classes in collections, such as defaultdict.
I interpreted your meaning as "sticking with PHP if you want to deal only with small clients and small sites". Perhaps I did misunderstand. At any rate, I was agreeing with you and still do :) And I manage 3 VPS'
Hype? Django is better.
Are you talking about PHP's ugly variable syntax or money?
Oh, duh. Why hadn't I thought of that? (Don't answer that. Rhetorical question.)
Most of the people that want a website done in *PHP* just don't know any better. PHP sucks, I have to maintain a PHP project at work, that is due to be replaced in the coming years with ASP.NET. It is an ugly C-like language will all sorts of inconsistencies. Most of the php std lib doesn't use exceptions. Strings and arrays don't even have methods, it's a bit of a joke to call PHP an OO language. The instances I've seen python used for websites (e.g. Django) are usually where the person building the website chooses to use Python. I doubt you will find too many Django jobs around, but it is growing. A year ago I was working in a PHP shop and I got them to use Django for building their time management tool. A flatmate is using it at his company internally. Another two local guys is freelancing with it. It is an option, just a hard one to find a job in. You'd probably be best to find someone who needs a website built (maybe in PHP) and explain to them that Django/Pyramid/Whatever would be a better choice because you can built it in less time, costing them less money. You can host it on any linux VPS, or there are companies around like WebFaction, dotCloud which do easy deployment. Avoid PHP, do .NET or Ruby or whatever to avoid it. In my experience PHP attracts a culture of doing things quickly and not caring about quality. You will probably see this in any web development shop that uses PHP.
Nodebox is great, as is Shoebot (our cairo based implementation).
it's ultra trendy amongst startups right now, especially the kind that get funded but don't really know wtf they're doing.
Well, even if you didn't care for individual years, a year isn't exactly 365 days long. Doesn't seem to matter initially until you think about "today" being at or around the birthday of the person asked.
Strings aren't mutable. In [1]: s = ["bla"] In [2]: def prints(str=s): print(str) ...: In [3]: s[0] = "stringy" In [4]: prints() ['stringy'] 
I really like python and am currently working on a very large python project. I just don't think it's a good first language.
Maybe it was, but I don't think it should be.
Yeah, I didn't mean to suggest that scheme/lisp/haskell/lambda calculus were all similar, just that they would all be good things to start with. I also didn't mean that you needed to know lisp in order to understand Python; I think I meant that you need to know one of those languages to understand how programming works in general. I agree strongly with your "write a lot of code to get better" sentiment, but think that for most people learning a simpler language first would make things easier for them. It might be possible for high school students to learn python and then do some quite good things with it, but at some point later on they will hit a brick wall when they encounter something that requires a bit of CS knowledge.
Nice article. I'm kind of shocked that some of these justifications are new to me. Also needs to give more shit to PHP for its list copying behaviour.
I'm a native English speaker. Just because I understand why it was done doesn't make it right.
&gt; Also needs to give more shit to PHP for its list copying behaviour. It does not give shit to PHP at all, at least that was not my intention. Within the design of PHP having a COW Array/Hashmap combination makes a lot of sense.
Thank you for the well written and objective article! This also helped me understand closures a little better. While I'm also prone to using classes to solve similar problems, I'm looking forward to discovering cases where closures are appropriate or even more efficient than classes. The GC of free variables is a little more mysterious to me, however. Perhaps its time to play with the [gc](http://docs.python.org/library/gc.html) module.
Python is a great first language; there's probably not much you want/need to do at the minute that you can't do in python, and you'll write useful code faster than you would with c++.
The name. You wouldn't believe the number of "business-types" that base important decisions on irrelevant things like that.
Python is a great choice for freelance work so long as your app doesn't require any sort of persistent connection to the server like a web chat. In those cases you might be better off picking something like erlang with one of the numerous http server libraries for it.
&gt;Whenever people try something like this it invariably fails in some unpredictable sort of way. And ambiguous, non-standardized symlinks don't?
Thanks for the reference to learnpython.org.. I have added it to my long list of python literature. trypython.org on the other hand lands me at a page with only one thing; a button to install microsoft silverlight. Is it worth it?
Erlang is a fine choice there, but not really a requirement. Python handles async/event based connections just fine. See convore.com. 
As stated before, this question probably gets asked multiple times every day on reddit. Look at those posts. It's really up to you how you want to learn it. Try one of the many many tutorials/video lectures/textbooks on the subject and see if it is right for your learning preferences. The google talk on python is a great place to start. UReddit is a great place to learn along with others doing the same, even though it seems rare that a course actually starts or goes to completion. It seems that the greatest way for most of us to learn is to find a project we are interested in and start working on it. Hello World and the like gets boring pretty quickly. Here's a site to familiarize yourself with python syntax that I don't see listed here yet: http://progzoo.net/wiki/Python:ProgZoo Good luck
Short answer: Don't use PHP. Learn it, sure. Just don't USE IT.
[Invent with Python](http://inventwithpython.com/) A lot of books focus on teaching you high level computer science concepts in python. This one does the same, but you use the concepts to make simple video games. It's designed to make programming fun first, rather than bore you with algorithms. After you finish this (FREE!) book, I think the other python books will be more appropriate.
Okay after some reading, I've implemented (or at least tried to) in my application. One part still confuses me. in [dispatcher.py](https://code.djangoproject.com/browser/django/branches/releases/1.3.X/django/dispatch/dispatcher.py) on line 257, it defines the receiver function. The problem is when I use the receiver function to attach a function as to a receiver, it doesn't actually end up calling the function I attach. For example: @receiver(pre_card_get_stock) def test_signal(cardname=None): print("YEAAAAAAAAAAAAAAAAAAAAAAAAAA") Doesn't actually print anything. But when I add an actual call to the wrapped function into the receiver function definition: def receiver(signal, **kwargs): def _decorator(func): signal.connect(func, **kwargs) func(**kwargs) &lt;------- I added this return func return _decorator it worked like I expect and prints "YEAAAAAAAAAAAAAAAAAAAAAAAAAA". What am I doing wrong here?
It's also way less wrong around the birthday.
Depends on where you draw the line between sub-optimal and buggy.
Rates vary by location...do you mind mentioning where you are approximately?
Exactly. I don't think I've ever met a good PHP developer. It messes with your mind, man!
How has no one mentioned [Google App Engine](http://code.google.com/appengine/)? It's basically the [Heroku](http://www.heroku.com/) of Python - free until you need the bandwidth, scalable, but then you'd have to ditch it if you accidentally hit on the next Twitter.
Thanks for clarifying that. Turns out my understanding was completely wrong.
Pretty cool 
Scumbag redditor: Told not to answer question Answers it
I wonder why anyone would WANT to use ASP.NET o.O
If you're going in to web development and are just starting out, you don't really have the option of *not* learning PHP. You need to know it, even if only because of the clients that will have existing systems. You're not in a position to be snobbish about languages at this stage. That said, Python developers are in higher demand for web development than they've ever been and that trend is going to continue. Django in particular is starting to get mindshare in the business world; a year ago none of my clients had heard of "dug-janger", now I have some asking for it by (the correct) name. PHP and Python (or PHP and Ruby) can be complimentary skill sets. Your time wouldn't be wasted learning both. 
DEAP and ECSPY are the leading evo comp modules for python from my point of view. Pyevolve has traction but its architecture is really non-modular and lacks sophisticated multi objective algorithms such as PAES or NSGA2. In terms of code design &amp; documentation I'm a little biased towards ECSPY, while DEAP niceness comes from including load distribution algorithms. 
Because it's better than PHP. You use can C#, which isn't as nice as python, but much more OO than PHP.
It was when I looked. The title has been changed.
&gt;The exception to this is some part of southern California where I've had companies practically offer their first born child to get me to relocate. Silicon Valley is also big on Python. Most of the hardcore engineering-led companies here choose Python over both PHP and Rails. From Google, to Quora, to [Supyo](http://techcrunch.com/2011/04/15/supyo-yo-fanning-parker/), to things like the awesome [Tornado server](http://www.tornadoweb.org), [the wide](http://www.crummy.com/software/BeautifulSoup/) [range of](http://numpy.scipy.org/) [libraries](http://www.scipy.org/), and the fact that you can build everything from high-performance websites to Linux &amp; Windows desktop apps and components all make Python very popular here.
Windows users do not get the great builtin effects
I use [web2py](http://web2py.com/) in work for an internal site, and think it's wonderful. It has its own built-in server, in-browser editor, Database Abstraction Layer, and is deployable on Google App Engine. On top of that, google groups has a healthy community around it, and there are a myriad of tutorials/videos on how to get up &amp; running quickly. I would highly recommend it to anybody new to the web-development scene. 
Better yet, sign up for the [Amazon AWS Free Tier](http://aws.amazon.com/free/) and learn with that. You'll learn both Python and AWS, both valuable these days.
&gt;It is an ugly C-like language will all sorts of inconsistencies C is ugly but is pretty well-thought-out. PHP was originally designed by someone who didn't have the slightest clue about language design, and as it has evolved, it hasn't been able to get rid of that baggage. 
Companies who are already fully on the MS stack, and all their internal IT guys are MSCEs and whatnot, and all their consultant relationships are with MS consultants. Basically.
&gt;"Learning" it should be a joke. It's a long, painful joke because of the quirks and inconsistencies.
See [Tornado](http://www.tornadoweb.org). A pure Python async server developed by Friend Feed to power their real-time stuff, [open-sourced by Facebook](http://github.com/facebook/tornado) after FB acquired FF. One of the demo apps is even a real-time web chat app.
Which is really frustrating, its almost like some sort of cosmic balance has tipped Python to be super concentrated there but not so much anywhere else.
I'm based in the Midwest near Boulder, Colorado but I know those rate's apply to large swathes of the country with exceptions based on adjustments for quality of life costs. I also have a personnel web spider that harvests data from indeed, craigslist, stack overflow careers, and sources like pay scale to give me tactical knowledge before making bids.
this worked fine for me as well. thanks for throwing it together
Glad to hear it :)
But then you can't implement the [EvilInt](http://www.reddit.com/r/programming/comments/hoig5/php_core_developers_must_not_actually_use_php_its/c1x7ytx) class! More seriously, there are some cases where subclassing builtins can be handy, like a named tuple class when it is not available in the stdlib.
Dare you to say that in the Ruby subreddit. ;)
because not all years have 365 days? Sure, I can go and write that code, but it should be part of the timedelta class - I can't see how anyone could argue against that. Nice edit, btw. 
Holy mackerel! I didn't know about your EvilInt class. This is truly ... evil.
Thanks for your reply. &gt; for most people learning a simpler language first would make things easier for them. I think we are potentially conflating two senses of "simple". A language can be simple in its implementation (e.g. C, Forth), or simple in its presentation to the user (e.g. Python, Scheme). I am claiming that the latter is more important than the former for a beginner. It is true that Python sweeps a lot of implementation details under the rug, but that will also be true of any lambda-calculus based language which runs on a von-Neumann architecture. (How does SBCL transform my code into machine code? I have very little idea, and for now I'm content with that. If I ever need to know, I know where to begin.) The idea that the beginning student must understand the machine at all levels of physical organization is kind of a canard: you can write C without ever learning about assembly (really, when was the last time you used asm?), and you can write assembly without ever learning about circuit design, circuit design without transistors, transistors without E&amp;M, E&amp;M without the Standard Model, &amp;c. At which point does the student _really_ learn what the machine is doing? Everyone must somehow understand this deep in their hearts, and yet people still come to the conclusion that some arbitrary plane of abstraction (coincidentally that of the language they grew up with) is the One True Model of computation. Instead, we need to recognize that there are reasonable trade-offs to be made between expressive power and conscious attention to the logistical details of shepherding bits around on the machine, and that our particular interests and applications largely determine what is reasonable in any given context. I am still not sure that I understand your point about the unsuitability of Python to CS-centric understanding. As an exercise, I suggest consulting the wikipedia page for ten algorithms and comparing their pseudo-code descriptions to a Python implementation. Persoanlly, even having taken and done quite well in a year of AP CS and another semester of C++ at university, it wasn't until I played around with Python that I fully grokked the implementation and purpose of a linked list. Even though lists are a primitive data type and therefore something I 'shouldn't have to know about', Python allowed me to teach myself what a list really was. I believe this was due primarily to the (apparent!) simplicity of Python's object references and class model: I wrote a little ListNode class, no boilerplate in sight, and two minutes later it was up and running. I just don't see what you would be losing by, say, taking [an algorithms class in Python](http://courses.csail.mit.edu/6.006/spring11/notes.shtml). True, you won't learn about segfaults and null references, but that's kind of like saying that in a developed state you won't learn about cholera. Perhaps it worries you that Python inherits features of many programming paradigms. This does not mean that one cannot write Python in a purely procedural or functional way. Further, if you're comfortable with procedural programming and wish to learn something about functional idioms, the fact that you can do so in Python without having to switch languages must be construed as an advantage to the learner. ### A Final Parable Let me close by telling another story. I work with scientists. They're all quite smart people, but of drastically varying programming ability. Some have built and programmed their own instruments from scratch, others took a semester of C in college because they had to. I was talking to one of the latter the other day, and she told me that she does primer design by hand. Primer design is a very common and very tedious computational task in molecular biology. It amounts to lining up two DNA sequences at some offset, performing a laborious melting temp calculation, then usually rejecting it and trying another until you find one with a suitable temp. Typically there are other constraints as well, and the resulting algorithm can take hours to perform manually. Moreover, the people doing this computation have advanced degrees, and usually do it while sitting in labs filled with millions of dollars of equipment and reagents. When you work in molecular biology you can hear the dollars tick by every minute, and yet you see Ph.D.s wrestling with some straight up kids-in-treehouses, pencil-and-paper shit. For hours at a time. Now, when I first had to design primers, I _immediately_ recognized it as a task unworthy of a human mind. Instead of doing it by hand, I read a few articles, wrote about 20 lines of Python, and had a custom primer design program in my pocket. I asked my friend if she had ever done any programming, and she admitted that she had taken the obligatory semester of C, but thought it wasn't worth the trouble. Now: if you can throw very smart people at a semester of C, and **what they learn is that it's not worth trying to program away the bane of their scientific lives**, then we're doing something wrong. What did my friend learn in that semester that helped her to become 'a real programmer'? Probably something about makefiles and #includes and the deadly, deadly importance of null-terminating one's strings. Did she learn that programming is directly relevant to her life's work and the general satisfaction she can derive from her daily existence? Apparently not. I remind that she is _ipso facto_ not stupid; in fact, if the only tool I had were C, I'm not sure that I would have bothered writing my own primer design program either, _especially_ for one-off tasks. I think that's something we should think about when advocating for a choice of language. Anyway, cheers.
No, that isn't better. AWS is quirky and not representative of a private server. AWS is good if you plan to use AWS. Different things are different.
This is true. For hobby work the line is different. That is exactly what I am saying.
From a comment in HN. &gt; So... Python has len() because it would be too hard to standardize on .len(). Any by the way, len() calls .__len__(), on which we have standardized. Got it. I don't know how much of a fan boy one has to be to think that that particular explanation in the article makes any sense. Also that "Pass by ... what exactly?" Author just take a jab at C++ and PHP without answering what Python actually does. I knew what Python does but I don't think the author know and he didn't actually make any argument in the section.
Don't learn the frameworks. Learn it as the templating language that it is.
...interfacing a C++ library.
I wasn't aware I needed bandwidth to test the simple web app I made. I'm sorry I don't have $20 a month to spare; I've clearly offended you.
Nodebox for OpenGL is pretty interesting.
&gt;I don't know how much of a fan boy one has to be to think that that particular explanation in the article makes any sense. I upvoted you for asking the same question I came to the comments to get an answer for ("wat"). I didn't see one, though, so I went back and re-read. I think I get it now, but it doesn't seem as profound as I think the author wants us to believe. Basically, I think it's just about namespacing. By creating special methods, you create an explicit namespace for built-in concepts, like len. If you want to hook into the well-defined concepts, e.g. len, you use the __len__ naming convention and then the len() method provides a syntactical shortcut for accessing the value. That way, when you look at the interface of a class, you know what's custom and what's built-in and, if somebody really wants to, they can name a member function .len for their own purposes without screwing up integration with other libraries.
The much higher rates I've seen are because of the brevity of the contract length. The more advanced and developed Ruby dev's usually have a small harem of clients and bounce between them, servicing their needs then riding of into the sunset like some sort of cowboy IT prostitute. It seems like a balance of personnel freedom to near constant questing for new clients. Hence I'm usually happier billing around $55-65/hour corporate to corporate.
Probably bitched about this for years but I had a client that demanded their refactored product be built in Red, it was currently blue but that wasn't working out. Homepages for Ruby is red, PHP is blue, and the reality is they wanted a Web 2.0 styled interface bedazzled with Ajax.
Yes, you have. People who don't invest in their education fail.
The point being? I think anyone who knows about Qt and PySide would know it is a C++ library.
I CTRL+Z then type bg in derr. That way I can make sure Buttebott (The python buttbott) starts up how I expect him to!
ahaha it freaks me out sometimes when I go from PHP to Java and have to remember that I don't have to explicitly do $this, or I don't need to prefix with $'s for variables in JS, and then with Python there's no semi-colons.
If you have a degree in Computer Science, you should be able to work in both. If you can't, you shouldn't really have that degree. That aside, hosting is more readily and cheaply available with PHP, but nothing's stopping you buying a virtual server or a dedicated and putting what ever you like on it. For a quick start, stick with what ever the host allows, then when you have the capital to do so, move your clients onto a VPS and build any new sites in whatever you like. VPS's are far more expensive than shared hosting, so if you do go down this route, you need to be able to support a large chunk of money leaving your bank account monthly. Dedicated more-so. TL;DR. Learn both to give yourself versatility. If you find a really good UK based shared host that does Python on the cheap, let me know.
&gt;Every time I want to introduce a parameter to a previously parameterless decorator makes me want to hit myself and the author of the decorator PEP with a stick. Making a parametrized decorator makes me feel very smart. It should be less mind-bending, although it is very understandable, but that takes some time. 
+1 for "...cowboy IT prostitute...".
why not just use Mutagen from the quodlibet project? I once started a wrapper for it to give it the same api for every format, but i never finished it. I remember it as a bliss, even though poorly documented. http://code.google.com/p/mutagen
&gt; I don't know how much of a fan boy one has to be to think that that particular explanation in the article makes any sense. Well then I tried my best to explain that. Take a look at ruby to see how a standard on `size` means two different things. (Array vs Fixnum meanings for size for instance). If an object in Python has `__len__` it means that it's sized. If it has `__contains__` it means that it's a container. If it has `__iter__` or a `__getitem__` that behaves in a certain way it's iterable and so on. None of this could be done with `.length`, `.get_iterator()` without assigning those general names one unique meaning that must not change. On top of that do many functions map to more than just one special method (any binary operator, iterator protocol knows two use cases etc.). The resolving of such ambiguities would require interfaces like in Java, and Python did not go down that road by design. Also without Ruby's mixins and class reopening it would not allow you to add additional methods on a bunch of types (like all iterables). &gt; Author just take a jab at C++ and PHP I took a "jab"!? I was comparing how many developers coming from such languages are expecting similar behavior but get something unexpected. &gt; I knew what Python does but I don't think the author know and he didn't actually make any argument in the section. I was pointing out that it's not passing by value as you would expect in C++ and not passing by reference as C++. Of course Python passes by value, but the value is the object's address. That article is just trying to point out way developers might end up being confused about behavior and naming as they can mean entirely different things in different languages. Please do not see this post as a reason to use Python over other languages or why the Python design is better. In fact I think a lot in Python is not even closely as nice designed as many other languages. The post was explaining why certain things work the way they work and what implications they have. Protocols and special methods are one of the core design principles and if you throw those over board you end up with an entirely different language. Which very well might be better, but for all practical purposes we are using Python and are happy with that.
&gt; it doesn't seem as profound as I think the author wants us to believe. I never said it was profound. It's just a very simple and beautiful solution for a problem that would otherwise require interface classes and probably ruby mixin modules if you also want the ability to put other methods on such mixins to have a consistent behavior overall.
For the ones that run in shoebot you can ... but yes, still some way to go. [EDIT] disclaimer: I'm one of the shoebot developers from time to time
I built this plugin inspired by Google's CI system: http://googletesting.blogspot.com/2011/06/testing-at-speed-and-scale-of-google.html Hope it's useful.
It's even more useful when attempting to get people to not use from module import * Just do this after defining the EvilInt class: int = EvilInt
flask is one of 33 apps that makes developing django apps awesome? WTH?
Sorry, didn't mean to misrepresent you. We probably just have different connotations for the word profound. You obviously thought it was a big enough deal to highlight and write about, which is really what I meant. Don't get me wrong; with respect the namespacing issue I discussed, I like the solution and the separation it creates. I was just confused as to why you brought it up, since so few people (in my experience) actually run into the issue this solves. I don't understand why you think interface classes and mixins would be otherwise required to deal with it. Don't other languages take the simple approach of "these symbols are reserved for these special meanings; just name your symbol something else"? If a symbol already has a meaning in a namespace, you simply have to use a new symbol and nobody really seems to gripe about that in other languages (that I've seen). The main advantages I see in the Python approach are in future growth: * As long as everybody follows the conventions, you can add new special methods to your hearts content and (almost entirely) avoid conflicts nobody could have otherwise predicted (e.g. avoid the case where the method "foo" now means something special and anybody who used "foo" for something else better change it!). * You can layer backwards-compatible meaning into these special symbols pretty seamlessly (i.e. getattr using \_\_getattribute\_\_ and then \_\_getattr\_\_ with new style classes) These are pretty cool consequences of the design, but I don't think they were fully captured/explained in the post.
[relevant](http://www.interestingemails.com/it-professionals-and-prostitutes-are-we/)
&gt;Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. So this time Django has to be good intentions.
is "bazinga" come from "the big bang theory" tv show? cool
but the Title has the word "all in pure Python"...
...correctly implying that Python is all you would have to write.
I think he lost it at the end - too many apps ...
So does that mean the Python standard library modules that are written in Python aren't "Pure python" because they interface with CPython which interfaces with c++ libraries?
I just copy it to guess the reason why someone say "interfacing c++". nothing more.
I thought r/rails might bite more. http://www.reddit.com/r/rails/comments/idlgc/rails_advise_requested/c24nwji
It looks like Notch in the thumbnail
Decorators are nice. The reason why decorators are hard to understand is not because it's hard to understand per se, but because there is a lack of official (quality) documentation that explains how decorators work. @x def foo: pass simply means pass = x(pass) where **x** is a function or returning a function (e.g. **bar(a,b,c)**)
He also listed django-celery and celery separately.
Decorator is an example where closures are used effectively.
My Pythonian is not as fluent as my JS/HTML/CSS (that's an understatement), and I'm looking to get some help on the Python end of the project. Basically I imagine the back-end to work as an API so that it will be front-end agnostic and it also needs to be plugin-compatible. The python end of it will communicate (For now) with the Bitcoin software using JSON-RPC and use web.py to display front-end/client, possibly baking Chrome with the app, but for now I'm using Chrome's `--app="http://.../"` feature, so it could work for a while (bling is nice, but I first want to get the software out there).
Cool! I’m interested in the project. Are there any IRC channel or mailing list?
&gt; If an object in Python has `__len__` it means that it's sized. Because standard `len()` will end up calling `__len__`, right? For now, let's assume that there's still `len(x)` function which ends up calling `x.__len__()`. What if Python had standardized that on `__length__` instead? * Can `len(x)` internally call `x.__length__()`? (Magically Yes) * Can anyone agree not to use `__length__` for something else? (Magically Yes) * Will the statement "If an object in Python has `__length__` it means that it's sized". still work? (Magically Yes) Now try and replace `__length__` with `size`, then your answer would be: * Can `len(x)` internally call `x.size()`? (Oh god impossible, NO) * Can anyone agree not to use `size` for something else? (Oh god impossible, NO) * Will the statement "If an object in Python has `size` it means that it's sized". still work? (Oh god impossible, NO) Keep in mind that you still have to call `len(x)` to get the size. The fact that `len(x)` ends up calling `x.size()` is part of the new standard protocol. What magically makes `__len__` any better than `size`? If someone wants to conform to the protocol, they will. There's no reason (beside in ability to patch primitive type) that some one can't make `Integer.__len__` return bitsize. &gt; Of course Python passes by value, but the value is the object's address. Yes. And you should have said that in the article. If passed by value (of referrence if needed) as in Java/C/Ruby/Lisp/Scheme. 
Nope, just started it last week. I think the best way for now would be to setup either a google-code project or a git (I prefer git because of the interface :) ), and use Google+/Talk to communicate. I'm *[deleted]*
Yeah, C's syntax works well for C. It does _not_ work well for languages that have since aped it, or at least the majority of those.
~~Just a heads-up: your Tornado link should be .org, not .com. tornadoweb.com is a "this domain for sale" page.~~ EDIT: Fixed now.
Thanks, I just added you into my Google+ circle.
From the blog post: "Here’s an incomplete list of Python and django related projects that I have used or I’m planning to test. This might help someone starting out to get an idea of how awesome is to work with this technologies." Maybe I should change the title to: "33 projects that make web development with python awesome, (mostly django related but not necessarily)." What do you think?
Thanks, fixed!
Serious question, how is it quirky? I've been using it a few months for toy projects now and it seems ok. I used to run Ubuntu Server in Virtual Box on my local workstation, now I've replaced that with the AWS free tier. Good performance, good price for experimenting/learning. Is there something I should be on the lookout for?
I'm not saying that you can't use AWS as if it were a private server. http://aws.amazon.com/ec2/faqs/#What_is_Amazon_Elastic_Compute_Cloud_Amazon_EC2 Managing the system feels way different. The faq is all about using these things as compute resources and thinking of storage as separate etc etc instead of just grabbing a VPS or server, installing everything on that one unit, and experimenting. GAE, AWS, these things are very different than a private server or individual computer. Walk before you run or you will trip over your own feet. 
I'm not sure about Windows but on linux, to do python development, you need to install the python-header packages as well as the standard python libraries. Other than that, I can't help you, but I hope that gets you to the next stage.
For Windows development you can use [MinGW/MSYS](http://www.mingw.org) or [Cygwin](http://www.cygwin.com) with the MinGW compiler installed. The header files are already installed in the `include` directory of your Python installation. For the MinGW compiler you'll also want to add a configuration for distutils. In Lib\distutils, add a plain text file named `distutils.cfg` that contains the following: [build] compiler = mingw32 [build_ext] compiler = mingw32 (or mingw64 if you're compiling for x64 code)
BTW, I got my understanding of parametrized decorators here: http://stackoverflow.com/questions/739654/understanding-python-decorators
I'm going to guess most people have a great time *using* decorators. Writing them is a bit tricky. The inception kind of tricky.
py.test has a similar plugin [pytest-incremental](http://pypi.python.org/pypi/pytest-incremental)
&gt; Bazinga is a nose plugin to run incremental tests **nitpick** I guess this sentence implies that the *tests* are incremental but actually the tests are just normal tests. The *runner* is incremental. 
No matter what I will write you end up being unconvinced, so I just end that discussion here.
Same goes to you, sir. 
I doubt that. If you read my article you would have noticed that I don't have any problem with how other languages are doing that because it suits their design principles. I was explaining why Python does it that way. If you don't expect that as an explanation that is your think. I was not in any way saying that this is a better or worse design idea than other languages.
&gt; I think we are potentially conflating two senses of "simple". A language can be simple in its implementation (e.g. C, Forth), or simple in its presentation to the user (e.g. Python, Scheme). False dichotomy and completely unrelated to what I was trying to say, but interesting points.
developing in django sounds so simple now!
lol bitcoin
I think I took a look at Shoebot a few years ago and had some fun, but alas, school and work caught on and I kind of gave it (in addition to nodebox) up. Nice to see that the project is still active.
:)
Might have edited it, but he does label that section "Other not django specific projects that help me with web development"
Ah, I see. Yes it is different to think of your app tiers and components in terms of different AWS services, instead of your own custom stack.
Along the same lines as rlayton, I would just install Ubuntu and grab their PySpeex package. Development is just easier on Linux. If you don't have time to diagnose why you can't compile it, this might seriously be faster.
I would do this if my target platform weren't Windows. :(
How about the *nix 'disown' command. This detaches the process from the shell so that it won't get killed when the shell dies / logout. If this is just for your own purposes, I recommend the 'screen' utility. This is a shell session manager. You run 'screen' and it takes ownership of your shell, detaching from your shell. You can then kill your terminal or logout and when you re-open a terminal, you can reattach to your running shell session.
I don't think I'd be able to help much, but I'd love to see the code. Hell, I might even try to contribute!
Do you have a demo up anywhere?
I used 'nohup' yesterday and my script ran all night as I hoped - how does 'disown' compare to 'nohup'? 
I don't mean to be a sour sally here, but I think the GIL is a good thing (in the CPython code base). I'm a real fan of the python codebase being as simple as possible, and eliminating the GIL would require an immense amount of hackery, as shown by the article. I love the idea of the GIL being eliminated in PyPy, but CPython should remain as C as possible, in my humble opinion. I know there are arguments to the contrary, but I can't shake my C-eugenic sense. Edit: Upvoted nonetheless. This is by far the best practical GIL removal implementation I've seen thus far.
Like Matlab, but free!
This is a neat fucking implementation.
Yeah - throw something on Google App engine for us to play with?
Ideas are all very well, but let's see some code.
yeah I'm pretty sure that heading wasn't there when I made the comment yesterday
You are right. I edited the post for clarity.
I removed the reference to celery since is very clear that you need celery in order to take advantage of django-celery. :D
The plots are prettier was well and once you learn to use the Divider and AxesArtist, omg you can make some sexy plots.
thanks :)
Up with the demo!
&gt; First, you'll need to write yourself an interpreter. A static compiler for Python doesn't have enough information to do the right things In other words, goodbye to hopes of writing a "fast Python". You can now only hope for "pretty fast Python".
It's a fairly nice framework. C# is neat too.
Poor article format imho, but you should still bear through the end.
They aren't kidding when they say that if you find slow code they treat it as a bug. I submitted 2 bugs and they found a fix for one (in less than a week). And, apparently, the bugfix worked for speeding up CPython too :)
Not sure what you're asking, Why can't you use `f.read()`?
Like the article says, you can still write a (non multi-stage) JIT and get very nice speeds. Time and research will have to tell whether JITs will eventually equal or overtake static compilers for most code.
so I have a text file which contains around 50 characters. All I want to do is extract those characters to a string, which I can then print to the screen or whatever....it should be simple as heck right? I say f.read as this is the closest thing that mimics what I want, but I can't assign it to a string...
 f = open('filename','r') mystring = f.read() print(mystring)
 f = open("filename", "r") foo = f.read() That should do it. Also, you might be better off checking out [r/learnpython](/r/learnpython)
How about considering a 23 MB lib/executable a bug? :) I know Python is not Lua BUT, why 100 times larger? 
I need a 2-argument assertion of equality so that I know both the expected value and the actual value on failure. I also need a 2-argument test of inequality. I also like both positive and negative assertions for a given set of exceptions, though I can live with a try/except/else block. I also need an assertion which takes a comparison function, like less_than or within_delta. I don't understand what point you're making. Can you provide an example of what you don't like?
It's kinda a bug, I admit. One day maybe we'll get to fix this one, not within a week though :)
It's not of the code quality for *everyone*'s consumption just yet -- it will happily run on a fresh Django 1.3 project though.
`s = open('blah.txt').read()`
People tend to think of the performance race as statically typed ahead of time compiled code with no runtime information vs. dynamically typed just-in-time compiled code with runtime information, which is confounding a number of issues. * It's been pretty much proven that runtime information makes it possible to generate significantly better code. This is absolutely performance critical for dynamically typed languages, but offers a nice speed boost to statically typed languages as well. * Ahead of time compilation means your compilation time is a less crucial factor, which enables you to make more expensive optimizations. When combined with good runtime information, this should always result in faster code. * Statically typed languages give the compiler more information for use with the optimizer. Most of this information can be inferred from runtime information in dynamically typed languages, but not all of it. Statically typed languages will therefore always have a slight edge, but this has nothing to do with JIT vs. ahead of time. In the end, I think that the highest performance can and will be achieved through both ahead of time compilers that use a huge amount of runtime profile data to guide optimization and from JITs that cache their output across multiple program runs in order to amortize compilation costs. From a theoretical point of view, there is very little difference between these two compilation strategies. 
While it does support plug-in data backends rudimentarily, I really don't want to make a GAE backend for it right now. Sorry.
The point is simply that `assert x == y` is more pythonic than `assert_equal(x, y)` and therefore usually preferable. Of course the former works in any test runner, but it doesn't provide much help when the assertion fails. That's why py.test tries to identify uses of the assert statement, and provide special handling to print a better message.
Yeah but you have to run it on a Windows server &amp;#3232;\_&amp;#3232; 
or, Do It Like UNIX.
Would you be so kind as to try and guestimate how big would a JIT enabled, standalone, RPython interpreter would be? I mean, one .exe file that would be able to understand the restricted version of Python. (something like the LuaJIT.exe outputed by the build process from that project) Would such a thing be feasible to create from the current pypy source code? :)
Not sure a tool to determine versions is a better idea than `#!python3` etc, but... [pyqver](https://github.com/ghewgill/pyqver) guesses the minimum version of Python required to run a bit of code, by looking for version-specific bits of syntax/modules
I think you're messing up levels. RPython is the language in which the Python interpreter and the JIT are written and it's compiled to native C. Why would you want an interpreter of that?
I was naively thinking that being a subset of Python would mean that the interpreter would be simpler and... faster. :)
I really like pypy, but for one issue: It randomly segfaults on some pure python code I wrote. Under CPython it runs with no issues. Any ideas on how I can debug this? 
Do you have programming experience?
You've just isolated what really irks me about the phrase *more pythonic*. Yes, "assert x == y" is prettier from above, but it relies on ''assert'' having some special syntax or even worse, operator overloading in the vein of what all the ORMs are doing today. Yes, such code is nice to write, but the implementation magic required behind the scenes breaks half the "Zen of Python" rules from ''import this''.
The following is valid in both Python 2.7 and in Python 3.x: assert x==y, "Expected (%s), got (%s) instead." % (x, y)
[Attest](http://packages.python.org/Attest/) also does that.
Not really, I know HTML and CSS and I've used PHP (over 2 years ago) so I don't remember much of it.
I don't know how big your script is, but I would try to make it as small as possible while still segfaulting and submitting that as a bug. Else, I'd recomend you head over to #pypy at freenode, they'll be able to guide you on how to debug it. Bear in mind that if you use any library that uses C, that might be the problem.
Remember, RPython is never meant to be interpreted! It's just simplified enough that it can be translated/compiled to efficient C. That C code can then be compiled into a native executable which can be used to interpret regular Python. The reason for RPython is to allow for development to occur in Python and not C, since it makes many things easier.
Start here: [Learn Python The Hard Way](http://learnpythonthehardway.org/) Don't let the title fool you. It is a nice intro.
Thanks! 
My pleasure.
 f.close()
Only in CPython, which closes the file automatically if you use the file like that. Otherwise this is the preferred idiom: with open('blah.txt') as f: s = f.read() Or this if you are working with older versions of Python: f = open('blah.txt') s = f.read() f.close()
This question is asked like every other day. Go here, it was posted 2 days ago. http://www.reddit.com/r/Python/comments/ikf6d/what_is_the_best_way_to_learn_python/
*All* implementations of python will automatically close that file. Just because some garbage collectors are lazier than others doesn't mean the file won't be closed. I imagine that the only possible way my example would cause problems would be if you were a) Using PyPy and b) Somehow managed to execute that line of code 1024 times in a very short period of time. Thus I stand by my simple happy snippet of code.
Search the internet.
It's pure python, no extension modules other than was provided by the pypy distribution. I was hoping there would be some trick to isolating the fault. 
Where's that?
I figured it was better to ask people about it rather than look through the numerous guides of differing qualities.
Thank you for your reply! As I said, I was being naive, a fool if you want. My knowledge is also quite limited. I simply saw what Mike Pall managed to do with LuaJIT and just wondered, how much more complex IS python? RPython **sounded** to me like something somewhere in between Lua and full Python and I naturally thought: could something as small and efficient as LuaJIT exist with a python syntax? :)
Documentation for a complete framework can't be built in one day. Release of DEAP 0.7 make a step further into presenting every aspect offered by the library, including some complex aspects like genetic programming, and load distribution. As for the code design, I think it's really a matter of taste, as I like frameworks to be open, allowing me to write exactly what I have in mind without having to dig inside class hierarchy. Following this vision, I tend to see ECSPY as a classic ready to use black-box framework, while DEAP is more a tool for learning, developping and researching evolutionary algorithms. All of this come from the eye of a DEAP developper, so I'll be curious to read inputs from people who tried both libraries. 
Can't you just edit it into your .py files in your Lib? I've done that with a few peices of the standard library, and whilst, the the code won't work for any one else, it works for me.
I think the point is that if there is a right way to do it and a wrong way to do it you're better off doing it the right way. Especially when you can just add eryksun's calculate_age function to an module and *never* have to think about how it works again. Just write it once and re-use, re-use, re-use.
Still, it's a good idea to avoid dangling files like that. With `with` it's ridiculously easy to do. Letting open files rot, waiting for GC to pick them up at some point in the future just doesn't feel very clean to me.
Chicago
How does it rely on assert having a special syntax?
You seem to be the most helpful person who's responded, which version is better to use? I have 2.6 which came preinstalled and 3.2 which is the latest. A lot of tutorials seem to differ in versions and google's own Python tutorial suggested staying away from version 3. How much does each version differ and is it significant whilst learning Python?
please report it as a bug. We will fix it.
The resource I gave you works with the Python 2.x series. So stick with that. If you want to learn more like web frameworks they are still in the 2.x series as well. Everything you learn about Python 2 will translate to Python 3. The libraries and such have not caught up to Python 3 yet.
Ok, thanks for your help.
My pleasure and have a great journey learning Python.
for the same reasons **print** had special syntax (pre python 3) In many ways it would be easier if a person could call assert(bool_exp [, error msg]). This way you get to skip any calculations made for the error message if the assert passes. e.g. assert True, resource_intensive_error_producing_method() will not call resource_intensive_error_producing_method because assert True passes Edit: Thanks gutworth
No worries, I only know what I do about PyPy by fumbling around with it a bit a year back. The fact that there is a Python-&gt;C converter trips up a lot of people who don't know about it. Basically, RPython mostly just concerns contributors to PyPy. Although a JIT for it could probably be pretty fast, it's unnecessary because RPython is designed to be able to be converted to C in the first place (a lot of Python's more dynamic features are left out). I don't know too much about the differences between Lua and Python. For sure the fact that Lua is based on tables as the main data structure probably makes its implementation a good bit simpler. But as others have mentioned Lua has a much smaller standard library as well. 
I tried quite some books to get into python and programming in general. This one made all the difference for me: [Think Python](http://www.greenteapress.com/thinkpython/thinkpython.html)
Yes, that's the deal breaker for me.
Flask?!
Flask is not based on Django.
It's just that this isn't a new question. In fact, it was asked yesterday, along with roughly once a day. The answers to this question should probably go in an FAQ for this reddit since it's such a common thing - I'll make a post about it.
then you should have just searched this subreddit
assert already works that way.
That'd be helpful to new people like me, thanks.
Sorry for the major inconvenience I've caused you.
Add a link to /r/learnpython -- big, bold, red and flashing. The one in the sidebar is apparently too subtle.
Part 3 is [here](http://www.reddit.com/r/Python/comments/immme/basic_data_plotting_with_matplotlib_part_3/)
Part 2 is [here](http://www.reddit.com/r/Python/comments/ilrq7/basic_data_plotting_with_matplotlib_part_2_lines/)
Pop up terminal, type 'python' and you will get the interactive python shell. Type 'quit()' or press Control + D to quit the shell. I got started by checking out: http://diveintopython.org/toc/index.html
Not tested, but this should also make possible a: #! pypy Nice...
`li` is not a class member, it's a global. I would change that - if you're passing it via `__init__`, then save it. Your example is only working because the global `li` is the same name as used in the `dump()` method. This example is too simple to know if using a class is a good idea or not. But yes, it does give you a chance to try out classes. With Python (coming from a C++ &amp; Java background prior) one of the things I had to unlearn was using classes *too much*. Also, it was a good perspective change to realize that a module (ie. file) can be considered functionally equivalent to how classes are sometimes used in Java/C++. Instead of having a class with methods &amp; members, you can just have a module with functions and module variables. The module *is* the class. Of course, if you have stuff that you need to make lots of instances of, then classes may be an excellent choice. But, I find that in Python I use classes a lot less than I would have to in Java/C++ 
On a micro level: * It's convention in Python to capitalize class names. * You never do anything with `li` in your initialization method. * The file is never closed. On a macro level: * This class isn't really a "thing", just a set of actions. You'd be better off just writing a function. * That function already exists. It's called `file.readlines()`, and you use it like this: `li = open("C:\\Users\\Xenocorp\\Desktop\\test.txt").readlines()`
This is quite handy. Especially the Popen subclass that integrates all the lovely info with subprocess.Popen.
* Capitalize your class name. * Inherit from object (new style). * Close your file handle. * Don't use globals. * Don't reinvent the wheel (http://docs.python.org/library/csv.html) 
Yes I get that there is already a method for reading a file all at once, I will eventually merge the file reading and CSV module into a set of functions/classes, since I deal with a tonne of Excel files on a daily basis. Oops, mistake. I see that I didn't self.li = li in def.__init__ I've changed that now. Also, this kind of points out what I was asking in the main thread. Is it a good idea to use mutable arguments in functions/classes, as either method of passing in mutable stuff, worked. At the end of both the global name li was filled with what was in the file.
I am trying to eventually merge the CSV and file reading into a few classes. If I can pass a single variable to a function and have it open and dump the file, with a importing a single module, I can see it saving me some time. The global was an accident that I've now cleared. I'm not sure what you mean by 'inherit', I've heard about it, but never seen it in action. If you have a link to some further reading, that would be much appreciated. I'm coming up to the Classes section in my book so maybe it'll be there, too. Thanks for the response! EDIT: I've changed the: self.li = li[:] Is this a better idea? Or, alternatively, just remove the passed in argument and create a new list with each instance of the argument?
&gt; Is it a good idea to use mutable arguments in functions/classes Not generally. It's almost always better form to create a new mutable object during the initialization function and make that accessible via a getter or just as an attribute.
Well looky here: [http://blog.python.org/2011/07/python-launcher-for-windows_11.html](http://blog.python.org/2011/07/python-launcher-for-windows_11.html)
Thanks for the great reply. I'm actually a little fond of classes, they just seem *cool*. I don't know what it is, but this whole idea of object.method is mesmerizing. What are the reasons that you had to *unlearn* it? I can see that eventually it can be annoying to code a tonne of Classes into your code, but it seems to be something that can really speed up the code *re-use* ability. In my example it does seem that it could easily be a single function, but I will expand on it once I've got the *style* of writing classes down. How do you do inline text changes in comments?
&gt; Control + D or on windows Control + Z 
a getter? For the time being I've changed it to: self.li = li[:] Would you think that is a better method for pulling in global mutables?
does matplotlib work with it?
A getter is just a method that returns a member of a class. def li(self): return self._li It's common style in some OO languages like Java, but Python convention is to only use a getter if you need to change something before it's returned, like if you want to provide a new copy of a mutable rather than letting other code touch your copy. Is there a reason you need that list to be global?
Thanks. I excluded the windows key combo because the OP seemed to own a Mac.
When I first learned about classes (after some time working in procedural/structured languages like Pascal and C), I was as mesmerized as you are. Working in C++ and reading the Gang of Four book cemented my "love" for the concept. Then, hard won experience taught me that they are not the silver-bullet, nor the be-all-and-end-all, but simply yet another technique to be used or discarded as appropriate. Classes are better tool in languages that are statically, strongly typed. Since python isn't like that, classes become more of a convenience instead of a requirement. One of the things I like about python is the ability to easily move between using classes and not using classes. Python's way of doing things means classes have very low impedance in actual use. I try to limit classes to cases where I have a collection of complex things *that also have behavior*. If the thing is just data - stay with a dictionary. (In fact, always use a dictionary, and just make one of the keys a function, but I digress) I used to make classes to represent 'objects' in my 'model', in much the same way as you'd do it in Java. Don't do that. Reserve classes for typed heirarchies of related complex things. 80% of the time, what you really want is a dictionary, 18% of the time you really want just a module and 2% of the time actually a class. It's not classes that help re-use as much as it is *parameters*. A class that encapsulates data and provides methods to operate on it is the same (but orthogonal) to a module that provides functions that operate on parameters. It's just an organizational thing - whichever is a better fit to your task. In your example, I would be trying to pin down what I'm trying to do. Does my class represent the file or the file *contents*. Should it know how to fetch the data from the file system, or just get it passed? I like to be minimalistic with classes/methods - do one thing, and one thing only, so personally, I would say in your case, the class is the contents and it doesn't know how to do file I/O. Of course, the converse opinion is also valid in some cases - maybe you want to wrap up a whole chunk of things and present a really simple api to a complex process. But...is that really a class...or is a module? P.S. Indent four for multi-line code class Indent: def __init__(spaces=4): pass Use backtick \` for inline `# stuff like this` 
&gt; *Python convention is to only use a getter if you need to change something before it's returned* I want to highlight this - it's an important point. 
So this launcher will allow me to work with version 2 and 3 code on the same machine, without virtualenv? Nice.
http://docs.python.org/library/sqlite3.html Or, if that's your thing: http://docs.python.org/py3k/library/sqlite3.html
Thanks for the tips and that Gang of Four book looks really interesting, that might be on my wishlist. What kind of level is it? At first I thought it was referring to the band Gang of Four, which, incidentally are also awesome.
you want to use mongodb. learn to use it now.
I had to set `python=3` in `%APPDATA%\py.ini` to make Python 3 the default interpreter when I run py.exe. Also, if anyone knows how to get it to install for all users, I'd appreciate the help. It's only installing for the current user. I suppose I could use winreg to copy the registry keys from HKCU to HKLM, but there must be an easier way.
Yeah +1 for sqlite, it comes with Python by default and is much simpler to get running than MySQL.
Are there any tutorials for using it? 
[Design Patterns](http://en.wikipedia.org/wiki/Design_Patterns) (aka: Gang of Four) is a very interesting book. A little dense at times and it expects familiarity with OO design concepts. It is both really good (documents common patterns) and really bad (influences thinking) and must be considered judiciously. Yet more tools for your toolkit. The patterns are generic enough you can apply them in almost any language that supports some kind of OO. (But that's not to say you *should*) 
Inheritance is a bit too complicated to cover in a comment here, so I'll just wuss out and give you the wikipedia page: http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming) The reason I say inherit from object, is so that you get into the habit of using what python calls "new style classes". Google that term and you'll see what I'm talking about. OOP has some dark corners, it can be dangerous to know "why" you're doing things at first. Just follow the rules until you know when to break them. In general: if you're only making 1 instance of a class, you probably don't need a class. Right now you just need some functions.
what he is referring to is to declare your class like class Excel(object): for detail: http://docs.python.org/release/2.2.3/whatsnew/sect-rellinks.html#SECTION000310000000000000000 the csv module support the excel dialekt for reading and writing, totally the way to go. http://docs.python.org/library/csv.html#csv.Dialect
Only as far as the Python version is concerned; usually, virtualenv is also used to isolate specific third-party libraries. The launcher doesn't help with that - it's mainly a shebang processor.
&gt; I had to set python=3 in %APPDATA%\py.ini to make Python 3 the default interpreter when I run py.exe. That's because for most people, a better default is still Python 2.x, because many packages still remain to be ported. You can also use environment variables for this - see the PEP. In terms of the registry entries, I'm surprised by what you say: the only entries the launcher sets up are in HKEY_CLASSES_ROOT, nothing in HKLM or HKCU. (When it *looks* for installed Pythons, it searches both HKLM and HKCU.) The launcher sets up: .py, .pyc, .pyo and .pyw associations to progids Python.File, Python.CompiledFile and Python.NoConFile, and under the ProgIDs the open commands point to the launcher executables.
the doc pages referenced by pigheaded has examples, plus you can browse to sqlite.org for more. If you need a tool to view the database outside of your program you can download app from http://sqliteman.com/ 
I didn't mean it was wrong for the default to be version 2. I was just reporting what worked to change the default behavior. I had no entries in HKCU before running launcher.msi. I only had entries in root and HKLM. The installer added the entries to `HKCU\SOFTWARE\Classes`, but it didn't modify the entries in HKLM, so when I log on as another user it still uses the system default (`C:\Python32\python.exe`).
It works. I added the following to `%APPDATA%\py.ini`: [commands] pypy=C:\pypy-1.5.0a0\pypy.exe 
&gt; The installer added the entries to HKCU\SOFTWARE\Classes, I see you've logged an issue - great. I'll look into it and follow up there.
You might want to look at some tutorials on basic SQL syntax which applies to sqlite, MySQL and a lot of other databases. Once you know the basics of SQL the Python sqlite documentation will be a lot easier to follow. A good place to start might be http://www.w3schools.com/sql/sql_intro.asp 
Thanks. I'm currently going through http://learnpythonthehardway.org but I'd love it if you could recommend a goal based tutorial. It's kinda boring just adding up numbers again and again.
Thanks. I've downloaded python 2.6.6 and I'm using the IDLE. I've read in some places to use Windows CMD to access shit but what is the advantage of doing that? Or is there no advantage..
No he really doesn't, not for this.
I really have no preference between `assert x == y` and `assert_equal(x, y)`, given **pytest**'s helpful tracebacks. My problem with **pytest** is the awkward support for [parameterized tests](http://pytest.org/latest/funcargs.html#parametrized-test-functions). **nose** handles [parameterized tests](http://somethingaboutorange.com/mrl/projects/nose/1.0.0/writing_tests.html#test-generators) much better. This is an [open issue](http://bugs.python.org/issue7897) for **unittest2**. In a nutshell, when I test "functional" code (i.e. free of side-effects) I want this: * To list inputs and correct outputs. * To apply each input to a specific function. * To consider each a separate *testcase*, so that they will all run even when one fails. * To learn which inputs failed, along with expected and actual results. GoogleTest (C++, not Python) has very good support for parameterized tests via [`TEST_P`](http://code.google.com/p/googletest/wiki/AdvancedGuide#How_to_Write_Value-Parameterized_Tests). I wish the Python community would wake up to the value of this. At least **pytest** has something, but it's a lot of effort for a very simple idea.
He'll love it, Mongodb is webscale after all
I think perhaps he should go straight to the big time and pipe his data to /dev/null
3..2..1.. go ! (sorry)
(Ninja Edit) Sorry. Mixing things up a bit. It will probably work, but binary packages won't be out for a little while at least.
well.. I upvoted you. I teach a python class for noobs, and usually Mongo is quite a bit easier to pick up because instead of learning another language (SQL), everything is more dictionaries and lists. Plus it runs cross platform, is easy to install, and you don't have to deal with setting up schemas. Sqlite is a solid choice for learning with though.
you've had some good advice elsewhere, so rather than comment on your code, I'll try and comment from a bit higher up. From experience in various languages, you are best off thinking of classes as things that tie their own state and their own behaviour together. both of these things are just as important. If you just have a bunch of state but no behaviour, prefer to use a collection instead (a list, or a tuple, a dictionary, a tree ...). If you just have a bunch of behaviour but no state or very little state, drop those functions directly into a python module - it effectively acts like a class anyway, but it is easier to read, use and share. Classes are there to be made from. Think of them as blueprints or a cookie cutter - they are designed to be used to make concrete things (instances of the class). If you write a class and you don't instantiate it, maybe it shouldn't be written as a class. One mistake I made repeatedly in Python was trying to put too much state into single classes, and then trying to be super-protective about how that state was used. Keep your classes small and don't be afraid to read state directly from class A while you are in class B code. Most programming books will go into detail about how and why this is bad, and often it is - but I've written and re-written so much code to avoid leaky encapsulations that I've probably wasted a good few years of my life. Accept that life is not a perfect abstraction, understand that your code will occasionally be fragile, and revel in the beauty of the end result. Then trash that ball of mud and move on. 
Python 3. They shot their foot real bad when they decided to change some basic features of the language, like the behavior of the '/' operator. By doing that they lost credibility for the future, even if I convert all my code now (at a very great expense and risk) what guarantees do I have that they won't do a bigger fuckup when moving to Python 4? 
ROFLSCALE
Kind of disappointed this didn't generate more buzz. Does no one use any of these libraries/apps? Can anyone point out their favorites? I'm just getting through chapter 8 of the Django Book and I was hoping to hear an outpouring of "yeah my site uses &lt;blah&gt;" and "avoid &lt;blah2&gt;" etc. Nu?
Anyone use [socialauth](https://github.com/agiliq/Django-Socialauth) or [Social Registration](https://github.com/flashingpumpkin/django-socialregistration)? Are these approachable for a Django/Python newb?
If they didn't they would still be subject to criticisms like the unicode and scoping things...you can't win there. Making backward compatibility all important gets you Java generics, also widely criticized.
Whenever someone says OOP in Python is 'bolted on' I stop listening to what they are saying. Usually works out.
http://www.zodb.org/ is a great database written in python that stores python objects. 
&amp; debugger attach!
It's one thing to break backward compatibility with Unicode, an entirely different thing to break backward compatibility with arithmetic division
Seems to me they can hardly win on this issue. If they don't fix it people count it as a wart, if they do fix it people complain about backward compatibility.
&gt; I'll need a database for this Why? You might find it easier to start with something like [shelve](http://docs.python.org/library/shelve.html): import shelve d = shelve.open("users.dat") d['bob'] = {'name': 'Bob Johnson', 'hash': '757fef7a129e0269c80e54ec9446bbfba79a0ec2', 'salt': 'asdha8&amp;(#hkDhfs'} d.close() 
durus also
The problem is that there was nothing to "fix" here, it was only a matter of definition. In Python 2 the division operator worked like in C, (3 / 2) resulted in the value 1. In Python 3 the division operator works like in Perl, (3 / 2) results in the value 1.5. This is entirely arbitrary, it's perfectly OK to work in either way, as long as it's consistent. The way they made it is that a formula may give different answers, -- or not --, depending on the formula, if it's Python 2 or 3. They fucked up, it's as simple as that. Note that both in Python 2 or 3 (3. / 2) will result in 1.5 
I mean, when you think about it, that's probably where all our data will end up anyway.
&gt; That's because for most people, a better default is still Python 2.x, because many packages still remain to be ported. You can also use environment variables for this - see the PEP. I haven't responded to any of the PEP mails (yet), but -1 on shipping this with 3.3 and making the default 2.x. Actually, -1 for making the default 2.x for any reason. Even though 2.x is the most popular, it's dead. This is a new tool so I think we should push it with the new versions while making it possible via this configuration to make it work with old versions.
This is one of the coolest projects I've used in quite some time. I haven't had time to play with too much of what they offer other than basic editor and project support, but I live most of my time inside Visual Studio (for C++). I'm going to see if I can drop Komodo/Vim for a few days and give this a real shot.
But py.test has generator tests, too. (It had them before nose, in fact.)
Yes, your points are valid and I doubt anything would change your mind and [Guido has his opinion](http://python-history.blogspot.com/2009/03/problem-with-integer-division.html) and its valid and so on. My point is that they will be criticized either way so they might as well make the language how they think it should be.
I don't think there's any advantage, just use whatever is easiest for you. IDLE would be fine.
I hear it runs on the Windows! (*I dunno...I've never actually used it. I believe one of the perks is a much enhanced immediate mode.*) 
The problem is that he takes a theoretical approach, I have to take the practical approach. I have about a hundred thousand lines of Python code, I cannot afford to go through every one of those lines looking for where a division might give a different result. It's fine for him to say I should use '//' instead of '/' because it's not he who has to convert my code. I say forget about any serious Python code, I'm definitely scaling back on my usage of Python. I'm a professional, Guido seems to think Python is his personal hobby. I'm going back to C, it may be more work to create data structures by hand, but at least I can be sure those structures will stay the way I created them. Between software I created myself and software I manage, I have tens of millions of lines of code. This is serious code, I work at real time control systems for an aerospace company, mistakes may cost millions of dollars here. I can't let theoretical ramblings interfere with my job. Fuck Guido. 
Good riddance.
I use it all the time, and love it. ipython starts at pimping out your interpreter with some color syntax and tab completion. then it adds in some 'magic' functions, that let you do things like launch shell commands, reload and run scripts. Read the documentation for a function, check the defined variables, Check your history, save your history, define a macro, launch a terminal editor (and automatically run the script upon saving), and magic functions for timing short snippets, or whole scripts, or profiling your script. Plus, launching with (-pylab) automatically loads scipy and pylab with some kind of voodoo that allows plots to draw automatically and without interruption. This alone is worth the cost of admission. And if that weren't enough, it has a growing parallel support thing going on, wherein you can launch a cluster of engines and automagically run your scripts in parallel. It's the bomb. Well worth checking out.