YCM is quite possibly the best plugin for any editor ever. Certainly the best completion one.
A language written in itself is also *much* easier to port to other VMs. A Python in Python may open the way to, say, a Python version of GemStone/S. There's already a Ruby one, but they first had to re-write Ruby in Ruby, more or less. Just another one of those things Smalltalk got right first time all those decades ago…
Yeah, but I'd feel like I'm cheating Heroku.
Shit son, it's toy code. Everybody knows 4chan is a shithole... this is a pretext to write code.
Sure. You could do that. I don't use virtualenv that often, but you could do that without trouble. It might help to have them centralised, though, because you could then write/use scripts that can trust on your virtualenvs being in a certain location.
I have problems with some of these. * Replacing `a or b or c` by `any([a, b, c])`. Is that really more Pythonic? If they'd been in an iterable already I'd say yes, but now not so much. * Catching `KeyError` just to raise another `KeyError`? Just let it bubble up. * I kinda hate `namedtuple` because it's such a hack, but maybe that's just me. * Also, I'd say the opposite of Pythonic code is _not_ normal code. Un-Pythonic or unidiomatic, or maybe something about newbies.
There is no reason per-se against having the virtualenv inside the project, however once you start having more and more virtualenvs it becomes much easier to manage them in one location than go hunting through a lot of project directories. Additionally [virtualenvwrapper](http://virtualenvwrapper.readthedocs.org/en/latest/) really makes it a lot easier to work with them and it stores all virtualenvs in one directory.
Yep. I always look at that !
PyPy is written in Python 2. There are no annotations in Python 2. This might change now that there is a release of PyPy3, but I wouldn't hold my breath for it for a while.
Agreed with normal code and pythonic naming. `KeyError` depends on scenario. 
Don't know. I do have two hypotheses: * Maybe explicit type annotations are not explicit enough for the kind of type inference RPython needs to do. * Maybe they might add it in the future, but couldn't use it until now, because they need to support versions of Python that don't have function annotations.
Nice list, way to spread the good word. I've been writing python for 2 years now and learned a few new things from this. Thanks!
It doesn't matter where your environments are kept because the idea is that you maintain a requirements file, making the environment itself disposable. They could go in /tmp for all it matters. But if you want to keep environments in the project, go ahead. 
Yeah. That's what I do. And I always call it "Env". Every project has its own requirements.txt so it makes sense for it to have its own Env. You can set up a download cache for pip to save downloading packages over and over.
I've since changed the code and rewritten using collections.Counter It will now get arbitrary n-tuples of words..
I only use a venv for one project, I don't really see the point of sharing it between multiple projects
At one point I made a mkvenv.sh script in the project root. What it did, is that it checked if a virtualenv already existed in the root, if not it created it and added a signature file to it which was the sha1 sum of requirements.txt If there was a virtualenv already, it checked the sha1 against the current requirements.txt and rebuilt it if it was different. It was useful for testing in jenkins as any changes to the requirements.txt file would trigger a rebuild of the virtulenv , otherwise it would leave it as is
Really good ;)
I do it just like you describe, this is the same as node_modules and bower_components for example.
It might make sense if you were doing a lot of similar projects that could all use one of a few virtualenvs, and they needed libraries that took a long time to install (like numpy, scipy, etc). But that seems like an awfully narrow use case.
&gt; I don't really see the point of sharing it between multiple projects Err, no, of course not, that would defeat the purpose of using a virtualenv in the first place. I think you misunderstood what I was saying
I started to develop my first web app recently - and looked for the easiest to get started with - because - well - I'm not that bright. Django is fully featured, but figuring it all out is a PITA - and I am reluctant to use ORMs because the one thing I do know is SQL. Bottle was much easier to understand - but I settled on Flask because it was both easy to understand, and it has quite a few plug-ins if I need them; add in some Bootstrap and you can make quite a nice web app. Also, I guess doing a lot of stuff myself means it'll be easier to understand Django in the future if I have to.
&gt; There is no reason per-se against having the virtualenv inside the project, however once you start having more and more virtualenvs it becomes much easier to manage them in one location than go hunting through a lot of project directories. If it's one virtualenv per project then it's always in the root of the project. No matter what system i'm on, I always know where the virtualenv is, I don't have to go hunting around in a lot of project directories. Also, if I stop working on a project and I delete it, its virtualenv is gone, I don't have junk virtualenvs around that I don't know if they're still used or not
Actually, pypy already has an (experimental) way to get rid of the GIL by organizing the heap with software transactional memory (STM). The problem is that a) this is still experimental and unstable and b) it is much slower unless threads are being extensively used. I think both problems can be solved eventually but it would require more time effort and community interest. Having pypy 3 out may help with that last one.
Ah yes, spaces instead of tabs, I have heard that is preferred. I will find the setting in Geany and that will be settled! :P I see alot of people using/recommending the requests package, and the more I read about it the better it sounds. I appreciate any help as I'm just starting out, so thanks!
Thanks! Trebek604 pointed out the PEP8 style guide to me which I had never heard of. I think this is something I wish I had found first thing so then I'd already have these habits heh
If you want to do this, take a look at http://www.buildout.org/, as it does exactly that -- creates a sandbox in your project directory, with the added benefit of "recipes" that can help a lot with deployment. Plus, you don't need to remember to switch your venv when you're working on multiple projects. Note: The documentation isn't great, which I think is the reason it's not used much. Persevere with it, and you'll quickly see the benefits over venv.
Well I guess it depends on how you work. If your way works for you - great. I prefer it the way I outlined above.
Some other links: * [Writing Idiomatic Python](https://www.jeffknupp.com/writing-idiomatic-python-ebook/) (Most of the example are included in that page, but there's more) * [Writing Idiomatic Python Videos](https://www.youtube.com/channel/UC8jQsBz_w948kSc7ehMRGmQ) (Still a WIP) * [Transforming Code into Beautiful, Idiomatic Python](http://pyvideo.org/video/1780/transforming-code-into-beautiful-idiomatic-pytho) * [Really, any video by Raymond Hettinger](http://pyvideo.org/speaker/138/raymond-hettinger) Anyone has more?
PyPy just released the first stable release supporting python 3 (3.2.5) http://morepypy.blogspot.it/2014/06/pypy3-231-fulcrum.html
Yes, as I said :) (Just to be clear: This is 'only' an *implementation* of Python 3 in PyPy. The language itself is still written in Python 2)
As /u/ulope said, I'm fairly sure the pypy tool chain uses a 2.x version of python so function annotations are a no go, but there have been other options like docstrings, so maybe they deemed them not powerful enough when compared to regular type inference?
pip install --no-index --find-links=path/to/wheels package==1.0 This is good article: http://lucumr.pocoo.org/2014/1/27/python-on-wheels/ 
Seriously, -1. You didn't even read what he wrote. And I hate this habit to that everybody here to jump at anything not perfectly written to "correct" it. Get a life.
They are installed with pip: $ pip install whatever.whl 
Ignore him, he's being a twat.
Agreed, using `all` and `any` over `and` and `or` isn't more pythonic at all. Use `all` and `any` when you already have a list / iterable, it's what they're designed for. 
this is a command I execute in the python terminal?
The normal code "is" example seems strange. I think the non-pythonic thing most programmers do with respect to "is" is not using it, for example: if a == None: when they should be doing: if a is None: 
No, straight from your terminal prompt.
* joined_lower for functions, methods, attributes * joined_lower or ALL_CAPS for constants * StudlyCaps for classes * camelCase only to conform to pre-existing conventions * Attributes: interface, _internal, __private I grew up on Java, which took Small Talk's camel case convention, so I'm just wondering: what's wrong with camel case anyway? The "blessed" coding convention in Python is the one thing I don't quite get. Is there an argument for underscores? I *swear* I am *not* trying to start a flame war. It's just that I'm wondering if the preference is completely arbitrary or not.
So I have the latest version of python downloaded. I downloaded the "get-pip.py" script, ran it and it worked, but at the end it said Installing collected packages Found existing installation pip 1.5.4 Uninstalling pip (next line) Successfully uninstalled pip Successfully installed pip Then when I tried entering &gt;&gt;&gt; $ pip install numpy-1.8.1-cp27-none-macosx_10_6_intel.whl and I got a syntax error in response. Any further help would be great... I have no idea what i'm doing
Could you expand on why "namedtuple" is such a hack ?
I think `if not a:` is better 
You're apparently trying to run these from the Python prompt, which is wrong. They are regular commands to be run from the standard terminal, not in the Python REPL. 
Depends. Could yield a false negative if a can be 0 or an empty string and that's not what you are interested in testing for.
I am in (almost) the same position as you are. I would like to gain more knowledge on Python and I'm currently looking for ideas. Also, [CheckIO](http://checkio.org/) is a great way to improve your python skills.
Again, i'm new to programming, so can you help me understand the difference between all of these (prompt, vs sdt terminal and REPL)? When I open IDLE, my editor, I get "the shell" that opens up on it's own where I can do basic things. This is where I tried running the installation thing. Is this the REPL or standard terminal? and how do I open up the one I am suppose to be running the commands in? Thanks!
&gt; if not a: will also be True when a is 0, '', [], {}, or a datetime.time of midnight
Empty sequences (strings, lists, tuples) are false. [PEP8](http://legacy.python.org/dev/peps/pep-0008/#programming-recommendations)
Thanks for the explanation. I have one more question: I was under the impression /dev/random was constantly fed new data from various unpredictable sources. If Python is not already using /dev/random, would it be better to use that, or at least occasionally re-seed Python's RNG with something from it?
Because it's implemented as piecing together a string that contains a class statement and compiling that to obtain the tuple subclass ([see source](http://hg.python.org/cpython/file/2.7/Lib/collections.py#l234)).
Sorry, the commenting issue was fixed.
You messed up the code formatting. s = 'qwerty' print(s[::-1]) i = 3 print(i if i &lt; 5 else 0) condition = ['Error', 'OK'] value = 1 print(condition[bool(value)]) choice = 'i' print({'i': 1, 't': 4, 'j': 22}[choice])
Don't run IDLE. I'm not an OS X user, but there should be something labeled Terminal that is part of the operating system and has nothing specifically to do with Python. That is where you are meant to run these commands. (And you don't type the `$` before the command. That's meant to show that you are to run that from a terminal prompt, because the default prompt ends in `$`.) 
Sorry may be I did not understand you but when we work with `None` or numbers we can be sure that a=None or 0 bool(a) = False bool(not a) True a=1 or -1 bool(a) = True bool(not a) False I have checked `bool('')` just right now in python3 and got False. `bool('hhh')` = True. Can you give an example when issue that you described may occur?
1) RPython is a python2 subset. 2) There's a lot of it, even if we moved to Python3, rewriting it all would be a serious undertaking. 3) We already have a decorator based syntax for optionally declaring types, which means we have almost no motivation to upgrade just to rewrite our codebase and get nothing new.
Goofy implementation, doesn't need to be written that way
Hey gschizas or anyone else who happens to read this... I know this thread is almost a month old but did you ever figure out the "Zwangi" problem? Having py2exe on my work computer would be stellar, but my anti virus software is stopping it from running (because of Win32/Zwangi). I don't want to override the administrative virus software if this thing is actually going to harm the computer. Dealing with IT is bad enough... Thanks in advance!
TBH, I haven't looked at it since then, as I'm mostly using cx_Freeze. In any case, the problem is still there, even one month later. Sad, really.
I think it's important to note that annotations can be anything for any reason, and they don't need to be return types. Based on [this post in the dev list](https://mail.python.org/pipermail/python-3000/2006-June/002438.html) also cited in [the annotations PEP](http://legacy.python.org/dev/peps/pep-3107/) there is a deliberate intention to keep annotations and their interpretations out of the standard library and core python. I would guess that the pypy community would prefer to hold to this unless the benefits for the project were substantial.
&gt; Catching KeyError just to raise another KeyError? Just let it bubble up. Agreed, unless you want/need to add more context to the error. &gt; I kinda hate namedtuple because it's such a hack, but maybe that's just me. Thank BDFL for `namedtuple`. It's perfect for a lot of use cases IMO. 
Is this a troll? You really think that the first example is bad code? You prefer to check a list that doesn't exist and has no meaning to using comparison operators? As to your fix, `sorted` returns a sorted list, it does not check if the list is sorted. So if by perfectly clear you mean perfectly clear that it doesn't do what the original code is intending, then yes, it is quite clear. 
No worries, thanks for the quick reply!
Going to disagree with: * `any`/`all` over `or`/`and`, it's harder to read (and slower), nothing about this is more pythonic * `KeyError`: there's no point in raising your own exception, just let the one from `dict.__getitem__` propagate. 
thanks so much! I was under the impression that python had some alternative terminal, I didn't realize it was the computer's terminal itself I needed to use. Thanks!
Do you mean: &gt; using `all` and `any` and &gt; Use `all` and `any` ?
For example, if I have a variable which is initialized as None and later want to find out if it was set, I might want to check and see if it was still None. If it's not, I want to do something. if a is not None: do_something() If I rewrite that as: if not a: do_something() do_something will also be called if a was initialized, but to a blank string, which was not the intention. Lots of types have some concept of a "false" value. As /u/steve_no points out in another comment: 0, '', [], {}, midnight all evaluate to False.
I see. Thank you.
Pretty sure most preferences with this are kind of arbitrary. I think the idea is to make it similar to natural language with _ in lieu of a space. 
Both have pros and cons. You can argue it to death which is better — the more important thing in general is consistency.
It is style and by definition style is subjective and completely arbitrary. You should write your code consistently no matter what the style is. In a team environment you should match the style used in the rest of the codebase. These style guides are just best practices, as they have been fought over for a long time. To this day people fight over where the braces go in C code, so having a unified "Python style" is nice. 
see [here](http://bugs.python.org/issue3974) for why it's kept that way.
Yeesh. There were a lot of errors in this. I found even more while cleaning up the ones you mentioned. Hopefully it's fixed now.
Thank you. Ran in to this exact issue earlier when a JSON request was returning an empty list.
Is `foo[:]` really the Pythonic way to copy a list? Edit: In Python 3, lists have their own `.copy()` method.
I've been using this for several days and it worked great. I have a craigslist scraper that pulls from a list of proxies and I was using this script to populate that list. Over the weekend I've not been able to get any proxies to pass all the checks. I've ran the script with "-s 10" and get no results every time. I ran it again with "-a" to see what the issue is and it seems like no proxies can pass the astrill.com check. IE: -------------------------------------------------------------------- 86.51.26.15:6588 | N/A | danmcinerney.org | 0:00:01.492890 | | dnsdynamic.org | 0:00:01.008426 | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Passed: elite proxy -------------------------------------------------------------------- 86.51.26.15:8090 | N/A | danmcinerney.org | 0:00:01.502075 | | dnsdynamic.org | 0:00:01.009243 | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Passed: elite proxy -------------------------------------------------------------------- 86.51.26.15:8008 | N/A | danmcinerney.org | 0:00:01.542672 | | dnsdynamic.org | 0:00:01.008047 | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Passed: elite proxy -------------------------------------------------------------------- 86.51.26.20:5555 | N/A | danmcinerney.org | 0:00:01.527005 | | dnsdynamic.org | 0:00:00.897465 | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Passed: elite proxy -------------------------------------------------------------------- 86.51.26.15:8089 | SAU | danmcinerney.org | 0:00:01.556448 | | dnsdynamic.org | 0:00:01.008312 | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Passed: elite proxy -------------------------------------------------------------------- 86.51.26.15:3128 | SAU | danmcinerney.org | 0:00:01.514200 | | dnsdynamic.org | 0:00:01.009771 | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Passed: elite proxy Normally when I scrape for 30 proxies with "python get_proxy.py -s 30" the first few populate immediately with US proxies that are quite fast. For whatever reason though, all weekend those proxies are all erroring out across the board. None of the test sites can connect to the proxies even though my personal tests are working just fine. Any idea on what might have changed? Proxy | CC | Domain | Time/Errors -------------------------------------------------------------------- 183.57.78.124:8080 | N/A | danmcinerney.org | Err: Cannot connect to proxy | | dnsdynamic.org | Err: Cannot connect to proxy | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Err: Cannot connect to proxy -------------------------------------------------------------------- 23.89.198.161:8089 | N/A | danmcinerney.org | Err: Cannot connect to proxy | | dnsdynamic.org | Err: Cannot connect to proxy | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Err: Cannot connect to proxy -------------------------------------------------------------------- 37.115.34.72:3128 | N/A | danmcinerney.org | Err: Cannot connect to proxy | | dnsdynamic.org | Err: Cannot connect to proxy | | https://astrill.com | Err: Cannot connect to proxy | | Header check | Err: Cannot connect to proxy
Also, thank you very much for the script. I was able to rewrite my craigslist scraper with threading so I no longer get temp IP banned when I scrape country-wide. It's been extremely helpful.
Did you ever truly need the performance of a namedtuple or a class with \_\_slots\_\_ defined? They make quite a difference.
Yeah, I noticed that too. It seems like the "normal" way has the advantage of being clearer more concise.
I prefer newList = list(old_list) Communicates intent better
The only downside is the "normal" way is incorrect (or correct depending on the situation). Point being they're not the same thing.
I'm sorry but a lot of these look like they're directly ripped from Raymond Hettinger's talk on pythonic conventions. https://www.youtube.com/watch?v=OSGv2VnC0go
&gt; I object to `if super_users:` over `if len(super_users) &gt; 0:` There is a huge difference between an empty list and `None`. Both of these tests can only be used if you know that `super_users` is a list and not `None`. Using `if super_users:` is not abusing syntax, it just uses the intended and well-known fact that non-empty sequences are true. (It's also recommended by the style guide [PEP8](http://legacy.python.org/dev/peps/pep-0008/#programming-recommendations).) 
Describe your problem in more detail, please. Sometimes rolling your own processing flow is faster than using a library because you can customize it to your specific inputs/outputs.
Mistakes do happen, and I would like to thank you for your efforts in providing this tutorial, it helped me to refresh my memory.
A syntaxe error ? Can you copy the whole thing ?
While I love asyncio, it's doesn't provide the additional benefits of stackless : no recursion limit.
Do you have an existing code base in Python 2? If so, now is a good time to think about moving to Python 3. But don't feel that you have to move *right now* -- Python 2.7 will be supported until 2020, so you've got plenty of time. If you don't have an existing code base, but you're starting a new project, check your dependencies. If the dependencies require Python 2, and you can't substitute something else, then you're stuck with Python 2. Do consider contacting the authors of the library and telling them you would appreciate Python 3 support. If you *must* stick with Python 2.7 for a new project, be sure to write your code in the most future-proof way. (Your future self will thank you.) To start with, put this at the top of every module: from __future__ import division, print_function, unicode_literals from future_builtins import * If so, you might want to hold off a few more years before moving to Python 3 -- but don't wait too long. But if all your dependencies support Python 3, and you have no existing code base to tie you to Python 2, then congratulations, you should seriously consider using Python 3.3, or even better, 3.4. But before you start, do you know Unicode better than a PHP developer? If not, you need to start here: http://www.joelonsoftware.com/articles/Unicode.html Seriously, that was written in 2003, and yet there are *still programmers that think that ASCII is all they'll ever need*. Makes me weep for the quality of coders out there.
Sorry, i was unaware that 'sorted' was already in the Python standard lib. I revised my remark to make it more clear what I was getting at. Basically my beef is that the back-to-back comparison operators is a special case when stacked up against other operators in the language. It doesn't read well when your engineers are also experienced in Javascript, C, Go, and everything else. Consider this: if a + b &lt; c: We take this as being equivlaent to "(a + b) &lt; c", right? So why does "a &lt; b &lt; c" get expanded to "a &lt; b and b &lt; c" ? It's terribly inconsistent.
The point is that it's not really a hack. Their implementation may be "hackish" but it doesn't depend on a hack to work.
Yeah.
There's also copy.copy().
I addressed lot of common cases. It *wasn't* rip off the tutorial. I have watched lot of talks by core python devs, read writing idiomatic python code, python cookbook et all. Talk appeared last year, but there are blog posts and snippets which predates the talk. Does that mean Raymond Hettinger copied ? http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html http://python.net/crew/mwh/hacks/objectthink.html 
Aside: Is Digital Ocean really using the term "x32" to refer to 32 bit operating systems? That is so completely bogus and wrong and I can't believe they'd do something so dumb. x32 is a separate ABI, distinct from x86 and x86_64, which uses 32 bit pointers but the full 64 bit instruction set, and runs in long mode. Few if any distros support it yet, and the ones that do provide little more than a kernel and C toolchain, i.e. you'd have to build an entire userland yourself. 
`is` is used with `True, False, None`. If is used for string comparision there are serious drawbacks. `a is None` works because of singleton. Most people try `&gt;&gt;&gt;'foo' is 'foo'` and it works. When they store the result in db and retrieve the value `is` comparison will fail.
You sir are correct. Though "memory location" isnt a great way to say it. I would say: The is operator returns true if both names are bound to the same object instance. Since the "names" wont share a memory location. 
Just a suggestion OP your examples are very wordy. The exceas code is valid but it obfuscates the point youre trying to illustrate in alot of places. For example: Superusers =functioncall If len(superusers) &gt; 0: ... Adds "real" context but obfuscates the boolean empty container idiom that youre trying to show. You dont need context to provide code examples. For instance I would say: mylist = [] if (mylist): print "mylist is empty!" Because even though that snippet has no practical application it clearly and succicently presents the concept. More power to you for adding more educational materials to the python world. Keep it up. 
Does Treading on Python use v2 or v3?
Next time will write as blog post rather than code only show case.
Never mind "Pythonic", which seems somewhat in the eye of the beholder: `a or b or c` is not semantically the same as `any([a, b, c])`. In the former case, `b` and `c` are never evaluated if `a` is true. In the latter case, they always are. So if they were expensive to compute (e.g. expressions involving expensive function calls, rather than just bindings in a namespace), the runtime behaviour (performance, raising of exceptions) would be quite different: &gt;&gt;&gt; a = 1 &gt;&gt;&gt; a or b 1 &gt;&gt;&gt; b Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'b' is not defined &gt;&gt;&gt; any([a, b]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'b' is not defined &gt;&gt;&gt;
And even at that, just use the `raise` keyword alone.
Not even necessarily that. Just dont worry about being so specific with the examples. Make them as small and digestible as possible. 
I find your indentation ... excessive.
If they're using python3 then why prefix the strings with u? They are unicode by default afaik.
&gt; The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes. https://docs.python.org/2/library/random.html Basically, reading from /dev/random is slow because it needs to wait for those "unpredictable sources" to generate random numbers. Computers can usually calculate faster than a true-random number can be generated (especially if 20 or 30 programs on your machine need random numbers), so you can get one truly random number and 100,000 "very random" numbers in the same time it takes to generate two truly random numbers. Usually, that's good enough. &gt; at least occasionally re-seed I'm sure it does, but probably not very often (hours, maybe) which gives you some time to cheat the system. Again, this is purely used for non-cryptographic uses so there is no strong requirement to be *truly* random.
the "is" keyword can be dangerous if you don't understand what it really does though, which is a common problem for beginners. in your example, its absolutely correct, because None is a singleton so any reference to None refers to the same instance of None. in general though, is checks for object reference equality (rather than value equality) and can produce unexpected results if you use it when you really meant to check value equality. 
if a name doesn't exist you'll get a NameError exception. 
Copying is a detail of slicing syntax, it's not the purpose of it. With the list constructor it's immediately evident there's a new instance involved - that's what constructors do. foo[:] also looks weird.
I agree with you. I think the 'any' function is intended primarily for dynamically populated lists where you don't know before runtime if it will be empty or contain an arbitrary number of items. If you know in advance which items to check its definitely better to use an 'or' chain. 
Ah yes, I was using nano in linux to write that, and forgot to set the tabs properly to 4. I forgot lots of other things too. I did however do LOTS of work on this since my first post, and even got it working with Python3, which my Windows PC has. I also figured out how to use github heh. You can see newest version [here](https://github.com/refrax/wallbase) if you are interested.
I was talking about the list().copy method.
Hack or not, named tuple is an amazing module for writing unit tests. Hardly an easier, lighter, and more self-documenting way to simulate a class in some specific state (so long as method calls aren't required). 
They certainly do "point to" the same memory location. But that's horribly un-Pythonic terminology.
Using `is` with `True` and `False` is a serious code smell. If there's any possibility that the value is of some type other than `bool`, why don't you want to handle it in the default way? And if there isn't, "simple is better than complex" applies.
If `super_users` can be either an empty list or None, and your code cares about the difference, it should be explicitly checking for `is None` first. "the length of the list is greater than zero" is an unusually verbose way of saying "the list is not empty" in English; the analogous statement holds for Python, except that we don't have an actual keyword for "empty".
Support 2 and 3 from the same codebase, if for some reason you don't want `from __future__ import unicode_literals`.
It's a standard math construct from a very basic level; even non-programmers reading that code would have a very good guess as to what it does. Just because other languages can't be bothered to implement something so nice doesn't mean we should avoid it in Python.
I dislike it because it's conceptually roundabout. "A list containing elements of *x*, from the beginning to the end" is similarly awkward in English compared to "a copy of *x*", or even "a list of the contents of *x*". Even if the analogous Python is terse.
 def bar(names=None): if not names: names = [] names.append('blah') this is wrong. it should be `if names is None:`. (what happens if you pass in an empty list that you want to append to?) also, i would never, ever, use `Counter`. it is unbelievably slow (at least in 2.7). just use a `defaultdict(int)`
I understand your point. I disagree that its conceptually roundabout. Once you understand that the slice operator really means "return a copy of this section of the list" it seems really natural. 
I prefer pip because there are a lot of instances where packages haven't been bundled for my distro (arch in this case) and I don't like having my packages split between distro packages and pip packages. It's just easier to have them all installed by pip.
I started reading the source, saw `_class_template` was a string literal with formatting. My heart sank a bit. Could almost smell the sulfur wafting from the `exec` statement.
True, but as far as I know, the specific consistency api isn't the problem or the solution. The GIL is required because the heap is not thread safe. Organization of the memory is deeply integrated in Python and the presence of the GIL is assumed by even more packages. This is a tough problem to design around.
Funny enough, I was curious about how the Python built-in `callable` was implemented just now and I stumbled on [this page](https://docs.python.org/3.3/reference/datamodel.html) with the following quote: &gt;Every object has an identity, a type and a value. An object’s identity never changes once it has been created; you may think of it as the object’s address in memory. The ‘is‘ operator compares the identity of two objects; the id() function returns an integer representing its identity.
Use apt-get for anything related to your OS and pip for your dev libs. Use apt-get for your dev for stuff really hard to install like QT or Wx, but that's all. Thing is, pip will get you more up to date packages, and can install in virtualenv, which make it a lot better to dev.
Coming from bottle, I'm using morepath for a new project of mine and up to now I really like it - it's well documented, flexible, and security is not an afterthought or left completely to third parties. So - good to see morepath progresses, thanks for the good work!
any(map(is_interesting, (a, b, c)))
`Counter` has its own benefit. If the key doesn't exist it can return 0. There are lot of scenarios where this is super useful. 
I use pip to manage dependencies for my own code. However, I strongly recommend against using pip as root (or with sudo). Either create a virtual environment for your projects or use "pip install --user" to install libraries to your home directory. Otherwise you may end up with conflicts between APT versions and pip versions.
"You may think of it as" is important. The identity is actual a hash of the name in a lookup table. Not to argue or anything, just want to emphasize that you cant actually deal with memory or memory locations directly in python. 
Py2.7 supports annotations, checked earlier while posting. I'm aware PyPy's codebase is stuck in Py2 for foreseeable future, so I wouldn't have asked if it were simply a modern feature and not backported. Edit: Derp, epic testing fail.
Py2.7 has annotations. And I'm only suggesting them as an addition to regular type inference, but based on an interview I heard with some of the devs and tidbits I've seen, I think all numeric types are doubles? So simply marking something as `int` or `float` should suffice. As far as strings and bytes etc., they're all static, so annotating them as their type should likewise be enough. Perhaps for lists and dicts, though, more intensive analysis is needed to allocate sufficient space..
Indeed; annotations being flexible is handy. Although i would like to see stdlib modules that allowed you to use annotations for different things, so you didn't need to pick external modules to depend upon. That's all irrelevant to rPython, though, which can use annotations however it likes; the regular Python interpreters would simply ignore them as usual.
Am I the only one here who hates implicit casting to booleans? It seems more with the Zen of python to prefer `if len(z) &gt; 0` to `if z` even though the latter is much shorter.
&gt; Py2.7 supports annotations http://i.imgur.com/ms9YC6p.png ???? edit: or are you talking about decorators?
There is an important piece you are missing here. The note correctly refers to the *period* of the pseudo-random number generator, not the size of its seed. The first shuffle after seeding will only produce one of 2^(seed bits) permutations, yes, but if the period of the generator is long, the second shuffle will be one of a second 2^(seed bits) permutations. Python uses the Mersenne twister, which has an incredibly long period (2^19937) − 1). So, if shuffles are run repeatedly off of a single seed, it is possible to achieve all possible permutations of a 52 card deck (although there still only 2^(seed bits) orders in which those shuffles can appear). By default Python seeds with the system clock at import time, so for a continuously running script things should be fine - the first shuffle is trouble, but if the players don't know how many shuffles have occurred since the last seed they can't use the limited permutations trick. A flaw the paper you link points out is reseeding before each shuffle, making each shuffle the first shuffle of a seed, thereby limiting the possible permutations to the number of possible seeds.
Oh duh, silly me. Thanks :)
I am just curious how you checked whether Python 2.7 has annotations.
Yeah, I suppose I wasn't too clear. Sorry. Because javascript runs on the client side but often interacts with server side resources, getting jQuery to work seems to be a bit of a task. I'm wondering if you (or anyone else on here) has been able to use jQuery functions with Django's templating system... and how to get the client/server communication between jQuery and Django code.
`Counter` has cool functionality builtin, like most_common(n), addition and subtraction, intersection and union, and it throws out keys with value 0 after such operations. Not everything needs to be fast, and Counter is very expressive indeed.
Oh no having to search the web! All the information you need is on the sidebar, also you can find dozens of tutoirals on Google. Stop being lazy.
ah yes, good point (also doubly so since I am thinking in 2.7 not in 3.4)
There is always overhead converting types. If it is worth it, you have to make that tradeoff. Is performance really important? In my experience performance isn't that crucial and for most applications it isn't, so make sure you aren't prematurely optimising. Also consider the source, a float converted to a Decimal isn't going to have any more precision magically. Consider the following example: &gt;&gt;&gt; Decimal(1.0 / 3) Decimal('0.333333333333333314829616256247390992939472198486328125') &gt;&gt;&gt; Decimal(1) / Decimal(3) Decimal('0.3333333333333333333333333333') Since the first conversion is converting a float to a Decimal, the precision is already lost. Starting with Decimals and then doing the division keeps the precision.
Actually I think it's -5 to +256. More importantly, this is an implementation detail of cpython and may not be reliable in other implementations of python.
Yay! Its finally stable! Too bad it targets 3.2 and not 3.4 right now.
That looks much nicer. Much easier to read. Another good habit to get into, I think, is to briefly describe function/method arguments and return values in their respective function/method docstrings. Even if your argument names are really self-descriptive, and it's easy to see how/where the arguments are used, like in your code here, it's just a good habit to get into. I usually do it something like this, personally: def func_name(x, y): """" This is a short overall description of the function/method. :param x: A string to be concatenated with ``y``. :type x: str. :param y: A string, to be concatenated with ``x``. :type y: str. :returns: A concatenated &amp; reversed string. """ z = x + y return z[::-1] I got the idea to do it this way from looking at the [Praw](https://github.com/praw-dev/praw) code &amp; docstrings. As I understand it, this doscstring format can later be parsed by the package [Sphinx](http://sphinx-doc.org/), to auto-generate documentation (in various formats) for your code. I have not tried this yet, but I figure I'll get in the habit, so when I do want to try it, I won't have to rewrite a bunch of docstrings. An example of the code documentation Sphinx can generate using docstrings: [https://praw.readthedocs.org/en/v2.1.16/pages/code_overview.html](https://praw.readthedocs.org/en/v2.1.16/pages/code_overview.html) But again, I am still relatively new to Python, and programming in general, so take my advice with a grain or two of salt.
Major packages (e.g., PIL) I would recommend installing via apt because they involve component pieces largely unrelated to python. Any pure python (or mostly python with just some C Python extensions) project should probably be installed via PIP. This gives you better flexibility over project versions and prevents you from tying project dependencies to the host OS
This looks really nice. Any examples of more complicated patterns?
After I finish it and get it working I will do some optimizing tests but yes performance will be crucial (to an extent of course) and everything I am converting is given to me as Unicode with 8 decimal places. And anything that is float I am just casting as decimal so that I am able to operate on one with the other.
Ah, that makes sense. Thanks for the clarification.
that is a good point. i think it's just that i'm overly annoyed at how unbelievably slow `Counter` is (it's like 3x slower than `defaultdict(int)`, but WHY?!). it's amazing that to add the functionality for most_common/addition it requires slowing down the whole thing by a factor of 3.
&gt;...bound to the same object instance. This is a nice, concise description. Thanks for adding it.
Would you be able to give me an example of what you want to do? I'm still not sure.
I forgot to mention that I would love to hear how you feel green compares to trial, nose, nose2, py.test, tox, etc.
Ooh, I'd like to output this to some WS2811 LEDs. I have a 16x16 panel just itching for some animated designs like this.
No one defining project directory *inside* the virualenv dir?
Looks interesting. Unfortunately, the pip install does not work for me: [venv:python3.4][DendroPy]$ pip3 install green Downloading/unpacking green Downloading green-1.0.tar.gz Running setup.py (path:[...]/venvs/dendropy4-python3.4/build/green/setup.py) egg_info for package green Traceback (most recent call last): File "&lt;string&gt;", line 17, in &lt;module&gt; File "[...]/venvs/dendropy4-python3.4/build/green/setup.py", line 7, in &lt;module&gt; long_description = open('README-pypi.rst').read() FileNotFoundError: [Errno 2] No such file or directory: 'README-pypi.rst' Complete output from command python setup.py egg_info: Traceback (most recent call last): File "&lt;string&gt;", line 17, in &lt;module&gt; File "[...]/venvs/dendropy4-python3.4/build/green/setup.py", line 7, in &lt;module&gt; long_description = open('README-pypi.rst').read() FileNotFoundError: [Errno 2] No such file or directory: 'README-pypi.rst' ---------------------------------------- Cleaning up... Command python setup.py egg_info failed with error code 1 in [...]/venvs/dendropy4-python3.4/build/green Storing debug log for failure in [...] 
&gt; the compile time You know that python doesn't compile right? (Ignoring the pyc files)
I probably should have said "package" instead of "project". In the context you mentioned, the "project" directory IS the parent directory of the python package. That is to say, a project set up to work with PyPi usually has the python code in a subdirectory of the project directory. I'll go work on the wording to make this more clear. Thanks!
Ah, OK. Sorry about the misunderstanding!
Ok, works now. Thanks!
Price can normally be thought of as an integer in most applications. You are normally not allowed to think of money as a continuous value so you can't really use floating point. Quantity can be either an integer or a continuous value. If it is a continuous value then floating point might be the preferred representation assuming that there is enough precision available (which is almost always the case these days). This assumes that you actually have to do some sort of calculation other than the money total. How you are supposed to handle the calculation of a total amount of money for a quantity and price is often a matter of statute. There is always some policy somewhere. It is unlikely that we can provide informed help without the context.
Do it whatever way you want, however just make sure the virtualenv doesn't wind up in source control. A virtualenv should only live on one machine, since some python packages include platform-specific code. If you need the same environment elsewhere, use requirements.txt/setup.py to get it set up. It's kind of like your IDE's project directory in that regard - you don't want to screw up a buddy's IDE config, just like you wouldn't want to screw up their virtualenv. So once again, make sure you tell svn/git/hg to ignore it.
Thanks a ton, it helped me a lot. Great read, looking forward to some new tutorials..
Nice. Color definitely helps with things when it is late and fatigue levels are high! I guess I would find it nice to have the file paths and line numbers in a different color, and I would find it especially useful to be able to selectively/optionally filter out everything but the line causing the problem in the stack trace in the case of an error. As far as features (as you did ask for feedback here I am posting this here; otherwise I guess the project GitHub issues would be a better place?): (1) So, here are some features that are present in unittest (when tests are invoked via '`python -m unittest project.test`" that I would consider *really* nice to have: - "`-c`"/"`--catch`": Control-C during the test run waits for the current test to end and then reports all the results so far. A second control-C raises the normal KeyboardInterrupt exception. - "`-f`"/"`--failfast`": Stop the test run on the first error or failure. (2) A feature from nose that I have always wished was there in unittest is to re-run the last failed tests. Related: I have always wanted a way to list all the failed/error tests in the previous run in way that makes it easy to pass to an editor (perhaps a flag to switch between the dot-as-path form for the test runner and normal slashes + ".py" extension for the editor) (3a) This one is a toughie, I think, and depends a lot on what you are using as a test-discovery engine: command-line completion for test names passed to the test runner, whether module name ("project.test.test_module_a") or test case ("project.test.test_module_a.TestCaseA") or test itself ("project.test.test_module_a.TestCaseA.test_run1"). (3b) This is me just being oh-so-greedy, but still: as (3a) above, but a curses window with fuzzy-matching to select tests. :) 
TL;DR: Because calling `type()` correctly is apparently too hard: &gt;It is a key feature for named tuples that they are exactly equivalent to a hand-written class. So is a call to `type()` if you know what you're doing. EDIT: If you examine the official code more closely, you'll note they had to write extensive string-escaping to prevent the user from passing an argument like `'); import os; os.system("/bin/sh"); ('`. Quite frankly, I will not be touching that with a ten-foot-pole any time soon. EDIT2: [I tried](http://bugs.python.org/issue21832), but they wouldn't listen to me. Oh well.
Oooh, awesome feedback! Let me respond in order: (0) I know! I actually _tried_ filtering out all but the last frame of the traceback, but I stopped because of two issues: 1) Traceback implementation is very messy, and a frame is not always...a frame. (sometimes a frame is a "filename:line" + "actual line", and sometimes it's much more than that). 2) The actual crash may occur in any frame! The most common case is for it to be in the last frame, but while I was testing I had all sorts of weird things happen. In the end, even when it _did_ work correctly, I found myself needing the remaining frames in the traceback for context and tracking down the actual problem, so I declared it a useless feature and removed it. (1) --catch and --failfast are features I've never considered, but seem worthwhile. I'll try to remember to add them to the Issue Tracker if you don't beat me to it. (2) Interesting feature. It would require writing a file on the _first_ run, whether or not it would end up being used on a subsequent run. Not sure what I think about that. Perhaps it would be best as an enabled option - save the state to enable smarter behavior on subsequent runs. Definitely worth adding to the issue tracker as a feature request. (3a) Bash-completion support (or zsh, in my case). That's a fabulous idea. I have no idea how to write completion plugins (modules? scripts?) for bash/zsh/your-favorite-shell, but I love the idea. That would be a fantastic feature that I would use personally. (Now why didn't I think of that?) ;-) (3b) You are indeed a very greedy person! :-) I have been down the ncurses road before, and I will not be going there again soon. Without some interactive interface, fuzzy matching doesn't make much sense. However, there may be a place for glob- or regex-style target filtering. We turn the suite of tests into an ordered list of dotted strings during test discovery already (well, essentially), so it wouldn't be hard to add a filter. Not sure if anyone would use a feature like that, though... Thanks for the good feedback! I encourage you to add each of those as separate issues on the GitHub project. If you don't, I'll do my best to go add them in a few hours if time permits. 
Ya I'm not dealing with dollars or euros or anything though. The currency is all in cryptocurrency so there is 8 decimal places always and each one matters usually. As well as quantity cause each coin can be split into 8 decimal places so again it does matter.
Ya sorry not the right terminology, run time? Does it affect the time it takes yo get from start to finish hahah.
It'll add a little overhead, but I doubt much.
Command-line completion is very simple once you have the ability to generate the full candidate list: the actually filtering out of unsuitable candidates is done by the shell. So, the key is to be able to generate the list of tests. I think glob-/regex- test selection is a *great* idea! You should add that to the issue list! If rerunning failed tests and command-line completion were available coupled with the ability to take a reg-ex or glob pattern, that would take care of a *lot* of the current pain of running tests! 
That's beautiful. I would like to use some parts of your visualization implementation for the [PolyGrid](http://www.reddit.com/r/Python/comments/27vh0x/a_maze_for_your_day_polymaze_converts_images_and/) system I made. It's basically the same thing - tileable polygon tessellations except PolyGrid makes the tiling fit within a desired shape. I checked the license and it seems fine - is that ok with you? Another question - are the tiles kept in some kind of data structure? A quick glance at the code looks like it's drawing the pattern but not storing the shapes. Is that correct? I really like it. Any plans to extend it or apply it to something?
&gt; annotations are present in Py2.7 Ehm I don't think so: Python 2.7.3 (default, Feb 27 2014, 19:58:35) [GCC 4.6.3] on linux2 Type "help", "copyright", "credits" or "license" for more information. (tab completion loaded) &gt;&gt;&gt; def test(a:None): pass File "&lt;stdin&gt;", line 1 def test(a:None): pass ^ SyntaxError: invalid syntax 
Oh, so *exactly* 8 decimal places. Nothing can exist past the 8th place. So entirely integer... If you can keep things entirely integer then the problems go away... Another thing, the method of throwing away all the extra precision after the multiplication is probably defined (rounding).
Oh, I totally missed... (2b) Yes, listing filename paths for easy manipulation by editors/scripts/etc. would be awesome.
Well that's good news! If you know of any tutorials/instructions that wouldn't be at the top of a Google search already, let me know. Implementing bash/zsh completion is at the top of my that-sounds-fun-to-do list.
I never understood how the number specification of tessellations worked but just reading through the readme made it completely clear. Thanks for that as well!
It sounds like not. Floats are for continuous values. This is definitely not a continuous value.
Lol, I don't know how I did this, but somehow I botched checking Py2.7. I must have tab-completed iPython3 instead of iPython.
You are quite right, I managed to F-up testing it somehow and accidentally used python3. Don't mind me, I'll be chewing my keyboard somewhere.
Author here (someone else posted the link). The shapes are stored in a shapes list. https://github.com/fogleman/Tiling/blob/master/tile.py#L133 Only the "template" shapes are stored there. The shapes created with a call to repeat() can be found in the "lookup" dictionary, along with the original template shapes. Feel free to use the code for your project.
&gt; Hope that's a bit clearer :) Nope! :) Why is django any different from any server side framework in this regard? You send requests, it returns responses - whether they be html, json or anything. Have you figured it out in any other language or framework? It should be pretty much the same in Django. 
I think I see. Basically you build up a potentially multi-polygon tile with shapes and then tell it to repeat?... What happens if you use repeat on something that is not tileable?
This is one of the few things I don't like about python is that slices make copies implicitly which goes against many python ideals. Lists are mutable, so you would expect operations on lists to only be references. 
Things will just overlap. There's no enforcement of rules.
There is no implicit cast, it is simply implemented as a nonzero operator which is defined for all built in types. 0 is defined for any domain such that x = x + 0. Lists have a zero that is the empty list because x + [] = x therefore [] is zero in the list domain. Same with empty string. If statements doesn't ask for true or false, it asks for if zero or nonzero. Remember that booleans types didn't exist in python until around version 3. In version 2, True and False are simple macros for 1 and 0.
I would like to hear about how *you* think it compares to nose and the like.
What I have is for Python 2 since I recall print statements instead of print functions. Not sure if it has been updated for Python 3.
Well, there seems to be precedent for what you're suggesting in NumPy...
Potato, potahto. I don't like the use of implied truthiness where a boolean operator would be more explicit. 
I haven't implemented SVG output but it should be doable. However, I ported most of the code to JavaScript / D3 / SVG. Basic demo here: http://www.michaelfogleman.com/static/polygons/ 
Thanks! Alot of people tend to forget the beautiful simplicity of python, just objects and names. 
FWIW [pytest](http://pytest.org/latest/) colors its output as well as supports all the features you mention in the readme file.
That's an excellent point. Good blog post too. Looong, but good. :-) I have never heard of drone.io -- I'll have to check it out.
I will be the first to admit that I don't know pytest very well, but in the vanilla installation I can't find "Vertically-aligned statuses**", "Four verbosity levels", "Built-in, optional integration with coverage", or "Optional HTML output". But then, pytest supports plugins and Green does not. Green aims to be a one-stop shop, not a plugin-platform. That can be a plus if it happens to meet all your requirements, or a minus otherwise. I bet you're right on target if you include the appropriate plugins. In fact, I bet it supports a whole lot of other things as well. ** Uh oh! The correct description should be "horizontally-aligned", or in other words, lined up in a column vertically. I'll go fix that description. I'm glad you made this comment, because it brought that to my notice!!
Not sure, seems to be working as normal for me. Are you able to access astrill.com? The script is checking for https://www.astrill.com/what-is-my-ip-address.php maybe you hit a rate limit on that or something?
Thanks for submitting the issues to the GitHub project!
I never enoutered anything of the sort. I have Python running process that have been only for month without being restarted, and I restarted them only because I needed to update the code.
I submitted issues for [testing the installation procedure itself](https://github.com/CleanCut/green/issues/9), [testing the code after it is installed](https://github.com/CleanCut/green/issues/10), and [considering using drone.io](https://github.com/CleanCut/green/issues/11). Edit: Made nice links in the text, instead of just putting bare links at the end. 
I keep mind in the project's directory tree, usually in a directory named ".venv". I'm actually not sure why it's recommended to keep them in a central location—I think they're a lot easier to keep track of when you keep them with the project.
It's possible. I actually modified the script after my post to only check the header and if it works on craigslist. Everything seems to be working fine now. I'll check tomorrow once I give the normal checks a break.
very cute, thanks for sharing
**trial** Honestly, I really like Twisted's trial, though I don't really have any need for the rest of the Twisted library. If most of my projects at my day job hadn't moved to Python 3, I probably would have just stuck with trial, but it [doesn't run on Python 3 still](http://twistedmatrix.com/trac/ticket/5965). Trial was and is the foundation for my inspiration for having better-than-unittest output in the first place. It's a great example of reducing redundancy (report module/class once, not on every line), lining up status vertically, and using color. I feel like Green trumps trial in two important ways: 1) It's not part of an immense event-driven networking engine (probably not ever going to change), and 2) it is not stuck in Python 2 (which will hopefully be fixed someday). Green will never replace trial, as trial has features necessary to run asynchronous unit tests on Twisted code. **nose** I was hopeful for nose. I tried all the plugins I could find that mentioned improving upon the output (nose's default output mimics unittest's default output exactly). When I couldn't find one I liked, I started developing Green (yes, this Green) *as a plugin for nose*. When I hit a serious problem in the plugin API, I discovered that [nose is in maintenance mode](https://github.com/nose-devs/nose/issues/45#issuecomment-40827502) -- abandoned by the original developers, handed off to someone who won't fix anything if it changes the existing behavior. I consider nose dead and gone. A project which will not change (even to fix bugs!) will die. The maintainer keeps pointing everyone to nose2. **nose2** So I pivoted to nose2! I can understand the allure of a fresh rewrite as much as the other guy. I had started reading nose code while writing the plugin for it. I dived deep into nose2. And ran into a mess. Nose2 is alpha. I submitted a 3-line pull request to [fix some problems](https://github.com/nose-devs/nose2/pull/171) where the behavior did not conform to the already-written documentation which broke my plugin. The pull request wasn't accepted because I (ironically) didn't write unit tests for it. By this time I had read so much of nose2 and kept thinking, "I can write a better test runner than *this*". And I believe I did, with regards to the features that I implemented. **unittest** So then I went and started reading unittest (Python 2.7 and 3.4) source code. unittest is its own special kind of mess, but it's universally built-in, and most importantly, subclassing or replacing it looked a lot *easier* than writing a plugin for nose and nose2. So I started over on Green *again*, starting down the road to what we have now. I had three initial goals for Green: 1) Colorful, clean output (at least as good as trial's) 2) Run on Python 3 3) Try to avoid making it a huge bundle of tightly-coupled, hard-to-read code. I contend that I nailed #1 and #2, and ended up implementing a bunch of other useful features as well. Whether I succeeded with #3 is debatable. I continue to try to refactor and simplify whenever I touch the code. I'm not sure that I'm convinced that [community acceptance of my project](https://github.com/kennethreitz/python-guide/pull/459#issuecomment-46914167) really hinges on adherence to PEP-8 and PEP-257, but I suppose I have work to do there as well. :-) Wait! What about the other test runners? - **pytest** -- Somehow I never realized pytest existed until a few weeks ago. I've barely looked at it at all. Hey, don't give me that look! I'm not omniscient! - **tox** -- I think I first ran across tox only a few weeks before pytest. It's homepage didn't mention anything about color, so I didn't (and still haven't) tried using it. If this (and the Green readme) don't inform you about my thoughts about Green vs. the rest, it's not for a lack of trying on my part! Your turn! :-) Edit: Added more formatting to the text to (hopefully) make it more readable.
Thanks for the tip! I have heard of tox from several sources now, but have not actually tried using it. I made a note on [this issue](https://github.com/CleanCut/green/issues/10) to look at integrating it into the workflow.
Great. This seems like a really sweet project, I've been through a bit of hell trying to get my tests automatically running with coloured output. I'll star the repo and might throw some contributions your way in future.
Pytest actually does a lot that green does also, for example the dev focusses on having useful output when test fail. It also colors output :) Green looks nice too! It's good to habe several options for competition and innovation!
Had server processes running for months with no apparent memory leaks as well. 
That was very informative. I was vaguely aware of nose's cruftyness, but I'm most familiar with plain unittest and pytest. I particularly like your focus on readable output. Have you considered putting the story of your struggles with nose et. al. into _README.md_? When I find a new project I'm basically ALWAYS searching for the answer to "Why does this exist?". &gt; Your turn! :-) **Complaint 1** My biggest complaint would be that it doesn't seem to support pytests's [asserting with the assert statement](http://pytest.org/latest/assert.html#assert-with-the-assert-statement). Having to use unittest and its non PEP8 compliant, needlessly class oriented style is pretty frustrating for me. py.test supports unittest AND simple functions that just _assert_ things. I love that. **Complaint 2** I don't think the colorized output is an improvement on py.test's. I ran py.test and Green on Green's own test suite and examples: * [green on green's examples (note the unittest tracebacks)](http://imgur.com/OEiCu12) * [py.test on green's examples (note the source code highlighting, omission of traceback info)](http://imgur.com/aL3vc7N) * [green on green's tests](http://imgur.com/OEiCu12,d95ecQu,aL3vc7N,NqJxfUf#1) * [py.test on green's tests (note the base level of verbosity)](http://imgur.com/NqJxfUf) The most important difference for me is that py.test gets rid of the unhelpful traceback from the unittest framework. It doesn't help me to see the traceback of an exception that unittest raised. The other thing is that I find py.test's default level of verbosity more useful. I like to know which _test module_ passed for each run. **Compliment 1** It seems fast. It's hard to profile against py.test, but its simplicity probably makes it faster. **Compliment 2** [I much prefer its _-v_ verbosity level to py.test's](http://imgur.com/YQLkSHm) 
This is amazing! It would be nice to hook this up to a tweening library to make some animations.
`__slots__` are used to conserve *memory* when creating lots of objects, not CPU time. (Instead of every object having a `__dict__`, all attributes are stored in a small array and accessed using properties set on the *class*.) `namedtuple` is slower than even a class without `__slots__`, by the way. It operates by mapping attribute names to indices (there's a reason it's called a "named *tuple*", not "struct" or something similar), doing twice the number of lookups for every dot.
That is brilliant. How about bees? If you could make a hexagon tiling with different sized hexagons that could be a real boon for bees. At the moment the hexagonal bases put in beehives have hexagons all the same size. Natural [honeycomb](http://en.wikipedia.org/wiki/Honeycomb) has different sized cells in it. And different sized bees come out. Some believe different sized bees allows a hive to more efficiently forage as bees can then forage in the flower size that best fits their size. Bees are in trouble and a lack of variation in the diet is thought to be one issue. The plate with the hexagons on it is called [the foundation](http://www.thorne.co.uk/frames-and-foundations/foundation/premier-langstroth-foundation/prem-wired-langstroth-worker) Does this make any sense? And would a rectangle with size [Foundation sizes Deep – 16 ¾” 8 5/8” Jumbo – 16 ¾” x 10 ¾” Shallow – 16 ¾” x 4 7/8”](http://www.beekeepingforum.co.uk/showthread.php?t=856) but with more "natural' variation in hexagon size be possible?
As long as you dont use pip with sudo it is perfectly fine to combine the two. As with all things, use virtualenvs.
ARGH SUDO PIP INSTALL KILLS KITTENS
That's an excellent idea and one I'm a bit miffed at myself for not thinking of immediately.
Add a textarea so people can experiment with the code, and it will be awesome!
I don't have a lot of experience with the built in Python unittest module. What of it's coding style is PEP8 non-compliant? Thanks for any answers :)
the comments here are more helpful than the actual gist :)
&gt; you can't explain how to use virtualenv in one command, and if you tell him to go &gt; learn it first, chances are the guy is going to give up life is hard. lets defer a small amount of time spent understanding now, so it becomes a massive PITA and time waster later when you break your system[1] &gt; Now, if you want to be constructive http://notes.pault.ag/debian-python/ [1] because sudo pip install kills kittens. 
Thanks, I appreciate the positive feedback!
&gt; lets defer a small amount of time spent understanding now, so it becomes a massive PITA and time waster later when you break your system[1] Yeah, sure, let's also change the all humanity so it will do that. The humanity buying iphones and going on facebook will surely take all the time in the world to take good habits. &gt; http://notes.pault.ag/debian-python/ It doesn't anwser any important questions, like how do you install pip, how do you install virtualenv, how do you use apt, wait, ain't you using yum, wait you 're on mac os, wait you 're on windows... Sudo sucks, but it solves all these problems, except on windows, when the guys can just come back with a command not found error and you can tell him to drop it. You can spend your entire afternoon giving the right answer. That's why I didn't do it, and that's why you don't do it, you just say "you should not do that, do this instead and good luck, and good bye". 
[Here is one](http://imgur.com/mpirjm3) made with moviepy ;) EDIT: code. from tile import Model, Shape import numpy as np from moviepy.editor import VideoClip, vfx W,H = 320, 240 def model_to_npim(model): """ Transforms a Cairo image into a numpy array. """ surface = model.render() im = np.frombuffer(surface.get_data(), np.uint8) im.shape = (H,W, 4) return im[:,:,:3] def make_frame(t): model = Model(width=W, height=H, scale=int(100-int(16*t))) model.append(Shape(6, fill=int(255*t))) a = model.add(0, range(6), 4, fill=int(255*t+160)) b = model.add(a, 1, 3, fill=int(255*t+80)) c = model.add(a, 2, 6, fill=(int(255*t))) model.repeat(c) return model_to_npim(model) clip = (VideoClip(get_frame= make_frame) .set_duration(5) .fx(vfx.time_symetrize)) clip.to_gif('tiles.gif', fps=20, opt='optimizeplus')
If you are on windows/osx use a python distribution (conda) If you are on linux and using python2.x then install python-virtualenv If you are on linux and using python3 then use the python3.4 and the built in venv functionality which now ships pip support. I maintain large stacks of scientific software for people on linux and windows. If you keep telling my users to break their systems then you are contributing to the shit perception of the python packaging universe and you are doing more harm than good. And BTW, philosphically, I don't give a shit about iphone people. I care that people use python to do useful things, and being an idiot (or being an idiot that tells people to do idiotic things) does not help create knowledge.
I know that if I don’t reboot my server running Python 3 the webapp crashes after about a month. Don’t know why.
It's all personal preference. It sounds like you have found the approach that works well for you so keep at it. Virtualenvwrapper and it's centralized storage makes it quick to switch between virtualenvs quickly. I find that convenient because I have a lot of long-lived branches and I have a virtualenv per (project, branch) pair. I do put the virtualenvs in the project directories for smaller projects though.
I have come to the conclusion that you are serious. But still not really sure. *edit - assuming you are serious, can you show me some example images or diagrams of mixed-size hex patterns?
that seems to be the only case where having them centralized seems like a good approach to me. altough, even then, I might just have a separate directory for each of the long-lived branches (rather than continually switching between them)
OMFG That's beautiful!
Yes I am serious [Here are some images of natural honeycombs]( https://www.google.co.uk/search?q=honeycomb&amp;client=firefox-a&amp;hs=BXm&amp;rls=org.mozilla:en-US:official&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ei=GXOpU7m6HtCu7Ab3yIHoAQ&amp;ved=0CAgQ_AUoAQ&amp;biw=1760&amp;bih=843#q=natural%20honeycomb&amp;revid=1652895643&amp;rls=org.mozilla%3Aen-US%3Aofficial&amp;tbm=isch&amp;imgdii=_) Natural comb varies from ['Natural worker comb 4.6 mm to 5.1 mm'](http://www.bushfarms.com/beesnaturalcell.htm). Also as well as variability of diets it is claimed that small cells are more resitant to Varroa mites. and the standard cell size in beekeeping is larger than natural.
Next time for graphing, look into using matplotlib, or pandas. Pandas hass completely taken over for excell/ libreoffice for me. (This is all just in case you didn't know : ) )
&gt;Note that reversed() doesn't return a list, it returns an iterator. Your code snippets aren't equivalent. Depends on what we are going to do next. If we use it in `for` loop both object are equivalent as for me. But when we want to append, insert and so on reversed looks not so good as was described. Raymond Hettinger did not even mention about slicing as alternative for reversed. As long as I am new in python I have a lot of information to think of :)
Built [this](https://github.com/oddbitdev/hexTap) as a learning exercise.
Since I'll be working on a source code from another language C#, generating source would be fairly easy but reading and parsing existing source code to identify tokens (i.e., methods, variables, classes, etc.) would be a challenge.
Thank you
&gt; If you are on windows/osx use a python distribution (conda) The you can't use 99% of tutorials on the Web. &gt; If you are on linux and using python2.x then install python-virtualenv Still don't explain how to use it. And it's wrong since it's only works in some debian like flavour. &gt; I maintain large stacks of scientific software for people on linux and windows. If you keep telling my users to break their systems then you are contributing to the shit perception of the python packaging universe and you are doing more harm than good. Nope. Breaks happen, but rarely. Leaving because you didn't help them properly happen every day. We are not dealing with a situation of serious dev here, just a noob wanting to makes things work here and now. 2 differents needs. If you want to complete and sure deal, it's in the doc (if your doc is well written). But as you can see, apparently, the doc failed yet another noob. And Python packages have a bad reputation because they suck. Universal packaging is hard, distribution is even harder, they are a lot of combinations of what you can do, and isolation requires to setup virtualenv. I do love Python, but this sucks ass. It's better than it use to be, but still suck. &gt; And BTW, philosphically, I don't give a shit about iphone people. I care that people use python to do useful things, and being an idiot (or being an idiot that tells people to do idiotic things) does not help create knowledge. This. This is the problem here. You consider only one type of person should be a programmer. Welcome Neo, welcome in the real world. Where half of dev have iPhones, and 80% are on facebook. Now, I don't own an iPhone or a facebook account, but I do want to help PEOPLE to learn Python, not just guys like you. BTW, didn't you leave mac user out of your explanation ? Because, HEY, OP is a mac user. 
What are you actually trying to do? Provide more details and we can help you find a pythonic way. Lists can store any data types and what you desire is very specific. 
I see two problems with your setup. First I think that having the python program running and the Arduino serial listener opener is your main problem. I can't be sure, but I'm guessing that they are both reading from the same device file so when one of them reads a byte the other won't see that byte. That would cause the mangled text you see and the exception that was thrown. For example, the serial device says it's ready, both serial readers see that and start reading, but the arduino window reads first, then when the python reader tries to read it doesn't see anything and gets confused. So try closing the Arduino window (or the whole programmer window maybe, its been a while since I've used mine). And lastly you changed the "MOVEMENT" text so if you were expecting emails you need to change your if statement to check for "E" instead of "M" in the python code.
It won't send an email because you have: if message[0] == 'M' : But you're message string starts with 'E', so it will never send an email. Also, you should avoid using `time.sleep()`. From a brief inspection of the documentation, it looks like `serial.readline()` will block, so there's no need to add in your own delay. Consider reading the docs for pySerial yourself: http://pyserial.sourceforge.net/pyserial_api.html?highlight=readline#serial.Serial As for the lines being overridden, I have no idea. If you want to extend this, you can use a median filter to smooth out the incoming signal, that is, have a `deque` of some size (probably 3), and push your sensor values into it and calculate the median, if the median is above some threshold (ie, high is 1, low is 0 when you insert). Or you could just rearrange the whole program and have the arduino device constantly send the value of the sensor, and then have the pc decide whether or not send the email using the filtering method I described. I'm not very familiar with working on arduino devices btw.
I counted the imports in a 120000-line django project and these are the most common: * datetime * decimal * json (mostly aliased ujson) * os * time * collections * re * hashlib * logging * random * sys * itertools * urllib2 * urlparse * string * urllib * optparse * base64 * calendar * socket * functools * operator * traceback * csv * cStringIO * struct * unittest
Interesting. So in the pictures, they looked very regular. Do you mean that sometimes the hex pattern gets compressed / stretched in one area? I didn't see any with distinct different-sized sections. Also, can you expand on what you are aiming for? Something like making a template pattern that can be manufactured into cells?
tried using list.index()? x.index([3,4])
I didn't make any of these, but I did help to judge them. [Entries from the 2nd Kivy Contest](http://kivy.org/#contest), including a screen shot and link to the GitHub repo of each.
I'd say: * unittest * os * datetime * re * collections * itertools
 ValueError: [3, 4] is not in list That is looking to find [3,4] in a list of lists as in [ 1, [3,4], [4] ]
So I should really work with strings if I anticipate doing this a lot.
Thank you
Hmm, for me: re os math sys itertools subprocess socket collections random ctypes 
&gt; always use this to read/write CSV files, don't try and roll your own methods, it'll end in tears I wish.
or a string with glue. s = "_".join([str(i) for i in x]) s.find("12314_12341234") 
What were the problems? We have a very active IRC channel (#kivy on Freenode) and a [Kivy Google Group](https://groups.google.com/forum/#!forum/kivy-users) you are welcome to ask questions on.
These questions always depend on what kind of things you're doing. What might be one person's bread and butter, everyday library might be a once-in-a-blue-moon thing for someone else. Every time this is asked you get a set of answers that only somewhat overlap. 
I would really add numpy in there.
This thread has been linked to from elsewhere on reddit. - [/r/kivy] [What is the sexiest thing you&amp;#x27;ve created using Kivy? (X-post from /r/Python)](http://np.reddit.com/r/kivy/comments/28yv31/what_is_the_sexiest_thing_youve_created_using/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
I depends on what's your area of expertise/interest. I do mainly data analysis on Python, so while I have used tempfile, for example, in the past I wouldn't include in the the "top 10 built-in Python modules that a new Python programmer must known".
NumPy is one of those incredible libraries that not everyone needs. If you're manipulating vectors of data in a math-y sort of way, NumPy is the de facto standard, but a lot of programmers will never need to even look at it.
requests (3rd)
I would like to use both, that is, to be able to use pip to install system packages where possible and install from source only when explicitly told to do so (or for the dependencies that cannot be fulfilled using system packages)…
misread the question. oops!
 def list_find(needle,haystack): for i in range(len(haystack)): if haystack[i:i+len(needle)]==needle: return i return None Is this what you'd call un-pythonic? I don't agree that that's really an issue. If there was a python library function to do this, I'm fairly sure it would look a lot like this.
&gt; In no particular order: A blatant lie, they are in alphabetical order!
Following the poll I submitted some days [ago](http://www.reddit.com/r/Python/comments/28r85w/what_modules_of_the_python_stdlib_do_you_use_more/) the [results](https://docs.google.com/forms/d/1IF_MTfhXR-XJUtT5bGje_0aj9bqwDpEV80tVySD4UCc/viewanalytics) are as follows: * os * re * sys * json * itertools * datetime * collections * argparse * random * unittest * logging * urllib * csv * math * time * multiprocessing * pickle * sqlite3 * functools * hashlib * subprocess * shutil * \_\_future\_\_ * gzip * threading (sorted from most voted to less voted and only the 25 most voted packages)
Add in pandas if you are using numpy.
I also would like to say NumPy - one of my favorite packages, however it isn't "in-built"
&gt; BTW, didn't you leave mac user out of your explanation ? Because, &gt; HEY, OP is a mac user. nope. try again. read the first sentence. &gt; You consider only one type of person should be a programmer nope, I just dont consider people to be as stupid as you do. Furthermore, based on your replies I don't believe you have any experience nor knowledge of what you are talking about. 
I don't know if you're into games. I code small games in Python with Pygame and alway use the following modules: * math * random * sys * os * configparser
Depends, I've used pandas to great end when manipulating very large amounts of complex data that came from Excel, CSV, and JSON files, but for my day-to-day purposes it's overpowered. Granted, I know I'm working in a relatively narrow band of computational computing, but I am an example of where NumPy is more than sufficient. Pandas is a great library, though, I high recommend using it if you're dealing with lots and lots of data coming from many sources that you need to perform complex operations on, it really simplifies the process.
* Learn `logging`. Sort of weird, but it's extensible enough to cover all kinds of use cases you might have. * The `operator` module is interesting if you're big into functional programming, but its more useful bits are `operator.itemgetter` and `operator.attrgetter`, both of which will make sorting lists of complex objects much more tolerable. Example: If you have a list of dictionaries all with keys `count` and `id`, you could sort by count with just `sorted(your_list, key=itemgetter('count'))`. * I'll be one of the people /u/hairlesscaveman mentioned and put in a good word for `itertools`, although I'd suggest it more for things such as `product`, `permutations` and `combinations`. * `os.path` is extremely handy if you're writing cross-platform code that handles files. * `re` will cause you great joy, and it also will cause you great pain. Use it wisely. * `csv` and `json` both come in handy for data interchange, although if you're on Python 2, use the third-party `unicodecsv` as a drop-in replacement to save yourself a bunch of headache. * `argparse` is useful for handling command-line options, although it takes some getting used to. * `datetime` comes up all the time in different kinds of programs, even if you just want to know what time it is right now. Learn that one and learn it well. (The third-party `pytz` will keep you from having to write your timezone definitions from scratch if you need those, and the third-party `python-dateutil` has a nice parser for freeform dates and times in text.)
I feel like numpy (and maybe scipy) deserves a mention as a 3rd-party module. Also, I haven't looked much into it, but pandas is another good library for machine learning purposes, I believe.
A just took a look at the Python Module Index - it's a hard choice :) I grabbed all in-built modules and put it into a surveymonkey poll if you want to vote here: https://www.surveymonkey.com/s/GWCCFXK, and the can be viewed here: https://www.surveymonkey.com/results/SM-WPZNMZY8/ My favorite onces would be - collections - argparse - urllib (in Python 3) - csv - pickle - sqlite3 - subprocess - os - shutil - random
tell me more about buildout, most of the videos on their site are down.
Adding on to this - if you want to reverse in place without using it for iteration, .reverse() is (much) faster than slice. Slice is best if you want a reversed copy. import timeit # Slice, copying to new variable print timeit.timeit('b=a[::-1]', 'import random;a = [random.random() for _ in xrange(100000)]', number=1000) # Reversed, returning an iterator print timeit.timeit('b=reversed(a)', 'import random;a = [random.random() for _ in xrange(100000)]', number=1000) # Reversed, converting back to a list print timeit.timeit('b=list(reversed(a))', 'import random;a = [random.random() for _ in xrange(100000)]', number=1000) # .reverse(), mutating existing list print timeit.timeit('a.reverse()', 'import random;a = [random.random() for _ in xrange(100000)]', number=1000) # .reverse(), after list() copy print timeit.timeit('b=list(a);b.reverse()', 'import random;a = [random.random() for _ in xrange(100000)]', number=1000) # .reverse(), after slice copy print timeit.timeit('b=a[:];b.reverse()', 'import random;a = [random.random() for _ in xrange(100000)]', number=1000) 1.62388288434 # Slice, copying to new variable 0.000236643136073 # Reversed, returning an iterator 3.11313892127 # Reversed, converting back to a list 0.0761127799045 # .reverse(), mutating existing list 1.98119213842 # .reverse(), after list() copy 2.03216239554 # .reverse(), after slice copy 
Why do you recommend buildout so much? Never heard that one before. I love virtualenv!
And what modules did you import to do this?
&gt;There are three columns of interest to me - name, phone number, and address. Without having real example of file it will be difficult to find this colums.
I use the empy module. Here is some example code for sending out grades to a class. The grades are in a cvs file. This is on linux, where you can send mail from the command line with the "mail" command. import csv import os import em infile=open("PFgrades4354.csv", "r") reader = csv.reader(infile) cols=reader.next() for fields in reader: data = dict(zip(cols,fields)) outfile=open("temp.txt", "w") it=em.Interpreter(output=outfile, globals={'data':data}) tplfile=open('math4354.em','r') it.file(tplfile) it.shutdown() tplfile.close() outfile.close() cmd = "mail -s 'Math 4354 Grades Before the Final' %s &lt; temp.txt" %data['Email'] os.system(cmd) print data['Email'] infile.close() print "\nAll Done\n\n" Here is the file "math4353.em", which is the empy template file. Math 4354 Section 001, Grades Before the Final Name: @data['Last Name'], @data['First Name'] Student ID: @data['RID'] This is a computer generated email with your grades for Math 4354 as of the time of the email. I took a snapshot of the Webwork grades, the last assignment is still open. Since the Exam 2 corrections are not available, I used the score on Exam 2. If there are problems, come by to see me or, if necessary, email me. Exam 1: @data['Exam 1'] Exam 2: @data['Exam 2'] Exam Average: @data['pfeavg'] Exam 1 Corrections: @data['ec1rpercent'] Exam Corrections Average: @data['ecavg'] Before calculating the exam corrections average, I take the max or the score on the exam corrections, and the score on the original exam. Homework 1: @data['HW01'] Homework 2: @data['HW02'] Webwork: @data['Pfwebwork'] Homework Average: @data['PfHomeWork'] T otal Score: @data['pfavg'] 
grep | wc ?
I do scientific computing, so usually I'm deploying my programs using something like Python(x,y), WinPython, Canopy, etc. which includes a lot of scientific modules alongside the default libs. I just sort of assume they're there and treat them like built-ins. os sys time logging argparse configparser External: numpy scipy matplotlib h5py
&gt; csv -- always use this to read/write CSV files, don't try and roll your own methods, it'll end in tears I never understood this. Maybe my own very simple methods for csv reading and writing have always worked because my data has never had commas in it?
Back in the 90's, the Stepanaov designed a container/algorithms library for C++ that could do things like this -- the subsequence search function was not container specific, so it could match subsequences of strings, of lists, of file streams, etc. My point is, what you're doing isn't a special case -- a library can be designed to solve this and many other data structure problems effectively Python lacked similar foresight, (can't say whether it was accidental or intentional), so you'll probably have to do it by hand. Check out the iterators library first though. It might have some tools to help. 
The builtins I've used most often are: * sys * os * argparse * subprocess * xml.etree.ElementTree * tempfile * csv * re The non-builtins I use most often are: * numpy * scipy * matplotlib * scikit-learn From the other posts on this page, there are quite a few that seem interesting and that I intend to look at when I get time, such as collections and itertools
learn logging. Every project I've worked on, people end up trying to do their own logging. They start off with "oh logging is too complicated, print is fine for what I need" but then they eventually realize that they need all the features in logging but they've already gone down the wrong path and they fucking double down. Unless you're writing a short one-off script, you're going to need logging. And even if it seems complicated at first, you'll need most of those features later.
It's one of these cases where people who are a lot smarter than you have spent a lot more time than you making `csv` work quickly, efficiently and easily. Besides, why would you spend a couple of hours rolling you own csv reader when you can spend a couple of seconds using the in-built one?
&gt; os.path is extremely handy if you're writing cross-platform code that handles files. Even better (in my opinion) is `pathlib`.
Thank you very much for this, I appreciate your help. So if I'm correct, your script creates a text file, fills it with information, uses that text file to fill in an email, sends the email, destroys the text file, and repeats the process? How would you go about writing the open text file to a .txt as opposed to shipping an email?
 grep -rhE '^(from|import)' --include='*.py' . | cut -d' ' -f2 | grep -oE '^\w+' | sort | uniq -c | sort or maybe find . -name '*.py' -exec cat {} \; | perl -n -e'/^\w+ (\w+)/ &amp;&amp; print "$1\n"' | sort | uniq -c | sort but really, I just used grep, split the results and fed them to collections.Counter, then went through manually.
Haven't tried that one! I'll have to give it a shot. (Still would recommend `os.path` for a newb to understand since it's so common, though.)
The person that wrote that almost certainly just looked at the source. [Here's the `YoutubeDL` class](https://github.com/rg3/youtube-dl/blob/master/youtube_dl/YoutubeDL.py#L66) for instance, and you can see that there are docstrings for the class and each method, so it's reasonably easy to follow. That executable that you found is a packed executable, probably built with cx_Freeze or py2exe or similar. It's just a bundle of a Python interpreter and a zip file containing the compiled bytecode of all the source files. Ignore that and go to the [github repository](https://github.com/rg3/youtube-dl/) to see the actual source in the form that it's actually written. You'll need to install this module as source if you want to use it as a module, I would imagine. 
requests is for downloading things. Mechanize is for simulating a browser. They do two different things.
Have you tried using timeit? import timeit timeit.timeit("sorted(dict_list, key=lambda x: x['key'])", number=10000) timeit.timeit("sorted(dict_list, key=itemgetter('key'))", number=10000) It will iterate the sort 10000 times for each and print out the runtime
Typo in readme: "I you plan to run this on desktop (...)"
Thanks!
Looking forward to it!
It's not built-in and it's not built in Python.
If you control your own file format, it's *ALWAYS* easy to parse, because you know exactly what you wrote. When you get handed "CSV" files from Excel that actually use hard tabs to delimit the fields… pain ensues.
Thanks! I ended up looking through the source, and eventually found a seperate API for the module looking through some similar comments on Github... [Link for the curious](http://np1.github.io/pafy/)
Assuming list called a and you're searching for a sublist b [x for x in range(len(a)) if a[x:x+len(b)] == b] Gives a list of indexes of every sublist occurrence. If you only want to find the first, this will be slow since it'll find all of them. Edit for clarity: a=[1,2,3,1,2,3] b=[1,2,3] [x for x in range(len(a)) if a[x:x+len(b)] == b] Gives [0, 3]
Actually, the identity in Cpython is just the memory address of the object (literally casting the pointer to an int). It doesn't have to be according to the language though.
But you can download things with Mechanize as well.
https://docs.python.org/3.3/reference/datamodel.html Interesting, I didn't realize that it was just a direct address. Thanks for the correction. 
&gt; json (mostly aliased ujson) I feel there's a learning opportunity for me here --- why did you alias it?
It was `json` originally, then it was replaced with `ujson` for optimisation reasons. Instead of rewriting the entire module, I just replaced `import json` with `import ujson as json`.
There was some guy asking about this on Freenode's `#python` just the other day. He couldn't convert the list items to strings and use str.find() so he just did an element by element compare. It's only a few lines of code that you only have to write once in your life. It would take longer to do the paperwork to submit it to the standard library than it would take to write.
Its a 3rd party python library, which he mentions. Its not written in Python but why would that stop you from using it.
pypy is viewed as a possible future replacement interpreter for cPython for performance-oriented code. Several PSF members have said this on more than one occasion. Hence having it work with Python 3 could be seen as "essential".
They were sorted randomly, I swear!
Can you tell me why one is more "pythonic" than the other? We don't need "c" in this context, we have no reason to care what is stored in the individual list elements. Pulling a reference to the elements isn't terribly expensive, but it's still cluttering the namespace.
My top 10, based on what I most commonly actually use, would probably be (in no particular order): `itertools`, `re`, `os`, `sys`, `collections`, `functools` (especially for `partial`), `json`, `time`, `timeit`, `importlib`. Honourable mentions to `unittest` (I know, shame on me for not having it at the top), `random` (obviously some things really need it, others don't), `struct`, `copy` (but it can be a sign that you're fighting against the reference semantics of the language - don't do that), `array`, and all the internet protocol stuff (although a lot of people prefer third-party stuff here). `argparse` is good to know, but it's ridiculously complicated; consider the third-party `docopt`. Probably more programmers in 2014 ought to pay attention to `locale` and `gettext`. Cheeky special mention for `builtins` ;)
You can also download things with `os.system`. Doesn't make it the right tool for the job.
im glad twisted got some positive press.
Trey?
&gt; It's one of these cases where people who are a lot smarter than you have spent a lot more time than you making csv work quickly, efficiently and easily. I'm extremely sympathetic to what you're saying about code re-use. &gt;Besides, why would you spend a couple of hours rolling you own csv reader when you can spend a couple of seconds using the in-built one? But the data I work with has always been extremely easy to parse. I generally use tabs and no item could ever possibly have one. So writing my own parser literally takes seconds. gthank raised a good point about using it though.
For future reference, you might be better posting this type of question to /r/learnpython. But in the meanwhile... Say your input csv file was called in_file.csv and looked like this: name,column_not_wanted,phone_number,address matt,rubbish1,123,x kim,rubbish2,456,y craig,rubbish3,789,z Then the following would show a pretty simple way to parse the csv input using the csv module, pull the columns of interest, create a file name.txt, and write a message with the variables dropped in: import csv def create_invite(row): f_out_name = '{}.txt'.format(row['name']) f_out = open(f_out_name, 'w') message = 'Hello {0}!, blah blah blah invitation stuff Address: {1}. Phone: {2}'.format(row['name'], row['address'], row['phone_number']) f_out.write(message) f_out.close() f_in = open('in_file.csv', 'r') reader = csv.DictReader(f_in) for row in reader: create_invite(row) f_in.close() Which should give you files like matt.txt containing &gt; Hello matt!, blah blah blah invitation stuff Address: x. Phone: 123
I was unaware of that. Cool. Good point. Got any info on the differences and why Requests is better for downloading?
Here's ten more that I'd consider important next to those above ten: decimal datetime time shutil urllib json logging glob functools operator
Why the downvotes? ujson is API-compatible and supposed to be a drop-in replacement. 
Also simulate a browser with requests (I actually ended up doing this, for performance reasons). 
What do you use them for?
Thanks for the subreddit reference - I'll use that in the future from now on! I'm getting 'Key String' errors on line 7 - where the code states ' f_out_name = '{}.txt'.format(row['name'])' It's having trouble with 'name' - I'm wondering if I have to 'open' the csv file previous to using a 'row'? File "invites.py", line 15, in &lt;module&gt; create_invite(row) File "invites.py", line 5, in create_invite f_out_name = '{}.txt'.format(row["name"]) KeyError: 'name' EDIT: apparently LibreOffice formats CSV files weirdly - it uses a bunch of spaces instead of commas. Is there any way around manually editing commas into the CSV file?
&gt;From what I can tell, it operates pretty much exactly like a class with `__slots__`, creating a bunch of getters (living in the class, not in the instance, of course) that lookup into the internal array. No, it doesn't. At least not in Python 3.4+: from builtins import property as _property, tuple as _tuple from operator import itemgetter as _itemgetter ... __slots__ = () ... {name} = _property(_itemgetter({index:d}), doc='Alias for field number {index:d}') As you can see, instead of using the (relatively) fast C-level access `__slots__` provide, it opts to use standard `property` (that uses slow Python-level function calls) to look elements up by their indices in a tuple (using Python-level item access, i.e. `__getitem__`) instead.
Run through the [quickstart](http://docs.python-requests.org/en/latest/user/quickstart/) of requests to see what it does.
nope, ken
Writing about programming but ducking up how the code is shown on small screens... Kind of makes it even less interesting... 
Buildout has a steep learning curve, but it does what virtualenv does and then a lot more. At work we have about 200 repositories working on Buildout. It's hard for me to write a detailed comparison though as I hardly know virtualenv. Is it true that virtualenv doesn't even have a cache for downloaded eggs so that they can be shared between projects? Buildout basically does version management and a shielded Python environment like virtualenv does, but it can also do a lot of other stuff related to setting up a working environment -- create directories, temporarily switch to a directory with source code instead of a packaged egg during development, collect together all the relevant scripts of all the packages, setup Django nicely, etc. 
I would add scipy before pandas. Pandas if you are very heavy on timeseries.
Been writing in Python for several years now. Here's my list of essential built-in Python modules. - sys: Essential system functions - math: You will use this after high school - optparse: easily create tools with command line arguments and help screens. - re: Regular Expressions will save your life one of these days. - json: This is your plain text object serialization - pickle: This is your Python-centric object serialization - random: I do lots of math simulations, and you can't simulate very well without a random number source. - urllib, urllib2: Essential to interacting with websites - datetime: Logging timestamps of operations is quite handy This is my list of standard modules that I can't live without. I think that the modules "math" and "sys" are so essential that they should be automatically imported into every python program. Behind those two, "optparse" and "re" are two that I use every day and in ways I never planned. I might even include "re" into my short list of modules so essential that every program should import them.
 from timeit import timeit from collections import namedtuple NT = namedtuple('NT', 'a b c') nt = NT(1, 2, 3) t = (1, 2, 3) def test_loop_t(t=t): return sum(t[1] for _ in xrange(1000)) def test_loop_nt(nt=nt): return sum(nt[1] for _ in xrange(1000)) def test_loop_nt_named(nt=nt): return sum(nt.b for _ in xrange(1000)) def main(): setup = 'from test import t, nt, test_loop_t, test_loop_nt, test_loop_nt_named' print timeit('t[1]', setup='t = (1, 2, 3)') # just in case print timeit('t[1]', setup=setup) print timeit('nt[1]', setup=setup) print timeit('test_loop_t()', setup=setup, number=1000) print timeit('test_loop_nt()', setup=setup, number=1000) print timeit('nt.b', setup=setup) print timeit('test_loop_nt_named()', setup=setup, number=1000) if __name__ == '__main__': main() Two times slower than access by index here. Doesn't matter much, in my opinion.
Interesting. virtualenv is just a "box" that pip / easy_install can plop Python packages into, so it doesn't really do anything with regards to downloads. pip, however, which is commonly used alongside virtualenv, does have a cache that shares downloads between projects.
pandas is mainly data munging. scikit-learn is the machine learning one.
I use it for simple collections of data that don't necessarily need their own class, but I don't want to use a dictionary and be typing strings all the time. The example is pretty good. &gt;&gt;&gt; Point = namedtuple('Point',['x','y']) &gt;&gt;&gt; p = Point(11, y=22) &gt;&gt;&gt; p.x + p.y 33 Sure I could use a dictionary &gt;&gt;&gt; p = {'x':11,'y':22'} &gt;&gt;&gt; p['x'] + p['y'] 33 but with a namedtuple there are a few less characters to type. Moreover, when doing interactive work you can do tab completion which is nice. 
thumbs up, and stared!
I got bored when I saw this earlier and tried to make a really general solution. It handles some other edge cases that your misses and supports generators. def find(iterable, sequence): initial_value, seq = _check_input_sequence(sequence) iterator = iter(iterable) i = 0 for value in iterator: # Found matching start of sequence if value == initial_value: try: # Look at each next item in iterable and see if it matches # each next item in the sequence matches = True increment = 1 for val in seq: matches = next(iterator) == val increment += 1 if not matches: break except StopIteration: # Reached the end of the iterable and still had more of the # sequence to check break if matches: return i i += increment else: i += 1 message = 'Sequence %s was not found in the iterable' % str(sequence) raise ValueError(message) def find_all(iterable, sequence): zero, seq = _check_input_sequence(sequence) sequence = [zero] + list(seq) seq_length = len(sequence) try: matches = [] iterator = iter(iterable) i = 0 while True: i += find(iterator, sequence) matches.append(i) i += seq_length except ValueError: if len(matches) == 0: raise return matches def _check_input_sequence(sequence): try: _sequence = tuple(sequence) except TypeError: _sequence = (sequence,) try: initial_value = _sequence[0] except IndexError: initial_value = sequence _sequence = (sequence,) _sequence = _sequence[1:] return initial_value, _sequence
* generic exception handling * does not validate SSL * non-ascii subject fails * `.ehlo()` is unnecessarily That's not how you do SMTP in Python (beside the SSL thing).
What's most useful is going to depend a lot on what you're doing: web stuff, sysadmin stuff, mathy stuff, etc. With that in mind, I'll out-Paretto your Paretto and suggest a single universally-important module: os. Specifically the os.path sub-module. Everybody ends up working with paths. Tons of people beginning Python just manipulate them as strings and and eventually end up with hard-to-spot edge-case bugs or just plain ugly looking code. I'll also suggest becoming very familiar with the built-in functions and methods on the built-in types. It's easy to overlook that stuff because you don't have to import it, but there's a lot of useful stuff there.
I often use: * pytest * prettytable * pep8 * itertools * collections
Cross-posting to /r/gis! FYI: the nyud.net link didn't seem to work.
This thread has been linked to from elsewhere on reddit. - [/r/gis] [/r/Python: github project making flat file maps out of GIS data/google maps](http://np.reddit.com/r/gis/comments/2909dw/rpython_github_project_making_flat_file_maps_out/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
I do a lot of work migrating old data to newer data types during migration and this is gonna help plenty. Thanks!
Came here to say the same thing. There's no comment in this thread suggesting this and it's an absolutely brilliant library that's saved me plenty of datetime calculation/conversions. For more information, just check out the [examples](http://crsmithdev.com/arrow/#quickstart).
/u/AM_BIRD_AMA and I suggested this below, but a great 3rd party "datetime" module is [arrow](http://crsmithdev.com/arrow/#quickstart). It's helped me out more times than I can count.
Formatting's messed up for `find` (you missed the indentation for the first line). Also, I think you'd need to support backtracking (try `find([0, 1, 1, 2, 3], [1, 2])`, for example). `itertools.tee` could be of use here. Third, the input fudging `_check_input_sequence` does might be convenient, but it just screams code smell, both the handling of empty sequences (compare to calling `str.find` with an empty string, which just always returns `0`) and the automatic wrapping if `sequence` is not iterable (what makes `find(lst, 42)` different from `find(lst, 'John')`? Right.). My proposal: from itertools import tee def iterindex(iterable, sequence, i=0): sequence = tuple(sequence) if not sequence: return i #Python 3: #initial_value, *rest_of_sequence = sequence #Python 2: initial_value, rest_of_sequence = sequence[0], sequence[1:] iterator = iter(iterable) for value in iterator: if value == initial_value: check_match, retry_next = tee(iterator) try: for val in rest_of_sequence: if next(check_match) != val: return iterindex(retry_next, sequence, i=i + 1) return i except StopIteration: break i += 1 raise ValueError('subsequence not found') Downside: the 1 extra stack frame for every instance of backtracking. Not necessary, but otherwise the code would've been much uglier.
Your description is correct. If you just want the textiles, I would generate a unique file name for each one when you open it for writing. When you close it, it will be saved.
That's the thing about true randomness: you can never be sure.
 def random(): """ Return a random number in the range [0,1]. """ return 0.874 # This number was chosen randomly.
why csv over something like pickle or json?
Most of what I do with python is data analysis, so with that in mind I use the following third-party libraries far more than any one built-in library: * pandas (huge learning curve but insanely awesome) * numpy (does all the heavy lifting for lots of other stuff) * scipy (great for signal processing, stats, and most general analysis steps) * scikit-learn (for machine learning) * matplotlib (for data viz, though there are lots of other cool newcomer packages) Those four right there are the lion's share of what I use, they may as well be built-in. I use them largely for model fitting, applied stats, and visualization (though let's be honest, it's actually mostly data cleaning, with a little bit of model fitting at the end).
It's a lot harder to open pickles or json. 
[unmirrored link](http://alternative-schools.org/ElliotHallmark/wp-content/uploads/2014/05/recursion.html) for you if the mirror doesn't work.
I've moved away from bash to python for automating my servers. I couldn't imagine life without os, sys, shutil (and logging to review what the hells going on when I care to peek under the hood).
Relevant XK..Ah, I can't be bothered. 
You can share modules between environments using virtualenv. Install the module system-wide, and when setting up your virtualenvs tell it to pull module from the system install. It's an option when setting up an env.
The python-win32 module tends to be a fairly thin wrapper over the Windows API, in this case PdhEnumObjectItems: http://msdn.microsoft.com/en-us/library/windows/desktop/aa372595(v=vs.85).aspx &gt; Consecutive calls to this function will return identical lists of counters and instances, because PdhEnumObjectItems will always query the list of performance objects defined by the last call to PdhEnumObjects or PdhEnumObjectItems. To refresh the list of performance objects, call PdhEnumObjects with a bRefresh flag value of TRUE before calling PdhEnumObjectItems again.
Can you open JSON in excel? Honest question because I don't use it. 
If you have to send or receive data from people who aren't programmers, you'll probably want csv if only because they can edit it Excel. 
Because Python is actually a Microsoft product.
10, hm..... I rarely use 10 of the builtins in all of my projects, but some below I use quite frequently. * `os` (extremely important) * `sys` (extremely important) * `threading` (extremely important if you want to do any kind of concurrency) * `string` (extremely important for string manipulation) * `re` * `sqlite` * `httplib` * `shutil` * `json` * `time` * `logging` Honestly, the most important things to know how to do in python are file IO, and `os`, `sys` modules. Once you know how to read/write files you can do anything with IO. Once you know how to interact with the `sys`tem and `os` you can start building complex modules and projects. Everything after that depends on the use-case (such as if you need `sqlite` or mysql). Since you are a beginner you're most likely overwhelmed in "what you should know"; but the reality is that you cant know all of it, that's why there is developer docs. Your best bet is to come up with a miniature project that uses file IO and a database backend store as that will get your feet wet with the API. Some outside project modules I use: * `django` * `BeautifulSoup`
Sadly, `collections.namedtuple` is [internally rather terrible](http://www.reddit.com/r/Python/comments/28utww/writing_better_python_code/cif9uxt?context=3). TL;DR: It's basically implemented as this: code = '''\ class {}: # snip ''' def namedtuple(typename, field_names): # snip some hand-written string escaping return exec(code.format(typename, field_names)) Note that you can manually create classes on the fly without this silliness by calling `type()` with three arguments.
For a beginner, I would go with: 1. itertools 1. collections 1. os 1. sys 1. functools 1. time 1. datetime 1. random 1. operator 1. pprint
No you cannot. In all fairness, it was not specified that it must be Excel compatible. JSON is rather good for data interchange. Not so good for spreadsheets. 
Ah yes. For interchange it's definitely better than CSV's. That's the whole point of it. CSV isn't even a standardized format.
After working with too many corrupted CSV files, I don't even think the word format applies to it. More like raw blob in (hopefully) ASCII, UTF(8|16...) encoding.
Try GSoC (Google Summer of Code) or other similar initiatives. You get to interact with mentors and solve some problems for the industry. You can also look at ODesk, Scriptlane to get a sense of simple projects being outsourced. I like @desmoulinmichel 's suggestions. 
Cool, thank you for the additional suggestions. I could look at what some people are asking for code-wise from ODesk. 
I wrote a game called Electropocalypse ( http://electropocalypse.com ) about basic electronics. It's available for iPad, Windows and Mac. I started it using Pyglet, but then switched Kivy and I loved it. Kivy looks great, and is easy to get running on many platform. 
Yeah, not the best site for mobile browsing. I'm using a HTC M8 so not a small screen as mobile phones go. Makes it more annoying that when you try to move around the page, you are navigated to another page if you go too far left. 
I've been doing it wrong all along...
Not a builtin, but I wanted to give a shoutout to [pexpect](http://pexpect.sourceforge.net/pexpect.html). It allows for automated interaction with utilities like telnet, ssh, and ftp. In my case, I'm using it at work to create a script that will automatically update ~1800 customer edge routers with an ACL for our new monitoring system and save the running configuration of the router to our TFTP server. By an extremely generous estimate I am saving my department roughly 1000 man-hours based on the assumption that if everything went correctly, it would take 3 minutes to update each router manually. It would take a dozen people 2-3 months of doing this in addition to their normal workflow to achieve the same result. Now, if I can only figure out a way to automate test calls in Python...
I'm an automation engineer...it's literally my job to glue steps together so we can press one button instead of hundreds. If you want to practice this, get really familiar with the command line (linux and windows) and learn how small programs / functions can be reused optimally to create a flow. Learn how databases work and what the best way to store "your data" is. Look for a problem that could be solved with one module...and make that module so it's flexible on input and can solve "like problems" as well. Right now I'm using python to monitor and deploy into the 1000's of virtual machines. Some are Windows Server 2008 or 2012 and some are Debian, except the IT people don't want to care, necessarily, what OS they're querying against because 90% of the applications are Java. Creating a common interface for all the different types of servers and environments gets me giddy with anticipation. This is what I like to do. Nowadays my bosses are into guis though. Everything I write is is command line based, but he likes to see charts and colors -- this is where I've picked up web frameworks and plotting libraries. The browser is the perfect cross platform gui terminal. This has frontend and backend code...so now you're learning Python and JavaScript; maybe even a little Node with some async design. There's lots of fun stuff you can do right now -- the libraries, languages and modules are endless. Pick something you like and just try to make it.
Great. Good luck.
If the total number of faces in the frame is 0 then print your message. Now if you want it to print the message when a particular face leaves the scene, i.e. when your face is no longer in the frame as opposed to your friends face , [it gets a bit trickier](http://docs.opencv.org/trunk/modules/contrib/doc/facerec/). Edit: Grammar, punctuation Edit 2: Link to face recognizer API
This is super useful, Im working on exactly this all week! 
Thanks for catching that, will update the readme.
[Got ya covered](http://xkcd.com/221/)
The patterns you are looking for are *single sign-on* and *single sign-off*. There is nice stackoverflow thread about it: * http://stackoverflow.com/a/1057199 
If you want to use it to keep track of a TODO list, check out [TaskWarrior](http://taskwarrior.org/) too.
That's a weak point for me, I'm not an experienced UI guy. You used `argparse`, so I don't have much to add on that front, sorry. I haven't looked at the bit with nltk, is that the direction you're going? If so, I can check it out too.
Yep. That's going to be difficult to browse on. I suspect that even pep-8 compliant code would give some problems when viewed on phones. I took a look using a Nexus-10 tablet and it was browsable by the way. How do you suggest changes should have been made? Thanks.
The code block should never exceed the width of the text. If rows are two long the block should have a horizontal scrollbar IMHO :-) 
You should probably decouple the web page from the actual work load: Have only one web server for all customers and do the actual work on different machines. 
TIL about setuptools "extras_require" feature. https://github.com/maebert/jrnl/blob/master/setup.py#L81
Any chance you are considering an android release?
I had thought it was done that way for performance reasons. I know nothing more than that, except I would assume they wouldn't do it that way on a whim. Also, I'm not really sure why the implementation details matter when they work correctly.
Agreed, though I've never actually used it (or needed to use it). Pandas is also good, from what I've seen.
This. Virtualenv creates a sandbox, but it's a sandbox that's "global" to the system. Buildout also creates a sandbox, but it's "local" to the project. Then you get the bonus of "recipes" that can do a lot of setup outside of your project, like setting up databases, installing binaries, etc. Also, virtualenv is fixed to the shell user it's installed under. Buildout doesn't have this issue; it works whoever you're logged in as.
CSV is a different format. If you're receiving CSV data in or need to output CSV data, using pickle or json wouldn't work. Likewise, if you're storing information for use later in your program, you probably don't want to store it as CSV. If you're worried about types, use pickle. If you're worried about compatibility, use JSON -- though I'd recommend YAML instead as easier to read than JSON when it's written in extended format, it's very Pythonic. Use the right format for the data you're working with.
If it's "your data", sure. But as Sartre said, hell is other people's CSV.
&gt; but by the time you're done dealing with quoting and edge cases you've spent more than enough time to wonder why you've reinvented the wheel This. Clever people have already done the work for you. Why waste time?
"Character" separated values.
Yes, but there's a PyPI package that fixes this: https://pypi.python.org/pypi/unicodecsv Again, why roll your own when someone's done the hard work for you? ;)
&gt; If you have data that has trailing commas because it's been dumped from Excel, it fails. Really?! That's very interesting, because all the data I've been working with in the last 18 months has been exported from Excel and I've not had a single problem with it.
&gt; So writing my own parser literally takes seconds. But you're still doing it over and over again. Why waste the time? Would you also write your own JSON parser? 
Dear OP, I just got myself a copy of Pythonista to use in conbination with Launch Center Pro, I was really hoping to use PRAW in Phytonista but in all honesty I'm a noob in Python. Did you ever complete the port of PRAW to Pythonista? If so could you help me import it?
The comment by muttony good hack to get started. However, I would check if the total number of faces in the image is zero *for multiple, consecutive frames*. The reason being it is normal for OpenCV to fail to detect a face in a given frame due to angle, lighting conditions, shadows, but for the face to be detected again a few frames later. A better hack would be to monitor the bounding box of the detected face, specifically, the (x, y) coordinates. If the bounding box is moving too far to the left, right, up, or down, you can easily detect this and print out the appropriate message. And again, this should be done for multiple consecutive frames.
Fun
`namedtuples` are also supposed to be more memory (and maybe speed) efficient because they use slots.
Idiomatic code. its like 4 spaces vs 2 spaces, or list comprehensions vs map/filter. The "community" at large prefers one. If you don't need an element of a tuple, the convention is to name it _ for i, _ in enumerate (haystack): I personally don't care that much for it, but if you have to work with other programmers, it does matter.
Go to fiverr, odesk and freelancer. Offer your services for cheap enough to keep your schedule full. Keep in mind that this is about education and not profit. Each company has it's own setup and they'll explain the parts that relate to software development. You'll get first hand experience overnight. Don't promise what you can't keep and don't collect on what you don't deliver. Everything else (delays, non delivery of work, or other honest issues) come with the territory and those people will work with you or move on without it being an issue.
Command line is fast, efficient and non intrusive! Give it a try and you will find that clicking your way to accomplish a task has many disadvantages even if it is more intuitive.
Not a module, but a very **very** useful function that I use a lot. Take a look at the `String.format` function. &gt;&gt;&gt; "The hexadecimal representation of 256 is {:X}".format(256) 'The hexadecimal representation of 256 is 100' &gt;&gt;&gt; "Hi, my name is {name}, and I'm {years} years old".format(name="Azeirah", years="2") "Hi, my name is Azeirah, and I'm 2 years old" [Documentation](https://docs.python.org/2/library/string.html#format-specification-mini-language)
please post things like this in /r/learnpython
Not to be confused with [fs](https://pypi.python.org/pypi/fs/0.5.0), which is more useful if somewhat less fun.
You want a simple project ? Create an app that just tell people when it's going to rain near them. That's all. Easy, useful. A bit of mobile, a bit of server, a bit of API. You use the GPS to detect the position of the personne once a day (unless he manually refresh), you query a meteo API, and you don't do anything unless there is a good chance to rain. If there is, just quickly notify them. Have a nice summer.
you list all the wrong reasons, yet in the long run, all you did was post another howto that will make a lot of people worse please reexamine your approach, its fruits are painfull
I will in the future, thank you.
Looking forward to a second article. Our tests are dogslow
Thanks, I'll research into something like this. Sounds like it should get me introduced to some new stuff. EDIT: I've been thinking about this project. I've found an API I think I can use for this project, but I think I'm going to have to try and simulate a random GPS location or just give it my own GPS location constantly. Or I could have the user input the city they're in or something.. Looking through this API is interesting, I never knew that they would limit us to a certain amount of requests per day. Plus some APIs we even have to pay for. Luckily most of them tend to offer a free option.
Great! Check out brewer2mpl
My extremely biased list, in no particular order: * itertools * functools, and its cousin * operator * os * multiprocessing * codecs * struct * timeit * collections * doctest
You are a beautiful person. I've been having a hell of a time finding documentation, thanks a ton for the help! 
By all means, I invite you to try it out! If I'm wanting to tease people I could bring up all kinds of Ruby vs. Python hot buttons but the truth is, none of that matters given various different goals, and especially with learning. Another language Ruby people I know sometimes play with is Clojure. Windows can be weird but I used Python for several years on it and it can be fine. Sometimes some libraries use system libraries that may not be available, and lately I've been using Cygwin with much success but not entirely sure I'd recommend learning all of that instead of just running a Linux VM. Best of luck, and keep it fun!
Thanks! I'm hoping the rig will have the power to run VMs. Also I hope they allow me to install freely. Is your production server Windows as well? 
Great points made by /u/zionsrogue !
&gt; LibreOffice Does this work: [https://superuser.com/questions/717243/libreoffice-is-saving-csv-files-with-tabs-as-separators](https://superuser.com/questions/717243/libreoffice-is-saving-csv-files-with-tabs-as-separators)
Comment from a maintainer that rejected [another approach](http://bugs.python.org/issue3974) &gt; The current version is clear and maintainable. There is nothing unholy &gt; about using exec. Earlier versions used other approaches and they &gt; proved unnecessarily complex and had unexpected problems. It is a key &gt; feature for named tuples that they are exactly equivalent to a &gt; hand-written class.
Personally I am trying to move away from Python and into Ruby but it is all personal taste of course. There are some parts about Python I love but then there are other parts that drive me crazy because how unpredictable it can be. I do not know Ruby but I have heard of so many people switching to it and loving it. The main reason I do not like it is because it is quite large. There is not just one way to perform any function, there are lots of ways to do it which can make it pretty unpredictable at times. For large code bases, I tend to not enjoy it, but for small programs I just want to hack away, I love it as it is so quick and easy to get up and running. 
Given the url I expect you're using Windows. Your best bet for installing OpenCV is either getting an installer from Gohlke's site: http://www.lfd.uci.edu/~gohlke/pythonlibs or installing Anaconda by Continuum Analytics (https://store.continuum.io/cshop/anaconda/) which comes with a lot of scientific Python libraries. If you really only want OpenCV, they also have Miniconda (http://conda.pydata.org/miniconda.html), which lets you install the same libraries similar to how its done through pip: conda install opencv OpenCV isn't available for Python 3 just yet, so if you tried using it there, your best bet is to switch back to Python 2 for now 
Awesome! Thanks!
For every foo.py there is or will be a completely unrelated pyfoo.
In theory, there's no difference between theory and practice; but in practice there is. There's a tremendous difference between what I said and what you said. Don't read about it. Do it. If the projects on odesk are too ambitious, start with fiverr, but dive in. There is no comparable substitute.
For the function defaults, I would rather write: def bar(names=None): names = names or [] names.append(foo()) return names
Cool! I forked it, I think evernote functionality would be a neat bonus, and it looks reasonably simple to integrate.
While I do love Python, if you want to learn a new language, I suggest to try something radically different. Python and Ruby are very much alike, and while I do believe you can achieve much more in Python than in Ruby because its ecosystem is way bigger, truth is you can code the same things almost the same way with both. So try something new. Try Erlang. Try C. Try something at the opposite side of your realm.
A JSON parser is much, much more complex. We're talking about like three lines of code. I've just never bothered to look at the csv library. If your requirements matched my own I don't think you'd have either. It's like trying to sell "logging" to someone who has only ever needed one level of verbosity, no output file, and very few print statements.
Couldn't agree more. Python vs. Ruby is like Pepsi vs. Coke. Go try some beer, or an iced tea, or a milkshake.
So the config file becomes a shell script instead of an ini-file?
Thanks this is very informative - due to the docs being outdated.
So unless I'm missing something.... You now have your configuration out of version control, so potentially things like static parts of SALTs are permanently lost and accessible to anyone on the server who has either r or x to the shell script as you haven't mentioned now it should/could be protected? In principal I don;t disagree with the approach but you need to wrap a lot more detail around it IMO to make it workable.. obm edit : spelling
Good one !
I like both languages very much, but made the switch from Ruby to Python a few years ago. Here are my views on your points: 1. Apart from the switch to Python 3 where backwards compatibility was broken (intentionally, with good reasons and documented well in advance) - I have never ever encountered a problem when upgrading to a new version of Python. Not so with Ruby. 2. I'd think adapting to a newer Version of Rails might be easier than learning a Python Framework from scratch. Django comes to mind if you'd choose the latter. It's really well documented and takes a conservative approach on backwards compatibility. 3.a I don't have any benchmarks to back me up here, but don't have the impression that the default Implementation of Python is significantly faster or slower than the standard Ruby interpreter. 3.b The few times I had to use Python on Windows, I had a hard time. Especially if I used Python packages with C extensions, since you'll have to install a build infrastructure on Windows first. (It's a one-liner in Linux to set this up). My coworker develops under Windows, and he curses every few days. But there are people who use Python under Windows just fine, better ask them on a qualified statement on that matter. Other than that: Starting with Python, a lot of it's design decisions to me seemed rather strange or even clunky at first (len(my_list) instead of my_list.length()? Explicit "self" with every method definition? No private class instance attributes? No switch statement? ...) Also, every time I didn't do stuff the Python way, things got ugly. Over the years, most of what seemed strange at first turned out to be the way it was for very good reasons (most of them documented very well). Thinking about it today, Python's philosophy of "there should be one obvious way to do it" is one of it's greatest strengths in my eyes: open someone else's code and instantly feel at home. I hope this helped.
In my opinion most - if not all - of an application's configuration doesn't belong into version control in the first place.
 So how do you track changes to the environment so that you can regress out of bad configuration changes and work out what data may have been affected by a change? Not arguing - just curious?
 def sublists(lst,sublst): for i in range(0,len(lst)-len(sublst)+1): if lst[i:i+len(sublst)] == sublst: yield i #example items = [5,8,5,0,3,3] for index in sublists(items,[5,0,3]): print('sublist found at index',index) 
Haskell is a fairly friendly functional language for Ruby and Python developers with a pretty good community.
I'm going to have to go ahead and completely disagree with you there. In our shop configs are in version control, separate from the code, in repo's that reflect each deployment environment. Along with static data, an environment vars setting script and other deployment specific stuff. I can't imagine the horrors if we *didn't* have configs under version control. It makes new deployments much easier and allows us to track independently the effects of varying configuration setups. 
You're welcome! I've had similar painful experiences in the past, but a tag team combo between Gohlke and Continuum have fixed most of the issues for me. I can definitely recommend using Anaconda for managing your libraries, because its also an easy way of keeping things up to date without going through the pains of building libraries yourself.
My way of doing things (I mostly develop small-sized WSGI apps): - applications of course are in version control. they can only be configured via environment variables (see http://12factor.net for reasons) - if possible I include some sample setup script a little similar to the one described in the original post and a startup script so a checkout can be run immediately for developing and testing purposes. - since the "real" configuration is a) specific to the system the app is deployed on and b) in part sensitive data (Django's shared secret for example) this should, in my opinion, never land in the application's (maybe public) repository. I keep data like this in configuration management (Ansible in my case). Which, to be honest, is versioned as well (just in another, restricted, repository specific to my local infrastructure.) So *here* is the point I can back out of bad config changes. - out of the configuration management data (which in the case of Ansible is supplied via YAML files), Ansible ensures the environment is set up correctly when an application is run. How this is achieved depends on the method, the app is run. In case of uWSGI serving my apps, I generate uWSGI config files that specify the necessary environment variables. Hope this helps. Also, if there are better wayst to do this (It took me an emberrassingly long time to settle on this setup) I'm happy to hear about them.
I can see how this might be useful if you have to access the config from a lot of different services, potentially written in different languages. But, if you're just going to pass it right into a Python script, you might as well use a config file and save the extra step.
You're right. For some reason, I misinterpreted onebitmissing's statement as referring to a singular repository, and I should have said configuration doesn't belong in *this* repository. (my config data is versioned as well, as descibed in my post below) Sorry for the confusion.
running tests the python version of 'compiling code'
heh, cute and awesome.
Thanks for the input :)
How does it automatically convert strings to numbers? Hmm… By using [`json.loads()`](https://github.com/mknecht/pyfs/blob/3150b56908d59efe24f750f98e84fb8522ecfd2e/pyfs/scriptsupport.py#L16)… Clever…
weeeeeeeeeeee i replace hamster with it.
Can't even dumb phones text to email addresses? 
I feel that i have learnt alot from developing in languages that have diffrent "styles" of programming. 1) Python. I really like the beuty of the code, and sometime i even go to extreams to modify working code to keep it as readable and beutiful as possible. This has changed how i program in all languages. (Ruby can be chosen instead, imho its all too rails) 2) JavaScript. This is where i use callbacks, alot. I learnt how to use them, and from callbacks to promises to async programming. Also this is a language i concider is a must to know for any developer. Nodejs is also a very intersting platform. 3) Clojure. Because its a Lisp, theres many concepts i still dont get, and that said im still learning. From Clojure i have learnt patterns i would never use in other languages. 4) PHP. As a poormans Java, still coming strong even with all the (daily) rants i read the language. PHP is alot more OOP than Python with all the classical OOP design patterns. You will learn OOP with dynamic typing. (Feel free to choose java if you drink your coffee strong) 5) Rust. As a systems programming language this is as lowlevel as c. Its fast and similar to c++, making it a language with a high learning curve. From here i have learnt generics and how to manage memory. (Feel free to learn c/c++ if thats your thing) Thats basically my short list as of now. Who knows how it will look in 1-2 years. The main point is that its not the language you learn, its the patterns and best practices. Most patterns are language agnostic.
This is what for.fields[wbfile] shows: &lt;django.forms.fields.FileField object at 0x7f91ff1c49d0&gt; Hence the file is definitely bound to the form. 
Right. It's not magical. For me it has simply been easier to manage when working with multiple developers and dev-ops engineers on mid- to large scale sites deployed to multiple environments - for example, staging, beta, and production.
Appreciate the input and totally get what you are saying. Gives me something to think about.
I appreciate the feedback! Helps open my mind a bit more in the directions I will go into in the coming months. I figure for my Ruby scripts I may migrate those to Python. But my Rails app I may consider converting to PHP/Javascript. Look into using Node.js since that seems to be hot right now. Thanks again!
I would seriously consider looking at using the pygooglevoice (correct?) module/api. It's awesome, you can send texts, check inbox for texts, etc. It's pretty damn fun, and awesome because it's literally free texting. I've used it for many things related to sms notification in my python code. Give it a shot! Let me know if you run into any issues, I believe I did but was able to resolve them with a tiny bit of hackery. https://code.google.com/p/pygooglevoice/
What are you doing with the shell script that a config file couldn't? Where is the difference between managing shellscripts and managing config files?
Thanks, I will definitely look into this. I was trying out google voice earlier for it but I went through all the area codes on this [list](http://www.bennetyee.org/ucsd-pages/area.html) and couldn't find a single number that worked. Because it was definitely the easiest solution but it's also rumored that google voice is being phased out/melded into google hangouts.
https://docs.djangoproject.com/en/dev/ref/models/fields/#filefield Looks like you just replace the .value() with .open() and it will work.
Most bulk SMS providers will also provide incoming numbers that allow you to route message contents to an email address and usually with rules - eg. If the message starts with 'invoice' then forward it to the accounts dept email. No coding required, just a service fee for the phone number and five mins setting up an account.
You refer to "Twelve-Factor App approach" and almost first thing mentioned is "Have a clean contract with the underlying operating system, offering maximum portability between execution environments" How does this work on windows? Poorly. Python is mostly platform independent so why mess it with bash?
&gt; Plus some APIs we even have to pay for. Well, it isn't free to have the server respond to requests for data. You're paying for the ability to send a lot of data to them, and have them respond to all of the requests, which they might need better servers to do so. But yeah, a free, ratelimited version is quite common. 
Sounds like a good use case of [Twilio](http://www.twilio.com/)
I like to include something like example_config.ini in my repo that has an example for all of the possible configurations. If necessary I might include more than one example ini file. Then the person deploying the app is required to pass in the path to their ini file, or I'll just look for a config file with a specific name in the same directory as the script.
I'm curious to hear this as well. From the sounds of it the biggest advantage was that no one checks in these scripts, but there's no requirement that anyone has to check in a config file either, so I don't understand how shell scripts changes anything.
Hi, just learning python and trying to play with your code to finish some functions (grabbing mp3 metadata), but I can't seem to get the base running. I'm unable to run the code due to "No module named gi.repository". I made sure to follow the installation instructions from this link ; http://python-gtk-3-tutorial.readthedocs.org/en/latest/install.html with no luck. Some directions on how to get that module working would be greatly appreciated!
Ehhh, thought I was on /r/crazyideas for a second..
Point taken, though I do hope you do use standard libraries when working with others! 
Notice operating system is singular. This is not about porting between operating system(s) (plural). This is about portability between execution environments - eg. environments with different database hosts, types of functionality enabled, and so on. I would suggest reading the rest of the 12factor recommendations specifically where they say "The twelve-factor app stores config in environment variables".
I'm not sure if this is supposed to be a joke, but I'm strongly biased by my personal experience. Python just won't let me go. JavaScript looks and feels ugly after Python. Even if I've learned the basics of C long before Python. Ruby looks and feels ugly after Python. Haskell looks and feels ugliest after Python.
Actually the biggest advantage was code simplicity. The problem was that unit-tests on specific components don't necessarily want to initialize the whole application, but the components themselves may require knowledge of the configuration - like AWS keys. Loading the config once globally is pretty dirty. It also still requires that we somehow know which config to load. This means either hardcoding a config file path or using an environment variable to switch between different configs. So, the options I felt we were left with were dependency injection, always initializing the app, or storing the config in a place independent of app initialization. Storing them in environment variables allows them to be independent of the application itself - the application doesn't need any logic telling it where to load configuration information from. In addition the configuration is available immediately as part of the execution environment. This means components don't have to rely on the app being initialized to be tested - this aids reusability and testability.
A properly-written call to `type()` (or a [subclass thereof](http://en.wikipedia.org/wiki/Metaclass)) is exactly equivalent to a `class:` declaration. `class` is syntactic sugar.
I'm not joking. Haskell is uglier than Python, definitely, but much prettier than just about every single other functional language (in which I mean looping by recursion and lists rather than explicit loop statements). Haskell is a LOT prettier than other functional languages, and Python and Haskell tend to borrow features from each-other frequently (see: indentation instead of braces from Haskell, list comprehensions from Haskell).
For any two things that are similar, you can find endless arguments about how one or the other is better or worse. I love Python and am not crazy about Ruby but it's very subjective and thus, kind of a waste of time to argue about.
Environmental config doesn't belong in your application's repository but you better have your environmental config in some sort of version control. At Gannett, we keep our application cfg in git because, why reinvent the VCS wheel? We continuously deliver our configs just like we continuously deliver our code. We use chef for stamping machines in an identical way regardless of environment. From Vagrant to Production. The application configure is the only thing that varies from environment to environment. It is also kept to the bare minimum. The only config we keep in there is what varies from environment to environment. In stage, the app cfg is as close to prod as possible to enable acceptance testing in a prod like environment.
Just would like to say that if you have a beefier machine there are tools like Vagrant + Virtualbox to take care of your platform needs. Headless servers don't take much though, I've never had issues virtualizing on a Core2 with 2 gigs of ram
I was able to complete a similar task with python's [smtplib](https://docs.python.org/2/library/smtplib.html) and [imaplib](https://docs.python.org/2/library/imaplib.html).
I didn't know the in-memory storage, looks good to me. 
I like that you pointed to code simplicity first. Because the security argument is a bad one: addressing the possibility of config credentials getting into version control by keeping them in a shell script is the wrong solution - it just moves the problem around a tiny bit. The right solution is to keep them encrypted in a password vault. But the desire to dynamically update configuration info isn't that hard to do with config files. Whether you're using files or environmental variables it makes sense to centralize, cache, and validate them early to avoid run-time crashes.
It's not ~quite~ API compatible. You can't do things like indent=4 for formatted json output. But, it's blazingly fast and works great for 99% of use cases.
It looks to me like the spacing is pretty consistent across the honeycomb but there are larger margins on the smaller cells. That could easily be printed. Are you familiar with the manufacturing techniques for artificial honeycomb?
Pathlib is good but recursively going through directories using it is a PITA and requires recursion where os.walk doesnt
If you liked Ruby you will adore perl: 1) Legacy 2) No rails (or handholds) 3) Windows, meh It was opaque before opaque was in. 
Now when is Firebird 3 coming out? :-)
&gt; "Have a clean contract with the underlying operating system, offering maximum portability between execution environments" &gt;Notice operating system is singular. Because you'd never have to port this app to Windows or embed it in something (okay...I'll concede that embedding something is not likely to happen). What's so bad about holding your configurations in ini files or python objects or whatever. Chuck a line in .gitignore. Done. If you need to switch between execution environments (dev, staging, prod, etc) THEN have a switch that looks for that from the command line but just that. What happens when you ask Fred the intern to add an option to the execution line and he borks it all up? Blame Fred? I wouldn't -- at least after I thought about it. Plus, when you're hammering out your app in dev, do you really want to keep typing `./localsettings.sh /bin/python path/to/my/app.py --whydididothis True --seriouslydontchangethisline "Something something something" --numberoffucksgiven 0`? Or, would you rather: `/bin/python path/to/my/app.py --env dev`? Have a config file like: class BaseConfig(object): '''A base config object for all shared information.''' SOME_VAR = 'something' ANOTHER_THING = False SHARED_CONFIG_SECRET = 4 #guaranteed to be random class DebugConfig(BaseConfig): '''Debugging Config.''' DEBUG = True class DevConfig(DebugConfig): '''Development config.''' SQLALCHEMY_DATABASE_URI = 'sqlite:///' IUNNO_WHAT_ELSE = None class TestConfig(DebugConfig): '''Q&amp;A config setting.''' SQLALCHEMY_DATABASE_URI = 'sqlite://testing.db' class ProdConfig(BaseConfig): '''Production ready config.''' SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://user:password@host:port/dbname' configs = { 'default':DevConfig, 'dev':DevConfig, 'test':TestConfig, 'prod':ProdConfig } Then, in another file: from .configs import configs config = configs.get(sys.argv[1], 'default') app.config.from_object(config)
That's may well still be a valid point, however you are not still addressing what /u/mackstann was saying. You may think coke is superior to pepsi, but that's still in the domain of cola; the point was to see what else is out there, to learn and comprehend new paradigms.
Hey, fs is loads of fun.
Check in `form.cleaned_data` You should also be able to get it from `request.FILES`
I see your point, but I fear you've missed mine. Firstly, I'm not recommending dozens of command-line arguments. Those were there to show that the settings file preserves the command-line arguments to your application. Nothing more. Also, there's really nothing I have against config files. This is just a simple alternative way to configure your application. It's more an article for people to read quickly, store somewhere in their minds, and perhaps reference when they hit a snag in the future. No universal prescriptions here. I actually migrated from a configuration system very similar to the one you describe. It worked well enough, but it broke down in scenarios where we didn't want to initialize the application but we needed the config like in unit-tests. People didn't want to deal with these pain points, so they got sloppy with it. That's why I switched over to this method.
Bare in mind that some of these may impact the correctness of your tests. It's quite possible to have code dependent on your database engine, which may pass (or fail) on sqlite and behave differently on postgres. Where possible, you should have unit tests that run quickly for devs to run every commit, and integration tests that take longer and run before each build. 
Yes, I'm seriously suggesting Haskell. I know it's not popular but if you're going to learn a different language you might as well learn a different paradigm while you're at it and Haskell is one of the nicer functionals.
PHP is more OOP than Python? I **strongly** disagree. No subclasses, single inheritance, so much unpure-functional deprecated API (mysql vs mysqli), weird namespacing, etc etc etc. Also the entire mess that is include()/require() In Python (and Ruby)? [Everything is an object](http://www.diveintopython.net/getting_to_know_python/everything_is_an_object.html).
You are loading and parsing a file: the shell script. It's just a different language. The extra step is copying the config into the environment before you can access it. Or, I could just read directly from an INI using configparser (or something better) and get sections and type conversion for free.
&gt; I've used RoR and I couldn't find anything more constraining and irritating to work with in the same problem domain. But when it comes to Python, I can use something like Flask and it is almost recreational to program in it (at least for me). You're comparing apples and oranges here. Ruby has plenty of Flask-type microframeworks like Sinatra.
&gt; At the moment I have a Windows laptop to develop off of. It's a really weak machine that wouldnt even be able to run a virtual machine. The servers running the scripts and rails app are unix. Luckily I am getting a beefier laptop soon but it will still be Windows unfortunately. Ruby, especially gems,would be better to develop on a different OS. Python is not any better in this regard - in fact, it might be worse. Libraries with C extensions are a pain. I don't know if Python on Windows has gotten something like it in the past few years, but Ruby has a [simple installer](http://rubyinstaller.org/) that comes with a compiler and toolchain bundled. IIRC most gems would install without any problem.
Or if you want a combination of Sinatra and rails, there's always padrino (that is without the bloat).
Twillo is good
What is firebird? ;]
This is quite similar to Procfile-based configuration, e.g. Honcho or Foreman. It's a good pattern to use. In your localsettings.sh script, you should really run `"$*"` instead of `$*`. Any parameter that includes a space or any special shell characters will be interpreted wrong otherwise.
Install on remote system, then ssh x
&gt; JavaScript looks and feels ugly. FTFY 
Do you want to know how to do this in python or just an easy way in general? If the former then I would do the following although it may not be very pythonic. Read a file line by line inserting the contents of each line into a set as you go. Now repeat for each of your files but always insert into the common set. Then read back each value of the set and write it as lines into another file. A set is a mathematical concept representing a group of unique things. Thus inserting 'A' and 'A' again into the set yields a set of size 1 containing 'A'. 
That will get the source before any javascript runs which will not contain the information I'm after. I know I need to use a headless browser to accomplish but have yet to figure out how.
I would probably `~$ sort -u list.txt new_list.txt`
if you have no duplicates in the file and don't care about order... data_a = open('file_a.txt').read().splitlines() data_b = open('file_b.txt').read().splitlines() output = set(data_a) | set(data_b) output_file = open('file_c.txt', 'w') output_file.write('\n'.join(output)) output_file.close()
An RDBMS
Would selenium work for you then? 
But if I pass the form from a template to a view and then to another view, request.FILES gets lost.
You misundersand. Just because everything is an object does not mean your code is oop. My main point was that the classic way oop is used is very similar in java and php, (main diffrence beeing typing) that was why it was on my list. Python hides alot of the solid oop principles, making for a very dynamic language, but at the same time hiding the way orher languages following theese patterns. One obvious sign is the missing class interface in python. 
I encounter the same problem on Python 2.7, Mysql and PyCharm 3.4 on OSX. My workaround is to only debug when I really need it and switch back to normal mode when I spotted what was wrong.
Hi All - I know there are still alot of rough edges in this thing! Still, any comments, critisisim, bugs, suggeston all welcome! I have a recent-ish APK here: http://chozabu.net/KivEntEdLatest.apk edit: [link to a gif for RES users](https://camo.githubusercontent.com/42d9e89da03c6e7d6d24243df3eb4d4b91b17336/687474703a2f2f63686f7a6162752e6e65742f73686565706d616368696e652e676966)
I'd recommend creating a separate settings file for tests, rather than checking for "test" in the command-line args all over the place. Star import your base settings file, and override the test-specific stuff.
I've seen this happen when using the debug toolbar, and my django code is creating a lot of SQL queries (like 3,000+ on default admin pages). Turning off the toolbar and turning on SQL logging helped me track down those issues.
I did actually figure it out, When you edit the pixelAccess object, you actually edit the original PIL image as well.
Wow, I just check *glob*, and i feel so bad. I always did that with some dirty *os.path* loops.
Give me break! The only thing killing Python is ignorant people belligerently resisting the future. 
If you truly believe that Python needs to be forked, then stop writing blog posts and actually do it.
I use the command line the whole time. It has it's uses. That doesn't mean it's human friendly. Simple test - for teaching someone who's never used a computer before, do you a) sit them in front of a GUI or b) drop them into a terminal? 
Command line is only like talking to a person, if when you talked to people you had to use a tiny subset of words, arranged in an abstract and often inconsistent way, and if you made the slightest mistake they would just scream "I DON'T UNDERSTAND YOU!!"
Ok. I am actually not the author of this post, nor do I agree with it, I just wanted to see the community opinion about it.
I don't think so.. I'm only using Python 3 at the moment (I don't have big projects, I'm starting from scratch) and enjoying it a lot! :)
I am using python at work for the past 6 years, have used ruby for specific use-cases where i needed eventmachine like async capabilities. Then being bored with developing routine web applications, i started trying functional programming with lisp &amp; clojure. I am not a competient lisp/clojure programmer, but being faimilier with them made me a better python programmer. This exposure to functional programming, changed the way, how i think about solving problems. I would suggest you to try any of the functional programming languages (Lisp/Clojure/Haskell/Ocaml/Racket/Scheme), though you might not use them on a daily basis, being familer with them would bring clarity in problem decomposition. 
I learned Ruby (and Rails) first then is currently learning/using Python. To me Python and Ruby are like Ryu and Ken. They can be the best of rivals, but can also have a mutual respect/friendship for each other. Python is Ryu. Ryu means dragon in Japanese and the mythological beast Python is based-on is a dragon-like creature. Ryu is also known to be a more solid character than Ken. He's combos are not flashy but they work and are quite powerful. Ruby is Ken. Ken means fist in Japanese and doesn't have something to do with Ruby (I got to say that). Ken is a more flashy character to play with. Someone may argue that Ryu should be Ruby since he is Japanese and Ruby was invented by a Japanese person. But... Do you know Ken is half-Japanese (Japanese mother)? Ruby is half-Japanese half-western since it was originally in Japanese then translated to English.
By saying "I pass the form from a template to a view and then to another view", do you mean that you are doing a ResponseRedirect ? 
You could use phantomjs via selenium webdriver. http://coreygoldberg.blogspot.in/2013/01/python-testing-phantomjs-with-selenium.html I have used it heavily, for a project at work, performs well.
&gt; pyHIDS is a HIDS (host-based intrusion detection system) for verifying the integrity of a system. It uses an RSA signature to check the integrity of its database. Alerts are written in the logs of the system and can be sent via email to a list of users. You can define rules to specify files to be checked periodically. Just in case you don't know what HIDS is.
make your script read/write to a database instead? https://docs.python.org/2/library/anydbm.html
Use JSON, Just run the your long script. at the end of the script you can covert the dic into a json object and write it to a file with a .json extention. Then in the second script you can read that dic back In from the .json file with json.loads.(i think that's the right command. Might want to look it up) Json is built into the standard lib so all you have to do is throw an import json in the top of your scripts. Just look up how to output a python dic to a json file and how to read a json file into a dic. If you need help let know and I can send you a sample script of how to do it.
Hey look! It's this thread again ...
Depending on what your data looks like using [HDF5](http://www.h5py.org/) instead of CSV may be an option.
This is what I was looking for. Thank you! 
Importing a ~600mb csv file into Postgres takes less than 30s using `COPY`, then you'd be able to query your data using SQL without much startup overhead. 
A talk introducing some of the basic tools for scientific computing with python. In particular, it shows how much you can do with a little code.
**Don't convert it to PHP** you will almost assuredly regret that. PHP is a mess of a language. [Like, a huge, unwieldy mess](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/)
Ależ oczywiście.
If your resulting dictionary consists of simple key/value pairs (where value consists of types such as int/long/str) you might want to look at something like Redis. The learning curve is not substantial. If you have more complex data structures your options become more complicated, either layering on top of what Redis provides or using some of the document dbs (mongo, elasticsearch, etc). I don't think using the built in dict type, between processes, is well suited for what you describe.
sorry for the long post, but I had to explain so that I am clear.
I wonder if they are going to add a do...while this time.
Right, I knew slots was to conserve memory primarily, but shouldn't that increase performance as a result? I'd expect less memory management to mean quicker access time when modifying, deleting, creating and garbage collection. But certainly better memory performance. I thought named tuples were quicker than classes without slots defined... You're positive about that? Edit: You're right... ('Normal: ', [0.46281981468200684, 0.4548380374908447, 0.4560990333557129]) ('slots: ', [0.40665698051452637, 0.4022829532623291, 0.4048640727996826]) ('namedtuple: ', [0.665769100189209, 0.6651339530944824, 0.6987559795379639]) Alright, well that settles that. I believe nt is better than a normal class for memory though, correct? And is it better than slots as well?
Have you considered embedding the information needed for the email directly into your user document ? Let me explain my self: let say you have a product A which price has gone down (below base price), what i would do, is to append to a field (lets call it B) a document with all the data needed to generate the email. (Think of it as a queue) Then when you want to actually send the emails, you just have to loop over the list, you only make 1 query t your database. when all the emails are sent, you empty the list.
How about this: Let the product document have another item email ids as list, of the users who are all tracking. Now create a empty set object and call it email_id_queue may be. Now loop through the product, if there is a change add the user emails list to this new set. Iterate through all the products and you will end up with list of all emails of users to whom you want to send emails. 
In response to your deleted comment, I didn't waste all that time for nothing =) Nope, just tested, it's very slightly slower than tuple index access, but just like it about twice as fast as nameduple name access. The stuff looks like this here: * index access takes about 40ns * name lookup takes about 45ns both for usual classes and those with `__slots__`, in fact slots are a tiniest bit slower. * namedtuple lookup by name takes about 115ns To be honest, I can't say how exactly it works out to these numbers, I'd say that the only way to really be sure is to run this stuff under a C profiler. That could be a pretty useful experience in itself From what I can tell from grepping through the code in Vim, it's pretty much a coincidence that the first two things take the same time. Index access goes through a bunch of pure-C redirects until it hits `tuplesubscript` which casts the index to `size_t` and fetches the value from the object itself. Class lookup by name IIRC does two unsuccessful dictionary lookups in the class and `object` attributes, then a successful lookup in the instance dictionary. Slots lookup should do a successful dictionary lookup in the class dictionary then indirectly call a C function that fetches shit by index or something. Namedtuple lookup by name probably involves a pure Python function call, which is slooooow.
My intended use was not teaching, but it could sure be used to demonstrate lots of concepts in various areas!
Okay, so tuple direct index access is the fastest apparently. Makes me wish we had \#define available :/ Is there a good way to do that without slowing things down? like: A = 0 B = 1 C = 2 inst = (100, 200, 300) inst[A] + inst[B] + inst[C] Is there a pythonic and high performance way to do this and keep the fast lookup time of a direct index?
Very nice point. I think adding this point to the blog post would make a better argument about why this is configuration done right.
Checkout Python Data Analysis Library at http://pandas.pydata.org/ Can read csv data and can write out to many formats. pandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language. 
OP here, I wrote this because I wish I'd had something like it as a reference. Hope it's useful to someone.
Very useful, thanks! I've been looking for exactly this kind of tutorial - if it was already out there I couldn't find it.
Glad to hear! I had the same problem - the info is all out there, somewhere, but it's scattered about and not collected in one place.
looks cool, i'd like to see some more query examples though. 
Without trying to sound rude, do they at least do basic scripting to make their lives easier? http://learnpythonthehardway.org/ is a good starting point (the html version is free)
Heh, I like that the article is zero-indexed.
You don't want to do that in Python if performance is critical. Adding three indexed items is not performance-critical. If you have a million+ items, then you install numpy and put your items into a numpy.ndarray, and then vectorize your operations. Like, if you want to add two arrays, you write `a + b` (instead of `for i, it in a: result.append(it + b[i])`) and the underlying library written in Fortran very efficiently does what you meant.
Who knows? Who cares? 16 years is plenty to learn a few programming languages.
Not rude at all. They want to learn basic scripting, most came from networking backgrounds, they are new. They think FOR loop creation is impressive. I want to help teach them in a class room setting. Thats an awesome link. Any idea on some good CS basics first, such as ints vs strings, memory, heap, etc? CS 101 basically.
true didn't notice that until later. but not everything is there and i was asking for advice on how to proceed if you don't have any thing good to add beat it!
Where do you want to distribute it? - for larger audience, that you cannot control, you have following options: 1) create python package and put it on pypi. Then anyone can install it simply by pip install MyPackage. Best method if your users are familiar with python. pip can install code directly from git repositories too. 2) create native packages (deb/rpm/whatever). Preferred way for majority of linux users. 3) Just put it into single zip file and write simple instruction how to use it. I suspect that the main reason existing tools are "failing" is because you want to have full control believing - wrongly - that you know what's best for users, while those tools have wide audience and prevent such behaviour. Either way forget about trying to make it uninstallable. There is no way to do it and you will only annoy users, or worse, actually do them some damage. I would never use any software that is making any attempts to do that. In controlled environment of your company, use chef/puppet/salt.
just for you this is my list of links which can help people learn to code in python. currently going through code academy at my speed. Coursera(Game programming) https://www.coursera.org/ Code http://code.org/ Checkio(Play with Python on a game) http://www.checkio.org/ Invent Your Own Computer Games with Python http://inventwithpython.com/ CompGeom Python Programming(Exercises) http://compgeom.com/~piyush/teach/py14/ Project Euler (Math) http://projecteuler.net/ CodeEval(Find out how you rate against top coders. Unlock awesome startup jobs and hacker deals.) https://www.codeeval.com/ The Python Challenge (solve each level through programming) http://www.pythonchallenge.com/ Udacity(Videos) https://www.udacity.com/course/viewer#!/c-cs101 Codeskulptor(web API) http://www.codeskulptor.org/ CodingBat http://codingbat.com/python Github Python Proyects https://github.com/karan/Projects Codeacademy http://www.codecademy.com/ Bucky's Python Tutorials. https://www.youtube.com/playlist?list=PL0213E8DC3AA8E21B Python Daily Programmer http://www.reddit.com/r/dailyprogrammer Pyschools http://www.pyschools.com/ Reference Books Learning Python by Mark Lut Python Programming: An Introduction to Computer Science by John Zelle.
The number one thing that drives me crazy about Matlab is the *awful* I/O. Most of the built in data reading functions only work with purely numeric data, god forbid that you have text data, let alone mixed text and numbers. When the stars align, you can sometimes convince it to write an Excel file with mixed data, but it only works on Windows. 
The directory needs to exist. You should also prefix the string with `r` or double the backslashes, otherwise it might get interpreted as an escape sequence if you use something like `\n` or `\r`.
This is amazing. Wow you are trying run when you haven't learned how to crawl first, then walk. http://learnpythonthehardway.org/book/appendix-a-cli/introduction.html take a look at how to make directories. Learn you some OS and terminal commands. EDIT: Sorry, looks like you need to look into escape characters or look at this api [doc](https://docs.python.org/2/reference/lexical_analysis.html#string-literals).
Also be sure to check out Binstar! :-) http://binstar.org
For more videos on the scientific Python ecosystem: http://vimeo.com/pydata http://pyvideo.org/category/37/scipy-2013
This reminded me to take a proper look at pandas...and now I wish I'd done that a long time ago. It's an awfully convenient (and more robust) way to do an awful lot of my normal numpy array mangling!
I always considered numpy to be scientists' tools, but I never really thought about how it's fortran under the hood and how it might be higher performance for certain things like that. `a+b` looks a lot cleaner as well. Great advice! Thanks.
This is handy, I'll try these out. Thanks!
So, for instance, some poetry in Perl I know of: http://nickm.com/poems/ppg256.html All of them 256 characters, which is kind of cool. Anything like this in our favorite language?
I've just recently got onto pandas. I'm trying really hard to stick with it, but I'm so often tempted to just use the base numpy class for multidim slicing and numerical operations with broadcasting.
I don't think the reason you gave are good reasons to change languages. 1. Upgrading to a latter version of ruby is going to be easier than rewriting your application from scratch. 2. You should chose technologies based on what you want on your resume, but on what is best for your project. 3. It sucks you have to develop in WIndows, but at least when you get a better machine you can use some kind of Virtual environment which will make some of the pain go away. 
tldr python is a real programming language that can easily interface with other programming languages 
You can *do* that sort of stuff in python, but there's normally a bit more indication that you're heading into crazy territory
Yeah, it's pretty insane that Matlab doesn't give you some kind of warning about what you're doing. [edit]ESPECIALLY seeing as they're targeting people who want to be able to do things like type in "i" for the imaginary unit without having to think about it.
I don't know what else I might end up using it for, but the immediate thing that jumped out for me is it has a great abstraction over a lot of the recent number crunching work I've been doing - creating datasets, scaling them and storing them. I've fallen into a bad habit of jury rigging things with pickle and json files, but it will be much less annoying (plus more reliable and clearer) to do this stuff with DataFrames.
I'm sick and tired of seeing little script like this to do something so common as sending email - Is there a module that's just brain-dead simple to send mail (and attachments) in plain text &amp; HTML that my mom can use ? (I've searched and have no luck)
gotta say zero-indexing is a bit tedious for science stuff. My ideal is fortran indexing, defaults to 1, but can be negative!
Trying to install python modules on windows is like banging your head against a brick wall. I've been trying for two days with no luck. Time to buy a mac. X(
I just wrote several lines about image handling, turns out that PIL is a great and handy tool to get the job done. Though deprecated, there is a forked lib called Pillow, which works the same way and provides py3 support. Just check the [Pillow Tutorial](http://pillow.readthedocs.org/en/latest/handbook/tutorial.html) out. btw, if you are under Windows, there is a binary package of Pillow in: http://www.lfd.uci.edu/~gohlke/pythonlibs/
Awesome Thanks!!!
Another good article: https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/
It wouldn't matter if Matlab didn't also use "i".
The simplest solution is to use the dbm module (https://docs.python.org/3.4/library/dbm.html) to store your data : - it's pretty fast (on Unix at least) - it's in the python stdlib (nothing to install) - it has a similar API than dicts - it's portable (you can read it from another language) If you look up several times the same keys I suggest you keep LRU cache in memory with a dict and with a limited number of keys to avoid using too much memory. So: - First time you run, you save your dict in the Berkeley db - For your second time you run, you make your look up into the db. Optionally, if your data set allows it : - Every time you make a look up, you store the key in memory (don't forget to limit the number of keys) so the next look up for the same key is very fast 
Question: How come when I try to do "tiff_img.show()" i get a blank white screen? 
Consider posting things like this to /r/learnpython in the future, thanks!
And also has the advanced linear algebra and data analysis tools that Matlab provides.
I use both Python and Matlab a lot. I've tried to use numpy, and I use it when I have to, but honestly the syntax for common data wrangling functions is awkward - with Matlab, you can do x' to transpose, [x;y] to concatenate, etc. With Python I have to look these up every time. And why are there both nx1 and nx0 dimensional arrays in numpy? Seriously? I use Python for lots of things, but for strictly numerical computation I'd use Matlab, and for data exploration and visualization I'd use R. I really appreciate the effort put into Python scientific software (I've contributed myself), but for day to day use it's not my go-to language. iPython notebooks are awesome though. edit: grammar
I worked in a pure Matlab shop, so I have some opinions on this issue. Matlab indeed has some severe shortcomings, but so does Python. I was the only person in my group at a certain "administration" focusing on aeronautics and space using Python for real work; everyone else was on Matlab. I did get one coworker to convert, but he eventually went back to Matlab because he "needed to get work done." His comments were: * Figuring out what to install from where is terrible, especially for Windows users. And before we jump on the "why would you use Windows!?!" bandwagon, we can just start with his being baffled by which Python version to install (3 or 2). Matlab just required one installer. I realize the commercial Python distros do solve this, but not having used any of them myself, I couldn't tell him which was "good." * Documentation in Python wasn't even in the same league as Matlab. I strongly agree with him on this one. Matlab's docs are easy to access and complete. Python's are scattered about, occasionally misleading, and often nonexistent. * The Python syntax was considerably more verbose (numpy.vstack((A, B)) versus [A;B] for example). * Python doesn't have Simulink. Or the Controls toolbox. Or the &lt;insert whatever here&gt; toolbox. While there are equivalents to these in Python (except Simulink), they often aren't nearly as mature as Matlab's offerings. For my work, I did have to spend some considerable time implementing routines that already existed in Matlab just so I could use Python. I don't regret it. Quite the contrary, it allowed me a chance to present my work at PyCon 2011. But sometimes it's hard to justify writing yourself a discrete algebraic Riccati equation solver when the *dare()* command is just sitting there in my (US$12K) Matlab installation....
I *used* to work as a controls engineer, but I moved on to other things around 2012. There was a huge amount missing in Python with regards to that field. For example, I had to author a good bit of code involving discrete linear time invariant systems; at the time, SciPy only supported continuous lti systems. That code is now in SciPy. However, that was the type of roadblock I regularly hit when trying to work in Python: it simply lacked implementations of things I needed. In reality, Octave's controls toolbox is actually quite complete. If you were thinking about staying open-source, you might consider writing Matlab code that runs fine under Octave. Just make sure everything actually works on Octave; it's still missing a few things...
This is the exact reason I hated matlab. I shouldn't have to come up with some hacky solution to a non-problem like having one damn column be a different type than the others. Super frustrating when you're trying to make a deadline with a project.
pandas is much nicer to work with than using numpy directly
People use single letters for iterators all the time. Single letters are even mentioned as a standard naming convention by [the creators of Python's guide to proper style conventions](http://legacy.python.org/dev/peps/pep-0008/#descriptive-naming-styles). They just say to avoid using I and O for obvious reasons.
But then your supervisors know only Matlab...
Also, while I like your "just use x, y, z and use a comment to say what each means", it can potentially be worth a more descriptive loop variable depending on what you're doing. Especially if it's a pretty long loop. It could quite likely enhance readability if I don't have to keep scrolling up to the comment to remind myself what the loop variables mean. *But*, isn't looping over "i" *extremely* ubiquitous? I can't imagine that you'd manage to find someone who can program but wouldn't immediately figure out what you're doing you do a "for i in &lt;whatever&gt;" loop. (As I stated in a separate comment here, I do use "index" instead of "i" if I'm doing a list enumeration, but mainly because I myself can never remember whether the index or the value comes first in a Python list enumeration so I don't want to have to look it up the next time I look at the code.) Or if you know that you're looking at code that's about plotting points in 3D space, xyz coordinates are so standard that, again, there's no reason *not* to just use xyz. Also, for both i and xyz, and I'd imagine that each is so ubiquitous that you'd probably actually be *hurting* readability with longer variable names in most instances. (If you're dealing with some 7-dimensional matrix-like object, for instance, then yeah, I could see the value in using loop variables that say what each dimension is instead of trying to loop over ijklmnop.)
The python GIL isn't all that great but it still beats what ever matlab does for parallel processing.
Why C is better than Python for Scientific Software... Why FORTRAN is better than C for Scientific Software...
The [Python Packaging User Guide](https://packaging.python.org/en/latest/index.html) is meant to be this. I can't speak for how good it is. Personally, I started by learning [distutils](https://docs.python.org/3/distutils/index.html) before it was fully deprecated, then skimmed the [setuptools docs](https://pythonhosted.org/setuptools/setuptools.html) (which IMHO are ridiculously unhelpful to the uninitiated) once it became the Right Thing to use. The distutils docs are still up there, albeit with a warning not to use them, and they are quite detailed if a bit dated in places.
Nice article. If you pass "include_package_data=True", then setuptools will include data files specified in MANIFEST.in. No need to specify package_data separately. See https://pythonhosted.org/setuptools/setuptools.html?highlight=include_package_data#new-and-changed-setup-keywords Also, I find "global-include" handy for the manifest file. You can add lines like: global-include *.md global-include *.txt global-include *.csv Setuptools will grab all matching files anywhere in the source tree and include them in the package. Python packaging is confusing. This was the first article I read that made me realize, for many cases, it can be quite simple: http://flask.pocoo.org/docs/patterns/distribute/
Matlab's debugging is better, I think. When you get into trouble, you can do a &gt;&gt; dpstop if error and then inspect quickly till your heart's content &gt;&gt; imagesc(m) &gt;&gt; line(x, y) or whatever. In Python, you have to use something like PyCharm, and you have to ensure you either have matplotlib imported, or import it when it drops you into debug console on exception and do &gt;&gt;&gt; imshow(m) Traceback (most recent call last): File "/&lt;basepath&gt;/anaconda/lib/python2.7/site-packages/IPython/core/interactiveshell.py", line 2883, in run_code exec(code_obj, self.user_global_ns, self.user_ns) File "&lt;ipython-input-2-ed6e4087078d&gt;", line 1, in &lt;module&gt; imshow(m) NameError: name 'imshow' is not defined "shit, that's right, gotta import matplotlib"... &gt;&gt;&gt; import matplotlib.pylab as pylab &gt;&gt;&gt; pylab.imshow(m) &gt;&gt;&gt; pylab.plot(x, y) &gt;&gt;&gt; pylab.show() 
Try http://www.codecademy.com/ it is an interactive learning website which can help you learn python. They will learn things such as: python Syntax - String and Console output - Date and time - Conditionals and control flow - functions - lists and dictionaries (data structures) - loops - file in/output. The website got their own implemented interpreter, which also help them learn more. I really recommend you trying it out. The new bostons youtube tutorials is also really good and easy to understand: https://www.youtube.com/watch?v=667ZeuZ0Q8M
Check out the multiprocessing module if you are worried about the GIL. I work with it in my day job and it it does allow parallel processing. Side note: if doing multiple processes with CPU tasks, you only get the max processing power with 1 process per CPU. 
Helpful, thanks!
You can approximate MATLAB's debug behavior by inserting the following line in your code. import IPython; IPython.embed() Edit: formatting.
Yeah, the User Guide that looks helpful. For some reason I hadn't come across it.
You can really go anyway you want with this. My point was to counter point the snootiness above me. My standard for large code bases is to `from collections import namedtuple` Then you can have immutable objects in an iter-able and reference its properties by name. For example, there's a decorator I use at work that maps SQL columns from a DB result to a namedtuple so I can access the row's values by name instead of index. That way a lot of my for loops actually look like, servers = Database.get_connection(config.connection_object).execute_stored_procedure(..., coerce = Objects.Server) for server in servers: print server.ip, server.fqdn, server.environment Or, I've been known on occasion to do something like, s = self.current_pool[index] # server assert s.ip is ... assert s.fqdn is ... Long method names aren't a bad thing, unless they get in the way. The same with short variable names, or ambiguous definitions, functions, classes, etc. It's whatever works best for you and your team.
Finally, a guide that lays out how to use twine. Thank you for that. Some notes: * `python setup.py test` isn't just for testing the build (I didn't even know it did that), you can also configure it to run your entire test suite. Speaking of test suites- your guide doesn't cover where to put them. * You have all the information needed for setup.py IN setup.py. This means it's either duplicated in your main python file or not there at all. This includes critical information like version. For a lot of python projects, you can just call `modulename.__version__` to get the version number, which is awesome. **You don't want to be updating metadata like that in two places everytime you version, etc** I've been working on an automatic as possible `setup.py` file that still does everything... it's missing some things you talk about, but has a lot of the stuff needed for a basic module with no scripts or C extensions, etc. https://github.com/ThoriumGroup/thorium/blob/master/setup.py It's not perfect, but right now it only requires that you modify the classifiers, keywords, find_packages, MANIFEST.in, and your module name. Set those up once, and you only need to update the `__metadata__` in your main `__init__` file thereafter. Edit: Added `code` around `__` to avoid __bolding__
Good call on the setup.py. I didn't end up putting much of the information in the main package file...though perhaps I should. I agree that duplication should be eliminated as much as possible. Also thanks for the setup.py. I'll take a look.
Hehe extremely long dict
Define "real". In my mind, a "real" programming language compiles the program to an executable that doesn't require installing the language and some unspecified number of libraries. Of course, that's just my opinion.
I think most computer scientists would define a "real" programming language as Turing complete: both of which Matlab and Python satisfy.
For anyone wanting to check out pandas, here's a link: http://pandas.pydata.org/
One more thing- I think you should split writing Sphinx documentation and converting it to html etc to another article. It's a topic as broad as setup tools itself, and it's really an aside to this.
So I have been writing/modifying data acquisition software for a new amplifier/interface board that my lab got recently. We have an existing matlab codebase that uses the old analoginput module that only works on 32bit windows. Python is my go to language but I decided to help the other guy's out and try to get the new hardware to interface with matlab. Long story short, matlab's mex files are completely useless for interfacing with hardware and unless I wanted to write my own DLL or use loadlibrary and recreate a couple thousand lines of C++ acquisition code that had to be exactly right (or things go boom) in matlab, I was out of luck. So I said fuck it and have been modifying the existing C++ based program for the past 2 weeks because that is prefereable to working with matlab. I HATE closed source systems. If I could have seen how the mathworks guys had written their new session based analog input then they would have gotten a new piece of hardware implemented on their platform for free. tl;dr matlab is a terrible platform for hardware developers
My definition is subjective. BrainFuck is not a real language. MATLAB and Python are. For me a real programming language is one that I could develop something non trivial in without wanting to blow my brains out 
Have you asked on the cython mailing list?
To your TL;DR: I would have thought that would be obvious.
I believe blender has a python api, although not sure if it can be ran externally or not. http://www.blender.org/documentation/blender_python_api_2_71_0/
I agree with /u/dagmx's [comment](http://www.reddit.com/r/Python/comments/296hil/how_to_teach_a_team_of_operations_how_to_program/cihzmxm). Don't bother with things like memory management and the like. Focus on making them productive with scripts as this will encourage them and set up a good foundation. You can worry about memory management later as Python handles all of that on it's own.
That's exactly why you should use whatever you want to: They know only MATLAB.
At the age of 42 my professional experience (outside of Python, to which I'm a newbie) is that the most common names for a variable when you just need to do something x times like in the MATLAB example are "x", "temp" and "loop". :-) I honestly don't know how much more descriptive you can get. 
But you wouldn't want to sit down and do your higher-level work in C. At the end of the day the Fortran and C are all assembly.
Python is a *general purpose* programming language. FTFY
The multiprocessing module is simple and elegant and is far superior to the low-level threading functions provided by the statically typed, compiled language I'm coming from. One needed a 3rd party library to get close to the elegance Python provides out of the box. I see all this complaining about the GIL when in reality Python has some of the nicest built-in parallel programming support I've seen. Unlike before, I no longer view parallel execution as a huge, complex, frightening process filled with danger ("The clothes I'm wearing are machine washable - BUT ARE THEY THREAD-SAFE?!?") that I sought to avoid because the effort wasn't worth the reward. It's simple, beautiful and safe. 
Fix your pycharm to run fast by switching to anything else.
Yeah, I don't have the experience you do, but I tend to just use x. It's practically a reserved word to me at this point. I imagine new programmers being taught to use carefully chosen variations of "mySuperDescriptiveVariable" for iteration variables and it makes me feel itchy. The use of i, j, and k are also popular for nested loops.
Unless you're actively developing Python for something Windows specific, I do no know why you'd set up a Windows development environment. A simple 1 core, 256mb Debian virtual machine can run happily in the background.
You can use blender in non-interactive mode or background mode with the **-b** flag. 
You mean python 2. So you should say python 2.
&gt; Matlab is not [a real language] When I see that I stop reading because I can tell the author intends to be inflammatory rather than presenting a set of factual arguments. Matlab is in fact Turing complete; only that it is more difficult to do certain operations in it.
Actually it's easier with python because getting me to pay for MATLAB isn't going to happen.
python has a debugger, that you can start on exception.
I wish I never have to see an article like this again. It's ridiculous, you won't find any one comparing hammers and screwdrivers as a god sent solution for all carpentry. I might have bought it if the article was a bit more specific, say comparing python vs matlab expressiveness for a particular computing task. Different tools will always be good at different things, that is an inherent property of being different (as a tool). No single tool will be good at everything. Stop trying to make whatever your favorite might be, the best at everything. It is almost certainly not the case. If it's not Haskell, *of course*.
It depends very much the level of Python they require, and if they value more your Python level or you general problem solving capabilities and IT knowledge. I'm going to ignore problem solving skills and general algo knowledge, as it's not particularly tied to Python. There are plenty of of blog posts about it on the Web. For Python, a standard dev should : - to be able to write in a Pythonic manner (idiomatic style, PEP 8 syntax...). You seem ok on these points. - know the stdlib and python ecosystem. I can't test that, but you should have no problem with pip, virtualenv, handling datetime, os.path, hashlib, uuid, csv, pdb, json, all collections (including sets() and stuff from the collections modules). - know OOP basics. Inheritence, overloading, properties, composition, etc. You seems ok with it. And advanced Python dev should be able to write nice libs, and so : - is ok with generators (and yield) - can craft it's own decorators - can craft it's own context manager - can craft it's own descriptor - knows how to handle multiple inheritances, dependancy injection, etc - make a lib from A to Z, including an clean flexible extended API, packaging, documentation. - setup unit tests An Python expert should - knows about most important 3rd party libs for most common task and know the names of most frameworks and what they can do - craft it's own metaclass - master introspection - know how to bypass most Python weaknesses : handle the GIL, deal with blocking API, create non blocking code, create code compatible for V2 and V3, etc - is confortable to take a project without doc, read the source code, figure a problem, and monkey patch it while offering a patch upstream - use difficult or little know modules such as heapq, inspect, nmap, etc Depending of your field, you also may need to be able to : - integrate with alternative Python implementation - write c extension - know your way around very specific libs such as numpy, scrapy, opencv, etc.
How to teach CI is one of the most underdocumented things ever. I could write pages and pages about it, but pratice, trial/errors and introspection then talking with collegues is still the best way to go. I'll give some advices though : - nothing is obvious. Nothing. - drop power points. Hands in the shell. Practice is everything. - teach one concept at a time. Don't mix. It's very hard to do it properly. Reguarly, look at them struggling, and check if you can't REMOVE something from the exercice. - etablish a clear skill tree you want them go climb, and follow it. Don't teach yield before comprehension lists, comprehension lists before loops, loops before lists, lists before strings, string before basic maths, etc. - teach debugging early. How to debug logically, but also the tools to debug (pdb; pdbpp, remote_pdb, etc). They need it. - python has dynamic typing. It means people must take the habbit to know what type they are manipulating. Every 10 minutes, ask "what type is this variable". Seriously. - get rid of complicated IDE. A clean text editor with syntaxic coloration and the console is the best way to start. - but introduce nice tools on the way. A nice shel (bpython or ipytoon) with code completion. A plugin for their favorite editor. Stuff like grin, pyped, python -m SimpleHttpServer, etc. - don't be too serious. Have fun. Make sexy images grabbers, drug benefits calculators, the hours people are missing at work chart generators... - introduce little by little the ecosystem : virtualenv, pip, 3rd party lib. Introduce the nice stuff like requests, arrow, docopt, bottle, peewee, beautiful soup, path.py, etc. - be a nazi with variable naming. If they forget about docstrings, comments and all the rest, at least reading the code will have some sense. - utf8, 4 spaces indent, from __future__ import print_function, divison, unicode_literals, absolute_imports. Around the 4th day, you have to require them or it will kill you. - you will have to give them "the talk" about encoding in Python. There is no way around it. - iteration is everything in Python. Put emphasis on that at every step. Eventually, using generators to filter iterables is like using grep, sed, awk, etc. Show them that. - spend some time to find libs and receipes that are specific to their line of work. You want them to be able to use quickly what they learn. - make sure you cover most common errors in python : decode erros, python path errors, mutable object in parameters, implicit string concatenation, empty generators, etc. Everybody encounter them. You will save them dozen of hourse if you just spend 5 minutes on these. - make parallels with what they know : if they know bash snippets to Python snippets, emphasis differences, convert old scripts to Python as exercice, etc.
On the Windows end: install python(x,y) or anaconda. Either of them will get you a full distribution -- but indeed, there's no clear way to find out about this other than having someone around who knows.
(Original author here): Point 0 of the post is that the argument is not that you should switch from Matlab, but that if you're starting from a blank slate, then it is often an inferior option (what to install is an issue with Matlab too, and I've had problems with code which wouldn't run after a Matlab upgrade; it's just that you've already solved those for Matlab). So, if Matlab works for you, use it. Also, yes, simulink seems to be a Matlab killer app in some domains.
Why? Is there too much implementation difference between them?
MEX is pure evil -
Fair enough, I think the quotes are a suitable modifier, and distinguish between practical (python etc) and "real" (prolog, ml, python etc)
Can you use PyQt with Python3 now? I didn't find a good guide.
While I agree that being a general purpose language gives Python some advantages over domain-specific languages like Matlab, I must say that it is also its biggest shortcoming when all you need your computer for is scientific computing. That's why I started looking more and more into Julia for scientific computing. It has the advantage of being Free Software and only does scientific computing and does it very well.
So much correct!
It doesn't seem to be mentionned in their documentation but [youtube-dl](http://rg3.github.io/youtube-dl/) can also download subtitles.
For one click install, you can use Anaconda python distribution which contains all the packages you need https://store.continuum.io/cshop/anaconda. It's free software, which works like charm even on Windows. 
&gt; only does scientific computing this is not, strictly speaking, true. Julia can do pretty much anything, it's just that it is catered to scientific computing. But there is nothing stopping you from writing game engines in it, for example.
I recently heard of swagger and am looking at using it in another project of mine to accomplish a similar goal.
i was summing the parts of the article that I thought were worth reading. 
Interesting, I view them as a: "I know I'm not using this term properly but you should get the idea" most of the time, and sometimes sarcasm. Linguistically I think they are a great construct because it allows more flexibility without stepping on anyones toes, upping the general clarity of the discussion. Have a good day!
So true. Even as a regular MATLAB user having to default to cell arrays to effectively collect mixed data for writing is pretty frustrating. There's always `fprintf` but if you've got a lot of columns of data it can be more annoying than the alternatives. This has been mitigated somewhat with the introduction of [tables](http://www.mathworks.com/help/matlab/tables.html) in R2013b but it's hard to get into the habit of using them when I've grown used to the alternatives over the last 7 years. 
Factually incorrect? Tell me, how is my definition "Factually incorrect". What "fact" am I violating? AFAIK there is no commonly accepted definition of "real programming language", but if I were to use it while communicating with someone I would be thinking of a language that is commonly used, not languages like Brain Fuck. If someone said "turing complete languages" then there is a strong definition and acceptance for what that means. "real" does not by any stretch of the imagination translate directly to "turing complete". Stating that my definition is "factually incorrect" just makes you sound like a tool.
&gt;Documentation in Python wasn't even in the same league as Matlab. I strongly agree with him on this one. Matlab's docs are easy to access and complete. Python's are scattered about, occasionally misleading, and often nonexistent. I agree with every point except this one... in fact, I vehemently disagree. If you've ever had to resort to the Matlab file exchange, you know that documentation is all but nonexistant. As for documentation in large, popular libraries, I've always found Matlab docs to be cryptic, lacking in examples and useful errors. Out of curiosity, did you have any specific libraries in mind (both on the Python and Matlab end of things?) Out of fairness, I'm thinking of the following python packages with outstanding docs: - Pandas - Scipy/Numpy - Statsmodels - Matplotlib (though not quite as good as the above) If there's one thing Python does really well, it's documentation. **Edit** &lt;cheapshot&gt; Concerning *getting things done*, I don't see how that argument can be made in good-faith seeing how often matlab fails to start because of some licensing server issue. When you can't even start the damn thing and have to resort to piracy *despite* having paid over $2000 for a license, saying "it lets me get things done" strikes me as "I tried it for 2 days and didn't like the significant whitespace" &lt;/cheapshot&gt; ;)
It's admittedly a bit less user-friendly, though.
&gt;when all you need your computer for is scientific computing This is never really true, though. Case and point: matlab can't read text files out of a wet paper bag. That kind of boilerplate functionality is really important in the scientific community for data portability and whatnot.
Any way to make your text bigger? I think your comment is a bit understated. I'm not being sarcastic.
Excellent reply. I would insert at the head of debugging tools the simple, lowly print statement.
Good god... watching matlab try to read formatted text is like watching a little boy get his dick caught in his fly...
[Joblib FTW](https://pythonhosted.org/joblib/)
Was gonna ask why isn't there an Octave/Python module out there, and sure enough I found oct2py. Have never used or heard of it though...
Have you ever used Matlab? (Honest question!) Matlab is the PHP of scientific languages. It's not that Python is sooooooooooo greeeaaaaaat *ohgodineedtochangemypants*. It's instead that Matlab is the proverbial [double-clawed hammer](http://blog.codinghorror.com/content/images/uploads/2012/06/6a0120a85dcdae970b017742d249d5970d-800wi.jpg). Need to read formatted text? You *can*, just like you can technically beat a nail into a plank of wood with a double-clawed hammer. It's just going to do a really messy job.
Matlab file exchange is terrible, I can't disagree with you there. I was referring to Matlab's official documentation that is installed with their product and each of their toolboxes. It's all located in one place, reasonably complete, and includes detailed references to how routines are implemented. Many of their documents actually include statements like "This routine uses SLICOT to arrive at a solution..." pointing out the actual underlying, hidden Fortran routines that are being executed. That type of information is actually quite useful when trying to figure out what's going on. The fact that everything in the official Matlab distro is accessible offline in a single help browser is a huge bonus too. I don't have any problem with Python's documentation or its standard library docs (generally... there are some lacking points). However, I don't like having to go to 3 different websites to find Python's, SciPy's, and Matplotlib's docs. I know it seems trivial, but it can be a problem. Furthermore, I just don't think that NumPy and SciPy are quite as well documented as Matlab (which I considered excellent documentation-wise). It's moderately subjective, though, so please do feel free to disagree. Both NumPy and SciPy are good examples of well-documented libraries. I have run into documentation issues with Matplotlib and smaller libraries. At the time I was using it heavily (a few years ago), Matplotlib's documentation was a bit difficult to navigate. I mostly relied on copying their examples. I was also using scikit-learn quite extensively, and the docs for that package were also less than ideal. At the time, a few of their learning algorithms had zero documentation, making them useless. Now don't get me wrong, I did use Python for my work, and I was quite successful at doing so. Was it better than Matlab? In some ways, yes, in others, no. The documentation, though, was a pretty hefty stumbling block.
Conda still needs a GUI.
to expand on my last comment, it's really easy to create various physics simulations in 2d, angled slopes, varying friction, gravity, elasticity, etc. I just uploaded a double pendulum while typing this, creating a gravity zone and getting things in orbit is also quite quick The scripting system could be handy for learning about python, kivy, cymunk and kivent - but there are probably better ways
Re: your edit I never once had a license server issue, but I personally had a named license, not a shared license. I would consider Matlab's enormous licensing costs a major down side. Your "didn't like the significant whitespace" comment was a cheapshot. I was dealing with smart people, not the apparently trivial, whining engineers you're assuming I worked with. 
That's fair enough. I'm one of those people who rely on google much more than in-app documentation (even though I arrive at the official help pages), so the location of the documentation isn't really an issue. I can, however, see how this would irk newcomers who are used to just typing `help(foo)` and knowing everything there is to know about `foo`. &gt;I have run into documentation issues with Matplotlib and smaller libraries. I suppose our point of disagreement is the implication that things are different in Matlab. Smaller libraries have exactly this same problem, and I've (personally) found it to be worse for Matlab. Python has a pretty strong documentation culture, though your point about the underlying FORTRAN implementations is well-taken. Maybe it's because we don't use the same stuff? I'm in cognitive neuroscience.
It is very different. Swagger is a standard for describing your API. It requires that you design the API yourself. Hypermedia API is the idea that RESTful API should be self descriptive. Collections+JSON is one of the standards for sleft descriptive API. Collection+JSON does not "describe" your API. It is a constraint on your API that makes them self descriptive. Alternatives are XHTML, HAL and Siren. What we did here is to allow you to specify which database tables should be exposed (any database), which fields of those tables, and which methods (GET, POST, etc.) and everything else is created for you. You have no choice in designing the API. They simply follow the Collections+JSON standard by the book so there is no choice to be made. There are tools that based on the API can automatically generate forms and tables because they do follow a standard. We are working on creating more of those tools. EDIT: [read more](http://amundsen.com/media-types/collection/)
Unlike Matlab, you have to declare a new figure explicitly if you want to edit it in multiple steps. Try this: import numpy as np plt = figure() # this is the line relevant to my comment plot(range(10), np.log(range(10)) / 2.2) title('Profound Truth') xlabel('Number of sexual partners') ylabel("Probability that it's not just an ingrown hair") show() # this usually helps too
I do find Python just awful on Windows. I instantly really miss the tight integration on Mac and Linux.
That didn't seem to work, maybe I'm missing something entirely. I'm on OS X 10.9 and from the terminal I open an IPython window using ipython qtconsole. Then I do %matplotlib inline in the IPython window. From there, if I run those commands it generates the plot after the plot(range(....)) command, and then when I run title('..') it still creates a new blank plot.
what?
http://python3wos.appspot.com/
I was developing some mex file. It should run on Windows, Mac and Linux. A single license is good for two installations... What else is there to say?
&gt; x is Turing complete When I see that blah blah 
I agree that MATLAB is Turing complete. So is the Wikipedia markup language. This is the difference between necessary and sufficient - it is necessary for a real programming language to be Turing complete. Turing completeness, in and of itself, is not proof that something is a real programming language. I would say that C is a real programming language. I would say that Wikipedia's markup isn't. Where you place MATLAB on that scale is subject to debate. I basically classify it as syntactic sugar over a BLAS package - but I never liked MATLAB. I didn't find the article well reasoned or well written. Despite this, I agree with the author's general premise that MATLAB is more harmful than helpful Specifically, it promotes a style of programming that is harmful in the extreme by making functions and classes substantially more difficult to implement than is appropriate. 
Per the OPs first point -- many new adopters would be more comfortable with a GUI tool to browse, install and upgrade packages. An attractive frontend to conda and pip would make a big difference to package management and discovery. 
Hm, fluff is nice but I disagree about it being a must have. Engineers and scientists are supposed to be more rational than that.
http://py3readiness.org/ http://python3wos.appspot.com/
Instead of running `%matplotlib`, try `from matplotlib.pylab import *`
Sorry about the english though. Not my native language and I don't proof read much.
It's 2014 and ease of use shouldn't be dismissed as "fluff" or "irrational". There're no point arguing that point and clicking isn't easier than figuring out a command line program. I've tried to convert several engineers from MATLAB, and stuff like having to resort to terminals is often times a bigger issue than one would expect.
This is also a very good point. Let me expand on that. Any time you're doing one of the following things, you'll spend more time wrestling with matlab than getting things done: 1. Using a shared license 2. Writing a mex file 3. Working with strings or text files
So much +1 on twisted. It's such a powerful lib that porting it must be very complex, but it's so frustrating.
&gt;just as you said, I wouldn't want to write a game engine in it The issue here is that I wouldn't read text data with matlab, either. It's utterly incapable of working with strings in any sane way. This is basic stuff that's absolutely essential for scientific programming. It's not that Python is amazingly good. It's that Matlab is amazingly bad.
&gt; only that it is more difficult to do certain operations in it. Which is exactly what people mean when they say it isn't a real language. Yes, there are more eloquent ways to put it, but the point remains the same: Matlab is not, in any sense of the term, a general-purpose language.
Have you tried the Anaconda distro, as mentioned above?
Python 3 ~~Wall of Shame~~ [Wall of Superpowers](http://python3wos.appspot.com/) 
Was waiting for this. Yay! btw, just came to notice support for Python 2.6 is dropped.
&gt; It's not that Python is amazingly good. It's that Matlab is amazingly bad. I must agree here!
That does help a lot, I actually use Anaconda on all my machines but I get in loops of thinking "right, I'll just open a terminal and... hang on, let me think." I can't claim to be doing scientific computing on python but my response has been to use Python as a sort of write-once language. Develop on Mac and run it on Windows purely because it so happens that my Windows machine is a bit beefier or on Linux because that machine is more energy efficient etc.
Here you go http://py3readiness.org boto(official python 3 support coming soon), MySQL-Python (there is pure python implementation wit py3k support but people say it's bit show), Twisted etc.
Yes, but work is in progress. [Here](http://twistedmatrix.com/trac/wiki/Plan/Python3) you can find a full list with already ported modules.
I've given up on converting people. I rather have my superior(smirk) tool at the cost of ease of use and let them deal with their pirated MATLAB copies.
Results in the same behavior
IIRC those "auto py3k checkers" all have the same flaw: they use the tags on PyPI to assess readiness, but I find that most packages don't bother including that information or don't update it when they update to a recent version of Python.
Application init code is my killer feature in this release.
Are there python 3 only packages? Just wondered. 
Didn't I just see this posted on stackoveflow? 
Thanks! It seems like most of the imported packages are web or network related.
You can easily convert the hex into binary data. Then I'm sure any audio library that support MOD formats (like PyGame) would play it.
You might like to look into [yt](http://yt-project.org/). Also [SimpleITK](http://www.simpleitk.org/) packs some of the most refined algorithms in the field in a very managable package. At the end of the day, you're working on something pretty sophisticated, perhaps something to keep in mind...
[Amazon Web Services](http://aws.amazon.com/), I had multiple scripts running on it pulling data from twitter, RSS feeds and scraping web pages all feeding into MongoDB. it was all very easy to setup and when I did, I was basically in the same situation as you. Plus it's cheap or free (first year with limitations)
That Kickstarter way exceeded it's goals.
web2py
Here are some websites I saved. Working through each question actually taught me more about Python: * http://www.reddit.com/r/Python/comments/1knw7z/python_interview_questions/ * http://thereq.com/q/best-python-software-interview-questions/google * http://techmyway.wordpress.com/2011/06/17/python-interview-questions/ * http://careerride.com/python-interview-questions.aspx
PyQt5 only makes Python 3 binaries available for Windows. While PyQt5 itself is compatible with Python 2.7, the difficulty of self compiling Qt and PyQt on Windows makes PyQt5 pretty much Python 3 only on Windows.
This is a small Python package I've been working on to make it easier to work through Project Euler problems. It handles both the creation of "template files" containing the problem text as a docstring and also checks the output of each file to verify if it outputs the correct solution or not. Since Python tends to be a language that many beginners (myself included) learn, I figured it would be useful to share it in case others are working through or want to work through Project Euler problems. This is my first ever Python package, so hopefully I didn't do anything too catastrophically wrong, considering I'm still fairly new to this stuff. I wrote more about the development in more detail on [my blog](http://kevinyap.ca/2014/06/eulerpy-streamlining-project-euler/). **Edit:** Was doing some last-minute changes with `setup.py` before releasing and only just now realized that the package did not automatically install `click`, so I've fixed that now.
I start new projects as Python 3 only, like [astsearch](https://pypi.python.org/pypi/astsearch), though I generally add Python 2 support if people ask.
Two cool things for me: *The new add_error() method allows adding errors to specific form fields.* *The dict-like attribute errors now has two new methods as_data() and as_json().* This will be way easier for working with AJAX forms now!
you are right about that. Personally, I have sent many pull requests to update trove classifiers. I think it's important to include as much information in setup.py as possible. In some cases, so called "auto py3k checkers" have manual override method to show whether a package supports Python 3 or not.
when you call ipython, do you call it as "ipython -pylab"? 
That site does re groups also (bottom right, "match captures"). And why should I download an app when this works perfectly in my browser?
Thanks for the suggestion. Was there a particular guide that you found most useful or did you just use the tutorials on the AWS site?
Hey there. Sorry for late reply. I guess you need to install 'python-gi' package and python3-gi. If you use Synaptic Package Manager, it can be easily installed from there. Otherwise visit this:[python-gi](https://packages.debian.org/sid/python-gi). Download the package and install it. I hope it helps. Otherwise, let me know.
desmoulinmichel and machstann point is about how much you will learn / expand your mind when **learning** a new language. Not whether it is better to develop with or not. As far as concepts and paradigms Ruby and Python are practically identical. Contrast with Lisp, Erlang/OTP, Forth, Assembler. Learning any of which would actually learn you something worthwhile. If you know Ruby or Python you already know the other. Just have to learn syntax and stdlib. Trivial and fulfilling study.
Heroku might be a nice fit for your use case. * has a built-in [simple scheduler](https://devcenter.heroku.com/articles/scheduler) which, judging from your description, will be enough for you, * provides preconfigured databases as a service ([10k rows for free](https://www.heroku.com/postgres)—I do a similar data-collecting task and in my use case it's enough for about a month; so I just dump the contents once a month to my local database and clear the online one), * assuming that your tasks are bound by rate-limiting, and not by cpu, you won't pay for cpu time at all ([one worker monthly is free](https://www.heroku.com/pricing)), * frees you from system administration overhead.
I posted it here bc when I come to r/python I like to find interesting things that are going on in the entire Python world. Because the SO post is in Python and the O'Reilly class is also in Python I felt it would be something the community would be interested in. 
https://www.pythonanywhere.com/
Your link is bad or malformed. For visualization library check out matplotlib.org and its gallery section. There are others but guessing you need something that can handle math heavy stuff then you should probably go with that first.
I usually go with ix for a short index, use collections/enumerators in python and always use Unicode Greek in python.
As an example, I've been using flask-sqlalchemy with python 3 even though it's not listed as python 3 compatible according to [python3readiness](http://py3readiness.org/). You can see [here](https://github.com/mitsuhiko/flask-sqlalchemy/blob/d4560013c1c51ef035381e35dd42a1628bb212ee/CHANGES) that it supports python 3.
Yep finally got it working as I needed.
&gt; the difficulty of self compiling Qt and PyQt Can you explain that a bit more? I still don't understand why Python 2.7 builds aren't available. 
Apparently it's in the development branch of 3.0, which is due in February. 
I think Digital Ocean http://digitalocean.com will fit your need. 
[Try This](http://bost.ocks.org/mike/algorithms/) [Or This](http://bl.ocks.org/mbostock/70a28267db0354261476) Those were the type of things I were going for. I know that matplotlib can do some great graphical work - I use it for a arduino real time temperature graph- but more of algorithmic visualization. 
This is literally the best company I have ever interacted with. Amazing services, customer support and infinite tutorials.
The flip side is that because web based software does so much more with text, it's harder to change existing code to support Python 3 than it is for scientific code that deals more with numbers.
Nice bro
The code works fine on my computer. Did you pass the right filename or path? But how would you like to convert a grayscale image to rgb, it would still be gray anyway.
Congrats to the Django team. This release looks awesome. Reading the release notes, I was surprised to see the admin-forms timezone thing in there: I've been bitten by that before.
Nothing I can think of off the top of my head. Really anything online about running python on Linux is what you need to look for.
Can you offer a use case? I read about that and was having a hard time imagining how I could use it.
I did not know this. Further investigations shall follow. Thank you.
Signals - before there was no great place to put them. Generally (I think) they were placed in models.py but in some cases it would be imported more than once leading to duplicate signals being executed for one signal (which was eventually solved by setting a dispatch_uid). Now you can connect your signals in the init code, which will only be called once.
Try it for feature and usability comparison. I am passing on good advice that was once given to me. 
/r/learnpython 
I'm assuming your native tongue is French (given your username)? I took 13 years of French immersion, and your English is FAR better than my French.
Any application specific code you want run, like I wrote some code that needed other functuons, methods to register themselves.
This is fantastic! Great way to streamline the process. Especially nice since the original site is no longer accepting answers: &gt; **NOTICE** &gt; &gt; On Sunday 15 June 2014 it was discovered that Project Euler had been hacked and a decision was made to take the website offline. Project Euler has existed since 2001 and after thirteen years of it being carefully nurtured to become what it has become today we hope you understand that this decision was not made lightly. No one feels this sadness more than the team. &gt; &gt; As the strength and priority of Project Euler is the rich and challenging problem set it provides then we are pleased to be able to allow the problems to remain accessible. However, please note that full functionality of the website, including the ability to check answers, register, and login to existing accounts, remains disabled. Over time certain features may be reinstated, but currently there is no definite time frame which can be stated. In addition no new problems are likely to appear until the website is back up and running again.
I like the kickstarter approach that gave Django schema migrations.
You are brilliant, my friend. I admire this so much!
Coincidentally enough, a couple of hours after I posted this to Reddit, /u/_ProjectEuler_ posted to /r/programming that [answer checking was added back](http://www.reddit.com/r/programming/comments/299srl/answerchecking_has_been_added_back_to_project/) to the site, but it's a little inconvenient since it still requires you to navigate to the site, fill out the captcha, etc.
This is an interesting project. It's a pythonic way of doing what Google Maps Engine aims to do (easy gmap visualization and sharing)? My only concern is that producing a flat HTML file will overload the user's browser if you're storing lots of points and attributes directly in the HTML. Any interest in incorporating cloud based spatial storage capabilities? Maybe some logic to manipulate point/line/poly render per zoom level? Granted it's significantly easier to criticize than to develop but those are just some ideas that pop into my head. Your thoughts? 
Perhaps if we all said it... Haha Currently I'm building a massive tool suite in MATLAB that takes a good 100+ hours to run. In order to get data in or out we've written mex libraries to talk to a database and to Avro files on disk. When I say mex is pure evil, it is not really fair because we are forcing MATLAB to do something it is not good at. 
nice job !
https://docs.djangoproject.com/en/dev/releases/1.7/ app loading
Also: https://docs.djangoproject.com/en/dev/ref/applications/
I also disagree with you. PHP took Java OOP *syntax* and added it to the language. But it just doesn't make sense for a dynamic language, which kind of sums up PHP, they missed the mark on pretty much everything. Just because OO books all use Java for their examples, doesn't mean that is how OO *must* look. You can implement all the OO patterns you want in Python, it might not look like your OOP 101 book but a lot of them are still applicable. Granted, Python doesn't have interfaces, it has dynamic typing (or zope if you really must have interfaces). Python doesn't need singletons (and you shouldn't ever use singletons, google it) because we have modules. Python rarely needs static, it has it with @staticmethod decorator, we can use functions. But Python can do multiple inheritance, everyone says it is scary, but I do enjoy using mixins, take that Java! You can also do some awesome things with Meta classes to change how classes are built... So no.
Whenever I have a "PHP isn't that bad" discussion with anyone I just refer to this article. Yes people need to get stuff done in PHP. No I don't need to get stuff done in PHP. And I am happy with that.
I just want to say that I am glad I am not the only one who dislikes nose.
I was expecting this thread to be full of folks saying "yes" and I am glad it isn't. Ruby and Python have a lot in common and solve similar problems. Granted Python is more diverse whereas Ruby popularity seems to have grown out of Rails (Sorry if this is bollocks, just my impression). Which is why I am glad a lot of comments are saying "Learn X instead!". I can recommend checking out the book "7 languages in 7 weeks". It is aimed at programmers who want to dip their toes in different languages and covers Ruby, Io, Prolog, Scala, Erlang, Clojure, Haskell. You can obviously skip the first chapter, but the rest are a bit out there. 
As someone who is new to programming, I'd second using Digital Ocean. Set up a Linux box and learn about ssh and cron jobs. Monitor their performance with Htop and make tweaks with Vim. Use what helps you learn the most!
This is really awesome. I lost my old solutions for Project Euler and have been meaning to taking it back up. What a great streamlined process you've built here. Thanks!
This is hereby dubbed "pohatu's Law" Exemplar: [pygithub3](https://pypi.python.org/pypi/pygithub3) / [github3.py](https://pypi.python.org/pypi/github3.py)
Appreciate it! That book sounds like a great ideal. Get a taste of a little of everything.
Yeah you're right, I changed it.
/u/Hacktivist is saying that since 'rolling your own' PyQt5 is difficult, people are effectively locked in to whatever official binaries are released. Currently on Windows, the only binary release of PyQt5 is Python3-only, so people are effectively forced to use Python 3 if they want PyQt5 on Windows.
Don't worry, my french is quite terrible too.
I hope people are not thinking about WAMP, the PHP/Apache setup. I'm talking about the one that have been explain in this reddit post : http://www.reddit.com/r/Python/comments/27d0km/is_crossbario_the_future_of_python_web_apps/
May I ask what your native language is?
I've been turned down for a job before because I couldn't answer trivia questions related to `functools` library (which I had not used at that point, and which I still rarely use if you exclude `functools.wraps`), even though I understand the concepts, so YMMV as far as how they are grading your knowledge.
Looks fantastic, but there's a few things you can clean up. if cheat: view_solution(problem) elif generate: generate_file(problem) elif preview: preview_problem(problem) elif verify: verify_answer(problem) Why not store the functions in a dictionary and then use something like: func = funcs.get(name, None) if func is not None: func(problem) sys.exit() #we're exiting any ways.
But stuff is, I feel handicaped in english. When I wrote an article about WAMP in french, it gathered some attention. When I do the same in english (ttp://www.reddit.com/r/Python/comments/298uno/small_demo_of_a_pragmatic_use_of_wamp_in_python/), I don't think I manage to interest people as much. It's hard to assess if your writting style is catchy or boring or even just painful to read because your are not use to it.
Pretty nice! You called out that this only needs standard libraries, but requests is still beautiful. Any specific reason for avoiding it, or just preference? Edit: [r.content](http://docs.python-requests.org/en/latest/user/quickstart/#binary-response-content) should do the trick
Cool beans. Was just wondering if I was missing functionality somehow
Find a problem that has been bothering you about your computer, and fix it. It could be a tool to make your life easier/automate your life, a bug or missing feature in an existing (Python) program, or an idea you had that doesn't exist elsewhere. Then, once you're done, write it again, but better.
If a standard library does the job i don't feel the need of using a not-standard library. But i will look more into requests and maybe use it when i make complicated http requests.
I know exactly what you mean. If you ever want someone to look over something before you post (not that you really need it), I'd be more than happy.
Thanks.
i am particularly amazed that nobody is mentioning Google App Engine. curious, is there any reason for that ? 
That's a good example. Thanks.
Thanks ! :)
You should consider an x-post /r/coolgithubprojects if you haven't already
Build something, solve problems or go through the documentation, browse blogs, dig into source code to learn some cool tricks how about building a Reddit bot? :D
I hadn't heard about that subreddit before; thanks!
To piggyback on code review, I just can't help but feel the solutions and/or problems should be stored in JSON or something. It would make the \n and string parsing you're doing obsolete. Regardless, this is an awesome tool - thanks!
See [here](http://python.6.x6.nabble.com/Windows-installers-for-PyQt5-and-Python2-td5036304.html#a5036352) for the authors reasons not to create 2.7 builds. As for the difficulty in doing it yourself you need to ensure that compiler version match what python itself was compiled with. You need to install Qt sdk that matches that compiler, build sip and then build PyQt. And I think that if you want PyQt4 and PyQt5 installed at the same time then both need to have been compiled with the same sip version. You can see why installing from the provided binary is what most people would go for instead of asking the users of your software to build PyQt5 from scratch for Python 2.7.
All you have to do is: from argvee import Application app = Application() @app.cmd() def start_server(port=5000, debug=False): ''' the docstring goes in the -h/--help string ''' ... @app.cmd() def sayhello(*names): ''' 1 or more names. However, if you want to use flags or any kwargs, you can't use *varargs style args''' for name in names: print("Hello, %s!" % name) @app.cmd() def sayhello_with_flags(names=[], debug=False, coefficient=1.5): ''' This way you can pass: --names foo bar baz -d -c 5.2 without any issues. ''' ... app.run() $ python app.py start_server -p/--port 9000 -d/--debug $ python app.py sayhello foo bar baz $ python app.py sayhello_with_flags -d -c 5.9 -n foo bar baz All kwargs become optional args, True/False default values will make them flags. It will create the one letter options on its own (-d/--debug), using a capital letter if it already exists (-d/--debug -D/--dupitydoo) For kwargs with default values of type boolean, int, float, or list, it will have special behavior. booleans become flags which flips the default value if passed in, ints or floats are type checked and passed in as that type, and lists will have 0 or more possible arguments (`nargs='*'`). For varargs like `*args`, it will be one or more arguments (`nargs='+'`), but as it shows above, you can't use varargs (*args) and keyword args (--debug) together. You would need to specify `args=[]` Let me know if you like it, hate it, or have a feature request or bug report Available via `pip install argvee`
http://adventuresintechland.com/the-creative-gap/
That perfectly describes what I am feeling right now thank you!
that is where I wish I am but currently stuck on the "creative gap" which /u/Ticklethis275 have shown me
not quite at that level yet :(
os, sys, itertools, random, datetime, doctest, csv, re Non-built in honorable mentions: Anything intarwebsy -- requests. Anything "Excely" -- pandas.
Neat. FWIW, I've been working on a `cmd` replacement that makes similar use of decorators and similarly uses `argparse` and `inspect` to do the heavy lifting.
What made you want to take the course in the first place?
WTF is Project Euler?
Oh wow, cool. I haven't even used `cmd` but I get the idea. Are you going to generate the class dynamically, or decorate methods of a class to create the `do_` and `help_` methods?
You could Google it...? From the first result: &gt; A series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve.
GameMaker.
Like I said - similar use of decorators. They register methods in a `dict` held by a class analogous to your `Application`, so that a main loop of my own invention can call them (passing in information parsed from the user input as well as a program state object). I'm not wrapping the existing `cmd` at all. It's a little more complex because I need to treat each registered function as a separate command which therefore has a separate `ArgumentParser` (underneath all the layers of wrapping). I'm hoping to have it up on GitHub sometime next month :)
No, wait, I am sure this isn't a problem in your code, I am a beginner and it's the first time I try to install/run something like this.
There is one true argument parser and it's a [docopt](http://docopt.org/) ;)
Then you may be right about it being a bug...maybe stackoverflow will have an answer? Sorry I couldn't be of more help!
I assume that a 2 scoops book is in the pipeline, but the 1.6 book was only released back in Jan so expect to wait. 
Ah good, I'm glad you got this resolved!
A few comments regarding the code: First, you shouldn't put all your code in ``__init__.py``, just put it in another source file, and import what's "exposed" in ``__init__.py`` using relative imports. Also, there is a way to use decorators in a way that works both with and without parenthesis: def cmd(func=None, *, name=None): if func is None: return functools.partial(cmd, name=name) # corpse of your decorator This could be a lot nicer to use: @app.cmd def example(): return 42 @app.cmd(name="hello") def world(): return 42 http://chimera.labs.oreilly.com/books/1230000000393/ch09.html#_problem_149
Then I am probably wrong, I just assumed as much as there was 1.5 and 1.6 book. Fantastic books and I am somewhat let down if that is the case.
The approach I took (I'm sure there are better ones) for my [resume] was to use pandoc to generate a HTML page and use wkhtmltopdf to convert the HTML page into a pretty nice looking PDF document. It may be a little clunky if your PDF is complicated, but it works well enough for simple stuff that it might be worth investigating. The advantage to this approach is that there is very little code to write except the CSS template, it's all just command line tools. [resume]: https://github.com/Ayrx/resume
I've been in a very similar position to this before and it is certainly frustrating. I had never been able to verbalise it before but this article is pretty spot on http://techcrunch.com/2014/05/24/dont-believe-anyone-who-tells-you-learning-to-code-is-easy/ If you can't think of your own little pet project to start with you can always find some sample code for something you find interesting and start to tweak it.
neat trick... I kind of wanted to be able to write `@app.cmd('main')`, but it's not really necessary. The naming thing isn't too useful anyway. But either way these all share the same state... so what about its `self`? How would I write a class instance method that can refer to `self`/`app` but also take a function as its argument? If you are writing `@app.cmd`, there has to be a method `cmd` in `app`'s class that takes a function as its first argument, so doesn't that mean it's impossible to make it an instance method?
Depending on what type of formatting requirements you have, you might also consider LaTeX for the final step.
For me it comes down to this: Python is free software, and Matlab is not. With Python I can publish code that anyone can download and run without cost. With Matlab they have to have bought—or been in a position to have been bought for them—a Matlab license.
How is this better than docopt? (seriously, I am curious)
&gt; If you are writing @app.cmd, there has to be a method cmd in app's class that takes a function as its first argument, so doesn't that mean it's impossible to make it an instance method? No. If `foo` is a class instance with a method called `bar`, `foo.bar` is a callable object (formally, a "bound method") that receives the `self` parameter automatically. This is why you can write `foo.bar()` and don't need to do `foo.bar(foo)`.
y u no Flask-sqlalchemy?
So I refer back to my original comment regarding different tools for different things.
I can see how this may be a personal preference, but i prefer to hide unnecessary imports and details such as "sessionmaker" and "scoped_session" with well-tested plugins, if they are available, but again, this is probably a personal itch :)
The use of `foo=[]` as a function argument bothers me, since [mutable default values ordinarily don't work as one would expect](http://effbot.org/zone/default-values.htm). Strictly speaking, argvee avoids the problem by always providing an argument value, but I can't help but think that the code will look incorrect at first glance to someone unfamiliar with the library.
Do you have any areas of interest? It's important to pick something you are interested in.
My biggest gripe about Flask-SQLAlchemy is that it forces you to have an instance of your flask app next time you want to use your models outside of your web app. Why tie your declarative base to that?
Neat, thank you very much for the clairifcation. 
I use wkhtmltopdf in one of my Python projects, it works well even in relatively heavy use. There are some problems though like how it breaks lines across pages.
best one ive seen. makes it so easy, no messing around. It just works
IIRC pandoc can take JSON input, might be worth investigating as a Pythonic intermediate format?
Here is how it works for me: 1. Code your project as you can (maybe get inspired by the code of existing projects) 2. Share your project on Github/ submit your project on Reddit for review. 3. Have angry Redditors scream at you that your code is not PEP8-compliant, that you don't use the subprocess module right, that your documentation sucks, and you could have done it better with package x or y. 4. Use this feedback to improve your Python.
That's fine, but it takes more than being good at *one thing* to be good at scientific computing. Different tools for different jobs indeed -- my contention is that matlab is not the best tool for scientific computing.
How does authentication work in this?
I personally follow pep8, but I've never met anyone else who does.
[This](http://newcoder.io/tutorials/) might help :)
The tutorials really are excellent. I just used it in the spring with python 3 for my senior design project.
While most companies seem to have their own modified styles, I've met a bunch of people who could and would write pep8 code when working on OS projects- including myself. So, nice to meet you.
Forget this thought. Seriously, this could be one reason for your "creative gap". I am overwhelmed by the majority of problems when I see them at first and I do have a decent amount of programming experience in multiple languages and paradigms. And so what, I still need to learn sooo much everytime I tackle some idea or problem. Try to break down a complicated seeming problem like a Reddit bot into basic thoughts, e.g. "What does a bot do?" --&gt; connect to reddit, make a post, read some posts etc This gives you already a small task list, you have to find out how it connects and what you do need to set up a simple connection. After that, you can try adding another feature, then another and before you know, you are writing a reddit bot. A feat you deemed to be well above your level. Simply by not caring about levels and just tackling the problem ;) Of course, there are indeed projects you will not finish or where you will be stuck a long long time or that you won't understand for a long time until hopefully you encounter that "Aha!" moment. But at least in my experience, in those cases the problem could be something else than the actual programming at hand, constraints like time (you can't do this alone in a reasonable amount of time) or wrong choice of tools ( e.g. that point your though-process towards an unhelpful direction) or something else. And even not finishing something still teaches you a whole lot and you will do better at the next task. You can then always come back to the unfinished stuff and trust me, it will look different suddenly. tl;dr; don't dismiss the seemingly hard problems, try solving them anyways step by step;profit from experience gained along the way 
&gt; that you don't use the subprocess module right what's the right way to use it?
1. Take on a matured project on Github; follow some issues to see the workflow between submitter, commenters, and final fixer 2. study the project structure, search the reasons for a particular choice they made, think how they thought 3. take a relatively simple bug, to work on it. try to fix that. submit that fix into a forked instance of the project 4. when you are convinced enough about the fix, submit a pull request 5. if the request is accepted, congratulations !
Looks pretty cool! The installation does work under Windows (make sure you have pip installed and your Python../Scripts is in your PATH variable). The check for correctness seems to fail though (I'm pretty sure I have problem 1 correct, but the check returns false). Could be due to line endings, line.split(".", 1)[1][1:-1] in get_solution might include that under Windows? Possible solution would be to convert the return of get_solution to integer.
I would suggest phantom.js instead of wkhtmltopdf since the latter is effectively unmaintained.
I try to follow pep8 as close as possible on my own projects, and use [pep8ify](https://pypi.python.org/pypi/pep8ify) to catch my mistakes. I like that I don't have to think "what is the right style to use" for Python because it's generally agreed on. In practice however, I appreciate consistency of style more than what the particular style is. 
The differences in line endings between OSes didn't even occur to me until now. I'll look into this. **Edit**: Do you think the check would be fixed on Windows if I were to change ` line.split(".", 1)[1][1:-1]` to `line.split(". ")[1].strip()`?
What would you like to work on? What are you interests? What sort of projects have you contributed in C/C++? These types of questions should help you whittle down from the vast number of projects out there to something you'll enjoy contributing to. Then pick a project, pick an issue, and code. Better yet, find an annoyance and fix it - as an example, I needed PyQt5 support in matplotlib for a personal project of mine so [I worked on it](https://github.com/matplotlib/matplotlib/pull/3072). I now know far more than I ever wanted to about matplotlib backends and PyQt, but I've gained experience adding code to a large project. 
What you seek is a [Cron Job](http://www.reddit.com/r/python) 
Normally these kinds of replies annoy me, since I hate that searching on the internet has effectively replaced human communications. But he could have asked more politely... lol
It's easy to learn to write PEP-8 code by habit if you use Pycharm. The PEP-8 inspector is enabled by default and will give you squiggly underlines on code that doesn't conform.
Here's my little twist on the usual suggestions: Pick a *small* project on github that looks cool, fork it, and work with that. 1. It'll really flatter the original developer and encourage him to work on his project 2. You can email him directly and ask for advice on how to fork, make pull-requests, etc. 3. See point 1 again. As a young developer, this would make me really happy.
Need some help as in "do this for me"? This is wrong website for that kind of stuff. Right website would be one where you can pay freelance programmer for doing work for you.
That [project](http://pythonturtle.org/) is more for beginners. 
http://rosalind.info/problems/list-view/
http://www.reddit.com/r/learnpython/wiki/index http://www.reddit.com/r/learnprogramming/wiki/index
Cool. It gets even simpler when you remove SQLAlchemy and just use sql :)
Is there any plugin for sublime as well?
You could use `ast` module. Here's an example: [`count-imports.py`](https://gist.github.com/anonymous/d51e06375bdf8513ca61). ### Top dozen stdlib modules * sys * os * time * subprocess * itertools * threading * re * random * multiprocessing * `__future__` e.g., `from __future__ import print_function, unicode_literals` * logging * collections ### Top dozen 3rd-party modules * numpy * zmq * twisted * setuptools * lxml * cython * pytz * matplotlib * pexpect * bs4 (`BeautifulSoup`) * pip * requests 
The PyQt5 support in matplotlib? Yes it is! It's been merged into `master` so will be up for release in v1.4.0. Not sure when that is coming, but you can `pip install` from the [github repo](https://github.com/matplotlib/matplotlib).
&gt; "shit, that's right, gotta import matplotlib"... So use the following at the top of your program: from os import * from re import * from sys import * from json import * from ssh import * from numpy import * from matplotlib import * # etc. That's the sort of BS that Matlab does. If anything you should be complaining about how Matlab automatically does that. My m file is in another folder, oh can't import that.
You're welcome to go that route! But I'd suggest we'd both be happier looking at the SQLAlchemy version a year from now than at an "elegant" tangle of conditional string operations that try to glue SQL queries together
Thank you very much for the reply!
Thank you very much, I appreciate it!
Thank you very much, I will look into it.
Try out /r/progether. We have a couple old projects that were coded in python and some projects were highlighted the other day that were built in python as well that needed some help. One particular one was in django if that is what you're interested in.
Yes, but I mean in the function declaration.
SublimeLinter contains a PEP8 linter.
Oh, got it... Of course, that will work. Thanks
Sounds very interesting - I'll read up on. Thank you!
I did some testing, the problem seems to be elsewhere, in your check "Strip newline from end of output if output is not a lone newline." in verify_answer. If I change the replacement to output = output[:-2] things do work. On Windows, all output from the command line ends with a new line ('\r\n'); which is not the case in OSX/Linux, so that's probably why it does work there.
Exactly the reason why I moved away from Flask-SQLAlchemy.
How are you using ZeroMQ? I built a system like this before where I sent the variables to be tweaked over ZeroMQ and then updated them that way. Rather than ssh into the AUV send the updated variables as a hash using msgpack or json through ZeroMQ and then update the other variables accordingly.
If you want to detect changes to a file on the file system in Linux, there is inotify, and the python library pyinotify. You can listen for events like file creation, modification, deletion, etc. As for alternatives, If you are accessing it over an insecure network, you should probably stick to SSH or similar. ZMQ is cool but I feel like it's not at all the right way of deploying configuration settings. There are deployment tools like Ansible that can deploy files in an automated way.
Interesting. If that line gets changed to `output = output[:-1].strip('\r')`, does that break the command line output on Windows? The reason I don't strip *all* whitespace characters is so that you can do things like this: # 001.py print testFunc(1) print testFunc(2) and have each line printed on a separate line.
This is fun! I'm getting "sh: cls: command not found" at the top of every refresh, on ArchLinux. everything displays just fine despite that. Makes me wonder if their is an OS agnostic clear command as part of the system library.
 I use 'os.system("cls")' to clear the screen to refresh the data but it will only work on windows. You can replace 'os.system("cls")' with 'os.system("clear")' for Linux and OS X. The message you suppose to get when a team scores - 'os.system("msg * " + update)' - won't work either on Linux and OS X. I don't know how to fix that. Edit: I changed the code on github to work with Linux, also for the notification. Tell me if it's not working
Nice! https://github.com/jrjohansson/version_information/blob/master/version_information.py performs a subset of these functions with `_repr_&lt;fmt&gt;_` functions and escaping.
It's a good point, and I considered how that looks, but I wasn't sure if there was a better way and you would know it's a valid value when paired with the `Application.cmd` decorator. I considered checking if it `is list` and using `list` as the default value, but then that wouldn't make sense for the others to be an instance of type `int`, `float` or truthiness instead of their type. Also, I can't think of any situation where it makes sense to call the decorated function twice, so in this way you have the option of putting default list values too. In this way it leaves more flexibility for default values and the behavior will work as intended when decorating a command. The funny thing is, the gotcha of this behavior, is that you don't have to worry about the normal gotcha of a default list value.
No serious and popular packages are python 3 only because python 2 is still widely used, especially in corporate environment. Most of the python 3 only packages are small ones that individuals made and which don't have big user-base.
IIRC it isn't that difficult, not more difficult than compiling any other module on windows anyway. It's definitely not something that I would consider "pretty much Python 3 only on Windows" just because it requires compiling, by that logic every module that doesn't have official windows installer would be considered "linux only".
&gt; which contains all the packages you need Until it doesn't. Python packaging is horribly broken on Windows, Red Hat, anything besides recent Debian derivatives, or maybe Fedora or OSX if you're lucky. Convenient cross-platform access to scientific Python libraries has become a walled garden, where if Continuum builds it for you then you're in luck, otherwise it's not worth bothering. When your needs are particular (in my case I've tried python-control, livestreamer, pypolyhedron, applpy, pyomo, and others), getting a Python package that isn't in the pre-built Conda repository to work is a nightmare. Matlab is just easier, and when you're in academia and it's cheap, it's absolutely worth it.
The author said they now just pass a reference to the source file, but I don't think they said how. If I were to do it, I'd probably use the inspect library, specifically the inspect.getsourcefile method. https://docs.python.org/3.3/library/inspect.html#retrieving-source-code
Best advice? Start fixing bugs / scratching itches in whatever python project you're already using, be it a library, or a full program. It's really hard to wake up one day and say: 'I'm going to start contributing to project X' and then actually follow through with it. Even more so if the choice of project wasn't yours.
This seems like the best way to go about it.
this thread [over here ](http://www.itsokaytobesmart.com/post/25459479536/numberphile-buffon-matches-pi) talks about approximating pi by throwing match sticks. I was able to come up with a python3 simulator using numpy in less than 30 lines. I think it makes for a good quick puzzle, although it is somewhat math heavy.
So when I use the max or min functions, will that call Python's functions or NumPy's functions of the same name? Matlab function names are designed to be in the global namespace, Python's are not.
This is great! really helped getting an idea of it after reading it thank you.
I thought GameMaker is just drag and drop stuff how does it help?
Yes I understand that it is a module and not a webservice, but the end game is to produce a visual representation of your data using gmaps like GME would, only you want to call it directly from your python code as opposed to exporting the data as a csv/shapefile/w.e. file and uploading somewhere. My concern for the browser has a whole [google developer page dedicated to this very problem](https://developers.google.com/maps/articles/toomanymarkers#fusiontables) Shape simplification is what I was referring to, not adding more data at different zooms. I'm glad it's on the todo. 
I find myself looping way more often than using imaginary numbers, so I stick to i and j, which are the way matrices tend to be indexed in literature anyway. For imaginary numbers, rather than i, I use 1i. Problem solved.
&gt; The multiprocessing module is simple and elegant and is far superior to the low-level threading functions provided by the statically typed, compiled language I'm coming from. It sounds like you've never done any real parallelism before, besides perhaps embarrassingly parallel problems. There's no shared memory in the multiprocessing package, since you're forking off different processes rather than threads. The GIL is still a real issue.
I can't get it to work on Mac but I'm illiterate so yeah...
I have also found xhtml2pdf to be useful if sticking with python is desired. I have it running on some production sites and it usually works well. As of a couple of months ago the version on pypi used pyPDF which I think is no longer maintained, but the github repo master uses pyPDF2, which is maintained.
As someone new to flask what does this exactly do? Why would you need queued registration?
I never said Matlab is better. I said Matlab is a non-starter. Python has tons of libraries for things that would never make it into matlab, and I've learnt my lesson with R. 
str(low) 
You uh need to cast low to a string by using str(low) if you want to use string concatenation (+) Or in your case you could use commas (print "whatever", low) and it will work the same except it will add the spaces Learning why all this is so finicky will drive you nuts / be amazing for the rest of hour time coding 
So you haven't contributed anything to the discussion, besides that fact that you can't afford Matlab, ok.
We've used computers before. 
Hi thanks! If I may bug you with another question... The original code I was messing with is from here http://inventwithpython.com/guess.py and it seems to work fine with out str why does it stop working when I play with it?
No, I refuse to pay for it. And this does affect other users. One of the benefits of using a programming language is the contributions of other members of the community. Guess which one has more of that?
Small tip, because maybe it makes you learn something, or maybe it's a silly optimization. Try using a partial to create the function you use for clearing, that way you don't have to do the conditional each iteration. Either way, high-order functions are fun to play with. So pull the conditional out of the loop at the top and do something like this: from functools import partial if platform.system() == 'Windows': clear = partial(os.system, 'cls') else: clear = partial(os.system, 'clear') Then you can start off each loop with a simple `clear()`
The topic of discussion was a comparison between Python and Matlab on dropping down into c. You butted in, out of topic, saying you're not paying for Matlab. "Which is faster, a Toyota Corolla or a Porsche 911?", "Toyota Corolla, because I refuse to pay for a Porsche".
It doesn't, the only time it prints a number is with guessesTaken, and it uses str() to cast it to a string Long story short - print is looking for a string and the + operator is used for gluing strings together. You can't glue something that isn't a string to another string -- without making it a string first
I see what I was thinking, I was taking lines like &gt;print('Good job, ' + myName + '! You guessed my number in ' + guessesTaken + ' guesses!') out of context, not taking &gt;guessesTaken = str(guessesTaken) above it into account thanks for helping a total newb :)
Please don't call it 'cast'. You don't *cast* anything in Python. `str(5)` creates a new string object by asking the integer object to create a string from itself. "Convert" or "make" is good. But "cast" sounds like it's C pointers.
I want to hit whoever wrote that with a very large stick. That is horrible code. Edit: I was bored and made it better: http://pastebin.com/YVvg3pBx
Yeah that's an important semantic distinction here, he probably got confused and I thought I was talking about C. 
You're correct in thinking that you'll need a while loop. Can you post what you've though out so far, i.e your pseudo-code maybe? 
Actually, which is better for scientific software.
Well, python has to do something with the data to make is visible. Export it to an html file or upload to a server or whatever, but I think straight to an html file or to a json file is the simplest as it doesn't require someone to build and maintain a web service and a UI for that service. That article isn't exactly about your concern as I understand it. It is still true that flat file or from a server, it all ends up in the DOM. That article is about *showing* too much data at once (and specifically markers, as they take a lot more to render per vertex). The server model doesn't solve anything. Wether flat html or webservice, you still have to design you map intelligently. Don't just put 100,000 markers on the map at once. Break them up into groups based on location, type, etc and make them visible in groups. You can do this with pygmaps_ng right now, and having 100,000 unrendered markers sitting around ready to be rendered doesn't make the map slow at all. Its just what is rendered that slows it down. That article has some tricks, and those could be implemented in different versions of the javascript interface, wether flat html or webservice.
There is also game maker language https://en.wikipedia.org/wiki/GameMaker:_Studio#Scripting
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 4. [**Scripting**](https://en.wikipedia.org/wiki/GameMaker:_Studio#Scripting) of article [**GameMaker: Studio**](https://en.wikipedia.org/wiki/GameMaker:%20Studio): [](#sfw) --- &gt;__Game Maker Language__ (GML) is the primary [scripting language](https://en.wikipedia.org/wiki/Scripting_language) that is interpreted similarly to [Java](https://en.wikipedia.org/wiki/Java_(software_platform\))'s Just-In-Time compilation used in GameMaker, which is usually significantly slower than compiled languages such as [C++](https://en.wikipedia.org/wiki/C%2B%2B) or [Delphi](https://en.wikipedia.org/wiki/Delphi_programming_language). It is used to further enhance and control the design of a game through more conventional programming, as opposed to the [drag and drop](https://en.wikipedia.org/wiki/Drag_and_drop) system. The syntax of GML borrows aspects from other languages such as [C](https://en.wikipedia.org/wiki/C_(programming_language\)), [C++](https://en.wikipedia.org/wiki/C%2B%2B) and [JavaScript](https://en.wikipedia.org/wiki/JavaScript), giving it some syntax features of [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) but is not fully featured in that custom structs and classes are not possible. &gt; --- ^Interesting: [^YoYo ^Games](https://en.wikipedia.org/wiki/YoYo_Games) ^| [^List ^of ^game ^engines](https://en.wikipedia.org/wiki/List_of_game_engines) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cijw4yw) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cijw4yw)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
This is not an error, just a warning. Feel free to ignore it. 
First thing, this is the wrong subreddit. /r/learnpython is where you want to ask for help. Second, that warning and error are just saying that "cat animation.py" is really fucking old using dated python functions that in the future will cease to exist. Nothing to do about it, really. The book must be old and so its examples are old. It's not an error with your python or pygame install. 
Thanks man! Glad you like it!
No, but as a newbie he might be confused about what is going on. Casting does not modify the variable, it just tells the compiler to handle the variable as if it is a different type. While here you don't tell Python to handle it as a different type, you actually create a new object of the new type. To somebody that knows Python, calling it casting will not cause confusion, but to a newbie it could, if they already knows C. And if they don't, then it sure as hell will cause confusion once the newbie learns C. ;-)
Nice one, similar to http://www.dobby.co/ which seems to have been taken down
This guy stole my idea!!1 But seriously, I had this exact same idea a while ago and I couldn't find a program to do it for me, so thanks.
Quickly throw together a project? [PyCharm does this](http://www.jetbrains.com/pycharm/quickstart/screenshots/types_of_projects.png)
Python camelot http://www.python-camelot.com/ 
Using Qt means you get to use the Qt Creator form designer, and then compile your .uic files into a Python class that you can reference from your code.
Again you're missing my point. I'm not saying python is the best choice for everything. I'm saying Matlab is *rarely* the best choice for anything; it's completely over represented .
&gt; But on the way I had a bizarre experience. You thought it was bizarre that versions that either had to make a function call per element or which made tons of slices (=copies) and zips (=copies in a Python that old) got the snot kicked out of them by the version that just iterates over values? I'm struggling to believe that, or the idea that `for element in vector: ...` isn't the first and only thing that anyone would write. `sum()` was added in 2.3 (released on July 29, 2003) so either this article is really old or the author is using some really ancient systems. It's quite the shaggy dog story. 
Probably because RAD tools are about GUI toolkits rather than programming languages. If you use [PyGTK][] there is [Glade][]. If you use [PyQt][]/[PySide][] there is [Qt Designer][]. If [wxPython][] there are [wxDesigner][] (which is proprietary) and [wxGlade][]. If you use WinForms with IronPython there are Visual Studio and [SharpDevelop][]. [PyGTK]: http://www.pygtk.org/ [Glade]: https://glade.gnome.org/ [PyQt]: http://www.riverbankcomputing.com/software/pyqt/ [PySide]: http://www.pyside.org/ [Qt Designer]: http://qt-project.org/doc/qt-4.8/designer-manual.html [wxPython]: http://www.wxpython.org/ [wxDesigner]: http://www.wxdesigner-software.de/ [wxGlade]: http://wxglade.sourceforge.net/ [SharpDevelop]: http://www.icsharpcode.net/opensource/sd/
Yes, let's alienate us even more, let's watch movies together ... alone :|
Try passing it along with the request and response using the meta parameter. http://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Request.meta
I have my doubts about this over the course of longer videos. Different devices and video players tend to play at slightly different rates. In college I did some experiments, and videos that appeared perfectly synced at the start would drift over the course of an hour to be a second or two off, without pauses or apparent skips. It might sync up the button presses, but keeping synced up over a full length movie is more complicated than that. 
I too had the same idea. Lol. Then I found this.
My girlfriend lives 800 miles away. It's kinda the only shot I have at watching stuff with her simultaneously.
It's a couple of years old (refers to something he did in 2010 as "recently"). Even as far back as 1995 the right tool for such a task was Numpy (or actually its predecessor Numeric). It had an excellent sum() function as well as other optimizations that would have probably cut down the run time from days to hours or less.
By vector I think you mean iterable
[**@__chrismorgan**](https://twitter.com/__chrismorgan): &gt;[2014-06-29 14:22:44 UTC](https://twitter.com/__chrismorgan/status/483254241562079232) &gt;I can just see people subverting the new matrix multiplication in Python for email addresses, e.g. me@chrismorgan.info ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/29e7gd%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Trivial implementation: class EmailDomain(str): def __getattr__(self, superdomain): return EmailDomain('{}.{}'.format(self, superdomain)) def __rmatmul__(self, mailbox): return mailbox + '@' + self chrismorgan = EmailDomain('chrismorgan') me = 'me' print(me@chrismorgan.info)
a watchdog http://brunorocha.org/python/watching-a-directory-for-file-changes-with-python.html
Yes, I prefer to never interact with friends again simply because they moved far away.
Even in C, casting may very well modify the variable's value: float pi = 3.14f; int three = (int)pi;
You are correct that java OOP isn't a bad thing to learn, but I'd recommend going full java or c# for the windows inclined and doing it properly. 
Except fields that use Simulink. Or any control theory. Or numerical optimization. Or computational geometry. Python's offerings in these areas are much weaker than Matlab's.
Just be glad there is no such thing as a unary matrix multiplication operator, otherwise you'd get the same thing with Twitter handles. EDIT: wait, duh: decorator syntax: @gvxdev def something(): pass Not as flexible as the email thing, though, since you can't use it in arbitrary expressions.
Hi, I won't give you a solution either. But I couldn't if I wanted to, because I don't understand the specification of your function and maybe your first problem is that you don't understand it, too (just guessing). I will give you some questions about your function so the things that have to be done become clearer. Where do the functions come from that you want to call if n is even or odd? Do you have them somewhere? If you continue until n is equal to 1, what changes n? Where does the sequence come from? What should the result of the function be, i.e. what should it return? Should it print the sequence or the number of integers in the sequence? Should it do both?
Watch2gether is a great way, too. It syncs up web based videos. Ninja edit: http://www.watch2gether.com/
its like the first exercise in the book, I think they planned to condense it down in later chapters :)
That must be the most misleading domain ever. Cool program, tho. Thanks!
This is just what I was looking for to use as a car to car streaming an VoIP system. I posted about it recently. Thank you!
Why not? `pathlib` did it with the division operator...
Interesting idea, but you should drop the server req.
I have used watchdog for updating configurations and reloading dependencies dynamically. I really liked the AS3 style event listeners. 
Slap a metaclass on it so we can just write `Domains.chrismorgan.com`.
You can either pass the returned pointer further to C code or use `value` property of the string buffer to access it as a Python string: string = create_string_buffer('', 64) clib.strcpy(string, "Hello") print(string.value) The C buffer is bound to buffer object and the memory gets reclaimed when `string` variable gets out of scope in CPython. This also means that after this point no C code should try to access this buffer.
installed! thank you :)
The [Eric](http://eric-ide.python-projects.org/) IDE has some support for building GUIs.
...God I hope no one starts doing that. I know it's a joke but I wouldn't be too surprised. Can anyone think of some actually practical operator overrides for this operator that don't involve matrices?
I've really only used it once, using subprocess.call() to open VLC to play a video. Seems to work fine on python 2.7
If this does happen, seeking to the same position as current playback should resolve it.
It becomes more complicated when you are communicating with the processes (sending or receiving data as they come).
I could see it being used as an alternative indexing operator, i.e. `foo @ (x,y)` instead of `foo[x,y]`. This could come in handy with things like pandas dataframes, where there are multiple different ways to index the same thing. It's limited by the fact that you can't assign to an expression, though.
I agree! My suggestion: OP should go out and learn a couple of languages from radically different families. I suggest Java (I know, yuck!) and Clojure. My rationale is this: Java is a very widely deployed strongly staticly typed language. Learning it will give OP experience with the benefits of using such a language while teaching a very marketable skill. I picked Clojure because of its radically different syntax and functional approach. With experience in Ruby and Java, OP should be have a strong claim to understanding how to implement object-oriented design practices. With Clojure, OP should have a similar claim for functional practices. If you can "think in" all three languages when you need to and can implement a simple web application using the best practices of the respective communities, you'll be in a place where you'll know what architectural style best fits how you approach problems. With that out of the way, you can explore more closely related languages and make a final decision on what to make you specialty: If you prefer Java, go try out C#, Scala and even write some PHP. If you prefer Ruby, try you some Python. If you prefer Clojure, seek help. *I kid, I kid*. Try learn Haskell, Rust, and Go. Basically, try closely related languages that share the features you liked, and pick the one with the best support and most active and helpful community. For me, Python's defining characteristic is its large open, professional and helpful community. The standard library is good and PyPI makes it awesome, but community is where it's at.
It actually will temporarily slow down a viewer who gets ahead due to others dropping frames. Found out about the feature because it's in the more options menu on it. Software seems cool but it actually looks like more work to me than what I do currently with my friend just syncing via Teamviewer. It at a minimum needs to add a playlist function. It'd be a serious burden to me and my friend having to play in a file viewer between every episode of an anime. 
I usually go with this pattern: for thingx, thing in enumerate(things): print("{}: {}".format(thingx, thing.summarize()))
&gt; Py2k for lyfe This is why we can't have nice things
It's not Python and it's not open source but inDesign is script able using JavaScript and is the go to app for document layout in every other case.
this bot is dumb.. especially when the tweet is actually the headline of the post
Gosh, that's interesting per se. But please, whenever you have to perform anything related to number crunching in Python, do use Numpy arrays and Numpy-provided functions. Then think vectors and matrices instead of explicit looping and you should get decent performances. Seriously.
&gt;Matlab's string-handling abilities just aren't that much higher-level than C Bingo.
Good read. What are your thoughts on yhat's ggplot2? As a newbie to python, I've kind of just skipped learning mpl and dived right into making plots in ggplot2. What can make mpl a better choice than ggplot2 or is it just preference?
No good replacement anyway. If *all* of those applications are rare to you, then we're clearly in substantially different fields and going to very different conferences. Out of the papers I read and the talks I go to, 8 out of 10 are done in Matlab. 1 is a serious implementation in C or Fortran, the last guy in the corner is using Python. And don't get me started about industry use. Edit: you may claim this is over-representation, but I counter that with: these are intelligent researchers and engineers who would be willing to change if a different tool was better for the job. In these fields, which are by no means rare, Python just isn't.
use envoy
Try def reverse_lookups(number, phone_numbers, names): return names[phone_numbers.index(number)] I generally prefer 'enumerate(x)' over 'range(len(x)) ... x[i]' if I have to keep track of an index. This function looks a little odd as you are trusting the caller to maintain the lists. They should be abstracted as instance variables on a class with mutator methods. class PhoneBook(object): def __init__(self): self.people = [] self.numbers = [] def add_person(person): etc() A phone book would be a lot more efficient to store some other way eg a dictionary mapping numbers to people
&gt; If the community was concerned about GUIs, we'd have something better than tkinter in the standard library. I prefer to use Turtle to draw all of my GUIs
I'll definitely consider using enumerate. At school my prof tends to use range(len(x)) but it's kind of annoying and really easy to make a mistake. Thank you so much! I forgot about .index() I have soooo much brushing up to do 
How is this RESTful? When you POST to http://localhost:5000/todos how do you know the todo is at /todo/1?
We can, he can't. It works out for the best. 
What he/she is saying is don't see it as out of reach but see it as a problem to tackle. That's what programming really is: solving problems. Programming isn't really about practicing and getting as far as you think you can, it's about figuring out how to overcome an obstacle. Break it down into a small as steps as possible and figure out how to carry out those steps. 
Most Pythonistas I know use ipython + ipython notebook for prototyping code, and then they pop it into their preferred text editor, e.g. vim/emacs. Combine this with a terminal multiplexer like tmux and you end up with something that feels like an IDE but is much more flexible/powerful/UNIXy.
Note that gdbm, kyoto, and leveldb don't support concurrent access. As silly as it sounds, I tend to use SQLite for a lot of key/value storage because of this. I joke that SQLite is my favorit nosql store!
Your Python prof tends to use `range(len(x))` ? That's a bit "unpythonic".