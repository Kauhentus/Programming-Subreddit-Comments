I know those websites, they're just a list of small challenges with a strapped-on checker and xp level-up system. [https://www.codingame.com/home](https://www.codingame.com/home) is better if you're already a master at python since you can win rewards and there are really tough challenges, but I ain't an expert (that's what I am trying to become in the first place lmao)
I did research. Yes, there are others. lmao.
Just trying to brainstorm ideas to help you move from knowing stuff to doing stuff. I'm not a master either! Good luck!
Thanks 
&gt; Learning another language is a waste of time since every language basically has the same things in different shells and after a while those slide down really easy. Unless you are speaking from decades of experience, **GO DO THIS RIGHT NOW**. Of course every language has the same things in different shells on some level, but that's like saying you should never eat anything but pizza, because every food basically has the same things in different shells. There are languages out there that are mind-bogglingly different from Python, and many of them are really really good. Learning any of them will show you new ways of thinking, new mindsets, new problem solving approaches, new concepts; some of those you will find useful, others not so much, and yet others will seem pointless right now but may sink in a few years from now. &gt; I started learning python about a year ago and now I'm pretty fluent with it and know my ways around the language. You have only scratched the surface here, kid. Learning the language itself is easy, I did it in 3 weeks. Getting really good at programming however takes at least 10 years. I've been at it for over 25 years, and I'm still learning new stuff all the time. One thing that is particularly telling is this: &gt; I tend to lose my motivation rather quickly when I'm not truly interested in the project. Get this; the reason you lose interest is because you're entering the phase of the project where the hard work begins. You've never done the hard work, you've just been goofing around. If you want to get serious about this programming business, do a project and actually see it through to the end - design it, build it, iterate, test, discard, start all over, test again, refine, polish, use it (or, better yet, attract some users), maintain it, etc. Because if you want to program for a living, this is what you will be doing all the fucking time (you said "work would be a good option", so I assume this is what you want to go for).
 &gt;&gt;&gt; import requests &gt;&gt;&gt; from bs4 import BeautifulSoup &gt;&gt;&gt; &gt;&gt;&gt; channel = 'http://www.youtube.com/channel/UCrJhliKNQ8g0qoE_zvL8eVg/videos' &gt;&gt;&gt; &gt;&gt;&gt; r = requests.get(channel) &gt;&gt;&gt; &gt;&gt;&gt; soup = BeautifulSoup(r.content, 'html.parser') &gt;&gt;&gt; soup.select_one('.yt-lockup-title a')['title'] 'Final remarks and conference close - Pycon 2017'
First, make sure you have `libssl-dev`. I didn't have that at first and couldn't use ssl module or pip. I'm not sure on the exact name of the package though, you might want to check that.
&gt; This I still can't figure that out, so please bear with me.. The visitor method (in this case visit_FunctionDef) is also called an arbitrary number of times right? It will be most of the time since it calls generic_visit which will call it back yeah. Usually in my visitors I just have a "standard" attribute which is returned at the end of the toplevel visit call, and I set/modify that as necessary. &gt; I don't see an easy way to reference parent elements though. Should this be done with some nested visitor-classes? Yes. Basically, you implement methods for the "top-level" nodes you're interested in then you spawn a sub-visitor for that bit e.g. if you want to explore the contents of functions you'd do: class ModuleVisitor(ast.NodeVisitor): def __init__(self): self.functions = [] def visit_FunctionDef(self, node): sub = FunctionVisitor(self_or_relevant_metadata_or_whatever) sub.visit(node) # get relevant data out of sub # don't recurse into the node ourselves.
Some will change your way of thinking. You can contribute to some project you like if you really can't find any project of your own.
Thanks for that, it's much clearer :)
What about using something like [Coconut](http://coconut-lang.org/) to start learning the features of functional languages? I'm sure it's not the same as learning a 'native' functional language, but it could be a nice blend of the familiar and the new.
Do you mean increment the version number reported in setup.py?
If nothing else, learning C would cause the OP to be very grateful for languages that have lists. Speaking of, maybe the OP could also learn a LISP. Maybe SICP?
It's customizable. I can add custom snippets, use packages that do literally everything, and easily change settings. It becomes slow once you try to turn it into an IDE, but it's marketed as "A hackable text editor for the 21st century," which it definitely is. 
As a data scientist, and someone who programmed in R for about 4 years and then switched to Python a year ago, there's a couple distinct advantages in the data science realm (not counting everything else of course, python obviously wins there). 1. if you need to do deep learning, Python beats R by miles. I guess R has mxnet, and I recently saw a blog post for a tf implementation in R, but its DL environment is a hundredth of what it is in Python. 2. More uniform syntax in machine learning libraries. With sci-kit learn's popularity, most machine learning libraries attempt to follow a similar interface, and that leads to users being able to be productive with new algorithms really quickly. 3. On that same note, literally nothing in R touches Sci-Kit Learn. It's scalable, intuitive, has incredible documentation, clean interface, and a massive community behind it. 3. Yes, shiny is nice, but Python has about 30 different web frameworks that, with a little learning, give you significantly more control over what you're making, without sacrificing anything really. I've made tons of apps at work embedding interactive Bokeh and Plotly graphics and interfaces in Flask applications. 5. This is a personal thing, but Pandas just makes so much sense :) I like dplyr and data.table, but Pandas is just more solid to me. Again, totally personal preference. 6. Ability to expand your AI application into something bigger. R is really not designed for production workloads and serious applications, and if you do try to do that, you're going to be doing some really janky things. Python on the other hand, has all the tools necessary to manage large applications. 7. Pyspark is much more mature than sparklyr.
If you want to build data dashboards I think R Shiny is still the easiest way to go about it (coming from someone who primarily uses Python for data analysis). Building GUIs is not that easy when you compare it to how simple it is to build something similar via HTML (R Shiny, Flask, Django, etc). Unless you *really* want to (or are forced to) build a GUI just for the sake of building it, I don't see a reason to do so. Just build a HTML-based GUI instead - why not use your browser as your GUI platform? If you have a bigger need than just data science, Python certainly has things to offer. I like to use it for building pipelines and CLIs and find it easy to do so. Also, I am just used to Python over R and like the language better. However, if you are already comfortable in R in both data science and more general applications you mentioned then it really comes down personal preference. There are different packages and ways of doing things but the end result will be similar. That's great if you're interested, but don't expect a wildly different end product.
Skimming over I found some issues: - Self signed certificate is signed using SHA1 (should be SHA256 or better). - "Check certificate information" seems to only **read**, not **check**, because the signature is not verified (unless that is done by [`load_pem_x509_certificate`](https://cryptography.io/en/latest/x509/reference/#cryptography.x509.load_pem_x509_certificate), but doesn't look like it). - AES encryption is declaring a global fixed `iv` that is reused on every call to `encrypt`. - Unless you are building your own crypto (DON'T!), encrypting something with AES CBC probably doesn't do what you want, because there are almost no integrity guarantees. - A few iterations of a message digest (specially MD5 or SHA1 as in the examples) does not make a Key Derivation Function. Don't use it to make an AES key from your password. Use bcrypt, scrypt, or even PBKDF2.
What I meant by "I heard they go like jelly and butter" was: &gt; I've heard that C is good for building small efficient stuff and python for taking those small efficient stuff and aseembling them into big understandable stuff
I heard that fact, so I started learning lisp (people were especially stating that fact for lisp) I think I didn't (and couldn't) dive deep enough into lisp since I didn't see a difference in the end results from a normal program and from a lisp program. Lisp had fun and simple syntax but you had to remember the name of basically everything you want to do, and I am bad at remembering names... Also normal recursion wasn't optimised (like it would still break after a certain debth) and tail recursion is simpler written as a shorter (and more understandable) while loop. Lisp also isn't used in the modern world at all so all of those facts summed together with the lack of good and interesting tutorials killed my motivation to learn this *"revolutionary language that will change your way of thinking"*
[removed]
About the contribution to public projects: I have to decide which project I want to contribute to since I will be spending a lot of time contributing to that project because I have to learn how the source code works before I can start fixing/adding anything. The "deciding" and "learning" hurdles are what stops me - I'm uncertain if a certain repository is too much for my skill level, maybe it's using a library completely unknown to me and I can't do anything or it's just far too complicated. And I can't really know which project out there is simple and which is complicated for my level since we don't even have a programmer leveling system out there!
Not really enough detail in your request... what system? Windows? Linux? Mac? Android? etc. Is there anything "special" or "odd" about your setup? How did you install IDLE? Obviously IDLE doesn't normally do this - it's a very mature (&gt;15 year old) applicaiton. 
&gt; that's like saying you should never eat anything but pizza, because every food basically has the same things in different shells. Kill me but I think that's a true statement... &gt; There are languages out there that are mind-bogglingly different from Python, and many of them are really really good. Name a few. &gt; Get this; the reason you lose interest is because you're entering the phase of the project where the hard work begins. You've never done the hard work, you've just been goofing around. The whole problem is that I don't know what to start making! I have no ideas what to make that will be on my skill level. I recently made a reddit bot which when I started making it I thought was gonna be really hard but then it turned out to be really easy (even though it took 2 days to fully debug). I simply don't know whenever something is within my reach or not...
There's no youtube tutorial for learning that so I've been waiting until I somehow get better at it lmao...
No. Rather, give them specific sudo access to create users. Never, run any daemon or similar as root if you can help it, especially if it receives any sort of input over HTTP/S
[removed]
You can try &gt; PAGE is a drag-and-drop GUI generator for Python and Tkinter aimed at building Python modules which can display a relatively simple GUI constructed from Tk and ttk widget sets using the Place Geometry Manager. &gt; &gt; https://sourceforge.net/projects/page/
It's never safe to run a process like flask as root.
&gt; perfect security is impossible &gt; &gt; That saying kind of disregards time costs &amp; difficulty of physical access.
I'm quite sure a simple ``apt build-dep python3.5`` installs everything you need to completely recompile Python with all standard extension modules. At least it did on my Debian box. (it not only installed ``libssl-dev`` but also ``libsqlite3-dev`` ``libbz2-dev`` and a handful of other -dev packages that are needed to build the various extension modules)
The article links to an $100 udemy course.
My only beef with decorators is that they can make unit testing the decorated function more difficult, but other than that, I've not had any complaints. 
There's almost nothing about Python in there.
just to clarify, only the workers would be running as root
I didn't realize I could give specific access. that works perfectly for me, thanks
Not OP but that's for the info.
You shouldn't run any more services than strictly necessary as root. It's much safer to create specific accounts with sudo access.
Pfft, security. 
Member functions with decorators can make subclassing difficult or confusing or both.
Here's a post that might help you https://www.codementor.io/uditagarwal/how-to-deploy-a-django-application-on-digitalocean-du1084ylz
What are your criteria for incrementing the project version - when I develop I have no single criteria for a fixed version, it is a combination of : - tests passed - sufficient coverage - New features documented - Critical &amp; serious bugs fixed Only one of these has a objective measure that is accessible on my local development machine. In fact I tend to change the version number/release number last. When I know I have something worth releasing. On my projects I commit locally on a regular basis (and at least daily) - even if tests are failing, functionality is incomplete. I push to github every few days - regardless of project status too. Unless you have a very simple criteria for a new version - i.e. a new commit I don't see how you can automate it, and even then I think you would need to write a new plugin which would catch a commit before it happens, and then update the setup.py (or whatever), but my guess is that commit count is not very useful in most projects. Also you could write a simple python script to update a file which is then used in setup.py, and then run it manually each time, but I am not sure what you can usefully do beyond that.
Python 3 Seriously though, you'd have to be more specific.
Pandas will make you feel more at home.
Stop using IDLE, it's terrible. Basically any code editor or IDE and basically any terminal will be better.
There's big money to be made doing data science with Python.
pylint can do single app code copy detection. I need something that spans multiple directories. Tnx for the tip though. I didn't know that. I use atom usually.
It never happens when I need a license. 
&gt; That's interesting, I expect it is only for literal strings? Does micropython forbid runtime string construction entirely? Applies to literal strings; when you construct a string at runtime, memory is allocated on the heap.
A pycharm project can span multiple folders.
Java has decorators. But not like, Python decorators. They use the Decorator pattern in some things, especially when handling files and streams. And decorators do make life easier and code more concise. Just don't abuse them ;)
Show your work!
You should be able to import them if you are running the ipynb file in the same directory as them. Did you change your directory in the script at all before importing? (using os.chdir, for example) ? 
Rust, Haskell, erlang, coq, hell even c++ are sufficiently different from python that they will force you to learn unfamiliar concepts.
In Anaconda Navigator, on the left hand side, click Environments. Then, on the right hand side, change the drop-down from Installed to Not Installed. Then enter your package in the search box. Check the box for it and click the Apply button. If you have Spyder running, relaunch it. Hope this helps.
So how do you handle that?
How would you know if something is within your reach if you don't even attempt to reach in the first place? I guess I can probably relate to what you're saying though. In the past, I felt like I was wasting my time tackling projects that seem to go way over my head. When I look back now, I realize that I gained invaluable experience that was transferred to other projects which were probably at "my level". Also, what's good about discovering challenging things is that it gives perspective on your limitations and may narrow your choices of projects to those which are a less challenging (but hopefully still challenging nevertheless). If you don't just do something, you're just wasting valuable time which could be converted into experience.
fair call. env = anaconda 3 64 bit. but really - there are some packages which do a better job than others of processing badly formed json, I've lost track of which ones handle file formats with more tolerance. unicode errors always seem to cause me pain. 
They're lovely to use but a total mess to write. If you don't want arguments, then it's a function wrapping a function which takes a function and returns a function. If you want arguments, then it's a function wrapping a function wrapping a function which returns a function.
That's neat, but how about 15-30 minutes instead? Then dial it up if it goes off just because he's asleep. That way you might have time to call 911 if he's in medical trouble. At 18 hours, you're pretty much notifying people if he dies...
For a long time it was Perl. But then the there was confusion about the future of the language with the long-awaited Perl 6, and Perl is rather... difficult to read oftentimes. Tcl, Ruby, and probably others I'm forgetting have had niches as well. Python gained popularity because it's common to write an entire program and have it run correctly the first time - it's just very straightforward. In addition, the community has a heavy emphasis on documentation, and the slow natural growth meant that there's almost always a library that does whatever you want to do (often in the standard library). It's not a shiny language, but it's a very practical one that helps you get things done in the most boring and simplest way possible. Just as Perl learned lessons from awk, and Python learned lessons from Perl, so are other languages learning from Python. Something will dethrone it in the future. And that will be fine.
I used to host an internal mirror of PyPI using [bandersnatch](https://pypi.python.org/pypi/bandersnatch).
Awesome thanks, I'm gonna give that a shot right now!
As long as it isn't rust. Mostly because I hate the people in their community. 'Rewrite it in rust' is not a marketing slogan.
Check out Nim. Much of the advantages of Rust (speed, memory safety) but with very pythonic syntax.
Thanks. But i was looking for something more specific. The thing is that the content is only available after I log in. That is not possible using pdfkit with a direct url. What I am currently doing is downloading the entire web page using selenium and then converting that locally stored html page to a PDF using pdfkit. The problem with that is the images on the web page are not available in the downloaded version. Is there a better way to go about things?
Well a very big point for it's popularity is that it's pre-installed on any major linux distro because most of the sysutils need Python. With the growing influx of Ansible we have another candidate which require Python and make it a lot more feasible on bare minimum installations to simply run Python scripts instead of Perl/Ruby/Rust
Sorry I can't share the code.... Again I work as a test engineer at an HDD company. I do a lot of areal density testing. Which is the testing of how to optimize the number of bits we can squeeze in a square inch. I'm using matplotlib and numpy to take a test module's output csv and process it. It creates plots and puts them into a pdf and does a bunch of functions. Basically it's just a major time saver. I could spend 5 hours doing this by hand each time I run the test. Or write this code and get it down to 30 minutes or so.
I really love that python has sets as a builtin type. But, more than that, I love the things you can do with duck typing and all the set operators. Like, when doing geometry, find the intersection of two polygons? A ^ B. Done. Pythonic. Lovely. Assuming you have a geometry library that respects the ducks. Quack quack motherfucker.
Maybe you should pursue high performance and engineer-friendly code, before which you should grasp most of the standard library of python. Just stand on the shoulder of the giant. For high performance, I recommend 'https://github.com/keon/algorithms' (basic data structure) and 'https://github.com/numpy/numpy' (scientific computing). For engineer-friendly code, I recommend 'https://github.com/requests/requests' (HTTP requests) and 'https://github.com/zzzeek/sqlalchemy' (SQL toolkit)
&gt; unicode errors always seem to cause me pain. Perhaps you should learn the foundation of *unicode* and *encodings*? In principle it is quite easy, once you have grasped it! * Read this first: [What every developer should know about unicode](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/) * Read this for some deeper insights and for really good definitions of terms: [utf8everywhere](http://utf8everywhere.org/) * last but not least: [the python howto](https://docs.python.org/3/howto/unicode.html) I put the python related link last with intentions! As the whole topic is independent of programming language, better grasp the concepts first. Then it will be easier to understand the main tooling in python itself: ``decode`` and ``encode``. Good luck! ☺
Did you look at the second link I provided? https://stackoverflow.com/questions/30452395/selenium-pdf-automatic-download-not-working
I don't know about other languages, but the syntax for f2py is very simple, and with numpy's array syntax you can transfer Fortran ideas to Python quite directly
Hey umnikos, To be honest, the one mayor problem I picked up from this thread is your attitude. Don't fool yourself thinking you're a pro at everything, because if you were, you would see actual results of that (no matter your age). This goes farther than coding alone, you can apply it to all aspects of your life. Be open minded and always eager to learn more. It will get you so much further in life. 
As a lover of both Rust and Python this is unfair. One of the things that Rust does that no other language really does is safety guarantees with no performance loss. When you start gluing lots of non-Rust code to Rust you start to lose those. A perfectly good thing to do is to rewrite it in Rust, which a lot of people are doing. It's not about arrogance at all.
With the exception of Perl, which is still used in many system utilities, none of those languages (either interpreter or compiler) are commonly installed by default in basic OS installations.
Of course. Its a 2015 macbook pro 13 inch i tried downloading different versions of python and it didn't help. I suspect it having something to do with my keyboard being european, because when i set it to american theres no problems at all
What do you recommend? I think eclipse is a bit too heavyweight for learning python
use IPython
this. and convince python authors to ditch idle; its dependency on tk means that it can not, in any forseeable future, support proper unicode (only ucs-2, not utf-16). it just works as long as you don't enter "odd characters" (eg. emojii), and then breaks.
&gt; most of the sysutils need Python. Which ones?
Uninstall python and you will find out. Be aware it may be a painful experience
&gt; Windows has more users That's simply untrue. I think you meant "windows has more desktop users", but code doesn't just run on the desktop. Every time you browse to reddit on windows, you're a "linux user", even if you don't own the linux machine serving the content.
Okay, let me give a pretty random suggestion. Use and contribute to [Porcupine](https:www.github.com/Akuli/porcupine). It's an editor written in Python that still lacks features. If this doesn't interest you and you can't find any project there's literally hundreds computer science fields to look into. I would recommend starting with basic algorithmic.
i just downloaded Ipython, but what is the advantage of this, it looks kinda confusing having to use the browser?
I wasn't thinking about physical access. Perfect digital security is undecidable in most complicated systems. If your system is accessible, and you haven't solved the halting problem then your system is potentially insecure. Edit: A mistake there... it's not the 'halting problem', its having every individual physical and logical component of your system be provably secure. Not likely...
&gt; One of the things that Rust does that no other language really does is safety guarantees with no performance loss. Can you explain what you mean by this? I've never used Rust or had a need to (scientific computing in fortran is how I spend my days).
I'm not going to deploy my web apps to your mother's computer. Nor am I going to deploy them to my workstation. I'm going to deploy them to AWS servers running CentOS 7 or amazon linux, where... python is installed by default.
If you are relying on a random github "cheat sheet" for your security needs, then you're already lost upstream. If you're at the case of "I copy and paste security code without reading line #4 in the official documentation for these functions", then maybe you'll also listen to another random github page telling you that`sudo rm -rf /` is guaranteed to remove any malware from your Linux system [1]. [1] This is true. *Technically* true, which as we all know is the best kind of true.
There is a graphical interface for you to shape your Tkinter layouts https://github.com/alejandroautalan/pygubu
We are talking about the popularity of Python, don't know where you see the developers at all in this. But as far as the language my point still stands, every major website, DB etc. is run on linux which make Python a simple solution for frameworks, scripts, automation. Not saying that other languages are more fit for some tasks or that other languages are not used, but for most people adding another layer (another installed package etc.) is simply not an option or not wanted.
Well if we are talking about Desktop Variants, everything that uses GTK+ or QT needs Python as dependencie, graphical software centers like the Ubuntu Software Center and other preinstalled tools. If you are talking about servers, well some startup tools but most importantly nearly all package manager frontends need Python either partially or fully, for example aptitude and yum.
I guess a large part of the reason is that the Python C extension API is very cleanly designed and easy to use. In fact, that's a large part of the reason why Python has the GIL: it makes writing C extensions much easier.
What is also fun is upgrading it globally from 2.7 to 3... 
pip install bumpversion and then make it am external tool
Check out the first ~20 mins of this [talk] (https://m.youtube.com/watch?v=lO1z-7cuRYI). Posting from memory and on mobile so can't quickly confirm, but it should provide a quick intro to rust memory safety. 
What it actually means is that Python is not cross-platform by any stretch of imagination. Unless you stick to standard library.
Fun, if you enjoy reinstalling your distro. 
Python is just pretty though. A real CS language that is also approachable 
What do you mean by “real CS language”?
Did you read through the parameters in the API? You can get the subscriber count from the channel object properties. https://developers.google.com/youtube/v3/docs/channels#properties Edit: More relevant, https://developers.google.com/youtube/v3/docs/subscriptions/list
Bullshit. You can get a lot of work done with pure Python libraries. And you need to compile the interpreter first (or get a binary package), and if you can do that, you can get those C extensions to work too.
Thanks! Boy a lot of reading to get to...
&gt; everything that uses GTK+ or QT needs Python as dependencie Python is not listed as a dependency for gtk3 or qt5 on my system. &gt; other preinstalled tools. Which ones? &gt; some startup tools Which ones? &gt; nearly all package manager frontends need Python either partially or fully, for example aptitude and yum. My package manager does not require python.
&gt; Uninstall python and you will find out. Be aware it may be a painful experience Wouldn't it be better to list installed packages that require python?
&gt;What is also fun is upgrading it globally from 2.7 to 3... Why not keep both installed?
&gt; My package manager does not require python. But the frontend does. If you look at something like Linux Mint 90% of it's interface is written in Python working on top of C framework like Qt or GTK+ Try installing desktop Linux then deinstall Python, you'll have a lot of fun
Nim is my bet on next Python. And it's faster than C in some cases.
Fully functional general purpose language. 
We do this not because it is easy but because it is hard
lol
&gt;But the frontend does. Which one? &gt;If you look at something like Linux Mint I'd rather not. &gt;Try installing desktop Linux then deinstall Python, you'll have a lot of fun I have desktop linux installed. The only thing that requires python is gdb. I would rather leave it installed.
&gt; Python gained popularity because it's common to write an entire program and have it run correctly the first time Python also attracted/targeted scientific communities *very* early on, "matrix-sig" (which borne packages ancetral to numpy e.g. Numeric and Numarray, and lead to inclusion of convenient array syntaxes into Python like slice steps and optional tuple parens while indexing) was created in 19*95* (Python 1.2~1.3). Python only exploded in these domains in the early 00s, but communities had laid the foundations and targeted the domain for a very long time.
(I think your original phrasing is pretty strange.)
The distinction you make isn't necessarily a good one. What you're really saying is that the libraries are compiled and your code isn't. When you are building a C application, you rarely ever build the entire stack from the ground up. At the very best, you statically link all of your pre-built libraries (which at that point are not in C but rather in machine code) but in many cases you simply link dynamically. What you *think* is happening but really isn't is that C libraries have interop capabilities with your C program out of the box. This is actually not true as evidenced by keywords like `__cdecl`, `__stdcall` and `__fastcall`. Library writers (like Microsoft and Apple) have gone through tremendous efforts to make it so that these things are masked away in the API (e.g. WINAPI is a typedef for calling convention). But there's a boat load of other things that are implicit in C libraries, like memory and resource ownership rules, threading, io etc... this is why a project like OpenCV has memory primitives. Things like the COM standard (ancient by now) have no other purpose than to specify a binary compatible standard and they do so with considerable effort and often times are still incomplete... **The bottom line is this:** languages are *not* meant to implement functionality, they are meant to define expressiveness. A good language will *not* implement IO, nor will it implement threading. Threading, io, memory are all services the OS provides... Versatile languages will put as few barriers in this goal as possible. (the gil is an example of a barrier) Having said this: C isn't a language that is universally compatible, C is simply a language that has **no** barriers to anything. It is barely a layer above assembly. Take note, for instance, just how much finickier even C++ is when it comes to libraries. Umpteen efforts must be made to make a C++ library coexist in a C# or Objective C project. Sometimes it is outright not possible. Python has the gil, but in general has made a good effort to play well with other languages. **Python is a glue only in that a language is always a glue.**
So that just means you are a special snowflake :) I'm not going to play cat and mouse here. I don't know any Linux not using python. But if you got yourself compiled one then you might have one. For instance here's a simple Debian 8 server without almost any additional packages: python2.7 Reverse Depends: zaqar-common yapf volatility vmdebootstrap python-sphinx-testing python-senlin sahara-common python-yaql python-troveclient python-tempest-lib python-senlinclient python-saharaclient python-restructuredtext-lint python-reno python-pulp python-pecan python-pbr python-osprofiler python-oslo.rootwrap python-oslo.policy python-oslo.messaging python-oslo.config python-oslo.concurrency python-openstackclient python-novaclient python-neutronclient python-muranoclient python-mistralclient python-manilaclient python-magnumclient python-keystoneclient python-jsonschema python-ironicclient python-heatclient python-gnocchiclient python-glanceclient python-glance-store python-gabbi python-doc8 python-cinderclient python-ceilometerclient python-barbicanclient python-aodhclient python-trove python-openstack-doc-tools python-nose |nodeenv neutron-lbaas-agent neutron-common nagios-plugins-contrib murano-agent mistral-common python-migrate manila-common python-magnum lavapdu-daemon lavapdu-client lava-tool lava-server lava-dispatcher lava-coordinator atac python-jenkins-job-builder python-ironic-inspector python-gnucash glance-registry glance-glare glance-common glance-api freecad falcon python-django-restricted-resource python-django-kvstore crmsh cinder-volume cinder-scheduler cinder-common cinder-backup cinder-api ceilometer-common ceilometer-collector ceilometer-api ceilometer-agent-notification calibre-bin calibre python-bandit aodh-common python-alembic python-uno zope2.13 |python-zope.traversing python-zope.testbrowser |python-zope.sqlalchemy |python-zope.sendmail |python-zope.publisher |python-zope.i18n |python-zope.dottedname |python-zope.copy |python-zope.cachedescriptors |python-zope.authentication python-zfec zeitgeist-explorer |python-zdaemon python-zconfig |python-zc.lockfile |python-xpyb python-xmlmarshaller xen-utils-4.4 |python-xappy |python-webpy |python-vte volatility |virtualbricks |virtaal |python-viper vim-youcompleteme |python-van.pydeb utopia-documents |python-txaws python-twisted-web2 |python-twill |ttb trace-cmd |trac-xmlrpc |trac-wysiwyg trac-virtualticketpermissions |trac-subtickets |trac-sensitivetickets |trac-roadmap |trac-mastertickets |trac-jsgantt |trac-httpauth |trac-diavisview |trac-customfieldadmin |trac-bitten-slave |trac-bitten |trac-announcer totem-plugins |tilestache |tilelite thuban |python-tftpy texlive-science |texlive-extra-utils python-telepathy |python-strongwind |python-storm stimfit python-springpython python-sphinxcontrib.blockdiag |python-sourcecodegen python-smartpm python-slides |python-sleekxmpp |python-simplegeneric servefile python-seqdiag seekwatcher |screenkey |python-scour python-scapy rss2email |python-rfoo |remuco-base |rdiff-backup qgis-plugin-grass-common qct |python-pyxmpp |python-usb python2.7-minimal python2.7-minimal python2.7-examples python2.7-doc python2.7-dev python2.7-dev python2.7-dbg libpython2.7-stdlib libpython2.7-minimal libpython2.7-dev libpython2.7 idle-python2.7 idle-python2.7 idle-python2.7 |python-wordpresslib |python-vsgui |python-unshare |python-unipath |python-ucltip |python-trml2pdf |python-tidylib python-textile python-sunlight |python-slimmer |python-simpy-gui |python-simpy python-setupdocs python-recaptcha |python-quantities |python-pysqlite2 |python-pysnmp4-mibs |python-pysnmp4-apps |python-pypcap |python-pymetar python-pyknon python-pmw |python-passfd |python-omniorb-omg |python-omniorb |python-mrjob |python-mpd |python-mox |python-mongoengine |python-minimock |python-midiutil python-messaging python-medusa |python-macaron |python-lzo python-loggingx |python-ldap python-krbv |python-kinterbasdb python-jswebkit python-iplib python-iowait python-iniparse python-gvgen |python-gudev |python-gtkglext1 |python-gnatpython |python-gmpy |python-gitdb python-geoclue python-gearman |python-fudge |python-formalchemy |python-fftw |python-enum python-enthoughtbase |python-easygui python-django-websocket |python-django-shorturls |python-dingus python-defer python-all python |python-coverage-test-runner python-configglue |python-bitbucket |python-async |python-amqplib python-adns |python-pytest-xdist |pytagsfs |pyroom |python-pyramid-beaker |python-py++ python-parallel |pyp python-nifti |pyneighborhood |python-mecavideo python-pyme |python-logsparser python-pylirc python-gtksourceview2 python-pygrace |python-pyfribidi pyflakes |pyew |python-pydoubles |python-pydhcplib |python-pyao |python-acidobasic python-radix |ptex2tex preprocess pida picard perroquet python-pebl python-pdfminer python-pcapy python-pastewebkit python-pastescript openteacher |openbmap-logger python-ooolib |ontv omniidl |oidua python-nwsserver python-nwsclient python-nwdiag |python-nosexcover mysql-workbench mypaint |munin-plugins-openstack |python-multipartposthandler mozo |moosic |python-modestmaps |python-mocker python-mlpy mandos magicor python-libvirt python-uno |python-liblicense |python-extractor |python-ldtp |ldtp |python-ldaptor |python-lazyarray |python-landslide keymapper kapidox |python-kaa-metadata |python-kaa-imlib2 |python-kaa-base |python-jabberbot python-inotifyx idjc |identicurse |ibid |hamster-applet gtranslator |gtk-recordmydesktop |python-gst0.10-rtsp |python-gst0.10 python-graphy |gnome-specimen |python-gmenu gnome-hearts |gnome-doc-utils |gnome-btdownload |globs gimp |python-genetic gdesklets |python-gaphas python-galleryremote python-funcparserlib |python-freshen |python-freevo freecad |python-fmcs |python-ferari python-fdsend |python-eyed3 |python-execnet |python-etk.docking |eficas |python-easyzone |python-drmaa |doconce python-django-genshi disk-manager |python-creoleparser python-commando cluster-glue |python-ckanclient python-cheetah |cfv calibre-bin calibre burn bup python-bobo python-blockdiag bitpim-lib |python-beautifulsoup |atheist aptoncd |apt-clone python-apipkg python-adios libadios-bin And that's without scripts which start with #!/usr/bin/env python There are thousands of them
Look at your own needs first. Being your own first user is super helpful, plus it'll keep you focused and motivated.
&gt; a simple Debian 8 server I wouldn't classify Openstack as simple.
I’d never thought about the interpreter lock that way, but it makes a ton of sense for what is (or at least, was) effectively a procedural, monothreaded language. This sort of leads to an interesting thought experiment - if Python’s primary implementation were a language with first class asynchronous support (like IronPython with C# async/await for instance), what could Alternate Parallel Universe Python look like? Would it have evolved something more robust than coroutines? Perhaps a block based model like Swift/ObjC?
Then open upwork.com or even indeed.com to see a list of real projects or jobs. Pick one and work on it. 
What do you mean by "engineer-friendly code" ?
So you're saying "just try to make something and if you fail try to make something else" ?
Being a little naive and clobbering sudo like it is yolo :)
Doesnt Nim compile to C?
A lot of new developers that are now considered programmers have come into the industry, mostly JavaScript, which is in my opinion not a very good language, and definitely not standing upon the plinth of syntatic sugar Olympics. 
Try atom. Out of the box it's decent, but it's very pluggable and there are many good plugins and themes for it.
&gt;&gt;If you look at something like Linux Mint &gt;I'd rather not. Come on man, you can't take an explicit example they provide and then just refuse it
The language itself supports threading. That's not the issue. The difficulty is sharing references with 3rd-party C code when there are multiple threads running simultaneously. Java has solved that, but the result is that JNI is famous for being a terrible API to work with.
2.7 is installed by default
&gt; Come on man, you can't take an explicit example they provide and then just refuse it Why not? Linux mint is not a sysutil. My point is that most of the sysutils do not require python. Except gdb.
&gt; languages are not meant to implement functionality, they are meant to define expressiveness That right there, is deeper than a Java call stack
There are some cases when a decorator returns something other than a function and does not retain the signature of the function (when the decorator is a class you end up having an instance of that class instead of a function) and can make reflexion more complicated than it should. Also, I encountered some cases when multiple decorators were applied on the same function and if you changed their order, the code breaks. You have to be extra careful to design and implement your decorators properly and not make then dependent on what they decorate.
Which I also think is a huge factor in the slow adoption of python3. It's actually a really big pain to deploy python3 to RHEL 6-based distros like CentOS 6 or amazon linux.
I know right! Everytime I have to put the lastest version of python 3 on an aws server it always takes me atleast 10 minutes of googling
Not sure we connected here. Let’s try another example — if the interpreter were written in Rust, ignoring the dates here, would we have seen more robust extension support and/or no GIL? My point is that it is an interesting thought experiment to remove C from the equation for exactly this reason.
I guess I got lucky then by having my 200k line code with a very nice GUI to work on Linux and Mac without ever having explicitly developed for them. It's harder to make code Python 2.7/3.6 compatible than it is to make it Windows/Linux/Mac compatible, but I and many other projects do that too.
Tkinter?
Guess what? A lot of useful libraries are not shipped in binary builds for all platforms because they are written in bloody C/C++ (whatever C vs actual C++ ratio it means). Sometimes you have only sources, sometimes you have only .deb and no .rpm, sometimes only .tar.gz, sometimes they even say that building on Windows is not tested and supported. Why? Because Python is possibly the SLOWEST language in the world so nobody actually writes in Python - they write for Python batteries and if you don't have a battery you're f***ed Python standard library without Tkinter (which seems to be used by nobody) and some other bells and whistles is just like any other language standard library: console IO, multithreading and file operations. Yes, Python is one of the most expressive languages, but it doesn't extend to standard library
And looks like Python stdlib is not enough for pretty much every field of industry: for Web (nobody uses Python standard http server in production and there is no templating unlike in Go), for desktop (nobody uses Tkinter), for science (SciPy and NumPy are not stdlib)...
We don't use openstack, even if some packages got included they are default on Debian 8 base (yes we install standard utilities and openssh only).
Yes, pip is great. It even can work properly if you have no Internet access (unlike npm). But there are numerous packages that cannot even install without raising some exceptions (under Windows and some under Linux). And yes, many of those exceptions are C-related.
Show me a language that has a good, modern, likeable standard library.
Why would you care about standard library? It’s hard to do anything useful in most language while limiting yourself to the standard library. On the other hand, I can pick the best libraries that do what I need, and I don’t need to litter my system with low-quality libs, or libraries I’ll never use (eg. the scientific stuff)
Saw your username, f2py is a godsend for all of us who inherited some ancient astrophysics Fortran code from our supervisors!
Thanks for your help. I believe I understand it now, so somewhat less confused.. :) I've updated my notebook and now back to my project (to which this was a bit tangential..).
It's also great when you just can't quite figure out how to mangle the correct numpy commands to do what you want, buy you can just write a dumb loop in fortran and import it and it'll work fast without requiring much thinking.
&gt; I legitimately want to know why anyone should use the library. I use and hack Django-hotsauce to learn Python. Thinking different in software development is an elegant way to become fluent in Python programming. 
Unless you're on Arch, and that's the default.
It's a matter of taste. I'm not sure that you should have everything you need in the standard library - it's perfectly normal to have third-party libraries. But they should be written in this language, have proper package management, etc. And in case of Python you can hardly find any useful pure Python libraries (maybe some middleware like SQL dialects drivers).
We didn't connect at all. I read "it makes a ton of sense for what is (or at least, was) effectively a procedural, monothreaded language" and thought the language you meant was Python. If you're talking about C then I guess my reply is that C isn't inherently monothreaded. It's not because of the language that we have the GIL.
Could you elaborate a bit on what your field is and what libraries you use?
Thanks that was really great.
Compare python to the alternatives: * Perl: hard to read, hard for non-developers to learn, Perl 6 never arrived. * Lua: never got much momentum, too small a base language, and too small a standard library. * TCl: I like it personally, but the lack of (built in) OO put off people used to OO. There were other issues and there are *lots* of interesting discussions about why TCL failed (because many people really love it). * Lisp variants (like Guile): fragmentation, and very different from languages most people had already learned. * Ruby: Not really sure, but I think it just lagged behind in adoption outside web development. 
You're going to have to provide way more detail than that, as well as a concrete and actionable request.
I've had the same talk with him, I wanted to reduce the time to 12 hours, he had none of it. He doesn't want to be a burden on anyone, hates the idea of people worrying about him. He's a lovely chap, when I saw him yesterday I forgot to ask him about a panic button. Easy to add though :)
That's not really an alternative to eval-ing code, it's just a different way of achieving it. You're still injecting untrusted code into your application, the security problems that come with `eval` apply here just the same. All you're doing is making your life harder for no good reason.
I'm pretty sure a lot of the updating apt is doing is done with python.
You're looking for **compile**, **exec**, and the various tools in **importlib** (or **imp** if you're using earlier version of Python).
You better got 'security' right.. -&gt; people gonna try it. beside that.. - it looks good, and works nicely! :-) well done
Readability, expandability, reuseability.
You even have CAD on it. I have servers running (web, dns etc) and never even heard of most of the packages here. Also you can safely exclude everything that starts with python- since obviously python packages will need the python interpreter. 
What, you don't think it's fun to nuke your computer and reinstall? 
That isn't iPython, that's a jupyter notebook, which happens to use ipython in the backend. Confusingly, it did used to be called an iPython notebook. iPython is just an alternative shell/ REPL which is much better than straight python, or IDLE's shell. That and an extensible text editor like VS Code, Sublime text, or atom (in that order of preference) might appeal to you. If you want to throw yourself into the deep end, some people like vim or Emacs, which are ancient, extremely deep, highly extensible command line text editors. I personally use Pycharm, which is hands down the best python IDE available. It's pretty resource hungry, though.
That would be too easy. Where's the fun if you don't have to fix your shit immediately after?
Because there is no one way to do it, everyone does Python deploys differently. * Some people sudo pip install everything in a docker container * Some people setup a virtualenv on a the server directly * Some people package everything up in a deb, sometimes including the virtualenv * etc etc
actually its a *must* to have both installed. too many apps work with only one and not the other. it's my least fav aspect of pyhon.
[This keynote by Jake Vanderplas](https://www.youtube.com/watch?v=5GlNDD7qbP4) talks (among other things) about the whole process of how NumPy came to be. Very instructive.
Technically, Bash was always more glue than Perl, and still is more than Python. But Python is gaining on Bash. The overhead part of the overhead/convenience ratio always disfavored Bash, but Bash has a hundred times the convenience of its predecessors like JCL, if you want to go back to the '60s-70s.
Accidentally uninstalled python on my fedora box once. Can definitely say it's not fun, would not recommend.
Readability !
&gt;The performance isn't as good as Python's Knowing almost nothing about Ruby, this already does not bode well when one of them primary criticisms for Python is its performance.
I had not considered this approach at all. I suppose I could setup a virtualenv, pip install from a URL, problem solved, sort of. The difficulty here is that plugins might have different dependency needs. If plugin A depends on libv1.0 and plugin B depends on libv1.1 I may have some problems here. Which is why plugins should bundle everything they need.
yes this problem is windows related
Maybe because Python is one of the better options for Machine Learning and Data Analysis. You can get a lot of very good packages there for free and there's lots of people to answer questions on Stackoverflow. On the other hand, while Python apparently can be used for mobile development on Android, it's far less common. Here, languages like Java or Kotlin are used much more often. Sounds to me like a case of using the right tool for the right job.
It's a bit complicated to explain in a reddit post. Also I'm in the middle of nowhere right now for the eclipse. If you want to know read a bit on Rust as it's its most primary feature. Basically it enforces strict ownership through the compiler. This allows the compiler at compile time figure out where all memory needs to be dynamically allocated and freed and also what function or block of code owns any piece of memory. This also allows race condition free multithreading.
&gt; plugin A depends on libv1.0 and plugin B depends on libv1.1 I think you will need a benevolent dictator to deal with that type of problem as , AFAIK, there is no other solution.
benevolent dictator? I think you misunderstand, the plugins are not shipped with the product. The plugins would exist in a repository of some sort. Think Java + Maven
If the config files are so complex that you almost have to invent a programming language (luckily this is rarely the case), I usually just let users write a .py-file. Yes, it is not secure in some scenarios, but so is giving the users a shell where they can do things. Probably comparable, if you wouldn't give them a shell, don't execute their Python code, either. Of course, one should not accept and execute .py-files from anonymous users on a server. Often, people already know Python, so they feel right at home and there's no doubt about what they can do. No need to learn a complex YAML structure by heart. If you are already very far into this, you could export the code to a .py-file and load that using importlib mechanics. This also allows you to look at your generated code.
Thanks for your reply and /u/all_my_watts linked me to a youtube video that explained it quite well also. I've spent the last couple of hours learning more about this. :)
 It's possible that your experience in a small class of untrained people doesn't match the world as a whole. I can't explain why it's suddenly become popular in your class as I don't know who's in it. In industry and education, Python's been popular for many years now.
thanks for saving me a click.
The problem with perl is that while modern perl allows it, it still allows to write programs in any way you want to. So if you have 10 programmers, you can have 10 different versions of how to write 1 program. And some people just love "wicked smaht" undocumented oneliners. Python was more focused on one simple way to write code from its conception. Plus great focus on documentation. Its very straightforward and easy to pick up. 
Did this, it literally broke everything.
You will need to manage and plan for upgrades as there is no viable method to use multiple versions of the same module in one python process.
Most of the RHEL toolchains are based on python 2 with EL6 being 2.6 and EL7 based on 2.7.5. EL6 end of primary support is 2020 and extended support is listed as 2024 and EL7 is 2024 for primary and probably 2028 for extended. So python2 will probably continue to be the basis for RHEL tools for a number of years ( unfortunately ). The next hope is that the tools in fedora get a refresh before EL8 gets fixed.
I think the current RISK with python is that its fixation on single threaded performance may become a liability as CPUs continue to lose ghz in favor of cores.
Nope. Just build it somewhere and include it in the path. Users can use pip or virtualenv to add additional modules with little to no effort. We recommend that users that need the latest and greatest just maintain their own copy since it's so easy. EDIT: Building is easy but if you take offense to the DIY then just use the SoftwareCollection. https://www.softwarecollections.org/en/ 
Ty it worked like a charm.
Found the arch user
Thanks. I ironed out the security bits. 
Which one did you choose? I started out with Automate the Boring stuff with python as a complete beginner know nothing about nothing and it gave me an excellent base. But i had also bought (havent started it yet tho) The Masterclass. The one with like over 30hrs which is quite a bit.
I think Udemy now has stuff for businesses and group learning/training.
hmm So essentially I can't import an entirely self contained module is what you're saying? now I'm not sure how I can accomplish my task. If this was Java, java devs would just produce all-in-one JAR files and be done with it. Dependencies within the jar are only used by classes in that jar. Thus each JAR is kept isolated. I suppose a worst case scenario would be setting up virtualenvs each time a plugin is needed to be used and use some kind of subprocess trickery to make it work but this comes off as overkill. I dont' want to say this, but maybe python isn't the right tool for this :(
It's not really the language Python was written in, but the era. Python is actually older than Java. The issue is that Python was created when we had single core machines and nobody was really thinking about multi core programming. When multi core machines started to appear the issue was fixed quickly by introducing GIL. The removal of GIL itself is actually not as hard, the problem with it is that Python becomes painfully slow or breaks existing code (mainly C libraries). When Python is rewritten on different language it is not 100% compatible, most often it doesn't support C extensions and uses different garbage collection, but that's acceptable because the port is not exactly CPython. So what I'm trying to say, the issue here is not the language Python was written but some of Python features that we ended up rely over the years. Larry Hastings has nice videos explaining the problem titled "Gilectomy". Here is one of the first: https://youtu.be/fgWUwQVoLHo he also updates on the progress and I see a new video that is 3 months old but I have not yet watched it yet, but you can easily find it by searching gilectomy on youtube.
I wouldn't call it a wrapper, maybe a glue gun, screws, and an Allen wrench. A python program is like Ikea furniture: you get a bunch of basic components, like a few slabs of Fortran and some C hinges, and Python then into a few hinged slabs or whatever.
The main "problem" with lisp is that it's not focused. It's more of a tool to make your own language. Start working on a large and complex problem and you end up writing a lot of problem-specific parts of lisp. Great in some fronteer cases, but for general stuff it can be pretty meh. 
&gt;Something will dethrone [Python] in the future. When you play a game of thrones you win or you die.
I'll try this. I think they might have used the terminal to do that instead of through the notebook. 
Well this works with packages that come with anaconda or ones that can be install via pip. My custom packages (which are just python files) don't seem to show up there regardless of where they sit on my hard drive, do they?
It's not that big a liability when using C and FORTRAN code as OP describes. For example, Numpy releases the GIL AFAIK. 
&gt; Yes, it is not secure in some scenarios, but so is giving the users a shell where they can do things. That's a really important point that a lot of people don't realize. If your user is going to be executing the python code locally then there is NO SECURITY at all. Which means you don't have to think about it. Just let them execute whatever python code they would like to. Feel free to throw as many `eval`s into the code as you would like. From a security perspective it makes no difference. Only from a usability perspective or a code stability perspective does it matter.
No we don't, these are all packages which depend on python, the one marked with | are installed in our systems. Most of them are default packages which come with base debian 8
RHEL is damn-near single-handedly keeping Python 2 in the public consciousness :-/
Can I study Reinforcement Learning in another language? 
You can't really use format strings with the default logger. The problem is that the logger has a single function that it knows how to call to format the messages, and it knows this at the level of the root logger. By default that function is the old style `%` formatting method. You could override it to the `.format` function but then a module that your import could log with `%` style and that could cause a crash in your code. So you can really only safely log with `%` and not with `.format`. Either that or audit all the code you import.
Lisps have been used as scripting languages, and have been developed as such AutoLisp, EMACS Lisp and Guile. That said, I am not disagreeing with you that it is not a good fit for the sort of thing we are talking about here. 
&gt; Perl is rather... difficult to read oftentimes. I like the understatement. 
Don't forget that even EL7 is php 5.4 which is already unmaintained upstream and they will maintain it through at least 2024.
Except that Python and Ruby are usually used where performance is not critical - or at least the performance of the Python or Ruby code is not critical because the heavy work is done in a C library (or similar) or calls to the OS.
Which language ?
Hmm, I think I have an idea of what you're trying to do. You could possibly create a metaclass that accepts some of these variables and returns a function. def generate_function(name, defaults, kwdefaults, code, *args, **kwargs): def archetype(): pass result = deepcopy(archetype) # Making a standard function dir. result.__code__ = deepcopy(code) result).__name__= name # etc return result You can use this and then mess around. Variable names are inside function.__code__ at various places. If you want to add things to a module you will probably need to know the fully qualified name. globals()['module_name']['submodule_name'].__dict__.update({function.__name__: function}) 
perl and ruby are preinstalled on most systems and at least perl has been for a long time.
You can determine if this self-described hack is a viable way of arranging for two versions of the same module to co-exist in one process. https://github.com/mitsuhiko/multiversion
Personally I don't like Ruby, because it "smells" like Perl to me. The issue there is that the language has a lot of syntactic sugar and encourages cleverness like Perl does. People who like it think that they write superior code, trying to be as clever as they can, in reality they are writing unreadable hard to debug code, that's a nightmare to navigate through for anyone new. Python also allows such "cleverness", but has limited capability to do that.
I'd argue this had much to do with the language making so much sense. It's easy to scare away scientists with Perl.
&gt; Just as Perl learned lessons from awk, and Python learned lessons from Perl, so are other languages learning from Python. Something will dethrone it in the future. And that will be fine. Which reminds me of the Christian Tismer quote from [Why is Python popular, while Lisp and Scheme aren't?](https://mail.python.org/pipermail/python-list/2002-November/141486.html) `Python is the second best programming language in the world. But the best has yet to be invented :-`. 
Claiming that people are "linux users" because everything in the "backend" of the internet is using Linux is a bit like arguing that everybody drives rubber cars because their tires are made of rubber. 
Can you tell us little about how it works, how it executes? Are you using 'exec' or 'eval' for example?
Well no, but if we were discussing a property specific to rubber, it would certainly be relevant to a discussion about cars.
Well yes. When people say "I use Linux", what they mean is they use Linux as their desktop OS. Nobody means, "I use it indirectly every time I use the internet". That's a silly interpretation of the statement. 
Exactly. The issue with perl isn't so much the initial development, it's maintainability. I've had difficulties untangling *my own code* after a sufficient amount of time had passed. Looking at one of my peer's scripts recently I was reminded of a line from Deadwood: &gt; The why is what fuckin' confounds me. What's in his head, I cannot fuckin' find in mine!
Python's learning curve is ideal for almost everyone (from student to mathematician,...). Problem with Python is pure performance, but all algorithms does not require low level optimization. Most people does not want to rewrite the fastest sort algorithm. We just need a "just fine" block that does the job and connect to other block. So now, we have the building block (numpy, ...) that are written in C for optimal performance, and the "glue" that is exposed in Python.
That doesn't sound like "a total mess". It sounds more like "very simple". And yes, I've written decorators, both with and without arguments. I've even written decorators that can be called with *optional* arguments: @decorate # no argument form def spam(): ... @decorate(arg) # with arguments def eggs(): ... Now *that* is messy, you have to write the decorator to dispatch on its first argument to either the decorator you want or a decorator factory, I don't recommend it. But just a simple decorator factory that takes arguments and returns a decorator? That's a doddle. 
Hey, I just do python yourfile.py in a container 
&gt; they can make unit testing the decorated function more difficult Huh? How is that? From the perspective of the unit tests, how do you even know whether the function is decorated or not? You're calling a function. How that function was created is irrelevant.
It will probably be GO. Last I read Google pays Guido for 50% of his time to be on Python. No doubt they are taking the lessons learned and applying to GO.
Gravity couldnt be seen, that doesnt mean its not there and its useless. Python is like gravity. It glues together everything but cannot necessarily attract attention.
Indeed; when used as a glue code, the GIL is no obstacle, because C libraries are free to do their own parallel tricks.
You generally don't want to build non-web guis in python either, at least not for a broadly distributed application. I mean, you can, but your users will complain that wx or qt or tk isn't native. People usually build the application backend in python and the front end in c# or swift. I think you can do native GUIs from python on windows if you use ironpython, but then your OS X or Linux clients will be a little klunky.
I would postulate that installing python is a trivial matter-- I know I can get vi on any server I log into for instance. That was likely the reason I never adopted emacs-- maybe it was there, maybe it wasn't. I could usually count on bash being there, I've gotten good at bash-- but it isn't great at a number of things. I have used TCL to do things-- but those same things were generally easier with python and python was there more often to do the things bash left much to be desired for. So, availability based upon trivial install and as a sibling to bash that was more suited to certain tasks for me...
We're not discussing operating system market share in general, we're discussing market share as it relates to application deployment and ease of use within a specific niche. And most overall computation in python's niche (mostly serverside/backend) happens on linux.
We aren't discussing either of those things. 
For example, if the function you're testing was decorated with a "retrying" decorator, your function would retry as part of the unit test. If you have delay timers in the retry, it will add that delay to your tests. I couldn't figure out exactly where to mock out the delay function of the timer, or how to remove the decorator's functionality entirely for the unit test, so now I just have slow tests. 
&gt; nobody uses Python standard http server in production Because SimpleHttpServer is not meant to be used in production, nor to be a "standard http server" - "**Simple**" should give you a hint, as should its superclass **Base**HttpServer. SHS is a utility server to be used as example and to subclass if absoutely needed, and BHS is basically an abstract class. Python does not have a "standard" or "production" http server, which is just as well given the intricacy of the protocol; look at the development effort that goes into apparently-simple Requests, and how hard it is to "do HTTP properly in production scenario". Pretty much all other languages have similar issues and have a separate effort for production-grade http servers, like Ruby and so on. C# "standard" http server is a behemoth like IIS... Come on man, you're clutching at straws. &gt; for desktop (nobody uses Tkinter) TkInter is actually surprising popular in some circles, but certainly PyQt and PyGTK are more popular. In any case, doing cross-platform desktop development is still a black art in any language, with everything eventually requiring some bridging to native libraries on different desktop implementations (Windows, OSX etc). &gt; Python stdlib is not enough for pretty much every field It's actually enough for *all* of them, by staying very high-level and eschewing implementation complexity, and leaving it to extensions to fill gaps where required. Because someone learnt a few lessons from the disasters of Java / Swing and its "write once, run *badly* anywhere": trying to do too much and too low a level, is a recipe for failure.
&gt; sometimes they even say that building on Windows is not tested and supported. Why? Because for a long, *long* time, building anything on Windows was literally *expensive* as well as a real pain in the ass. Things have changed a bit of late, but it's still much harder than "apt-get gcc binutils-dev &amp;&amp; ./configure &amp;&amp; make". &gt; nobody actually writes in Python - they write for Python batteries "Batteries included" refers to the stdlib. You are arguing that people don't write for the stdlib. If you want to troll, at least get your buzzwords right.
deleted ^^^^^^^^^^^^^^^^0.6467 [^^^What ^^^is ^^^this?](https://pastebin.com/FcrFs94k/57950)
/r/flask or bottle is much more lighter and apt for beginner. The graphs are in JS so it's not dependent on the framework.
Yes, highly optimized C. So when people talk about Nim being "faster than C" what they really mean (whether they know it or not) is "faster than C a normal C programmer is likely to write".
Perl is still pretty big in biology. That said, it's pretty easy to scare anyone over 30 with perl. 
If you remove C from the equation, you lose tons of popularity. Python is popular as glue code *because* it has relatively simple C entry points, not *despite* that fact. Look at Java and the shambles that is JNI for comparison. And as /u/larsga said, there is nothing inherently monothreaded about C.
Had to reformat last time I tried to install 3.6 on Ubuntu. :/
As an I.T professional that specializes in network engineering I use Windows but do all my coding in cygwin, reason being there is no Visio for Linux. I love Linux, I'm old school, would rather use a window manager (enlightenment) than a desktop any day but it is what it is.
u/kylebythemile, could you please stop spamming your company? You, u/Alexa_di, your alt u/kyledevyay, u/coolrivers... I realize that the rules for self-promotion have changed, but it's basically all you do. (u/coolrivers gets a bit of a pass though because they don't spam the shit out of programming subs.) Sources: * https://www.reddit.com/user/kylebythemile/submitted/ * https://www.reddit.com/user/kyledevyay/submitted/ * https://www.reddit.com/user/coolrivers/submitted/ * https://www.reddit.com/user/Alexa_di/submitted/ * https://www.reddit.com/domain/appendto.com/ * https://www.reddit.com/domain/developintelligence.com/ * https://www.reddit.com/domain/stackshare.io/ Your name specifically doesn't show up in the stackshare.io search; that's because they've all been removed. Here's one as an example: https://www.reddit.com/r/PostgreSQL/comments/6n41qe/circleci_transitioned_to_postgres_after_some/ As a bonus, here's one where u/Alexa_di pings you by name: https://www.reddit.com/r/WebRTCdevelopment/comments/6p7upz/how_webrtc_has_changed_web_communication_read_our/ Please stop, it's really annoying.
&gt; Last I read ... must have been a long time ago, since Guido has been working at Dropbox since 2012.
Did that myself. Yeah it was a painful experience
Check out `types.FunctionType` which is close to what you need. Unfortunately its mostly undocumented. But I hope you trust your users, because you're letting them run code with whatever permissions your application is running with.
Pypy in my experience is still a little raw in terms of reliability. I've also flirted with numba and other JIT compilers, but I always find most of them are inconsistent in their results. When they work they are awesome, but I've had times where PyPy ran slower than vanilla python. 
I agree with, sadly, Perl (I hate that language so much) but I've never seen a linux distro with pre-installed Ruby, mind giving me an example?
&gt; If your user is going to be executing the python code locally then there is NO SECURITY at all. That's an exaggeration. They're running code with the permissions of the running Python process, which can be limited. (Don't run your application as root.) You could run the process in an OS chroot for even more security, or in a VM. None of these things are foolproof, but they're not "no security" either.
From what I have read, that could be Go. Would it be a good choice to start learning Golang?
You are probably asking the wrong question. You should be looking at WSGI deployments and stacks. Django, Flask, Bottle, they are all just WSGI apps. Once you get your head wrapped around that it becomes pretty easy to figure out an implementation that will work with your constraints. Also don't be afraid to change your stack up a little if what you deploy isn't working for you. Analysis paralysis will ensure you don't have running software.
Ruby often if not usually isn't I've encountered systems with Perl but not Python, however
Long time perl programmer, from 92 to 2007 or so. I learned ruby in 2002 and python in 2005 and use them both. I really like python as a glue language because IDLE rewards you for writing and testing your code one method at a time. You end up keeping your code neat, modular, easy to unit test because it punishes you for attempting to write your script as one giant unnamed method. It's faster to write it in IDLE, it's slower to hack up an unmaintainable mess. With glue code this more noticeable. 
Ruby is slow unless you're willing to use jruby and throw ram at it. 
&gt; and Perl is rather... difficult to read oftentimes. Some of my coworkers refer to Perl as a write-only language, sometimes
Um, one, link to video please. Also "XYX made easy, part **ELEVEN**" does not inspire confidence.
Ruby, like perl and c++ work best if you can get agreement on what features not to use. This is the flaw of kitchen sink languages. If your team is willing to stick to idioms, ruby is really nice. Nicer than perl. 
For posterity again: this is a nicely documented fork that works well and is slightly easier to install than the microblog version. Thanks so much for your help!
Not really - tbh the whole thing is a massively silly idea and I'm probably way too late to contain the worst harm. I have already expressed concerns - sometimes you have let events unfold.
Yum is written in 2.6. This is why cent6 (iirc) still had 2.6 as the default version.
I thought all code should be written like this...
Okay, but that's not because of the decorator. If you had programmed the "retry" directly inside the function, you'd have the same problem. In Python 3.x (I forget exactly which version it started) the default `functools.wraps` decorator adds an `__wrapped__` attribute to your decorated function that gives you access to the original. Prior to that, it's easy enough to do by hand: def decorate(func): @functools.wraps(func) def inner(): ... inner.__wrapped__ = func return inner and if you're stuck with decorated functions that *don't* do that, well, you have my sympathies. If you don't mind a dirty hack, you could probably extract the original function from the decorated function by digging through the `__closure__` attribute and crossing your fingers: py&gt; import functools py&gt; def decorate(func): ... @functools.wraps(func) ... def inner(arg): ... return func(arg) ... return inner ... py&gt; @decorate ... def spam(n): ... return "spam"*n ... py&gt; spam # decorated version &lt;function spam at 0xb79caadc&gt; py&gt; spam.__wrapped__ &lt;function spam at 0xb79caa94&gt; py&gt; spam.__wrapped__ is spam.__closure__[0].cell_contents True Don't rely on that cell_contents stuff in production, but it's probably safe enough for a unit test. 
If I programmed the retry directly inside the function, it's much easier to mock out. I never could figure out how to mock out (remove the functionality) of the decorator. Stuck on Python 2.7 when I had this particular issue, but I'll definitely look into the wrapped dunder next time I come across this. 
Sorry, I thought I only used one link. I am trying to edit, but I don't see the link. As for the part ELEVEN portion, I updated my playlist, and wasn't sure if I should post the entire playlist or just my update (new video) --mainly because I had posted my entire playlist on this reddit before) EDIT: I included the entire playlist as well as you are right -- it might be intimidating for beginners. Thank you for the feedback. 
Sorry, I meant "one" as in "first point", as there's no link to the video at all on your post.
"its pretty easy to scare anyone with Perl" - there, fixed it for you. Good perl is really easy to write, I've written well documented Perl scripts totalling over 20K lines in the early 2000s that are *still* in use today. Short perl was good as well, because you could do a lot in one liners that fit on a command line. This was "obfuscated Perl" - and way too many people (still) take pride in. That shit is scary. I hate that Python doesn't have braces as delimiters ... but otehr than that, there is very little separating the two.
Python can actually perform admirably well. It's just a little too easy to unwittingly kill its performance by writing code that does a bunch of unnecessary IO. 
I see. I tried to link directly to the video (first time attempting) and I must have royally screwed up the process. I fixed it. 
PyQt4 and 5. Also, lots of numpy, scipy, pandas, and VTK 5, 6, and 7.
So i just tried installing ipython with the pip command(I have installed pip), and it downloaded and installed like it should but is nowhere to be found, maby i'll try pycharm, do you use the free or paid version?
i suppose you could try automate the boring stuff with python...but im sensing thats not necessarily the direction you want to go in. Its for absolute newbies /w no prior programming experience.
you gotta rename it dude.. 
There's weaponized autism, then there's the regular kind. You are just a moron.
Perl doesn't seem to be big in biology in the last several years. True, it used to be, but open any recent issue of Bioinformatics (or any other high-profile journal) and it's mostly R modules, a bit of Python modules, lots of compiled software (mostly C) with some Java thrown in, and a bunch of webservers with PHP or Python backend. And that's honestly great. Perl is a good language if you want to show off your skills by writing some ungodly bunch of `$`s and `_`s. And academic software tends to be messy without obfuscation-friendly languages. 
Technically, it's not guaranteed, because the malware could be running in memory or as a rootkit, or infected the firmware, or unmounted the drive where it is stored, etc.
I use the paid version - as a student, I get it for free. I would probably just use the community edition if I weren't (and couldn't get an employer to pay for it).
&gt;but otehr than that, there is very little separating the two Type system? Class syntax and this weird `bless` magic? Decorators? A ton of `$_`-like magic variables? Sweet regex syntax? Tail recursion? Anonymous functions? GIL? That's just from the top of my head, and I haven't written a line of Perl for probably five years (and was nowhere near a great hacker back then). Perl 5 and Python may be living in the same niche, but it doesn't make Perl "Python with braces".
Eh, it's name has meaning in Irish, and I'm not gonna use it for anything really, so I don't mind so much. But yeah, in hindsight? Terrible name. Just terrible
Go is a high-performance compiled language that was supposed to dethrone C. It's not gonna compete with python any more than Tesla X is gonna compete with the Boeing 747.
Yeah... very terrible 
 $ sudo apt-get remove ruby Reading package lists... Done Building dependency tree Reading state information... Done The following packages will be REMOVED: cinnamon cinnamon-screensaver cinnamon-screensaver-x-plugin gir1.2-xapp-1.0 gir1.2-xplayer-1.0 gist libruby2.3 libxapp1 libxplayer0 mint-artwork-common mint-artwork-gnome mint-meta-cinnamon mint-meta-codecs mint-meta-core mintsystem pix rake ruby ruby-json ruby-sass ruby2.3 ubuntu-system-adjustments xapps-common xplayer xplayer-mozilla xplayer-plugins xplayer-plugins-extra xviewer xviewer-plugins it seems like mint comes with ruby in the base install as cinnamon relies on it.
Ah sure, if a name that doesn't cross the pond well is the worst mistake I make, I think I'll be alright :) 
Fair enough :D
Not sure which version of Python you're using, but one thing you can do is use [Pyinstaller](http://www.pyinstaller.org/) to distribute your script to Windows users, I believe. I haven't done any large-scale app building/distribution where a proper chain of events happens like with appveyor, but what I've done is whip up a script, mock something up in tkinter, and have Pyinstaller take care of the .exe part. I then just use inno setup to provide my users in the office with an installer. YMMV, as my industry experience is limited and I'm just a lone dev at my company. 
Perhaps there are a myriad of better ways to phrase it ... but my point was that moving to Python didn't intrinsically give me much that Perl5 didn't. I can prototype the work I want to do just as easily in Perl5. When written well, it is just as readable as Python is. Perl5 is ridiculously easy for old-timers to pick up (especially C/C++ and Java coders). That's handy when you want to show app devs what you want done. OTOH, if I want to write a multi-threaded application that does a lot of text processing, then Perl is just fine. I wrote a couple like that. It compiles and builds on a ridiculous number of platforms quite easily. Python is a little harder for us old farts to get the syntax right, but it too has the same advantages once you get used to it. The big bonuses of Python are the exponentially larger community of users and the deeper domain coverage (i.e. number and quality of modules). But I could likely find solutions in Perl5 for the problems that you'd be using these "sweet" features in Python for. Perl's Regex is just fine, Tail Recursion is also there (I haven't used it, so don't know of its quality, as I generally detest recursion), and anonymous functions exist in Perl too. GIL is one where Python's somewhat better in managing mutexes, but Perl just solves the problem differently by choosing to not enforce mutex (arguably its actually more flexible). Again, YMMV, but I didn't see much difference besides syntax when moving from writing quality Perl5 code to writing Python code using similar coding standards. Of course, Python enforces those clean code standards far better ... so I guess that's the other big benefit when reading other people's code. So yes, IMO Python is a syntactically cleaner Perl. Not particularly different actually.
What kind of container? -edit: not getting a reply, but i guess its docker!?
I heard positive things about local shop: https://pypi.python.org/pypi/localshop
Why do you want to make your own instead of using something that already exists?
That's part of it I guess. Nothing's wrong with trying something else. If you finding yourself doing this often without finishing anything however, it probably means that you're either not committing enough effort or you're not reflecting on your former projects when assessing how doable a new project maybe. Referring to what u/tdammers said though, just be careful not to equate losing interest to failure. 
You can't setuid a script so it runs with the user permissions. So if you have a script I can copy it, edit it, and run my edited copy. That to me is "no security" it runs as if it was written by the person running it. The person who writes has no control.
Noticed something that might be an UI bug. When I click on the calendar icon, I see a quick flicker happening. The screen goes black (or is it an overlay) then back to normal.
That's an overlay that's displayed in the time between an api request and it's reply, so that people using the app on slow connections won't think it has suddenly hung for no reason. It actually reads "loading". I could probably introduce some way of only displaying the overlay if the request takes above a certain amount of time, but I never got around to it. 
Right; maybe I should clarify that. It is perfectly OK to drop 90% of your projects in a half-finished state once they have served their purpose of you learning what you wanted to learn. However, you also need to learn the hard parts of seeing a project through to the end, and not running away from the stuff that sucks. That's what the 10% are for in which you try to either finish, or reach the point where you conclude that you need to start afresh with the knowledge gained in the first attempt, and then still try to finish it on *that* attempt.
Eh, I can live with it. My least favourite aspect is dependency management. Virtual environments feel like a terrible, terrible hack and are a huge pain in the ass.
I wanted to like Go, but I find some of the syntax "weird" (like the := dick operator instead of just using =), and I'm not a fan of the lack of classes or the dependency on low-level arrays and "slices" instead of having higher level data structures in the standard library. It's more of a "slightly higher level alternative to C" than a Python substitute.
I'm surprised no one here has replied with the simplest of all explanations: Python has the best syntax in any programming language. No semicolons, no braces, english words whenever possible and easily readable and writable code that supports all modern language features (from enhanced loops to generators and decorators) and also some functionality that you won't find in any other major language (like syntactic sugar indexes for slicing lists). Basically Python is amazing at doing more than your typical languages in less lines of code and less boilerplate code, which leads to less code complexity and thus less development time and less bugs. So, I hate to sound obvious but basically it is so widely used because it is a truly great programming language!
If you're not tied to Tkinter then I would give PyQt a try. Comes with a great drag and drop interface designer where you can convert your saved design to a python file which can be imported to your main code. Very easy and hassle free. 
&gt;You are just a moron. Am I a moron because most sysutils do not use python?
Appveyor is a *continues integration* service that supports Windows. You can use it to test and build your program for multiple Windows versions, but it's not in and of itself a distribution mechanism. If your users are savvy enough to install Python, then they can use pip to install your package (assuming you've packaged and uploaded it to pypi). If they're not, then you can use PyInstaller or its equivalents to package and Inno Setup for your installer. But, here's the thing, if they're savvy enough to successfully run an installer for your package, then they've also demonstrated the skills required to install Python itself, which is arguably a far bigger win for them. But the option with the widest reach is to make a webapp. They upload a file and you give them back the result.
There are many reason you are a moron. You will never figure them out, and die alone as a result. Stop talking.
Just keep one dict for all active users, record every error they perform along with time, and in a separate thread go through users constantly checking for time difference. Then, in a separate part, make a dict mapping time of day to # of alarms. Keep looking for a number higher than 1.
&gt;There are many reason you are a moron. You will never figure them out, and die alone as a result. &gt;Stop talking. A person on the internet insulted me. I am hurt.
Thanks... I won't have access to a full user list, but I can derive the users involved at any given run of this mechanism. I think I see what you mean. Gives me ideas, at least!
Yeah, in that case do dict.update(Id: [(error_code, time)]) and dict(error_code: ID, time, user, incidents). Check the first one for high len(dict1[Id]) and the second one for high dict2[error]. incidents. 
Instead of showing the overlay if the request takes longer than x unit of time, show the overlay anyways but for at least y (say half a second) units of time. This I think is easier than measuring the request delay.
Hahah kid you not I ordered that book over the weekend and I'm waiting for it to arrive haha cheers 
Easier, but probably a worse user experience. Makes the whole app feel slow even when it's not 
It's actually very easy with pyenv. I have installed and run a whole bunch of python versions simultaneously. The virtualenv plugin helps too. Use 'pyenv local' to set a per-project version.
lol awesome!
Try pyenv with virtualenv plugin to manage them - it becomes automatic. It's great.
Cool, good to know! I like the abstraction.
Going to try to finish some real work, then if I have time I'm going to start the last part of the level 3 google foobar challenge
I don't think any sizeable amount of people ever liked writing Perl 5. For scientific computing, people that could stand the performance moved very fast into MathLab, and the rest into C++. Both were a mess. When Python started to get good vector libraries, it was as if a light turned on on the heads of everybody at the same time.
And there are more phones (Linux or macOS) than desktops. 
I would recommend checking if your package manager does not need it before you uninstall.
There's hardly any code at all XD Good explanations though.
So I shouldn't feel bad for neglecting my previous unfinished games that were basically the same thing done over and over with nothing more to learn? Good, because I ain't finishing *those* things...
Been there done that. Was immutable infrastructure so I just blew it away
You have to install it to a different location (e.g. usr/local/), you probably overwrite the system 3.X install with 3.6 when most system packages don't support 3.6
Python succeeded (despite its issues) because people just want a simple sensible dynamically-typed garbage-collected language for high-level programming, and Python provides that. Easy data structures and I/O, bog standard flow control, recognizable syntax, a REPL for easy learning. * Perl failed because it catered to some users' desire to be clever and tricky with implicit variables, context-sensitive symantics, and convenience shortcuts. Also they didn't have a usable REPL for a long time (not sure the current status). * Lua is too small (tables for everything), doesn't *want* to be general purpose, and doesn't help the user enough in catching their own mistakes. * Ruby was the "cool kids" language, offering lots of ways to shoot yourself in the foot (eg., monkey-patching). Anyhow, it was too much style/fad driven, though was once considered a possible alternative to Perl 6. * Scheme/Guile/Racket is too ... unhelpful? impractical? (cons/car/cdr? no native hashmap syntax? Bleh.) * Perl 6 seems a lot like Perl 5 to me, but I haven't carefully studied it. Seems like even deeper complexity than Perl 5, but its community claims otherwise. Either way, I think people want simplicity and a smaller language, and Python supplies that. * Dunno what happened to Tcl. That was before my time. And I'm *old*. I leave out JVM languages because ... they're based on the JVM; Python's scripting niche is based on the native OS. Python has plenty of issues which I won't go into here, but it gets enough core things right (see first paragraph) that it beat the competition. It also came out of the box with a pretty substantial standard library, which I'm sure aided adoption. Now, as for the language that will eventually take Python's place...
Reddit only allows so many characters per post
I could barely read my own perl code that I'd written shortly before. I'm sure a good, disciplined programmer can write good, readable, maintainable perl code, but a mediocre one like me can't. Part of it is the kind of quick and dirty jobs I used perl for, but mostly I just find it hard to read even though it is fairly easy and can be fun to write. People talk about readability, but perl is barely legible to me and kind of hurts my brain to look at. Python is just prettier for normies; I think that matters.
Tend not to use them when not writing django. Sqlalchemy has them for property magic
Yeah don't be such a `cuntoir`
You're going to need to provide more detail, like what exactly your data looks like, or it will be hard to help.
Also true. But very little mobile software is written in python (incidentally I don't think android ships with a python interpreter... I wonder if that's why), so that's more or less irrelevant to this specific topic.
web scrapping is actually a Real World Project, as everyone here has said, checkout your own needs too. 
This is fantastic. I always enjoy your writeups Adrian, and I hope a deeper explanation of the application of this new feature can make it into your forthcoming book.
Wanted to look through the js but was intimidated at searching 1600 lines of vanilla js in one file. Try making some folders with names that imply functionality and splitting the code a bit. 
have you heard of the dunning-krugger effect? it seems to be very common in the programming scene
It seems to also be very commonly stated wherever I post a programming question. Is it *that bad*?
based from your post and answers dude. it's pretty bad. but it'll get better.
I think you've got it wrong. Python succeeds *in spite of* its syntax. *Lots* of people prefer curly braces and semicolons. You hear complaints all the time about significant whitespace. &gt; and also some functionality that you won't find in any other major language (like syntactic sugar indexes for slicing lists) Perl does string indexing/slicing even better. &gt; Basically Python is amazing at doing more than your typical languages in less lines of code and less boilerplate code Disagree. Python is verbose, but I think that's a *good* thing. In Python things are spelled out (for example, mandatory `self` in objects; I *love* that --- no need to wonder if the variable is one of the object's attribs or not). Perl, otoh, is known for extremely dense code that's difficult to understand later in the month/week/day. Python is good. But I think it wins by being small, simple, sensible, and practical. Users have so many different technologies to keep in their head, we just want languages that are as described above. Python currently fits this bill better than the alternatives. That said, if you gave me a language with more conventional syntax (like C/Java/JS), but was simple and sensible like Python, and fixed many of Python's warts (ex., it's weird scoping, lack of a keyword to declare locals), I'd switch away.
I like how it forces you to space things properly. You can have a heap of complex C-based libraries (which would take me ages to understand) or a really simple, plain English, neatly spaced script. Also, no porting is required. This means that so long as the C-based libraries can compile (highly technical Python devs sort that one out) then all your apps work on EVERY platform. This is pretty amazing and it's sorta what C was supposed to be. Well what C is... until people go designing apps that only work on Windows, rely deeply on core API calls and are CPU-specific. As far as I know, you can't do that with Python unless you make your own libraries. 
Thanks, I really appreciate that :-) I'll be covering this method in detail inside the book and on the PyImageSearch blog as well.
&gt; As an I.T professional that specializes in network engineering No offence but it's doubtful you're a professional or an engineer. Let me re-word this for you. &gt; As a technician who mostly debugs networks, I only really know how to use Windows. However, I like the idea of using Linux. You can use Python on Linux, right? 
Sounds right. Lesson-learned: If using Linux, not using virtual envs or Conda is asking for trouble.
You are not asking for an expensive task, I believe your best choice would be to multithread the tasks and have asynchronous writes to the DB. You can achieve this by extending the Thread class and creating your own that would ping, parse and then save to the DB. You could also define expected errors inside the class and continue the program's execution without a problem. I've done this multiple times. You can start 500 threats without a problem on modern computers. This means that if your task tasks about 2 or 3 seconds to complete, you can actually run the all within your 10 second repeat frame.
Yeah, I get that, sorry. I guess I figured it was better to send one large file than lots of little ones over the network, to minimise the number of distinct threads my server has to spawn to handle the requests. I don't know how much of a benefit that is, but it can't hurt. You can see I tried to break up the python code base based on functionality, just didn't see the benefits of doing so with the java script outweighing the costs. 
When you play a game of programming language thrones you win or you stumble amiably along for many years until someone bothers to rewrite that one application that was keeping the whole office on Visual Basic 6.0. 
Android doesn't ship with anything that is not strictly necessary to boot its java rip-off. Python does not have a mobile story because none of the big boys picked it for their mobile bets. IOS is osx-lite, so ObjectiveC was the natural choice; and Apple being Apple, when they wanted an easier dev-friendly language, they built their own from scratch, which actually riffs on python quite a bit. Google went with "I Can't Believe It's Not Java", and then simply blessed another JVM language (Kotlin). Microsoft went with their dotnet stuff. The only ones that could have bet on Python were Nokia, but they first insisted on C/C++ and when devs ignored them and started building stuff for Maemo in Python anyway, they sold themselves to MS and abandoned ship. Blackberry went for JS, and FirefoxOS... friends don't talk about FirefoxOS. 
&gt; there are lots of interesting discussions about why TCL failed Got any links, out of curiosity? 
Define "useful" -- or rather don't, I already know you mean "useful to me to troll in a given thread". The stdlib is largely pure python and it comes with crapload of really useful stuff, from email to sockets, from sqlite to xml to csv... there is a reason "batteries included" and "import antigravity" are so popular. Package management is also gold-standard now that pip and virtualenv ship with stdlib; you cannot honestly say there is "nothing useful" in PyPI. And what is this crap about extensions having to be written in the language? That's a recipe for obscurity. In real life, the more you can accomodate hybrid approaches, the better for adoption. Postel's Law applies. Python's pragmatic approach to extendability is why we are having this very thread, it's a huge success story. Does it suck a bit more on Windows than elsewhere? Sure, like all *nix-first tech. Blame MS and their pay-me attitude; if they had started shipping a free compiler in 1994, maybe Python extension developers would have used it sooner. Still, Python will run on Windows just fine and if you add pyWin32 you get better system-scripting facilities than what MS itself provided for a long time (Powershell is better but requires mental gymnastics, the resulting scripts are barely readable).
Beautiful 
Ah, I had tried this with 10 threads, it never occurred to me that I could potentially scale to 500 threads! I just assumed that would demolish the server. I will give this a try, thanks!
Words to live your LIFO by
I'm forking it just for that name
Looks fun. Thanks for sharing this. One simple improvement: there are some conf files that need to be initialized; it might be a good idea to combine them into one generic config file and add an example, e.g. settings-sample.conf.
Python
Hahah, have fun bud. The name means "helper" in Irish, my national language, but I get how it's kinda rough. 
https://en.wiktionary.org/wiki/c%C3%BAnt%C3%B3ir I mean the name is appropriate... but soooo inappropriate You can always change the name and maybe that will improve sales?
As the outer commentator has suggested, there's already libraries to do a lot of the heavy lifting around this, however, if you want to do it yourself you can probably start by looking at Barnes-Hut trees for handing the collision detection.
Yeah, that's a solid suggestion, thanks. It's mainly so disjointed because new config files and cert files kept cropping up as I added more functionality
Ok, so appveyor is like travis/jenkins. If I can get pyinstaller to work the way I want it then I'll definitely look to use this for automated builds. It looks like this is free for open source projects, so it's a winner. Unfortunately, installing one piece of software might be a stretch, so asking them to using pip is not possible. I suspect I might have about 5 people use this, and I'd rather them use it then give up on the data. If the first option doesn't work then I'll go webapp, maybe it's time to start using heroku. Thanks for the help!
Glad somebody looked it up 😅. Eh, I'm mostly convinced while the name didn't help, the market for stuff like this is so saturated you'd need to hit it with something as or more polished than Evernote to even compete, so I figure I'll leave it as is. Somebody else said they're gonna fork the repo over it, so if it really bothers people they can go that route 
Packet headers?
i have tried a bunch of to-do apps, and they all want a subscription. I'd gladly pay a one-time of 5 or 10 bucks for an app with features similar to, say, ToDoist, e.g. labels and comments. they charge $10 a month or some shit for comments! hah!
Hey man I know the feeling. Writing code from scratch is like building a house when you have no idea what'll it look like. You start with one or two simple rooms, then realize you want a second floor but your foundation doesn't support that, so you rework the foundation. Every big code I've written has gone through his process. Sometimes the code is worth refactoring, but there have been times when it simply wasn't worth it. I've setup the db but can't get the server to run yet, I'll look at it tomorrow. Would love to give some tips.
&gt; just didn't see the benefits of doing so with the java script outweighing the costs. Well, for clients, http pipelining can make downloading several small files faster than one large one. If you're worried that a few short-lived threads are going to crush your server, you might need to invest in some better hardware. Also, you may find some small benefit in not requiring clients to parse all 1600 lines for pages that only require a small part of it. More importantly, though: breaking up the codebase makes it easier to search and understand. There is direct benefit to your future self, as you won't have to work as hard to locate code that needs updating. It also makes it easier for others to contribute to your project, as it's easier to grok a well-segmented codebase than one where everything is dumped into a single file.
Yeah, I get you. The problem is, the second you include a server you've got a constant cost, and that needs constant income. It'd be unreasonable for a company to expect constant user base growth, so the only way to get that constant income is with subscriptions, and then it's a balance between making a good free product and trying to encourage people to upgrade without pissing them off... It's a rough gig. Gimme python backend work over stuff like that any day. I guess it's the price we pay for stuff like cross device syncing though.
Indent by four spaces to get a code block. I'd change the order of if statements: n_distinct = len(set(a, b, c)) if n_distinct == 1: print('This is an equilateral triangle') elif n_distinct == 2: print('This is an isosceles triangle') else: print('This is a scalene triangle') Also, for equilateral, you can use `a == b == c` instead of anding.
Oh big time, and learning javascript while I was doing it was not the best choice, to say the least. I'm pretty sure there are three different functions for normalizing date-time in that scripts.js file somewhere, with only the most recently written one being used. I'll probably look at a utility to generate some placeholder cert and key files, as well as the couple of config files needed, tomorrow, and maybe automating the database setup. That db was another thing that slowly grew extra parts as time went on. If you want to pm me the errors you're getting feel free, there's one kinda hard to track down dependency I have for a module that handles making web push notification requests, because learning how signed json tokens work was low on my priority list.
that's kind of what I figured. I dug more into your program and realized it is all managed on the back-end with a mysql db so you would have to have the same business model. I don't need cross-device syncing, and even if I do, just dump my tasks as json data that I can sync using google drive or dropbox. server costs.... gone! hey... maybe i should make a todo app...
 No
Done the bioinformatics course. Also, made another package. Finishing up the documentation before I post it to PyPI.
Haha, give it a go sure, it's a nice learning experience if nothing else. Or, you could always fork me and rip out the stripe payment integration..... I might actually do this, now that I think about it.... and then you could just run it on a raspberry pi and buy a domain name, amazon charges me like 50 cent a month for dns, and away you go with a subscription free, cross device synced, open source todo app. As regards server costs, the thing is served as a website, so there's always gonna be some kinda hosting necessary.
Oh yeah, don't get me wrong, I understand the usefulness of segmenting code bases, but this is a mostly single page application, so most of the scripts file is necessary most of the time, and to be honest most of this was hacked together in about fifteen days, I think, so there wasn't much deep thought about software architecture going on. I figured make it work, then make it pretty if it turned out to be worth it. I definitely let some best practices slide, but hey, that's what hobby projects are for, right? 
Not sure if you still need it, but `binascii.b2a_base64(s.encode()).strip()`. ninja edit: `strip()` instead of `[:-1]` because you're just removing the newline.
Why not an emergency bracelet or necklace? It's what they're designed for, and can be triggered at any time by the user, or if they detect a fall and no motion. Lower failure risk, and more likely to save lives.
...I resemble that remark.
 mysqldump -D cuntoir &gt; cuntoir.sql
Sorry, I'm confused. Are you saying I should include a dump of my production database in the github repo? Because that includes hashes of people's actual passwords, and tasks they've created and stuff. They didn't agree to have that published, and I wouldn't be comfortable publishing it even if they did. Sorry again if I misread you 
He has one, it's more about him not liking the idea of laying there and being found up to a week later (after he passes). Morbid I know! He's a bit quirky and likes the idea of me making it.
You are right, how about mysqldump --no-data -D cuntoir &gt; cuntoir.sql 
That could work, I know waaay less about mysql than python, but I'd rather create a robust setup tool that lets people set their own password and user for accessing the database, and probably even name the database themselves, since every database connection is created using the same function in authLib.py
OK, that's good. I'd thought you that you were relying on your system as the sole means of keeping him alive. [Here](http://www.medicalalertadvice.com/fall-detection/) is an article about those kinds of devices. The good ones are designed to be fail-safe, and don't require any user input for falls. Though they should also allow for a call button in case something else is happening (e.g. heart attack/stroke symptoms).
Sure just giving you a heads up, if you are interested in anyone using your app, https://i.imgur.com/WLIDGRu.png kill this with fire ASAP, you just have to run 1 command to get the dump and 1 to commit it 
Thanks :)
Sorry, could you explain what you mean there? Are you saying if I want anyone to self host it, I should provide a database template instead of just detailing the database setup, or are you saying there's a security issue here (aside from giving away my database structure being a "security issue"). Again, super new to mysql, slightly worried I messed something up big time. 
Surely there are build tools and other utilities for that sort of concat job. I'm not a JS ninjastar, but these things exist for CSS so they likely exist for JS too.
It's a reasonable question. Ultimately, Sphinx tips the balance for me, as I get to think in terms of a documentation collection, with rich interlinking and docs-oriented constructs. The world of Markdown can't even agree on an extension syntax.
&gt; Are you saying if I want anyone to self host it, I should provide a database template instead of just detailing the database setup Sorry, here it goes: You picked a *not optimal* way to share your schema if you want someone to self host your app, I'm just trying to tell you it's really easy to do a dump of the database and share it. If that's what you actually want of course. Regards /u/enchufadoo 
Perfect, thank you. Yeah, you're absolutely right, copying mysql command outputs to a text file is about as janky as it gets. I'll probably cobble together a setup tool tomorrow that will auto generate the right database setup. 
plz lrn 2 webpack
Thanks, you were right. Didn't use uppercase 'C'. ugh.... So frustrating, spent hours looking into other things, and it as all from being case sensitive which I knew python was case sensitive. That is the most frustrating part of learning programming; one stupid error can set you back hour.s Well thanks for the help!
Yeah this is the biggest reason in my opinion. Back in the day it was very difficult in many languages to leverage a C module, python changed that in a big way supporting the datatypes, parameter ordering and adding a locking model that actively helped instead of hindering.
Something about your writing style makes easy for me to read through fast. When I've got some spare time at work I'm going to be putting together a program to identify circuit boards, this looks like it will be an awesome resource.
Definitely let me how the project turns out!
Perl has abysmal syntax. I think python quickly shows it limits with large projects, but perl is frankly unmaintainable. I judge a code base by the number of lines I need to study in detail to discern meaning. It's just too arcane for a utility language. 
That looks like a lot of fun, I'll have a look at the code tomorrow at work! I'm just a bit curious about your benchmarking. What is exactly the setup of the experiment? I mean, I know that GIZMO is great and all, but AFAIK, it was mostly designed with the hydro evolution in mind. What I mean by that is that it is probably not the most optimal for pure N-body evolution. Also, it might be slightly misleading to say "100% Python", since I bet you are using quite a lot of Numpy there, but I see what you mean! Anyway, I'd be curious to know more about the project :) When I read the title of this post, I found myself thinking "since when PKDgrav is in Python?", but then I realised I missed a "y". Did you, by any chance, look at the results of the simulations, just for fun? Since the code seems to handle 10^6 particles fairly well, it starts to look good!
Nope, I'm actually a double ccie, want to try again? 
Yes
Sounds like an opportunity to refactor! Let some of us newbs hack away if you'll accept pull requests :D
Hahah, of course, request away, but I certainly wouldn't say I have any real experience, just a student messing about with the hours I don't spend on college work in the summer. I probably know less than you :) 
The benchmark is with 125,000 particles randomly sampled according to the [Plummer](https://en.wikipedia.org/wiki/Plummer_model) density distribution, running on one core. I've only compared how long it takes to compute the forces, as GIZMO also has all sorts of fancy time stepping and tree updating magic that would make it slaughter a naively-coded integrator made with pykdgrav. And yes, GIZMO is very much a multi-physics code, but compiling it with only the N-body flags basically just makes it GADGET-3, with no extra overhead. And of course GADGET-3, while probably not the fastest these days, is the treecode against which all others should be judged. As for whether it's 100% Python: what is meant is that every line of code that I had to write was Python syntax.
**Plummer model** The Plummer model or Plummer sphere is a density law that was first used by H. C. Plummer to fit observations of globular clusters. It is now often used as toy model in N-body simulations of stellar systems. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.26
Perl is for masochists.
Just like I think I will be rich, I should be an expert ...?
Thanks for the info, definitely doing the pyinstaller route. I've always packaged with either debian packages or pip setup. Glad to know there's something like this out there.
I too would like to see this. 
Rather like some of the highly optimised cPython core. Not that I personally care one hoot about run time speed, let alone two, but some people still seem to be obsessed with it despite the code having to wait on the network, or the db, or the...
&gt; I think you've got it wrong. Python succeeds in spite of its syntax. Lots of people prefer curly braces and semicolons. You hear complaints all the time about significant whitespace. Whitespace is perfectly clear, end of story. All those dumb, wasteful curly braces might look good, but it is impossible to tell at a glance what is intended, and what is actually happening. Python is one of the very rare occasions where I can rely on my Mk I eyeballs to tell me exactly what is going on.
/r/learnpython
Wrong, I've written C based apps that would only work on VMS :-)
&gt; As an I.T professional that specializes in network engineering I use Windows but do all my coding in cygwin, reason being there is no Visio for Linux. Try [Alternatives to Microsoft Office Visio for all platforms with any license](http://alternativeto.net/software/microsoft-visio/).
So you grab what you want from here [pythonlibs](http://www.lfd.uci.edu/~gohlke/pythonlibs/) on Windows. If that doesn't work or you're on Linux, I dread to think what you're attempting, you (plural) must be way out on a limb.
So false that it's laughable.
Python is slow. So is waiting for the network, the db... Asynio anybody?
Not OP, but I have found that creating my own versions of particular tools are the best way to internalize concepts.
Search for "python sql migrations", should be able to find something useful.
[This](https://drive.google.com/folderview?id=0B2svky0iJMUDWU9TUW1mNnQ3Q1E) 
Hey again, could you help me again? How would you get the href for the same element?
I was looking for constructive criticism, please. Thanks!
Not to sound too critical, because it's a great hobby app, but hobby projects are more for *learning* good practices than they are for ignoring them. ;-) That said, even if you wanted everything to end up in one file at the end, you could just cat them into a single file, or even better, use webpack or a Grunt job to concatenate, uglify and minify the code for you. That said, my first few attempts at using Grunt were ... ugly, and I ended up doing it manually at first, and then writing my own version of Grunt in Python because I couldn't get my brain hip to the way all the JS people were doing it until I read [this](https://24ways.org/2013/grunt-is-not-weird-and-hard/). 
&gt; Terrible name. Just terrible Sometimes, memorability is worth a bit of terribleness. Soylent comes to mind. As a self-professed deviant, I personally love it. 
Webpack is a great option.
I guess I figured it was better to send one large file than lots of little ones over the network. Have a look into webpack. It can pack your multiple JS files into a single file and minimize it so you can send just one file to the server.
These are neat and there's some cool features of the language tucked away in there, but I feel like a most of the time they would stray a little far from my "import this" bible. 
I like golfing because it is interesting to view Python's capabilities, but to anyone who'd think about using golfing in a project : don't. Please don't. You won't remember what the trick does 3 months later, your colleagues will hate reviewing your code, and you will die alone in pain. Don't. 
Try bottle or flask. Make sure to deploy via gunicorn ;)
Maybe?
Maybe they are into cuntnior?
https://wiki.python.org/moin/BeginnersGuide https://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_3 /r/learnprogramming /r/learnpython 
I like the idea of matching the greyscale value of a pixel to an ascii character based on the weight of that character. Nice coding. Could do with a bit better efficiency though.
Irish dictionary: Cunt- a bloke who's a right cunt
This deserves to be on best of
few guidelines that will help you next time: 1. use conventions. make sure you know how you called variable or class without see the source code (UpperCase for class, under_score for var/function.) 2. use IDE (pycharm is great) that will help you to spot the error 3. while debugging, use REPL with auto complete feature (I'm using ipython). it will help you to eliminate some basic mistakes and to learn the basics of the language. 4. when asking other people, alway paste the source code (remove sensitive parts). if needed, divide it to files and show the directory structure. also, the exact error massage is crucial. make sure you copy/paste it and not type it in. good luck!
What's there to learn? 3 is pretty much the same as 2, except * you need brackets when using print statements * `raw_input` changed to `input` (or maybe the other way around) That's it. Nothing special. Just remember to append "3" to pip and stuff. 
Go to https://www.edx.org/course/introduction-computer-science-mitx-6-00-1x-11 It's a free MIT Python course that uses 3.5 It's an amazing class. It's 50$ if you want the certificate for your resume. Cheers.
Ah okay, didn't know that as I mainly use XFCE, thanks for the insight!
https://docs.python.org/3/library/asyncio.html
Additionally, strings were changed. In Python 2, they were by default byte sequences (IIRC), whereas unicode strings were a special case (`u"hello"`). This is basically reversed in Python 3, with unicode/utf-8 being the norm and bytes being their special case (`bytes(string)` and `b"this is a byte sequence"`)
Sure, but how often does that difference actually matter?
When sending data with sockets, for example. They only accept byte strings.
Nobody cares about vendor certs. All they demonstrate is proficiency as a network technician... they don't teach you about designing cutting edge network hardware from the ground up or upholding professional/ethical standards. Kudos to you as a technician, but you'll never be a professional with just a vendor cert to your name. Think about it this way... if Cisco goes bust tomorrow and somebody engineers some totally new gear then you'd have to apply to that engineer for certification before you could install/fix their gear. Whereas, a professional doesn't pride themself on their ability to install products made by a vendor. And uuuum... you wouldn't know where to start if a client said 'yeah but Cisco gear doesn't fit my needs!!! We need custom built gear because we are trying to release this technology before Cisco, so they can't patent it and charge us millions to use it!!!' Sounds harsh but there's professionals then there's worker bees. You're a certified worker bee. Nothing to be ashamed of, but it bugs me when technicians go calling themselves 'professional engineers' without knowing the first thing about applied physics. 
Are you open to pull requests?
This should cover most of the changes. http://python-future.org/compatible_idioms.html
Golfing: - [x] You get to know and understand the Python minutia. - [ ] You are Pythonic. - [ ] You are succinct. - [ ] You are readable. - [ ] You are maintainable. - [x] You nevertheless get an immense sense of personal achievement :-) 
This is of topic, but if you don't mind me asking, what degree do you have (e.g IT/CS/CSIC/..)? Thanks
This is easier for rpi control panel https://github.com/dddomodossola/remi/blob/master/README.md 
You can learn from online:- Read Informative articles, Watch the video, Use forum or community websites, Use online tutorials, and much more… One of my friend did Python course from Koenig Solutions that’s why I want to suggest you that you should do the course from any well-respected training center. 
While I generally agree with that sentiment it seems to me like OP has very specific things he wants to model. So he'd be learning those as well as the "game engine". Furthermore it seems like they want to be playing with essentially n body simulation type things. They don't require the overhead of a full engine when you can import a module to do the work or simulate the behavior yourself. This isn't complex (yet). If OP gets back to us with more information about his goals and needs we can probably steer him to what he needs. 
Something like [this](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html) perhaps? Alternatively, you can use mean/std functions to calculate column summary and then create a Gaussian distribution using those values to sample a new column: df = pd.DataFrame(data) mean_col1 = df.ix[:, 0].mean() std_col1 = df.ix[:, 0].std() gaussian_dist = np.random.normal(mean_col1, std_col1, df.shape[0]) (not tested)
This might have come in handy a few years ago when I was doing my masters in astrophysics
I found [Automate the boring stuff](http://automatetheboringstuff.com/) the most helpful for learning Python, and programming in general, mostly because it gives some practical tasks for you to complete that require some thought. It was a lot more understandable for someone like me who came from a non-computer science background. Also, don't forget that there is YouTube and if you ever get stuck on anything Google is your friend (which will usually direct you to Stackoverflow.) I wouldn't even consider buying any books for it, there's so much free stuff out there on the internet! You've just got to find the stuff that clicks, the really important part with learning a language is to actually do it yourself rather than just read. And don't worry if you don't get everything at once, the most important lesson ATBS taught me was at first not worry about doing it the right way, but just do it in a way that works. You'll eventually start realising the optimal way to do things. 2 isn't too much different from 3, although when you search for most of your problems in Python (or examples in docs) you'll mostly find them in Python 3 code, meaning you might have to remember to change the odd thing such as print statements.
Professionally I'd recommend taking the raw "cunt" out of the project name. Secondly, the amount of manual setup required to even start playing around with this is a non-starter, especially for a yet-another TODO app. Script it.
&gt; I definitely let some best practices slide, but hey, that's what hobby projects are for, right? Not really IMO. Personal projects are often the only place where you can actually do things the *right* way, because you don't have pressure or deadlines. We deal with shitty fragile code every day in the wild. 
Tinter?
I personally see no need to spend a single cent on learning languages. With so many free tutorials out there, on YouTube and such, you can learn pretty much anything if you put your mind to it. That's how I learnt Python 3. Also, stackoverflow is a great place for Q&amp;A
Exactly, I've used f2py for plenty of that. It's just so easy compared to using the C API (which I didn't manage to figure out).
I got it to work for C++, but it took a third party too (swig) to simplify the process, and it's still a pain in the butt. The relevant part of my C++ -&gt; Python library Makefile is: swig -python -c++ -o _tab_interp_module.cc tab_interp.i python setup.py build_ext --inplace where you have to write setup.py to be something like from distutils.core import setup, Extension extension_mod = Extension("_tab_interp", ["_tab_interp_module.cc", "dust_temp_interp.cpp"]) setup(name = "tab_interp", ext_modules=[extension_mod]) and tab_interp.i is: %module tab_interp %{ #define SWIG_FILE_WITH_INIT #include &lt;stdlib.h&gt; #include &lt;string&gt; #include &lt;fstream&gt; #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;math.h&gt; #include "dust_temp_interp.h" %} %include "dust_temp_interp.h" all written by hand. By comparison, my f2py makefile just goes: f2py --opt=-O2 --f90flags="-Wall -mcmodel=medium" --f77flags="-Wall -mcmodel=medium" -c sph_plotter.f90 -m sph_plotter i.e. it's 90% just setting the standard Fortran compiler options.
Didn't a bunch of crucial syntax also change? 
Think Python is available for free: http://greenteapress.com/wp/think-python-2e/ Same with Automate the Boring Stuff: https://automatetheboringstuff.com/
There may be places to find people to do your homework for you. Personally, I think that asking /r/Python will either give you an answer that's so needlessly convoluted, that it tell your teacher that you're cheating, or utter contempt.
No offense, but it looks like a "please do my homework" post. Would you mind to share with us your implementation and the time you spent on it :) ?
Have you seen much modern python? The code and style are not very mainstream pythonic. It looks like PHP. You don't need parenthesis in the if-statement or returns. What is `if(len(tags) &lt; 1):`? Not python. Try just `if tags:` instead. This `getLib.py` is horrible. In python we don't really do string concatenation but use string formatting. And we definitely don't build HTML in code. It is one massive slab of this too. Maybe try a template engine? And some decomposition assignments? All the repetitive db.commit()/db.close() stuff needs to go; maybe try a context manager or write some abstraction? Or maybe get some SQLALchemy or something higher level?
You mean Tkinter?
What's your use case? With this much detail it's difficult to recommend something. 
Having spent a lot of time working with **multiprocessing** here's a few points: * You don't go really that far away from docs to make it interesting. Multiprocessing started as an external lib and thus the docs explain basic use case really well * You don't explain - and that would be interesting - how to discern between IO bound (and thus maybe benefitting from threading) and CPU bound (and thus maybe benefitting from multiprocessing) tasks * Multiprocessing, ZeroMQ and RabbitMQ/Celery. I use all three on daily basis and they _are_ different tools though you can design a case solvable equally well with any of them. * You don't discuss costs of thread vs. process or where to start profiling one's code On top of that, your code has variables with misleading names. It's really not a tutorial that stands out from anything already written about multiprocessing whether it's the approach, quality of examples or depth of the discussion. 
* https://www.reddit.com/r/programming/comments/bk87r/where_tcl_and_tk_went_wrong/ discussing this https://journal.dedasys.com/2010/03/30/where-tcl-and-tk-went-wrong/ * http://wiki.tcl.tk/9505 I have certainly read a lot more in the past, but not recently. Personally I think one big missed opportunity was the failure to emphasise, and improve the stack for, event driven servers (i.e. the niche that Node seems to dominate these days). 
&gt; Lots of people prefer curly braces and semicolons. You hear complaints all the time about significant whitespace. On the other hand, a lot of people like significant whitespace. We just have nothing to complain about. It is one of the things that makes Python code, even when written by people who are not disciplined about formatting, very readable.
I'm making a program that can reload RNDC when called upon remotely, with some kind of authentication. Running the actual commands is easy, making a long-running process is the tricky part.
what a strange grab-bag of insults. did a cisco cert murder your parents in an alley when you were a child?
Since this is a python subreddit, I tried to actually read through the codebase and come up with something that can help you in the future. Not to be rude, but I hope you came here for actual critique, not patting on the back. Imho, you should think about packaging this app correctly - creating some folders, setup.py, readme that is useful (right now there is a lot of tables that are weirdly collapsed and because of that - not readable at all). There is a lot of boilerplate templates for pypi projects that can get you started. Functions are big and there is a lot of redundancy connected to the db usage. Refactoring would go a long way here, maybe start by grouping functions into modules (more or less that is done now) and into classes when that makes sense (for example, if some of the functions use the same variables that you have to initialize over and over again, like db connection). Like some guys previously mentioned, setting up the app seems really bothersome. Maybe think about launch scripts that would take care of that, incorporate docker, or at least establish some good practices with virtualenvs. Managing db connections by yourself will bite you in the ass. Same with the db migrations - doing that manually will sooner or later make you hate this project. Maybe think about some simple ORM like peewee? The last thing, I think there are no tests (I'm not sure since I didn't have time to go through it all yet). When I'm prototyping I don't write tests in the beginning too, and I think that is okay if you want to have a POC of your solution. Here, it seems you are investing more and more time in this app, and I guess it's now or never with writing any tests - it will get waaaay out of control later. Debugging simple mistakes will be a nightmare. 
Not all are supported on Linux subsystem. If you want to use vagrant or docker to virtualize your dev environment, then you will deal with switching between windows and Linux subsystem.
It'd take me about ten minutes. Including a test suite. Now, do your assignment yourself.
&gt; even if you work with VM/Docker/LXC/others. You can be pretty fine with 4Gb Definitely not. Some devs in my company where I work use mac mini with 8GB of RAM and sometimes they're unable to work and all this are very slow (dev VM requires 3GB of RAM). Sorry, but if you work on a big project, you IDE, heavy VM or few VMs, running tests and several other apps that you daily use will not fill well in 8GB of RAM.
Line by line as in scanline by scanline, or individual lines of text? You can't do OCR over single scanlines (the glyphs are bigger than that, after all), so it's a bit unclear what you're after.
I'm glad that I don't have to deal with calling my own C from python at the moment, but when I had to, it took me two weeks just to map all the possibilities: sweave (deprecated), cython (I guess I'm stupid for not understanding the terse documentation), writing a plain module (numpy docs: use these numpy specific distutils. everybody else: don't use distutils, use setuputils instead), f2py for C, writing a C API extension (and probably screw up reference counting), the Boost python module... Most guides seem to assume that you know how python packaging works (directory layout, setup.py, making a package, eggs), while that's what I was trying to figure out, The trouble was amplified because I wrote a CUDA library. At this point I'm pretty sure that I'm just going to avoid C extensions. The solution in my case was actually to rewrite my python to julia, which has an amazing FFI for calling anything compiled. Ed. It's a shame Fortran has this image of being for old people who like to torture themselves, I feel like C(++) is usually more torture for numerical work.
If we speaking about laptops, to be honest - MacBook retina display and battery life is a game changer. Also, aim for a laptop with SSD drive. MacBook is expensive but totally worth in my opinion as a laptop for programming. In work, I use a workstation with 2x24" monitors with Ubuntu as a core system. Private, I have Macbook Pro 13" that I use to develop in python.
People say that print changed, but it works with brackets in Python 2 anyway. My coworker thought that return statements must have brackets in 3, but that's also not the case. They're optional in 2 and 3. Aside from that, I can't think of any difference. Some specific packages have an occasional quirk that's different, but overall it's still the same language. I don't understand why people treat it like a bit deal.
My thinking is, if your users are so incapable that they cannot install software, then give them a website, as that's probably the limit of their capacity.
too bad this cant give bounding boxes
There are a bunch of cool things you can do in C++, but the lack of proper support for arrays makes numerical work such a pain. I feel that it comes down to the philosophical difference in how they view arrays. In C and C++, an array is a block of memory - a computational object. In Fortran, an array is grid of values - a mathematical object. Fortran has a higher level of abstraction here, which makes it easier to understand and to work with, but makes it trickier if you really want to mess about with stuff on a memory address level.
My point is Python gained more of the type of success Lua has - glue language - convenient way to trigger something else, not pythonic. It is much less a success of general purpose language some people would think.
It helps that numpy has a similar array syntax to Fortran as well.
I actually find trying to write a C or C++ library for Python to be oddly complex, whereas using f2py will turn a Fortran module into a Python library with almost zero work.
Easy mode: https://docs.python.org/3/library/concurrent.futures.html with ThreadPoolExecutor(max_workers=50) as executor: for h in my_hosts: executor.submit(my_ping_host_function, h) See docs for more options, and you can gold plate it if you want. Also experiment with the amount of workers. Alternately you can rig something with bare Thread's and Queue's but I'd only do that if a convenience like the pool executor is not enough.
No degree, going into my second year as an electronic engineering student
Yeah, sure, go wild :) 
I find parens around if statements look cleaner to my eyes, they're a holdover from the C I use for college. You're right about the "if(len(tags)):" being rough, I wasn't super confident with how python reads empty arrays for if statements, so I didn't want to assume anything. If I went back to refactoring now I'd probably go with "if(not tags):", I'm not sure what benefit the if:instead: pattern has. Absolutely, getLib is a mess, most of what it does is building html strings for rendering on the client side, which is a pretty messy task. String formating would go a long way, although I'm not sure what the problem with string concatenation here is except that it's not best practices, I mean it's not a security issue there as far as I can tell. As regards the database stuff, yeah it's a mess, and it's a dodgy mess because it needs to be remembered every time or else I could end up with trailing database connections. I should probably write a database handling connection handling class that takes care of all of this, but I'd rather not start leaning on higher level abstraction, I want to learn how this stuff really works, if that makes sense? Thanks for your feedback, I really appreciate how in depth it is, and I'll keep it in mind for the future. Top of my list right now is writing a setup function, but after that I'll probably look at redesigning my database connection stuff. 
The hardware/software requirements of your company might not correspond to the needs of a novice programmer. 
[This](http://preshing.com/20110926/high-resolution-mandelbrot-in-obfuscated-python/) is obfuscation and not golfing, but I just love it.
Setup.py is top of my list, once I have that built it should be easy enough to clean up the readme because it will let me get rid of all the database descriptions. It should also make starting the app as simple as typing "python server.py", I think. You might also have to start the http redirect server, and I'd recommend doing both of these in a screen session. I will likely create a database handling class to manage database connections, to clean up the commit()/close() pattern I've got going on now. I do prefer to manage the database connections myself though, because part of this is that I want to get experience managing that kinda stuff before I start relying on abstractions. Yeah, there are no tests. In general I'll test new functionality with the requests library, and throw a bunch of obviously incorrect requests at it to make sure tis working properly, and handling errors properly. 
i am just starting hoping to learn something...anybody willing to help :D 
Well, like I said, I'm gonna shut down the server I have running it very soon and just maintain it as a hobby project for anyone to self host if they want, so I'm not too concerned about professionalism when it comes to the name, plus it's not an English word, so applying English standards to it is a little absurd, but I do get how it doesn't translate well. Someone further up said they're gonna fork me over the name, so maybe their version will do you, eh? Yeah, a setup script is top of my list for me at the minute, along with ripping out the monetisation and cleaning up some bits of the codebase 
gold?
We don't say bloke here, thats British moreso.
setup.py is one thing, keeping a nice and clean project structure is another. Making it more familiar (by making it resemble other projects) will lower the learning curve for new developers that want to give your app a go and contribute to it. I guess handling the database by yourself is similar to handling and creating the login system by yourself - may be fun, probably won't be, and for sure you will make mistakes. ORM's are really (I can't stress how much) complicated, and implementing it by yourself is probably impossible. It may be a great exercise though, but if you release your app publicly and people are using it, that is a big no no. Using requests is fine, you should probably make it automated though. Use pytest for example, and maybe add some simple CI for practice (however, if you are working on it by yourself it's probably redundant). Still, integretion testing is one thing, but adding some unit tests will really help you think about the structure of your code.
of course not, but saying that 4GB is fine even if you work with VM/Docker/LXC/others is wrong, especially when somebody wants to buy mac that is expensive and will probably not replace it for better any time soon
Just watch out with holding on and transplanting to your previous experiences. Python is not C or Java or PHP. Like nobody does extra parenthesis in python in simple cases like these. Less noise, less cleverness, more readability: `if(not tags):` adds nothing over `if not tags:` except extra visual parsing noise and satisfying your personal historical preference. String concatenation is slow and noisy; HTML in code is the worst. Just look at that special character mess. So many quotes and plus signs and eye sore; try to figure out what is going on and what shape the HTML has at the end; it is a solved problem; this is why templates were invented (or at least use highly compact helpers). I don't know what you want with the low level database stuff. Maybe it is cool to try it this time, to experience it is not so great and why people created higher level abstractions. SQLAlchemy or Peewee are like standard (or Django ORM) if you do anything serious: the developer overhead and bug risk of low level database use is usually not worth whatever you think you gain.
There's also `concurrent.futures.ProcessPoolEexecutor/ThreadPoolExecutor` which will handle most of this queuing burden for you. Executors also play well with `asyncio` via `loop.run_in_executor`.
I haven't worked on other open source projects (tbh it always felt a little intimidating, like sacrificing your code at the alter of the pull request), but I guess the official python style guides are a good start? To be honest, for my own projects, I just prefer stuff like camel case and parens around conditionals. As regards the database and password stuff, I mean, it shouldn't really be a big no no, like somebody has to build these systems, and to do so they have to know how they work, right? As long as you're up to date with password hashing best practices and you're not doing something really dumb like having terrible password rules or storing them in clear text, I don't see it being a huge problem. Unit testing is not something I know about, I don't really have any formal training in "proper" computer science, just a little bit from my engineering courses, and even that was like "intro to C" and some embedded processor work for a robot, where the testing was "turn it on and see if it works" 😅. 
You can probably start by checking PEP8 for code formatting guidelines that are used by most of the python developers. Well, if you are handling some private data and you are just starting it is a big no no since you are risking a leak of your users' data. In the future you will have problem with loading data from db (scalars won't be useful for long), managing loaded objects etc. I'm not saying it's bad idea to give it a go, I'm just saying it's probably a bad idea to give it a go in a production app. I highly recommend you reading about unit testing. Get a general idea and then check out pytest a try giving it a go. Testing may be intimidating at first, but soon you will get proficient at it and benefits are enormous.
Hats off to you
Well, I mean, there's no accounting for taste right? It suits my mental model of how conditionals work to have them wrapped in parens, and the language allows for it, so I don't really see it being a terrible thing. Slow and noisy? Sorry, I'm not super sure what you mean by that. Unless I'm just being dense, and you mean it like it's just a dumb way to do it, but I'm not sure there's any huge performance benefit, is there? If so please point me somewhere I can read about it, those low level optimisation are always pretty cool. Django isn't something I've used, part of me wanted to keep non-standard library usage to a minimum, I'm not really sure why, except I don't like looking at loading bars I guess? And I wanted to minimise dependencies for set up
Yeah, PEP8 what I meant by the official style guide. Stuff like max line length being 79 just seems kinda absurd to me though, like, I develop with a full screen terminal lost of the time, I've almost three times that many columns to play with. Obviously that would be unreasonable, but 79 seems unnecessarily short. Idk. I mean you're always risking leaking user data, if you mess up server setup, or if don't protect your database host properly, or any other mistake. I always figured it's best to learn how this stuff works and implement it yourself atleast once before relying on abstraction. Maybe that's hubris, but I think it's worthwhile. I'll definitely look into unit tests, thanks. Automating the testing of new functionality sounds sensible. 
Haha, thanks 
Dope project mate! You know, to paraphrase Musk, if you want to sell something in a niche that already exists, your product has to be significantly better than the rest, so don't be sad if you can't surpass the pros. Keep it up!
&gt; I guess I figured it was better to send one large file than lots of little ones over the network You're correct. But using something like gulp or webpack, you can combine all your JS into a 'build' file that is served to the client. We do this where I work and there's &gt;400 JS files
That matters if you process text files. Other than that I guess the xrange - range thing is also nice to know about.
Sure, but line limit isn't the only thing specified in the PEP8. Also, parsing mentally a line that is 79 char wide instead of 120 is a little bit easier, but still, that is probably subjective. Specs like pep8 are created so that people can focus on code instead of constantly arguing about formatting styles ;) Sure you are always risking that, you are free to do whatever, it's just that you have to bear in mind that you are playing with some people data and you owe to them making it as secure as possible. You can always just read through the ORM codebase and try to understand it, that is what I do at least.
Not to mention that a lot of them are going to have unintended side effects (lack of short circuiting in if replacements, etc) or changed performance characteristics. This is probably better taken as a list of things you should never do in python.
Yeah, that's very true, I suspect the coding style arguments will be around as long as humans write code 😅. I think it's probably OK to risk it once you make a genuine effort to be aware of and mitigate the risk, if that makes sense? And don't get me wrong, I don't mean to say using abstraction isn't a good idea, obviously I don't build a soldering iron every time I want to solder something, just that I do know how a soldering iron works, and with programming, often the only way to understand to low level tool is to replicate it yourself. 
Not really. As /u/bananaEmpanada said, it's mostly the same, but he/she failed to point out a few of the actual "gotchas". 1) Integer division is different and results in different outputs. This can cause runtime errors. 3 /2 = 1 in Python2, 3 / 2 = 1.5 in Python3... 2) Unicode. Huge topic, so look it up. 3) Banker rounding. Again, results in runtime differences. Overall, it's mostly the same language.
You won't gain a noticable performance update. But Python programmers usually try to follow the [PEP Python style guide](https://www.python.org/dev/peps/pep-0008/) or the little bit easier to digest [Google Python Stlye Guide](https://google.github.io/styleguide/pyguide.html). It's about readability for you and for other developers. If, while and for all don't use parenthesis because assert, return, except and return don't either. Many people have thought a long time about how to best write code so it's the easiest for the eye and for other developers, and you should follow the result of that investigation too. You're trying to learn a new language, right? Why don't you follow the recommondation set by its creators, simply because you programmed C before.
&gt; Slow and noisy? Sorry, I'm not super sure what you mean by that. Slow can refer to being slow to write, read and for the code to be processed. Noisy means there's a hell of a lot of 'noise' in the way when you're trying to read the code. Say this bit of HTML: name = 'world' &lt;div&gt;Hello { world }&lt;/div&gt; would be this with the way you're writing: str = '&lt;div&gt;' str +='Hello' str += ' ' + name str += '&lt;/div&gt;' See how much harder the second one is to read? There's a lot of `str +=`'s and quotation marks. You have to mentally run through it line by line to decipher it rather than with the first one where you can instantly tell what's going on. I had a look at `getLib` and I have no idea what the end HTML will be just from reading. I'd have to render it in the browser and look at the source just to figure out how everythings laid out which isn't good. As for templating: http://jinja.pocoo.org/ Use something like that. &gt;Django isn't something I've used, part of me wanted to keep non-standard library usage to a minimum, I'm not really sure why, except I don't like looking at loading bars I guess? Loading bars in what context? The only loading bar you'll see is the install which will take 2-3 seconds at the max on an average internet line. Keeping dependencies to a minimum is a good practice but not to this degree. These frameworks have been written to save you reinventing the wheel and making the same mistakes everyone else has. 
True. They also add a ton of features most people don't use but cost memory. Not to mention the fact that whole `asyncio` and `concurrent.futures` are at best confusing to use. Personally, if you want multiprocessing, you probably want **multiprocessing.Pool**. Learn to use it well.
I've never noticed a difference with range. It works the same in both for my use cases. I know the backend implementation changed, but it doesn't affect for loops or list comprehension or whatever.
I see what you mean, but for the kind of html in code string building I'm doing, it would be a three or four hundred column length line if I was to do string formatting that way, which doesn't seem like the best idea. And yeah, I was being a bit tongue in cheek with the loading bars thing, it was really about minimising dependencies. Frameworks are nice, but my experience of trying to get a handle on the framework space from the javascript side of this project as I read it made me wary of them, so I stuck with manually writing this stuff.
Messing around with JSONs and exporting YNAB and financier budget files 
Good feedback. I'll see what I can add.
From what i have heard (not tested it) it becomes more of a speed issue. So usually not code breaking.
I don't speak Irish fluently... but isn't this usually written replete with accent marks in order to distance it from the English word 'cunt'? Example: cúntóir instead of cuntoir. I bet you most people won't notice that they're the same word.
Haha, me neither, few Irish people do. It is, but urls, git project names and all that don't usually allow for unicode characters, unfortunately. The actual homepage title and all unicode text spells it that way 
&gt;I see what you mean, but for the kind of html in code string building I'm doing, it would be a three or four hundred column length line if I was to do string formatting that way, which doesn't seem like the best idea. Hmm what? Your HTML shouldn't be 300-400 columns long. If it is then you should really refactor it to be nicer. It _is_ the best idea to use a templating language. Doing it all by hand is not only incredibly messy but also leaves you vulnerable to all kinds of exploits. You should try and stay away from writing your python logic (and really any python) in the same file as your HTML. Keeping the controller and view separate makes things 100x easier. &gt;rameworks are nice, but my experience of trying to get a handle on the framework space from the javascript side of this project as I read it made me wary of them, so I stuck with manually writing this stuff. I mean yeah they require a couple of days to read the docs and figure out what's going on but the time you can save by using them is incredible. As it stands you now have to implement a bunch of stuff from scratch. Like templating, authentication, URL routing, handling form data and much much more. It also again leaves you open to lots of exploits. 
&gt; They also add a ton of features most people don't use but cost memory For instance?.. &gt; Not to mention the fact that whole `asyncio` and `concurrent.futures` are at best confusing to use. I would agree about `asyncio`, although [it's slowly](https://github.com/python/asyncio/pull/465) [getting better](https://bugs.python.org/issue28613), but what's confusing with `concurrent.futures`? The number of public methods is less than number of fingers on your hand.
Awesome. I had seen you mention it meant helper later on the page, and then I realised I *really* don't know Irish as I'd always thought it meant "to count". Of Course, apparently 'to count' is cunta. Maybe [link an Irish Dictionary to the page.](https://books.google.com/books?id=PzeMyvxbUMUC&amp;pg=PA86&amp;lpg=PA86&amp;dq=c%C3%BAnt%C3%B3ir+to+count&amp;source=bl&amp;ots=fZFLXAw4pE&amp;sig=39q7s2m_5sTR86FxBEuLSP0FD8A&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjk8MHe7-rVAhVIWSYKHSrHDf4Q6AEIJjAA#v=onepage&amp;q=c%C3%BAnt%C3%B3ir%20to%20count&amp;f=false)
No problem: BS in CS MBA Expired Nortel engineer Expired jun and hp Expired mcse And on and on And I was an engineer at Cisco for 8 years in their qa department... So be quiet child, really want to compare balances? 
Sorry, could you point out a couple of these potential exploits? Embedded javascript exploits aren't an issue, because a user will only ever see their tasks, and sql injection is taken care of by the MySQL library I'm using, and the entire site is served of https. Certainly the code base would probably be cleaner with a framework, but I don't think I'm risking user data not using one. And I meant more like there's dozens of javascript frameworks doing all sorts of stuff. Refactoring is something I should definitely do to this code base, but it comes after a setup script and removing the monetization system on my list of things to do. 
Haha, that's not a bad idea. Irish is a lovely language, terribly taught in our school. I wish I'd taken more time to learn it properly. 
Oh nice! I think I'll use this in a project I'm thinking about. Thanks!
Take a look at `Online Books and Resources` to the right ==&gt;. If you're an experienced programmer I recommend `Dive into Python 3`. For beginners one not on the list is Alan Gauld's [Learning to Program](http://www.alan-g.me.uk/l2p/index.htm). His book first came out in 2001. He knows what he's talking about as he's a moderator for the Python tutor mailing list.
You're welcome.
&gt;Sorry, could you point out a couple of these potential exploits? I haven't looked for exploits in your app specifically, I'm just talking in general. Reinventing the wheel for everything in a web app always opens you up to potential flaw. Sure you might be alright but if you was using an app that had been in use across thousands of sites for years and has a constant team of people working on it you expose yourself to less risk. &gt;Certainly the code base would probably be cleaner Tbh that's my main concern rather than exploits. It's just tough for other people to work on without spending ages reading through the code. &gt; And I meant more like there's dozens of javascript frameworks doing all sorts of stuff. Sure you're not wrong, but I was just referring to a backend framework like Django.
I'd say it matters one hell of a lot as the number of Unicode decode/encode errors reported has plummeted :-)
[spartan programming](https://blog.codinghorror.com/spartan-programming/)?
Tell that to Dropbox, Google, the umpteen businesses built on Django, the gazillion microservices built on Flask. Or the site you're commenting on. Or Boto for AWS. Yum/anaconda on RedHat. Ansible. Feedparser and the related validators. Most of this stuff is just pure python, used in pythonic ways. Lua is not even in the same ballpark by any metric. Modern languages that are more widely deployed are usually the ones backed by huge commercial muscle: C# from MS and Java from SUN/Oracle+IBM. Python at the moment is basically winning everywhere except mobile, and that's mostly because that world is under commercial lock and key.
I am trying to make Python count to a number N. It's way harder than it seems.
No need to spend money at all. The only money I spent learning was in a book I wanted to have a physical copy to read. The tutorials listed here are all great. 
All anyone need do is read [What’s New In Python 3.0](https://docs.python.org/3.0/whatsnew/3.0.html).
Ah, I get you. Sorry if I came across a little harsh there, I wasn't calling you out, I just wouldn't like to think I'm putting people at risk. You're right, I shouldn't be generating html code in my backend system, I should probably be generating the individual "task" structure on the client side. I'll look into Django alright, but like I said, this stuff if lower on the priority list than a setup tool and stuff. Thanks tho, backend frameworks are a good idea, I'll look into them. 
My favorite teacher on Lynda is Simon Aallardice. He teaches the fundamental OOP and the fundamental database course among others. Make sure to check him out.
A nice place to learn a few golfing tricks is codewars. Some solutions there are insane sometimes.
&gt; Ah, I get you. Sorry if I came across a little harsh there, I wasn't calling you out, I just wouldn't like to think I'm putting people at risk No worries, it's all good. Sorry if it came across that way :) As for the rest: Sure thing! I mean you might not even need to move this specific project to Django or a templating language if you don't want. Just going forward, it'll make your life a whole lot easier if you start new projects using them. I've personally never used Django, but I hear it's great. Though it can be a bit 'heavy' in a sense that it does 'all the things'. If you don't want to use something that big, using something small like jinja just for your templates would do a world of good. I'm quite partial to Bottle myself: https://bottlepy.org/docs/dev/ Super lightweight and easy to use
I think [struct.unpack](https://docs.python.org/3.6/library/struct.html#functions-and-exceptions) is what you need.
/r/learnpython 
/r/learnpython 
Zeromq
Reading any form of geospatial raster data you'll likely make your life easier using [GDAL](http://gdal.org/). A nice pythonic library for reading and writing that data is [rasterio](https://github.com/mapbox/rasterio) (which is also backed by GDAL).
The usage patterns and docs. I had to read through the code to know whether I need it. That's like having to study engine design for 3 years at CalTech to buy a Prius. Usually when I use a package, that's because the authors contributed effort and brain power to grant me superhuman coding skills. With futures I felt it, but the **htop** said a different story. If you use executors what you get back are futures. Futures use way more memory to allow users to implement better management of results. Most people using **multiprocessing** just want to: execute this X tasks on my Y core machine as fast as possible, thank you. Now, don't get me wrong - `concurrent.futures` make sense in python3.6 and on, and if PyPy drops the GIL (which they will do, even if nobody gives them a penny, because PyPy without a GIL is going to be like crystal meth without health issues) then using futures will be a mandatory task on every job interview. 
You might find the [defaultdict](https://docs.python.org/3/library/collections.html#collections.defaultdict) helpful.
This made my day. thanks!
Example of usage: from mimesis import Cryptographic crypto = Cryptographic() crypto.bytes(entropy=8) 'b'\x95\x10q\x0b\x02J\xbb\x03'' crypto.token(entropy=16) '98d075b15e3154956102eadce9768ebd' 
Nice work! You can also spell out numbers with PyICU - that is, if you can afford having ICU4C as a dependency: In [1]: import icu In [2]: formatter = icu.RuleBasedNumberFormat(icu.URBNFRuleSetTag.SPELLOUT, icu.Locale('fr')) In [3]: formatter.format(42) Out[3]: 'quarante-deux' ICU uses the [Unicode CLDR](https://en.wikipedia.org/wiki/Common_Locale_Data_Repository) under the hood which you could do too, rather than have to rely on volunteers to contribute locale data for their language. If you do decide to go down this path, consider adding it as a component to an established Python localisation library, like [Babel](http://babel.pocoo.org/en/latest/numbers.html) (see https://github.com/python-babel/babel/issues/179).
Dropbox? I have bad news for ya: https://about.sourcegraph.com/go/go-reliability-and-durability-at-dropbox-tammy-butow https://twitter.com/jamwt/status/629727590782099456
Use Beautiful Soup to parse the HTML for the contact number. It's can be really hard to parse the HTML using regex.
Can you expound on this?
I'm a 400lb. hacker, so there's at least that volume. 
The answer to both your questions is no, it is not possible. The best you can do is to get the total number of posts a user has made from the user's `statuses_count` field.
what do you mean?
Autocorrect
Let me try. !getbook A Scanner Darkly
[removed]
I haven't really done any golfing in a long while, and then it was pretty much all python2 (which has a few golf-exploitable warts that python3 cleans up) but for a few random things: - Abuse exec and eval. Sometimes repeating a string can be shorter than writing a for loop itereating n times. Eg. here's one I did for calculating pi to 1000 digits: z=s=e=1;exec"s+=z*4*10**1008/e*(2**e+3**e)/6**e;e+=2;z=-z;"*1800;print'3.'+`s`[1:-9] Note that rather than do `for i in range(1800):` to repeatedly iterate over the calculation to obtain the next digits, I just created a big string containing the same calculation repeated 1800 times (by string multiplication) and then execed it. - Another thing you'll see in that example (though this is more specific to python2) is that sometimes, getting a `repr()` via backticks and then using string slicing to finangle it into the format you want can be shorter than proper string formatting (eg. `s` above was py multiplied by 10^1008, but I didn't want the first digit or the trailing ones, so used the py2 \`\` format to get the reprm then sliced it off. But sometimes you can go even further (eg. to go from a list of single letters (eg. `['A', 'B', 'C', 'D']` to the joined form, you **can** do `''.join(l)`, but you can save a character with: `l`[2::5] - Learn what spaces can be dropped, and reorder terms to take advantage(eg. you can write print'foo'+x but not printx+'foo' without an extra space. Sometimes you can rewrite expressions to take advantage of this. Eg. `x-1` and `~-x` are both the same length and return the same thing, but you can save 1 character with `while~-x:` versus `while x-1:` because the symbol ends the keyword without needing a space. Plus there's basic stuff like: - alias stuff you use multiple times to single-letter values. - Put stuff on one line with `;` when indented to avoid paying the indentation cost multiple times (sometimes another reason to avoid for loops). - Avoid imports where possible. Often using `raw_input` is better than importing sys.stdin, though not always. - Using functional tools like map and zip is often very helpful. - Regexes tend not to be as helpful in python as they are in other languages, since there's more verbosity required (need to import re etc), so often string manipulation can be better, but they're still useful sometimes. Of course, the above are mostly just microoptimization tricks. Often the way to shave off those last few bytes can come from throwing everything away and trying different ways to conceptualise the problem - ways that might be quite unusual and counterproductive in terms of the usual metrics of simplicity, performance, or clarity, but that might lead to a solution that's a few bytes shorter.
Dope bot Good bot
This was deeper than I thought, thanks :)! 
Energy = Mass * The Speed of Light squared
Good human
This is my first from-the-ground-up project on pypi. I'd love to get some feedback on anything: code, api, naming, whatever. I know the choice is a little slim now (just pushover is supported) but i wanted to get some feedback before running with it. Thanks in advance!
It can, actually. I'll be covering *object detection* in a future blog post.
StackOverflow rules apply: what have you tried? Have you even googled anything? Any projects in mind? How about /r/learnpython ?
It depends on what exactly you want to practise. For general things you can try https://checkio.org/ Or you can find an open-source project at the sphere you're interested in and try to fix bugs/make improvements there.
Yeah but it was started in Python, and it wouldn't exist without Python.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Even the official python peeps have a better list: https://www.python.org/download/alternatives/ and it's not even complete. Here is another list: https://wiki.python.org/moin/PythonImplementations 
&gt; even if nobody gives them a penny, because PyPy without a GIL is going to be like crystal meth without health issues I lol'ed at this.
I haven't had a chance to use the concurrent futures library. I mentioned it in the blog post as an option though. I'll take a look into it.
Nice. Definitely something I could use to beef up my Django tests.
Well, it really will be. I mean, in most benchmarks it's faster and/or more memory efficient. And they support Python2.7 - which will see commercial use for the next 5 years, at minimum. The moment they release stable GILless PyPy that can be used as a drop-in replacement for Python2.7, the community will go crazy. I expect to see drop in Java developers, by 50% on first month. Consider this - I work with huge Django based project. One of the problems with Django is keeping the templates performant while allowing template developers to use all the bangs'n'whistles, which incurs huge performance penalties - PyPy with JIT helps quite a bit in such situations. 
If you are on a unix-like, try running file on it.
Has anybody gone through this course? If yes, what is your opinion about it? I bought the course but haven't started yet, any tips would be much appreciated. 
I have been working on automated testing using Python, behave, tox, requests... and trying to figure out time.it in Python. It should be simple... but I hit a wall with time.it.
It does sound great, it's the threading model we all deserve.
Four Chan, is that you?
The Python 2 `range` that created a list has gone. `xrange` was renamed to `range`. There's a good explanation of the differences at [Python’s range() Function Explained](http://pythoncentral.io/pythons-range-function-explained/).
EVE Online player spotted.
This is really helpful, thank you!
Check out [this](https://github.com/uqfoundation/multiprocess)
So if I used Jython, I could easily import my Graph class I wrote in Java and use that data structure?
Omg.. I feel like it should an awesome joke that I didn't get :(
They use stackless?
Yes, it can be very useful in testing phase.
I'll definitely have to investigate. Thanks!
big == fat is the joke
Yes, but then you'd be using Java. *ba-dum-tiss* 
user1_num and user2_num are the player's positions on the board
Do you have a link?
Whoa testing phase? That phase should never end right, TDD and all. :P
Make a dictionary with the position as the key, and the obstacle strength as the value. Check the player's position in the dictionary for the obstacle value. /r/learnpython would be more appropriate for further responses.
Yes. These days they use multiple languages but the game was originally written in stackless and it still makes up a large percentage of the code base.
/r/learnpython is the best resource for learning Python in my opinion. This is a great starting point https://www.reddit.com/r/learnpython/wiki/index
Absolutely agree.
Good article. One error: `False`, `True`, and `None` are not built-ins anymore; they're keywords. Like `Ellipsis` and `None`, `NotImplemented` is a "singleton". Also, `NotImplemented` should really be called a "sentinel" rather than a "constant". That's why if you replace your `NotImplemented` objects with `type(NotImplmented)()`, then your example won't work. Python is checking against the built-in objects by identity.
Your use of globals is harming the visibility of one simplification; the logic is the same regardless of which player is making a move. Write a single Turn function that takes as arguments the elements that are specific to a user: def Turn(user_position, user_id): if user_position == position_1: print("you have hit an obstacle. Go back 4 spaces.") user_position += move1 elif user_position == position_2: print("you have hit an obstacle. Go forward 2 spaces.") user_position += move2 elif user_position == position_3: print("you have hit an obstacle. Go back 6 spaces.") user_position += move3 elif user_position == position_4: print("you have hit an obstacle. Go forward 9 spaces.") user_position += move4 else: playerroll(user_id) return user_position while not_done: user1_num = Turn(user1_num, 1) user2_num = Turn(user2_num, 2) Also, use return values to update what you might think of as globals and stop using globals. I am not sure where the move1, move2, etc. variables are initialized, but they look more like constants than (global) variables. 
I'm new to python, but it doesn't appear that you check to make sure the file exists or that you have write permissions.
Cheers mate. The move1, move2 etc are for each of the obstacles (our task had to include import the number of spaces for the obstacle from a text file) telling the player to move forward or back however many spaces. There's quite a lot I need to do to shorten the whole thing so I'll work on that now.
Great work! Thanks for having Finnish there. Where is the data from? 
By the way, what do you mean by not_done?
Just start using it. Find any project you feel like doing, and do it in python. You'll start slow and gradually learn the language as you go.
From the internet. We compile data from open resources in Finnish. If you are native finnish speaker, then you can check correctness of data or updated them and help us with this great language.
The joke is at the "yo momma" level. Whether that is awesome or not is a matter of taste perhaps.
As I mentioned in my previous reply to you it will be covered in a _future_ blog post. I haven't written the tutorial yet, but it's absolutely possible with OpenCV 3.3.
ahh good point on the write permission... it always writes the file "new"(overwrites) so whether it exists or not the file is "created"(aka its not appending) will need to check if it is writable though... if its not readable it will assume it doesnt exist and then try to write and when that doesnt work it will let you know. fixed: def write_ini(ip,cfgfile): if not Config.has_section('IP'): # check to make sure we didnt already load our config file with this section Config.add_section('IP') Config.set('IP','Current',ip) # set the Current IP in the config file to the one fetched from whatismyip.org try: with open(cfgfile,'w') as cfgfile: Config.write(cfgfile) return 1 except IOError: print("Error: Config File is not writeable, Changes will not be saved.") return 0 
I am trying to make python count to N. It is much harder than you would think...
I discovered [this blog post](https://blog.patricktriest.com/analyzing-cryptocurrencies-python/) the other day and thought it would be a great oppurtunity to experiment with Jupyter notebooks. I'm currently working on making the data interactive. https://joshsisto.com/Cryptocurrency-Analysis.html
just do this: ssh blah@host rndc reload Really tho, just have Jenkins or whatever you use for CI/CD do this for you whenever you update the zone files. Jenkins should pull the zone repo, do any validation checks, deploy the files out to your DNS server, and run rndc reload for you. You should not have to write any code for this, at most a shell script or Makefile that scp the zone files and ssh rndc reload is all you need.
An anagram data type, like a set but allowing (unordered) repeated values
No. The best way to handle it is to get everything set up as a proper Python package, with a setup.py etc, then pip install those. Have your foo, bar, etc packages depend on the common one. You don't have to push to PyPi, you can run a local private repo with DevPy. The next best way is to update the PYTHONPATH env variable to include the package area where you've placed common. Manipulating the sys.path directly is usually the worst possible way of doing it.
EAFP: Easier to Ask for Forgiveness than Permission. Don't check if you can write to it, just try it and have an except block if you can't. Edit: whatismyip.org is a "bulky" website, try using checkip.dyndns.com. (I don't know if either are IPv6 capable though.) Edit2: put all of your imports on individual lines, it makes it much nicer to read.
So what I'm attempting to do is automate being reimbursed for travel expenses by taking a picture of any receipt and having a program that can identify each line item and how much it costs. The problem I'm running into is that the OCR I've tried doesn't return the line item and then the price - it returns all of the line items and then all of the prices so my list looks like: ``` ['paper', 'pencil', 'pen', 1.34, 0.45, 3.56] ``` I would like it to look like: ``` ['paper', 1.34, 'pencil', 0.45, 'pen', 3.56] ``` Or even better: ``` [['paper', 1.34],['pencil', 0.45], ['pen', 3.56]] ``` My thought was that if I could scan the receipt for non-white areas of the receipt, "cut" that part out of the image to create a new image that I could then send through OCR so when I get the result, I would know which item corresponds to which price. Hopefully that makes it a little more clear?
Iirc, only the interface was written in stackless
Why does it need to be saved as a .pyw file?
Server side also
Download the HTML with the requests library and parse and query within the DOM using beautifulsoup4.
Or better yet, don't check, try to write and let it die if it can't. You might want to catch the exception if you're looking to print out a pretty "I can't write that file" message but you kind of want your script to give you a bunch of crap if something unexpected happens. Aside from that, if I were writing this, I would separate out the "read from config file" logic and the "check if the IP has changed" logic. I'd probably even put the stored/fetched IP comparison in the "main" block, since it's straightforward and makes it more apparent that that's the main task your script is accomplishing. So it might look something like this: stored_ip = get_stored_ip(cfg) # ie. read from ini actual_ip = get_external_ip() # ie getExternalIp if (stored_ip != actual_ip): # write file print "New IP stored!" else: # print "nothing's changed!"
fixed the writable issue and it seems checkip.dyndns.com is much much slower(takes a few seconds) when read by the script.. quick when done in browser.. weird
Check my edit2 I made a moment after you made the comment. (Separate your imports onto their own lines.)
Four Chin
changed the URL call to the following and now it requests quickly(changed user agent) def getExternalIp(): req = urllib.request.Request('http://checkip.dyndns.com', headers={ 'User-Agent': 'Mozilla/5.0' }) data = urllib.request.urlopen(req).read() return re.findall( r'[0-9]+(?:\.[0-9]+){3}', data.decode('utf-8'))[0] #return the first IP on page(there is only one) 
I've used flask on the first Raspi B with great success. It'll probably run even smoother on the newer boards.
how so? what happens?
I've been working on a module that provides seamless abstraction to a general purpose tiered database structure, allowing a programmer to store and pull data without having to touch SQL. It's super alpha and could definitely use improvement, but if anyone is interested in that kind of thing I can put it on Github and link to it here in a post.
So that it runs without the console popping up, right? It looks like all .pyw files are being run by 2.7 and all .py files are being run by 3.6. That's why it works the way I have it. I guess something with Python Launcher isn't running correctly. It probably has something to do with the way I installed the two versions of Python.
I've used both `multiprocessing` and `concurrent.futures` and I prefer the later. I usually use threads and release the GIL in C-extensions though.
Love the logo. Also, looks like a great library.
Great points! Will update the post shortly.
Cool. Also, `NotImplemented` is not a type, so you may want to rename your article.
So it's a bit strange, but this has been a childhood obsession of mine. I always wanted to make an evolution game where intelligence is what evolves, and not the creatures physical attributes. This is my product after a couple months of work on the side. The source code is [here](https://github.com/apockill/CritterEvolution) and you can download an executable [here](https://drive.google.com/file/d/0B8WHbiufjfVCb1dBUDUzajRqajA/view) Tell me what you think! It could do some touching up, but overall I think the project is more or less finished until I get more time to add new features. I want to change the intelligence to do something with neural networks, but I can't think of a clever way to do that without having terrible results.
Wow, thank you so much for this post. You were extremely helpful and I appreciate that you were able to point out the differences between these features that happen to use the same word. 
Any discussion between van Rossum and Hettinger is worth reading, *especially* regarding optimization issues - thanks for sharing!
Hello! This board is for Python, the programming language, not for actual snakes :)
He's suggesting you use a boolean variable as a means to escape a loop that will run until said boolean variable (not_done) is set to False. You can set up an if statement or a separate function (or both) to determine if the end conditions of the game are met. Once your end-game condition has been met, you set the value of not_done to False. This tells your game loop to terminate and continue, so you can execute your end of game code and exit. Another popular way of doing this is having a "while True" loop and just executing a break statement from a conditional (if statement) if the end-game conditions are met. A place more suited for these types of questions is /r/learnpython, you will likely get more in-depth responses there.
Onii Chin
I just finished making a Reddit bot on /r/buzzfeedbot that gets the main points of "Top X" articles from BuzzFeed's archive and posts them on the subreddit. 
personally I thought the taunting module was better in 2.7 than the newer, 3.3 pytaunt. You can see how efficiently he catches it, due to the interpreter not having all of the bloat that came along with the newer version.
Another way to answer the question about trusting packages is to point to the possibility of adding a checksum when installing a package. This is supported in later versions of pip and ensures that you get the same package or an error if someone tampered with the package.
All right, thanks for the help.
https://pip.pypa.io/en/stable/reference/pip_install/#hash-checking-mode
Golang is interesting but it doesn't fill the same niche as Python. Namely it can't glue together much of anything. There's `cgo`, but it compiles much slower than `go` and you start to run into platform issues. So already you've sacrificed some of the big advantages of `go`. For other languages Golang bindings are limited compared to Python. Where Golang excels is in building portable, single .exe applications that don't have a human interface. I.e. server apps, where you communicate with other apps through a protocol (like `http` or `tcp`). I think it's almost the opposite of Python in that sense, it's the most self-contained language out there.
Skimmed README, skimmed table of contents and first page of documentation. Can't find a full list of every type of data it can mock.
I've got way better responses here, only one person responded and he suggested using a switch case (which I'll try). Thank you though!
The quick way to make Python talk to a C-library is `ctypes`, which is actually faster than `f2py`. If you are writing a C-api module then yes there is a lot of boilerplate. 
Thanks for sharing - Alan Gauld's site is timelessly great!
PROVIDERS.md
Thank you!
Gotcha. This guy seems to have figured out how to do [something similar](http://www.astrojack.com/scanning-and-ocr-ing-a-paper-receipt/).
Let's make README better together. Please, fork it and suggest your variant. Thank you!
Actually many companies are switching from Python to Go. Big Python projects are really hard to maintain. 
Ah nice - cheers!
You're welcome, and that's a shame. That community is always mentioned as a place to go for help on questions like yours. I wonder if it's not the best suggestion after all. Some great introduction to Python courses that I've found that really teach the fundamentals well are: [MITx 6.00.1x - Introduction to Computer Science using Python 3.5](https://www.edx.org/course/introduction-computer-science-mitx-6-00-1x-11) [MITx 6.00.2x - Introduction to Computational Thinking and Data Science](https://www.edx.org/course/introduction-computational-thinking-data-mitx-6-00-2x-5) [Udemy/Peter Norvig's CS 212 - Design of Computer Programs](https://classroom.udacity.com/courses/cs212) These are all incredible courses that cover most of the basic principles behind many of the tasks that people use python for in 'the real world'. Good luck!
Intuitively you would just do: print(n for n in Range(N)) right? Wrong, that's just displaying the numbers, not "counting" them out ;) One, two, three... N It's an exercise that has given me practice in classes, dictionaries (multiple languages support) and functions.
I will add my working example (when done) to github. 
Can you profile your script to see which part causes the lag?
`venv`, `httpie`, `youtube_dl`, `Jupyter`
That's extremely cool! I especially like the emergent behavior and the visual delineation of populations over time. I tried running the .exe but got a "could not find theme default" exception: [(image)](https://i.imgur.com/o6W5P3Q.png)
Huh, that's weird! What operating system are you running on?
venv and youtube_dl look fun, I might have to play around with those. Can httpie be used to automate online logins?
Excellent summary! IMO, scheme problem was no batteries included. Yes, it has hashmaps, somewhere... in several flavors. So, I have to make a decision, install a package, and live with all the incompatibilities of code written by other people and who took different decisions.
`httpie` is not really for automation but for testing http requests. I use it mostly for testing AJAX endpoints.
I'm on Win 10 - I tried running as admin and disabling Malwarebytes, but no dice! I also have Py 3.6 installed, so I may just download the source and run it that way. **Edit**: I see that it's written in Py 2.x - I'll try that.
Source code and more documentation on the github page: https://github.com/OpenChemistry/tomviz
What have you tried so far? Does this all have to be done by hand or are you allowed to use existing packages?
You can use Google App Engine (aka Google Cloud) or Open Shift. Both are free for entry-level users and have great Python support. There are hundreds of paid hosting solutions (probably in your country too) but when it comes to running your own scripts as if it were on your own computer then you're talking "dedicated hosting" plans, which can get pretty expensive pretty fast!
Well, there's Monty....
AHH! My mistake, I linked the executable but not the default/ directory. Here's a zipped up file with everything you need to run it. I fixed the youtube link. Tell me if it works: https://drive.google.com/open?id=0B8WHbiufjfVCQUZ2Vk9LOXA2NnM 
I'm writing one for OneDrive at the moment. It works read-only. I'll probably do dropbox and google drive too. I'm surprised that the dropbox one doesn't already exist.
Oh hell no. Codecademy is OK for learning the synyax of a language and not much more. Its definitlely not good for "learning how to program." Check out MIT's intro to Comp Sci free course. https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-0001-introduction-to-computer-science-and-programming-in-python-fall-2016/index.htm edit: added link to reply to /u/SAT01 because this sub doesn't trust me to comment more than once every 10 minutes... 
Thanks!
&gt; When written well, it is just as readable as Python is. But that's a problem. You need more effort to write readable code in perl than in python. That comes with TIMTOWTDI vs "There should be one-- and preferably only one --obvious way to do it."
could you please link it? I googled it and there are a few Thanks
i *know* this isn't 100% what you're asking and on top of that i'm rusty enough that i don't know that the following is completely true, but i'm almost positive that pandas allows for reading/writing specific tabs within an excel file - even if you'd be starting with no experience with the pandas api, i would whole-heartedly recommend taking the time required to get this worked-out in pandas rather than continuing down the path you're on now.
i mean, yeah, N isn't a number. python isn't a miracle worker! i'll see my way out.
The new download works perfectly - thanks! I had to pry myself away from this to write this update. :D The plants can work as 'islands' as well to simulate Darwin's Finches - all it takes is a few critters to migrate and a new sub-population is created.
Awesome. I spotted that on PyPi. I can add it to the wiki if you like. How did you find developing a filesystem? Anything that could make it easier?
`bytes` and `token` don't obey the seed if one is passed in the constructor, due to using `urandom`instead of `self.random` Mocks don't need to be cryptographically secure (despite the class name :P ) so there is probably no harm in getting rid of `urandom`
I love it when that happens. If you get some time, look through the breeding code on the Critter object. You'll notice that color is associated with the parents + a random mix. That's why sometimes you get islands of only one color, since some successful ancestors spread quickly there!
First and foremost, this belongs in /r/learnpython Anyway, I didn't try to follow all of your code (especially since it is sloppy with the `if` statement) but take a look at `random.choice` and `random.shuffle` Additional tip (as per my "sloppy" comment): instead of if val == 1 or val == 2 or val == 3 do: if val in [1,2,3] Furthermore, you can use slice indexing LL = ['A','B','C','D','E','F','G'] print(LL[-2:])
&gt; subprocess, and a lot of the default ones like os, sys, re, and time FWIW, `subprocess` *IS* part of the "default" (aka, standard library) Anyway, mine would be the scientific stack: NumPy/SciPy/Matplotlib (etc) since it let me move away from Matlab. 
PR, please.
thanks, fixed it.
- Run a linter on your source code: pep8, flake8, pyflakes, whatever. Don't ask for basic style advice; _do_ ask for things a linter is too dumb to understand. - Use requests rather than stdlib urllib. - Why use a config file with just a single entry rather than just dumping the IP in textual form into the config file? - If this is a script, where's the shebang? - Don't return something and not check it. - Don't `return 1` or `return 0`; this ain't C. - Use a JSON API endpoint for the IP. Don't use regex. Other than that, avoid comments in favour of obvious variable, function, etc. names I strongly recommend you read PEP8 to start with.
Your code needs to switch between dealing with three types of lines - let's call them "G-lines", "ditto-lines" and "n-lines". I'm assuming the first line of the file is a G-line? G-lines start with a fixed-point decimal number with 4 digits before and after the point, followed by an integer, and then a number of Gxx values. I notice that the G labels on a G-line can vary, and you don't really know them in advance. Note that this means there will be "holes" in your grid, where some G values are missing for some lines. If a line starts with the 4.4 decimal number, and second column on a line is '-1', it is a ditto-line, and it seems to mean that the previous G-line still applies. If the line just contains signed 1.3 decimal numbers, it's, by default, an n-line. I'd suggest you use a nested dictionary like: grid = { 'G04': { 3300.0: 0.059, 3360: 0.077, .....}, 'G07': { 3300.0: -0.223, .... }, ... } You need to loop over the lines of the input file, and for each line, decide if it's a G-line, ditto-line or an n-line. If it is a G-line, you need to remember the sequence key (the 4.4 decimal) and the G values in a list, and then check if your grid dict has a key for all of the G-values, and if not, create them, with an empty dictionary as the value. If it's a ditto line, you just remember the sequence key; if it's an n-line, you then insert the values into the grid dict using the list of remembered G-values as the keys, like this: for col, g_val in enumerate(g_values): grid[ g_val ][sequence] = line[ col ] After you've run through all the lines in the file, your grid dict should contain everything in the right place, and you can then output it with a nested loop. See how you get on with that. I'll leave the output loop as an exercise for you ;-) Hope that helps.
Think Python http://www.greenteapress.com/thinkpython/thinkpython.pdf 
&gt; I have a heap of expired vendor certs and a comp science degree... hahaha I am amazing and have totally surprised you child!!! Uuuum, I still see no 'engineering' qualifications or professional memberships there. Your experience is in testing and debugging networks, child. Nice attempt at a power speech though :D 
Thank you so much! I just looked thru the contents and I really like what I see :)
Very cool. For completion's sake here's a similar library (which you mention in your readme) https://github.com/joke2k/faker The more the merrier in open source!
Mimesis work much faster, than Faker. Also it's provide more data providers than Faker.
Anyway, Faker is also cool tool.
Some ignorant person around my neighborhood thinks it's funny to always leave poop in front of my house. Should I leave a sign outside to tell him to stop? Nope. I decided to buy a Raspberry Pi 3 with a camera v2 and got to work. With opencv, Dropbox and some extra tools I created a home surveillance video that is still but records at a certain FPS. I made it so whenever there is movement pictures get taken and sent straight to my Dropbox account. I caught the SOAB but let it slide for a while so I could gather up evidence. Saved all the pics and also was able to find what were his walk times. Few days ago I went down exactly at the time that he walks his dog. Asked him about this and he denied it. You should have seen his face when I showed him all of the pics. Didn't call the cops but I did let him know what an a hole he is Update: trying to expand this to something more meaningful now. I am going to set up the video feed across from where I live so I can track how many cars pass my street. With that information I am going to study: -What's the most popular car to drive around my neighborhood -What are the times with most/least traffic -what color is the most popular -Avg speed of the cars and what direction gets more volume of cars Call me crazy but I love doing projects like these!
Finalizing documentation on [latexipy](https://github.com/masasin/latexipy), which allows you to save figures that fit well in LaTeX documents: import latexipy as lp lp.latexify() with lp.figure('filename'): make_my_plot() And, in the tex file: \usepackage{pgf} \input{filename.pgf} [Here](https://github.com/masasin/latexipy/raw/master/examples/example.pdf)'s a PDF with example code and output. You end up with the same fonts, and a similar size. Tests are working (100% coverage), and most of the docs are done. Expect to see it on PyPI within the next day or two. Edit: [Added!](https://pypi.org/project/latexipy/)
Not so fast. Good coders can write readable and maintainable code in any language. Yes, Python enforces that better. But Perl allows bad coders to be productive, too. And these bad coders are the reason why I reluctantly agree with the "There should be one-- and preferably only one --obvious way to do it." of Python. Oh, look, we just came full circle. :-) Anyways, I use both - but Python more
`print(list(range(N)))`, actually.
oh hell. Yeah, I see what you mean now. The words, oh the words.
The "academic degree" node in de-&gt;personal.json is wrong translated... Source: I am German. I can look later over it and send you the correct translations tomorrow if you like. (it's late...) 
Of course. Check it, please. A German language is very important for us. Vielen Dank!
https://buildbot.net/
This is a great library. Hopefully this name sticks lol. I personally liked the original name, church :)
&gt; This is a great library. &gt; Hopefully this name sticks lol. I personally liked the original name, church :) Yeah, it was funny name :D, but offensive for some members of community. This is a final name of the project. We'll never rename it again.
I got a good laugh when I started reading through the `Critter Specific` functions and saw how much more sophisticated the mating function was than the rest of the actions. Even the code mimics life. XD It is evident reading through the code that you put a lot of thought into this design. Even though there is a lot to absorb as an outside observer (eating an elephant comes to mind), there is a clear logical structure to everything. The OOP design structure is a natural complement to an evolution simulation. The overall structure makes it easier to grok your design intent in the same way that a descriptive iterator name can make a conditional statement read almost like a sentence in natural language. I also like the balance between sophistication and simplicity, although I have to admit that I'm already thinking of ways to increase the sophistication. For instance, the whole genome system could be cloned into a "meme" system, which could then act as a loose abstraction of culture. The memes spread via communication, which is really just the mating function, perhaps with some tweaks so that it can spread maybe by proximity to multiple other critters at a time. The really interesting part would come via gene / meme interactions; for instance, say you have an "aggressive" meme - it could be very deadly to other critters when paired with a high constitution gene, but very dangerous to the critter itself when paired with a low constitution gene. There could also be a "cooperative/symbiotic" meme which causes a critter only to attack when attacked - or perhaps even when another in its immediate proximity is being attacked, and so on and so forth. Let the populations develop, then await the inevitable "meme wars". XD The dynamics between genome and meme/culture (acting as a barometer of intelligence) would then start to replicate behavior as described in [The Red Queen](https://www.amazon.com/Red-Queen-Evolution-Human-Nature/dp/0060556579) - that intelligence itself is a mating strategy of genes for the propagation of genes (i.e. the critters are just a vessel), which in theory creates healthier gene pools to create greater intelligence, thus creating a virtuous cycle.
Right on - mimesis is an excellent name
Glad you like this name. Thank you!
Very cool! However the source is a broken link, "Py" is missing.
Pandas is the easiest solution with python. I do this work on a daily basis.
OP provided a link in his edit, but I think it's the equivalent of MITx 6.00.1x. Great course, and really makes a good job to solidify what you learn.
https://www.edx.org/course/introduction-computer-science-mitx-6-00-1x-11 Is that this course? Just enrolled and completely free!
I know..can you point me to an opencv doc or something. I don't find anything about bbox. Is it using yolo or something 
**[HIRING] (NYC) Software Development Engineers @ Amazon** PM me for my email / how to send your resume. Do you want to work on technologies that range from User Experience/Front end to the Data Layer? Do you want to deal with complex technological problems and solve them with cutting edge technologies? Do you want to work with distributed computing, scale and scaling issues, machine learning, big data as well as Machine Learning/Big Data (Hadoop) as well as cutting edge mobile/web technologies? If so, email me! Hiring for roles primarily in NYC, but also in Seattle, Austin, and Boulder.
Pretty dam big I'd say. 
You didn't reply to /u/homeparkliving
Would I have to write a python wrapper class just to use the java library with python code?
I had never looked into doing this with Python before. I did a little searching and came up with the following that might be of interest to someone. from requests import get get('https://api.ipify.org').text get('https://ifconfig.co/json').json()['ip'] get('http://ipinfo.io').json()['ip'] get('http://ipinfo.io/ip').text.strip() All of those produced my IP address as a string without needing regex or BeautifulSoup. Thanks for sharing!
I have updated README and add section "Data providers". Also i created this issue: https://github.com/lk-geimfari/mimesis/issues/206
Create flask server for image downloader
VPSs are pretty cheap and you can do anything on those. Mine is about $3 a month for single core, 1.5GB ram and some storage.
Great library and excellent README - I wish I could have used this months ago 
I'm not aware of anything simple. Does this thread [cross platform alternative for signal.SIGALRM?](https://mail.python.org/pipermail/python-list/2015-November/698968.html) help?
Ah, thanks, I fixed it. I've chatted with the author now and there's a few things to try and coerce `setuptools` into doing to properly support the various amd64 instruction sets.
I'll have a look, thanks.
Oh, I was wondering why this repo looked so familiar to Elizabeth. Can confirm it is an excellent library.
+1 for ipinfo.io and requests. returns a nice json object with ip, org, asn, location, etc. 
No. The main feature of Jython is you can access compiled Java objects directly and manipulate them as if they were Python objects, and pass Python functions to Java callbacks and extend Java classes with Python subclasses. It's mostly transparent. All runs in the same JVM process. 
You can download the data in `netcdf` format from their site. You can use `xarray` or `netCDF4-python` to read netcdf data into python. All the best! Edit: Also you can use `h5py` to read netcdf data into python.
I highly suggest pythonanywhere for easy of use. They literally have a tab for setting up a scheduler.
I appreciate your thoughts on my code :). This was written a year ago, and if were to change anything it would be to separate object definitions into different *.py files and document a but more on the overall structure. The simplicity was key to this project! It could have been a buggy mess if I tried to do everything I wanted all in one go. Something I want to do now is integrate some kind of neural network into the decision making process instead of the gene "tests", and have parents trade weights at different nodes to make decisions. But that might have to wait. Anyways, feel free to fork the project! If you find a way to bring it to python 3 that would be amazing.
That's the one!
Check out /r/learnpython
Thank you!
With regards to the text file, if you reference a file that doesn't exist, python will automatically create it I believe. I'm not 100% sure though off the top of my head 
That's actually pretty convenient. So if you try to write text for a filename that doesn't exist it will just create one?
Edx has a bunch of them on Python. Is this the best one for an absolute beginner?
If you run "open("filename.txt","w")" it should create "filename.txt" in the directory you're running the script from 
&gt; api.ipify.org appreciate you showing me ipify.org they made this for scripts so I dont need to worry about them getting pissed off or changing anything on me etc... thanks EDIT: upon further inspection all of these sites are great.... appreciate you doing the research also they have already thought of the easiest way... from their own page: # This example requires the requests library be installed. You can learn more # about the Requests library here: http://docs.python-requests.org/en/latest/ from requests import get ip = get('https://api.ipify.org').text print('My public IP address is: {}'.format(ip))
sitting aroudn at dinner I applied a bit of KISS thought against my script and realized since im actually comparing a hostname to my external IP I dont need a config file or anything.. so with your suggestion above the new script(still needs to handle exceptions better) is now:(thanks again for ipify.org link) from ipify import get_ip from ipify.exceptions import IpifyException import socket myHostName = 'google.com' #hostname to compare your ip against changed = False try: ip = get_ip() myHostIP = socket.gethostbyname(myHostName) except IpifyException: pass # If you get here, then some ipify exception occurred. except: pass # If you get here, some non-ipify related exception occurred. if ip != myHostIP: changed = True #TODO: call website php script that will change hostname ip print("\nIP {}.\nYour IP: {}\nHost IP: {:}\n".format("Changed" if changed else "Didn't Change",ip,myHostIP)) 
This is really well executed. I've also found this idea interesting, especially the (test - action) model? Is this model covered under some topic that I can read about?
/r/LearnPython
Thank you :) I've been mulling over how I would do something like this for a long time, and finally got the free time to do it. Feel free to check out the code [here](https://github.com/apockill/CritterEvolution) or run the program for yourself [here](https://drive.google.com/file/d/0B8WHbiufjfVCQUZ2Vk9LOXA2NnM/view). As for further reading, this was based on thought babies and an ipod touch game from a million years ago that I loved when I was growing up called [artificial life](http://www.stormyprods.com/alife/). This game gave me the general idea of a 'test'-'action' based model, but I always wanted to remake it and change how things worked, and impliment intelligent breeding. My next steps if I ever get the time will be to change the test-action model to be an input-&gt;neural network-&gt;action output model, where a neural network decides which action to perform based on the various inputs. The neural network weights might be traded by parents during mating. I'm not sure. It'll be a while before I have time off from school to keep working on this! 
I see, thanks for the info. The project is really well made. I'll definitely keep an eye out for NN based modifications to this.
Even better as long as the number N is "smallish"
Hehe
ran 2to3 on it... works great. how hard is it pounding the API? would a delay in the run function make any sense?
Good work! 
I still believe this non-cool, very practical course was the first, best thing I did to learn Python. YOU MUST type each exercise. You need to get it in your bones. This used to free (PDF) I believe in that form it still is. https://learnpythonthehardway.org/ 
I doubt this script can hit the rate limit but just in case: I changed: api = tweepy.API(auth) to: api = tweepy.API(auth, wait_on_rate_limit=True,wait_on_rate_limit_notify=True)
This is really cool and interesting! How long did it take you to complete this project? 
You are correct. I've simplified code that coworkers wrote by taking out the file exists or not check. 
Thank you! It was about two months on and off, doing it on my spare time during school. But the ideas and thoughts behind it have been in my mind for years, I've only finally gotten around to making it happen. Feel free to check out the code and play it yourself, links are in the youtube description!
Something like datasets (the module)?
Faster in what sense? f2py is just a one line command to turn a Fortran module into a python library, which is about as quick as you can get Edit: Ah, by "C library" I meant "a library for Python written in C", not "a library for C" - I think ctypes is for the second one.
Running it locally? 
Rosalind is a great resource if you are open to problems in the field of bioinformatics. Many of the problems are related to important aspects of programming and do not require any prior knowledge of biology. Might be worth browsing. 
I downloaded your executable file and it only works on Windows. Is there any version that works for Mac? 
Sorry buddy, I don't have a mac myself to build it on. The source code is available, and if you want to run it from source it's absolutely possible. The reason I can't build for mac without actually having a mac is because PyInstaller can only build executables for the operating system in which it is built.
Yes E: it use scaley.io for thumbnail and only show thumbnail + link for now
Yep, you are right.
Might be simpler to use this: http://canihazip.com/s
better means bigger?
I'd recommend checking out projects you have interest in and use an IDE like pycharm and step through it with the debugger. It's a great way to learn python by watching how things change and what functions do what/how.
Learn Python the hard way still has that weird idiosyncratic position on Python 3. In 2017, that's making it harder than necessary. 
Ok, so I see you have added setup.py, but I think you've totally missed the point :P setup.py is for packaging purposes, check out those pypi boilerplate projects on github. What you've created is an entrypoint for application. This goes waaay out of convention, maybe read through python docs or some projects to get a grasp what is pythonic and what are some conventions used.
give a try to exercism.io
It's almost like RH had an interest in keeping you tied to their own support... oh wait
The amount of people typing "resemble" when they want to say "resent" makes the above comment *so* ambiguous to my mind.
&gt; I read, it's just the western hemisphere has "confined" Ruby to web development That's because, before Rails, almost nobody outside of Japan used Ruby *at all*. When Rails happened it took the webdev world by storm, basically replacing PHP in bog-standard web shops, but that was it. Whereas in Japan, Ruby was used from the start as a general-purpose language even before Rails came on the scene. Python, on the other hand, started as a more generic language and slowly crept into many different niches.
The Django website has a pretty good tutorial. I learned through a combination of this and a personal project I hacked together in parallel. Worked quite well. https://docs.djangoproject.com/en/1.11/intro/tutorial01/
The [official Django tutorial](https://docs.djangoproject.com/en/1.11/intro/tutorial01/) is really cool. It is a really good overview of how to use Django with a lot hyperlink to specific parts of the documentation in case you want to learn more.
In the stdlib : functools, collections, itertools, multiprocessing... Outside : the scientific ones : numpy, scipy, pandas, numba, matplotlib the viz ones : jupyter, bokeh, holoviews, seaborn the useful : path.py, parser, datreant.core and datreant.data, toolz, dask.distributed the "I need a gui" : bottle (with bokeh and some bootstrap/js) (btw, I'm more a numerical scientific than a web guy.)
Thank you all for your answers!
/r/learnpython
This is simply awesome.
OK 
At the end this could be some strange kind of reinforcement learning with possibly multiple resulting NNs (families) all adapting to the "same" reward function (eating stuff or people) And then suddenly you have to write a paper about finding lots of different minimas and thus solutions to a function by seperating critters on darwinish islands You have then invented an evolutionary ensemble learning thing :D (the ensemble part being exporting genes and letting families clash in tournaments) and its fucking awesome
Oh and look into googles NN-creating-NNs (idk if info other than "we do that now" exists) and maybe find something to use there (to not just change weights)
Something I thought was fun and interesting was project Euler. It's basically a website that's filled with math problems that start of somewhat simple and get progressively more complex but you can only really solve them with programming. For example, you'll have a problem that involves factoring a number, and the number will be something absurd like 7381462837284. Of course you could do it by hand but it makes you think about math and programming very closely. Of course this is only if you're into math but it's still a lot of fun and teaches a lot
When posting to /r/learnpython ,i recommend writing a better description of your problem. As a guide just try to answer the following four questions: What were you trying to acomplish? What did you do? What should have happened? What did happen?
Yeah, that looks cool, I will get started on it. Idk how I missed it lol
I would rename all mentions of pyplot to matplotlib (and delete and resubmit this post), because it's not very discoverable otherwise. The library you're using is matplotlib, pyplot is just a submodule.
That is really cool, will start on it. Quite embarrassing that I missed it. 
Sentdex has a decent video series on it : https://www.youtube.com/playlist?list=PLQVvvaa0QuDeA05ZouE4OzDYLHY-XH-Nd
Dude user creation/authorization is like 200 lines 
 "academic_degree": [ "Junggeselle", "Spezialist", "Master" ] should be: "academic_degree": [ "Bachelor", "Diplom", "Master" ] Not much changed. :) I also had a look over the files in de-at and de-ch, but they seem to be correct.
You need to provide pandas with an xlsx engine. See http://xlsxwriter.readthedocs.io and feel free to post any questions you might have. 
Sorry for incorrect data. I will update it. I love German. Thank you!
No need to excuse. Machs gut. :) 
True, but matplotlib is a lot more complex. I didn't even start to describe complete MPL's API (and I don't see how to fit it into a single picture anyway)
Wow, it's really nice bro! But let me tell you one suggestion, I would rather check before you retweet your tweet. I mean, in the try/except block at the 36th line from twitterbot.py, you can check if the tweet has been retweeted before with something like this: if not status_object.retweeted: api.retweet(status_object.id) (sorry for my bad english bro) 
Yeah, we've renamed this library. Elizabeth ss very beautiful name for Queen of Russian Empire or Great Britain, but not for library. `Mimesis` is better we think.
Start with the official Django tutorial other people mentioned (the famous polls app tutorial). After that do personal projects, google, and spend time with Django documentations. Try replicating some advance tutorials too, after you finish with the official tutorial. For example: https://code.tutsplus.com/tutorials/building-ribbit-in-django--net-29957 This is the twitter mock up tutorial for the very old Django version. And the Heroku deployment part is a bit old too. So this would be a good exercise in refactoring old code and making it work with newer version of Django and newer ways of deploying sites on Heroku. If you choose to go through this tutorial and get stuck, I have already rewritten it, so you could send me a message. I am beginner though, I'm still unsure whether to divert my studying efforts to Django or web scraping. :)
The big selling point of RH is stability, but they need to be more aware before finalizing on a version that many applications no longer support because it's well past it's prime. It seriously increases RH's support burden and frustrates the users.
I made a pull request on github with the changes ;)
I downloaded it for my mac, I need to install pygame so I will try with homebrew. Once I get it running I will contribute info on how to get it running.
Scrape some data from a website and visualize it
Here is how I got it running: sudo pip install pygame numpy scipy python SimGame.py However I dont think it is rendering the graphics correctly. All I see is a blue screen with the controls. 
it's a little hard to read an article with one letter per line... 
Cool idea, I always wanted to find something close to this, but paradoxically enough it doesn't satisfy me for an unknown reason (eg., What type of arrays for 2d histograms, where are lines/columns taken from in the array, that's the kind of things I would have loved seeing in an infographics reference)
But it also increases lock-in for customers, which is likely why RH management keeps setting it willy-nilly. As an app developer, you don't want to upgrade unless forced (and sometimes you simply can't do it, because app developers have long left), so paying RH to safely "stay old" becomes appealing. The more RH can offer that, the better from a commercial standpoint - because they're basically the only ones with enough development muscle to actually come good on those support promises. This is why I suspect these policies are not "unaware" - they know very well what they are doing, it makes them money. I wouldn't be surprised to learn in 2030 that RH is making a killing on custom long-support contracts for outdated Python / PHP / whatever.
There is no switch case in Python so have fun :-)
So why not `user1_pos` and `user2_pos`?
This is a very interesting 'game'! I have thought about doing this too very often but never knew how to approach it. Anyway, it looks cool, but the executable doesn't work for me :/ it gives me the error `Error loading Python DLL: C\Users\~~\AppData\Local\Temp\_MEI72042\python27.dll (error code 14001)`. Anyone know what it is and how to fix it?
Currently I'm using Visual Studio Code, and I Like it for python. But honestly, idk what IDE are using UK schools, but probably the IDE won't be so user-friendly (or at least that's my experience here in spain with IDE's and schools)
You could use a [comma separated value](https://docs.python.org/3/library/csv.html) to store the table.
However, keep in mind that we don't accept mammoth's shit. Only active and interesting projects with good documentation are added. Dead and abandoned projects will be removed.
We've created similar lists for all popular programming languages. You can check this out [here](https://github.com/lk-geimfari/awesomo/)
[This too](https://djangogirls.org/)
They lost last week! Very good news for public scrapers.
PyCharm is pretty good, no idea though whether they use it in UK schools. 
I'm not sure what one is commonly used in UK schools. In my educational use of Python, I used Spyder as it was distributed with Anaconda, though the only time I remember a professor stressing their IDE was one who used PyScripter. I have considered moving to PyCharm, as I hear very good things about that as well. This StackOverflow article is closed, but this has a summary spreadsheet of different features that might help you decide: https://stackoverflow.com/questions/81584/what-ide-to-use-for-python
But PyCharm is not a software that needs to be paid?
Community Edition is free and awesome
Nice, Will try that IDE, thanks or info bro
Imagine if Python have a JIT VM with better performance *_*
Well crap, if Python3 takes 2x longer than Python2.7 to start up, I'm going to keep sticking with Py2 then. Sucks there's friction like this over the source, but I understand both sides. I think it's important to keep the source readable but it's even more important that its fast.
I've seen this kind of thing described as tiny types, in Java context, but makes sense in python as well: small, simple, immutable classes that encapsulate validation of common value objects. For more complex types, I like to subclass namedtuples, adding extra validation in the \_\_new\_\_ method. Anyway, nice article.
What? Are you telling me that this isn't readable: sub (@) { map { $_ + $_[0]-&gt;[0] } @{$_[0]}; }
I was in exactly your same boat a few years ago and I used Codecademy to learn to write Python. It's great for walking you through steps and you're able to follow along well with the examples as you complete the steps. I know I went through just about every tutorial out there at the time and Codecademy's online exercises was one of the highlights. Give it a shot and see how you feel, everyone's got a different opinion.
Came here to recommend djangogirls. It's the best beginner one imo
The post is about how big the python family is.. how else do you measure big?
http://www.attrs.org/ can do something similar with validators, except it also validates on attribute assignment
This looks very interesting! I'll definitely be giving it a go. 
I should have mentioned it, but I am a big fan of the `attrs` library (despite the questionable `attr.ib` naming). Validation + immutable classes go a long way towards simplifying logic.
This pattern is supposed to solve the problem of needing to validate an email address before every use, but it also requires you to do: &gt; assert isinstance(email, EmailAddress) Which is validating an email anyway. This statement could just as easily be replaced with a function call to validate email. I only see the gain if mypy is being used. Thoughts?
I got as far as `While Python 3 has a piss-poor type system` and gave up.
Assert is useless if the code is run with the -O or -OO options so you have to use an alternative mechanism.
I haven't looked much into Django Girls, but I've read parts of their tutorials when I needed help understanding things. It's a good resource. Here's the link I'm talking about, it's an e-book/blog project: https://www.gitbook.com/book/djangogirls/djangogirls-tutorial/details
I didn't notice that they had made a Python package for it as well. I'm a little surprised it is't mentioned with the examples given on their main page. It's just using requests.get, but I like that is has "backoff" in there as well. Nice find. I hope to make use of it. Also, I doubt you would leave it that way, but catching all exceptions and then passing might be one of the biggest no-no's that I hear about. I makes me cringe a little. I looks like you're doing well in your changes, though.
Being British I'd guess that UK schools would just use IDLE. Sure it's far from perfect but it's perfectly adequate for beginners.
That's how it starts :) go ahead and click the critters button, then left click the blue screen to generate completely random critters to start the evolution process. Make sure to put down some plants to sustain the population. Or do you mean that it's also not rendering the gray toolbar at the bottom? That would be a bit strange.
Thanks for.the suggestions! I might actually do this...
I suspect you are running this on Linux or mac? Unfortunately the executable is windows only right now. Running from source is easy though, just pip install numpy, scipy, pygame and then run SimGame.py
I think this issue is so high profile that it'll get sorted, especially the problems with namedtuple. Of course one way to avoid it is never import anything :-)
This is so cool. I love little simulator stuff like this.
Yes!!!! I was just sent some code. Here is an excerpt of the import statements: from pylab import * from numpy import * # from matplotlib import * It is so frustrating! It stinks of "How do I do exactly what I know about in Matlab but in Python" with no deference to the language itself. And you can tell from the commented out import that they were trying to brute force fix things! Quick tip as I see it: * use `pylab` for NOTHING ~~except to have an interactive IPython and/or Jupyter shell. Do not rely on any namespace settings~~ -- Nevermind. It turns out that there is `ipython --matplotlib` option now * Use `pyplot` (as `plt`) for either quick plots where you do not care about anything but seeing the data or to create true matplotlib axes and figures * Use the object oriented interface for everything else And as an aside, be **extremely** weary of `from MODULE import *`. There are nearly zero good reasons for it. 
If you really want to learn it in depth. I highly recommend the book entitled; Django by Example
Besides my comments in reply to others, is there a reason this was done with the XKCD theme? Does it really add to the graphic? (answer: no) **Edit**: I do not mean to shit on this. I can see how it may be useful, though it doesn’t really provide much more than the sample gallery. 
Plz more updates. Starting to think it was all a bamboozle... I mean me too thanks
yhat's ggplot package doesn't look to be in active development any more and is *super* buggy; dev looks to have died in the middle of a major face-lift/re-write. Instead, I'd consider [plotnine](https://plotnine.readthedocs.io/en/stable/) to be "Python's version of ggplot".
My bad, yes works correctly! 
Perfect timing, I was just about to search for some pyplot tutorials, because I need to extend a script plotting errors over time. Thanks mate!
By active participants.
There is a new version updated for Python 3, but it is no longer free and I assume OP is looking for a free resource.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Thanks! Feel free to run it from the executable in the description, or play with the source!
The [TDD](http://chimera.labs.oreilly.com/books/1234000000754/index.html) book is pretty decent so far. However, it uses Django 1.8 instead of 1.11
Note that using this bot would violate the Twitter [Automation rules](https://support.twitter.com/articles/76915#) &gt; D. Automated actions you take on Tweets or accounts &gt; Automated likes: You may not like Tweets in an automated manner. &gt; Automated Retweets: Provided you comply with all other rules, you may Retweet or Quote Tweet in an automated manner for entertainment, informational, or novelty purposes. Automated Retweets often lead to negative user experiences, and bulk, aggressive, or spammy Retweeting is a violation of the Twitter Rules.
I've come to the conclusion that outputting Json and visualizing with D3 is the best solution for graphs and visualizations.
If you're focused and work hard on the problem sets, then yes. Don't think about it too much, and just start. If you don't like the course or find that you don't understand the material, then you can always find another course.
I would love to look at it! Yes, please share! I have been working with PHP, C# on SQL and I would like to see how did you do it for Python. Thanks!
An IDE is just a fancy text editor. You would be just as fine writing out code in Notepad++ as you would writing out code in Atom.
The [official Django tutorial](https://docs.djangoproject.com/en/1.11/intro/tutorial01/) and the [Django girls tutorial](https://tutorial.djangogirls.org/en/) are a good starting point. If you are looking for something more advanced check out the [TaskBuster Django Tutorial](http://www.marinamele.com/taskbuster-django-tutorial) or the book [Test-Driven Development with Python](http://www.obeythetestinggoat.com/pages/book.html). I've written a [blog post](https://consideratecode.com/2016/09/06/free-tutorials-for-learning-django/) comparing these tutorials a while ago. 
It's akin to that, but mine has different features and goals. The tiered database structure is intended for multi-layer data warehouse applications, anything storing a large amount of data. I want to implement the automatic schema feature, but I didn't need it right off the bat so it's not in there.
Use Python 3 unless you are forced to use a library that hasn't been ported over for whatever reason. Nowadays, though, even that is unlikely; hence I recommend Python 3 regardless.
Python 3, the world is finally starting to cut support for 2. 
If you read on you would have gotten to this gem: &gt; In practice, most programmers will get around this by using Python properties and getters + setters: I don't think the author knows many other programmers.
Python 3. There's no good reason these days that I know of for starting a new project in Python 2 (supporting legacy systems is different, obviously). I haven't coded in Python 2 for a number of years now, and I don't miss it in the slightest.
This is a good resource, courtesy of GitHub, on Open Source Licenses: https://choosealicense.com/ Personally, I prefer the MIT license for its simplicity.
Great! Thank you very much!
CodeAbbey - Not as big as Euler project yet I found it very good. You can submit answer in different programming languages http://www.codeabbey.com/ Checkio - Resolve programming problems in form of a game https://checkio.org/. I found that best part is that you can look at other people solutions to see how you can improve your code. Of course once you solve it yourself!
Codewars.com is great!
The usual direction is that people start off writing in Python. Then when you get to a point of seeing performance bottlenecks (which, although Python is "slow" compared to other languages, Python itself usually isn't the bottleneck; it's usually I/O or network), you write some of it in Go. But most people would always start off new software in Python as opposed to Go, since you can get up and running much faster
Windows Vista or XP?
I really don't get the argument here. If the author wants to verify an email address, a validate function could easily be written and checked in the constructor. As it is written in the article, we have a redundant class which is really nothing but a data container. Not to mention the added overhead. This pattern only seems useful for people using mypy. Otherwise, it is demanding Python's type system to do something it is never designed to do. Perhaps before calling a language shitty it is better to consider if your approach is taking a hammer to a screw.
https://www.codecademy.com/learn/learn-python
The issue that you'll get is that text is quite a nice way to describe what you are plotting. Now of course you could describe what you want to plot by clicking various buttons instead, and some languages are better than others. Also if you don't need to tweak your graph that much then you can have a very simple language for describing your graph (or no language). I'm going to include some suggestions in R because if you are only concerned about plotting then the language probably doesn't matter. So if I can convince you not to abandon text you might be interested in *ggplot* in R. This is a DSL designed to succintly describe graphs and easily tweak your existing graph (think like jquery for graphs). There is a port for python [ggpy](https://github.com/yhat/ggpy). If your graphs are simple there are few tools that get rid of boiler plate and the command line see for example feedgnuplot. You also have tools like Rio for R that automate some of the data munging and npcli (by me!) which is a similar tool but in python. Pandas has some convenience function for plotting data frames. E.g `df.plot` as does R for that matter. Of course you could just write your own functions / executables as well. Edit: grammar
This is the most straightforward way to go, PMOTW as example code: https://pymotw.com/2/csv/
I recommend two scoops of django. 
It looks fine to me. Browser issue perhaps?
Tldr: setup.py becomes flit.ini.
i'm currently at about 50% of the way through the udemy bootcamp by jose portilla... totally worth the 20 bucks i payed
I'm stuck on Python 0.9 as I also don't know how to use a search engine to find a question that has been asked and answered repeatedly.
yeah having the backoff pre-programmed and them knowing how their site responds if down etc has some good benifits over other options... also I already fixed the exceptions issue... i just wrote pass there because their example code only had the comment in the exception and obviously that wouldnt run lol
Hmmmmmmmm... that sounds a bit like a job for Excel (I'll get me coat)
Well done OP 
^ what he said
I think you caught a couple downvotes there because you're interpreting this as an XY problem and proposing a solution to what you believe to be the core of the issue rather than the question. While I would agree that may be (I haven't used it) a great way to learn Python, it doesn't track well with what the original question was.
Even with mypy, I don't think the language lends itself to this -- if you're going to be this defensive in validating data then you're going to want immutable types everywhere, and Python makes the creation of immutable types a little awkward. It seems to me that data should be validated at the boundaries of the application -- when input by a user or read from a database. I'd just have `send_email` take a str without validation and try to do what it can, raising an exception if there is a problem along the way.
Great thanks!
If you're stuck, you could also do this like cellular automata. Iterate over the grid for each cell. Determine state by counting rotten neighbours. Build a new grid representing the next generation. BFS with a queue would be more efficient, though.
try www.google.com
but the are lots of others as well try yahoo or duckduckgo. :)
I should have specified, but I am running Windows 7 \^\^ And yes, technically I can install those modules and run SimGame.py, but I am really curious as to what this error means.
Why are you introducing `smart constructor` term and idea when we already have `descriptor` protocol for this same purpose. https://docs.python.org/2/howto/descriptor.html
Hey! We have a bunch of coding challenges in our own platform (all free and Open Source). Here's the [Introduction to Python](https://learn.rmotr.com/python/introduction-to-programming-with-python/getting-started/welcome) and [Advanced Python](https://learn.rmotr.com/python/advanced-python-programming). The platform is a work in progress, it doesn't have much explanations for non-students. But hopefully, you'll find it useful.
Will definitely have a look at this as well. Thank you.
sorry, forgot I was in the builtin reddit browser instead of Chrome, works fine in it. 
This is so much better than most of these lists. Maybe the most interesting one I've ever seen.
It is if you're working in base 24 or higher.
Alright man, I'll get the code together and post a link when I get home from work.
I thought i know pretty much everything cool &amp; active in python, I shall stand corrected. Thank you!
You were already right years ago except for edge cases.
1) Check out the `dir` function. 2) Check out the `help` function. 3) post to /r/learnpython next time. 
Ah, that may be the issue. I built the executable in Windows 10 using pyinstaller, and it may have packaged DLL's that work for Windows 10 but not Windows 7. Or maybe it had dependencies on them. Anyways, thanks for helping debug!
Man I don't even have the words to express how cool this is
Change the notes to Italic ore something to distinguish them from the code below them. As jwink3101 alluded to, it is better to use: fig, ax = plt.subplots()
Thanks!
Thanks! I appreciate the love. Subscribe to my youtube channel for more weird projects.
https://trypyramid.com
I extracted all data in lists and seperate them, I will need them later for writing to another file...I am stuck in extracting mentioned data. Yea, I am allowed to use whatever I prefer, including packages. 
Thanks! I'll post the summer sale link here: https://medium.com/@josemarcialportilla/10-online-courses-summer-sale-12540ec2a1b0
Thank you so much dude...first of all for taking time and writing all this stuff and helping me. I will try this, thank you. Do you mind if I can ask you if/when I get stuck?
thanks dude! I wrote this script like, 2 years ago so yeah it's super messy... I've been meaning to redo it with a machine learning aspect, bc that's what i'm into now... really though thank you so much
holy crap!... man seriously thanks... i completed your python bootcamp after studying it on my own for about a year... it was great none the less... i learned stuff!
Thank you!
Thank you! I hope that you found useful tools for yourself.
Sure. Happy to help. ;-)
Also I believe they have a program for students to get it free
Do you know if the fuck supports xbps-xxx commands of Void Linux? Because. Wtf.! They are terribly named. 
Siraj has some awesome videos 
Got a few new things to check out when I've got some spare time.
Wow, thank you so much. While I wont be a contributor, its a nice way to explore all those nice projects.
There's tons. `dotmap` and `box` come to mind. Remember there is no such thing as a json object, only a dictionary object, so when you look for this you need to google something like "dictionary attribute access". Also, IMO it's a terrible idea. Convention is a powerful thing; if you start writing weird code it will be a lot harder for your collaborators. This in not worth the couple extra keystrokes you'll save. 
Yeah, this is a freak feature of Linux. Anyway we love Linux.
An alternate approach (if you're going to use Python's type hints) is to use NewType: from typing import NewType EmailAddress = NewType('EmailAddress', str) def str_to_email(s: str) -&gt; EmailAddress: # do your validation logic here return EmailAddress(s) At runtime, EmailAddress is the identity function (so you don't incur the overhead of instantiating a new object), but the type system will treat "instances" of EmailAddress as if it were a subclass of 'str'. The net effect is that if you pass a str into places where an EmailAddress is expected, type checkers will complain. The weakness here is that somebody could ignore the `str_to_email` function and just directly use `EmailAddress` -- the user has to be disciplined enough to make sure they call that pseudo-constructor only if the string really is an email address. 
`*args` and `**kwargs `may be what you're after: https://stackoverflow.com/questions/3394835/args-and-kwargs
A big old messy django project stuck with a early version of oscar yikes
It's not possible for about 2 years. It's possible to fetch friends of a user as an application with Graph API. But application will only receive users already using this application.
Congratulations! You have been subscribed to Mammoth Facts!
Sounds like an Active Record pattern, also known as ORM What's the particularity of this one in specif to lets say every other ORM in existence ? 
This
Agree. But useful for quick one user scripts.
Depends on your OS. For Linux, you can watch the output of xrandr. On windows, you'd need to call the win32 API to query the number of screens. 
Windows, I am actually using the win32 API for some other functions of the script, but I wasn't aware it could do this, I will look into it!
So I've been playing with your world for the last day or so and having a lot of fun. Wondering now how much work I'd need to do to modify your code to get measurements over time? Shouldn't be too hard I think, you already make some pretty interesting measurements! Also an interesting detail I didn't expect: The way the plants distribute their food is highly coupled so the spatial/temporal correlations of the energy distribution for any individual plant is contingent on the environment surrounding each of the other plants as well. Since the energy quota needs to dip below the max for food to spawn, it's possible for the food around one plant to be completely eaten while food around other plants remain untouched (if the critters cannot access them in time) and so the critters die of starvation when in reality there *was* food available. What this means is that the environment around distinct plants in the game are coupled even if they are completely isolated. Now this could be an unwanted effect, or it could be a really interesting demonstration of how things really happen in nature (though perhaps on a more heuristic scale?). In nature, most local environments will be historically contingent and sensitive to their neighbouring environments. If a far away environment changes its effects will still ultimately ripple to the local environment. (This is one of the fundamental reasons why global warming is terrifying.) In fact, this seems analogous to the property of criticality in physics which describes the states of systems undergoing some kind of phase transition. Anyways, there's a lot more ideas to explore with this world, so thanks for sharing. Now all I got to do is figure out how to squeeze out more fps and get some proper statistics!
https://docs.python.org/3.5/distutils/examples.html has a 4-line setup.py; would that do what you want?
How to make sense.
What do you mean by "variation"? I typically use matplotlib in conjunction with numpy a lot, but lately I've switched over to Plotly because it's much easier and integrates well with matplotlib. You can also embed Plotly files in an HTML page, which is useful. 
The easiest solution is probably to call GetSystemMetrics with an argument of SM_CMONITORS. 
Mine uses an object that references the entire database, instead of just one record. It bakes a tiered general purpose database structure into the class, where a script can deploy any warehouse database using data stored in a directory tree. I created it to solve a problem on another project that involved a large data warehouse. I'm not claiming it could be used for anything or that it is better than other solutions for any particular problem.
If you can dump the spreadsheet as a csv file how about the [csv dictreader](https://docs.python.org/3/library/csv.html#csv.DictReader)? The `fieldnames` parameter is really useful :-)
That felt good to read
Besides the very unpythonic type checks, the author just renamed a pattern typically known as *micro typing*.
Some of these are much better described here than on the project's own page! e.g. Superset.
I'm glad you're playing it and enjoying it! &gt; modify your code to get measurements over time? This shouldn't be too difficult... I mean, if you want to make it using PyGame's UI builder, it'll be a bit of a pain. If you want to simply output excel graphs it can be done nicely. Hmm... I think it would be worth making a graphic utility for pygame for the purpose of showing cool population statistics over time! &gt; energy quota needs to dip below the max for food to spawn I thought that was a pretty interesting side effect of the energy policy as well! I notice that predatory behaviors do much better in areas where there is little food but a lot of critters. It's crazy how much emergent behavior can come out from just three simple objects! As for FPS, my biggest bottleneck was checking for collisions. I ended up using a SciKit library for creating a KDTree for coordinate points, and running that every 30 frames to get the distance of every critter to every other critter. It was significantly more performant than my python algorithm or using certain numpy algorithms. However, I am seriously considering writing parts of my code in Cython for extra performance (and to learn how to use Cython). Thoughts?
I think the author is a Java programmer.
If you want a ggplot-like API in Python, I *strongly* recommend you use [plotnine](https://plotnine.readthedocs.io/en/stable/). Yhat's project doesn't seem to have much life in it, and plotnine is already far more complete of a port than ggpy was.
&gt; If you want to simply output excel graphs it can be done nicely. Yea at the moment something as simple as that could be pretty cool in and of itself; in game UI would be the cherry on top. &gt; It's crazy how much emergent behavior can come out from just three simple objects! That's for sure! I'm really interested in the science of emergence and my own studies in physics sort of revolve around these ideas as well. My own simulations have been on the Ising model (and we use it to try to understand the brain), but the model is general enough that people use it for economics or social modelling. &gt; Thoughts? Unfortunately, my background in physics had me working with MATLAB and so I'm only a novice in the programming realm or even more specifically Python so I can't offer much productive thoughts in this regard. You said the collisions were your biggest bottleneck but you used a KDTree and that helped. Are the collisions still the bottleneck? Also, is the distance calculations the source of the bottleneck or the actual checking of collisions? 
I'm not sure what's my bottleneck actually. Come to think of it, I finally have the full version of pycharm so I can do really in depth profiling. I should profile my program and see what's holding up FPS right now. Whats your FPS? I run at around 30 with 1000 critters.
Great list some projects I had not yet heard of some of these. Thanks
If you end up profiling I'd love to hear an update! http://imgur.com/a/o93Pb FPS oscillated around 23 with about 800-900 critters. Does turning 'Render' OFF increase the FPS significantly? Just eye-balling it it seems to help a bit but I'm not sure. Here is a sim I've been running overnight. I wanted to have little niche environments that mix (lowest level), but not well, with other niches. I then wanted a sort of 'breeding' ground (second level), and finally I wanted an open 'grassland' type space with abundant food but also the freedom for the critters to get lost and die or go out exploring. Over the course of the simulation I also oscillated the energy around quite a bit so as to weed out the gene pool. FPS seems a little lower than yours, but I will be running this sim on my office PC when my work simulations are done on it. That computer should be much more capable of churning out FPS. :D PS I'd love to hear about different environments you've created. In this sim I was trying to see if the different hierarchies evolved different sort of behaviours. I'm curious what other shapes of environments you may have tried.
By the way, I saw your rap-song with the neural network and it's amazing bro! 
yoooo thanks dude!
Wrote a neat little rest api on my website to provide pretty logs for irc chat. [Looks like this.](https://i.gyazo.com/430cb41c9963bf0c6dfc09eabf3e8c2e.png) Also bughunting my [async http lib](https://github.com/theelous3/asks), and moving an odd bit of code from it in to its own lib that unifies the api for both curio and trio.
I love your environment! Wow, step 1,300,000+, that's dope. Click "PLACE" to toggle the menu, and now you can select to find the "BEST" critters of all time. AKA, the longest living one ever, the most mated, etc. I would love to see them! You can place them and click "Save" and it will generate a loadable json for that critter (or any selected critter) for later loading. If you find any interesting critters, please share them! I'll send you profile results if I ever get around to it. Currently I don't have a python 2 environment on my computer.
In addition to this, try self.__dict__.update(**kwargs) And pass in a dict with key pair as field value.
Ooh so that's how the save works. I thought it saved the entire simulation. Good to know! How does BEST differ from FIND by the way? I'm assuming FIND looks for the best that are still alive? Also what exactly was lineage measuring? Oldest lineage? Will definitely try to catalogue some cool critters!
Cool!
[Hiring] "Software Engineer (Python) at Mobpro" MobPro (Mobile Professionals) is looking for an experienced software engineer to join the development efforts of our real-time bidding platform. We have an automated platform which, based on our clients’ needs, automatically bids on more than 20.000 bids per second. Our goal: to show relevant advertising to the right consumers’ smartphones. https://www.djangojobs.net/jobs/701/software-engineer-python-mobpro/ … #python #django #jobs #backend #programming #ansible
You can also subclass from `types.SimpleNamespace` which does exactly this: from types import SimpleNamespace &gt;&gt;&gt; ns = SimpleNamespace(foo='foo', bar='bar', baz='baz') &gt;&gt;&gt; ns.foo 'foo' &gt;&gt;&gt; ns.bar 'bar' &gt;&gt;&gt; ns.baz 'baz'
These questions are generally better for /r/learnpython. I had a brief look at how you are doing things and reviewed your question. A simple way to achieve what you are wanting, is to check if pb_numbers is the last index in the list. If it is the last index, clear the matches list. There are some improvements that could be done, but I wouldn't worry about those just yet. Keep on plugging away and as you come across more tutorials, you'll be able to look back and wonder why you did things that way.
I think I'm out of the loop here. What do you mean by "mammoth's shit"? Searching only gets me a docx to HTML converter. 
was looking for the same function and from: https://stats.stackexchange.com/questions/281673/byars-confidence-interval-calculation I found that stats.chi2.ppf gives the same result as CHIINV, except its not the inverse so: excel's CHIINV(probability,deg_freedom) = python's stats.chi2.ppf(1-probability, deg_freedom)
Is Yhat [Rodeo](https://github.com/yhat/rodeo/graphs/commit-activity) dead?
You don't install the template - you use it via cookiecutter: pip install -U cookiecutter cookiecutter https://github.com/audreyr/cookiecutter-pypackage.git Also: try /r/learnpython :)
I found a persistent XSS vulnerability in your site. I opened an issue on your tracker and DM'd you.
That is the most elegant way, I reckon. Here is a working example. class A(): def __init__(self, **kwargs): self.a = [1] self.__dict__.update(kwargs) nw = {'b': [2, 3, 4], 'c': [5, 6, 7]} a = A(**nw) print(a.__dict__) 
Guy walking dog: Who are you?! Sundazefeeling: I'm Scatman.
BEST is for best of all time, FIND is for currently alive :) definitely share some! Also you can edit the critters directly on the save file if you want to have some fun. It's surprisingly difficult to make a good critter by hand!
"Learn Python the Hard Way"
Nah I'm not :) I'm just a humble programmer who thinks types are useful in writing maintainable software. Not a fan of having to dig through lines of stack traces to figure out what values a method expects to receive. 
Unless I'm mistaken, descriptors apply only to class attributes. It's useful to have this safety at functions as well. 
It's more that the whole properties/getters/setters for everything is a very strong Java-ism, and something a lot of people new to Python from Java do a lot (since in Java you *always* write getters/setters for everything from the very start).
Author here. To be clear, I am not claiming to invent this pattern. I came across this pattern when dabbling in Haskell: https://wiki.haskell.org/Smart_constructors, and just thought it might be a useful concept for Python developers. 
Does Ansible fall ina your "mammoth's shit" category? Seems like an oversight to include an Ansible playbook repo (which is almost entirely YAML) but not Ansible itself (which is almost entirely Python)
Man I've always had a hard time learning regex and had no idea [this existed](https://github.com/lk-geimfari/expynent). Awesome! Edit: Their documentation sucks but the code is straight forward if you examine the source.
It's actually called a Value object, descriptors are used to control attribute manipulation. 
Yeah, `expynent` is pretty simple library, but i'll try update documentation in this weekends. Thank you!
For Python 3, NewType is the way to go for simple things like this. Value objects really begin to shine when you start dealing with concepts such as money and need to enforce rules like you can't just add $5 and 5€ and get something coherent. 
I mean very old project which deprecated.
Awesome! Thanks! I hope you continue to work on it over time. Looks like it can have a lot of good uses. Obviously for every programmer, it's good to know regex, but this significantly reduces the time in having to accomplish those tasks. Didn't mean to sound like a dick about the documentation. Just honest, because the docs are pretty non existent lol. I appreciate it!
If you insert directly into the `__dict__` like that, I believe it bypasses any property setters, which may not be a good thing. Best just set the args in the 'normal' fashion; def __init__(self, **kwargs): for kw, value in kwargs: setattr(self, kw, value) 
I stand by that. Python has the worst-of-both-worlds type system. It breaks at *runtime* if wrong types are given - fair enough - but at the same time it doesn't​ provide good tools to help you validate your types. Mypy + type hints go a long way, but many type errors still slip through. When even JavaScript has good type systems to choose from (flow or typescript), it's hard to claim that python is good here. 
I can haz complete sentence?
How does it handle: 1. A package that isn't located in the top level, e.g. it's at `./src/mypackage`? With setuptools you have a pair of inputs like `packages=find_packages('src')` and `package_dir={'': 'src'}` 2. How does it handle multiple "top level" modules? e.g. when you install both `mypackage` and `myotherpackage` become importable. 3. How does it handle non-Python files -- html files, certs, etc? 4. How does it handle non-script entrypoints? These are used by almost every plugin system I know. 5. Compiled extensions -- C, Cython, Rust, etc? 6. How do I declare if a wheel is universal or not? 7. What actual advantages does this have over the existing system? setuptools is bit of a beast, but it's usable and more importantly familiar.
I ran deliberately had open wifi for many years. I would be happy for this to exist, but there will be some abuse issues. These days every web forum, website that allows comments and wiki has a deluge of spamming attempts. Constant attempts to post links to scams and to try to get google page rank by having lots of links to websites. Spammers would like this and many of them will try to pay with stolen credit card details or compromised paypal accounts. 
&gt; bughunting If you know that certain properties (should) hold for your code under any valid input, try testing with [Hypothesis](https://hypothesis.readthedocs.io/en/latest/) - it finds minimal counterexamples and is basically magic :)
I think something needs to be done to improve package. We need to be introspective on what flexibilty we acually need from it. [Poet](https://github.com/sdispater/poet) is the solution I'm most excited about. 
Thanks for the quick reply! I'm a subscriber of /r/learnpython but it didn't even click to post there! 
**Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year!** \#1: [Python 201 Book is Free for 48 hours](https://np.reddit.com/r/learnpython/comments/5814lw/python_201_book_is_free_for_48_hours/) \#2: [Python 101 Book FREE for 48 hours!](https://np.reddit.com/r/learnpython/comments/5bmaz0/python_101_book_free_for_48_hours/) \#3: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
You forgot to include the masterpiece that is [FuckIt.py](https://github.com/ajalt/fuckitpy).
I just took a look at it and I'm not impressed. They have a few prewritten regex patterns and that's basically it. I recommend instead the *Regular Expressions Cookbook* from O'Reilly.
😏
You could also use an explicit dictionary as argument: class testSample: def __init__(self, sample_attributes): self.sample_attributes = sample_attributes def some_method(self): print('Serial number: {}'.format(self.sample_attributes['serialNum']['val']) where `sample_attributes` is a dictionary such as sample_attributes = { 'serialNum': { 'val': serial_num, 'range_low': data_range_1, 'range_high': data_range_2 } 'otherAttribute': { 'val': some_val, 'some_other_attribute': some_other_val, } } This may be a better choice if you are still unsure about all the attributes that you will want to consider, because you don't have to change your `__init__()` signature all the time, but instead you just supply a new dictionary. I personally prefer this version to `**kwargs` because the expected input of your constructor is more explicit. The drawback is that instead of doing `self.serialNum`, you now have to do `self.sample_attributes['serialNum']`. EDIT: changed `obj_attribute` into `sample_attribute` to better fit the example.
Yelp is a Python shop. If anyone is interested in a career there let me know!