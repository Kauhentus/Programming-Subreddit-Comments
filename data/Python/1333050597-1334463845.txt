Grant that gender has both biological and cultural construals. Biologically there are major genders (male 50.22%; female 49.72%) and minor genders (collectively, intersex 0.07%). The boundaries of cultural gender categories are much more fluid.
Python's *and* operator expects the operands to be boolean and returns boolean. So, even if Numpy wanted to, they can't return an array as a result of *a and b* where *a* and *b* are arrays.
The severity of gendercide is inversely proportional to the size of the dominating gender, so that the worst possible gendercide is enacted by the gender with the smallest population. Consequently the lower limit on the severity of gendercide is proportional to the gender with the largest population, namely, males. The least severe gendercide would be for males to annihilate all non-males.
Note, I assume you mean Eclipse + PyDev. I also second this. Granted, Eclipse is a bit of a beast but the PyDev analysis + Eclipse debugger integration really makes for a nice setup.
I voted on the favorite poll but not the disliked poll. Vis should be normalized for this (e.g. compare %favorite to %disliked).
The slightest whiff of sexism is clearly not "exactly the biggest problem" in either database-dropping world.
Assuming "problems" are ranked in bigness according to some societal impact such as lives lost, economic output, etc.
Yes I do he asked for the IDE so that is what I put.
And, therefore, **something**-is-misunderstood-by-me is false.
The theoretical lower limit on the severity of gendercide is in a case where there are exactly two genders, equally distributed.
And thus we can avoid an interminable discussion of the actual boundaries of gender.
Wait, stop. If all you want to do is log in and such, displaying the entire web page is severely overkill.
Perhaps the word "drop" in "some of the biggest databases are dropped every other month" means ["to get so incomprehensibly filthy that [...] ones mind explodes."](http://www.urbandictionary.com/define.php?term=drop) In other words, perhaps "drop" has a positive connotation.
If that were the case then we would need to look at other possible candidates for "exactly the biggest problem in software."
There's also the question of the relation of the possible worlds to the actual world.
And the question of the value of the question of that relation.
PyCon (etc.) is more fun if it's diverse. If I can sacrifice a "manly" project to send a welcoming signal, I'll definitely take that trade-off.
To branding in general, if it gets in the way of serendipity.
Nice catch, I hadn't thought about that!
I did this once (jees, it was over 10 years ago) using [Allegro](http://alleg.sourceforge.net/). Apparently it contains a basic Python wrapper now; I'd look into it if Pygame doesn't pan out. As for "class interaction" in Python, you can structure code similarly to how you would in Java, but most of the time you *shouldn't*. There are lots of primitive types in Python that are well-suited to many needs without needing to resort to "everything is a [custom-made] object". There are also plain, non-object-oriented functions in Python, which are themselves first-class objects; often there is no sense in having one-method classes when you could just use a function.
You need to escape a quote mark if it's the same one you used to start the literal string. The "representation" method of a string chooses a format that is somewhat concise, but doesn't aim for the most legible format. The repr format isn't meaningful, except as a format that a Python interpreter can interpret again. You won't often be printing it. &gt;&gt;&gt; '"Isn\'t," she said.' '"Isn\'t," she said.' &gt;&gt;&gt; print '"Isn\'t," she said.' "Isn't," she said. &gt;&gt;&gt; '''"Isn't," she said.''' '"Isn\'t," she said.' 
Did you even read the article? That exact thing happened, and surprise, they ignored her. Like god damn, at least make that stupid argument in a comment thread where that exact fucking thing didn't happened to negative results.
Okay.
Replace Legos with Python/computer programming.
&gt; some of the biggest databases are dropped every other month What does this mean?
Alright then.
Most Linux users are spared this hassle. Perhaps that's why there's not a big rush to clean things up. Neh? The command to install latex2html for Ubuntu, Arch, and Gentoo: $ sudo apt-get install latex2html # pacman -S latex2html # emerge latex2html You need to remove some references to the paths on your own computer. Some strings refer to paths under /Users/whit537/, which breaks the build. Specifically, PYTHON_SRC points to /Users/whit537/src/Python-2.4.2. Edit: Or make PYTHON_SRC an environmental variable?
It means a lot of tech news coverage last year went with "Oh, and someone leaked a whole big thing of Gawker passwords", "Some guys hacked Sony", "Some guys hacked Sony again". I will withdraw the claim that these are the biggest databases anywhere, but they're quite high profile and a lot of people put a lot of faith in this kind of thing working.
&gt; Fucking_Metal_Fever I'm offended because it's capitalized words + underscores.
I forgot what subreddit I was in. Good catch.
&gt;A hypothetical woman. Don't use a collective noun here, it deviates from the usage in the joke. No, actually. The joke refers to the stereotypical woman, so it aims to represent them as a whole. When the joke refers to "she", it's referring to "whatever comes to your mind when I suggest 'woman you're having sex with'". &gt;The question is does using a reference to a guy's ability with a single woman generalize as a stereotype to all women. Yes when it assumes what the strawwoman would say. If you're telling a story, I don't think it would be as bad, but the jokes are *men* imagining what women would say. &gt;For someone who likes to strut out that straw man fallacy I'm referring to "hypothetical woman" as "strawwoman" because it's shorter to type. &gt;If it does, how can any such comment be made in a non-sexist manner? Are you not committing the *ignoratio elenchi* fallacy by demanding I answer a question that has no bearing on our argument? I can't remember what fallacy that is. Anyway, whether or not I can think of a non-sexist sex joke does not change the sexism in TWSS.
I just know that when going Mac midiox was one of the most missing programs for me, still is - awesome piece of code that...
Best IDE out there.
I don't think you can make 16 bit programs in python. Python only works on computers with at least 32 bits cpus.
&gt;edit: I'm saying this for the first time; could a downvoter explain the downvote? I guess it's not sexist as long as it's against men. You created a hypothetical situation and then treated it as though it was real. Maybe she would say, "Sorry for the sexism." Maybe he would say a woman writing a program expressing its "girlishness" isn't the same as a man writing a program expressing its "manliness". Maybe everyone would realize that segmenting everything to one side of a gender binary is the wrong way to live your life. Edit: I should add, I didn't downvote you.
&gt;I can't fathom the thought process that led to your OP in this thread. Then don't; ignore it. It was probably too long and involved a number of assumptions on my part so instead of us making this an argument, let's agree to agree that I fucked up at some point.
As a masochist I find that objectionable, but keep it coming.
I hate it when people use "_-bit" the wrong way as well, but I wasn't going to bring it up.
sed -e "s/manly/epic/"?
Is Visual Studio free even if it is used for commercial reasons? What features really make Visual Studio stand out against other IDEs? 
It sounds more like a combination of "test" and "estrogen" to me, I didn't think "testosterone" played into it. Even if it did, favoring two groups equally isn't a great idea. Why not something neutral? That's why assertEquals makes a lot more sense.
I'm the only woman in engineering here, so yes, those who wrote the bot AND most of those who complained about the bot were men. One could ignore the bot itself, but frankly, I don't think I should have to. In any case, there was typically a small discussion after each TWSS joke, most often centered about how it either made no sense or was objectionable. I think writing a bot that tries to interpret human language is a really interesting problem. I am confident one could make a more clever/creative use of that solution that just TWSS jokes. And no, I'm not the humourless harpy some people seem to assume. In fact, I love jokes. I just like them to have a modicum of cleverness. One of the funniest things I've ever heard happened in an interview: Me: Hello, good to meet you. (we seat ourselves) Interviewer1: (dives immediately into a highly technical question) Interviewer2: Whoa, whoa, whoa! Let's do a little interview foreplay first!
disclosure. I am the curator there. 
You can't garuntee that. You can't even say that with any certainty.
Not exactly. The assignment doesn't require Linux, it just appears to be the best way to go about doing it the way I want to.
Well, it's a login through an API (using OAuth), so I can't have the user type in their username and password in the program. That's why I figured the best way to do it is to open the login page in a browser, but rather than open a browser I'd prefer to open a window in the program to display it.
&amp;#3232;\_&amp;#3232;
Tried that... not as funny. But thanks for the idea :)
C# on .NET is getting like that. I find many developers still coding in the 1.0 version syntax with a few new syntax style thrown in there.
Microsoft picking up Anders was one of their smartest moves.
subscribed! 
What kind of news feed are you referring to?
Any tech blogs in particular you'd recommend?
It's like a train derailment.
Sorry for the bad formatting, I tried to make it look good but it didn't work.
 $ pep8 AdobeMalwareClassifier.py | wc -l 800 &amp;#3232;\_&amp;#3232;
While I agree that TWSS jokes (and most jokes) are unprofessional and should not be regular in work-place, I don't think it's sexist. So I don't think the OP has to try to make it about sexism to justify her action and get people to support her side.
"***THIS SOFTWARE*** IS PROVIDED BY THE COPYRIGHT HOLDERS AND,,,,,,," Well, i wouldn't call it that. 
https://gist.github.com/44903654d7c27e6730f6
I came here to say "please tell me that's codegen". But you even know what did it. Nice! /googles weka
Template Power for php is by far the simplest embodyment of parr's vision of removing all logic from the template. I have coded up similar systems in python and lua. But I think mustache is the winner in this category.
Do we need to add a new section to https://gist.github.com/289467 ?
Yes, VS shell is free to use even commercially. Features - well, imho it boils down to personal preferences. If a developer has used VS for developing in other languages it would be natural to use it for python next.
Yes and no. As a development environment VS is pretty solid. For a developer who is doing other development on VS using python in it would be natural. For features - think of PTVS as PyDev for Eclipse. All python related features come from this package. Project is now a year old (first beta relesed Mar 7 2011) and funded differently as wing or komodo-ide so yes, expect fewer features. For example no django template debugging.
Yeah, but if you rotate this code counter clockwise, you get a nice mountain landscape. That's worth something too, right?
Looks like ASCII art. Hey, I can see a boobie!
[Here is my approach.](http://codepad.org/xaNPm7Wp) If you have any questions feel free to ask! The premise of the monthly average function I implemented is the same as your own, checking to see when the month and year of the current entry is no longer the same as the "current" month and year.
It's auto-generated and all that, but I liked this bit: isDirty = 0 if input.DebugSize &lt;=0: if input.ExportSize &lt;= 211: if input.ImageVersion &lt;= 520: if input.VirtualSize2 &lt;= 130: if input.VirtualSize2 &lt;= 5: if input.ResourceSize &lt;= 37520: 
That is pretty clever. 
The costs of C++ are complexity, tons and tons of complexity: * Loss of lots of C's ecosystem and tools due to name mangling * Templates linkage issues * Compilers incompatibility due to huge complex language specs * Compilation times * Incomprehensible compilation errors * Increased code footprint/overflowing instruction cache * Quirky debuggers Also design mistakes: * The "rule of 3" not being enforced in any way is a huge pitfall * No reliable ABI (C shares this but is a de-facto solved problem in C) * Constructors are implicit by default ("explicit" keyword should have been default). Too many implicit converters detract from type-safety * Badly designed standard library (See the C++ stdlib iostreams vs. Qt's much better designed ones) * Specified exceptions behave in a very stupid way (std::unexpected_exception). * Many, many more... Those of us who believe implementation inheritance is plain *wrong* would add the misguided OOP features of C++ there too. Interface inheritance is not wrong per-se, but is too weak (See type-classes as the more proper alternative) and adds redundant/incompatible forms of polymorphism. IMO, the major advantages of C++ over C are: * Templates/specialization, allowing more sane type-safety * Auto-destructors (implying RAII) for less error-prone resource management * const methods allowing transitive const semantics The rest of the OOP features of C++ are really worse than manual vtables IMO. With a certain strict style in C, most of these C++ advantages can be partially achieved in C. For example: always export an "init/fini" pair, making destructors easy to see/review. The huge disadvantages of C++, however, are inherent and cannot be worked around. In my experience, C development, especially in a large group with less discipline over all developers (where a subset would be un-enforceable) scales better and we spend much less time fighting with tools, and getting work done.
I doubt it will handle thousands of objects on screen with various effects.
[IdleX](http://idlex.sourceforge.net) is an extension to IDLE. It is simple to run and provides extra functionality without a lot of GUI bloat.
A few years? Wow. I believe that they do a year (or major versions or something) but you would have to check. I have certainly not purchased a license every few months that is for sure.
Have you played the early Final Fantasy games? He's not trying to rewrite Skyrim here, he's making a game like the RPGs that ran on the SNES -- which itself was only 3.58 MHz.
Don't forget the g flag. ;-)
I'll give it a try. I see PTVS 1.1 was just released too.
Personally, I liked the "incomprehensibly filthy" interpretation.
For the record, ["the feminist" agrees with you](https://twitter.com/#!/velociraptors/status/185356655989493762).
I've written a DSL for my workplace following a declarative model syntax similar to your proposed syntax. Unfortunately, it is not open source. One that is any has many interesting ideas and yet another syntax for protocol DSLs in python is construct: http://construct.wikispaces.com/ Here's a decent example of the syntax for construct: http://construct.wikispaces.com/examples
I use pycharm and I like it, but... hope they are not building a 20 tons monster trying to get new customers entering the spiral of offering an increasing, never ending number of features (candies). In my opinion they should concentrate before on robustness, usability and speed. And yes, not everything in pycharm is working as it should. Anyway, very good IDE. Keep it fit, please
Having reddit's code in the screenshots is a nice touch :)
Cool! That works out. And here I thought you were also a feminist :)
How can I start? I have no idea where to even start this. 
There's a discussion of code, libraries used, and a link to the github page. What's wrong with having it in /r/Python?
&gt; but I don't really have any :| Windows pfft. You mean, you don't *think* that you have any. That's not a dig on Windows, I'm just saying that there's always something that can be improved. Example: At school, I'm required to sign in to a frontpage that they have to show that I'm a student before they'll route my stuff. I built a script using mechanize that'll take care of it for me. Look at the python projects that are blogged about, if you aren't sure where to look, [this](http://www.pythonweekly.com/) python newsletter often links to good ideas and project reports If you're truly uncreative, I'd suggest hitting the source code for the standard library. I'm constantly hearing about how quality the Python is, and how much it can teach programmers. Another realm worth looking into is patterns. Maybe pickup the Head First patterns book and implement each in Python. For that matter, pickup an Algorithm book and implement everything. I struggled with looking for intermediate level books and realized that the only way to progress, after you've learned the syntax, is to code.
The first program I used dealt with calculating percentages, I did it just often enough that it saved me a few mins each time. Start small
Let's dive straight in with something that might seem daunting to write: an emulator. For something simple to emulate, try the [Chip-8](http://en.wikipedia.org/wiki/CHIP-8). All information about the chip-8's hardware and opcodes is available on that page for reference, but it won't help you write the actual emulator. There's lots of other resources on the web about it, [here's](http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/) a good tutorial on it, albeit in C++ (try not to just port the code, however; learn how it works). Emulators are fun to write, and challenging to get right. With it being in Python, exactly replicating the hardware might be tricky, but [some](http://docs.python.org/library/array.html) modules can help with that. 
True, though I personally am trying to find the perfect IDE for my needs, and keep hoping something *will* have changed each time this question is asked. That is, I am unhappy with basically every IDE for one reason or another, and it continues to make me sad.
&gt;Loss of lots of C's ecosystem and tools due to name mangling This is only considered a negative because it's C++ and there's thus some strange *expectation* of having C's ecosystem available. &gt;Incomprehensible compilation errors To be honest, I don't find C's compilation errors much better. Most compilers phrase their errors in needlessly obtuse ways IMX. C++ ends up with **longer** compilation error messages that contain a bunch of redundant stuff that hides the important part, yes, because template names get expanded all over the place. STLFilt apparently helps a lot with this. &gt;The "rule of 3" not being enforced in any way is a huge pitfall In C, it's enforced by not having access to the functionality if you don't write it. And there's still nothing that enforces that you write an explicit 'destroy' function for structures that manage their own memory. Or that you **call** it, for that matter. Seriously, you can't count this as a "not-workable-around, huge disadvantage of C++" while saying that the equivalent problem in C is solved if you just "always export an 'init/fini' pair". &gt;Specified exceptions behave in a very stupid way (std::unexpected_exception). They behave in the only way they realistically can, given (a) backwards-compatibility with some stupid initial design choices (throwing non-exceptions - although it's kinda hard to avoid that without making the base exception a built-in type, I suppose - and `catch (...)`); (b) the fact that there isn't static analysis for exception possibilities (and TBH, Java has shown that checked exceptions generally just piss everyone off); (c) the fact that you really just can't do anything sane if an exception is thrown in a destructor. &gt;The rest of the OOP features of C++ are really worse than manual vtables IMO. ...But they're basically just automatic vtables (never minding that the spec says nothing about implementation).
After a few years of writing Python on Windows, I'd say: pain is relative. Though in particular, if you are stuck writing on Windows and deploying on *nix, some relatives are more painful than others..
Here are some ideas for scripts off the top of my head: - Write a script that detects when you visit a youtube link and pauses your Winamp/Foobar/whatever mp3 player you use until you navigate away from the page. - Write a script that takes a reddit username and downloads their comment history (or as much of it as you can -- stupid reddit limits you to 10 pages of 100 comments each for 1000 comments max), feeds it into a Markov generator and spits out a comment that statistically sounds like they wrote it. - Write a script that automatically downloads the 10 most popular videos from r/videos+video+youtube and saves them as .mp4 files with readable filenames that are derived from the title with spaces converted to `_` or whatnot. - Write a script that takes a US zipcode and a body of text, and automatically finds all the congresspeople for that district and sends the text as an email to all of them. - Implement your own meme text image generator, which takes as input the URL for the image plus some text. It should overlay the text on the image, using the familiar all-caps Impact.ttf in white with a 2 or 3px black stroke, save the image and upload it to imgur, printing the URL. - Write a script that uses Google's spelling suggestions to spellcheck a Word document. These are all things that are eminently doable in Python with existing libraries -- all the hard work has been done for you, so none of the above should be more than 100 or so lines, and you should be able to bang any one of these out without much trouble if you truly know Python. 
So apparently I need to practice sed expressions more...
Could I have a few pointers on how to get started? Seems a bit daunting.
Just break it up into little programs. Write a function to login, then write a function to search, and so on and so forth. There should be plenty of examples online of loging into a website, or querying a search engine. Just combine the two things. edit: [there might even be a nice api that you can hook into.](http://code.google.com/p/pybing/)
license covers all upgrades for the following 12 months. That is. After this period the IDE continues working in full power, but you do not get new updates. I find that a reasonable deal. 
What does "support" mean? Can you write apps in ironpython and build a distributable android app?
I've spoken to the developers. The majority of the codebase, client and server, is in Stackless Python.
You can write apps in IronPython and using MonoDroid + Android SDK build a distributable Android app.
Deferreds are rather similar to some form of monad, yes. 
Django's DSL for models is a slight mind-bender in that they want the properties to ultimately behave like basic types when used with an instance, and yet have the model intercept those values when marshalling to and from the database. Django chooses to re-write the class definition so that the properties get stored in the `_Meta` inner-class so you can interrogate them. I think it works well. But the Django approach may be over-kill for many situations where you don't want need to allow that flexibility.
I absolutely love Sublime Text. Could you by any chance tell me what to do with sublineCodeIntel or SublimeRope once I download the zip? 
Would this be through Mono for Android? 
The only Python is good Python.
 is_dirty = 1 Mixed-case is blasphemy.
Signed up! Thanks!
Have you played Quake?
I don't think i've played the first one, i don't see what it has anything to do with this.
Just use Vim
Django does a number of interesting things and I stole a few different ideas from Django model's. One problem I ran into was, when doing class level declarations, how to maintain order for the fields. The way I ended up doing it is that each field, when constructed, gets a unique sequence number that is kept track of at the class level of the base field. Then the metaclass creates data structures that give the message container the fields in the proper order.
If you are already using gevent there is also the package gevent-websocket which you can pull from pypi or out of bitbucket. We created an updated version of gevent-socketio that is an abstraction on top of websockets to support older browsers with transports like xhr polling and flash sockets. https://github.com/abourget/gevent-socketio http://readthedocs.org/docs/gevent-socketio/en/latest/
Thanks!
So now that we're done laughing at it, is somebody going to demonstrate how this *should* be done properly in Python, and perhaps submit a patch to Weka ? 
Or use gevent and write normal code, just saying ...
LPTHW
Would your teacher happen to be a doctor?
I have plenty in other posts. Mostly concerning the Loch Ness monster, for some odd reason. 
This _is_ normal code. Using gevent means having non-normal code.
OK, everyone is going to tell you that it's impossible to code with an IDE because they're big massive toy boxes with lights and buzzers that nobody needs, but the thing is... that, *some* incredibly smart people actually learn from buzzers and whistles that give meaningful feedback about things, and being able to look at some "object" and see what it looks like as a blob in memory "thing", structured by meaningful information that "points to" other things (imagine inspecting ordinary code the way we inspect CSS manipulations of the HTML dom, or however your web course taught you it should be explained). Some people need IDEs, so we should help those people get IDEs. If we make something good enough, we might even enjoy using it someday. Well, maybe it'll give us indicators like PID, the child processes and signals listened to. You know, all the juicy stuff that the Kernel developers laugh at, because "rrrho ho ho! ve do not need zis, ve arrhh keehrnel dewelopers." I don't use an IDE because they're monolithic giants, but so is my beloved GVIM. I'm willing to admit that to myself, and I don't shun IDEs that *take the approach of writing the text control in the scripting language hosted by the IDE.* **YOU MAY NOT USE LISP AS THIS LANGUAGE PERIOD.**
Ohhhhh, I just want to make scripts for command lines, maybe make a simple shell. Be able to send email without a browser. Just add accessibility and simplicity.
And now we are on hardware 30 to 40x faster, software graphics will do just fine for almost anything danielito will try, including fairly complicated graphics. Plus with pygame &amp; SDL and he can have hardware acceleration with little to no extra effort on his part.
Cool! OK, look up smtplib, that will help with your email idea. Making a shell is a little unnecessary, but it should be possible with straight raw_input and a bunch of if statements!
This uses Mono for Android to work.
Roles are sometimes accurate, but it's not acceptable to always place women in the same roles--see, e.g., [*United States v. Virginia*](https://en.wikipedia.org/wiki/United_States_v._Virginia). Saying that women can't stand military training doesn't justify denying that training to *all* women, since *some* of them can stand it fine.
Perfectly reasonable. But you've shifted from "it's bad because it's sexist" to "It's bad because it's annoying." Yeah, annoying things should stop, but they never will and they certainly aren't worth the attention they're getting under the guise of sexism.
Ironically, that's what all the purported "sexists" in computer science say too.
That was my point.
Are you the OP? Your response here is completely reasonable. The problem with your OP is that you didn't like the TWSS jokes because they were sexist. That they were annoying or "not clever" were implied to be secondary reasons why the TWSS jokes were undesirable.
Flask is a pragmmatic framework, it doesn't force you use OO. Though OO is main stream but not always best choice, some time you need to create 2 separte function like parsing and some validation, if you use Django(might be wrong, since I haven't explored so much)you will be forced to create class, at this point to support a simple functionality you are trying create lot of abstraction, my point is framework should provide OO and functions as well. Django has got learning curve, but flask is minimal, docs are awesome, Django has much larger base users. Disclaimer: I am flask fan boy :)
What's the difference between this and Celery?
Thanks, that's a nice compact way of doing it. I haven't actually used sets before (I've only been programming less then a year) but I think it's time I look into this data structure.
Its also a generalization that has no basis in reality. Which is what this article shows.
Sets are awesome and I'm always finding new uses. Programming pushes us to think about iterative steps, but sets let us think about the unions, intersections, and differences between things. It turns out that many iterative problems can *also* be expressed by arranging things in sets and acting upon whole groups at once.
[Direct link](http://www.jetbrains.com/pycharm/nextversion/index.html) without the blogspam.
Because the SL4A bridge is not nearly as complete as what you can do with native code (Java). Your best bet is probably [Kivy](http://kivy.org/).
Not having order means you can't access its contents by index (e.g. `foo[1]`) which makes it pretty un-list-like. I'd say it's more like a dict that has only keys and no values, which means that you also can't do `foo['bar']`. (But you can write `'bar' in foo` just like with a dict/list.) 
You generally don't access lists' contents by index anyway. It's far more normal to iterate over them, which you can also do with a set. In fact, how could you even want to access "the third element of the set" or whatever? In fact, even if you really wanted to, you actually could: s = set(['a', 'b']) l = list(s) first = l[0] second = l[1] But I think that's almost always bad python.
This is real gem survey for hackers, self taught, not the reality because in corporates programmers(so called) foreced to use the language what non technical or managers choose. 
By curator u mean selector of links? Or are u more like a d.j. ?
That's a much better syntax than that used in the article.
 s = set(itertools.permutations(str))
I've done some playing around in Kivy and it's absolutely brilliant for simple graphics.
You are absolutely correct. It's a bad habit from my C days.
What you need is the "lexicographically next permutation": def lexicographically_next_permutation(a): """ Generates the lexicographically next permutation. Input: a permutation, called "a". This method modifies "a" in place. Returns True if we could generate a next permutation. Returns False if it was the last permutation lexicographically. """ i = len(a) - 2 while not (i &lt; 0 or a[i] &lt; a[i+1]): i -= 1 if i &lt; 0: return False # else j = len(a) - 1 while not (a[j] &gt; a[i]): j -= 1 a[i], a[j] = a[j], a[i] # swap a[i+1:] = reversed(a[i+1:]) # reverse elements from position i+1 till the end of the sequence return True ###### if __name__ == "__main__": li = ['a', 'b', 'c'] print li # process while lexicographically_next_permutation(li): print li # process **Pseudo-code:** 1. Find the largest index k such that a[k] &lt; a[k + 1]. If no such index exists, the permutation is the last permutation. 2. Find the largest index l such that a[k] &lt; a[l]. Since k + 1 is such an index, l is well defined and satisfies k &lt; l. 3. Swap a[k] with a[l]. 4. Reverse the sequence from a[k + 1] up to and including the final element a[n]. Available [here](https://github.com/jabbalaci/jabbapylib/blob/master/jabbapylib/math/permutation.py). *Edit*: pseudo-code added.
Ok. I also did LPTHW. But try and go through the book i linked to. It's a very nice complement to LPTHW. It introduces you to computer science concepts and cool algorithms. You'll love it.
There is a real thing in here that perhaps I should make explicit. Nerdy types are constantly being forced into situations in a typical workplace that make them feel uncomfortable. They pretty much have to just buck up and "get over it". If this group is being a little weird about stuff I am inclined to give them a break... But what about a woman actually working in tech? She gets all the normal crap plus she has to deal with her coworkers being weird to her. The person who wrote the linked post couldn't complain to HR about a hostile workplace (she just couldn't). She had to deal with it on her own, using the normal nerd coping strategy of extreme passive aggressiveness implemented in a obviously clever way. No amount of pointless sensitivity training will make any difference here. This is something that the group is going to have to deal with from within. Why should we? Simply because it is unfair. 
itertools.permutations returns a generator, not a fully instantiated list of permutations, so the second variant is not slower. And in fact: &gt;&gt;&gt; timeit('set(itertools.permutations("aaasd"))', number = 100000) 1.5462353489467127 &gt;&gt;&gt; timeit('s = set()\nfor i in itertools.permutations("aaasd"): s.add(i)', number = 100000) 2.894003728376262 &gt;&gt;&gt; timeit('s = set(); a=s.add;\nfor i in itertools.permutations("aaasd"): a(i)', number = 100000) 2.3871553594207455 Because the loop ends up being implemented in C, inside the set constructor, instead of being interpreted by the interpreter, also, you don't need to lookup `s` and `s.add` every time (as you can see in the last example, caching `s.add` helps a bit).
Yeah, forgot to say that I use Linux. **Edit:** please don't listen to this guy *gcmalloc*. I just tried it under Windows 7 with Python 2.7 and it works flawlessly. I can report no crashes.
well, kivvy is definitely a compiler, pygame is a library, so it needs to be compiled for whatever device you're using. I mean I feel your pain, but there's a reason the main python devs haven't added a graphics library to the python standard library. Heck, there isn't even an imaging library standard. It's getting to the point that's it's unacceptable to not have a standard graphics library in a modern language, but it would also put a lot more constraints on python implementers to have some sort of "open window, draw on canvas" type graphics built into python. At the same time most languages let graphics be a platform-dependent thing or are a language tied to a platform (C#, and even C# is divorceable from its gfx). Java has graphics tied to the standard lib (awt) and look how that turned out? **TL;DR: problem is in layer 8.**
Why is it so good?
Thanks! 
What exactly does the rope sublimerope package do? I would love to get autocomplete for classes in my project, but it's not happening.
I used to use emacs for a long long time, but I have switched to Sublime Text 2 and been very happy with it. 
Windows accepts both \ and / as a path separator.
I don't think viscence was making the same comparison as you think. Both of your examples still generate non-unique permutations, so there is unnecessary overhead at the price of simplicity.
Have you got sublime text 2? The version I have has auto complete for classes etc.
As does the [thread-starting comment](http://www.reddit.com/r/Python/comments/rm3ii/whats_the_best_way_to_reorder_strings/c46x11t). But yes, there are two solutions in the comments that don't generate duplicate permutations at all.
Yes.
I can't think of an algorithm to generate all unique combinations without generating non-unique intermediate permutations. Is there one?
None of what you said refutes my statement. Yours has higher time complexity, it's as simple as that. I said nothing about yours being slower in cases with small inputs.
does not look worth it for the price
This is an obscenely bad idea. Use the builtin package mechanism and if needed, use relative paths on the import as a last resort. You best possibility may be to just use virtualenv.
It's really much closer to a dict without values, plus some set theoretic methods. You can't put unhashable objects in a set.
I do, but auto complete for classes or even modules is not working. If it's the same file, it recognizes the names, but not between files.
I accept your argument, I think we can find a better understanding here in a few seconds. The case I referenced was actually about a state-run military-style university, where there was a lot of rigorous military training as part of the curriculum. The issue was never finding women to go through it, it was all about the fact that Virginia didn't think women were capable of completing the training, which caused them to completely forbid women from even trying to attend the school. The findings that *most* women couldn't take the training were irrelevant, since most *men* also couldn't. The school was meant to set apart the sheep and the wolves, and Virginia's policy was that it was impossible for women to be strong enough.
thats what rope does
Manual pythonpath hacking is no longer needed and leads to weird bugs. Put the code into a package inside a virtualenv.
I always thought it was droopingCamelCase.
Aah that makes sense. Thanks!
I am using the Visual Studio Shell + Python Tools for Visual Studio 1.x (latest release...). The whole thing works great. I'm using (on this project) CPython 2.7, sqlite, wxPython, and a few odds and ends. It's remarkable that this works so well with CPython. I have also had good luck with Iron Python on other projects, and see no reason it wouldn't work here. I do notice that sometimes PTVS doesn't report exception exits very well, so when the Python program quits for no good reason, I keep a command window open to run the program and get the error message. Occasionally this seems to be necessary. Other than that, big win. I moved over from PyScripter (also pretty good) because I'm a big VS user in other areas and it seemed nice to be able to stick with one tool. I use VS Pro, Premium, and Ultimate in other areas, so the VS shell seems pretty natural. If only I had an OSX version. :-) 
It isn't necessary to use Iron Python (which is far from dead, I assure you) with the VS Python Tools. I'm delivering a pretty big CPython 2.7.2 project right now, and it's working great. Intellisense, debugging, stack and object view, all of it. It's pretty impressive -- much more than I expected. Having said that, Iron Python can't be beat if you need some quick and dirty way to talk to some .Net &lt;stuff&gt; for some reason. For opening .NET assemblies and poking around, it's the best REPL available. (AFAIK, anyway...)
To say this needs documentation would be a colossal understatement, I see a giant code dump that rewrites ASTs, and have no idea what it does.
&gt; At school, I'm required to sign in to a frontpage that they have to show that I'm a student before they'll route my stuff. I did the same thing when DSL first came to my area 15 years ago. I had a little program written in delphi that logged in to the phone company's site, and then logged in to the ISP. It ran in the tray with a traffic light icon (green for logged in, red for error, yellow for in progress) 
The (using 2to3) part is no longer true by the way. It now supports Python 2.5 up to 2.7/3.3 from the same sources.
Seems like a good solution .... &gt;&gt;&gt; set(["".join(i) for i in [p for p in itertools.permutations("aaab")]]) set(['abaa', 'aaba', 'aaab', 'baaa'])
It's something that's so obvious once you have it pointed out.
&gt;Try it yourself using 'abcdefg' as the input for each of them. OK, now try `'a' * 100 + 'b'` as the input. I'll be waiting.
axed is definitely the wrong word
You might also be interested in libpd - you can actually embed PD in python. 
&gt; The standard library functions are an order of magnitude or more faster. On all inputs? Standard library functions are generally faster because they are C optimized; not because their time complexity is any better. (i.e., the constant factors are much lower.) &gt; You have to look at the whole system, not just make armchair generalizations on one step of the process. I was analyzing the time complexity of your algorithm versus the other. I'm still not wrong. Your examples may not have a large enough input size for the time complexity to overcome the constant factors.
&gt; I've seen indicate a strong disapproval of any action to fight sexism, and at least some disapproval of women in general. I suspect that this is misleading. You're assuming some agreed upon definition of sexism. What you think is sexism might be very different than what others think is sexism. &gt; That's definitely not the sign of a healthy, non-sexist Reddit. No, it's a sign that given a large enough sample, you're bound to find people that disagree with you, or worse, are jackasses. &gt; And of the other replies, it should be noted, many seem to go too far the other way....for example here, many people voiced support for "testrogen," which was sexism, only the other way. If the name of a gender specific hormone used as the name of software is sexist, then your definition of sexism is far too lose by my standards. Namely, it doesn't reinforce the belief that one sex is inherently "superior" to the other. Maybe it makes people like you uncomfortable, but that doesn't mean it's sexism. So you know, just because everyone doesn't have your strict definition of sexism doesn't make them bad, "unhealthy", or deserving of change.
Yeah, that sounds pretty fucked up. I'd agree that as long as government is making laws, they should be as egalitarian as possible. My not-so-widely-shared other opinion, though, would be that if they were a private organization, they *ought to be allowed* to discriminate against any group for any arbitrary reason. Whether it makes sense or not.
Oh, allowing people to discriminate is fine if it's a private entity, but the programming community really needs to buckle down and do what they can to accept women....
I guess it depends on what you're looking for. A python beginner doesn't need a fancy IDE with lots of features. I would stick with IDLE for now. Anything more is unnecessarily complex for a beginner who doesn't even know the language yet. I personally use gvim, which is great for coding because of its unique navigation and editing and its extendability. However, it has a rather high learning curve.
&gt;If you are about to ask a question, please consider [r/learnpython](http://www.reddit.com/r/learnpython) 
 A = 0 T = 0 C = 0 G = 0 for filename in filenames: data = open(filename, 'r').read() for character in data: if character == 'A': A += 1 elif character == 'T': T += 1 #more like that ---- That's about it. I may be misremembering the semantics of read(), so read the Python docs about reading files and find the method that will give you a string from a file. Also, if you are reading really huge files, this approach might not be good, and in that case you should look up how to read files iteratively.
Thanks. However, putting every project in a virtualenv and create `setup.py` seems an overkill to me. I looked at `imp` and I came up with this solution (add it in `shell.py`): import imp f, filename, desc = imp.find_module('config', [os.path.abspath(os.path.dirname(__file__) + '/' + '..')]) config = imp.load_module('config', f, filename, desc) 
There's another good solution, but I'll give you mine. files = ['filename1.txt', 'filename2.txt'] for f in files: counts = {} data = open(f) d = data.read(1) while d != '': if d in counts: counts[d] += 1 else: counts[d] = 1 data.read(1) print f, counts, '\n\n' Interesting question, thanks for asking it :)
The Pythonic (2.7) way of doing it: from collections import Counter nuc_count = Counter() for f in files: data = open(f).read() nuc_count.update(data) print nuc_count &gt; "There should be one-- and preferably only one --obvious way to do it."
Isn't enough to make their own language a headache? Do Haskellites have to ruin other languages too? ;-)
The problem of course is, what if x=0 really is the maximum or minimum?
Reading data from a file one byte at a time is putting a lot of additional strain on the IO system. You'd be better with a much, much bigger number and a second loop. 
I assume you are writing the output of that function to browser. Did you tell the browser that it's a html page by specifying the Content-type: text/html http header? EDIT: [http://wiki.python.org/moin/BaseHttpServer](http://wiki.python.org/moin/BaseHttpServer)
http://docs.cherrypy.org/stable/progguide/files/static.html
Tell us why, write a little review, compare it to other IDEs / editors! Otherwise ... spam. $59? You must be joking ...
great newsletter here: http://www.pythonweekly.com/
also known as lowerCamelCase.
True!
Sadly, we can't often put the `input` call in the condition like that, because we lack syntax for this: put = lambda k,v: globals().update({k:v}) or v n = random.randint(1,10) while put("guess", input("1-10?: ")) != str(n): # "guess" is now a name AND # we used it in a comparison print(guess)
This is awesome! All lossless formats/libraries should have a vocabulary that operates in a non-lossless or less-lossless manner. It is too bad that PIL is python specific. There should be a VM agnostic semantic layer above C so that all languages could enjoy these changes.
What if you create a child process?
You could use a batch file to launch the python script with the runas command. runas /? in cmd will give you its options. Actually, I'm not sure this will get around the UAC even if your run as administrator. I've never messed with it other than on XP.
Only paused, my friend, only paused. I love you, Genericname48.
Wrap your script launch with an elevate.exe call using the Elevate Powertoy. http://technet.microsoft.com/en-us/magazine/2008.06.elevation.aspx It'll prompt the user to allow UAC and assuming they're admin level already, it'll be as good as running it from an admin console. Also, this method looks interesting: http://blog.pythonaro.com/2011/09/python-wmi-services-and-uac.html
Hi! * See [/r/learnpython](http://www.reddit.com/r/learnpython). * The book [Invent with Python](http://inventwithpython.com/) really helped me. * See [Wikipedia](http://en.wikipedia.org/wiki/Application_programming_interface) for the API question ;-).
Thanks for the links! Hopefully it'll improve my understanding of Python as well as the OP!
Something that I kind of ignored for a long time, and have just found out is very useful is try/except. Basically, you try the code under it, and if there's an error, it'll do the code in the except part. It's like: try: print list[100] except: print "There is nothing in spot 100!" As an example. Whatever you want to use it to do in your programs is going to be more important. Also a tip, I always use the variable "loop" or "count" when using loops, for the most part. It makes it easier to keep track of what a variable is doing.
You mean, it's cheap, right?
In the meantime you can try wsgi_intercept. http://code.google.com/p/wsgi-intercept/
Exception handling can be easily abused if you aren't careful. Read: http://eli.thegreenplace.net/2008/08/21/robust-exception-handling/
`request` was considered when talking about additions to the standard lib for 3.3, but everybody seems to agree that it would be premature since lots of things are changing quite fast for this package right now (and you might not want to support the current version 10 years from now...). I doubt that this project of `httpcore` and such will provide anything for the standard lib very soon, but usable code, yes that's for sure.
Yeah, discarding it arbitrarily seems like a bad idea. Ideally it would at least consider it. Eg. compare it to other peaks it found and keep it if the magnitude is close enough. Or, if some degree of continuity can be assumed, look at the tangents near that x=0 to see if it looks like a peak.
One of the best books I've found for beginning programmers is Hello World: http://www.manning.com/sande/ It's written for kids, but I've found it's one of the few that introduces topics without a ton of jargon getting in the way. Plus, unlike books written for boring adults, it gets into writing games. As for the definition API, it's one way for two systems to talk to each other, without having to know anything about the other's inner workings. There are other ways for systems to talk to each other: APIs are just one of the common ways.
I googled part of my UAC program and found that someone's [already using it somewhere.](http://maphew.googlecode.com/hg-history/790d54de44fd2131b59db30da4ce5177cba066a4/gis/o4w_extras/pyuac.py) I posted it to some mailing list a few years back. So there you go. 
You're better off being more specific with your `except`: try: print list[100] except IndexError: print "There is nothing in spot 100!" except: print "I don't know what happened." raise
Meanwhile, next door: http://krebsonsecurity.com/2012/03/mastercard-visa-warn-of-processor-breach/ :-(
On Project Management, I recommend you to read about Agile, and in particular Scrum. On the Engineering practices, I definitely recommend you to use plenty of Unit Tests to help you refactor your code later on.
Your question is really unclear.
so, the only bonus it has over vim is the visualization of the entire file in reduced size?
really nice module!
My advice would be to fork some library you use and get comfortable with it and how it has been developed. Personally I write tests for all my functions before I write the functions and I try to avoid writing functions greater than 10 lines, excluding blanklines and docstrings
Well there is Tkinter, so the python devs have at least thought about graphical interaction. But Tkinter doesn't allow a drawing canvas afaik.
Learn to throw away code. It can be tempting to try to save bad code, but sometimes, you have to go back to zero and start again. The second time, it'll go faster. You can diagram what you know worked, think about what didn't, and try something different.
try/except/finally block works fine aswell.
Thanks! Glad some folks are using it. 
Could probably just set your interpreter to run as administrator by default. Don't forget that from the OS's point of view, the interpreter is where your actual instructions will come from, not the script. That's probably what needs privileges. Logon with administrative account --&gt; find python.exe --&gt; right click - properties --&gt; compatibility tab --&gt; privilege level checkbox "Run this program as an administrator" Simple. Effective.
"the standard library is [where code goes to die](http://www.gossamer-threads.com/lists/python/dev/875479?do=post_view_threaded)" 
The cool thing about this isn't just what he accomplished, but that he was able to accomplish this using regular Python. Truly a testament to Python's flexibility and power.
Upvote for you sir.
wtf is this shit... it does zigzags 
God no!
Hm… You're right. Never seen it from that point of view.
Just because it's possible does not make it a good idea.
I took it as more of a "look at what is possible" than a "you should use these instead", although a couple of the "pros" were intriguing to me.
Generally usable first and then migrate it to graphical. For something like this, is it better as a web application or a local .exe? NOTE: This project is just a personal project. 
It's possible because many things in the language are badly abstracted away. That's not a feature, that's a bug. A lot of what a Python frame object exposes is terrible for alternative Python implementations and you really should not consider something that exists. For more horrible ideas, google for my "5 years of bad ideas" talk.
It really depends on what you're going for. A web app has much more potential to be useful for more than just one person on one computer, it can branch into something multi-user and multi-platform, something you can use at your desk and continue using without too much a break in work flow on the toilet with your smart phone. Plus, it lets someone else do all the work of putting together all the handlers to display graphics, etc. Disclaimer: I build web apps for a living.
Looks really handy, Unfortunately I have trouble getting it to import the Win32API C:\Py&gt;asadmin.py You're not an admin. 6884 params: ['C:\\Py\\asadmin.py'] Traceback (most recent call last): File "C:\Py\asadmin.py", line 133, in &lt;module&gt; sys.exit(test()) File "C:\Py\asadmin.py", line 124, in test rc = runAsAdmin() File "C:\Py\asadmin.py", line 76, in runAsAdmin import win32api, win32con, win32event, win32process ImportError: No module named win32api
but it does make it a good april fool's day joke. or does it not?
Yes, I am the OP. I can certainly understand the confusion about whether TWSS is sexist. It's not nearly as obvious (or as grave) as, say, laws prohibiting women from going to university. (from dictionary.com): Definition of SEXISM 1: prejudice or discrimination based on sex; especially : discrimination against women 2: behavior, conditions, or attitudes that foster stereotypes of social roles based on sex The problem with a bot that makes the TWSS joke is that a) it reminds women of their gender (this is not productive in an environment in which women are greatly outnumbered - see stereotype threat) in a way that could degrade their performance b) it reinforces the stereotype that women are primarily sexual objects
Hm, it no worky. https://gist.github.com/7aed4c886398e10fcec2
I was looking for something like this when i wrote the driver for my singing floppy drive. but i didn't know of anything at the time, so this sufficed: https://github.com/amstan/floppy/blob/master/interface/notes.py
Would you mind commenting on the issue I created? https://github.com/prezjordan/Melopy/issues/38
I wish I was clever enough to just _get_ these posts people make.
Just remember: if it's on code.activestate.com, you shouldn't use it, ever. It's a directory of bad ideas.
Quite useful maybe, it could be there's some knowledge that the author is assuming everyone should have but not mentioning in documentation. :)
Just a screenshot of the code from Sublime Text's minimap http://imgur.com/Rc060
Sorry, it should have stated that it requires PyWin32, a separate add-on module for Python. [PyWin32 project page](http://sourceforge.net/projects/pywin32/) Install a version that matches your Python version and you should be good to go.
I suppose that's true, but i is the only reference to each object, so they'll be freed after each iteration of the loop anyways. In my experience, you almost never need to iterate a given number of times without needing access to the loop counter, but this could be a useful trick when benchmarking.
the way if changed the default python, I think was using hard links or some other thing that broke the "defaults write" way to change 32/64 bit python. And there are tons of packages that don't even build on macports (vtk was one of them that I remember).
I took it right from git and it seemed to install fine there. It'd be handy to have a tool to play the rendered file.
That's one way to make your loops 10 times as fast :&gt;
Sorry, I'm sorta new to git and python. Windows 7x64 Python 2.7 Opened up the git Bash and just did what he wrote here https://github.com/prezjordan/Melopy $ git clone git://github.com/prezjordan/Melopy $ cd Melopy $ python setup.py install
Sounds really interesting, but being not so music-minded, I can't think of a good personal use for it unfortunately.
Ok will try, thanks. 
Thanks
"Independent" feels too strong to me. For example, imagine a woman joking to a man, "Oh you just slept your way to the top." I think it's much more likely that the man would be able to laugh this off than in the reverse situation. That's not to say it would be taken that way 100% of the time. In some situations some men would be really hurt inside by that even if it was "just a joke." But I think there are more situations where they would hurt the women it was made to because it connects to negative female stereotypes in a way that it doesn't connect to negative male stereotypes. Of course, in both situations the joke is borderline offensive (that's what makes it a joke), so you can argue that it's sexist in both situations. But I think that the gender of the participants can easily reinforce whether something is just mildly ribbing or really offensive.
One of my pet discomforts with python. &gt;&gt;&gt; import this ... Readability counts. ... There should be one-- and preferably only one --obvious way to do it. ... &gt;&gt;&gt; 
Ah ok cool, thanks.
Feeling proud that I immediately thought about itertools.repeat. Anyway, I don't remember when I last used a C-ish-for-counter loop and not a for-in-the-actual-iterable-I-work-with.
How about renaming 'classify' to 'bless'? :)
The answer to that is "classes and functions that you import via a module", usually. In some cases (such as thetvdb's scraping API), it can also be HTTP POST and GET requests.
Internally it produces the same amount of integers. For the Python user, it produces the same amount of throw away variables, all references to the same object instead of different ones. Not sure why this is better.
You want no throw away variable for repetition? If you want to go against Python idioms, you could always create this (using various hacks): with repeat(1000000): print 
Changing the version using `defaults write com.apple.versioner.python...` is [a feature of Apple's system-installed Python][1]. Building Python from the official sources won't make that work whether or not you use MacPorts. [1]: https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/python.1.html
 fortenbras (~/projects/Melopy) $ python2 setup.py install Traceback (most recent call last): File "setup.py", line 7, in &lt;module&gt; from distutils.core import setup, find_packages ImportError: cannot import name find_packages ... fortenbras (~/projects/Melopy) $ python setup.py install File "setup.py", line 10 'name': u'Melopy', ^ SyntaxError: invalid syntax I'm not having much luck here. Any suggestions? I'm on Arch Linux, maybe I don't have something like 'disutils' installed. I'll google up later, but if you have any suggestions as to what that means I'd appreciate it. Thanks! This looks like a lot of fun.
As a note, I just installed python-distutils-extra, still no dice. Same error as before for python2. Edited to add: Looking over setup.py, I noticed that it first looks for setuptools. I got that installed (Arch package python2-distribute), and now it works well.
 The venerable master Qc Na was walking with his student, Anton. Hoping to prompt the master into a discussion, Anton said "Master, I have heard that objects are a very good thing - is this true?" Qc Na looked pityingly at his student and replied, "Foolish pupil - objects are merely a poor man's closures." Chastised, Anton took his leave from his master and returned to his cell, intent on studying closures. He carefully read the entire "Lambda: The Ultimate..." series of papers and its cousins, and implemented a small Scheme interpreter with a closure-based object system. He learned much, and looked forward to informing his master of his progress. On his next walk with Qc Na, Anton attempted to impress his master by saying "Master, I have diligently studied the matter, and now understand that objects are truly a poor man's closures." Qc Na responded by hitting Anton with his stick, saying "When will you learn? Closures are a poor man's object." At that moment, Anton became enlightened. [-Anton van Straaten](http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html)
I like the part where he uses a high level interpreted language and gets upset about an extra integer allocation. How cute.
Here are some hints to make refactoring easier. Use classes and strong types whenever possible. Don't pass around dictionaries as ad-hoc data types to your functions. I'm not talking about kwargs here. I'm talking about data blobs you pass around. They can turn into unknowable god objects. If you do, every time you go back to a function to work on it, you'll have to remind yourself all over again what the heck is this thing you're passing into this function. Use strong data types whenever possible. This helps self-document your code. This is important for refactoring because, during a refactor, you choose the functions, modules, and classes you wish to dismantle. Create A/B style unit tests for those pieces. Pass in complex data to them, get their output, and put it somewhere safe. Refactor that shit. Run the same tests over again and save those results. Compare the results with your previous run. If they are not IDENTICAL, you fucked some shit up. Once you get better at this, you'll fuck this step up less. Refactoring is kind of hard in python because it is not strongly typed. Errors can only be checked by extensive and exhaustive testing of code paths. However, refactoring is just as essential in python as any other language, so you cannot delay doing it. Embrace it. Love it. Just make sure to get damn good at it.
What do you mean portable? Exe's are windows based. If you mean portable as in, you can just copy the prog somewhere and run it without the python intepreter, then use [py2exe](http://www.py2exe.org/)
I've been using bottlepy + Google App Engine for awhile now, and have to say it's very easy to get up and running. You can very easily get it working with mod_wsgi and apache as well, see my server configs here if interested: [github/hortonew](https://github.com/hortonew/ServerBackups/tree/master/bottlepy)
* [cx-freeze](http://cx-freeze.sourceforge.net/) * [py2exe](http://www.py2exe.org/) Next time, please try to properly express yourself. If you do not take any time to ask a question, why would anyone take the time to answer it? Take care.
Ah, you followed instructions. Interesting, I wonder why it doesn't work on OS X.
And [PyInstaller](http://www.pyinstaller.org/), for completeness.
if i create a game, and this game contains files, etc... all these necessary files will be packaged also i guess, but then how does it works? it installs or is portable ? lets say also that it needs access to some os libraries, how does it handle it ? 
Well, there'll be no disposal of the None object after releasing, so it would likely involve much less allocation / deallocation events. None will have the incref/decref still, but no malloc/free as is the case for every integer (bar the first 100 which are cached)
also, perhaps more importantly, I'm trying to avoid premature optimization. I'm going to tackle building the fun bits, and the game, and some interfaces, and when it starts slowing down, I'll refactor. Or, start over, having learned a lot.
I hardly think that's fair. Lots of core Python devs have interesting and/or useful recipes on there. Nick Coghlan has a nice logging recipe for splitting INFO and lower to STDOUT w/ WARN and higher going to STDERR, for instance. I don't have time to dig up the link, sadly, but that's the sort of thing that I wish was default behavior, and I'm happy he put it up there.
Would that be this one [PDF slides](http://www.pocoo.org/~blackbird/badideas.pdf)/[video](https://www.youtube.com/watch?v=bpjHa0G9X5w)?
Actually, it seems far less common in Python than in Ruby/JavaScript/"Lisp" (for whatever definition of Lisp happens to float your boat right now). It's a handy concept, but much like recursion, I've never found it so amazing that I just have to use it to solve every problem, even if it's technically feasible.
Process some JSON data.
The basic idea is that everything that you can't assume is on the recipient's computer gets bundled, so default libraries from the operating system aren't included. All the tools can bring the files together in one folder, and make an executable to start the program. From there, they may be able to turn that folder into an installer, or a mac application bundle, or a portable (single file) executable.
I call it _ (underscore). That's the python convention for a throwaway variable, no?
 f = lambda: defaultdict(f) d = f()
True, I can't ever see a case where this would be *worth* the readability cost of doing so. But it does still remain a difference, and one that may have some relevance (eg. it means it might be worth optimising out with static analysis that converts a "`for x in range(N)`" with x not used into a loop without creation of unused objects. All the benefit without changing the idiomatic code)
I will freely admit that they slip up and accidentally post something you might want to use from time to time. But it's so rare is to hardly be worth noting.
I got my first email about a week ago about a bug in a small open source project I made. It was the most exciting day of my life.
Yes--we have a bug too! * high five * (I mean, one that someone reported because they were using it)
Didn't even think about modifying ```load()```, thanks! What does the 999 parameter do?
Don't ```defaultdicts``` take default types, not values? How would I make that create something like this: defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
To be fair, he probably knows, at least intuitively, that an "integer allocation" is this abstract `PyInt` or `PyLong` thing which is an expensive operation. I think many python programmers would be horrified to know how much code is behind the curtain. But this is [the case](http://www.ruby-lang.org) pretty much [everywhere](http://www.perl.org).
I am not sure if it's a phonebook (post) or checkbook (code), but first I would look at the options you have available (tkinter, qt, wx, web, etc) and turn this into a class that will work independent of the UI.
Bah! You are right! I made a phone book script in Perl and accidentally said that. This program is a checkbook app :)
... which will work fine until you suddenly need internationalization, where `_` is the conventional shorthand for `gettext`. I usually stick with `i` (or `j` or `k` depending on what's left -- any deeper nesting than that and you have bigger problems than naming things) because that's the least surprising variable name -- except for the fact it isn't actually referenced at all throughout the block.
I found myself in this workflow fairly commonly: * Signup for random website, put in dummy@mailinator.com account * Go to mailinator.com, keep refreshing until email arrives Sometimes emails can take a while to be sent or arrive, which makes checking for it manually a pain. I decided to automate the refreshing into a script because I'm lazy. Now the workflow is * Signup on site, put in email * Spawn off mailinator command with email, add libnotify * go do something else until notification comes in The code is a bit rough, but not too bad, IMO. Feedback is welcome!
I wanted to share my joy with others... is there a pre-existing subreddit for Trac hacks that I should have known about? Also, I have to say, I don't know many people who don't find a bit of joy in the moment when they realize that someone else is benefitting from the fruits of their labor.
Nice, clean, well-documented code for a sensible project with a great looking homepage :)!
True, but releasing software with the intent of becoming famous isn't often the case. Most people do it to fix a problem or further some cause. As for reddits..../r/images? /r/funny?
Well, `defaultdict` takes a "default factory" which is just *some callable thing* that's going to get invoked to produce an object instead of raising a `KeyError`. In that context, passing `str` or `list` or `lambda: 999` will all work, because all of them can be called to produce an object. It looks like you want some object which can be indexed three times with nonexistent values, finally terminating with a list? &gt;&gt;&gt; d = defaultdict(lambda: defaultdict(lambda: defaultdict(list))) &gt;&gt;&gt; d['nonexistent']['bogus'][time.time()] [] Is that correct? Maybe you want something different than what I have in mind. The idea of overloading `object_pairs_hook` in `json.load`was that all dictionaries will automatically be `defaultdict`s (here, check out what the decoder does: http://hg.python.org/cpython/file/14abfa27ff19/Lib/json/decoder.py#l219 ...it will either make a dict or call your custom thing).
I don't think there's an easy way to do what I want, so I ended up adding all the necessary checks to a normal nested dictionary. Thanks for your help.
[Situation: there are 14 competing standards.](http://xkcd.com/927/)
It's probably not the best data structure, but it lets me do stuff like: d[name]['parameter'][id].append(new_value) ... bool(new_id in d[name]['parameter']) Basically I don't need to see if any of the keys are present, nor the list, before I append or check soemthing. My new code is less elegant (IMHO) because it does all those checks.
My spyware filter flagged this site for what it's worth.
I was going to say something snarky about this. But honestly, I would love to use this instead of ant. so +1
This here will create that elusive recursive `defaultdict` that always returns a `defaultdict`. However, when I descend around 70,000 levels deep (`turtles[1][2][3][4][5]...[70000]`), python just explodes, so I guess it blows the stack in a way I'm slightly afraid of. def factory(mapping=None): return defaultdict(factory, mapping or {}) turtles_all_the_way_down = json.load(f, object_pairs_hook=factory) 
That doesn't make the last list though?
cool! I had no idea there was a /r/freesoftware. (Kind of new around here.) Think I'll go exploit it to get famous lol
Looks like that could work (except the terminating condition is based on nesting depth). Thanks a lot!
is it taking a breath after two 'tiobe's language of the year' awards and three consecutive linux magazine 'best programming language' ?
I think it is the lack of {} to define those blocks of code! On a more serious side it probably has a lot to do with iOS. 
Yep. There's a limit to what you can do with a language that unfortunately doesn't run in your browser or on your phone.
Perhaps the more interesting question is: What caused the steep increase in Python's popularity in the second half of 2010? There is a strong (negative) correlation between Python and C/C++/Obj-C through to the middle of 2011. The decline noted could just be a correction. It *may* have something to do with iOS, but Obj-C has been on the up since mid-2009...
It has a bazillion or so alternate domain names - keep refreshing until you get one that works.
When you're looking for R or Matlab style data structures and functions in Python, you'll most likely end up with numpy/scipy. Then you can do something like this: &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; a = np.array([True, False, False, True, True]) &gt;&gt;&gt; a.nonzero() (array([0,1,3]),) &gt;&gt;&gt; np.nonzero(a) (array([0,1,3]),) &gt;&gt;&gt; np.nonzero(a==True) (array([0,1,3]),) For simple examples like this you might wonder why bother with another library, but once you start getting into vector/matrix operations or more sophisticated scientific algorithms, it really shines. 
With many distinct characters, every algorithm is pathological, because there are simply too many things to output. Apparently I recurse n*n! times instead of just n!, though, because of the depth of the recursive tree. With more work, the algorithm can probably be converted to a more direct iteration. The algorithm is not hard to understand, if you quit trying to trace it and just think recursively. The set of distinct permutations is the (non-overlapping) union of the sets of distinct permutations ending with each distinct character. So we recursively generate those sets and output each one.
... its so cool ... I'm starting to convert all the sharepoint crazy-docs in my office into music!
Same here. ipython 0.12. "import ipy_autoreload" fails too (ImportError: No module named ipy_autoreload)
 ipython -v [TerminalIPythonApp] Unrecognized flag: '-v' Also In [1]: %autoreload? Object `%autoreload` not found. In [2]: %autoreload ERROR: Magic function `autoreload` not found. 
If you use the 'activate' script, pip will automatically use the relevant virtualenv (as will other python command line stuff). source virtualenvdir/bin/activate 
Ok that crashes ipython in my case: In [2]: %load_ext autoreload In [3]: import autoreloadtest In [5]: autoreloadtest.test Out[5]: [1, 2, 3] In [7]: autoreloadtest.test Out[7]: [1, 2, 3] In [9]: %autoreload 2 In [10]: autoreloadtest.test [autoreload of doctest failed: Traceback (most recent call last): File "/usr/lib/python2.7/site-packages/IPython/extensions/autoreload.py", line 220, in check superreload(m, reload, self.old_objects) ValueError: f() requires a code object with 1 free vars, not 0] [autoreload of encodings failed: Traceback (most recent call last): File "/usr/lib/python2.7/site-packages/IPython/extensions/autoreload.py", line 220, in check superreload(m, reload, self.old_objects) ImportError: cannot import name aliases] [autoreload of ctypes failed: Traceback (most recent call last): File "/usr/lib/python2.7/site-packages/IPython/extensions/autoreload.py", line 220, in check superreload(m, reload, self.old_objects) RuntimeError: maximum recursion depth exceeded while calling a Python object] [autoreload of unittest.loader failed: Traceback (most recent call last): File "/usr/lib/python2.7/site-packages/IPython/extensions/autoreload.py", line 220, in check superreload(m, reload, self.old_objects) ImportError: cannot import name case] Out[10]: [1, 2, 4] (yay!) In [11]: autoreloadtest.test Traceback (most recent call last): File "/usr/bin/ipython2", line 7, in &lt;module&gt; launch_new_instance() File "/usr/lib/python2.7/site-packages/IPython/frontend/terminal/ipapp.py", line 403, in launch_new_instance app.start() File "/usr/lib/python2.7/site-packages/IPython/frontend/terminal/ipapp.py", line 377, in start self.shell.mainloop() File "/usr/lib/python2.7/site-packages/IPython/frontend/terminal/interactiveshell.py", line 290, in mainloop self.interact(display_banner=display_banner) File "/usr/lib/python2.7/site-packages/IPython/frontend/terminal/interactiveshell.py", line 409, in interact self.run_cell(source_raw, store_history=True) File "/usr/lib/python2.7/site-packages/IPython/core/interactiveshell.py", line 2410, in run_cell cell_name = self.compile.cache(cell, self.execution_count) File "/usr/lib/python2.7/site-packages/IPython/core/compilerop.py", line 121, in cache linecache._ipython_cache[name] = entry AttributeError: 'module' object has no attribute '_ipython_cache' If you suspect this is an IPython bug, please report it at: https://github.com/ipython/ipython/issues or send an email to the mailing list at &lt;nospam!&gt; You can print a more detailed traceback right now with "%tb", or use "%debug" to interactively debug it. Extra-detailed tracebacks for bug-reporting purposes can be enabled via: %config Application.verbose_crash=True and back to the shell. So .. I think for the moment I'll stick with --no-confirm-exit. But as I used tornado a lot I see how this can be extremly usefull.
Oh, after running %load_ext autoreload it works. Maybe something's wrong in my profile, then.
works like a charm, great! Do you know if Django shell will be affected too?
[Done, hth](https://github.com/ipython/ipython/issues/1549)
Docs, please! So far, the only example I see anywhere is `"Hello, world" -&gt; print`, which doesn't give me much feel for the capabilities of your language. How do you define a function? Can you pass multiple parameters to a function? How does this integrate with regular Python code? How does the 'implicit parallelism' work? I think new languages have to meet a higher bar than new libraries or frameworks. Language design is a tricky thing, as much an art as a science. Combining an 'intuitive feel'* with flexibility and agility is certainly a good idea, but you need to substantiate the claim: what can Pythonect do beautifully that is ugly or awkward in Python/bash/etc.? *Maybe it's just me, but I wouldn't call shell scripting 'intuitive'. Concise, yes, and very powerful for certain tasks, but shell scripts tend to be ugly messes of punctuation, abbreviations and substitutions.
buildout isn't exactly in the same realm as make* IMO. the way it handles dependent parts is odd. paver adds functionality to your setup.py according to the docs, so it's too specialized for python, to be a general purpose tool. the link to vellum on that page returns a 404, I can't even tell if it's still maintained. scons is probably the best bet in terms of maturiy. 
What about bpython? :)
It's a crying shame.
This might be good for people who use ipython as an upgrade from matlab, but it's bad news for programmers because `reload()` pretty much never does anything useful. In particular, once you call `reload` you can no longer expect the behaviour of your code to match what it'll do the next time you run it.
Recipies -&gt; Recipes
Are the indices important, or are you thinking like a &lt;insert other language here&gt; programmer? The itertools module contains a variety of ways to manipulate lists, all in fast C. For example, if you wanted the indicies to then filter another list by, what you're really looking for is itertools.compress() I'm not sure why you're adverse to using list comprehensions, particularly when combined with generators they are very fast and very lightweight. 
For the lazy, here's one of the more interesting: &gt;&gt;&gt; range(0,3) -&gt; import math -&gt; math.sqrt [0.0, 1.0, 1.4142135623730951] Interesting, but I'm not convinced. Piping data through an import statement doesn't seem very intuitive. It looks like functional programming, but it's not clear if it can neatly do things like reduce/fold and currying.
 [i for i,d in enumerate(list_one) if d in list_two] 
by no means am i an expert when it comes to handling high res raw video, but i would surmise that your hardware would be the bottleneck, not Python/OpenCV may I ask what specs you're running this code on?
this is elegant, but I was looking for something that would return: (array([0,1,2,3,4]),) because all of the elements with these indices in list1 are present in list2
I think lambdas and lexical clojures (static scoping) are the most overrated concepts in nowadays (probably because of Ruby and JavaScript?). When you are coding in Python in most case what you acutally need is not a lambda (which is general) but special concepts like generators, functors, list comprehensions and generator expressions, decorators or RAII. For example, RAII could be done with blocks in Ruby: File.open("filename.txt") do |fs| puts fs.read end but there is `with`, a higher way to do it in Python which I prefer: with open('filename.txt') as fs: print fs.read(), In JavaScript/Ruby you pass a block/function to `.forEach`/`#each` method to iterate collections (though these languages have `for` statement!), but you simply use `for` statement in Python. The specialized language construct, `for`, gives us more control. You can `break` or `continue` control flows and `raise` errors in `for`.
OK, I see where I misunderstood. &gt;&gt;&gt; np.nonzero(np.setmember1d(a,b)) (array([0, 1, 2, 3, 4, 5]),) &gt;&gt;&gt; np.nonzero(np.setmember1d(b,a)) (array([0,1,2,3,4]),) Similar discussion [here](http://stackoverflow.com/q/2333593/48837). Edit: I'm still not sure that's what you want, but I'm sure there's a way to do it in numpy 
To avoid conflicts between package managers, multiple installations of the same package (I've seen people using pip and virtualenv to install the same ipython version many times). Add perl's cpan, ruby's gems, common lisp packages, etc. and you'll have a complete mess.
I see that other have suggested this, but my latest version of numpy that came with enthought doesn't have setmember1d... In [3]: numpy.setmember1d --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) /Users/igor/&lt;ipython-input-3-066760b45bcc&gt; in &lt;module&gt;() ----&gt; 1 numpy.setmember1d AttributeError: 'module' object has no attribute 'setmember1d' 
This looks like a half baked SCons knockoff. BTW, SCons is written in python, and written in way that works with 2.4 and up.
&gt;I've seen people using pip and virtualenv to install the same ipython version many times That's the whole point of virtualenv, being able to install the package multiple times without conflicts. If you create your virtualenvs with --no-site-packages, you would need to install ipython each time.
That was a trivial example. Let's take a real world case: the custom comparison function for sorting (as in sorted() or list.sort()). Do you want a first class function in there or the crippled lambda? How about an object instantiated from a subclass of a default Cmp class with the sorting method overridden?
This seemed to work (thanks for the link to the docs): In [12]: %load_ext autoreload In [13]: %autoreload 2 In [14]: 
tl;dr - a lisp programmer grilling python because it's not lisp.
using a lambda like in a LISP would make the code unreadable. (zen of python: readability counts) that's what functions are for. for your example, the named function is clearly the best solution--if only for the sake of clarity and maintainability. if you put the function def at a lower indent count than the function using it in the sort, then you also save having to re-instantiate the code objects on each loop.
yeah, let's downvote him, stick our fingers in the ears and start screaming LA-LA-LA
i was talking about the article--and i downvoted the post and all your comments because the point is moot. i, in fact, read the article and SICP; i understand the article, but the point holds no validity in Python because there are different values inherent to Python.
if only you'd understand what downvotes are for...
Good point, this may well cause problems, although I haven't tested it. If you want to bring it up on the mailing list, maybe someone will spot a good way to deal with the issue.
Sometimes it's required to have multiple versions of installed packages. For example, Pyramid just upgraded to 1.3, a major upgrade, for Python 3 compatibility. We have apps that are still using 1.2, and do not yet work with Pyramid 1.3. With virtualenv we can have Pyramid 1.2 (and its transitive dependency sweep) peacefully coexisting with Pyramid 1.3 (and its transitive dependency sweep). This type of situation is not all that rare. Virtualenv solves the dependency conflict problem at the cost of disk space. Using the packages from your distribution is nice if they are up-to-date enough. However such packages are often months or even years behind the latest releases of the underlying packages. Sometimes that can be a problem. 
This is a debatable issue. If you're working on a bunch of different projects with different sets of requirements, installing all dependencies for each project into it's virtualenv makes sense. It isolates projects from each other and means that you don't get version conflicts between projects and if you need to make a change to one of your dependencies, you don't have to test it against _all_ of the projects that might use it. If you're concerned about resource usage (bandwidth especially) you can use a local pypi proxy to only download 1 copy and use it multiple times.
Well because he's wrong. I mean, why is he even trying to use an if-then-else in a lambda anyway? It doesn't make the slightest bit of sense. The equivalent might be more like lambda x: {'real': a, 'imag': b}.get(x) Lisp doesn't have anything other than lambdas, so they have to stuff the ability to raise an error in there. So our whole function becomes: def complex_number(a, b): return lambda x: {'real': a, 'imag': b}.get(x) Anyway, as others have said, in Python, whitespace and readability and such count. It doesn't really make sense to be able to do this inside a lambda: if foo: bar_expression It looks like it's not doing anything, since bar\_expression is...just an expression, and it's not being returned or anything. But if this were in a lambda expression, that would be the return value. In Scheme (I don't know Lisp, sorry) this actually makes sense: everything is _always_ an expression, and whatever expression is encountered last is the one whose value returned. Doesn't make sense in Python; it doesn't work that way. As for custom comparators, I shudder to think of a time when a Python lambda _isn't_ sufficient, but you don't want to bother naming the function. Yes, Python is not, at its heart, a functional programming language. But God forbid we should have to _name_ a few variables here and there. Terrible. Not everything in one language translates directly to something in another language. That's just the way it is.
Damn, you're on a roll -- that seems just about perfect. I'll have to change back my code, but I think it'll work.
Nope. It took me a while to come around on it. I shared the packages across my entire install until I burned myself more than once, then I started using --no-site-packages. There's a reason the option exists. You might not need it and that's fine, but a blanket statement saying to never use pip and never to install the same package twice makes it sound like that's *always* a mistake. I heartily recommend [this link](http://www.clemesha.org/blog/modern-python-hacker-tools-virtualenv-fabric-pip/) to better explain the situation than I ever could. It also assumes your chosen distro does a great job of keeping up with updates to Python packages. And assumes the package you're interested in even has a distro install.
The -E flag was removed from the latest version of pip. virtualenv is not magic, just use the pip that is installed in the virtualenv. The activation scripts just distract you from the simplicity of the system. $ virtualenv env New python executable in env/bin/python Installing setuptools............done. Installing pip...............done. $ env/bin/pip install package
Don't kid yourself. It doesn't matter if somebody spells out for you what namespace pollution is, you'll still downvote whatever you don't agree with. I guess it's the price to pay for a low entry barrier to this programming language: everybody can get in and join the comfortable circlejerk.
I took a trip over to [/r/lisp](/r/lisp) and it seems like everyone there is well-adjusted and likes Python perfectly fine. Turns out the author of the post understands Python much more than he lets on in his post, and turns out, quite unsurprisingly, that people over there don't seem to hate on Python nearly as much as you do, including the author of the post. Plus, I fail to see how: def return_a_function(foo): def bar(bat): return foo return bar pollutes any namespace at all. Oh no, we've introduced an extra variable in the scope of `return_a_function`! What will we do now?
[from collections import Counter](http://docs.python.org/library/collections.html) was my first thought but nothing more specific than that.
Yes, you settle, when you have 15 or 20 clients with production software written at different times over several years and no $$$ to upgrade, test, and redeploy their applications. 
fair enough
You'll wanna 1) tokenize text, 2) stem words 3) count word-stem occurances with defaultdict. Once you have the word counts, you'll probably wanna use a handy library to generate the image (you also should find a lib for steps #1 and #2)
I don't regret this. But I both rue and lament it. 
The whole thread, starting with "What's so cool about Scheme?" is a good read.
Once you start using recursion, you can't stop as long as you pop.
Front page desperately needs other examples besides hello world.
Bravo, you just won the debate! I think the patronizing bit did the trick.
I've only ever used [inflect](http://pypi.python.org/pypi/inflect) but I'm not sure that really counts.
This is also what I got. When I use %load_ext autoreload, my reload works fine...
Here is the write up if anyone is interested: http://blog.chewxy.com/2012/04/04/a-better-passenger-boarding-system/
Nested dictionaries seem pretty useful to me, I'm surprised the PSL doesn't have something that makes working with them easier.
It doesn't look like ass if you customise it to look good. Hopefully this tool will make that easier to do.
i think so i downloaded it from the MIT open course for CS101 awhile ago. However, it will not let me go back to my code after I run it. I need something that will be more like Microsoft Visual C++ for python
There is a difference between an IDE (like MS Visual Studio), and a compiler, and python isn't a compiled language. I *think* what you're trying to do is this: * Get a text editor, [like notepad++](http://notepad-plus-plus.org/) * Write your code in the editor and save to file * Open a command prompt * change directory to the place you saved the file * Type "python &lt;name of saved file&gt;" This will run the code you've written to the file, and is the standard way to write and run a python program. 
You save the code in a text editor (and please use a real one, not notepad), leave the text editor window open, go back to the command-line window, hit the up arrow to retrieve `python my_code.py` from the command history, hit enter, and it runs again. (Some text editors can make this even simpler for you, if you put in the effort to learn how. I haven't bothered, personally, because that's already incredibly simple.)
Fuck year. This build tool is excellent.
looks cool. Need to check it further.
 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'tended' is not defined
i don't know why but i lol'd at this
Surely a capable demonstration of how to ply the language to project specific needs. Impressive python skills!
Get back to /prog/.
I got a newb question. Why should I use iPython?
Why don't you keep a reference to the parameter class and delegate the method calls? If you rely on function identity, terrible breakage can happen. Beyond that, whenever you have to ask "How do I change the type of this object", your classes are wrong, flat out and the subclasses you are using are supposed to be instances of some other type, which will usually look like the strategy pattern or the state pattern. 
One of the examples I remember darkly and straight, handwavy from my nether regions is something along these lines: You have bank accounts, which can be credit-backed or not credit-backed. If you go below $0 on a credit-backed account, the balance becomes negative and a standard credit plan is applied to this account. On an account without credit backing, a transaction that would send the account into negative balance simply doesn't succeed. A naive first implementation would have something along the lines of an interface Account with methods GetBalance and Withdraw with 2 implementing classes CreditBackedAccount and UnbackedAccount with pretty obvious implementations. However, once users are able to enable and disable credit backing of their account, the account instances would need to change the class in order to have the different strategies. The better solution is a strategy pattern. You have a OverdrawingStrategy, which can be a CreditBackingStrategy or a UnconditionalRefuseStrategy. The Account now has an Overdrawing-Strategy which can be replaced as necessary and no object must change classes. In other words, a responsiblity of the account-class has been replaced by a second class hierachy. 
What I am most concerned with is that the example provided in the link has an array containing "cat" "window" and "defenestrate"
Right -- strategy pattern is awesome. This is addressing a case where the object you're given doesn't have a convenient hook for adding a strategy (or is missing a method that would be really convenient for you -- imagine adding an "md5hexdigest()" method to strings by "casting" them to an md5ablestr. Think after-the-fact mixins. I have no doubt that such a pattern could be horribly abused, is probably a bad idea and a sign of poor architecture, and may not even work. But I was surprised at how (relatively) simple it is to implement!
I don't know if it's a good idea, but I generally use `__getattr__` to accomplish this task. Suppose I need to wrap a `base` object in a `Child` class. I add a `__getattr__` method to the `Child` class that returns local methods/variables if they are defined, otherwise delegating to the `base`. This is especially useful when `base` is an instance of a dynamically generated class. I use this pattern, combined with @property, in my `pymongo` wrapping library to add additional functionality to certain collections. For example, adding a `Menu` to the `menus` collection automatically stores all the `MenuItem` objects contained within that `Menu` to the `items` collection and links them accordingly.
Indeed, if you want to do terrible things, python lets you. MI, metaclasses constructing other classes and such. Great fun. However, in the case you describe, I guess you are using an external library, and in that case, it should be wrapped anyway, so you have a controlled class to add the strategy to :)
I still remember import rice
More importantly, Tkinter is lacking many useful widgets that you would want to use in a program. I tried to use it for my first python GUi project last semester. Ended up switching to pyside in the last week and was able to redo the semester's work in 3 days using Qt Designer and pyside.
Assume that you have the entire text you want to parse in the variable `fulltext`, and that the lines are of format: Speaker Name: I say words in this way. The code should be something like words = {} for line in fulltext.split('\n'): parts = line.split(':', 1) speaker = parts[0] text = parts[1] if speaker not in words: words[speaker] = {} for word in text.split(): if word not in words[speaker]: words[speaker][word] = 1 else: words[speaker][word] += 1 print words That should give you a list of speakers, the words they said, and in what frequency. Adding together the dictionaries shouldn't be too difficult after that. Note that I've not done anything with language analysis, so if you're looking for something more meaningful than "split on newline, then split on spaces", go with the other comments :)
That might not be what he... intended.
HTTP and XML without SOAP? Heresy! Fortunately it looks like they've encoded the HTTP response status code in an XML tag, otherwise the WS-* gods would be very, very angry. Other than that, it's a nice quick example of how to find the value of a tag using lxml. Only question is why [lxml][2] rather than [ElementTree which comes as part of the standard library][1]? [1]: http://docs.python.org/library/xml.etree.elementtree.html [2]: http://lxml.de/
I've done the same thing, works great. Do you know that you don't even need your child \_\_getattr\_\_ to return local methods/variables? Just define them in the child class and python will dispatch them directly without even going through \_\_getattr\_\_. For example my \_\_getattr\_\_'s are as simple as: def __getattr__(self, name): return getattr(self.baseInstance, name) 
my talk actually made the loosely define 'cut' of 80 proposals. would you say it's worth making the trip from SF?
For people who are scared of contributing to PyPy: At the PyCon sprints we had over 100 commits from brand new contributors.
*I* pick up ElementTree first, but I know some people have strong feelings about the performance of lxml. I wouldn't think those people need a tutorial on tag retrieval ... Perhaps more to the point, lxml does things ElementTree doesn't, including XPath, XSLT, RNG, XSD, proper namespacing, and so on. Those are some of my favorite parts of XMListan, so there are times when I advise folks headed in those directions to start with lxml.
Ah, so it's like PythonCard.
pleased to know that i helped you a bit on your cake day :)
Agreed: the referenced article is lightweight. Presumably the reader will have had someone say to him or her, "You ought to learn this. And you ought to learn *this*, in particular, because someday you'll need XSD and other stuff not even worth explaining at this point."
That and the fact the article is from two years ago (which made me go check when ElementTree was brought into the stdlib - [Python 2.5 in 2006][1]). Blog posts should make the publication date more obvious. I dislike the increased use of '/blog/name-of-article/' URLs versus the previously common use of '/blog/year/month/day/name-of-article/' URLs for this very reason. [1]: http://docs.python.org/whatsnew/2.5.html#the-elementtree-package
I don't understand why you need both threads and subprocesses. Can't you launch all the subprocesses from one thread? What is the thread supposed to do once it has launched a subprocess? Sit there and wait? There's no need for a thread to do that, you should be able to wait on any number of subprocesses from one select() in one thread. 
I care not for pythonic. My solution is this: i = 0 while True: i = i + 1 if i &gt; 100000: break pass 
yes I think I can do: intersection = set(list1+list2) but I want to find the indices in list1 and indices in list2 of all elements 
Late reply - Yes to both. It is based on IntelliJ so has a wealth of plugins including VIM bindings, it has built-in support for rendering ReST (and other format) docstrings on the fly. It uses the docstrings comments to improve the auto complete suggestions - soooo useful! I hate going to work and having to develop in PyDev now (proprietary third party plugins)! 
Agreed. Also checkout [Hidden features of python](http://stackoverflow.com/questions/101268/hidden-features-of-python) it's enlightening! 
Do you really need the indices or would the values do?
Why would you even submit a proposal if you weren't going to go? As someone who reviewed just about every single proposal submitted for the last two PyCons, which amounts to over 700 proposals, I have to say I'd be pissed if I spent time fighting for a proposal to get in and they just said "nah I'm not going".
It appears to have been added on [2002-02-08](http://hg.python.org/cpython/rev/19834cd101d9) and first appeared in version 2.1.2. I don't know why it's stored as ROT13, maybe just 'cuz. 
 s = 'hipster' barkboy = s[::-1] 
&gt; Don't use threading in python. Why not?
&gt; For whatever reasons Python is not accepted as a mainstream language. What mainstream is this? The number of places Python is used very much outweigh the number of places it hasn't reached. Your idea actually *is* used - I've done it myself. I designed part of a system that I had to build into our C++ product by writing out an implementation in Python. It used to be a lot more common when Python had less of a reach and wasn't the "final language", but people are building more and more with it as of late, so the need to do this seems to have dropped off.
http://www.wefearchange.org/2010/06/import-this-and-zen-of-python.html &gt; As soon as we'd chosen "import this" I realized we just had to implement it. Python 2.2 was about to be released and I proposed that we turn off checkin notifications and sneak in a "this.py" module which when imported just printed the Zen of Python. Tim or Guido suggested further that we rot13 the contents of the module just for a little extra obfuscation, and we told no one outside our little group. According to my intergoogles spelunking, as soon as IPC 10 was concluded, we commemorated the event by committing this.py to what was to become Python 2.2.1, thus adding to the affront of new features in point releases. IIRC, it took a long time for someone to find our little easter egg. 
For somebody who's not Dutch, you're pretty good at finding those obvious answers.
Have you made sure that your ec2 instance has port 80 permitted in a security group? 
Yes. I opened it up, as well as port 8080 -- just to see if it would work. I checked my Windows Firewall settings as well. I was thinking maybe IIS would have some sort of Trans-Proxy configuration I could use...but I couldn't easily find one of those on Google either.
 There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. 
You win. Dynamic vs Static IP address got me here -_- now I feel really silly.
 import this
I like that, too.
Damn, I am not Dutch. Better switch to java.
Seriously, type `help()` then type `modules`. If `antigravity` doesn't jump out at you, `this` will, you dirty C++ programmer, you.
i think he forgot "for parallelism"
I've been doing it wrong this whole time? 
It may not have been very obvious to you at first.
import that, then
I'll often find myself writing something incomprehensible like that, and I do feel clever for a bit, but I usually rewrite it and make it clearer after a minute or 2. I'll admit I sometimes get a little crazy with list comprehensions though, and keep them a bit verbose.
You'll find many correct and different opinions on this. And pragmatism beats purity. I believe classes and methods are great code organizers. A class should contain whatever mostly pertains to it - the verbs it does, the states it defines. For organizational purposes the context of your question is important. What other classes are there? What does your module do? If you had a class for different kinds of chess rules then I'd say the get_legal_moves method goes there and it gets the game state as a parameter. If the code of for get_legal_moves was 500 lines then maybe I'd break it off of the ChessBoard class just so I could put it in a different file. Not to praise java or anything but generally speaking all code in theory fits into some noun class or namespace. You should try and make your project look like that unless you have good reasons not to. I hope that wasn't too cryptic.
In my opinion *get_legal_moves()* does sound like a method of a game state class. But *is_legal* not so much. Don't know about your use case but "don't ask for permission, ask for forgiveness" might fit here just right. I.e., don't ask if the move is legal, just move it.
&gt; Don't use threading in python. It's more complicated than a simple "don't do it". Don't use threads for cpu-intensive code. That doesn't get you anything in python, or C, C++, or any other language you care to name. Use processes which will use multiple cores and not trip over the GIL. Do use threads in python (or whatever) for I/O-intensive code. This won't trip over the GIL. Don't see the point of creating N threads just to spawn N processes. If you want to spawn many processes and decide to create one thread to monitor the processes just to keep all that code encapsulated in one place, fine.
YouTube and Dropbox are two examples that are written mostly in Python. It doesn't get any more mainstream than that in my opinion.
[What is that after your name?](http://i.imgur.com/WCo4A.png)
Where I work, I don't get code reviewed :)
It's a [fork bomb](http://en.wikipedia.org/wiki/Fork_bomb).
You are quite right, *but*: Sometimes in simple games I wrote I wanted to have a list of *possible* moves. So I can decide later (by random or some startegy pattern), which move I take. In that case it is far better to analyse the possible moves than to "just move" ;-)
Future you will hate you for screwing him over with crap like that.
A quick tip - you don't need the square brackets inside your join(). IIRC, the list comprehension will then behave as a generator. Same result though. More importantly, map(None, ...) is equivalent to zip(...). And in all the cookbook recipes on splitting sequences into equal parts they use zip or its variations, not map(None, ...). Why did you choose to write it like that? And how did you come up with '521261222116161122211'?
I also like to put some line breaks to make it supposedly look a bit more readable, but nobody usually cares to read through it and say it's a shitcode. Still, lots of fun!
[This](https://gist.github.com/2319191) is a very basic snippet using [NLTK](http://www.nltk.org/) for getting a word frequency file that can be pasted into the [Wordle advanced interface](http://www.wordle.net/advanced). You can use it from the command line: $ python wordfreq.py inputfile.txt &gt; freqdist.txt
Reading code like this a nightmare. 
The more general answer is: that is luckystarr's flair for this sub-reddit 
It's bad and you should feel bad.
I know it's a bad example due to the way Tagged has handled the project after acquiring it, but Digsby was written in mostly Python
Writing code like that is easy, writing clear code that solves complex problems is a challenge. As soon as you realize that, the "guilty pleasure" mostly loses its pleasure. It's not something that you can use to impress a girl in a bar, true, but... oh, wait. 
Yeah, writing atrocities is actually fun, and to some degree, I think it's good for you. It gives you a better idea of what you can pull off with the language. Plus, knowing how to write ugly code helps you learn how to write cleaner code. Just last week, I turned a five line for loop into a single line double list comprehension with lambdas and an os.system() call. It was repulsive, but entertaining. Of course, I didn't actually use that code for anything ;) Another gem; f = (lambda: True if some_condition else lambda: False if some_other_condition else lambda: None) () I think of it as a game. "How bad can I make this?" 
It almost looks more like PERL than Python.
It doesn't matter what he calls it, he'll have to write the same code anyway, eg: def just_move_it(self, move): if not self.is_legal(move): raise Exception("illegal move") self.apply_move_to_db(move) 
Yeah, if anything my side/home projects are *more* readable because I can devote as much time as needed to get it right.
Sometimes for fun, I write stuff using only lambdas. https://gist.github.com/1366139
This. I'm sure we've all cursed our past-selves for writing unintelligible code.
what are you maintaining?
And you're ok with your code being completely useless once you quit your job?
I avoid (at least in the toy example in my post) need for a `super` call, because the superclass (and its bases) are all already initialized. Is there a case where, in a situation like this, you'd need to explicitly (re-)call `super(...).__init__`?
Have you considered taking up Haskell? :)
&gt; Also, later on, I will be one of those other people. Yep. I find as I go along in my career the time frame which I remember solutions to problems is decreasing rapidly. Thankfully, Google is there to help me find my previous solutions (provided I post them somewhere online). It's actually been very helpful in the past. For example [this problem](http://lists.centos.org/pipermail/centos-devel/2005-May/000025.html) I actually encountered a year later but was able to find my own post and not have to sink days into diagnosing it again :-)
 # Unknown origin! degree = 1 # zeroesones returns alternating strings containing all zeroes, all ones, with N chars in them, for each in zolist # For example, ['00000', '11', '0', '11'...] for 5 2 1 2 zolist = '521261222116161122211' zeroesones = ''.join(['%d'%(v%2)*int(c) for v,c in enumerate(zolist)]) # Given this list, this groups it by threes (I am not sure how) triples = map(None,*[iter(zeroesones)]*3) # Now, things get strange. For each in triples, we return the number converted to a float and subtracted by .5 # So first, ['00000', '11', '0'] becomes (0.0, 11.0, 0.0), then [-0.5, 10.5, -0.5] point = [map(lambda k:float(k)-0.5,x) for x in triples] # So it looks like it ends up with 3-dimensional coordinates. Do some form of plotting with this data. cmds.curve(degree, point)
I lol'd in real life.
This is the first program I've made that I thought my actually be useful for someone besides myself.
who? [this guy](http://vigilantemma.files.wordpress.com/2011/04/wand2.jpg)?
Ich liebe sauberen Code
I have to learn how to do lambdas more.
I lqtm'd.
this is cool but turtle is more fun.
As a quick bit of background: * The program fills the screen with white objects in the shape of squares ( grid) then asks the user for a number of seeds. * It then places the seeds in random cells on the grid and turns them from white to green * from each seed a spiral algorithm is run at the same time, checking to see if a cell is white, if it is it then checks all of that cell's neighbors and bases its color on a random chance that is biased by its neighbors colors. (as an aside, at this stage only blue, green, goldenrod, and brown are possible colors) * After the chart fills it then runs through each cell on the grid and checks its neighbors, whatever color that cell is predominantly surrounded by is the color that cell becomes. * After that is complete a color function is run that also checks every cell again and adds in the other colors based off its neighbors (dark green, light goldenrod, dark blue).
I think knowing and practicing how to write ugly code is always going to be worse for you as a programmer than knowing and practicing how to write good code.
[.gitgnore](http://help.github.com/ignore-files/)
I actually once - around 2001 - managed to get point rotation for a list of points around world origin down to a single expression. Flash Actionscript made it possible to inline assignment with usage. It was perhaps a 200 character long line, dense with operators, but it was all a single expression that did all of the math for figuring out where a point should move, while setting all of the variables like velocity, all based on how you dragged or threw it with the mouse. It was essentially a for loop through a list of points with 2 lines in it - one to do all that work on the current point, and another to draw the new point. It was later completely incomprehensible, and I've never managed to figure out again how it works. Even the few ints in the huge line, when twiddled, yielded nasty results that explained nothing. I don't know how I did it.
Why? The point of this was specifically to make something that looked complex. This isn't production code.
lucipher's right. I just learned that if you only have one arg, it can be written as a generator, sans its own pair of ()s.
Then why does it matter? Why even open a thread about it? 
Well, actually, yes. But that's beside the point. I don't write code like this for work. I do this for fun to stretch the language and learn about new constructs. For example, I learned more about map and generator objects while doing this. This post has been a learning experience for me. I'm surprised how almost no one likes to play like this, and virtually no one presumed (I forgot to state) that this is just play code - not an example of what I do for work. I should have been more clear about that. For work, I'm actually known for creating highly readable code, and abstracting out concepts that allow us to write code in ways that start to approach natural language.
I don't think so. This kind of thing helps me understand the atoms of the language better. Then when I go back to my real work code, which is very readable, and nothing like this, I understand things at a deeper level, and am able to write even more concise code, which when coupled with readability makes for compact, easily maintainable code.
Believe it or not, yes.
Totally understandable. The more I play like this, though, the easier it gets for my brain to decipher crazy code. It's good brain training. I find I can read other people's code far faster having trained my brain to quickly make sense of things like this. I don't tend to write like this for work code, of course.
Well, how does writing good code *not* help you understand how the language works? For example, does anyone say "I would be a better programmer with a better understanding of the atoms of the language but my code is just too readable" ?
Aye, I have not yet figured out a way algorithmically to solve that issue but it is in my mind.
Any chance you'd share the code? I'd love to look through it, maybe even try some generating rules of my own...
I was thinking you could model artificial life using the map also. Each organism would have a simple program determining their actions. Organism could eat vegetation or each other. Reproduction would occur when creatures of the same color meet. Reproduction would mix the parent original program. Simulations like this are really fun to watch. I like the "villages" idea. You could also just stick to cellular automata and simulate the spread of villagers. Each village would have different color people that would reproduce. When the villagers from opposing towns meet the village with the most people in the surrounding squares would win the battle and the losers would be erased. Anyway, cool project sounds like fun.
bash 101 put this at the bottom of your ~/.bashrc PATH=$HOME/bin/python/bin/:$PATH export PATH then source it like so to have the settings take effect immediately $ source .bashrc or just log out and log back in
The seeds are placed randomly so diot is correct, more seeds does not necessarily mean more clumping. I could bias the random placement of the seeds to make them start closer together. not sure how i would do it yet but i'm confident i could, actually i'm not sure what I have not thought of that already....hmmm to the white board.
While you are correct about the spiraling, if too many seeds are placed the map looks like a giant blob of land with water doted everywhere and makes little sense. you are also right in assuming that once a seed is placed another can not be placed on top of it, in fact as soon as a tile takes a color it will not change until the entire grid is populated.
Yes, but my point was about the behavior if the sequence args aren't the same length.
I think I understand. Essentially, from each seed it propagates outwards in a spiral fashion. As you do that, each cell looks at it's neighbours (hence the Cellular Automata part) and from there determines certain probabilities. E.g. More water around, means that cell is more likely to be water.
Assuming you're Debian-based, did you try using [update-alternatives](http://linux.die.net/man/8/update-alternatives)? sudo update-alternatives --config python
&gt;With this explanation you sound like a way better person than what i initially thought :p. This reaction sums up what I think I'm seeing in here. Downvotes galore, and no one getting that it's for fun. I've deeply wounded everyone with my play. And yes, in my real code, I actually strive to write "beautiful" code, brief, succinct, easily read, and very easily maintained. That's the other end of my spectrum of play.
Brainteaser do have their place and time. const char main[]="jtX,pu YjwT_^jv17[jf17Z\xcd\x80jv17XP[K\xcd\x80 =) \xe8\xdb\xff\xff\xffHello, World!\n"; (32bit linux required) I've spent like three days, THREE DAYS on making this one thing work, and I don't regret anything! I think you have not make it abundantly clear that you don't actually write code like that, that you are inviting people to play Python code golf with you.
yes?
There's no silver bullet, but I found the Java documentation much easier to use in .chm format, as available [here](http://www.allimant.org/javadoc/). You can view on Linux / OS X using xCHM. If you need to build docs for your own or third-party packages in this format, [jd2chm](http://www.burgaud.com/jd2chm/) comes in handy. The improved ease of use comes from the searchability.
I think that's taking it to a non-existent extreme. It helps me find edge cases I wouldn't normally encounter. There's a lot to learn about the internals of a language at these edges.
I love Python, but I have to write Java fairly often. Here are some things that work for me: * Eclipse. Embrace it completely. If you stop fighting it, it will hurt less. * Attach the OpenJDK source. This will get you more documentation (and source code) in your editing environment. (Now you don't have to go hunting through the online documentation anymore.) Look into Javadoc tools if you want pretty formatting. * Eclipse Hotkeys! Especially Shift-Ctrl-T, Ctrl-T, Ctrl-Click and anything that helps you navigate, find types, and read documentation inline. 
Yes. It's so bad but so good. It's also fun sometimes to __import__("name_of_package") Add to that a fixed-point combinator and you can do some truly horrific things. 
Add a heuristic such that when placing a seed, there is some probability where the seed will be a multi seed, so instead of placing one, you place three within a confined radius of each other. The slider can control that probability. Just a stab. This looks really cool.
Looks a bit like how I imagined [Earthsea](http://en.wikipedia.org/wiki/Earthsea) would look. Nice work!
Is it on Github? If not, please put it on Github!
Yes, yes, and yes. Code completion is actually better in a staticly typed language, so your IDE can help you out a ton; you should be able to code complete your way through large swaths of code. Likewise, make use of code generation (getters/setters, equals, hash, etc) so that you stay focused on domain logic. IntelliJ IDEA is another IDE to look into. It feels a lot like Eclipse, just way more polished (naturally, since it's a commercial product; I found it worth the price though). 
this is all fine and dandy until you have to debug logging. :)
Except when you realize you want to keep that print around for a while....If it becomes less than temporary for the next 5-10 minutes, you may want a more permanent solution.
The 'easy' solution is to go with DRY and then use something like a Base class and a logger mixin... class IsLogger(object): CRITICAL = CRITICAL ERROR = ERROR WARN = WARN INFO = INFO DEBUG = DEBUG NOTSET = NOTSET __message_format__ = "|".join(("%(asctime)s", "%(name)-25s", "%(levelname)-8s", "%(message)s")) __date_format__ = "%Y%m%d %H:%M:%S" def __init__(self, name=None, *args, **kwargs): super(IsLogger, self).__init__(*args, **kwargs) basic_config(level=self.NOTSET, format=self.__message_format__, datefmt=self.__date_format__) logger_name = self.__class__.__name__ name = logger_name.lower() threaded_name = None if hasattr(self, 'name'): name = self.name if 'thread' in name.lower(): name, threaded_name = name.split(r"(Thread-") threaded_name = threaded_name.replace(')','') if name.lower() != logger_name.lower(): upper_bound = 25 - len(logger_name) name = name.lower()[0:upper_bound] logger_name = ".".join([logger_name, name]) if threaded_name != None: logger_name = "%s(Thread-%s)" % (logger_name, threaded_name) if len(logger_name) &gt; 25: logger_name = logger_name[0:25] self.logger = get_logger(logger_name) def critical(self, *msgs): self.log(self.CRITICAL, *msgs) def error(self, *msgs): self.log(self.ERROR, *msgs) def warn(self, *msgs): self.log(self.WARN, *msgs) def info(self, *msgs): self.log(self.INFO, *msgs) def debug(self, *msgs): self.log(self.DEBUG, *msgs) def log(self, severity=None, *msgs): if severity not in (self.CRITICAL, self.ERROR, self.WARN, self.INFO, self.DEBUG): severity = self.INFO for msg in msgs: if type(msg) == str: for msg_ in msg.split("\n"): if len(msg_) &gt;= 1 and msg_ not in ["", None]: self.logger.log(severity, msg_) elif type(msg) in (list,tuple): text = '\n'.join([str(m) for m in msg]) self.log(severity, text) else: msg = str(repr(msg)) self.log(severity, msg) def display(self, *msgs): print msgs self.debug(msgs) class Base(IsLogger, ...): def __init__(self, *args, **kwargs): super(Base, self).__init__(*args, **kwargs) ... 
I didn't want to come off as rude, after reading my comment I realize I do, so I apologize. What I meant is that long, unreadable lines obviously do not matter if you do not use them in real programs. Everyone does ugly code if it's only for the sake of testing, one-liner might be interesting in golf code problems, but then I think you should have made your point clearer when you created this thread. It indeed seemed that you were advocating for the use of unreadable code, and in this case I understand you got negative comments.
My general rule of thumb is: * use print when creating something new and you're trying to debug it AND you won't need it in 15-20 minutes * use logging for everything else
Hi, I'm the author of the blog post. &gt; It's not exactly hard to do this with print. But it's effortless with logging. The problem with "print debugging" is that there's *always* moments of "oh wait, I need to add this." You still have that with logging, but this way the timestamp is *always* added. There's no need to have "%s" % (time.strftime('%Y/%m/%d %H:%M:%S')) (followed by, whoops I forgot to import the time module). It's not hard to do this with print, but logging makes it effortless.
Also, the author of Invent with Python is a redditor who will answer questions you email him. al@inventwithpython.com
Until you realize that sometimes it is better to be more verbose to more clearly communicate the intent of your code. If you are the only programmer on all your projects, you only write one-off programs or nobody on your team cares about unreadable code it may take a while, granted.
Ich liebe verständlichen, lesbaren Code. Wenn er auch noch sauber ist, liebe ich ihn sogar noch mehr.
I tried some clustering algorithm by applying a random chance that a square 3 or less spaces away from a seed will also be grass, this is the results, a bit better looking if i do say so myself, I think with some math tweaking it could look pretty good. I dont really like what happens when there is 100 seeds (last pic) though http://imgur.com/a/JMUdb
OP is using a shared host and has his python installed under `$HOME`, both of which would imply that he's not an administrator and won't be able to use `sudo` or any package management commands. Adjusting the order of directories in the PATH in the shell startup file will fix things for interactive ssh sessions, but that most likely won't have any effect for serving requests, as the PATH of the webserver is not under user control. OP will probably need to adjust the shebang line and hope that the host is using CGI or FastCGI. If the host is using WSGI then it may not be possible to use a different python interpreter. 
The Apache Commons project is a god-send if you can include OSS stuff in your code (The Apache License is very permissive with what you can do with it). It has libraries for a lot of the things you commonly do like join strings or run MD5 hashes. With these libraries things only take a few lines to get done rather than the 10,000 lines it seems to take without them.
You are correct. I definitely did not specify my intentions of sharing some python code golf with the [/r/python](/r/python) community. "Guilty pleasure" in my mind meant, e.g., sneaking off into a corner to eat a tub of ice cream by oneself - i.e. not something you'd want to share with anyone, ergo not something that would see the light of day or make it into my work code. I see now that it could also mean - and seems to have been overwhelmingly interpreted as - "I love to make my coworkers miserable by committing code like this to the repo."
I'd like to reemphasize "playing" - this is play code, not work code. It's like an artist's sketchbook, toying with ideas to see what's possible. I seem, however, to have unintentionally dragged out deep-seated pains in everyone who's ever had to work with a miserably written codebase.
&gt; I seem, however, to have unintentionally dragged out deep-seated pains in everyone who's ever had to work with a miserably written codebase. :) That may be true. I've certainly had my share of "refactor everything please" projects.
I like to play as well sometimes. Silly stuff, really: a = lambda a: a b = ( a ( a ) ( a ) ( a ) ) print b("Hi") 
Honestly, the only thing that I don't like about Python is that I can't use all the time saving features Eclipse gives me. I use the ones I can, but I miss the awesomeness Eclipse gives Java that almost lets it match Python some of the time.
exactly...
There are many types of debugging. I'll focus here on debugging during development, and not post-mortem data dump debugging. When I use the logger as a debugging aide, I find the time stamp and component name to be mostly junk information which isn't worth the space. I want more information per line so I can see more debugging information on the screen at once. When I do need the timestamp, I usually implement a 'now()' function. now = datetime.datetime.now often works. To go back to Nimbal's comment, I agree - I only use the 'print' statement for debugging, and never for output. I use 'write()' for the latter, so I can easily replace the output stream with stderr or a file. I don't know how Python 3.x's print function will change my behavior. Logging levels also don't make sense in an debugging session. They are very blunt. You can't simply enable 'debug' level because then you'll get every bit of crap in the system. You might be able to enable specific components, but then you have to have all of your debug loggers well labeled. That takes work and time, which I don't want to do while debugging. (I'm not even sure I can remember the output diagnostic line format a day later! Then again, I don't need to.) In any case, in most cases I strip out that diagnostic output when I'm done. Why do I do that? 1) Much of that information is worthless except for finding the bug, and the bug's been fixed. 2) As Nimbal said, do you really want to see that information again when you're trying to figure out some other bug? 3) Code needs tests. How do I test that the log information is correct? Why go through that extra work? 4) There's a performance hit; some of the debugging I do is in inner loops, and even a extra function call doing nothing is going to slow things down noticeably. If you're going to have log statements, then they should to be part of the specification, with a test plan and guidelines on what information should/should not be logged. For example, "log the start and end time RPC calls, with identifying information" or "abort and log I/O failures" or "track major component calls". Adding debug logging willy-nilly leads to chaos in multi-developer environments. 
If you can, there's always [Jython](http://www.jython.org).
I agree! It looks much more like continents. Btw, I think this is a great pet project. There's a lot of potential for features and improvements. :D
Yep, that's one of the key features of generator expressions. (Note the "genexpr" object.)
Since this is buffered IO, it sounds like all the writes are being held until a buffer fills. Try adding a `sio.flush()` after each `sio.write()` to explicitly flush the buffer instead of waiting for it to fill. If that fixes it, then add `line_buffering=True` to the `TextIOWrapper()` options and you should get that behavior automatically.
How come it's written in the first person but signed by two people?
&gt;go with DRY def critical(self, *msgs): self.log(self.CRITICAL, *msgs) def error(self, *msgs): self.log(self.ERROR, *msgs) def warn(self, *msgs): self.log(self.WARN, *msgs) def info(self, *msgs): self.log(self.INFO, *msgs) def debug(self, *msgs): self.log(self.DEBUG, *msgs) ...
Will do :)
That can be typo prone. It seems like using these throw away print statements is lazy, but true laziness (as in, reducing work) is to use logging.
In mylogging.py: import logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s') critical = logging.critical error = logging.error warning = logging.warning info = logging.info debug = logging.debug print = logging.debug You could even have separate files for "import myfilelogging" or "import myconsolelogging". It's verbose, but still better than implementing your own class and it would give you the "import logging; logging.print(x)" interface that you want.
&gt; Are you saying that logging is going to allow you to fix bugs on its own? So you're going to log every single value of every single variable and every single function call, store all of this, then somehow filter it down to only the relevant bits when you find a problem? No. No more than you are saying you have to have a print statement for every single variable and every single function call. &gt; Not to mention, you have to mess around with log files instead of seeing the answer immediately in the terminal. Use "tail -f logfile.txt" and you can see the log messages in real time, except 1) they're in a separate console so they don't get mixed up with your program output and 2) you can leave tail running, and you won't have to restart it or reload a text file for multiple runs of your program.
Well, I guess you got me there. Good point. 
&gt; logging has always perplexed me(even log4j). Yeah. Python's logging module has a ton of features, and it's always perplexing to look at the docs. If anything, I wrote this blog article so I could always have a source of "these are the two lines I want to copy/paste to get logging". EDIT: I think what I said could be taken as being sarcastic. I wasn't being sarcastic. I really would shy away from using logging in Python because I would forget how it works, and trudging through the docs was more work than just using print. So I wanted to once and for all write out the two lines that I would need to copy/paste to get it working.
WAT? I think using logging for debugging is as bad as using prints.
The point is to perform macro-style literal replacements on source code. *ed*: live source code
&gt;Eclipse. Embrace it completely. If you stop fighting it, it will hurt less. This hits too close to home. Eclipse and I don't get along too well. :)
Could you elaborate more about why you don't like XCode/iOS? Or why you like it less than Java? I've never used it, actually I've never done anything with mobile.
I write it to become smarter. I actually write code like this a lot of times right in the shell to get quick answers to things I'm wondering about, or to rapidly test out some dictionary manipulation, before I then go write proper, clean, documented code. Practicing this stuff makes me faster and faster at it all the time. A good, and very simple example (just happen to have the code sitting next to me): a girl I work with - junior tech person learning coding and python (picking it up very quickly) - came by to ask some question about a data structure. While listening to her explain what data she had (from a JSON import), I typed up this quick example structure so we'd have something to play with (this looks a lot more like my work code; I think it's pretty readable): import random # make a fake joint structure joints = {} for name in 'bob fred mary alice alex allen frank'.split(): joints[name] = {} for channel in 'tx ty tz rx ry rz'.split(): joints[name][channel] = random.random() # choose one to zero out chosen = random.choice(joints.keys()) for key in joints[chosen]: joints[chosen][key] = 0 She had a question about finding a key name of a dict that itself had only 0 values in its keys. I typed this straight out in about 15 seconds, I think only editing one bit when it errored: [name for name in joints if all((not joints[name][chan] for chan in joints[name]))][0] Having played so much this way, that just reads to me like regular code. However, I know it's crazy for most people - I just wanted to check something before going over more realistic coding options with her. As I typed it, while she was finishing up explaining something, she trailed off and asked "What are you doing? What is that?" Then when I ran it, and it printed out the name of the key, she said "Holy bananas!" It made me laugh. It's fun. But *then* I said "Okay, let's write it the correct way." I wrote up this example for her to study: # find joint with all zeroes for name in joints: allZeroes = True for chan in joints[name]: if joints[name][chan]: allZeroes = False break if allZeroes: print 'found him/her: %s' % name break Again, I think the above - while quite simple, and not really addressing many things, like what if a key's value isn't a dict, etc - is the kind of code people in here are talking about when they speak of easy-to-manage stuff. *Most* of my code is very readable like this. Believe it or not, though, my one-liner, which accomplishes the same task as the 9-line version after it is easier for me to read and digest quickly. It wasn't always like that. That one line would have been a bit of a stumbler for me a year or two back, but now, having played so much with this kind of "crazy" coding, it's like I'm entering the Matrix, and it just reads like regular, clean, simple, elegant code to me. Of course, I recognize that it's not often the most efficient - all() has to wait for the whole list, whereas the if joints[name][chan] bit can kill out early, but I don't make time-sensitive stuff, and as I said, my real code doesn't look like this. I work on artist tools on the back end. It took me many times as long as writing the one-liner did to type up the 9 lines of code, though. It was probably a few minutes, vs. 15 seconds - not a huge savings, but when I'm screwing around and looking for answers in the shell, I prefer to blast something out in one line. That's where this kind of thing shines for me. I think you're right - people here are traumatized :) It's not just flexing the language. Code like my post flexes my brain. Having been doing this awhile, I can feel a huge difference in the complexity of code I can handle. Things I would have run from before are fun puzzles for me to clean up and figure out now. You don't get better at taking pain by avoiding it.
No, it is using an interface called CameraLink. It uses a PCIe frame grabber. I believe Camera Link is based on LVDS.
Ah, I see. Thanks, I didn't think of being able to perform the changes it mid run
Someone else asked me as well and I will tell ya what I told them. I am currently uncomfortable letting my code go right now, I put a LOT of time into it and its like my baby. Perhaps later on when I consider it done I will release it but right now I would rather now. What has stopped you from using pygame? if I make ask
How cool! that's awesome. My talk proposal was about learning from my failure in a CS class and turning it around to engage women in the Python community. If I make the cut, I will most definitely come, and I hope to meet you!
Also Ctrl+Shift+R is "find resource" which returns to you classnames and files as you type. I use it a million times a day.
Working on the AST directly using something like [karnickel](https://bitbucket.org/birkenfeld/karnickel) seems easier
It's definitley a complex module, but that's due to it's power. I hestitated using it, but after getting myself to delve a bit into it, it turned out to be immensely usefull and not that hard to use at all (well, as most of the times, I admit ;-)). The huge advantage comes of course from getting output from other libs. The cookbook and tutorials (as well as the other documentation) you've provided are great. Cheers for that!
I love print. You can pry print from cold dead keyboard.
Awesome. I did some really basic proof-of-concept work in python and ended up using numpy for applying the "rule", pygame for visualization, and GDAL to interact with spatial data formats. http://code.google.com/p/perrygeo/source/browse/gis-bin/cellular_automata.py Got a link to your code? 
thanks
Not sure why you are getting downvoted in this thread. I make sure I have the following two lines at the start of each file: import logging as log log.basicConfig(level=log.DEBUG) All debugging statements (printing out intermediate values etc.) go in `log.debug`. Whenever I'm satisfied with the result, I switch the base logging level to `log.INFO` and viola, all the verbose logging goes away! :) 
that's the trade off for dynamic languages. I felt the same way several years ago when I was coming from Visual Studio. Now my opinion is that if you write good simple code you don't need to rely on those things. Obey pep 8 religiously in your own code, and insist your team members do the same. Establish and follow conventions. Use Docstrings, Write Tests. Use the interpreter. 
Why do we need to have this whole bunch of boiler plate code + another process running just to handle this temp debugging? Stuff having to import a library just to `print`
spend a day with it, it is super easy. I got a nice parallax side scrolling demo done in an afternoon and that includes making the graphics
Dude, you don't even quote identifiers.
I'm a fan of XCode, but I will be the first to admit that it is not beginner-friendly, especially if you're trying to get that first iOS app out the door. Trying to figure out which icon to click to get to such-and-such options page can be infuriating. If you get a good and current Cocoa book, you should be able to get up to speed relatively quickly with XCode, and then it just becomes another IDE with a bunch of features you may or may not use. Don't try to use an older book -- XCode changed a ton between v.3 and v.4, and you'll just be stymied trying to do things that have different workflows in v.4. 
What advantage or features does your library have that existing ones don't? (sqlalchemy for instance)
Good point. I think I should introduce own BeeSQL replace character and then replace that by the Database specific character. Thanks for the catch.
I think a lot of people actually think that way. I've seen countless devs who were alone with their code, and "securing" their position like this. That's just a terrible way of thinking IM(not so)HO.
Why not requests? e: sorry was on tablet testing out android ICS e^2 :that was a stupid response, sorry its not an API.
This algorithm from jabbalaci beats any of the others given here (on my computer) if the sequence happens to contain five or more repeated characters, for example "aaaaab". This includes beating zahlman's distinct_permutations_rec. However, if the sequence contains more unique characters, then the simple set(itertools.permutations("aabbcc") will win. The jabbalaci code is paying more for all the indexing calls and swapping in Python. If the code was implemented in C or Cython, it may be able to compete with the simple set and itertools call for all cases.
If you look at the history of how it was written it becomes more obvious: https://bitbucket.org/pypy/extradoc/history/blog/draft/py3k-status-update-3.rst
I'd say Google Guava since it uses generics.
Eclipse looks quite bad if you compare with IntelliJ IDEA. I used to be an Eclipse guy too until I found IntelliJ.
no. use pypi and pip
web2py's plugin_wiki has a built-in [tag could](http://web2py.com/books/default/chapter/29/12?search=tag+cloud) 
How is this related to python?
What do you mean?
Had to write a script to remove the floating "lookatme" badge. It is gigantic at my 150% zoom level. It hides some text and forces you to scroll up a few lines after a "page down" to read all of them. Maybe just to me, but a 1024x768 banner at the top of the page could be less annoying than that.
I know it's on pypi, but I don't think you should install it that way. It's not a library.
Probably not, but it's simple. It's just a single file, you can download it and copy/paste it into your .bin folder if you like.
I don't see anything wrong with installing non-libraries from PyPi. Look at IPython, for instance (and there are plenty of others).
For the love of God! Don't hack sys.path! I've done it to interface with a compiled program and it's a disaster. Also, hacking your PYTHONPATH variable is wrong too! Try running it on another computer. It's a pain. setup.py is the way to go for real packages, but if you insist of being stubborn, do this instead (Python 2.5+)... from ..sortings.shell import config I could be off on the number of leading periods for sorting (it's 2 or 3). You'll need to have __init__.py in the . directories, but you should have those anyways. Now wasn't that easy? http://www.python.org/dev/peps/pep-0328/
Thanks for this and all your open source work man!
Great, But can you tell me how you are getting the tweets from twitter?
Make it configurable! I use ~/prg/bin myself.
`__init__.py`: from core import connection `core.py`: import beesql So, core.py is importing `connection` from itself as `beesql.connection`. Frankly, the fact that this isn't some kind of syntax error is a bit surprising. Also, you really don't need `#!/usr/bin/env python` on files that are not actually executable. Not that that one's hurting anything, it just feels wrong. Also, I might be a bit biased, but I prefer the Django-style of using **kwargs to define `WHERE` parameters. Something like select(create_date__gte=datetime.datetime.now(),some_foreign_key_id=21)
Submitted a pull request. The new download syntax with configurable /bin is: $ curl -L http://bit.ly/curlish | bash -s ~/prg/bin
cool little script. I am curious about your jabbapylib. Is this something that you maintain so you can easily use the functions for your programs? Seems like a cool way to keep snippets. 
A site dedicated to tweets? &amp;#3232;\_&amp;#3232;
I think most docs of python open source projects are host on readthedocs
Seems like a solution seeking a problem. How often does this happen in production code bases? 
You probably don't have it installed. http://pypi.python.org/pypi/argparse
Your solution also allocates 100000 integers.
It looks to be written from the perspective of a coroutine library author (or at least heavily influenced by that viewpoint). I haven't ever used twisted or greenlets in production code, and I don't know many people who do, but it seems like this could conceivably come up. I'm torn between "always cleanup" and RichardWolf's very salient point. I dunno maybe the author's want to be able to catch KeyboardInterupt and have it kill one coroutine, but not the whole process and still cleanup correctly which I can see being nice if I was debugging something like that.
your sarcasm is hilarious!
I'm just stuck now. Any feedback or advice would be greatly appreciated! I need to finish this by tonight.
This should be posted to [r/learnpython](http://www.reddit.com/r/learnpython) or [r/learnprogramming](http://www.reddit.com/r/learnprogramming) as noted on the sidebar. Aside from that, this is just really bad form. You waited until the last minute, basically did not even try to do the assignment yourself, and instead of describing exactly what you want help with, you posted a link to a long and detailed homework question, and apparently just expect someone to do it for you. You need to at least try to go through the high-level 'getting started' portion of your linked assignment on your own.
Seconding Webfaction. I've been running Django there since 0.95. It's a really great system for the cost.
It -&gt; is -&gt; kind -&gt; of -&gt; hard -&gt; to -&gt; read -&gt; , -&gt; particularly -&gt; the -&gt; 99 -&gt; bottles -&gt; of -&gt; beer -&gt; example. -&gt; Making -&gt; it -&gt; somewhat -&gt; resemblant -&gt; to -&gt; &gt;&gt;..+brainfuck++-.&gt; -&gt; , -&gt; which -&gt; I'm -&gt; not -&gt; entirely -&gt; sure -&gt; is -&gt; your -&gt; goal. No -&gt; disrespect -&gt; intended -&gt; , -&gt; just -&gt; an -&gt; opinion. edit: You're also missing an *import threading* in your first threading example.
I get worried when I see stuff like this. Does this really belong in Python? I have a fear that one day Python will turn into the bloatware that is C++ with all the changes to the language. 
I use a free Amazon EC2 VPS. Suits my needs fine.
Depending on what you're looking for, Google app engine might work for you. It will run most (all?) wsgi compatible frameworks. The downside is that you have to use their data store, though I think there is a beta mySQL alternative. I use app engine with django nonrel for hosting my personal site. It's easy to set up, and since it's basically django I'm not tied to Google for hosting. That said, I don't know how well that would scale for sites with an actual user base. 
+1 for Heroku. You can get a lot of use out of it without paying a penny/cent.
Isn't this contrary to the ideals of Python? It is quite ironic that you chose Pythonect as the name.
So use the [Heroku Scheduler](https://addons.heroku.com/scheduler)
No love for [Linode](http://linode.com)? Excellent documentation/library, and super easy to spin up or reconfigure instances. As a relative noob to server admin, I was able to get Ubuntu running with Apache, PHP, Python, SSH/SFTP, MySQL, and Webmin installed, and a couple of my domains pointed at it in one night.
I don't understand too much about how it works, from what I saw, it costs $35 a month and it behaves just like a shared host (1 worker process, 1 webhost process, and I think $10 for database space or something). For all the nice graphics they have, it isn't very self-explanatory, and I'm a technical person, imagine if I was an average joe.
I do not see the point of releasing this. Pretty much every person who wants a static weblog generator rolls their own; the target group only includes programmers (in this case it is explicitly stated), and writing your own takes what, one or two evenings?
You should check out [ep.io](https://www.ep.io/).
Thank you for your feedback. Lexical scoping in data flow programming language is a challenge. Here are some drafts of lexical scope designs I had in mind: "Hello World" -&gt; len -&gt; print "Hello World" -&gt; len -&gt; print with -&gt;: "Hello world" len print Would love to hear your (and others) thoughts. Suggestions for new lexical scope designs are welcomed as well. P.S. I've fixed the missing import theading. Thanks!
Thank you for your feedback. I don't know if this is contrary to Python ideals. I am not trying to be Python. The reason I called this language Pythonect is because it allows you to connect two or more Python codes together.
I know its weird, I am archiving all tweets about sachin tendulkar only. 
just fyi, I'm not the author. and the author might not be a redditor, but you could probably ask on bitbucket. But one thing I like about it is it's just sphinx, plus a theme plus some niceties for generating docs by some convention. If you know sphinx, you should be able to do anything with this that you can do with sphinx. (Another reason I thought it was cool)
Playing devil's advocate for a moment, the fact that he briefly mentions in the post, JavaScript's "multiline anonymous functions" are a pretty big deal. A browser programming language needs to be able to handle lots of events and callback functions (I click on this object, call a function that responds to that click). From a historical perspective, I don't think Python even had lambdas back when JavaScript initially came out. Another problem is Python's need for significant whitespace. For regular programming, this isn't too big of a deal, but when you start dealing with event-based programming, it wouldn't be as nice. I would imagine it would end up looking something like this if we did it today: button.attach_event("on_click", lambda e: button.animate({ duration: 500, direction: "left", fade: True}, lambda e: button.trigger("animation_complete"))) So it wouldn't be nearly as syntactically pretty as the Python we're used to. Finally, significant whitespace means we'd have to transfer extra data when you send scripts from the server, which could make it take even longer to download them. The fact that JavaScript uses braces makes it easier to minify it, so you can make the size of your script smaller more easily. Maybe in some parallel universe Python is actually being used as a browser-based programming language, but I think no matter what happens, browser-based programming will always be pretty ugly at its core. 
JavaScript's biggest weakness is the lack of a decent standard library. Even just having python's standard library available in the browser would be wonderful.
(blog author) I've put my comment about anonymous functions in &lt;small&gt; so as, hopefully, not derail this into a discussion about that specific tangent.... To explain better my meaning by it, I wish in Python you could do: myobj.somemethod = def (self,param1,param2): if self.something == .... .... Its entirely arbitrary that python lambdas are firstly use the *lambda* keyword as opposed to *def*, and secondly that they have to be on one line, and thirdly that they don't use a conventional *return* keyword etc Really, my focus is on what we might imagine have flowed from Python being that language put into the browser rather than Javascript... Would Python's richer standard library have helped fight-against vendor-specific non-portable Javascript dialects between browsers, for example?
Crikey, why not? Browsers can be bigger downloads than Python is. A large-enough subset of the Python batteries, and Python's nice collections such as sets, zip, enumerate etc could make client-side scripting a pleasure without being in any way a barrier to browser download.
There are implicit line continuations inside paratheses and brackets. This can be used to arrange the whitespace for readability whenever you are inside function calls, lists, dicts, or tuples. Your example could be rearranged to read as follows. button.attach_event( "on_click", lambda e: button.animate( { duration: 500, direction: "left", fade: True }, lambda e: button.trigger("animation_complete") ) )
CPython has a permissive license. There wouldn't be anything stopping them from simply including that as part of their browser.
Huh...actually, that's not too bad. I didn't know that worked for lambdas as well, and thought they had to be on a single line (only really used them for map/reduce and the like). Thanks a lot! Maybe Python could have been a decent browser language.
It sure is, butt that is not python vs javascript; fairer to compare pypy with v8
Was I the only one expecting to see an actual example of a rendered snippet? 
[source](http://www.addedbytes.com/cheat-sheets/python-cheat-sheet/) - available in HTML, PDF and PNG
Not really. Well-written C is far more portable than any other language. CPython already runs on most significant platforms.
You can only do so much in data flow before it becomes unreadable. Someone mentioned [Pyp](http://code.google.com/p/pyp/) on proggit the other day, which to some extent overloads the pipe operator. I think using a tried-and-tested method such as this would slightly help with readability, but the ability to extend expressions over newlines would also help. Your github page could perhaps elaborate a bit more on your reasons for creating this, the problems you intend for it to solve, why currently existing solutions don't work, and the direction you want to take it. Currently I feel as though a small Python script has the capability to do what Pythonect does, while maintaining more readability due to its enforced syntax, so I am presently unable to see its purpose. Nonetheless it will be a fun project and I'm sure you'll learn lots from it. Best of luck.
You're preaching to the choir here. And I'm not even a Javascript hater. I think it's OK but boy, Python in the browser would be a lot more pleasant.
Thanks for posting this. I was going to comment on the example anonymous function syntax you used in your blog post, and here it is. My questions are: * Your example looks entirely reasonable. Is that what Ruby's block syntax is? * It seems like you should be able to do what you said while remanining compatible with python's existing syntax. You just choose the indent for your anonymous function and anything within that indent is part of the function. First time you pop out of it is when the function ends. Am I missing something here? Make it a PEP! 
What do you think Javascript is implemented in? There is no platform that has a Javascript implementation but not a C compiler.
[ftfy](http://imgur.com/EASd3)
There's this amazing thing called Google you might want to try out. Check out Android NDK. And if you think the Android devs weren't writing stuff in C long before they had a working JS implementation, you're crazy.
Welcome. 
I practised Python thoroughly on [Project Euler](http://projecteuler.net/). It starts very easy and then gets harder and harder. I highly recommend it!
Browser programming is largely event-based, and thus inherently less pleasant than command-line programming. GUI programming is a better match, and it’s usually not much more pleasant than browser programming, Python or no Python. 
My Python cheat sheet: 1. Try the most obvious thing. It will probably work. 2. Unless I'm dealing with an old library module. Then Google to discover its weird conventions.
How does it reduce work when you have to setup the logging and specify a file and watch it in a different console? I see that it can be better *sometimes*, but you are oddly stubborn here.
What happens in your next round of debugging? When you leave the old debug statements in (which is kind of ugly and clutters up your code and hinders readability), you see debug messages from a bug long solved in your logfile while debugging a new bug.
And how does it work? PyPy is not exactly easy to get into. Edit: to be more specific: do people just hack away or do you guys somehow coach the newcomers?
Why the hell was this reposted on imgur?
Why didn't we use C++ in the browser? It would have been so fast.
the [pointclouds library](http://www.pointclouds.org/) is a really interesting project, if you're looking for a terrific GSOC2012 project, this looks like a wonderful project to work on. since robotics borders on so many various disciplines, being able to (write performant code in python is key to research *pdf warning*)[http://conference.scipy.org/scipy2010/slides/sccolbert_robot_vision.pdf]. 
That's a stupid solution. At least do this: i = 0 while i &lt; 10000: //doShit i += 1
Also if you already know other programming languages but want to learn Python: http://coffeeghost.net/pybat/python_cheatsheet.png
A single change to the logging level: logger.setLevel(logging.WARNING) (which will ignore the logging.debug() and logging.info() messages, since they are at a lower level.) However, if you really want to remove them, then it's about the same thing that happens when you use print() calls. However, it's easier to grep for logging.debug than it is for print, since you don't want to accidentally remove real print() calls.
Perhaps it's just in the projects I work on, but I'm usually writing a bit of code, then running it, then writing a bit more code, then running it. I don't have to stop/restart the tail command (it just keeps running in the separate window and spits out output when the log file gets added to again.) Also, it's helpful for me that the real program output is separate from the logging messages, so that I can see what the user will be seeing. It's easier than re-opening the log file in a text editor.
Check out the Python Logo and width of the inner table as compared to the image.
&gt; A single change to the logging level: logger.setLevel(logging.WARNING) (which will ignore the logging.debug() and logging.info() messages, since they are at a lower level.) That does not make any sense. I was talking about another round of *debugging", in which you would log with logging.DEBUG again. About the grepping: it is quite handy to just start your prints with a common prefix. I often use print "====&gt; my debug message" which is easy enough to grep. If interfering with other prints is an issue in the output, you can just print to stderr instead. But this pretty much never happens, because when you are temporarily debugging things, it is usually no problem at all to see your debug messages.
probably to accomodate reddit related queries?
And why was it changed to jpg?
Does anyone have one of these for python 're' - regular expressions? I'm always struggling to get the syntax right and have to resort to documentation. 
[Really?](https://encrypted.google.com/webhp?q=python%20regular%20expression%20cheat%20sheet) EDIT: Whoa, clicking this link sends me just to google. It was supposed to go specifically to [the search for python regular expression cheat sheet](http://www.google.com/search?q=python+regular+expression+cheat+sheet). In short: Yes, I was being an asshole, but didn't intend to be as big an asshole as I was.
dang
No problem. The restriction on lambdas isn't so much that they must be a single line as that they must be a single statement. You can't have if-else blocks, since those are multiple statements. You can have multiple lines if they are a single statement defining a list, dictionary, list comprehension, or something else of that nature.
Can it traverse firewalls?
That's actually a really fn good idea!
We could all just learn assembler , that would really speed things up. 
&gt; searching the python docs for stuff like the magic method names is nearly impossible [The Python Language Reference, §3.4: Special method names](http://docs.python.org/reference/datamodel.html#special-method-names)
try searching for "special method names" in the little search box on the python docs. its way the fuck down the page under the unhelpful title "data model".
I agree that the search on docs.python.org is terrible, but the docs are pretty well organized. I found the special methods section by just going to the language reference and looking at the table of contents. If you want to search the Python docs I'd recommend using a `site:docs.python.org` query on Google or your search engine of choice.
People reblogging this have added: &gt;Python and Javascript really are exceedingly similar; both are prototype-based dynamic languages and are essentially find-replace translatable. That seems... really not true. :/
If you're not going to be helpful just move along.
 button.attach_event( "on_click", curry(button.animate, 1, curry(button.trigger, 1, 'animation_complete'), duration = 500, direction = 'left', fade = True ) ) with PyQuery providing the appropriate `curry` recipe: def curry(func, ignored_arg_count, *some_args, **some_kwargs): return lambda *more_args, **more_kwargs): func( *(some_args + more_args[ignored_arg_count:]), **dict(some_kwargs.items() + more_kwargs.items()) ) # or something close to that, anyway and taking advantage of Python's keyword arguments.
So glad to see somebody writing an actual library for irc bots in python that uses Twisted. Kind of tired of having to remember all the protocol details that `twisted.words.irc` exposes when wanting to mess with that.
Thank you. I think it's a matter of finding the right formatting. Imperative programming does not guarantee readable code. But yeah, data flow is generally harder to format and it's going to take some trial and error before finding the best choice. I have not used Pyp, but I did look it up (and went through some examples) and here are the key differences between Pyp and Pythonect: 1) Pyp is text-oriented, Pythonect is general-purpose. I am planning on adding examples to shows Pythonect do: Image processing, Mathematics, and more. 2) Pyp does not support automatic parallelization. Pythonect does. And, I personally believe that automatic parallelization is the future. Also, I am planning on adding support for multi-processing and distributed computing - so it's not going to stop with multi-threading. 3) Pyp is an application and Pythonect is a language, meaning that adding new features to Pyp or integrating Pyp with another application requires adding/modifying/deleting code. Pythonect on the other hand, is designed to take already-existing Python code and let you use it almost "AS IT IS" in a data flow. No re-writing of code or adjustments to be made. Write once, use twice. Example? From [Pyp](https://code.google.com/p/pyp/) Homepage: &gt;What's New in Version 2.04 &gt; &gt;New Functions &gt; &gt;The following string method allows pattern matching using a REGEX: &gt; &gt;p.re(REGEX) returns portion of string that matches REGEX regular expression &gt; &gt;echo 123456 | pyp "p.re('.3.')" &gt;&gt;234 Now, Pythonect already supports regular expressions. Not because I have added any special code for it, but because Python already have a standard module called re which does it. Here's the same code, in Pythonect: import re -&gt; "123456" | re.findall('.3.', _) It's not even that different. Consider you need to use re API and to import Python's re module.
Awesome. I looked for similar frameworks and couldn't find any when I started. I'm going to check yours out.
My computer had to work harder to decode and playback the video than if he were to have posted a textual version. For that matter, the needlessly complex javascript interstitial on the nerds-central site also consumed processor cycles that would otherwise be idle. Their whole damn operation is "immoral".
This is excellent. Any chance that we could integrate the output with the existing ``pstats``[ library from the stdlib](http://docs.python.org/library/profile.html#module-pstats). A lot of profiling ecosystem tools work against that output.
amazed that noone has mentioned it, but this question has been answered before (the googs will help) iirc python just wasn't at a point where it made sense to use it in the browser, while javascript was pretty much created for that purpose alone
I'm working on them as we speak. Unfortunately I got busy this week and it took me longer than I hoped.
This right here. Keep it simple. 
That leaves Ruby as the only immoral option. Discuss. :)
Whats wrong with just using pdb or ipdb? I don't use prints or logging to debug. import pdb;pdb.set_trace() its just too easy. Failing that, trace is also really useful. http://docs.python.org/library/trace.html
I like the second one, but I don't know how intuitive it would be... This is what I think it's looks better: xrange(99, 1, -1) -&gt;iter(i) "{0} bottle(s) of beer on the wall,\n{0} bottle(s) of beer." -&gt; format(i) -&gt;print "Take one down, pass it around,\n" -&gt; print Feel free to disagree. Good luck with your project.
It's completely innocuous code but it's maybe not ideal that clearly obfuscated strings got waved through like that. It's great as a one off joke, of course. 
If the image is too large, imgur converts it to a jpg automatically.
I often find that recommendations from my peers here on r/python are of a better quality than what Google gives me. Eg: "well if you have never used RE before, x is a good resource. On the other hand if you are competent with RE and just want to learn about how python handles RE, go to y. Then someone else will pipe up: "Nah, y is from 2002 and partly obsolete, z is where it's at."
Sure there is. Python supports a level of metaprogramming that makes it intrinsically harder to optimize than javascript. Operator overloading, `__getattr__` and `__new__` all introduce corner cases that must be carefully managed. PyPy has done a great job but Python is hard to optimize as a direct result of its highly dynamic and customizable object system. The same features that make Python expressive and great for writing libraries make it hard to JIT compile.
I have a love hate relationship with this website...
If want to code javascript, but prefer a more pythonic syntax, try [http://coffeescript.org/](http://coffeescript.org/).
No. The compiler itself will be slow. Try shoving some code with template in a C++ compiler and see the outcome. Edit: and as akho_ metioned, web environment is largely event-based, which I think C++ is not really good at it.
Can you elaborate on this? It looks like they allow free signups, but don't they charge you if you use too much processor power?
Got any good links for trying something like this out? I see in one of their videos they use GAE and some sort of web framework with python. But I'm confused as to what their service entails, is it a shared host type of thing without diskspace/access?
This would be better in [/r/learnpython](/r/learnpython).
Interestingly, that's just because they reblogged an early draft of the article before I took that bit out; I didn't want a discussion about language and anonymous functions, I wanted a discussion about what we might imagine would have happened if a language heralded for its teachability and readability had been the mainstay of the widest distributed VM - the browser. So I wrote that they were exceedingly similar; can you think of a way in which Javascript would defeat find-replace translation into Python?
Ah see that's what I wonder about. How much can this service handle compared to a shared host or compared to a VPS.
It's more that there exist glaring differences in how the languages fundamentally work that prevent me from accepting an "exceedingly similar" claim. Most notably, the typing system (and associated wtfs). But if you're looking for a more concrete example, Javascript's `arguments` system works completely differently from Python's `*args`, and `**kwargs` has no equivalent.
Thanks! It's not that the idea is "hard to find" but everything come down to the execution. We hope we made the right decisions and If you signed up for the beta you'll see it for youself too soon. ;) Cheers!
Oh, I'm sure as hell not going to pay for something I could make myself.
This is pretty neat (the algorithms they're using in this library are insane!), but I think GSoC 2012 applications are closed already. 
They take kind of a different approach than traditional shared web hosts. With traditional shared web hosts, there tends to be a mapping between files and web pages. With Python applications, there tends to be an entry point (your wsgi script) and you get to the other content with URL routing. Because of this, Google AppEngine thinks of your project simply as an app. You don't have disk space on a server, you have an application. When someone tries to access that application they find a server with the available resources and have it start up an instance of your app. If your app has a hundred simultaneous connections, instances might be running on a dozen different servers. If you have one connection, the extra instances shut down and you only have one instance on one server. There are a few other services that use a similar model. I believe [Heroku](http://www.heroku.com/) and [gondor.io](https://gondor.io/) are publicly available, and [ep.io](https://www.ep.io/) is in limited beta. They are shared hosting in the sense that your application will be running on a server with other applications, but its architected differently than most shared hosts. Tutorials for getting up and running on Google AppEngine depend on what framework you want to use. If you want to use their webapp framework, there is a [tutorial here](https://developers.google.com/appengine/docs/python/gettingstarted/). If you want to use Django nonrel on AppEngine, I'd start [here](http://readthedocs.org/docs/django-nonrel/en/latest/content/djangoappengine%20-%20Django%20App%20Engine%20backends%20(DB,%20email,%20etc.\).html). If you have another framework in mind, Google "appengine &lt;framework&gt;" and you'll probably find some results.
yeah going from javascript to python is what I had in mind; going from python to javascript would take quite a hassle-filled support library
As I said on Hacker News, I shall say here. **No.** That is all.
They just received one billion dollar and can't spare more than 504$ for one of the most promising projects in Python's history?
Hey, you've always been very helpful to me on StackOverflow regarding this module, but I've also mentioned in the past that it is quite complex and difficult to find out how to do what to do. Sure, it's just 1 call in a lot of cases, but knowing what to pass to the call is complex! The things I've found difficult have been these things: * 'magic' in the logger names. The whole concept of the dotted notation is hard to learn about - it's hinted at in the 'Logger.getChild' function documentation on the first page of the docs, and then further down in 'logging.getLogger', but you have to read right into the Advanced Tutorial to get any idea of what it all means. I think this concept should be right on the first page. In particular, I don't think the API reference should talk about child loggers or logger names without having explained this system first. * Configuration has lots of little corner cases that interact. eg. Some snippets recommend the `logger = logging.getLogger(__name__)` approach at module level, but if you use one of the config commands in your code then all those loggers will be switched off silently - unless you know to use the disable_existing_loggers argument. (It's in the reference, but because it's a default parameter, you don't see it in any tutorials or snippets, so you are unlikely to know it exists.) * Errors can be a little obscure. eg. If you ask it to write a log file to a/b/c.log and a/b/ doesn't exist, it'll tell you that a/b/c.log wasn't found. Another example: if you pass a bad filename to fileConfig, usually the first you know that it was a bad filename was that you get a 'section missing' error when querying the configuration, when really you want things to fail as soon as possible. And obviously some other mistakes just never get seen at all, because the logging system has decided you didn't want them logged (due to your incorrect configuration). It would be handy to have a debug flag that lets you see exactly where a given message goes (or why it doesn't get output anywhere).
Absolutely. It's true, I'm being a jerk, and I regret that. But when I saw the guy's question, I was all "Wow, there aren't any python-oriented regexp cheat sheets? I bet I can find one!" And the very first search I did found me a number of high-quality examples. And I thought, "This asshole didn't even try to answer his own question before bringing it to us and wasting our time!"
Wow, this is pretty freakin' cool! Anything that makes more people write docstrings is good in my book. Great work!
Could be, but there were a lot of non-WebFaction ideas posted, with some higher voted than the WebFaction comment. It looks fine to me for now, though another mod may come along later (not sure where everyone is this morning).
+1 for Heroku. I have tested it for a few ideas I've had, and it seems to be working very well. Basically, it's like Google App Engine Done Right(tm). It may not be for everyone though - ultimately I just stayed with a full Linode VPS.
+1 for Linode. It's what I currently use. I've heard people say it's terrible for the price, and there are much better solutions -- but so far they haven't been able to actually give me a link to something better (let alone cheaper). That said, it may not be what the OP is after. I found I prefer a full VPS to an "app engine" type system, but but he may be more interested in something like Google App Engine or Heroku.
This is all kinds of awesome. It's one of those ideas that's so simple but oh so right.
Cool. I often wanted this but never find time to make one. Register it at PYPI for distribution please.
I will do that soon. Also, it's only 1 file, so you can just drop it into your project.
What? Why is this a good idea? Docstrings are for docs, there's no good reason to try to put code in there.
Or, more precisely, derive code *from* human readable text – at worst that means making many implicit assumptions to fill in the gaps of ambiguity left by human readable text... and implicit is anti-Pythonic. And that's my issue with this approach –there's a lot of implicit magic going on and that's really far from the explicitness that defines 'Pythonic' in my mind. Additionally, unless I've missed something, this library forces users to give up a lot of power vs. argparse to force one's self to write something that really could be auto-generated from the argparse code. Just my $.02, of course... 
I don't really see that, certainly not it being anti-Pythonic because you go get the options from the docstring. If you need argparse's power, don't use this approach. But for simple maintenance scripts, etc., this would be a nice way to abstract away some boilerplate and encourage people to write good, formal help text.
Thanks for looking into it.
We've already got Python, though. What benefit does a DSL provide? (Just because `optparse` has a horrid API doesn't make this a good idea.)
I like it, especially for simpler command-line interfaces. I was surprised by [the swearing in the project README.md][1] though. I don't think it works, the light-hearted tone is well established by the surrounding text. Swearing is fun, and in many contexts is acceptable. I don't think this is one of them. Also it would have been great to have stood up and yelled "YES, FUCK *YOU*" during David Heinemeier Hansson's presentation from a few years back. Because it's always fun having a stranger swear at you. [1]: https://github.com/halst/docopt/blob/master/README.md
Thanks, that's a good distinction to make, and is why I was attracted to Linode over those types of services as well.
Explicit is better than implicit. This is more Ruby-like than it is Pythonic.
There's a big difference between putting the usage message *in* the docstring and deriving code *from* the docstring. 
Thanks for the feedback. I'll see how I can improve the documentation or code to try to address your comments. My comments on your feedback are: * The logger name hierarchy is no more magical than the Python package hierarchy, and if you follow the suggested good practice of using `__name__` for module-level logger names, it's exactly the same. I can try and bring that out in the reference a little earlier. * I'll see if I can make the warning about disabling existing loggers more prominent in the tutorials. * Some conditions you observed are based on behaviour by the underlying code that logging calls, e.g. examples at [1], [2]. Of course logging could add additional checks for misconfiguration, but logging is *intentionally* silent when configuration failures occur, because in some production scenarios, producing error output because of logging misconfiguration would be a no-no (e.g. it might interfere with an application's operation, say if it's using `sys.stderr` in its application logic). That's also why, in production, it's recommended to set `logging.raiseExceptions` to `False`, so that exceptions caused in logging (e.g. format string mismatches with passed args) are swallowed. [1] Behaviour of `open` with non-existent files: &gt;&gt;&gt; open('/temp/a/b/c.log', 'w') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; IOError: [Errno 2] No such file or directory: '/temp/a/b/c.log' &gt;&gt;&gt; [2] Behaviour of ConfigParser with non-existent files: &gt;&gt;&gt; from ConfigParser import ConfigParser &gt;&gt;&gt; cp = ConfigParser() &gt;&gt;&gt; cp.read('/temp/a/b/c.ini') [] Edit: updated docs checked in, should show up on http://docs.python.org/ by tomorrow.
perl called, they want their modules back ;) [Getopt::Euclid](http://search.cpan.org/perldoc?Getopt::Euclid) This is what I use for my perl apps and now I got the same module for python, nice. Thanks for sharing this (a tiny bit unpythonic, but fuck that) code! 
I would say it having a horrid API makes it a perfect idea. Just because a DSL is human readable it doesn't mean it's a bad DSL.
I like that it makes a simpler way to do arg parsing. I'm assuming for anything like required args, we'll have to put that in after the parsing?
Yes, as for now docopt is only concerned with options, but I'm thinking about how can it be extended to parse arguments.
An alternative approach which might be of interest is Matt Chaput's [Baker](https://bitbucket.org/mchaput/baker/wiki/Home), which uses docstring info on functions (e.g. `main`) to determine how to parse the command line.
I just submitted source to PyPI. Now you can use pip/easy_install to install: pip install docopt It's first time I submit something to PyPI, so I could possibly make a mistake. However, I tested it in a vertualenv and it worked. So, please, tell if you succeed or have any problems with installing it via pip/easy_install.
What the fuck?
I know! [Its quite a number of dependencies...](http://highscalability.com/blog/2012/4/9/the-instagram-architecture-facebook-bought-for-a-cool-billio.html)
The right answer to a horrid API is to make a good one instead.
that website remember me that i can't do math......
I honestly don't see much magic there. The syntax is very simple and very clear: if the line starts with - it defines a new option, and the option's documentation starts whenever there are two consecutive spaces. It doesn't seem like the parser does anything complex or subtle to figure out what you mean. The nice thing with this approach is that I get better control over the exact way the usage message is formatted for the user. I don't like auto-generated documentation much because I need to dig deep into the API to figure out how to make it look right, if I am even given the option. 
The horrid API is horrid enough for me to just use sys.argv instead.
Yes, this is exactly one of the reason I wrote `docopt` – I didn't like the bondage that `{opt,arg}parse` put you when you want to make the usage-message look like *you* want. Of course, using those, you can make "groups" of options, and add "epilog", but that's too little and, worse, you need write *code* in order to do that.
yeah, this works for very simple things, but i love argparse because i can make it so that arguments can be verified through a function (like seeing if a file exists), making it so that it automatically opens a file with the specified argument (a filepath), etc etc. This just seems very hackish =/
look in the collections module for how the named tuple is implemented, I'll give you a hint, it's magic
Not sure we even need to bring up PEP257. It looks like you just used the docstring as an example. This should also work: usage = """ usage: [stuff here] """ options, arguments = docopt(usage) While I am not sure if this qualifies as "Pythonic" or not, that doesn't matter to me. It makes a tedious job much easier. Unless there is a serious bug hiding in there somewhere, I will definitely be using it.
If "human readable" is taken to mean "like natural language", it almost certainly does.
https://www.odesk.com http://www.freelancer.com/
That's definitely thinking outside the box. Any support for sub-commands? 
How well does this play with Django. Could I use this for my management commands? 
I'm new to Django and don't know if there is anything specific about CLI in it, but you should be able to use `docopt` for any of your scripts, assuming you don't want to extend some built-in-Django interface.
The right way: start writing open source software that is useful. Then they'll come to you.
mcdonc and JerMenKoO are both right. You become much more marketable if you have your name attached to some open source projects. Even something as large as Django can always use more help, even in the very technical parts (not just writing documentation). Submit patches to Django using their own ticket system, or find projects on Github and fix their issues. If you're really a Python programmer, then there are libraries you use every day, and bits and pieces that you find would work better some other way, or missing a feature you'd like, or something like that.
yeah, no. ply is also insane
Nice. If you also have ganglia (http://ganglia.info) running, you can also use ganglia to feed data directly into graphite.
First time post for fun :) I am NOT skilled in python, but I've been using it for a year (and some change) for simulators, etc. I've had to deal with it, so I'm here to help, not to be impressive. I was introduced a year and a half ago, so I use v 3.2 I'm providing some tkinter GUI bible pages, assuming you're using tkinter. I've never played Stratego, but I'm assuming some *basic* basics in terms of the communication between the GUI and the programmed rules is fundamental. [Some widgets for tkinter](http://effbot.org/tkinterbook/) [Canvas Widget help](http://effbot.org/tkinterbook/canvas.htm) [Events and Bindings](http://effbot.org/tkinterbook/tkinter-events-and-bindings.html) If you are, in fact, making a GUI, just PM me, and I'll help you along. I've had to make some stuff for Cognitive Science classes in Python. I'm here as a fellow student, studying with you. 
Yes, the free database offerings are quite meagre, that's also partly why I recommended MongoDB. [MongoLab](mongolab.com) offer a 240MB free database, you can even choose the hosting location. MongoDB's document based structure also seems to fit very nicely with a lot of projects one might want to throw together. A lot of the time you don't need a relational database. It is free to sign up for an account and run any number of sites that only use a single "dyno" each. Some free addons require you to add payment information to your account, but even then, they wont charge you until you explicitly enable charging on your account which is done separately through the CLI. Also, regarding hardware specs, it seems to run on a quad core Intel(R) Xeon(R) CPU X5550 @ 2.67GHz. Here's the contents of /proc/cpuinfo http://dpaste.com/hold/729849/
but the way the macports system of changing the default python breaks it even when the default is the apple's python.
If this was forwarded to me for code review, I'd have stopped reading at the declaration of 'template'. No. Just no.
I'm going to hazard a guess that's not what CDRE was saying wtf to. I know it's not where my wtf came from. As with your first post, I have no idea where this is going, what should be discussed, etc. What is this? Couldn't you just post "Instagram just made a lot of money, shouldn't they donate to a bunch of it to open source projects"?
I can only help you with 1), sorry. The place where they *were* posted (pyvideo.org) seems to have had a lobotomy. But you can find all of 'em at NextDayVideo's YouTube page: https://www.youtube.com/user/NextDayVideo
Nice! 
"If you build it, they will come."
&gt;Object-oriented principles after one semester!? Wow, you are in trouble. I know, right? They waited a *whole* semester to talk about OO while using an OO language?
&gt; The logger name hierarchy is 'magical' in that you can pick arbitrary names, which may or may not do exactly what you want. Logging tries not to be arbitrarily restrictive, but the good practice of using `__name__` is IMO reasonably well documented. Logging can't help it if you make a mistake in a logger name, any more than `open()` can tell you if you misname a file that you write to. That might require telepathy ;-) There's no magic about hierarchical names, it's a common way of organising a namespace and logging's use of such a namespace is not that hard to grok, is it? &gt; Sure, but these things can be wrapped. When you let open() throw an IOException out of the logging library that is arguably a leaky abstraction. Perhaps, but you're not going to get completely perfect leak-proofing in general, because that isn't likely to be worth the effort of doing it. In the `open()` case, I think it's fairly obvious that the path is wrong somehow. Even `open()`'s error message doesn't tell you *exactly* what's wrong (i.e. which specific directory was not found - it just gives the whole path in the message). I'll review and see if I can improve the error handling round the couple of areas you mentioned. &gt; What if your logs contain important data and you end up running a live server for a week without logs by accident? That could be because you set the verbosity to `CRITICAL` by mistake; logging isn't going to be able to divine your intent in all cases. If it's that important, one would assume there's a need to check things carefully after changes, just to make sure things are working as expected. Logging could fail and you lose log events because of e.g. insufficient disk space or network problems; it's not proper for logging to resort to printing to sys.stderr just because that happens, because that could interfere with the application's operation (and logging has no way of knowing whether it would, so it doesn't e.g. write to stderr - but you can tell it that it's OK to do so, by configuring a suitable StreamHandler). Note that logging has functionality to allow the configuration to be updated without having to restart a server process, as long as the server process has been designed to use that functionality. &gt; It's the silent errors that are the biggest problem The errors are generally silent when making logging calls in a production environment (`logging.raiseExceptions` is False) because, for example, there's no benefit in printing potentially thousands of lines telling you that a format string doesn't match the arguments passed. However, configuration errors can generally be caught in development and test environments before deploying to production. I do appreciate the time you've taken to give this feedback - I will review error handling, but if you think there are specific things which are bugs, please raise them on comp.lang.python or the Python issue tracker.
No, not without heavy modifications. Django's management commands determine arguments/argument types and such through Django classes.
Well fuck, I know the tedium of using optparse, having to reread the documentation, and struggling to customize the usage output. Excellent job, and definitely pythonic.
So, basically never use is. And don't write some weird \_\_eq__ function that says your object is equal/is something it's really not.
Good read, explained differences clearly. Finally completely get it. Also, never knew about interning.
&gt;To summarize even further: don’t use is unless you’re comparing with None or you really, really mean it. And you don’t. I wished s/he put that in the beginning :-P
`==` is for comparing values `is` is for seeing if two things are the same object. Example: You lose a green marble. You see that your friend has a green marble. They might be identical (**==**) but that doesn't mean that it **is** the one you lost.
&gt; `a is b` is effectively `id(a) == id(b)` Conceptually, yes, but in practice, `id` won't always give you the same results as `is` because CPython recycles reference ids really quickly: &gt;&gt;&gt; id(object()) == id(object()) True &gt;&gt;&gt; object() is object() False &gt;&gt;&gt; id(object()), id(object()) (4302504784, 4302504784) 
I wouldn't say that. The article specifically says _always_ use `is` with `None`. And sometimes you want `__eq__` to do "fuzzy" matching for your class. It just depends on what your class is about.
Yeah, it's pretty basic info, but based on all the "Help me do my homework!" self posts we get, I assume a lot of newbies are subscribed to this reddit.
Trust me, there are. When I started out, I subscribed to /r/Python to learn little tricks and tips like this one here that maybe I didn't pick up by reading the docs. It's much appreciated by the newbies.
You should always use `is` when testing for equality with a singleton. So speaketh PEP 8.
Like justanotherbody mentionned above, sometimes you might want to accept a False-ish object (an empty list, an object with a custom `__nonzero__` or `__len__` method, ...).
Ahh, that makes sense if you want to specifically see that it's still set to None. I guess that would be useful in certain contexts.
Except this seems much less simple, being like 50x as much code. Plus, what are these `described_routes` and `link_header` imports? Also, he has `json` and `simplejson` in the wrong places, since `json` is a standard library module and will never (in &gt;=2.6) fail to import, and `simplejson` is much faster and generally better to use. I'm not even going to read the rest.
the pyvideo.org site seems to have the videos: http://pyvideo.org/category/17/pycon-us-2012
&gt; Logging can't help it if you make a mistake in a logger name, any more than open() can tell you if you misname a file that you write to. The difference is that open always gives you output - you either get the file (albeit misnamed, perhaps) or you get an exception. You have something you can meaningfully search for in either example. logging does nothing for many errors, and the result is usually silently lost data. &gt; there's no benefit in printing potentially thousands of lines telling you that a format string doesn't match the arguments passed. Personally, I'd rather see the thousands of lines than no line at all - the first situation is easier to spot and rectify. The second may go unnoticed for months, until you realise for some other reason that it's not there. Then you're going to check a variety of things - the logging hierarchy, the verbosity, etc - until eventually you spot the format string problem. If the format string is part of the formatter, you can have a flag that lets you emit an error on the first use only. Or there can be a set of file/line entries to ensure that logging only emits one error per line and future errors fail silently. Or logging errors can just go to a new destination (which I suggest below). &gt; configuration errors can generally be caught in development and test environments before deploying to production. Configuration is one of the things that typically differs the most between development and production. It's probably the *main* thing that I need to see good diagnostics for once I deploy. I understand that you don't want to pollute stderr; how about letting users pass a file-like object to logging as a sink for such problems? Consider the unix 'nohup' command - it knows that it swallows output, so it compensates by creating a 'nohup.out' file to collect that information in case it is useful. The default behaviour never loses your information, just redirects it. I just don't believe failing silently should ever be the default behaviour - if you want to swallow exceptions and suppress diagnostic feedback, you should have to explicitly enable that. I think that is one of the problems people see with the logging module - you add it in because you want *more* information, but if you're not careful you actually end up with *less*, whether that is because you named something wrongly, your loggers got switched off due to fileConfig, you specified a configuration file name wrongly, etc. I don't think there are any bugs in the logging module - I just wanted to share my experience and why I agree with some of the posters on this page regarding why it can be tricky to get logging working the way that we want.
Oh yeah. Forgot about that. But that explains why I use is type()
`isinstance` also counts subclasses as matching, so if you absolutely want something to be a certain class and not a subclass, you can use `type` instead of `isinstance`.
Wat? Don't see no Python there at all o.O **EDIT** Maybe you mean this: https://github.com/sickill/ascii.io-cli
Ok, but perhaps `a is b` matches `(lambda x, y: id(x) == id(y))(a, b)`. The difference is in object lifetime.
Thanks for the list. This seems like a pretty sweet hobby that I might pick up. How do you earn your bones in the industry? I imagine certs and schooling are nothing compared to practical experience but reverse engineering a lot of stuff comes with legal ramifications now a days. Is there an industry accepted practice set of sorts?
Given the ambiguous legal nature of it and that you can get yourself in pretty deep international stuff, most businesses want a security clearance (Top Secret w/ poly), so make sure your life is squeaky clean. Also, businesses like to see Certified Ethical Hacker on your CV. To earn your bones, you can work in malware analysis, consulting, or computer forensics. Also, you'd be useful anywhere that low level stuff is needed - embedded systems, kernel development, and the like.
Why would you write that instead of isintance(x, list)? And why would you want to forbid your API users to pass in sequences that are not list instances (tuples, various user-defined list classes like ZODB's PersistentList, etc.)?
If this is true, and it performs as expected, and it's accepted into the CPython mainline, that next release would be a very very very compelling reason to move to 3.x, meaning something good I could tell my boss, who doesn't give a shit about new keywords and unicode niceties etc... /crossed fingers
STM would add considerable overhead, slowing down single-core programs. Guido has often expressed that would not be acceptable. And rightly so. I predict that, even if a complete set of patches is released to remove the GIL, they will not be accepted into CPython. 
Did you even read the link? Armin specifically mentions what the observed slowdown on a model VM is.
Yes, I read the link. 20% slowdown. That's considerable.
Considerable, but if it means a 380% performance improvement on most modern PCs, why not consider it (and toggle it on/off for SMP machines/via an environment variable)? You're totally right that existing code wouldn't magically become concurrent, though.
[Go](http://golang.org/) comes pretty close, but you're right. There's no magic way to parallelize code. That said, there should be a way to do real, concurrent programming in Python without having to launch individual instances of the runtime and communicating via RPC.
I agree, it should be considered. I could live with a 20% slowdown (depending on what exactly would become slower). But Guido's historically been very opposed to slowdowns on non-concurrent code. I'm not optimistic on the odds of him accepting a 20% slowdown, but perhaps he'll find it acceptable.
People complained about Python's speed before those patches, and they've been complaining about it since.
Yep, agree. Unless there's a way to speed up fundamental operations without incurring additional overhead from excessive context switching, I don't see any way this would be added, or at least enabled by default, especially considering that 99,9% of existing Python code wasn't written with concurrency in mind. Parallelism is a complicated topic -- and it's one of Python's main design goals to be easy to use, not complicated (and maybe performant.) Edit: Looks like there's a Wikipedia page for this: http://en.wikipedia.org/wiki/Automatic_parallelization
not just conceptually, also in actuality: http://hg.python.org/cpython/file/23f648d7053b/Modules/operator.c#l135 the example you have above is not really equivalent, as object() is dereferenced after id() is called on it (which I know is the core of your example...but I think people should learn to see that pattern quickly).
I wanna play with this, but it feels weird to have to install ruby to deploy Python.
http://www.gun.io 
I just chose list as an arbitrary class
20% slowdown sounds horrendous, where's this "everyone" ? 
People here are jumping to conclusions. No one really knows how much overhead STM would incur on CPython or indeed whether it's even really an achievable goal. This is an early test, at most a research project. Why can we not celebrate it on its own terms? How cool that the possibility of adding STM based parallelization is being explored by one of Python's more prominent developers. How awesome that Python has a diverse ecosystem where many different approaches to parallel execution can be explored simultaneously. This is a long, long way from being production ready, but its an exciting and interesting investigation in its own right.
In testing, my interpreter stops interning at 257, so 256 and below will always be a singleton. Does this hold true for everyone? Let's find out! a = 0 b = 0 while a is b: a += 1 b += 1 print a Report back here :)
I think something like Erlang is as close as you can get to transparently multicore code. Go is still in its infancy and has yet to prove itself.
Agreed. The distinction is horribly straight forward. The description made it sound far more complex then it is. I got confused midway through and I've been using all of these features for 10 years.
In its infancy, sure. Yet to prove itself? I disagree. Did you know that Go [powers 10%+ of Internet traffic](http://code.google.com/p/vitess/)?
&gt; Considerable, but if it means a 380% performance improvement on most modern PCs ... for event-driven frameworks like Twisted only, and only if you rewrite your code to be compliant with idiosyncrasies of the new model -- incrementing a `processed_requests` variable at the end of your handler effectively serializes your event handlers, obviously (while wasting the rest of the cores). At least that's how I understand what exactly Armin is trying to do.
After many years of speeding up my programs 20%, 50%, 100% and more just by saying 'import psyco; psyco.full()' I have no other alternative than to place my trust in Armin Rigo capability. So lets see what the future will bring. 
By the way, how do you implement virtual functions to customize behaviour in Go? It's actually something that I encountered in C++ code: that was the first time I've seen private inheritance, and I immediately decided to rewrite that code to use embedding+delegation instead of inheritance, but suddenly realized that I can't do that, because the class in question had to override some methods of the privately inherited class. So it seems that the Go model is substantially more restricted than the traditional OOP, as in, the only workaround I could come up with is to rewrite the base class (now to be embedded) to hold a pointer to the instance of the derived class, or to receive such pointer in every method that called those abstract virtual methods. Is my understanding correct?
People seem to overthink about this. That is just an experiment. Not an exact patch for CPython. Even [the attached code][1] is not an implementation of Python (but a Lisp dialect). When Armin Rigo is actually done write the patch, then we can try and evaluate it at that time. [1]: https://bitbucket.org/arigo/duhton
He's making a tongue in cheek reference to the fact that people will use what they're given. i.e. Python was 20% slower before and they were using it then. The "everyone" is everyone who was using Python before last year.
&gt;Being able to tap into that power at a cost of 20% overhead or so is still a very considerable gain. You already can with multiple processes.
You sound like you know what you're talking about, can you explain what this article means? What's STM, GIL, and CPython?
That's unfortunate for them. I know which one I would rather debug. And I know which one can scale to multiple machines.
STM : Software Transactional Memory GIL : Global Interpreter Lock CPython : Vanilla python
Ok, well what does that stuff mean? What does using a software transactional memory to kill the global interpreter lock mean? 
No, no - the real benefit is in the standard library, where this paves the way to do things like automatic parallelization of list and set comprehensions and use high performance I/O techniques. I mean, it's great for GUI toolkits too, but the standard library is where we really run up against the limitations of the GIL and improvements there benefit all programmers.
I'm afraid I don't know.
I think the fact that the typical CPU today is multicore (even in embedded systems) may help lower Guido's resistance. Pair it with some work on standard library modules that benefit from killing the GIL and that may be enough to swallow the potential penalty.
Python has a global lock (GIL), so your multi-threaded python apps are using one core. Typical multi-threaded programming involves having lots of locks, mutexes, etc, carefully placed to improve performance while avoiding race conditions bugs. Software transactional memory means that different chunks of code are executed at the same time but in a way that any change don't actually touch the memory the other chunks sees. If there's any chunk that conflicts the changes of the others, it's "undone". The rest of the changes are "commited". I.e. STM gives you automagic multi-threading (even on non-threaded code in some cases). Is a very interesting approach but in practice we don't know if it really works. STM is being developed for PyPy but it's interesting it can be also done for CPython. Other VMs (such as Java) have explicit multi-threading with a lot of locks and mutexes everywhere. In theory STM is easier to implement and has several advantages over locks.
I did all of this but it still does not seem to be working. Is there a way of doing this without using BufferedRWPair? I feel like there should be a simple fix because carriage return is a relatively common form of line ending. I'm relatively new to python, and can't seem to find anything on this. Thank you for your help.
First off, that's not the entire code I think. Second, your error means that the index is out of bounds. Try printing i before each loop and see when it exceeds len(str). Third, I would try not to use 'str' as it is a keyword. It is OK in your situation but you are now unable to call str() to create a new string from something else.
What would you propose instead? That's not meant in a critical way, but to discuss the merits of one thing, we need an alternative to compare it to.
The code is really long so I just isolated the part that was giving me issues. The thing I don't understand is why my index is out of bounds for the line with "V" but not for any of the other lines of code when they are all written similarly. 
All lines with `if i+1&lt;=len(str) and str[i+1]=="?"` are wrong. When you get to the last letter in the string, `i+1` will be equal to `len(str)` and `str[i+1]` will be out of bound. Let's say `s = "XXI"`, when `i = 2` we have `s[i] = "I"`, `i+1&lt;=len(str)` is true (3 == 3), but `str[3]` is out of bound. Remove the `=` from `if i+1&lt;=len(str)` on every line.
Upvote this guy. While the top two comments are "nyah meh GIL never hurt nobody", this guy sees the possibility of at least cool hack value. This is not wasted effort. Don't dwell on the "can't", and think about the "could" for a while.
As this is /r/Python, can you talk more about the specific QT Widgets? Would love to hear about your experiences with freeze.
Well, to be fair, it was something that I designed badly, I think.
&gt; But that won't happen until we find a way to remove the GIL. You say *we* as if *you* are actually working on it.
But those are all still things that would have to be changed by the language implementation. The grandparent post was somehow implying that this is solvable by users and not the language implementer's problem, which is completely bananas crazy if you ask me -- a pure python hash implementation would be slow as balls.
You're right, but that's because Go doesn't really follow the OOP paradigm that you describe -- at least it's not idiomatic. It sounds like what you really want to do is define an interface, and provide types that satisfy that interface. That way, you could do something like this (example from sort package): // A type, typically a collection, that satisfies sort.Interface can be // sorted by the routines in this package. The methods require that the // elements of the collection be enumerated by an integer index. type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) } --- type Grams int func (g Grams) String() string { return fmt.Sprintf("%dg", int(g)) } type Organ struct { Name string Weight Grams } type Organs []*Organ func (s Organs) Len() int { return len(s) } func (s Organs) Swap(i, j int) { s[i], s[j] = s[j], s[i] } // ByName implements sort.Interface by providing Less and using the Len and // Swap methods of the embedded Organs value. type ByName struct{ Organs } func (s ByName) Less(i, j int) bool { return s.Organs[i].Name &lt; s.Organs[j].Name } // ByWeight implements sort.Interface by providing Less and using the Len and // Swap methods of the embedded Organs value. type ByWeight struct{ Organs } func (s ByWeight) Less(i, j int) bool { return s.Organs[i].Weight &lt; s.Organs[j].Weight } From the Go FAQ: &gt; Is Go an object-oriented language? &gt; &gt; Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes). &gt; &gt; Also, the lack of type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java. Could you provide an example of what you are doing? Perhaps I could suggest a more "Go-like" approach? Edit: Added sort.Interface for clarification.
It depends on the platform. Linux [Debian, Arch, Gentoo, Red Hat, etc], Mac, Windows, Solaris, etc. all do things very differently.
Then yes, you need to uninstall 2.7.2 beforehand. Not removing it beforehand might work in the sense of not giving errors, but things might blow up later.
Yup, you can do that. But I wanted to implement Newtons Square root method algorithm.
It would be interesting to know how Python does it.
&gt; do I need to worry about any incompatible issues after I installed the new version of python? If you're just going from 2.7.2 to 2.7.3, no, there shouldn't be any compatibility issues. Bugfix releases (x.y.z+1) should never break things that worked before.
I imagine the alternative involves frameworks such as Django somehow protecting the dictionary from malicious input. I haven't thought through the practicalities of that.
I like the idea (especially cross platform). However, how is this conceptually different from Apple's Airdrop system? I know it has more cross platforminess going for it, but beware of existing patents...
It would be interesting to know how C standard library functions do it. :)
jingleman is pretty much correct, looking at glibc's code for finding the sqrt of a float http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=math/w_sqrtf.c;hb=HEAD it calls a function __ieee754_sqrtf, which is defined for i386 here: http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/i386/fpu/e_sqrtf.S;hb=HEAD this is some assembly, which just calls exectues a FPU instruction to sqrt the number in a register. In short magic!
Yes, it's Newton's method. He implemented the version [described in SICP](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.7).
wonderful concise example right there
I use `isinstance(x, basestring)`. ;-)
Ok, that makes sense. (Though I think list is not a good example of an arbitrary class.)
You're adorable.
:) Thanks
``import math; math.sqrt(n)``
"Newton's Square root method" should have been included in the title of the post.
What about on a mac? Also, do I need to manually update python in all of my virtual envs too?
this is awesome! thanks bro!
So....a web application? Yes, you can make a web application with Python.
no, what i want to know if i can mix both, so i can add interactivity to python.
If you don't want to pay for it, why are you using ActivePython at all anyway?
checkout [pyv8](http://code.google.com/p/pyv8/)
Add interactivity? It's a programming language. Its middle name is interactivity. Use PyGame or PyGTK to make a GUI.
You seem to be talking about a web page, served by python, with javascript in it. So you're going to want a Python framework to serve HTML, like Django. And you're going to want to read about [AJAX](http://www.w3schools.com/ajax/default.asp). The basics are: Django serves an HTML page. That HTML page includes some javascript scripts in it. Those javascript scripts make subsequent calls to other Django URLS to, for example, cast a vote on this comment - `http://www.reddit.com/api/vote`. Django sends back a response, which your javascript parses, gets the value it expects to get, and acts accordingly, in this case making an orange arrow.
I don't get it; why would you want to switch between Python and JavaScript? Not only are they both great programming languages, they have mostly the same features (except JS has cool anonymous functions that are easy to write). What is the motivation for this?
See above; [he's not](http://www.reddit.com/r/Python/comments/s67jm/can_i_use_javascript_in_python/c4bet6z).
I know he thinks he's not, but he wants "invisible python code" that is "server side" and "interactive js", presumably on the client side... We call that a web page where I come from. He just doesn't understand how they talk to each other.
If you mean, "Can I write the server side of things in Python and use Javascript/AJAX on the front end to interact with it". Yes, it is a very very common practice. When speaking HTTP between each other, it really doesn't matter what either side is written. 
Well, it could be a server-client relationship with a Python server and a JavaScript client, using Node.js to run on the client-side. I admit, that's sort of a long shot, but it's possible!
ActivePython is good for corp places that want to pay for direct support. If you're just doing local dev or small projects just use regular Python.
Try implementing a method to do a *matrix* square root. It's a challenge, but you can still use Newton's method. A slight extension even manages to be stable, see [Higham](http://www.ams.org/journals/mcom/1986-46-174/S0025-5718-1986-0829624-5/S0025-5718-1986-0829624-5.pdf). (PS: It's already in [SciPy](http://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.sqrtm.html))
Also, for the potential users if the vim plugin: it is using the keybindings of gvim.
This answer is awesome, but leaves me wanting. I've tried google to no avail; but... What arrangement of discrete logic gates is used in the fpu to do the fpu instruction? 
When people eat soup with a fork for long enough, they start to think that spoons are stupid.
It's not what he wants. It's what he asked for. The two are definitely not the same.
The main advantage of ActivePython is PyPm. Certain packages can be very difficult to get installed on windows, and PyPm makes it much much easier. (Like PIL, PyCrypto, etc...) For every other case, I've noticed no difference whatsoever.
MSVC 2008 express (the needed version for python) is free so thats an option too. I let it compile whatever it can then fetch the strugglers from here http://www.lfd.uci.edu/~gohlke/pythonlibs/ when im using my windows computer
Fair point, still can't believe my comment is so unloved someone has come in here to suggest using subprocess and it has the same (0) votes.
&gt; You might need to set an option to let Python know it should use mingw to compile everything rather than MSVC. Why? Isn't Python itself compiled with MSVC 2008?
Yup, I completely misread your post. Sorry!
Ain't no thang.
WebStorm mainly because of the excellent DOM detection and JavaScript codesense. The JavaScript helpers in other IDEs dont compare, IMHO...it really helps with the repetitive boilerplate stuff. PHPStorm seems more lightweight than Netbeans and Zend Studio. I just got very comfortable with both IDEs right away.
&gt; Isn't Python itself compiled with MSVC 2008? Yes.
Well that's not "package management" now is it? No matter how easy it is to: 1. Try easy_install or pip and watch it fail 2. Search on google for a windows installer for the library 3. Download the installer 4. Click through the wizard It is no where near as easy as simply using easy_install, pip, or pypm. Furthermore, and more importantly, let's say you're working on a python project and it has a dependency on PIL or some other library that can't be installed through the package manager. Now your setup.py is going to fail for people who don't already have the dependencies installed and you can't provide them with an automatic way to install those dependencies. Your users will have to fend for themselves which is exactly the opposite of a good user experience. 
No, it is just what you are used to.
Binaries for some modules can be had from here: http://www.lfd.uci.edu/~gohlke/pythonlibs/ So that might be less of an issue for me.
I am still a Vim user. :) I use Vim for a large number of editing tasks but for Python I am giving PyCharm a shot.
I was referring to native extensions. If you want to compile native extensions on Windows and you don't have/want to use MSVC, you need to configure an option in distutils to instruct it to use mingw instead.
What is the new thing about threads that gevent 1.0b has? Where can I read about it?
Oh, well as long as it's not a problem for *you* there's really no room for improvement then.
I can not understand what the problem is. ActivePython has the advantage of coming with win32 and its documentation as well as with some other goodies you could find convenient. For the rest, in my experience there is no difference using ActivePython or the official installer. You are absolutely not forced to use the ppm repo: you can install packages in the same way you would do with the canonical python installation. Maybe I'm missing something?
If you want to use pywin32, COM objects, ..., ActivePython gives you the tools out of the box, together with additional documentation (including a copy of the PEPs and dive into python) and the pywin ide. I use both ActivePython (for 2.x) and canonical python (for 3.x) in the same computer. That depends on your needs.
Yes, I understand, but why wouldn't you want to use MSVC 2008 Express? I mean, compiling extensions with a different compiler from what Python itself was compiled with is a bit scary. It's all C, true, but...
Upvoting for good information. Thanks!
Cool dude, thanks for the words of wisdom.
I recently wrote an HTTP Server in Python to host a bunch of api scripts for a project that I'm working on. [This](http://stackoverflow.com/questions/60680/how-do-i-write-a-python-http-server-to-listen-on-multiple-ports) is the resource I used to get started. It is actually a completed http server in python that already supports threading. Some changing will be required, obviously, but the bulk of it is there. The first change you will need to do is in the do_Get function inside the Handler class. This is what the server will do when it receives a GET request. Since you are new to Python, I would stick with GET requests and avoid POST requests, they are more difficult. Some advice on handling GET requests. Check out the urlparse module. More specifically, urlparse.parse_qs. This function parses GET requests into a workable format. Just to get you started, the first three lines of your do_GET function will probably be: parsed_path = urlparse.urlparse(self.path) request_full = parsed_path.path parm = urlparse.parse_qs(parsed_path.query) From there look at the values of parm, they are primarily what you will be dealing with. Depending on the values there, your server will preform different tasks and deliver different pages back to the client. Make sure you send a [response](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes), a header, and content. These three actions are the only things done in the example above so they should be easy for you to duplicate. The content you send to the client will be HTML. Looks like you are mostly set there. You still need to add an action to your form. and names to your form elements. Don't forget to use the method GET and not POST. And there you have it. I've done your homework for you. By the by, this code works in Python 2.7.2 with only built-in modules. It should work in 2.4.x, but probably not in 3.x.x.
Oh, if only the professor would let us do that. :/
... and make sure to put in your credentials. &lt;tongue-in-cheek&gt;In fact, learning the difference between HTTP and SMTP might help too.&lt;/tongue-in-cheek&gt;
Yeah, he definitely needs Flask because Flask is the only way to deliver HTML and other stuff in Python, then he could use Javascript on the client side with Flask. Flask can run Javascript on the client side as well.
Um....sarcasm?
Now all I have to do is get the form to put someone's name in place of the textbox when they type it and hit submit. aka when I sign up as "Steve" to 1pm, it takes away the textbox and writes "Steve" in its place. Also, you're a wonderful human being. I've been stressing over this assignment all day and that got me way further than I would've in the next 2 hours. 
hear hear. upvotes for everyone! I'll buy the first round!
I'm still confused on how to respond to the form and update the html. I think i'm not allowed to use that module. 
my code is delivering the HTML now, but I can't figure out how to update the html. 
No, no. Don't take my comment serious. I was just being sarcastic.
Too burnt out on coding to understand human emotions (or sarcasm) currently. Also, if you have any idea how to respond to a form submission, I'd love to know, 
The last time I tried, pypm doesn't work with PIL (or all extension with C library), so it is just the same as pip without compiler. If you can purchase ActivePython then use it, otherwise Python is better choice
It seems that you have gotten the code for an extremely basic HTTP server from --angelo. So I'll assume you have that part working. You first need to use python in the server code to interpret the request from the client. It is easiest for this request to be sent using GET. The HTML that is sent to the client from the server must be altered by the server before it is sent. How it is altered depends on the client's request. In the server code you have set up, before the line, "conn.send("HTTP/1.1 200 OK\n\n" + HTML)", you must alter the HTML variable using Python to have the correct names in the correct places. Then in the HTML form, you need to set up an action for the form. This tells the browser what to do when the user hits the submit button. You can read about how to do that [here](http://www.w3schools.com/html/html_forms.asp) (last example). The file listed in the action parameter is what the browser tries to open when the user submits the form. The method parameter specifies how the values in the form are sent to the server. Using GET, the values are put into the URL request. So, if you had: &lt;form action="save" method="GET"&gt; Then when the browser would send a request to the server for the following page: http://localhost:8080/save?val1=xx&amp;val2=yy The server code must be able to process this request. The server must be able to see that the client is requesting a page called save and passing it a set of values. By the way, to name those values, you must use the "name" parameter in your input tags. (Like in the example above) Your server should have code to recognize that when the client is requesting the save page, the given parameters should be saved to the database, or emailed, or whatever action is needed; and then send the HTML to the user again, probably with a message stating that the values were saved. Not to offend, but it seems as if there is something you are not understanding with this project. You might want to contact some other people in that class and ask for help. This project employs a number of different skills at basic levels that it seems like you are having trouble piecing together. My guess is that a classmate or even the teacher could help these piece together better. Like I said though, I'm not trying to offend, we've all been there.
It took me hours of reading today to even start the assignment. This is not a programming class and I have not taken a programming class since freshman year (currently a junior) so I am more than in the dark about this assignment. I have never even seen python before this week. I've been asking questions on the class's discussion forum and no one has had much useful insight about this, most of the class seems in the dark. 
If I'm correct, then this error shows that you're trying to import a module for a different architecture than you're running. This means that you're using PyGame for 32-bit when you're running 64-bit, or vice versa. I also think that this would be better posted at Stack Overflow. 
Just a friendly note, you might get a better response (or at least, better received post) by posting in [/r/learnpython](/r/learnpython)
Not that I don't agree with your point, but your arithmetic is wrong. If we take the "original" speed of python as x, then a 20% speed up gives us 1.2x. A 20% decrease in speed then gives us 0.8(1.2x), or 0.96x.
What problem did you run into on Heroku?
What guide were you following? It should be quite strait-forward. Shoot me an email at kenneth@heroku.com if you'd like.
Will this run on my Apple II/e?
Perhaps when you want to emulate js you just parsed out from some website? Would that work? I don't know :)
For comparison, here's my template, as a [Python script](https://gist.github.com/2375802#file_gcj_template.py) or an [IPython notebook](https://raw.github.com/gist/2375802/044b85eb568cfda4ead624d73b78d4fc22caeb97/gcj_template.ipynb). I went for a simple, non object-oriented approach, and kept everything necessary in one file.
What's the rationale for having parent classes? The template overrides all but the printCases method anyway, and that doesn't seem to be called.
&gt;There are also some profanities. You might want to remove these. the way I feel about this assignment, I might add more.
hmmmm, both this and [cubes](http://databrewery.org/cubes.html) look pretty useful. 
If you develop something in python, an interactive console to test out how something works is needed. Everyone and their mom agrees that ipython is much better than the standard python console. It offers "offers enhanced introspection, additional shell syntax, tab completion and rich history." [Wikipedia](https://en.wikipedia.org/wiki/IPython) It is awesome. Run it with "ipython -pylab" (if you have matplotlib installed) to have all matplotlib stuff for plotting at your fingertips immediately!
I did some quick googling and the best I found for describing a hardware implementation (atleast for people who can't read a hardware description language like VHDL/verilog) is pages 25-26 of this PDF (but I have no idea whether this is how modern CPUs do things, most of what I could find related to FPGA design) http://dspace.thapar.edu:8080/dspace/bitstream/10266/981/1/thesis_60761008.pdf When looking at the flow chart on page 26, just remember the divisions by 2 and squaring can be trivially replaced by bit shifts, for example in C on x86: int number = 4; int n_div_2 = number &gt;&gt; 2; int n_pow_2 = number &lt;&lt; 2; this will means (I think) the algorithm is optimised to reduce the amount of space on a chip used (i.e. number of transistors), but will take a number of clock cycles to complete. I guess there are probably a number of different algorithms, and maybe one day I will use them. But for now I will use the Altera megafunction, and not worry about it.
I recommend [vObject][1]. It has [some documentation and a few examples][2]. import vobject from datetime import datetime, timedelta # Create a basic calendar event event = vobject.newFromBehaviour('vevent') event.add('dtstart').value = datetime.now() event.add('duration').value = timedelta(minutes=5) event.add('summary').value = u"Browse Reddit" event.add('description').value = u"Suggest iCalendar package for Python" event.add('url').value = "http://www.reddit.com/r/Python/comments/s7xij/icalendar_files/" # Create the calendar itself ical = vobject.Calendar() ical.add('x-wr-calname').value = u"My Calendar" ical.add('x-wr-caldesc').value = u"What I do from day to day" # Add the event to our calendar ical.add(event) # Write the calendar to disk with open('example.ics', 'w') as fh: fh.write(ical.serialize()) I used it to create [BBC schedule calendars][3] from JSON data. [1]: http://pypi.python.org/pypi/vobject/ [2]: http://vobject.skyhouseconsulting.com/usage.html [3]: http://reliablybroken.com/guide/ 
What sort of thing do you envisage? The common structure of the problems is pretty simple, and I've been using my template for a couple of years without adding anything to it. I've vaguely thought about an interface that would integrate with the contest server to get the input file and submit the output. I suspect some co-operation from Google would be necessary for that, though.
Indeed I will, I have a long term task to do OLAPish type stuff from our app that's running on appengine. So I have to figure out the whole data export thing too, brewery might do the trick. 
I love PyCharm, but it can really be slow sometimes on my laptop (E-350 AMD Fusion). It's not the occasional slowness that irritates me, it's the fact that there is slight but noticeable lag when typing text. 
[obligatory meme response](http://www.quickmeme.com/meme/3os1zi/)
The main Python modules used are: Pyramid (web framework), SQLAlchemy (DB ORM), Genshi (Templating), Celery (Async Processing), GridFS (MongoDB), PIL (Image Library), Solr (Lucene full-text search), formencode (form validator), redis (Redis driver), retools (Redis caching library).
I would use dictionaries. Iterate through the file character by character, check if a character is in the dictionary. If it isn't: add it. if it is, increment the value.
Alright I'll send an email when I find the steps I took.
I was thinking along similar lines. Maybe an interface to automate getting the problem, setting up the code template, loading the test files, etc. Might be nice to have a 'test' button as well that grabs all test files for the problem and gives me a test report. Its a little bit overkill, but its fun to play around with the code. Its entirely possible that i'll later decide the class hierarchy serves no purpose and remove it. Its just the way I naturally design things.
Okay, I would try to come up with a solution and then ask people what they would do to improve on that solution. I have no interest in writing the code from scratch and that's the only interesting part of the question you've posed. However if you post some code, I get something useful out of reading and trying to debug your code, and you get something out of me responding. Edit: Having said that, [map/reduce](http://ayende.com/blog/4435/map-reduce-a-visual-explanation) Edit Edit: I don't think map/reduce is a good "python" introduction, but it is useful
432 . I just read various books including the mythical man-month anniversary edition and figured out there is no silver bullet. There is no single tool, process, methodology or development which will improve my productivity an order-of-magnitude or 10 fold. We are all ultimately bound by the complexity of the problem we are trying to solve. I should focus on small incremental improvements instead of chasing a pipe dream in a revolutionary way to solve my problems.
IMHO It's still too much work, you have to re-write how functions/structs are defined anyway. My favourite solution is Cython. I write Python and C/C++ at the same time, mixing then as I like, all with python syntax. I still have to define the types of functions, classes, etc. but in most cases it's just copying the headers changing the syntax and doing typedefs or dummy definitions of the weirdest types.
Noticed this and a couple of other oddly out-of-sequence items. *Mastered Django, now learning HTML*. ಠ_ಠ
Yeah, you're totally right. That's what I get for trying to write something while uncaffeinated. Going to try and fix now.
multiprocessing.
In those 2 months that passed since my last message, I've learned that == checks if the values of the two objects are the same, while *is* keyword checks if the two are the same objects. 
Say it with me now, Reddit is not your homework army. 
This explains why I didn't get it during that class :)
Awesome! Great job guys. Downloading it now.
Actually this is perfectly valid, and PostgreSQL actually includes a [specific column type](http://www.postgresql.org/docs/9.0/static/hstore.html) for this kind of thing.
Alright, I'll post it there too, thanks for the help.
Chomsky would be more pragmatic.
But that is for using postgres as a key/value store, whereas the OP wanted to store json in a field because he doesn't like the way django implemented model inheritance. 
Am I the only developer not powered by caffeine?
no
[Wait...](http://www.reddit.com/r/Python/comments/s85gy/evolution_of_a_web_developer_from_php_newbie_to/c4bzij6)
In case performance is unimportant: text = open("inputfile.txt").read() for char in set(text): print "%s is in there %d times." % (char, text.count(char)) Just add sorting, weed out the whitespace, and you are done.
There are dictionaries all over the place. For example, incoming JSON fields can get turned into dictionaries. Few projects - even a bigger one like Django - have the extra programmer time to rewrite all of the components which might receive data from untrusted sources. And most people don't even know this is a problem.
Here's an alternate way to iterating character by character. I have no idea whether it's faster or slower. It's pretty ugly though. I wonder if there's a better way to express that regex. def frequency(string): string = "".join(sorted(list(string.lower()))) l = re.findall("a+|b+|c+|d+|e+|f+|g+|h+|i+|j+|k+|l+|m+|n+|m+|o+|p+|q+|r+|s+|t+|u+|v+|w+|x+|y+|z+", string) d = {sequence[0]:len(sequence) for sequence in l} Edit: It's actually quite a bit faster, about 30%. Edit2: But this is ridiculously slow compared to this identical function taken from rompe's answer: def frequency3(string): return {char:string.count(char) for char in set("".join(string.split()).lower())}
Well, can I have another one? Coz it's more like a Pinterest clone than a Twitter clone. :)
Very cool. Does this work with python3? My cursory searches indicate no.
You're erroneously assuming I didn't realize it was sarcasm and just overlooked it.
That's what I initially thought. I mean what's wrong with stuffing attributes into one column?
Ah I see! Yea, instead of a "Very Bad Thing", we treat that as a "Sometimes Useful Thing With Tradeoffs". 
Though cannot find the exact source, Guido van Rossum said several times to prefer list comprehensions and generator expressions than `map()` and `filter()`. Is there anyone knows the source?
pun on virtual environment. if you don't use them you should, google virtualenv.
Honestly? Not really. It will take you some time before you get it; you need to come to a problem that requires OO for a solution before you can really grasp the concept. At least, that's what it took for me.
In fact, here's the code for a basic pyglet program that displays a 3d cube that can be rotated. From here it's just a matter of creating the data that represents your object (a humanoid figure, for example) and rendering it with OpenGL. from pyglet.window import * from pyglet.gl import * global xRot global yRot xRot = 0.0 yRot = 0.0 win = Window(fullscreen=False, visible=False, resizable=True) points = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1] squares = [0, 1, 3, 2, 2, 3, 7, 6, 6, 7, 4, 5, 4, 5, 1, 0, 5, 7, 3, 1, 0, 2, 6, 4] cubeBatch = pyglet.graphics.Batch() cubeBatch.add_indexed(len(points)/3, GL_QUADS, None, squares, ('v3i', points)) glClearColor(0.1, 0.2, 0.3, 0) glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) @win.event def on_draw(): glClear(GL_COLOR_BUFFER_BIT) glMatrixMode(GL_MODELVIEW) glLoadIdentity() glRotatef(xRot, 1, 0, 0) glRotatef(yRot, 0, 1, 0) cubeBatch.draw() glMatrixMode(GL_PROJECTION) glLoadIdentity() glOrtho(-2, 2, -2, 2, -2, 2) @win.event def on_mouse_drag(x, y, dx, dy, buttons, modifiers): global xRot global yRot if buttons &amp; mouse.LEFT: xRot += dy yRot += dx win.set_visible() pyglet.app.run()
Pygame is available only for 32-bit architectures. Try installing 32-bit python. Also, under Eclipse &gt; Preferences &gt; PyDev &gt; Interpreter - Python &gt; Libraries Add pygame to your libraries list as well as a forced builtin.
I've been using Pycharm for a couple of months, a lot of productive features in it.
What sort of data are you sharing between threads? I should think any reasonably complicated threaded program evolves to the point where it locks down memory that is shared between threads to the point that the API looks like IPC anyway. e.g. Python's Queue module and multiprocessing Queues. It becomes moot whether you're in process or out of process so you may as well be out of process. Unless you're developing on a console; which isn't in python so that's moot as well.
virtualenvs have always been more trouble than help for me. Not once have I had a conflict between different versions of a Python library, but often I've had to update a library (or an interpreter) multiple times because of all the copies scattered across virtualenvs. I don't agree with the widely held wisdom that everybody should be using them.
You don't need to serialize it. I'm saying the interface can look like one used in threading but be one used in multiprocessing. e.g. these resources which you lock when reading and writing can look like whatever structure you need but be implemented in terms of a mmap'd chunk. Queues were one example of an inter thread communication which can also be used for inter process communication.
What are you talking about? You are being helped in r/learnpython just fine.
Grey text on a white background gives me a headache, can you bump it up to like #1D1D1D or something?
It's sort of an organizing tool for me: Usually when I work on projects they'll get bigger and bigger and I refer to the requirements.txt file to see what I have currently installed and pip freeze to check out what is really installed (all dependencies). But I know my working environment is not everyone's; I was skeptical about the need for virtualenv and switched a couple months ago. Easy enough to set up and maintain, so it's just part of my workflow now. 
A personal license is £ 54 at the moment, which is cheap for IDEs of this quality. They always have special offers on that license, I've bought the 2.0 release (which entitles me to a year of free upgrades) when it was about £ 35 and it's the best money I've spent in 2011 -- it's basically one meal out, and it makes quite a difference in my projects in terms of productivity.
I think as a beginner, it is actually more beneficial to code simple algorithms like this yourself. For learning purposes, of course.
I'm curious: Am I the only developer who finds almost any ORM or similar database abstraction more trouble than it's worth? I'm a basics-first kind of guy: I speak HTML, CSS, JavaScript, HTTP, CGI, and so on. Still, I'll happily use high-level tools that build on the low-level foundations instead of coding the raw version, if that makes life easier: using a CSS preprocessor, writing a WSGI application, and so on. But in all my life, I have *never* found a database abstraction layer or ORM that I actually liked, and while I have tried to use several different ones of varying levels of power on some significant projects, I have always abandoned them within a few days and reverted to designing a clean database schema that is fully under my control and writing my own functions to wrap up the necessary SQL queries. This never seems to cause me any long-term maintenance problems. I get good performance. Since you can do most things with reasonably standardised SQL these days, there's not a lot of downside in terms of portability either. And most telling of all, for the small-to-medium-sized projects I tend to work on, it actually seems to take less time and effort to design a schema and write a handful of SQL wrapper functions that do exactly what my project needs than it does to integrate and conform to an ORM. Then again, a pretty large chunk of the web development world seems to disagree with me on this one, so what am I missing?
The point about mimicking development environments is valid. I think the importance of having different versions of packages installed is often overstated, though - 99% of packages will hopefully be compatible with the recent packages installed systemwide. And updating five separate copies of a package is annoying. Installing fresh copies of everything also makes less sense if you're using big compiled packages like numpy or PyQt4 than if the dependencies are pure python. I use virtualenvs for testing packages I'm working on, but typically with the `--system-site-packages` option, to avoid reinstalling numpy from source.
The trouble is that in practice the lack of deep integration between distro-level package management and virtualenv creates a significant maintenance headache. The moment the "normal" way to set up a useful Python package is via apt-get or similar, efforts to keep manual installation of that package simple and well-documented naturally become less of a priority, but that is usually exactly what you need to do if you want to install the package within a virtualenv rather than system-wide.
Does it have any advantages over VTK?
How do you implement the callbacks with this? It doesn't explain that part at all.
I don't see the point; you create a section of memory that is shared between processes, which you still need to lock in some way, so now you have all the downsides of threads (manual locking semantics) and all the downsides of processes (extra memory use, virtually impossible to debug effectively, extra effort to share data). So, we don't do that.
At first glance, I was pretty excited about this. We're rolling an official set of Python bindings for our API for [Review Board](http://www.reviewboard.org/), and I thought this would be an excellent backing. A few things shot that down, though. So, some hopefully constructive criticisms/things to consider: * No support for async callbacks, as far as I can tell. Synchronous functions are fine if you just want to automate something with a little script, but use this in a GUI or something like Python Tornado and you'll have blocking issues as soon as the server gets bogged down or the API has to generate some data that fell out of cache. * Not really REST. That's fine, but call it what it is, because this isn't really suitable for a true REST API. * Builds URLs, doesn't follow links. This is part of the "not really REST." Our API links resources together and clients are expected to follow those links. I don't see a mechanism to do that here. (Probably could roll my own, but then I lose most of the advantage of Slumber). * No Python 2.4/2.5 support. I talked to the "requests" module author and he confirmed that it's supporting only 2.6+. This might be fine for a lot of people, but at least wasn't fine for us (too many customers at large companies using RHEL/CentOS boxes with older versions of Python for their servers). * No support for per-request mimetypes? I don't see it at least. That's important in some APIs. * No support for getting the mimetype of a response? Again, I don't see it. If I have a resource returning a vendor-specific mimetype for that resource, I want to know it so I can know what I'm looking at (for wrapping purposes), without knowing the URL (since URLs can change and links should be followed in REST). Slumber seems great for basic HTTP access of serialized data. It's not REST, though, by any stretch of the imagination, which is a shame because that would be pretty great. That's the easiest thing to fix, though. Just don't say it's for REST :) (P.S., "REST", not "ReST" in the docs. "ReST" is "ReStructured Text")
Thanks for the example. I just tried it out and it worked perfectly.
I've never used VTK (looks cool though, will probably start playing around with it) but I chose pyglet because I wanted to learn OpenGL and the documentation for it is really well done. I also needed to be able to create a tool that was very specific for our research pretty quickly, so it was the obvious choice for me.
Project Euler is a collection of small but interesting programming tasks.
Cool, thanks!
I prefer to use synchronous functions with gevent/eventlet monkeypatching than async callbacks. It is more robust. It can be composite with ordinary exception handling (not error callbacks). It can be easily looped (not recursions).
So what? Different people code in different ways with different trade-offs. One of the things that holds python back is its weird cult like desire to conform.
Github is popular because it's good. Setup is simple (on OSX, they even have a self-contained app), use is simple. Compare that to anything else, Launchpad, Gitorious, Bitbucket, Sourceforge or Google code and it's so immensely obvious how much better their usability is. Sure, git is good - but it's by no means the reason github is popular. Mercurial is (IMO) on par with git in terms of usability and function (although each has their caveats - git's is likely the amalgamation of multiple languages make it more hacked together than other systems). BZR is not git or mercurial - it's actually rather bad and very slow (as this article discusses). BZR is only even mentioned because Canonical wanted to control the source of their DVCS when git and mercurial were fine choices. BZR was and is a continual mistake. 
Do you know if there is a way to tie django to an existing user base?
Sure, that would be fairly easy. Create a backend that talks to your SQL server without using a ORM (or maybe using an API or whatever or raw sql statements) and return a users class that you define, then have a .save() method that commits any changes to the user back to the database. That part is optional however.
But the same goes for Github - there's a lot of people using it, and they must be sucking up a lot of bandwidth. Someone mentioned in the comments that if you tell bzr your launchpad username, it can switch to a much faster protocol. I guess that's what most people using launchpad see.
A very simple project: Implement a 'hangman' game. You can add as much to it as you like: Allow any combination of computer-human, human-computer, human-human or even computer-computer. Try to make the interface entirely foolproof - ie, if the user says there are 'exit(0)' letters in their word, don't blow up. You can do a lot of fun things with interfaces. Try to find a way to draw the hangman, ASCII art or otherwise. Have the computer get increasingly annoyed as you continue to answer invalidly, for example. Have it accept as a wide a range of words or phrases as possible, such as 'indoubitably' for yes. Also try to have the computer always guess the most likely letter for the situation. To that end you will need a dictionary. If you are using Mac, you can find a plaintext dictionary in "/usr/share/dict/words" or sometimes "/usr/dict/words". Otherwise, there are many around. A manageably small one [here](http://lastbit.com/dict.asp). You can make even the simplest projects as complex as you like.
Well, github must be provisioned better, because cloning a large repo happens at about 630 kB/s as opposed to 85 kB/s. And "large" for git usually doesn't mean multiple gigabytes -- the current git repo for the Linux kernel (going back to about 7 years of changes, so not the complete ancient history) is only about 570 MB.
I totally recommend django. Check out r/django and r/webdev too, they're some pretty cool folks.
His hypothetical tool should have told him that `with` is available from the future in 2.5 and that decorators were added in 2.4…
[Here's the repository](https://bitbucket.org/smalone/blatherblog/overview). Please feel free to leave constructive criticism, this was done in a weekend and I do have some concerns about certain elements of the code (try to guess what they are :D). Update: Because I'm apparently insane, I kept coding after I posted this. New things not shown in old screenshots include: * New green buttons! * Smoother, white-backed style! * Customisable menu links! * Other crap I'm about to pull out of my ass! 
&gt; It's not my connection, I'm on an otherwise idle ADSL2 connection, that syncs about 14Mbps. i.e. capable of downloads of up 1.4 megabytes per second, not the 50-70kB/s that bzr is dawdling along at. If I clone something from Github, I get speeds of 60-80 kb/s at home, and I have a 20Mbps cable connection. Since it obviously has nothing to do with my internet connection nor Github's infrastruture, "git is so slow" and I should write a rant on my blog. 
Currently installing hg-git so I can move to Github. Edit: The combination of Windows, Python 3 and my own inexperience with Git means that for the time being, BlatherBlog is Bitbucket-only.
&gt; `from bottle import *` &amp;#3232;\_&amp;#3232;
Looks good! You might want to split app.py into a smaller chunks (Post/Blog classes in their own file). I haven't looked through all the code, but having the Blog class doesn't really make sense to me (unless you are doing multi-blog engine). Also, where do you add new posts (looks like you go to /edit but that isn't very intuitive)? Writing a blog in a new language is always a good exercise.
There's a link to "/new" in the header menu, which gives you a new post page. 
 import bottle as b
I don't know why someone downvoted you. In my opinion the special datatypes in collections shouldn't be used until you fully grok the standard types.
`b.`
that?