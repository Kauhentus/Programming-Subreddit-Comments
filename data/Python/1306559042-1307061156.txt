For commercial people, they don't want the code to be stolen. They poured money into the development of the product and they don't like the idea that someone else would just take it. Some commercial people I've met thinks that the source code is the "secret sauce" and should be kept under lock and key.
One of the problems is that Ruby is better than basically everything else at making DSLs. It is one of Python's great strengths that it has very regular syntax, this is unhelpful when you want something like Chef recipes (someone already linked to kokki below, you can judge for yourself if it is as readable). That said, I do have a full Chef server implementation in Python (using Django) called [Commis](https://github.com/coderanger/commis) and an API client library for interacting with a Chef server called [PyChef](https://github.com/coderanger/pychef). I'm always looking for ways to make Chef more accessible to the rest of us Python folks, so if you have ideas (or just complaints) please let me know! *Full disclosure: I work for Opscode, the creators of Chef, though I have been a Python developer for far longer*
Just echoing my above links for [Commis](https://github.com/coderanger/commis) and [PyChef](https://github.com/coderanger/pychef). I built them partially to address this exact issue :-)
If use the ORM, it does the needed escaping for you. If you use things like rawquerysets, then you can shoot yourself in the foot if you aren't careful.
Yeah we use Praat in the class and I know it has scripting capabilities. Like I said, I want to pretty much come up with something myself and see where I can get. I took a look at the Praat source code and my amateur-ness really shines through when I'm staring at a bunch of function definitions that reference other files and so on. I've only ever worked with single-file programs that maybe have an auxiliary text file for reading/writing. Source code for even a medium-small sized program is way overwhelming for me at this point. That said, it's not really about getting anything extremely accurate or even usable. It's just for the experience. I'm a mechanical engineering major anyway, just taking a minor in linguistics because it's interesting to me. I realize it's not necessarily the absolute values of F1 and F2 that determine the vowel, but their relative values. Good point. I would like to get around having to "teach" the program for each individual that might use it, but I might just have to tune it to my voice. This whole project is something I've been thinking about for a while but I have about 2 weeks to actually throw something together. My teacher is ok with just turning in a "progress report" as long as I mention what I want to keep working on. I could be mistaken but I think the Fourier transform is about the only way to get frequency information from a waveform. Edit: ok it's not the only one (see [Goertzel algorithm](http://en.wikipedia.org/wiki/Goertzel_algorithm)) but I think it's at least the most popular.
I just use Puppet. I am not a huge ruby fan, but it's not like you have to actually *write* ruby; it has its own DSL. A python-based tool that I really do like is fabric. It's imperative rather than declarative like puppet/chef/cfengine and projects in it end up being a sorta gross mish-mash of python and shell scripts, but it allows you to script complicated things quickly. I use puppet to manage almost all software, but for our primary application that isn't nicely packaged and things change all the time I use fabric.
[Spoken Language Processing](http://www.amazon.com/dp/0130226165) covers everything but the kitchen sink. 
Matplotlib has [specgram](http://matplotlib.sourceforge.net/api/pyplot_api.html#matplotlib.pyplot.specgram) for making spectrograms. They have an [example](http://matplotlib.sourceforge.net/plot_directive/mpl_examples/pylab_examples/specgram_demo.py) plotting the spectrogram of a chirp. SciPy's [Signal Processing package](http://docs.scipy.org/doc/scipy/reference/signal.html) has tools for digital filtering, correlation, and convolution if you need to preprocess the samples or estimate the pitch. 
Interesting, which is faster?
Decorator seems to be faster: https://gist.github.com/996744
Perhaps it's simpler in the long run to parameterize the decorator: import logging logging.basicConfig(level=logging.INFO) class MethodReplace: def __init__(self, attr, newfunc): self.attr = attr self.newfunc = newfunc def __call__(self, cls): oldfunc = getattr(cls, self.attr) def wrapped(*args, **kwargs): self.newfunc(*args, **kwargs) return oldfunc(*args, **kwargs) wrapped.__name__ = self.attr + "_wrapper" setattr(cls, self.attr, wrapped) return cls def get_logger(cls_name, fun_name): def logger(self, *args, **kwargs): ar = tuple(str(v) for v in args) kw = tuple(k + '=' + str(v) for k,v in kwargs.items()) msg = "Calling {}.{}({})".format( cls_name, fun_name, ", ".join(ar + kw)) logging.info(msg) return logger @MethodReplace('__getitem__', get_logger('LoggingList', '__getitem__')) @MethodReplace('__setitem__', get_logger('LoggingList', '__setitem__')) class LoggingList(list): pass &gt;&gt;&gt; data = LoggingList([1,2,3]) &gt;&gt;&gt; data[0] = 0 INFO:root:Calling LoggingList.__setitem__(0, 0) &gt;&gt;&gt; data[0] INFO:root:Calling LoggingList.__getitem__(0) 0 &gt;&gt;&gt; data.__setitem__ &lt;bound method LoggingList.__setitem___wrapper of [0, 2, 3]&gt; 
Saw this yesterday: http://yaybu.com/
 mydict = {'light red': '#FF5555', 'dark red': '#550000', 'blue': '#0000FF', 'red': '#FF0000', 'dark blue': '#000055'} def searchdict(searchterm): for i in mydict: #this is where you went wrong, you were assigning searchterm to entries in the dict if searchterm in i or searchterm in mydict[i]: print "%s : %s contains '%s'." % (i, mydict[i], searchterm) EDIT: On second thoughts, this is not the right way to do it- you should use an iterator tool or something else. I was just fixing your code. EDIT^2: Grammar 
The second function you listed will basically just print out the entire dictionary for each key the dictionary contains. The loop and if statement basically boil down to: "for each thing X in this dictionary, is X a thing in this dictionary?" Probably not what you intended. :P When you write for x in some_dictionary: what you are asking Python to do is iterate over all the *keys* x in the dictionary. Similarly, if x in some_dictionary: checks whether the value of *x* is a key in the dictionary. Now, in your loop, the condition checked by the if statement is ALWAYS true: def search_colours(searchterm): for searchterm in colours: # we just got 'searchterm' from the dict, if searchterm in colours: # so of course it's in the dict print colours, "contains", searchterm The thing to realize is that the variable name you use in the for loop introduces a new binding; the effective meaning is: "loop over all the keys in colours, and call each one 'searchterm'." That use of 'searchterm' as the loop variable *replaces* your function parameter 'searchterm.' [Side note: for loops in Python don't introduce new scopes as they do in other languages, so your function's argument 'searchterm' is effectively *overwritten* and cannot be accessed after the loop runs. Insidious!] I'm guessing what you want to do is check whether each *key* contains the term you're looking for. Just switch around a couple of the names and you're almost there: def search_colours(searchterm): for key in colours: # examine every key in the dict if searchterm in key: # does the key contain the term? print key, "contains", searchterm Now, if you want to return all the components of the dictionary whose keys are matched by the search term, you have a number of options. Do you want to return a dictionary containing the matching mappings, or a list of key-value pairs, or something else? If a list of key-value pairs is good enough, you can use a [list comprehension](http://docs.python.org/tutorial/datastructures.html#list-comprehensions): def search_colours(searchterm): return [(k,v) for (k,v) in colours.items() if searchterm in k] List comprehensions are a very neat and concise way of expressing lots of things, so I recommend checking them out. And if you want those values returned as a dictionary, dict() can create a dictionary from a list of key-value pairs quite easily. 
A problem with using `val or "something"` is that a valid value might be False, such as the following: &gt;&gt;&gt; val = 0 &gt;&gt;&gt; val = locals().get("val", "") or 1 &gt;&gt;&gt; val 1 In this case you can use a conditional expression: Edit: &gt;&gt;&gt; val = 0 &gt;&gt;&gt; val = val if "val" in vars() else 1 &gt;&gt;&gt; val 0 &gt;&gt;&gt; del val &gt;&gt;&gt; val = val if "val" in vars() else 1 &gt;&gt;&gt; val 1 The test expression gets evaluated first, avoiding a NameError in case val isn't defined.
ya, i know this works, but these are just too long to do too often. I wanted some really shorter version.
This was incredibly helpful, if only I had more upvotes to give! Thank you so much.
What I'm doing is not dynamic at all, it's purely algorithmic but not numerical. I use lots of tuples (chart items, edges, probabilities etc.) and ShedSkin can't handle them because it requires them to be homogenic (all the same type). I could keep on rewriting the code until ShedSkin is satisfied, but it's uncertain that will work and if it will have a payoff -- ShedSkin appears to be a plug &amp; pray solution while Cython requires/allows manual tweaking to work well. The alternative is replacing the tuples with structs in Cython, I think that's the safe bet (short of handcoding it in C++ which I would have to learn first).
I'm senior architect for [http://www.woome.com](http://www.woome.com), [http://shufflepeople.com](http://shufflepeople.com), and [http://monsterchat.com](http://monsterchat.com). They're all python/django apps, doing realtime video and messaging between million of users. Lots of fun and some really interesting scaling challenges.
Just so you know, your last two links won't work because you have a comma and a fullstop including in the link. 
Wait. &gt;&gt;&gt; val = locals().get("val", "") or "something to cache" is identical to &gt;&gt;&gt; val = locals().get("val", "something to cache") Isn't it? There's no point in defaulting to a falsy value to fallback to a default. EDIT: Except for the bug with falsy values in your original.
happy reddit birthday! Time to post some gratuitous animal pics ;P 
I wrote most of [Terminator](http://www.tenshu.net/terminator/) a tiling terminal emulator for UNIX desktops. It was a lot of fun and taught me a huge amount about python and programming in general, even if it's not the most exciting thing ever :)
Well, now I feel silly, but my best Python project so far is [a pretty simple, kind of buggy 2D platformer](https://github.com/tsmacdonald/Dragon-Platformer) written with PyGame.
Ah, yes, it sounds like you'd be better suited by Cython indeed... I love the fact that there are so many choices available.
Just so you know, [fully qualified domain names](http://en.wikipedia.org/wiki/Fully_qualified_domain_name) end with a dot, and so this link [google.com.](http://google.com./) does in fact work.
Although very much WIP at the moment, I have been working on an AMQP home automation framework: http://github.com/jingleman/MHub 
What are your thoughts on using Tornado instead?
Cool. I love Terminator. Cheers for making it.
Plus your first link did work, which also has a comma. Good to know.
I'm currently working on a window manager written in Python called Pyndow. It's a work-in-progress, but it's goal is to get the combination of floating, tiling and multi-monitor support *right*. (All window managers that I know of fail in combining all three, IMO.)
I'm currently developing a little python app that interfaces with XBMC, figures out what episodes are missing from your tv collection, searches some torrent sites for them, and adds them to your torrent client. I'm calling it "spiderBro", in honour of the meme I love so much :P 
Looks neat! Although you can achieve a lot of cool tiling stuff with screen, it's not nearly as flexible... And it always loses your tiled setup when you detach the screen. Not exactly on topic, but perhaps this is a good place to ask - anyone know how to keep a screen's multiple tiles when you detach and reattach? 
I wrote the analysis portion of my phd thesis.
http://sickbeard.com/
Catch `NameError`: try: val except NameError: val = "something to cache"
TIL, thanks :)
Wow, thanks for Terminator, it's the best one! Could you please add a hotkey for renaming current tab (and returning focus to terminal)? :-D Thanks.
I wrote a web application server (Snakelets) with pluggable applications and a blog app on top of it. This was started before any of the WSGI stuff took off. It still runs my own website but I've not been developing it anymore for a couple of years. I learned a lot from it. I also wrote [Pyro](http://pypi.python.org/pypi/Pyro4/) , a remote method calling library. I think this would qualify as my most interesting project because I'm still developing on that one occasionally, even though I started that project way back in 1998.
my first semi-serious for fun python interface to text based lcd displays: https://github.com/anupamk/hd44780
I wrote [PyQuante](http://pyquante.sf.net), a quantum chemistry suite written in Python. For the last 20 years, the trend in molecular quantum mechanics has been to use large codes for electronic structure theory evaluation, which has kept graduate students from really understanding the methods they're applying. I was amazed how little quantum chemistry I knew, and I had a PhD from Caltech. PyQuante was a great way for me to work through some of the classic papers in the field, and ultimately grew to be a pretty good package. It's not yet at the point where it can replace the big codes, but I'm not done with it either.
Anyone develop any games beyond little tetris games and simple 2D sprites? Even if it's 2D sprites, something with particle effects?
I'm developing a thick desktop application that helps you create instruction books for your 3D LEGO models: [http://code.google.com/p/lic/](http://code.google.com/p/lic/), [screenshots](http://bugeyedmonkeys.com/lic_info/screenshots/)
I remember this question from a while back and I dont think there's any way to do it directly using screen. If that is important to you, it's probably best to look at alternative program. There are many who believe that popular replacements like tmux are more powerful and IIRC, can save splits. 
I wrote an app to help me review exercises on a tablet: From a pdf and a CSV file containing the students id's: 1. It prints a personal copy for each student with his name, the text of the exercise and a datamatrix containing his id. 2. After the examination, I scan all the pages into a big pdf and move it to my iPad. 3. I review the exercises on it, make annotations, and put another *annotation with the mark* on top of the datamatrix. 4. Feed the annotated pdf to the app again. It will: * Make a CSV file with the students markings; * Add an outline to the annotated pdf indexing the pages to the students names, so you could easily move to point where the exercise for a concrete student begins; * Optionally, mail the annotated pages to each student.
What's wrong with val = None ... if val is None: val = calculate_val() (or `val = val or calculate_val()` if you like to live dangerously)? Or, if you really want to use `"something to cache"` as a value (i.e. not a result of some expensive calculation), why not write `val = "something to cache"`? What are you trying to do, exactly?
AFAIK you can set the title in the $PS1 variable.
Thanks for Terminator man :-)
a multithreaded reddit indexer. It checks /r/worldnews every 5 minutes, grabs the headlines, votes, and total comments and other information, stores it to a json file while another thread grabs json files and mines them with opencalais, then stores it into solr and postgresql. with this information I can generate trends by seeing which topics remain hot topics, how long they stay there for, voting activity, comment activity, etc. It was neat seeing topics like Environment and Natural Disasters suddenly spike, replacing topics like Politics when the japan earthquake hit while the libyan revolution was getting into full swing. edit: the reason for the two threads was because opencalais often says it's too busy so I have to retry which means that sometimes, the json files pool up.
Rolling my own is more fun. Sickbeard also uses rss feeds, which I don't like as the only one I've used (eztv rss) has gone down for several weeks at a time, and it doesn't use my xbmc library to get the list of shows and missing episodes, you need to manually set up shows. 
How do they fail? Never noticed this.
Dude, terminator is my main shell whenever I'm on my Linux box. thank you so much for an amazing program
I wrote a wxWidgets app that split a VirtualBox virtual display into individual frames.
Very cool!
I'm currently writing a mumble music bot. It sits in a specific channel and allows people to whisper it "play" and it will whisper music to them so that only they can hear it and they can hear it from any channel theyre in (as long as they haven't muted their sound). Right now it only works with mp3s (but hey it works!) and it's a huge WIP. It's the biggest thing I've written in Python though.
I made a robot with it once. Based on a 6-wheeled robot chassis, I threw a single-board Linux computer and the guts of a Wi-Fi router on it, running Python to receive commands and push them out the serial port to the motor controllers. On the other end, I used pygame to read a USB Playstation 2 controller and send commands to the robot. There was also a webcam connected to the wireless router, so you would use your laptop as a sort of remote command center. It was a pretty awesome project.
Fuck, I love Terminator, thanks for making it :)
PLEASE! :)
Robot you say? Awesome! Have an upvote sir :)
Deep learning techniques ( in particular Restricted Boltzmann Machines ) were a large part of the algorithm that won the Netflix challenge. They also require quite a bit of knowledge to get up and running compared to SVM and ANNs.
This looks awesome, dude! Makes me want to go back an play with my legos :o
Oops, thanks, fixed.
That is my default terminal on all my machine. Many many thanks! 
So did you talk with jacobian at Pycon? What happened?
that sounds really interesting! do you plan on open sourcing it or making it public in some other way?
\*Checks if poster is Phd_in_everything\*
Nice one, thanks! 
The programming wasn't particularly sophisticated, but the project was always exciting: [on the street](http://www.youtube.com/watch?v=Yt5wvaMwLJ4) - [pulse](http://www.youtube.com/watch?v=m2xcacaYuEE) - [burn](http://i.imgur.com/x1uzy.jpg) Laptop controller for pyro system. Play it like a keyboard, store patterns, etc. 
I'm curious what information you could spare (or a source for it) about using python to program an arduino. I recently got a duemilanove and would like to python it. 
LOL... We shook our hands. I have a lot of respect for his opinion. He is right that web2py design choices sets us apart from the rest of community. We dare to be different and we consider it a strength. There is not much for us to agree on. I think the ball is in the hand of the users.
A python optimiser. Turns out because of python's overhead in performing an operation, basic optimisation such as propagation and strength reduction end up slower. My findings show that only refactoring algorithms such as code hoisting and invariance checking benefit, if even only slightly. This is probably why pypy went as a separate interpreter for speed gains.
I wrote [an app](http://www.tweethit.com) that finds out the most popular Amazon products on Twitter. Source is [here](https://github.com/ocanbascil/TweetHit).
I wrote a script that lowercased improperly capitalized words.
That's weird. I'm working on something [very similar](http://i.imgur.com/qUFb9.png). (That code is *very much* a work in progress). Is your code on github or similar?
Tornado's an interesting app server. I've written [a hacked-up web stack](https://github.com/iamseb/togrog) with it and MongoDB that has full async db support (so the app server doesn't block on db io). For async applications it's really useful, but I personally don't like callback-style asynchronous code. As a company our particular expertise is based around Spawning and Eventlet for asynchrony, so we've written our own asynchronous stack based around those tools, with what I think is a cleaner blocking-style for async processing. Quite a lot of our code is released on github, and I encourage people to take a look: https://github.com/woome/ 
I did a 'rigorous' performance analysis of 5 approaches (Win32 Python 3.2): from timeit import timeit tests = ( """ for x in range(1&lt;&lt;21): val = vars().get('val', 1) val """, """ for x in range(1&lt;&lt;21): val = val if 'val' in vars() else 1 val """, """ for x in range(1&lt;&lt;21): if 'val' not in vars(): val = 1 val """, """ val = None for x in range(1&lt;&lt;21): if val is None: val = 1 val """, """ for x in range(1&lt;&lt;21): try: val except NameError: val = 1 val """) results = [timeit(t, number=1) for t in tests] slowest = max(*results) results = sorted(((n, r / slowest) for n, r in enumerate(results)), key=lambda x: x[1]) for n, r in results: print("test {}: {:.2f}".format(n, r)) Output: test 4: 0.12 test 3: 0.20 test 2: 0.78 test 1: 0.80 test 0: 1.00 Searching `locals` is expensive. The conditional expression turns out to be a bit faster than using `get` with a default value, and it's marginally faster to only do the assignment when val is undefined. For me it looks like the best value in terms of performance and readability is assigning a default value of None. That said, and as expected (EAFP), the test using exceptions is the fastest. 
i wrote the external crawler for [raptr.com](http://raptr.com) using [SEDA](http://en.wikipedia.org/wiki/Staged_event-driven_architecture) which is used to track almost realtime status of your xbox activity. it uses memory queues for inter-process staging, and network queues for receiving commands from the rest of the application as well as posting results back to the datastore.
Thanks! I use terminator every day. Didn't know it was written in python. As it should be I guess.
Thanks. I was just being curious. As for me personally, I use both Django and web2py. I use web2py to prototype my ideas. It's a great framework when you are the lone gunman, but I am sure it would be great for teams too. Loving the shiny new bpython shell by the way.
I would always assume decorators would be faster, considering it's one less function call (`super`). Correct me if I'm wrong though. 
thanks all for chiming in your opinions, I like them all(almost). Thanks [eryksun] for the analysis(http://www.reddit.com/user/eryksun) on performance. Atleast I have a good benchmark to work against
like the analysis, will try to make do with one of the solutions here.
no, not right now. It IS on my svn server, but it is not open to the public right now. It's also not running right now, so I'm not collecting data. There are some error handling things I have to do to make sure I never lose data. Once I get everything all said and done, then I will release it.
once its finished and mining data, yes. It's all in svn but svn is not public for now. But yeah, I do plan on open sourcing it.
Cool! I like this tutorial. I just bought one.
What was your thesis on?
&gt; I pointed out that if their competitors have the know-how to decompile, they might as well make a clone from scratch. Not really. A competitor with sufficient skill can decompile someone else's code and extract the most useful parts to give themselves a big advantage in development time. The industry is full of people with similar levels of capability to yourself. So what you don't want is to spend 2 years on a product that your competitor can potentially copy in a few months by looking at your work, leaving them time and money to spend on beating you in other areas.
Dude, this has always been my fucking favorite terminal ;) Every time I install a clean Ubuntu, first thing I do is download Terminator ;)
One thing you might do is use Celery (or another distributed tasker) to manage that kind of shit. Also, Celery is cool as fuck.
I've actually always been of this mindset. You can always use something someone else has made, but the interesting part comes when you build it exactly as you want it to work ;)
Why Python? I don't really know what's required of a window manager, but I imagine python might be too slow for the job (especially with compositing)?
Nice try windows.
The important thing is not the symbols used in the format string, but the method used for replacing those symbols with the arguments. The first example given by the original poster uses Python's string interpolation which knows nothing about SQL or the database connection, and so can't detect malicious or malformed text. The second example uses functionality within .execute() which can ensure the arguments are quoted properly for SQL usage, and can perhaps also perform encoding-specific stuff for the connection being used.
And would be [0, 0, 0, 1], but you're right that I'm wrong. In the heat of the moment, I messed up :) Correct is of course out[0, 1, 1, 0]
i just found out about terminator today. i had a change i wanted to make, ended up asking about it in IRC and figuring out i needed to patch the program myself. big relief that it was python! i changed and repackaged it quickly, and now it's what i use.
I'm working on one that I posted a few weeks ago. Not ready for download yet though or I'd provide a link.
I made a Python-based real-time MIDI player version of my [Piano Spiral](http://www.youtube.com/watch?v=FWmTg3bHwuw) visualization. It's still buggy as hell, though, so I never released it.
You could always hack on the existing project, and submit patches so it becomes more useful :P
I wrote [Shodan](http://www.shodanhq.com) a "Google for Hackers". It indexes meta-data of computers (services, hostname, city, country, lat/lon etc.) and lets people search for Internet devices based on those criteria. It's almost exclusively written in Python, and I'm looking to port the few remaining C portions over to Python very soon as well.
You make a good point, and in future I will - I'm using this as a learning experience to get my python skills up to scratch (I'm a c++ programmer by trade, and none of the stuff I do in work goes near web scraping, json etc). One thing I definitely *will* be doing is having a look through the source code of programs like sickbeard and couchpotato to get a better feel for how they do things like validate torrents and incorporate those ideas in my own code (open source for the fucking win). They are both big, multithreaded programs using several frameworks I don't know my way around, and at the moment its a lot easier and more fun to just hack away on my own code. I have vague plans to release my program as an xbmc plugin once xbmc supports python 2.6 (the upcoming release, Eden, is going to do this). Maybe after I have a bit more experience under my belt I'll try to contribute to sickbeard or couchpotato :)
You learn *so much* by doing that as well. Things I've learned in the last month from doing this project include: * Python has a global logging module I didn't know about, and its easy to use and full-featured * It also has options parsers for config files and command line params that are also easy to use * It has awesome support for sqlite and mysql, which made coding a db_manager singleton dead easy * Git is a lot nicer for source control than something like clearcase, which I have to use in work :p * You can remote control most torrent clients via json these days * My general aptitude at vim and regular expressions has increased tenfold from coding this project Building things yourself is a lot of fun ;)
fixed it thanks for the help 
Just tried this out, its awesome. I may switch from screen to this...
Like many other responders to this comment, I also use Terminator as my primary shell ([obligatory screenshot](http://i.imgur.com/uzh3c.png)). Thanks for Terminator. I didn't see a donation link on your site. Do you accept donations through PayPal or Flattr or anything like that? I would like to show my gratitude and also help fund further development of Terminator.
Another fan and everyday user of Terminator here, didn't know it was made with Python. Thanks!
I would just like to say a massive THANKYOU for Terminator! This is the first program I install on any Linux desktop workstation and I spend probably 75% of my work week staring at Terminator - really great work!
This *might* be the wrong place to evangelize, but if you use Vim plugins, you really ought to be using [Vundle](https://github.com/gmarik/vundle) to manage them. I switched from Pathogen recently and I won't go back.
Python supports C extensions, so it can be fast when it needs to. Hinting C types can help speed it up à la Cython, too, but I've never used that, personally. I have heard a great deal of good things about Shedskin, however.
I used wxPython to create a gui to communicate with a temperature controller board that I designed myself. I use it to brew beer.
As a long time perl user I recently tried python on a small project. My disappointments with python were: 1. No CPAN, dear god it sucks without it. And the multitude of incompatible versions of python and libraries. Even with easy_install... 2. Outputting data was horribly difficult in comparison to perl. I was using it to write yet more scripts in an arcane language nobody else uses. I ended up wrapping the python script with a perl script to do the transformation to the third langauge. (If it matters I was building 'routing tables' using networkx)
I wrote the python portion of the [libfreenect](https://github.com/OpenKinect/libfreenect/tree/master/wrappers/python) library and a [Hadoop](http://bwhite.github.com/hadoopy) library.
Just looking through the thread, I'm pretty sure [my crappy web app thing that solves sides of triangles](http://devio.us/~clorow/triangle_solver.cgi) won't get much attention... **EDIT** Explanation: Side a is opposite from angle A. So if you put in a=3, b=4, c=5, then angle C will be 90 degrees.
Why Python itself of course. Working on PyPy is beyond cool.
I remember spending a lot of time looking into a similar starfield playing Star Raiders on the Atari 800 -- where it was probably coded in 6502 assembler. So now, make it simulate "turning" and entering hyperwarp.
I wrote Bitbucket (dot org), which is entirely in Django/Python.
Aha, I follow now, I didn't catch the % up there. Thanks
I don't know enough about Ruby to give it a fair comparison, but what I do know is this: the Python ecosystem is huge so it's difficult to give you a run-down of what libraries you personally might find useful. What particular areas are you interested in? To get you started, here's some libraries a ruby web programmer might find interesting: [iPython](http://ipython.scipy.org/moin/) An Enhanced Interactive Python shell. A must-have IMO, especially if you're new to the language since you can tab-complete and tab-inspect an object to see its various methods. [Requests: HTTP for humans](http://docs.python-requests.org/en/latest/index.html) Kenneth Reitz's excellent request library. Makes HTTP requests VERY pythonic and readable. Don't bother dicking around with urllib(2) or httplib(2) unless you absolutely have to. [Django](https://www.djangoproject.com/) Probably the most widely known and widely used Python web framework. Has excellent documentation. Like Ruby on Rails, Django also has a lot of great high-quality 3rd party middleware/libraries like [Haystack](http://haystacksearch.org/) (which lets you integrate things like full text search into your site easily, among other things). [Pyramid (aka Pylons)](http://pylonsproject.org/) Pyramid (formerly Pylons) is on the opposite side of Django as far as web frameworks are concerned: it's a loosely coupled, À la carte style framework that lets you pick-and-choose components (ORM, templating engine, middleware, etc. Everything you want/need, nothing you don't. [virtualenv](http://pypi.python.org/pypi/virtualenv) Probably not that useful for someone just playing around with Python, but it's definitely a must-have for any working Python programmer - especially when you're managing projects on multiple machines with multiple different versions of libraries etc. [Fabric](http://docs.fabfile.org/en/1.0.1/index.html) Awesome tool for deploying/automating sysadmin tasks without swallowing the complexity of puppet or chef ( edit: My bad: This isn't necessarily true. See discussion below) [NLTK](http://www.nltk.org/) Natural Language Tool Kit. VERY powerful - and it lowers the barrier of entry for experimenting with [natural language processing](http://en.wikipedia.org/wiki/Natural_language_processing) for working programmers. That's just a quick run down of stuff off the top of my head that I've been toying with for person projects. 
Without knowing ruby it is difficult to comment (what I am going to say might be true in ruby too)... Stuff I really enjoy about python: * everything is a pointer to an object, really, everything. * indentation is imposed. I can pick anybody's code, and it is guaranteed that it'll be fairly readable. As a side-benefit, no need to type all those curly bracket and semi-colon!! * auto-documentation. Classes and method are automatically documented, you write a class MyClass, then when you go into the interpreter, you can run help(MyClass) and it's nicely documented. If you put a comment at the top of a class (and methods), it'll integrate it into the documentation too. * battery included. There are A LOT of libraries that come by default with python. At first you think "meh, I can get those libraries from the net in any language", but it makes for very portable code, people don't need to get libraries x, y and z to get your code working, it will work. * some functional programing - read about list comprehension, generators etc.. very neat high level language functionalities 
NLTK looks great. There are no decent Natural Language libraries for ruby. Same with SciPy/NumPy -- there's just no equivalent. Virtualenv looks neat. Ruby has RVM and Bundler as means to the same end. I didn't realize this existed for python. Very cool! Fabric also looks interesting. There are some ruby gems that try to accomplish the same thing, but I don't like the way they work. I may end up using this. Thanks for the suggestions!
I love blog posts made sight unseen. "I don't know of it, therefore it must not exist." Worse, his complaint could be addressed in a gist on github that could be shared with all. *Worse still* the problem isn't simplification, but **extreme** laziness.
A lot of this is true in ruby too (they're actually very similar languages!), but the auto-documentation point is really interesting. Ruby doesn't have any sort of in-built knowledge of documentation. Cool feature.
The Ruby equivalent to Fabric is probably Chef or Capistrano. :) and with virtualenv, make sure you check out virtualenvwrapper - makes working with virtualenvs on the command line really easy ;)
I wrote a command-line app which connects up to Gmail, displays the most recent email, and gives me the option to keep/delete it with a single keypress. I also ripped the url's out of about 8 years worth (~10000) of bookmarks/textfiles with useful links that I'd meant to "read again some day". Then I got python to query each of them to see if they're 404, if not grabbing their title, and export them to a 500-link per file bookmarks.html. I imported this file to del.icio.us, having it automatically add other users' tags to each link, then exported it again. This let me have an up to date copy of organized bookmarks which I still need to read again some day.. I made another app to keep track of tasks I was working on. I'd hit a hotkey and it'd start a timer, then at the end of a given task I'd hit another key and it'd stop the timer, asking what task I did, and whether I want to associate any tags with it. It then calculated how much time I'd spent on the task (assuming I wasn't multitasking the entire time) and let me work out roughly how much time I spent on given tasks over the few months I used it. I got halfway through making a web interface to my todo app using Flask but have been swamped with other stuff. I had no idea how to make any of these things when I started, so they're all pretty hacked-together until I get time to work on them again "some day".
Oh, nice! I've always meant to try out Pyro, but I've never had time, or a project for which it would be useful. Keep it up!
Capistrano in particular is the one I strongly dislike :). I haven't used chef enough to have a well-formed opinion of it. I will check out virtualenvwarapper, thanks!
I wrote a wrapper around my pen plotter's bizarre drawing language, so I could make fun programs to control it via Python. I then went on to make programs to do things like draw some simple fractals, and convert image files into "art" (pointilism, etc.). The most fun (and most pointless) was a simple interface in Pygame to read mouse input, and then draw whatever was sketched with the mouse to the plotter, in as-close-to-realtime as the plotter could do it.
No problem :) good luck with Python :D
Here's my github: https://github.com/behindcurtain3 I only just started with python also so I'm in the same boat as you!
How could it tell proper nouns from regular nouns? That's very context sensitive, isn't it?
&gt;Virtualenv looks neat. Ruby has RVM and Bundler as means to the same end. I didn't realize this existed for python. Very cool! I don't mean to troll, but RVM was copied (badly) off of venv.
I wasn't claiming RVM was there first, just stating that when I've used python in the past, I've been completely unaware of virtualenv's existence.
Decorators: http://stackoverflow.com/questions/739654/understanding-python-decorators#answer-1594484 List Comprehension: http://docs.python.org/tutorial/datastructures.html#list-comprehensions Libraries are one thing that python does so much better than ruby, in both documentation and availability. Ruby seems to be at a dissadvantage by how cutting edge it tries to be and because of that libraries are rarely very mature. If you are looking at scipy look at [matplotlib](http://matplotlib.sourceforge.net/) [psyco](http://psyco.sourceforge.net/) [pypy](http://pypy.org/) So much more. One of my favorite language features is that everyone tends to like good documentation and creates good documentation (take a look at [python docs](http://docs.python.org/) and documentation for the many libraries, to me it is so much better than looking through an rdoc or most ruby docs).
games are always cool!
You may actually get a fairer comparison in a Ruby forum as you may find a cross over coder there.
Yay, my code is used by CCP! Anyone else here who really dislikes the reference implementation? I think it is wrong to use such an unpythonic way in the standardlib.
David Beazley has a great presentation on generators, and combining them with comprehensions [here](http://www.scribd.com/doc/19568362/Python-generators-from-David-Bealey). I'm a big fan of using python for systems automation, here's some of my favorite modules/libraries: * [Paramiko](http://www.lag.net/paramiko/): A very straightforward implementation of SSH2 * [Fabric](http://fabfile.org): Much like Capistrano for Ruby, built with Paramiko * [pexpect](http://www.noah.org/wiki/pexpect): An expect-alike written in pure python. Very useful for automating tasks that require user interaction * [doctest](http://docs.python.org/dev/library/doctest.html): Automatically create tests for functions from comments. Saves a ton of time and makes it easy to expand your test coverage * [Twisted](http://twistedmatrix.com): A reasonably simple event-driven networking framework, tons of support for different protocols * [SQLAlchemy](http://www.sqlalchemy.org/): Very powerful database toolkit and ORM * [Multiprocessing](http://docs.python.org/library/multiprocessing.html): Process-based "threading" interface, provides API for spawning processes and get around the Global Interpreter Lock * [Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/): HTML/XML screenscraping and parsing library that handles pretty bad markup. Total lifesaver when scraping sites written by messy devs * [cmd](http://docs.python.org/library/cmd.html): Provides a simple framework for creating command interpreters. Very useful for making a specialized interactive shell for your application * [Suds](https://fedorahosted.org/suds/): Simple SOAP client * [Smolt](https://fedorahosted.org/smolt/): A basic hardware profiler. While the main use is to send data to Fedora devs for support, can also be used without that functionality to easily grab hardware data from your cluster Edit: formatting and added Suds
&gt; Ruby doesn't have any sort of in-built knowledge of documentation. RI and rdoc-server fills this function in Ruby, fyi. If you're a ruby programmer who doesn't use the crap out of them, now you know.
SciPy, NumPy, and the other scientific libraries are the best, I think. You can do much, much better linear algebra, bioinformatics, and statistics in Python. I say this coming from a Ruby perspective, so there may be things I'm missing, but that's the real core of what I wish Ruby had better support for.
We polyglots live in /r/python too ;)
lxml rules for all kinds of XML / HTML processing http://lxml.de/ if you want a fine library to scrape some HTML, make sure to check out pyquery (based on lxml) that allows for easy extraction of all kinds of data with jQuery selector syntax. http://packages.python.org/pyquery/ 
Tasks Python is better suited for: * Maths, statistics &amp; sciences - numpy, scipy etc. Shitload of domain specific frameworks. * System programming/integration - There are about 18000 dependencies on python in a stock ubuntu server, slightly more than perl. Compared with Ruby's 2000 deps and language choice becomes rather one-sided. * UI - Python's UI frameworks (especially PyQt) are much more mature than their Ruby counterparts. * Complicated networking - twisted is very good to have around even if you don't need it very often. * Distributed systems - Excellent networking frameworks &amp; message queue support. * Speed - Even though comparing scripting language performance is a bit like comparing chicken IQs, cPython is faster than Ruby &amp; JRuby with PyPy is promising to be relatively close to Java in the long run. Equal par: * Web - Both have lots of frameworks, finding one you like is pretty easy whichever you're using. Ruby wins: If you need a DSL.
The downside of this technique as written is you won't respond to `issubclass` or `isinstance` properly, however with the fancy-shmancy ABC features added in Python 3, you could get around this by adding a `__issubclass__` magic method.
* [ipython](http://ipython.scipy.org/moin/) * [gevent](http://www.gevent.org/) * [numpy](http://numpy.scipy.org/) * [pyglet](http://www.pyglet.org/) * [pygame](http://www.pygame.org/)
rvm + bundler == pythonbrew + venv + pip -r but no one tool really maps to exactly one other.
Fabric is a much simpler system, but fills the same role as Cap. Neither have much, if anything, to do with Chef/Puppet.
Thanks, I work in Python regularly and learned a few things here
I am in a situation similar to the OP. I started exploring python lately. I am wondering if anyone knows of a python reference similar to this: http://rgruet.free.fr/PQR26/PQR2.6.html (which really is a goldmine), but updated for 2.7, or 3.2? So far there's one thing I have problems with, that is the python object model - I don't have a clear picture yet of it,. What happens when I call a method on an object, how/where things are going to be searched and in what order. What callbacks( descriptors, etc.) will be fired, static methods, class methods, metaclasses and their role in python. If anyone knows a concise article describing it, or some diagrams that may be of assist I would be very grateful!
Great tips! I just want to add: * [bpython](http://bpython-interpreter.org/) which I prefer over iPython, but that is a matter of taste. * [virtualenvwrapper](http://pypi.python.org/pypi/virtualenvwrapper) makes working with virtualenvs even easier. * [PyPi](http://pypi.python.org/pypi) the ''CheeseShop" and the place to go whenever you are looking for Python modules. I would also read [David Beazley's Slides on Generators](http://www.dabeaz.com/generators/) which influenced my programming style quite a lot back in the day. The single most important thing to do is to become familiar with the standard library. Python ships so many powerful modules and you find gems like [multiprocessing](http://docs.python.org/library/multiprocessing.html), [logging](http://docs.python.org/library/logging.html) or [functools](http://docs.python.org/library/functools.html) to name just a few in there. 
One thing I've sort of dreamed about is that `class` and `def` should be some kind of built-in functions that work with a more generalized `block` syntax. As it is today `class A: pass` is sugar for `type("A", (object, ), {})`. Wouldn't it be neater if it were an expression of some more basic syntax? That way if you wanted to create some new ORM, instead of hacking metaclasses to describe your database with `class Person(ORM): dob = field(date)`, you'd write something like `ORM Person: dob = field(date)`.
1. I would replace the ugly range statement: for i in range(2,n): by (the more pythonic): for i in 2..n 2. I would add a repeat until statement: repeat: ..... until condition 3. I would allow a function definition a la javascript: myfun= function(....): body of the function For the rest, Python is pretty perfect for me. 
No [GIL](http://wiki.python.org/moin/GlobalInterpreterLock). No "self".
Hmm, I would sort of be tempted to go in the direction of Golang: get rid of the `while` statement and just use a `for` statement with a conditional instead. :-)
No self where? In the method definitions sure. I type `def foo():` by accident all the time. But what about inside the method bodies? Would `x` just implicitly mean `self.x` or would you add some punctuation, like `$x` or something?
Damn thats really cool. 
I sometime think it would be better if Python had a difference between declaring a variable the first time and reassigning a variable, such as `:=` vs. `=`. I think doing so would resolve a) a typo problem, since `vart = foo` would fail when you meant `var = foo` and b) a scoping problem. As it is now, you have to use `nonlocal` to cleanly pass the Paul Graham test. With `:=`, there'd be a difference between `x += 1` and `x +:= 1`, so `nonlocal` and `global` would be redundant.
Braces! Seriously indenting code to form a block is a real pain and makes for portability issues. I know this will never happen in Python but for a Python like language it would be nice. If this is a new language I'd like it be built with C++ and work closely (low overhead) with the STL. Sort of like what Apple is doing with MacRuby where MacRuby uses much of the frameworks that Mac OS/X is built out of. So a C++ string becomes a String in This mystery language and so forth. I'm not wedded to C++ either but the goal is to tightly link the language to a more modern C. So things like "D", "Go" and others should work. Simplification of the language ought to be considered. The goal here is to have a language that can be embedded in a micro controller. This is one area where a Python like Language might have serious up take. Obviously a certain amount of infrastructure is required but I do wonder just how much code space is required to get to say 80% of Python on a 32bit embedded controller. Some attempts have already been made to produce an embedded Python but my impression is the current implementation is to much to ask for on many embedded platforms. Build for speed! There seems to be a tremendous amount of overhead in determining just what an object is. I'm not sure what the best answer is here. 
Access to instance attributes ought to be in local scope and should be the default. Right?
I'm looking into the same kind of systems and found the following [Comparison of open source configuration management software](http://en.wikipedia.org/wiki/Comparison_of_open_source_configuration_management_software) Wikipedia link. There is a bunch of python systems but I can not at the moment recommend one. I'm also wondering if I want Windows support. Hope the above help.
Thanks fot the decorator link. I've been wondering how they work and that was an amazing explanation
&gt; Beautiful Soup: HTML/XML screenscraping and parsing library that handles pretty bad markup. Total lifesaver when scraping sites written by messy devs No, just no. For the love of god, use html5lib and lxml.
Just get rid of underscores and I'll be more than happy. ''.join() is retarded no matter how many explanations you give me. lambdas suck, just enclose them in parens and make them multiline also str[::-1] is stupider than str.reverse(), grow up and accept it except for these little annoyances, best language evar.
The point is you cannot hide algorithms. There is no value in knowing the variable is called "height", "amortisedValue" or "fred" - the important stuff is what is done with that. There are discreet operators in the Python language, therefore its no mistake what "someclass.fred += 1" does, even if that operator is overloaded in that class definition. And sure, the longer the code the longer it takes you to figure it out - but that's no different to arguing that its longer to drive interstate than to the corner shop, therefore I shouldn't drive interstate in order to test drive my car. And its not like you have to manually do everything - there's tools to draw UML diagrams from Python code to aid in your disassembly, you can break into running programs with pdb, you can use strace to figure out when system calls are being made... I don't even have to fork out money for the REALLY good stuff to get some pretty good (and in many cases, good enough) information. And this is the same with pretty much every other language. Over 90% of applications is fluff code of no value, required to make some mundane operation work - particularly if there is a GUI component. If the code is making a sorted list of objects then passing that into a GUI library for rendering in order - odds are its the painters algorithm. I've now unlocked that those objects probably represent points on the screen, and the three integer variables are the x,y,z coordinates. Since most operations are usually 2d, the least-used is most likely z. someclass.SDFTGS is therefore someclass.z. QED You can apply this to every known compsci algorithm. Now consider that the only real value in your application is the IP you're trying to hide, once you remove all the known algorithms (which will make up most of the code), guess what's left? If you're really worried about protecting your IP, then do what others have suggested and **don't give it out to ANYONE** - because obfuscation is going to not buy you very much at all. In the case in point - MMORPG's should be implementing some kind of public key cryptography in their clients to prevent hacked clients from accessing the servers. If I were in their boat I'd be releasing the client open source and encouraging technically-adept end users to submit bug fixes. There could be some kind of bounty reward system in or out of the game for this. These are the kinds of things that a community is built on - and an MMORPG is nothing without a community. The client is just an I/O system and even stuff you'd toss client-side for performance reasons isn't valuable - like fiddling with character stats on certain events - its a bit of a 'duh' mathematically. One particular patended technology I helped build, we initially had the same struggle with management that the OP MrValdez is struggling with now, and we also toyed with some of the ideas around it (e.g. those suggested by others like using a client/server model). In the end we just put it out there, and there was one company that tried to rip it off. They were stupid enough to even leave our copyright notices in the text amongst other things. I understand the court didn't take long at all to reject their version of events, and bankrupted them in damages. Its nice to know there's a support system even if everything else fails. 
You will miss the enumerable module. It's a great language to develop in though. The libraries that I've used have been always solidly put together and documented well, as opposed to many ruby gems which are not. Also if your doing web development you can count on real documentation if your using django, and wsgi implementations are more mature than rack.
Testing tools: * [nose](http://somethingaboutorange.com/mrl/projects/nose/1.0.0/): test runner / testing utils * [coverage.py](http://pypi.python.org/pypi/coverage): code coverage * [pylint](http://pypi.python.org/pypi/pylint): linting Two one-liners for debugging: * `import pdb; pdb.set_trace();` - drop into an interactive step through debugger at any point in your prgoram * `import code; code.interact(local=locals());` - drop into the python REPL at any point in your program If you're doing web development, use the [werkzeug debugger](http://werkzeug.pocoo.org/docs/debug/#using-the-debugger). Some of my favorite python features: decorators, generators, [sets](http://docs.python.org/library/stdtypes.html#set), [WSGI](http://www.python.org/dev/peps/pep-0333/)
Pretty sure jfb3 means having to add self to the parameter list yourself. I think what is wanted is like it is in Java where in class instance scope you auto-magically get "this" to reference to the instance with.
Just wanted to say as a Java-Ruby guy I learned a ton about Python from this. Thanks all!
 myfun= function(....): body of the function Doing a "def myfun():" in this place would do *exactly* the same thing, it binds the function to the myfun variable. The only use for extended lambda syntax would be inside other expressions, a case in which this syntax wouldn't even work. There is a good reason why lambda is the way it is.
Built in introspection: ast, inspect, traceback, dis (all stdlib modules); built in serialization: [json,] pickle (for arbitrary objects, much faster than yaml) with proper transactional ACID persistence via ZODB; power tools like Twisted, Werkzeug, Pygments, pytest; web frameworks like Pyramid, Flask, Django; hosts like appengine, ep.io; documentation like you've never experienced it before with Sphinx… Edit: built in XML parsing: etree (both pure python and C extension included in stdlib) with third-party lxml as a wrapper for libxml2/libxslt with the etree API (swap an import and get free speed, xpath, html parsing...); standards-compliant html5 parsing with html5lib; relational DB toolkit/ORM with SQLAlchemy; PyPy: fast, hackable and compliant python… Edit: dynamic access to the GNOME platform with python-gobject; Qt via PySide; Java: Jython; .NET: IronPython; coroutines and laziness with generators; mixins via multiple inheritance; metaprogramming with decorators; dynamic interfaces with abstract base classes; modules as singleton objects…
So you did mean to troll?
[pyquery](http://packages.python.org/pyquery/) is a fun wrapper for lxml.
Ah I have just the thing. The python official docs have a great description of this. It doesn't delve too deeply into metaclasses, but learning how method calls actually use descriptors is a huge step towards figuring this out (and its really elegantly clever and versatile technique). http://docs.python.org/reference/datamodel.html Python 3.2 isn't really any different, read the "new in python 3.x" pages to see the few things that changed in the data model.
A casewhere/switch statement such as: switch x: case 0: something() y = z case 1: otherthing() a = b else: finalthing() 
Integers are static objects and can't be changed. If you did id(a) and id(b) at various stages in your code example you would see the variables point to different objects at various stages.
[PEPs][] (Python Enhancement Proposals) make the language designed by and for the language users themselves. Unlike Python, Ruby’s language design is done by language designers, not users. Moreover, ruby-dev, the mailing list for it, is written in Japanese. [PEPs]: http://www.python.org/dev/peps/
I'd give it a name that doesn't cause non-technical management to scoff when it is first mentioned. 
Ack! no! I loath locally scoped instance variables. When trying to learn a codebase, it is impossible to distinguish them from globals (though I'm used to C++ where globals are sadly still used). Also, the python object model would never allow this, unless you were willing to put a ton of "local" commands inside of methods or have foreward declarations inside the classes.
The question wasn't about changing python it was about a "python-like" language.
Note that pdb acts as a REPL as well so for debugging, the latter is a little redundant and less powerful.
You can't use multi-line statements in pdb: (Pdb) def f(x): *** SyntaxError: unexpected EOF while parsing (&lt;stdin&gt;, line 1) And some of the debugger commands (`a`, `b`, `c`, etc.) conflict with variable names (the ones inside your program or ones that you would define while debugging), so it doesn't behave exactly like the REPL. So, that is why I prefer using `code.interact` for REPL stuff, and pdb only for debugging (stepping through code).
Most everything in Python is immutable (including strings). So although integers are objects, you can't change them, and if you change a variable's value, the variable now actually points to a different object. So, for your example: a = 4 # id(a) == 12366576 b = a # id(b) == 12366576 b += 1 # id(b) == 12366552; id(a) == 12366576 What you're actually doing is reassigning the 'b' variable to point to the Int object with value 4, not adding '1' to the contents of variable b.
I don't have a strong opinion on whether explicit variable declaration is better than implicit, but you might as well use an operator like `var` or `let`. `:=` would be mistaken for the pascal assignment operator. 
I'd strip out all of the complex features - list comprehensions, sets, etc. Not that these aren't great features, it's just that I'd like a simple &amp; powerful interpreted language that I can have non-programmers work on. And *basic* python is just that: something that a security analyst could easily learn, something that a high school student could learn, something that a java programmer could pick up in a couple of hours. But once you start to graft functional programming onto that basic language, kinda like adding oo concepts onto C for C++, I think you make it less suitable for those amateur programmers. Alternatively, it could be cool to have a basic switch, like the optimization flag, that would enforce a simple subset. EDIT: given the down-votes, it sounds like python folks might not be interested in a great language for amateurs. I guess I'd look elsewhere for inspiration and interest in easy, intuitive, and obvious languages useful to amateur, beginning, and part-time programmers.
For dict and types derived by dict I would make a.whatever always equivalent to a.get(whatever,None) I would introduce symbols (like Ruby) and I would implement special functions names as symbols instead of odd names. So class A(object): def __init__(self): pass def __call__(self): pass def f(self): pass # A.f(), A().__call__() would be class A: def :init(self): pass def :call(self): pass def f(self): pass # no "because not special" # A.f(), A():call() 
yes please!
&gt; Another issue I'm having is that you can't parameterize a table name, so if the tables used in a query are determined on the fly, you have no choice but to build the sql using string functions. Correct. In this case it's appropriate to use standard string interpolation. Just make sure you escape anything you throw into it properly. A regex in the form of "[a-zA-Z0-9_]" would probably cover it.
This is a good guide comparing rvm and virtualenv http://gillesfabio.com/blog/2011/03/01/rvm-for-pythonistas-virtualenv-for-rubyists/
I would implement optional static typing, better support for functional programming (e.g. automatic tail-call optimizations at the bytecode level) and data-structure-pattern matching.
In Python, += doesn't modify the object reference on the left hand side (unlike C++, for example). It creates a new object that is equal to the left hand side plus 1 and assigns it to the reference on the left.
get rid of the whitespace requirements. 
I don't know ruby at all, but [this discussion on StackOverflow](http://stackoverflow.com/questions/1113611/what-does-ruby-have-that-python-doesnt-and-vice-versa) tries to summarize differences between the two at the language level. Not at ecosystem level, as you're asking, but still relevant. The question has been "closed as subjective and argumentative". In my opinion it's not a subjective question and should be reopened. But I don't have karma to propose that.
i still don't understand why we have to write if x &gt; y: rather than if x &gt; y the indentation already gives all the information that the colon gives, right? whenever i'm switching between matlab and python, i consistently forget the colons.
Re the range change, How would you handle intervals other than 1?
And it looks much nicer than seeing a bunch of function(...) all over the place. def dada: ftw.
Make assignment an expression which returns a value. I think the reason for not having this is that it makes it easy to type `=` instead of `==` and not realize you made a mistake, but I'd rather be treated like an adult by the language in this case. Also, add `unless`!
Because user-testing in Python's predecessor language ABC showed that ":" was less prone to making indentation mistakes among programming novices. In my own experience I can say that it's easier to get analysis tools to know that ":" means "next line indented" instead of doing more complete code analysis. 
The problem with the first is it prevents the ability to add new methods on dictionaries, like "from_keys", without possibly breaking code. What happens if you do d["pop"].pop ? The need for an explicit :call means you couldn't implement functors as objects. You would have a() if a was a function and a:call() if a was an instance of A. I like that feature of current Python.
&gt; Because user-testing in Python's predecessor language ABC showed that ":" was less prone to making indentation mistakes among programming novices. i've never heard that reason before. sounds interesting. citation? but even so, i'm not sure if that is a very good reason. programming novices don't remain novices for long. &gt; it's easier to get analysis tools to know that ":" means "next line indented" instead of doing more complete code analysis. i have heard this reason before, and although i understand it, i don't know how much i like the reasoning. should we really be designing programming languages based on the limitations of our tools? is that done for other design decisions?
For reals, it'd be one extra character to close the scope, and eliminate all ambiguity.
I'm not sure. If I do tmp = random_functional_call() inside some method as a helper for some calculation, should that result really stay around as an instance variable? In Java ea everything is predeclared, so the compiler can know that you meant a variable as an instance variable, but in Python I don't see how it'd work.
Well if it was sufficiently Python-like then it would have the same problem, or else you first have to explain how it would be different.
I see that problem as a lack of declaration. You can't declare variables either temp or permanent. (Fuck, the problem is you can't *declare* variables. I hate that part of python, I want to declare a variable so that if I mistype something I can find out about it before it runs.)
I like the colons because they tell my stupid editor that it needs to indent.
I recommend the tutorial in the Python Docs: [Python 2.7](http://docs.python.org/tutorial/index.html) [Python 3.2](http://docs.python.org/py3k/tutorial/index.html)
how is that preferable to an if...elif...else? edit: not meant to dismiss, meant to clarify why...
**Videos** Python Osmosis http://python.sourcequench.org/?m=200905&amp;paged=12 Another Series on Youtube http://www.newthinktank.com/2010/11/python-2-7-tutorial-pt-17 **Books** http://www.swaroopch.com/notes/Python http://www.awaretek.com/book.html http://diveintopython.org/ If you don't have an editor you like yet. http://www.swaroopch.com/notes/Vim 
pressing colon is one keystroke. pressing tab (after enter) is one keystroke. what's the difference? also, editors can get smarter and automatically indent without the colon.
with cython, its kind of like you have optional static typing, but I know what you mean.
I'd make **all** data structures immutable (like tuple/str/float etc already are). I'd provide builtin concurrency mechanisms based on message passing, hence the need for immutable data. Sort of like mixing in more functional style with some Erlang. Being immutable also removes the need for locks and solves the GIL issues. 
It's shorter. This may seem trivial but it isn't when the expression you're examining is particularly long and you need to type it out with every if and elif.
http://code.google.com/edu/languages/google-python-class/index.html Google's python class got me started
Follow these lessons: http://learnpythonthehardway.org/static/LearnPythonTheHardWay.pdf "The Hard Way" is like you did it in elementary school. Lessons/worksheets that teach the basics. Interaction with real answers so you can check that you're doing things correctly. It's more than just reference/introduction, it's tutorials and lessons. Done simply, done at a reasonable level. You'll love it.
[Learn Python The Hard Way](http://learnpythonthehardway.org/)
Whats wrong with Beautiful Soup? is there like a list of cases where it sucks?
Unless you are really careful you can easily leak memory due to navigatable strings having a reference to the whole document. Also the parser it used to have is bad (like really bad) and changes behavior depending on the version of BS and Python. html5lib exists nowadays and it has a proper HTML parser that can handle *any* case your browser handles too and in exactly the same fashion.
In addition to queviltai's note, if it works like C, the cases can run into each other. Not sure if that's good design, but occasionally useful.
&gt;lambdas suck, just enclose them in parens and make them multiline If you want multiline lambdas, then just use `def` wherever you want. Lambda is only intended for encapsulating very simple functions for things like data hiding or comparison lambdas to pass to `sort()`.
This is about a python-like language. I'd argue it's not python-like without the whitespace requirement and typically the only people who give a shit about the whitespace requirements are those coming from C or other equally verbose languages.
I can not disagree more, the whitespace requirements are one of my favorite features...braces are useless if you're writing clean properly indented code in the first place.
&gt; also str[::-1] is stupider than str.reverse() Except slices are infinitely more versatile and terse than a reverse function.
How is that shorter. Comparing the two options we have here: s1="""switch x: case 0: something() y = z case 1: otherthing() a = b else: finalthing()""" s2 = """if x==0: something() y = z elif x==1: otherthing() a = b else: finalthing()""" print len(s1), len(s2) the first one (with case) is 9 lines vs 8 for the if/elif/else thing. The switch/case one is 133 characters vs 95 for the if/elif/else statements (of course lots of those are additional spaces since you need two levels of indent in the first case, but still switch/case looses).
Tru enough. I'm sort of a polyglot myself.
There are static code checkers for Python like PyLint and Pyflakes.
Have it be intelligent about the return value of a function ;) For example, in Ruby, you don't have to explicitly say `return x`, you can simply say `x` as the last line. I get a decent amount of `NoneType has no ... attribute` kind of errors.
Some examples of "arbitrary changes" would be nice...
proper lambdas
'self' is one of the underappreciated features of Python. To give one reason: it enables "open classes". In Ruby, classes are explicitly open. You can simply re-open a class declaration and put new stuff there. Python doesn't have that, but it doesn't need it. Since 'self' is explicit, you can just assign a new function with a self parameter to your class and your instances get a new method.
I'd ditch the class system and replace it with prototypical inheritance. Not like ECMAScript 1.0's prototypes-masquerading-as-classes, but a system as advocated by Doug Crockford. I'd also fix closures so they work the same as in ECMAScript 5.0 strict and get rid of global objects. Oh, and I'd also make everything in the stdlib that is currently synchronous, asynchronous. Getting rid of classes simplifies the language without removing any functionality. Constructors become functions that return objects. Coffeescript is doing some neat things that make a lot of sense.
I now appreciate Guido more than I ever have, for his taste in saying no to suggestions like those in this thread.
In that case, i would use: for i in 2..n by 2 
A good short intro would be to read [To Ruby From Python](http://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/), even though it is meant for people going the other way :)
Good to know. Thanks for the tip!
&gt; In our port of Python 2.7 to the PS3 console Hot damn.
Another reason is that if assignment was an expression, you'd need to figure out an alternative for named arguments, because foo(bar=baz) would suddenly mean something else. Not saying you're wrong, though. In fact, I'm strongly convinced statements are the tool of the devil and the prefect language only contains expressions. 
Yeah, I'm familiar with them. They just have never really felt quite as... intrinsic, I guess. 
Not the original poster, but dropping reduce from the global namespace, the new print function and the new string formating syntax come to mind.
This is something I wish ruby did better. Very interesting way to design a language.
Interesting. Something like 'my' in Perl? Of course then you need to decide how the dynamic parts of Python work, variables can be added to a class from anywhere, at runtime.
Silverlight actually makes sense here in a strange way. If you don't have windows, you don't need an online python interpreter, because you already have python on your computer. 
I don't count myself as a redditor (because I don't contribute that much) but my general comment -- EuroPython is 7 days long, and planning the meetup for the 6th day sounds strange. I'm only planning to visit first three days, for example, and if it wasn't for the talk I'm giving, I'd probably plan for two days instead. I know at least two redditors who are going to Florence for 3 days only. So, my point is -- how about moving this to 21st or 22nd? I'd gladly join you on any of these dates.
What if we were testing whether x &gt;= len(str[:count].lower()) - 1 ? In any case a better alternative in many instances would be: val = { "a": lambda x: x*3 "b": lambda x: x-5 "c": lambda x: x**2 }[10]("b")
Perhaps by specifying the interval implicitly; e.g. 2,4..n ? I think Haskell does it something like that 
&gt; i've never heard that reason before. sounds interesting. citation? I saw Guido give a talk a few weeks ago and he mentioned this specifically.
&gt; I'd make all data structures immutable (like tuple/str/float etc already are). I'd provide builtin concurrency mechanisms based on message passing, hence the need for immutable data. For what it's worth, that's the plan for [my language](http://magpie.stuffwithstuff.com/).
Well, why not (the 25th is just the default date) ? Let's say the 21st then. we'll PM each other. 
The GIL is an implementation detail, that many other implementations have skipped. It's not part of the language.
Heh... `from __future__ import var`. SyntaxError: future feature var is not ~~defined~~ declared. 
They're pretty intrinsic (interactive RI! `RDoc::RI.Driver.new.interactive`) but they're also pretty clunky :(
Non-mutable data structures can create some real problems (such as the quadratic behavior of str += str, until they optimized it away behind the scenes with mutable strings). Not to mention, it would break some very useful use cases (such as the ability to modify the "dirs" return of os.walk to modify the paths it travels).
But all these examples are parts of python 3.x, which has clearly been stated would be backwards incompatible.
When I started Python I wouldn't understand why the self was an explicit parameter of each method (no other language I know has that, but an implicit "this" or similar). Then I learnt about bound/unbound methods and understood that you could apply those methods to any object, not just on instances of that class. I would not want to have it any other way now. Or do you have suggestions for viable alternatives? 
--Gotta give you a thumbs-up for the braces issue! One person decides to use 2 spaces, another uses 4, and still another uses tabs, and the whole structure is a nightmare! Also, ever blocked and copied a bunch of example code from a web site, only to find that the tabs didn't come with the text? ARGH!!! --About the STL though, skip it. It's never been "Standard" anywhere, and it seldom works. (My little joke is that it should be called the SSTL, for the "sub-standard...") --Ditto for simplification, Python already is making inroads onto micro's. I do wish that it was easier, but as micros get beefier it's just a matter of time. --Speed: These days, the speed that matters most is the speed of creating and maintaining the code. (There's a reason why you don't see a lot, or any, major new apps being developed in assembly or *shudder* machine code. By the time it's done the problem space has left the station.) Edit: Formatting
Optimization. If cases are closely spaced integers you could compile to a jump table. Dispersed integers would compile to binary search or a hash table. Static strings would compile to a prefix array or a hash table. A mix of objects would probably compile to a hash table of (type, value). These optimizations are probably possible with elif, but 'x == 3' is a predicate where simply 'case 3' denotes a value. A compiler would have to be fairly smart to transform elif into an optimized switch statement. A good design might build if/elif syntax on top of case syntax. That way you handle all your syntax in the parser and the optimizer doesn't have to be as smart. Haskell does this with if/then/else.
I'd almost do the opposite: add a check that if a function contains a return statement then implicit return of None would raise an exception. I don't really like even the explicit return of None, though I can understand why that behavior was chosen.
Both replacing print with a function and the new formatting syntax are very useful. Print because you can then override the default behavior if you need to, and formatting because of it's greater flexibility. I'll agree with reduce, but I didn't use it often enough to have it greatly affect my code.
The colon is always an unnecessary keystroke that requires an annoying "shift". If your editor couldn't handle the new grammar, that would indicate a deficiency with your editor. 
A language which only has expressions is one with no side effects. Check out Haskell.
The beauty of Python lies in its simplicity and very little "hacky" code as you see in C, PHP, perl, etc. I would not want something like while a+=1 &lt; 10: # ... in Python.
Do you get those errors because you forget the return because you are a Ruby programmer?
Explain.
It's often useful but the default should be to break. I don't like continue and break keywords. I think it would be better to use a different word for cases that can be fallen in to. Such as: case x of when 'a': print 1 also 'b': print 2 when 'c': print 3 
Here are a couple of like-minded efforts that might inform the discussion a bit or just provide ideas: [Reia](http://reia-lang.org/) - brings a python and ruby syntax ideas to the Erlang VM [Nimrod](http://force7.de/nimrod/index.html) - brings a python-like syntax to a compiled systems language I like both options for their creative approach to bringing Python's lanugage design philosophy to their target environments. 
You have to use Python 3's `super` explicitly in that case. Functions defined within a class get branded for life if they reference `__class__` or `super`: &gt;&gt;&gt; class T: def f(): __class__ &gt;&gt;&gt; T.f.__code__.co_freevars ('__class__',) &gt;&gt;&gt; T.f.__closure__[0].cell_contents &lt;class '__main__.T'&gt; 
You might like Erlang's variable single assignment rule. 
As Libraries seems to be covered good already ill also mention some great software/toolkits that will help. * pypy - Alternative interpreter with amazing speed * pip - Find and install python packages * supervisord - python demontools/startup * uwsgi - *fast* WSGI server to host your web apps * gunicorn - python-port of the unicorn server for ruby, also a fast wsgi-server * gevent - single thread event driven network platform (like node.js) * twisted - Network server/client swiss army knife * pyQt - Great UI toolkit to build desktop apps. * pyglet - a openGL wrapper that makes GL a bit more pythonic. * pylint - will score your code for you (warning, kinda addictive) 
I guess they wish Python 3 would never have happened?
Playing with your game now, but I'm not sure I get it. Looks cool though. Can you shortly explain the concept? Also, who's Vanessa and why are you writing games for her?
I'd go but I don't know European and I'm not in Python.
Yes, I know. But I'd like a python like language to not have it.
Hey, let's reverse the question for a moment while we're at it - what does Ruby have and do better than Python? I guess the most obvious example is Rails because that's the best known sweet spot in Ruby, but are there others? I used Fox with Ruby a while back to put together a little toy program a couple years back, but that didn't strike me as being unique to Ruby.
But they can't tell whether I meant to create a new variable or not.
That would be complicated, since Python doesn't have traditional for loops. They use an iterator instead of the traditional (init;until;increment) syntax (which is why we have to use range). You could have some fun with generators that may be able to emulate that, though.
Not really. Cython allows you to add declarations for C primitives, and classes can be made into efficient structs. However, everything else is just Python, and goes through the interpreter overhead, e.g. popping something out of a list or dictionary -- neither Python nor Cython can statically type that.
I think you missed the point of the parent comment. For example, IronPython and Jython both do not have a GIL. 
&gt; also str[::-1] is stupider than str.reverse(), grow up and accept it Ever heard of reversed()?
Have you read the rejected [PEP 3103](http://www.python.org/dev/peps/pep-3103)? Optimization is sited as the primary rational that makes a switch statement worthwhile. It's difficult in that Python doesn't have named constants. It seemed Guido was leaning toward a frozen dispatch dict stored on the function object the same as default parameters. It wouldn't be able to reference local variables. It would have to be recomputed each time a nested function was defined. And at the module/class level it would probably be translated to an if/elif chain. I would have appreciated it, but the proposal had no popular support.
| What in God's name does HOR do and why is it called every time those three other methods are called? it gets a pair of (probably) coordinates, check them for minimum constraints. and if the boxs aspect ratio is scewed it adds the squeeze factor to the coordinates.
What you want is a language with support for static typing, and preferably with type inference so that the declarations are not redundant.
An infinite for loop: for x in iter(int, 1): pass 
You can have that `if` spans on multiple lines, and this is often case with class-definitions, especially in Python 3 (due to additional type information). The colon at the end is much appreciated in a case like that. 
No. I do understand that. It's just something that, in the standard Python, I dislike. And, if given a choice in a new language that is python like, I'd rather it didn't exist. I can wish for what I want, be it in the language or the implementation of it.
I've heard good things about Think Python, if you are essentially new to programming: http://www.greenteapress.com/thinkpython/thinkpython.html
What is the [10] doing there?
For example: allow multiple expressions in a lambda, perhaps statements as well.
In general I would like to see this. It would be nice if javascript adopted actionscript's type annotation method, but perhaps the same annotation system could work in python: a:int = 5
I just want to force declaration, not instantiation, and not type.
It seems like you want to program in Javascript, rather than Python. Anyway as to your point about classes, this is practically that way since Python 2.3 . Classes are just objects, so are instances. You don't have constructors, only `__call__` behaviour that is handled by object's type (which is an *object* referrenced by another object's `__class__` attribute) and is by default (with `type` as a metaclass) to call object's (class') `__new__` method to obtain instance and `__init__` to initialize the instance. As to asynchronous API this I particularly don't like. We don't need that mess in Python and besides Python already has superior mechanism for asynchronism—generators. Especially since Python 3.3 .
 * Mutable arrays of packed struct. i.e., a bytearray-like thing I can pass directly to OpenGL for vertex, texture or uniform data. * A vector size 1-4 arithmetic library that integrates with the former, provides optimized 3D math including quaternions. * The ability to opt-in to only using TLS on a thread with some explicit global memory block passing, to allow for more course-grained locking and better parallelism between threads. and because I'm a luddite.. * Make a lone period equivalent to missing parentheses in Python 3.x, so you could do either of the following: * `print . "hello"` * `print ("hello")` 
And being able to assign to captured variables. This is disabled in inner named functions for some silly reason, leading to code like this: def attachEventHandler(): x = [0] def handler(): x[0] += 1 if x[0] == 10: doSomething() e.attach(handler) When it ought to be def attachEventHandler(): x = 0 def handler(): x += 1 if x == 10: doSomething() e.attach(handler) Or even def attachEventHandler(): x = 0 e.attach( lambda: x += 1 if x0 == 10: doSomething())
Scala's `var` and `val` seem, especially, like something that wouldn't feel very out-of-place if implemented in Python.
Would it be possible to still have that same ability with an implied self (or 'this' as in Actionscript/Javascript, or etc.)? I have typed `def something (self, etc)` 534 times (recursive cat/grep check) in just my home 'farting around' directory of Python tests. I've done probably as many more at work, yet I've never had to do anything with self that I couldn't do with the implicit 'this' back in my js/as days. It feels like a tax that gives me no benefits.
* Ditch multiple inheritance in favor of Ruby-style mixins. * Real lambdas.
Not true, ocaml is a functional language but it has side effects. It's just about removing the categorical difference between expressions and statements, side-effects is orthogonal to this.
No, actually... I haven't really done much with Ruby. But when I do something like: def full_name(self): self.first_name + " " + self.last_name I'm probably thinking from an ML perspective, as I've seen this sort of thing a bunch there. 
Are you saying the colon is appreciated for clarity? The spanning is possible because of parentheses, so I'd think the final close parenthesis would be enough. Where I appreciate the colon is for one liners, such as if x is None: return class T: ... (The ... is legal syntax in Python 3. It's an Ellipsis object.)
Isn't that what the 'nonlocal' keyword in Py3 was designed to address?
Useful tools: pip, virtualenv, tox, pyflakes, fabric, sphinx, pdb++ Standard library modules: collections, itertools Testing: nose, py.test, unittest2, mock 
I am 100% opposed to an implicit self. It feels like magic, and I much prefer being able to pass it around like a regular object than some arcane rules about it being spawned out of thin air.
If you hate `''.join()`, maybe you'd prefer `str.join('', iterable)`, such as `print(str.join('\n', "Python"))`? It's more typing, though.
I would make all versions backwards-compatible 
Last line should probably be: }["b"](10) 
I am leaving Italy tomorrow... darn
Is it really that annoying to have to import reduce? &gt;&gt;&gt; from functools import reduce &gt;&gt;&gt; from operator import mul &gt;&gt;&gt; reduce(mul, [2,3,4,5,6]) 720 
I tried to get into progrmming many times... Think Python made the difference for me... Great start for non-programmers
I don't see how 2..n is more pythonic than range(2, n), especially given that range can also add a step...
&gt; if given a choice in a new language that is python like, I'd rather it didn't exist His (correct) point is that this sentence is incorrect. edit: This is /r/python. Can't we be a bit more civil? Whether or not he actually does understand the difference, he's using the wrong terms. If anyone disagrees feel free to leave a comment.
I would prefer to not have statements at all. Or at least, have equivalent expression forms of all types of statement. Relatedly, I think I would prefer that mutating methods of lists and dicts return the object rather than None. 
This. Who in their right mind names a language to remind people of a species of snake? We should name it after a variety of coffee bean or something, much more enterprise.
No no no! You're asking for implicit functionality. That is the antithesis of Pythonic!
I'm not a cheerleader for any particular language. My point with prototypes vs. classes is that classes are just a special case of prototypes. You can implement a class system with prototypes, but not vice-versa. Think about it this way: a class is an instance of a metaclass, and an instance object is an instance of a class. So what if you want an instance of an instance? And what is the "parent" of a metaclass? With prototypes, you just have objects with relationships between them. There's no need for a class hierarchy when you have no static typing. The complex mro goes away; if an attribute isn't found, you look in the prototype. Javascript gets a lot right, but a lot wrong. Many things are being slowly fixed, but it's hardly as nice a language to work in as Python. Generators are great! I'm not sure what you mean by "mess"; generators aren't compatible with Python's stdlib **at all**. There are lots of attempts to fix that (gevent, twisted, stackless), but that doesn't change the fact that at its heart, Python expects syncronous I/O. Multi-line lambdas would also be nice, but I can't figure out a way to make it work nicely without breaking Python's whitespace-as-block-delimiters, and that's one of the language's strengths.
oh god. I'M SO SORRY GUIDO
&gt; Are you saying the colon is appreciated for clarity? Basically. I didn't think of one-liners, but that seems like the nail in the coffin. 
We can't descend into perlanarchy!
For me, "more pythonic" means: "it feels more like pseudo-code".
Braces. I am so tired of arguing with people whose only "complaint" about Python is the lack of braces. Freakin' A, just throw them in so we can get work done already. They'll cling to their memory leaks and dangling pointers before they give up their precious curly brace. And just to ruin somebody's boilerplate reply for /r/python karma: ``from __future__ import braces``
&gt; So what if you want an instance of an instance? If that's your use-case… What's the point in subclassing an instance? class wtf(2): pass &gt; And what is the "parent" of a metaclass? Different metaclass. All the way up to `type`, which is the metaclass of all metaclasses. You can have as much of them as you need. &gt; There's no need for a class hierarchy when you have no static typing. The complex mro goes away; if an attribute isn't found, you look in the prototype. Actually, MRO is great. &gt; Generators are great! I'm not sure what you mean by "mess"; generators aren't compatible with Python's stdlib at all. There are lots of attempts to fix that (gevent, twisted, stackless), but that doesn't change the fact that at its heart, Python expects syncronous I/O. This is why I like it—you can just program to generators and ignore the low-level async APIs. You can swap the implementation from OS I/O thread-level scheduler to a different one or to schedule yourself, all without affecting your code on application level. 
The tutorial is awesome. 
On a similar note, never do something like this: def foobar(somelist = []): ... You'll run into the same sort of problem. Instead, do def foobar(somelist = None): if somelist is None: somelist = []
Simple -- always add ", which is what they use at Google".
Why can't you do `[[]*3]`?
s/null/None/ and s/==/is/ and remove parenthesis.
I think you mean: def foobar(some_list=None): if some_list is None: some_list = []
D'oh. I've been eating and breathing C# at my job; haven't had much time for Python lately.
They are, except that the -1 thing in the third position is useless for anything except the standard reverse. You can't reversed and strip out the first two elements at the same time, for example: '1234'[2::-1] = '123'. Makes no sense to me.
Just define "def join(s, l): return s.join(l)" and you're done. Why complain?
References - how do they work?
Ah,you're right, it does. Thx.
One slight correction: range is a function, not a statement. And I, for one, prefer it how it is.
For me, it means "more internally consistent". "2..n" adds a construct that won't be used anywhere else, whereas range is just a function, and thus adds no further complexity.
That's a list with three times nothing, which is the same as a list with nothing. What he wants is a list with three lists with nothing 
The usual (and idiomatic) way is to write "if x is None," because then you don't need to worry about whether there couldn't be a case in which you get an x that actually evaluates to false, but still shouldn't be replaced by the default value.
Because that produces [[]]
*sigh* Python is great, but it kills me sometimes.
Well mutable data structures also create even worse problems :-) Note that being immutable in the language does not require that the backend also implements things as immutable. The backend can do whatever it wants in order to optimize for memory, performance, concurrency, GC etc. In any event you can still implement strings as a sequence of substrings in the backend which will give linear composition performance. And I certainly wouldn't abandon the whole immutable data approach for just that one use case. It too can be implemented using the existing send() mechanism for generators to say which dirs should be iterated over.
Good example, there should be product() just like sum(); instead there is the cartesian product in itertools, for which product() is way too general a name I think. And it doesn't support infinite sequences even though it's in _itertools_.
Right, exuberant just said that. IDK, i'm an idiot.
You could add new methods you would use the : notation instead of the . notation. d["pop"].pop would be mean d.pop.pop in my notation and d.pop would not be a method. To call the pop method you would do d:pop() instead. You could have functor because A:call(...) would be equivalent to A(...). The : would only label "special" methods instead of __ prefix. 
Very good point, fixed. (I had put `if some_list:` rather than checking it was `is None`.)
Yep, I ran into that before. It was driving me crazy, seeing entries pop up multiple times in my list of list of lists...
Not sure what you mean. I'm talking about something like this: &gt;&gt;&gt; class Foo(): ... def __init__(self): ... self.bar = 42 ... &gt;&gt;&gt; f = Foo() &gt;&gt;&gt; def answer(self): ... print "The answer is {0}".format(self.bar) ... &gt;&gt;&gt; Foo.answer = answer &gt;&gt;&gt; f.answer() The answer is 42 
map (lambda _: [], range(3)) works too
That somewhat lacks the explanation about *why* using a mutable value as a default parameter is a bad idea (and why using `None` is recommended): * http://www.markus-gattol.name/ws/python.html#none_as_default_parameter_value
IMO, `[[] for x in range(3)]` looks cleaner. You could also do `map(list, [()]*3)`.
&gt; "2..n" adds a construct that won't be used anywhere else... And rarely at that. Keep in mind the most common case of range is doing "range(n)" which only has one parameter. So you wind up saving a grand total four characters with the new language construct. On top of that, using range itself is pretty rare. You're usually better off doing a "for foo in bar" or a "for i, foo in enumerate(bar)".
Ah fair enough. It can tell you when you've typo'd an existing variable but not when you say "mispell=4" and misspell misspell. However, I'd have to check, but I'd bet the static checkers can tell you if you have a variable that's never referenced anywhere. So if you never use "mispell" because you used "misspell" everywhere else it'd tell you about "mispell" and catch the error that way, no?
As for the annoying usually pointless "self" thing instead of: def roots(self): d = sqrt(self.b ** 2 - 4 * self.a * self.c) x1 = (self.b + d) / self.a x2 = (self.b - d) / self.a return (x1, x2) I'd prefer: met roots(): d = sqrt(.b ** 2 - 4 * .a * .c) x1 = (.b - d) / .a x2 = (.b + d) / .a return (x1, x2) Hopefully ".var" can be parsed unambiguously, and if not then "$var" could be used, tough it looks bad and perl-ish while the dot just fades in the background. Also this change is actually backward compatible with python, so the current form could still be used when needed.
Not saying that BS did not have its use, but a couple of years later we have better tools :)
For contrast this works fine in ruby: ▸▸▸▸▸ ~ viral$ irb ~&gt; Console extensions: wirble hirb ap rails2 rails3 pm &gt;&gt; [[]]*3 === [[], [], []] =&gt; true :P
The type annotation syntax you referenced already exists to some extent in Python 3. At least in callable definitions, you can use that syntax to annotate argument types, although it obviously isn't enforced. For example, this is valid Python 3 code: def foo(a:int, b:set): # do some stuff 
That's fair to say. To use my Python example translated to Javascript: function Foo(){ this.bar = 42 } f = new Foo() function answer() { console.log("The answer is "+this.bar) } Foo.prototype.answer = answer f.answer() The answer is 42 I don't mind that Python is explicit about it, but you're right that it's possible to do it the other way. One place I'll totally admit adding "self" gets annoying is when I'm prototyping, and I go "ok these functions should be part of a class", and I say "class Foo" and indent all my functions under it, and then as I continue I invariably find that I forgot to add "self" to one function after another.
That's not what I said and that's not the question I was answering. Dropping reduce is a _completely_ unnecessary break in backwards compatibility. That's the problem.
no it doesn't, same thing as in python a=[[]]*3 =&gt; [[],[],[]] a[0].push("a") =&gt; [["a"],["a"],["a"]] it's kinda justified if you think about this: b=["a"]*3 =&gt; ["a","a","a"] b.map { |e| e.object_id } =&gt; [20769640, 20769640, 20769640] So it creates 3 copies of the same thing. A naive implementation could look like this: class mylst(list): def __mult__(self, times): if len(self) == 0: return self collected = [] for i in range(0, times): for j in self: collected.append(j) return collected def __init__(self, lst): super(mylst, self).__init__(lst) 
The last one is impossible, you'd create ambiguity in cases such as `f.__name__`.
I am fully aware of that. If you read what I was answering, the question I got was «What arbitrary changes do you feel Py3k introduced?» All of the things I listed are backwards incompatible changes to the Python language that solved no real problem. One could argue that the changes make the language slightly better or slightly worse. I'd argue the latter, but it's by such a small amount that it _really_ doesn't matter. But what really _does_ matter to me is that making backwards incompatible changes _hurts_, and you should only do so in order to fix real problems. Changing the print statement solved no major problem. It just means that switching to Py3k i that much more of a pain. And I know about 2to3, but that's hardly a good solution.
looks like comprehension works as expected: &gt;&gt;&gt; newlist = [[] for x in range(3)] &gt;&gt;&gt; newlist[0].append(3) &gt;&gt;&gt; newlist [[3], [], []] &gt;&gt;&gt; So basically you should only have this issue if you use *X to pre-create your array elements. **EDIT::** fixed wording.
Also, here's a post by Guido van Rossum on [why explicit self has to stay](http://neopythonic.blogspot.com/2008/10/why-explicit-self-has-to-stay.html) that has some additional reasons why it is the way it is in Python. One more thing I'll mention is that I like, as Guido points out, the formal equivalency between F.answer(f) and f.answer(). For what it's worth, Lua works basically the same way as Python. foo:answer() (note the colon) is actually syntactic sugar for foo.answer(foo).
Standard library for HTTP that doesn't suck ass. Seriously, try uploading a file using Python in a portable way.
This may be unexpected, but I don't think it's a bug. In fact, I think it would be more surprising if it worked the way you want it to.
And of course, the same holds true for itertools.cycle: from itertools import cycle inf_lists = cycle([[]]) first = next(inf_lists) first.append('E Pluribus Unum') second = next(inf_lists) first == second
The new print syntax is slightly more powerful. But all of the most common use cases (print either a single variable, literal or a tuple literal of variables and literals) one character longer. In most non-american locales, parentheses require two key strokes, meaning the net loss is three key strokes, not one. Still, not a big deal. On the other hand, in python2, it is pretty easy to emulate all the new feature of the py3k print function by e.g. using str.join. Does making the less common cases a bit shorter and clearer outweigh making the common case a few characters wordier? I don't know and I don't care. The language is fine either way. But it is such a useless change to break backwards compatibility for. That's the real problem.
I am fully aware of that. If you read what I was answering, the question I got was «What arbitrary changes do you feel Py3k introduced?» All of the things I listed are backwards incompatible changes to the Python language that solved no real problem. One could argue that the changes make the language slightly better or slightly worse. I'd argue the latter, but it's by such a small amount that it _really_ doesn't matter. But what really _does_ matter to me is that making backwards incompatible changes _hurts_, and you should only do so in order to fix real problems. Changing the print statement solved no major problem. It just means that switching to Py3k i that much more of a pain. And I know about 2to3, but that's hardly a good solution.
No. &gt;&gt; a=[[]]*3 =&gt; [[], [], []] &gt;&gt; a[0].push("a") =&gt; ["a"] &gt;&gt; a =&gt; [["a"], ["a"], ["a"]] &gt;&gt; a === [["a"], ["a"], ["a"]] =&gt; true &gt;&gt; b=[[]]*3 =&gt; [[], [], []] &gt;&gt; b[0].push("a") =&gt; ["a"] &gt;&gt; a === b =&gt; true &gt; ruby 1.8.7 (2009-06-12 patchlevel 174) [universal-darwin10.0] 
If I understands the above code correctly, coming from a rubyist, that is generally how we do it though :)
I think it would be more practical for things like: function_list[n] = function(....): body of the function I've found several occasions it was useful to have an iterable or addressable list of callables, and I've always ended up with fairly odd ways of handling it.
I would have been fine with Py3k breaking all my code if it had offered something useful in return. Killing the GIL. Lambdas as real anonymous functions instead of only a single expression. A bunch of things like that come to mind. But a different print syntax and a different string formating syntax? There was nothing wrong with the old way, there is nothing wrong with the new way. It's just completely needless change. Useless. The only really important change is unicode strings. It's not enough.
You're saying it's unexpected the way it is now, but it would be even more surprising if it worked differently. Is there no way to resolve this unsurprisingly?
Just making Python PEP8 compliant would be a great goal for Python 4.
Presently, mutators returning `None` is how you tell that they're mutators. I would only want to see that go away if we had Ruby's convention of mutating methods ending in !. So, `my_list.sort()` returns a new list and `my_list.sort!()` sorts in place and returns the same list object.
What I don't get is why would anyone *expect* [[]*3] to be [[],[],[]]? Seems pretty logical that []*3 would *not* be the same.
It's not a bug. No joke. You can use this feature to provide a computed default value: _marker = [] def myfunc(myarg=_marker): if myarg is _marker: myarg = compute_default_value()
`nonlocal` fixes that, but seems kinda hacky. I'd like it if there was a difference between initial assignment and reassignment. That way the scope of a variable would always be clear. To take your example: def attachEventHandler(): x = 0 #RunTimeError! x undeclared! let x = 0 #Sets x at the scope of attachEventHandler def handler(): x += 1 if x == 10: doSomething() e.attach(handler) 
It seems to me the best solution at this time is to let the programmer decide if they want mutable or immutable objects. Putting it all on the compiler makes performance characteristics too unpredictable.
Surely for an endless cartesian product a generator is the best solution: &gt;&gt;&gt; from itertools import count &gt;&gt;&gt; p = ((x,y) for x in count(0) for y in range(3)) &gt;&gt;&gt; [next(p) for i in range(9)] [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] 
I don't know, the semantics of **[a] * N** seem pretty clear to me. I mean, if you have: a= [] b = [a]*3 a.append(1) You get exactly what you would expect: [[1], [1], [1]] ... a list with three references to **a**. For it to behave otherwise would either require the * operator to invoke copy() to produce each object in the output list (adding some completely unnecessary inefficiency for 99.9% of the cases) or to treat [[]] * 3 as a special case in the parser. That would be *really* confusing. 
No - see [here](http://www.reddit.com/r/Python/comments/hn0kl/3_is_not_the_same_as/c1wphcs)
Name it Adderol, and it will remind the MBAs of their time at business school.
To understand that you need to know about *values* and *names* and what role *assignments* play. That link is probably worth a look: * http://www.markus-gattol.name/ws/python.html#name
Yes it is, but if you want to do that on on arbitrary number of sequences/iterators (not just 2 like your example), then you need something exactly like product(), except as a recursive generator.
It would have be possible to resolve it efficiently if Integers, floats, etc. where not mutable. Then we could simply do a copy of each element, and the copy operation on unmutable objects could simply return the original object. Happiness is an option.
The first two elements become the last two elements when you're going through the string backwards: &gt;&gt;&gt; "1234"[:1:-1] u'43' 
Sure, but you want something less dynamic, while dynamic is the essence of Python.
You're saying "two" twice while I only see 1 in that expression; how does that work?
are you trolling? **EDIT**: I mean - this behavior is *exactly* the same as in Python as murmu wrote. Try it.
I was considering the case of replacing a method that calls `super()`. In that case an explicit call will still work: &gt;&gt;&gt; class A: def f(self): print("A.f") &gt;&gt;&gt; class B(A): def f(self): print("B.f") super().f() &gt;&gt;&gt; b = B() &gt;&gt;&gt; b.f() B.f A.f &gt;&gt;&gt; def nf(self): print("B.f: new and improved!") super(B, self).f() &gt;&gt;&gt; B.f = nf &gt;&gt;&gt; b.f() B.f: new and improved! A.f 
OK, I understand. I think it's simply something Guido wanted to bury stone cold dead.
Yeah, it wouldn't be the same. I had a brain fart, if you will.
Never? Never is too strong. You can use it to implement caches.
 I don't think calling copy() for each element is without its problems. See my comment.
&gt;Playing with your game now, but I'm not sure I get it. Looks cool though. Can you shortly explain the concept? I just started playing with the code for it yesterday, but the concept is to provide a set of puzzles that can be solved with different colored goos. It might start simple 'split, become smaller, now you can make passage through this tunnel, success!' and grow to be more complicated 'split green to y/b, blue is bouncy so jump off a high platform and bounce to a different platform, select the other goo, position him on some pressureplate, or whatever, blue goo goes on to perform other tasks, and needs to split later in his part of the puzzle, etc.' I want to add complexity slowly until the puzzles are kind of like, :o I'm still toying with ideas in my head, what goos should do what, should/how can they recombine? Is your score based on how many make it to the finish, or just how fast? Can they recolor (paint cans?). Can you die / should there be enemies, or just a struggle against the levels? Etc. I'm a full-time computer technician, so it's just something I'm working on in my spare time, but after making Mahjong I feel like I can tackle a bigger task. Currently doing boring work and implementing a TMX parser (for maps). &gt;Also, who's Vanessa and why are you writing games for her? She is my girlfriend, and because ever since we started dating she's been bugging me to make her her own Mahjong game. :P
From my experience, this language has the worst learning curve. I don't know why. Everything is documented etc, but I just can't get stuff to work. It is really bad at connecting the dots. I feel like I am missing something. I have written a Google App Engine application and thousands of people use it, but still I can't get basic things to work. Just now I am learning to use the unittest2 utility: http://code.google.com/appengine/docs/python/tools/localunittesting.html I try to follow the instructions but the damn thing doesn't find my test cases. I googled and googled and I still have nothing.
Well, they fail for me. Almost all tiling managers have a ridiculously crappy floating model. Window decorations are either absent or non-functional. Placement policies are typically non-existent or weak. Xmonad does *some* of this in contrib, but not enough. Furthermore, most tiling managers use either automatic management or manual management, rather than implementing both and allowing a choice. Almost all floating window managers have little to no tiling. Kwin has some feeble tiling support at the moment, and other window managers like Compiz have a "grid" plugin. But neither of these offer the full power of your typical tiling manager. Finally, multi-monitor support is the worst. For example, almost all window managers treat a multi-monitor setup as one monolithic desktop, rather than allowing independent desktops. (EWMH is partly to blame here.) i3 almost gets this right, but limits each workspace to only one monitor. Xmonad is the only window manager I'm aware of that gets this right 100%. Another multi-monitor feature that's nice is the ability to switch focus between monitors (even when a monitor doesn't have a window on it), or move a window from one monitor to the next. Xmonad is really close to nailing all of these, and I've modified my working copy of Xmonad a bit to alleviate some of my criticisms, but it has a fundamental design flaw in my opinion. Namely, it hard codes an abysmal floating model while still allowing other layouts to provide a floating model. Thus, when using a floating *layout*, you still get windows floated in the built-in floating model quite often (i.e., transients). This is supremely annoying, and it is my opinion that this would be a fundamental change in Xmonad's source. Almost everything I want is implemented in one window manager or another, but I haven't seen one window manager with everything I want. I came to most of these conclusions after I added a third monitor to my workstation. Before that, Openbox was sufficient. (The desire for independent workspaces drastically increased when I added a third monitor.) I'm now running Xmonad with a fair level of happiness.
it's named after monty python, not the snake species.
So the bytecode compiler would see that x isn't declared in the nested function and thus should not be added to the local scope, as compared to the current behavior: &gt;&gt;&gt; def f(): x = 0 def g(): x += 1 print("g's variables:", g.__code__.co_varnames) &gt;&gt;&gt; f() g's variables: ('x',) Which is remedied by `nonlocal`: &gt;&gt;&gt; def f(): x = 0 def g(): nonlocal x x += 1 print("g's variables:", g.__code__.co_varnames) &gt;&gt;&gt; f() g's variables: () 
guido has always wanted python to be "the specification", not "the implementation". the gil is *not* in the language. just use an interpreter that doesn't have the gil.
cool. Is the speed increase the primary reason you would prefer optional static typing?
"Special cases aren't special enough to break the rules."
My meta-build system [Minuteman.][http://larryhastings.com/minuteman/] The project is in a lot of flux right now, but give me a month or two and I'll have a hell of a good demo for you ;) You can also see the old demo in the PyCon 2011 lightning talks. Sunday afternoon, like 25 minutes in.
True, but copyright law deems that it's named after the [snake](http://python.org/images/python-logo.gif). 
Thus "python-like"!
Which part, and why?
Yeah. It actually doesn't seem to be too slow (but my machine is a beast). What I'm worried about is memory consumption... In either case, I chose Python because that's where my strength lies. This is also my first go at a window manager, and I suspect that I'll make so many mistakes that it will necessitate a re-write. In which case, I'll go with C or Haskell. Plus, it makes customization via scripting nice and easy. &gt; (especially with compositing) I don't plan on including compositing at the moment, although I have written a very basic and incomplete [compositing manager in Python](http://code.google.com/p/pycompmgr/). It only does transparency, and it actually works quite well. (To the extent that it is quite buggy.)
How is having statements separate from expressions more simple than just having expressions? I don't consider the code you describe hacky.
That seems worse than just using range, honestly. If not for that I'd kind of agree.
No, because after I mispelll it someplace I might use my be using my mighty Vim powers to replicate that mispelll-ing in other places, at high speed.
Is that meetup really necessary? I think most Python developers have heard of reddit or are using it regularly, just chat up with random people at the conference :)
That can also actually be a useful trick in some cases.
Please elaborate 
Not need for links, the explanation is simple -- the mutable value is created once when the function is created. There is only one of it. If it is modified, it stays modified for all the subsequent function calls.
`[:1:-1]` means to start at the last index and return, in reverse order, up to but not including index 1. Thus `x[:1:-1]` yields `x[3], x[2]` in the given example. Here's the corresponding slice for a length 4 sequence: &gt;&gt;&gt; slice(None, 1, -1).indices(4) (3, 1, -1) Given the sequence length, the slice object has to bounds check the indices and figure out what to substitute for None.
Lathering myself in the rage today
Yeah, but what if you want to be able to pass None?
+1 for static typing.
&gt; 99.9% of the cases Are you serious? When do you ever need n duplicates of the same list? Initializing with a set of empty lists seems by far the more useful case.
As Python is written today, no. The point I was trying to make was that _if_ all the common cases, i.e. floats and ints and strings where all immutable, then the copy operation on all those common cases could be reduced to a no-op, and suddenly there would be no performance or memory usage problem in the common cases. 
I only use the []*x expression when initializing things for later processing. Like numpy's arange, zeroes, ones, and other functions. I see now why it works the way it does, but for my typical use cases, I always want deep copies.
Bah, Python can pry my == out of my cold dead hands. == works fine, incidentally.
Wow thanks for the free pdf, you tool. I just deleted it. I'm going to download it again just to delete. it.
Actually you don't want to use 'is' instead of '=='. '==' tests for value equality, 'is' tests for object identity. In [1]: a = [] In [2]: b = [] In [3]: a is b Out[3]: False In [4]: a == b Out[4]: True In [5]: a is a Out[5]: True 
I guess so; what else? If it's optional it doesn't give you any safety, I suppose.
Hmm. I could put this question on a test for new hires and really weed out the good ones. [Excellent!](http://i.imgur.com/12T3m.jpg)
I came here to post this. This is a neat idea for objects that will always be the same and could provide a nice performance boost.
STOP SPAMMING
I would have failed it. Your loss.
First, dspdude is obviously making a joke based off of the magnets meme. He isn't actually asking a question. Second, the way you wrote that makes you sound like a condescending douche. Third, "that link" is obviously your website. It's kind of insulting to pretend that it's not. That said, it's completely valid to say "Hey, I wrote an article explaining this very thing. Take a look at it here(link)."
Expressions should have no side effects, meaning, if you evaluate an expression twice, it should evaluate to the same value. Breaking that rule, you have more concise code, but also harder to understand.
Statically typed code can be more readable, IMO. I've often found myself perplexed with function signatures while getting acquainted with new APIs - I think to myself, "does this expect a string, or a Foo, or what?".
The expression is evaluated once for each loop. It's like [func(), func(), func()].
I'm glad we're having this discussion. I've run into this nuance far too many times .
The main things I'm aware of are: 1) Larger web development community and toolset. I personally feel like Rails is better than Django, but not strongly enough that I want to argue with Django developers over it. Django is good too. The larger and more enthusiastic community is what does it for me. [Heroku](http://heroku.com) is a shining example of everything that's right with the ruby web development ecosystem. 2) [Shoes](http://shoesrb.com/). While not really useful for "real" applications, Shoes is great as an introduction to GUI programming, and for quickly hacking things together. 3) [Hackety Hack](http://hackety-hack.com/). I haven't looked at this too much myself, but supposedly it's fantastic for teaching kids to program. 4) Metaprogramming. Ruby lets you accomplish a lot of weird conceptual things that aren't quite possible in python. In practice, this can result in exceptionally beautiful DSLs. 5) Somewhat better support for functional programming idioms. 6) [Macruby](http://www.macruby.org/) is a great tool for building OS X applications without having to deal with Objective C. EDIT: Also, I can only imagine ruby has better testing tools. I don't have any experience testing python, but rubyists tend to value tests to a sometimes-unreasonable extent.
If I could design *any* language, regardless of how possible it is, it would be python, except; * Multi-level break (eg, `break 2`). Default can be 1, it's still backward-compatible. I don't care that it's like GOTO. * Optional static typing. * Explicit `instancemethod` (none of this "`self`" business!). * Easy cross-platform GUI building! (possibly Python's greatest failure, Qt numbs the pain only a little) * No GIL! * Optional `private` (not mangling!) and protection that isn't a `property` hack. * Native inline regexp (using python string methods is more readable, but dammit, sometimes I just want to regexp and don't want to `import re`, `re.this` and `re.that`.). * Perl/Bash-style ranges (`for int in {i..j}`) * Native bash-style pipelining (oh yeah!) * C-style `for` loops (`for ( i=n, i &lt;= m, i++)`) alongside `foreach` loops. I don't care for `for i in range(n,m)`. * Stack recursion limit boolean/flag, or better yet, no-recursion-limit decorator (Yes, I know I can `sys.setrecursionlimit(sys.getrecursionlimit+1)`, not the same). * (Cython) Native java-style ID (state hash) alongside pointer int (which is what Cython `id()` is). I feel this would also help tie Jython and Cython code together. * Easier composition (I find `class.method = mymethod` ugly, but that's probably to do with tying a first class staticmethod into implicit instancemethods). Perhaps a "`compose()`" method on `object`?
I guess that list multiplication is just not the tool that is intended or suited for this useful case. you can do b = [[] for i in range(3)] to get a list of three empty lists. And not every list is made of mutable objects that are only going to be used in-place. For the general case, it is more straightforward and consistent with the rest of the language to do what python already does. Even if it were truly proven that concatenated duplicates of lists show up more often in practice with copy()'d elements than with duplicated references, it wouldn't justify performing the extra operation implicitly in every list multiplication.
Decorators look useful. This functions-as-first-class-objects idea is something I sorely miss in ruby. There are hacks to accomplish the same thing, but they are much less pretty.
Then you can do def foobar(some_list=False): if some_list is False: some_list = [] 
I can't see the comment you're replying to, so I don't know the context of your comment, but I just want to point out that ruby actually has the same behaviour wrt integers. a = 4 =&gt; 4 ree-1.8.7-2011.03 :002 &gt; a.object_id =&gt; 9 ree-1.8.7-2011.03 :003 &gt; b = a =&gt; 4 ree-1.8.7-2011.03 :004 &gt; b.object_id =&gt; 9 ree-1.8.7-2011.03 :005 &gt; b += 1 =&gt; 5 ree-1.8.7-2011.03 :006 &gt; b.object_id =&gt; 11 
I'm just curious, how is this different than: def myfunc(myarg = None): if myarg is None: myarg = compute_default_value() 
Actually, this is such a common misconception that it is mentioned in [the core documentation](http://docs.python.org/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange). Which is probably where you got the example. In other words, sauceplz.
Some good ideas, but I hate C-style for-loops and I do not miss them at all.
In Python 2.x you could save a few keystrokes compared to the comprehension by using map instead: `map(list, [[]]*3)`. This maps the list constructor to each reference to the empty list, constructing 3 new lists. In Python 3 it returns a map iterator object that has to be exhausted by calling list again... meh. Anyway, it's probably better to use the list comprehension since that's a common idiom. You don't need to use range, though. Any iterable will do, such as `[[] for i in ';'*3]`, unless you really need to index them for some reason.
Totally agree, I'm far too lazy to rock the boat though :/
Okay, fair point.
Python already supports immutable objects - you can just override setattr and friends to reject any changes. I'm not talking about immutable objects as syntactic sugar (like private/protected/public are in other languages) but very fundamental like in functional programming. Having truly immutable objects in the functional sense makes message passing and marshalling a lot easier since objects can't change underneath you (ie the VM implementation). Additionally there is no need for the GIL or similar forms of locking because you mainly need to lock mutable data structures. Speculative execution and checkpoint/restore also become trivial (assuming no side effects - another functional programming fundamental).
Yeah I know about the method with range of course, but it's quite annoying when you want to construct a three dimensional matrix. I disagree, I think it's perfectly reasonable to have a special case for multiplication with lists, because there is no useful purpose for list multiplication otherwise. "Doing the operation implicitly" is a pretty relative statement, because most people explicitly expect Python to do this, and it would of course be well documented if it were changed, etc.
This is an issue with the python version you are using (I am assuming that you are using python binaries from python.org). Python older than 2.6 are built with gcc 4.0 on mac, so you need that installed (I think you can still get it from xcode 3.* if you request the compat for mac os x 10.4 or something). The simple solution is to use python 2.6 (2.7 would work as well). [EDIT] I actually misremembered. After checking on my macbook, the python from *Apple* uses gcc 4.2, whereas the one from python.org uses 4.0. The Apple python are installed in /System/Library/Frameworks/Python.framework, the python.org ones in /Library/Frameworks/Python.framework.[/EDIT]
You're absolutely right and I regret that I can only give you one upvote. It takes a picture, gets the picture's width and height, and verifies that the picture is not wider or taller than the arguments specified. Then, it makes it a little bit smaller if necessary to maintain the original aspect ratio, and, finally, it returns a picture which has been adjusted to the correct size.
right, but it's still a common way to load up a list on a single line, which is what I'm getting at.
I think if you try to get the 10.3 compatibility stuff you get gcc-3.3. You need to 10.4 stuff. But I think if you have 10.5 or higher you already have Python 2.6, don't you? Or do you need 10.6?
Just checked my python version, and its 2.6.5. For the record, I have the newest version of Xcode installed also. Apple 10.6 as well.
I'm confused.. how does that screw up `f.__name__`? The idea was that if a period was surrounded by whitespace, that'd be unique enough to denote the special case. (I've edited the original comment to wrap it with inline code formatting for clarity) If you understood that, and it really is a problem, mind providing a counter-example to help me wrap my head around it?
[__getstate__](http://stackoverflow.com/questions/5972445/problem-with-pickle-and-tkinter)
Sorry buddy, actually `[[]] == [[],]` Nothing like `(foo)` and `(foo,)`
... do I smell a fellow Schemer? Or maybe just impeccable taste?
I prefer: def foo(bar = None): l = bar or []
None, however, is a singleton, so you can rely on &gt;&gt;&gt; a = None; b = None; a is b True 
the difference is that in silviot's case, there is *no value* that can be passed to the function which will cause the function to think it has been passed its default value, whereas in your case, if I call myfunc(myarg=None), it will calculate a default value.
Thanks, that looks like exactly what I need.
What about `foo(bar=False)`?
Anybody who squabbles over syntax is dead weight
It is just an excuse to share a beer/chanti. I *will* chat with random people, it is just another (fun) reason to do it.
Questions like this should be used ONLY as "interview bonus points", IMO. You don't want to weed out a good thinker just because they don't know trivia.
This would imply to me personally that bar is supposed to be boolean.
I've taught myself Python over the last 2 months using that website, it did a great job.
Right, but l would be assigned to [] instead of False. It doesn't even need to be *False*, just something that evaluates to false. Say you pass in an empty list of your own? You'll get a reference to the new list instead of the one passed in.
Point taken!
I have to say I am utterly surprised. Ok, I didn't get that dspdude was making some kind of joke, still don't get it. I also didn't intend to sound, well, anything at all, I just wanted to help somebody by providing a link (yes my website; clear from my name and the URL so why say explicitly?). Sorry if that came out totally wrong, I am surprised ... I am not a native English speaker so maybe that's why. Or, well, no actually I am not sorry because I didn't do anything wrong nor did I have bad intentions, quite the opposite actually, just look at my history of posts, no mean stuff there at all. sigh. We don't see things as they are, we see things as we are. -- Anais Nin (1903 - 1977) 
&gt; **Username**: markusgattol &gt; **Linked website**: http://www.markus-gattol.name ಠ_ಠ
True and False as well.
I have had a diddle with [multiprocessing](http://docs.python.org/library/multiprocessing.html) before and it seemed to work well.
For even more flexibility there's [`__reduce__`](http://stackoverflow.com/questions/5238252/unpickling-new-style-with-kwargs-not-possible/5239396#5239396) (Stack Overflow) and `__reduce_ex__`, which are explained in [PEP 307 -- Extensions to the pickle protocol](http://www.python.org/dev/peps/pep-0307).
The problem is that the special case you suggest actually acts *against* the nature of list multiplication, for instance: [1,2,3]*3 produces [1, 2, 3, 1, 2, 3] [[1,2,3]]*3 produces [[1, 2, 3], [1, 2, 3], [1, 2, 3]] You are creating three copies of the list you're multiplying. You're *not* creating three copies of the contents of this list, though. Such an implicit copy would be potentially dangerous, and invalidate much of my already working code...
You need to install the SDK for 10.4 as well (see my edit)
well, they are immutable, in a sense. what about lists of objects? automatic deep copying of objects could do bad, bad things. 
This isn't a bug. It's working *exactly* the way its supposed to work. [a] * 3 creates three copies of the list and concatenates them, not three copies of the *contents* of the list. A list contains references to various things, possibly including other lists, but it does contain the items themselves. It's very important to remember that.
How on Earth does he sound like a condescending douche? I don't think it's far-fetched to imagine that someone might actually ask how references work. It's not "obviously" a joke, otherwise he would "obviously" have gotten it. It's an *in-joke*, and requires a certain amount of time spent retting oneself in the meme marinade, time not everyone is willing to give up. So just because he didn't "get it", doesn't mean a literal interpretation of the question makes him condescending--or a douchebag. Nor does it look to me that he's "pretending otherwise", when his username is the same as the name of his site... Rather, it is you who doesn't sound like the most affable UID in the internet line-up, when you think some dude sounds like a douche for not grokking an ICP meme. ICP! Hell, I wish I *didn't* get it. 
We should upvote this more. I can't even count how many times I've had to tell others about it.
It's true that this is confusing. The main reason for instantiating empty lists, or lists of empty lists, is to use them as append points for accumulators. In general I try as much as possible to avoid the accumulator paradigm, preferring comprehensions or other constructive constructs (i.e., ways to construct the list as you want it to appear immediately instead of creating it and then mutating it. I find my programs are much easier to write and read if I avoid this kind of mutability, or at least relegate it to a few small functions. However, yes, sometimes it's unavoidable. An example where you could replace `[[],[],[]]` would be to instead use lists of tuples and then transpose it using `zip`. Instead of: &gt;&gt;&gt; a = [[],[],[]] &gt;&gt;&gt; for i in range(3): ... a[0].append(i*1) ... a[1].append(i*2) ... a[2].append(i*3) ... &gt;&gt;&gt; a [[0, 1, 2], [0, 2, 4], [0, 3, 6]] try, &gt;&gt;&gt; a = zip(*[[i*1, i*2, i*3] for i in range(3)]) &gt;&gt;&gt; a [(0, 1, 2), (0, 2, 4), (0, 3, 6)] (Admittedly, that returns a list of tuples instead of a list of lists, but usually this is fine.) Of course, this is a trivial function. In a case where the above `for`-loop is more complicated, sometimes inserting a simple `append` in the middle of some complex calculations is really easier to express. In those cases sometimes the code can be cleaned up by moving the calculation to a function which returns the values in question, and using it in the body of a comprehension; this really depends on the context.
There is a backport for 2.4 and 2.5: http://pypi.python.org/pypi/multiprocessing
hm, I wonder why it was deleted. It wasn't a stupid question or anything. Basically they guy asked: If everything is a pointer to an object, how come when I do this: a = 4 b = a b += 1 print a it doesn't print '5'?
&gt; Actually you don't want to use 'is' instead of '=='. If you're testing for `None`, `True` and `False` you definitely want to use `is`. They're singleton values.
This is not going to work if `False` is acceptable as well. The usual way is to use an instance of `object` as a placeholder: _default = object() def foobar(some_list=_default): if some_list is _default: some_list = [] 
[/r/learnpython/](http://www.reddit.com/r/learnpython/)
This is how I expected it to work.
What is the space underscore for? doesn't map(lambda: [], range(3)) mean the same thing?
When will ´a == None´ give an unexpected result?
&gt; just use an interpreter that doesn't have the gil. unless you provide all the batteries.
You can actually achieve what you intended by using: def foobar(somelist = list()): ... This will instantiate a new list on each function call.
&gt; You'll get a reference to the new list instead of the one passed in. Which is fine IMO. Since in other case you're relying on side-effect, which in most cases is really undesirable.
I know, that's why I phrased my sentence thus.
I can think of some examples where you wouldn't want that, but you're absolutely right. This is all playing with side effects, which is most often the *wrong* way to do things.
&gt; When will ´a == None´ give an unexpected result? If `__eq__` has been overridden on `type(a)`. But more to the point, `is` is more readable for this case, and faster to boot (which never hurts).
A language is rarely just a language. Most of the time the language is a platform and here is where the shit hits the fan. Batteries included philosophy of python gave us a lot of functionality but also a platform that's inconsistent and violates line ONE in PEP-20 BIG TIME. Given enough power, I would DESIGN the python platform. I would design it to be beautiful and simple. I would look at the structure of iOS and morph that into a SANE platform where one can program to a modern virtual machine capable of GUI, networking, etc. I would make it so the developer could produce a self contained program for distribution out of the box. I would also like to see some kind of borg mechanism to isolate legacy code where one could install legacy platforms as plug-ins to current platform and assimilate old code. kinda like: assimilate(somemodule, 2.6) instead of a simple import. 
Even better, start ipython anywhere in your code: http://stackoverflow.com/questions/2026447/is-it-possible-to-tell-a-python-script-to-stop-at-some-point-and-give-you-the-han
It was for a sandboxing project that required screen scraping. VirtualBox has an existing python API, which is pretty darn good. There are a few quirks, such as, you can't access the framebuffer unless you manage all of the events and threads of the VirtualBox emulator. So my script was rather naive and just took screen shots every 0.5 seconds. The main script started the screen-shot-thread and X frame threads that would slice off a portion of the screenshot and paint it on an undecorated frame. VirtualBox has a "seamless" mode, but the frames created from the seamless mode are 1px by 1px and don't have a context. The view of these frames are actually just portions of an OpenGL context that covers the whole screen. So this script patched that problem allowing our other software to continue doing it's work outside of the sandbox.
**You should never assume normal arithmetic on a mutable type. That is the main thing to remember. ** Mutable types (set,list,dict) are there for performance reasons. And they are pretty handy for that. So do not add, substract, multiply with integer mutable types, unless you know exactly what you are doing. If you want a list (or set, or dict), construct it with comprehension, literals, or by an explicit loop. 
If you have little programming experience both Head First Python and Head First Programming is a good book (although they are not free ones).
We're talking about a feature which isn't already there, so how could it invalidate working code? (Assuming nobody actually wants identical copies of lists). I don't think a deep copy is necessary, if you explicitly specify that a list multiplication only copies the list. And the use case I was thinking of uses empty lists anyway. Also your example would be no problem, because integers are immutable.
Better and more comfortable: def default(doohickey, default): if doohickey is None: return default return doohickey def foo(bar=None): l = default(bar, []) You could even go so far and factor this stuff out into a decorator.
No it doesn't. See: &gt;&gt;&gt; def foo(l=list()): ... return id(l) ... &gt;&gt;&gt; foo() 174610924 &gt;&gt;&gt; foo() 174610924 &gt;&gt;&gt; foo() 174610924 list() is the type-constructor for list, but in this case it is called *only once* at "compile-time", then evaluated and incorporated into the newly generated function object. Thus the resulting list is always the same one.
Sorry, I used Scheme at a summer nerd camp when I was a teenager, but never since!
Perl is like a ghost story the PyDevs tell to keep the kids from wandering off into the forest.
I dunno, I just feel like if immutability is such a win, why do no successful languages (and no, Haskell hasn't succeeded yet) use it yet? It could just be laziness on the part of language developers, but my tendency is to believe that making everything immutable a) makes certain things that could be simple for users more complicated than they need to be and b) requires a level of optimization that is unrealistic for real world applications. Remember, in the end all languages *must* have side effects in order to do IO. Haskell hides this under Monads and whatnot, but you still have to do something.
...and I thought the OP comment was features "arbitrarily changing" between 2.x or 2.y or between 3.a to 3.b. And that's why I wanted examples - I haven't seen too many code breaking changed between minor versions. In the context of 2. -&gt; 3. there are lots and lots of changes. Good or not? - I can't judge. I run 2.7, haven't tried 3.2 yet.
Moral of the story: Lua is right and we should all be counting arrays from 1 instead of 0, but it is what it is.
Yep, my mistake
Or, if they fail to answer correctly, you can check how quickly they understand what's going on, or *if* they understand it at all, after you explain it. But I agree tricky questions should be used for bonus points.
Is it really needed for optimization? Can't a smart compiler figure out that this if-elif-chain can be rewritten as a switch statement internally? When I read that PEP I was thinking that the C fall through behavior could be activated with a continue statement; this seems justified as it's much more a special case than breaking out of switch.
Well in that case a temporary variable would help a lot. Not a reason for new syntax in my opinion.
You are at most guilty of missing a joke meme. I wouldn't sweat it. It seemed like you were trying to be helpful.
Map maps a function to elements of a list Therefore the function must have an argument, since the elements of the list are going to be applied The underscore is just a dummy, you don't care what's the element in the list, you're always mapping it to an empty list
This isn't trivia. It's pretty central to how the Python object model works. OK, true, don't be a dick and ask it as a trick question by trying to disguise the difference between the two, but something like, "How are `[[]] * 3` and `[[], [], []]` different?" is a perfectly reasonable thing to expect an intermediate or higher level Pythonista to be able to answer at a job interview. 
You're asking for a completely different language than Python then. In the language that `ascii` is proposing, you wouldn't be allowed to write `x[0].append(item)`. It's something utterly unlike Python.
Depends on the job. No offense, but based on your other responses in this thread, you aren't an advanced level Python programmer. There's nothing wrong with that! But sometimes, you need to hire someone with advanced level skills.
Never say `if a is True:` or `if a is False:`. Always say `if a:` or `if not a:`. It's in PEP-8, I believe.
That's a fine sentiment but since that's not enforced why do we still need a distinction between statements and expressions? `while do_side_effects():` is OK but `while a = foo():` is not, while arguably the latter is much more transparent (assuming foo is not using side effects itself). So while I agree with the rule of thumb of avoiding side effects in expressions, it's not an argument for statements vs. expressions.
I don't see how list comprehensions or sets are particularly hard. A list comprehension just builds up a list, a shorthand for a three line for loop. Either way, _you don't have to use them_, so what's the issue? For the longest time I didn't use an OO with Python, and it worked fine. I still know nothing about stuff like metaclasses and I it doesn't seem to matter. I think Python is absolutely the most suitable mainstream language for amateurs. You mention Java which is infinitely more annoying for a beginner with all its declarations and mandatory OO
I think it's much better to use "`_marker = object()`". This way it's obvious that you are using it as a unique sentinel, while I actually was confused by Silvio T.'s code right here and now, because I thought that he maybe wanted to cache the computed default value as the only element of _marker or something.
&gt; It would have be possible to resolve it efficiently if Integers, floats, etc. where not mutable. Integers, floats, strings, etc. __are not__ mutable. Lists, however, are.
I didn't mention Java - I mentioned C++, and I agree that they're both bad for beginners. However, having a feature in the language does mean that it gets used. Use of the simpler features just isn't "pythonic" at times, and you'll have some programmers implement every feature - just to see how they work. And then another beginner will run into that code and have to maintain, read or modify it. This is exactly the problem with Perl. 
OK, do you want `a + a` to create a copy of the contents of the list, if `a` is a list? That is, `[obj] + [obj]` is equivalent to `[obj, copy.deepcopy(obj)]`? Btw, are we talking about a true deep copy or a (one level deep) shallow copy? For instance, `[[a]] + [[a]]` should produce `[[a], [a]]` (still referring to the same object `a`) or the second `a` should be deep-copied? What if it doesn't support deep-copying? Or, do you want `a + a + a` be different from `a * 3`? Or, do you want it to be different _only_ when all elements of `a` are lists, or `a` contains a single element that is a list, or `a` contains a single element that is an empty list, or a list containing a single integer, or a list containing a list containing a single integer etc? You see, as of now there's one little gotcha, which can be more or less easily understood and avoided at the cost of writing explicit list comprehensions. The alternatives, after you consider their implications and edge cases, are _horrifying_.
I still think 0..n is more readable and coherent than range(n), or more precisely, xrange(n). Also, it's not limited to integers; it could apply to 'a'..'z'.
Whitespaces in expressions are ignored now. Currently you can write `a + b` and `a+b` with the same meaning. This also happens with `f . __name__`.
TIL about `code.interact()`. Cool!
It's OK to have impeccable taste, no need to apologize ^_^
..d'oh.
It would be even shorter if you used itertools.ifilter instead of a loop. It's nice to see pypy progressing. I think it would be interesting to see a breakdown of where the speedup actually happens. (Does this make sense for pypy?)
dspdude was referencing "Magnets - how the fuck do they work?" [know your meme](http://knowyourmeme.com/memes/fcking-magnets-how-do-they-work) cite this [music video line](http://www.youtube.com/watch?v=_-agl0pOQfs&amp;t=1m49s) but I feel the original inspiration to this whole magnet fiasco is none other than [Richard Feynman](http://www.youtube.com/watch?v=Dp4dpeJVDxs). 
Try this: def foo(a = list()): a.append(3) print a foo() foo()
Sounds good :) I'm doing some work on sickbeard to support more torrent sites, don't know if my code will be up to snuff to submit afterwards, but there's a lot of internal stuff I have issue with that would be really cool if someone could put the time in to fix. Torrent and NZB sites are called 'providers' in sickbeard, each with their own python module, problem is they're not self contained, so you can't just say, drop in a provider someone else has coded. Adding a new provider means modifying a bunch of different libs and config files elsewhere in the project which I find really inefficient and a poor way of doing things. I'm not a coder by trade, so not sure if it's within my own abilities to fix ;P
Okay, and what do you have against `unless`? I've only ever seen it make for more natural, readable code.
It is not enforced, but it should not be encouraged either. It would be encouraged if the assignment operator had a return value.
No I'd like a very specific exception for lists and multiplication. I mean a shallow copy. Addition is not confusing as it is, so it shouldn't be affected.
You did mention java ("something that a java programmer could pick up in a couple of hours"). I see what you mean but comparing it with Perl is unfair, because that's the extreme. Python is pretty conservative in that regard.
&gt; I mean a shallow copy. So "`[[0.0] * 3] * 4`" works as you expect, but "`[[[0.0] * 3] * 4] * 5`" doesn't?
Argh. Good point.
Wasn't that already done as far as names go? And the source layout can be changed without breaking compatibility, maybe even automated.
This will probably sound more like Ruby-bashing than I intended, but here goes: 1) I'm not convinced this is true. It's been a while since I did Ruby so I may certainly be wrong, but my general experience is that the Python ecosystem is more high-quality; just look at SQLAlchemy and Werkzeug for some examples. I do think Django is better than Rails *by design* not to mention the admin app for situations where it makes sense. Python also has heroku-like hosts, a whole lot of them in fact, such as ep.io or Google's appengine and plenty more. Ruby's Rack was modeled on Python's WSGI and while it's of little importance "who was first" it might be suggestive of maturity. 4) Again my knowledge of Ruby might be limited but I think Python has much better introspective capabilities, it can parse itself into an abstract syntax tree and compile such trees back into code, and save for Ruby's block syntax is, I'd argue, a more expressive language. Python has decorators (for both functions and classes) and proper object attributes (as opposed to accessor methods) but also the descriptor protocol for fine-grained accessors, there's coroutines and multiple inheritance and a real module system and function annotations, docstrings and list/dict/set comprehensions and generator expressions and seemingly more powerful operator overloading, and of course context managers. There are counterparts to *some* of these constructs in Ruby but they make more sense to me personally in Python. Different things look different in Python and it's a *good* thing. 5) Only because of the block syntax, which for most uses you can use decorators or context managers in Python. Functions are also more naturally first-class in Python, there's the functional concept of list comprehensions and there's also function partials and Python *does* have a lambda and closures. 7) If you consider ``foo.should be_true`` and sensible API, perhaps. :) For Python I suggest py.test or my own Attest. If you're into DSLs maybe have a look at [Konira](http://konira.cafepais.com/docs/index.html). Edit: Getting downvoted because I'm clearly not contributing to the discussion. Reddit, I'm losing hope.
Making all data immutable changes the sweet spot of a language, and especially when coupled with message passing puts it firmly in the army of co-routines space. People aren't used to writing programs like this yet. You are spot on about the side effects and I don't know what the best solution is there. (Monads are definitely not it.) We currently have languages like Python where their sweet spot is side effects making it very hard to do things immutable data allows and languages like Haskell where the sweet spot is immutable data making it hard to do side effects. Perhaps two different languages where there is a defined marshalling and message passing mechanism, or a single language with two different modes for functions. As it currently stands I still think that immutable data in a language that allows for easy side effects is where we should go next since it will get us away from locking and improve concurrency plus message passing.
Have a look at: * [stackless](http://www.stackless.com/), (specially at Microthreads) * [eventlets](http://eventlet.net/) * and [greenlets](http://packages.python.org/greenlet/) also, the main advantage of multiprocessing is not necessarily speed but blocking vs non-blocking events IIRC.
Awesome, a little slow over SFTP but definitely usable!! Thanks :)
Because of the GIL, multiple threads will not make CPU-bound programs faster. They may make IO-bound programs faster. Multiple processes will make CPU-bound programs faster, if you have multiple CPU cores available, and they're not blocked on a common resource. So you should use multiprocessing.
Use ipdb for added win!
Good idea!
Better to use a private variable like `_cache`. Remember, [_explicit is better than implicit_](http://www.python.org/dev/peps/pep-0020/).
I highly recommend this tool for developers of open source packages who wishes to ensure their code works in all supported environments.
Ah I see, thanks for the clarification. 
Right, that's the stuff I was able to find, but I figured there had to be a more pythonic way. \_\_reduce\_\_ seems to require mucking with \_\_new\_\_, meaning you have to keep your serialization code in sync with your constructor args. At that point it seems easier to write code to stick the relevant fields into a map a serialize that. That's actually what I'd been doing, because it also gets around the issue when you reload a module after you created an object, and pickle refuses to serialize it because the class objects aren't the same reference.
Can you explain in one sentence why it's added win? I don't know anything about ipdb or pdb atm.
i use deep copy anyway just to be sure !
This issue keeps popping up again and again on every single form of Python discussion forum I'm involved in. Copying a reference does not copy the value it points to! It never has, and it never will. The hours wasted could have been spared by reading [the manual](http://docs.python.org/reference/datamodel.html#objects-values-and-types). Sorry for the tone. It's actually commendable that you document this for future generations -- but it is **not a bug**. The bug was in your understanding of how things work. You should rather investigate and learn, and the you might feel inclined to teach others by writing [the threehundreth blog post](http://www.google.com/search?q=python+references+copy+blog) about how Python references work.
@donri Holding a discussion, while starting points with, "Again my knowledge of ruby might be limited, but" and finishing it with "to me personally", suggest that, clearly, you must paint it green.
Why you don't you initialize the lists as you need them? If you're creating a list of lists, you obviously have a some sort of loop to use them. Why couldn't you define the main list outside and then append the inner lists as they are needed?
With regard to points 4 and 5, I really can't agree with what you're saying here. Yes, the majority of ruby's power here comes from "just" the block syntax, in the same was as lisp's power comes from how everything is "just" a list. It's an immensely powerful construct. Ruby also gives you more access to mess with existing (and core) objects. Incidentally, ruby does have support for parsing into ASTs and then re-compiling into code, via gems in the standard interpreters, or natively in [Rubinius](http://rubini.us). Anyway, there was a discussion comparing their abilities on Lambda the Ultimate a few years back. http://lambda-the-ultimate.org/node/1480 EDIT: And as for point 7, yes, I do think that's a sensible API. Just because it isn't as easy or even possible in python doesn't make it worthless by definition. This particular case can enable the programmer to reason more clearly about their tests once they become familiar with it. I'm not actually claiming ruby has better testing tools than python, as I've never tested python -- just that it wouldn't surprise me if that were the case, given how crazy rubyists tend to be for the testing framework du jour. EDIT AGAIN: I didn't downvote you because I don't think you're contributing to the conversation. I downvoted you because claiming python has better metaprogramming capabilities than ruby is foolish at best. There are several things python does better than ruby, and this is the primary thing ruby does better than python. It's like if I tried to argue Java is better suited for writing device drivers than C.
What does painting it green mean?
https://github.com/flags/Somber A quick wrapper I'm making for PyGame designed to do away with a lot of repetitive coding. Main file is core.py. https://github.com/flags/bm2k11ts Brett's Minesweeper 2k11: The Show. Multiplayer minesweeper.
I would go but it's poor timing with my job. Otherwise I would have been signed up for it ages ago. In fact I'm a bit annoyed I wasn't able to do it.
You sir, have my begrudging upboat. You're definitely right though - if you don't understand the meme, it would look like an honest question since there's no other way to interpret that. That all said, being a redditor/of the internet, it's not exactly that obscure of a meme? Regardless... shouldn't assume that everyone else wastes as much time as I do. - As far as the condescending douche goes, it wasn't that he offered advice, but the manner in which he wrote it. Unfortunately, I'm not the most concise or clear writer, so bear with me. &gt; know about *values* and *names* and what role *assignments* play. What came across as condescending was the italicized emphasis in the sentence. Maybe this is just my inner reading voice, but this is the kind of emphasis I would stress when explaining a concept to someone with no understanding of the subject. For example, if I were explaining basic division to a kid, I might stress words such as numerator and denominator. However, if I were explaining a more annoying integral with something nasty in the denominator, I wouldn't stress these same words while explaining how to tackle the problem. Yes, the problem contains a numerator and a denominator, but dammit... you're not 6. You know what they are and why the hell am I explaining them to you? And that's what rubbed me raw with the wording. If you take dspdude's post literally (and within the context of the OP), he's concerned with the complexities of references and how it relates to nested arrays. Yes, variables, variable names, and values assigned to variables are related, but they aren't the concepts being discussed. And if you take a look at the link provided, it discusses nothing about references in that section. A little about object references above, and a little bit about basic array assignment below, but nothing relating back to dspdude's question. Given the tone, and the incredibly basic material he was talking about, the advice Markus was giving came across as not only irrelevant, but incredibly douchey. It almost seems like a backhanded insult. Again, I suck at writing, let me know if that made close to 0 sense. &gt; That link is probably worth a look: Regarding the link, when you say "hey, check out that object", you imply a certain disownership and lack of vested interest, which gives it a more objective quality. "I am recommending this material to you because the author is an exemplar of his field and this work is a clear mastery of the subject." However, when this work is your own, presenting in this fashion comes across as disingenuous. Not only are you biased towards your work (objectivity lost), but you potentially stand to gain from the traffic. It's kind of why bloggers will get flak for 'spamming' a subreddit with their daily posts. However, it seems like it's generally kosher if bias is admitted? "Hey, I just wrote a tutorial on __ - check it out here." As a reader it gives some level of context to the bias, so you know what to expect ish. &gt; his username is the same as the name of his site... True, but not everyone always thinks to check username. So I kind of didn't think to check. Basically, this was the thought process * notice reply - wow, douchey post * notice "STOP SPAMMING" - ok, douche is a douchey spammer * make silly assumptions - why do spammers continue to submit posts their '3rd party' links when people continue to call them out on it? * submit my post/don't check username until later. So I was more than wrong on that, but it made sense at the time. - Anyway. That's why I thought this guy, Markus, came across as douche. I still think the wording comes across as condescending, however, I should have just bit my tongue. It seems like he's actually a nice German guy who's really trying to help another redditor out, and it's more just differences in language. edit: formatting
I knew strings where unmutable, but I'd got it in my head that ints wheren't. Learn something every day, I guess. :-)
You have to create an instance of add first. Creating an instance makes an object of a class. Example: class Add: def add1(self, x): print x+1 a = Add() a.add1(1) Note that if you're on python 3 that print has to be print(x+1)
Hey, thanks for taking a swing at the question in the first place. It's not an easy task and they're obviously shark infested waters anyway. 
I did what you said and finally did a.add1(1) and get Traceback (most recent call last): File "&lt;pyshell#8&gt;", line 1, in &lt;module&gt; a.add1(1) TypeError: add1() takes exactly 1 argument (2 given) Python must be bullshitting me I DID give it one argument Please! Help! EDIT python 2.6
ah, sorry, you're right, I fucked up, edited my original post to fix this now. It takes 2 arguments because the first argument has to be self. Self is the instance. Try reading the python tutorial, it'll teach you all this. May also help to do a little reading on Object Oriented Programming to understand it's purpose first.
Thanks alot IT WORK OMG MY LIFE IS COMPLETE AND ALL THE ANGELS BOW DOWN TO YOU (and then they wince at the all caps)
Depends. Initialisation of new processes can be costly (depending on the OS). Also, for multiprocessing you basically copy the process and all it's data, so the memory consumption is higher than with multithreading.
Python 3 doesn't have unbound methods: &gt;&gt;&gt; class Add: def add1(self, x): print(x+1) &gt;&gt;&gt; Add.add1(..., 1) 2 &gt;&gt;&gt; Add.add1 &lt;function add1 at 0x010023D8&gt; 
Hey Markus, I apologize - I kind of made an ass out of myself. I responded to [cloaca](http://www.reddit.com/r/Python/comments/hn0kl/3_is_not_the_same_as/c1wray1) just below, so I won't go into depth here, but I tried to explain why the post came across as condescending. Let me know if something doesn't make sense, and I can try to clarify. English is my first language, and I'm never quite sure if I'm making sense to others. Best.
I don't think he wanted an unbound method, he was asking about basic OOP, so I told him to create an object.
I just meant he couldn't have seen that error on Python 3.
If your function needs to accept either None, False, or a List, then you are probably doing something wrong in the first place.
Great comment, but this sort of boilerplate is exactly the kind of stuff I hope to avoid by using Python. Does this bother anyone else?
"except when they are" (or rather, "practicality beats purity")
&gt; (formatting is off a bit blame reddit) No, I will blame your lack of markdown knowledge. See that link on the bottom right of the box you are typing in? Click on it. It's called "formatting help" and it does exactly that.
`'['*3]` messes with my brain which then sees a mismatched `[` on the far left. &gt;,&lt;
You know the part where you pushed "a" on one list, but it appeared in all three? Yeah. That's the exact weird behavior we're describing in Python too...
@7cardcha, you don't have to manually insert 4 spaces. IDLE and most other editors can adjust the indent level of a selection with a programmed key binding such as &lt;tab&gt; and &lt;shift&gt;&lt;tab&gt;. Also, it's not mentioned in the quick help that you can use inline code by enclosing it in backticks (typically shift tilde), such as typing `x ** 2 + y ** 2` without the exponentiation operators getting mixed up with making ** 2 + y ** bold. 
FTFY... just don't make me have to move my fingers too much. Now I'm messing with the semicolon worshipers.
Testing raw x ** 2 + y ** 2 indented four spaces x ** 2 + y ** 2 
I just discovered iPython recently, great tool!
Dude this is just plain wrong. Assuming you have a class A, derive B from it, and the method in B calls your super variant, then in the A method, self. _ _ class _ _ will be B which is just wrong: class A(object): def method(self): print self.__class__ class B(A): def method(self): super(self.__class__, self).method() B().method() will give you: &lt;class '__main__.B'&gt;
I respectfully disagree that this isn't trivia. I don't have a ton of Python experience (worked with it for ~6 months professionally), but the experience I do have is non-trivial. We took advantage of many of Python's more "advanced" features, including metaclasses. I don't claim to be an expert, but I do think I have a fairly solid working knowledge of the language. Not once did I consider multiplying a list; I never needed to understand the mechanisms behind that syntax. There may be some instances where it's a appropriate, but they seem like either 1) corner cases or 2) domain-specific cases. Expecting all experts to have hit either 1 or 2 seems unrealistic to me. You're going to needlessly eliminate a lot of qualified candidates if rare cases become your filter. Now, whether or not they *understand* the difference between the two is another issue, as silviot points out. There's another point too, which is that I would go out of my way to avoid using this syntax simply because I've never been a big fan of Python's overloading of this operator (lends itself to exactly this kind of misunderstanding). So now you're not only testing me on a rare case, but on a case that I specifically avoided because of its ambiguity. Personally, I would be happier to have a candidate who avoids ambiguity than one who knows trivia.
Thanks
I'm sure he's super-relieved.
Well, yeah, probably, but at least that's the right way to do the wrong thing :-).
It's not IDLE, but you can run `python -i &lt;script&gt;` to go into interactive mode after running the script.
Is there any reason why people seem allergic to using a debugger?
Don't use "from x import *". Just use "import x". Then refer to the imported variables as x.y, x.z, etc. Makes the code much more readable, and errors like this easier to figure out.
It's hard to be sure what's actually going on without seeing more code. All the error tells me is that you tried to access a global variable that was not defined. What file contains the line "player = HeroClass()", and where in the file does that line occur? What file contains the code that tries to access "player"?
This is what I was looking for; thank you. 
Sorry I tried to explain it the best I could without having to upload it. Edit: I suck at formatting. * player = Hero() * Player is a global variable in the main.py * Hero() is a class that's in the player_class.py What would be the best option to upload my files so others could see?
I will agree that it's pretty rare that you multiply a list, unless you're dealing with numeric analysis-type stuff.
I'm getting a similar error if I both change the import to "import player_class" instead of "from player_class import *" and changing the following line. * player.player_profession * main.player.player_class = 0 Error below if I try setting the variable. * NameError: global name 'main' is not defined
Well, it all depends on what your scripts are actually doing. If there's network io you might want to have a few requests in flight, and if there's cpu use you might want to try PyPy. If you are disappointed in the performance of a script you use often and want to speed it up, start by profiling it, with `python -mprofile` or similar.
[Pastebin.com](http://pastebin.com/) is one pretty convenient option.
None of the things you pasted so far ever referenced "main". Care to just paste the player_class.py and the file that imports it somewhere? dpaste.com pastebin.com ;)
Try this: For beginner: http://beginpython.com You learn by following instruction given and practicing right away. 
Yep, that last update seems to have done it.
Damn. I replied this without trying it because I was sure I had read this as a solution to this issue in an article some time ago. It seems that either the article was wrong or I'm the one that is remembering it incorrectly. I suspect the latter.
[Dropbox of my zipped files](http://dl.dropbox.com/u/13819979/player_class.zip). Sorry for me not explaining well and not uploading this sooner. I thought "main.player.player_profession = 0" would go to main.py, look for the class player, the variable player_profession, and set it to 0. Am I getting that wrong?
Ah, here's the problem. 'player' is a global variable in the module main.py, but you're trying to change it from the module player_class.py. Basically, this is backwards: main imports player_class, not the other way around. So main can access the stuff it imported (i.e., stuff in player_class), but player_class cannot see anything in main. Importing is a one-way street. This is an example of why functions that use global variables should be kept to a minimum: the relationships between different parts of your code can get confusing pretty quickly. Instead of using a global, why not have your set_class_X functions take a player parameter instead? Something like: def set_class_war(player): player.player_profession = 0 player.stats_main[0] += 200 player.stats_main[1] += 50 # etc. (Bonus points: I'd also suggest thinking about how you might make Warrior, Wizard, and Rogue subclasses of Hero, instead of just using a single Hero class with a handful of functions designed to mash a given Hero into the desired shape.)
[pdb](http://docs.python.org/library/pdb.html) is the python debugger. [ipdb](http://pypi.python.org/pypi/ipdb) looks like pdb but with all the nice features of [ipython](http://ipython.scipy.org/moin/). If you don't use ipython... I'm not sure how you live. Code completion, history search, input-output reference... I don't know what I'd do without it. 
Seems fine. Nice job on the game.
Maybe it turns out that there are multiple types of tools, each of which is useful in different situations? The debugger's great when you have an idea of where the problem is and want to step in and just watch that code very briefly. The profiler's great when you want to gather broad statistics on how your code runs. And the tracer's great when you have specific areas of code that you want to get stats or other information on.
Those are the exact sources I used for that when I did this exercise a few months back. 
Some love for PyLint? http://www.logilab.org/857
Yes, but the question as stated makes clear they're *going* to be different, which, with a modicum of intuition about how python works, should be enough to let someone guess the actual behavior.
&gt; If your function needs to accept either None, False, or a List, then you are probably doing something wrong in the first place. Intermediate layers (such as some types of decorator) may not know or care what values are passed in if they're merely forwarding them.
This is how I did it. I just copy and pasted the bits that deal with it so sorry if its not formatted or anything. class fungusGroup(pygame.sprite.Group): def __init__(self): pygame.sprite.Group.__init__(self) fungals = fungusGroup() for x in range(len(orgas)): o =fungus() fungals.add(o) rectList.append(o.rect)
[Pricetack](http://pricetack.com), my first major project from scratch. And on Web2py.
The [Web2py](http://web2py.com) Book and Web2py Framework will have you programming a database-driven web site in very little time.
Since the selection on Ruby is more limited, check out all the frameworks: Django, Web2py, Bottle, Web.py, Werkzeug, Pylons, Pyramid, Flask, TurboGears, Tornado. Also, Google App Engine.
Probably the best Python IDE option out there. 
Even if you don't use the techniques directly, this article will deepen your understanding of class decorators, super, mixins, and various ways of composing behaviors. Not bad for a 5 or 10 minute read.
&gt; Note that if you're on python 3 that print has to be print(x+1) I didn't know whether or not ultranonymous was aware of the fact, considering this extraneous advice quoted above. The comment was not intended for 7cardcha.
The specification could require the implementation to be GIL-free.
Thanks
yeah, there are lots of eclipse haters, but once you get to like it, it's hard to switch. pydev is also what keeps me there, brilliant.
It's all right, no offense taken, obviously all this was a misunderstanding from the very beginning, let's not waste any more precious time/energy on the matter. I am happy though you came forward like this, shows you have enough self-confidence, honor and rightfulness to correct mistakes you made. I salute you for that! 
Get [Programming Collective Intelligence](http://oreilly.com/catalog/9780596529321) and implement all examples; Then, modify them for Python3 (and for your own use). 
True. Still, TIL that you can run individual test-cases in the interactive shell.
[PuDB](http://pypi.python.org/pypi/pudb) for debugging graphically in the terminal. It's great!
There is no such thing as 'ugly range statement'. There is generic for statement, which works with any iterable, and there is range function. And this decomposition is pretty good, actually.
Well, most of such suggestions does not require too much taste to say no to, but I agree.
You might want to see http://norvig.com/python-iaq.html , part about dictionary literals.
Python already has multiple expressions in lambdas. For convenience, define Scheme's begin as so: begin = lambda *args: args[-1] Then you can write a Scheme-style lambda with an explicit begin: lambda x, y: begin(print(x), print(y), x + y) (let expressions would be very useful, though...)
That's pretty neat. But without being able to do something with the results of the non-final expressions they can only be used for side-effects ...
No, I am using eclipse + pydev for school. Hate it. I have never really liked the way eclipse does things. But...I will try this version to see if it is any better. BTW...it isn't PyDev I don't like. Just eclipse.
As screen is server-side, you can use Terminator on your client and still use screen on the server.
For Java libraries missing source code I always used Jad, but it looks like that is now abandoned and http://java.decompiler.free.fr/ might be the way to go.
That is the one I am using as well. I like it too.
would you look at that. A discussion on language brings up the GIL. /facepalm ^1000
Lacks SCP support though. Which I found weird.
Some basic but useful tips 
Thanks, I think I got it working. Now to figure out your homework ;D
As a fellow C# dev interested in learning more about Python I found this highly interesting. I sympathize with your sentiment that .net and java developers seem to over-engineer everything, I've started looking into Python and Ruby for much the same reason.
I think you're confusing immutability with singletons.
*If* you get to like it perhaps it is hard to switch. I couldn't get any further than a grudging toleration.
 def foobar(somelist=None): somelist = somelist or [] What bothers you exactly? You're creating an instance of a mutable type at the time of definition. This is _exactly_ how it should work. If you want a fresh instance, you should create it explicitly. Consider this: SOME_GLOBAL_DATASET = [] def add_to_dataset(obj_to_add, dataset=SOME_GLOBAL_DATASET): dataset.append(obj_to_add) For the sake of this example, I'm using a list and a fairly straightforward operation. Code using the same principle can be found in the wild, though, and it wouldn't work if function definitions worked as you propose.
True, but there are very few cases where this is the case and the function still needs to create a fresh instance of a default value if a keyword argument is missing. In those cases a marker object is an option, but that says nothing about everyday use (where None/falsy defaults for mutable arguments mean "no explicit value passed"). i.e. if some cheeky muppet wants to pass empty strings, lists, dicts, tuples or boolean `False` as an argument for an optional keyword, that's their problem and not mine. The documentation (in code and in text) should make it perfectly clear of how the function should be used and anything beyond that is just monkey business.
&gt; You're creating an instance of a mutable type at the time of definition. This is *exactly* how it should work. I disagree. One extra line of code is not how it should work in my ideal language. I'd prefer it if default variable assignments were freshly re-evaluated each time a function is invoked. But that's just my wishful thinking for python.
Special cases aren't special enough, and all that. It may work differently in another language, but that behaviour would be inconsistent with how the rest of Python works. Neither approach is without its drawbacks and there's little incentive in switching one set of them for another if the current approach is perfectly fine except for some cases (i.e. instantiating mutable values as defaults) which can easily be worked around. The syntactical overhead is minute and the only people bitten by it are those coming from another language that behaves differently or those who don't understand how Python's variables work.
I'm having some trouble (again) and I'm hoping you could either help me, or point me to a good site that can help beginners like me. I'd like to have something like [this](http://www.lucidchart.com/documents/demo/4de53870-2a1c-468b-8ded-307b0a7ab53f) for how my battles work but I don't know the best way to organize it. Right now I have a back and forth battle system set up but I'd like to create a new file with all the battle functions would be, including ones not created yet like chance to hit, speed (for who goes first), etc. I'd like to start off making it right rather than hobbling it together as I go. My thought is to make all the battle functions go inside of a separate file. The main battle function would call who_attacks_first, which would calls does_the_attack_hit(attacker, defender), which might call deal_damage(attacker, defender) which would modify the hp of defender. Is this a good way to proceed or is there a smarter way to do it?
How about a "why" or at least a list of their contributions?
By the way, profession has 1 F.
I'm not sure I quite go so far as to call myself a game developer, but I've a python roguelike I poke away at now and again. https://github.com/DanaL/crashRun
The ones I know off hand &gt;Benjamin Peterson 2.7/3.1 release manager, core dev. &gt; Mark Hammond Windows and XPCOM (XUL) integration, core dev. &gt; Brian Curtin Runs the PSF Sprint Committee, core dev, big Py3 evangelist. &gt; Victor Stinner Low-level/VM expert, made PySandbox (to date the only CPy sandboxing tool people haven't been able to beat that I know of), core dev. &gt; Dan Greenfeld Lead on Django Packages and the new Python Packages site, Django and Pinax dev, does awesome cartwheels. &gt; Nick Coghlan Core dev (don't know him well). &gt; James Tauber Lead on Pinax and Pyjamas, founder of Eldarion (well regarded Django/Pinax consulting shop), international man of intrigue. &gt; Raymond Hettinger VM and algorithms expert, core dev. Has forgotten more than I will ever know about data structures. &gt; Guido van Rossum BDFL Afraid I don't really know the rest that well.
http://www.devshed.com/c/a/Python/PyGame-for-Game-Development-Sprite-Groups-and-Collision-Detection/2/ I've haven't looked at pygame much, but that link should help you.
There's a few on this list I didn't recognize, but here are the ones I know: &gt; Benjamin Peterson PyPy and CPython core developer. CPython release manager for the 2.7.x and 3.1.x series. I think he just graduated high school. &gt; Mark Hammond Author of [pywin32](http://sourceforge.net/projects/pywin32/), currently working on [PEP-397](http://www.python.org/dev/peps/pep-0397/), author of [Python Programming on Win32](http://oreilly.com/catalog/9781565926219) &gt; Victor Stinner CPython core developer, general Unicode master, author of [faulthandler](http://blog.python.org/2011/05/new-faulthandler-module-in-python-33.html). &gt; Dan Greenfeld Involved in the Django/pinax community, presenter at various conferences. &gt; Nick Coghlan CPython core developer, author of the ``runpy`` module, frequent contributor on python-dev and seems to review just about every checkin ever made. &gt; James Tauber Founder of Eldarion, core Django and pinax developer. &gt; Raymond Hettinger CPython core developer, author of several modules, established speaker and teacher, and he's now tweeting almost daily Python tips. If you pick one person from this list to follow, it should be him. &gt; Guido van Rossum He is. &gt; Antonio Cuni PyPy core developer &gt; Alfredo Deza Pretty involved in the Testing In Python mailing list and various testing tools. &gt; Brian K. Jones Currently working with @dabeaz (Dave Beazely) on the new Python Cookbook. Him and Dave also gave two tutorials at PyCon 2011.
I'm near the bottom of the list. I have no idea why. I don't recommend that you follow me.
Hm, I'll keep iPython in mind later. As for now I'm at the basics, and therefore will stay with IDLE.
me too. 
Well, I would be a little dubious of a function named "who_attacks_first" doing anything besides examining its arguments and returning a value that indicates who attacks first. It probably shouldn't go on and actually *perform* the attack. One reason for this (besides the name being deceptive) is that the two operations are themselves distinct and might require different information. Finding who attacks first might only require looking at the two combatants to see whose speed is higher; but checking miss rates and damage might also require knowing what kind of attack is being performed: for example, suppose you wanted different attacks with different miss rates? If that were the case, a call like "who_attacks_first(attacker, defender)" would be missing vital information needed to perform the hit check or damage calculation. In other words, keep each function's task as simple, focused, and clearly-defined as possible. This will help keep your design easy to understand. If you treat each of those functions as single units, your main battle code could use them to coordinate the process, something along these lines: * Use who_attacks_first to determine the order of turns * Each time an attack is processed, check if it hits with does_the_attack_hit * If it hits, call deal_damage That's just one way of doing things, of course. It would be valid to represent an entire combat turn as the evaluation of a single function which then delegates to other functions (in line with your current idea), but in that case I'd suggest giving that function a name that properly describes its purpose. ;)
since bottle is only one file, web2py could easily absorb it's power now
I was going to add the reasons why but I got lazy and just hit post. Thanks coderanger for your additional info. Not all of the people are well known but I like some of the stuff they have to say; deal with it people.
Awesome! By the way, VeraMono.ttf isn't necessarily going to be on your end-users machine. You may want to include it with your distribution (and the repo in the mean time!) :)
Write less code. Especially less classes. You can go a long way with functions and decorators without having to create classes. You should also use list comprehensions more than you probably think you can. Also, the standard library is your friend. `functools`, `operator`, `collections` and others can come in handy when you least suspect it.
Ah, yeah, when I package releases I include the font. It never occurred to me to include it in the repo though.
Never. It's way too noisy. Its constant nagging about variable names and such is more annoying than useful and drowns out the important stuff. `pyflakes` misses a lot of things, but a good IDE can pick most of them up. Now if only `pyflakes` was fully compatible with 2.7 (e.g. set literals and dict comprehensions)...
Well, from randomly clicking on several of them I found you follow Conan (which I also follow, thank you Twitter-stalker-algorithms) so you've got my vote :-) You also seem to be about as active on Twitter as *I* do... which tells me you're *probably* busy with "Real Shit(tm)"... So there's another mark in your corner... So... *bam*... Followed... IN YOUR FACE! 
What about Armin Ronacher (mitsuhiko)?
install CherryPy http://www.cherrypy.org and you are set nothing else required to get started! it is not the fashionable way to do it but it kicks arse dead simple, good enough performance wise for 99.9% of the web sites out there and a mature project backed by a friendly community!
You are missing the point.... Almost any python framework does something like this (not quite what I suggest but some extension of what is suggested by the page you link). I coded[this](http://web2py.com/examples/static/epydoc/web2py.gluon.storage.Storage-class.html) for example. The problem is performance. In my code the __getattr__ code is the single most called function.
If you have more developers you think should be on the list could you post a comment on the post?
Dammit. Now I feel obliged to tweet insightful things.
Additionals: @alex_gaynor Django and pypy core dev, plus a funny young gentleman. @dabeaz Python author, awesome hacker, good guy. @jessenoller Core-dev (multiprocessing), PyCon chair, highly amusing. @jacobian Django BDFL, talented guy. @holdenweb PSF chair, dry wit, accumulated wisdom of his many years, Python tutor and author, swears profoundly. @fijal pypy core dev, strange polishman. @cfbolz pypy core dev, scarily intelligent and deeply decent German. @mitsuhiko Austrian Python web genius. Creator of flask, bottle, jinja2, etc, etc, etc. @birkenfeld Python core-dev, occasional release manager, creator of Sphinx. @nedbat American but still a good guy, long time pythonista and author of coverage (testing tool). @gpshead Core python-dev, threads and processes man, googler. @rdavidmurray Core python-dev, currently working on email6. @jackdied Core python-dev, biggest claim to fame are class decorators and gopherlib... @tarek_ziade Token Frenchman, core python-dev, foolhardy enough to tackle sorting out the distutils mess in the standard library. Mozillean. @ianbicking Another Python genius, probably responsible for starting half of the core Python infrastructure that isn't in the standard library. @carljm Now maintaining half of the projects that Ian Bicking started. Django core-dev. @jezdez Django core-dev, another talented German (I believe). That's a good selection of some highly talented Python programmers from my twitter stream who weren't mentioned. Lots more out there of course. I'm @voidspace (another python core-dev, looking after unittest and maintainer of unitttest2 and mock, token Englishman).
CherryPy is definitely the way to go for a beginner. It'd dead simple; give it a go, and come back to ask questions if you need help!
It depends on your needs/wants. Generally it involves either using a python-based server with a python framework, or using a python framework with apache and mod_wsgi. Some nice frameworks: * [Django](https://www.djangoproject.com/) * [Flask](http://flask.pocoo.org/) * [Bottle](http://bottlepy.org/docs/dev/) Personally I recommend Flask or Bottle to get started.
You can't tell me not to follow you! \*followed\*
Huh? What makes you say that? I know that you can have multiple immutable objects representing the same value. But you don't _have_ to. If you're asked to make a thousand copies of an immutable object, there is no reason to not return a thousand copies of the same object, even though there is nothing _forcing_ you to do so either. It's just an obvious optimization.
Then you'd undo one of his reasons for following you...
Turns out most uses of lambdas in my code were easily replaced by `functools.partial`. "Real" lambdas would be interesting, but there's no way to make it work without changing fundamental assumptions about the syntax.
I approve of this list, and of the fact that I'm not in it (since I only tweet about silly things).
[CoffeeScript](http://jashkenas.github.com/coffee-script/) - brings a syntax inspired by Python and Ruby to JavaScript.
My IDE of choice would have highlighted that line in neon red for being a statement that has no effect. Just saying.
Why not start with Erlang and add Python's style of syntax?
Bottle is really simple. Once you get a hang for it, you can expand into larger frameworks. Flash is "the new bottle", but because bottle is literally everything you need in one script (bottle.py), it's a great place to start experimenting.
How about just: def foobar(some_list=[]): if some_list is foobar.func_defaults[0]: some_list = [] 
`unless` and `if not` are identical in length and the former is no more readable than the last; I would even argue it's less readable because it requires you to grep for an additional keyword to find all conditionals. Now, if you mean conditional assignment (pseudo-Python `foo = bar if qux`), that's a different matter. That's not going to happen unless Python makes assignments an expression (which would contradict how Python currently handles names). It's also not much less typing than what's currently available; except you now have to look in two places to see whether a line will be executed.
Annoying shift? Are you even aware that most programmers in the world have to use shift _or worse_ for most characters needed in programming? I don't even notice the shift key any more. Maybe you should work on your typing skills.
I find the colon makes the code more readable and easier to scan. Maybe I'm weird.
IIRC this was introduced with various use cases in mind, also including per-argument docstrings (I think `Sphinx` took care of that need for the most part). Type annotation is one of the more practical use cases, but the idea is that it helps converting the resulting Python code into a typed language more easily (e.g. for compiling).
`help()` If that doesn't give you a good idea how to use the function, just knowing the type won't do you much good either.
which IDE is this? lol
Unless you have a composite shift key (i.e. single-use capslock), parentheses are _one_ keystroke in practice. Even if you want to count putting your finger on the shift key as a keystroke, you can't count the second parenthesis if you're like most programmers and type matching pairs before typing out the contents.
What about CherryPy? I did some stuff with it and I found it to be be astoundingly simple, but still let me do everything I wanted to. 
No problem, easy to forget that many of these names mean nothing outside of the core development team and Django community. Brett Cannon (@brettsky I think) maintains a nice Twitter list of all the core committers too. EDIT: https://twitter.com/#!/brettsky/python-committers is the list.
&gt; The : would only label "special" methods instead of __ prefix. And what is the exact gain of that? I always thought Ruby's colons looked a bit awkward and I'm used to Python's dunders. Apart from the three saved keystrokes at the cost of not being as easy to spot, what's the point?
+1 for this list, I would also add @markramm, @zzzeek (Mike Bayer), and @benbangert to balance out a bit of the Django-heavy folks :-)
I do not. Please give the money to a good charity of your choosing :)
Not really more typing if you aliase it. join = str.join print join('\n', 'OMG') This is unfriendly towards other, more adapted, programmers, though.
It was nice talking to you on IRC :)
The only (unique) use of `lambda` as-is is to pass data as a callable, e.g. when a function expects a callable and you want to pass a static value. `functools` and `operator` provide a lot of alternatives for most other common (ab)uses of `lambda`.
How does `x +:= 1` represent anything meaningful? If `:=` is the "first assignment" operator, `x +:= 1` (shorthand for `x := x + 1`) would define a variable that already exists by referencing the same variable. The semantics would be confusing if the left-hand `x` referred to a different variable than the implied right-hand `x`. The only meaningful solution is to namespace the variables, but there's no point in doing so explicitly if you could already just rename the variables into something completely different to avoid the problem (or use `nonlocal` to mess with non-local variables).
I think that a lot of people overlook the core devs on many projects and focus on people maintaining esoteric libraries. I think these guys are well worth watching both on Twitter and on the mailing lists.
This doesn't really solve the use case, though. var x = 1 def foo(): var x = x + 1 This should still raise a NameError unless you change the underlying way variables are handled in Python; and then you don't need fancy syntax.
Also, it makes class decorators very straightforward. You can just decorate the class's instance methods by replacing them with functions that call the original method just like you would call a super-class's methods.
Why do you throw random static methods together and call them instance methods when they do not act on the instance at all? Maybe you should just use modules instead?
This. Also, before I found Python, I was already explicitly using `this` all the time to be able to use the same names as arguments in setters, so the only change was in the four letter word I'm using. I also find that in Python it's harder to get into the habit of adding random variables as attributes. Whether that's an effect of the explicit `self` I do not know.
That reminds me of PHP and its `global` keyword. ~~Good times~~.
I've used bottle a couple of times. It's simple and great!
This made me realize something: a number of years ago there was a meme that Django was bad for the wider Python community, now with one exception all the Django developers you listed are major contributors to other parts of the Python ecosystem.
Not a complete list though, it doesn't have any of the alternate implementation developers who are now also CPython core devs.
If you poke him, I'm sure he would update it :-) (doesn't he live like 20 minutes from you now?)
PyCharm. Well, the colour depends on your settings, but the warning is very useful in case you are interrupted while writing an assignment and forget where you were. Of course it's annoying if you use overloaded operators purely for side-effects, but if you're doing that on purpose, you deserve much worse than ugly highlights. (e.g. `def __mul__(self, other): print 'wtf'`)
Though to be fair, so have many non-Django web folks, maybe web devs just all realized there is a world beyond the browser and request cycle.
You don't NEED any kind of framework...
Floats and ints and strings _are_ immutable. They are not, however, singletons, unlike `None`: &gt;&gt;&gt; def foo(): pass ... &gt;&gt;&gt; def bar(): pass ... &gt;&gt;&gt; type(foo()) &lt;type 'NoneType'&gt; &gt;&gt;&gt; type(id(foo())) &lt;type 'int'&gt; &gt;&gt;&gt; foo() is bar() True &gt;&gt;&gt; id(foo()) == id(bar()) True &gt;&gt;&gt; id(foo()) is id(bar()) False i.e. the two values returned by id() for each None object are equal integers, but not identical, although the two None objects are. This also demonstrates that for non-singletons `x is y` can fail even if `id(x) == id(y)` succeeds (equal objects can have the same `id` without being identical).
Oh I don't want to diminish anyone else's contributions, just that we're kicking the "Django isn't good for Python" meme in the ass.
He's up in the city now that he's done with indoctrination^W introduction, that's a Cal Train away!
You could just write your own library and use wsgiref (heck, you could implement wsgiref yourself, too), but Python's biggest strength is the wealth of good, stable code that is PyPI. Especially for someone switching over from PHP, writing everything from scratch would be unusually cruel.
ditto, aye aye :)
You can install Python on Windows, but for web development you should run it on Linux (or MacOS X if you frequent Starbucks while jotting down notes in your Moleskine) because that matches the usual production environment more closely. You can install Linux inside a VM (e.g. Oracle VirtualBox, which is free and relatively easy to set up as VMs go) if you don't feel comfortable switching to a different desktop OS entirely, but it's a good idea to have a GUI available, especially if you're used to working in Windows. A desktop edition of a major distribution like Ubuntu should do the trick. You should learn how to write code in Python first before you try to write web applications in it. Unlike PHP, Python is also heavily used outside the browser world, so you can spend a lot of time trying it out in the interactive shell. For starters, you may want to pick a straightforward framework like CherryPy that requires very little overhead to get started. You may want to give one of the larger frameworks (i.e. Django) or something closer to the bare metal (e.g. Werkzeug/Flask) a try once you're familiar with the concepts and ready to create a more thorough structure for your apps. Generally the biggest difference is that in PHP you rely on the web server (usually Apache) to take care of a lot of things, especially the routing. In Python, the web server is part of the application, although in many cases you'll want to put something in front of it (e.g. nginx) to take care of serving static files and such for performance reasons in production environments. If you want to use Python professionally, you probably won't get far with regular shared hosting providers. There are some specialised services, but the most common choice is a VPS, which requires some (Linux) server administration skill. __tl;dr__ Software development is hard; let's go shopping.
This is just wild conjecture, but the decision to include this syntax might also have been influenced by the increasing popularity of RPython (via PyPy). I'm guessing it's the first stone on the path to PyPy primacy.
Django used to ignore docstrings in favour of their official website, thereby necessitating much ⌘+Tab ing to a web browser and using their site search (+ click click click). Type annotations would have saved me quite a bit of such laborious work.
I really like cherrypy. At the risk of revealing my secret identity, I'll point you to my [website](http://gnudist.com). I've been meaning to publish my source code but I've been lazy. Could post it tonight if anyone would get a kick out of seeing it.
Sorry for the broken link, too annoying to edit from phone. edit: fixed link
There are many details of Erlang I don't like. The record stuff is crap. Only being able to assign to a name once does have a sort of ideological purity and is used [elsewhere](http://en.wikipedia.org/wiki/Static_single_assignment_form) but feels bad. 
Thanks for the reply Chris. I will be donating again to the FSF and EFF in your honor. Keep up the great work.
I recommend Google app engine, its free and will give you a friendly introduction to Mvc, templating and orm (not to mention cloud development)... if u want to have more control, I recommend django and mod python on Apache. I also am working with pyramid which is like django but with its own set of advantages and disadvantages... pick a project you want to work on, then pick the framework you want to learn, then hackaway... happy coding 
I don't know about cherrypy, but I will check it out.
Nice site. Think you might like a jQuery script that collapses the other panels when you expand one? I wrote one a while back. PM me if interested.
[Scrapy](http://scrapy.org/) initially seems like it has a bit of a learning curve, until you pick out the core pieces you really need. It uses lxml and Twisted, and it commits foot-based violence on the scrapers/spiders I used to write with BeutifulSoup.
Why would you want to do any of that? What if I just want a simple CGI script? It's not like you suddenly lose the ability to do that just because it's Python...
I started [here](https://docs.djangoproject.com/en/1.3/intro/tutorial01/) and I made out just fine.
I was thinking of adding that but was putting off implementing it, I'd definetly appreciate the code.
So is there any micro framework focus on ORM, corresponding to bottle ?
try the [PIL](http://www.pythonware.com/products/pil/) library (Python Image Processing) from PIL import Image img = Image.open('bird.jpg') img.show() **edit:** example added
Look into the [fastest growing web framework](http://i.imgur.com/sPLzH.png)
That's a great point, and it makes me wonder why this error happens in Python 3 today: &gt;&gt;&gt; def accum(): ... x = 0 ... def inner(): ... x += 1 ... return x ... return inner ... &gt;&gt;&gt; inc = accum() &gt;&gt;&gt; inc() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 4, in inner UnboundLocalError: local variable 'x' referenced before assignment Contrast this with a `.append()`, which works perfectly: &gt;&gt;&gt; def accum(): ... x = [] ... def inner(): ... x.append(1) ... return x ... return inner ... &gt;&gt;&gt; inc = accum() &gt;&gt;&gt; inc() [1] &gt;&gt;&gt; inc() [1, 1] &gt;&gt;&gt; inc() [1, 1, 1] I think that this shows that the first version should work even without a `nonlocal`.
multithreading makes it easier to share objects, but you have to manage synchronization. multiprocessing isolates and requires the use of formal data sharing mechanisms (queues, pipes, etc.) if the "system" requires each "task" to communicate together, multithreading is eaiser. if the "system" has each "task" largely independent and not talking to each other use multiprocessing. 
I never said that we had to discuss language grammar instead of the language implementation or ecosystem. Relax. GIL isn't "part of Python," but it's in cPython and people like to complain about it. It's OK. Let 'em vent. Even if probably most of them never write multithreaded code anyway.
I was exactly in your shoes about 8 months ago. Unfortunately, I haven't been able to make *too* much progress (no projects complete, at least), but I've learned quite a bit more as I've dove deeper into Django. One big thing to get out of the way first: there is currently no mainstream way to run Python code embedded in HTML like you can do with PHP, which it sounds like you might be expecting. This is exactly what I was expecting to do with Python when I first started looking into it, but it's not how it works, and you have to change your thinking slightly. Instead, what you'll be doing with Python if you want to work with it in the raw is create the actual HTTP *response* that happens to include the HTML mark-up along with the header -- not just the markup itself. This, as you'll learn, is pretty tedious, so your next step might be the same as mine: looking into a framework like Django to handle this tedious stuff, so you can actually build things much faster. Anyway, if you want to get moving faster and you're willing to make a serious commitment, I'd suggest getting yourself a cheaper VPS (I \*love\* [Linode](http://linode.com) - they have an excellent [resource libary](http://library.linode.com/)), installing the basics (Apache/MySQL/Python/Django), and following the tutorials [here](https://docs.djangoproject.com/en/1.3/) and [here](http://www.djangobook.com/). Good luck! It may seem a bit intimidating and inaccessible at first, but I promise it's well worth it to stick it out. Edit: spelling
pygame as well.
 from scipy.misc import imread from pylab import imshow, show imshow(imread('foo.jpeg')) show()
If you want to get a web site using python up and running on windows with the minimum fuss and bother, then I would strongly recommend web2py. All you need do is: download - unzip - run. No other dependencies! Once you have the basics running you can start experimenting. Download... http://web2py.com/examples/default/download 
Tried Django, found it unnecessarily complex for simple things, switched to CherryPy, and never looked back. I've built dozens of things with CherryPy in the last year, and it really is wonderful, simple, and understandable.
For me (experienced in Python, beginner with web programming, and not needing to make any complicated sites or use databases), plain old CGI seems to work the best. I'm tempted by frameworks/runners like web2py and flask, but they either require some more server setup to host, or require an extra continuously-running service which you need to restart/reload for code changes, which I don't like (unless you need it, for a high traffic site). One thing I do like about web2py though (from reading through it's docs, I haven't used it yet, but it looks pretty nice), is that you can run a lot of different sites on it, without each separate site having it's own runner/separate service that you need to manage/restart if it crashes, etc. I'm also tempted by Spyce (letting you use Python in a simple embedded-in-html way like PHP), but that project hasn't been updated for years and the mailing list is basically dead, so I'm not sure if I want to start using that. Well, that's just my personal view - I don't need to make any complicated CRMs or blogs/forums with a lot of visitors, just some really simple one-trick web pages every now and then, with very few visitors. I guess my ideal setup would be something like an WSGI config, where you can drop Python files down (similar to as though they were CGI), and then use their paths in the URL, similar to CGI and PHP, but with the performance of WSGI, and not needing to manage separate website-specific runner processes. I think I read about that kind of setup before, but I can't find it at the moment. 
 subprocess.popen("display", image_path) Oh, on Windows? No idea. edit: oh my bad, I mean import subprocess, sys sys.exit(subprocess.call("display", sys.argv[1]))
If you're going to be unfriendly, you may as well be *really* unfriendly: join = lambda iterable, joinstr: str.join(joinstr, iterable) join('OMFG', '\n') 
I'm curious, why do I need to follow them?
It's fairly trivial to adapt this to any Python webapp you can easily launch from a Python module, or to run a Django app with 'python manage.py runserver'. Shell scripts installed by pip will have the wrong path in them, ie. the paster/gunicorn shell scripts refer to /tmp/ locations that don't exist.
3 1-to-2-line examples (excluding imports) in 2 hours. I assume pygame is about the same. Then you think, "What's the easiest way to do this in C or pure C++?" I'm sure it's not _too_ bad. Update it for multiple images. Then add random playback. Some cross-platform exception handling to be complete. You're now at maybe 10-12 lines without 'going Perl').
By Flash, you mean Flask? :)
I implemented it just now, I think I'll have to tweak the feel of the effect. Thanks for the motivation.
don't sell yourself short, you are an occasional pypy developer now too :-). and thanks.
Here is the passive aggressive answer: from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer from datetime import datetime class RedditHandler(BaseHTTPRequestHandler): def do_GET(self): self.send_response(200) self.send_header('Content-type', 'text/html') self.end_headers() self.wfile.write("Hey reddit, it's " + unicode(datetime.now())) server = HTTPServer(('', 80), RedditHandler) server.serve_forever() (but a more helpful answer would probably be that you should check out Django or one of the other python web frameworks).
Not too bad indeed. In C, it's four lines of code: #include &lt;unistd.h&gt; int main(){ execlp("display", "bird.jpg"); } 
You mean Django? It seems to be the fastest growing as of the last interval on that graph.
Aargh... oops. I'm a big fan of silliness, but to be fair I mainly found those on the list by scrolling through recent tweets. So it's your own fault for not tweeting enough.
Yep, they're great additions. @kantrn should be up there too, plus @ctitusbrown, @doughellmann and many others I forgot.
Hey, way to be champ! First off, great way to ignore the import subprocess part of that. Second off, way to make it *nix centric. That's exactly what we're looking for. Third off, way to ignore any chance of error handling. Finally, there is no reason to use subprocess for this. If you're going to run display and not rely on python at all, just use import os import sys os.execl('/usr/bin/display', sys.argv[1]) Normally I wouldn't be a dick, but you've made the following errors: 1. Assuming Windows is an irrelevant platform, or at least implying it through your post. 2. Ignoring the question itself by using an external display program. 3. Making the result of 2 not be cross platform in any sense. 4. Being a dick. If you have any questions about when it's appropriate to use subprocess.popen, let me know! Edit: Oh yeah. If you need advice on when it's appropriate to be a dick, follow my handy dandy checklist listed above.
If your wanting to learn the nuts and bolts of the web with python go to this link and read the first answer. http://stackoverflow.com/questions/1641616/python-and-web-development Or just go to: http://wsgi.org/wsgi/
Don't forget the cross-platform part. I think vtable's 10-12 lines estimate is probably correct.
`x += 1` means `x = x + 1`, i.e. it evaluates the expression `x + 1` and assigns it to the variable `x`. As that variable is being assigned to, Python considers it locally scoped. But then it finds a reference to it in the same assignment and rightfully throws an error because up to this point, the local variable was undefined, so you can't reference it. To simplify the use case: &gt;&gt;&gt; x = 1 &gt;&gt;&gt; def foo(): ... x = x ... &gt;&gt;&gt; foo() Traceback ... `x.append` on the other hand is just a method call. As the variable `x` is not being assigned to, it is not created in the local scope and instead delegated to the outer scope where a variable with that name exists. `x.append` works for the same reason `print x` also works. As a rule of thumb: whenever you assign to a variable inside a scope (e.g. a function definition), you create a local variable with the same name which will be used for all references within that scope (even those preceding the assignment). `x += 1` is a shorthand for a re-assignment, so it fails if the variable hasn't previously been assigned in the same scope. Keep in mind that in Python variables are _names_ and they are scoped. Each inner scope can shadow the outer scope. Assignment creates a name in the local scope prior to the execution of that scope's code, so if a reference occurs before the assignment within the same scope, the reference will be resolved to the local uninitialized variable rather than the existing outer one with the same name. i.e. the scope is created at the point of the function definition, not the function call. Once you understand that, a lot of things will be much clearer.
that's one of *my* big turn offs about ruby. if you like it, just use ruby. 
When most people say they want to use Python for web programming, they are thinking of using frameworks to create standalone WSGI apps; much like how people talking about using Ruby are thinking of frameworks like Rails or Sinatra. You can write CGI scripts in Python, but I wouldn't call that Python web development. CGI scripts are to web applications what shell scripts are to desktop applications.
Despite all the praise it gets, I wouldn't call Django's documentation a shining example of best practices, actually. It's an unfair comparison because Django is much larger, but the documentation of Flask, Werkzeug or Jinja (all Pocoo projects incidentally) is considerably more useful. In addition to a lot of prose (including a quick tutorial and elaborate explanations of various common use cases) they contain very detailed API references. Django is very lacking when it comes to the API reference because it mixes the API reference with the prose and frequently under-delivers (you may find a dozen similar classes but no easily findable mention of their methods and their expected arguments, for example). Sadly code inspection (in most IDEs: "go to definition") often isn't very helpful either when there is any magic involved (e.g. metaclasses or factories).
I think type annotations can certainly help in some situations, but I would consider them more useful for lower-level functionality than most project-specific code. One of the strengths of Python's duck typing is that you don't have to define classes or interfaces every time you want to create what could abstractly be called a "type". In many cases the default arguments or wording of the docstrings should give you a good idea of what is acceptable input. Type annotations are only useful for automation -- be it compiling to native code (a la RPython) or type hints and validation in IDEs.
I, as a scientist, tend to infer trends by looking at more than a single bullet point, ideally doing a linear regression over all points weighted by their statistical uncertainty.
same code in web2py (complete code): def index(): return "Hey reddit, it's " + request.now 
Out of curiosity, why the use of module globals? Bottle doesn't seem to encourage that afaik, is that a web2py-ism? How does the web2py DAL figure out from: Field('updated_on', 'datetime', default=datetime.now()), that you actually want the datetime.now function called, vs. setting the default as the *current* datetime? Or is that just a typo? Have you tried using SQLAlchemy? It'd cut down a lot on the boiler-plate you're writing with the DAL.
1) As of today, heroku supports a process model, you can run Python webapps on it: http://docs.pylonsproject.org/projects/pyramid_cookbook/dev/deployment/heroku.html
BaseHTTP request handlers are not WSGI powered. That's literally the worst way to get started with web development in Python :)
Python web applications speak the WSGI protocol which is understood by WSGI servers. WSGI servers are Apache with mod_wsgi, tons of custom servers and many more. I wrote an introduction into that a while ago, you might find it interesting: [Getting started with WSGI](http://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/) The library section is not up to date. Paste was largely replaced by WebOb and luke's helpers no longer exist. I recommend Werkzeug of course, but I am biased :)
Very extensive. But if you just wanna get a simple coverage analysis just follow [this quick start](http://nedbatchelder.com/code/coverage/).
Cross-platform is definitely better. `show()` from PIL creates a temp PPM or BMP and loads it in the platform-specific viewer. Personally I'd use Tk + PIL. It's just a few lines of code and more cleanly programmatic. But I guess the OP doesn't mind showing the image in the Windows picture viewer.
I'm down with your method if it isn't obvious. Don't get me wrong; I'm fine using third party libraries where it's beneficial to a program. However, I'm certainly not the sort of guy who will design a script ***simply*** to launch another program without any interprocess communication.
CherryPy has Python 3 support and a built-in webserver, so you don't need to run Apache.
virtualenv is a must for all serious python developers. It lets you create multiple isolated environments in which to try out libraries and develop new applications. For a quick install take a look at http://www.stuartellis.eu/articles/python-development-windows/ I also use buildout which lets me define the various dependencies I need in a repeatable manner. http://www.buildout.org/
I love how simple it is. It's like I'm writing a normal python script, but for the web. I get the appeal of full-stack things like Django and Pyramid, but this just stays out of the way and lets me write my code. Love it. 
Well, it opens it in the default web browser. Not image viewing program. Those may or may not be the same for you.
It is an honour to have been rebuked by you, sir.
what? no "import request" ? *MAGIC*
pip http://www.pip-installer.org/en/latest/index.html
Here's how to setup Python for CGI/IIS execution: http://support.microsoft.com/kb/276494 There are hundreds of guides on how to do it with Apache too. Good thing about this solution is, that you are free of any dependencies (other than a CGI server and Python of course) and you can run whatever Python version you prefer (which for me, means 3.2+). It also teaches you a bit more about the nuts and bolts of HTTP since you need to write your own headers. One gotcha: If IIS tells you that your CGI app is misbehaving, it's probably because there's a syntax error that prevents you from outputting the HTTP headers. Use the cgitb module for any other errors.
Can't you set it to ignore certain PEPs, or is that another syntax checker I'm thinking of?
Many libraries don't need to be installed system-wide. You could just place the folder in the same directory as your script. I know this works for CherryPy.
yes. magic.
http://www.lfd.uci.edu/~gohlke/pythonlibs/ Has been handy a few times.
I cannot open the wordpress link. Could you use [pastebin](http://pastebin.com/) please.
There is no advantage to this. Just put it in site-packages like normal.
Probably the most confusing thing about being a Windows user starting to learn and work with Python has been that so many things are still 2.X while I had gotten 3.X. It would be so much simpler if it were just explicitly stated from the outset. Instead, I was often left hunting for lines of code just to figure out which version I was looking at.
I added another link to the end of the original post. The wordpress link should work, try again a bit later. On the wordpress page I give some examples too.
&gt;I would even argue it's less readable because it requires you to grep for an additional keyword to find all conditionals. I don't think readability has anything to do with searching, and I also rarely (if ever) find myself searching for conditionals.
Disregard libraries, acquire fluency.
"Raw Python for the web" is WSGI. I gave a WSGI tutorial a few years ago, the code is available here: https://bitbucket.org/lost_theory/wsgitalk/src Start with [this file](https://bitbucket.org/lost_theory/wsgitalk/src/c37d088a6751/examples1-simple/simple.py), the most simple WSGI app: def application(environ, start_response): start_response('200 OK', [('content-type', 'text/html')]) return ['&lt;h1&gt;Hello world&lt;/h1&gt;'] if __name__ == '__main__': from wsgiref.simple_server import make_server print "Serving on http://localhost:4000..." make_server('localhost', 4000, application).serve_forever()
wha?
So you want more operators and/or special cases. I think thinking such as "it's neat, let's add it" without considering the pollution each operator adds to the core language, made [Perl the way it is today](http://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg). In Python 3 the print keyword was even removed because it worked well enough as a function. IMHO range works OK too.
For bottle, it's really meant to be placed in the directory with your code. So when your done with your project, you can just leave it there as it won't effect anything outside that directory. In fact, you can place any module in your project directory that way.
I think that's exactly why so many people recommend starting with 2.x over 3.x.
Pygame would be something like: import pygame pygame.init() screen = pygame.display.set_mode(1024,768) # Whatever resolution you want. image = pygame.image.load('filname.jpg') screen.blit(image, (0,0)) pygame.display.flip()
It's better than in Perl where it's all global by default, IMHO.
Probably the easiest way to work with Python on Windows is to install this [super useful development environment](http://www.ubuntu.com/download/ubuntu/windows-installer)!
I think getting rid of the print statement was a good move. However this is not the same case. The point about python is that it's easy to read and understand, and a big part of it is visual cues, that separate chunks of words with sign and operators. I believe a range operator will make it easier to notice a popular type of operation - iterating a range of numbers - than when reading the word "range". For example, I think that the latter of the following is more readable, and would require less attention when skimming over code: &gt; for i in range(len(seq)): and &gt; for i in 0..len(seq): 
OP said "raw". I gave the most "raw" suggestion possible. Dunno why I'm getting downvoted into oblivion.
Yes there is: it's ridiculously easy. For someone just starting out with python easiness is a definite plus.
Activestate Python and PyPM. Pip installs from source so for somethings you need to have all the right compilers to get it to install. PyPM is a binary installer which is nice for packages like PIL and MySQLdb.
if let's say you built a website under virtualenv. is it inherently secure as in a hacker cannot access anything outside of the virtualenv circle?
For something simple, you can setup a Cygwin environment and use Python's easy_install.
What the hell is this?
great answer! thanks a lot =)
Not much of a website, is it? Why not just link to the twitter account?
I'd just use native Windows, rather than install Cygwin to setup Cygwin-only things. Also, I'd suggest using `pip` over `easy_install`.
No, this is not at all the purpose of virtualenv, nor does it act like a chroot or something along those lines.
Dropping a folder into the site-packages directly is also pretty freaking easy. Not doing so is usually just laziness.
no but you can run multiple radically different Python stacks side by side with it, especially useful when running the same site as a stable and testing versions with potentially major library breakage should they be in a mixed environment
no but you can run multiple radically different Python stacks side by side with it, especially useful when running the same site as a stable and testing versions with potentially major library breakage should they be in a mixed environment
Just updated the algorithm based on comments on the post, much faster now. I don't know why pre-filtering using file size or using a set didn't occur to me sooner.
Check out [os.startfile()](http://docs.python.org/library/os.html#os.startfile).
New to python? Use 3.x
On Windows? import os os.system('foobar.jpg') This will open it with whatever program is set to open jpg files. UPDATE: Whoops. Forgot about os.startfile(), which is the proper way to do it. os.system() still seems to work for me though.
I cannot speak about the design decisions made in the article but I can speak for web2py: 1) there is no need to pass globals() 2) You can do Field(...default=datetime.now()) or Field(.. default=lambda:datetime.now())
The mantra is: 3 if you can, 2 if you have to. Basically, that means that if all your library dependencies support 3.0, you should too.
3 if you can, 2 if you must. edit: EnigmaCurry beat me to it by a few seconds.
dont know why this isnt the #1 answer...
Check out [sink](https://github.com/sebastien/sink) on Github. It doesn't directly compare the files, but does generate metadata by which to do the comparison.
just be aware that pip wants to install source packages, and you'll need a proper C/C++ environment setup if you want python libraries with C extensions to install properly.
Even Windows 3.x is kinda old now. I don't think a modern version of python would even run on it. Most people use 95, 98, Me, 2000, XP, Vista or Windows 7. Windows 2.x is definitely out.
I'll take a look at sink, it sounds interesting.
Are people still trying to launch 3.x? I thought we gave up on that...
Well **I** thought it was funny. (edit: was at -3 when I wrote this)
So did I. Upvoted.
This is what I thought when I saw the title.
And to people in the arbitrary future: hello from 2011! Try to use 4.x or whatever the latest Python is.
A while back I had to detect duplicates in a great many files scattered over a large network. In my case, since I knew there would be (relatively) few duplicates, I did a three pass system. Basically between your first (file size) and second (complete md5sum) I did a hash of the first few kilobytes (2-8, can't remember) to eliminate files that were clearly not different. Performance will vary with the number of files, size of each file, and number of duplicates.
There are a ton of modules out there that don't work with 3. If you're learning Python so that you can use it as more than a hobby, you'd be better off using 2.x. If aren't going to need to work with python in any official capacity for quite a while then go with 3, so long as you know that for a while here you may need to learn some 2.x specific stuff on occasion. Also, there is something to be said about getting more people learning 3, because there is a ton of inertia in the python community right now over moving to 3.
Also, while I've never used them personally, http://www.webfaction.com seems to be well liked in the python/django community. They offer $9.50/mo shared hosting and are really django friendly.
Yes, but you have to find site-packages, and then realize that the code in there will be used with any program you write. If you install some library for your first project and write code relying on that, then update the library in site packages for your second project, then go back to the first project, your old code will no longer work. If you're just learning you may spend a while before you realize what the problem is.
Library and a lot of code for Python 2.x is the reason. However, latest version of NumPy, SciPy, PyQt are compatible with Python 3.x. If you are electronics-engineer the rest of interesting stuff you will find at [gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/) (especially matplotlib, PIL).
Github is hosting a Python conference in the same format as CodeConf. Aimed to be smaller, more social.
Are you looking for some comments? * use open() instead of file() [\[supporting material\]](http://docs.python.org/library/functions.html#file) * you should have some better exception handling - what if the file removal fails? what if you're handed an invalid directory? * are you worried about md5 collisions? could also use another hashing algorithm as a backup, I've heard zlib.crc32 is fast; perhaps consider just grabbing the hash of the first N bytes for this use case * any worries about symlinks?
global module only has 1 line, thread local, like massimo said no need to pass any global to dal.
read this: http://code.google.com/apis/customsearch/v1/using_rest.html You can call this programmatically with: apikey='....' keyword = 'hello' import urllib, simplejson url = 'GET https://www.googleapis.com/customsearch/v1?key=%s&amp;q=%s&amp;alt=json' % (apikey,keyword) json = urllib.urlopen(url).read() d = simplejson.loads(json) print d
Does it come with a Python IDE?
Oh, my god, I commit these very errors every day! I will stop immediately! Feel free just to downvote me. It'll save both of us time.
If you know how to start doing some task, break it into smaller task that you can handle. If those tasks are still too big, break them into further smaller ones, and so on so forth.
You could use either [httplib](http://docs.python.org/library/httplib.html) (built-in) or [requests](http://pypi.python.org/pypi/requests) (not built-in, but I've heard it's really nice) to make GET request corresponding to a google search. Then, use a html parser to walk through the resulting html, extracting each resulting link (which parser depends on which version of Python you're using). This is called web scraping. You could also try [scrapy](http://www.google.com/search?ie=UTF-8&amp;q=web+scraper+python), though I've never used it. Then again, I'm sure Google has an API you could use... [Here it is](http://code.google.com/apis/websearch/docs/). You could play around with that too. That would probably be better than scraping since, if they change their html, your scraper breaks. In general, check to see if a website has an API you can use. [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer) and [SOAP](http://en.wikipedia.org/wiki/SOAP) are the two formats most widely used. If the site does have an api, check to see if there are Python bindings. If not, no big deal; you can just make the raw requests and then parse the resulting JSON or XML to get what you want. Otherwise, you're left with web scraping, which is hacky and fragile, but at least it's always an option.
Use 2.x; * More third party libraries available * More support * More documentation and tutorials * You can also make your program work on both versions easily with [2to3](http://docs.python.org/library/2to3.html) * The difference between the two is not so big so it's not like you'll have to learn another language later If you don't believe me, try going to [python official website](http://python.org) and clicking on the **Download** link. You'll see the following message: &gt; *"If you don't know which version to use, start with Python 2.7"* 
Ah, my favorite protocol. It's best pronounced loudly, and suddenly, in the face of the listener: Net-BOOEY!
I came here to say the same. Developing python applications in Linux is so much easier than Windows.
I wrote a tool like this, too. It compares files byte-by-byte, which can be quite a lot of files than hashing the whole contents. See http://liw.fi/dupfiles/ for my program. That page lists a few other tools too, the fastest of which seems to be the one called hardlink (http://jak-linux.org/projects/hardlink/).
Feedback is always welcome, as I'm still relatively new to Python.
I thought i'd chip in with a [script I had](https://github.com/regomodo/handy_scripts/blob/master/md5_dir.py) made. It looks through a directory, hashes each file and stores filename=&gt;hash in a sqlite db stored in memory. It then deletes the dupes. I made it as I had loads of duplicate images (backups of backups of backups in the same drive. Stupid) so it only hashes+stores ["nef","jpg","tiff","dng"]. It's crude but it worked for me and I have another one elsewhere which uses os.walk.
Oh, I suppose I could swing by. Though I have no desire to type my information into redditgifts just to say I might go to a meetup.
That is pretty neat, I never considered a more sophisticated data store for my script as my problem fileset was only about 5500 files. Being able to persist the results between runs could be really handy on very large filesets...
If you're looking to learn how to scrape websites, check out mechanize, lxml, and BeautifulSoup. If you want to search Google without an API key, here's an example written for Python 3 (adapted from one of Alex Martelli's scripts): def gsearch(query): import json import urllib.request, urllib.parse query = urllib.parse.urlencode({'q': query}) url = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;{}' response = urllib.request.urlopen(url.format(query)) results = response.read().decode('utf8') results = json.loads(results) data = results['responseData'] return [[data['cursor']['estimatedResultCount'], data['cursor']['moreResultsUrl']], [r['url'] for r in data['results']]] &gt;&gt;&gt; print('\n'.join(gsearch('python')[1])) http://www.python.org/ http://www.python.org/getit/ http://docs.python.org/tutorial/ http://en.wikipedia.org/wiki/Python_(programming_language) 
Thanks, gents. Evidently /r/python humor has a certain inertia!
I'd say it depends on your hardware. Windows 2.1 comes in two flavors, giving you wider hardware support. Windows/286 will run on 80286 processors, as well as 8088 and 8086 (a pleasant surprise). Windows/386 will run on the 80386 processor. Additionally, it only requires 256k of memory, vs Windows 3.x which required a whopping 384k 
Baba BEUI?
Yes, as [someone said](http://stackoverflow.com/questions/645943/mysql-for-python-in-windows/3242143#3242143): **[no compile orgy. no strange errors. no terror](http://code.activestate.com/pypm/)**. 
Accidental md5 collisions are *extremely* unlikely. Like, you're more likely to be struck by lightning while adding the error check unlikely.
Thanks everyone for the replies..looks like I have some research to do. Also just want to through this out there..could this be done easier using a different language?
As far as I can see, you got only two downvotes, none of which came from me. That said, if you want it raw, [there's a Python HOWTO on that](http://docs.python.org/howto/webservers.html). It's a bit dated, I think, but it covers CGI to some extent.
Neither do I, but apparently the PHP core devs think `[]` is less readable than `array()` and the only argument on the list that gives any indication for the reasoning is that the former is harder to search for.
But just knowing that they are possible can make you uneasy. Doing a binary compare before deletion wouldn't take much time.
I think lints are generally configurable like that, but I haven't found any such info for pylint. Maybe I wasn't looking hard enough.
Better safe than sorry. If you haven't been struck by lightning as a programmer, you haven't programmed long enough! =)
Thanks. I was just copying photos yesterday when I realized I needed something to detect duplicates. I don't know why I didn't think of Python.
One more suggestion. Use optparse instead of argparse so you eliminate one unnecessary dependency. 
If anyone is interested in a similar app with an optional GUI interface, I wrote something just like this a while back which called DupeFInder: http://www.monsterden.net/software/dupefinder It can be run from the console to just output a list of matches, or can be run using a PyQt GUI to create a match tree, with the ability to selectively tag and batch delete files, or crudely launch a viewer (that you type in the name/path for) to inspect files. EDIT: fixed link It uses the same basic MD5 hash with filesize filter algorithm as this script. 
Why not use the stdlib for the final comparison? import filecmp filecmp.cmp(a, b, shallow=False)
Did something similar a couple months ago when I had to weed out duplicates from among 100,000+ small jpegs. Except rather than testing the first few kB, I specified a user-defined "strictness" level (a percentage of the file size). A loose scan would read, say, the first 10% of a file, while the strictest scan would read the whole thing. It churned though those files in no time.
Sure thing! Also, if you're an IRC-kinda-person and wind up looking into Django, I often lurk in #django on irc.freenode.net, where there's lots of great people willing to help when you run into trouble or have questions. The important thing to remember to make Django a bit less intimidating is that it's simply a set of Python scripts sitting between Apache and the database that help make it easier to do a few of the core things needed for any dynamic website (and more): handle HTTP requests; interface with the database in a more accessible ORM fashion (often based on those requests); and generate HTTP responses to those requests (using the data returned). Again, you *could* technically do all of this by hand with your own Python scripts and oodles of SQL calls, but no need to reinvent the wheel if these frameworks already do everything most people need to do and much more.
upvote for pip. Setting up a c/c++ environment can be a pain. I use Python for scientific computing, so I found this useful for a number of reasons: [pythonxy](http://www.pythonxy.com). 
This, but don't use BeautifulSoup, it's years old and slow as balls. lxml.html is fast and Mechanize is robust and the two will work for anything you need. 
very interesting! combining two things i enjoy, sc2 and python.
[Something I wrote on the subject a while ago](http://bouncybouncy.net/blog/2008/02/21/how-my-dupe-finding-program-works/) At the time it was faster than any duplicate file finding program I could find, but there might be something faster these days. It's designed to read the smallest amount of data possible, which makes the runtime very fast on slow disks or network shares.
I love python, but problems like this are the reason shell programming exists. To get a list of all duplicates anywhere below the current directory you can do: find . -type f -exec md5sum {} \; | sort | uniq -w 32 -d --all-repeated=separate | sed 's/^[a-z0-9]* *//' or if you want to remove all but one of the duplicates just add some more sed &amp; xargs: find . -type f -exec md5sum {} \; | sort | uniq -w 32 -d --all-repeated=separate | sed 's/^[a-z0-9]* *//;1~d;/^$/,/./d' | xargs -I '{}' rm -i '{}' add #!/bin/bash, replace 'find .' with 'find "$@"', and you've got yourself a working program. For a slightly different interface using the same idea, [see this page](http://elonen.iki.fi/code/misc-notes/remove-duplicate-files/). Of course if you're using Windows or some other operating system that doesn't support unix commands but has python (do those exist?) you should ignore everything I've just said.
find+md5sum+unique doesn't really scale though. For any reasonable amount of data you'll want to pre-filter by file size collisions. Once you have files of the same size, you still don't want to read them in their entirety if you can avoid it. See the link I posted above on one of the fastest ways to find duplicate files. 
Hmm this would be cool for music, but rather than checking the file where I heavily edit tags, it would be nice to check a hash of the waveform, which if I'm not mistaken flac already has embedded.
I was under the impression that argparse replaced optparse in [2.7](http://docs.python.org/library/optparse.html)? I had been using the C-Style [getopt](http://docs.python.org/library/getopt) module previously but I've found argprase to be much more concise to use than getopt, I originally looked at optparse but then I saw the deprecated notice.
Why don't you use Jquery UI's accordian? This is literally something that's been written for you.
cool anybody have a favourite "intro to scraping in python" they could point me to?
Specifically web scraping? I suppose so if someone wrote a DSL (domain specific language), but Python is generally an easy language. With C++, handling json, url processing, and http connections isn't in the STL, and dealing with the data structures and resources is more cumbersome and prone to bugs. It's a bit simpler in C#. Here's a program to use the Google ajax API that someone got working (see edit 3) with [the help of Stack Overflow](http://stackoverflow.com/questions/1212344/parse-json-in-c). I could have made gsearch a class with properties like the C# program, but it would still be simpler in Python. On the other hand, the statically typed C# program will have better performance. 
Thats why I just started with 2.x I don't seem to run into libraries that are 3.x only...
[Python 2.1 alpha 1](http://www.python.org/download/releases/2.1.3/NEWS.txt): &gt;Support for Windows 3.1, DOS and OS/2 is gone. The Lib/dos-8x3 subdirectory is no more! Version 2.0.1 (June 2001) was the end of the line for the old int 21 code in DOS. 
I've been avoiding the JQuery UI, but there isn't really a good reason why. I just checked out the accordion effect and it looks like it would be worth a shot since it might make the animation a bit more fluid. 
optparse is still in Python 2.7, but argparse is only in 2.7. If you use optparse, the code will work in 2.6 (and everything back to 2.3), which is kind to the people who favor stable releases of Linux distros (Debian, RHEL/CentOS, etc).
http://www.monsterden.net/software/dupefinder seems to be the right link.
Now if only there was a good Sc2 replay parser .... Sc2gears works but its not open sorce.
Can I run PYTHON.EXE straight from the MS-DOS Executive, or do I need to use the PIF Editor?
... no ability to install without direct internet access... (pypm requires internet access, even if you pull down a pypm file from their repository you cannot install it as there's no pypm command to do so) 
&gt; any worries about symlinks? walk() won't follow symlinks unless explicitly told to (followLinks=True). So if one is worried about them, then simply ignore them.
You CAN run it from MS-DOS Executive, but I would recommend the PIF Editor in order to get all your include paths pre-set. 
[pyttsx](http://pypi.python.org/pypi/pyttsx) interfaces to [SAPI 5](http://en.wikipedia.org/wiki/Microsoft_Speech_API) (Windows), [NSSpeechSynthesizer](http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Speech/Articles/SynthesizeSpeech.html) (OS X), and [espeak](http://espeak.sourceforge.net) (Linux, cross-platform). NeoSpeech's VoiceText supports Korean and SAPI 5. They also have some iPhone apps, but I don't think they have a system voice for NSSpeechSynthesizer. AFAIK, espeak doesn't support Korean, but [espeak-chinese](http://www.eguidedog.net/espeak_chinese.php) apparently speaks a little Korean. 
what about: [PyCon 2010: Scrape the Web: Strategies for programming websites that don't expected it](http://python.mirocommunity.org/video/1616/pycon-2010-scrape-the-web-stra)
This is what i thought it was about...
I'm a python-loving developer. I have a small app. I want to make it available on 2 operating systems: Windows and Mac. I want it to be self contained i.e. A DMG that contains the APP for OS X and a ZIP file containing a folder with the .exe and all the app data (images, translation files, etc.) can packaging do this? it says "make **Python applications** [...] easily available to a wider audience with **very little overhead** for build/release/install mechanics". Can it help me escape from the py2exe/py2app nightmare? 
&gt; Setting up a c/c++ environment can be a pain. Well... Yes, if you for some inscrutable reason decide that you need Cygwin or MinGW. Otherwise you install VS Express 2008 (or whichever matches the compiler used for compiling Python, it's 2008 now) and set three environment variables (LIB, INCLUDE and add the path to cl.exe to PATH) using vsvars32.bat as inspiration. As a bonus, you now can use Cython, Pyrex, Psyco, PyPy, or just compile your own plain C extensions (fun fact: distutils can take care of all the details for you making it super-easy, if only a bit of using it in unintended way).
wxpython (IMHO the best GUI toolkit for Python) does not support python 3.x; same with PIL. These are show-stoppers for me. My advice is to install 2.7 and code to 3.x standards (as much as possible) Check from time to time your code using python -3 option to check for things that cannot be trivially changed by the 2to3 tool. 
Python 3 isn't expected to be mainstream for another 2 years. And there are some heavy hitting 3rd party libraries/programs that have not even really started looking at migrating. There isn't an AMD vs other preference. Nor is there a 32bit vs other preference. You will want to pick up whatever works best with your OS. I run amd64 gentoo Linux, so mine gets compiled for my hardware. But running windows: pick the one that matches your version of operating system so you don't have to compile it with MSVC++. I prefer Linux as there is more support tools for building your own extensions or adding 3rd party libraries that require specific c libraries to be installed.
Here's a quick demo of using SAPI 5 on Windows: &gt;&gt;&gt; import win32com.client &gt;&gt;&gt; tts = win32com.client.Dispatch('SAPI.SPVoice') #say the current time &gt;&gt;&gt; import time &gt;&gt;&gt; t = time.localtime() &gt;&gt;&gt; tts.Speak('the time is {} {}'.format(t.tm_hour, format(t.tm_min,'O&gt;2d') if t.tm_min else "o'clock")) #list available voices &gt;&gt;&gt; voices = list(tts.GetVoices()) &gt;&gt;&gt; voices[0].id[-19:] #show the Id of a voice 'MS-Anna-1033-20-DSK' &gt;&gt;&gt; tts.Voice = voices[0] #set the current voice 
&gt; Any preference for the amd64 vs. Win32 versions? Interesting things like Psyco or PyPy tend not to support 64bit Python (at least on Windows). That's a clear disadvantage. Also, 64-bit programs tend to consume a bit more memory and therefore run a bit slower (due to all pointers being 64 bits now, and there's a lot of pointers in Python). On the other hand, I can hardly imagine a situation where you need more that 2Gb of memory for your Python program, and where you wouldn't think about rewriting it in C so that it uses ten times less memory for starters. Note that it's completely OK to run 32bit Python on 64bit Windows, in fact I do just that.
&gt; For a month now I have been enjoying something which I am being called crazy for: watching commented StarCraft 2 replays I share this sentiment. Watching SC2 replays is fun on a level I imagined impossible. It's just like watching sports.
Very exciting to see this coming together! Tarek, thanks for the detailed Python 3.3a0 fetch/build instructions in the blog post. 
Comparing hashes is much faster than doing what I presume is a bitwise comparison. You only have to read each file once (at most), no matter how many files have the same size. 
Interesting, but the one problem I see is that your method could be slower if you have multiple large, matching files. You won't read any more data, but if you have say 10 duplicate files that are all 10 MB, do you handle it so that each file is only compared to one other file, or are all 10 compared to every other file, leading to 10 * 9 / 2 * 10M = 450 MB worth of bitwise comparisons? Perhaps this case is simply not very relevant; I can't think of two many situations where this would actually occur. This did make me think of a good speedup for my own software though (mentioned in this discussion), that maybe instead of computing the entire hash for all files, the process could be made into 3 steps: 1. filter by size 2. compute a mini-hash of only the first and last K bytes of potential match files 3. compute the full hashes for files only with matching mini-hashes This would potentially lead to reading slightly more total bytes if there are large number of true matches, but in most cases would create a similar speedup by avoiding reading the majority of bytes in non-match files. 
Also, the sorting process will be slower than creating a hash table.
It's not even a remotely relevant view point for this thread, so why even bother posting that?
Looks like it can: http://docs.python.org/dev/packaging/builtdist.html 
Does anyone know if distutils2/packaging offers some method for specifying arguments for specific C compilers? Ie, something like extra_compile_args, but a dict mapping compiler name -&gt; options specific to that compiler. I've been hoping something like that gets added, cause it's slightly a pain to try to detect which is the active compiler, and modify extra_compile_args on the fly - and it also seems like the setup.cfg-oriented style of packaging is gonna make that route harder to use anyways.
Oh, and also - huge thanks to Tarek for the guts and dedication to tackle the monster that is python packaging.
2 or 3?
It compares all of the files in parallel. What it does is read the next chunk from each file you are comparing, then stores them in a hash table indexed by chunk. So if you had 5 files and the chunks were 'A', 'B', 'C', 'A', 'B' the hash table would look something like A: [file1, file4] B: [file2, file5] C: [file3] At this point you can ignore file3 as being unique, and then [file1,file4] and [file2,file5] are re-ran through the process. It repeats like this until they either diverge, or EOF is reached. This method also does not even use md5 and simply relies on the python hash table implementation to match duplicate chunks to each other. In practice computing the hash of the first 32K of a file is probably enough to determine uniqueness, but I've never bothered testing this. It would be easy enough to modify my program to maintain stats for how much of a file had to be read before it diverged from other files of the same size. 
I think he was making a joke about my using the title "(Windows) 2.x or 3.x? (self.Python)" to ask about Python 2.X vs. 3.X on Windows XP. the title could be interpreted as asking about Python on Windows 2.X vs, 3.X. Thus my laughing hard enough that I had to wipe coffee off my keyboard.
I think you are right, but lots of people are on 2.5 and 2.6.
Actually, the truth is slightly worse. There is always the possibility that a file has been written with different characters stored using different normalization rules. e.g. the string éé might stored in a file named «\xc3\xa9\xcc\x81». Because Unicode allows the exact same string to be represented in multiple ways, and the filesystem layer is encoding agnostic, you can't open a file reliably just by knowing which character sequence defines the file name. Please also note that you can have two files in the same directory named «l\xc3\xa9.txt» and «le\xcc\x81.txt», which in any modern file browser will be rendered as two files with exactly the same name. This is likely to cause various rather serious bugs.
+1 for learning python the hard way, great intro / starter, then you'll read the docs and feel comfortable ... another good thing is using IDLE
Unless I'm mistaken, that's for creating an executable installer *in an already installed python site-package*. Just a little convenience over "python setup.py install". I don't think it creates standalone apps (which I think is what the OP meant).
Sure, but then he'll have "duplicate files" by some definition of duplicate.
I've been shocked by computers, and had some EPROMs erased by static, but I've never actually been struck by lightning. Let me rephrase my earlier statement: accidental md5 collisions are so unlikely that if you add extra code to work around them, it is billions of times more likely that your extra code will contain a bug, than that you will see an accidental md5 collision.
You're not comprehending the level of unlikeliness we're talking about. The extra time you're spending to do that binary compare increases the window during which a stray alpha particle can zap your RAM and cause an error in your program. As unlikely as that is, it is a gazillion times more likely than an accidental MD5 collision.
Its such a mess http://www.dwheeler.com/essays/fixing-unix-linux-filenames.html I am glad I only use it at home to organize some letters I write on Linux or BSD...
Good point I hadn't thought of that!
Might not be completely what was wanted but I've had success so far using https://github.com/utahta/pythonbrew
Not sure myself which way is faster... To compute the hashes you need to read all data of all files at least once. The stdlib filecmp.cmp function tries to avoid this by first comparing os.stat(). If it needs to do a bitwise comparision it stops reading the moment it finds a difference... See [the code](http://svn.python.org/view/python/branches/release27-maint/Lib/filecmp.py?view=markup) for details... 
I've been using [Scrapy](http://scrapy.org/). It's pretty straight forward. 
Consider using [PhantomJS](http://www.phantomjs.org/), a headless WebKit. Write a PhantomJS script that renders your graph then dumps it to an image file (`phantom.render(path)`).
Here, [Stack Overflow](http://stackoverflow.com/), or Freenode [#python](http://www.python.org/community/irc/).
PhantomJS looks awesome. I wasn't expecting such an ideal solution.
Turtles all the way down.
You think that's bad? I get some ridiculous error trying to _write_ such files on FreeBSD, causing 500 errors when people upload files with accented letters.
Is this a copy of [PySchools](http://www.pyschools.com/) or what? Even the Learning Python -menu has the "PySchools Python Quick" entry...
Can the email not actually attach the images but include them with remote srcs? Then you could just embed the image in the email a la &lt;img src="http://yoursite.com/whatever/foo/graph.png"&gt; and have your application catching that url and generating the graph on the fly... Otherwise, some kind of headless js solution (phantomjs, node.js, etc) could work, but they often don't work well with javascript not intentionally written to be used in them
Whether the email includes the images or a link to the images doesn't matter. Either way, I need to call the Highcharts code from Python. 
We already use the exporting module in the web application. It's JavaScript. I've examined the POST arguments sent to export.highcharts.com, and they're SVG tags. So before I can do that, I again need to run Highcharts (which is JavaScript) in order to generate the SVG for the graph. 
You're welcome 
thanks, we will get there eventually :) IIRC we do have those options but not per/compiler type. If you can think about a way to write it in setup.cfg (we have a [compilers] section and [extensions] section) please add a bug and describe it. We'll be happy to add it. 
Unfortunately we did not improve this area because it's very specific to every OS. I think packaging will eventually make this easier, in particular with the definition of data files. But we'll still need projects like py2app on the top of it.
Turtles all the way down.
It depends on the filesystem. In HFS+ (OS X's filesystem), all file names are normalized to Unicode NFD, so the two strings you give will end up opening the same file: $ python Python 2.6.1 (r261:67515, Jun 24 2010, 21:47:49) [GCC 4.2.1 (Apple Inc. build 5646)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; fp = open('\xc3\xa9', 'w') &gt;&gt;&gt; fp.write("hello") &gt;&gt;&gt; fp.close() &gt;&gt;&gt; fp = open('e\xcc\x81', 'r') &gt;&gt;&gt; fp.read() 'hello' &gt;&gt;&gt; os.listdir('.') ['e\xcc\x81'] Ninja edit: looks like this was already pointed out in the comments on the blog post.
Wow, thanks for sharing this, I will definitely have a play around with it! Have you published anything using these codes yet? I am an experimental spectroscopist (on a reddit lunch-break while the machine is misbehaving)
Up voted for Requests: HTTP for humans. This is beautiful! 
Haven't looked at PhantomJS yet, but your question reminded me of this: http://blog.davidpadbury.com/2010/10/03/using-nodejs-to-render-js-charts-on-server/ Cheers
While that does have some attractiveness, it's more desirable to display the graphs in the e-mail. It's more perceived (and even real) value for the user. They can see the new graph info immediately, then click a link to come to our web application. I won't deny that just supplying a link is an appealing plan B. :-) 
Anyone know of a write-up of this? Sounds great, but it's genuinely TL;DW, especially with that player.
[/r/learnpython](http://www.reddit.com/r/learnpython) is a good place too.
Great! I'll definitely be checking out your code. I'm also a molecular dynamics python developer for my research group. We develop extensions for the Molecular Modelling Toolkit, a package you appear to be familiar with. Keep up the good work =)
/r/learnprogramming might be helpful as well. what the heck is an RT60 reverb anyways?
Turtles all the way down.
&gt; what the heck is an RT60 reverb anyways? http://en.wikipedia.org/wiki/Reverberation#Sabine_equation
Are you using argparse (introduced in Python 2.7)? Makes it really easy to add and handle CLI arguments ;)
Yup! Just discovered it last night too. It's ridiculously powerful.
Looks good. If you don't mind a few comments, perhaps: * Have a look at [PEP8](http://www.python.org/dev/peps/pep-0008/). To make you code more readable by python programmers consider changing from tabs to spaces (preferably 4 spaces to one tab). * There seem to be a few extra imports. For example, httplib2 is imported twice and glflags is imported for the FLAGS constant that doesn't appear to be used. I'm not sure you need to import oauth2 (as oath) if you are already importing the tools you need from oauth2client. * You are explicitly importing find from string. You could drop this import and use the .find() method of builtin strings. You could also use the .index() method here, too. This would allow you to replace: Original: index = find(task['title'], substr) if index != -1: matches[i] = (tasklistID, task, index) i += 1 With: if substr in task['title']: matches[i] = (tasklistID, task, task['title'].index(substr)) 
This may not be possible (I'm not particularly knowledgeable on the subject!) but a user interaction suggestion: typing all of those "-x" flags gets in the way of a pleasant user experience. You're already asking the user to learn these flags in order to use the software, so if at all possible, try to simplify the operation and require that the user learn the proper sequence of inputs instead. For example: $ python tasky.py "Event" da/te/11 "This is a note" This program is probably not intended for widespread use, but perhaps one day you'll want to release it into the wild :-)
Because it might save this guy some headaches down the road. I am glad someone told me this 5 years ago. It was the best advice. Managing libraries in windows is complicated. Dealing with the paths, installation and upgrades is very difficult. If a library is updated, in windows you would never know unless you went to the website. So yes it is relevant to the OP's question. Also looking at the votes many people feel the same way.
Thank you for your feedback! * I didn't realize this; I thought Python required tabs for some reason. I have converted all tabs to 4 spaces. * This wasn't my code (Google provided all the authentication stuff) but I have removed the unnecessary imports. FLAGS was used if I wanted to disable the local server feature so it's unnecessary for my code. * Oops totally missed that this existed. It's been changed now and pushed to bitbucket. A question regarding your code sample: wouldn't that replace a single search operation in the original with two searches in the new one? (one for "in" and the second in index()?)
Nah, still not related.
Either here or /r/learnpython, but please feel free to ask away!
Thanks for your feedback! I had originally had it separated by commas, but then I wanted to make the date, note, and parent task (there's also a --parent flag) fields to be optional. The CSV approach allowed this, but it seems clumsy to me to have something like: $ python tasky.py a "foobar", ,"this is a note." instead of $ python tasky.py a -t "foobar" -n "this is a note." in addition to the fact that parsing commas inside strings like "This is a note, also." meant that I had to manually parse the arguments. argparse (the library I used to do the parsing of the optional flags, etc) seems to be designed for the '-' flags approach as well and seems less error-prone and simpler than any manual approach. In the current model, only the action ([a]dd, [r]emove, [t]oggle, [l]ist) and the title (-t "title") flags are needed for these (except for the list, which requires no other flags). I couldn't think of any way to accept arbitrary strings for the title, note, and parent name while still allowing them to be optional (since "5/11/11" is an acceptable string for a note as well as a date).
yea, #python on irc.freenode.net
ok fanboy
It's Python 2. On [this page](http://doc.pyschools.com/html/variable.html), we see the following example: &gt;&gt;&gt; 1/2 # returns integer value 0 &gt;&gt;&gt; 1/2.0 # returns decimal value 0.5 In Python 3, all division defaults to floating-point division.
&gt; A question regarding your code sample: wouldn't that replace a single search operation in the original with two searches in the new one? (one for "in" and the second in index()?) Yes, yes it would. I started with just a change to .find() and then threw in .index() for... well, yeah. Sorry. Also, I dropped the i += 1 because I was changing matches to a list but then forgot to note that. Bad me. 
Awesome, I'm going to be checking out your Generalized Born code. I hope you have a good surface-area term.
tabs vs. spaces is just a preference. I prefer tabs myself. Use what you like.
from wtf import *
Have you ever tried computing the Connolly surface area?