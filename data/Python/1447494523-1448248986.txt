Atom uses more RAM than OPs system has.
This repo maintains some good list: https://github.com/lukasz-madon/awesome-remote-job
sublime on my system consumes approx 15mb with rust packages loaded. so i assumed atom will be using the same approx coz both of them look and work in similar ways. 
OS X users don't usually build Python. We install a binary via Homebrew or pyenv.
The equivalent in Ruby is 'gemsets', but that's a different topic.
Plenty of companies do have Linux on corporate desktop. 
You need to install 'pyOpenSSL', 'ndg-httpsclient', and 'pyasn1'
OK, when I meant vanilla Vim, I actually meant all the goodies that get shipped with Vim by default. Vim's Python omni-completion is partially implemented in Python and it parses the code you write. I thought maybe one could salvage this feature to display documentation without actually having to install any extensions. Almost all Vim extensions for Python I've looked at are huge and I wouldn't use a tenth of the features they have to offer.
That's what I've been doing till now. I keep a tmux vertical split open where I read documentation. But it's a bit cumbersome.
Downvoting becaue Atom is not the solution for someone with only 1 GB or RAM.
I believe you should learn python 3 directly,just for the length of the support (till python 4 exist if any). If you have some kind of project in your mind, just check the compatibility. Took python 2.7 if necessary. The concept of someone will learn other version along the way depend on the project. I took 2.7 route and not learn python 3 until next year 
Use 3.5, but learn the differences so you can write 2.7 if you ever need to.
If you don't mind spending some money, i would recommend getting a RaspberryPi and the camera module. Had lots of fun playing with OpenCV-Python! Edit: OpenCV is a popular computer vision framework that can be used for various things like facial recognition, robotics, traffic analysis etc.
Homebrew installs binaries if it can. If you specify extra options, then it will compile from source. `pyenv` is the mutt's nuts.
I've done python professionally for ~9 years now, had hired people. First of all: - writing code according to basic standards - code must be readable - testing (unittest2 is enough) - code has tests - basic familiarity with frameworks used at company (e.g. Django) - because I don't have the money to educate at 101 level - versioning tools - because it's 2015 and I will need to rollback some of your commits :) Almost must-have: - familiarity with common OS databases (psql, mysql, sqlite) - communication skils - ability to write text - for docs, emails and other documents require to live inside company Most programmers think that the best hires are 1337 h4x0r guys - that's not true. Good programmers are people able to communicate their ideas clearly, both in spoken and written form. I put strong emphasis on this when hiring. Also, I look for talent and if given person wants to learn. Skills are usually a cherry on top since most companies have very specific stacks. Personally it took me about 8 years of **extremely hard** work and continuous self-education to be at a level when I know all the tools used by the company that wants to work with me - thus I never expect people to know our tools.
I say learn both, but focus on 3. In a few years, by 2020 I believe, support will end for 2.7 and there is going to be a need for people who can migrate old projects to the new standard.
I did, in fact, follow the link. I'm not worried about resources for learning. I can figure that out. I just need some sort of inspiration for what to work towards.
you know what they say about assumptions...
oh yes how could I forget that I could take time off from my working, paying job and go into a store and just grab one. my bad
... Where's the readme?
Sure, that is quite expected since Python 2 is older and still very much alive. But it doesn't seem like there is a lack of learning resources for python 3 either, so I don't think that's much of a problem.
I meant if you take a class (perhaps an online class) and it uses 2.x, that would be another reason to choose that. Especially if it's one's first language and trivial differences are not that trivial.
I wasn't clarifying terminology, I was assuming that since we're clearly discussing programming here, the term "expressive" is being used in a programming context, and its programming meaning was implied.
Haven't seen a git with no readme in ages. :O
Do both. There's an endless supply of 2.x examples and help topics. Not always the case with 3.x - Knowing the major differences can be a big help when you're looking for answers later on in a forum where everyone is using 2.x That said, I learned using 2.x - But I started by taking a class, and the instructor taught both. Main examples were given in 2.x and then notes were given for differences in 3.x
I have FuzzyFinder (similar to command-t) and MRU. But I find myself always using MRU (I configured it to remember the last 9000 entries). Very simple and convenient.
thanks, this is exactly what I needed. thank you Zouden!!
3.5
"a git"? Okay, grandpa!
Yes. It's one of the easier to learn languages and yet it lets you do a lot of advanced stuff. It's the best language to go from zero to hero, in my humble and totally biased opinion.
Probably next to the setup.py
Here is a good resource for an unbiased answer to your question: https://wiki.python.org/moin/Python2orPython3
C++ it is, vanilla C has no need of it. 
Oh is this some internet web site?
Yep, check the wiki.
Does your next paycheck come in 16 days?
Sure. Learn numpy and pandas. Work in finance or a research setting
100K a year doing something you love is really a dream for many people. You can do a lot with 100K a year. I don't know how old you are, but I think learning Python at point in your life will neither land you a higher-paying job nor a more satisfactory life. You seem interested in programming. Why don't you keep doing what you are doing; it's something you love, right? And try to learn programming in your free time, just for fun. You can be both rich and happy. Your attempt of getting both richer and happier might end up with getting neither. 
We're all old here.
If distros follow your release, they'd never get done. It'd still wait for Perl 6 final release in a few weeks. And then then it's just weeks away from the next KDE drop, and the Xorg drop happened last week, and.... The point with setting a time based release schedule is that you don't delay for others if the schedules don't sync. It hurts more if the releases are yearly rather than every six or eight months. And it hurts less if releases are every five weeks. But a time based release schedule is generally the only way to deliver something. Dropping features that don't get done or stabilized on time, and keeping to the schedule. Even then you might end up pushing a release a bit to get a fix in, or because something came up during the testing phase that should be solved. The alternative is Debian style releases, which happen with less planning than pregnancies. But if you like that, Debian is that way, Slackware is good and true on the other hand. OpenSUSE went to a rolling release cycle and don't really have a date anymore, sort of like Rawhide, but stable. Plenty of options, no need to yell at people that they are killing anything, and certainly not a reason to delay a distribution just because a minor programming language got it's release off. If they'd delay for Python, why not delay for Java? And Gcc? and Clang? And Perl6. All at the same time. 
I'd say that's a reasonable assumption given that it would be the end of the month. Another hypothesis would be that it's simply an example. Regardless, I believe we can surmise it's a monthly paycheck. 
That coincides with the end of the month, so that would seem reasonable...
whats your everyday like? what kind of tools/framework you use and what kind of problems you solve? thanks!
Working for a place that have legacy systems require you to learn the difference, I'd say go for 3.4 for yourself (from what I've seen it's the one best supported library wise as of now), make sure to run your codes on both 2.X and 3.X and have fun! 
there's hardly any difference from a beginners standpoint, so w.e.
what's the point of unary plus when it does not change the var value? +, you cannot write those things in many other languages
I don't agree. Pretty much anything you learn about programming will help you be a better programmer. If you learn Ruby, you'll get ideas for how to do better Python. There are very few ideas in programming that are non-transferable skills—basically just API specifics and obscure bits of syntax—and those are still helpful when thinking about how things could be done better in a different language.
It doesn't always change the value, but it can. There's some discussion about it here: http://stackoverflow.com/questions/16819023/whats-the-purpose-of-the-pos-unary-operator-in-python
I was having some other non related issues, so I re-installed ubuntu 15.10 from scratch(i had originally upgraded a fresh install of 14.10 -&gt; 15.04 -&gt; 15.10). After re installing I found that python 2.7.10, 3.4.3 and 3.5 are all installed. tkinter didn't work for any of them from out of the box, but I installed python3-tk and python-tk and it is now working for all 3 versions of python.
Absolutley useless comment. Software changes every day. If you haven't tried the latest build or suggest something better you might as well be quiet.
Opinions are like assholes, everybody has one. My opinion is that anything Gnome is bloated and especially recently wastes a shitload of screen space. As for your advice? Stick it in your opinion and have a dose of reality.
Depends. In that role I was a test engineer, or rather, sysadmin / test engineer. The test department needs their own sysadmins and people who can do things like that split off from the customer facing sysadmins / consultants. Because testers end up being in part the project management, release process and things like that, since they generally have a very good view of the entire product/feature set. And this is problematic. But, test engineer, QA engineer, they come in different forms. Some are just people writing test cases and descriptions to be followed by hand, sitting day in and day out with a remote pointed at a TV, figuring out if the UI elements render smoothly, and if scheduling recordings that slightly overlap cause problems, and if having a program that starts before it stops, because there will be a time shif (summer time/winter time) during it's playing... Others are programmers that build test infrastructure, load tests, QA tools that hook into the CI system. Not quite devops, but not far from it either. 
If you really have an opinion (or even expertise) about OPs problem you should probably give an answer or comment positivly about one of the editors above. But arguing with me without any data to back it up is just a waste of everybodies time. Give me an example of a Python IDE that uses less resources and has the same responsiveness and features that Gnome-Builder has as an IDE!
You have my upvote! 80 MB sound better. I don't mind the HeaderBar in Gnome-Builder because it is used for searching and switching the pannels into visibility (But I agree that apps that don't put any buttons in the headerbar are sub-optimal). I think Vim and Gnome-builder are similar responsive when it comes to CodeCompletion and Scrolling+Symtax-hightlighting. So I would say it is largely a question of how much RAM OP can spare and how much OP relies on graphical user interfaces.
Your points might be valid if Python wasn't a key component for many Linux users. It comes down to what about a Linux distro is important to the user base. For some it is the latest kernel for others it is being a great development environment. For modern installations a great development environment implies the most recent Python. If I wanted old stable Python I'd go out and choose another distro. Fedora however is supposedly a bit more bleeding edge and as such you have the right to expect key components to be up to date. 
Its really not a binary choice. By the time you've learnt one version you are 99% of the way to knowing the other.
[Ninja](http://ninja-ide.org/) is a good light IDE for Python.
I like the sound of that, I'd definitely lean towards the math and stats part although my science background is more health science so that puts me behind.
[A direct link to the website](http://alexrecker.com/our-new-sid-meiers-civilization-inspired-budget/), for the exceptionally lazy. Nice idea, not sure why it needed such a complex explanation.
3.5, and that's the obvious answer. When OpenCV 3 will air, no-one will ever have a reason to remain on 2.7
Yes. We all know this. But I find it hard to recommend 2 for someone whose required packages are all available for 3.
Nice. I, personally, wouldn't want to deal with everyone asking me why I have the Afghanistan flag as my profile picture -- but if she's cool with that, more power to you :P
Yes : GUI, sys admin, data analysis, ESB, testing, building automation, etc.
You keep saying "it's already near the max"… it's a lot ! You're rich. Maybe could you stop your job for one or two years, do a lot of programming and see what's the result ?
But what about right days?
It might be overkill for this project, but you should look into NLTK. There is a `tokenize` function which splits words automatically. It's also just a great package to know in general
Use python 3 unless you know exactly why you need to use python 2 instead. 
It's interesting seeing opinion shift, though! Even just in the last couple of years, these threads used to be slightly in favour of 2.7 and are now firmly for 3.x.
I suggest splitting your cellphone bill into a base amount + variable amount(base amount being the minimum cost each month for the service), and incorporating the base amount into your magic number. Do this for anything that has a variable cost that includes a non-zero minimum cost. The more things you can incorporate into the magic number the lower your volatility and the easier it is to see how your finances are going. Since you developed it in Python you should be able to easily enter the entire cellphone bill when it arrives and it will automatically calculate the variable component for you and add it in
How about creating a simple neural net trained to compute a sine wave. Make it with three layers: input/hidden layer/output. 
&gt; However, on the question of learning, they really are the same for almost every task. On the question of learning, they have a dramatically different landscape of learning resources.
I agree; that's the kind of code "non-pythonic" was invented to describe. :-( Shame on people for not voting this up yet. 
Hey, as someone who's been programming in Python since like 6 months ago, I started with 3.4 and had no problems learning. I've had a few problems when trying to use libraries that were made for 2.7, but luckily they've been pretty easy to modify to make them work with 3.4. If you just want to learn and don't have any specific project in mind that uses libraries made for 2.7 I'd recommend just starting with the newest version, as there's obviously a reason they released it (improvements).
Source code is the new tutorial? 
Isn't that survey ≈2 years old? I think things might be a bit different now. I am of the opinion that if we keep discouraging those looking to learning Python from starting with Python 3, we might be perpetually stuck with using Python 2.
It is, but it's also the best data we have. I agree with your opinion. However, what is best for a company or someone new is to choose what is most popular and hardest to shoot yourself in the foot. Need some fancy async, then go right ahead. Why would you want to fight with unicode before you actually learn how to do a for loop? What is Python 3 really buying you personally? I run a 200k line open source project. It supports both Python 2 and Python 3. There's no substantive difference except a lack of a GUI in Python 3 because VTK doesn't support Python 3 quite yet.
This assume the cell phone bill is a constant amount. But again, this app assume you earn the same amount of money at the same date, so it doesn't work for freelancers.
2.7 if you are new to programing, 3.5 if you already know another language. 
The web browser is nice too, and has tools such as a "network monitor" that can display all the web traffic to and from the website, etc.
A repo, yeah.
Atom's icon should be a picture of Mr Creosote... Or maybe John Pinette...
It works with both. ;-) I have to write this in the readme, already know.
Thank you too.
Yes, passing the parameter "multiple_instance = True" in the "start" call each client has it's own App instance. But maybe you have to implement a registration/signin system.
wow so much hate :P ... tho i think Mr Creosote should be brand ambassador for eclipse which consumes so much ram. but functionality wise eclipse is the best for Java and Scala. i don't know about other languages supported by eclipse. 
Awesome
How it is related/different to https://github.com/shedskin/shedskin ? and Cython ?
I've used both and they were roughly equal in RAM gluttony.
Why does the number of downloads from computers equate to the number of developers developing current projects with Python 3? Deployed software or computers running Python != current projects in active development using Python. You'll need stronger explanation of the number than just there's lots of downloads".
For me, the new matrix operator in 3.5 is reason enough to switch.
doesn't exist anymore. however, I'd prefer using the grequests lib
If your background is health science, look into python packages and frameworks related to the health industry. A quick search produced https://us.pycon.org/2015/schedule/presentation/428/
Pythran sounds more like a Python to Fortran compiler. :P
There are enough widgets to interact with the user, that allows to show data (like Label, TextInput, Table etc) and receive inputs (like Button, Menu, Checkbox etc). You have write only python code. The contained examples will make it easy to understand the usage of the library.
Without being an expert, PyMC3 is a full inference package. Uses advanced samplers (NUTS), and stuff like [Theano](http://deeplearning.net/software/theano/) which allows for clever estimation of the likelihood + prior gradients, so you can exploit that information to sample more efficiently. emcee is "just a sampler" (albeit a very nice one). It often gets forgotten that there's also [sampyl](https://github.com/mcleonard/sampyl), somewhere in the middle of emcee and PyMC3. I have started using it for a number of things as it's very nice where you have access to your prior and posterior and estimates of the gradient (or can get them using autograd). It's far easier to use and install than PyMC3 and works reasonable well. For large scale problems, the approach taken in emcee doesn't scale too well (although there might be changes on emcee, haven't checked on it for a while), and sampyl seems to deliver the goods without much hassle. The code is also clean and simple to dive in if you want to contribute (I'm not the author btw), and I think it deserves more love. 
&gt;Which is my point. I don't get it. That was my point too. &gt;What if a, b, c and d have the SAME type? Then I might have a type checker for each of them? &gt;It DOES increase the coupling because it DOES receive more data. In positional argument case it gets [1, 2, 3, 4] and in the kwargs case it gets {'a': 1, 'b': 2, 'c': 3, 'd': 4}. So instead of do_something_with(a) you have do_something_with(kwargs['a']). The method still doesn't 'know' anything more about that method than what it was previously told. You've just lost the ability to do type checking via the method signature. &gt;Absolutely not. It fails FASTER because mismatch of the function keyword arguments is checked at the call site, vs just checking that the number of arguments are the same. Ok, so if you call like this: function_name(a, b, c, d, e) you won't get any indication that e isn't being used. It will silently take it.
3.5
Do all these Python-&gt;C++ compilers provide any significant speedups? I've seen Cython, Nuitka, and now this. Is there any advantage?
Ask /r/learnpython.
Here's a nice little example of a Pythran code speedup. http://stackoverflow.com/a/32600805 It's pretty simple and pretty powerful.
Thanks for confirmation :)
I regularly use https://csvkit.readthedocs.org/en/0.9.1/ to quickly clean/browse csv files.
I started learning Python 2.7 because I was introduced to Python through Rosalind. Initially, I wasn't much bothered about Python 3 but later on I installed Python 3 as well. I am still dedicate most of the time on 2.7 but I also keep practicing on Python 3 and keep referring Python 3 books. Although I think if you have just started learning, you should go for Python 3. You can easily check where Python 2.7 and 3 differs. After all, Python 3 came into existence because Python 2.7 needed improvements. Besides, most of the packages are available for Python 3. Rest of them will be available by the time you gain some mastery over Python 3. 
I personally use it to rebuild Sphinx documentation on every file change, but you can easily find other ways Nana can help you. If you have questions, feel free to ask here in the thread. If you found a bug, please [report it](https://bitbucket.org/moigagoo/nana/issues/new).
I'm a little out of touch with Asyncio, but I liked his idea of an API standard with a reference implementation. 
you could have the password as an input variable when you run it in the command line. At least that is what I did when I made a selenium python script and had your same concerns.
The encrypted volume will have to be unlocked in order for the process to read from it, so you're back to square 1.
Pythran only targets the subset of Python used in scientific kernels (including many numpy functions) and has several optimizations built-in to optimize this (lazy evaluation, loop fusion, SIMD instruction generation etc). There are no such optimizations in Nuitka, for it targets the whole language. So my catch is : use Nuitka for general purpose code and Pythran for scientific kernels. the same statement holds for shedskin, btw.
do you have a usb printer or a network printer?
I now tried saving the file as BMP and then printing via LibreOffice. The result doesn't look that good...
I somehow have to think about HHVM now. Started as a PHP to C++ compiler (some like to call it transpiler, whatever). And now PHP 7 gets released in a few weeks and is partially as fast or faster than HHVM.
Yes, but the consequence is thre is no inter-call optimization, thus you're paying for all the temporary array creation, and you don't merge the operations when possible. Nor generated SIMD instructions for the merged (implicit) loops etc.
if you have a network printer instead of a usb, you can forget about win32 and send the image to the service on the printer, you need to know the protcol used by the printer and choose the right library/module/api 
This is great! Thank you, but how do I convert that element into an int or float besides just detecting?
I understand but cannot suggest you the best method to do this because I do not use web frameworks.
Inotify already does this. 
You would need to get into a management position for the $150k+ year and to qualify for that you will need to have 5+ years of extensive experience. Once in management, you are actually doing very little coding.
If someone has root access to the machine running the code, you are already done. Any mechanism living solely on a single computer at some point needs to be decrypted into memory.
This comes up a lot in sysadmin work, and the solution is to use good OS level file permissions controls. Also, the *only* time Selenium is the right answer is when you need the browser to render something. Otherwise you should simply be reverse-engineering the site's API, and using requests.
Either way, sounds like you're just doing security through obscurity, and not anything that'll actually help. Rely on your OS to protect files from other users.
That's a huge question - my days are varied. I have a good day every day. I feel that not everybody in banking feels the same way that I do - however I count myself fortunate to be in a department run by good managers who take an enlightened view towards what makes a good developer environment. At the moment my project is mostly Scala so I'm on Intellij. The bank I work for has invested in it's own python-based platform (sorry cannot talk much about this in public), so a lot of my time is spent working with that.
&gt;what's the point of unary plus when it does not change the var value Why would unary plus change the var value? Unary plus is just like unary minus - it affects the *expression* value (or not, as the case may be). Changing the variable would be really weird behaviour for a unary operator. Some languages have increment operators that do so, but these are not the same as the unary operators, they just happen to use the same symbols (the same way `&gt;&gt;` isn't the same as two greater than signs).. &gt;you cannot write those things in many other languages What languages are you thinking of? You can write that in most C-like languages at least, and indeed, likely in any language that has a unary plus. The only caveat is that some languages define ++ and -- pre/post increment/decrement operators, so you need to lexically distinguish that by breaking up the tokens. Eg the following C / C++: int a=5; printf("%d\n", +a); printf("%d\n", + +a); printf("%d\n", + + + + + + + + + a); printf("%d\n", + + + - - - - + + + + - - - - + + + + a); printf("%d\n", +-+-+-+-+-a-+-+-a); /* don't need spaces here, since no lexical confusion with ++ or -- ops */ will give exactly the same output as python here. Same for javascript, java, C#, ruby, and a bunch more.. It makes perfect sense when you think about it. Clearly, you want to be able to write -a: the unary negation of a, right? But it's not just variables you should be able to negate, you want to be able to negate functions and any general expression. Eg. you'd want to be able to do -(foo(42)+5*bar) and simiar, or -(expr) for any given expression. And if you can do that, then nothing stops an expression involving a unary minus itself. Eg. `-a`. so you can do -(-a), -(-(-a)) and so on. And those brackets are redundant - so that's the same as `- - - a`. Finally, unary plus is just the equivalent of unary minus - it's somewhat less neccessary since it's generally a no-op, but it seems sensible for it to behave symmetrically with minus. 
if you are suggesting hashed passwords for this, you need to recognize that you have no idea what you're talking about
Weird, it looks like you might have got a bad installation. Did you check pep8 module? engine.py in line 240 seems to point to pep8 being the culprit. I downloaded pep8 and made sure that the method was there, then I removed it and did a pip install flake8, created a self failing test for bad math and ran the script, but didn't see any issues. I am also running Python 3.4 and didn't have any issues with it. I would also consider just opening the Python interpreter in whatever env you used to install this and do a "from pep8 import normalize_paths" to see if it comes up. If not, you may need to pip uninstall and pip install again to get it to work.
Hey, so to me, it looks pretty good overall. Here's a question though - are there certain values you calculate in the functions that would be easier to define as attributes for the class? I'm having trouble switching back and forth (on mobile), but I wondered that since the classes look to serve primarily as a wrapper for the functions.
Npp does autobackup to a folder you specify. 
Make a config file (I use JSON, personally, out of preference, but you could use INI or even a .py file to import, really): { "user": { "name": "yourname", "password": "password" } } Then, make sure it's only readable by the user: `chmod 0600 config.json` Then load it in your script: import json with open('config.json','r') as f: config = json.load(f) uname.send_keys(config['user']['name']) pword.send_keys(config['user']['password']) I put all my user variables in a JSON config file. Safest possible way without delving into encryption and stuff.
That's simply because of their age.
Thanks, Kivy seems like what I need. My goal is to have an on-screen-keyboard that has only 6 buttons. I want to be able to click them and fire our a keystroke such as "up arrow". I need to be able to set transparency for the entire window. It needs to always be on top of windows eg. when using a game I want this mini keyboard window overlaid. Does this sound plausible? I know basic python where I have made a 2D shooter with pygame. I have used Pyglet as well. I havent done anything regarding buttons....I really wanted to use HTML5 eg. Electron w/ nodejs but I ran into trouble where I cant send data to other windows...the electron app is always in focus.
Git-crypt
Coincidentally, someone posted this exact problem within the last week on /r/django, I think. The only comment when I saw it suggested `string_if_invalid` as well.
thanks for replying!
That's where it came from (as noted in the post, I went down this rabbit hole because of the question in /r/django).
Sure.
Yes, you are right. And for this reason I have not mentioned it. Flexx seems to be very similar. I have not Flexx knowledge, and so I am unable to compare it to RemI. There is someone can help on this?
Originally, the classes were their own, unique endpoints, but they've been combined and I haven't gotten around to removing them. Good catch though.
`units` is a simple enough program. Maybe you could get the source and either make a library or translate into a Python module.
I run a Python based Twitter weather bot and I just use a simple .cfg file [CITY] CONSUMER_KEY = consumer key here CONSUMER_SECRET = consumer secret here ACCESS_TOKEN = token here ACCESS_TOKEN_SECRET = token secret here Then: config = ConfigParser.RawConfigParser() config.read('settings.cfg') CONSUMER_KEY = config.get(city, 'CONSUMER_KEY') CONSUMER_SECRET = config.get(city, 'CONSUMER_SECRET') ACCESS_TOKEN = config.get(city, 'ACCESS_TOKEN') ACCESS_TOKEN_SECRET = config.get(city, 'ACCESS_TOKEN_SECRET') 
Because most of the time, you don't actually need the ordering, and keeping the dict ordered adds substantial cost (a lot of things become O(log n) instead of O(1)). If you really need ordering, `from collections import OrderedDict`, or look into SkipDict on PyPI. 
What is the benefit of grequests over requests + gevent monkey patching?
php has ordered arrays.
I think OrderedDict is implemented as a dictionary into a linked list, so you get to keep the O(1) operations. But you definitely lose a constant factor in both time and space.
you are extremizing things a bit, but I get your point (under a wall of rethorics, that is) 
I think most JS implementations keep object fields in insertion order most of the time. At this point too much code relies on that to change it, even though it's not standardized.
A django (&lt; 1.8) wat, when using python 2.x
How exactly does that work if you remove an item? Is it a doubly linked list?
There are several cases where I can see the usefulness of having a total order on all values in the language, but using ordinary comparison operators for that purpose seems ... error-prone?
well, can you agree that `-(-x) == +x`? &gt;&gt;&gt; --1 == +1 True &gt;&gt;&gt; --123 == +123 True &gt;&gt;&gt; and so, to the same end &gt;&gt;&gt; x = Decimal('3.1415926535897932384626433832795028841971') &gt;&gt;&gt; 0+x Decimal('3.141592653589793238462643383') &gt;&gt;&gt; +x Decimal('3.141592653589793238462643383') &gt;&gt;&gt; --x Decimal('3.141592653589793238462643383') Its performing a mathematical operation, and as such, is a completely valid response to `+x`, if the response was any different, that would be far worse for consistancy
This is really strange, x should be Exception(). This seems like a language bug as opposed to quirk. x is only lost if it's defined before the try/except and there's only a pass in the except clause.
We at Abilian use (currently) Flask+WTForms for HTML forms rendering / validation / serialization and Flask+Marshmallow for "REST(ish)" APIs.
The code overwrites a variable in a really silly way. I see the point, but I'd hazard a guess that more problems are resolved than cause because of that.
Not a "bug" in the sense of incorrect behavior. The `except &lt;exception&gt; as &lt;varname&gt;` form is defined as clearing `varname` at the end, so that the example code is actually executed as if it were: try: raise Exception() except Exception as x: try: pass finally: del x The reason for this is that `x` holds a reference to the traceback, which holds a reference to the stack frame, which in turn (through its locals) holds a reference to `x`, which creates a cycle. The GC would eventually clean that up, but it would allow the frame locals to live longer than they're supposed to, and so to guarantee they get cleaned up at the end of exception handling Python forces this behavior in the definition of the `except` statement.
[Here](https://www.reddit.com/r/Python/comments/3sytg6/a_real_python_wat/cx1x3d0) is the explanation of why it is that way.
[Here](https://www.reddit.com/r/Python/comments/3sytg6/a_real_python_wat/cx1x3d0) is the explanation of why it is that way.
I think the numpy encoding is important, the folk who I'm aiming featherweight at aren't big of web knowledge or JSON encoding or the like - that's at the wrong end of the stack (they focus on matrices and linear algebra). They'll learn web-stuff if needed, but my goal is to open the door, not force it upon them. Re. your two requests - agreed, they sound nice, I shall bear them in mind, cheers!
Flexx is more powerfu but too complicated. The react concepts leak into the GUI abstraction
Probably not good learning resources to use then.
May I ask you why you feel it more powerful?
Nah. It might be not a Python resource per se, but something that uses Python (just intro to programming, CS, data analysis, scientific computation etc). It doesn't really matter in the end of the day for many applications.
Yep, i'm doing consultant work on Kivy, Android/iOS app. And i'm building Android/iOS application for customers, as well as Kivy/python-based multitouch installations for Museums.
I use Selenium frequently, firstly I recommend turning off images, CSS, Flash, and javascript(if possible) to speed up Selenium. If you are on Windows you can't really lock files to a specific user and if you want to be able to input plain text into the browser there must be a way to obtain the string for the password someway. Getting the user to input the password is one option but is not ideal. What I do is just scramble the password and store the scrambled password in plain text (it is scrambled using a seed in random and can be unscrambled if the same seed is input) that way a person would need both the scrambled password, the scrambling function and the seed used to unscramble the password so if the files were stolen with the file and the seed (excluding the scrambler) the person does not know my password. Alternatively you can use cookies; driver.add_cookie({'name':'key', 'value':'value', 'path':'/'}) This method is more secure but not ideal for me as cookies can expire but the cookies can be scrambled like the password to add more security.
So nothing to do with a Buddhist temple-monastery then. How droll.
I think the bigger question is why try/catch is unscoped in python, unlike in most other languages. If try/catch were scoped, both this language inconsistency and the GC issue would just automatically go away, as the variable refc is decreased at scope exit.
&gt; The philosophy here is that we shouldn’t necessarily take down your entire site with a hard HTTP 500 error any time you have a typo in a template variable name, or forgot to provide a variable you were expecting to be able to access I wish people didn't do this. I just flipped out because I tried to use TkInter and it silently squashes exceptions from your program because "We don't want the GUI to go down if the business logic bugs out".
I regard this code as unsafe. Why do you put the dangerous chemicals in the same refrigerator as your cold drinks? One day you will swig from the wrong bottle.
Oh, that makes sense.
I really prefer an unscoped `try`. Consider try: file = open("foo") except IOError: bail() with file: file.read() assert f.closed Try doing that in Java. It's not so fun. It would be even less fun in Python, since you'd need to say `nonlocal` in the `try`. FWIW, Rust has a nice way around this (every statement is a block and RAII over exceptions) but it wouldn't really work for Python.
That makes absolutely no sense
This goes back to the earliest days of Django, and primarily to the fact that the template language was explicitly intended for use by people who knew HTML but not Python (and who were not necessarily programmers of any sort). So for things that are reasonably recoverable, Django's template system doesn't outright crash and start throwing tracebacks at you; the complexity of how invalid variables are handled is the tradeoff (and much of *that* is designed to make it easier to help non-programmers debug problems).
&gt; The point is that the previous x=5 assignment has been lost. It has been overwritten by the `as x` which is perfectly normal. The odd part is that `x` is then unbound (and /u/ubernostrum [explains that this is desired and specifically implemented so](https://www.reddit.com/r/Python/comments/3sytg6/a_real_python_wat/cx1x3d0))
&gt;Objects of different types except numbers are ordered by their type names I literally started laughing out loud
Rename your exception variable then.
No, a few different aspects stop them from doing that. For starters they don't get access to run, the C drive, and they can't run programs from within explorer windows address bar. Secondly and more importantly, group policy restricts access to command prompt (they're also blocked access to scripts, as we don't use those any more in this fun modern age :D) :) Being school PCs, they're heavily restricted in their movements. It's surprisingly difficult to get to something like the command prompt without knowing a trick like the one above. bat, cmd, reg etc etc all the usual suspects are blocked with functionality provided by applocker (and previously software restriction policies) which define where and when various file types can be executed.
Shouldn't `() &gt; []` compare size of an empty or default object or whatever, rather than the string names? Wouldn't that make more sense? Edit: I guess it might be because `sizeof` in python needs `sys` to be imported but still...
You're not "upgrading", you're porting if you do this move. That doesn't mean you shouldn't, but you should appreciate that code will break if you don't treat it as a port to a new language, because that's what it is. 
Hi Chris! SO happy to hear you participated in Ulti Coder! We are hiring new grads for our TechSTAR program - you can apply for that here :) You can also email techcareers@ultimatesoftware.com https://recruiting.ultipro.com/USG1006/JobBoard/dfc53730-57d1-3460-336f-ddafabd108f3/Opportunity/OpportunityDetail?opportunityId=a0ba98bc-b3e3-4bab-af6e-8925d24418c5 
Hi anossov, It is true that we have meetings, but every company has to have them in order to be successful and keep everyone on the same page! Happy Monday :) 
No, unless you compile your own version of Python.
Don't move to Python 3 for bug fixes (although the improved—still not great, but improved—Unicode handling would count as a bug fix in my mind). Move to Python 3 for new features (hello, `asyncio`; `async`/`await` is pretty amaze-balls) and because that's where all future dev on the language will happen.
&gt; Pybedtools is the big one that doesn't have 3.x support It does now!
Thanks for the info, I had not realized that
I've been really liking [TQDM](https://github.com/tqdm/tqdm) for this. It's very simple to use (it just wraps an iterator and returns another iterator) and supposedly has less overhead than PB.
Nope, purely need to see if the device is up and connected to the network. Cool thanks a lot!
You know, I feel like these would be much nicer if they were implemented as decorators. @cool_py_timer_bar def long_running function(foo) ... return bar Something nice and pretty like that
To be fair that would be much easier if the new version didn't have worse performance and break backwards compatibility with a ton of legacy code used by businesses. I don't particularly want to use Python 2.7 over 3.x, but I also can't justify rewriting 10's of thousands lines of working code.
Or a context with ProgressBar(...) as pbar: do_stuff() pbar.update(...)
I didn't plan on the code getting so much attention. It was a rough POC I threw together so my wife and I could start using it. As mentioned in the README now, I've rebooted the project in hopes of turning it into a public tool. There's much work available yet, as I still have to port over the guts and get authentication and the framework squared away.
Thanks! Yes, it's a little over-explained, but only because I'm not very financially savvy and I wasn't sure how much of it was novel. This project marks the first time I've tried to intelligently track my own finances, and I wanted to get as much feedback on the thought process as possible. We are thrilled people are digging it.
This is a good idea too. I feel progress meters like these should be implemented as easily and transparently as possible.
so... it's clint.textui.progress.bar ?
I made a convenient function to fillup the Table from a 2d matrix. You can see the usage in widgets_overview_app. Let me know your opinion ;-)
Thanks for the update. It's still returning the whole list rather than the difference between the text file and the directory.
I think you'd be shocked at how easy it is, in general, to migrate a large code base to Python 3. I did it earlier this year (roughly ~7k lines of code), and it took me all of a couple hours to make the fixes and test my code. There really aren't that many major changes in syntax.
2 questions: what does the pep8 directory structure look like in your site-packages and are you able to find the method in your pep8.py file?
fuckin facepalm. I had a file called pep8.py in my pythonpath that I'd created for some reason. Deleted it and it worked.
Agree, I really thought it was going to be a decorator. 
Hug is actually far *simpler* then featherweight import hug @hug.get() def myfn(x, c): """Example function""" return = x*x + c vs: import featherweight_api def myfn(x, c): """Example function""" return = x*x + c featherweight_api.register(myfn) featherweight_api.run() # run the server on localhost:5000 Also, hug will auto-document their API for them, and add a clear path to add automatic argument validation and conversion. You get much more for much less code, and much less learning required.
This was very interesting. Let us/me know if you decide to write a tutorial on CFFI.
True, especially since PyPy.js is still being developed, I'm sure that there are plenty of optimizations that can be made. I just fear that, with developers wanting to use other languages and heavier frameworks on the web, that this kind of usage will become standard now that it's possible.
I ended up going with the ping method to check if the device was actively on the network. Thanks though!
It's a reference to this: https://www.destroyallsoftware.com/talks/wat
That is one of the coolest libraries I've ever seen.
&gt;If I could change one thing about Python, it would be adding let or var I'm not too bothered by function level scope, but I do agree that expicit declaration rather than assignment and declaration being the same syntax would be better. Currently the way you designate scope seems backwards to me: there's a keyword for explicitly *not* creating the variable (ie global or nonlocal), rather than for declaring it.
well, the problem is really the platform, not the pypy.js itself. In theory you should be able to use the platform at insignificant cost compared to native (e.g. 30% in mem and cpu) with *just* pypy optimizations and not pypy.js optimizations (it's just a backend).
I created a simple progress bar for Dos while my programs run. Usually the output of my program is a write() to file, so this displays in the terminal. # this part instantiates the counters import math progress = 1 # for Progress Bar progress_bar_current = 1 # For Progress bar percentage = float(float(100/float(#####))) #replace hash marks with len(list) or simply the number of iterations if known # This part installs in the function as it iterates. progress += percentage progress_bar = int(math.ceil(int(progress)/5)) if progress_bar != progress_bar_current: os.system('cls') print '\n\tSearch Progress:' print '\n\t' + '\xdb' * progress_bar + '\xb0' * (19 - progress_bar) progress_bar_current = progress_bar I thoroughly impressed myself when this worked as planned, since I'm a fairly new programmer, and it beats staring at the blinking cursor in Dos, with no idea if the program is even working. 
Which I can appreciate, as I've seen my fair share of bad Python. And honestly, I don't write decorators often, and honestly don't know yet what edge cases I have to deal with, but I'm now interested in making this a pure Python decorator because I've actually always really wanted something that simple to do exactly this. 
1.2x performance *increase* over cpython? What. So the next step is to write an HTML5-backed implementation of libsdl or pygame, so we can just run darned python games on the web, without significant performance issues? That's... unexpected, and impressive. 
&gt; def test_get_static_vendor_css_bootstrap_3.3.5.min.css(): SyntaxError: invalid syntax Looks like it needs some work in how it generates the test function names. Otherwise it's a pretty interesting idea...
They don't have access to powershell, that's already blocked, and they can't install their own programs (so no explorer++). Students also can't run executables (there's actually a massive list of the different file types that are restricted) from any location they have write access to (this includes pen drives). Nor can they download executables or any compressed resource within school. I'm yet to see anything besides this little python code (which I've now fixed without breaking python) that can get around it. I invite ANY suggestions on how you believe they may be able to get around it! I always like to make sure i know about every avenue of attack. There's very little the combination of group policy, file server resource manager and applocker haven't been able to lock down though. EDIT: I should add, although their movement sounds very restrictive, it's all geared to ensuring both security in terms of user tampering and that they stay on the task a teacher sets rather than exploring.....like i did when i was a student :p I used to spend more of a lesson testing out how deep i could go rather than doing what i was tasked with.
Reverse engineering a ton of unordered hopefully unobfuscated javascript requests tied with event listeners in random locations and handing the sessions with correct cookies and headers and data is a pretty big waste of time and effort for a simple application
I agree, `tqdm` is much much better, compare example from blog post: #import libraries import progressbar as pb #initialize widgets widgets = ['Time for loop of 1 000 000 iterations: ', pb.Percentage(), ' ', pb.Bar(marker=pb.RotatingMarker()), ' ', pb.ETA()] #initialize timer timer = pb.ProgressBar(widgets=widgets, maxval=1000000).start() #for loop example for i in range(0,5000000): #update timer.update(i) #finish timer.finish() With exactly same thing rewritten using `tqdm`: import tqdm for i in tqdm.tqdm(range(0, 5000000), 'Time for loop of 1 000 000 iterations: ', 1000000): pass 
I wish these progress bar packages worked with iterating over large files. That's my typical use case when I want a progress bar.
Regardless, it's a genuine bug. I've gone ahead and resolved it in https://github.com/jjyr/zerotest/pull/1
How about [sentdex](https://www.youtube.com/playlist?list=PLQVvvaa0QuDe_l6XiJ40yGTEqIKugAdTy)?
I use PHP for things like this, I've done a variety of projects on pi using a blend of PHP for web elements, and python to access various data and comms. Here is a link to a good thread on it. Same question, and there are a variety of answers. http://stackoverflow.com/questions/19735250/running-a-python-script-from-php
sampyl is new to me, thanks! You might consider submitting it, don't think it's been posted here before. 
https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-gunicorn-and-nginx-on-ubuntu-14-04
WebGL backed pygame would probably work pretty darn well actually. Might be the future.
This.
I just want to clear up for you that you are not using DOS. The command prompt (assuming you are using windows), is still windows. DOS is a very very old operating system.
Just this weekend used tqdm to show progress while processing a file containing approximately 6.5 million records. No problems, nicely displayed in one line of terminal output.
What kind of web server?
I... I thought this was /r/elitedangerous for a second... 
If you're developing in a Windows environment the most significant advantage is ease of installation. Although [Christoph Gohlke's webpage is phenomenal](http://www.lfd.uci.edu/~gohlke/pythonlibs/), it's a lot easier for someone new to python to install one Anaconda package, even if it's 350MB, than to hunt down each individual package and install the wheel with pip. This has the advantage of lowering the pain threshold for someone who wants to experiment with ipython notebook or pandas or some other useful tool and will likely result in them starting down the road to learning Python. If they can't even get numpy installed because of pip compiler error, they're more likely to not experience that initial thrill and not pursue the language. 
I would recommend getting a better shell than the standard command prompt that comes with windows. I am a linux developer, so I don't know what the state of the art is on windows, but I'm sure someone could comment. If I were to use windows I would probably use the bash from cygwin, but I haven't touched a windows machine in quite a while (for development). But yeah, just FYI the command prompt is not DOS, and its not used colloquially in that sense either.
GUI based virtual envs. Sci kit actually installs Stop worrying that the whole system hangs by a thread and some C++ package will destroy everything I will never go back to anything other than anaconda (on mac). Just genrally not a total pain in the arse, well done anaconda!
Can you please share the code? Maybe I'm doing something wrong, or maybe something changed since I last tried tqdm.
It's better at handling C libraries than pip, and effectively bundles virtualenv, virtualenvwrapper, python and pip all together. C libraries often fuck up when using virtualenvs (see: a lot of the time, you can't use an interactive backend with matplotlib in a venv). You want to be using a virtualenv for most projects, because there's so much shit that can happen in your system to mess up installed libraries (I've had repeated problems with graph-tool just fucking up for no reason). Conda install is much quicker than pip for large libraries like scipy. Because it deploys much quicker and is much more platform-agnostic, it's much more useful for CI. The downside is that a lot of PyPI is missing from conda (although tends to be more obscure packages), and mixing up where you install things from is a bad idea.
Oh god that API you added is horrible
Great article! 
Yes, but redraws don't happen until the timer says so. Which makes it not as reactive as others
Oh dang, first time I've heard of someone using sampyl out in the wild. I'm really glad it is working out for you. I spent the last few months job hunting so I haven't had much time to work on it, but I'm getting back to it now. This is some nice encouragement, thanks!
Man, that pythonlibs page saved me countless of times while working on Win! Thanks Christoph! 
are you a total beginner to programming in general or just to python? 
Looks really nice, but seems you can only use this in for loop? 
sick, even comes with pip installed
Ok, this is intresting. But consider this, I only added a new function and not removed the old one. Okay, you consider it bad, and maybe it is. And this is the reason for which I posted here, obtain feedback.
Python &gt; PHP
Run the entire server from python, if you use something like flask you can also use python for templating as well as using python natively to power the site.
Uh this seems like the right time/place to ask. When I just want to read files I just do this: variable = open('file.txt', 'r').read() is doing it like this wrong? I think it may leave an open file object but I am assuming that garbage collection takes care of that. instead of: fileob = open('file.txt', 'r') variable = fileob.read() fileob.close()
Nice! Didn't know you could do that. Thank you.
The o let programming experience I have ever had was low level Python and it was about 7 years ago, so stark beginner. 
you just install git, it comes packaged with a colorful bash and mintty and it just works
Sorry for the lack of explanation from others -- hashes by definition are one way, so given the password `pass12`, you might end up with `80d20c`, but there is no easy way (intentionally) to go from `80d20c` back to `pass12`. So a hashed password makes sense e.g. for user passwords--we don't want to know what the user's password actually is, we just verify it achieves the same, hard-to-crack, unique hash. But in this case we want to store `80d20c` but be able to convert that back to `pass12`, which means we could use a "two-way hash" (note that string of words is meaningless) or rather an encrypted string which we can decrypt. A well-crafted hashed password should take roughly the heat death of the universe to crack for anyone; for an encrypted password, we would want someone with the proper access keys to be able to relatively quickly decrypt, but for anyone else, heat death and all that.
And? You've covered a microscopic keyspace?
The draw is for people who don't know all of that? 
Great, a place to start! Thank you!
Not going to happen
The government funds science (in the US through NSF) and arts (in the US through NEA). The government should also fund worthy open source software projects.
Will repost it there...
I just don't have the expectation that the Except clause is a separate scope because that's not how python works in other cases. So, you clobbered x. It should not be 5. I agree that my expectation would be that x would be the exception, but I disagree that this is a gotcha because a gotcha means (to me) that you were trying to do something that made sense and the language gave a result that doesn't make sense. Trying to get the exception from x outside of the Except clause doesn't make sense because it might not be there (ie: there was no exception) and so there's no valid reason to try and access it. x being the exception is the worst possible case because x would be 5 in the case of success and then on the off chance that the exception is triggered, x is some totally different thing. So you caught the exception, yeay! but then it creates some awful side effect that breaks your code in a new way. x staying 5 would make more sense, but then exceptions are an exception, because for loops and `with` don't create new name spaces. And the except block is all about accessing the current name space, because the whole point is adjusting the current namespace to account for the error. So, accidentally passing the exception to the current namespace because you weren't paying attention to variable names is unacceptable (because there is zero use case for it), as is creating a new namespace for something that exists to operate on the current namespace. I can't say that I'm in favor of "consistency" when none of the options make sense and they all cause more trouble than being "inconsistent".
Does it have to be held in memory simultaneously, or can you iterate through a portion of it? If it can be read line by line and you don't need to keep the results (at least all of it) in memory for some end use evaluation step, there's really no limit to the size of the input file. Python will happily chug away chewing through a multi-terabyte file until you get bored watching it run. From what you're describing, the only memory requirement would be to hold enough to evaluate against the string you're trying to match, which would be minimal. EDIT: this stackoverflow deals with your question specifically: http://stackoverflow.com/questions/17056382/read-file-in-chunks-ram-usage-read-strings-from-binary-files All you need to do is read one chunk that's 50% the size of your total desired matched string, and then read the next chunk and append it to the first. Then evaluate the whole chunk. Keep the second chunk, grab a third chunk, glue them together, evaluate, grab a fourth chunk, etc etc. Memory usage is minimal, speed on a decent machine should be pretty quick. 
vim
"All software needs to match my workflow, or it's terrible." Mmmmkay buddy.
&gt;does anaconda have a dramatically better user experience than pip and virtualenv? is anaconda an improvement for people already experienced using different tools in the python ecosystem that solve the same problems? The answers are yes and yes, if they are qualified with "windows doing science". At least a few years ago, getting both matplotlib and numpy up and running was nontrivial, and ran the risk of discovering dll hell. Also, irrespective of OS, if there is a need to maintain legacy code in a variety of minor versions of the interpreter (e.g. 2.5, 2.6.2, 2.7.10) (looking at you, science!), this is rendered trivial, since the interpreter is treated as simply another package.
Any decent programmer's text editor will be able to open files of arbitrary size without loading them entirely into memory. 
I'll give it a shot
It is still going as I type this... Roughly 14 gigs of just characters at this point. Think it'll still work?
gists, to be exact. .:)
&gt;Only in Python is something like that perfectly normal. No block scoping in Pascal/Delphi either.
Odesk changes their name to upwork because their reputation was such shit. It's great if you live in a third world country, otherwise the wages are horrifically low. 
Www.repl.it
Arbitrary size means arbitrary. 
Can you show me the error messages you are getting? You gotta understand what is not working before you can fix it. It's not working right is not a good answer for solving a problem. Define what is not working. Is it a connection? or is expecting data in one format and you are giving it something else. You're working with an external api in spotify so you might have to go through the documentation. Once you understand what is not working, then you can fix it. You can do it. I have learned to put exception handling in any code that has any dependencies outside the scripting environment like connecting to a database, reading a file or making requests. Understanding error messages is the key. Most of the times solutions turn out to be something simple. Why? because you understand the problem.
Yes, but I'd like there to be an NSF analog department with a pot of money to give to things like PyPy. 
Didn't even think of this! Will do!
[cmder](http://cmder.net/) is a nice and easy way to get something that is not awful on Windows. It is a package with nice configurations from the get-go, containing ConEmu, Clink and MSysGit. Be sure to get the version that contains MSysGit!
Have you tried Flask? If so, what's your thoughts on it?
Someone just posted this the other day: https://www.reddit.com/r/Python/comments/3soovw/top_6_sites_for_finding_a_remote_python_job/
It's not, necessarily, I don't prefer it personally :P That said, it's still a valid language that can be enjoyable to program with, and it has its advantages over Python (don't ask me what they are, I don't wanna)
I don't think that PyPy.js' author's concern is so much about the RAM footprint as it is the responsiveness. If you have to download a 5 MB Javascript package every time you load a webpage, and then initialize the environment, you're going to start to have some serious delays that don't work for the majority of websites. However, SPAs or "big" programs like games in browsers would work with it.
I appreciate it. I am definitely not a windows dev, but I have been wanting to do a cross platform game for a while and have been dreading setting up a windows dev environment.
the only problem is there are so many PHP vulnerabilities
[CGI](https://docs.python.org/2/library/cgi.html) is one simple way.
just use jinja for html template. theres no reason to even use php for that. 
I finally got the command syntax correct! Wait...I need to have escalated privs? Ok, fine sudo !... oh yeah no sudo. Where is cmd.exe? Oh there it is. Ok, right click, run as admin... Select text.. Oh yeah, gotta "mark" first... screw this interface, I'll just SSH... No cygwin? Every.Single.Time. 
Regarding every single request you do including hubs like school sites that pass authorization flow through several different pages (blackboard, internal sections of the page like finances, etc)? It's 100% a complete waste of your time for a simple script compared to right clicking in firefox and inspecting the element, getting a unique css selector and putting it in selenium and having everything you want done in five minutes. Do you also use a linux distro as a personal desktop OS and pretend it's flawless? 
Imagine a world where all of those terminals could be combined into one. Imagine a world where you could vim in this new environment. Imagine a world that has progressed 30 years! Imagine PyCharm. :P
This is a great list, one thing I'd add is that Anaconda also lets you link against different linear algebra libraries quite easily. If you have the paid version of Anaconda (which is free for academics, which are a huge population of Anaconda users), then you can seamlessly have your numpy/scikit-learn/etc linked against the Math Kernel Library from intel.
Do you have a CPU bound or I/O bound issue? If you can reply to this question, you can choose asyncio or not.
Thanks for explaining why I was wrong like a normal person, rather than just throwing insults. 
Which is why it was changed to that in Python 3
For sure. One thing Anaconda might consider is packaging a version of Maximus' [Conemu](https://conemu.github.io/), which is a lifesaver for commandline work in windows. It basically replaces the useless cmd.exe with something quite a bit more powerful, and extensible.
I get the sense you've not used vim much. &gt; Imagine a world where all of those terminals could be combined into one. Why would I want that? If I really wanted all the terminals combined, I could use Tmux or screen, but with a tiling window manager most of my windows are 2 key presses away, and whichever windows I want visible at any time are visible, and are easily rearranged with a few key presses. &gt; Imagine a world where you could vim in this new environment. I can edit 3-4 times as fast in Vim as in most other editors. I understand that there's a mode where you can install vim under PyCharm; I've yet to play with it, but the screenshots I've seen suggest that it's a bit of a hack. &gt; Imagine a world that has progressed 30 years! The Vim landscape is evolving constantly; Vim and most the plugins I use all have commits on github within the last week; this is not old dead software. I doubt the monthly PyCharm development man-hours amount to a tenth of the ongoing Vim ecosystem development man-hours. Don't get me wrong, I have a lot of respect for PyCharm; it provides a powerful development environment that even a relative beginner can use to good effect, and I believe it's a great force for good in the Python ecosystem. But I suspect that you don't really have a sense for what vim/shell is like in the hands of someone with a moderate level of expertise.
&gt; Why would I want that? If I really wanted all the terminals combined I meant realtime lint, code stepping, etc, all in your text. &gt; But I suspect that you don't really have a sense for what vim/shell is like in the hands of someone with a moderate level of expertise. I do. I'm not moderate level, but I know a few developers that are at work. Zero of them use vim for an IDE. They all use it for text editing, "lighting fast" of course, but none use it for debugging, error checking, etc. They say "why would I do that in vim?".
Spyder
Does the user executing the script through the scheduler have the right credentials? Do you hav3 all the paths setup correctly? I normally create a bat file which resolves all the path and environment variables issues... Test this bat standalone (being kicked off from a random directory)... Schedule it and kick off the scheduled job manually first... 
I have been looking at using it to make writing curses apps easier and have written some web scrapers using it i currently use my asyncio inotify bindings to run unit tests and doc tests on file save (icheck, bindings and links here: https://pypi.python.org/pypi/butter/) while there are blocking versions, the yield from/await makes it a little more explicit and i use the awaits as implicit locks on data structures in some of my code (as this is cooperative multitasking, you only are 'off cpu' when you yield control of the cpu) removing some explicit locks from my code
I've recently started to see one huge problem for people, that have started programming web applications with PHP. Since php code is written inside the html, which will be run through to generate the end-html to send as a response to the request, then the people who start with this *idea* of how this works, will struggle later on understanding the difference of backend and front-end part of the code. When I started to explain how one sends an ajax request from javascript in front-end to backend code to be run, then he did not understand at all how to do this. In python/java/etc, this would not become an issue, since the front-end and backend code is separated and all the requests/responses are clearly understandable via routing and specific functions. Why this is so problematic in my perspective, is that so many people start developing web applications in PHP and hence take a very wrong idea of how requests really work. Thats my 2 cents on the issue with PHP.
The simplest example is having a time.sleep(x) nonblocking
Yep, that's exactly how I found out about it, down to the letter. Now it's running on a couple of my old lab's computers and the others start warming up to it as well. Spyder being integrated helps a lot.
Hrm. I load, process, store data all the time. All three steps are disk IO, or CPU bound. I often wonder how I can speed things up in this context. edit: details... I have arrays of data stored on disk (usually in hdf5 format). Often I have multiple, similar data sets. I usually want to perform the same operation to each data set. So my normal processing flow looks something like: for each data set, load into memory, do some process (i.e.: filter for a frequency), and write result back to disk. The reading/writing to disk is IO bound. The filtering is usually CPU bound. I've never bothered to try to multithread this, but each data set is independent, so I theoretically could. Is there any advantage to using async/await here?
Okay, explain to me a use case: most commonly you want time.sleep() to be used to halt a program or a thread for a while, right? If it's non-blocking, it doesn't halt the program or thread. So what purpose does it serve?
welcome to the future. There is pygame cffi which is exactly that - a rewrite of pygame in pure python/cffi bindings to C.
There is the named group which is not in regex101, as far as I know
Thanks for the TQDM suggestion, I like it. I tried to use it if I iterate over a pandas dataframe (df.iterrows()), but then it doesn't show the ETA time as it doesn't know the length of the dataset. Any suggestions for that? from tdqm import * import pandas as pd df = pd.DataFrame(range(10000)) for index, row in tqdm(df.iterrows()): time.sleep(0.1) 
If it is any sort of large, well-established website it will likely have a license somewhere explaining what the terms of use of the data is. Further, it depends on the country. In the U.S., [facts are not copyrightable](http://www.dmlp.org/legal-guide/works-not-covered-copyright#facts). However, IANAL and I don't know enough specifics about the situation to know whether your particular case is only copying facts or wherever there is an creativity involved in the scores.
CPU Bound jobs won't gain any benefit from async/await. IO Bound jobs will gain (possibly*) benefit from async/await. &gt; All three steps are disk IO, or CPU bound. That's like answering "Are you male or female?" with "yes". Everything is IO bound or CPU bound (in the broadest sense). The trick is knowing which, and to respond to your edit, does the total job spend most of it's time doing IO or filtering? To be honest I expect the easiest way of speeding things up would be running multiple processes, one per data set. * The reason I say "possibly" is that disk IO isn't like network IO. With disks the reason you're waiting is because the head needs to move on the disk, the platter needs to rotate to the right point, or in the case of SSDs it takes time to activate the right bank. The disk can't go off and grab something else while it's waiting. There's only one (set of) heads, so there's no opportunity for concurrency. Disks being accessed over a network, or in RAIDs.... there could be opportunities.
If your friend is learning Python from a science/data/stats perspective, we set up [DataJoy](https://www.getdatajoy.com) for exactly this use case!
I never called it a gotcha. But it is a real "wat", because the language suddenly behaves inconsistently to how it normally behaves (or how any other language behaves). You could expect that x is the exception or that x remains being 5, but you could never expect that x is deleted. x being the exception would be perfectly fine. You can have a conditional that assigns to a variable, and then your variable might be what it was, or a completely different thing, depending on whether the conditional triggered or not. That would be 100% within user expectations, and useful. x being 5 would make no sense in the context of how scoping works in python, but IMO it would be better if they were scoped. That's how it works in all other languages.
I feel like Pypy lacks the attention from mainstream Python community and funding , which makes it is left behind CPython. I don't think it is reasonable , JIT for a script language like Python is important for its longterm development , like v8 to JavaScript.Why the whole Python community don't pay more attention to Pypy? To be honest , JIT is costy and needs a lot of money and talents. I really worry about the future of Pypy.
&gt; For a complete reference, see the official [re module documentation](https://docs.python.org/2/library/re.html).
What about a Python Notebook, like one hosted at [jupyter](https://try.jupyter.org/)?
Is there a soure code somewhere we can see ? A bug tracker to request feature ?
&gt; Don't use it in production http://i.imgur.com/JaYcxvz.jpg
My theory is that people who care about performance aren't using python because it is slow, so python users don't care about performance. 
This is the modified code: http://pastebin.com/0VunXLKs I receive this error: Traceback (most recent call last): File "spotifysearch.py", line 19, in &lt;module&gt; for i, a, t in enumerate(results['tracks']['artist']['items']): KeyError: 'artist' So I assumed it was in issue with me calling objects from the JSON file. If you would like to see the JSON file, just use the normal program and add a "print results" before the for statement.
From what? 3.4, or are we talking 2.7?
Never mind, then! :)
Fight me IRL 
https://squadedit.com/ has built in ftp so if you could connect to a server, you could run the python code from there.
I made this a few years ago now, it's great to hear people still find it useful. I don't do much page modelling nowadays, but it's still my goto tool when I do. Edit: It would be seeing more active development, but its currently taking months to get a mozilla editor review, so it's not really worth it unfortunately.
The [performance improvements](http://slott-softwarearchitect.blogspot.de/2015/09/python-35-and-upgrade-strategy.html) are interesting as well. 
Update, I got it to call artists, but the issue is that the actual name of the artist is within a dict with the name, 'name', so how do I actually use this, because it tells me invalid syntax when I try to print v[0{'name'] which is what I assumed I needed? Updated code: http://pastebin.com/wpFADzVU
Similar to codeshare but with the possibility to run code: - https://codebunk.com/ - https://coderpad.io/
I actually think its novel, I wasn't slagging it. Just pointing out the obvious as a PSA. 
For what it's worth, I came to the comments to say the same thing. 
Have you seen subreddit = '/r/%(skill)spython' % {'skill':'learn'} yet?
haven't seen that one yet. Is that for all versions?
What's PySide? The README is not descriptive.
&gt; PySide https://en.wikipedia.org/wiki/PySide
Thanks!
I've been bouncing between tqdm and ipy-progressbar but looking for an alternative that supports iPython/Jupyter a bit better. Any recommendations? If I don't print debug info, tqdm works fine, but every time I call a print statement it leaves the last iteration visible, appends the printed statement, and then appends the updating progress bar. ipy-progressbar is aesthetically better, but for some reason causes a huge amount of CPU overhead on my Macbook Pro with large iterators.
Can we please rename it like PySide4 or PySide5 to be consistent with Qt4 and Qt5?
I am the author of the project. Please feel free to comment on it.
All those changes look good; I just want my print statement back.
&gt; Nobody in Python 3.5 should be using mypy Can you elaborate? mypy is fully PEP 484 (type hinting) compliant and can be used as a linter. That's what OP asked about.
Thanks for the great explanation.
&gt; Is it compatible with Python 3.5 yet? I tried to install it a few weeks ago, but during installation it said it supports at max 3.4 There were no breaking changes in 3.5 and it should work perfectly fine as far as I know. I wonder if it was just a soft limit.
Just pick a language and start... python is just the easiest to get going compared to all the rest. Also, its not constrained in any way - in the sense that there is nothing that it can't do, except in-browser scripting ... only Javascript can do that. PHP is only used for the web... and Ruby is mostly used with Rails for web development. Python can be used for anything - webserver, native applications, guis (wxpython, tkinter, etc), distributed databases, regular scripting, and even browser scripting through the skulpt in browser cross compiler. However, if you already have a goal application in mind, like building a web application, it might be easier in RubyOnRails or PHP. Python can definitely do it, but it will take a wee bit longer (there is Django, Flask, and lots more in python for web applications). RubyOnRails and PHP were built for the web and have a larger web specific community... so its a little easier there. But then, they are difficult to use for anything else. Btw... java and javascript have nothing to do with each other. In fact, javascript is more similar to python than to java. 
Never had to use finally and personally only compare classes if i know i wrote the appropriate __lt__/__eq__ methods, so never had a problem there, but the other things looks nice. The speed i gain from the print statement still keeps me in python2.7
I tried to install via pip with the command &gt; pip install pyside and received this message: &gt; only these python versions are supported: [(2, 6), (2, 7), (3, 2), (3, 3), (3, 4)]
Yea this would be really nice. It's unbelievably confusing with all the different versions being muddled up.
I had the same reaction. Didn't even bother messing with it due to the $250/year offline fee or being forced to make my data public. You can get it up and running ipython/jupyter here: https://plot.ly/python/offline/
Thanks! ```iplot([{"x": [1, 2, 3], "y": [3, 1, 6]}])``` So JavaScript-y :(
Yup. The backend is JavaScript (they actually open-sourced plotly.js and the Python/R packages that hit the JS API). Still, it is a heck of a lot easier to get up and running with plot.ly than it is with matplotlib, even if it isn't overly pythonic. 
 from __past__ import print_statement I would laugh, then cry.
If you're taking about execution time you are worrying way too much about nanoseconds. If you're taking about development time, you're worrying way too much about the fractions of a second it will take for you to type a set of parenthesis. I don't see how it could be any faster in practice.
&gt; it is a heck of a lot easier to get up and running with plot.ly than it is with matplotlib Not sure if I agree with that based on what I've seen, but that may change once I actually play with it. That said, I'm not a huge fan of Matplotlib's API either. I get that they want to maintain API parity with the JavaScript interface, but I do wish they at least had a Pythonic front-end. 
&gt; Anyway, what makes this website "Python"? Isn't it just a regex tester? It's for the Python flavour of regular expressions and it's written in flask.
The bindings implement duck typing pretty well, so any PyQt object that is expecting a QString will accept a python string. Conversely, any python function expecting a string will normally handle a QString. The same is true for a lot of other basic types. My general rule of thumb has been: use python types where possible and reasonable (i.e.: where performance is not an issue). This isn't always possible as Qt has a lot of types that python does not have - so there's nothing to duck type into. Qt has excellent image handling classes. But while there's no direct python equivalent for QColor, Qt provides a bunch of ways to extract the type you need. For instance: from PyQt4 import QtGui c = QtGui.QColor('red') c.getRgb() # (255, 0, 0, 255) 
This is sampling of a social distribution.
Regarding the javascripty-ness and the get up and running timing, check out pygal. It's svg plotting, interactive graphs, and very nice. Super basic graphs, plot.ly is far more advanced, so is Matplotlib, but for 99.99% of graphs that you're going to make, Pygal is super simple. 
The API is a bit more modern and streamlined, too. PyQt supports older, deprecated Qt API.
`super` with a class name is also fragile, and can break with class decorators and such. See http://stackoverflow.com/a/19609168/1763356. IMHO this post *under*sells Python 3, but until the moronic "I can't be bothered to type two parentheses every 50 lines" argument goes away I can't really be bothered entertaining the argument anyway.
I'm sorry to say this but **this project is really not ready for the outside world**! I went through the whole code base and it's riddled bad practices. That said, I'm not even sure if it has any right to exist as it does nothing better than *scrapyd*.
This is fantastic.
no reason really, i've used both and d3. Honestly d3's great because of it's extensive gallery
He/She may need to work on 3.5 as part of their work, also 3.5 has added quite a few cool things into Python that the person may want to use. Admitidly I use 3.4 still but 3.5 is tempting.
https://plot.ly/python/offline/ &gt; Instead of saving the graphs to a server, your data and graphs will remain inside your IPython notebook. When your ready to share, you can just publish them to the web with an online Plotly account or to your company's internal Plotly Enterprise. Hmmm. Does anybody know if that's a requirement for sharing graphs or what the deal is there?
Does a tool/script exist to port pre-existing PyQt to PySide?
Awesome. Thank you so much for you feedback. Could you please elaborate on what do you think seems to be lacking and bad practices that you noticed? 
I don't know, why don't you tell us? ;)
Final update, I fixed it, it turns out I had to put each layer of the list into a variable and call it from that till I got to the needed value. The changes are in the link provided on my GitHub.
You used to be required to buy an offline license or publicly publish your data, but that requirement no longer exists. You are able to keep call of you data locally/private (as it should be) 
+1
I tried converting my PySide project to PyQt in order to use Qt5. PyQt's API is much stricter than PySide's: You can't pass integer values when enums are expected, C++ methods with multiple default values won't accept parameter lists that only offer values for some of the defaulted parameters, and the error messages for overloaded methods not matched are hard to make sense of.
Thanks!
&gt; The speed i gain from the print statement still keeps me in python2.7 https://www.youtube.com/watch?v=ztVMib1T4T4
PyQt ties its releases to releases of Qt and uses Qt version numbers so that's why it versions like that. I rather like PySide releasing on its own schedule/having its own version number so it's more free to make bugfix releases. Something like `PySide5 2.2.3` or whatever would cause more confusion IMO. Though I do agree that maybe going back to using the pip name `PySide` would be better but there are a lot of people who want to stay on Qt4 for various reasons and switching the main PIP package would be painful for those people.
Kivy is another great open source alternative for those interested 
&gt; I'm just talking about the major version. What if PySide wants to make an API change that's big enough to warrant a major version change, and there's no Qt6? Though on this point I think my opinion has changed on calling it `PySide2` in the package name as it would be setting that major version in stone too - and the Qt major version would be the one that makes sense to be in the package name. And I guess `PySide5 2.0.0` isn't that bad. Also on my idea for going back to `PySide`, It would make the multi-qt-binding modules like one Jupyter QtConsole uses easier to update to the Qt5 PySide if it had a different package name and didn't go back to just `PySide` &gt; &gt; switching the main PIP package would be painful for those people. &gt; They're doing that anyways. Sorry my wording was confusing. What I meant was using the pip package `pyside` for Qt5. If anyone has thoughts on this, someone opened up a GitHub issue: https://github.com/PySide/pyside2/issues/26 Would be helpful for more perspective as I believe nobody knew at the time of the name change that this numbering was controversial - and we're still trying to inch this towards 100% tests passing (80% now :D ) so I think now might be the best time to bring it up with the maintainer.
Upgrade your auto complete :P in the middle of typing `print` I can tab and it will finish the word, create the parenthesis and put my cursor in between them. So the difference between 2 and 3 for me is effectively nil
You can do your horrible hack with `sys`: import sys class FooManager(object): def __init__(self, name): self.name = name def __enter__(self): self.module = sys.modules[self.name] self.old_names = dir(self.module) def __exit__(self, exc_type, exc_value, traceback): new_names = [n for n in dir(self.module) if n not in self.old_names] for name in new_names: print('{}={}'.format(name, getattr(self.module, name))) Then: &gt;&gt;&gt; from foo import FooManager &gt;&gt;&gt; with FooManager(__name__): ... a = 4 ... b = True ... a=4 b=True u/sushibowl has a much more reasonable suggestion.
That's not that dirty, but it looks like it would only work for module-scoped variables? I'd like for something like this to work too: def test(): with manager(): a = 1 b = 2 
Yeah, PM me
You got me there, I can't think of anything outside of `inspect`
As a contributor, no, now is not the best time. Lets get 100% of tests passing before this is moved on. EDIT: I guess it is a matter of opinion, but I know Christian is not keen on dealing with that type of rename right now. It was a PITA to rename to PySide2 the first time. Doing it again doesn't make sense to me.
Also, please note that [the setup github](https://github.com/PySide/pyside2-setup) contains an explanation of what it is.
Serious question: why? Other than habit, why is a statement better than a function? I find the function much more flexible.
For Qt 4, yes. [*nix or Windows with Cygwin](https://github.com/prusnak/pysider).
&gt; Python 3 makes it easier to develop high quality software. Hmph. Do you know why I still don't use Python 3 for quick scripts? Because a lot of them involve processing all the files in a large codebase, and people aren't necessarily so careful with their encodings. Python 2 lets me manipulate characters like they're just strings of bytes - I simply don't worry about encodings. In Python 3, I have yet to come up with a reliable way to write a quick script without worrying about the encoding.
Thanks, here's the [link](http://pastebin.com/emR6bRd0)
The thing about coding is it quickly becomes impossible to remember everything you did. Or to even remember to check everything you think you did months later. Simply "knowing" you did / didn't do something is dangerously presumptive.
Just because I am a bit pedantic (and spent teh whole day working on a PyQt project...) It's "QList" and "QString" and PyQt also allows you to pass a Python string to a function that takes a QString in C++. (But yeah the myriad Qt types are not 100% convertible to and from "native" Python types.)
To reference the other thread, this is a good time to use Anaconda
I didn't want to go much deeper about it but if you want a full web application with everything and the kitchen sink thrown in ( like user authentication and management, cookie and session management, etc etc... all the things that you need in a dynamic web application) Ruby on Rails has much better support. There are numerous libraries and they are more mature. All of these are possible in django and flask... its just a little more difficult. You will have to fish more for libraries and struggle a fair bit in integrating them. At least, that was my experience 2 years ago... things might have gotten better though.
When you say it doesn't return anything, what is the output you get from these: where pip pip --version where python python --version Trying to install something: pip install pywinauto ..if that works, try and use the example on the pywinauto page (just to confirm if anything can / can not work)
Virtual environments are a great way of isolating things, some libraries don't work as well in virtualenvs in Windows, but still worth a go.
Read the article and you'll see that they did. ;)
 pip --version returns nothing, 3 instances of pip.exe show up in the task manager where python returns "C:\Python27\python.exe" python --version returns "Python 2.7.6" pip install pywinauto returns nothing starts up an instance of pip.exe meanwhile i have manually installed the package i need but I want to get pip working anyhow. easy_install doesen't work either btw (same behaviour)
I forgot - what does where pip return ? You can also try running pip like this: python -mpip + try and upgrade setuptools and pip this way: python -mpip install -U setuptools python -mpip install -U pip 
"and put my cursor inbetween them" What is that editor? I need it! That could save me minutes every week! No really what is it? I need a nice IDE because visual studio's intellisense is still not working properly after a year
hahahahaha! Yes its my biggest dislike in python 3 :P, at least for now that I am not used to python 3 its not only typing the parenthesis but also forgetting to type it, and going back to correct the misstake. I guess this is a non issue after cpl weeks of programming.
Well you've always been able to use the function anyway if you prefer it. In my work I use python for quick scripts constantly and print is invaluable for debugging. Making it a function when I'm forced to go to 3.x It's going to slow me down noticeably. Edit: function, not statement.
Pycharm does this. I believe there are others that do it as well, though I don't know what they are.
So your answer is... habit.
I get some impression of how it is relevant to Python from the comments, but for the sake of completeness, can someone explicit why this is relevant to /r/Python?
&gt;Oh no, criticism about Python 3, better downvote just to be sure! Nope, not me. &gt;* exception chaining is nice for debugging. It doesn't let me write better code. Good code is easily debuggable. *When* your code breaks, you have to be able to fix it easily. This is not cosmetic; it is extremely significant. You are wrong on this one. &gt;* asyncio can be easily achieved using greenlets, which are more powerful afaik. ~~"More easily" is really subjective.~~ But your point stands that it can be done about as well in both. Edit: derp, thought you said "more easily"... ignore the first sentence, sorry.
&gt; This is not cosmetic; it is extremely significant It seems minor to me in the grand scheme of things, but I can accept that for some it might be a game changer. There are also other important disadvantages I skipped over. For example, Python3 is slower (and even pypy3 is slower than pypy).
I don't use pypy, so I can't speak to that. However, performance on cPython for Python 3 is supposedly now on average the same as Python 2. There are, of course, edge cases where one is faster than the other. In my personal and anecdotal experience with cPython, there has been no scenario where the poor performance I was seeing was caused by the interpreter (as opposed to shitty code), so it's just not a big deal to me even if Py2.7 is a tiny bit faster. If you want real speed, you should be coding in C or Fortran anyway.
It sounds to me not like your problem couldn't be solved in Python 3, but perhaps that you couldn't figure out how to solve it in Python 3. I haven't dealt too much with it, but 'rb' and encode have worked alright for me on the occasions I needed them.
Also, size = int(resp.headers["Conent-Length"]) should be size = int(resp.headers["Content-Length"])
cosmetic? * the original `&lt;` design decision was horrible. i wouldn’t trust that thing at all in python2 * exception chaining is really fucking useful * `super(ClassName, self)` is fragile when used with class decorators and the stuff not mentioned also contains decidedly non-cosmetic changes, e.g. the better bytes-unicode separation. python 3’s mental model encourages you to actually get things right instead of bulldozing over encoding issues. and the cosmetic stuff is also nice. fucking `urllib2` finally gone, `True` and `False` aren’t veriables anymore but proper keywords, …
Well none of the improvements matter to me at all frankly. I was perfectly happy with 1.5 for my purposes, and upgrade primarily for security (or when a distro pushes one out I guess).
To be fair matplotlib is not very pythonic. Lots of objects get created implicitly, so it always feels like there is a layer of strange things going on below the surface. 
Nice! I don't use sublime, but I'm sure people will appreciate that.
I thought people knew too. There have already been 2 posts on this at least on this sub.
After spending a weekend monkeying around with curio and the async/await paradigm, I approve of any and all posts with the objective of clarifying and simplifying asynchronous programming. This was like finding a bottle of water in a blistering-hot desert. 
I assure you I am being earnest about this. It's going to be a pain in my ass for no benefit. My editor is usually something minimal on whatever machine I happen to be working on (emacs if I'm lucky) so no auto-parens for me. Considering that "(" requires a shift, what used to be a quick thumb to the space bar is now four keystrokes every single time, and given that I'm trying not to look at the keyboard that's going to include a lot of accidental ")" too. Yes, I can and will adapt, but I like most people don't like minor recurring inconveniences to be added to my life if they can be easily avoided.
why recurring? that’s a one-time *really minor* change of habit, no more. i don’t even get why it’s worth mentioning
It is a change of habit from one that I like to one that I don't because it requires more effort and causes more errors. If it doesn't bother you congratulations. I've been using print statements in my scripts for 15 years and I find them simple, elegant, and convenient. We will have to agree to disagree.
jedit
It was kinda funny when everyone was saying PySide was dead but multi-million companies are heavily using it at the same time. Just didn't have a reason for Qt5 support yet as Qt4 still worked/works perfectly fine for the needs.
first off these sorts of posts are better suited for /r/learnpython second when you want to type out code in this subreddit or also in /r/learnpython, put 4 spaces before the code in question - for example: x=[k for k in some_iterable] # this code is normal inline text # this code is formatted automatically with 4 spaces before each line x = [k for k in some_iterable] This makes it easier for people to separate your code from the questions you are asking
[removed]
if what you want to do is to plainly run an (arbitrary, for example R) script in your directory, subprocess is *the* pythonic way to do. it does not crash for me in this minimal example: myscript.R: x &lt;- 4 print(x) runner.py: import subprocess subprocess.check_call(['Rscript', 'myscript.R'], shell=False) execution: $ python3 runner.py [1] 42 i suggest you drill down on why the subprocess execution does not work, possibly using the above example as a reference (eg. simplify your example program until it equals the functional program above). sure there are ways of integrating R with Python, but you're in mixed-object-models land then. that can both yield wonderful results and cause splitting headaches; as long as you have trouble running subprocesses, i suggest you try to fix that first before you dive into that.
OK fair enough, although I'm sad when I hear people beat around the bush instead of say 'I like xyz because it looks nicer than matplotlib'. Anyway, mpl plot styles are improving, the defaults are changing, and it has a comparible data=dataframe API to seaborn for the next release.
Good.
Good.
Good.
Good.
Good.
[Good.](https://imgur.com/Ils1env)
Good.
Good.
Good.
Good.
Good.
&gt; I approve of any and all posts with the objective of clarifying and simplifying asynchronous programming. [David Beasley PyCon Brasil 2015](https://www.youtube.com/watch?v=lYe8W04ERnY) is great. I have no tried asyncio yet. Looks a little alien *async def*. Beasley Mad Max picture is a hint that it can be difficult. &amp;nbsp; Threading/Multiprocess have i used when needed, so will see how asyncio comes along,think it look overly complicated. 
Good. 
Good.
Good.
Good.
Good.
Good.
Good.
Good.
and a big downvote for being a blurb about people searching google for python more than php almost valueless in and of itself and then mentioning tiobe.
This kind of "data point" is idiocy in that it is entirely feel-good. Good luck chasing down stories like this while whatever the next *new hot thing* eats Python's lunch because everyone was too complacent patting themselves on the back. It would be more useful to compare to new and upcoming languages that provide something which Python does not yet have; but by all means let's compare Python to PHP *again*.
Good.
Good.
Good
It would be great to hear a comparison of Bokeh and plot.ly from someone who has tried both.
With extra yes.
If PHP falls in the middle of the NOC, and no one is there to hear it, does it throw an exception? Edit: I'll take the downvotes as a compliment of an exceptionally bad joke.
Good.
I'm right there with you on 'because it looks nicer'. Then again, anything I can do to drive people away from Excel and towards something like Python then I'm all for it. 
My question: Why would one expect that the speed of two operations in a low level language (like C) to be the same, relative to each other, in a high level language such as Python?
Good
here is what my condarc looks like: proxy_servers: https: yourserver:port for what is worth, i do not have "http://" or "https://" in front of the server. 
Good
I switched from PHP to Python as my preferred language when I was pretty green, in like 2003. Feeling smug.
Good.
I have solved this, but artist does not exist, spotify sends it in artists, that way it can account for multiple artists, so if I did a 1 instead of 0 it would give the second artist if it existed
Good.
 &lt;?php die('Good.'); ?&gt;
Good.
Good.
Good. 
Good.
Good job!
Do not use `?&gt;`, please.
Good.
Good.
Is.... is this news to anyone?
Bueno.
I agree! :) We have different design goals, I think. Fundamentally Plot.ly seems to be focusing on the "easily build some plots on the web" kind of thing. This is an area that is served by many other similar services, from Tableau Public to Many Eyes and even Office 365 and Google Sheets. Smaller startups include things like chart.io and whatnot. Plot.ly's core value proposition is offering a nice programming API to this system from many languages (especially Matlab, whose user community is quite underserved in this regard). Bokeh's goal is to be a fully open-sourced interactive visualization package, which library authors in the Python ecosystem can embed and extend. We also do want to serve end-users very well (hence the high-level charting, and eventually a hosted plot service), but we want to build that on top of an infrastructure of lower-level components that can be composed in more novel ways. So, trying to serve the role of a native D3, Tableau, and Shiny for Python, all in the open source. 
Good.
Good.
To let the OP do so, please go help the wxPython Phoenix project guys ;)
Good.
Good.
Good.
[ITT](http://i.imgur.com/4hc9acc.gifv)
Good.
Bad
Why is not closing it a thing in PHP style, anyway? I recently came back to PHP (unfortunately) after a years-long hiatus and was surprised when my IDE pointed this out as a style problem.
Forgot your ; Been a while it seems ;)
I'm having the pyperl flashbacks. 
Good.
Cat.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/bestof] [\/r\/Python's reaction to the fall of PHP](https://np.reddit.com/r/bestof/comments/3tcdqr/rpythons_reaction_to_the_fall_of_php/) - [/r/php] [How to lose respect for your language in 1 easy step.](https://np.reddit.com/r/PHP/comments/3tcs5d/how_to_lose_respect_for_your_language_in_1_easy/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Great!
... sigh, that error. Thanks.
Fuck sites like this.
because every PHP file thinks it lives inside an HTML template :) 
Maybe... [Stop Writing Classes, by Jack Diederich](https://www.youtube.com/watch?v=o9pEzgHorH0)?
Bra
Good
Good.
the second one.
Isn't that why you use `raw_input`? Honestly, if python is ever in a situation where a language 10x better comes around to eat its lunch, I'll be happy to welcome our new language X overlords. If you mean that python will get 10x worse over the years, I would be very sad. That's not really what happened to PHP though, from what I gather it's mostly gotten better over time. It just never got rid of the warts. 
good
Most likely. I really, really hope Python 2.7 dies quickly. It's the same situation we're in with Perl 5. 
Good.
If you go through my comment history you'll find that I've reviewed pieces of code in a quite detailed way. So, generally I'm happy to do this. But currently I really don't find the time. Here are a few things though: * There are basically no tests. I wonder why coverage is saying 26% ... * It should really be a Flask extension, and it's so close to be one. Instead it subclasses `Flask`. * The `Arachne` class ... * ... has a lot of methods that should be "private" (starting with an underscore). * ... is overriding `Flask.run` but does nothing. * `export_dir = cwd+'/'+path+folder` should use `os.path.join` instead of concatenation. * `cwd = os.getcwd()` is a [bad idea in web applications](https://code.google.com/p/modwsgi/wiki/ApplicationIssues#Application_Working_Directory). `os.path.dirname(__file__)` is a slightly better idea. * There isn't really a need for `SettingsException` even less in a separate module. * `if not os.path.exists(export_dir): ...` is true if `export_dir` is a file. * `ExportCSV` and `ExportJSON` are almost exactly the same ... DRY. * `Flask&gt;=0.10.1` ... pin *all* your dependencies/requirements. * Overall it takes away too much flexibility. What if I want to log to syslog (which is what you should be doing instead of logging to files)? What if I want to have settings in environment variables?
Oh I'm fully aware, it's simply good practice however
I actually wanted to ask a question about the data source, but I fear it'll get buried. Wouldn't "analyzing how often language tutorials are searched on Google" indicate both interest in a language as well as language complexity? Perhaps the introduction of asyncio or the async/await syntax has caused people to rush back to Google for answers? I mean Good. 
The problem is that 50% or more of the Python that is getting used is already running on 2.7. I start new stuff in Python3 but when I got a bit of freelance work recently, they wanted 2.7. Likewsse the job before was already running 2.7 and there was no reason to go through the hassle of making it work on Python 3 as it gave no real benefit. 
Good.
God that is horrible about the encryption. Unfortunately, a lot of people think you only have something to hide if you use encryption. Damn right I have shit to hide! My credit card number, banking info, etc. 
GOOD
Hey I knew I already saw something very similar somewhere! That's in the great talk "don't do this" from Richard Jones at the PyCon AU 2013: http://www.slideshare.net/mobile/r1chardj0n3s/dont-do-this-24000445 With a whole lot more of hacky goodies inside. 
Good.
I mean, the encryption doesn't bother me *too* much. Because the vast majority of stuff going over IRC is public anyway. Most of my channels have 200+ people in them. I would say at least half are logging every message sent. But for private messages and authentication? Yeah, those should be encrypted. Or done in such a way that you don't need encryption. You can do authentication that way, but not really private messages.
Good.
Good.
Good. 
Misses a major potential quality improvement... Type hints and annotations. Python has more problems as codebase gets larger. Function argument and return type annotations and static code checking will allow us to get rid of a large number of errors that get through to the runtime. With static type checking, Python overcomes one big disadvantage that it had vs Java. Also... this is optional. So it doesn't get int the way of small programs (until we decide we need it). 
Perl 6 just got a developers preview 15 years or so after it was announced. Python is *way* ahead.
Try this: {% for key, values in products.items() %} &lt;h4&gt;{{ _('%(name)s')|format(name=values['name']) }}&lt;/h4&gt; &lt;p&gt;{{ _('%(caption)s')|format(caption=values['caption']) }}&lt;/p&gt; {% endfor %} Never used babel, but since I read it uses jinjas i18n extension, I decided to check's [jinja's documentations instead](http://jinja.pocoo.org/docs/dev/templates/#i18n) Let me know if it works so I can post it on SO for those internet points :)
 while Php.rank &lt; Python.rank: print("Good.")
The problem is that it prints: ... Good. 6 ... Run it and see :\ 
Salty as fuck. 
Good.
What language doesn't require constant Googling? Or do I just have shitty memory?
well, babel picks it up as a valid string to translate but the PO/T file still just generates msgid "%(name)s" msgstr "" Which, is just a singular value to fill. I'm pretty okay with dumping babel if it works with just jinja but I havent been able to get that to work either
&gt; n is ever in a situation where a language 10x better comes around to eat its lunch, I'll Julia
It's not really any harder than threads. In many ways, it's easier. No locking necessary, no "zombie" coroutines. It *used* to be complicated before coroutines and Twisted's `@inlineCallbacks` came along, and *really* complicated when you only had `async_chat`… I recently started playing around with `asyncio` and `aiohttp` (I couldn't resist trying the new `async` and `await` keywords), and it's pretty straightforward in practice. The main problem I found was that too much documentation (tutorials, too) assumes you already know all about event loops and how the whole async thing works. If you don't, it can all appear more complicated that it really is. The only bits that might take a bit of work to get your head around are the server-/GUI app-like event-based execution model (although you can also use event loops like thread pools) and the whole "futures" business (which is no different to waiting on threads, really). I'd recommend looking at [Scrapy](http://scrapy.org). It's based on Twisted, not asyncio, but the principle is exactly the same, and Scrapy is a marvellous example of (a) what async networking is great for, and (b) exactly how to write async software. Whether asyncio or similar is a better choice than threads/multiprocessing is largely a question of how many IO streams it's useful to be able to handle simultaneously. I wrote an RSS aggregator based on Twisted, and I benchmarked it at 1800 feeds downloaded (not parsed) in 45 seconds, which is 40 feeds/second. Try managing that with threads and/or multiprocessing… (You can combine asynchronous IO with parsing in multiple threads/processes for maximum performance.)
&gt; no reason to go through the hassle of making it work on Python 3 as it gave no real benefit. Other than Python 2.7 being end of life'd. This is exactly how we end up in the PHP/Perl5 scenario. In 20 years someone is going to go "Why the fuck did they use Python 2.7 when 3.5 was just released".
Isn't PYPL flawed too though? It uses `Python tutorial` for instance to track the popularity for Python. If someone has been using Python for more than a couple months, I doubt they are going to be Googling that. Only newcomers to a language will Google `language tutorial`, so this only tells us about the increase and decrease in market share gains for a language, not its overall popularity. The way PYPL does it is certainly better than TIOBE, but not by much. It does not tell you how many developers Python retains in comparison to other languages, which I think is a more important metric.
Good.
Just prints 'Good ' forever, like it should. No 6 anywhere. Is that what you're referring to?
This is good for Python.
&lt;?= "Meh, I like PHP. It makes me a lots of money"; ?&gt;
Copy pasting my stackoverflow answer http://stackoverflow.com/a/33792518/3312882 , just in case someone comes looking... Lets do a slightly deeper dive here to find out the real reason behind this weirdness (if any). Lets create 3 methods and look at their python bytecode and runtimes... import dis def func1(x, y): return min(x, y) def func2(x, y): if x &lt; y: return x return y def func3(x, y): return x ^ ((y ^ x) &amp; -(x &gt; y)) print "*" * 80 dis.dis(func1) print "*" * 80 dis.dis(func2) print "*" * 80 dis.dis(func3) The output from this program is... ***************************************************** 4 0 LOAD_GLOBAL 0 (min) 3 LOAD_FAST 0 (x) 6 LOAD_FAST 1 (y) 9 CALL_FUNCTION 2 12 RETURN_VALUE ***************************************************** 7 0 LOAD_FAST 0 (x) 3 LOAD_FAST 1 (y) 6 COMPARE_OP 0 (&lt;) 9 POP_JUMP_IF_FALSE 16 8 12 LOAD_FAST 0 (x) 15 RETURN_VALUE 9 &gt;&gt; 16 LOAD_FAST 1 (y) 19 RETURN_VALUE ***************************************************** 12 0 LOAD_FAST 0 (x) 3 LOAD_FAST 1 (y) 6 LOAD_FAST 0 (x) 9 BINARY_XOR 10 LOAD_FAST 0 (x) 13 LOAD_FAST 1 (y) 16 COMPARE_OP 4 (&gt;) 19 UNARY_NEGATIVE 20 BINARY_AND 21 BINARY_XOR 22 RETURN_VALUE Here are the running times of each of these functions %timeit func1(4343,434234) 1000000 loops, best of 3: 282 ns per loop %timeit func2(23432, 3243424) 10000000 loops, best of 3: 137 ns per loop %timeit func3(928473, 943294) 1000000 loops, best of 3: 246 ns per loop func2 is the fastest because it has the least amount of work to do in the python interpreter. How?. Looking at the bytecode for func2, we see that in either case of `x &gt; y` or `x &lt; y`, the python interpreter will execute 6 instructions. func3 will execute 11 instructions (and is thus almost twice as slow as func2... in fact, its extremely close to 137.0 * 11 / 6 = 251 ns). func1 has just 5 python instructions, and by the logic in the previous 2 points, we might think that func1 should probably be the fastest. However, there is a `CALL_FUNCTION` in there... and function calls have a lot of overhead in Python (because it creates a new eval frame for the function call - that's the thing that we see in the python stacktrace - a stack of eval frames). More details : Because python is interpreted, each python bytecode instruction takes a lot longer than a single C/asm statement. In fact, you can take a look at the python interpreter source code to see that each instruction has an overhead of 30 or so C statements (this is from a very rough look at ceval.c python main interpreter loop). The `for (;;)` loop executes one python instruction per loop cycle (ignoring optimizations). https://github.com/python/cpython/blob/master/Python/ceval.c#L1221 So, with so much overhead for each instruction, there is no point in comparing 2 tiny C code snippets in python. One will take 34 and the other will take 32 cpu cycles, because the python interpreter adds 30 cycles overhead for each instruction. In OP's C module, if we loop inside the C function to do the comparison a million times, that loop will not have the python interpreter's overhead for each instruction. It will probably run 30 to 40 times faster. Tips for python optimization... Profile your code to find hotspots, refactor hot code into its own function (write tests before that to make sure refactor does not break stuff), use the `dis` module on new function, try to avoid function calls and modify your algorithm. Finally, if python speedup is not enough, reimplement your new function in C. ps : The explanation above is simplified to keep the answer within reasonable size. For example, not all python instructions take the same amount of time, and there are optimizations, so not every instruction has the same overhead... and lot more things. Please ignore such omissions for the sake of brevity.
&gt; Quakenet seems to believe that encryption is useless. The author was pretty clear in that they believe IRC over SSL is useless, not encryption in general.
wait, that's seriously how pypl is conducted? So, all I have to do is create a really really terribly designed language and then get a bunch of companies to use a product written with it, then stop supporting the product and it will become better than all languages out there. That's a flawed system
I've been working with PHP for almost 11 years now, I have not had a single problem with it really. I never understood all the hate towards PHP. I'm just getting into Python, I like it so far and I'm considering porting some of my web scripts.
Ah, I think I understand. You can handle it any way you see fit. For example, you can check for a nonzero return code and then raise an unhandled exception our directly call sys.exit you could also use the logging module to send you an email.
Manage your finances! Here's someone who applied some python to calculate out a daily budget: http://alexrecker.com/our-new-sid-meiers-civilization-inspired-budget/
I prefer PHP for most web stuff. Other web stuff I use NodeJS. I haven't found a framework in Python that matches Laravel as far as ease of use yet. I don't care about the language so much as I care about the frameworks.
5% down in 5 years! It's tanking!
5% of which Python number ? 5% of which PHP number ? This is pure Python fanboyism. % are relative. It's like saying 5% of 1000 is the same than 5% of 2000 : nonsense. PHP is here for at least one more decade. Enjoy it or not, it's a fact. So, in conclusion, irrelevant.
That's a smashing down ! PHP is doomed, Python will dominate and exterminate (Dalek voice here) all other languages in 3 months !
Python 3 compatible. Good.
&gt; from what I gather it's mostly gotten better over time. I use PHP a fair bit (and Python about the same), PHP has improved remarkably over the last few years and PHP7 looks like been a decent performance bump, it's tooling has also improved a great deal (composer is excellent, not excellent for PHP, simply excellent) and some of it's frameworks are very nice (Laravel is great for a lot of stuff as is Symfony). I'd still like to use Python on the web but frankly in the location I'm in and the market I'm in PHP is still the clear winner for a lot of stuff.
(author here) Thanks for the feedback. And yes, there's a lot of stellar improvements I had to painfully cut out, as the point of this article was to be brief rather than exhaustive. I did the latter approach with the following, which apparently some people found overwhelming: http://migrateup.com/whats-really-new-in-python-3/ Unfortunately, in this age where we all have too much to read and must prioritize, a person won't be able to benefit from an article if they don't read it. So I made today's article, which is shorter and more digestible, and (I hope) will benefit more people as a result.
As someone who spends a great deal of time in PHP land I think your comment is just about perfect. It's nice to see someone not go full /r/lolphp :).
Good.
Same, Laravel or Symfony for most web stuff, Python for build automation, server management, integration testing (Selenium) and just about *everything* else. 
MS basically liquidated Nokia. They have laid of 18,000 to 25,000 employees in the company. Its mostly just a brand name now and I think they're going to lose/layoff even more employees soon. That's a large reason why PySide had languished with little updates for so long, most of its developers had to scramble for new jobs or emigrate out of Finland. 
Sometimes I need to do something with lists and tuples and then I google what `zip` does because I always forget.
I don't use it too much, though lately I've needed it for a few class projects. Keeping track of certain things like addresses and finances is about all I use it for normally.
This is unfairly biased for php though. 
Even if you haven't ever had a problem, you can't deny it is lacking in the style, syntax, structure, and simplicity, and sexiness that python has.
Thanks for sharing your take on this. Do you think nuitka to obviate packaging issues, + Numba (JIT classes coming ), blaze,bokeh, dask and dynd (interesting type system) will keep python afloat in data science, or Is Julia poised to eventually replace it? R aint goin anywhere because CRAN is huge...python is more general purpose and thus more amenable to Julia's progress. I'm trying to figure out if I should invest in Julia now (Get ahead of the curve and python being a dead end?). It was a nogo untill I heard about the cash infusion...They said they will use it for also the core stats infrastructure, but I'm not sure how long it will be before a data science acolyte can be super productive without messing with pycall bridge etc
I believe if sites like this take off to an extreme, r/circlejerk (don't say their name too many times, they'll be summoned) will have a heyday trolling literally everyone who is attempting to make a point. It's a silly idea at its core, because there are people who are moderate towards both, but they aren't the people who are commenting here. These are people who either: a. Like Python more than Ruby, or b. Like Ruby more than Python. To quote /u/ilikebigsandwiches : "Fuck sites like this."
When I find myself in times of trouble, Guido van Rossum comes to me, Speaking words of wisdom, "Good"
It does.
I got a subscription to laracast.com (pretty inexpensive) and just went through a bunch of those videos. It demystified a lot of the more advanced stuff. There was an initial learning curve for me because the development process is a bit different than traditional PHP development cycle thanks to the artisan commands. Once I got those down, pumping out apps for our clients was pretty easy. But honestly, if you feel comfortable with django, just go with what works for you.
Django is great for large scale Web Apps, heck even Instagram uses it
I built a CLI to a local classifieds website.. just dinking around. [Here's the code](https://gist.github.com/blakev/a6bbe3b5a861d64c6e36) (written with 3.5). I think if people could create "interfaces" that made something they use often...would be a good starting point.
You would hope, but enterprise sometimes tends to [stick to near-DOS solutions, as long as it will keep working.](http://arstechnica.com/information-technology/2015/11/failed-windows-3-1-system-blamed-for-taking-out-paris-airport/)
Rust is cool and all, but a Python replacement it is not. IMHO something like Ceylon or Crystal is a much better bet there. Julia, too, but that's aimed too close to scientific applications to be a general replacement.
Python's getting taught widely in schools now, so there's little indication this is actually about business trends.
Downvote?... The r/Python community really enjoys the circlejerk. edit: Yes... the post was downvoted into negatives. Recovered into the positives now.
We've got a lot of people who really want to keep python's warts though.
Good.
Any from the US or just European? 
It's gonna die really, really, slowly, but that's ok (and expected). As long as people keep on migrating to 3 at a steady pace.
HA! I TOLD YOU LOGAN!!!! Good.
Good 
It is. I'm alluding to the fact that if you can replace the primary market-share webserver setups (NGinx and PHP-FPM or Apache) with a Python-based solution the market share might become relevant. As it stands, it's like comparing the income of a Poor Homeless Guy with Donald Trump's.
"cat" too? Damn, cold-blooded...
Don't know, but I'm downvoting it.
from circus import sense_of_humour
No newline?
asyncio?
Good. (sorry, couldn't help myself)
&gt; Do you think nuitka to obviate packaging issues What's wrong with Anaconda? I ask just out of curiosity. 
yep, you would have to write a compiler or two to make it reliable. 
 while not print('good'):pass
Good.
Php is from the devil. There I said it.
C99 standard: &gt; 5.1.2.2.1 Program startup &gt; The function called at program startup is named main. [...] It shall be defined with a return type of int and with no parameters [...] or with two parameters [...] or in some *other implementation-defined* manner So the C99 standard allows *void main()*, but using it makes the source code non portable. Also, didn't C99 add the implicit main return?
Read "Learning python the hard way" and every time you have a new little script to write just do it in python. You'll struggle but thats how learning works. (Especially in your 40's. It doesn't stick quite as quickly as it used to... not only because of age but you probably have a lot more real-life on your plate than before). Practice practice practice.
Try converting some of your smaller scripts to Python. Learn how to translate the data types, structures, and functions from your earlier work, even if you don't replace the script.
You are confusing releasing the GIL with pandas doing parallel threaded computation - which it is not doing.
because it was made in Python and django per [wikipedia](https://en.wikipedia.org/wiki/Plotly)
I'm starting a python project now, and all the libraries I use support python3. So I wanted to give it a go. Since I'm on OS X right now, I figured if I type brew install python3 I would be good to go, right? Well, somehow that completely broke my vim, as now plugins report that python support isn't enabled. Very good start for python3. I immediately ditched the idea of using it.
Anaconda is amazing, but doesn't let me distribute self contained executables. Nuitka does that, and more robustly It seems think than other options. 
What have you tried so far?
Kmean clustering can give some good value (sklearn.cluster import Kmean)
Testing, not enough time for it.
`groupby()` does not do anything in parallel. It just releases the GIL so that if something else wants to run at the same time, it can. But `groupby()` itself is still single-threaded. The example in your second link is running two different `groupby()` computations at the same time. Notice how the example they're comparing to is run inside a `for i in range(2)` loop, i.e. they're computing the same exact thing twice. They're comparing calling `groupby()` two times sequentially in one thread to calling `groupby()` once in each of two threads. But `groupby()` itself is not multi-threaded at all. You can only take advantage of this speedup if you have multiple calls to `groupby()` and you can arrange yourself for each of them to be called in a separate thread.
This is insane.
any reason you want to stick with Python 2.x? 
any Kivy apps which are on Mac Appstore, iOS Appstore and which also look good? 
Link to docs?
It's why unit tests exist.
thanks, i'll check dask out as well
Well if you need some inspiration, one of the guys I co-founded my current company with was one of the creators of perlmonks: http://www.perlmonks.org/?node=nate Our entire backend runs on python now. I'm sure once you get over the learning curve you will find python is a pretty awesome language. A tool I recommend checking out if you are doing sysadmin work with python is: http://www.fabfile.org/
They should be listed in the bookstore with PHP5.3, PHP5.4, Perl 5.18 and Windows XP books.
&gt;Using hashrefs, arrrefs, splits, joins, etc. You know that Python has built-in hashes (`dict`, including literals written like `{'foo': 'bar', 1: 2}`) and can freely nest container types without clunky arrow syntax, yeah? Also `.split` and `.join` are methods on the built-in string type. Most of the "ways" you have in mind are right there - we just do explicit type conversions, consider regex a sledgehammer rather than a swiss army knife, and keep our syntax regular, simple and unambiguous (i.e., no DWIMmery).
Well, there's always the official documentation (which is usually pretty good) that you could use if you need info on some particular module...
I went perl -&gt; python, although i wasn't as deep into perl (or other languages, for that matter!) as you are. I personally just went through the official python tutorial, i felt it motivated python pretty well, along with reading and understanding the reasoning behind python's philosophy as contrasted with perl ("There is only one way to do it, and it's the right way"... see more with `import this` as another person mentioned). The nice thing about this is that there are far fewer gotchas than perl, so this direction is easier than the other! Keep in mind that even after you are proficient, it's more legwork to do a few things when writing little scripts (no backticks for shells, for example), but the result tends to be a lot more readable and maintainable (no backticks getting skimmed-over as single quotes, for example!).
As I said, no time. Time is the issue. 
See also: pyqtgraph if you need something fast, or interactive, or deal with large data sets.
I will use it to make my fish tank's climate controlled. And to make some simple games. But I am no where near good with Python yet. Currently I am following a tutorial series on YouTube and just learned about decorators.
As long as you provide any changes made to PySide, and have document on how to use the library (if you also changed it), you can make your app closed source
People have tried this in the past, and the consensus seemed to be, re-mapping the keywords wasn't very useful if the identifiers and documentation remained in the original language. You could use your local language for your own program's identifiers and documentation, but that just creates a bizarre impedance mismatch with the standard library and the vast majority of 3rd party libraries using English. tl;dr It becomes turtles all the way down.
&gt; I'm thinking about the language grammar and/or standard library components, not any user-defined functions The language grammar should be relatively easy. The standard library is exactly like a user-defined function, the language does not make any distinction between the two. So, if you want it translated, it cannot be automated: you have to rewrite all modules and function names, this is a fork, and you have to maintain it afterwards. This part is technically not that hard either, but an immense amount of work, both initially and for maintenance. Maybe someone could come up with ways to automate parts of it, but it would still have to be updated for each release, and each locale.
The post was a joke :D
if you finished LPTHW you should be able to make a simple app by yourself. just come up with something and then write it. it can be either a simple game (snake, tetris, mario), some utility app (youtube video downloader, ftp client) or web app (django?). reading too many books is pointless, you will learn the most by writing programs. the only books you should consider are ones like "The Clean Code" and framework-specific books like "Two Scoops of Django". Also, forget about python 2 unless you're going to work with some legacy code.
Since I could not find any information if there is a collision in number sequence where number is a primary key, so did it myself. In my use case I scrape data from various data sources where some ids are primary keys and some are urls or even a concatenation of several values that ensures uniqueness. These values are to long to be indexed, so I decided to convert all these values to sha1 and just in case decided to check if a primary key (most common case) does not have collision.
Larger range requires much larger free disk space :) Since I was checking that for database primary keys 10^8 is quite large primary key.
See [PEP-0011](https://www.python.org/dev/peps/pep-0011/): &gt; Microsoft has established a policy called product support lifecycle [1] . Each product's lifecycle has a mainstream support phase, where the product is generally commercially available, and an extended support phase, where paid support is still available, and certain bug fixes are released (in particular security fixes). &gt; &gt; CPython's Windows support now follows this lifecycle. A new feature release X.Y.0 will support all Windows releases whose extended support phase is not yet expired. Subsequent bug fix releases will support the same Windows releases as the original feature release (even if the extended support phase has ended). Microsoft's extended support phase for Windows XP ended on [2014-04-08](http://windows.microsoft.com/en-us/windows/lifecycle), which predates the release of Python 3.5.0 (2015-09-13), therefore Python 3.5 does not support XP. (You just barely got in under the wire on 3.4, as 3.4.0 was released on 2014-03-17.) 
If you think you'll ever find collisions in a 'proper' hash function like this, you are sorely mistaken.
Docs generation is still a WIP.
[removed]
With a little practice your pdb workflow can be quite fast. I've already got my project open in my editor. I can insert a pdb anywhere I want with just a few key presses. I switch to my pdb window with two keypresses. Yes, I do have to switch windows to add breakpoints sometimes, but that's a lot faster than anything you can do that involves touching a mouse. As for linting, with Syntastic I have that all nicely integrated into my workflow. My linter runs automatically on save and I can jump to the (highligted) locations of issues with a key press. I could make it run continually but find that distracting. Despite being old in origin, Vim with a few core plugins is a thoroughly modern editor. All the major innovations you see in other editors over the last few decades have all made their way into Vim in one form or another. In fact, there are integrated python debuggers available for Vim, I just happen not to feel a need for them. And, yeah, I do program for a living - backend web development in Django.
Fair enough, I used to work for a company that had to translate all documents into 2 (and sometimes more) languages, and the tools at that time were simply unavailable (or ridiculously expensive and still terrible) for maintaining synchronization between translated versions of edited documents. My hope for this idea was that there could be a standardization of not only commands but also a subset of common names, like "self", "_init_", the predefined exception classes, etc. But the most I think of it the more headaches would be produced by enforcing that level of standardization on a dynamic language. Perhaps translating the grammar would be the only thing actually feasible!
Now, I don't think and don't rely on probability, I know exactly, that there is no collision in number range from 0 to 10^8.
To add to /u/avinassh's comment, I **strongly** suggest you use Python 3.x instead. If not you'll be locking yourself into soon to be outdated language syntax and features. Python 3 support is now very well established and there's really no reason to stay with Python 2.7 unless it's due to a system constraint. 
If anyone wants to know why the year 2000 problem happened, this was it.
For a long time the combination of lack of library support and poorer performance made Python 3 a bad choice for most non-trivial projects and that set public opinion of Python 3. Python 3 library support has been pretty solid for a few years now, and the overall climate has recently turned in favor of Python 3, so I think most people are in fact starting new projects in Python 3 and making the transition where practical, but it's a slow process. There are still a small handful of important holdouts that don't yet support Python 3 (the lack of Fabric support for Python 3 alone is probably responsible for a large fraction of the continuing Python 2 use), so the deprecation process is very slow!
How often do you have any reason at all to use `input`? Other than in python tutorials, I've never seen it used in actual live code. If you need user input and you're writing a web-app, you get it via a form; If you're writing a gui app you take the input form a gui widget; If you're writing a shell script you take the input from the command line or via file objects; and if you're writing an interactive console program you're going to use the `curses` library which has its own input methods. `input` is a toy function used in tutorials and there's really no good reason to make it more secure.
You might consider the 2nd edition of the Python Cookbook: http://www.amazon.com/dp/0596007973/ In fact, the main networking chapter appears to be mostly readable online, so you can try before you buy. Another option would be to use a more modern book, and translate all the Python 3 examples into Python 2 versions as you go along, by recreating the code yourself, and debugging anything that does not work. This is a lot of effort, but has the advantage of teaching you a great deal; if you can see it through to the end, you will become extremely well versed in Python 2. For anything specific to asyncio, you could substitute [Trollius](https://pypi.python.org/pypi/trollius), though the recent await/async syntax in 3.5 is not likely to be translatable, as well as (I believe) anything related to "yield from". Finally, I will join the chorus encouraging you to consider whether you truly want to stick with 2.7 at this late point. However, you know better than any of us what your needs and situation are, so I wish you the best of luck regardless of what you decide.
That's cool, thanks! I added a semaphore to restrict downloads to 10 but otherwise it executed perfectly. Thanks again! import asyncio from concurrent.futures import ProcessPoolExecutor import sys import time import aiohttp import feedparser TIMEOUT = 20 # seconds sem = asyncio.Semaphore(10) class ParseError(Exception): """Replacement exception for feedparser.""" def urls_from_stdin(): """Yield URLs from STDIN.""" for url in sys.stdin: url = url.strip() if url.startswith('http'): yield url def urls_from_csv(): """Yield URLs from STDIN.""" with open('feeds.csv', 'r') as feedlist: for url in feedlist: url = url.strip() if url.startswith('http'): yield url def parse_feed(xml, num): """Wrap `feedparser.parse()`. The objects it returns can contain unpickle-able exceptions. """ feed = feedparser.parse(xml) if feed.bozo: raise ParseError(str(feed.bozo_exception)) return feed async def fetch_feed(url, num): """Retrieve URL using asyncio, parse it in process pool.""" print('[{:3d}] Fetching {} ...'.format(num, url)) try: async with sem: r = await asyncio.wait_for(aiohttp.get(url), TIMEOUT) xml = await r.text() feed = await loop.run_in_executor(executor, parse_feed, xml, num) except Exception as err: print('[{:3d}] {!r}'.format(num, err)) return None else: print('[{:3d}] {:d} items in feed `{}`'.format( num, len(feed.get('entries', [])), feed.get('feed', {}).get('title'))) return feed async def main(): """Start downloads and wait for them to complete.""" start = time.time() futures = [] # for i, url in enumerate(urls_from_stdin()): for i, url in enumerate(urls_from_csv()): # Don't `await`. This returns a Future, which will be # populated with the result of the function call # when it's done. You can `await` the Future to # go synchronous. fut = asyncio.ensure_future(fetch_feed(url, i+1)) futures.append(fut) # All downloads are in flight and asynchronous. # Like with threads, we need to wait for the downloads to # complete, otherwise the program will simply exit. # OTOH, we have to wait using `asyncio`, so we don't # accidentally make the whole thing synchronous... print('[TOP] Waiting for downloads ...') await asyncio.wait(futures) print('[TOP] Shutting down executor ...') executor.shutdown() print('[TOP] {:d} feeds fetched in {:0.3f} seconds.'.format(i+1, time.time() - start)) if __name__ == '__main__': executor = ProcessPoolExecutor() loop = asyncio.get_event_loop() loop.run_until_complete(main()) 
You could maintain a 'wrapper', I suppose. For example (and I'm brainstorming here), create a module called `fr`which wraps the entire standard libs but into french. Some sort of API like: import fr # enable translation of builtins through some witchcraft import chaîne # imports wrapper around string from standard libs a = 'Bonjour le monde!' b = a.fractionnez(' ') # calls str.split() c = chaîne.metenmaj(a) # calls string.capwords() imprimez(a, b, c) # calls print() print(a, b, c) # still works - we didn't delete the english - just wrapped it I used [Microsoft's Language Portal](https://www.microsoft.com/language/en-us/Search.aspx?sString=string&amp;langID=fr-fr) for my translations. Sorry if this offends anyone - mon français est insuffisante.
&gt; Those won't get translated without a great deal of work, and would be missing documentation. I think translating the grammar misses the whole point of why Python is great. I agree, and the default fallback would be exactly as it currently is: untranslated. I'm not suggesting that every piece of documentation and every module and function name be translated; just that there exists the ability to convert from one back to the other with minimal loss in program integrity. The purpose isn't to duplicate the language or ecosystem, but to lower the entry bar. Right now a prospective Chinese/Russian/Swahili programmer has to learn not only the Python language, but also the English interpretations to understand that language. If it was possible to consistently and automatically translate the commands and a subset of the modules/functions of the most popular packages to lower this bar of entry, many more would become engaged enough to take the time and overcome those two hurdles. The bulk of the ecosystem and detailed documentation would likely remain English, and therefore most would end up picking that up by default as they began solving more difficult and intricate problems. Wouldn't the Python ecosystem benefit from having an additional 100,000 or 500,000 active participants and programmers?
You can use the PyQt docs interchangeably most of the time. 
First, I don't think python's use in data science is going to fall anytime soon. Python is easy to learn (there are TONS of resources out there), it can be used as both a statistical language as well as a general scripting language so you kind of get a 2 for 1 deal when you how to code it, it has an every growing number of high quality libraries, and it has a lot of heavy weight corporate support (Google uses it extensively for example). That said, I think python with face some challenges. The division between 2.7 and 3.x is going to be more prominent as 2.7 inches towards end of life. Python also isn't the fastest of languages and is at a significant disadvantage when compared to C++ or even Java. I agree R isn't going anywhere (but I disagree with you on the idea that R isn't going anywhere simply because CRAN is huge). A lot of the packages on CRAN are crap/overlap/are poorly documented, and if you were going to use some of the more obscure packages you'd be an idiot to not validate them before pulling them into production. It can also be frustrating to have 10 different ways of doing things in R vs there generally being one way to do things in python. R is not a beautiful language by any stretch (though that may be part of why I enjoy it as much as I do), and R faces all of the same speed concerns as Python. You also have to realize that for 90% of tasks, R and Python are all you need. You can get a TB of RAM on a server, both language are relatively easy to perform parallel processing with, and a lot of the more popular libraries/packages are already written in C. That makes them generally 'fast enough', and if you are truly concerned with speed, R and Python are great for quickly prototyping and then once you've built your model, you can go back and implement it in pure C. Julia's strongest selling point is that you don't have to do that multi-step process of prototyping and then rewriting either the whole pipeline (or just the 'glue' sections between code already written in C). But Julia is still changing A LOT. Plenty of things aren't fully fleshed out, future improvements are likely to break backwards compatibility, and the library support is years behind both Python and R. There are also relatively few resources to learn Julia. There are a few Julia books in the pipeline (Actually reviewing one right now), but they are going to become obsolete relatively quickly due to the on-going changes to the key components of the language. I think the biggest issue that Julia will face is come 5-10 years, will it even matter? So many areas are moving towards distributed computing and something like Spark allows you to crunch massive amounts of data at relatively decent speeds. My take on Julia is that you should only mess with if it you actually want to learn it and have a genuine interest in the language and not because you think it's the 'next big thing'. I like playing around with it but it is way to unstable and lacking too many of the key features I'd need to integrate it into my day to day work, plus I'd end being forced to do all of the work myself since no one else I collaborate with regularly knows Julia. 
Thanks, I'm still new to all of this. I was trying to restrict the number of simultaneous downloads through aiohttp. Was I restricting more than just the number of aiohttp connections by doing that? 
I hear that, but Julia's benefits exceed just greater speed on in memory datsets, and if developed right, will encroach on both single node and distributed niche. First, there are the making of a probabilistic programming framework in Julia that using autodiff and the distributions package can provide a comparative advantage over current languages in general day to day inference. The macros could make this fast and expressive. Faster than Pymc and more expressive and general than stan. With this general inference and extensive optimization package, I don't think it would need to fill every single statistical test and niche before becoming more useful for most daily tasks. Second, it is developing a distributed infrastructure that I think can overtake spark. Its distributed computing primitives are getting better and will eventually have extensive linear algbera support. Third, It is getting streaming statistics that don't exist anywhere else- the SAS people who are working on out of memory but single node datasets will finally get something that can handle their stuff. Pycall and Cxx means you can interface easily with existing code. Last is deployment. Self contained binary executables are planned, there is a good shot it can compile to javascript using at some point using llvm web assembly backend. You would then be able to write rich client side reactive web apps without JS and deploy interactive reports to decision makers. No other common analytics language has this capability. Then there is the type system with eventual return types that can provide codebase safety. Also it just fun to code in..that means grad student will write new techniques in Julia. If things firm up, I think all this would pull users from other languages...or they risk losing a comparative advantage. What do you think about this argument? 
What's the benefit of this over, say Docker images?
I'm not really talking about people who know about the security flaws in input() and use it anyway. I'm talking about people who don't know about the security flaws, and may use input() in such a place where you're really not meant to. It's more important to be secure by default than to be (very slightly) more hostile to beginners by asking them to cast any input from a string to an int if they want to work with it as an int. An input function should *never* be able to execute code.
Hi, I am working on the bokeh charts currently and just wanted to provide some alternative approaches on the data side, so that it is easier to make use of the charts. See this notebook: http://nbviewer.ipython.org/github/rothnic/OpenFlights-Analysis/blob/master/OpenFlights.ipynb Warning, it is rather big, so it'll take a second to load.
&gt; Wouldn't the Python ecosystem benefit from having an additional 100,000 or 500,000 active participants and programmers? Not unless we understand what they write. Should I switch my reply to you to my native language so I can lower the bar of entry of meaningful communication? Should you be expected to know the language of anyone replying to you? I know my self-taught English sucks. I know *English* sucks. But for good or bad, it's the language of tech. Not learning at least to read technical docs in your area of interest is just going to bite you in the end. You'll end up with closed communities that can't learn from other closed communities. It's not like with books. I need Nietzshe to be translated into either English or Spanish to be able to gain something from his work, granted. But technology advances at such neck-breaking pace that if you wait for translations to be available, you're already late by years. Should we translate the command lines too? Heck, as someone that started to use computers when no OS came in anything but English... fuck, that was hard, but the effort paid off immensely. Heck, today I'm having problems with Linux because the error messages, translated into my native language SUCK! Not only they break the pattern I was used to see... the translations themselves leave LOTS to be desired. Example: git is difficult to use for a newbie, imagine trying to search only for an error message in a language that only a few percent speak. Now I need to translate it back to English in order to find something? In less words: your idea would cause too much fragmentation of knowledge. I hope my Broken English allowed me to express my opinion in an understandable (and hopefully not too rude) way. If that was not the case, I do apologize! Take care!
yes, there is `source` function argument that defaults to `None`. afterwards, in `query.py` if it's still `None` then it is converted to e.g. `0.0.0.0`, depending on other parameters. so I guess you need to use it like this: `results = dns.resolver.query('domain.org', 'MX', source='10.xx.yy.zz')`
Now have it create a `systemd` file and we'll be in business!
I don't want to be that guy, but it's an extremely bad idea to continue running Windows XP on an Internet-connected laptop. Security patches have long since been discontinued and there are published vulnerabilities that will never be resolved.
&gt; Due to the nature of plaintext and how images are encoded, uring this script produces a file about 900 times larger than the original image. Wow. So its a tool to convert KB into MB?
It's possible through a hack to do something like this. See this blog post that I wrote a while ago: http://aroberge.blogspot.ca/2015/10/from-experimental-import-somethingnew_14.html
I don't entirely understand why I cannot just convert the img data to base64, then use that? in css you can use `url(data:image/[format];base64,b64data);` This provided me a much smaller css file.
This didn't actually compare the data visualization tools. :-(
Hey did you ever get it working? This would be incredible. 
What happens when those programmers decide to release code to everyone else? Sure the symbols can be translated, but the rest of the community would not benefit from the fragmentation due to different languages. Whether for good or bad, English is the de facto standard method of communication in technology and the sciences.
Could you give me a reason why you would want pure css and not an image? The larger size is clearly a disadvantage. What would the advantages be?
Just a comment, comparing Python vs Scala Spark performance really depends on what you are doing so its not fair to say that performance will be comparable for all cases (article never mentions where it isn't). The first type of computation is applying arbitrary lambda functions. This takes a large performance hit for serialization to/from python plus that python is not as efficient as JVM. For example, when you create the postsRDD since that has python regex search etc. The second type of computation is when using SparkSQL. As long as you aren't using python UDFs, the python api is building a query which Spark will compile and execute in the JVM. This doesn't take a performance hit because the data stays in JVM, python is only responsible for passing the query to execute (vs above provide the definition of the function to compute in the python interpreter). This would be working with the Dataframe in the code blocks below the postsRDD definition.
I felt like doing it this way, that's literally my only reason for doing it this way. EDIT: I tend to just wrote code for fun. I've got a complex project or two that aren't really useful, but they're good resume builders and they're fun to do.
It's not that narrow. It's like posting an entire thread on how to redesign a subreddit with CSS. But just because the subreddit you are designing is /r/python doesn't mean it should be posted there. Same way it shouldn't be posted to /r/politics or /r/funny if those were the subreddits you were redesigning. I think it's a novel way to hide something, and certainly interesting, but it's just not the right place to make the submission.
Thank you =)
At the bottom, pandas is built on NumPy arrays. We also have an internal "block" structure which allows adjacent columns of the same data type to be consolidated into a single numpy array.
Heh that's funny. Got a link to some sample output?
And its rendered output: http://jsfiddle.net/gwah5mn3/
Pretty complicated for a third of a megabyte, eh? &lt;/sarcasm&gt;
While I agree that conda is the way to go, maybe I'm missing something, but isn't what you are asking about one of the primary purposes of pyenv. Or maybe I'm not sure what you mean by "create". See their [command reference](https://github.com/yyuu/pyenv/blob/master/COMMANDS.md#pyenv-install) It points to python-build, which is a separate, but associated project that installs [lots of different](https://github.com/yyuu/pyenv/tree/master/plugins/python-build/share/python-build) python versions. It can also install anaconda/miniconda and pypy. The thing I like about pyenv is that it doesn't require anything but bash to bootstrap your install. The thing that sucks about it compared to conda is that it will mostly be compiling from source, so you need all the dependencies, plus it takes some time. So pyenv manages these python installs, then also can change which python your current shell is using or a project uses via config files. Virtualenv I believe is more for when you already have python available on your system and you want a contained environment for a specific app to install dependencies into.
PyQt (and Qt in general) is an oft overlooked, but very awesome toolkit for a great many things. It's threading is good, networking is good, graphics are good... hell, the only thing that isn't going for it are: it's sometimes not very pythonic; and, the GPL licensing (where pyside helps nicely).
2.7 is in it's end of life right now, receives no new features, and will be completely unsupported by 2020. Personally this timetable is really fucking slow. But nobody asked me so what do I know?
So here's what I cam up with: def some_process(df): return df.groupby(['a','b']).size().unstack('b').fillna(0) Essentially you want pivot, but don't have unique indexes, so we just need to groupby, and then unstack. I highly recommend [Brandon Rhodes pandas tutorial](https://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjt3Ojri57JAhUBpB4KHfeIDxIQtwIIJTAC&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D5JnMutdy6Fw&amp;usg=AFQjCNEwlzqF5yt3Aze9jiHTVxjKiBtehA&amp;bvm=bv.108194040,d.eWE) as a great way to get an understanding of these sorts of things.
I just saw the code: @param source: bind to this IP address (defaults to machine default IP). @type source: IP address in dotted quad notation Thank you very much.
You're looking for a [cross-tabulation](http://pandas.pydata.org/pandas-docs/version/0.17.0/generated/pandas.crosstab.html): pd.crosstab(df['a'], df['b']) 
I believe you can run pyspark on PyPy now, which might improve performance by quite a bit (though not really addressing the serialization aspect). I agree though, performance is highly dependent on the workload. 
What is the `scanner.scan` output supposed to look like? The author shows a code example with a print statement, but didn't include the output. I can't really figure out what the point of the scanner was. 
No, but you can easily have scores or hundreds of connections (that's async's big advantage over threads/processes). You'd probably want some mechanism to prevent more than 10 connections to the same server at the same time, though.
This was one of those posts that made me do a double take. My first thought was "That title can't be right. That is perhaps one of the biggest wastes of time ever." I then opened it up and saw the title wasn't wrong. My initial horror was quickly broken by the hilarity of how stupid it is and how OP did it for the lawlz. Well played sir. You have my respect... or some strange variation of it converted to CSS.
Well, I'm glad someone got some enjoyment out of it =P
Can't you use hexadecimal notation to shave off some bytes? :) 
What's the gzipped size though?
It's 3 kilobytes larger, I'm laughing my ass off
O.K.
&gt; The spoiler is that is does nothing interesting. It is just the default behavior of the .Net regex engine that looks for all matches in the string instead of stopping after the first one (unless explicitly told not to). In .net the first match is always just match[0] That's the same in Python. This has nothing to do with this class. What this class does is building a group out of the internal AST to merge multiple regular expressions. Pretty sure in .NET you also need to manually build a group out of those. &gt; Since regex is a grammar it really wants to only match "one" thing per matching group, so doing something like this and actually getting 3 different Tom matches means an annoyingly complex regex, re-anchoring or look ahead That's completely wrong and if you read the article you would have seen that automatic anchoring without skipping ahead is the default in Python. Multiple matches have been possible forever with different interfaces including `finditer`.
I'm a C programmer, and I barely grasp the concept of Python's for loops. They make almost no sense to me. Thanks for the tip!
Worst series of answers ever
Ok so here is a quick introduction. Basic functionality is this : `for element in collection:` Which allows to iterate over the elements of a collection. Then range(N) returns a range object (ordered list) of integers from 0 to N-1 inclusive. So "`for i in range(N):`" is the equivalent of "`for (int i = 0; i &lt; N; i++)`" in C (c99). You should check the documentation for the range function as it can do more than what I explained and it can be useful.
Thanks, that actually really helped!
Like Bash?
You are confusing two packages, virtualenv (created by Ian Bicking, now maintained by PyPA) and venv (a package in the standard library since python 3.3), which do almost the same thing. Both are designed to provide an environment which contains python packages. However, how they implement this is quite different. Virtualenv hacks around how python's import system works, as before python 3.3 and PEP405, python had no native support for virtual environments (https://virtualenv.pypa.io/en/latest/development.html#status-and-license has a very short history of virtualenv and its predecessors). Venv is a module which creates the necessary file structure to work with PEP405 (and has support for customising how they are built). There was discussion about making virtualenv use venv when running on python 3.3+, but that doesn't appear to have gone anywhere. Note that venv only creates virtual environments with the version of python you invoke it with, so it's best to invoke it like: python -m venv ENVDIR However, there are a number of scripts/packages/projects which depend on virtualenv (as venv will not be backported to python 2), so virtualenv will still be used on python 3. Additionally, python 3.3 venv did not install pip in to the virtual environment, and issues with how some linux distros packaged it, so virtualenv is the better option. [@chrstphrhrt](https://www.reddit.com/r/Python/comments/3teu9o/create_py2_and_py3_environments_with_pyvenv/cx6071j) gives the command you want, but it's worth understanding why there are two packages.
Recently I've used it for two things: POS-tagging for intelligent iterative search query optimisation (by extracting nouns), and their Bayesian Classifier for text categorisation (in this case, determining the category of scene releases, ie. TV&gt;SD, Ebook&gt;Magazine, etc). Both were used in proper practical applications.
I got kinda frustrated typing those commands 😅. Feedback is very welcome!
Okay, cool thing. Really. But I sort of feel compelled to ask: [But why?](https://i.imgur.com/TnQRX6v.gif)
It's worth mentioning that you can still get updates until 2019 [with a simple trick](http://betanews.com/2014/05/26/how-to-continue-getting-free-security-updates-for-windows-xp-until-2019/) that might stop working at any point though.
Or you could just get a job where your colleagues were not selected for their ability to do language tricks and warble on about "interpreted languages". 
&gt; if you want to make your code run faster then using the threading package is really not a good idea. This depends on whether your code is CPU-bound or IO-bound, right? Don't Python threats release the GIL before they wait on network reads and stuff? Edit: Found [what I was looking for](https://wiki.python.org/moin/GlobalInterpreterLock): &gt; The GIL is controversial because it prevents multithreaded CPython programs from taking full advantage of multiprocessor systems in certain situations. Note that potentially blocking or long-running operations, such as I/O, image processing, and NumPy number crunching, happen _outside_ the GIL. Therefore it is only in multithreaded programs that spend a lot of time inside the GIL, interpreting CPython bytecode, that the GIL becomes a bottleneck.
I understand why they did it, but I find it unexpected that a list comprehension has its own scope whereas a for loop does not.
So, forgive my ignorance, but is there a reason you wouldn't use something like Puppet of Chef to do the same thing?
Silly enough to be fun, I love it. Next is javascript to render a base64 encode dynamically to CSS on the page! Or the classic image to HTML table - screw you people with JS and images disabled ;)!
You should submit this to matplotlib https://github.com/matplotlib/matplotlib/tree/master/lib/matplotlib/mpl-data/stylelib
It's good to see a universal hatred for interview questions like these in this thread. If I'm gonna interview you for a Python developer position, I don't even care if you know what Python is. Whether you know language X is the last thing on my mind, let alone if you can tell me from the top of your head what `zip` does. In 12 years of programming Python I've used `zip` perhaps 2 times, at most.
This is not something I use for production deploys. It is a one-liner I use when I start a new project on my dev machine and need a new hosts file and nginx config to serve static files. For instance, Flask does not serve static files. If I want the static files to be served at the same location as the web app, I need a virtual host to serve static files and send everything else to the Flask server. Then, need to toggle between `127.0.0.1 cafe.com` and cafe.com's actual IP to test the live changes? Again, just a one-liner to take down the hosts entry and config file. I found myself doing this frequently and it got annoying, so I wrote a script to make development easier! Puppet or Chef would be serious overkill.
Although I hate these kind of articles, I agree with that. The example uses camelcase. If an interviewee picked up on that and used camelcase too, even if it's horribly against python conventions, I'd be quite happy. When in Rome...
I was irritated less than half way in. Camel case variables, Hungarian notation, no os.walk, importing os inside a function, capital letter variables. Lots of PEP-8 violations. And what's with calling a variable lIn? Really? Ell, capital I and n. This is horrible code.
Well, have you tried running that? What happened? First of all, `=` is the assignment operator, not the equality operator. That's `==`. Second, you need to get your constant date into a form that you can compare to `today`. If you call `type(today)`, you will see that it is a `datetime.date` object. That means that you need to create another `datetime.date` object for your other date. Look at [the documentation](https://docs.python.org/3.6/library/datetime.html#date-objects) -- to do that, you need to call `datetime.date(...)`, with the year, month and day as arguments. The bare `2015-11-20` you currently have will be evaluated as the number 1984. You can actually compare a `datetime.date` object to a number and not get an error, but you will also not get the answer you expect (the comparison will always evaluate to `False`). Third, you need a colon after the condition in your `if` statement.
[This](http://imgur.com/tmSNrxY) is what I thought would work. I'm guessing that it is slightly more complicated.
good to know :)
oh, i use conda with pip and it normally works pretty well id say.
I am making a card game and want to print "Dealer takes a (whatever_card_it_is- the variable is take)" what is wrong with this? print ("Dealer takes a "+take) 
You're getting a syntax error because you're missing a colon.
&gt; In 12 years of programming Python I've used zip perhaps 2 times, at most. It varies depending on the kind of programming you do. I've personally used `zip` quite a few times. Other than being extremely useful for iterating over multiple things, it's also a neat trick for transposing lists of lists.
I did try this but I had thought that the data was the 21st and thus received my expected output. My apologies. Your explanation is is correct and will update my explanation to reflect yours. 
Thats what I thought as I was reading it as well. Really disappointed with codementor, I hope they hire someone to fix issues like this happening, because it seems to be a regular occurrence.
Question 2 was definitely indicative of this. Function name was underscore-spaced, while variable names are camel-cased in hungarian notation. Ay
Question 1 is pretty wrong since I believe 2.7... it compiles to pyc bytecode as everyone who has written python has seen. It is interpreted, but it still compiles. And as for "what is python" That's not a great answer. Python is a programming language/grammar/spec, and if someone came out with a compiler that compiled python code to machine instructions then that's valid. Python is just a language.
A comprehension is more analogous to being a separate inline function (like a lambda) so it follows that it should have its own scope. This is particularly true when considering the generator expression, since it mirrors a generator function that uses `yield` which wouldn't be possible if it was in the same scope as its enclosing scope. And in fact in Python 3 the list comprehension is really just a generator expression that's then fed to `list()`. 
He's assuming that your threat model is an adversary who can observe other people in the channel. I use SSL because it stops my ISP having plaintext access to everything I'm sending to the IRC server.
It works like that because it wouldn't be possible to assign to function scope variables inside for-loops if for-loops had their own scope. Static languages use declarations of variables to bypass this problem. Comprehensions don't allow statements to begin with so they don't have this problem so they can have their own scope to just encapsulate the loop variables. 
Seriously, I know in my code I'll initialize certain things as None and then expect them to become, say, strings later on. Not only would this not work with Hungarian notation, I think it's better because for example I've spotted logic bugs in my code from the "cannot concatenate str and nonetype" errors that popped out, but which would have been harder to track down if it just ran and gave me undesired output at the end.
There's a colon missing at the end of line 3. Also, `today` is not a string, it's a datetime object. I'd change it into a string, like this: import datetime today = str(datetime.date.today()) if today == '2015-11-20': print ('.....') Also, with questions like this, /r/learnpython is probably more up your alley.
I mean, who *doesn't* have Googling "do &lt;thing&gt; in &lt;programming language&gt;" as a decent chunk of their workflow? At work I sometimes have to code on computers without internet connections (privacy protections on the data we're looking at) and it cuts my productivity by so much. It also leads to crappier code because it amplifies the effect of "writing ugly code that works in a reasonable amount of time is better than constantly having to run back and forth to my desk to look up the right way to do twenty different things". Sometimes I go do things at my desk and then burn them to a CD and bring them back, but sometimes that's not efficient if it's something where I really need the data right there (either to test the code against, or because I'm staring at the data to try to figure out how to write the code in the first place).
I use zip (izip) all the time to iterate multiple iterables in parallel. 
ignore the fortunes by the way the content doesnt mean anything its the principle that matters aahahahahah
just european
/r/learnpython
That is exactly what I thought. If someone asks me to walk a directory in python I'm going to google. There is zero chance I could complete that question without access to the python docs.
the examples are not using standard Python. ever heard of PEP8?
Oh-my-zsh and probably other shell frameworks have Django support. I would advise switching to oh-my-zsh or prezto.
Welcome to the world of software engineering interviewing...
I'd love to do this and we are working on it. Apple has made it very difficult because the iOS Wifi scanning capabilities are in a private API and banned from the Apple Store. 
&gt; we use the os module for interacting with the operating system in a way that is cross platform. You could say sChildPath = sPath + '/' + sChild but that wouldn't work on windows Actually I think this does, at least in Python 3. I've never had a Windows user tell me my code was broken in this manner, so I assume it automatically handles it.
It's an OS that comes with it's own built in P2P network with a rather unique goal. We're working on making the OS more efficient for Internet usage and we're also working on making software more efficient for Flash storage. We're building a lot of the end user stuff in Python so anyone can join in. The main thing Python is used for is the network which is very efficient and fast enough to be used as an external storage device (even perhaps fast enough to be a bootable primary device) anywhere in the world, even faster than onboard storage devices, mainly in the form of Flash storage like SD cards and USB sticks. You don't need to know Internet sockets, how the Web works, how the Internet works or even understand ISP's to be a part of this project as it's not required to know. It's all done automatically and Python provides an end user front-end so people can write programs upon the Internet without any restrictions and without knowing a multiple of other languages.
That's amazing
Awww... Yeah I just read about it in the faq. I feel like this would really be a nitch market but... Have you considered making it a jailbreak app? If so (sadly, unlikely as it is), there are some great subs where you can ask the community for help / advice, like * /r/jailbreak * /r/jailbreakdevelopers But yeah... I definitely want to play around with this!
Many people teach out of a conviction to help people learn better. So, what you say isn't necessarily true, but I think this article is here simply for the sake of getting SEO hits since Python is a big search item these days for prospective programmers.
Jesus fucking Christ why can't people read the goddamn sidebar? This isn't the place for your goddamn homework.
Indeed, explain that you know the difference between js typing and python typing.
Does this example help? https://github.com/belangeo/pyo/blob/master/examples/utilities/02_midi_ctl_scan.py
"Strongly typed" is roughly equivalent to "This language has fewer wats."
Forward slash is a perfectly valid path separator on Windows. It's just not the canonical version you see when displaying a location.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Beautiful
I think I'm good. I installed pep8 and autopep8 so I've got an idea of what I should be doing. Thanks though!
Came here to say exactly that. I stopped reading at OS.listdir though
Was this inspired by this? https://www.indooratlas.com/
Yes, knowing what your code is doing is the key to figuring out whether and how much you'll be affected by the GIL. (and yes, it's mainly an issue for multi-threaded CPU-bound applications; IO-bound applications feel it much less, if at all compared to the normal overhead of the language)
For bonus points, question whether "strong" and "static" typing have useful definitions.
I was going to nitpick this too but I think the author covers it their first bulletpoint: &gt; be consistent with your naming conventions. If there is a naming convention evident in any sample code, stick to it So I let them off on that point. 
I've used it for text prediction. From a partial input, I could get an ordered list of the most likely matches (based on some corpus of training text).
I'm pretty sure that stock zsh does it if you turn completion on. Edit: Yeah, I think it might work with any script that uses argparse.
CPython is the main implementation of Python. Cython is an intermediate language for writing C extensions.
Cython isn't another implementation; it's another language.
Cool, thanks! 
OK. Thanks for letting me know!
This is a fairly good test, but I think it is important to make it clear that you're not going to deploy their code. We've interviewed some people who were excited to work on our production code but also felt that we could have easily stolen their work without compensating them. Now we make it clear that we've solved the problem and their actually working with 2 week stale code. 
Bad article. From my experience, the typical questions during an interview are: - traverse a tree - invert a linked list. - what does this regexp do. Honestly, I am mostly offended by this kind of quizzes. They are a waste of time, I've addressed them at every interview, and they are useless to understand how good one is at coding. Want to see if I can code? Go to github and get my repos. That's my code. If it's good for you, that's all you need. No, I won't solve your stupid interview problem. I'm tired of that. Give me the real problem and if you think I can solve it, I'll solve it. 
Thank you! Yes, I've been looking at that example. I've yet to find a good way to write to .mid-files using pyo, though.
Or you pay them if they solve your problem. Either way, make it real, and make it fair.
Its amazing how this can be voted up (so damn high) in the python subreddit. We have lost all sense of decency. Its the rubbish clickbait articles that get all the attention these days.
This is amazing work. Hats off to you guys.
That's where the web framework starts. If you wanted to replace WSGI as well, you'd be writing a web _server_.
`ResultProxy` maintains an actual DB API cursor, which means it's tied to DB connection and possibly some resource on the DB. I would try to move off of it as fast as possible. If you care about the ability to refer to columns through attributes, you can roll out a simple `__getattr__`-based wrapper for a row from `ResultProxy`. But at this point, I'd probably consider starting to define some ORM model classes.
Well I guess that's as good a reason as any :)
Yeah, it's not perfect by any stretch of the imagination, but it's a big enough pile of features that tend to work pretty well together, and cover enough areas, that it's remarkably handy. It even has decent documentation!
I like to think that's how _most_ development shops will hire when not shackled by HR/management. We just hired a guy that's never even touched python before, but he's got _decades_ of experience in the problem space. It'll take a few weeks for him to get up to speed, sure, but after that? We'll have ourselves a damn team mate. 
Happy cake day!!!!
FYI this can also be found by going to your user page, and, where it says "redditor for X years", hover over the "X years" part. In fact all dates are presented this way on reddit -- hover over them to see the actual date instead of the summarized "x units ago".
A strongly typed language is a language whose type has been passed down for generations!
Maybe you can still call them from Pythonista?
I can't disagree more strongly. Comments in code inevitably go out of date, and in my experience they're mostly used to explain decisions which should instead have been rethought.
Add "what is PEP8?" to the list, then see if this author can answer it.
Well, it's also fun to write incredibly stupid things and see Reddit's reaction to them
First, awesome work. Second, if you like automating configuration management like this I'd suggest working within a framework. It doesn't really matter which framework you choose - but Chef might be a good place to start as you can toy around with chef-solo (free) before moving to chef-server (centralized, pay for 25+ nodes... or not, it complains but doesn't stop you). On top of that since everyone has gone nuts with them over the last couple of years there are repos out there for lots of things, nginx included. EDIT: Just saw your other reply... I think I better see what your use case is now, and you're right - flopping chef down by itself probably isn't the answer. Now I don't know much about your workflow, but you might want to look into using Jenkins to trigger deploys to a test server when you push a commit to git.
I don't mind at all - I appreciate any help. I'm a complete rookie (a 3-day workshop experience level). https://github.com/kmaiya/Presidential_Web_Scrape/blob/master/presScrape.py
Also check out Biopython. It has loads of useful parsers for reading and writing FASTAs, VCFs, GFFs etc.. Oh, and here's a nice example of how to look for ORFs in all six frames of a nucleotide sequence using biopython: http://stackoverflow.com/questions/13114246/how-to-find-a-open-reading-frame-in-python?rq=1
I think the hard part of this isn't the scraping but extracting the information. What kind of information do you want? Like something more than chemical formulas?
By compound structure do u mean this like the actual structure.. Showing all the chain bonds? 
I want to start with Wikipedia because it looks easier compared to more technical sites like NIST or ChemSpider to learn something like this on (Wikipedia has consistent formatting and is all in HTML, first learn Wikipedia to hammer down the idea, later more specialized for the field and do compound structures etc.) For now, I want to extract identifiers and properties. Ex: https://en.wikipedia.org/wiki/Methanol Notice how off to the right, there is a table, I want to pull all the names, and some of the properties, like acidity to add to the larger curation I have been working on for the past 6 months.
compound structures are usually stored as smiles, cxsmiles, or mrv files in the field (I'd use another site for this as I think they are images on wikipedia)
sql database or xml-file option, know anything about this? https://www.reddit.com/r/learnpython/comments/3tn6cs/scraping_wikipedia/cx7l0ej
I do a lot of interviewing and I would never ask these sorts of question.
How exact are compound names? Like how many names can one compound have? If you take all your compounds and just slap them to the end of the lookup url, would it sometimes give 404s? If there's two different uis, you can just modify the pasting code to like, try the first part, of there's an error, do the second. 
Thank you so much. That makes a lot of sense to do it this way. The biggest problem I will run into will probably be as Avcdo mentioned: compounds can take MANY different names all referring to the same structure
Yep, came to say the same thing. Don't put extra load on their servers, they are providing a free service so accusing it is not cool, especially since they are providing alternative. https://en.wikipedia.org/wiki/Wikipedia:Database_download
How many access points are required to get a relatively confident position? I actually wrote something very similar to this a few years ago. It seemed at least when I was developing the app, that signal strength varied quite a bit even while sitting in one location. To define a fingerprint, how many samples do you take?
~~you don't need to scrape wikipedia, they offer database downloads~~ edit, you should just look up how to use xpath, and some loops. 
 modffi.c:32:10: fatal error: 'ffi.h' file not found #include &lt;ffi.h&gt; ^ 1 error generated. make: *** [build/modffi.o] Error 1
https://github.com/micropython/micropython#external-dependencies Looks like you're missing libffi-dev.
R has what looks to be a *very* nice scraping module. I don't program in R, so I can't remember what it was called, just saw some examples of its usage in a step by step guide for an nlp-Twitter bot last week and was fairly impressed. So you're already familiar with R, an will do your analysis there, it might be worth your time to look it up, instead of learning Python :)
Yes, thanks.
Just to mention that, libffi dependency can be disabled in unix/mpconfigport.mk . It's not recommended (MicroPython stdlib depends on it), but if you're just looking to give uPy a quick try, that may be the easiest way for starters.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
This is definitely something you need to ask ArcFM themselves for support with.
Just download and learn to use Scrapy. It's a Python software specifically designed to scrape stuff and extract the data you want to extract into objects. Then you can do whatever you want with it (such as store it in your own DB).
Switch to Linux and use cron or systems' new scheduler. ;)
if you are hiding the interaction with the db then you should do so all the way. E.g.: if you don't care about memory usage you can put a list() around your results and keep using the ResultProxy list. Sessions and transactions help maintain relational integrity - but perhaps your db interactions always involve a single record and you don't have to worry about it. I guess what your are doing could make sense if you can draw clean boxes around all your db interactions and think of them as disjoined steps. However, concurrent systems (web...) are usually more complicated and you should think of drawing larger boxes that allow you to guarantee overall transactional behavior.
That. scrapy is great - very well written, very well designed, and very well documented. A bit of a learning curve, but it's worth it. The spiders themselves are usually very short. That said, see the other comments about not scraping wikipedia (or train scrapy to use their API - it's probably possible).
Based on some other comment OP made, he's not really planning on hammering Wikipedia with some big app. He just wants to use WP to practice. His scraping activities, since they're just for learning, are not going to affect WP at all. Now, if he were writing an app to share with people, he should not scrape WP. I mean, practicing by scraping some tiny bit of WP is definitely going to use less of their bandwidth than downloading a DB dump from them that is GBs in size.
Werkzeug or WebOb could be a good starting point of building your own web framework. These two are not a framework, but a library, but have done all complicated-but-common things to deal with WSGI.
It sounds like using the wikipedia database dumps are the better way to go here, but if you want to do web scraping in python you could look into: * [requests](https://pypi.python.org/pypi/requests/), for web scraping * [beautifulsoup](http://www.crummy.com/software/BeautifulSoup/), for pulling things out of the HTML These are both super useful for scraping text off of the web. You just need to look through the HTML of whatever site you're interested in to understand how things are structured, and then write scripts that will pull the relevant information. That said, as others have noted, you should be careful you're not needlessly pulling data that someone has already pulled and made available, and in general don't hit web pages too many times too quickly, or you will either put too much load on their servers or get your IP banned. *edit* Note that the github page you linked to is already using BeautifulSoup, so you can see some examples of its use there. I think that it might be easier for you to figure out how to use BS on your own and then build something that's right for your particular use case.
If you want to pull the same bit of data from multiple pages (say, the third column from the first table on a page, or some of the stats from Wikipedia's fact-box), then I recommend http://import.io. The downloadable version has a browser that you train by opening several similar pages (say, 5 different wikipedia pages) and selecting the part that you want to extract (eg. all tables), then it learns a selector (ie. "The first table in the page") and then zips through your entire list of pages extracting that thing. You could do the same with Python &amp; beautifulsoup, but if you're a beginner it might take longer. Whichever way you go, you'll need to decide **exactly** what thing you want to extract in terms of the HTML on the page. eg. "The first table", "Anything starting with AtomicNumber:", or "the 5th line from the fact box". From your responses and lack of examples it seems you're having trouble explaining exactly what you want to extract to other humans. That won't get you far when explaining to a computer (import.io or programming). You'll need to create a different template / script for each website you want to scrape from, and scrapers are notoriously brittle- when a website changes or a page differs in some way (say, the part you need is in the wrong section, or they add an advertising banner into their website) the scraper often needs to be updated / rewritten.
Have you looked at [DBpedia](http://dbpedia.org/)? It has pre-scraped Wikipedia into structured form. You can query the data online with the SPARQL query language, or download it all and use it locally.
Weputachipinit.tumblr.com Engineering is currently fucked
&gt;business intelligence analysts Ipython notebooks are great to demo here. Pandas makes data manipulation from a wide variety of sources easy. Not to mention the notebooks allow for replicable data analysis and easy verification without having to redo what some guy did in 20 excel sheets.
No, it's implementation of a subset of the language, as it says in its README at https://github.com/micropython/micropython . But on that front - what subset is implemented, and how much what's implemented is compatible with CPython - it went much farther than any other "embedded Python" implementation you might hear about - PyMite, tinipy, Owl, etc. There's more detailed list of differences to CPython at https://github.com/micropython/micropython/wiki/Differences
If you want to tell me something I'd appreciate if just do it directly instead hiding it behind sarcasm.
This is the part that I find most interesting: 7. There's work on native efficient JNI bridge, inspired by Kivy's PyJNIus module, included into growing Android port. Would be *very* glad to see an efficient python option on android! 
Me too, that's why I'm working on it ;-). There's long way to be able to write Android apps in Python, but some integration already works, e.g. it's possible to implement "pm list packages" in Python: https://github.com/pfalcon/micropython-projs/blob/master/android/pm.py
&gt; the technical pros and cons of Python (being dynamic, interpreted, single-threaded, not usually as performant as compiled languages, etc) It might be useful to illustrate this with some basic profiling examples, followed by a quick demo of using numpy or a similar package to get around those limitations.
X-Post referenced from /r/dns by /u/unrealiz [json2pdns - python script for creating PDNS sqlite databases out of JSON files](https://www.reddit.com/r/dns/comments/3tfy3a/json2pdns_python_script_for_creating_pdns_sqlite/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
It would be interesting if you could do some sort of walk through with real data (or test data relevant to your organization) that touches on many of these roles and illustrates usage for a real use case in your org. Something like: * log into a server and dump some data from a database * ftp the files somewhere * transform the raw data into a simple report * include a graph (maybe use seaborn to pull together a multi-faceted graph) and include it in an email As a bonus you could show how easy it is to run the same code on Unix, Mac, Windows. Anyway, I can imagine it is a little intimidating to figure out how to show it all in 1 hour. My advice would be to keep it short and use very small code snippets. Like they say, "leave your audience wanting more." Maybe someone will ask for a follow-up demo. Finally, be enthusiastic but don't try to force it on people. Python is awesome but Java, perl and all the other languages you organization uses are great too for their needs. If you are too much of a salesman, people might stop listening. Good luck!
Thanks. I've wondered about router permanence for awhile and didn't know about dynamic channel assignment. So far I've used places for ~3 months with no problems.
Cool. That being said, it doesn't affect my point. A one-off scraping of even 10,000 pages isn't even noticeable for the Wikimedia Foundation. Based on [this](http://reportcard.wmflabs.org/#), WF gets 4,300 pageviews per second. I'm actually shocked it's so low. But [this](http://www.technologyreview.com/featuredstory/520446/the-decline-of-wikipedia/) article confirms. The math works out to about the same number.
Lots of good points, thanks! I'm going to put together a number of code examples loosely based on real use cases for us and then string the examples together to form a scenario. Showing the same code running on multiple OS's would be nice, although it would require either some RDP'ing/SSH'ing or virtual machines. But I'm fairly sure they'll accept Python as platform-independent, considering they are all used to writing Java in OSX and deploying on another *nix. Good point about the salesman image, I'll keep that in mind.
Yeah, I'll definitely go into how to work around the various perfomance limitations (multiprocessing, gevent/greenlets and C-FFI) as well as how to interface with Java.
This is good advice, but I haven't worked with data analysis, so I couldn't really make a very credible presentation of the tools involved.
Maybe your IPython notebook is running in separate virtual environment? Try to install it through pip in IPython notebook itself.
Let us know how it goes and best of luck!
It might be interesting to start in on lists and list comprehensions right off the bat and not even talk about loops. OK, you have to talk about them, but list comprehensions and map and reduce are so powerful and such a good "selling point" for the language.
Heh. I'm thinking of showing the "import essay" comic to illustrate the concept of "batteries included".
 import this
Are the micro controllers able to understand python, or is it compiled to native code?
Why not at least [try googling](https://www.google.no/search?q=%22getaddrinfo+failed) your error to get [your answer](http://stackoverflow.com/questions/7334199/getaddrinfo-failed-what-does-that-mean)? It means the hostname you are trying to connect to cannot resolve. webchat3.uk.quakenet.org is not a valid hostname.
I did google it, i am 100% sure thats the host name :/ I have no idea what it is
Try using one of these: https://www.quakenet.org/servers
I'm using oh-my-zsh autocomplete for Django, and it autocompleetes the built in commands like migrate/startapp etc. However, when you write custom management commands, these don't get autocompleted by the plugin. So I was wondering if your bash autocomplete does it.
Yes that's exactly what I did! Still didn't work! That's why I was wondering why! 
In no specific order: I would only use comments if they add something of value. #Variables clock = 0 isn't adding that much (on the other hand it doesn't do much damage, so if you like it, keep it). Most python coders keep to [pep8](https://www.python.org/dev/peps/pep-0008/). That means lowercase functions . Also I've never seen `def function (arg)` but only `def function(arg)`. `pass` is a noop (does nothing). You can use it to stub out functions or classes: ``` def to_be_defined(): pass ``` You could delete all `pass` in your code and change nothing.
If you understand lists you could do this; states = ["G--", "-A-", "--R", "-AR", "---"] for state in states: # loops, setting state to each of the possibilites in turn set_lights(state) time.sleep(...) def set_lights(state): if state[0] == 'G': # first character of 'state' GreenLED(1) else: GreenLED(0) if state[1] == 'A': # second character of 'state' AmberLED(1) ... It would enable you to change light combinations by just defining a new state list (line 1) rather than recode the `clock` state in your whole program.
A few things to start off with: 1. You don't need to put parentheses around the `if` and `while` expressions 2. You use `pass` and `return` in a bunch of places where they're not needed. `pass` is only needed if the block is otherwise empty, and `return` is only needed if you want to return from a function before it would naturally return. 3. Excessive whitespace in some places, such as `else :` and `def RedLED (On) :` 4. You use a `try`/`finally`, but it doesn't look like you're using exceptions anywhere. Does the gpio library use exceptions in some way? 5. You should be using `True` and `False` instead of `1` and `0`. 6. A lot of your comments are unnecessary, because they don't say any more than the code says. 7. Your LED functions are very non-DRY - see if you can figure out how reduce code duplication.
 &gt;A few days ago, the company I work for asked me to hold a presentation on Python. The background for this is that while we are primarily a Java and Javascript company, parts of our infrastructure (mostly related to packaging and deployment of serverside applications) are handled by Python. Well that sucks! I'm not a big fan of public speaking. I'm more of the mind if they can't figure it out them selves then why are they working here. &gt;I'm thinking of a rough outline covering things like: However education is a good thing so here are my comments: &gt;* the technical pros and cons of Python (being dynamic, interpreted, single-threaded, not usually as performant as compiled languages, etc) You must hit on a few key concepts in this section, especially the idea of one right way to do things, readability of the code especially after long periods of ignoring it, and the large standard library. &gt;* a short look at the basic syntax This can easily eat up considerable resources/time. Depending upon your business needs though string handling should be highlighted. The idea here being that many business apps are string heavy. &gt;* HTTP communication I'm not sure I'd bother with HTTP if you only have an hour. &gt;* JSON/XML/YAML parsing This is a tough one but I really wonder if you can fit a reasonable intro suction to these technologies if you only have part of an hour to devote to them. &gt;* uploading/downloading files to an FTP server Again why bother with this if you only have part of an hour to devote to it. &gt;* sending email Interestingly I can see his as a big deal especially if you have developers that will be using Python for system scripting. &gt;* database interaction This may be very important for your business, as such you probably should follow up with a more focused class. &gt;* using pip and virtualenv (maybe this is unnecessary at this level?) Unnecessary? Are you kidding. Atlas tin the context of pip it should be mandatory for any intro like this. Pip is elementary to managing a Python install. Virtualenv on the other hand is something that is only of value to a few developers and frankly I see it as a half assed solution for many users. &gt;* calling Java code from Jython Why confuse the masses? Seriously here don't try to teach about one version of Python while focused on another. Mention JYthon at the end of the talk so those that might be interested can look further. &gt;But my question to the community is: what would you include in a presentation like this? What would you recommend not including? Well you can see my answers above. Let's face an hour isn't a lot of time, a 5 minute self introduction and then ten minutes for questions at the end leaves you with 45 minutes of talk time. That will go fast. I might add that a bit of history of Python would be in order. The fact that they limit you to an hour is a good thing because it will force you to trim out a lot and focus on key elements. For me the primary focus of a talk to expose practicing programmers to Python should be basic language structure or syntax if you will, ease of maintenance and the ability to to make use of the large standard library. The ability to write code that anyone can read years later is a big Python advantage. The basics should be 50% of your talk time for this sort of intro, maybe a bit less. Spend the rest of the time on Python uses that jive with the focus of your business. If your business focuses on database manipulation dedicate time to that. If it focuses on R&amp;D maybe a focus on numpy is in order. The idea here is to spend enough time on things that a user in the company might find useful. If you want to draw people into the Python world, you need to show them something that relates to their life and hopefully makes it easier. 
Should have written "African or European" to be a real Pythonista.
So true about learning to use the standard library or 3rd ones appropriately. That was the biggest hurdle I had at first. All of the methods to work with data structures in Python are excellent, and I spend more time working on getting something useful out of the data vs writing the code to do so.
Well, not yet
You're right, I was not providing constructive criticism. My bad. Next time, before you submit a comment like your first one. Don't. Think for a minute and either: a) Don't say anything and move onto the next thread b) Provide a couple of bullet points like you did in your follow up comment with specific, actionable feedback.
https://learn.adafruit.com/building-and-running-micropython-on-the-esp8266/overview http://www.esp8266.com/ It is very limited in practice BUT it is incredibly rewarding once you have that REPL commandline popping up on your computer with an internet connected $2 board! Basically all you need is a TTL-USB programmer and a few ESP8266's from ebay that will set you back maybe $15-$20 for like 5 esp's and a programmer or two. So much fun but it helps if you are already familiar with Arduino or the likes.
/r/learnpython! !! !!!! ! !
But it's not even April 14th!
awesome feedback, ill number my responses so they make sense 1. I know, but i found it to be good practice and made it a little easier for me to see my own arguments 2. i wasnt aware of this, it worked so i assumed it was correct; when i call a function, once it has been completed will it just resume the main loop automatically? i thought i had to return to make it go back 3. i saw alot of this on google results, alot of resources show the whitespace, i was unsure so i followed suit, if its not needed then thats cool, ive learnt a little bash scripting and whitespace is very important so was taking a little pinch of salt from that 4. i dont believe the gpio library needs it, but it allows me to use the "finally" statement to perform the clearup at the end, regardless of if the script ends or if i keyboard interrupt it, i was going to add an exception but there isnt really a use yet, i may be adding more interactivity via the terminal to control the lights so i may add something then, will require a little more learning 4. Is there a reason for this? 1 and 0 work fine, im not complaining just looking for a reason why true/false is better 6. The comments are purely for me, im still very very early beginner like this is my first functional script, i like to look back at older scripts when im learning to see what i did, the comments let me see what it is im looking at for reference point 7. what do you mean by non-DRY? I made the functions so i could call them (1 for learning and 2 to try condense my code and make it more modular) where as before i was setting GPIO.output in each of the loop statments, as opposed to just calling it with an argument Love the feedback thank you so much /u/atrigent hopefully i dont come off sounding like an asshole, i appreciate you taking the time to read through and feedback on it i knew there would be parts i could improve, but as it was my first script that was functional and did somthing, im very proud of how it turned out, and if i can improve it then im all ears!
i dont know about lists or states yet, would they improve the script or is it more of a preference/more common way to do somthing like this ill look into them and play around with it, thanks!
all my comments add value to me, im very new to scripting so if i go back to look at the script at a later date i can see what i did, understandably alot of them just list the obvious though do i not need the clock variable? thats what im using as a timer to keep track of things, it starts at 0 and works up, if i call it wouldnt it error saying it hasnt been defined? or would the first call "clock = clock + 1" start at 0, create the variable and work up? noop is an amazing word, someone else made the comment on this and im going to look into it further, thank you :) the white space is my fault, i learnt some bash scripting before python and its done like that, but also alot of sources on google have the white space as well so i followed suit Where youve done "def function(): pass" would that mean once the code ran it would revert to the first pass? also little side note, how did you make your text into those blocks?
Is this a command line thing or are you using a gaming framework or turtle or something similar? 
Other posters have pointed out a lot, I've got a couple more. You should raise exceptions if your functions do not receive a valid argument. For example: def GreenLED (On) : if On not in (0, 1): raise ValueError("Argument has to be either 0 or 1, got {!r}".format(On)) ... But in the case of your LED-toggle-functions, the pythonic thing to do would be to just use the truthyness of the argument, which means that all arguments are valid: def GreenLED (On) : if On: print "Green on" GPIO.output(29, True) else: print "Green off" GPIO.output(29, False) See if you can't combine the three LED-functions into one using a dict like this: LED2GPIO = {"green": 29, "amber": 31, "red": 33} Try to avoid ever using global *variables*. Global constants (like LED2GPIO, above) are fine. What is bad is having some kind of *global state* which both influences and is influenced by different parts of your code, because this makes your code very hard to grok and debug. Right now it's very linear and not a problem in practice, but if you don't fix it it will come back to bite you when your code has grown larger. Instead, create a function or a class to hold the variables you need, like your `clock`, `pedestrian`, etc., and pass the relevant values to the functions as arguments. For example like this: def main(sleep_time=0.5): clock = 0 pedestrian = 0 ped_clock = 0 .... # this is true only when run as a script, not when imported: if __name__ == "__main__": main() Move the GPIO setup into main or somewhere as well. Rule of thumb: a .py file should not do anything or change anything unless it's run as a script. Use the exceptions, they are your friends! It's better to raise a ValueError too much than to forget to raise one that should have been raised. Be glad when you see them, because not seeing them is much worse! They tell you exactly what went wrong and where, and you're told at once, not at some later time because of some collateral damage. Don't write a try-except-block until you've discovered it's needed, and then catch *only* the exception that you just discovered should be caught. In other word, don't fall prey to the [most diabolical python antipattern](https://realpython.com/blog/python/the-most-diabolical-python-antipattern/). In closing, don't let all this criticism bring you down! You're doing great! Consider the time and effort that we, the commenters, have spent writing helpful(?) advice. It shows that we have faith in you, otherwise we wouldn't have bothered. :-) 
It would make the code much easier to follow as well as easier to maintain. States are very commonly used in hardware design and they are used in software commonly too such as in regular expressions or compilers just to name a few. States would apply nicely to your code because in essence your trying to describe different possible scenarios and in each of those scenarios, you have a different set of outputs. It screams states to me. Also, lists in Python are probably the easiest data structure I can think of. They function similar to arrays if you've used arrays in other languages but lists in Python are a bit more flexible. If you read the list documentation, I'm sure you'll benefit from the capabilities it offers.
I wrote about using kmeans to find dominant colors in images: http://charlesleifer.com/blog/using-python-and-k-means-to-find-the-dominant-colors-in-images/
What about https://github.com/audreyr/cookiecutter-pypackage ?
There are many resources on the [Python Wiki](https://wiki.python.org/moin/Audio). For instance, you may want to take a look at [PyAudio](http://people.csail.mit.edu/hubert/pyaudio/). If you're developing a game though I encourage you to check out [PyGame](http://www.pygame.org/docs/), which is a wrapper for the popular media library SDL
Yes, using turtle. Sorry, should have specified. 
When you say implementing your own types, do you mean implementing an arbitrary algorythm? Or using your work with one already implemented?. I implemented the srm0 in numpy (and later on an fpga), and for training, i used a genetic algorythm. But i would be interested in seeing if your method improves the training times and / or the classification. 
/r/learnpython
Regarding number 5: Using booleans is more efficient since a boolean uses only 1 bit and an integer uses 32 IIRC. It might also run a bit faster because of this (the effect will be negligable, but still) Secondly it prevents your code from behaving in unpredicted ways because ints can have many different values besides 1 and 0. Finally it improves code readability and saves you some typing. Instead of writing 'On == 1' you type if On or if not On. All in all your code is absolutely fine keeping the size of your program in mind. But one day you might want to move on to slightly bigger programs, and then stuff like this might become more important.
/r/learnpython
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
If you aren't sure, try using nslookup and ping to see if the host name resolves to an address and if there is a machine responding at that address. I tried myself and that host name does not resolve.
Oh sorry, I was a little vague there: I meant it should be possible to implement a couple of Python classes that describe an SRM0 neuron and then let neat-python's NEAT algorithm evolve the network structure and parameters that meet whatever fitness measure you want. The easiest thing to do might be to modify the existing spiking model (https://github.com/CodeReclaimers/neat-python/blob/master/neat/iznn/__init__.py) to implement SRM0. Then you could use the XOR spiking sample as a guide for how to train your own SRM0 networks.
1. Well, you should get used to leaving the parentheses out because they look really weird in python code. 2. What else do you think would happen? The program would just stop? No, when a function executes to the end it returns. And if it didn't, then you'd actually need to add a bunch more return statements. 3. Python is sensitive to whitespace when it comes to "block" indentation, but in most other cases whitespace is ignored. Some whitespace is considered a good practice, but the specific instances of whitespace I mentioned seemed excessive to me. All I can say is to read more code and possibly read some style guides. 4. Fair enough, that's a legitimate use of `try`/`finally`. However, you can think even more broadly than this. What if your program gets terminated before the main loop starts? Surely this is unlikely to happen, and doubly unlikely if you're always going to be the one terminating it, but it's good to get in the habit of thinking like this. Basically you want to write your program so that it couldn't possibly fail. However, one additional comment is that you should try to make the `try`block small, for readability's sake. This would involve putting some of the rest of the code into functions and calling them within the `try` block. 5. Programming is as much, if not more, about writing for a human reader as it is for a computer. For the LED functions, the argument is fundamentally being used to convey two states: LED on (true) and LED off (false). Numbers, on the other hand, are more useful when you are actually counting something. Using booleans conveys your meaning better to a human reader. Now, it is true that `1` and `0` are idiomatically used as true and false in some languages, and it is also true that `True` and `False` in Python are basically just `1` and `0` anyway. But in Python it is idiomatic to use `True` and `False` where it makes sense, as it does here. 6. Hmm. Do comments like `#Variables` really help you when you can clearly see that variables are being defined there? Does `#Functions` help you see that you're defining functions there? Does `#Green on` convey more information to you than `GreenLED(1)`? In general, comments are the last thing you should try to use to make your code understandable. You should try other things, like using a consistent organization and descriptive function names (which I think you have done fairly well), before resorting to comments. 7. DRY stands for Don't Repeat Yourself. The idea is that every piece of knowledge should be written in a single place in your program. For example, your pin numbers are written in four places each, including twice in each LED function. Not only is using raw numbers considered a bad practice (they will be seen as "magic numbers" because the code does not make clear what their meaning is and expects the reader to treat them as "magic"), but if you need to change any of these numbers you will have to change them in multiple places. Some will argue that it doesn't matter in the case of a small script like this, but I disagree. I long ago lost count of the number of times I though "I couldn't possibly ever need to change this trivial little thing, I'll let this duplication pass" only to have to change it shortly after. It's good to get into the habit of rooting out repetition wherever you see it, because it causes major readability problems, causes bugs, and makes programs difficult to maintain.
You know that .split() defaults to whitespace? x = x.strip().split() products = [{'name':x[0], 'price':x[1]}]
Hey man, sick video! I am new to python and am still learning (I still have A LOT o learn..) and I was wondering, what's the def function thing? What is it used for?
it defines a re-usable function. Within the context of a class it's called a method.
Ahh ok, So is the variable helloWorld already defined in a previously made variable? Or is it like a pre-determined function within Python (like the random function)?
Thank you!
Neither, it is the name of a function that you are creating. "helloWorld" did not exist before I wrote def helloWorld(): def is short for define so you are defining (creating) the function helloWorld to be used at a later time. It is a way to group code together that does a certain FUNCTION and then access that code at a later time.
You are very welcome. Also, if you have any suggestions for other games that you'd like to see done in this way please let me know. I plan on making a channel out of this and possibly getting content out every other week or so. 
How many when pep8'd though? Nah I'm kidding. This was a great video. I watched the whole thing. Reminds of of that time I spent watching Notch program this rpg for an hour
I got -4 rep for wishing OP a happy cake day? Jesus christ. /r/python 2nd saltiest sub aside from /r/globaloffensive ?
we'd love to see more live coding, but not so fast speedy gonzalez. 
Yeah, it wasn't sped up at all.
yeah! thanks
No, no, no, I was running through the code just do display it. I wasn't counting the lines -_- It was all for the looks.
mailur sounds awfully close to failure
Awesome vid, dude. If you're taking suggestions, I vote for 'Go Fish' next. 
I remember that! Was it the one he was walking through a maze and designing the walls
it is not even my homework 8)
Also, I noticed that you do not check the top boundary. As long as I can fly above the screen, I stay alive...
Raymond Hettinger does a lot of advocacy talks around how to sell the language. Check out the Pycon keynotes.
or from bash: `cat file | wc -l`
&gt; ( ͡° ͜ʖ ͡°) ( ͡° ͜ʖ ͡°)
TIL. Don't know why I've always done that. Prolly just used to piping to it from grep that I never really thought about it. Thanks.
Now do star wars battlefront in 87 lines. Bruh.
FYI there is the option to slow down the video in YouTube! :) check the "Settings" cog.
 import pygame from pygame.locals import * import sys import random So yeah, he used pygame but not as extreme as your example.
Or how to draw a circle around a coordinate thats inputted by the user
And pygame contains over 6k lines of python and 52k lines of c. But yeah, we'll keep calling it 87 lines.
As developers we try to use tools already produced to help us get to the best OR quickest OR cheapest end. He did that and he did it well. 
Lol, I wish.
It takes time. This isn't my first rodeo. Keep at it and you'll get faster. It the same with anything. 
I don't think I understand your question. The way the pipes work is that once they leave the screen the are moves back to the right side of the screen and the offset is randomized again. 
I can't seem to find good tutorials on pygame. All the ons I find are *copy/paste this code into your IDE and watch it work! On to the next lesson*
Okay, I'll add it to the suggestion list. Thank you for watching :)
You imported a 50k line game library.
So then I guess that makes the code 50,087 lines long. Not bad.
You have to take it upon yourself a little bit to understand what is going on there. When it comes down to it learning any module is largely the job of the programmer himself.
Any other examples than the XOR example? I'm not sure I get the purpose of illustrating something so trivial with an advanced algorithm. I'd like to see it in play on some real data so I can learn to use it better
you are getting downvoted (at least by me) because this is not a forum for help with your homework. It's a forum for discussion and posts about python. You should ask your question in /r/learnpython. In any case, you are going to want to remember how triangles work, how radians and degrees work if you decide to use `math` in the standard library, then you can use `turtle.circle` to draw some circles. Also, feel free to use `input` and don't forget to convert it to a float.
WIKIDATA!!!! it even has a wikiproject to gather chemical Data.
Hi! The dark magic comes from the code that prints the presentation code and runs it. It also makes the talk more appealing to the audience :). Regarding the comments: * The shebang improvement is a very good idea, I'll fix it. * The my_append function only purpose was to explain how to fix the default=[] issue. Generally I'd use a if x is None: approach to handle this, but, in this particular case, I though that using an example related to the previous slide where I explain "or" behavior would be a better idea. By all means the my_append function is stupid and unnecessary, there's no way to fix such a useless function.
Thanks, I'll use this approach! Edit: I've made some changes and now the presentation is python2/3 compatible. The new shebang is #!/usr/bin/env python
snake_case is pretty much the only major PEP8 standard I don't follow. I'm a much bigger fan of camelCase and PascalCase.
Hey, nice video! Would you mind if I adapted the source to run this on [Tingbot](https://www.kickstarter.com/projects/744235676/tingbot-raspberry-pi-made-fun)? I think this would make a great demo app!
This might be of interest to you: http://beets.readthedocs.org/en/v1.3.14/index.html It can do the playlist thing among many other things.
/r/learnpython
Really? github?
Good job OP. You made something that works. However, I'm sure you noticed that there were many repetitive parts. It's best to not repeat yourself, though. I'll give you some thoughts about your code (both formatting and in general). I probably forgot a couple of things here and there, though. Feel free to ask any questions. Before that, though, know that it would have been better if you'd posted it in the /r/learnpython subreddit. (See the sidebar here for more info.) 1. Import standard library modules first. 2. Use logging instead of print. This allows you to see the tiny repetitive information if you need to, and hide it normally. You can also log to a file, etc. 3. For hardware, add comments as to what the pins represent. If you don't need, then you can do: for pin in (29, 31, 33): GPIO.setup(pin, GPIO.OUT) 4. Even better, name the pins: `GREEN, AMBER, RED = (29, 31, 33)` If you need the names as well (such as for logging), you can use a dictionary. colours = {"Green": 29, "Amber": 31, "Red": 33} 5. You can set variables to the same value by using `a = b = c = d = 0`. 6. Initialize the variables in the main function. 7. Follow PEP-8, regarding whitespace, and variable names etc. functions should be `lower_case`. 8. Your three functions are doing the same thing, just with different numbers. Make them into a single function. 9. Use `True` or `False` instead of 1 and 0. Also, this guarantees two cases instead of if, elif, else that you have now. 10. Don't compare to `True` or `False`. Instead of `if x == True` use `if x`, and for `if x == False`, use `if not x` 11. Don't use parentheses around if and else. 12. You don't need to check for `True` then use it as is. Just put the variable directly. 13. Separate your main loop into a function which runs only if you run the file, but not if you import it. (*i.e.*, `if __name__ == "__main__"`) 14. clock has been defined as zero. To make it clear, use `while True` 15. Use states. It makes it easier to keep track. 16. Use functions to do the heavy lifting for you. 17. You are not using the pedestrian clock, so I removed it. 18. Add a way to cleanly exit. 19. You need to clean up in case something happens in the beginning as well. What if you set up pin 29 fine, but then you get an error for pin 31. You'd be stuck and you would need to go through the interpreter to reset it. 20. Use clear names. Or at least describe them with comments. What is `pedestrian = 0`? I thought at first that it was the number of pedestrians waiting. Having `pedestrian_waiting = False` makes it clear that it is a boolean (True or False) that shows whether there is anyone there, or I guess if someone pressed a button? 21. Why do you turn on amber after red had been on (before switching to green)? I've never seen this type of traffic light before. Is it common where you live? If you continue with the project, you'll probably want to use a button to figure out if there's a pedestrian waiting, and to decrease the amount of time that the current green light will last. In that case, you'll probably want to use an interrupt. This is how you would set it up: GPIO.setup(button_pin, GPIO.IN, pull_up_down=GPIO.PUD_DOWN) GPIO.add_event_detect(button_pin, GPIO.RISING, callback=pedestrian_callback) Note that you would want to catch the rising edge of the signal if your button is pulldown (`GPIO.PUD_DOWN`), or normally low, and the falling edge of the signal if your button is pullup (`GPIO.PUD_UP`). This depends on your wiring. Also note that the callback (the function that is called when the event is detected) has to have a `channel` parameter (`def pedestrian_callback(channel)`), and would need to modify a global `pedestrian_waiting`. Better practice is to move everything into a class, so you'd have `GPIO.add_event_detect(..., callback=self.pedestrian_callback)`, and, inside the class: def pedestrian_callback(self, channel): self.pedestrian_waiting = True You would also need to reset `pedestrian_waiting` after that cycle has ended, as well as the pedestrian clock. [I've put the rewritten code up on github](https://gist.github.com/masasin/32240f1fcf08d2c980da) for you, including comments and documentation. It's almost half the length of yours in terms of actual code, and I think it'll be much more manageable and easier to understand. Note that I'm using Python 3, not Python 2. (I think it's better to use this, actually.) edit: You can also use `cycle` from `itertools`. I updated my code to do that.
im not arguing at all, far from it, im simply giving my own feedback on my thought process, im taking all of this on board and actually writing it down, no need to be rude about it, text doesnt convey emotion and im actually extremely grateful people are taking the time to not only read the code, but feedback better ways to improve it
With PEP8 you will have something around 100-110 LOC. :) Also is it just the speed up or did the coder wrote everything ONLY in vim's INSERT mode?
Self-plug: You could save maybe 20 lines of boilerplate by using [Pygame Zero](https://pygame-zero.readthedocs.org/en/latest/). The idea is that by reducing boilerplate, we can make games programming more accessible to younger kids. If the source code is available and suitably licensed, a cleanly written Flappy Bird is [something I was looking for](https://bitbucket.org/lordmauve/pgzero/issues/26/10-classic-games) as a code example for Pygame Zero.
&gt; This isn't my first rodeo. Did someone watch too many Raymond Hettinger videos? :D
You could go for a career in science, where you happen to solve many problems through programming, as opposed to looking for a career in programming, where you happen to solve scientific problems.
By the way, do check out the-silver-searcher (ag) if you're searching through codebases. Literally orders of magnitude faster than grep.
that's exactly why i'm using `check_call` instead of `call`: if `Rscript` returns any other exit code than 0 (success), an exception is raised inside python.
Could do with more buzzwords
I personally use snake_case, but I've been doing it before I even knew what PEP8 was. I just think it's more readable. 
Engineering can be good places to look. Test engineering in various fields can involve a lot of programming. These days it's still mostly C/C++ and Matlab, but engineers are starting to find tools like python useful. 
[removed]
OP is getting clobbered, but to the uninitiated, it is not obvious from the title or video that this relies on a game engine. 
87? Heh, make that 2: import py_swbattlefront as swbf swbf.run() Whaddaya mean, plagiarism? ;)
Why would you want to do this?
Test engineering involves writing tests for machines etc, or for code?
My goal is to keep the games simple enough to do in a reasonable amount of time. Do you have any specific game in mind?
&gt; starfield Thank you for the suggestions, I will write them down. I have a line up for the next five videos. Keep your eyes out for the!
I never said I used cat for grep. I said I pipe FROM grep. `grep 'pattern' filename | wc -l`
Writing it down, thank you. 
I can admit that I have no idea who that is xD
The source code is available in the Youtube description.
Glad you liked it :)
Absolutely! Please do!
The XOR example is intended to be a "Hello World" style sample, so you can see the minimal amount of code you need to write in order to make use of the library. It's also a convenient debugging tool sometimes, because you can step through the NEAT-specific code and watch what happens without getting swamped by the complexity of the network and/or application code. There is currently a [single-pole balancing example](https://github.com/CodeReclaimers/neat-python/tree/master/examples/pole_balancing/single_pole), which solves a slightly harder problem. The double-pole balancing example is currently broken, hopefully I can find some time soon to get that cleaned up and working again. I haven't spent a lot of time on examples so far, because I'm still doing cleanup and refactoring of the NEAT code, but eventually I plan to add some examples of the sorts of problems that are used in the literature to demonstrate cases in which NEAT performs better than other approaches. (Or at least, performed better at the time the initial paper was written.) If you have a particular type of example you'd like to see, let me know and I'll see if it's something I can do. So far I'm thinking about adding a predator-prey example (like the simulation described in [this paper](http://nn.cs.utexas.edu/downloads/papers/jain-alife12.pdf)), an inverted double pendulum, or one of the hard maze problems from some of the NEAT literature.
well, if you are using vim only in insert mode, then you do not get any features of vim and lose 90% features of gedit/notepad and similar editors. vim's power is in command mode, of writing 'sentences' of commands, e.g. `ci'` - change inside quotes, `dw` - delete word, etc. etc. I cannot imagine how painfully slow it must be to have only insert mode in vim. :)
It's a quite popular Python "guru", there are lots of speeches of him on youtube. In one of the videos he kept repeating "Is this my first rodeo? No.", unfortunately I couldn't find that particular video right now, but I'm gonna leave you an example anyway. [Raymond Hettinger - Python's Class Development Toolkit](https://www.youtube.com/watch?v=HTLu2DFOdTg)
You still don't need a pipe in this case grep -c 'pattern' filename …but if you're playing with different commands, it might be more flexible.
Why?
Python I &lt;3 I love the part when the coder is like "Fuck it we'll make it a class" XD
Actually, that is the video where he asks the rodeo thing, at about 19:50, when some guy asks a question :D
I'm sorry. I posted in the wrong channel, and I didn't explain why I need to read a file in parallel. Sorry, one more time.
I think that would take more than an hour, hehe.
May not be able to get one.
Testing of stuff... physical stuff: does this alloy melt at the specified temperature? Does this ceramic electrically resist to spec.? What is the density of the fluid flowing through this pipe? Etc. Lots of overlap with instrumentation, stats, and tons of numerical simulation. 
/r/learnpython
What science job needs a security clearance?
I think someone else might have mentioned this, but I don't remember. You'll probably have more luck finding a solution on kivy's mailing list or irc channel, or if you think it's a bug then you can report an issue [on github](https://github.com/kivy/kivy/issues). Try to give full information about the error, I'm not sure what exactly your input problem is. Touch screen input just doesn't work at all?
For management, I avoid all technical demonstrations. It's got to make business sense. So, for python: * batteries included (explain std libs) * readability means future maintainability * python is the most taught language in CS right now - getting skilled employees in future * more than one implementation of python - no vendor lock in (yeah, it's open source too) * permissive open source licensing * show off a side by side code comparison to Java and C++ to show lines of code - explain productivity increase of less time spent on boilerplate code * show how much time is spent compiling code (productivity increase) * explain that there are situations where it is NOT the right tool for the job (set reasonable expectations)
My particular line of work is writing software to automate data collection in a production environment for high speed cables, things like SATA, HDMI, and a lot of significantly faster server room cables. The hardware I automate includes digital and analog IO, servos, laser engravers, and most importantly oscilloscopes and vector network analyzers. Once we have the data collected it goes through a barrage of computations to produce different industry standard or customer requested measurements, and if it passes all the requirements it gets shipped out. There's also a lot of statistics thrown in, especially performing tests to ensure that our fixtures are reliable and tests are repeatable. This involves a lot of post processing and can take a lot of computation power. We manage a couple databases, a statistical analysis intranet site, and a number of desktop applications for performing data analysis and report generation. This is just the software oriented side of my team, we also have mostly hardware guys who specialize more in the designing building of the fixtures, since we have to take into account everything from how to calibrate everything to how to print barcode labels. 
I believe the one with the underscore is deprecated. 
Thank you :)
Just write some code. It will contain bugs. Find and correct them :-) Seriously, debugging skills are just matter of experience. I never heard about debugging excercises, and I doubt they could be useful to obtain a real debugging ability. 
I missed the part of his post where he mentioned defence contractors. Can you point me at it?
Your code is absolutely lovely! I love to see the textwrap module put to good use, it doesn't get the credit it deserves. What resources did you use to figure out packaging? I've been having some trouble figuring out the process and could use some advice.
But how many assembly opcodes???
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules there before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." If your question is about homework, show them that you've tried to solve your problem in your post and you should get all the help you need. Cheers &amp; best of luck with Python!
I didn't even know they actively developed Python 2 anymore.
First of all, you define a variable imax but then just use the value instead of the variable. Also, the from (blank) import * is generally not a good idea. You introduce the possibility of namespace conventions, and I would argue that its easier (and more readable) to use "import (blank)" and then access functions as mpmath.mpf(). You can even do "import mpmath as mpm" so it's a little bit easier to type. That way, anyone looking at your code would know that mpf belongs to mpmath, but imax (for example) belongs to the main namespace of this module. Also, you should consider using timeit() to time functions. It can handle lots of thing's for you like running multiple iterations and returning either the sum of the time of all of them (from which you can calculate the average) or a list of the results. Additionally, the while loop should be a for loop. Are you using mpf because you need arbitrarily large precision? If not, consider using numpy arrays and see if you can do this using ufuncs (which are optimized for a distributed operation over the whole array, and are often several orders of magnitude faster than iterating over the array). I would be very surprised if mpmath didn't have something similar. You should also take a look at the standard math library, many of the functions there (such as for the absolute value and logarithm) are several orders of magnitude faster (for single values) than the numpy functions, which are optimized for arrays. You might also try mathematical tricks to see if you can shave of some time. Maybe use a taylor approximation for sin and log10 and see if that's faster.
while many of those positions sound interesting, unfortunately many of them also require a clearance
&gt; I just think it's more readable. Actually it has been shown in multiple studies that it is indeed more readable.
Go check out vim-pymode then
Example apps that actually do something? Difference with REMI? (Posted a week ago or so)
Yeah, probably. Contra, as nubzzz1836 suggests, is a good choice though.
Not the first person to point that out :P
Believe me, I live on those sites. Google and StackExchange are my best friends :P Just not for this particular piece of code. 
I've been working on a series explaining Pygame that's gotten some good feedback. I try to explain everything and not just say "do this". Please feel free to try it out and see if it works for you: https://www.youtube.com/playlist?list=PLsk-HSGFjnaH5yghzu7PcOzm9NhsW0Urw
I'm loving it so far! I wish I had found this before :D
Sweet, thanks man! Forked it [here](https://github.com/joerick/FlappyBird). Can be run using [Tide](https://github.com/tingbot/tide)!
Ooo, that's a great resource. Fabric is the one I really miss from python 3. It's the only reason I have python 2 still on my machine. I use it heavily for deployment automation.
I don't know if this will help, but I've always had luck with extensions that need compilation by PIP installing from the Visual Studio Command Prompt. You should be able to find it in the vs2010 folder in your start menu
Why? Python 2.7 is perfectly fine for many people and companies. Migrating complex projects comes with a huge cost for companies (if it was trivial, as you seem to think, most of them would have already switched). And there is little gain in the short term, but a high risk of introducing regressions on production code which is currently perfectly fine. Getting a bit tired of all these people telling others what to do with their personal / professional lives. Let people pick the tools they like and live with the consequences. Python 3 is a different language than 2.x, whether you like it or not, because so it was decided. It's akin to asking "Can everyone just hurry up and switch to [Java, Scala, Ruby, whatever language you like most], please?" 
Fabric and the NewRelic agent are not ready. That enough makes upgrading to Python 3 almost impossible at my company. :-(
I solved mine be clearing registry and then reinstalling MS Visual Studio. The msvc9compiler.py first looks in the registry to find out where vcvarsall should be, before checking system paths/path variable. Also by default the newer versions of MS VS do not include vcvarsall by standard, there are extra options that need to be specifically checked.
I don't follow line length but I follow almost all of the rest. I find that being consistent and right 95% of the time is better than being inconsistent and right 100% of the time.
Agree with this 100%. Plus, at my workplace, Python is not even a main language people develop in. Most developers on my floor use Perl, which frightens me to no end. Being one of the only Python developers on the floor, and the only one who is not paid to develop, I'm just lucky they have Python in the first place. Some of these boxes are 10+ years old running anywhere from 2.7 all the way back to 2.4. The company will absolutely not upgrade to 3.x for legacy compatibility reasons. As a result, when I develop code, its mostly for the reasons of running on these machines, and as a result, I'm used to its quirks and workflow. I'm tired of 3.x developers labeling me as a heretic and a barbarian because I just must not understand the explicit advantages of 3 over 2.
Eight space tab hurts my feelings
I'm having trouble... it's saying that it can't find the file and also that it's not a supported wheel on this platform. Tried the 32 and 64bit versions, downloaded them to my desktop. :S
I have the visual studio c++ repositories installed, but I don't have any idea where they've hid themselves. As far as I know I don't seem to have a vs2010 folder (that's easily accessible at least).
It would be hard for anyone on my team to be able to only do one. We all develop specialties though, I've really leaned towards driving our software development, we have one guy who does most of the web and DB stuff, one engineer who has become our full automation engineer (most of our systems depend on people), one guy who works mainly with active systems (cables that have active equalization and amplification), we even have a dedicated mechanical engineer in our team (he doesn't actually write software though) you get the point. Everyone on my team writes software and works directly with hardware, but each of us have unique percentages. Keep in mind that I'm just part of one team in a very large company. The vast majority of engineers we hire are for design work and never write a line of code, but you'll find a test engineering team inside just about every manufacturing company, they have to have someone doing quality control. 
I hate you! Why couldn't you have this before I started working on [this god awful monstrosity](https://github.com/Tylerlhess/VM_project) school project. I think I uploaded the instructions in the project itself. I should push more often really but in short it is a RISC based architecture VM that runs off ASM files where the ASM is roughly based on an actual instruction set (forget which at the moment). Oh and this is only part one of my school undergrad capstone... part two I get to build a compiler for it my VM... \#HowImSpendingMyThanksgiving 
Good tips. I have not used numpy and didn't know those were available. If working with large amount of data I would definitely look in to that.
As always, put it through its paces, rip it apart, suggest improvements, and they'll be made whenever I get around to it.
That sounds really awesome. Do you enjoy it?
Went with floobits and it's online IDE. Very cool. 
Hi, That's cool. . Thanks for a project where a noob like me can get over. PR : as a user, can I ask you to make the elaborated news modal fitting with the size of the news. .?
I'm looking for a solution to this problem too. You pretty much came up with the same thing I did initially. However I realized that I don't know if grequests is using threads or not... If it is then the above code needs to be modified to be thread safe.
Ahhh that's very nice. Thank you. 