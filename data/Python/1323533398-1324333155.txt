Literally? No.
wxWidgets seems to look pretty on both Linux (GTK) and Windows, whereas QT looks good on both Linux (KDE) and Windows. If there's a way to make PySide not look like ass in Gnome I'd use it.
despite some might not like the design decisions in web2py, you have to admit Massimo has put a tremendous effort into making it something many people love. I think this is the essence of a great project. There must be someone who is willing to put lots of love and energy into it.
Oh, you're a literally/figuratively nazi? You guys are *so* much fun.
It could be covered by the `-3` switch: &gt; -3 : warn about Python 3.x incompatibilities that 2to3 cannot trivially fix new-style and old-style classes behave rather differently on a number of features, as you've discovered.
&gt; For those who aren't familiar, the issue here is that property only works in "new style classes." It works in part, actually (and strangely): the descriptor's `__get__` works, but `__set__` is apparently ignored (and `__del__` does not work either, naturally): class Foo(object): @property def qux(self): return 3 class Bar: @property def qux(self): return 3 &gt;&gt;&gt; from test import Foo, Bar &gt;&gt;&gt; f = Foo() &gt;&gt;&gt; f.qux 3 &gt;&gt;&gt; f.qux = 4 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: can't set attribute &gt;&gt;&gt; b = Bar() &gt;&gt;&gt; b.qux 3 &gt;&gt;&gt; b.qux = 4 &gt;&gt;&gt; b.qux 4 &gt;&gt;&gt; The `__get__` method was correctly called on read access or the first `b.qux` would have returned something along the lines of `&lt;property object at 0x100473e10&gt;`, not `3`.
That adds a 10x10 px white border around the image.
Hmm, I don't do stuff like that with it but I'll look into it. I only know of ImageMagick because I heard it uses ghostscript internally for a few things (may be wrong)..
I think you are right. AFAIK it uses some functions from gs when dealing with PDF files.
I'm having some problems with it, I'm using the executable directly, rather than the API/shared memory portion of it and it seems the gs executable returns before the actual conversoin has been done. This means that I can't reliably get the threads to tell me when they're done. Catch 22.
I agree projects are people , the more effort and love is invested in the project the better they are 
I've found this to be especially true with the new Themed Tk widgets available in Python 3.1 and higher. I don't think it's available in any 2.x series. I built a very attractive yet simple application on Windows 7 using the *tkinter.ttk* package, part of the standard lib. The only question I got from anyone about it was, "What does the icon mean?" since it still sports a "Tk" icon.
Its implementation is rather clever.
Not to nitpick but the ui designer doesn't save as qml.
I've not even looked at the implementation of it. I'm *guessing* that when you connect a signal to a function that the function you're applying it to gets decorated by the signal function? Then just adds that to the event loop when it gets fired. Maybe, I dunno, I've got the Qt SDK on here I'll have a look.
If you want to extend the browser, then write an actual browser extension.
I don't have the skills to write a browser extension, and I need more than that anyways. I need a program to convert the .flv once downloaded, which an extension can't do.
To add to these, love and effort alone ain't enough, without sustainability. I have seen so many promising projects died slow, horrible deaths because although the brilliant people who started them had put in much love and effort, but after a while they lost interest. These are the grasshoppers. Be very careful with grasshoppers.
But PyGObject is maintained, and it's largely the same as the old PyGtk was.
I must be really weird in that I like PyGame and PyGTK the most.
I like Gtk because it's lightweight, fast, and (I know this is a BS reason) I like the default GNOME themes and think my applications look good in them. Edit: the last GUI framework I used is the ever powerful, ever simplistic www.clutter-project.org Getting everything together was a bit more work, but the resulting user experience was pretty freaking sweet.
I second that. This is a project we can all learn from - you put into a lot of heart eventually results will show it. I am saying this as a Django developer that considers django superior to web2py. That being said I respect the effort and I think there may be application domains where web2py may work out better.
Hi, great work! It says it's the 4th edition. Is the website (version 3.2) going to be updated? I kinda like the web version.
check out http://kivy.org
Congrats for this, have wanted to try web2py for a long time now, but unfortunately don't have the time for a personal interest project. Maybe 2012 will be the year.
multiprocessing is **not** ugly. — brought to you by the anti-defamation league for processes, forking, and message-based parallelism
Very true. Until you try to deal with timezones. Then, it's just as broken as every other language's work around timezones. 
Why would you say literally when you mean the opposite? 
+1 for requests. Made urllib and urllib2 just go the hell away. 
yes. Today or tomorrow.
ttk also [makes an appearance](http://docs.python.org/whatsnew/2.7.html#ttk-themed-widgets-for-tk) in Python 2.7.
PyQt looks fine in Gnome for me. I think Ubuntu ships a Qt theme to make it blend in well with GTK applications
For really simple uses, EasyGui is worth a look. It's a completely different paradigm to 'real' GUIs: you keep a procedural programming approach, and just throw up a series of dialog boxes. Limited, but beautifully simple to code. And since it's using Tkinter, it's just an extra Python module to ship.
It is important to point out that since 2008 this is no longer a one man project. We now have a [long list of contributors](http://web2py.com/examples/default/who) and some of them wrote more code than me this year.
Was considering this over Django. Thanks for posting!
Have you considered vim or emacs? Both are ridiculously powerful, and can be customized to do the "F5 -&gt; run code" dance. I'm also certain there already are plugins that help you with that. [edit]: It's late... I'm tired... weird typos fixed... :)
[Emacs](http://www.gnu.org/s/emacs/) is pretty good.
You're right. It saves as a .ui file (but in XML). I confused it with QML. Thanks for the correction.
[PyCharm](http://www.jetbrains.com/pycharm/index.html)... its F10 instead of F5 to run. But its a sort of middle of the road editor somewhere between a full IDE like Komodo and a lightweight editor like vim.
[dreampie](http://dreampie.sourceforge.net/)
I certainly am using numpy/etc. I'll look at that package too.
I do find it funny that in a subreddit for an open-source language, you've got nazis that do not understand the basic idea behind language evolution. Using literally in a context where you do not *literally* mean it (pun intended) draws attention to the fact the you do indeed know that what is supposedly *literally* true, is not. However, saying it in such a way exaggerates this and *literally* makes the language more exciting. How else would you phrase my question?
go for IDLEX http://idlex.sourceforge.net/ It is fixing most of the problems of classical IDLE and it is still IDLE. In the future some of the functions implemented in idlex will hopefully go to the official distro
PyScripter! PyScripters, represent!
yeah, pyscripter has improved a lot in the last versions I use it in my py3k-only notebook. Clean (no cluttered), lightweight and without any problem running tk guis or matplolib plots 
it seems there has not been any work on dreampie lately, Am I right ?
Hells yeah, the dev(s)? respond fairly quickly to bug reports.
Komodo Edit is free and is relatively light
Right, but I've been using it for months now with only a rare crash, usually when I'm doing something weird. Feature-wise I consider it better than the alternatives.
I just wısh he could do a 64 bıt versıon. Apparently he's been working on one if you check the Issues list, and it was supposed to be out by the end of this year. He needed $800 for 64 bit Delphi. http://code.google.com/p/pyscripter/issues/detail?id=484&amp;colspec=ID%20Type%20Status%20Priority%20Milestone%20Owner%20Summary%20Stars
I prefer Wing IDE. Best Python IDE ever.
Two off-the-cuff impressions: 1) You should be able to exit by clicking the X in the window bar or hitting alt-F4. Esc is not what comes to mind when I'm thinking of exiting a program. 2) Speaking as someone who has taught introductory logic circuits: The most important feature in a simulator is the ability to package off a subcircuit as a reusable component. So if you're looking to add features, you may want to look at that next.
I started using pyQT this week and was very impressed with QT/ QTdesigner. After seeing the example code, and how simple Designer is to use, I actually wondered why /everyone/ wasn't using these tools. ..Then I read the license, and my mood fell a little bit. I don't have much experience with software licenses, so I was hoping someone here could help clarify this for me: It's free to produce open source apps using PyQT, but a developer must pay a licensing fee for commercial apps. However, pySide is free to use for commercial apps. With both though, would a developer have to pay royalties since both use QT (the QT site was super-unimformative in regard to this :( )? I apologize for my ignorance; Ive been learning Python for the past few years, but all of the licensing stuff is brand new to me. Is there a good guide for interpreting software licenses? GTK also looks very promising so I was wondering how licensing worked with it as well.
[Muntjac](http://www.muntiacus.org/)
I never thought of pressing a key and having the code execute, but Kate has that! Too bad Kate is KDE only :/
[GTK+ with HTML5 backend](http://www.reddit.com/r/Python/comments/mzjgu/what_would_be_considered_the_best_crossplatform/c3550x3)?
I think PySide is your friend then. 
I just dropped a line on the dev and he wrote me back saying 64 bit should be out before 2012. Good news :)
I like your solution too. It's simple and fast. I basically came up with the same thing but I think mine's a little neater (https://gist.github.com/1454697). I like how you used a dict to look up words. I don't know if you purposely chose it for a reason, but I used it because Python dicts are implemented like a hash map, such that it reduces the complexity of lookups to O(1), compared to those who use list iteration/set intersection/permutations/regex to determine if a letter is in a set which is O(n) or more. Therefore it's O(n^2 ), the fastest I think you can do this in. Everybody else's is at least O(n^3 ) or more.
I believe you are right. QT Designer is a really great resource for prototyping. I will give Pyside a try and do more research into how all the licensing works. This thread has provided lots of solid opinions on the pros and cons of the various pythom gui modules, so I'll be trying out others as well. Ha, back at an old job where I first started learning Python, I used Ren'py to make some utilities (hours tracking, music database/log explorers, etc.) It takes a large amount of resources compared to other frameworks (it's meant for games and built on top of Pygame), but it can still be a good tool if you need something up in a short amount of time and have zero previous experience with GUI modules/programming.
I did not know this! Wonderful!
SPE ([Stan's Python Editor](http://pythonide.blogspot.com/)) allows you to execute code via one or two keystrokes while still having a lot of the features of an IDE. There's a Windows version too, although I've not used that extensively. My only problem with SPE in this regard is that there doesn't seem to be the concept of an application/project so you have to switch back to whatever file has your main function when executing in order to get meaningful results. Unfortunately I don't think it's still under active development although I find it reasonably stable. Otherwise, PyCharm is worth checking out as freyrs3 mentioned.
What makes you think it's KDE only?
[The Kate Download page](http://kate-editor.org/get-it/): "As Kate and KWrite are part of the KDE project, you can get them simply by installing the KDE packages from your Linux distribution. To get Kate for Mac OS X, please visit KDE’s Mac pages. Windows packages are available through the KDE on Windows project." That being said, I know you can run KDE apps in GNOME environments and others, but it tends to slow them down and beat them with the ugly stick. Also it's only too bad because OP is a windows user. As a KDE user Kate makes me so happy and warm :)
I hate it when people diss Python 3. It makes so many things like this better.
I run a few KDE apps on my gnome desktop, and they look the same as they do on a native KDE desktop. You can also run kate on windows and other platforms, probably, but I've never tried. That being said though, I think it's not a good editor -- but if you like it, that's great.
Yeah but to run it you have to load a couple of Qt or KDE libraries which slows it down. Still technically KDE only because you are running the KDE libraries...
matplotlib comes with a standard GUI that's accessible through the matplotlib.pyplot subpackage. In just a few lines of code you get access to an interface that can zoom in the plot and export image files.
SciTE is similarly lightweight, has the F5 run feature, and allows you to continue editing your script during execution. I hate that IDLE doesn't let you do that. http://www.scintilla.org/SciTE.html
For the lazy: could someone point me to the release notes? I was wondering what is different.
http://web2py.com/examples/default/changelog
WingIDE 101 is free and is simple: http://wingware.com/downloads/wingide-101/4.1.2-1/binaries
Sublime Text 2 FTW: http://www.sublimetext.com/2
Man! I tried out Vim +gVim but the configuration takes FOREVER. And creating a cross-platform configuration that's clean/neat takes FOREVERRR. Now I'm using Sublime Text 2. The editing experience in Vim was unparalleled for me, but since losing my .vimrc I don't want to try all over again. Why can't it just be awesome out-of-the-box?
web2py is an incredible framework. I can't wait to read the new book, but I can't find the PDF or other downloadable version. Happy to pay the full $35 to get it, but I can't find it on Lulu. http://www.lulu.com/product/paperback/web2py-book-(4th-edition)/18738286 is the closest I can come. Can you tell me where to find it?
I've never really noticed much of a speed difference, and my laptop is not really a very fast machine. The only place where it's probably a little slower is when you first start up the first KDE app, when the shared kdelibs are not in memory yet. But I don't really think it's much of an issue.
&gt; It is, however, a PITA to get it going on Windows, but once you've got it, works fine. On OSX as well. And applications run in X11, which is butt-ugly.
[Geany](http://www.geany.org/), written in Python.
the multiprocessing module however is. with the whole "transparent, but not quite" approach.
Do you use WingIDE?
I'm a hardcore emacs user but emacs isn't an IDE.
I've since discovered that, I can't actually get matplotlib working on my install, something wrong with Tkinter. I think there's a 64-bit incompatibility going on.
&gt; Why can't it just be awesome out-of-the-box? The downside to being a brilliant generic text editor is that you're going to compromise in some specific niche uses, because putting that functionality in by default then screws up somebody else's day. And this is true even without leaving the same domain, for example you probably want "electric pairs" on when programming Python, but its a PITA when programming Lisp. So decent generic text editors give you a good set of defaults, then let you customise that to your specific requirements so everyone is happy. In the case of Vim, if I ever find myself stuck with a bland copy &amp; no internet, there are 6 lines in a .vimrc that will get me through the day - tabstop/shiftwidth of 4, pick a good font for gvim, turn on filetype detection &amp; syntax highlighting, and add the statusline in. The overwhelming majority of the editing is done using the normal builtin commands so not having some fluff plugins doesn't really put too much of a dent in productivity. Setting up your "main" environment though is a task that will never end because hopefully your job is providing you with new and interesting things to do, not the same old crap day in day out. 
Is a "py3k-only notebook" a thing?
patch pyGates.py [unix_path_patch](http://pastebin.com/raw.php?i=nP3GM8DL) (didn't use os.path.join, too lazy)
Fun. Good job.
That's nice, it works well enough that I haven't looked at the source since forever. But when I'm on the job, vim still beats all of them.
SciTE is not an IDE but a simple editor. It has tabs, syntax highlighting, autocomplete, execution of the current script, break of execution and it is so light that its editing component (Scintilla) is the base for most of the other Editors/IDEs mentioned here. :) I've tried to move away from it to a more advanced IDE/Editor but I couldn't find one that is as good. 
No, it is a challenge. Some months ago I forced myself to take my fears out and to swicht to python 3.2. As I have many applications at work working on py2.6, including a django website, I decided to set-up one of my computers with py3k and to code there everything new. In this way I can experiment and learn how to set up a py3k ecosystem with currently available py3k libraries (numpy, scipy, matplotlib, PIL, PyQt, Biopython, ipython) some of them still not fully tested at that moment, without risking THE BIG accident at work and allowing me to smooth transition of my current highly used programs. In the path, wxPython, PyCrust and Stani's Python Editor were lost behind but I found IDLEX and IEP (you should check it), rediscovered pyscripter and PyQt and gave IPython a major role in my toolset.
Just checked out IDLEX and IEP pages, seems interesting, thanks. Any particular reason you prefer PyQT over PySide?
Vim and Emacs seem a bit of a science by themselves. I've tried several times. I used lispbox for learning lisp and battled with Emacs for python. Still (unfortunately) I never catched the idea. For me gVim/Vim and XEmacs/Emacs probably will stand as the Unfulfilled Promise forever. 
PyCharm is the best Python IDE. You probably want to use the best tool available. It's really quite simple. 
PyQt already brings the designer and there is more documentation around. Apart from this, no special reason (I do not shell so no license problem). Also, spyderlib (that I use together with PyCharm in py2.x) and IEP are PyQt applications... so I suppose it is natural selection at work...
Hey, nobody said Spyderlib ?
This goes against the grain but Eclipse + PyDev is a extremely nice solution for the Python developer. Yes Eclipse is huge, but it is worth the disk space if your only intention is to use PyDev. Another option would be EMACS. 
WingIDE is probably the best, PyCharm is second, but PyScripter is free and it's not much worse then those two first commercial IDEs, so for me it's a clear winner.
Think you may have better luck asking this on the PyBrain mailing list...
Forgive me, but what is your programming background, what other languages are you already familiar with? It's been a long time since I've used a language which *doesn't* allow for some form of indirect function call, the idea that this is surprising is itself a surprise to me!
what are the main advantages of WingIDE over PyCharm?
I would be really interested to know which languages actually do this: I have prior experience with C only, which I used to write small programs to do mathematical calculations - i.e. no large programs with a proper model or underlying structure.
1) Yes, constantly. One place it's often useful is as a callback function: onmousedown(function_to_do_something_awesome) Or in method dispatch: def do_one_thing(): print "alpha" def do_other_thing(): print "beta" actions = { 1: do_one_thing, 2: do_other_thing } import random avariable = random.randint(1,2) #print "alpha" or "beta" depending on the value of avariable actions[avariable]() 2) Other languages use lambdas. Here's how you could do a callback in ruby: &gt;&gt; def x(f); f.call; end =&gt; nil &gt;&gt; x(lambda {puts "YAYYY"}) YAYYY
&gt; but something about it doesn't seem quite right Its quite right, Python functions are first order objects. You can manipulate them just like you would any other object. [Relevant Docs](http://docs.python.org/reference/datamodel.html#index-864) &gt; Secondly, what do other programming languages without this feature do if they want to specify a bunch of different functions at one calling point? Is there a similar design pattern or approach? There's a bunch of methods. In Java you'd use something like a [Callable](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Callable.html). In OOP languages that don't doesn't support this you'd end up doing a similar pattern. If your language handles pointers like C then you'd pass those around. In functional languages first order functions are the norm almost by definition.
I can't answer your first question but If a programming language doesn't have this feature you can still have the same effect simply by using flags and some if blocks. Example: if answer == "foo": print_foo() elif answer == "bar": print_bar() if you did have that feature you could write your code such that "answer" would contain either print_foo or print_bar (instead of "foo" and "bar") and then you could get rid of those if blocks and write print_something(answer) which would have the same effect. I hope that helps.
I do. But I have the Pro license which cost me $99. Best money I ever spent.
Another usecase in combination with introspection: If you want to call functions by name during runtime (for whatever various reasons), getattr() returns the function object. So the handling of function objects is perfectly intended by Python: import modul_with_my_func my_func = getattr(modul_with_my_func, "name_of_my_function") my_func()
Will be available very soon. Solving some technical problems... will be announced on the mailing list shortly. Sorry for the delay.
In C you can do the same thing with a function pointer.
&gt; How else would you phrase my question? How about: &gt; Don't you think that that signal/slot mechanism of Qt is the greatest thing ever?
Really? It feels like I've barely touched the .vimrc that came with my gVim installation.
Which is *literally* word-for-word what I said.
I think this is a wonderful idea.
It's been a long time since I used C, but I remember I could have a pointer to a function. It's basically the same thing.
Can you elaborate on why you think this is the case? I'm new to PyQt, having just moved from wx. I'm still a bit confused by the point of slots -- seems just another callback function like in OpenGL. What am I missing that makes them so awesome?
It's entirely possible that they work the exact same. I don't use `wx`. Something like this: self.connect(thread, SIGNAL("finished(bool)"), cls.update_progress_bar) Just makes me cream, it's so succinct, obvious, straightforward and elegant. My intention is very much well known, the function it calls is laid bare. It can be used in a polymorphic way to allow connections of signals from multiple sources to a single function carrying along the origin via parameters. Overall it just feels like one of those extremely well thought out ideas that's baked so well I can smell the goodness *literally* as I open my editor. P.S: Literally is used as troll bait.
I use PyCharm for the following reasons... * Google App Engine Support * Excellent debugging support (with break points) * Unit test runner * Built-in refactorings and code suggestions I gladly paid the $100 dollars. Check it out: http://www.jetbrains.com/pycharm/
No, it isn't. The world "literally" is *literally* missing.
As another reply, I've got that book and I've read it 2/3 times through and I still use it as a reference almost daily. I will say: It's *the best* reference you can get on how to *use* PyQt, the examples are not merely illustrating some contrived example but really are applications in their own right, you could drop the examples into a production application without much hassle or glaringly awful bugs. The writer is extremely knowledgeable, he's well spoken and maintains the exact balance between idiot pandering and letting you know the *details* of how to *use* PyQt. I stressed use a lot because it *does not* delve into the internals of PyQt what-so-ever. There is still so much magic left for me in Qt due to this, I call methods like `thread.waitForFinished(-1)` without having a clue what it's really doing and any side affects that this may cause. This coupled along with the fact that PyQt has very little official Python-centric documentation (even the stuff that's out there is mostly C++, even when it says Python) you're left with plugging and glueing various bits and ends from documentation that you find around. It gets easier when you write more code using Qt, you get to know it's quirks. However, whilst this book is a must read for anyone doing real GUI work with Python I highly recommend you take it knowing FULL WELL that you're going to still need to do a lot of learning outside this book.
I'm not sure if English is your second language or anything but if you're saying that "Don't you think X is Y?", you're *literally* saying "I believe X. Do you agree". Which, if your belief is true and your faith strong you would say "X is literally Y."
Do you use it for Python? If so, show me your ways, mighty emacs user. I really like the idea of emacs but I just end up fighting with it.
That's so sad! I spent a few days learning about vim configs and now LOVE it. Even on Windows.
The only thing I need to get working in vim is code completion based on the library files (instead of just based on matching existing words in the current file).
You would only say "X is literally Y" if X literally was Y, not an exaggerated comparison or some methaphor. Qt signals/slots are not literally the greatest thing ever, just figuratively. Let me just link this here: ["literally" by The Oatmeal](http://theoatmeal.com/comics/literally).
i’m not an experienced library developer, but fwiw i wholeheartly agree that strings/bytes in python 3 are a huge advantage over strings that are unicode/strings that are bytes/strings that are ascii in python 2. the [article he links to](http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/) is interesting, too, but i can’t quite understand why its author dislikes this behavior. it was his own decision to create hybrid code after all instead of using 2to3 or forking, so problems that arise are not python’s.
That's it? The same trodden routine of why "Literally" cannot be used as a modifier to exaggerate something? Languages evolve, sorry you're stuck on 1.0.
From the wording of your two bullet points ("structuring", "calling point"), it sounds as if you expect this to be used mainly for complicating the control flow of the program. A better use is storing a (reference to a) function as an attribute of an object. That is, don't think of it as changing how you branch, think of it as allowing you to slightly alter behavior while keeping the functionality the same at a high level. (Class inheritance and polymorphism serves the same purpose.) class A(object): def __init__(self, myprinter): self.myprinter = myprinter def foo(self): self.myprinter('foo') def normal_print(x): print(x) def loud_print(x): print(x.upper()) a1 = A(normal_print) a2 = A(loud_print) a1.foo() # should be 'foo' a2.foo() # should be 'FOO' So treating functions as first-class values allowed us to customize the behavior of the same code, just like changing any other parameter value. In C, you would use function pointers rather than the function object itself, but Python does not make such distinctions.
I like `from __future__ import (whatever)` I realize it is used for language features right now but I would much rather have the convention be kept consistent. `from regex.__future__ import (whatever)` or `from __future__ import regex` makes much more sense to me. It implies that it's a future feature of that module or a future version of that module.
Yes, I came here to ask how this would differ from \_\_future\_\_.
Strongly opposed, for two reasons: 1. This seems to be used in the context of a large expansion of the standard lib, anything in there has a foot in the grave, and that's just too bad, with Django we've been trying to move to a small core, rather than a larger one, and I think it needs to be clear that "batteries included" doesn't mean everything under the sun goes in the standardlib, we have a mostly working package infrastructure and this point, let's take advantage. 2. If it's speculative, it shouldn't go in the standardlib. The stdlib should be for well defined, best implementations of common patterns. Not ok implementations that we'll test out for nebulous problems with no clear buy-in. `requests` is pretty popular as a 3rd party module, what does it gain from being the stdlib besides being "official"?
How is it too bad because OP is a windows user? It mentions windows support right in your quote.
I use Emacs but I've taught folks to use Python using WingIDE 101.
I think you misunderstood him; dying or experimental libraries will stay out. He proposes that the preview namespace will be used for good and necessary implementations, who's interface is just still unclear. Right now, they are scared of adding modules to the stdlib, because they might solidify with a bad interface. Running a module through the preview will help them discover the minor tweaks necessary for pushing it to the stdlib, or at least give them the confidence to do so. 
Right, and I'm saying if the interface is unclear it shouldn't be in the standard library. That's what being a 3rd party lib is for, that's a much better way to evolve something than putting it on an 18month feedback cycle.
I think they are pretty much on par. Except on OSX. I need X11 to run WingIDE. No thanks.
Wouldn't random.choice(actions)() be better?
We're free to use 3rd party libraries, but I think there's an advantage to putting it in preview. They're basically saying: This is an official library, that will be in python from now on (with small insignificant changes). You can rely on it. Personal anecdote: I worked in Redhat for a while, and I went through hell when I wanted to use rpyc in a project. They only allow to add dependencies through yum, and it wasn't packaged, so I had to become a package maintainer, and the whole process took more than two month. I would probably have given up and used xmlrpclib if I could. "Batteries included" is a powerful concept.
Came here to say this Sublime Text 2 and a terminal are perfect 
This kind of templating is available in the Nagare framework. Check the [Presentation tier documentation](http://www.nagare.org/trac/wiki/PresentationTier), at the "Imperative DOM building API" section.
If it takes 2 months to add a dependency to a project you have *massive* process problems, that can't be solved by putting everything in the standard library.
If you want to pip install something *globally* into that versions site-packages directory, I think you can do: pip-2.7 install foo or pip-2.6 install bar If you are wanting to install a package that is specific to a project and/or its something that version might change from project to project (like Django for instance), you should be using virtualenv.
Yes, the process is certainly cumbersome and slow, but if that surprises you, I wonder if you ever worked for a big company.. TBH, a major part of that duration was because I was a new contributor (and therefor faced stricter bureaucracy), and otherwise it would take about two weeks.
One example where this pattern is very useful is in a GUI program for example: Let's imagine a window with a button that calls a function when pressed. In tkinter you would write command=some_function. If you would write command=some_function() then this function would be called when the "command" variable is defined (at creation of the button) and not when the button is pressed. You probably wouldn't want that.
I'm not experienced with distutils, but you could try adding mod1 to the "libraries" for mod2: libraries = ["boost_python", "mod1"] 
I think this is a rather interesting approach to templates. Although, from my perspective the reason why I like declarative templates like Cheetah, Jinja, and Mako is that it is easier to integrate with web page designs made by designers. 
instead of a namespace for them, why not make them available as 3rd party modules on the chesseshop so i can install them on older versions of python and declare them as a dependency in my setup.py while it seems like a great idea i dont see any advantages over separate 3rd party modules
1) actions isn't a sequence, you can't use random.choice on it: In [30]: x = {1:2, 3:4} In [31]: random.choice(x) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) /Users/bill/&lt;ipython-input-31-dcaf5fe4da2e&gt; in &lt;module&gt;() ----&gt; 1 random.choice(x) /usr/local/Cellar/python/2.7.2/lib/python2.7/random.pyc in choice(self, seq) 272 def choice(self, seq): 273 """Choose a random element from a non-empty sequence.""" --&gt; 274 return seq[int(self.random() * len(seq))] # raises IndexError if seq is empty 275 276 def shuffle(self, x, random=None, int=int): KeyError: 0 2) The reader should imagine that the variable comes from somewhere else, I'm just pointing out that at the time when you do actions[avariable](), you don't know the value of avariable.
I already moved from random.sample which was incredibly slow on a 400k line file. Most CPU is now being used in pop() of the index list
You bring up a good point, why isn't actions a sequence?
You could also do `random.choice(actions.values())()`, but I suppose that's beside the point.
unfortunately, this does not work. g++ -pthread -shared -Wl,-O1,--sort-common,--as-needed,-z,relro,--hash-style=gnu build/temp.linux-i686-2.7/mod2.o -L/usr/lib -lboost_python -lmod1 -lpython2.7 -o build/lib.linux-i686-2.7/mod2.so /usr/bin/ld: cannot find -lmod1 it adds -lmod1 to the linking command, but the folder where mod1.so exists is not in the path.
In that case, use the library_dirs argument to tell the linker where to find mod1.so.
You can already do that with all of these.
Indeed. When changing to this : mod2 = Extension('mod2', sources = ['mod2.cpp'], library_dirs = ['build/lib.linux-i686-2.7/'], libraries = ['boost_python','mod1']) I still get the error because -lmod1 is looking for a file called libmod1.so and not mod1.so I tried to manually rename mod1.so to libmod1.so and linking works. Unfortunately, when I try to import mod2, I get another error : ImportError: libmod1.so: cannot open shared object file: No such file or directory So here is what I did : $&gt; cd build/lib.linux-i686-2.7 $&gt; LD_LIBRARY_PATH="." python2 And then it works, but only if I import mod1 before mod2. But all this is very ugly ... I find it weird: this problem sounds pretty trivial to me, I must be missing something !
I thought the same at first. And then I started to grok vim and realized,... it *is* great out of the box. Over the years I threw things into my vimrc, but they are mostly cosmetic. It's just that the way you edit using vim is *way* different from traditional editors. And you have to get used to it. Once you do, you'll see that it's not as bad as you once/now thought/think ;)
This might not apply to your project, but here is how I set it up in my current work. I write C++ code that doesn't know anything about Python and compile it as standalone libraries. For the Python bindings, I use [sip](http://www.riverbankcomputing.co.uk/software/sip/intro). To build it all in one go, I use CMake. If you need help with that, I can post some of the CMake scripts when I'm in the office tomorrow.
I remember trying/installing a vim plugin for python which did that using vim's OmniCompletion. Even tough I installed is, I actually never use it :) So I can't say much more. Try to google for "vim python omnicomplete" or something the like. Then, if you want to, you can re-map the OmniComp shortcut. The default is C-x, C-o IIRC. An that's not all that convenient ;)
I'm not too familiar with Ruby, but your second example seems to imply that Ruby supports the same behavior that Python does. How is your first example any different? It seems like in Ruby, you would be able to do the same thing, except you would write actions[avariable].call instead, which seems like a syntax difference more than anything else.
&gt; Man! I tried out Vim +gVim but the configuration takes FOREVER. What are you trying to configure it to do? Chances are there are sample .vimrc files online which will do the same thing.
Even PHP has [anonymous functions](http://php.net/manual/en/functions.anonymous.php)! 
&gt; it's that it's apparently slow and does not execute programs directly. What do you find slow about it? I am curious because I might be able to fix it. I understand that using a lot of stdout will be slower in IDLE on account of Tkinter's text widget, which is why the Squeezer extension was created. (Disclosure: I am the developer of [IdleX](http://idlex.sourceforge.net) ) 
And I'm sure they're used excessively, just like namespaces and the JSON-compatible array syntax.
For people who have programmed in Java, have you ever wondered why Swing is in the the javax.swing package when so much of the rest of the library is in java.* packages? The reason for this is that the javax package was originally designed for experimental extensions, so the first releases of Swing were put in there. But then programs were written that made use of these libraries, so they couldn't remove it from javax without breaking a ton of old code. There is a danger that this \_\_preview\_\_ namespace could face the same fate.
&gt; They're basically saying: This is an official library, that will be in python from now on (with small insignificant changes). You can rely on it No, I don't think they're saying anything of the sort. If they put something there and find out that the interface is too hard to use or not flexible enough, I'd expect that they rip it out and start anew, or at least make significant changes. Locking them in to supporting something with only minimal changes is exactly the opposite of what they want. They expressly want the ability to get something in front of peoples' eyes without it being finalized, and still have the ability to refactor significantly. 
I basically recommend one of three different approaches to learning programming, depending on your use case (ie, what you want to get out of it). It seems to me that you fall into the first category, but maybe not. **1. Python, with a book such Dive Into Python.** This is good for people who want to be able to see results quickly, get a taste for programming, and/or write some simple applications quickly, without having to learn too much of the underlying computer science. Ruby is a decent alternative, but I find Python's syntax more natural for people unfamiliar with programming. **2. C, with a book like K&amp;R or another beginner's book** This is good for people who want to learn the way that computer programming works a system level as well. It takes more work to get off the ground in C and write more sophisticated applications. But along the way, you'll be forced to learn about memory management and basic concepts of data structures, since they're not handed to you on a plate as they are in Python. K&amp;R is a great book for learning C, but I'm not sure it's a great book for beginning programmers. I may be wrong, though. **3. LISP, using SICP (the 'wizard book')** This is my favorite approach, but it's for dedicated computer scientists only. LISP itself is not the most useful language in the workforce (even Reddit no longer uses LISP), but IMHO, it's a language that will always be relevant. This is the absolute worst way to learn programming if all you want to do is write snappy webapps or iPhone apps and make a quick buck. On the other hand, if you make your way through SICP, you'll be in a great place to learn pretty much whatever you want, programming-wise. A related note: one object-oriented language is (more or less) like any other. There are differences in their implementations and quirks, but it's just a matter of familiarizing yourself with the idiosyncrasies of the language. Functional programming, however, is very different. In my experience, object-oriented language skills do *not* readily translate to good functional programming skills. The reverse is *not* true. If you are a skilled functional programmer, you'll won't have much trouble with picking up OO skills. This is because functional programming is a very minimal, basic style, and OO can actually be constructed from within a functional programming paradigm. (SICP does something of this sort, which is why it's such a great way to learn the essentials and the fundamentals). On the flip side, I think Java, C++, MATLAB, Objective-C, JavaScript, PHP, and Perl are all bad for learning to program as a beginner. They all have their place in the 'grand scheme' of things, but they all have their drawbacks for the beginning programmer. In my experience, most people fit into one of the above three categories, and the above three languages are optimal for each of those use cases.
You're right, writing good PHP doesn't leave much room for the kind of dynamic/functional programming you might be used to in languages like Python. Unfortunately, writing good PHP leaves it looking more like Java :/
I take it this is a Windows-only program?
It is indeed. Your IDLEX has nothing to worry about bro :)
&gt; and allows you to continue editing your script during execution. You can edit scripts during execution. I think you are running IDLE without a subprocess, which happens when selecting "Edit with IDLE" with older Python installs.
Look at this part: if event.type == pygame.KEYDOWN or event.type == pygame.KEYUP: run = AnimatedSprite(running_images, 15) run.location = (x_coord, y_coord) sprites.append(run) You keep appending new AnimatedSprites to your `sprites` list but you never remove them so they keep on being displayed later on. You either need to remove old sprites from the list or work out a way of only relying on one sprite object. Hint: the second option.
This PyScripter project looks very interesting. I just tried it out. The auto-inserting of ending parens and quotes is a neat feature and its debugger is cleaner than IDLE's. I checked out the subversion trunk and saw its written in Delphi. Would it be difficult to port to Linux? I don't have any experience with Delphi. EDIT: The debugger needs a little more testing, but I like its overall interface.
I actually first heard it from reading this comment: http://www.reddit.com/r/Python/comments/cbvns/your_favorite_python_ide_go/c0ric5s And I've of course noted the incredible slowdown when having lots of print statements.
`sort -R`?
&gt; so once you start dealing with large amounts of data or lots of print statements (like thousands or more) The socket is not the bottleneck. The Tkinter text widget is the problem. I find it interesting what has changed and what hasn't since last year when that thread was posted. 
Excellent, thank you for taking the time to give this advice. I'm very much at the very beginning and I had no idea what options were open to me and how useful different options would be. Much appreciated.
So what's the point of putting them in the stdlib in some hybrid "it's here but not officially" form? Either it's stdlib ready or it needs more time to bake, I don't think you can get that in the twighlight zone because there's no feedback cycle. If you put requests in there today, it'd be like 12 months until it's in a released Python, and then another 18 months of people giving feedback that can't be used by real people, because Python release cycles are (justifiably) much longer than 3rd party packagers.
I'm super new to Python &amp; PyGame, have Java experience though. So, in order to rely on only one sprite object, would I blit the single object to the screen at the position being changed by the user?
Fair enough. Is there any way to change the performance of the Tkinter text widget, or am I just better off not using IDLE at all?
Basically, yes. What you need to do is create your AnimatedSprite outside of your main loop and keep a reference to it. When the coordinates of the sprite change you update the sprite's location using that reference. Something like this (get rid of the bit I showed before): ... link_sprite = AnimatedSprite(running_images, 15) sprites.append(link_sprite) while True: ... x_coord = x_coord+x_speed y_coord = y_coord+y_speed link_sprite.location = (x_coord, y_coord) ... Personally, I would move the `?_coord` and `?_speed` variables inside the AnimatedSprite class rather than trying to handle them externally.
If you turn off line-wrapping for the Shell, performance increases a lot. Look in PyShell.py for 'text.configure(wrap="char")' and comment it out. If you need line wrapping, you could implement (naive) line wrapping in ModifiedUndoDelegator in PyShell.py: def insert(self, index, chars, tags=None): try: if self.delegate.compare(index, "&lt;", "iomark"): self.delegate.bell() return except TclError: pass self.mark_set('insert', index) while len(chars) &gt; 80: UndoDelegator.insert(self, 'insert', chars[:80] + '\n', tags) chars = chars[80:] UndoDelegator.insert(self, 'insert', chars, tags) 
Refactor, yes, not back off. I can't imagine finding out an interface isn't flexible enough without having an idea on how to make it flexible.. It's software, it's pretty accommodating.. I think they're mostly afraid of the small details, like how "print" was locked-in as a statement for so long, or the confusing "except" syntax. These were easy fixes, but they just couldn't break existing code. I mean, look at the examples he gives out: - daemon - solved problem with several modules, but none of them good enough yet to be canon. - regex - so completely solved, but just not comfortable to use, and everyone has their own style. Hardest part is finding a syntactic common ground. - ipaddr - Not sure what that is, but I'm betting it's mostly api calls to the os..
Alternatively, you can use the Pyganim sprite animation module, which handles these details for you. http://inventwithpython.com/pyganim/
I'm not sure that'll be faster. Inserting anywhere but the end is equally as slow as popping from anywhere but the end. You'll move the bottleneck to a different place, but (probably. I haven't tried) not remove it.
And if you need code completion, add [SublimeCodeIntel](https://github.com/Kronuz/SublimeCodeIntel) in the mix using [Package Control](http://wbond.net/sublime_packages/package_control).
`__future__` changes the syntax/semantics of the module that imports it. This would just be a normal package full of modules you could import, but there would be less guarantee of backwards compatibility in the next Python.
And, just a quick update. I've now modified the site so that login is optional.
&gt; I think mine's a little neater I agree. Your 3 small functions look cleaner than my one long one. &gt;I like how you used a dict to look up words. When I originally solved this problem, my first thought was to use a set but that doesn't allow for duplicate letters (all elements must be unique) and my next idea was to hash each letter, keeping track of the count of that letter, plus as you mentioned, you can't really beat an O(1) lookup time. When it comes to coding, especially Python, I tend to avoid some of the more "advanced" functional constructs: lambda, map etc. I'm not really that much of a fan of list comprehensions either. I find nest list comprehensions very difficult to grok easily/quickly. Still, I think it's cool to see how other people approach a problem like this. And despite the BDFL's design philosophy, it's clear that there's more than one way to do it in Python too. 
Any reason for not using random.shuffle? I don't see why you'd want to use random.sample over random.shuffle anyway.. I cooked up [this](https://gist.github.com/1463908), which ran in 1.5 seconds for a 100k line file (over about 30 seconds for your code). If memory becomes a constraint, you can revert to the list of indices and seek(), but instead of the random.randrange you just random.shuffle(self.index) then pop() from the end which is O(1) instead of O(n). That one ran in about 3 seconds over the same file for me (the constant seek()ing imposes some overhead).
Because a dictionary is a mapping, not a sequence.
In Ruby, you pass objects and send messages to them, not pass function objects. The difference is subtle but important. In the ruby example, what we're passing to x is a lambda object, which we then send the "call" message to; the lambda knows to respond to this message by executing the call method. A side effect of this difference is that Ruby has parameterless functions executed without parens after it; that is: x(myobject.mymethod) Sends x *the return value of myobject.mymethod* as the first parameter, not the method itself. (Because that line reads "call x with the value of sending the message 'mymethod' to object 'myobject'", while in python in would read "call x with the method 'mymethod' of 'myobject'").
What I meant was, why would actions be a dictionary instead of a sequence.
Oh, sorry! Because you generally want a dispatcher to have arbitrary, rather than sequential keys. For example, under the hood, when you tell python "x = X()", python is looking up 'X' in the global dictionary in exactly the same way as I look up action in the example above.
[What the fuck](http://facts.learnpython.org/2008)
more like reduce(int.__add__, [1, 1])
You might get problems if you get two integral types (e.g. long or Decimal). It's better to use the operator module: reduce(operator.add, [a, b])
Why not just sum([a, b]) ?
[PyGUI](http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/)
That would cause multiple problems, like being readable.
Yes. The sort you gave is essentially [BucketSort](http://en.wikipedia.org/wiki/Bucket_sort). A similar but more advanced option would be [RadixSort](http://en.wikipedia.org/wiki/Radix_sort), which relies on the structure of the elements. There is a well-known Omega(n log n) lower bound on the worst-case behavior for sorting algorithms, but this applies only to *comparison sorts* -- sorts that work by comparing two elements and determining their relative order. The above sorts are not comparison sorts.
why not a + b 
Would this help? {():sum([a, b])}[()]
this it is! reduce(int.__add__, (map(int,{():[1, 1][:2:]}[()])))
Enumerate(). Fucking yes! Was looking for exactly that today
Well, it's not using Tkinter for a start which in my opinion makes it a million times better than anything written in Tkinter. As for a Linux port, I don't know. The dev is pretty active on his google code page, try there. I've got it working in Wine really well, so far zero problems. There are some annoyances, try typing a variable with the name of `P`, capital-p, that shit drives me insane. I will turn that feature off *one-day*.
these method only use to write one VIRUS!!! very dangerouse code
TIL Python have documentation.
[Found a bug](http://facts.learnpython.org/2003). Click the arrow on the right of the text box and the output gives an invalid syntax error.
Bah, just discovered that there are comments, and someone noticed earlier. Should have scrolled more. &amp;#3232;\_&amp;#3232;
 whoosh
 def _start_ipython(): from IPython.Shell import IPShellEmbed return IPShellEmbed() start_ipython =_start_ipython() Call `start_ipython` wherever you want. Should be a nice complement to inspect-shell (sometimes you want to block, sometimes you don't)
whoosh
http://xpython.org/
http://en.wikipedia.org/wiki/Counting_sort
You have [procedural types](http://www.marcocantu.com/epascal/English/ch06proc.htm) in Pascal/Object Pascal/Delphi.
&gt; `__future__` changes the syntax/semantics of the module that imports it. Also, for that reason imports from future must come before any other code, which would be inconvenient for importing modules.
&gt;True and false are just variables More like: You can create variables named True and False and give them any value you want to.
Thanks for the tip, I'll see if I can use the approach you describe. As for sip, I'm afraid my project is closely tied to boost and boost::python.
Let me find a jQuery plugin for that.
My opinion on the standard library is that it should shrink rather than expand. External packages should be used at some point, and I'd rather the standard library focused on helping users reach point as early, easily and painlessly as possible ([node is a good example of this](http://substack.net/posts/b96642)). Integrating stuff to keep it versioned in lockstep with the language doesn't work well; the standard library is now about half cruft, and a quarter tolerable implementations that have better competitors on PyPI. `__future__` is fine for language additions.
Ok, now that I could look at the scripts to remind me, here's the slightly more detailed version: 1. Compile your mod1 C++ code (without Python bindings) to a static library, libmod1.lib 2. Compile your mod1 Python bindings to a dynamic library, linking them against libmod1.lib, yielding libpymod1.so (for clarity, I prepended a "py") 3. Compile your mod2 C++ code to a static library, linking against libmod1.lib to libmod2.lib 4. Finally, compile the mod2 Python bindings, linking to *both* libmod2.lib and libpymod1.so This process should leave you with libpymod1.so and libpymod2.so that you can easily rename (or tell the compiler the correct name in the first place) to mod1.so and mod2.so. For me, importing my equivalent for mod2 without first importing mod1 works fine. Edit: I suppose you could compile the pure-C++ libraries as dynamic, depending on whether you want to deploy them as such on the target system. Static is more convenient if you don't care about file size.
This is awesome. But will be hard to work with designers.
Editra! Seriously, I've tried pretty much every editor, and I keep going back to this one.
Why not 2? Because this is python, and we need to use ALL OF IT.
Speaking of reduce and operator, I added the factorial implementation I use: from operator import mul factorial = lambda n: reduce(mul, xrange(2, n+1), 1) print factorial(21)
I'm getting a 404 error when I try "get_contributors". e.g. con = r.get_contributors('android') I'm probably using it wrong - any ideas? Or do you need to be a moderator to get the contributors?
Except it doesn't actually completely work yet. I tried porting one of my PyGTK programs to PyGI, first using their sed script and then hand-fixing what it couldn't convert, and got crashes that I couldn't fix in several places. (One example: AboutDialog.set_authors(), which should take a list of strings in Python and convert it to a const gchar ** in C. It segfaults.) Of course I should help out rather than just bitching, and I plan to do that as time permits. Just pointing out that while "convert from PyGTK to PyGI" is the way forward, it's not actually proven to work yet for any large projects that I'm aware of.
I wrote a simple one you might be able to use for inspiration: http://code.google.com/p/pysimpleconwayslife/ 
Thanks, but I've already finished it.
They are keywords in Python 3.
Shouldn't that be `__next__`, not `next`? Edit: Also, `list.append`, not `list.add`. You didn't run this did you?
Interesting implementation but it would only really work if the people writing your templates are also Python developers. I knew quite a few Python developers that never learned how to use the `with()` statement properly much less designers who just want to grind out some HTML.
That is a good thing.
I like this one a lot: def permissive(*args, **kargs): for value in args: print str(value) for name, value in kargs.items(): print name + "=" + str(value) permissive(1, True, 'hello', name='john', alive=True) 
You need to be a moderator to get the contributors.
If finances are what's holding you back, the financial aid application is a nifty [Google Doc form](https://docs.google.com/spreadsheet/viewform?pli=1&amp;formkey=dGhyc3l3dVN2aFhZUXlhSWtZNUxFbFE6MQ#gid=0). You just fill out which parts of the conference costs you'd like financial assistance with, provide some amount of information and justification, and it gets submitted to the committee.
 [ val for val in possibleValues if val in s ] Hmm? s.intersection(possibleValues)
Can someone please explain to me why [PythonWin](http://i.imgur.com/K5IhQ.png) is never mentioned when this question pops up? It looks like every week there's a new Python editor/IDE added to the millions available, but not even once have I seen a mention of the de facto Windows Python IDE – it's included with [pywin32](http://sourceforge.net/projects/pywin32/), for heaven's sake. When I first started with Python I gave IDLE a shot, but I didn't really like the interface. My second option was PythonWin. This was back on Python 2.3 or so and since then I've never had to look elsewhere. Is there something horribly wrong with PythonWin, are Windows pythonistas not aware of it's existence, or what?
Except that the values have to be in order and intersection returns a set
Cool. Perfect. Thank you!
Also http://facts.learnpython.org/1017 &amp;#3232;\_&amp;#3232;
I know people knock visual studio all the time as big and hard to use. After using it I believe most people that have this view haven't actually used it. You don't have to use all of the toolbars and dropdowns :) The combination of [Python Tools](http://pytools.codeplex.com/) and [VsVim](http://visualstudiogallery.msdn.microsoft.com/59ca71b3-a4a3-46ca-8fe1-0e90e3f79329) is amazing. You should [check out this video](http://www.youtube.com/watch?v=7CoGsSlrxKk) and browse the [detailed walkthough](http://pytools.codeplex.com/wikipage?title=Detailed%20Walk-thru%20Guide%20-%20IDE%20Features&amp;referringTitle=Home).
Picking a framework is not only about looking for a list of must-have features. With Pyramid you are taking advantage of a framework designed by experienced web developers who have been burned developing "successful" monolithic frameworks.
It's a trade off. If you are aiming to target 100% of all applications, then you'll need a very flexible framework. One that is not opinionated and one that needs much work to put things together and then to maintain all of these components. On the other hand, if you are aiming to target 90% of all applications and is able to come up with a framework that makes life much easier for people to use. Then, that is a worthy goal, and in some way a lot more interesting. 
cringe.. I am the author of the linked post. Sorry, this was written as a sarcastic response to someone passing judgment on using Pyramid after not using it for very long. The linked post is needlessly smug and dismissive and I should have kept the tone of it it in my head rather than put it on the page. Just so Django and TG2 and web2py people don't feel their ears burning, as backstory, I worked on Zope for many years. And while a lot of the criticisms apply to full-stack frameworks in general, it is the subject of most of that post's scorn. And I am to blame there; I contributed my share of wet cement to the bind that Zope finds itself in today. But the combination of out-of-contextness smugness of the linked post might have you believe otherwise, sorry.
True, but if you can build a framework that targets 100% of all applications, document and maintain it well, then you can build something on top of it that targets the 90%. If you screw up, you can at least scrape off the stuff you added and start over again on top of the very general thing, which was not harmed.
Without knowing what your program does/looks like, it is hard to give you a pointer has to how to implement that functionality. If you are talking about IDLE making you open and close it again, then that is another story. And if you have questions about Python, /r/learnpython is probably a good place to check out too.
In the beginning almost every web site you start working on looks like it's going to fit in that 90% of all the web applications. But add a few new features and you get to the other 10% applications you thought your application didn't belong to.
It is hard to know the best way to do this without knowing what your code looks like. Paste your code somewhere, like http://dpaste.com or http://pastebin.com and we might be able to help you better :-)
I don't want to start a senseless web frameworks flamewar. I do believe full-stack frameworks have their niche. I related to your post because I'm also a bit scorned about dismissive comments about the lack of features in Pyramid without trying to understand what's Pyramid's main point. Sometimes I believe, people coming from old Zope days, are too humble, which is a good trait, but sometimes I miss stronger opinions like in the one in your post saying "Hey, Pyramid is not crap and if it's like this is because of this and that".
They aren't in Python 2? D:
No. Try the following in both 2 and 3: import keyword "True" in keyword.kwlist
I think they meant this: import math float(2.00).__pow__(float(math.pi.__mul__(float(1.00).__div__(math.pi))).__div__(float(2.00)))
So... does someone want to explain to me what the point of this "Pyramid" thing that we are discussing is? :-)
http://docs.pylonsproject.org/projects/pyramid/en/1.3-branch/narr/introduction.html
Great. Unfortunately, you don't see anyone who takes such frameworks and create a full-stack framework targeting 90% of all applications. For developers, most want to build applications, not frameworks. Most want to be able to quickly build up something functional.
It seems that the convenience of gluing everything together is obvious, and unfortunately the absolute necessity of separating concepts for modularity is subtle, and can only really be learned from the school of hard knocks. http://www.bonkersworld.net/images/2011.11.15_life_of_a_swe.png 
&gt;I do believe full-stack frameworks have their niche. Not sure where you are coming from, but I think full-stack frameworks shouldn't "niche"; they should be the norm!!! Tools that allow people address 90% of all things are much more interesting than those that aim to address 100% of all things. You look at something like Drupal that is essentially a content management system and that is hugely popular. So an effective full-stack framework which is more flexible than a CMS should be the norm. 
&gt; Great. Unfortunately, you don't see anyone who takes such frameworks and create a full-stack framework targeting 90% of all applications. Actually you do. I named several of them in the original post. &gt; For developers, most want to build applications, not frameworks. Most want to be able to quickly build up something functional. I'm a web developer too. And I want to be able to do build stuff quickly. Having everything inside the same package isn't the only way to "quickly build up something functional"; you can get this without welding everything together too, as long as you have good integration docs.
I wasn't aware of all of these full-stack frameworks built on top of Pyramid. I will look at them carefully. That said, when people advocate for building applications by patching together different components , there are 2 assumptions they usually make (or take for granted). First, to do that effectively, you really have to be masterful of all of these components that you want to put together. People like you probably have worked alot with these components, so you might make the assumption that others are too. But this might not be the case. And if someone who doesn't know much about a few components they are attempting to patch together, that just opens a big can of worms down the road. Second is maintainability. When you are patching things together, you are really building a customized system. You will likely be either modifying the light-weight framework and/or the components that you assemble. Even if you know what you are doing. This just opens up lots of issues or at least concerns down the road in terms of maintainability, sustainability, upgradability, and collaboration.
Full-stack frameworks *are* the norm (the popularity of Django, Rails, and various CMS systems are examples). But there are a heck of a lot of people who eventually have requirements in the 10% range; when those folks use full-stack frameworks with tight coupling and strong opinions to solve their problem, they often get into the business of having to carve their application out of the framework by removing and subverting features, coding by exception instead of having the more satisfying job of actually building something.
These are reasonable concerns. More "full-stack" frameworks are a better choice for novice developers, who will be overwhelmed by the choices that a more flexible framework like Pyramid will force them to make. Heck, I'm a Pyramid contributor (albeit a minor one), and there are still projects for which I would choose Django, because they fit in Django's sweet spot. And if a novice web developer wanted to get an application going very quickly I'd probably point them at Django. But Pyramid has its place. I know what Django is and isn't good at. I know enough to make informed decisions about which templating engine and storage layer I want to use. I don't like wrestling with the framework when I don't want to do things the framework's way. I'd rather have a framework that is explicitly designed to let me make my own choices. Pyramid is such a framework. There's no "one true framework". There are different tools for different jobs. You're doing a good job of pointing out why full stack frameworks are valuable, but that doesn't negate Pyramid's value in the slightest, IMO.
See you all there!
It's always easier to go buy a some-assembly-required table at Ikea than building a table by sawing and carving wood and lashing it all together. I'm not suggesting that everybody should become a carpenter or industrial engineer in order to have a table. But carpenters and industrial engineers still have jobs. Several hundred thousand companies that need carpenters and industrial engineers hire them (including Ikea) every year. So we've built systems that the Ikeas of the world can use to build larger systems with if they like. "Scaffolding" is also included for people who want to buy a carpentry kit including all the raw materials and chopping and carving tools and instructions. Built atop those are "development environments" which are prefab kits for building a table without a great deal of tooling. Built on top of those are applications for people who just wanted the table delivered to their house in the first place. Each layer in that set of stuff is appropriate for different people and uses. It's often more appropriate to kick down a layer if you need more control than it is to try to make a bureau out of your prefab table kit. It's just not credible to say that since we have Ikea, we don't need carpenters or industrial design engineers anymore.
Meh. It works with any hashable. How about: {id(()):sum([a, b])}[id(())}
That real-time web with co-routines tutorial looks awesome, everyone should probably signup for it.
You are setting imageList to [] for each item in your directory, so when you append the data, it is always to an empty list. This can be fixed by moving the creation before the loop. You actually have a second issue: dictionary isn't updated on subdirectories. You can fix this either by adding the keys from the returned value or by passing a dictionary into your function. You need to be careful when fixing this. If you add a function argument dictionary={}, that object will be reused on later calls.
There's a lot of realtime ecosystem ( gevent, socketio, twisted ) featured this year, should be a good time.
&gt; More "full-stack" frameworks are a better choice for novice developers, who will be overwhelmed by the choices that a more flexible framework like Pyramid will force them to make. ^------- this. 
Use from collections import defaultdict dictionary = defaultdict(list) and do your update as dictionary[path].append(newPath) edit: Also, your function is throwing away the result of the recursive calls. You need to either pass the dictionary to the call so it can add to the same one, or import the recursive values into the dictionary with dictionary.update(imagesWithSubdirectories(newPath)) also: if newPath[-4:] in {'.gif', ',jpg', '.bmp', '.png'}: or if newPath.endswith('.gif') or .... 
Thank you! :-D
Ah! Good catch on the list. Little confused as to how I might fix the dictionary issue. I need two dictionaries, one completely outside of the loop? Something like: outDictionary[dictionary.keys()] = tuple(dictionary.values()) This doesn't actually work, throwing the exception: TypeError: list objects are unhashable
Also, you are not accounting the return from recursion. I made the following changes to your code to get it working: .... imageList = dictionary.get(path) if not imageList: imageList = [] .... dictionary.update(imagesWithSubdirectories(newPath)) .... 
&gt;For developers, most want to build applications, not frameworks. Most want to be able to quickly build up something functional. for people who are building those websites that have been built a billion times before, there are plenty of full stack frameworks and cms's to choose from. pyramid(imo) does not and never has claimed to be one of those frameworks. It boggles my mind why folks coming from other frameworks arrive at pyramid thinking it's just like django or drupal or rails or web2py or plone except that it is more rock and roll(or whatever trait attracted them to it to begin with, but the t-shirt is more awesome than a my little pony look alike) and then they ask something like "how do I use the orm" or "how do I validate forms" to which the answer is "pyramid doesn't do that, use whatever you want" and then they get all butt hurt and write things on the mailing list like the link. It happens seemingly every month like clockwork. it's just annoying noise. 
This in the block after checking whether it's an image or not?
There are a few things here. First, your algorithm is broken because you add newPath to imageList every cycle, but you also clear imageList out every cycle. So it's going to look like only the last image is being added (because this is the only image that happens and doesn't get cleared, because the loop breaks). Second, a better way to check paths like that is to use picExtensions = ['.gif', '.jpg', '.tga', '.bmp', '.etc'] if os.path.splitext(testfile)[1] in picExtensions: case_if_true() It's usually better to use a built-in function to get your data rather than using slices, if nothing other than for readability. Also, for recursive directory walks, you can use "os.path.walk()". An example is picExtensions = ['.gif', '.jpg', '.tga', '.bmp', '.etc'] for root, dirs, files in os.walk(path): for file in files: testfile = os.path.join(root, file) if os.path.splitext(testfile)[1] in picExtensions: print "Got image! %s" % testfile add_to_container() 
On the flip side if you happen to be financially successful as a result of Python, you or your company might consider a [donation](http://www.python.org/psf/donations/) to the PSF to support these kind of grants.
[This](http://codepad.org/Iqqoicpe) is more elegant (and terrifying): len(reduce(operator.add, (((),),((),))))
I must confess I've done this once or twice, as a convenience. I felt terrible about it though!
Because is was hiding behind a hard to guess URL like [http://python.org/doc/](http://python.org/doc/).
&gt;It's always easier to go buy a some-assembly-required table at Ikea than building a table by sawing and carving wood and lashing it all together. I'm not suggesting that everybody should become a carpenter or industrial engineer in order to have a table. But carpenters and industrial engineers still have jobs. Several hundred thousand companies that need carpenters and industrial engineers hire them (including Ikea) every year. The truth is while it all seems "pure" for us all to be carpenters, but in reality when you need a piece of furniture, you'll go to Ikea. Or if you can spend a bit more, you will go to your local Natuzzi dealer. The truth is there are great already-made furniture for 95% of all your needs. And for many it's not worth to become a carpenter to cover the other 5%. And you want to know what the truth is? Even if you ever become a carpenter yourself, chances are you won't make as good furniture as Natuzzi, and at a much higher cost. And you want to what another truth is? The world isn't just about carpentry and furniture. What if you need to fix your car? You want to go learn to be a mechanic too? It's all about trade-offs and priorities.
&gt;I'd rather have a framework that is explicitly designed to let me make my own choices. Pyramid is such a framework. If you aren't a "novice" developer, why would you even use a framework? WSGI is easy enough to build an application. Together with WebOb, a template engine (or you may even want roll your own). Why even use a framework in the first place? 
This is awesome. Haven't looked at the source closely but I'll probably be contributing to this somehow. Seems fun.
Cool. 
Cool. 
Cool. 
I'm not saying that there isn't a place for Pyramid and the other microframeworks. But I'm not convinced about the "goodness" that many claim they have. When I look at these microframeworks, which are supposed to be free of "opinions", but in truth, there are opinions. You can't escape from opinions. And you know what, opinions are good, especially from the wise and knowledge ones. If a group of people have spent years working with web apps and creating frameworks, when someone who are not as knowledgeable as you come along and have to make certain design decisions, why would their opinions be more useful than yours? Almost all non-trivial web app will have to deal with database, form, authentication, forms, etc., why would someone as knowledgeable and experienced as you are afraid of making these decisions to put together a cohesive framework that would make a lot of people's lives easier? 
Noone is confused Pyramid with Django or Web2py. What's being discussed here is that some (such as myself) think that a framework that is effective, easy for 90% of the time is more interesting than one that tries to cover 100%.
Drupal is essentially collapsing under it's own weight: http://www.unleashedmind.com/en/blog/sun/the-drupal-crisis &gt; Drupal core is not maintainable anymore. There's too much cruft. Too many half-baked features that no one actually maintains. In five years it might be in the same scrap bucket as Storyserver. I think the point of the original linked article is you *think* such systems should be the norm, but those of us who have been around this block two, three, ten times kind of know better. Can you show us some great off-the-shelf, full stack system from five, ten years ago (let's see, ATG Dynamo, Cold Fusion, Microsoft Site Server, Websphere, various Perl/PHP/Java debacles) that's not entirely an obsolete and unmaintainable dinosaur today ?
&gt;The truth is while it all seems "pure" for us all to be carpenters, but in &gt; reality when you need a piece of furniture, you'll go to Ikea. Or if you can &gt; spend a bit more, you will go to your local Natuzzi dealer. The truth is &gt; there are great already-made furniture for 95% of all your needs. And &gt; for many it's not worth to become a carpenter to cover the other 5%. I guess you think you're saying something different than I said. &gt; It's all about trade-offs and priorities. No, I'm sorry. In this context, there is no reasonable tradeoff to be had. Software engineering is defined as creating appropriately-scoped systems that cooperate with each other across well-defined boundaries. It's impossible to create a long-term successful system without appropriate scoping and layering. Documentation is important, and if you create systems that are capable of interoperating, you have to document how they work together (and we do, or at least we don't try to pretend we don't have to). The only thing left, I think, is branding and marketing. It makes a huge branding difference if something is called "Django" vs. "Pyramid + SQLAlchemy + formalchemy", because the latter *sounds* more complicated. But in reality it's just not, given an appropriate amount of integration documentation. Believing there is some material difference is to believe "Coke Adds Life" or "Virginia is for Lovers" or that when you go to McDonalds' everyone really is lovin' it.
I'm not saying Drupal is a great piece of engineering. I'm saying that Drupal is hugely popular, more popular than what these microframeworks ever dream of,.... largely because it solves painlessly maybe 80% of all problems out there. That's what the "norm" means. The norm does not mean an attempt to solve 100% of all problems, and ending up being barely minimal so that the only people who end up using them are those elite experts. Without Django and other full-stack Python frameworks, nobody but a few who "have been this block ten times" would be using Python to write web apps. Everybody would be using Drupal, Rails, etc. That is what the norm means. 
&gt; If a group of people have spent years working with web apps and &gt; creating frameworks, when someone who are not as knowledgeable as &gt; you come along and have to make certain design decisions, why would &gt; their opinions be more useful than yours? Because there is no one universal right way. There are many right ways, and some of them are mutually exclusive, right? &gt; why would someone as knowledgeable and experienced as you are &gt; afraid of making these decisions to put together a cohesive framework &gt; that would make a lot of people's lives easier? You're somehow thinking I disagree with you, and that I believe full-stack systems don't make life easier for lots of people. I believe they do, whether they're marketed as "full-stack" under one brand name or they're independent libraries combined together to form such a stack. To the extent I haven't done it already by creating or learning all the consituent parts, if in the future I try to put "the one true framework" together, when I make a total mess of it, I'll be glad to be able to start over without throwing everything away and starting from scratch. I'll be able to avoid starting from scratch because although the stuff I built will make lots of binding assumptions (a data model, an admin interface, a form system, "pluggable applications"), it will be built atop something that already provided useful but less binding features (authentication, authorization, view execution, internationalization, templating, debugging tools, URL generation, static file serving, mailing, testing). Since I'm no genius, but I still want to produce stuff, and have pride in the stuff I produce, I *need* this layering. It's not really optional.
So what is your suggestion to the folks that write Pyramid and other Pylons Project libraries? Should we stop writing software that can be documented and used independently from some notional branding whole, and try to shoehorn all of our problems into the 90% solution space provided by a well-branded, existing full-stack system?
It's not that black and white. There are gradients.
Firefox stores its history in a sqlite database. So perhaps the currently open page is already stored in the history? Here's some [details](http://www.forensicswiki.org/wiki/Mozilla_Firefox_3_History_File_Format) I don't know how this has changed since version 3. 
&gt; Without Django and other full-stack Python frameworks, nobody but a few who "have been this block ten times" would be using Python to write web apps. again this implies a lack of perspective; *plenty* of people wrote web apps long before anything like Django existed. Starting with Perl CGIs, later ASP pages, then PHP pages, servlets, ad nauseum. I know it might appear this way but it's not like Django just "saved" the world from a small cabal of cognoscente who possessed the coveted ability to build a website - this is a total myth. A lot of us outside of the Django community have worked extremely hard to allow Python to be used for web development and thank you very much for pretending we don't exist! Historically, the abovementioned frameworks like ATG Dynamo, Cold Fusion, Site Server, basically allowed underqualified, uncurious programmers to build huge towers of crap, which were then hoisted upon their organizations and other programming teams to maintain and ultimately to replace. A lot of us have no interest in repeating that over and over again. Edit: note that I do not consider Django to be equivalent to Websphere, Site Server, or Drupal. It's far smaller and more agile than those, and I'd be much more comfortable recommending Django than Drupal any day.
 from pprint import pprint now with tabbed formatting.
ah, `len(((), ()))`
BTW, this "90% solution space" that somehow has gone from arbitrary number to established fact is, IMHO, more like 10% - and that's very optimistic.
Of course these frameworks have opinions - you are producing a false dichotomy here of "frameworks that are 100% opinions" and "frameworks that give you nothing". Opinions about what architectural approaches and libraries are best suited towards a problem are not the same as opinions about how to write clean code vs. crappy code, or how to perform very basic tasks. This is not a philosophy against reusability. Databases and forms and such are all handled by available libraries. Having someone stack up their favorite libraries and approaches is not akin to leaving someone to reinvent all of these techniques from scratch.
If you actually get into the nuts and bolts of Pyramid most applications are literally what you are describing. There's a surprisingly thin layer between WSGI and your view callable in Pyramid, which is why it's so beautiful. You pay for what you eat and nothing more. If you don't want to use sessions, databases, authentication, or anything else you don't have to. At its core it is simply a great way of mapping URLs to functions. Don't have any misconceptions about WSGI, it's pretty well established that WSGI is not the correct layer on which to build applications. It is a layer for allowing a server to communicate with Python. The goal of most of these frameworks is to make WSGI sane for building real apps, but most of them tend to go a bit further and force you into some other technologies that you may not want to use.
You could probably do a similar thing using Amara. http://pypi.python.org/pypi/Amara/2.0.0a6 https://github.com/zepheira/amara 
i'm not suggesting that Pyramid ceases to exist. I'm not suggesting anywhere that documentation is bad. I am saying that full-stack frameworks are interesting and there should be more effective, thoughtful Python full-stack frameworks. 
While 90% is not a "solid" figure, it's based on the perceived number of users who use a full-stack framework vs those who use a micro-framework. Are you saying that of all people who build web apps using python 10% use full-stack and 90% use a microframework? And you also believe that this 10% is "very optimistic"?
Are you saying that without full-stack frameworks like Django or webp2y or etc., **as many** people would still develop web apps in Python?
If there really is as much commonality to building web applications as you suggest, why would there need to be *more* full-stack frameworks? Shouldn't there need to be fewer?
No, he's saying that full-stack solutions solve ~10% of the web application development problem. Which, these days, isn't impossible. Many modern web apps are written largely in JavaScript (or even Objective-C on the iPhone) and the server side is just a glorified pack mule that schleps data to and from a persistence engine. Things change.
If somebody is just starting out, what do you recommend? The learning curve of vim/emacs is too steep and the modern IDEs/Text Editors can do everything vim/emacs can do and provide user friendly graphical interface. What would you recommend in that case?
WingIDE 101 is pretty reasonable, as I said above.
You could try either the free [Scipy Superpack](https://github.com/fonnesbeck/ScipySuperpack#readme) for OS X, or [EPD](http://www.enthought.com/products/epd.php) (the free version includes numpy &amp; scipy).
Yes, the reason for asking the question again was that i wanted to make sure that wingide would also be good choice for professional use also (equivalent to other professional IDEs like vim/emacs) and not only for learning purposes (which you recommended for). I am not a beginner to python, and even i had a basic knowledge of vim. I worked with vim for 3 months. So i assume that you recommend wingide either way. Thanks for the reply. Sorry for repeating the question.
Yes, it's nice. You can try the full version out for free for a month or so I think. The 101 version is free-as-in-beer, but it doesn't have as many features as the full version. PyCharm is also nice.
who's to say? I know I will. and being libertarian minded and not liberal minded, I don't really fucking care. :)
&gt; Noone is confused Pyramid with Django or Web2py. there are plenty of examples on mailing lists and stackoverflow of people getting confused about what pyramid is and is not. this very topic on reddit demonstrates that in the title. 
I would make that `newPath[-4:].lower()` because you don't want to miss files just because they're named `Foo.JPG` or `Foo.Jpg`. 
The location of python is set in that script file (line 2 and line 10), so you'll need to edit it to point to the version of Python you want to install it in.
Devices on linux act just like files. If a high level API isnt available, sometimes you can read and write directly to the device. For example I can do this in terminal: sudo cat somesound.wav &gt; /dev/dsp Yours might be something other than dsp depending on what sound system you are using. PulseAudio perhaps? Basically though, you can take the output from one device, work with it, and then pipe it into another device. I found this which might be useful for you. http://jprvita.wordpress.com/2009/12/15/1-2-3-4-a2dp-stream/
 for ext in ['.gif','.jpg',.'jpeg']: if string.lower(newpath).endswith(ext): *do stuff*
I actually wrote a post about doing this because I found the process to be so tedious and frustrating. My solution ends up using MacPorts which it doesn't seem like you are doing, but I highly suggest. http://www.adrianrosebrock.com/journal/2011/4/23/setting-up-numpy-and-scipy-on-a-macports-python-distribution.html
Are you doing this explicitly as a Python project or as a means to fix a problem with a Linux device driver? If its the former then go for it, if its the later then there's a probably a better way to attack this problem at its root by configuring your audio stack.
Virginia is for lovers!!! :)
You need to review more examples of how dictionaries are used. dictionary.keys() returns a list of the key values, as does dictionary.values, and there's no reason to make a tuple out of the values. Your exception is that what you're telling it to do is to add one item to the dictionary whose key is the entire list. Python doesn't allow lists as key to dictionaries. What you need to do is loop over the the keys and set outDictionary[key] = dictionary[key] one at a time. Or use the dictionary.update(other_dictionary) built-in function.
 l = {1, 2, 3, 4, 5, 6, 7, 8} l2 = {2, 4, 5, 8} x = list(l.intersection(l2)) x.sort() print x
Did you fix this? I just *tried* to read your code. My scroll wheel broked :( Why are you loading the UI file manually? When it seems you've got some generated UI segment in a class further on. I'd love to help you debug this, but I can barely see what's going on in the functions pertaining to the mouse clicks. If you fixed it, could you post the answer.
have you ever seen a site that someone built using Dreamweaver ? This is an extreme example - however, the point is, if you give a big red button to people that have no interest whatsoever in learning/understanding anything, they're going to push it. And now you have another site that someone later has to rebuild from scratch. Again, Dreamweaver is a very extreme example. But this is the concept at play in a more subtle way elsewhere. Are we *better off* that a completely non-curious middle-management type with total disrespect for our craft built a crap-ass site that someone later had to maintain ? Again again ! This is not the same with the frameworks we're discussing. But I'm here to push the needle more towards the "let's be curious; let's care" side of things. 
I'm a little familiar with how devices work on Linux, and I've used FIFO's for inter-application communication before, but I suppose the issue is figuring out how to get other applications to recognize the device and have things like volume controls available.
As far as I can tell, the background noise elimination isn't available in the Linux drivers, and I've toyed around with the volume levels quite a bit trying to make it so I can still be heard on VOIP applications without raising the volume so much that I end up with white noise / background static.
You'll probably want to hook [into libudev](http://www.signal11.us/oss/udev/) to actually go about creating new devices. I guess the question is do you need to do this in realtime or do you just need to work with existing audio sources. If you're just working with existing then ok_you_win is right, you can probably just work with unix pipes and pipe your applications against each with the processing happening in between.
Thanks for the information. This looks like a good start. I need to do Microphone Device --&gt; Processing in Python --&gt; Virtual Microphone device, so yes -- it needs to be real time or it's going to make it useless for what's mentioned in my post: &gt; There's a lot of background noise on my laptop's microphone when I'm on Linux, but using Audacity, I can do a pretty good job of elimnating the noise. **However, that isn't very useful for live recordings for things like VOIP.**
Nope, I did not fix it. I'm ignoring it for the moment, as it only seems to affect my specific distro, and it's in the experimental branch. Basically, this is the setup of my program: I have a QMainWindow, which in turn has a QWidget, that in turn has a QLabel. The PDF is displayed as an image in QLabel (ImageLabel, in my program). The QRubberBand, named rubber_band is created when one clicks on the image, and is updated when the mouse is moved. When the button is released, the rubber_band is hidden. So, the rubber_band magic is done in mouseMoveEvent (starting in line 420), mousePressEvent (line 443) and mouseReleaseEvent (line 469). In mousePressEvent, if the mouse is in the PDF area, I create drag_position, which is the starting point of the QRubberBand rect. In mouseMoveEvent, I update the geometry of rubber_band, taking care of the cases when the mouse is moved to the left and/or above the starting point. Finally, in mouseReleaseEvent, if rubber_band isnt empty, I get the coordinates of the box and use it to select the text inside the box, and then hide it. The bug happens in line 430 (setGeometry).
Are you starting X manually or is it automatic?
Well, since we're not on a 386 with 40mb of ram anymore how about: lines = [line for line in open(filename) if line.strip()] random.shuffle(lines) Since mattseh mentions a file with about 400k lines this would use about 40mb of ram if each line is about 100 bytes. 40mb of ram is 1% of available space on current machines. It's almost 2012, ram is cheap, use it. 
I gave up and sshed to a debian box. I cant be bothered to manage fortran installaion.
best python IDE ever!
You can always try to use [Homebrew](http://mxcl.github.com/homebrew/), I ended up using it over Macports actually. But, since you have Fink and Macports installed, it'll be a chore to make them co-exist.
Sweet, bookmarked this for when I'll need it. Thanks!
Which is it? Background noise (rustles,noise from household appliances/hvac, etc) is a very different beast from static or other signals that originate within the device.
There is no specific support (i.e. no option to create a Pyramid project in New Project dialog), but in general it should work OK. Since PyCharm 2.0, debugging should also work.
 sorted(s.intersection(possibleValues)) Unless you're referring to the natural order of the original data, in which case you're probably stuck, but I have to wonder what the source is of such a requirement...
Totally awesome!
I think you are implicitly accepting the fact that many people use Python for web dev is because of full-stack frameworks available in Python. It's not hard to see why full-stack frameworks address the need of most people for most of their needs. I think you are also saying that full stack frameworks are much more difficult to get right. And I agree, and that's why there should be more not fewer. But when you are implying that people who use full-stack frameworks are not interested in learning anything, I think you are flat out wrong, because you can't see things in other perspectives. Today, web apps are becoming more and more dominant. And it's easy to see why. There are many intelligent people who are not "around the blocks 10 ten times" in Python web frameworks, but who are writing web apps. I know people who have great ideas rooted from AI, or security, or many other fields of computer science, and who wanted to translate their ideas into web apps. These are extreme examples, but they are meant to show you why there are people who don't have time or even interest to dabble into the gritty details of things. But that doesn't mean they don't want to learn; that doesn't mean they are stupid. What they want is to quickly execute their ideas. Many folks around here tinkered with a tiny thing for so long that they think they are geniuses and the rest who don't understand or don't care to understand the gritty details are stupid.
There is no question that building a full-stack system that works in harmony is hard. But there is virtue in building a holistically harmonious system that makes people's lives easier. This is why I think there should be more attempts. 
I would have to agree
I'm referring to noise generated by the device when the ambient environment is silent.
I fail to see your logic or even the premise of your argument. Are you disagreeing with my assertion that most non-trivial web apps will need some levels of database, authentication, session, forms, etc.? Are you saying this is not true? Building a full stack framework is much more difficult than building a micro-framework. The difficulty is to make design choices in putting together a system whose components complement each other and work in harmony. I am sure that if the authors of current full-stack frameworks break down their systems and start from scratch, they will make different and better design choices. I remember reading a while ago something from the Pyramid people about having to make a sub-optimal design choice to make it work with the existing requirements. And that's just a micro-framework. There should be more full-stack frameworks that implement new ideas and avoid old mistakes other people make.
Thank you. It looks much cleaner and complete than the stuff I wrote.
Wow. Um, maybe because there's a middle ground between "a framework that makes all of your choices for you" and "writing the same glue code over and over again each time"? Pyramid feels to me like a collection of best practices for constructing WebOb-based WSGI applications. The routing engine, security apparatus, and i18n story are all fast, flexible, and powerful. Those are not problems I'm interested in solving every time I build a non-trivial web application. Pyramid might not be for you. It's not for a lot of folks. That's fine, don't use it. But there are a lot of skilled developers with years of experience building highly scalable real world applications who think Pyramid is useful, I myself would be pretty cautious about dismissing their opinions.
What's new: http://www.jetbrains.com/pycharm/whatsnew/index.html
What's the character of the noise - is it a specific requency (a constant hum or whine), or is more of a distorted/staticky kind of noise? Do you have a sound file you could some where?
OK, all your python libraries are supposed to be installed to /Library/Python/2.7/site-packages And your Python binary is supposed to be installed to /Library/Frameworks/Python.framework/Versions/2.7/bin/python You're not presenting us with any error messages, really, so it's not entirely clear what's wrong. Have you tried running Numpy or Scipy yet, or what?
He already has Homebrew.
&gt;I think you are implicitly accepting the fact that many people use Python for web dev is because of full-stack frameworks available in Python. yes &gt; It's not hard to see why full-stack frameworks address the need of most people for most of their needs. no. I like that shift from "many" to "most". As well as change in subject from "people" to "needs". Nice ! &gt; But when you are implying that people who use full-stack frameworks are not interested in learning anything, I think you are flat out wrong, Not what I'm saying. Non-curious people will gravitate towards "Don't make me think" frameworks. This does not speak for everyone who uses those frameworks, obviously ! &gt; These are extreme examples, but they are meant to show you why there are people who don't have time or even interest to dabble into the gritty details of things. But that doesn't mean they don't want to learn; that doesn't mean they are stupid. What they want is to quickly execute their ideas. These aren't application developers, they are cut and paste coders. They can do what they'd like. For actual software and web application developers who are actually practicing a craft, we'd like flexible, open ended, and finely tunable approaches to be standardized and encouraged. We don't want our approaches marginalized and lobbied against because of a misplaced appeal to amateurism. 
Automatic.
Perhaps you meant: if newpath.lower().endswith(('.gif', '.jpg', '.bmp', '.png')): # do stuff
I've tried PyCharm from the first preview, but there're still unfixed critical bugs. I wonder if anyone experiences the same issues. 1. The debugger seems to run into problems with namespaces. I sometimes get strange import errors which do not appear when running the code in opposite to debug. 2. Find usages doesn't work properly. Maybe import ... from ... is not recognized. I have reported those bugs about a year ago. Although the feature set (lateley discovered the DB browser with SQL console with code completion ... sweeeet) is impressive, Wing IDE just works and has the supirior debugger.
Have you tried the final 2.0 release? We've made several fixes a short time before the release, affecting Find Usages and trying to avoid incorrect import errors when debugging.
Dammit. I was hoping it was a misconfiguration with your X server.
Not so fast ;-) It has the potential to become the best ever, but Wing IDE is still on par. It has not that much complementary features, but is very mature and has better debugging. PyCharm still has some issues (see my other post). And you can't beat the support from the Wing team. Truly awesome.
No, just the RC version yesterday. I'll check the final version out this minute!
Yes, that's how I defined my integers for adding :-)
did they fixed/updated the Git integration with the nasty hack?
You can run it under GNOME, and although I've not tried it, it ought to be available on OS X and Windows. The startup time for the KDE libs and daemons may be a bit of a turnoff for some, though.
I'm gonna have to go with Wing IDE 4.1.2. I've tried both, and Wing is just better.
probably, thanks :) I find string.* still sticks in my memory better. QuickBASIC brain damage i guess.
Could you please expand on this a bit more? I have no idea what nasty hack you're talking about.
After using WingIDE for quite some time, I still think that PyCharm is better, so I stand by my original statement.
&gt; There should be more full-stack frameworks that implement new ideas &gt; and avoid old mistakes other people make. I understand that you think that magic happens when you put all the stuff you listed above into a single Python package and you give the result a brand name. From a marketing perspective, it's absolutely true, people love one-stop shopping and clearly get very attached to brands. I also understand that you believe Pyramid itself should be one of those things too, or at least that non-full-stack frameworks should not exist. Nobody can take that belief away from you of course. But once we start to talk about that, it becomes an discussion about software branding, not about technology. And, to me, making software is usually more interesting than doing that.
I totally agree. Regarding easiness/simplicity, I find it useful to separate those into short-term and long-term. I think that short-term convenience and long-term sustainability can at times be conflicting requirements. I suspect that it is hard for a developer to appreciate design decisions made in favor of long-term sustainability until they've experienced the pain of working on an insufficiently modular codebase over some period of time.
The PyCharm debugger coughs up blood at the sight of ÆØÅ :-/ Caveat: Haven't tried in the newest build. Beta from two weeks ago hadn't fixed it though. 
Ok, just tried the 2.0 final release. Unfortunately the problems are still apparent. I just can guess, but it looks like there're still issues with variations of the import statement, like import ... as ... or from ... import. That might screw the find usage functionality. Debugging seems to be confused by a local package named "io" (namespace clashes within standard lib moduls).
Neat, but why shell out $100+ (because you have to renew anually) instead of sticking with PyDev (since netbeans has removed their python support *grumbles obscenities about Oracle*)?
If you've reported the Find Usages issue already, could you please provide a link? I don't remember any problems similar to what you describe. We do handle all variations of import, including import ... as. As for the io problem, looks like our fix hasn't helped - we'll investigate it further.
You don't have to renew annually - the license is yours to keep forever. Renewal is only needed to get upgrades. PyDev has mostly the same features if you look at the checkboxes in the feature list, but I dare say that the quality of implementation of most of the features is better in PyCharm. It helps to have a team of 4 working full-time on the product (PyDev is developed by just one guy).
Anything specific that you liked better in Wing?
The find usage was actually a forum post (sorry, it's a bit ago): http://devnet.jetbrains.net/message/5275365#5275365 The debugger issue came up with test execution. Issue id: PY-2131
The PyCharm team is very responsive in answering. Also, on the Mac, you still need X11 to run Wing IDE. No thanks.
Will probably give it a second try, now with Sun's Java as with it doesn't/didn't work well with OpenJDK.
Did you file a bug on it?
That editor looks awesome. Then I saw the price tag. Then I saw my bank account. :( Any other recommendations for free Mac editors? I'm currently using textmate trial but I'm not that happy with it.
I'd be interested in hearing what the future of TurboGears is going to look like. Previously it has been based on Pylons, and now the Pylons project is focusing their effort on to Pyramid - are they looking at releasing their "full stack" framework on top of Pyramid in, say, version 3?
I am not a big fan of eclipse...
Just made an interesting observation. The issue seems to be related to path problems: I have opened an existing package directly as directory. Although I've set the pythonpath and in addition the path in the PyCharm setting, PyCharm did not recognize my package properly. (The paths were set to the directory containing my package.) But when opening the containg directory directly in PyCharm, my package is recognized and the find usages functionality works! The debugger issue has disappeared as well.
Thank you
One of the main news of this release is the new debug toolbar http://pypi.python.org/pypi/tgext.debugbar/0.0.1 but for most curious people this release hides a few gems, I suggest users to take a look at them. http://www.turbogears.org/2.1/docs/main/Extensions/Crud/index.html#easycrudrestcontroller http://www.turbogears.org/2.1/docs/main/Config.html#hooks-and-events http://www.turbogears.org/2.1/docs/main/TGControllers.html#mount-points-and-dispatch http://www.turbogears.org/2.1/docs/main/Caching.html?highlight=caching#template-caching http://www.turbogears.org/2.1/docs/main/Templates/Jinja.html#extensions http://www.turbogears.org/2.1/docs/main/RequestFlow.html?highlight=request%20flow#user-defined-middleware
Again, I'm not saying that Pyramid should be what it is not. Also, you can have your bias, but I do not think that a full-stack framework is essentially putting all the stuffs into a package. In fact, Django and web2py have both been condemned for "reinventing" the wheels. You can have your bias, but I do not think that a full-stack framework is simply about branding.
We have an experimental branch that doesn't rely anymore on Pylons and that should be the base for 2.2, but we don't really want to break any existing code so it will take some time.
I don't know much about PyCharm. Is there a way to integrate vim with PyCharm? Ideally, I'd love to have some kind of solution where vim is embedded in PyCharm. I'm currently using Eclipse with the Aptana Studio plugin (PyDev), and I get vim emulation via the Vrapper plugin -- it's not perfect (i.e. no visual block select) but I still find it amazing and very useful for quick editing/navigating. Actually, I use regular vim to code and Eclipse for things like debugging, searching for string patterns in the entire project folder, visualizing the project root, automagic links to module/function source, etc.
The truth is many application developers love full-stack frameworks. Of course, these don't fit your narrow definitions of what application developers should be. While full-stack frameworks make more assumptions about usage and design, they are also software, which happens to be a lot more complicated than microframeworks. And as such, you can practice the the craft of software engineering and development with full-stack frameworks. Just because they appeal to a wider range of audience does not mean that they marginalize the craft of software development. 
Hello again! Just posting some updated information... I finally figured out how to make it so I can continue onward from where I loaded the background, now I'm just having trouble getting it to realize I'm pressing down keys and have it place the correct icons on the slots. Again any and all information/help is welcome! I'm a pretty big noob at this, so I'm sorry if its messy. Also have it on pastebin at http://pastebin.com/8ZvzvhQv background_image_filename = 'mastermind_empty_board.jpg' import os, pygame from pygame.locals import * from sys import exit SCREEN_SIZE = (640, 480) pygame.init() screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32) background = pygame.image.load(background_image_filename).convert() keepGoing = True while keepGoing: event = pygame.event.wait() if event.type == QUIT: exit() if event.type == VIDEORESIZE: SCREEN_SIZE = event.size screen = pygame.display.set_mode(SCREEN_SIZE, RESIZABLE, 32) pygame.display.set_caption("Window resized to "+str(event.size)) screen_width, screen_height = SCREEN_SIZE for y in range(0, screen_height, background.get_height()): for x in range(0, screen_width, background.get_width()): screen.blit(background, (x, y)) keepGoing = False pygame.display.update() def drawBoard(counters): x=0 y=0 cnt=0 for key in counters: if cnt == 4: y+=32 x=0 elif cnt == 8: y+=32 x=0 elif cnt == 12: y+=32 x=0 elif cnt == 16: y+=32 x=0 elif cnt == 20: y+=32 x=0 elif cnt == 24: y+=32 x=0 elif cnt == 28: y+=32 x=0 elif cnt == 32: y+=32 x=0 if (key == "r") or (key == "R"): #print "r" screen.blit(red_image, (x,y)) if (key == "g") or (key == "G"): screen.blit(green_image, (x,y)) #print "g" if (key == "b") or (key == "B"): screen.blit(blue_image, (x,y)) #print "b" if (key == "y") or (key == "Y"): screen.blit(yellow_image, (x,y)) #print "y" # if (key == " "): #print "nothing" cnt+=1 x+=45 counterlist=[" "]*32 red_image, red_rect = pygame.image.load("red.png") red_rect.topleft = (10,10) green_image, green_rect = pygame.image.load("green.png") green_rect.topleft = (0,0) blue_image, blue_rect = pygame.image.load("blue.png") blue_rect.topleft = (0,0) yellow_image, yellow_rect = pygame.image.load("yellow.png") yellow_rect.topleft = (0,0) count=0 while True: for event in pygame.event.get(): if event.type == QUIT: exit() if event.type == KEYUP: if event.key == K_r: counterlist[count] ="r" count+=1 print red_rect if event.key == K_g: counterlist[count] ="g" count+=1 print green_rect if event.key == K_b: counterlist[count] ="b" count+=1 print blue_rect if event.key == K_y: counterlist[count] ="y" count+=1 print yellow_rect drawBoard(counterlist) pygame.display.update() 
I'm a long-time PyDev user, but I've been trying out PyCharm 2 for the last couple of days and I have to say I'm impressed. Initially I was put off by the lengthy (and noisy on a Macbook Pro) scanning of the project, but I have to say that in comparison to PyDev it's absolutely flying when scrolling through files or opening ones that I've yet to open in the current session. I've not gone into great depth yet, I find the workspace searching isn't as fast as Eclipse and I haven't found any way of working with multiple projects within the same window (which is something I use very heavily in PyDev because a lot of my work is spread across several projects). But I am enjoying the far superior integration with Django and it seems to be more successful at recognising libraries within a virtual environment. Speaking of virtual environments, I would quite like to see both PyDev and PyCharm treat them as first class citizens. In both it feels quite clunky and unintuitive to work with them. in general though, as long as I don't come across any major faults, I'm going to strongly consider purchasing PyCharm. EDIT: Regarding multiple projects in one window, looking at the PyCharm 2 additions, it looks like it's possible, but I've not yet figured out how to use it.
So what's your suggestion. How are we doing things differently than you would?
Try the [IdeaVim](http://plugins.intellij.net/plugin/?id=164) plugin.
Interesting - so what is it built on? Pyramid? Or are you just putting together your own components such as WebOb etc...
It is still using most of the foundations of Pylons and Pyramid, like WebOb, Paste, WebHelpers etc. Only the Pylons package is not in use anymore.
I appreciate the libudev link: Its something I'm also interested in. Point.
So if its constant like that, could a coder invert it and combine it back into the original feed?
Glad I could help.
I'm planning to buy a copy soon... hope it's worth the money. How's the SFTP support?
I'm planning to buy a copy soon... hope it's worth the money. How's the SFTP support?
$100 for a commercial IDE is very good. I agree that doesn't help if you can't afford it, but it doesn't change that fact.
I hate eclipse. I need no other reason.
I'm reading: that is chock full of nerd candy. Have another point.
[This is why](http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2011-python-ides-panel-4901374). Skip ahead to about 9:30 in the video. The presenter (from JetBrains, the company behind PyCharm) does TDD and flies through the demo. This was presented at PyCon last year and I was speechless. On top of that, they ran several promos during the year offering it for only $50. And in that time, we've gotten a 1.1, a 1.5 and a 2.0 release. Well worth the money IMO, especially if you're not already invested in another editor like vim or emacs. PS--the license is good for one person on as many machines as they use, and for any platform. I double-checked with them on this before purchasing. Wing IDE offers a similar license but only within the last year or so.
Yeah, getting things to work that need compiling is a pain. Fortunately, Michael Foord provides windows versions of PyCrypto anyway.
I suggest taking a look at [Komodo Edit](http://www.activestate.com/komodo-edit). I've come to really like it a lot.
&gt;From a marketing perspective, it's absolutely true, people love one-stop shopping and clearly get very attached to brands. People don't love one-stop shopping merely because they are in thrall to some clever marketing. There are real benefits. Having a single locus of control and responsibility for a collection of inter-related modules can make it easier to set up, learn, stay up-to-date, get support, diagnose and resolve problems, request improvements, etc. Whether the benefits outweigh the costs is another question, and certainly depends on the details of the situation, but it's not all just "marketing." And it's not clear what "branding" has to do with it -- people can get just as attached to the "Pyramid" and "SQLAlchemy" brands as they can to the "Django" brand.
Before you jump in, use [Sphinx](http://sphinx.pocoo.org/).
Sphinx is the preferred solution for documenting Python. In fact the standard library documentation that I'm sure you've seen by this point is written using Sphinx. It's a fairly robust solution, you can export to HTML, LaTeX, PDF and a variety of other formats. There's little reason to use Doxygen over Sphinx when documenting Python.
Hi, it looks like white noise, so you dont have a lot of choices. The simplest is to decimate, Eg: you may configure the soundcard to a high sample rate (96khz, etc), a low pass in ~10-15khz and downsampling by six. One more tricky is to detect silence segments and null the input. Hope it helps!
Debugging worked in the previous version as well if you knew how to set up your project to launch the paster script. I've been using the v2 RC for a while and it feels much more polished and a lot of the annoyance from v1 seem to have gone away so congrats. One very annoying flaw that it still there even in the 2 release is the resolution of packages. I'm using Flask on a project with Flask-SQLAlchemy both pip installed in site-packages (win) yet pyCharm still choke on the second import with an unresolved reference error hint. from flask import Flask # this is ok from flaskext.sqlalchemy import SQLAlchemy # flaskext is unresolved I've tried reloading and removing/adding the python interpreter on the project which sometime helped in 1.0 but there was no effect. In all case, great product. It's really my preferred python IDE and you just made me happy releasing the 2.0 before jan because it means my original license worked.
Right now, I'm less concerned with signal processing and more about making the actual virtual device since I really need to get that done otherwise there's not much of a point in experimenting with noise elimination methods. After I get that working, I plan on seeing what's used in Audacity to eliminate noise because its algorithm has worked great so far.
there is also sage! but you need to install some QT library for matplotlib dynamic stuff to work 
Yes. I do like Doxygen, but I used Sphinx for a recent project and it was great
If anyone wonders about this: &gt; wx.TaskBarIcon. I assume it’s called that because the System Tray is part of the TaskBar or maybe they don’t differentiate between the TaskBar and the tray area in other operating systems. From [old new thing](http://blogs.msdn.com/b/oldnewthing/archive/2003/09/10/54831.aspx) &gt; The official name for the thingie at the bottom of the screen is the "taskbar". The taskbar contains a variety of elements, such as the "Start Button", a collection of "taskbar buttons", the clock, and the "Taskbar Notification Area".
how is "90% of all apps are served by monolithic one-size-fits-all frameworks" not a narrow minded opinion ? Common. It's all just preference. I don't encourage full stack systems to stop what they're doing and you shouldn't encourage those of us writing fine grained systems to stop either, that's all there is to it. 
I tried it out and didn't actually notice it doing any highlighting on .mako files. Maybe there's a setting I need to make, but the IDE is pretty much as complicated as Eclipse and I didn't have the motivation to figure it out.
pretty good really. caches locally there's a free trial, try it first?
Yeah, you are right, first the first ;) Maybe you could use Jack in some way with your VoIP program and then the virtual mic is free. There's pyjack ;) Audacity uses some silence detection for the noise reduction, it could be a little more complex (multiple bands used) but if it is real white noise like it looks it works just like a simple "noise floor power" on/off switch. I have some background because i did some processing courses. On winter holidays i did a "toy" implementation of a modern speech codec in python (https://bitbucket.org/san/celp_codec/).
the `flaskext` folder does not contain an `__init__.py` file, which causes this error. Create an empty `__init__.py` in that folder, and PyCharm will pick it up right away.
I tried doxygen for a project made up of bash shell scripts, sql files, and python files and came away disappointed. I will try sphinx next time. 
&gt;this is the only data structure that matters to non-theoretical branches of science, physics and engineering Bullshit.
Sphinx &gt; epydoc &gt; doxygen. I started off using epydoc, was forced to use doxygen for awhile as much of our codebase was C++, and now use mostly sphinx. Doxygen always feels like you're reading C++ documentation instead of Python docs. Using a mixed hand and auto-generated system like Sphinx is very useful for languages like Python that allow you to be too clever with modules. I end up putting a lot of my code in sub-modules and aggregating in a main module. Auto-generated documentation systems stumble over this, so hand-generated docs are the only way to make sure my users write the correct (clean) code.
FYI, fink isn't really actively developed anymore. Macports is much better maintained and has a larger database of ports.
Aye, PY-4614. Details are not visible at first glance because I first thougt it was a setting, so I made a forum post first, which is referred to in the OP. Two videos of the errors, too. Edit: Confirmed to still be a problem in 2.0 Release.
When I read about [how Haskell handles infinite lists](http://learnyouahaskell.com/starting-out#texas-ranges), I was stunned - it's very elegant. [2,4..] will produce an infinite list of even numbers.
Unfortunately it is true for the most part. Many, if not most physicist have no idea of algorithm complexity analysis and just use what is most intuitive to them, ending in horribly inefficient code. 
You can put the code of next() in \_\_iter\_\_(), replace "return" with "yield" and throw out the StopIteration exception for shorter/cleaner code. Also, think about if this really needs to be a class. Seems like a generator would do just fine.
Sorry, but those introductory sentences are just stupid. Are you going to tell us "non-theoretical branches of science" won't ever look something up, for example? This would require the implementation of a map, for instance by using a hash table or a tree. Let alone the call stacks and tons of other aspects of how the python interpreter itself works and... sorry, the bottom line is just that that statement is incredibly stupid and in no way based in reality. Also, how are iterators and generators "data structures" anyway?
thanks.
A problem with the subscription model is that in this case, some bug fixes are only provided in the upgrade, e.g. [PY-4614](http://youtrack.jetbrains.net/issue/PY-4614) was noted as fixed in *the upgrade*. IOW, if you have a valid license where the subscription upgrade ended in November, you won't get the fix. (All that aside, it isn't fixed AFAICT, and it was reported in September—kind of disappointing when it is a complete showstopper for me)
I've reopened the issue; we'll investigate this further. Sorry for the trouble.
You can do it in code as twotime has said, or you can set it globally for your environment by setting environment variables.
When you open a project and have another open open already, you get a dialog asking whether you want to open it in a new window, replace the currently opened project or open both in the same window. Note that it works only when you do "Open directory", not "Reopen".
This is a known issue: http://youtrack.jetbrains.net/issue/PY-4769 We'll try to get a fix in for 2.0.1.
I made the mistake of converting a project for which I already had a good start at documentation into doxygen. My sad conclusion is that doxygen is an excellent tool for not writing documentation.
Thanks, Dmitry! (I actually thought that the issue would have been automatically reopened when I commented on it, especially since Yulia replied)
There's absolutely nothing wrong with that if it gets the job done. "idiomatic" python is more often than not horribly inefficient.
If you've used a previous version, you may have assigned the .mako extension to the plain text file type. The highlighting (and all other features) should work if you assign it to the correct file type under Settings | File Types.
How does Pyramid stack up against Flask? Is it a fair comparison (both being micro frameworks) or am i missing something?
Thanks for reporting it.
I like the idea, but it bothers me that the query interface changes depending on whether there's a fragment or not. &gt;&gt;&gt; url = furl('http://example.com/abc?username=fred') &gt;&gt;&gt; url.args['username'] 'fred' &gt;&gt;&gt; url = furl('http://example.com/abc#frag?username=fred') &gt;&gt;&gt; url.args['username'] KeyError: 'username' &gt;&gt;&gt; url.fragment.args['username'] 'fred' I can see that getting frustrating quickly. But overall, it looks awesome.
This is infinity and constant memory usage too: k=0 while True: k+=1 And this is neither generator or iterator. And can deal with infinite lists of data as well. 
Komodo Edit is pretty good. You can define your own functions easy enough.
It comes down to mutable data. You're passing the object by reference, which in the function it will use the mutable data structure by-value and mutate the object that the reference points to. Essentially, lists will get passed by-value, but because they mutate in-place, the reference to the whole list is to the same *container* but the objects lying underneath change.
NP :) It's a complete showstopper for me that I wish that I'd tested for before I purchased it. I just went by reviews, ran some random script pieces and purchased. 
I'm not real sure about the definition of microframework these days, but it's not our intent to advertise Pyramid as one (others in the comments here have asserted it is, but it's really not). Assuming it's possible, Pyramid's just a web framework. That said, Pyramid and Flask are pretty similar. I think you'll just have to try both to get any credible sense of how they fare against each other in some sort of comparison.
It's true that the "only data structure that matters" comment is silly, but the rest of the article is good. Those interested in this topic should be sure to see Beazley's [article](http://www.dabeaz.com/generators/).
There is absolutely something wrong with that. Their computing clusters could be used much more efficiently, saving much energy. A professor at my university is devoted to teaching how to use the damn machines efficiently (maximizing utilization of all CPUs) because of environmental concerns.
it was something about having to fork your company's project and do a pull request because PyCharm couldn't manage those kind of repos... that's the best i remember :)
If you mean HTTP authorization in Git, it's now supported.
Iterators... the complex alternative to a while loop and a counter....
If you mean HTTP authorization in Git, it's now supported.
At nowhere did I suggest that there's no place for microframeworks and for you guys to stop doing what you are doing. I am only advocating for full-stack frameworks, saying there should be more of them. &gt;how is "90% of all apps are served by monolithic one-size-fits-all frameworks" not a narrow minded opinion ? Not one-size-fit-all but one-size-fit-90%. There's a huge difference. 90% of your needs may be feasible, but the law of diminishing return kicks in for the last 10%. In any case, you might say that such full-stack frameworks reflect a narrow mind, and I disagree. To each of his own.
Hopefully, it gets fixed. I voted it up.
I'm not sure I understand your question. I don't have any suggestions for microframeworks. I only wish there are more full-stack frameworks. If these are based on Pyramid, Bottle, Flask, great. Give us better solutions. That's all I'm saying
We are talking about "traditional" server-side apps. If you turn to client-side apps, frankly there is no incentive to use Python for the server-side services. Things like node.js provide much more attractive solutions for simple server-side tasks. So, if this is what you are talking about, then I'm afraid all of the Python frameworks (micro or otherwise) become increasingly irrelevant.
Like any concept, it is complex when you first learn it, but simpler in the end.
Show me your elegant while loop to iterate over a N-dimensional ball. Iterators are often overkill. Sometimes they are not.
Wouldn't that just be nested while loops? I am not saying that there are not instances where iterators make tidier looking code. I am just pointing out that we have increased total system complexity in a way that does not provide extra functionality.
"extra functionality"? As soon as something is turing complete, nothing will add "functionality" (as far as we know). A turing machine itself is, by definition, turing complete, yet somehow people prefer languages that are just a leeeettle bit more comfortable to program in. If "adding extra functionality" was what developing languages is about, we could scrap the effort altogether because that stopped a lot of decades ago. (And iterators add tremendous benefits, like not having to take care about possibly unknown internals of data structures.)
What do you find better in Wing for debugging comparing to PyCharm?
Fine. Then: ... I am just pointing out that we have increased total system complexity in a way that does not provide extra functionality *that is otherwise trivially available*. 
You definitely need to talk to some scientists who do serious programming if you believe that infinite lists are the only data structure that matters to non-theoretical branches of the sciences. Your statement is ignorance which should be hidden in a dark closet, not paraded around as if it had meaning.
Would it be too bad if I say that you can get the same with Eclipse/PyDev for free?
"thumb up" only here since i can't by now in stackoverflow (newbie there). Excellent explanation.
&gt;Wouldn't that just be nested while loops? I'd love to see your code! input: n is the dimensionality, r is the ball radius (both parameters set at runtime) :) I'd don't doubt you'll manage to do it, but when you have to do this over and over again, abstracting the iteration logic and putting it all in one place with no duplication is very helpful.
I tried to follow the link you supplied but unfortunately the blip player does not allow me to skip ahead (possibly because I am using 64bit flash)
Try to avoid or correct the [top 10 issues](https://www.owasp.org/index.php/Top_10_2010-Main) as defined by the OWASP.
I was aware of this too but again, it reassured me that it isn't in any way comparable to the difficulty of learning a new language.
And I disagree. I really don't want to write code to iterate over a tree over and over again. Hmm. Maybe you could just write a method that gives you the next element upon each call? That would solve the problem. But now you can only iterate once at the same time over the same tree, so better wrap it in its own object. And wouldn't it be cool if such objects were instances of a common base class (or, in duck typing terms, just had common method signatures) so that it wouldn't matter over what exactly I'm iterating? That's especially useful if something else wants to actually iterate, so that we can just pass the object. Oh, we just invented iterators! Every modern language has iterators of some kind available. Java has it as part of the collections framework, C++ has them as part of containers in the STL, even Haskell, which follows different paradigms, has type classes like Functor that give you this kind of "I just have a bag of things and want to do stuff to it, no matter what the bag looks like" abstraction. Python has support in the language itself which, in my opinion, fits its paradigm pretty well. It was never shy of adding stuff to the language if it is warranted. You may well argue about how python gives you that abstraction, but I do not think you can argue that the concept itself is too trivial to warrant an abstraction.
Could you give us more details? What's the contest all about? What services will be written? 
Memory usage isn't constant.
hm I don't see "mako templates" or "jinja templates" in the "file types" dialog (screenshot: http://i.imgur.com/H3xKE.png ) , does this type need to be added ?
That won't really be true until someone makes very popular a server-side JavaScript framework that you can write synchronous code in. Writing async code when you don't have to pretty much sucks. And even then, even if becomes a no-brainer to use JavaScript on the server side too, it will be many years before everything else becomes irrelevant.
OK, so violent agreement as to what we're doing then?
Writing as a user of IntelliJ Ultimate 10, what is the release timeline looking like for the updated plugin and will I need to upgrade to version 11 for that? With the release of 11, will the plugin lag behind less?
I noticed, thanks :)
Sanitize input, don't use third party libraries unless you have to, never run processes as root, setup anything you run in a container or vm and harden that instance, use physical separation as security where you can.
goodie, goodie :)
That was a really interesting link. Thanks for sharing. I think I'll have to get active on stackoverflow now.
It's probably going to be a bit like the (cipher ctf)[http://www.cipher-ctf.org/rwth-ctf.php?edit=0&amp;include=rwth-ctf.php]. The services have to accept flags (special string tokens) and store them as long as possible in files while the game server is going to ask the service for the available flags. When you have flags you gain defense points while you can also gain offense points by stealing other teams' flags.
Keep an eye out for the pickle module.
Thank you very much. I didn't know them!
The updated plugin is already available. It's compatible only with IntelliJ IDEA 11, not with previous versions. The releases of the plugin are typically synchronized with major releases of IntelliJ IDEA. This happens because the PyCharm code uses new features of the IntelliJ Platform as they appear, and we're unable to backport the new features to older releases of IntelliJ IDEA.
Regarding the first answer there, as it seems to be the one you had in mind. &gt; So, a metaclass is just the stuff that creates class objects. &gt; That's it. There is really nothing more about metaclasses. This is false. This is a tiny part of what a metaclass is and does. Because, similarly, an ordinary class is not "just the stuff that creates objects", it is the stuff that also provides implementations of most methods of an object, and the only stuff that can provide implementations of several special methods (such as `__str__` and `__len__` etc for performance reasons, plus stuff like `__getattr__` to avoid the thing aptly named "metaclass confusion"). For all its apparent simplicity, Python's object model is much more complicated and just as quirky as the one of C++, in my opinion. I'm too lazy to try and document it, so instead I offer you a challenge: write a class `Function` which behaves exactly like the built-in function type. So that you should be able to do this: class Cls(object): pass o = Cls() Cls.f = Function(lambda self: 'assigned to the class') o.g = Function(lambda: 'assigned to the instance') print o.f(), o.g(), Cls.f(o) And they should behave just like if you assigned the lambdas directly. Without cheating: implement `__call__` and call the stored function from there. Bonus question: if you manage to do this, you will notice that you still can't call `Cls.f(None)`. As you shouldn't, but if you wanted to allow that, what else should you override? As far as I know this stuff is totally undocumented (and you'll never know how to find the parts that are kinda indirectly documented, unless I tell you to pay attention to the fact that lambdas implement `__get__` for example). So download Python sources, get a decent C code editor (like Vim + ctags), and start digging. The starting point should be `Python/ceval.c`, then you'll have to examine `Objects/classobject.c`, `Objects/funcobject.c`, `Objects/typeobject.c`, and the corresponding headers from `Include`. After doing that you should have a pretty good idea how Python classes actually work, which directly translates to the understanding of metaclasses, though they have some quirks of their own (there's some really weird shit going on when you use a function for the `__metaclass__`, but then pass a proper class (obviously, different from your function) as a metaclass to the `type` invocation there. And I actually had to do that once, because it produced the effect I wanted). Good luck, have fun.
&gt; The following is discouraged and is possibly fined with negative scores: &gt; Filtering connections based on the connection layer is not allowed (regardless of IP-anonymization). Welp, there goes my first suggestion. [secretiveslave](http://www.reddit.com/r/Python/comments/ncki1/secure_python_programming_hints_anyone/c382ez1) has good suggestions besides not using third party libraries. Use *trusted* and *tested* third party libraries, and use them quickly. For example, I'm imagining that you'll get a web service which is vulnerable to SQL injection. Instead of fixing the vulnerability yourself, rewrite the service using sqlalchemy or another library. It'll be faster to write, and production ready libraries will (in most cases) be better than throwing something together yourself using only standard lib tools. 
By third party libraries, do you mean ones provided by the organizers of the event (which are most likely purposely flawed) or any third party libraries? 
Both really, I wouldn't use their libraries just because they are made available unless part of the challenge requires you using them.
&gt; But the root of the problem is clear: Python is happily reusing arrays as it sees fit. No it is not, and you should not be writing this nonsense if you don't know the root cause. &gt;&gt;&gt; m = 4*[2*[2, 3]] &gt;&gt;&gt; ["%x" % id(r) for r in m] ['7ef45b8c', '7ef45b8c', '7ef45b8c', '7ef45b8c'] What you've got here is four instances of the same row, not four different rows. Using the `*` operator to repeat a list performs a shallow copy. When you modify one, you modify them all: &gt;&gt;&gt; m = 4*[2*[2, 3]] &gt;&gt;&gt; m[0][0] = m[0][0] * 42. &gt;&gt;&gt; repr(m) '[[84.0, 3, 2, 3], [84.0, 3, 2, 3], [84.0, 3, 2, 3], [84.0, 3, 2, 3]]' If you want a deep copy, then: &gt;&gt;&gt; from copy import deepcopy &gt;&gt;&gt; m = [deepcopy(2 * [2, 3]) for r in xrange(4)] &gt;&gt;&gt; ["%x" % id(r) for r in m] ['7ef45b8c', '7ef4554c', '7ef41cac', '7ef45aec'] &gt;&gt;&gt; m[0][0] = m[0][0] * 42. &gt;&gt;&gt; repr(m) '[[84.0, 3, 2, 3], [2, 3, 2, 3], [2, 3, 2, 3], [2, 3, 2, 3]]' And now the original `scale()` works as expected: &gt;&gt;&gt; m = [deepcopy(2 * [2, 3]) for r in xrange(4)] &gt;&gt;&gt; fmt(scale(m, 0.5)) 1.0 1.5 1.0 1.5 1.0 1.5 1.0 1.5 1.0 1.5 1.0 1.5 1.0 1.5 1.0 1.5 All of this other nonsense about needing to use Numpy or generators stems from a lack of understanding of a shallow copy. You can absolutely write a `scale()` that does `matrix[r][c] = factor * matrix[r][c]`, there is nothing wrong with that. 
Is that thing real? If so, it is beyond awesome. I want one NAO. 
Here's how I've done it: Preferences &gt; Settings &gt; Template Languages and select Mako, then add the template directories. [That's it](http://i.imgur.com/AZYH0.jpg). You don't need to do add any file type. 
bwahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahaha wait wait...... hahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahahahahahahahahahahahahahahahahahahahahahaahahaha +1
Thank you very much! I'm working with it right now, and it seems like this would be what I'm looking for!
Never trust any input you receive regardless of its source. Check it and beat it into something safe. If you can't beat it into something safe then reject it. If you write input sanitizers first then you buy yourself time to check or replace the rest of the code.
If you can muster up the energy, please continue. This is fascinating, I've never noticed these dark corners before.
Beautiful! This is exactly what I need, after about an hour, I can now extract the most recently viewed youtube video. Thank you so much!
This *is* a sort. Using 'sorted' in a sort kind of defeats the purpose. Since it's a sort it can't return a set, which is unordered. The list comprehension above is correct for this purpose assuming possibleValues is in order itself. Notably there is a flaw in that duplicate values will only show up once in the result; but that's unimportant because this was meant to be an example of a non-comparative sort, not an actually valid implementation.
One liner: import sys; print (lambda words: [word for word in words if len(word) == max(map(len, words))])(filter(lambda line: not [char for char in list(line) if list(line).count(char) &gt; sys.argv[2:].count(char)], map(lambda x: x.strip(), open(sys.argv[1], "r").readlines()))) Could be slightly more efficient, but it's still better than solutions that use itertools permutations. 
&gt; This is false. This is a tiny part of what a metaclass is and does. It's false, but it's a good starting point. (The Earth isn't round, but that's a better place to start than the Earth is flat.) "Metaclasses" sound really scary and incomprehensible. If you start by explaining, "Hey, you know how classes make objects? Metaclasses make classes," it makes it seem more approachable.
These are the three functions I wrote. This is written for linux, but with a little editing of get_path, you can make it cross platform. Using get_data(path) will return a two dimensional array of your browsing history, with the first spot being time and date, and the second spot being the website. It's arranged by time, so I ignored the time and date, and just started at the end of the array and worked backwards. get_link() searches backwards from the end until it finds http://www.youtube.com/watch, and then returns the whole string. So this can be edited for whatever website you were interested in. import os import sqlite3 as lite import sys def get_path(): #Returns the path of the firefox database #Set the firefox database path path = "/home/" path += os.listdir(path)[0] + "/" #Move into the users home folder path += ".mozilla/firefox/" #Move into the firefox profiles list for item in os.listdir(path): #Find the profile and move into it if item[(len(item)-8):] == ".default": path += item + "/" break else: continue path += "places.sqlite" return path def get_data(path): #Returns the browsing history as a two dimensional array con = None con = lite.connect(path) cur = con.cursor() cur.execute("SELECT datetime(moz_historyvisits.visit_date/1000000,'unixepoch'), moz_places.url FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id") data = cur.fetchall() return data def get_link(data): #Returns the address of the most recently viewed youtube video data_end = len(data) - 1 pos = data_end link = "error" while pos &gt;= 0: if data[pos][1][:28] == "http://www.youtube.com/watch": link = data[pos][1] break else: pos -= 1 return link path = get_path() data = get_data(path) link = get_link(data) print link Now what I have to figure out is how to get the .flv address from youtube. I've been reading a ton of different stuff, and I can't seem to get a working guide. EDIT: Fixed the formatting
What's your skill level?
My brain just exploded from the amount of possibilities..I head over to their website to see about developing and they have a check box for "buy a nao(become a developer)" ...I wonder how much they are!
GIGO But that scale function itself did cause me physical pain. That ``len(matrix[0])`` business is worrisome
Does that make much of a difference?
If you get selected for their developer program, it's $3909*. A comment on their [TechCrunch article](http://techcrunch.com/2011/12/12/the-nao-next-gen-bot-will-be-your-friend-when-no-one-else-will/) the other day has a comment stating their previous model cost $12,000 (no idea if this is accurate). \*Source: their profile on [https://us.pycon.org/2012/sponsors/](https://us.pycon.org/2012/sponsors/).
The question is too general. I don't know what you're really looking for. What makes a good API usually has little to do with the structure of the code -- I mean, standard rules apply, right? Write clear, idiomatic code and document it. For someone who is experienced, that's just a given. If you're new to Python, though, or new to programming, maybe it isn't. Not assuming anything, my answer is this: A good API wrapper (whether its a wrapper to a web API or a C library) has two key features, both of which are unrelated to the structure of the code: coverage and maintenance. The two worst things about API bindings (in my opinion) are when they don't implement a critical feature (or can't easily be extended to implement it) and when they're deprecated because the web API went through a backwards-incompatible change and the maintainer is AWOL. 
To consume web API you can use [requests](http://docs.python-requests.org/en/latest/index.html). It's a library to make clean http requests.
&gt; What you've got here is four instances of the same row, not four different rows. Yep, I know, and that's exactly what I meant by "reusing arrays as it sees fit". Clearly not the right choice of words, duly noted and corrected. The part I don't understand, though, is why is it 4 instances (the four rows), and not 8 of the original [2, 3] array. I would have expected it to apply the scaling 8 times, and not 4. As for the deepcopy and shallow copy, yep, sure. But you should not expect the user of your function to know about it. Using numpy is better and faster. You are wrong in the last account, writing a scale() function that modifies a matrix in place is not a good idea, as I clearly have not been able to convey in my article. 
looks a lot worse than xml.etree or lxml none should be using the xml.dom.minidom apis these days in new code
I think the problem is that explanation could have been given by anyone who didn't know shit about python by just looking at the word "metaclass", so it's really not very useful.
&gt; It's designed to be lightweight and easy to distribute for projects where using more fully featured libraries like ElementTree or lxml doesn't make sense.
etree is in the stdlib since 2.5 
Speaking of the debugger, is there any chance that you will include the 'Evaluate Expression' while stopped at a breakpoint? It is a pretty critical feature I use in IntelliJ all day long and miss big time in PyCharm. Thank You!
_You_ continue. I told where to look and gave a concrete goal to achieve, now it's all up to you! =)
I did not know that. I don't really like namespace handling in ElementTree though. To each their own.
Exception handling :)
You can use the command line of the debug console for interaction. It also has code completion.
Honestly, if somebody is new to Python metaclasses, the SO explanation is excellent, and your explanation is an undecipherable mess. Not because your text is bad, but because metaclasses are a new concept; if you're going to wrap your head around it, you need it explained in very simple high level terms, with lots of examples of why it's useful, before you're ready to dig into the details. I don't mean to criticise your writing style, for somebody who fully understands the explanation given on SO, your post here is a good springboard to jump to the next level of understanding, and you're actually a decent writer. But your post reeks of an «that explanation simplifies some key concepts, ergo it is wrong, ergo it is useless»-attitude, which is a pretty common attitude among techies and it _completely_ misses the crucial point about how people actually understand new things.
&gt; and your explanation is an undecipherable mess. ... Are you guys reading something other than my post? What "my explanation" are you talking about, that one paragraph where I say that he is wrong because classes not only create instances but also provide methods, and so do metaclasses (for classes)? Because nothing else in what I wrote is remotely close to an "explanation"! What the fuck is going on? I mean, I've been in a lot of arguments, but this is the first time people discuss and critique my explanation when I have not written one in the first place, _and even mentioned that I'm too lazy to write one!_ Are you guys huffing paint thinner or something?
That thing I'm trying to criticise you for is that the SO dude make a simplified high level explanation of metaclasses and you reply by saying «Well, actually *minor missing technical details*]». It's not constructive. It's not useful information. The SO dude most probably knew everything you said but he chose to skip some details that are not important when gaining a high level understanding of the concept. His explanation was better for it. You pointing those things out makes you sound less like a knowledgeable user that is trying to help other people understand Python and more like somebody correcting other people just so s/he can sound smart.
True. It is O(log(N)).
@Rhomboid: I think you missed the point: it is not surprising that the copy is shallow (this is simply a design decision of the * operator on lists), but the fact that 2*[2,3] does not give you two shallow copies of the single list [2,3], while 2 * [[2,3]] does. Actually the python documentation states: s * n, n * s: n shallow copies of s concatenated so it is clear that 2 * [[2,3]] gives you two shallow copies, but to know that 2*[2,3] does NOT, you have to know that concatenating references to the same list gives rise to elementwise copies. This sure looks like the most plausible way (mainly because the list class would be much more complex on the level of implementation if it weren't, it would have to store its data subdivided in sublists/slices), but certainly it is not the only way. 
One thing that's suspicious is that you're trying to emit a "finshed()" signal for a vanilla QObject that does not have that signal defined (unless I missed it somewhere). I'm not sure how you do this in PyQt but in PySide it would be something like: class MyObject(QObject): finished = QtCore.Signal() def notify_finished(self): self.finished.emit() def on_finish(self,callable): self.finished.connect(callable) Are you positive that the "finished()" signal is actually being emitted/received?
I'm positive. The work actually gets done, it just doesn't do it when I *want* it to be done and it hangs the GUI thread whilst it's NOT doing it. I'll try it your way and see how it goes.
The author is not missing "minor technical details". The author makes a completely false assertion -- that there's nothing more to metaclasses than class creation. In fact I've seen people claiming just that, that after a class has been created, it doesn't interact with the metaclass any more, so it's a somewhat widespread misconception. I'm all for gentle introductions to the subject. But as gentle introductions go, they should not give factually incorrect information. One can do any amount of hand-waving they want, *"That's not the only function of metaclasses but the most widely used, so I wouldn't go deeper for now"* is perfectly OK, *"That's it. There is really nothing more about metaclasses"* is unacceptable and, most probably, is a result of the author's extremely shallow understanding of the subject. Then, yeah, what I did was not "constructive". I did not supplement the missing parts of his explanation (because explaining those "minor details" would take about twenty times as much time as his explanation, at the same level of newb-friendliness). Instead I set up a challenge to serve as a guidance and basically told everyone interested to go and read the sources of the fucking interpreter, which is as newb-unfriendly as it gets. How the hell have you managed to mistake that for an explanation (albeit "undecipherable", LOL) -- I can't rightfully comprehend. I suggest that you stop wasting my and your time and go do something useful. For example, try to complete at least the first part of my challenge, that will greatly increase your understanding of Python and allow to have a more substantiated opinion regarding the "minority" of certain details.
With alsa there is a file plugin. See: http://www.alsa-project.org/alsa-doc/alsa-lib/pcm_plugins.html Search for "Plugin: File" Also consider the kernel module: snd-aloop http://www.sm5bsz.com/linuxdsp/install/snd-aloop.htm 
Just to show you, you can make a `QObject` emit whatever you want, there needs to be no pomp about it. http://pastebin.com/WNpNr4uV - ignore the erroneous imports, I'm being lazy. You can see that `whatever_jizz_jizz()` is emitted because `LOLSIGNALS` gets printed.
WTF IS THIS SHIT indeed? self.cls.deletions.append( str(self.cls.single_output_dir + "\page%s.pdf" % i).replace('/', '\\')) output_stream = open( self.cls.single_output_dir + "\page%s.pdf" % i, "wb") self.work.create_job( '"' + str( self.cls.single_output_dir + "\\page%s.pdf" % i + '"' ).replace('/', '\\'), # WTF IS THIS SHIT str('"' + self.cls.single_output_dir + "\\page%s.tif" % i + '"').replace('/', '\\'), self.cls) # WTF IS THIS SHIT should be page_pdf = "page%s.pdf" % i page_tif = "page%s.tif" % i out = self.cls.single_output_dir self.cls.deletions.append(os.path.join(out, page_pdf)) output_stream = open(os.path.join(out, page_pdf), "wb") self.work.create_job(os.path.join(out, page_pdf), os.path.join(out, page_tif)) and self.gscriptpath = '"' + os.getcwd() + r'\gs\gs9.02\bin' process.start(' '.join([.... should be self.gscriptpath = os.path.join(os.getcwd(), r"gs\gs9.02\bin\gswin32c.exe") process.start(self.gscriptpath, ['-q', ...]) 
Fair enough. I knew that QObjects have support for dynamic signals, I've just never used them in this way. 
Learning Scheme would be good for you. It would make you use different parts of your brain and bring a new light to some dark corners in there. You could then have a look a some of the most [influential programming books](http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read) ([here](http://www.codinghorror.com/blog/2004/02/recommended-reading-for-developers.html) is another interesting list). You could get involved in an open source project you like or start your own. Make a simple game. Start an application which you will actually use and which will help you out. To me programming is similar to a craftsmanship. The more you practice, the better you get.
Indeed. You can read comments, congratulations. This thread is about multithreading. The comments are there to remind me to go back and fix it. It works, and I'm not entirely bothered about that until the actual *real code* is working.
It's really quite useful if you just want to make sure that a specific function gets called when a specific thing happens.
I wrote a [command-line interface](https://github.com/jsmits/github-cli) for the Github Issues API. Maybe that can get you started.
This has always been supported. What exactly doesn't work for you?
It's possible that GIL contention is preventing the UI thread from running your slot call. This is just a shot in the dark because as far as I can tell from skimming your code everything seems at least conceptually ok. If the signal is being sent then it should be waiting on the UI thread's event loop for processing when control returns to the UI thread. The only thing I can figure is that for some reason the UI thread is blocked. This is just wild speculation though, because I have no idea about PyQt internals (I've always used PySide), specifically, how the bindings manage the GIL/threadstate. You could try yielding the worker thread after each page is processed to see if that helps?
I'll try it. Does PySide have it's own version of `QtGui.QApplication(sys.argv).processEvents` ? This is what I was trying to use to automatically get it to process all the events that had been put in it's event loop. I do have a previous version that was updating the thread properly, I just needed to use `QRunnables` along with their `QThreadPool` for thread handling, queueing and other really nice features. It seems there is something that I'm missing here.
The first thread you linked to has cost me so much money. SO many good books. As for the scheme idea, don't you think something like Clojure would be better? The syntax is the same for the most part except some parts of it are way better. For example: (defn function [arguments] (body)) That's beautiful!
I can't help but be reminded of the old adage... A good C++ programmer can code C++ in any language. From reading that code, you should be posting this to a Qt forum, not a python forum. The help I will offer, is that your assumptions about pythons threads are flawed. Here's my Python 101 Gui + threads + doing heavy lifting. Spawn the Gui in the primary thread, and do no work at all in that thread more complicated than a print(). This is just basic GUI coding practice, every cycle you spend doing work in a callback from the GUI, or in the same thread as the GUI, is time the GUI is sitting there looking like it's crashed. Every Operating system released in the past 5 years will grey your application and tell the user that your program has crashed (or the more vague "is non-responsive")if you try to do work in the GUI thread. Don't use Python's threading, use Pythons Multiprocessing, as it works. 
Closure is the new kid on the block, but if he likes MIT's OpenCourseWare and there is one course on Scheme and none on Clojure, I say go for Scheme. Moving to Clojure afterwards if needed would be easy anyway.
Well, take care about input(), because it goes through eval(), so it could do nasty things: __import__("os").system("rm -rf *") bai, files~~
I don't see where my main GUI thread is doing anything *more* complicated than a `print` statement, point it out so I can look over where I can improve.
Looks like XPATH.
That's a nice gift. Thanks.
&gt; Does PySide have it's own version of QtGui.QApplication(sys.argv).processEvents I'm not sure what you're asking here. PySide is (or at least was in the past, and still is AFAIK) API compatible with PyQt. 
I'm not sure myself, I was just throwing it out there in case you knew an alternative to that method. It clears the event queue by processing all events in it afaik.
Yes it has the *processEvents* method. However, calling *processEvents* only processes events for the calling thread (i.e. you can't call it from your worker thread to have it process events for the UI thread) so if your UI thread is being blocked for some reason that won't help you.
Hey now, *sometimes* it works from the main thread ;) It's the only way (at the moment) I can get it to kind of unblock. Eh, I'm playing with it now and I've been staring at the same damn blocks of code for like 6 hours and I'm starting to go crazy. A quick walk and I'll clear my head of it. What do you think to the the locks in the `update_progress_bar` method? Are those required?
@Rhomboid: Why make deep copies when using list comprehensions? What you're doing is functionally equivalent to m = [2 * [2, 3] for r in xrange(4)] (well, I didn't check yet, but as you're creating the entries in the list comprehension itself, I don't see how the entries of m could possibly be shallow copies of one and the same element (the first?) in a natural way).
I don't know what locks you're referring to, I don't see any locking being done in the code you posted. Also, all those calls to *processEvents* are unnecessary. Events will be processed automatically once control returns to the main event loop, and you're not running any long running operations on the UI thread anyway, which is what you want. As a general rule *processEvents* is a method you almost never need to call unless you know what you're doing.
There is *one* place in the code that it really needs to be used. If I take it out before starting the threads off (*before* threads have even started) then the `self.gui.progressBar.show()` method never really takes any effect. As for the locks, I think my local repo is further than what I posted, I can't remember when I added them, it's all a blur haha. I know what processEvents does, why do you think you shouldn't call it unless you know what you're doing?
Thanks for the idea of getting some programming books. Christmas is fast approaching and I haven't given anyone present ideas yet so maybe I'll ask for some of these.
&gt; There is one place in the code that it really needs to be used. If I take it out before starting the threads off (before threads have even started) then the self.gui.progressBar.show() method never really takes any effect. This is related to the problem of your UI thread being blocked. When you make the *show()* call it doesn't show anything immediately but places events on the event queue that will be processd the next time control returns to the UI event loop. The reason it doesn't work (currently) is that your UI thread seems to be blocked and thus the show call doesn't actually get processed until the UI thread becomes unblocked (which currently is after all processing is already) done. If the UI thread was running as intended (expected) then it would be superfluous. I.e. it's only necessary because something (more insidious) is going wrong. &gt; I know what processEvents does, why do you think you shouldn't call it unless you know what you're doing? The whole point of the event loop is that it handles processing of events for you. If you're constantly making calls to *processEvents()* you're not using the event loop correctly/as intended. The only exception to this is when you're doing some long-running operation on the main UI thread and you want the UI to remain responsive. Calling *processEvents()* is just manually returning control to the event loop. So typically you either: 1) combine work on the UI thread + *processEvents()* in a tight enough loop that the work being done is transparent or 2) offload the work to a background thread so that the control returns normally (quickly) to the UI event loop and UI event processing can continue as normal You've opted for the threaded approach (usually superior) so it's superfluous to also be calling *processEvents()*. 
There's a bit of overhead in using defer.inlineCallbacks, rather it may be faster to simply return defer.succeed(connection) 'nd if it raises an index error, return a deferred that fires when a new connection has been made, as I'm assuming there is already a function that returns a defer when you tell it to connect.
I had a thought. You could try removing the finished() signal emission (or any other Python callbacks that might be waiting on the event queue) and see if the UI becomes responsive. If this is the case then it's almost certainly a GIL issue. 
What I mean, is that, as far as I can see - all the work *is* being done in another thread. It's not at all inconceivable that I'm missing something here or just *thinking* a certain segment is threaded. As for the the only (from my perspective) real use of the `processEvents`, I'm not sure if you've run it/tried to play with it. But you'll see that after it creates the window, it does nothing. The only processing in the GUI thread is when the `convert` function is called (like I said, as far as I remember how I coded it). During the `convert` function, it just enumerates a pdf document and starts a thread that *then* creates all the other threads. I thought this was standard for when you make &gt;a few threads, to create a single thread which starts another group of threads. What I am saying is, there really shouldn't BE anything in the event loop unless reading a file from an SSD is slow and blocks the GUI thread completely. Really, read all the methods. Everything executed in `main.py` is in the GUI thread, anything else is from `mthreading.py` and is executed outside the main GUI thread. I'll try moving the disk read/pdf enumerate since that's a library call and *could* be blocking. EDIT: If you have a bitbucket account I'll grant you read access to my repo. If you want??
I did find fishdicks' post useful in showing that there is something more to metaclasses than the SO answer leads you to believe. Especially the challenge and the hint. He didn't explain it fully, which could be frustrating, but it still presents something useful.
Thank you for the challenge. Here is my attempt: http://paste.pocoo.org/show/521374/ I don't think I would have got it without your hint about `__get__`. Is it right that `__get__` is where the bound vs. unbound method distinction is made? Also, when I run `Cls.f(None)`, I don't get an error, it works the same as `o.f()`, is that right? 
I'll give it a go, if it's a GIL issue, reckon I could just offload the image processing to a C-extension? EDIT: It still does freeze it, I'm not yet convinced it's a GIL issue (I lack experience with the GIL.) can you give me a solid reason to believe you and not go off on a rampage and waste my time trying to track down a non-existent issue when it's the GIL fucking me over?
I'm not convinced it's a GIL issue either. I was just trying to offer a possible diagnostic method to narrow down the causes. The only thing that makes me think it might be a GIL issue is that I've had some similar weird things happen to me when using Python + Qt in the past that I was eventually able to track down to GIL contention issues. Although, those typically present as things running painfully slow, not outright blocking of a thread.
Ok. So, overall, I've got five threading classes. One of them only ever holds a single thread, another can *create* multiple threads but they get started five at a time. The others create a thread of each other. So adding that up there are around 9 active threads and 4+len(pdf pages), do inactive threads count?
&gt; What I am saying is, there really shouldn't BE anything in the event loop unless reading a file from an SSD is slow and blocks the GUI thread completely. When your "finished()" signal is emitted the slot must be invoked on the UI thread because the receiver object (your MainWindow) lives in the UI thread. When you emit the "finished()" event from the worker thread it won't call the slot directly because it will cross a thread boundary. Instead, it will defer the slot call to the UI thread's event loop to be processed the next time the UI thread begins processing events. My only thought was that this Python callback waiting on the UI thread's event queue could be blocking the UI thread if it's having trouble obtaining the GIL. No other events can be processed until it obtains the GIL and runs your Python callback which would, in essence, be blocking the UI thread. Like I said before I have no idea if this is actually what's happening, it's seems plausible and I'm just trying to offer some suggestions. 
What did it used to be? And what does this affect exactly?
No, it blocks with the signal disabled. Please don't tell me this is the GIL, I've got like 9 active threads.
I'm not telling you that it is. I was only giving my reasoning for why I thought it might be. But if other threads are executing, then yes, it's highly unlikely.
It used to be 80 MB (upgradable at extra cost), and was the memory quota available for long-running applications such as Django sites.
Phew, I really didn't want to have it be the GIL. Thanks.
Sigh. So much misunderstanding on both sides. Niknuiq, Fas2, you both kind of missed the point. 99% of real world embedded programming (and a large part of non web/crud programming) is about processing continuous streams of signals. Data structures don't matter for this. (Cross off everything that ever allocs new memory for example.) Keeping the complexity low and memory use constant so that a process does not fail is the most important aspect. I love using crazy data structures. I do so any chance I get and do frequently in my own FOSS projects. I've read through 20% of the 4 GB of papers I've accumulated from HN and proggit and maybe have made toy implementations of a third of them. But (as an embedded programmer) this stuff never comes up.
WebFaction you are the bomb thank you
Thanks I fixed it. I doubt the overhead is really measurable but it makes the code even easier. :)
As someone who's been dealing with some much pain due to sites going down due to processes being killed for lack of RAM, THANK FUCK FOR THIS!!
Aye but if you had multiple processes etc, with gunicorn, it ran out quickly if you had a cron job that peaked or something.
That little?
I contacted the support about a year ago about a not properly working debugger and find usage functionality via the forum and filing a bug. The issues havn't been solved since today. That's not what I call good support. Then I chose Wing IDE. It worked as expected.
gift horse, meet mouth ;-)
This 256MB "doesn't include memory used by the operating system, the MySql and Postgresql database servers and the frontend web server... (unlike on a VPS)". And plans are as cheap as $5.50 a month prepaid. If you need Python hosting and don't need a dedicated server, you're crazy not to use Webfaction.
Scoured the internet for a while trying to figure out why os.list.dir(c:\\windows\\system32) wasn't showing me a bunch of files that I was expecting to see in there. This saved my day. *edit* I should also say that this applies to 64bit windows installs, not 32bit (that was the original issue).
&gt; Is it right that `__get__` is where the bound vs. unbound method distinction is made? Yes. Well, it's where binding happens, methods know themselves if they are bound or unbound of course. I mean, in case you are not completely clear about that: in statically typed languages like C++/C#/Java the compiler knows that it deals with a method lookup, in Python there's only attribute lookup and it doesn't know what you are going to do with the result. &gt; Also, when I run Cls.f(None), I don't get an error, it works the same as o.f(), is that right? Yes, it looks like I was mistaken about that. I explored that stuff, because at some point I got completely confused: The standard attribute lookup looks like this: search for the attribute in the class hierarchy, then if it's a data descriptor (implements `__set__`) just invoke the descriptor protocol, otherwise do instance lookup, if that fails but we have found the attribute in the class hierarchy then check it again for `__get__` (and invoke if present), otherwise return it, otherwise check for `__getattr__`, otherwise throw AttributeError. By the way, it means that "instance attributes always shadow class attributes" is a white lie, it happens with normal attributes and it happens with functions only because they don't implement `__set__` (try it with your `Function`!) So, I was interested why the hell in case of attribute lookup on a class object it's checked against descriptor protocol support too. It's a total mindfuck, isn't it? According to usual rules it should be checked only if found in the metaclass hierarchy! But then `classmethod` and `staticmethod` descriptors couldn't possibly work... So I discovered that this particular exception (*"unbound method ... must be called with ... instance as first argument"*) is thrown from `instancemethod_call` in `classobject.c`, which in turn is appears to be indirectly called from `class_getattr`, which also implements custom attribute lookup logic that searches in base classes' instance dictionaries. Obviously. So I thought that you'll have to reimplement that part in Python to disable the check. Well, turns out it's even more complex. Frankly, I'm a bit burn out at this point, because when I solved my challenge myself (after proposing it) and played with it a bit, I stumbled upon yet another mindfuck: why doesn't metaclasses `__new__` fuck up instance creation? I mean, if you think about it, for the two kinds of `__new__` methods to work according to usual rules (a method is implemented in the class, then bound to the instance), the instance-creating `__new__` should be defined in the metaclass, and the class-creating `__new__` should be defined in the meta-meta-class. Well, OK, since we know that attribute lookup on classes is different and does actually prefer class methods to metaclass methods (shadowing them) unconditionally, then it's all because `object` defines `__new__`, and that shadows the metaclasses `__new__`! Except that I experimented. And discovered something truly terrible. [Exhibit A](http://ideone.com/TmQby): override `__new__` in the metaclass with my custom Function that also implements `__set__`, it is not called, all right, consistent with the theory. [Exhibit B](http://ideone.com/PuWUL): also implement `__new__` in the class. It doesn't get called but causes the metaclasses `__new__` to be called. WHAT. THE. FUCK. PS: I fully stand by my assertion that Python object model is at least an order of magnitude more complex than that of C++, which tells a lot. Virtual inheritance quirks seem straight and sound in comparison to the snake nest of entangled attribute lookup routines working on several levels of class-instance relation plus inheritance.
There we go. Thanks. &gt; snake nest I see what you did there.
WebFaction is so awesome. GoDaddy and every other hosting company should be taking notes.
GoDaddy should just cease to exist out of shame.
That's fantastic. I've been using them for couple of years now, and have only good things to say about their technical support, documentation, and the service itself.
What. The. Fuck.
So how does a memory quota affect Django apps (I'm learning Django specifically right now). ;)
Stupid question: it sounds to me like you're using an external executable to do the work. Wouldn't this be better handled by asynchronous IO than multithreading?
Apps like Django and Rails stick around in memory (e.g. Django with mod_wsgi is loaded into the Apache process, along with all the Python code in your Django site - your apps, middleware, etc. - and this adds to the memory footprint until you restart the Apache process). By contrast, in common configurations, PHP is loaded into memory to handle a request, then unloaded after the request has been processed.
Hand out fake flags on every request to get something. Make a game out of it by leading the attacker down the garden path so they have to work at it to get their fake flag. If people think they've already got your flags, many won't try again.
Lets all say a prayer for this person tonight.
I've just released the v0.2 version [1] with the global update checking. [1] http://pyevolve.sourceforge.net/wordpress/?p=2220
Thanks for the reply..I probably should have just done a bit more searching. Well, I applied to their program...but I wouldn't be able to afford something like that for YEARS...but..you know. One can dream, right? The things I would do with one of those..I'd just quit school and try to create our robot overlords.
What is your idea exactly and why would we need it since there is already the python subreddit?
Awesome! These are easily my favorite solutions so far, mostly because they seem easiest :P
I could have used this in the past. Good tip.
So I gather from your helpful feedback that the extensibility of docutils isn't a subject that interests you.
the code he's raging about is simply unacceptable. you know you won't come back, and doing it that way in the first place indicates you're not familiar enough with python to be using it for this kind of application in the first place.
I came here to say that I find it incredibly unusual that adding threads to an application would simplify the solution. Very unusual indeed.
No. It means exactly what it says. It attempts to use the result of `range(0,8)` as an index. To check if a value is in some set of values, use... I hope you're ready for the breathtaking simplicity - `in`. To create the range, use a slice index. It looks like this: if sP in data.grid[0][:8]: (I assume you mean including 0, but excluding 8 as an index, the way that sane programmers normally index things. If not, adjust accordingly.)
This sounds more-than-vaguely pornographic.
No, list indices must be integers however you can use slices. You can use the 'in' operator to search a list or any other object which implements a __contains__ method. The result of slicing a list is another list which can be searched as well. # a list of lists of numbers data = [range(a) for a in range (10)] print data sP = 5 # if sP in data[7][5:8]: print "This is True" sP = 2 if sP in data[7][5:8]: print "This will always be False" [Here](http://stackoverflow.com/questions/509211/good-primer-for-python-slice-notation/509295#509295) is a nice primer on slicing.
There need to be less libraries naively hardcoded to Django and more that are general use and usable by anyone in the Python web development community. The continuous stream of "Django-only" libraries only serves to suck the life out of the bigger community.
Um yeah... not really witty or funny. If you want funny nerd rap go watch "[kill dash nine](http://www.youtube.com/watch?v=Fow7iUaKrq4)" if you haven't seen it already.
Sure. Here you go! def recurse(a): if a &gt; 100: return a else: x = 20 return recurse(a + x) def itera(a): while a &lt; 100: a += 20 return a Notice how `recurse` calls itself? Recursion! You call yourself until you reach a bound. Notice how `itera` loops? Iteratation! You iterate through the loop until you reach a bound. Python can do recursion, but it's generally considered a bad practice. LISP on the other hand should be written with recursion.
Which one will compute faster?
Speculation here, I'd say iteration works faster, because each time you call the recurse function, it has to allocate memory for each set of x and a. The further down you go, the more memory will be eaten up.
Generally, iteration, but it depends. Sometimes the compiler will optimize the recursion into iteration. Also, recursion is often the more straightforward way to write something, and readability/comprehension is important. 
Run `python -m cProfile &lt;filename&gt;` and find out yo damn self! :-)
Unless you're dealing with a possibly infinite stream of data, or expect a variable without an upper bound. Then iteration is the winner, even if it appears more complex.
I thought docutils/RST was for creating documents, not web pages. If you can figure out how to typeset and print a youtube video I'll concede that this may be a useful module.
Iterative is the loopy things, they go loopy loopy loopy loop Recursive is the recursive things, they go recurse recurse recurse recurse
Point of recursion is not to be faster ... the point is that there are huge group of tasks which is obviously recursive and doing it iteratively means massive waste of time and loosing clarity of code. Let's say I was writing json_diff (it is in PyPI) ... comparing two arbitrary json files. You have to go recursive there or you go mad. Various strategical tasks (examples could be The Problem of Eight Queens, ... get http://www.amazon.com/dp/0130224189 from your local library).
Recursion is more natural to write when you have a problem that is described in terms of subproblems of the same type. def fib(n): if n &gt; 1: return fib(n-1) + fib(n-2) else: return 1 The fibonacci sequence is defined recursively, which is very easy to translate directly to code. However, in languages like Python, you will get better performance if you translate the process to an iterative approach. fib(n): a,b = 1,1 for i in range(n): a,b = b, a+b return a Using memoization, or other optimizations, recursion can be just as fast as iteration. In fact, given a "sufficiently smart compiler", you could write recursive code, and the compiler would translate it into an iterative version that behaves the same, except faster.
I have a sudden urge to use Python and 'pop a cap' in some Perl and Ruby users.
More specifically Lisp support tail call elimination and so can execute some kinds of recursive functions in a fixed stack size and in a generally faster manner. Python doesn't have this so recursive functions are always going to have pretty steep overhead.
&gt; The fibonacci sequence is defined recursively, which is very easy to translate directly to code. However, **in languages like Python**, you will get better performance if you translate the process to an iterative approach. This is a bit like saying "if you're over six feet tall, you can't solve the Halting Problem." It's technically true, but the implication is seriously misleading. The reason that you get better performance with the second algorithm is that the _algorithm itself_ has linear complexity, (cf. exponential complexity for the first), not that Python has some special magic for making linear-time outperform exponential-time. You could write a recursive function that implements the second algorithm just as easily: def fib (n, a=1, b=1): if n == 1: return a else: return fib(n-1, a+b,a) 
There were too many sections where it looks like the lyricist was sitting around waiting on the GIL.
[Here](http://inventwithpython.com/blog/2011/08/11/recursion-explained-with-the-flood-fill-algorithm-and-zombies-and-cats/) is my favourite explanation of recursion and how it is different from iteration. EDIT: Fixed link. Thanks line10gotoline10!
Oh god my ears.
Even more confusing: The registry looks different for a 32 bit app vs a 64 bit app. The reg-keys you insert in regedit running under a 64bit process might not be on the same location if you try to read them with a 32 bit app.
As another example, tree structures tend to have methods that are obviously better suited to recursion: # Returns True if other is an ancestor of self def isAncestor(self, other): return self is other or (self.parent and self.parent.isAncestor(other)) versus iteration: # Returns True if other is an ancestor of self def isAncestor(self, other): node = self while node: if node is other: return True node = node.parent return False
I was trying to use web2py and I couldn't get a single app running with Apache without getting killed. Had to compile and configure it with lighttpd but FastCGI wouldn't stay running. Kept dying with nothing in the logs. I'm very happy about this.
I found nginx+gunicorn quite a bit more stable tbh. Manage it with supervisord.
Meh, with the RAM increase I'll probably just go back to the web2py install script and run it with Apache.
Yeah, the problem is teachers teach you one first and then they teach you the other, and they ask you to do it one way or another for a particular problem. It's a bit silly because in real life you look at the thing you're trying to do and then try to come up with the most straightforward solution, but classes can't work that way. 
May as well be constant. Soft O. 
Yeah, but your improved version still sucks in Python because it can't go past 1,000 recursions. In a language with TCO, that wouldn't be an issue. You can work around it with a trampoline function, but sheez, that's way overcomplicating a simple problem.
Care to elaborate?
I didn't write that code.
With GUI applications, you kind of *need* to do some multithreading with it in order to not freeze the UI.
I still need to start off the tasks, which will need to be in another thread in order to not freeze the UI.
It seems to me that if you rerun the same script again (on the same server), the JIT should have warmed up by then and be faster. Maybe even load will drop. For the webserver side, tornado is known to be faster than twisted web, although I'm almost sure the web server performance has not made any impact on the actual numbers (also, I have higher expectations about quality from twisted web).
Calling functions itself also has quite a bit of overhead in Python.
...me in the midst of a caffeine binge wrote it. You have no clue of the context of this whole application and you've got no right assuming things because of 6 lines of code. I was on an extremely tight schedule to write this (I told them a month, get given a week) so things like that are bound to happen. It'll get fixed eventually, but right now there's no pressing need. The file name strings are dealt with in two places, three if you count that one of the places is two arguments. So please, take your frustrations out on someone else. I'm hear to learn and talk about code/Python, not be berated by some elitist troll.
Take a look at some data structures, specifically a stack. For me it really helped visualizing recursion.
 if a &gt; 100: needs to be if a &gt;= 100:
 import sys sys.setrecursionlimit(int)
It can be [added](http://code.activestate.com/recipes/474088/) though.
No argument from me there. In fact, at the very moment I took a break to reply to your comment, I was dealing with some de-recursification shenanigans in order to cope with Python's lack of TCO. I was just clarifying the difference between the performance of one algorithm in two different languages, and the performance of two different algorithms. On another note, I've never really accepted Guido's rationale for refusing to implement TCO. The number of times I've been thwarted by the absence of a stack trace is dwarfed by the number of times I've been thwarted by the absence of TCO itself.
Author, why you no run twisted web benchmarks with cpython as well? 
Hi, Thanks for all your help. I fixed it! I was profiling this morning and I found that setting up the `QThreadPool()` before starting work in it seemed to block somehow. I moved the `QThreadPool` initialization to the main window constructor *and we now have it working*. Thanks again!
Yes
Fine, but we were not talking about embedded programming. I for one was talking about researchy programs, like simulation code that physicists often write.
Y U NO check wikipedia? The articles on [Recursion](http://en.wikipedia.org/wiki/Recursion#Recursion_in_computer_science) and [Iteration](http://en.wikipedia.org/wiki/Iteration) have short, clear and explained examples.
Be careful with that! If you set value too high recursive function can crash Python.
Not really about Python, it's about Windows lying to you. 
Does that seriously matter?
If you want to use twisted server with a mini framework, you should look at cyclones implementation of bottle: https://github.com/fiorix/cyclone/blob/master/demos/bottle/complete.py
I agree with zzzeek's general point. In this case there are general-use libraries for this, for example [SimpleGeo's python-oauth2](https://github.com/simplegeo/python-oauth2). The README for that project even describes (with code snippets) how to get it working with Django, using Twitter as the OAuth authenticator. The ["code" page](http://oauth.net/code/) on oauth.net cites the above as the go-to Python implementation (though there are plenty of GitHub forks if that specific variant doesn't float your boat). But I suppose there'll always be people who want it packaged up as much as possible for Django, Flask etc. BTW, if you use the SimpleGeo solution, I claim the bounty ;-)
Definitely
Yeah, I rarely use it apart from when I'm trying to make sure that a function actually *works* when being recursive. TBH - It's been proven to me that in Python there are much better alternatives than recursive functions. Generators/clever iterative functions seem to be quicker.
To expand on that concise summary a bit: Yes. Python is simple and consistent, but it's also very powerful, and there are libraries for almost anything you want to do - GUIs, web services, number crunching, graphics, and so on. It's also widely used, so there's plenty of existing Python projects to look at and/or help out with. A couple of qualifiers: - If you're looking to get a job in programming, big businesses are more likely to use Java or .NET. An increasing number use Python, but it's not going to overtake those languages any time soon. - Some specific types of programming - like controlling embedded systems - will have to be done in more low-level programming languages. But you can probably cross that bridge when you come to it.
If you are going to work in a programming field, sooner or later you will learn more than one or two languages. And it won't be a problem for you. So it doesn't matter that much what you stick with now. But yes, python is a great choice. But I would recommend to play with C as well. To understand some "lower" concepts (working with memory) and even understand what python has to deal with when you write your fancy high-level loop (or whatever).
When you write out some long code yep.
If you unpickle untrusted data, that data can run arbitrary code. This is documented and by design, so that complex structures can be pickled, but it leaves you open to some dangerous (although simplistic) attacks. &gt;&gt;&gt; payload = "ls" &gt;&gt;&gt; pickletools.dis("cos\nsystem\n(S'"+payload+"'\ntR.") 0: c GLOBAL 'os system' 11: ( MARK 12: S STRING 'ls' 22: t TUPLE (MARK at 11) 23: R REDUCE 24: . STOP &gt;&gt;&gt; pickle.loads("cos\nsystem\n(S'"+payload+"'\ntR.") REDUCE is the key, it takes the tuple ("ls",) and gives it as arguments to the global os.system. Using pickle to load functions from modules can bypass import protections in some sandboxes. --- More info: [Why python's pickle is insecure](http://nadiana.com/python-pickle-insecure) and [exploiting pickle](http://blog.nelhage.com/2011/03/exploiting-pickle/).
To understand recursion you first have to understand recursion. (*scr*, most other comments are more useful …)
So... Were a user to have their pickled dictionary, that contains a wealth of shit about some playing cards or something, switched out for something, malicious code could be executed on their machine...? Or am I missing something? Do you have to use pickle in a certain way for it to be exploitable, or is it always devilmagic?
You need to let the "attacker" control the data that is being unpickled. So if I'm running a server and let you upload some data, then I unpickle it, then you can run malicious code. If I download that pickled-playing-card-dictionary from someone, that person can run arbitrary code on my computer. If it's the person who wrote the program, though, I'm already trusting them not to run malicious code.
Whenever whatever card set changes, the server sends it to players. The server has its own speshul copy, which is different, for no interesting reason. The pickle could be intercepted on the way to the user, though. considering none of it is being eval()'d, or passed to os, or anything, it's just reading attributes (if that's the right word), is it dangerous, or would it simply fail out with an error? What I'm failing to put clearly is: Is the simple act of running loads() dangerous, or is it further execution?
Running loads is dangerous. It's as bad as eval()ing.
Yeah, there's very little CPU use here to make PyPy significant. The load averages reflect on IO contention, which seems to start sooner in the non-Twisted case.
Aww crap. That means I have to write a file structure or some shit. D:
TLDR: definitely
It was not my first language: BASIC(High school)&gt;C&gt;C++&gt;Python. But it has been my #1 language for the last 10 years. So, there you go :)
Well, researchy stuff is the other half of my experience. If you want to limit it to that, cool. (Though the article pretty clearly about embedded flavored programming.) Science code is much the same thing as embedded. Ultimately you still need to crunch a lot (possibly infinite) amount of data very fast (possibly real time). The only difference I can think of between science and embedded is that science is more okay with using floating point and usually has no cost restrictions on hardware. Typically someone will start with a 10k line CSV sensor log, fiddling with it in Excel until the graphs look right. Then ask you to make it run in real time, maybe processing 100k samples per second or whatever their capture device maxes out at. The most complicated thing (algorithmically) here is replacing their first order Euler integrators with higher order difference equations.
Thanks! The version comparison seems to work better than that of Yolk, I'm not getting spurious upgrades. Would you consider adding links to PyPI package pages? Often they contain useful information like links to source, changelogs, and documentation.
Similar story here. Haven't found anything better since.
Beside the short-term professional aspect (yes, python knowledge is in demand), the thing is to recognize that a language is a tool. Like any other tool, this one is better fitted some task than others. But tools have different degrees of flexibility (think swiss knifes or leatherman's). Python is extremely flexible, so it can help you understand even concepts that are not native to the language, be it low level programming or functional programming. It won't be efficient but it will help you understand. You'll be able to move to other specialized tools easily from there. So go python ! 
Ah, glad to hear you were able to resolve it. Now that you say that, I'm fairly certain I know what was going on. You created a local QThreadPool to manage the work in the *convert* function. But you didn't assign it a parent object to manage the liftetime scope of the QThreadPool (which is usually fine since the Python garbage collector will just take care of everything for you). In this case the Python ref-counting mechanism will take over and the QThreadPool will be deleted as soon as it falls out of scope. However, the C++ destructor for the QThreadPool blocks waiting for all runnables to finish before reclaiming the memory. Because the QThreadPool falls out of scope on the UI thread, its destructor will run on the UI thread. Thus, the *convert* function was actually blocking the UI thread as soon as it exited waiting for the QThreadPool to finish destructing. Now that you're keeping a reference to the QThreadPool alive for the life of the MainWindow, its destructor is not running until the main window is destructed (i.e. application shutdown I assume) and the thread is no longer blocking. That's pretty tricky, and definitely an artifact of the C++/Python binding rather than anything conceptually wrong with what you were doing. 
Hey Josh, yes.
If you have something that has to run more of less independently with respect to the rest of the program than a thread will be way simpler than doing your own multiprocessing...
Very cool. It seems it runs other languages too (C++, C, .NET, Urbi). Possibly the underlying platform is from the [makers of Urbi](http://www.gostai.com/).
Well, this is /r/python, so you know what the answer is going to be here... I agree with the other comments, Python is a great first language and a good primary language. It should not be your last language, though. Learn to program well during your break. There's plenty you can still learn with Python now that you have the basics. Consider playing around with some of the functional features (list comprehension, for example) or experiment with different styles of programming: game development with Pygame, web development with the cgi module or a dedicated web platform, database integration with sqlite, or much more. You will eventually need to learn other languages. Learn old-school C (not simply C++) to learn all the things that Python's "magic fairies" do for you. Make sure you really understand direct memory management, garbage collection, the relationship between strings and arrays, and how real arrays (not Python's magical tuple and list classes) work. You'll also want to get used to at least on commercially mainstream language like C# and / or Java. PHP is a weird language, but it definitely has its purposes, and you can make a decent living without a huge amount of experience. (Maybe that's one of the reasons so much PHP code is awful.) But all this begins with a love of algorithms, and a knowledge of the basic stuff a programming language can do. Python is as close to an ideal language for playing with programming as we have right now. 
A stack isn't a naturally recursive structure, though I can see how it could be. (10 items contains 9 items contains 8 items etc). A tree is a classic example of recursion, because it's more obvious how recursion is a better way to parse it.
That makes so much sense it's untrue! I *was* creating the `QThreadPool` object as a local variable, so that makes sense. What I don't get is that, with `QThreads`, is that if *they* go out of scope, you get memory access errors and it quite literally thows a big fit that you're deleting a thread. Essentially, `QThreadPool` takes a `QRunnable` and assigns it's `run()` method in a `QThread` object, guided via the `QThreadPool`. I'd like to know why there's a difference with things going out of scope with the `QThreadPool` and using `QThreads` directly. Thanks for that insight, definitely some valuable information you hold in that noggin' of yours!
&gt; What I don't get is that, with QThreads, is that if they go out of scope, you get memory access errors and it quite literally thows a big fit that you're deleting a thread. QThreads will throw a fit if you try to delete them **while they are running**. If you wait til they are done to delete them then everything is dandy. So you must either assign a parent object to a QThread to manage its lifetime or ensure that you'll hold a reference to it for the entirety that it is running. This is actually why the QThreadPool's destructor blocks. It has to wait for all the child QThreads to finish before it can delete them. I'm not sure why they decided on inconsistent destruction behavior between QThreadPool and QThread (i.e. one blocks for safety, the other crashes your program). In the future, though, a tip is that you don't necessarily need to create your own QThreadPool. You can just use the global instance that's always available. You can use it like: QThreadPool.globalInstance().start(runnable) and just dispatch work to it whenever. This is typically how I use the QThreadPool and why I was not hip to this detail of its destruction requirements.
I thought of doing it this way (`.globalInstance`) but I decided that I wanted clear separation between the different *kinds* of thread work that will be going on. I wanted for someone who was looking at the mthreading.py module to see that yes, there is a `QThreadPool` for starting the PDF conversion, another for starting the deletion of temporary files etc etc. You see, I originally had it with `QThreads` and I'm quite familiar with their scoping rules, and their subsequent erroring. If I had those same errors I would have seen my problem quicker. I actually prefer the `QThreadPool` destructor method, since it seems a lot safer (for example, some IO, networking). But I would prefer it if it printed something to the console (the same way `QThreads` do) that we're destructing it whilst threads are running. As a side note, it seems they have started the documentation migration for Qt, what do you think? It's very incomplete at the moment and all the old links are going to the new place. Quite jarring.
if you understand, you understand recursion.
Okay. What I have seen is just massive simulations that run on big clusters, no streaming/infinite data kind of thing, and certainly no real-time requirements. 
Yes (but then, you ask us). It's extremely versatile, can probably do what you want, is used profesionally, is fun, and usually if there's some hot new thing out, someone will start working on an open source Python library to work with it. It shouldn't be your _only_ language eventually, but it's a great one to use exclusively for quite some time.
Worth pointing out, you can turn a recursive function into a stack-based function so you can treat it as a semi-iterated one. 
Yeah, this is on my TODO, I'm going to implement lots of features related to PyPI repository, like download information for releases, etc..
Along with the highlights takluyver has already mentioned, be aware that: * Python *originated* from experiments in language learning, and has always had a significant number of core maintainers who keep their eye on Python-As-A-First-Language; * Python is now widely used in colleges and high schools as an instructional language; and * Historically, the community of Python practitioners has been congenial and welcoming. Python has particular domain strengths that might matter to you, youlysses; are you a linguist or nanochemist, for example?
I agree. IMHO Learn paradigms not languages. You may find that you always come back to Python, but for example Haskell will change the way you think about some problems.
Docutils is primarily for creating *documentation*, but is a generally useful markup language. Most documentation is viewed online these days, like for instance, the [python documentation](http://docs.python.org/), and the wonderful [ReadTheDocs](http://readthedocs.org/) site, both powered by reST. Also, check out [pelican](http://readthedocs.org/docs/pelican/en/2.7.2/), a blog generator, which creates a blog from files formatted in reST. I use pelican to power my blog, which is why I wrote this little plugin. It's true, you can also render reST to print-oriented formats, and currently rstyoutube doesn't handle that well at all (**Edit:** It probably just crashes). Perhaps the best way to degrade gracefully in those situations would be to provide a reference/link to the video. Also, this comment was much more useful than the first one. It will help me flesh out the README file to explain why the module is useful. Thanks for the feedback. 
Yes, but it really depends on what you want to do later with programming. If you want eventually to study computer science, it is good to keep in mind that most of the courses is gonna be either C/C++, at least at the start. Transition from low level language (like C) to higher level language (like Python) is always easy - elegant one liners and having things done automatically for you is a great bonus. The other way around may annoy you a lot during the process. So if you want to treat programming as a side thing, or a language to get work done, then yeah. I've been through all the C's, Java, PHP etc and python is the thing I use right now when I need to check something out, or build a website. If you want to study CS sometime later, don't "stick with" it. Definitely use it, but keep an open mind (especially about C/C++, since beside assembly they resemble the actual CPU "though process" the most). Edit: Actually If it is the latter, and you want to use python and be honest about your C skills, make sure you know C enough that you can transform every Python code to C code. Then you should be fine sticking with it.
Upvoted, but I'll add one qualifier: not everyone who programs is going to become a hardcore programmer who has to understand memory management. Whether 'you will eventually need to learn other languages' or not depends on what you want to do. I'm in science, and the idea that scientists should do some coding is slowly creeping in. But it's not what people focus on, and there's little incentive to go learning a variety of languages. Programming here is a tool, not a quest.
libraries should include their own plugins that apply to various target frameworks. You'd have the oauth core stuff, then you can have ext.django, ext.pyramid, ext.flask, whatever. It just means that you've *actually* "abstracted" the non-framework part away from the framework part.
Imagine we want to calculate 1+2+3+4+5+....+100. **Iteration** Is a loop, generally 'for' or 'while' loop but that doesn't matter. Which is inside 1 function. You call that function. It goes into a loop until it finds the answer and returns it. **Recursion** Is one function that does ONE UNIT of the whole calculation but it calls itself many times each time with the result of the previous one. This means that one function needs to do TWO things. first, check if it should call itself again or stop (otherwise it will be in infinite loop each one calling another one and never stops) this condition is called BASE CASE which tells that function enough already! the second thing is to actually do one unit of work. So in this example the recursive function first checks if the current number is 100. If it is that function should not call itself again because we don't want to add 101 to our results. If it's not we do call ourself. This means in recursion when a function is called it doesn't care about the bigger picture. It doesn't care whether it's calculating 1+2 or 1+2+3+4+...+100000. It just knows when to stop and if it's not there yet it'll call itself again. Hope that helps.
Yes, although you're going to spoil yourself without knowing it, and learning other languages after that will become a pain. In order to alleviate this issue, you should learn javascript: * largest implementation ever (every browser on every platform, including phones and TV) supports it * it has a bunch of quirks like most other programing languages that teach you about programing in real life outside of the python bubble.
At the last python and djangocon, there were a number of employers who said they were looking to fill python positions. So if you're looking to get a job in programming, I think it's a great language to look at. More people use Java and .NET, perhaps, but the ratio of jobs to programmers is pretty favorable for python job applicants.
The purpose in those cases isn't to teach best practice but to teach technique. Real life best practices can be learned later. You have to know how to add before you can multiply, yadda yadda yadda. 
Im totally happy with django-socialauth OAuth example from it, https://github.com/agiliq/Django-Socialauth/blob/master/socialauth/lib/oauthtwitter2.py 
I'm sorry I'm not talking about the OP. But will these tutorials be recorded? That Hettinger one sounds good.
I agree. I love python. I've written scripts, applications, web scrapers, usb drivers (twice!), and other stuff with python. it's great. Disadvantages: 1. Speed. Make up for this using ctypes, cython, pypy, etc. 2. Distribution. Still not sure how you write a windows app without making the user jump through hoops and install python along with the app. Compiled native code always works better here, although there are things like py2exe that probably still work. I'm a linux guy though so this isn't a huge problem for me. 3. Team Projects. You've gotta make sure you do it right if you're working on a team. Document, document, document. Python is so flexible but it makes it difficult when you're trying to define common interfaces that could be, well, anything.
&gt; libraries should include their own plugins that apply to various target frameworks. It would be nice if they did - but in a lot of cases, it won't happen because of time constraints, other priorities etc.
You missed decker's point. In *most* programming scenarios, performance is the least important aspect of programming. It's very, very rare for any career programmer to actually have to optimize a particular algorithm. Or create an algorithm in the first place, honestly. Much more important in enterprise software development is correctness and maintainability. Ironically, maintainability is arguably more important than correctness. 
It's that way in any language. At the lowest level, calling a function involves a stack push and a reallocation of registers. Good compilers will optimize much of this away if it's unnecessary (typically called "inlining"), but scripted* languages such as Python tend not to be able to do those types of optimization. *scripted is somewhat nuanced with respect to Python, but I think the point is made. 
Good work. You're getting there. I think you'll find that the code you posted (second time) will work if you replace the pygame.image.load("red.png"), ("green.png", etc) with this: load_image("red.png"), you'll have a working program. Take out the first loop; you don't need it. Instead of the 'for y in range... ' put this line: screen.blit(background, (0, 0)) just before the second loop. Move the video resize code from the first loop to the second loop. Hope this helps. Looks like you're nearly there
if you followed the thread you would see that he is indeed **very** constructive
If you want to be a great programmer, take up a language and use it until you stop dreaming in it. Then, switch to another. Go through a dozen or so. Later, pick the best one for whatever task you have. After a decade of not "sticking to" a single language, you'll be better programmer than 99% of programmers out there.
If you want to do array slicing like in R or Matlab, use numpy. In [1]: import numpy as np In [2]: a = np.array([[1,2,3],[4,5,6]]) In [3]: a Out[3]: array([[1, 2, 3], [4, 5, 6]]) In [4]: a[1][[1,2]] Out[4]: array([5, 6]) 
Oh joy, magic filesystem hooks. I hope they're code objects attached to the node of the filesystem being affected or something to keep their effects and presence localized to the kludgey area of the filesystem. Nevermind, they'd bork that design by repurposing data structures that the original Lotus 1-2-3 will read in the NTFS (I assume someone has grafted on a plugin system by now) as "emergency reboot sequence reached."
Tutorials are not recorded.
geez, what the heck is your app doing that it couldn't stay in 80MB of memory?
That makes me a sad panda. I neither have the money nor the time to attend. I'm on the other side of the globe... ....wait a minute.. import time_machine Traceback (most recent call last): File "file", line 1, in &lt;module&gt; ImportError: No module named time_machine **Dammit!!**
Well, this uses a class which is too bulky. Also this uses unnecessary recursion.
I always describe it like this: a recursive call is "some unit of work" that must be done, as well as a context under which you perform the work - typically, this consists of the arguments passed into the function. Take a tree traversal: given some starting node in the tree, do some work, then recursively call passing your children as the new context. So if a set of recursive calls consist of a bunch of calls to the same method, just varying the context, this same recursive call can be transformed into an iterative call thusly: create a "work queue", either a stack/list/queue, whatever structure it's appropriate for your problem, and "preload" it with your initial case: say, the root of the tree. Now perform the following steps until your work queue is empty: - pop off a work item - perform the unit of work with the context of the work item - based on logic, generate new work items with new contexts (i.e., children nodes) and put then into the work queue 
While cute, stuff like that isn't actually useful if you are trying to improve performance or maintainability.
Recursion, where? :3 *sigh*
`Operation` calls itself. This consumes a stack frame and will eventually cause the program to crash after a certain number of calculations. Also, what possible purpose does `Foo` serve? Why not simply access `operators` directly from within `Operation`? 
As someone with a Linguistics degree, I second this. Though I didn't have too much time to get into language processing, Python was one of the major languages -- Perl was the other, if you exclude RegExp in general -- we used for various tests and experiments with syntax, language processing, etc. 
The way it has gone for me over about 15 years of programming. I need to do something, I see if I can do it in a language I know easily, if not I learn a new language. I went through this cycle a few times and then found Python. I haven't needed to learn a language since starting with Python, it can do everything I need to do. I've also not had to use Perl since learning Python, which is good for me because I had trouble understanding what I had written a lot of the time with Perl.
def Operation(): # ... Operation() This is recursion.
Your TLDR is Ler than the OP.
this
That's the welcome app using the custom install script from the Webfaction wiki.
&gt; Python is simple and consistent This is very true, except when it's not!
The money is in these languages: c, c++ and Java. A closer second place tier is Objective-C and iPad apps. Python is up and coming, but it's not nearly as prevalent. Most jobs I see posted look for one of the big three above and then have Python as a secondary or tertiary language devoted to your development environment as opposed to the actual product.
Not sure if your link is not working for just me or what, but try [this link](http://inventwithpython.com/blog/2011/08/11/recursion-explained-with-the-flood-fill-algorithm-and-zombies-and-cats/) if the one above is broken.
It also sounds like a sandwich.
excerpts from ' Are595's (Poignant) Guide to Python'.
It really depends on what you're trying to do. Like others have said, check out some other languages. They'll help you be a better programmer overall. I think Python is a great language to "stick with", because you can do so much with it. You can use it for scientific purposes, automate systems/sysadmin type things, create desktop apps, make your life simpler, write scripts for Android, etc. My favorite thing is making web apps with Django (a Python web framework). Since web apps are only getting bigger, knowing how to make develop them is handy. 
Sorry I wasn't very clear. All I meant to imply is that some languages encourage iterative solutions, while others encourage recursive solutions. Python seems to encourage iterative over recursive.
Python is a great language with a really bright future, and was voted as language of the year by readers of Linux Journal (again). You're safe with Python.
I'm not an expert in python, but any "inconsistency" I came across actually had a valid and rational reason behind it that I didn't understand at the time. I can't think of anything that would spur a comment like yours, would you care to elaborate? EDIT: now that I think about it, some of the stdlib is a little unwieldy but all perfectly usable and heavily documented.
That entirely depends on what you want to get out of a long-term relationship with a language. From a practical perspective, Python can get a lot done with relative ease, and has a lot of hiring potential. From a hobbyist/learning perspective, I personally favor Haskell, because there is always so much more to learn, and a significant amount of Haskell wisdom can of course be translated into Python.
Briefly: Iterative: Do a step. Then do the next step. Recursion: Do one small part of the problem, and using just a recursive call, tackle a whole subproblem in a single step. (Not necessarily in that order.) Iteration is a specific simple form of recursion.
TLDR: 1
You could have a look at JSON.
http://www.youtube.com/watch?v=tRJ9t8JsWIw&amp;list=FL8zJSxikADE5ISJFJ7B-AAA&amp;index=137&amp;feature=plpp_video On a more serious note, I think I'll stick to some sort of semi-colon separated shit or something. Doesn't require extra libraries or aught.
OMG... this completly sucks - is it real or skit? If it is real: Forget about `eval`. It is just evil. Have a look into the `operator`-module and use the needed functions by a mapping: In [14]: from operator import add, mul, div, sub In [15]: ops = {"+": add, "-": sub, "*": mul, "/": div} In [16]: op = "+" In [17]: numbers = [1, 2, 6, 13] In [18]: reduce(ops[op], numbers) Out[18]: 22 Much more pythonic ;-)
Most definitely yes. Python is a great - and above all - _very practical_ language. It has its warts, but overall it's just very lovely, and that's exactly what you want from the language you're going to work with. 
&gt;The money is in these languages: c, c++ and Java. Well, yes, but there is also still money in, say, being a plumber. High income is not at the top of everyone's list of goals.
Iterative is like asking 100 friends to do something (one after the other). Recursive is like asking yourself to do that something 100 times (all by yourself). 
And if **that** doesn't work, try [here](http://www.reddit.com/r/Python/comments/nes3j/can_someone_explain_to_me_iterative_vs_recursive/c38jejf).
I don't think that's really the case at all. Python encourages taking simple approaches and enables simple expressions of those approaches. Recursion is often seen as "tricky", but it's sometimes much more obvious.
[Here's a few.](http://wiki.python.org/moin/PythonWarts) Also, special keywords like len and del break the OO abstraction since everything isn't really a method on an object. Some of the things listed in the above link have been fixed in the Python 3.0+ lines but they really haven't seen much wide-spread adoption.
That's part of the problem. Another part is that recursion is treated as an overly magical thing, when really there is nothing interesting about it at all **provided** you have been given a **correct** understanding of how function calls work. Another part is that you don't really get taught (or even encouraged to think about) how to break problems down recursively, you're just shown examples and expected to mimic them.
&gt;scripted\* languages such as Python tend not to be able to do those types of optimization. &gt;\*scripted is somewhat nuanced with respect to Python, but I think the point is made. I think the word you're looking for is "interpreted".
I am surprised that you think the idea that scientists should do some coding is slowly creeping in. In 1965 as a chem undergrad I had a job as the Chemistry Department programmer. My first formal task was to teach a programming to chem majors and anyone else who wanted to learn. I ended up spending half my career involved with coding, systems analysis, design and instrument interfacing. And was sysadmin for a couple of networks and minicomputers as well as a coder on mainframes. I certainly knew a lot of people trained in the sciences who thought they knew how to program because they could write a loop in BASIC, but I also met many who were really sharp. For a lot of work in the sciences it is easier to train the scientist on how to code, than it is to train the programmer about the science and the computational problems the programmer is going to run into.
I knew the "len" example would come out, as it was strange to me as well until I understood it. When you discover how it's actually implemented you realise that it really isn't "break[ing] the OO abstraction" as each object is responsible for determining it's own length. You can read more about it and a few other "gotchas" in [this article](http://lucumr.pocoo.org/2011/7/9/python-and-pola/) by Armin Ronacher. But it, and the rest of the Python "protocol" system, is actually an exceedingly clever system which guarantees better consistency throughout the language. As opposed to a language like PHP, where the warts of the language are a result of poor design decisions and excessive focus on backwards compatibility, Python's "warts" are usually a result of misunderstandings or trying to apply ideas and learnings from other languages to it.
Generally, if you're installing a module just as a .py file, or a folder with some files in it, you move it into your /%whateveryourpythonfolderis%/Lib/site-packages/ folder. If it's in a tar or a zip, generally it'll have a "setup.py" folder, in which case you can extract the tar/zip anywhere, then go into the folder and run "python setup.py install" which will install it all for you. By the way, this may be irrelevant, but lxml parses HTML faster than BeautifulSoup does (at least it did last time I checked), so it's generally recommended if you're going to be parsing lots of HTML. BeautifulSoup probably has a simpler syntax, but lxml's XPath can do all the same things.
Perhaps you would prefer me to state the same thing differently.... Where the JOBS are... is in those three languages. Take it however you want: individual salary or potential employment. Most people looking for a language to learn are looking there because they want to be employed.
What platform are you on? If you're on Linux, a lot of packages will be in your distro's package manager. You can also install [Pip](http://www.pip-installer.org/en/latest/) to manage Python packages outside of your distro's repository. This will get you newer packages, but they may or may not work well with the rest of your system. Generally they will be fine.
that's kind of whack man. 
Confirmation bias precludes me . . . .
Regardless of the implementation, it breaks the interface and interface is what OO is all about, you're not supposed to have to care about the implementation. Same does for del. I actually don't care about any of this. I understand it and am fine with it. I just think it's good to acknowledge that Python has its fair share of inconsistencies and hacks.
In my experience BeautifulSoup can parse more crappy malformed HTML-pages. If I remember correct (not sure), lxml had troubles with multiple headers and bodys on a single page.
OK, i put the story here, any comments are welcomed Today a friend told me she's struggling with solving the [EuroPython 2011 Problem D, called Twibet](http://code.google.com/codejam/contest/dashboard?c=1277486#s=p3). The key to the [solution](https://gist.github.com/1487636) was the recursive traversal (traverse_graph) of a directed graph. The representation of the graph is a dictionary of the monks as keys and a list of the following monks as values. Because running on the large input file raised a runtime error of maximum recursion depth exceeded, I used a this little hack: sys.setrecursionlimit(10000).
You looks to be a windows user ( as you don't kwown about tar.gz ) Go to this page. http://pypi.python.org/pypi/setuptools and download the package for your installed python version Next you install it. Then, open a console and type C:\easy_install BeautifulSoup Next you should learn about python packaging because your OS does not have a packaging system.
Agreed. I would never use it, but I love that it can be added.
The tutorials look like something that I need in my life, and it'd be great to be a part of the pydev world, see where the language is going, etc. I'm a student in Santa Cruz, so travel costs are effectively zero for me but room &amp; board, registration, and tutorials are all out of my price range (basically, if it costs more than beer, I can't afford it). Since I don't know if I'd even be able to attend on the days of the tutorials, should I just submit a guesstimate where it asks for nights in the hotel and tutorials that I want to attend? If I need to estimate, should it be an over- or under-estimate? Thanks for doing this and bringing it to my/others' attention here, whether it works out for me or not, it's an awesome opportunity. 
lxml is for parsing XML (and HTML which is also XML). BeautifulSoup is for paring those HTML which have no resemblance to XML.
The question is: what is you're motivation ? are you interested in learning computer science for fun ? to achieve a CS degree or equivalent knowledge ? to find a job as a programmer ? 
Not exactly true. http://lxml.de/lxmlhtml.html It has both an XML parser and a dedicated HTML parser. http://lxml.de/elementsoup.html It can also deal with broken HTML with its own interface to Beautiful Soup.
we'll talk when you start having problems with that
Agreed, I was just saying that using a stack can help understand program flow and context (whether its for recursion or not.)
Python is a great language, and probably as good as first language as any. It won't teach you too many bad habits and should act as a good introduction to a variety of other languages should you feel so inclined to learn them. Good programmers will learn a selection of languages as each language is a tool best fitted for a particular set of problems, and few languages are great across all problem spaces, but Python is pretty close to ideal for solving many real world problems. It's also a great language to use in the shell. 
There are numerous programming languages for reasons other than just bored programmers. While python is an excellent choice for a wide range of problems, no one language is the best choice for everything. You have to know your problem before you can pick the language to solve it. Picking the language first will eventually get you into trouble. Summary: keep learning languages. A bigger toolbox never hurts.
The advantage of using just one language, is that it becomes second nature, like a native language. I was like that with C. Now that I'm using several languages, I find I'm always having to look up basic syntax, because I can't keep them separate. (Just how does that Case statement go in this language?) Perhaps if you're young enough, you can learn several computer languages and keep them separate, as kids can do with spoken languages. Maybe I'm just too old for that.
&gt;big businesses are more likely to use Java or .NET While this may be true, for what it's worth, when my workplace was looking to hire developers, we were looking for people with experience in Python (as that's what we work in) and good candidates were few and far between.
It's because of how many processes it spawns. I think four is the default with two threads each. You can get it manageable by restricting how many processes and threads Apache will allow to run but it's still high. According to support it's fairly common for those packages.
&gt;...plenty of existing Python projects to look at Like [Reddit](https://github.com/reddit/reddit/wiki)!
Good points.
That's the whole idea - it doesn't break the interface, it _is_ an interface and the object/class is responsible for the implementation! And I don't see how the python implementation of del() is different to any other languages "destructor". If you consider that len() or del() act as operators (with some extra power that functions give) - you'll realise they are not inconsistencies or hacks.
pip install BeautifulSoup
What console? I feel so stupid! 
Where do I type this and where do I save the beautifulsoup.tar.gz?
Haha, good shit! So can you not run beautifulsoup on windows.
Verified.
Are you sure?
Start -&gt; Run -&gt; cmd No worries :-)
Start with Python. Wade in the murky seas of Fortan and C. Frolick in the functional paradises of Haskell and Lisp. Immerse yourself in the jollys of PHP. But always realize that, in the end, you come back to Python to achieve true balance.
I would always hire (at my old start-up) science guys that coded over computer science guys. The CS guys would get all gussied up with all sorts of algorithms and data structures that they had learned at school and want to apply. The science guys would look at it as a tool to get shit done. We, as a business, needed to get shit done. Never regretted the bias for a second.
Also, as addendum, I've found that a business using Python is also strongly correlated with businesses that have a clue, so while there might not be as _many_ jobs, I'd feel a lot better about taking a random, sight unseen, Python job, than a random java or php or asp or ... job.
You can install from the tar.gz on Windows, but there's an easier way - mardios mentioned it in another comment: easy_install. It's part of the setuptools package, so you'll want to install that first. 1. Save [this file](http://peak.telecommunity.com/dist/ez_setup.py) to you desktop and double click it. A black box (called console or command prompt) should pop up and it will start downloading and installing setuptools. 2. Once that is finished, open another command prompt by clicking Start -&gt; Run, typing **cmd** and hitting enter. You should get another black box. 3. At the command prompt type **easy_install BeautifulSoup** and hit enter. It should start downloading and installing BeautifulSoup for you. When that's done, you should be all set to import Beautiful soup into your scripts. If you get an error in step 3 about it not being able to find easy_install, try typing this at the prompt: **c:\Python27\python.exe easy_install BeautifulSoup** substituting the full path to python.exe depending on where you have it installed. easy_install is pretty cool as it means from now on you'll only need to do step 3 to install many common packages.
COBOL programmers that tend/herd billing systems (for example energy company billing systems) do quite well. And since the old maintainers are often baby-boomers and retiring, there is a growth industry there. That said: who the fuck could spend their lives maintaining utility billing systems in COBOL. The idea alone gives me hives.
I am curious about the USB-driver thingie. I have never used Python as a low-level systems language. (Usually web-apps, and scripting for large numerical things). How does this work? In fact, I am a little baffled that it is even possible. How/What did you do here?
&gt; Since I don't know if I'd even be able to attend on the days of the tutorials, should I just submit a guesstimate where it asks for nights in the hotel and tutorials that I want to attend? If I need to estimate, should it be an over- or under-estimate? I wrote the post but I'm not on the financial aid committee...but I would think you'd want to state as accurately as possible what you can afford. If you have to deviate from a 100% accurate number, I guess I'd slide towards over-estimating. If you're awarded more than you need, please say so ASAP. We'd hate to award two people with less than helpful amounts, then have neither of them go forward with a trip, then have them reject the offer after most people have already called it off. As with any award of this type, we can't guarantee that everyone gets exactly what they ask for, and we can't guarantee that everyone gets *anything*. 
This is exciting stuff, the margin between Node and PyPy is pretty drastic. Though I've learned not to underestimate the PyPy guys. SockJS looks like a much cleaner realtime abstraction layer than SocketIO which always struck me as a kind of a ad-hoc solution.
Thank you for taking the time to respond. I appreciate it. It didn't work for me, but I got it to work another way! Thanks!
2. Try pyinstaller. It compiles the app into an exe. 
It's not a USB driver, per se, but I wrote [this](https://github.com/nemec/audibleMPD/blob/master/console.py) little bit of code to read /dev/input/eventX for keyboard and mouse input, similarly to how you'd do it in C. Here's someone else doing the same thing: http://hackaday.com/2011/03/17/writing-python-drivers-for-input-devices/
YES!!!! Python is a very good language to stick with as it should remain viable for a long time. However don't assume it is perfect. For example I find defining blocks of code with white space to be frustrating and it can and does lead to errors. If you haven't already you should look at Lua and Ruby as potential alternatives. Of course neither of these is perfect either. Many will suggest that you should learn many languages but sometimes that isn't practical especially if you are a more casual programmer. If you fit this description Python very well might be all you need. 
Check [this](http://en.wikipedia.org/wiki/Shunting-yard_algorithm) out :)
Hum hum from Tribler.__init__ import LIBRARYNAME 
Have you checked Go? I've also used python successfully for many years, and Go is the first language that gives me the same giddyness
Go is barely usable. It's got an ancient and verbose syntax with lots of warts. Its builtins suck, especially containers. I just spent all day playing with it, it's not very productive, and the toolchain is also immature. 
Not very productive? How do you explain the momentum related to it? http://go-lang.cat-v.org/pure-go-libs http://go-lang.cat-v.org/go-code Also, please elaborate on the syntax verbosity and wartyness. How do the builtin containers suck? And while you're at it, please also expand on the toolchain immaturity. 
It's almost as verbose as C with none of the familiarity and simplicity. The toolchain is a replica of a typical binary language, makefiles, compilers and linkers, these things slow you down, compared with modern dynamic languages. The momentum is due to Google. This is Pike's last big push to make his succession of language failures take off. A few minor names, and some arm twisting within Google are keeping this alive. It's a long shot. The syntax maintains braces, and doesn't include lots of modern language sugar: Explicit tuples for return values, no named arguments. Archaic data types (sized and signed integers? Nobody cares anymore). No tuples. No modern functional programming features. None of the builtin containers allow custom data types. Maps can only take the standard types for keys. There are no sets. There is no proper debugger support. There is incomplete GCC integration. The GC and other performance related features are not complete. There is no LLVM support (they should have started with this). Go is more about what they _didn't_ include than what they did. The feature set is so light, that its performance approaches C. I want to like Go, but it's green threading and builtin CSP piled ontop of a C syntax remix. Both green threading and CSP can be extracted and made available to more mature languages. Plan 9 C extensions effectively give you the interface extensions, and that rounds out the advantages that Go gives. If Go had been here 15 years ago it would have been a game changer. 10 years ago, and it would be Python's peer. Prove me wrong.
I figured as much. Thanks for the input; maybe I'll see you there. 
Your version is better because it's not Java crap, but `reduce` isn't considered Pythonic either. Guido hates it and banished it to some module in Python 3.
I wouldn't hire me for this very reason. I don't know shit about the domain I work in and it gets in the way. Edit: Not sure why I am downvoted, I'm pure CS.
Thank you! It seems to me that your argument is really two things: 1. It's young. 2. It's not python. But snarkiness aside... I think there's only one useful thing from the dynamic languages that the main implementation of Go is lacking: REPL. That's a big minus for development agility, but given the reflection package, perhaps we'll see one at some point in the future. Much of the momentum is due to Google and the big names (Pike, Thompson) behind the language, I agree. It's only a bad thing if you don't like the language, isn't it? When trying to adopt a new language to a business setting, corporate backing (even if only nominal) is crucial. Syntax issues can be just swept away in a Jedi fashion. Many people care about data types (int32 vs int64, float32 vs float64 etc), and Go makes it much less complex and less arbitrary compared to C or really any other language I know of (save Haskell, I guess) that makes these distinctions. Explicit tuples are a must, I suppose, in a a statically typed language? Named arguments might be nice, but might also make the language more complex for little benefit. Maps can be used for much of the same effect. Same for FP features: might be nice, but is the benefit large enough? Perhaps not. Maps key limitations are perhaps a bit irritating, then again, they make the code much more straight forward to read. Yes, there are no sets. The default implementation is using the same architecture as the Plan9 C compiler. It's simple. &gt;Go is more about what they didn't include than what they did. The feature set is so light, that its performance approaches C. Yes, exactly! Isn't it great? &gt; If Go had been here 15 years ago it would have been a game changer. I think it still has a shot. My feeling is that it's not here to counter languages such as python (which is great), but rather to be against languages such as Java, C++, and C#. Go's simplicity extends from beneath the hood to every facet of its manifestation. I dare you to show another modern language like this; you may say that's it's not a good idea to make such a language, but that's another issue. Most others that I've seen are focused on large machinations whose fundamental idea seems to be either "ultimate academic elegance" and/or "make it impossible or very hard for the unskilled to make mistakes". These are sort of noble goals but not without cost. 
Totally. I've been programming for 7 years. Java, C, C++. Since I started Python 2 years ago I can't near to use anything else for its awkwardness. 
I should have qualified that a bit more. I'm in organism-level biology. In this field, programming has largely been confined to a few 'modellers'. We're now trying to ditch proprietary statistics packages in favour of R, which is slowly forcing more people to grasp programming. (Although I think using R will become a straitjacket when we inevitably want to do more than stats and plotting). I know that in other areas of the sciences, like physics and bioinformatics, programming is much more widespread.
&gt; It's almost as verbose as C Conciseness is not as great a goal as a lot of people like to think it is. Go strives to keep it down to one-idea-per-line. Jamming multiple concepts into a smaller and smaller space just makes it harder to keep track of things when reading code, though I agree that it makes writing code faster. That's why I like python for one-off scripts. &gt; with none of the familiarity and simplicity. The break from familiarity is intentional. And the language is damn simple, so I don't know what you're talking about there. &gt; The toolchain is a replica of a typical binary language, makefiles, compilers and linkers The makefiles, etc have always been a temporary bootstrap. 3rd party compiler front-ends (http://code.google.com/p/go-gb) or an upcoming 1st party equivalent make the use of makefiles or directly invoking the compiler and linker unnecessary. But, yes... it is compiled, and then linked. That's generally how it works when you've got a language that both modular (compilation and linking are a separate step) is turned into machine-code. &gt; Explicit tuples for return values Because having that dynamic would result in less efficient code... the more you know at compile-time the more streamlined the code can be. Go is a systems language. &gt; sized and signed integers? Nobody cares anymore Uh, yes we do. Which you choose simply matters when you don't want the runtime to have to do overflow checks to see when it needs to upgrade the size of your boxed numeric types...remember it's a systems language. We want the language to not prevent the compiler from making the most efficient code possible. Knowing in advance what size numeric type you need is one way this is accomplished. &gt; None of the builtin containers allow custom data types. By built-in containers do you mean maps and slices? Because any other containers are in the library and take whatever you want. And maps and slices can have anything as a value. &gt; Maps can only take the standard types for keys. Not for long. Remember, this language is young and is still evolving. &gt; There are no sets. map[T]bool &gt; There is no proper debugger support. gdb works fine &gt; There is incomplete GCC integration. Ian Taylor works hard, but he's only one man. &gt; There is no LLVM support (they should have started with this). The LLVM model didn't lend itself as well to the way coroutines work in go. The go runtime has a novel way of maintaining the stack layout. &gt; Go is more about what they didn't include than what they did. The feature set is so light, that its performance approaches C. Finally something we can agree on! &gt; I want to like Go, but it's green threading and builtin CSP piled ontop of a C syntax remix. Both green threading and CSP can be extracted and made available to more mature languages. Plan 9 C extensions effectively give you the interface extensions, and that rounds out the advantages that Go gives. I came for the concurrency primitives, but I stayed for the elegant syntax and type system. Coding Go let's me get down to business immediately - no messing around with stupid type hierarchies. To be fair, python has this feel, too. But I found that if I wanted to write a python program of reasonable size, I had to be extremely careful with how I did things. I started sneaking the type names into the variable names, for instance, so I could to code-time type checking. &gt; If Go had been here 15 years ago it would have been a game changer. 10 years ago, and it would be Python's peer. This is not a comment about the language, but of the times. &gt; Prove me wrong. Impossible to do in the time frame of this reply, obviously.
I couldn't make it work at that momento, so I've implemented [django-social-auth](https://github.com/omab/django-social-auth).
... Yes. I realize I failed to get my point across. Apologies. 
Post your GUI class constructor.
Hi! It's way simpler than you can imagine. First, ask yourself what can be done by a standard C library. Then remember that python provides beautiful access to a C (or any compiled) language. Then realize that it's easier than you realize. 1. Check out libusb - userland usb drivers. Used for everything from camera support to webcam stuff. http://www.libusb.org/ 2. Check out the python bindings, pyusb. http://pyusb.sourceforge.net/ 3. ??? 4. Make awesome non-compiled usb drivers using the libusb interface. DID I JUST SAY CROSS PLATFORM?! No I didn't, but it's certainly possible. For one of my drivers I actually had to patch the linux kernel because it rejected my invalid packets that I forged. Windows just passed it through, but the usb subsystem had a cow. That was a fun one to figure out :)
if you can do it in C, you can do it in python... usually.
oh cool. thanks.
You have to add the attributes for GUI widgets yourself. Something like this: def __init__(self): self.builder = gtk.Builder() self.builder.add_from_file("../ui/buttons.ui") self.widget_names = ["chk_btn_wall", "other_btn"] for widget_name in self.widget_names: setattr(self, widget_name, self.builder.get_object(widget_name)) This isn't beautiful because you have to mention all the widget names in two places, but it works.
 def __init__(self): builder = gtk.Builder() builder.add_from_file("MeetstaatGui.glade") self.window = builder.get_object("window1") builder.connect_signals({"on_main_destroy" : self.quit, "on_notebook1_switch_page" : self.nb1focustab, "on_chk_btn_walls_toggled" : self.editWallSearch, "on_apply" : self.on_apply, "on_Add_clicked" : self.add, "on_Quit_clicked" : self.quit}) self.DD = builder.get_object('filechooser_wanden')
Oh how I envy you... I went from BASIC (middle school) &gt; Pascal (High school) &gt; C++ &gt; PHP :( The alternative was Visual stuff or .NET and I don't know if I should have went that way or not...
Thanks!! That worked. I just had to remove the 'self' before the 'builder' in your example. It seems strange tho, because for debugging purposes I figured that I should get the same error if I wanted to try to change the label of the tab of the notebook, and it did. So that means that I have to include all the widgets I want to reference in the list you proposed. I just tried my tab-label test and that works now too. thank you!! (really searched to long for the solution for this problem, google wasn't my friend this time ;-)
Most GUI applications in history have been singlethreaded. I think you're talking about a specific implementation.
Do you know that, or is this an assumption, as it was moved to `functools`? Would you considr everything in `functools` to be *unpythonic* then? Of course this was the shortest way I had thought of. You can easily replace `reduce` by a self-written function. My emphazise was to show up the `mapping`-Pattern in order to accumulate similar function calls.
No, I mean, if you're doing any meaningful work with GUI applications, you need to make it multithreaded or else half the time you get your GUI thread to do *anything* then it's going to halt. Anything that reads external data that takes &gt;2s, multithread it.
If you have programmed in Pascal and C++, you should be able to pick up more langauges, IMO. Having gone through C++ with some level of success is a finishing Bootcamp with a nod from the drill sergeant ;)
I only did C++ for half a year or so. That was a major disappointment in my life because I rewrote a Pascal program that was over 500 lines long into just 80 lines in C++ &amp;#3232;\_&amp;#3232;. It felt wrong that I liked Pascal for some language and IDE elements and disliked C++ because it was slow to compile, was too strict and cryptic. But then I switched to web only development, and for 10 years I used scripting and existing apps, or vb scripting in Office or bash scripts to do desktop-level apps. I didn't compile a thing for over 5 years now. Until I recently got into Android development.
Very cool benchmarks, I only wish he could have included gevent (or even Twisted) instead of Tornado, but there is no sock-js for gevent and it doesn't run on pypy yet. I also would have been curious to see how Erlang-sockjs compares.
I'm very much enthusiastic about gevent sockjs server, seriously!
Is there any gevent implementation of sockjs? If there isn't I'll consider writing one over the holidays.
Like I said, most GUI applications in history have been single-threaded. How do you think they dealt with this?
I think this [MozillaZine article](http://kb.mozillazine.org/Profile_folder_-_Firefox#Navigating_to_the_profile_folder) should have all the information you need.
Right, but you can't use a ~ in the path in Python, it returns errors. So I'm looking for a confirmed working piece of code from a mac user, as I won't be able to test this before the final product. 
You realise that will only work on a system with a single user, even on Linux? You're just taking the first thing you find in '/home/'. If you want it to work for the user who's logged in, try: os.path.expanduser("~") Also, you might want to use: item.endswith('.default') And if you're trying to be cross platform, use os.path.join to stick together bits of paths.
Ah, cool. Thanks for the tip! That's easier than using a variable just for "/" or "\\" haha.
website parsing: http://www.crummy.com/software/BeautifulSoup/ 
No, I haven't heard of Gevent SockJS server yet. But I'm sure there is a demand for it: https://twitter.com/#!/progrium/status/118346034274508800 
About your website block program, the program linked below is what I use. If you don't know git (version control) and github.com, you should about them. Perhaps you could extend get-shit-done to include a timer. https://github.com/leftnode/get-shit-done
you should learn how to use the os.path module [0]. [0] Common pathname manipulations http://docs.python.org/library/os.path.html
By letting the GUI freeze? That's what I'm trying *not* to do.
Would [this](https://github.com/Lawouach/WebSocket-for-Python) do?
No, thats just the websocket protocol. SockJS has WS as a transport but its not the entirety of the protocol. There's a ton of those websocket servers floating around actually, I'll probably use [gevent-websocket](http://www.gelens.org/code/gevent-websocket/).
Once again, feel encouraged to implement SockJS server for gevent! Doing a SockJS server is not rocket science, it's just work. We're trying to make this work as straightforward as possible :) Here are some (hopefully useful) pointers. The good starting point is sockjs-protocol: * https://github.com/sockjs/sockjs-protocol Which contains a literate-programming style documentation which is a runnable python test: * http://sockjs.github.com/sockjs-protocol/sockjs-protocol-0.1.html You can run it against a sockjs server and see more or less if it's working. Some tests were called "fascistic" :) If you're particularly unhappy about them, feel free to raise a github issue. Btw, we have quite a few suggestions already: * https://github.com/sockjs/sockjs-protocol/issues There is a public mailing list: * https://groups.google.com/group/sockjs feel free to join it. You should be able to find some interesting discussions in archives. For example: * https://groups.google.com/group/sockjs/msg/ef42bcd3cf05fad3 * https://groups.google.com/group/sockjs/browse_thread/thread/cd2b468d312bd5e1 Additionally, we're present on the IRC channel on freenode: #sockjs When you're more or less comfortable with sockjs-protocol tests, you might want to review the QUnit tests included with the sockjs-client. Here you can see them running against a sockjs-node deployed on cloudfoundry: * http://sockjs.cloudfoundry.com/tests-qunit.html Additionally, please follow changes on "dev" branches on sockjs-node and sockjs-client, as that's where the new code is being cooked. And please, let us know if you have any feedback or if you find any nasty bugs :)
Firefox on OS X stores profiles in `~/Library/Application Support/Firefox/Profiles`. Other folks in the thread have some good ideas for improvement; I'd also point you towards the [glob](http://docs.python.org/library/glob.html) module. Something like this, perhaps: profile_path = glob.glob(os.path.join(platform_profiles_path, '*.default'))[0] places_path = os.path.join(profile_path, 'places.sqlite') 
What do you have in ~/Library/Mozilla/Firefox/Profiles/? I was reading something from Mozilla that had that and the path you put as two places the profiles could be, and I'm not sure which one to use.
Seriously, do simple stuff like moving files around, or actually quite complicated tasks once you know the ropes, in bash if you can. My personal programming hierarchy is: 1. If I can do the job in `bash` then that's it, job done. 2. Python is second port of call, I do most of my work in Python 3. C for more system level stuff, drivers, single purpose high intensity tasks, occasional spot optimisation. 4. Very (*very*) rare spot optimisation in assembler.
lxml is now the recommended solution for HTML and XML parsing. Additionally, you can use Scrapy for the actual download of the web pages (it integrates lxml as well).
http://www.artima.com/weblogs/viewpost.jsp?thread=98196
... And that's when you start wondering why you didn't use Java in the first place.
True that
Slick. I've been doing C since my Vax days, and I've always done drivers in C. I like Python (and use it for a lot of algorithm testing/development), but I had never considered it as a low-level systems language. So. TIL. Thanks!
Yes! The [set operations](http://www.catonmat.net/blog/set-operations-in-unix-shell-simplified/) in bash has me wondering what other things I've used python when I could've just kept using bash.
Don't get me wrong. Bright people are bright people. And people who know how to get shit done effectively and efficiently are worth their weight in gold. There are certainly CS grads that do this, but it seems that they develop this through their careers, not through their university training. (And one of my degrees is CS, so please realize that I am caveating my own existence here)
I am flabbergasted that I never really even considered Python as a systems-level development language. I just used C for that, and SWIG if I wanted to API-ize it. And Python for high-level conceptual stuff. TIL. Thank you. 
[os.sep](http://docs.python.org/library/os.path.html) is that variable for you, for the platform you're on.
I'm not sure I'd recommend it for anything where speed is critical, of course, but it was a lot of fun.
first off you probably want to use os.getenv('HOME'), that's going to give you the users home dir. second you should use os.walk instead of what you're doing. It will give you a generator which returns a tuple. if sys.platform == 'darwin': path = os.path.join(os.getenv('HOME'), 'Library/Application Support/Firefox/Profiles') fileName = 'places.sqlite' for root, dirs, files in os.walk(path): if fileName in files: print os.path.join(root, fileName) 
Python can expand "~"s. You just have to ask it nicely: &gt;&gt;&gt; import os &gt;&gt;&gt; os.path.expanduser("~dalke") '/Users/dalke' &gt;&gt;&gt; os.path.expanduser("~root") '/var/root' &gt;&gt;&gt; os.path.expanduser("~/Library/Mozilla/Firefox/Profiles/") '/Users/dalke/Library/Mozilla/Firefox/Profiles/' 
Although I generally agree, you could be a bit more polite. The guy's just learning...
You know it is pretty pythonic to be nice to beginners and learners.
Also a complete noob here. Is this a namespace issue?
Yeah, you *can* do lots of things in bash, but the question is do you really want to? Python is almost always more readable and easier, in my opinion.
You can just return it from the function: def curturn(turn, computer, human): if turn == computer: do_computer_turn() turn = human else: do_human_turn() turn = computer return turn Note there you can check whose turn it is, and inside of each branch you can update the turn to be other player. 
Just return the value? I'm not sure I understand.
In `curturn` you need to return the `turn` variable, and in `main`, you need to set `turn` to the output of running `curturn`. Whatever the variables are inside of one function will have no affect on other functions or even on other times you run the same function again (unless you do stuff like use global variables, but that's a bad practice in general because it makes the program too confusing). In general, your functions aren't divided up very well. The point of a function is if you're going to do something more than once, you should abstract it. That being so, `display_instruct` is probably better off in your `main` function. On the other hand, the text of that prompt and all your other prompts are better off at the start of your program as "constants" (not really constants since this is Python but close enough). So you'd do something like: WIN_TEXT = "Congratulations, you've won the game!" LOSE_TEXT = "You lose, sucker!" NEW_ROUND = "Next move!" def somefunctionoranother(): if win_condition(board): print(WIN_TEXT) return elif lose_condition(board): print(LOSE_TEXT) return else: print(NEW_ROUND) This puts your text in one place, so it's easier to proof read and makes your code parts smaller, which is also easier to proof read.
You should spend some time reviewing how parameters and return values work. A function can only access a variable when that variable has been passed in as a parameter and it can't change the value of that variable in the function above it unless it returns the new value. &gt;&gt;&gt; num = 4 &gt;&gt;&gt; def myfunc(): ... num = 7 &gt;&gt;&gt; myfunc() &gt;&gt;&gt; print(num) 4 &gt;&gt;&gt; def myfunc2(): ... x = 8 ... return x &gt;&gt;&gt; num = myfunc2() &gt;&gt;&gt; print(num) 8 Think really hard about what values each function needs to do its job (parameters) and whether that function needs to change the value (returns). For example, your `curturn` function uses a `move` value that isn't in the parameter list and changes the `turn` value but doesn't return it.
ok i see what you did here and please excuse my noobness, but here is where i get the problem i do if turn == computer: computer_move(board,computer,human) turn = human else: human_move(board,human) turn = computer return turn
There are several different things you can do to handle situations like this. If you are doing OOP then you can have a game class with players, board, and a property to indicate whose turn it is. If you are doing none OOP then you can use a global variable that can be used by any function. Many people will tell you that global variables are bad but I don't think they are always bad; this would be a good place to use a global variable. Since this variable is related to multiple parts of your program it is OK to define it as a global variable. Just don't abuse global variables (they are very tempting) and use them when it makes sense. If you are religious about not using a global variable then you can use an extra parameter in your functions and pass a variable holding the "turn state" around but I don't think this is necessarily better then a single global variable. For an example see the answer at http://stackoverflow.com/questions/423379/using-global-variables-in-a-function-other-than-the-one-that-created-them In your program you could define the "turn" variable at the top of your program and declare it as a global in functions that need to use it like I showed below. x = 'X' o = 'O' turn = x ... def next_turn(turn): global turn if turn == x: return o else: return x To answer shostyscholar's question, yes it is a namespace issue. In Python function bodies are namespaces (to be more precise, they are local-namespaces for that function). This may feel like a limitation at first but it is a really useful thing. Since the number of variables you want to share is usually much less then number of variable s you would not want to share this is the way it should work. Some languages behave total opposite of this (for example javascript, variables are global if you say nothing and they become local if you use the "var" statement) and it becomes a pain in the neck. Now I would like to point out something else. In your case the turn variable is used to indicate only two states. It is either player's turn or computer's turn. When you have variables like that you may want to use a boolean variable. Then your program may become simpler. For example instead of using "turn" you can use: computers_turn = True then you would not even need a next_turn function. You can use computers_turn = not computers_turn and this would switch the turn to the next player. Instead of using if turn == x: do something turn = o you can use if computers_turn: do something computers_turn = not computers_turn As a side benefit your program becomes more readable too. 
Python is "batteries included" you can likely accomplish much more than you realize with just the standard library that is included, no libraries needed. My advice, don't wait for the perfect idea dig in a write SOMETHING that is useful to you. Doesn't have to be big, doesn't have to change your religion, just has to be fun or make life just a little bit easier.
[lxml](http://lxml.de/) or [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) for all your web scraping needs.
I just downvote because you can't call that "Linux code" 
Your code makes me want to punch babies. You have barely any programming etiquette.
listen to me here. I said i was a noob. I am 12. I am TRYING MY ASS OFF HERE i would rather you not troll me here
How am I trolling you??? All I did was give you my opinion on your programming etiquette.
If you're into math, try projecteuler.net. It has lots of math problems only solvable through programming. You will not only get a lot better at math, but also learn how the language works. 
Don't worry about him. He's just being an ass.
Your question has been answered in other posts, but I thought you might like this in case you weren't already using it to learn Python3. http://inventwithpython.com/chapter10.html Great site/e-book about learning python via making computer games, and one of the chapters is tic tac toe with the code included. Good luck, and that's awesome you are trying to teach yourself this at 12, wish I'd had the motivation to pull that off that early. http://inventwithpython.com/ (link for the main site, not the tic tac toe chapter)
The way this works is it modifies your hosts file and map your website of choice to some other website or a bogus IP address so that you can't get to it (w/o re-enabling it again). While this tool works and you can use it right away, it also presents a pretty simple opportunity for a short programming project. Basically just write or delete an entry in your hosts file when the command runs. You will get to exercise opening/reading/writing files using python. Maybe some os.path commands for checking. And maybe regex for finding the right entry to remove later. I think it will be a good exercise.
I don't have a `~/Library/Mozilla` at all. This is on Lion, with FF 8.0.1.
Right. It's quite unclear what SockJS does then.
Thanks. I'll use the other one.
Imagine if SocketIO only did the transport fallbacks and didn't try to do all the pub-sub/channel API stuff. That's sockjs. Instead of doing an API like SocketIO on the client side, it makes the other transports look just like the WebSocket API.
Is Python more readable than `grep word *.txt | more`? Python is more readable for complicated things, but for simple stuff like moving files around, bash is good at what it does.
any one cares to comment on the cython code completion? seems a big step fwd for both the language and IDE...
I see. That's pretty nifty :) Thanks.
IMHO Scrapy using xpath is much better and easier than BS, specially when you have to scrape several websites. 
Do you know, that he is just learning? Why he uses classes? Is that really something a beginner should do? And `classmethod` as decorator? `map` and `join`? A lot of stuff I have never seen at beginner's codes... That's why I asked, whether this is skit? Perhaps he wanted to make a joke?
Thank you! I didn't know that - but I can follow Guido's pov.
That's readable if you know what grep and more are. The equivalent in Python would be longer, but require less knowledge to understand.
&gt;If I can do the job in bash then that's it, job done. Not for me, unless I'm forced to or the script is really short, like 10 or fewer lines. The reason for this is 1) I hate shell scripting 2) I love Python and 3) most importantly, I never know if my short bash script isn't going to need to be reused and expanded, in which case Python is much more preferable. 
http://www.youtube.com/watch?v=6S8OsJOP4Bw
You may be interested in [Programming Praxis](http://programmingpraxis.com).
My advice: avoid the SGML parsing method for HTML scarping and go right to XML DOM.
Consider coding some simple games. Pygame is a game development library that makes the process pain-free, and it's a good approach to learning how to do all sorts of things from file management to network sockets to graphics. there's /r/gamedev if you need help getting started, too...
Then man grep and man more. I would argue for personal tasks Bash is more appropriate because at some point you had to know what those things do to make it.
It's cool to have a project. I had similar goals and I found some python books on torrent sites and I made a text based RPG that incorporated a lot of statistics. It's kinda pointless how the statistics are integrated, but I will be using it mostly for stats stuff, so it worked pretty well.
Having tried both, I would say that to me Eclipse feels more sluggish and the Java origins are showing, a lot.
That's what convinced me, too. I tried several alternatives and even got a license for Komodo IDE (which I accidentally renewed for another year), but PyCharm is what I'm sticking with. The strong integration with common tools (coverage.py in PyCharm 2.0!) is the killer app for me. The code intelligence, automated refactorings and very customizable inspections are a huge plus, too.
$100 for a commercial IDE that can be installed cross-platform on as many systems as you need is a steal IMO. If you don't intend to use PyCharm commercially, you can probably sort something out with the guys at JetBrains to get you an Open Source or educational license. I'm using PyCharm to make money, so I don't see anything wrong with paying for what helps making my job easier.
Why not? That's code for Linux. It won't work properly on a non-Linux computer. 
It's pretty much in the definition, yes. If you value marketability of your skills higher, though, Java, C++, C#, PHP or even Ruby (it's what the cool kids use these days) may be a better choice, though. The trouble with Python is, for me, that it's incredibly hard to switch to another language if you're used to Python because everything else will feel just wrong.
As a PLC programmer, this is very interesting. What sorts of applications do you think this has?
Well, I think the main application would be teaching (it would be way more accessable/easier to get your hands on than a PLC for most people), but you really could do all sorts of things with it if it was extended to have more variable types and things like that. It effectively would become its own scripting language.
For simple stuff like grep, head, tail, sed, yeah, bash is probably the way to go. But if you have to pipe one command into another, and that into another, and that into another, 6 or more times, you might want to consider something else.
Look into OpenShot. From what I understand the bulk of the beast is written in Python, and you can probably just use whatever they're using.
awesome thanks!
I think web scraping is a great way to learn python. It's challenging enough to be interesting, useful enough to be motivating and simple enough to let you focus on learning python. FYI, if you functional/declarative scraping is more your style, lxml works with XPath. BeautifulSoup is a hugely popular web scraping library, but, as good/popular as it is, you might like lxml's approach better. Use [mechanize](http://wwwsearch.sourceforge.net/mechanize/) to fetch your pages. When you need an actual browser, use [WebDriver](http://seleniumhq.org/projects/webdriver/).
Who does "the recommended solution" refer to? Anybody in particular? Or just zeigeist? Regardless, I quite agree. I felt ashamed and excluded from the cool-kids-club when I realized I didn't like BeautifulSoup. 
Please let it be your last use of tkinter. There are so many toolkits that are better suited for somewhat complex UIs.
Very interesting. I think these are some admirable goals.
Why use os.walk? I already have to specify different code for each operating system, and calling a function is more resource intensive than just using a string with "+= "/Library/whatever/"
no problem! take care.
Such as...
On the contrary this is exactly what should be used if one expects wide use of the code. Sure TK is a little old and maybe not pretty but it is the lowest common denominator. 
I haven't installed the code yet, I'm literally on my iPhone at the moment but code like this could be very helpful This is especially the case if it is easy to use and understand. For an educational tool simplicity leads to use. For education though you would eventually need to have real I/O. Maybe support of Modbus would help there. Obviously you can emulate the real world but allowing new recruits to move things increases interest and understanding. 
I've found [this class](http://pyglet.googlecode.com/hg/examples/fixed_resolution.py) in the pyglet examples to be of use, and the ideas contained within are easy to learn and apply yourself. If you are looking for blocky scaling you want to instantiate this class with dimensions that is some divisor of your window dimensions. For instance, If your window is 800x600, giving this class dimensions of 200x150 will scale each pixel to a 4x4 block. If you don't mind bilinear filtering ("fuzzy" scaling), make sure you pass filtered=True.
Python is a very good tool for this class of user. Of course the user still Ned's to get the right result but a domain specialist will have a better understanding of what is right or wrong than CS graduate. For many Python is the only language they will ever need. Of course it is easy to run into performance issues where falling back to C++ is wise. They funny thing is at this point if performance is an issue you are likely involved in a pretty big project where educated programmers are available. In the end though getting things done generally requires a high level language. Performance usually resolves itself with the next gen hardware or a RAM upgrade. 
Who/what is Waldo? NinjEdit: saw the wiki link. 
It doesn't come with every python installation, if that's what you think.
PyQt4 is cross-platform, and you can use qtcreator to design your UI.
Given the simplicity of the Mathematica code, I think you should call Mathematica from python. 
No, but it would be easy in Node.js
Haha; let me rephrase that: can we find Waldo using only Python libraries that do not make external calls to proprietary software? :)
Using [scikits-image](http://scikits-image.org/) [http://i.imgur.com/MfbAg.jpg](http://i.imgur.com/MfbAg.jpg) I'm no expert both in image processing nor mathematica...filtering red is as far as I can go :(
It works in FreeBSD and other posix unix. It's Linux code, but not only Linux code.
empty line
scikits.learn would probably also be useful.
What keeps me from leaving Tkinter is it's canvas and text widget. If I find a toolkit that have widgets that match those, then I will switch to it on a whim.
It also doesn't look like ass.
`QGraphicsView` and I'm not entirely sure what you mean by 'text widget' but I looked at the google image results and it seems you either mean a large text entry area (`QTextEdit`) or an Excel style sheet (`QTableView` / `QTableWidget`).
#created by reddit
Hi, Just wanted to show you the `QTextEdit` widget in action with a simple font selection widget. The majority of this was created with QtDesigner and the UI file was automatically generated with `pyuic4`, if you take the time that I posted this, and see when I posted my other comment, you'll see how long it took me to make this. [UI File](http://pastebin.com/15KPR4wV) [Main](http://pastebin.com/m84jmTDp)
wow, that looks great. I'll have to upgrade from .12dev. I just can't get used to not working from a script. Love the qt console though, definitely worth the install time. 
import Waldo
Wally!
 from PIL import Image # for compatibility with Pillow (I got nothing)
I prefer the plugin because I frequently have to switch programming language at work. I really like eclipse's ability to switch my environment and context with just the click of a button.
&gt; "Tornado’s IOLoop suppresses all exceptions." Ah, here was me thinking that it was only the primitive `asyncore` that did such a thing. Given how many people are enthusing about event-driven models these days, it's surprising that they're not a bit easier to test.
&gt; Clarification: I am thinking along the lines of the resolution settings in most games. The window stays in full screen at the same size, but the scale changes. You're not really, because in most 2D games when you change the resolution, the size of the objects in pixels remains constant. In 3D games the scale appears to change, but that's just a result of rendering to a bigger buffer - the objects have the same size in 3D space.
IPython never really excited me until 0.11 came out. Can't wait to see what they do next!
Now, under debian testing, it's available as package ipython-qtconsole!
Feel free to [help us do it](https://github.com/ipython/ipython), especially if you've got some good ideas about what should happen next. ;-) For anyone with spare time but needing inspiration, we've got a [list of potential projects](http://wiki.ipython.org/Potential_projects). That's in addition to the usual bugs and feature requests on the [issue tracker](https://github.com/ipython/ipython/issues).
Will do! The only (minor) thing I can think of now, is it might be nice if the Windows installer had an option to install certain dependencies automatically (using easy_install).
I'm not sure we've got any control over the details of the Windows installer - we just use distutils/setuptools to create it. But any help with Windows stuff is appreciated, because the core developers are mostly on Linux or Mac.
I got close, but it's not quite correct: i have some false hits on the boundaries (probably issues with the boundary condition in the correlation function). Also, I had to change the correlation template form 0/1 to -1/1. Here's the code: import numpy as np import matplotlib.pyplot as plt from scipy import signal import skimage.io as sio from skimage import img_as_float import skimage.morphology as morph img = img_as_float(sio.imread('DepartmentStore.jpg')) r, g, b = np.rollaxis(img, axis=-1) red = np.clip(r - 0.5 * (g + b), 0, 1) stripes = np.vstack([np.ones((2, 4)), -np.ones((2, 4))]) corr = signal.correlate2d(red, stripes) corr_threshold = 0.999 * np.max(corr) binary = 255 * np.uint8(1 - (corr &gt; corr_threshold)) pos = morph.greyscale_dilate(binary, morph.disk(30)) plt.imshow(img) plt.imshow(pos, alpha=0.4) plt.show()
This is the best release of IPython yet. I just downloaded it and the notebook feature is amazing and intuitive. I like it a lot. Also, the zeromq architecture looks interesting. From what I've read, IPython can now support different front-ends for the kernel. Perhaps now I can get IDLE to work with IPython... ;-) 
* item[(len(item)-8):] is the same as item[-8:], but you should be using str.endswith anyway. * why did you put a continue there?
In the event someone else cares: I ran pip install --upgrade ipython on my ubuntu install and got the following error when running iptyhon. Traceback (most recent call last): File "/usr/bin/ipython", line 26, in &lt;module&gt; import IPython.Shell ImportError: No module named Shell Turns out I had the ubuntu ipython package installed, so I had to run &gt;sudo aptitude remove ipython (edit: apt-get works too if you don't have aptitude installed) then install some ipython dependencies: &gt;pip install tornado &gt; sudo aptitude install python-zmq alternatively (or if using Ubuntu older than 11.10) you can try: &gt;pip install pyzmq-static you might need to: &gt;sudo aptitude install build-essential uuid uuid-dev python-dev I haven't actually run this last method for pyzmq-static.
It looks like there's some theming capability in the newer Tk, and I've heard it can look native on windows, but yeah. Tk looks like ass. http://tktable.sourceforge.net/tile/
Ack can't get figures to re-draw in the notebook interface ... otherwise this is great. 
Have a look at wxPython demo, PIL, libsvm-3.11, neurolab-0.2.0, OpenCV2.3, ecspy-0.7 and PyBrain-0.3 for inspiration.
Thank you!
Am I the only one who doesn't use/care about these new features? For me ipython is furthermost a very good interactive python shell. It's great because it has colors, easy access to help, autocompletion and so on. Of course the fact that it has all these advanced features doesn't hurt me, but I'm afraid that in the long run ipython might become bloated and buggy. So please, ipython developers, don't forget the core qualities of your software!
Apple owns letter "i" as a first letter of an word. This is a copyright violation.
I've been using the dev version for about a month and am really impressed. For data analysis the notebook is the best environment I've encountered. I used to use Mathematica because I liked the notebook format, but I am always willing to embrace an open source alternative. Also running the notebook server remotely allows you to have a full graphical display with no lag as its only pushing HTML rather than pixels. 
Me neither. I'm trying to set plot titles without having to combine multiple calls in one line like ```plot(x);title('Test')```. Doesn't seem to work any other way.
Try bpython if you want something lean. IPython has always been bloated IMHO, at least now its got some really cool features.
I see no Ubuntu 11.04 package zmq. I tried python-zmq which installs 2.0.10.1-1 but ipython notebook says ImportError: IPython.zmq requires pyzmq &gt;= 2.1.4, but you have 2.0.10.1 
I've tried bpython, but I'm so used to IPython that I'm not going to change like that. Don't get me wrong, I still like IPython a lot, I'm just a bit concerned about the direction of the project.
Can someone tell me how to get this on my mac? objections answered in advance: * yes i do have a linux VM * no i cant run linux on my mac (mac book air efi boot doesnt work yet) * i dont usually run macports fink or anything similar, because i usually keep that stuff on my linux vm, but this would be worth installing on the "host" vm (macosx).
For whatever it's worth, pyffmpeg is maintained now. It underwent a fairly major re-write, and has a lot of (nice) new functionality (i.e. it's actually quite usable now, unlike before). Edit: Partially scratch that... Looks like it no longer works with ffmpeg 0.9?
I had something similar on the Windows version but with v 2.1.11. Unfortunately it seems that IPython does a string comparison on version numbers, which compares character by character, which means that '2.1.4' &gt; '2.1.11'.
My apologies. Fixed in my post to hopefully work better: I'm running Ubuntu 11.10 which has package python-zmq version 2.1.9-1 
I've done a bit of reading about `QGraphicsView` and it seems that it doesn't support tagging and/or complex objects grouping like Tkinter's canvas does. [Tags](http://infohost.nmt.edu/tcc/help/pubs/tkinter/canvas.html#canvas-tags) make life easier while implementing visual editors (like finite state machine editors, and flowchart editors) by allowing primitives to be grouped by a single id, and it simplifies implementing common operations like selection, etc... As for the [`Text`](http://infohost.nmt.edu/tcc/help/pubs/tkinter/text.html) widget, it makes it trivial to code things like syntax highlighting and the likes. Those two widgets are what are keeping me with tkinter. When I don't need those widget in a program I'm writing, I usually fall back to wxPython or ncurses. 
To each their own. You will eventually have to join this century. (I jest, I jest!)
So is IPython a bit like Mathematica and MATLAB?
Thanks for the example.
If I'm planning to join this century (ui speaking), I think that I'd rather learn HTML5 and resuscitate my rusty JavaScript. Unfortunately (or perhaps fortunately) the trend is htmlize everything and have faith in the cloud \*shudders\*. I'm thankful that I mostly dwell in the hardware and embedded systems world. I don't know how programmers deal with the fads that the gods torment them with.
Yeah, I'm kind of the same. I really like the stability that you can gain from the traditional methods of distributing applications (Desktop applications), rather than the browser stuff. I think I'll ease myself into it with Qt's web framework and things like that. Other than that, I'm taking a while off Python and learning Clojure, I was burnt badly by Python's threading methodology and I want a decent view of multithreading.
More than welcome!
From http://ipython.org/ipython-doc/stable/install/install.html, the simplest way to install this would be $ easy_install ipython However, I'm personally very wary of installing libraries within my base OS X install, as I don't want anything to break in the next version of OS X if Apple updates the version of Python used. I use Macports for this very reason - the installation of iPython with Macports is still as simple as $ port install ipython
The [ZMQ architecture](http://minrk.github.com/scipy-tutorial-2011/zeromq.html) for this looks like quite a feat. I can't wait to try and interface with the shell over the zmq sockets, it raises a bunch of exciting new possibilities. 
you could have done "pip install pyzmq-static" which includes the zeromq runtime instead of of installing zeromq on your system. 
Ah, I see. Updated my post to explain.
Thoughts: * Dunno why the `Foo` is there, that's not necessary. * If `Operation` is to be a method, it should take a `self` parameter. Otherwise just make it a global function, and even get rid of the class while you're at it. * `Operation` should not call itself as a way of looping. Just write a `while True:` loop and `break` out of it when necessary. * I don't understand your comment about the security hole. Yes, it's there. If you wanted to avoid it, you'd have to use `raw_input` instead of `input` (unless you're on Python 3, in which case the former was renamed into the latter). * Running `reduce` on an arithmetic operation over integers is better than running `eval` on a string that you construct.
Aptana can do this too, no?
Aptana *is* eclipse with the plugin.
Is anyone working on emacs integration with the 0mq api? I spent the last few days fighting with python-mode/rope/pymacs/anything to get them to do auto completion and launch an ipython process. I still don't have it working perfectly, and it seems some of the extensions don't like recent ipython version. Ideally it would be possible to get emacs to interact with the same kernel the front end is using. If no one is working on that, how do you guys recommend developing? Do you just use editors and reload from ipython as necessary? Is there any plan to add an IDE-type object browser to ipython, or is there an existing qt package for this purpose?
Typically things that you want to package, or even just be able to reuse, use this kind of layout: your_package_name/ your_package_name/README your_package_name/setup.py # using setuptools your_package_name/your_package_name/ # where your supporting libraries live, including a __init__.py to denote it as a module your_package_name/bin/ # where your script lives your_package_name/docs/ your_package_name/tests/ Now this can get complicated if this is a webapp and you have to have templates and assets stashed somewhere. If you need that I would look to how Django does it.