I also wish JS to die and replaced by python. But not going to happen. Gotta work with what you've got.
Aperantly
I wish this project become a success. Hopefully sonner rather than later.
For example, a library using asyncio internally creates a future (i.e. it doesn't return it you as the library client) that fails but doesn't inspect the exception in some scenarios. In turn asyncio logs the exception when the future is garbage collected, but what is logged doesn't provide sufficient information to determine what went wrong. How do you debug the lifetime of that future to determine what went wrong?
Haskell on 25 before objectivec??
Reading a book on Python so I can eventually do worthwhile things with the language.
Some of those things, yeah, I might implement, it depends on how much interest the project garners. We'll see. More pressing for now is writing more unit tests, to be honest.
I don't exactly remember how the confusion arose. It was actually an interesting subject where we addressed the same problem using pseudocode, excel + VB, C and Matlab. Ie we wrote the pseudocode first, then implemented the coded solution 3 different ways (or 4 ways in my case). This helped us to assess the relative strengths of each platform. Also made picking up the basics of each language much faster.
Headed to the CS fundamentals boot camp and the Hettinger boot camp!
yes, an oft-referred to paper on this is [Unix as a 4th Generation Language](https://www.gnu.org/software/nosql/4gl.txt) 
 File "&lt;ipython-input-1-67f87826bb35&gt;", line 1 &lt;humor&gt;But how it would read a doctor's note?&lt;/humor&gt; ^ SyntaxError: invalid syntax
If you know almost nothing about Python, why are you on this sub? The fact that you think significant indentation causes more bugs than bracket mismatches is just… precious.
Pretty much anything you can think of. What do you want to do?
I'm not so sure. I want to explore more of the language. In some way exploring more of a computer too, if you have any recommendations in how can I go about it, that would be very helpful. 
Damn just left the bay area from SoCal for the long Independence Day Weekend. Not sure I can justify money wise going up there again. ;_;
Yes, but only using extras_require. 
I hate lists like these because they're completely devoid of any context. It'd be like if I made a list of "Top 20 cars in the World" and the Ford F-150 is #1. Well, yeah... in terms of sales, the F-150 is #1. But put it in a race against a Ferrari and I'm going to put my money on the Italian. 1 for what? What are you using it for??
Crossplatform code sharing and games.
I honestly think python got this rating because of its ability to be used by multiple professions especially those not involved with CS. E.g. python is used extensively in GIS and most in that industry know no other language.
Now it's onward and upward to position zero!
It's not devoid of context. It explains what the criteria were and you can even click on the "custom" button and create your own rating.
Thank you, I will look into it but eventually we'll need to implement this feature on out own server.
Gotta wonder how many developers they have working on *just this one problem* at places like Amazon.
Use the custom ranking maker on the website. I took out google searches and twitter and reddit and based my own ranking on jobs, github and stack overflow. Python's still number one. 
"End product"? You sound like a Delphi developer. There's a lot more code in the world than commercial GUI-driven programs. 
It isn't "built on Github examples". Click the custom button and weight the factors the way you like. 
We'll only implement this in our lab so there are no concerns about security so far - these computers are fully ours (so full permissions and we trust the users not to mess with anything). File size can be around 50Mb, processing will take definitely more than a few seconds (more like 10 minutes, actually).
And someday embedded engineers will know Python, because everyone will have learned Python in school.
It *can* be, but that doesn't mean you'd want to. Python still needs a really good answer for the mobile question. 
Prolog is still very popular in artificial intelligence, even if not popular overall.
To replicate the Py2 virtual environment in Py3 as closely as possible and then upgrade dependencies gradually.
the corporate world doesn't use github we use internal private repos on our own servers exclude github and try again
Great that you're learning things on your own initiative. I would start with checking out the sidebar. 
So you're claiming here that people who write C on embedded systems for a living don't know what they are doing. Improve algorithms on embedded systems? LOL I would love to see your logic when you code, you must be quite the rockstar mate. 
Probably not. 
Thanks.
&gt;Try to learn logic programming in Python. Ok! :-) https://sites.google.com/site/pydatalog/ http://pyke.sourceforge.net/ 
It's true that library maintenance is harder. What worried me for this was not so much our code as finding some breakage or mutual incompatibility in the many libraries involved. 
You're an idiot, so I'll make it extra simple for you. &gt; it's faster than Usain Bolt on Red Bull Statement about C in general. I wanted to point out this isn't necessarily always true, thus: &gt; Only if you know what you're doing. Naively written C code isn't magically fast. "You" is used like the word "one" here. (Example: One does not simply...) It doesn't follow that I'm focusing on embedded engineers here. In fact, I had people in mind that don't use C on a regular basis (such as web devs) but might think that just writing their software in C would make it "very" fast. &gt; Improve algorithms on embedded systems? LOL I'm glad you're so easily entertained. &gt; I would love to see your logic when you code, you must be quite the rockstar mate. Weak attempt.
If you would have been on Java you wouldn't have needed a resume anymore. 
Java and Python are both excellent languages and both are widely adopted. When you say Python is seen as a starting language, that is just completely wrong. Just because it is easier for beginners to learn, doesnt mean it is meant for them exclusively. Top tech companies use Python (i.e. Google, Facebook, Amazon) and many open source projects are adopting Python. Not to mention, the influx of all of these projects and libraries are creating a massive growth spurt that Python had not seen before, which will translate to a shift in the industry. If your primary metric is which has more job openings, then sure, Java may have some more. But if you look at the historical trend and the rate at which Python is becoming adopted, I think it's safe to say that will not be the case for long. For the record, Java was the first language I learned, the language I was most comfortable with, and by far my favorite. The second I had to learn Python for one of my jobs, that opinion quickly changed :) 
&gt;the corporate world doesn't use github &gt; &gt;we use internal private repos on our own servers There's more than just proprietary, commercial code in the world and the corporate world is generally using what everyone else is using. Regardless, taking out Github doesn't change Python's #1 position.
Exactly, python is not the nr1, it's Java. If you like it or not. The java who runs most of the backend business logic isn't on github, what are these guys thinking. Bah
Python is used for a lot more than web dev.
Isn't Rocker written in R? https://github.com/rocker-org/rocker
Although I would recommend that you rewrite the API in Python to the best of your ability, the pyjnius package will allow you to call the JVM (requires Cython to be installed).
That's still odd. In my city there are little to no web jobs for Python. Mostly all C#, PHP, and node (or some front end JavaScript architecture). 
You could always use the built in markdown previewer in atom
numpy arrays need to be square, so you need to pad the rows. Something like this should work: lines = [line.strip().split(' ') for line in file.readlines()] N = max(map(len, lines)) lines = [line + [0] * (N-len(line)) for line in lines] array = np.array(lines, dtype=np.float32)
But there _are_ real end-to-end products built with Python. Lots of them. (There may be some with R, too, but that was the point of the comment - whether not Python is a scripting language is not the point.)
Great post. Very informative. 
I am getting an error below: Traceback (most recent call last): File "FileCha.py", line 43, in &lt;module&gt; L = readElements() File "FileCha.py", line 36, in readElements array = np.array(lines, dtype=np.float32) ValueError: could not convert string to float: The section of code I have now: def readElements(): f = open('Elements') lines = [line.strip().split(' ') for line in f.readlines()] N = max(map(len, lines)) lines = [line + [0] * (N-len(line)) for line in lines] array = np.array(lines, dtype=np.float32) return(array) # changefile() L = readElements() print(L) Sample of where the columns change from the actual file: 173 2 2 10 10 90 91 42 174 2 2 10 10 90 41 93 175 2 2 10 10 10 44 93 176 2 2 10 10 41 10 93 177 2 2 10 10 58 42 91 178 2 2 10 10 59 91 89 179 2 2 10 10 44 92 93 180 2 2 10 10 90 93 92 181 2 2 10 10 89 91 90 182 2 2 10 10 92 89 90 183 4 2 100001 100001 80 97 95 84 184 4 2 100001 100001 16 82 36 68 185 4 2 100001 100001 62 20 88 87 186 4 2 100001 100001 76 46 97 95 187 4 2 100001 100001 34 78 47 97 188 4 2 100001 100001 96 83 66 97 189 4 2 100001 100001 46 83 85 96 190 4 2 100001 100001 46 80 85 83 191 4 2 100001 100001 91 59 65 73 Thank you for helping me, please advise how I can fix the issue.
I checked it just now and C is not listed at all when only Web is selected. The list, copy and pasted, is: 1.Python 2.Java 3.C# 4.JavaScript 5.PHP 6.Go 7.Ruby 8.Scala 9.HTML 10.Perl 11.Lua 12.Rust 13.Processing 14.D 15.Clojure 16.Ocaml 17.Actionscript R isn't even listed for Web either. R only shows up for Enterprise. C shows up for everything _except_ Web. 
You can do this. np.array(lines, dtype=np.float32) implicitly casts each element of lines into a float, but is failing because one of the elements cannot be converted to a float. Figure out which element(s) it is and fix it. 
Could it be because there are two spaces separating middle of each row in lieu of one?
No, split() should handle that fine. Open it up in ipython or a debugger or add a print statement and take a look at what is in the lines array.... debugging 101.
I'd never heard of LOLCODE. I might look into developing this professionally through crowdsourced dogecoins.
I'd like to propose adding [Construct](https://construct.readthedocs.io/en/latest/) to your list, as I use it quite often to parse binary protocols! Also great post :) 
Unfortunately I never have debugged something like this and don't know what the messages mean. here is part of the output that I think is relevant. ipdb&gt; ValueError: 'could not convert string to float: ' &gt; /usr/lib/python2.7/dist-packages/spyderlib/widgets/externalshell/sitecustomize.py(81)execfile() 80 filename = fname ---&gt; 81 builtins.execfile(filename, *where) 82 except ImportError: ipdb&gt; --Return-- None &gt; /usr/lib/python2.7/dist-packages/spyderlib/widgets/externalshell /sitecustomize.py(81)execfile() 80 filename = fname ---&gt; 81 builtins.execfile(filename, *where) 82 except ImportError: 
That's reflected in the rankings. Both Python and C rated 100% but their use is across different platforms (as primary use). Java and C++ went far behind, also mirroring Python and C in terms of their primary platforms respectively.
So I edited the file to shorter and consistent one, it still didn't work got same error. Then I removed the double space to single space and it worked. It looks like it is due to the double space.
Found the solution [HERE](https://stackoverflow.com/questions/2492415/python-split-by-1-or-more-occurrences-of-a-delimiter) Thank you for assisting me and pointing me in the right direction.
Netaddr is probably the library you are looking for, specifically the [is_private](https://netaddr.readthedocs.io/en/latest/tutorial_01.html#private) function of IPAddress. https://github.com/drkjam/netaddr/
Also, more importantly, what are you doing this for? Access control? Maybe doing this in the web/app server is better, because if you ever put behind a proxy, might always return true as a local network.
This is an advertisement. 
To me, using a DI framework on individual method calls is silly. If you need two file handles in a method, the caller of that method should provide them. Ideally, you push IO as fast from logic as possible (in practice this is easier said than done - though the SansIO stuff is very interesting in this regard). As for wanting two db connections, probably to different databases, you could use generics and a marker interface to tell the two apart. We do this at work in C# (which is much more rigid about types). If you want two database connections to the same database, then you're probably doing something silly. It's not impossible, it just requires a little more forethought. 
Have you considered not using a virtualenv for ROS and then just using one for everything else?
ROS just installs the packages globally, so I don't understand how to avoid this.
I hate to say it, but a project that heavily uses type hints is probably better off weeding out contributors that don't like them early, as those PRs are probably going to result in quite a bit of friction. Having been on the maintainer side of that, accepting critiquing PRs from someone who doesn't seem to get the ethos of a project is a balancing act between going "this is all wrong" and being polite. Sometimes the person simply doesn't know better, but sometimes it's done intentionally. 
Really nice article. I especially appreciated this after having done a lot of work in Angular over the last few weeks; I've only just become comfortable with dependency injection and mocking, and seeing how it can be done in Python was great. 
Assuming this is posix and not windows: 1) scp. If this fails you will need to catch the error client side and send or log some kind of alert. 2) cron job that checks the target directories every few seconds or whatever for changes and executes your processor. Could also do this with a daemon. 3) put this code at the end of your processor. The cron job should wait for the processor to finish, returning either an error or success, and log/alert accordingly.
what?
You should be able to do this if you install from [source](http://wiki.ros.org/Installation/Source). Follow the *generic* instructions in *Section 1.1*. Make a virtualenv, install: `pip install -U rosdep rosinstall_generator wstool rosinstall` into it, and then you can proceed with the rest of the ROS install. I always installed ROS globally, but I think this should work . . .
I tried this, but sadly it doesn't use pip and installs the packages from apt...
Direct to the source Playlist on youtube * [ Python Tutorial for Beginners (For Absolute Beginners)](https://www.youtube.com/playlist?list=PLS1QulWo1RIaJECMeUT4LFwJ-ghgoSH6n)
It seems a parser for binary data, while I was focusing more on textual languages but I will look into it. Thanks!
Thanks!
Pretty cool, though the usage of python 3 types and asyncio and ancient python2 classes is a bit confusing.
You can do preetty much anything you can do with any other programming languages. Create websites, command line tools, rest APIs, GUI apps, machine learning apps, etc. You might want to start with writing a script for automating your repetitive tasks.
That's fair! Just a suggestion :) 
Logic programming is hardly used at all by businesses, but it's an important CS concept. 
[pip-tools](https://github.com/jazzband/pip-tools) (pip-sync)
Which step of the install gets packages from apt?
Then what IS the point? You don't use R to develop word processors. You don't use SQL or bash for that either, yet most companies have a large amount of both involved in critical business processes. 
`rosdep install --from-paths src --ignore-src --rosdistro lunar -y` This normally fails and if given the OS installs all the packages from apt.
OK, so I *think* you want [Ansible](https://www.ansible.com/) due to the part about multiple machines, and I think you want **alias** (in `bash`) for the bit about wanting it "controlled by your dotfiles", but I haven't a clue what you're trying to do or suggest, exactly, for either. Also **hassle** not **hustle**...
A few questions: can you post the error msg? are you installing `desktop_full`, if so can you try just `desktop`, or `ros_comm`? did the rest of the steps work fine? can you post the contents of the rosinstall file? (EDIT: Just checked on my system, and this file gets really long. . .so maybe not post it here directly . . .)
`out += value` But `out` is a string and `value` an integer... Btw, I think a `join` would make more sense than concatenating values and separators and at the end removing the last separator...
I always assumed they were activated through pure mechanical triggers...
Now you have two problems!
Interesting !
Ahhh, web scraping. Use [Requests](http://docs.python-requests.org/en/master/) to pull the page HTML and then use [Beautiful Soup](https://www.crummy.com/software/BeautifulSoup/) to do DOM queries. [Scrapy](https://scrapy.org/) is a another popular choice but I haven't used it since reading the docs for it takes longer than actually writing a scraper from scratch. At least for the purposes I've encountered.
That's what i thought too...
I'm going to try to reinstall. I am really going to regret this at work tomorrow. :P I will update this as I try to do so.
You know how much the licence costs, or is it individual pricing depending on company size/revenue? 
Ya python is the most intuitive language to get up and running with. If you want to be able to use the power of your computer to accomplish tasks on your data with clean and simple libraries and APIs there isn't really a comparable language with the same community.
I need to sleep as well, but in the mean time, I did the source install in virtualenv and, it **does** install packages from apt- but only to satisfy the dependencies of the packages you have downloaded. You can try [something like the `--filter-for-installers "pip"` option](http://docs.ros.org/independent/api/rosdep/html/commands.html) Otherwise, you can run rosdep with some combinations of flags to just get the dependencies and install those manually through pip. Keep in mind, there are a bunch of other non-python dependencies that need to be satisfied, so you will still need to deal with those, which can be a pain if you're doing it manually. Or just let rosdep do it's thing. In general, python packages that you install through apt- should not cause you any trouble with your python install. Virtualenv is more for stuff you install from pip that can conflict with your system package manager, so it's probably fine to let rosdep do it's thing, and even to install ROS from apt.
I get this error when I run the command I wrote above: `ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies` The full error can be found here: `https://gist.github.com/c0nn3r/3cccce36ca6d53787a37fd419be16a9d`
Thanks! Fixed in https://github.com/pquentin/blog/commit/af3a3ae9821ec9e410891538f57461215b531fd3 and https://github.com/pquentin/blog/commit/e63abcaba028f7c45520b051555535172e4c0f5a
What do you mean by "ancient python2 classes"? If you refer to me writing class Cron: Instead of: class Cron(object): Then you should know that in Python 3 all classes are "new style" classes, so in Python 3 the two forms are equivalent.
Wonderful!
I will definitely use this! Looks fantastic, thanks OP
Get 3. 2 is dead.
I've been fiddling around with TatSu for a while, and making progress on a parser I've had on the back burner for years. I think the docs need more examples, and the error-handling could be more clear, but it seems well-constructed.
3.5
Well, another name for circular in such cases is "network effects". And they play a big role in language adoption. Eg, there aren't tools for X, so no one uses X, so no one writes tools for X.
Don't run PyGame code inside IDLE. Use a different editor like Sublime Text or VSCode.
As someone who's seen hardware people writing software, it's often quite bad. Recent example, using bubble sort to get the single maximum of an array. In a camera driver. 
Yeah, for sure. I had a job interview this month where 90% of the questions asked were 2.7 specific. Companies are still stuck with elder snakes.
You can always learn 2 from 3 if needed.
I mean, yes, primary Python ought to be 3.5++ but 2.x isn't really dead dead, it's more like on cardiopulmonary bypass machine.
We need an answering bot for this question.
This is a really good idea! I just think that the name is terrible! Please try to find a better name and rename the project; no "ya" :) You can see a lot of people are excited about the project itself... N.B. I speak as a person who regrets creating something by the name of "yagmail".
Looks like scripts for optimizing music libraries is the python equivalent for the toy web framework every PHP programmer needs to write. (yes, I'm guilty too: https://github.com/desfrenes/Tags )
&gt; If you know almost nothing about Python, why are you on this sub? If you know almost nothing about search engines, why are you on the Internet?
👍
Well, you know what they say, two hardest things in computing science: naming things, and cache invalidation. Sorry, but no, I'm not going to waste everybody's time with renaming. Just not worth the effort IMHO...
Why did you use hsaudiotag and not mutagen or eyeD3?
Your "game loop" code (`gameDisplay.fill` etc.) isn't being executed until you quit. This is because you have it nested at the far left so it won't be executed until the `while` loop is terminated. If you want to execute it every loop, then nest this code at the same level as the `if event.type` lines.
Good one, thank you
I first learned about pentominoes in a book *Fountains of Paradise*. I read it in 1987, so I wrote a solver in Borland Turbo Pascal. I had to make it resumable so others could use the machine. It took 4 CPU months to find all 2339 solutions to 6x10. Later I wrote an *obfuscated* Perl\* solver, where every solution was printed as a functioning copy of the original code (a sort of quine). It used recursive regular expressions to find the places pieces could fit in a 2D board. In turn it designed these regex strings on the fly using a tiny turtle drawing language like LOGO. Speed was not my goal. \* Perl can easily become obtuse. Not all obtuse code is worthy of being called "obfuscated." But yeah, it's funny. 
I'm finishing up a script to handle the boring parts of an event I run on /r/piano. I thought it was broken, because it was telling each piece that was entered was entered exactly twice. But no, turns out that's what's actually going on. THANKS ASSHOLES.
Continuing my work on a completely free open-source alternative to services such as Pusher. Real-time scalable websocket notifications so people can implement things like slack or social website notifications to name a few. Becoming quite a big project but as the sole dev it takes a while. :) I didn't like that there were so few non-subscription based services out there that you could host yourself. https://github.com/thenetcircle/dino/ Edit: some things involved: flask, socketio, sentry, statsd, rabbitmq, cassandra, rdbms, web interface, rest api.
Agreed, when I first started porting things it was the smallest, least dependent scripts circa Python 3.2, but even there I had to port some libs myself. Around the Python 3.4 era is where it seems the bulk of libraries in everyday use had started to be ported, and now we're well into the 3.6 era, basically anything lib that's Py2 only we're treating as abandoned and to be stayed away from. I hear a lot of hoopla here and on HN from butt hurt print as a statement fans, and people who're insistent that the libraries they use are Python 2 only but are strangely silent the moment they're asked to list them. It's just not that painful anymore. It was painful. I think the 3.0 / 3.1 era should have been branded as "test if you can", and that 3.3 was where it really became a plausible replacement. Python 2.x scripts and code that aren't being touched much at all can and should just be containerised with everything required to build them from scratch, because if it ain't broke and ain't going to change in the future, there's no need to put effort into it. There's heaps of COBOL and Fortran out there that says it's perfectly possible to keep it going many years into the future.
This doesn't feel very pythonic: so much string concatenation and list buffering :D I guess it is fine for a debug tool but I wonder if this wouldn't be a lot more efficient with generator(expression) and join()'s instead of concats.
You're right. yield + join is indeed how CPython does it. But efficiency was not a concern here.
3.6
Why you're getting downvoted: * It's a frequently asked question with a very simple answer. * r/learnpython
For those who are interested in Python for embedded, take a look here: [The Rise of Python for Embedded Systems](https://www.zerynth.com/blog/the-rise-of-python-for-embedded-systems/) I hope it will be useful.
You fucking legend, I love you mother fucker. You get an upvote and I would give u gold but im 15. U beast Take ur upvote
Heh yea, that is very appropriate. What about `aiocron`? Or maybe someone else could make a suggestion :/ EDIT: Ok that already exists, I find the "ya" name more appropriate now. I think you'll later regret not having changed it before adoption though :(
This is really cool, I have briefly thought about it before, and I'm happy you gave the conclusion to the story :) (regardless of the code, the story is the interesting part for me!)
F you and your redirect. 1 down-vote isn't enough. Also, it continues to reign because it solves a lot of annoying problems, moves fast and is updated, has an admin, is pluggable (see DRF!), and generally just works. Its not hard to come up with reasons. 
The IEEE spectrum app is very interesting, but also seems to lead to a lot of flawed conclusions... For example, just because Python is not tagged as 'embedded' in the app, doesn't mean it is used less in embedded systems than Erlang, which happens to be tagged as such.
Look, I appreciate your concern but (1) we could have a big debate which name to change it to, (2) I think it is more important to have a name short but easy to remember, and I think yacron is reasonable in that regards. Who knows, maybe some day someone can fork my project and give it a better name. I would be totally cool with that (but not yet, please, too soon..).
I agree with you about using the IP address module -- it's easy. I did something very similar to your example: https://github.com/jftuga/universe/blob/master/tcpscan.py#L76 (the is_ip_on_lan() function)
Do you want the bot or the functionality? http://www.mediahuman.com/howto/download-youtube-channel-updates.html
Out of interest, can you describe your Turbo Pascal solving algorithm?
I'm not here for a debate; I've said what I wanted to say... which was just trying to warn you of what I felt was a mistake I made. Regardless, good luck with the project, I will consider using it the next time I need cron in a project.
Clarification: I'm not talking about packages I've written. Rather, I was using pandas a couple days ago (running code that a colleague had written that imported pandas), and I was surprised to find that I was missing some dependencies, given that I'd tried pretty hard to find all the dependencies in my colleague's code, and then assumed that all the dependencies of those imports would be pulled in by pip. After figuring out what was missing, I found via the pandas website plus some issues on github that pandas has optional dependencies that are described in the docs, but are not actually coded into setup.py. This surprised me and I find it hard to believe it's good practice.
[Cached version](https://webcache.googleusercontent.com/search?q=cache:-F31l-w3tE4J:https://www.zerynth.com/blog/the-rise-of-python-for-embedded-systems)
No problem. Next time you might get a faster/better response out of the /r/learnpython subreddit as that's more geared to beginners. Good luck with Python and well done with your effort so far!
You're using data from poloniex, so what possessed you to name your library after their biggest competitor?
If they ask questions that are so specific that the answer is only correct for 2.7 then they are asking extremely dumb questions.
 It was before I knew anything fancy about recursion. However, making it resumable (start in the middle of the search) makes recursion more difficult anyway. I haven't read the algorithm in the OP, and I wrote this while a beer is wearing off. For twelve pieces, keep an X Y R pointer for the current position. On startup, if given a filename, read in the current values for X Y and R to make the process resume-able. Otherwise, all the X Y are in the upper left corner, and the first rotation value for R. For the first piece only, the freedom range is only the upper left quarter of a symmetrical layout like a 6x10 rectangle. For all others, the X Y can be moved all over the board. Another number defines which piece we are trying to move. We start with the first piece as the current piece. Considering the current piece only, (THIS PIECE) Move the X rightward by one, (NEXT PLACE) If that X is off the right edge of the freedom zone, Move the X to the left edge of the freedom zone, Move the Y down by one, If that Y is off the bottom edge of the freedom zone, Move the Y to the top edge of the board, Mark the PREVIOUS piece as active instead of the current piece, If there actually is no PREVIOUS piece, Stop, you're done moving all the pieces everywhere. Start from the top of this routine for THIS PIECE. For each R rotation valid for the current piece, (NEXT ROTATION) Try drawing the piece into a copy of the current board. If any clash with other pieces, Fail this location and retry at the NEXT PLACE. Separate optional heuristic check for performance: Are there any smaller pools of free areas not divisible by five? If so, Fail this location and retry at the NEXT PLACE. Adopt that new board configuration with the new piece drawn in. Mark the NEXT piece as active instead of the current piece, If there is no NEXT piece, Ring a bell, save the board to a file, you FOUND A SOLUTION. Erase the current piece from where you drew it. Continue the looping at the NEXT ROTATION.
I use all the major exchanges but Poloniex has the best volume for trading altcoins :)
How is this better than qunatopian.com ?
Right, but why would you create so much ambiguity by using a name that's already taken in that space (crypto trading)? That's like me releasing a Factset/BB competitor and calling it IEX.
Hacked together a script that uses markdown and weasyprint to collate my character's journal entries (which are stored as a markdown document per day) together for the D&amp;D 5e game I play in and print the complete journal as a single PDF document. This makes it easier for the DM and other players to review my journal. It also makes it easier to search the entire journal for keywords such as NPC, monster, or location names. I eventually plan to write some more scripts including, I hope, a journal indexing and search script. However, being able to search the PDF will do in the short term. One of the first times, that I can recall, that I have used a for-else statement. 
Smaller learning curve, more customizable, open sourced code are my main reasons. I also don't know if you can use cryptocurrency data with them.
Eh, it's just a name for an open source project, guess I didn't really think about it too much! I didn't name it after the exchange, I just like the name.
I want it to carry it out automatically
Dropbox got quite far with a custom Python interpreter. It did not work very well for them. A simpler method would be to write a script to decrypt another script but that's trivial to break. You could transpile (machine translate) your Python to C and ship a binary. But even binaries get hacked, there are countless cracked games and apps. 
First thing. I tried the example in the docs and got KeyError: 'defaults' stacktrace. It would be nicer if the example ran as is and if that error message (defaults needed to appear in the YAML) was a bit more meaningful. Second thing. Might I suggest [trying my library](https://github.com/crdoconnor/strictyaml) to parse the YAML instead of PyYAML / jsonschema? I wrote it among other reasons to give nicer error messages when parsing with a schema, so instead of [giving this as an error](https://gist.github.com/anonymous/910f513c60a32db15ee0cc8cc5a42a78) it would give this:: YAMLValidationError: while parsing a mapping unexpected key not in schema 'somet' in "&lt;unicode string&gt;", line 13, column 1: somet: d ^ (line: 13)
Well... I did use Mutagen and then eyeD3 (https://github.com/desfrenes/Tags/commit/5fdf8a517fc1c4f53ca37461cc06b2567094257d) but later replaced them with hsaudiotags. I must have found hsaudiotags.auto better with mixed bag of mp3/mp4, I guess (https://github.com/desfrenes/Tags/commit/2aeb27e2d1e568c8333360c267c32b7eb8c9a210)
No, python is a general purpose programming language: &gt; Python is a widely used high-level programming language for general-purpose programming Straight from python.org
Source: http://evontech.com/what-we-are-saying/entry/why-django-is-the-best-framework-for-python-developers.html
Hi Simon. I'd be interested in looking into this to see if it makes sense to cover the topic. It would be cool to discuss it. Want to contact me here? talkpython.fm/home/contact
Neat, thanks!
I have to say, the site uses an awful layout. Why do I need to manually zoom in to see the full content on a now standard widescreen monitor??? [Picture of this mess...](http://imgur.com/a/jjafG)
&gt; First thing. I tried the example in the docs and got KeyError: 'defaults' stacktrace. It would be nicer if the example ran as is and if the error message was a bit more meaningful. Oops! Sorry. I uploaded version 0.3.3 to fix this. &gt; Second thing. Might I suggest trying my library to parse the YAML instead of PyYAML / jsonschema? Hm, I just learned JSON Schema and you ask me to learn another schema language :-/ I'll have to think about it. For now filed it as an [issue](https://github.com/gjcarneiro/yacron/issues/4) in the tracker. Anyway, thanks for the feedback!
I really want to go to djangcon and attend your tutorial but I live too far away. I know djangocon usually upload talks but I doubt they would upload tutorials. That said, I was wondering if you have any plan of releasing your tutorials online on udemy or similar websites.
The pypi page does not mention support for python 3.6. The package contents appear to contain a windows dll (pyd file) for each supported version of Python and it has not been updated with a version for 3.6 yet. It looks like you're stuck using 3.5 for now.
You miss Pyrser from Lionel Auroux http://pythonhosted.org/pyrser/
I am just starting to learn python with Codeacademy.
But mutagen handles every audio-filetype. Right now I use the mutagen easyID3 classes, but I want to look for a better alternative. In my case, I also included a script that will look for non-mp3 files, so I only need to look for mp3 files.
Anything you're at liberty to share? Sounds interesting (though my physics are limited to compsci bachelor level).
Thanks, I will look into it
What i meant was do you really want to program something yourself or just use the tool i gave you that will do it.
Programs running on applications processors (like on the Raspberry Pi and Beaglebone Black) on top of a General Purpose OS (like Linux) subscribe to the loosest definition of an embedded system. I'd bet a good deal of those "C" programmers are on microcontrollers with memory constraints. Unless you have a system with loads of heap space and extra clock cycles, Python is NOT viable.
I'd like to give programming it myself a try
I've been working in and around embedded systems for about a year (still a student) now and while I love using Python in general, I can't help but feel it's too late for Python to try to take on embedded. First of all, while Python should be easily available on any ARM based systems, I'm not aware of any way to run Python on a PIC or AVR (although I may be surprised here). Secondly, the resources listed in the article of 60-80k flash and 3k-5k ram are definitely not guaranteed; there are systems with much less than that in embedded where Python might struggle to run efficiently. Though I guess their VM has been tuned to handle these low resource systems. Lastly, with the rise of languages like Rust which has a much stronger focus on safety guarantees that embedded desperately needs, I'm not sure if Python is the right language at the right time. Having said that I'm all for displacing C from it's throne in embedded. I love Python and I love C, but C can be a dangerous tool, too dangerous for how much it's relied on in embedded. 
No, not in a safe manner for python nor any other language know today. You could have a look at [fully homomorphic encryption](https://en.wikipedia.org/wiki/Homomorphic_encryption#Fully_homomorphic_encryption). But i doubt that it will be feasable in the next 5 years or so.
**Homomorphic encryption: Fully homomorphic encryption** The examples listed above allow homomorphic computation of some operations on ciphertexts (e. g. , additions, multiplications, quadratic functions, etc. ). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
This is the dumbest idea ever. No good developer is going to spend their time writing code for a contest. The rest of the pool who are stupid / naive enough to waste their time on this are going to give up after they realize they need specific hardware for the fucking barcodes. This is incredibly stupid.
Maybe some kind of "Memory Constraint" module that gives python hard limits? 
&gt; too dangerous but I think the reason it has all that "danger" is because of things you need to do in embedded: write directly to memory locations, manipulate values in the stack, have a low memory footprint, etc
You can gzip and base64 it then just do the opposite before you run it. Of course this is not encryption (which would be mostly useless anyway because it would have to be decrypted before it was run anyway which means the client would always be able to decrypt) The only thing this does it make it unreadable at first glance but anyone with a brain can recover the source Try this code (if you don't trust me just change exec to print): import zlib;import base64;exec(zlib.decompress(base64.b64decode("eJzjSssvUshUyMxTKErMS0/VMDTUtOJSAIKCosy8Eo1MLS0jTS4AyQcJ7Q==")).decode("utf-8")) It's this code with gzip -&gt; b64: for i in range(11): print(i**2) code to generate: import zlib import base64 def compress(code): return base64.b64encode(zlib.compress(code.encode("utf-8"))).decode("utf-8") code = """ for i in range(11): print(i**2) """ fmt_str = 'import zlib;import base64;exec(zlib.decompress(base64.b64decode("{code}")).decode("utf-8"))' print(fmt_str.format(code=compress(code))) 
I went last year and thought it was definitely worth it, so I'm going again this year. Good food, awesome hallway track (really), and great speakers.
I don't think that's necessarily true; when I wrote it I more meant that a lot of embedded systems have significant importance in whatever they are embedded into. Whether it's medical devices where a malfunction can be fatal or an assembly robot in a factory that controls high power motors. Those things listed are definitely dangerous but I think, given the power that some embedded systems have, it's really critical to have a safer language that makes it difficult for programmers to make "simple" errors like the kind one might find in sloppily written C code that reads and writes directly to registers.
Man based on your expert evaluation I should just march right into his office and tell him to pull the plug... If you're not interested how about just moving on.
great! will check out=) 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Yes, you should march into the office and tell them to pull the plug. By putting forth this contest and publicizing it, your company is essentially putting out a big sign saying that you don't understand how the software industry works and you're unwilling to pay reasonable wages for software development. The project being described is the sort of thing that someone with the necessary skills might do on a $10k contract. More likely, closer to $50k.
/r/learnpython/wiki
Udemy, Great classes. 
All that does is limit how much you can use, it doesnt change how much is required. C will absolutely use less memory (if done right) than python. Python is for ease of development, not reducing resource usage.
&gt; memory is very cheap now. Embedded is now full of it. "Embedded" headless PCs or "Embedded" *embedded*. This is what the current chip I'm working with has: - 2 x e200z4 in delayed lock step operating up to 200 MHz - Up to 2.5 MB flash memory w/ error code correction (ECC) - Up to 384 KB of total SRAM w/ECC 
Actually, micropython and zerynth (whatever that is) is mentioned in the article. While I have no experience with either, I could see a suitable limited subset of Python being useful for at least part of the embedded-ish¹ code I write. There are a few cases (interrupt handlers and SCC managment) I have trouble seeing handled effecient by Python. The rest, which is mostly protocol handling and the high level communication with either the 422 bus or the host system, could easily be written in python. There it would more be a matter of how dense the code is. The bytecode is OK, so it's a matter of how much space the runtime requires. 1. Running on a FPGA remake of the IBM Artic RIC card with 2MB RAM and a 80186 emulation on the same FPGA.
Here, I'll summarize the article for you: 1. Python is really popular! 2. Hmmm, but it's not popular for embedded. 3. &lt;An advertisement for Zerynth&gt; I didn't know about Zerynth before though, so I did get some value from this.
whatever 
This belongs on /r/ProgrammerHumor
u/sentdex has a youtube series that really helped me (a lot.) I started learning python to automate parts of my job (investment banking) and this man taught me python in a matter of weeks (from the ground up.) i'd HIGHLY recommend watching his videos and coding along with him. i've tried codeacademy and MIT's online into to python class and sentdex has been the best resource by far. https://www.youtube.com/watch?list=PLQVvvaa0QuDe8XSftW-RAxdo6OmaeL85M&amp;v=IX6mc9l6tY4 
What this have to do with python? Spam.
I liked the book Automate the Boring Stuff with Python. A great book for beginners. There's also a Udemy class that covers the book. 
Video linked by /u/YoloSnek: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Installing Python 3 - How to install/use both Python 2 and Python 3](https://youtube.com/watch?list=PLQVvvaa0QuDe8XSftW-RAxdo6OmaeL85M&amp;v=IX6mc9l6tY4)|sentdex|2014-01-22|0:15:47|651+ (95%)|139,926 &gt; Sample code for this basics series:... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/YoloSnek ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dkhmv6j\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Looks glorious, what's the catch?
Right, so rosdep wants to install all those packages to satisfy the dependencies in ROS. It doesn't know what OS you're on (which distro), so it's throwing the error. AS I said, ROS has *a lot* of dependencies, and you will need to install them. Most are not python (e.g. Eigen, Boost), but some are (e.g. python_qt_binding). You will have to tell it which OS you're on, and it will need to install stuff from apt-. If you really want to do the virtualenv thing, you will have to deal with the dependencies manually. I would still advise installing with apt- (just do apt-get install ros-whatever-whatever) because system python packages should not cause any problems, and use virtualenv for stuff you install from other sources. This is looking like a lot more trouble than it's worth . . .
heh. The catch is it has been long in the making?
No, but it shouldn't make a difference.
Sad prize amount for the feature set you want, think that amount or more yearly for an off the shelf cloud solution. I'm also deducting points for failure to have some sort of submission solution worked out.
Looks nice but can this be used for embedding python inside c++ application with exposing some API to python scripts loaded at runtime? Currently pypy + cffi is one option for that.
Is it new hardware? No one's going to argue that old hardware can suddenly support modern software.
Brand new. Supported through 2029.
I've worked with micropython, and it was an absolute pleasure to work with compared to arduino for example. I loved having a repl prompt to the microcontroller (it's even possible to get a repl prompt over wifi), and no compile time. Typing in a command and having it instantly execute, is a must have when doing rapid prototyping, I wouldn't go straight to putting micropython as the language for things like washing machines and fridges, but for prototypes and maker style projects it's amazing. Micropython has definitely won me over as the language that will be powering my next tinkering project.
&gt; you can buy 2 GB 1.5GHz quad core odroid PC alike for what 40$ That's cool. If that product will do what you need it to. Is the odroid CPU ISO 26262, IEC 61508, ASIL-D certified? Edit: Spoiler alert, [No](https://i.imgur.com/Oq6J18p.png). The Cortex-A53 is targeting application processors not real-time processors. It's based on ARMv8-A, the embedded real time safety cores are ARMv8-R.
Well cool man, looks really easy to use which is something I'm a fan of
I've never heard anyone say "if loop". Are these native English speakers? If not, they might think that "loop" refers to the structure of the code where you have `&lt;keyword&gt; &lt;expression&gt;: &lt;newline&gt; &lt;indented code block&gt;`
Some are native English speakers, some are not. What they all have in common is that they all seem to be fairly new to programming.
/r/learnpython
Been in the game for 21 years, never heard "if loop" before.
You're getting a compiler error. Google the clang compiler flag -fopenmp to learn what it does. You should be able to figure out why that flag is causing you issues when you have read more about it. 
You can see it mentioned here and there on the internet. Mostly by people new to programming, but here's some old IBM documentation: https://www.ibm.com/support/knowledgecenter/en/SSSHRK_4.1.0/itnm/ip/wip/ref/reference/nmip_ref_stifloop.html
&gt;you can buy 2 GB 1.5GHz quad core odroid PC alike for what 40$ ? Wat? There's absolutely nothing *embedded* about that hardware, that's a full blown PC. For 90% of the embedded use cases that hardware ranges from absurd / useless all the way to potentially life threatening (where non-EEC memory would not be something that is even considered).
Cool writeup. For the plebs who don't need to color code their json and just want it cleaned up python provides a nice tool for that `python -m json.tool some_ugly.json`
They call it so because they have learned a wrong thing 😈 For all german speakers there is a website that makes it clear: http://if-schleife.de/ (*Schleife* is simply the german word for *loop*)
Beating my head against the LinkedIn Ads API
Practically anything labelled as a microcontroller is going to look something like that. Applications processors with clock speeds in the GHz and DDR peripherals are orders of magnitude harder to layout on a PCB. You go from a 2-4 layer board to 10 layers with blind vias (i.e. $$$$). I'm not going to get started on the complexity of the build systems. Most embedded systems have no need for that sort of power. It's a really hard sell during design time when you want to allocate tons of extra resources and skilled labor just because you wanted to use a language that's easy to write in.
The author is wishing for this to be true even though it is not. There is no "rise of Python for Embedded Systems". There's possibly a rise in its use for hobby systems for RasberryPi systems but those are at the far end of "embedded systems" and most people would not call them embedded systems.
Some of them are actually german! It doesn't explain the native speakers, though.
Would you agree that Python's dynamic typing is a dangerous feature of the language on critical systems? The only think that I can think of that Python would do better is garbage collection.
/r/learnpython or http://python-guide-pt-br.readthedocs.io/en/latest/scenarios/scrape/
I think it is a good habit to write documentation (even if short) for every function you create. Thanks for sharing.
Could you show the source?
Yeah, presumably they learned that while (foo): bar is called a "while loop", so they assumed that this: if (foo): bar is called an "if" loop.
Interesting. Maybe calling it a "loop" makes sense in the context of whatever this "stitcher language" is?
Neat! How did you draw the moon? Seeing the source would be cool. Also, looks like you're on Windows - the print screen (prtscr or prtscn) key on your keyboard, or the "snipping tool" that comes with the OS, will make taking screenshots easier :)
'Python 3 object oriented programming' by Dusty Phillips might be what you are looking for. I'm liking it and I also started with 'Think Python'. 
I think there is a pep on it, or maybe its just explained in the documentation for dis. But theres no point AFAIU.
Dynamic typing doesn't make a system dangerous, bad testing does. Making your programming easier to test makes it safer to deploy at the same cost.
I drew the moon by using the dot function to make a yellow dot and then I placed a black dot over part of it to make it crescent shaped. And thanks!!! I used it to make it my desktop background. I'll post the beginning of the source momentarily. It has a lot of lines so it would be kinda tough posting the whole thing.
I don't know if I'd say it was a major danger, especially relative to the amount of freedom C gives you. In my opinion the language in use is just a tool, and while there's a lot of power in C, and obviously some of it is "necessary" for doing certain things embedded systems often require, I would like to use a tool/language that prevents me from making as many errors as possible on the way to writing a complete program. I've never felt like the dynamic typing of Python was much of a benefit or drawback, but it is something to be thinking about while writing the program. I can't say that I know enough about the internals of Python to know if it could be easily changed for performance or safety reasons if you wanted to have a VM specific to embedded like the article is mentioning. I do think static typing would be a better choice for embedded where you really want to make as many guarantees as possible with how your code will behave; I believe static type systems make that more available/easy.
I'll post it momentarily it has a ton of lines so I'll post the beginning. 
You could also make a github account and upload the code there, then link to it here. If you're not familiar with github or revision control, this may be a great time to learn :D
Ohh gotcha, yeah I'm very very new to Python. I just learned how to use Turtle graphics this Tuesday and it's really the only thing I know.
Oh, awesome! That's pretty great progress for two days of learning.
Thanks a lot!!! I really appreciate that!
https://github.com/mazman1012/Ali-Mazrui/blob/master/Python%20Turtle%20Owl
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mazman1012/Ali-Mazrui/.../**Python%20Turtle%20Owl** (master → 864fe33)](https://github.com/mazman1012/Ali-Mazrui/blob/864fe33bf703bd98953cac463e92e2a9eb92d431/Python%20Turtle%20Owl) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkhy5e9.)^.
Can you post the owl?
&gt; software developer at Microsoft, loves Linux.
I think you should look into saving your Python code into .py files, so that you can run it again easily. There's lots of good tutorials on the sidebar, and /r/learnpython would probably help as well.
All links worked for me. When you click on the download links they each go to a separate page and then you have to scroll down to the table labeled **Files** at the bottom of the page and select the file you want.
https://github.com/mazman1012/Ali-Mazrui/blob/master/Python%20Turtle%20Owl 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mazman1012/Ali-Mazrui/.../**Python%20Turtle%20Owl** (master → 864fe33)](https://github.com/mazman1012/Ali-Mazrui/blob/864fe33bf703bd98953cac463e92e2a9eb92d431/Python%20Turtle%20Owl) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkhz1m5.)^.
What are popular Python enabled boards?
Thanks a lot!!! Your input meant a lot. Did my link work?
ESP8266, get it from China for less than 2 bucks, I'm waiting for mine now (I've ordered 5 cause they're so cheap). 
Yup, it sure did. Looks like writing that took a while :P
I work on embedded safety critical stuff that has to be certified. Some of the testing we do requires complete code and decision coverage. That would get really nasty if the arguments to a function can be of any type. (It already gets pretty nasty in C). A separate issue from that is in all safety critical code I am aware of, dynamic memory allocation is not allowed. All variables either live on the stack or are statically allocated at compile time. Can Python even do that?
At a local college, it's an online course I'm taking. Website is Zybooks and the book is CSP17 programming with python 3.3
The answer is yes, you can. It's a different experience to working with the native tools, but you can make apps for mobile.
Lol yeah probably a total of 3-5 hours
I would consider a while-loop to be called an "if loop" by certain people. I've never heard an if block/statement referred to as a loop. (~15 years programming)
That was a lot of work; well done! I cleaned up the source a little bit (removed prompts ('&gt;&gt;&gt;'), tracebacks, etc): https://gist.github.com/Nicksil/26914fd7d9de4326cb1975483013017b 
I have, there is also a link to the whole source in it. You should find it on my profile.
Thanks a lot!!!
Thanks for the link man, I was wondering if you could check one more piece of code as for some reason when I press my key, the block moves on press and release and I just want it to move continually in the direction i press i think it might be an indentation error as a comment on the video says so https://www.youtube.com/watch?v=ldh13IP8GAY&amp;t=53s&amp;list=PL6gx4Cwl9DGAjkwJocj7vlc_mFU-4wXJq&amp;index=8 https://pastebin.com/73H6YKVQ
it is written in Python and C++ code. Please check out our website for full details. 
Yes, I choose what os I love and use.
I've worked with safety critical software that definitely used memory allocation, although I can appreciate in more real-timey applications it might not be appropriate. In python not using dynamic memory pretty much makes no sense to begin with. All variables are going to be dynamic, even integers support arbitrary sizes. In non real-time applications I feel the standards are chosen based on what makes the senior developers feel safe rather than what would actually reduce bugs. To be fair a lot of that is me feeling unproductive writing and testing C when I could have written the same thing in python, in a quarter of the code and an eighth of the time. 
yeah so everything from `lead_x += lead_x_change` down to `pygame.display_update()` needs to be unindented one tab or four spaces. Right now it's only changing the x co-ordinate when there is an event to process, what you want instead is for the x co-ordinate to change every iteration of the while loop. My bad- I thought you wanted it the first way around.
I'm interested in an answer to this too. I ended up using regex that captured digits (with commas and decimals) before or after a string I specified (like set, sets, count, boxes, etc). It required a lot of manual verification though. And, I never made it smart enough to know that "3 sets of 12 widgets" = 36 widgets. You may want to look into a NLP concept called "name entity extraction". 
&gt; memory is very cheap now. Embedded is now full of it. LOL WUT. Clearly someone has never worked with industry microcontrollers.
I feel that. I so badly want to contribute to a FOSS project, but I still feel like I'm in over my head. But I'll keep plugging along!
I also recommend [Learn Python The Hard Way](https://learnpythonthehardway.org/book/preface.html)! It's free online, or you can purchase it in book form if you're more a tangible goods type with money to spend!
Yeah I was originally doing it with some pretty monstrous regexes, but in the end it wasn't all that accurate. I'll look into name entity extraction though.
My bad, I'm used to writing code compat with 2. I forgot that was the case. I also don't get to use asyncio at all.
This is possible to achieve, you only require 2 libraries: * Requests * BeautifulSoup4 The first step is to inspect the login form on the website and recreate it using the Requests library. You will have to first create a Session object my_session = requests.Session() login_payload = {"username": "johnsmith@example.com", "password": "hunter2"} login_request = my_session.post("http://example.com/login.php", login_payload) Then you will have to navigate to the website you want to monitor: product_request = my_session.get("http://example.com/product123") Then create a BeautifulSoup object that will check an specific tag. soup = BeautifulSoup(product_request.content, "html.parser") my_html_element = soup.find("h1").get_text().strip() Now you can either use the Twilio or Mailgun REST API to notify yourself when a condition is met. if my_html_element != "Something": # Here implement your Twilio or Mailgun REST API Then you can run this script with crontab.
You should think about (and specify) what your end goal is. As you learn more your goal will change, but it is important to focus your learning. The world of Python programming is too large for just 'learning python'. That said, I would recommend "Automate the Boring Stuff" as a starting point. After the basics focus your attention on what interests you - web, data, etc, and build simple projects related to that area. 
Well, 3.6.2 came out, and they still haven't fixed it, despite a simple patch being available. The last update states that since it wasn't a blocker for 3.6.1, they might as well not let it block 3.6.2 either. This is crazy. 
Well, 3.6.2 came out, and the bug STILL isn't fixed. In fact, the last comment stated that since it wasn't a blocker for 3.6.1, they decided to not make it a blocker for 3.6.2. :-( 
So I have to download every file each by each?
Use a set instead of a list.
Nvm
They're wrong. If statements don't loop...
Pretty shit name, how do you pronounce that?
There's nothing special really, a's just tend to come coupled to an mmu and r's tend to have larger local memory to speed up interrupts.
Only the one you require and possibly the help file.
What's the advantage over writing the C++ natively and running the binary from python? Would you pass the source to cppyy and run it that way instead?
You're right: you can't currently trade cryptocurrencies with them, but Zipline (the backtester) is 100% open source!! https://github.com/quantopian/zipline Also, their backtester takes slippage and commissions into account: it provides a much more detailed back test.
I'm just learning Python (not a programmer). How long have you been building things with Python? Broadly speaking, what can you do? (e.g. web scrapping). Any examples of previous things you've built? I've got a couple ideas that have to do with web scrapping. 
I guess that's only very very important software i've only seen this hard requirments on critical systems for planes (everything that needs to work to keep a plane save). Examples would be radar, navigation, control systems, etc. But everything else usually just has to fit a certain size and has very strict power consumption rules. I guess the same would be true for cars (or at least i hope). Certification is really annoying and i agree that this would be almost impossible to do with python (at least with my python knowledge).
dear god...
I don't have any project ideas (been a problem for me for a while :/), but I'd definitely be down for joining a group project, just hit me up.
For my knowledge, the main reason why c is so much unsafe is to allow easy optimisation. It has pretty much nothing with writting to memory location, manipulate value on the stack or having a low memory footprint.
Isn't it kind of a pain to do it that way? 
While you guys debate how the software world works 2 interesting things have happened. 1. plenty of students professors and teachers are very happy about this. 2. I have gotten more quotes back below $1k and a max completion time of 3 weeks. Maybe you guys should examine your bubble because it seems far different from mine.
If the business plan supports the cost of the BOM (bill of materials) necessary to run micropython, I'd rather have the blessed product out the door and revenue coming in than wait for Engineering to deliver their c compiled baby two years after the date that they promised delivery. That happened to a company that I once worked for and the 2 year lag took down the company. In manufacturing (compared to a recurring revenue model), you are only as good as your last quarter. And history tells us that most mid to large sized manufacturers will go under after 4 disastrous quarters in a row. So yeah, yeah. There are segments where costs or safety might not allow micropython. And at the same time there are plenty of segments that will support it. Just let the boys in business development run their risk assessments, risk mitigation and risk management numbers and make the call that makes the most business sense. I've seen enough autocratically run companies whose engineering minded business owners wouldn't do the math needed to save the company from being embarrassed by a woefully tardy design shop whose Developers ended up getting bonuses just to coax them to stay on and finish what they promised to finish two years earlier. Meanwhile virtually the entire Sales, Marketing and Support personnel were leaving in droves.
How does it work on CPython without using C-API?
You could host the code on github or pastebin and share it that way. Would be interesting, I've never worked with that stuff with python before.
 import os path = '' while not os.path.exists(path): path = raw_input('path: ') path = os.path.abspath(path) Might want to try /r/learnpython next time! Good luck.
You don't have to create a text-based API to communicate over stdin/stdout. Just call functions.
There is no programatic way to make a string raw *after* it's been assigned in memory. That said, try this in a Python 2 interpreter: print(["Raw?\n", r"Raw\n", raw_input(r"Type Raw\n :")]) The string returned by **raw_input** is already raw... that's part of why raw was in the name.
Thanks for the clarification!
Very cool.
My guess: zur-neth
Well all of the above really. The low memory footprint (flash and ram) comes from the fact that you can simply **do** the things I mentioned without any checking as to whether it's safe. So yes, you are right: optimization is a key part: If you want to write to a memory location, it just compiles down to a couple instructions which simply do it. There's no overhead of something checking bounds, etc.
thanks
I am quite certain that this is spam. Please leave, marketing drone.
The link to the pyhpc paper does not work for me, does anyone have a mirror? Would love to read it.
Yeah if you go to the post of the actual drawing there is a github link
Is there no way to move the load_something definition to above the properties?
it uses C API, why do you say it does not? You just don't have to use it :)
I'll ask the author
You should make a function that uses those two dots and given a "time" parameter shifts the black dot left or right to make the different phases of the moon! Great job by the way!
Like Zerinth? Doesn't seem hard to me
Ooooo that sounds really interesting. I'm still very very new to Python and coding in general.
I guess. That's what I did to make it work, moved it outside the class (and on second thought, it may even be better off in some other class or in a misc utilities file). But I'm still trying to find out if this is possible at all. You never know, there's lots of python sorcery I don't know about. :) 
https://github.com/mazman1012/Ali-Mazrui/blob/master/Python%20Turtle%20Owl Cleaned up version by /u/Nicksil : https://www.reddit.com/r/Python/comments/6ojl17/first_drawing_using_python_turtle_graphics/dki0d6j/ https://www.reddit.com/r/Python/comments/6ojl17/first_drawing_using_python_turtle_graphics/
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [mazman1012/Ali-Mazrui/.../**Python%20Turtle%20Owl** (master → 864fe33)](https://github.com/mazman1012/Ali-Mazrui/blob/864fe33bf703bd98953cac463e92e2a9eb92d431/Python%20Turtle%20Owl) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkigy4h.)^.
What you're after depends on what are you expecting to change in the website. I would start by answering the following questions: - How often does the website change ? In other words, when was the last time you observed a changed in the website ? - What is the scale of change you're expecting ? There could be changes to the website that is not even visible to the user such as javascript changes. Maybe only a few elements change but there could be a number of elements on the page. Once you identify what you're expecting to change then life becomes a bit easier. If its just a DOM change then you could do it using BeautifulSoup but what if an image is changing on the page ? Hope this helps and doesn't confuse even further. 
You are doing it wrong. You are supposed to draw lines and circles. Sticktrees in the worst case.
oh god o__o welcome to python 2 you suck
Very cool creative coding.
Direct quote: "here you go that's odd ... Well, I've put a copy at cern.ch and redirected both the cppyy.readthedocs.org and README on bitbucket there: http://cern.ch/wlav/Cppyy_LavrijsenDutta_PyHPC16.pdf That should do for now. The other alternative record is: http://dl.acm.org/citation.cfm?id=3019087 but that's not open access (at least, I don't see the pdf from home). And slides are here: http://www.dlr.de/sc/Portaldata/15/Resources/dokumente/pyhpc2016/slides/PyHPC_2016_talk_9.pdf Best regards, Wim "
You don't want to pass self to a classmethod but cls. This works for me: &gt;&gt;&gt; class Derp(): ... @classmethod ... def method(cls): ... print "derp" ... &gt;&gt;&gt; Derp.method() derp 
Why do you assume Twilio or Mailgun? 
Personally I'd use [Geopandas](http://geopandas.org/) + [Xarray](http://xarray.pydata.org), which both more flexible and free in every sense of the word - the only real advantage of Esri products is the enterprise support and management features.
Didn't know about that convention. Thanks. 
I'm no expert in Python but that ended up looking like an owl instead of a turtle.
RPi.GPIO just spawns a thread that runs `epoll` on the GPIO. There's no reason you can't just do it yourself.
Oh what, i've been trying to keep away from all threading and running everything on 1 thread, shows what i know. Do you know if there is some other GPIO library out there? I checked this one out: https://pypi.python.org/pypi/pyA20 but it doesn't seem like it has any event handling or checking, just checking the values and setting them.
Well, if you are passing 'self' to a method you are kind of stating that method depends on an instantiated object from that class. @classmethod s do not care about the properties of an object (self). Otherwise you need to instantiate an object of that class: &gt;&gt;&gt; class Derp(): ... def method(self): ... print "derp" ... &gt;&gt;&gt; d = Derp() &gt;&gt;&gt; d.method() derp 
A few tutorials introduces loops directly with while-else and for-else loops, maybe that is the reason newcommers think if-else is also a loop.
What's the overhead?
The mentioned website simply states that there is nothing like an *if-loop*! 😉 So it's not the *source* of the evil but a lighthouse of *correctness* 😎 It clearly impresses one if he visits this simple site and has to read he had been fooled by someone...
What's with the extra parenthesis?
If you can run it you can decrypt it. If you can decrypt it it's not really encrypted. 
I don't understand what you want. Calling `iterools.product` on your input cannot produce the output you pasted. You should fix this, clarify the original problem, and also repost on /r/learnpython. That's the subreddit for questions of this nature.
&gt; This is crazy. Welcome to Python development. It's amateur hour every hour.
It is measured to stay within 1% when the profiler is active. The agent actually prints the CPU overhead in debug mode.
Heck, even the arduino would be a pretty bad match for Python resources-wise.
Thanks for posting this. I've been looking for something like this whilst also learning through code academy. Do you know if it'd be better to read this alongside/before/after using code academy? 
I've been using self for everything and it's been working... Probably because the names 'self' and 'cls' are just naming conventions, and, I suspect, may also be interchangeable. (I use 's' for everything, rather than a bulky 'self'. Makes it much more readable to me.) def method(s): s.something = s.other_method()
I think Chris Hawkes on YouTube has a good tutorial. Warning some language ( how to automate python)[https://youtu.be/6N8EwDcrNoo]
[removed]
I appreciate how you named the turtle `bob`
Yes. The names are just convention. There is nothing stopping you from naming the first argument to an instance method `sassafras`. Except other python programmers might hate you for it.
&gt; delayed lock step What does the 'delayed' here mean? One CPU's clock is delayed after the other? So it's TickA-TickB-TockA-TockB? 
Well, for now I'm not too worried about other opinions on that. I'm more worried that I can read my own code without melting my brain. :) One of the first things I did when I began learning python, was to find ways to avoid the 'Self Hell' (which was one of the things that kept me miles away from python for a long time). I saw once someone who came up with a way to use implicit selfs, so that you didn't need them anywhere, but it was too complicated for me (and there was some talk about it's reliability and potential caveats).
The amount of effort you put into this is really inspiring! I want to do a code review/refactor of it because it's a great place to start learning some programming concepts, unfortunately I'm starting vacation today and not bringing a computer. Will try to get to this in a week or so when I return. Kudos, you have a bright future ahead if you're willing to put up with so much trial and error :)
Your might want to look into list comprehensions.
Thanks! :)
Great stuff! I've created what's called a "pull request" - a request to contribute a change to your repository: https://github.com/mazman1012/Ali-Mazrui/pull/1 . Merge it in if (and only if!) you think it's a worthy addition. It adds a python file so you can type `python ali_python_turtle_owl.py` and then watch the drawing play automatically. This is what /u/joe_mikkel suggested. Here's a gif demonstrating (which I also included in the PR): https://github.com/jonmcoe/Ali-Mazrui/raw/add-python-file-and-gif-animation/owl_drawing.gif A good next step might be to split up the function `main` into sections (draw_tree, draw_owl, etc)
If you need to send an Email without configuring a SMTP server you can use the Mailgun REST API, it is pretty easy and fast to use. Or if you want to send an SMS to your mobile phone the free Twilio API is good enough.
Much better than mine! 
Your username is the name of the service. Nice try
Some things I've noticed: * You check if `storage` is an instance of `BaseStorage`. IMHO, it'd be more Pythonic to rely on duck typing instead of requiring a specific base class. * Your library relies heavily on asyncio, but for some reason `get` and `set` aren't required to be coroutines, but are coerced to be coroutines by the library. Why? If you're going to use them asynchronously anyway, why not require the user to write `get` and `set` as coroutines? * There is a `remove` function to remove specific keys, but no `clear` to remove all keys. I think that'd be a useful addition.
&gt; Would it be better to set up the scheduler per object or setup a scheduler to control every object? That depends on a lot of factors. That said, without knowing your specific requirements, I might favor pushing it towards the shell using tho `at` shell command. `at` has a lot of weaknesses versus `cron` for scheduling, but if I had a simple "do this later" system, it'd be my starting point.
"I found idiots who are willing to do things for free and that makes me right".
The code it is executing is one cycle behind. So Core 1 is on cycle ```t```, Core 2 is on cycle ```t-1```. There is a 3rd core or additional hardware that compares the outputs and makes sure they're the same.
This is really cool! I started Python last Friday and all I have done in Turtle was get it to draw shapes based on user input of how many sides they wanted.
There was an experimental version of [PyPyROOT](https://root.cern.ch/pypyroot) which married pypy and ROOT and, as I understand it, used cppyy. Later the project seemed to die despite its enormous potential usefulness for HEP. The paper linked in another comment mentions pypy, so is there hope for a revived pypyroot or something similar?
It looks like you can just use [advanced search](http://wireless2.fcc.gov/UlsApp/UlsSearch/searchAdvanced.jsp) to find a list of all call signs for the services that you care about (not sure if you care about aircraft, or cellular or what), scrape the data, then write a script to visit each individual page and check to see if the zip code is a Texas one (I assume you are in Texas based on the example link). 
&gt; "Various Python utility functions, mostly geared towards dataviz and used to create visualisations such as this [bar chart](https://raw.githubusercontent.com/Udzu/pudzu/master/images/chart_elections_full.png), [time chart](https://raw.githubusercontent.com/Udzu/pudzu/master/images/chart_g7_full.png), [periodic table](https://raw.githubusercontent.com/Udzu/pudzu/master/images/chart_periodic_full.png) and [image grid](https://raw.githubusercontent.com/Udzu/pudzu/master/images/chart_40under40_full.png). &gt; The modules aren't properly packaged up or pip-able (yet) but are reasonably simple, generic and docstringed. They are not optimised for speed or tested for resilience. They are targeted at for-fun, interactive work." Hi all. Thought I'd put this here in case it's useful to anyone. I plan to upload the modules in three sets (some of the code was adhoc and needed cleaning up to be useful). This is the first set, and includes various functions and data structures: - *[utils.py](https://github.com/Udzu/pudzu/blob/master/utils.md)* - various utility functions and data structures. - *[dates.py](https://github.com/Udzu/pudzu/blob/master/dates.md)* - date classes supporting flexible calendars, deltas and ranges. - *[records.py](https://github.com/Udzu/pudzu/blob/master/records.md)* - utilities for functional handling of records (lists of dicts). The next set will cover image manipulation: - *pillar.py* - various monkey-patched Pillow utilities. - *charts.py* - Pillow-based charting tools. And the last one will cover web parsing: - *tureen.py* - a few BeautifulSoup utilities. - *wikipage.py* - Wikipedia and WikiData parsing utilities. Comments welcome. I expect I'll continue to update the code but currently have no plan for a proper release as I don't know how much time I'll have to dedicate to this.
Gonna just point out that if you're doing this from scratch, why wouldn't you use python 3?
Thanks for your feedback! As for the points you've made: 1) Cache heavily relies on specific behaviour of `get` and `set` methods and letting storage be anything but instance inherited from `BaseStorage` may create confusion. For example, you *cant* pass `dict()` as storage since its `get` method wont throw `KeyError`. 2) There are four cases in which cache could be used. with sync/async function and with sync/async storage. In early version of library there were actually 4 wrappers and main `cached` wrapper would pick one depending on the type of function and storage. The current approach makes library usage more intuitive: you can create custom storage with async in mind or simply write sync code, and it will work the same. Also current solution allows for a mix (for example, async set method and sync get method) **Tl;dr** I found this solution simpler on a final user and it doesn't add any significant overhead, while also simplifying a code significantly. *I will actually think this one over though, that's a nice point after all.* 3) I will think this one over. My concern is that with any additional `abstractmethod` set in `BaseStorage` it requires more work to set your custom storage (more methods to overload). Im not sure about which methods are absolutely crucial when you want to cache something. What is, in your opinion, an *absolute minimum* that is required to define any specific cache structure? **EDIT**: The more i think about '2)' the more i think that your proposition makes more sense than what i've got. Looks like i've outsmarted myself while coding this part. Thanks again for your feedback.
I don't know. I tried some fancy formatting and it failed :(
Making a radio that works on Spotify's ai and plays songs based on mood
https://www.ibm.com/support/knowledgecenter/en/SSSHRK_4.1.0/itnm/ip/wip/ref/reference/nmip_ref_stloop.html It looks like there's a basic fundamental loop in the language and you can use those loops to iterate data for the loop. I think the context assumes a loop and the operators you can use within the loop.
You could just do 4 space indentation like this and it would look okay, I think. Check the formatting help.
Nice, also look into using loops (recursion) if there are common patterns. It'll reduce lines of code and could simplify some parts.
In think you might have missed what GP meant (apologies if I'm wrong): Python interprets code in the order it appears in the file, so simply moving that method above the place that you want to call it should fix your problem. It can stay in the same class, it just needs to appear first in the file. IMO there's nothing wrong with doing that, from a style perspective.
Yep! Thats exactly what im looking for. I basically enter in some parameter in that advanced search, click the geosearch tab and click my county and i end up at a page shows in the picture in the post. I have no clue where to start to be honest. Is it as simple as searching it manually, adding that results url to python, and telling it to record every call sign in column x and every frequency license association with it in column y? edit: added more description
Actually, it looks like you can use "query download" and skip this whole thing. You can limit your search to just "Texas" and "Active" Licenses, do the search, download the results, and open them in excel without issue. Neat.
This seems to be more about how to scrape data... I already have the data, but I need to automate its interpretation
`clear` is more ubiquitous than `pack`/`unpack` since not all back ends require marshaling, but that's in your base class. 
The only licenses i need are the active licenses between 300-6k in the brazos county. I just noticed the query download though, i sent a request. I couldnt find anything specific on what a query download is in google, what exactly is a query download? I overlooked it because i wasnt sure what that meant. 
while `pack`/`unpack` are helper methods that do not rely on storage structure, `clear` is storage-dependend and would have to be overloaded in any class inherited from `BaseStorage`, which is their main difference.
For a library you're making too many assumptions. 
I don't understand which assumptions you refer to. However its a valid point that `pack`/`unpack` methods should, perhaps, not be a part of `BaseStorage`.
Maybe this will help: from tkinter import * DICT = { 'a' : 'b', 'c' : 'd' } othervariable = 'a' root = Tk() var = StringVar(root) default = DICT[othervariable] dropdown = OptionMenu(root,var, *DICT.values()) var.set(default) dropdown.pack() root.mainloop() 
Thanks man that's really useful I almost give you gold 
`self` and `cls` are just naming conventions. However, the first parameter of a class method and the first parameter of an instance method are actually different to each other. The first parameter of a class method is a reference to the class, and the first parameter of an instance method is a reference to the instance. If you start to write code like so: class Derp: @classmethod def class_method(s) ... def instance_method(s) ... then you might confuse yourself into thinking that `s` means the same thing in the above methods, when in fact they don't. This is why it's better to stick to the conventions that 99% of Python programmers use, which is: class Derp: @classmethod def class_method(cls) ... def instance_method(self) ...
Dive into Python. Get the basics down, learning a back-end language first off is a good start, in my humble opinion. 
I do testing validation for a hardware company. I made a python script that takes a list of network locations and creates the corresponding tests that need to be executed based on filetype. It also copies files, renames files, makes directories, and generates my testing script. I had to do this all manually before. Saving me about 5 minutes per test. 
Mechanical Engineer here; I got into Python primarily as it assisted me with professional duties (analyzing test data, not having to rely on excel so much, etc etc); and my interest took off from there. I'm now wrapping up my MS in Computer Science, and strangely enough, I just found out at my new job, I may be programming in Swift before long. Don't let the decision of what language to start in distract you; it doesn't matter so much as working on projects and writing software yourself. In time you will recognize the patterns, best practices, and so on which will translate from language to language without issue. For Python related stuff, I love the videos by /u/sentdex (same name on youtube); he has a ton of playlists on various subjects, I would encourage you to dive into a playlist you may think you don't have much interest in (like NLP (natural language processing)).
Continuing the Python track on Team Treehouse. Going through the Object-Oriented Python module this week.
If you want to make iOS apps go with Swift. It's really that simple. You can also run Swift server side on Linux so no big limitation there (although pythons library eco system beats all other languages of course). 
Swift can be a back end language though.
Yeah I was thinking about that but I don't really know how yet.
Not hotdog.
No you found a post on Reddit and decided you would set the world right by telling everyone how wrong they are. Thanks for your great service you are a true hero in my eyes someone I can truly look up to and admire all my remaining days. I can't wait to tell my kids how you righted the injustice. Thank you sir. Thank you!
Would I just type that in after all my code and it'll automatically start?
Great!!! Would this be on github?
Yep!
Site Reliability Engineer Technology Las Vegas, Nevada (no remote work) Apply Zapponian [noun|employee of Zappos]. You are self-motivated. You think like an entrepreneur, constantly innovating and driving positive change, but more importantly, you consistently deliver mind-boggling results. Bold [adjective|not afraid of anything]. A role at Zappos is an opportunity to be a part of something different. To go bold. We’re a company that isn’t afraid to take risks and question the status quo. Oh yeah, we like to have fun too. Perks [noun|the good stuff you get for working hard]. Zappos pays 100% of your medical, dental and vision premiums. Primary care visits, dental exams, eye exams and generic prescriptions are all free. Plus matching 401k, life coaches, orthodontic benefits, and more. And don’t forget, an unlimited 40% Zappos.com discount. 1990s [noun|a decade we love, but no longer live in]. Old school cover letters are so 1990. Want to show us who you really are? Create a video cover letter. A flash mob, a comedic monologue… whatever showcases your passion for Zappos and the work you’d be doing! Videos are not required, but if you create it, we’ll watch it. Scout [noun|you're a recruiter, too]. As a Zapponian, we’ll ask that you always keep your eye out for great talent to join our family. Consider yourself an extension of the recruiting team, scouting for the best people to grow our company. What you'll be doing: Helping various teams automate various tedium with Python using industry standard best practices Refining current automatons, including tools used for infrastructure management. Design and build applications to improve the availability, latency, scalability, and performance of our systems. Build automations to respond to first level issues, striving to fix them automatically. Drafting new standards for the creation of tools and processes. Nursing our poor XMPP bot back to health and adding new features. Connecting existing 3rd party tools to other internal tools, making a big ol' web of data mining goodness. Eating good foods and sharing friendship. Playing a Nintendo game or two, or becoming a Tetris Grandmaster. What you'll bring to the table: Python engineering experience, including building and running enterprise applications at scale. Linux expertise, from shell all the way down to the kernel, including internals and networking. Building and running containerized applications using Docker. A strong love of making things easier on yourself and others by automating the heck out of everything...From putting pants on to building an 18 story building (in Python!). Enjoy working in a fast-paced environment that is fun and borderline wacky. Maybe an excessive amount of wacky. Maybe not that much wacky. Definitely fast paced. Did I say wacky? Networking experience (working with switches, firewalls, routers, packet sniffers, load balancers). SAN/NAS experience (IBM SVC, V7000, XIV, DS Series, NetApp, FC, iSCSI, NFS). Any other automation experience (Selenium, JMeter, Powershell, ActiveState Perl/Python). Any other cross platform programming languages C, C++, Go, Java, Erlang, Haskell, COBOL (j/k... maybe). Experience in Python web frameworks. HTML and CSS experience (design, what-not). Shipyard experience. We like boats. Boat expertise optional. Proficiency with a certain manufacturer of foam dart gun. (You know the one we mean). What you didn't know about the team: They are just as wacky and random as this job description. To Apply : http://jobs.jobvite.com/zappos/job/oCGM3fwR
Curious how security vulnerabilities are archived/stored within the tool. Is the information maintained "by hand"?
No need for a yield here, just replace the brackets (list) with parentheses (generator) and that's it.
We use your declared and transitive dependencies from your package manager to find out what components you're using, then we use the data from the [Black Duck Knowledge Base](https://www.blackducksoftware.com/technology/knowledgebase) to find out which vulnerabilities apply to each component (and to give you advice about possible versions to upgrade to to remediate the issues)
Well you're doing a great job :) keep it up!
Isn't this what RSS feeds are for? 
ReST since that is what is supported natively by Sphinx. Tried Google style docstrings and could never get it to work easily with RTD
The only thing of interest with Swift is to write iOS apps, it is rarely used elsewhere. If you only want to write iOS apps, that's fine, otherwise, pick another programming language... Python is probably one of the programming language the most used to learn programming nowadays (with C for the basics and Java for OOP).
Look at the sidebar books, Dive Into Python is pretty good.
Same here. When we started using Sphinx it wasn't as much of a built-in thing/not as well supported, so we started using the default ReST syntax with `:param int foobar: descr`. I wouldn't mind switching to the numpy or google format, but it'd be a huge amount of work without writing some tool to do it for us, and then it'll mess up the blame history.
The chapters are pretty easily digestible, so if you have time I'd recommend doing both. Codecademy is a good way to jump right in with no setup on your end, but it also holds your hand more. Zed's book encourages you to find more answers for yourself by Googling, and he also insists that you type EVERYTHING whereas Codecademy will populate a lot of the code for you. They're two different approaches really, no harm in trying both to see what's better for you! Good luck!
I've read the first edition awhile back - it was good for teaching the language don't remember how much "engineering at large" it covered
Ok cool, I was wondering if you perhaps found something more sophisticated :-) Myself I tried to compensate for the time it took for the game logic to calculate the state for the next frame and subtract that from the after() wait time, but it gets unprecise rather quickly. Well, I guess tk was never designed for building fluid animations so we have to be glad with the stuff we do get :)
That's one hell of a way to dance around the fact that you are taking advantage of people. I know you're upset that people called you out, but maybe if you feel less entitled to other people's labor people would respect you more.
I like it. It's lovely. Well done, bob.
Hi, bob! 
Yeah, I tried that too, didn't worm aswell
Cool. One more question, then. Suppose I create a new package: we'll call it 'Unknown'. This new package is actually a library and it becomes popular to some degree (let's say about 1k downloads a month). Does the tool also perform an analysis on 'Unknown' so that downstream packages have a sense of the vulnerabilities in 'Unknown'? How do vulnerabilities of this new 'Unknown' package loop back into the Black Duck Knowledge Base?
Someone more Windows-familiar might be better suited to answer. In OSX / Linux you would navigate to that working directory in terminal (`cd [whatever]`) and then type exactly that: `python ali_python_turtle_owl.py` On windows i think you can just do the same? Start &gt; run &gt; "cmd". get the black screen / prompt, `cd` to wherever the project lives, type `python ali_python_turtle_owl.py` Another option would be loading the file in the IDLE editor (you probably got this when you downloaded python?) and pressing play/run/whatever.
Reminds me of [Python 3 in one picture](https://github.com/coodict/python3-in-one-pic/blob/master/README.md)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [coodict/python3-in-one-pic/.../**README.md** (master → 4477fa5)](https://github.com/coodict/python3-in-one-pic/blob/4477fa5b0a54ae4a624e83036c44d9955f415107/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkj7os0.)^.
Just started the Launch_Code program. It's my first exposure to coding of any kind and I'm really enjoying. My only project so far has been using the coursework program to make some turtles race.
Thanks for taking the time to respond. I think I'll be doing both from now on. Thanks again.
I'm really surprised. Are there not enough core contributors (I understand even Guido isn't paid to work on Python full time), or is there some other problem? It seems like Python is more popular than ever, so a lack of volunteers seems unlikely. Then again, there was recently an article showing that only about 30 people are making significant contributions to the core scientific stack, so maybe not.
Sure, but using a generator expression there would only solve part of the problem. It's also not always faster than using a list comprehension. It would be better to build the resulting string all at once.
Thanks! I actually improved the explanation because I realized the solution is actually natural when you think about it recursively.
Well I never really thought they were the same thing (I never knew they were two), but I had wondered how exactly I was calling methods through a self. within classes I never even instantiated. This explains things. :)
Yep the KB would handle a package called Unknown just fine. We use an identifier schema that makes each package unique and specific. Good question, thank you :)
Yea, I kinda did misinterpret it, perhaps. &gt; Python interprets code in the order it appears in the file Thanks for that reminder. :) So, above the properties, but inside the class... I may try it just to see it working, but it kinda goes against my own conventions. I rather keep things organized and consistent throughout. Still, in my case, that would defeat the purpose of that method call, which was to keep the properties section short and clean. The code that's inside the method takes some 20 lines (it's actually two functions), and so to move the methods up... I might as well get rid of them, and just lay out their entire code there. That would make a lengthy and noisy initialization section, though. 
You can use pyenv instead of virtualenvwrapper. What do you mean using 3.6 globally? I think you can set the global version by running pyenv global 3.6.x
*The Hitchhiker's Guide to Python: Best Practices for Development* is a good one. Coming from a similar point, I've found specialised books and online content more helpful than utility-knife books for practical matters such as testing, design patterns, modular design, etc. 
Lots of linters look for RST formatted docstrings out of the box. Most editors also interpret them properly and provide the doc as well as type information. That's a pretty big win when trying to onboard new people to a module or project.
The standard syntax is hard to remember and hard to read in code. I use the numpy format. https://github.com/numpy/numpy/blob/master/doc/HOWTO_DOCUMENT.rst.txt I much prefer def func(): """This is a docstring Parameters ---------- x : float the x value y : str some string """ to def func(): """This is a docstring :param x: the x value :type x: float :param y: some string :type y: some string """ 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [numpy/numpy/.../**HOWTO_DOCUMENT.rst.txt** (master → 6958be1)](https://github.com/numpy/numpy/blob/6958be1c9180bd52a7aaf979718b2b851f280055/doc/HOWTO_DOCUMENT.rst.txt) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dkjbgci.)^.
awesome
Try https://newsapi.org they collect and store articles from 70 different news sources. They provide an easy API to access all those data.
Yes, but you can use something like cx_Freeze to bundle your app together with Python and all the dependencies.
I'm going to be adding content to this , such an amazing project
Since I heard of Conda I don't use anything else. You may want to have a look.
This would be the same for java also right? Is there any other language that won't require that? Is it only C++ or something?
This is brilliant. Thank you!
C++ will still require all the libraries you depend on, though you can link them statically and make it look like a single executable, I guess. What's your end goal here?
It seems like anytime I make any sort of virtualenv it creates an instance of python 2.7. Additionally if I want to just run the python command I would like to use 3.6 instead of 2.7
You can choose which version the virtualenv will be created with. pyenv virtualenv 3.6.2 new_env Have you run pyenv global 3.6.2 ?
That entire statement makes no sense. Please add detail, or give an example of what arguments would be passed in and what result you'd expect.
[removed]
&gt; There is a 3rd core or additional hardware that compares the outputs and makes sure they're the same. Shuttle style MISD? Cool! I always assumed MISD did each instruction in the multiple computers at the same time, rather than in being offset. What is the delay used for? Is the comparitor comparing the output of Core1 and Core2 at `t-2`?
You are not in the wrong place, but I would assume this subreddit would lean towards python. That said unless iOS is imporant to you I would suggest python for the simple reason that you can code for backand end frontend for both servers and desktops. And as a nice bonus (which pushed me from perl6 towards python3), with stuff like pyinstaller you can create program files that inclues everything and dont require the target to have python installed. You can even create one big blob so your whole thingy is one binary file that will run by itself on these systems.
[removed]
&gt; You can even create one big blob so your whole thingy is one binary file that will run by itself on these systems. Do you mind clarifying what you mean by this?
if I run pip install facebook-sdk it will install under python 2.7.6 if I run python it will run under python 2.7 if I run cd /mydirectory mkvirtualenv --python3/usr/bin/ myenv It creates it and then I got to activate it (which works) and I run python 2.7.6 is run again!!! it doesn't make sense to me lol
&gt; If you are about to ask a question, please consider r/learnpython or the learn python discord. Homework-style questions will be removed, and you'll be encouraged to post there instead.
Uh just to create something simple and portable, trying to figure out which would be the simplest. I want something very small in size and fast so I am just looking at my options. I know this is another question, but do Java and python all have their own GUI API or something? I want crossplatform so I was thinking of using Qt. Does it matter if I use python or java for qt or it doesn't matter?
Yep, it's one of those "when you know it, it's super simple/easy/logical"....
I'm using "jq" for doing that (and querying the json), but it's a nice one.
https://chriswarrick.com/blog/2014/09/15/python-apps-the-right-way-entry_points-and-scripts/
Sure, you can just change "big blob" with "file". You can tell it to create a single file that will contain everything so its super easy to move around and set up.
LOL, you have to activate the virtual environment you want to run. I make a batch file with a name like py27.bat. In the venv for 2.7, there is a batch file called (not surprisingly) activate.bat. In py27.bat be sure to "call ...2.7 path.../scripts/activate.bat" otherwise it runs activate and immediately exits. If py27.bat is put in system path, you just type py27 instead of python to run scripts. edit: You should call "deactivate.bat" at the end of py27.bat.
I'm not sure why this is posted in /r/python?
What is your skill set? What projects have you done? What was the difficulty of those projects? You can't expect to make money without those qualifications. Also, if you went into this industry expecting to make millions, you've come here for the wrong reasons.
Better? 
This doesn't fit this subreddit at all. It also feels like ad to be honest.
Ya I've done all that. I don't think that's the issue as I want to run version 3.6 in that batch file not py27. it seems like py27 is overriding everything
Java has their own API. Qt used to have Java bindings, but they're unsupported now. Also, Qt is definitely _not_ "very small in size".
That would make an awesome floor to ceiling poster.
I would say Python is the best.
Oh yeah same! I love jq but the json prettifier is nice if you just want it done quick without installing anything new
This question gets asked so often on here it should really have its own meme GIF. Let me put it in as straightforward a manner as possible: yes, Python programs require Python to be present on whatever computer is running them. But, here's the thing, if you are asking this question **YOU ARE WAY TOO EARLY IN YOUR ADVENTURES IN PROGRAMMING FOR THE ANSWER TO MATTER!!!** **Do not** worry about *distribution* until you are sufficiently skilled to write something that needs to be distributed! At that point recognize that for every major language -- and certainly Python -- there exists at least one pathway of distribution for the desktop, mobile, web, etc., and really unless you're trying to put the program on embedded devices with extremely limited resources or very odd operating systems it will probably not be that hard.
I stand corrected. I, like passionate developers sometimes do, was preaching out of habit in favor of my toolset. 
No, not really. For one thing, at least on a mobile device, that appears to have only three columns of numbers. Type in an example of your data, say 3 to 5 lines of it; describe how it's formatted (are the columns tab delimited, comma?), and then give an example of the result you'd expect from the program given that sample data. From what you've descrived within a row none of the first five numbers can be duplicated, it's unclear if the sixth can duplicate any of the first five. And do you mean most common numbers across all columns and rows? Within a column? It's very vague. 
II think this is just spam, upselling that chenyumin site
Way to go on the github site! You'll be a FOSS-contributing pythonista in no time at this rate. I **highly** recommend reading through the python tutorial ([Python Tutorial](https://docs.python.org/3/tutorial/index.html) )... and typing in the examples yourself, if only for the first 3 sections. It's how I started learning python and is **very** well written. You'll get a consistent approach to the very basics that will make the whole thing make more sense. Congrats again!
I did not know that...hmm, what would you recommend? I wanted Qt to make it easier to have the app on both Windows and Linux but if its large in filesize then forget it. If java has their own API for both Windows and Linux then maybe I'll go with Java but if python has it also that's another idea.
Java has their own API, but the JRE is ~80MB even if you take the bare minimum. If you need a small, cross platform binary, your best bet is probably something like SDL2 + OpenGL + imgui with a compiled language like C/Rust.
What is this? If that site is even half of what I think it is, it is seriously fucking cool.
It actually is. Explore. :)
Yes - you should find Idle inside your python installation on windows. You can hit the start button and type 'idle' and hit enter. Then "open" the .py and hit F5 to run!
I just put forth a pull request for an example function. It uses a range object (0-&gt;19) to change the rotation direction and pen width. Have fun!
I think you're missing the obvious answer, which is installing Linux on the younger, faster machine that you've currently hobbled with Windows 7.
You can set PyCharm to do either Sphinx-style or Google-style, it's just a drop down item on the preferences.
looks very nice. any plans to support calling into c++ functions with rvalue reference parameters?
numpy style
Not OP, but THANK YOU!!
Is it suggesting that asynchio is a 'basic' skill of Python? 
link: https://raydurkuless.pythonanywhere.com
1) yes 2) use Anaconda Python https://www.continuum.io/downloads I'd recommend using Anaconda everywhere. Want a Python 2.7, 3.5, and 3.6 virtualenv? Anaconda can make those. They're also accessible from anywhere. Another bonus is you get the MKL compiled libraries, so your numpy/scipy calculations are 5x faster on Windows. The one downside is it doesn't support Powershell.
I will be messaging you on [**2017-07-22 23:26:50 UTC**](http://www.wolframalpha.com/input/?i=2017-07-22 23:26:50 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/6op7uc/interactive_mind_map_for_learning_python/dkjnitx) [**2 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/6op7uc/interactive_mind_map_for_learning_python/dkjnitx]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! dkjnj0y) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
I'm in SW Portland and can drive if others want to carpool locally.
Fluent python is really good (book). Also python3 through the standard library is another great book that will help you learn about all the internal libraries. 
Must be so great to live on your high horse I hope us little people can see over the manure your dropping. 
I believe this is what you want to do import cfg dropdown = OptionMenu(root, var, cfg.DICT[cfg.othervariable]) or alternatively this from cfg import * dropdown = OptionMenu(root, var, DICT[othervariable])
I have no idea how asyncio and a microcontroller adaptation can be considered even close to belonging on the "basic" branch. How do you intend to branch toward numpy, flask/django or sqlite; by category or skill requirements?
Look up pyenv-virtualenv and pyenv-virtualenvwrapper. They're projects that simplify all this and were made/are maintained by the creators of pyenv
Agree with yawpitch that it's a bit vague. I think your friends will be csv for reading in data, zip for transforming from rows to cols and collections Counter. Also you could try numpy. Below might give you some hints: import csv from collections import Counter with open('LIST.txt') as tabbed_seperated_values: # load the tabbed data and transform it from rows to columns with zip transformed_data = zip(*[line for line in csv.reader(tabbed_seperated_values, dialect='excel-tab')]) # do something with each column for col in transformed_data: # slice off the header value and use counter to get most common 10 in each column print(dict(Counter(col[1:]).most_common(10))) 
 There are some great insights to be gleaned from the PyCon and PyData conferences. see http://pyvideo.org/speakers.html I recommend anything by Raymond Hettinger, Alex Martelli, Brandon Rhodes, David Beazley, and of course, Guido van Rossum. 
There's another subreddit for learning Python, /r/learnpython. I suggest you ask this question there. I would also suggest you expand upon your question to be more clear about what you want... what will your program be given as inputs (if any), and what do you actually want as output (such as how many 14-digit strings to produce, and if they should all be on the same line, etc.)
So I just get Anaconda and I can use not only any version of Python but also choose between the 32 and 64-bit versions even if I have the 32-bit version on my machine?
Config is being imported already via the alternative method so this wouldn't make much of a difference from what I already have . Sorry about that, Should have made that clear. 
Linux (or at least Ubuntu) comes with Python 2.7 pre-installed and I find it to be a pain in the ass having multiple versions of Python on one machine
I think async in general will be a basic skill (and necessity) in the coming years. 
 import string import random for i in range(0, 100): print ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(14)) check out more python stuff on my blog
Taking another look at it, it seems like what /u/Allanon001 posted is exactly what you need.
Going off LTS version, 16.04 doesn't have python 2.7 installed by default, I believe it's 3.4.
The link is dead for me.
Are you on windows? You can just use py.exe then. You can run that with any version of python, like py -3.6 some_script.py. Also for example pip has 3 executables for each version of python. So if all you versions are in the path, you can use for example pip3 or pip3.6 directly. In the python scripts themselves, you can add a shebang at the beginning of the file, specifying what python version should be used for that file.
Now that's awesome
The code is taking command line arguments, using tuple unpacking to split them to different variables, then printing them. The error message is because you aren't calling the script with exactly three parameters and the argv list or tuple has one value rather than the four that is assumed. I would suggest learning Python 3 instead, Python 2 is only useful if you are dependent on an old library that was never updated or replaced or if you are supporting old code that won't run on Python 3. Finally, that book is very unpopular here, and for good reason. The sidebar has a link to better resources, many for free!, that would probably help you more. With that, I'll add, there are a lot of good videos on YouTube from Python core devs and others at PyCon as well as people like SentDex that teach the language well. Edit: Just realized, this was posted on the wrong subreddit. This should probably be posted in /r/learnpython instead. The sidebar I refer to above is located there.
Well, /r/AskReddit has even more viewers, so try there.
I don't think you can choose between 32 and 64 bit...not 100% though. Just use 64. Python is a toy with 32 bit. EDIT: to be clear, you download 32 or 64 bit anaconda python with either python 2/3. I don't think you can install a 32 bit python virtualenv from a 64-bit install. You most certainly can install a base python 3.6 and then make a virtualenv of say python 2.7 or 3.5.
Okay, I'm giving that a shot right now. Unfortunately I did something and my UI won't open up now. -_- I'll have to try his suggestion once I get it working again...
Thanks for this. Unfortunately I broke my UI so i'll have to test this once I get things working again...
Yeah I posted this to learn python and was able to get an answer. I'm going to use that sub for any more questions. Thank you very much. Would I have to download python 3? I know Macs come with python but does it update itself eventually or do I need an outside source.
I can't give you a full answer on that, as I haven't used a Mac since long before they went Intel decades ago. 😀 But, if OS X uses Python like Linux distributions do, which would be why it comes with Python, then you wouldn't want to upgrade the system Python, because that would likely break the OS to the point it might not finish booting. You would want to install it without it upgrading or replacing the system Python. I'm sure the python.org site will explain how to do so. From there, you will also want to work on a virtual environment per project to better handle libraries, versions, and dependencies.
What's the learning curve for matplotlib? I was going to install it, but became a bit overwhelmed. The directions aren't clear for beginners. I figured out that the file is actually located at the pip website, but that I need to install pip first, but I also need to install visual studio, and was going to do that when I realized that it's over 600mb and at that point just gave up. 
Why? If your scripts use shebangs it's a simple matter to have Python 3 specific scripts run with ``#!/usr/bin/env python3`` and scripts that can run on Python 2 and 3 run the default Python using ``#!/usr/bin/env python``
I'm confused by your question. Do you mean "like these" instead of "to these"? You want 10K strings which have a length of 24, composed of random elements from A-Z and 0-9 (no special characters or repeats)?
👍
It probably depends on which you value more: legibility or editor support. ReST has better editor support, but is pretty ugly to read. Google is easier to read, but has very little editor support. I've found that a combination of type annotations and Google style docstrings gives me a nice mix of legibility and tool tips in VS Code.
The learning curve is not that steep. You can get started very simply, and most plotting is done in 2 lines of code. It gets more complex as you want more control over what it does, and the side effect is that (very unpythonically) there's 3-4 ways to do anything. So you can find very complicated tutorials for very simple things. Pip comes with python for windows, you don't need to install it. You need the VS C++ compiler (NOT visual studio itself) if you want to compile matplotlib from source. If not, you can get the pre-compiled version [here](http://www.lfd.uci.edu/~gohlke/pythonlibs/#matplotlib). If you are going to work with a lot of scientific packages, I'd recommend you uninstall python and install Anaconda instead, which is a version of python bundled with a huge amount of scientific modules, including matplotlib. It's a pretty big install, though, at least 2 gb. If you have troubles try asking in /r/learnpython, which is very beginner friendly. 
What do you mean by virtual environment?
Thanks!
What's ~~won't~~ wrong with r/AskProgramming 
When you type in a command on your terminal, it looks at the directories in your PATH environment variable. Whichever directory has an executable that matches the command that you typed in will run that program as the command. You can see the directories listed on your PATH by typing `echo $PATH`. Similarly, when you import a module in Python, it looks for that module in several places, to include directories in your PYTHONPATH environment variable and your PATH environment variable. Tools like pyenv and virtualenv ultimately work by manipulating those environment variables to change how the shell and the python interpreter look up executables, packages, and modules. pyenv is written in bash and includes all the functionality found in virtualenv and virtualenv-wrapper. I would just use it as opposed to the latter two tools, particularly since it's written in pure bash and thus has no dependency on any particular installation of Python. I've used pyenv for the past couple of years and I've found it to be great at what it does. That being said, I think the future of Python packaging is [pipenv](https://github.com/kennethreitz/pipenv). Honestly, if you're just trying to get stuff done, I would use pyenv as it's a mature, stable, easy-to-use tool that does its job well. If you're curious to essentially the beta-test future packaging/environment management tool for Python, go for [pipenv](https://github.com/kennethreitz/pipenv)
Windows not having Python installed at all cannot be considered a feature of the OS. For the rest, google **pyenv** and **virtualenv**.
Won't?
oops
search is fucked. i typed in "dicks" and got primordial black holes
What's wrong? @truh
You may also want to leverage [someone's pre-existing cookiecutter](https://github.com/knowsuchagency/cookiecutter-pypackage)
i finished implementing circular motion detection in python yesterday and wrote up a short blog post, mainly about what to do with it. check out my reddit if you are interested!
Being able to install it. I'm stumped. &gt;Command "/usr/bin/python -u -c "import setuptools, tokenize;__file__='/tmp/pip-build-3p9XhV/cppyy-backend/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record /tmp/pip-_JBMeU-record/install-record.txt --single-version-externally-managed --compile" failed with error code 1 in /tmp/pip-build-3p9XhV/cppyy-backend/ 
*Or* you could use `2to3.py` and only do the details by hand. 
2to3 doesn't port python code correctly. It's a very conservative program. It also doesn't handle unicode at all. The reason people have trouble updating is unicode and only unicode. You're better off using six and supporting both python 2 and 3. 
&gt; What is the delay used for? If a short event causes an error in the first core, it may under some circumstances be less likely to also affect the second core on the next cycle. Say, if there's a sudden, short burst of radiation or an electrostatic discharge that causes a failure in operation.
Looks like lies to me. The variables A, B, C, z1, etc don't appear to have been defined anywhere, so eval would fail with a NameError exception.
Well, that's one end of embedded applications. There are tons of others where resource consumption is less of a concern. I worked with an EZ80 based building automation system where anything but C and assembler would have been disastrous for performance, but I also worked with a DPI solution where the python scripts we threw at it could as well be spitting in the ocean, but by pretty non-controversial definitions could still be considered embedded hardware. Customers bought for its capabilities as an appliance, not as a computing platform. Designed to be installed, configured and left to its own devices. On the other hand, I've worked with systems that don't really qualify as embedded platforms that make many embedded systems look like powerhorses. VIC-20 is a general purpose computer with 5k of RAM and a 1 MHz single-accumulator CPU. The Atari 2600 is a video game system with 128 *bytes* of RAM and a 1 MHz single-accumulator CPU. Point is that "embedded" and "power" are actually entirely orthogonal qualities.
Well, an example of where C++ of unknown quality using a library the SO OP was unfamiliar with wasn't as quick as a low-level and highly optimized C-backed function of Python's happened to be on it's basically idealized case. Plus for all we know the C++ version ran with the file cache empty and the Python one had a fresh cache hit. These sort of benchmarks are very often pointless and misleading. Well written, idiomatic Python is not, and cannot be, as fast as equally well written and idiomatic (and properly compiled) C or C++, given all other measures being equal. It's not possible for it to be, as there is **always** the runtime to contend with.
Perhaps the OP forgot to past the bit of python code that defines those variables just before the file is loaded. 
I also think that the Python version is much easier to read and is probably more usable. There's probably a much higher quality equivalent to eval in C++, but as you mentioned it wont be more optimal than all the hand optimization that has gone into python eval.
In general, a virtual environment may refer to a number of different things (virtual machines, docker images, etc.). In this context, he is referring to the practice of using venv, virtualenv, and other similar/related tools for the purpose of compartmentalizing python dependencies (i.e. modules they install and use via pip), and in some cases, other python versions. In the case of python 2 and python 3, you should be able to simply install both at the same time directly on your system without needing any special virtualization. However, if your system does rely on python 2, your path variables for "python" and "pip" should continue to refer to the python 2 installation that comes with your system by default, and you should have separate references to "python3" and "pip3" for the purposes of interacting with python 3. **Here are your take aways from this thread:** 1) Learn python 3. Learn about python 2 later just to be knowledgeable. 2) To install python 3, simply run the [installer](https://www.python.org/downloads/) for your OS. Current version is 3.6.2. No special nothin'. 3) See the python 3 documentation on the venv module (which ships with python3 by default [here](https://docs.python.org/3/library/venv.html). **To set up a venv:** 1) Open the terminal, go into your project folder, wherever it may be: cd ~/my_project_folder 2) Make your venv inside a new folder in that directory: python3 -m venv ~/my_project_folder/my_venv 3) Now, whenever you work on the project stored in my_project_folder, you will start by running the following command: source ~/my_project_folder/my_env/bin/activate You should now see (my_env) to the left of your shell prompt. **While inside of the venv, the following will be true:** 1) Running "python" will run python3 instead of python2 since you made the venv using python3 (with the command python3 -m venv...) 2) Running "pip" will likewise run pip3 for the same reason. 3) if you run: pip install some_random_module ...it will only be installed *only within the my_venv*, and will not pollute your system python installation! And that's the point. 4) To exit your venv, run the following command: deactivate Run that in your shell, not in python.
There's also the fact that \^ is xor in Python but exponentiation in that C++ library, as one of the SO comments mentions.
 All of the above works on both linux and OS X, btw. 
"forgot". Yeah. He also forgot that `^` is binary xor in Python, not exponentiation, so his calculations will be completely different. Apparently he didn't compare the results he got in C++ with those in Python. 
It can certainly be faster. Load a complicated binary file into a series of numpy arrays. Using libraries means your well written code is that much better. A 2 GB file read in 4 seconds is slow to me. You're not going to make it faster in C, certainly not without far more complicated code. We should be comparing apples level of Python effort to apples level of effort in C. If your problem is IO bound, it doesn't matter. 
That's a relatively easy fix with a quick regex, though it would definitely reduce the speed of the Python.
I got in the habit of creating venvs directly from the python executable of choice rather than hoping PATH is correct, like so # /usr/local/bin/python3.6 -m venv .env 
Well, it's easier to read, but at the sacrifice of being a bloody stupid thing to do if someone has control over what's in those files.
Why not /r/learnpython I'd prefer not to fracture the community we have or encourage facebook
Using `sphinx.ext.napoleon` didn't work for you?
Sure, it gets much better, especially when you rely on libraries that are implemented in C and Fortran.
Breaking it is fun. An e will break it.
Python executes code inside a class definition the same as it executes code inside a script: from top to bottom. This won't work in a class for the same reason it won't work in a script: the function isn't defined when you try to call it. # inside or outside a class makes no difference do_things() # Fails with NameError def do_things(): ... One common solution is to move the function to above where you call it. Or move it to outside the class altogether. Why is is inside the class? The tricky thing is if you need to call the function both as a method (whether instance method or class method) *and* during the construction of the class. For example, this doesn't work: class Spam: def method(self, x): return x + 1 value = method(99) # expecting 100, but get TypeError The problem is that inside the class body, the descriptor protocol magic that makes methods work doesn't run, and `method(99)` doesn't have enough arguments (expecting two arguments, `self` and `x`, but only got one). Changing to a class method doesn't fix this. Using a staticmethod would work, except that the staticmethod descriptor object itself isn't callable. You can write your own descriptor (caution: this is deep Python magic, only a little simpler than metaclasses, and you aren't expected to understand this) but the easiest way is just to move the code into a module-level function, and call that, and then have a method do the same: def function(x): return x + 1 class Spam: def method(self, x): return function(x) value = function(99) 
/u/Skaruts was trying to call `Derp.method` from *inside* the class, before `Derp` actually exists. That's why they got the NameError.
&gt; I use 's' for everything, rather than a bulky 'self'. Ewww. If you want cryptic single letter names, you can find Perl [here](http://www.perl.org). *wink* `self` and `cls` are only interchangable in the sense that the interpreter doesn't care what you call them, so long as they're legal names, but when reading, it really makes sense to follow the standard naming conventions: `self` for instance methods, `cls` for classmethods, `meta` for metaclasses, and I use `this` for custom descriptors that don't fit into any of the above categories. But `s` is definitely used for strings, and even then only for generic string functions. I don't know what this "Self Hell" is you refer to in another post. 
Which you should do. If you're not using the optimized libraries out there, no wonder your code is slow. Years ago, I saw a convolution done in C vs. Numpy. It's a fairly simple algorithm, but it was faster in numpy. Using a library like numpy means you have people with PhDs trying to optimize their code vs the stock equation. I'm not going to go implement a convolution integral, matrix inversion, or eigenvalue/eigenvector extraction. I've done it in C. It's slow, full of truncation error and memory intensive; I'll use a library.
Sorry, my point is that *Python* cannot be faster than *C++*, not that well-optimized *C* and *Fortran* called by Python cannot be.
[Allright then](https://assets.bontards.com/thumbnails/ec/ec05fb2ccb61388f667adefccee5d2d311a3012e/capture-d-e-cran-2017-07-22-a-14-01-45-original.png)
Wow! Did not know about venv plugin for pyenv, I use alias plugin for environments and this is solid, but looks like overkill.
Google + pycharm
We already have /r/learnpython, and stackoverflow. How is this meant to be different?
What are differences with python-control http://python-control.readthedocs.io/ https://github.com/python-control/python-control ? I wonder if Julia https://julialang.org/ is not a better bet than Python for control.
You didn't show any code, so we can't give any kind of detailed answer, but experiment with this sort of thing: xtl = ax.xaxis.get_majorticklabels() # Get the xticklabels # xtl = ['list', 'of', 'xtick', 'labels'] # alternatively just set your own list ax.set_xticklabels(xtl, rotation=90) Adjusting fontsize also can be useful. The "rotation" keyword is probably mainly what you're looking for though.
`^` is xor in cpp also - it must be getting overridden by the exprtk library, or the results are wrong in both languages. 
&gt; Ewww. If you want cryptic single letter names, you can find Perl here Nope! Thanks but I prefer python, but with my classes readable, and with less time wasted typing straw code. There's not even anything cryptic about it, you instantly know what it is when you see it. If you don't understand [this class](https://pastebin.com/Hc58501B), it's probably not because of that. EDIT: by this I don't mean that I won't adapt to these conventions. It seems to me that everyone's interpreting that I don't care about them. I do, but I'll adapt in my own way, so that half of my spare time isn't spent writing `self self self cls cls cls self self self cls self` and my brain doesn't melt trying to filter out all that crap to read a class. &gt;I don't know what this "Self Hell" is you refer to in another post. I saw it first [here](http://kmkeen.com/self-hell/), but it's a name that's been around. 
Any time you can use a literal instead of a built-in function it will be faster because the byte code can load the object directly instead of doing a check to make sure the built-in hasn't been reassigned. 
Did not know this, thank you!
Doctest format is the only one that makes sense to me. def factorial(n): """Return the factorial of n, an exact integer &gt;= 0. If the result is small enough to fit in an int, return an int. Else return a long. &gt;&gt;&gt; [factorial(n) for n in range(6)] [1, 1, 2, 6, 24, 120] """
For example, it is legal to say `str = first_name + last_name`. So the interpreter has to check to make sure that doesn't happen, which takes time. 
It's awesome, I use pyenv for all my python stuff. I can easily install all versions, create virtualenvironments, it even has the autoenv functionality built-in and is so easy to use.
This is really interesting, but would there ever be a case where it would be relevant? A few µs isn't going to matter for ~10 strings, and I feel like you're never going to initialize millions/billions of empty strings in Python. Honestly, the best savings is that fact that "" is much easier to type.
Despite the deafening silence to my first post, here is some more of my dataviz code. This includes various helper functions for Pillow (the "friendly Python Imaging Library fork"), a few functions for creating Pillow-based charts, and the sample scripts used to generate this [bar chart](https://raw.githubusercontent.com/Udzu/pudzu/master/dataviz/ukelections.png), this [time chart](https://raw.githubusercontent.com/Udzu/pudzu/master/dataviz/g7.png), this [periodic table](https://raw.githubusercontent.com/Udzu/pudzu/master/dataviz/periodic.png) and this [image grid](https://raw.githubusercontent.com/Udzu/pudzu/master/dataviz/40under40.png). Comments welcome as before.
This is the correct answer. TY for taking the time to write it. IMO if more python devs understood what virtualenv was doing, we'd have much simpler solutions to these types of problems instead of so many convoluted ones.
This webpage is not available ERR_SPDY_INADEQUATE_TRANSPORT_SECURITY A microcosm of the master troll language: python. Koan: A new kid on the construction crew is full of energy ready to help. The master carpenter says: "here, take this stick and bang nails into that pile of scrap wood". OKAY!!! The student was not enlightened. When the student meditated on the koan, then the student was enlightened. The master carpenter never wanted you to contribute or have any skills.
https://stackoverflow.com/questions/18098061/change-the-ticklabel-orientation-and-legend-position-of-plot
Yep. seems like premature optimization.
Single quotes are even easier! 
so does that mean you should do `{}` instead of `dict()` too?
Seems like it would be useful to be able to switch that off in the interpreter for people who wouldn't do that.
Yes
I'm curious why anyone would go the verbose route with str() in the first place. Thinking about it, are there places outside format conversion or type checking where you'd actually want/need to use str()? Even with string building, f-strings are still more terse than str(). 
I agree. Let's never endorse or support Facebork.
&gt; I'm curious why anyone would go the verbose route with str() in the first place. This (somewhat) reminds me of a stackoverflow answer by Alex Martelli where he talks about "pronounceable code". [Here is the link](https://stackoverflow.com/a/2745292/8079103). Although he seems to prefer `dict() vs {}` and `list() vs []`, he does seem to agree with you about `str() vs ''`. &gt; I wouldn't use str() in lieu of '' any more than int() in lieu of 0 -- that wouldn't promote "pronounceable code" nor reduce punctuation. 
That would cause a lot of chaos, unless you're only writing single scripts with no dependencies and never working with anyone else.
Most of the scripts I write are for automating my work so yes that applies to many of them.
If you're on python 3 and you hate pep 20. 
 &gt;&gt;&gt; dis.dis(lambda: str()) 1 0 LOAD_GLOBAL 0 (str) 3 CALL_FUNCTION 0 6 RETURN_VALUE &gt;&gt;&gt; dis.dis(lambda: '') 1 0 LOAD_CONST 1 ('') 3 RETURN_VALUE 
I always use `{}` for empty dictionaries.
Yeah it probably won't matter, but who knows!
Python 3. Ignore anyone who says otherwise. Edited for markdown :'(
I use both. It's easy to write your code to support both using the module six. I also support 3 versions of vtk, pyqt4 and pyqt5. Ideally, if the user has to use your code, it doesn't matter which versions of your dependencies or platform they use. It should just work.
If you're starting something new, use 3...reasons to do otherwise have effectively evaporated in the last two years. I write code all day for work, and we switched a year and a half ago, and haven't looked back. 
Agreed 100%
Note: Reddit is Fun parses this as a numbered list so it looks like: &gt; `1. Ignore anyone who says otherwise` /u/moleeternal means use Python 3 😉 
You're sure he did not refer to Python 1?
Lol, awesome
Ask the devs
both...and it's not my choice(not always atleast)
* 2 + 3 simultaneously for any open source library I write (unless there's a compelling reason to use async/await), so that a wider audience can use it. * 2 at work (upgrading 8+ year old large project with 150,000+ LOC to 3 would be a headache and the benefits probably don't outweigh the costs). * 3 by default for anything greenfield. Used to be that the libraries were better on 2 as recently as 3-4 years ago, but these days 3 is probably the better ecosystem.
How about {0} - {0} for empty sets? I'm guessing set() is faster.
But how much slower are triple quotes, if at all?
How many tests do you do per day? 
It's a big topic, and it ain't cheap, but if I were going to learn it all the hard way, again -- not in a university program -- I'd start over and begin with [Computer Science: Distilled](https://www.amazon.com/Computer-Science-Distilled-Computational-Problems/dp/0997316004?) and then move through the books recommended in that that interest you.
&gt; I'd be really interested in seeing this once you get it figured out! Trying to learn some Flask but I feel like I need a simple project first
Interesting. I've been using python and {} since before set literals existed, so I've never thought of it as anything other than an empty dictionary.
In CPython it does not even check it loads then calls the builtin every time. The literal is in the function's constants and can be loaded directly from there. 
At runtime? No difference. The difference is in the parsing stage. 
I started in my first job on python 2 because this was before 3 really took off. By the time I left python 3 was the obvious winner, but there was two years of legacy code to port, so it never happened Having just started a new job I decided to make the switch. Bar the fortnight of `missing parenthesis in call to print function` it's the best thing ever. G-strings are amazing, generator delegation is amazing, python 3 is just better!
Tried it. After it failed a couple of times on RTD I gave up because it wasn't worth the time in my opinion.
Python3 95% of the time.
I [timed it](https://gist.github.com/therealfakemoot/2d2cfd49af01e624ae33405c7cfca5d6). Looks like the `set()` function is actually faster. The reasoning there is `{0}-{0}` is constructing two literals AND calling the `__sub__()` method . Calling `set()` on its own amounts to less work overall.
But do none of your scripts have dependencies? Even on modules included with python.
This is my first time really messing around with matplotlib, so I'm definitely still learning how to do a lot of the basic stuff. That did the trick! Thank you very much!
Some do. Some don't.
My job is all 3 now because it's a relatively young project. 
Thanks for the link. It was helpful! 
[Python does string interning](https://stackoverflow.com/q/15541404) on string literals, so `""` won't really use more memory than `str()`.
Why wouldn't it be? str() makes a call that creates an object and assigns it. While "" will just assign empty string object that was pre-created when python started. Why would you even use str() looks like unnecessary attempts at optimization.
Likely a whole team! Machine learning is helpful for this problem, I'd imagine.
Two years lol. We've got something like 15 years. We're working on it. 
This probably (and by probably I mean definitely) needs pandas added to /python-libraries/science. Its exclusion would be odd anyway, but *quilt* is there, and I mean, good luck using quilt if you don't know how to use the pandas dataframes it returns
Will add it now. Thank you. :)
Python 3.3 documentation says the following: "Curly braces or the set() function can be used to create sets. Note: to create an empty set you have to use set(), not {}; the latter creates an empty dictionary, a data structure that we discuss in the next section." Coming, personally, from ECMA land, {} is a quite natural way of creating a dictionary.
Not directly related but im a big fan of high charts and using flask to deliver the content via AJAX from client side.
Coursera have some interesting courses on this topic. You can watch them for free, but without certificate at the end. https://www.coursera.org/specializations/data-structures-algorithms
Thanks for sharing, holoviews are really cool!
WebService for online gaming. 100 millions user. 1 million simultaneous requests. Python+Flask is good enough to save development time vs something custom writter, but optimizations like this are extremely helpful. Bottlenecks are already rewritten in C. Everytime we manage to not to create an additional object - we see a visible bump in uwsgi requests rate. Yes, even changing dict() to {} visibly helped. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Another Example Where Python Beats C++ • r\/Python](https://np.reddit.com/r/programming/comments/6owq98/another_example_where_python_beats_c_rpython/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I know I'm going to get downvoted for this, but here goes: Python is not a fast language. If you need speed, then use C or something like that. Python is for writing code that is readable and maintainable. I can't imagine a situation where the speed increase switching out "str()" for "" is going to make much of a difference compared to just switching to C.
Numpydoc. It's awesome because it's supported by Sphinx, and it is very detailed. On the other hand, it can be annoying to change things in multiple places. I've recently started experimenting with a Numpydoc/typehinting combination, though.
Love pillar.py. Curious why you bother doing all this charting in PIL considering the number of Python modules, JavaScript solutions, and Excel features dedicated to this problem.
I know it generally goes without saying, but for the benefit of thoae not in the know, add "on the CPython implementation". I wouldn't be surprised if an implementation like PyPy could in many cases optimize away the check for builtin reassignment. 
I agree with your opinions. Thanks for responding guys! 
Right. This is just about Cpython bytecode. 
For someone like me who uses python on a daily basis to maintain product database info,if I can easily swap out the builtin function for literals and save a few seconds on run time, that's a few minutes a day, multiply that out by a year and you save a few bucks of productivity. Even a little time savings ads up so these little tips help folks like me out.
I find it hard to believe that you can use flask and than save some noticeable amount of time by building string by "" instead of str(). But I probably misunderstood.
str is actually just grabbing a cached value in that case.
this probably comes down to the method of reading lines of the file into memory in each case. nonsense post. 
Not a comment on the code, but: "There are 255,168 different states in a game of Tic Tac Toe." Where does that number come from? There are 9 slots and each can be one of three options (X, O or empty), so wouldn't that be 3^9 = 19683 possible states? (not accounting for reflections etc)
&gt;&gt;I wouldn't use str() in lieu of '' any more than int() in lieu of 0 -- that wouldn't promote "pronounceable code" I don't understand that argument at all. 0 is pronounceable, but how are you supposed to pronounce `''`? I don't see how that's any different from `[]`. They both start and end a 0 length data structure
I read somewhere `" ".join([first_name,last_name])` is faster. didn't check it though.
So now we're down to *some* scripts with *no* dependencies for personal use *only* which won't be used by other people and can only be maintained in a different way from other code. All for a minor improvement in a very specific use-case. And you want them to radically change the way that Python functions just for that?
If the flask-extensions work this is actually a really great project.
Control and curiosity, I think. I do use matplotlib+seaborn for 'proper' charting, but ended up using Pillow for some image grids and then got drawn to it for other things. I'm certainly not planning to implement a general scientific graphing package in it, though I think it does have scope for certain types of visualisation.
I've only tried [Flask-Login](https://gitlab.com/pgjones/quart/tree/master/examples/login) so far, do you have any recommendations to try?
I can't really speak for Alex Martelli, I was simply pointing out what he said. You could always ask your question on that particular stackoverflow answer, he might answer it directly. 
I haven't read them myself, but I get the impression they are for people who are already familiar with doing manual pentesting.
&gt; G-strings Lol! Well, can't disagree with you there, G-strings are amazing :P
There's a list that flask tries not to break with updates, http://flask.pocoo.org/docs/0.12/extensiondev/#approved-extensions
I guess it wouldn't Zouden!!!
Using literals is also a bit more expressive.
The post above is replacing the str symbol not just doing a string concatenation example. 
Important to note that this is just encoded, not **encrypted**
Ok, so that's nice optimization, but it still is making a call. IMO I don't think there's a place in Python on Optimizations like these, you should just write code that is readable. If speed is the issue, then you rewrite bottlenecks in a different language (typically C) or use statically compiled language for the project.
My problem isn't really with openpyxl, it is more I'm not sure how to properly call the function. The error I'm getting is almost certainly a fairly simple python syntax issue as I'm still very much a beginner.
exprtk doesn't compile anything to C++. It doesn't implement C++'s arithmetic. To perform an exclusive or with exprtk, you use `a xor b` instead of `a ^ b`. To perform exponentiation, you use `a ^ b` instead of `pow(a, b)`. Regardless, the person claims they altered the input to use the appropriate operators in Python.
Should be `{}` for sets and `{:}` for dicts IMO.
hey /u/dalore can you tell me more about the symbol thing, googling python symbols does not help much. Is the str class is called the symbol?
Built a web scraper to scrape football (soccer) scores from the sky sports website and print them out into a pretty table in the shell. Work in progress but the basic functionality is there. 
When you type 'str' the Python interpreter looks up it symbol table and sees that str means to use a specific block of code which we refer to as strings. Now you can redefine str to be whatever you want. That's what he did. 
That's... I like that a lot more after 2 seconds than I did when I first read it, and now I'm a bit bummed that it will never make it into the language. The only similar thing I can think of that wouldn't break anything is `{,}` for sets, but I don't really like that. I feel like it would imply that `[,]` and `(,)` should be valid because those literals also use a comma. The colon is unique to dictionaries, which I think makes `{:}` a better option.
I'm probably going to post it on Github,so you can def take a look. Really though, most of the complexity is in the application itself and has nothing to do with Flask. I could send you some simple boilerplate that will get you a running flask server in no time. And really, the Flask tutorial is pretty great. Very simple to follow. 
{,} could probably make it in, but it looks a bit weird imo
Indeed, but it'd break all Python code with the first in them already. And that's not acceptable.
Yeah, it's too late to fix that. Maybe if they ever introduce a backward compatibility-breaking version. 
Well, there's not just one hash. The way it hashes a unicode string differs from how it hashes a float, for example. There's quite a lot to take into account. As of 3.4, for byte strings and unicode strings the hash is selectable at compile time from either [SipHash](https://en.wikipedia.org/wiki/SipHash) or a modified [Fowler-Noll-Vo](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) hash, with the default being SipHash. (See [PEP-456](https://www.python.org/dev/peps/pep-0456/).) For very small strings (under 5 chars or so) a simpler djb2 hash is used. All the hashes used a randomized seed/nonce to prevent hash collision attacks. 
oh! I get it now. Thanks a lot!
You can believe anything you want to believe. I am talking about actual example on our codebase for our usage. The difference is significant. Another example of significant boost I found was: previous code: dict([(a,b) for a,b in ...]) fixed it with dict((a,b) for a,b in ...) This intermediate unnecessary list creation slowed each request a little bit. And when you have a queue of those - they do accumulate. 
A symbol is the association between a name and its value. https://en.wikipedia.org/wiki/Symbol_table
Non-Mobile link: https://en.wikipedia.org/wiki/Symbol_table *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^94081
Isn't `(,)` a literal empty tuple?
No, it's invalid syntax. You're thinking of `(x,)`, which is the syntax for a single element tuple.
&gt; Python is not a fast language. Technically Incorrect. The default CPython implementation is slower than C and other common languages, True. However, Python itself has many different interpreters, most of which are designed to be faster, such as Pypy and Cython. Edit: tl;dr: Language != Interpreter
So 3.7 -&gt; 4.0?
Why "read somewhere" when you can measure? $ python3 -m perf timeit -s 'first="first"; last="last"' "first+last" ..................... Mean +- std dev: 49.4 ns +- 3.0 ns $ python3 -m perf timeit -s 'first="first"; last="last"' '"".join([first, last])' ..................... Mean +- std dev: 160 ns +- 2 ns 
Does this mean that redefining subroutines used in existing functions will change those functions' behaviors? That's stupid. *tests* &gt;&gt;&gt; def hello(): ... print("Hello there!") ... &gt;&gt;&gt; hello() Hello there! &gt;&gt;&gt; def print(a): ... pass ... &gt;&gt;&gt; hello() &gt;&gt;&gt; Why would you make the language work like this? I would have assumed the behavior would be more like the following: * Functions are data, just like lists, integers, etc. * A named function is a ref to a function * Using the ref directly uses the value of the function at that point * Defining a new function uses the ref, but leaves the old data for any existing refs On compilation, a function would convert any directly-referenced subfunctions to direct ties to the data, rather than to the reference name. Most languages don't provide the ability to redefine functions, but let's take a look at a few that do: ##Forth - my style : hello S" hello!" CR TYPE ; ok hello hello! ok : TYPE ; redefined type with TYPE ok hello hello! ok ##Node.js - python-style &gt; console.log("hello") hello undefined &gt; a = function(){ console.log("hello"); } [Function: a] &gt; a() hello undefined &gt; console.log = function(a){}; [Function] &gt; a() undefined ##Ruby - python-style def hello() print("hello") end hello() def print(a) end hello() hello ##perl - my style sub hello { print("hello") } hello(); sub print { } hello() hellohello I guess I'm just old-fashioned. This isn't even optimization, really, since it dramatically affects how different importable codebases with a shared namespace will interact. With the style perl and forth use, modules that use specific names internally, but don't expect to be used outside, continue to work as expected. Consider the following: from X import * from Y import * in python, if X and Y have overlapping functions, they will interact. Mainly, any Y.util() will take the place of any X.util(). In perl and forth, this behavior can only disrupt the code expecting both modules to be fully available, not each one's internal functionality. Obviously, python solves this by encapsulation inside individual namespaces. 
Are you running with Python 3? types.MethodType in Python 3 takes only 2 arguments - the name of the function and the instance of the object. I don't think you can add a method to the class itself in Python 3 using this method... not sure though. I am fairly new to Python. Can someone comment how to add a method to a class dynamically in Python 3?
Your style makes recursive functions a pain in the ass. You can still do it, but you have to use the y-combinator and it's ugly as hell. 
Don't import with *. Import exactly what you need or maintain the module namespace...
Is it because one has to run a function?
OP, In the patch_worksheet function, may be able to replace these lines: m = types.MethodType(merge_cells, None, worksheet.Worksheet) worksheet.Worksheet.merge_cells = m with this: setattr(worksheet.Worksheet, 'merge_cells', merge_cells) or possibly just: worksheet.Worksheet.merge_cells = merge_cells
Modules *are* able to dictate what is imported when you type `import *`, though. And for modules that have their own (C-like) namespace in the names, it's fine to import globally.
It may not generate problems. But it can, and also makes it harder to understand what is accessible in this module, sure, we dealt with this in C, but it's not necessary. And it makes the code way more readable.
If you want to choose what version of python to use for your virtualenv you can pass in the path to the python version with the -p flag when creating your virtualenv.
I was going to say that's a stupid argument he was making, but then I realised that I was pronouncing "dict()" as "dict parenthesis" and "{}" as "dict." So maybe I just think it's a silly argument because I'm subconsciously pronouncing things differently than he is. 
i mean, as a rule of thumb, yeah. i wouldn't intentionally throw away this advice just to be angsty. i think the point is - except for compiled modules - python is just not a performance oriented language.
Rad! I'll keep my eye on this!
I thought that at first, too, but it's on a log-log plot. 
Yes. https://stackoverflow.com/questions/5790860/and-vs-list-and-dict-which-is-better A blog posts exists somewhere that digs into the "why" but I can't find it.
Oh man I should have thought that it might not have been python 3. Thanks! 
I will try this tomorrow! Thanks. 
I said that at the end. &gt;Obviously, python solves this by encapsulation inside individual namespaces.
That depends on how functions are compiled. Specifically, when the name is overwritten. One could also argue that a language symbolically creating, then slowly filling, a function's definition would have access to its symbol from the start of the definition, not upon completion. For example, even though perl follows my style, recursive functions work as expected. sub a(){print(5);} sub a(){a();} a(); Out of memory! Technically, the python style also has to follow this rule, or this code would work differently. def print(x): print(x) #is this the old or new print()? print(5) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in print File "&lt;stdin&gt;", line 2, in print File "&lt;stdin&gt;", line 2, in print [Previous line repeated 995 more times] RecursionError: maximum recursion depth exceeded #Looks like the old print Yet, this code throws a RecursionError. So, both languages redefine the function name before fully compiling the code within, despite one preserving the old code reference and the other not for prior functions.
The tweet says "" is "WAY faster." I would think all caps "way" would mean an order of magnitude or less efficient big o. From the graph it appears to be consistentlyrics faster, but I'd guess less than 10%.
I think it is a fair comparison since the python is presumably simpler and easier to iterate on for optimization. 
... is the fact that empty strings bool to False not common knowledge?
You won't really appreciate svg files until you use your browser to zoom in: http://bokeh.pydata.org/en/latest/docs/user_guide/export.html#svg-generation
Any plans to move project to github? 
In addition to what /u/nemec said, `()` is the empty tuple.
How do those compare with `{a:b for a,b in ...}`?
Years and years ago, yes. Today, not so much. It's still a convenient way to concatenate a sequence of things whose number isn't known in advance, but any performance gains are gone and were an artifact of internal implementation, which isn't something that's good to rely on long-term.
I hate this plot so much (TL;DR humans suck at comparing values in log plots). Using his source with a single test of 10,000,000 runs - because I can't imagine a scenario where adding more run gives more accurate results - I get: $ python2.6 tim.py s="" durations 0.3015229702 s=str() durations 1.80297422409 $ python2.7 tim.py s="" durations 1.28322410583 s=str() durations 2.95777606964 $ python3.6 tim.py s="" durations 0.24903437200555345 s=str() durations 1.6517077800017432 Wonder why 2.7 is so slow?
Totally agree! I can't imagine a scenario where `''` wouldn't be more clear. f = '' if g is None else g looks much more explicit to me than f = str() if g is None else g "I don't want a function call. I want an empty string!"
If I remember well the check has little part in this overhead. It is more that calling a function is very costly. There is teo things that you can test to check my affirmation. Comparing global empty function call and operation on global variable Comparing global empty function call and local empty function call.
`join()` is 2.3x slower than string concatenation on my computer. You _really_ should test these things before saying there's no difference. Lots of the advanced python performance techniques talked about at conferences revolve around not using classes, or lots of functions. Because using either of those requires more CPU time. When you're trying to do billions or trillions of things in your app, these small amounts of time add up to hours or days worth of wall clock time.
Well for historical reasons majority of our services are still on 2.6 and we don't have this luxury there.
How would you determine who would and would not want to re-assign language builtins? Maybe in my script, I replace str to do more than what the builtin does. And now you want me to have to do extra work to use a design feature of the language, because _some_ people might incorrectly assign to a builtin instead of being more careful about the code they write? How far do we take that? Do we prevent every potential bug for developers at all costs?
I use a package called 'WinPython' which is rather convenient. It's a complete set of the scientific python modules, it installs to a single directory (so you can have one directory per python version), and doesn't require admin (so plays well on the corporate network). You could download and install a new version of winpython and test it with effectively zero risk to your existing installation.
Can you call C as well?
I really hope more projects decide to host source with free software. Gitlab at this point isn't just as good, it's better.
I wrote this tiny library about a year ago to help people prepare for technical interviews, school exams or assignments. Hope you find it useful!
Your ruby example is not comparable with python as ruby aliases Kernel.print as print. You can actually shadow *all* instances in *all* scopes by reassigning methods from the base class or module in ruby. &gt; irb(main):002:0&gt; print === Kernel.print &gt; =&gt; true &gt; irb(main):003:0&gt; module Kernel ; def print *args ; $stdout.write "foo" ; end ; end &gt; =&gt; nil &gt; irb(main):004:0&gt; print "bar" &gt; foo=&gt; 3 &gt; irb(main):005:0&gt; print "baz" &gt; foo=&gt; 3 In languages where built-ins are implemented as regular functions / methods instead of reserved keywords in the interpreter, and which allow mutable assignment, this is an intended design feature.
I'm not entirely certain about it and I don't have a python instance around to check it, but I believe that str.join is still faster than the + operator when concatenating many strings, because it doesn't have to generate a bunch of intermediate str objects.
I'm interested to know what you think using literals breaks in pep 20.
Of course people who want to know should test. But my point is that relying on quirks of today's CPython implementation is a bad basis for long-term maintainable code.
How integers get hashed is a bit interesting. Almost all "small" integers hash to themselves. The one exception is `-1` which hashes to `-2` (since the value `-1` is reserved in the hash function C API for indicating that an error has occurred). So what's a "small" integer? Any value between `-2**61+2` and `2**61-2` on my current system (64-bit Python 3.6 on Windows). I'm not sure if that varies with CPU bit width or not. In Python 2 the bounds appear to have been `-2**31` and `2**31-1` (the bounds of a signed 32 bit integer).
well, you guys advertise cffi as solution to all native interop problems, so why can't cppyy rely on cffi completely?
Ouch. We've moved most of our stuff to 3.6 and I'd fight tooth and nail against going back.
Ha! I was drunk. G-strings are also good though.
Django works, Flask works, there's a bunch of async frameworks with no clear winner (yet, though Sanic seems to be the most actively developed one), or you can deploy sync frameworks with Gunicorn+aiohttp to get some of the benefits at least.
Hey, what would you say are the differences with [Sanic](https://github.com/channelcat/sanic) then?
Methods look a little more rigourous than the usual 'let's pull github'. Poor perl, just keeps falling.
They are still showing python as not being embedded. Micropython anybody?
That doesn't have market share even remotely comparable to way those languages listed are used.
Why doesn't the interpreter do constant folding?
You've got to try this in PyPy or it's pretty meaningless
A language doesn't count as embedded until I can run it on a few kilobytes of RAM. By few I mean single digits. 
Post this in r/learnpython we'll help
Because CPython does very little in the way of compile-time optimization. In fact, I'm pretty sure CPython still officially labels itself as a reference implementation of the Python specification. For a Python compiler/interpreter that performs more rigorous optimizations, see PyPy. Edit: I realize I didn't really answer the "why" question. I imagine that part of the "why" is Python's intrinsic dynamism. When any name can be shadowed by any value at any time, you lose a lot of your ability to make educated guesses or inferences or assumptions about what's going to happen with code. For example, consider `{foo} - {foo}`. That can't be constant folded because `foo` could literally be of any type at any time. I imagine that someone could, if so inclined, say "well we can add special cases for literal objects/constants defined in the specification" but to quote the Zen of Python: `Special cases aren't special enough to break the rules.`. I'm not a core developer, nor have I spent any great amount of time reading or participating in the development mailing lists so I don't have any great insight into the process. You may be able to find more concrete foundations for these choices with research.
It's will be slower for 2 strings, but faster if you have many strings to concatenate.
Glad to see Python getting more usage. However, seeing how HTML isn't a programming language (read: Markup Language), not sure how much to trust this ranking. Neither is SQL (read: Query Language).
They do have an explanation for that in the article
I think the largest difference between Quart and Sanic are the project aims. Sanic I think is inspired by Flask, but aims to be a fast framework. Quart aims to be the Flask API with Asyncio. This difference can be seen when it comes to globals (request, g) for example which do not exist in Sanic. This difference I think gives a good choice to developers, should they wish to move on from Flask to gain Asyncio features they can prioritise speed at the cost of learning a new web framework with Sanic or prioritise minimal changes with Quart which mostly requires adding asyncio features to any existing Flask code. I'd also mention [Growler](https://github.com/pyGrowler/Growler) (which is also Flask-like) and [aiohttp](https://github.com/aio-libs/aiohttp) as two other great asyncio web frameworks.
 [pyGrowler/Growler](https://github.com/pyGrowler/Growler) &gt; *Description*: A micro web-framework using asyncio coroutines and chained middleware. &gt; *Stars*: 671 &gt; *Forks*: 29 &gt; [Issues](https://github.com/pyGrowler/Growler/issues) | [Pull Requests](https://github.com/pyGrowler/Growler/pulls) [aio-libs/aiohttp](https://github.com/aio-libs/aiohttp) &gt; *Description*: Async http client/server framework (asyncio) &gt; *Stars*: 3485 &gt; *Forks*: 622 &gt; [Issues](https://github.com/aio-libs/aiohttp/issues) | [Pull Requests](https://github.com/aio-libs/aiohttp/pulls) *** ^(This is Earth radio, and now here's human music ♫) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
No, what is your concern with gitlab?
Why is Swift relevant to this headline? The top ten has always included $MICROSOFT_LANG and $APPLE_LANG because of monopolized proprietary platforms, but they don't compete beyond their niche. I find it fascinating that Apple managed to advertise Swift as competition to unencumbered platforms like Python, and that our community seems to actually buy their marketing, despite Swift not having free batteries.
While I agree on HTML, unfortunately SQL is definitely a programming language. SQL defines queries, sure, but you can (and people do) write logic in SQL, it's definitely a programming language.
The inherent issues with suck rankings are that they are super biased due to industry inertia. No sane person should program in languages such as Cobol, fortan, lisp, perl or even PHP.
Literals are special though
But now it's common place to have IOT devices to have RAM in the size of MBs and even GB.
That really should be "don't need to join a non-daemon thread IF its **run** method exits."
For sure! `a = 1` is a literal assignment. However, `{0}` is TWO components, the set literal syntax `{}` AND the value between the brackets. I haven't read the actual CPython source code in any depth, but I suspect that because `{}` is wrapped around a value, which could hypothetically be of any type ( you can do `{dict}`, which is a valid operation ) the compiler/interpreter opts not to do any inference and optimization. Again, not a core developer so I'm not an expert, but from my top-down understanding, it makes sense.
Thanks, this should be a more perfect title.
What about pascal?
From the micro-python website: &gt;Yet it is compact enough to fit and run within just 256k of code space and 16k of RAM. That's not tiny and you don't have an application yet. The company selling you a dodad with that much memory instead of double that to provide an equivalent product would be hard to beat.
File that under things I never even considered learning, but somehow have anyway.
I didn't realize I was in the Python subreddit, and for a moment was perplexed by the downvotes and this argument. Any embedded developer will laugh if you suggest Python qualifies. The volume of microchips produced every year that do *not* have megabytes of RAM is far far more than those that do. And on those chips you're trying to squeeze every bit of performance out of the limited resources. Maybe I'm wrong, so I'd love to see an example of a commercial product using micropython, *specially* one running with micropython's minimum specs (256KB flash and 16KB RAM).
Makes sense. I was thinking of making single str() per request, but if you make many, it's whole another story
But is it turing complete though??
I don't like how both variable names were italicised differently
In fact, it is. [Turing completeness in declarative SQL is implemented through recursive common table expressions.](https://en.m.wikipedia.org/wiki/Turing_completeness). So is Conway's Game of Life, interestingly.
**Turing completeness** In computability theory, a system of data-manipulation rules (such as a computer's instruction set, a programming language, or a cellular automaton) is said to be Turing complete or computationally universal if it can be used to simulate any single-taped Turing machine. The concept is named after English mathematician and computer scientist Alan Turing. A classic example is lambda calculus. A closely related concept is that of Turing equivalence – two computers P and Q are called equivalent if P can simulate Q and Q can simulate P. The Church–Turing thesis conjectures that any function whose values can be computed by an algorithm can be computed by a Turing machine, and therefore that if any real-world computer can simulate a Turing machine, it is Turing equivalent to a Turing machine. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Non-Mobile link: https://en.wikipedia.org/wiki/Turing_completeness *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^94242
Please don't mention that abomination! 
Seems odd when it does fold 1+1 etc
&gt;No sane person should program in languages such as Cobol, fortan, lisp, perl or even PHP. I agree with this part.
Exactly. The price difference between chip with a 16KB vs 32KB RAM might be only $0.20. But most of the time *that is enough* to prefer the cheaper one if it can do everything if you simply used C/C++. In the majority of cases it's the factor deciding whether the product will materialise at all. I think a lot of us engineers do not try to understand the business world in depth. This is what results in hardware getting exponentially faster but software staying just as slow. And complaints of high-margin pricing (e.g. Apple products) by comparing to BOM cost.
Why is Lisp in that list?
Whatever you say. I might be insane because I am not a programmer by profession, I am an rf engineer and I just pick the language that does the job for each application. If PHP works it works. We are not talking about big scalable banking monsters or w/e you are referring to only. There are many simpler cases that exist in the world... But if keeping something not complicated is the definition of being insane I am fine with it.
Why do you think no sane person should use fortran? Its still heavily used in HPC applications in the scientific community. 
Currently testing a mathematical discovery/proof. Looking good so far. 
The difference is a bit subtle to fit it here but let me attempt to give a brief summary. python-control from the start tries to retain the "Matlab" way of doing things. Now of course, that's a bit difficult to give a precise definition but let's say you wouldn't be super-stranger to commands and argument signatures. That's where I started to drift away already. The second part is more technical; matlab, and I guess Octave, relies extensively on SLICOT. python-control relies on the GNU licensed version of SLICOT(wrapped and renamed as Slycot). These are Fortran libraries that provide lots of routines about control systems. However, they have closed the source about a decade ago and the license is still not compatible with many control library settings (GNU Licensed). So if it isn't in SLICOT it probably won't be in python-control. And python-control is currently mostly for SISO systems. That's another reason why I drifted away. I'm obviously super simplifying the story. Other than that, I find matlab to be not moving at all and lack of support annoying. If you compare Solidworks 2000 and 2017 the result is incredible. If you do the same to matlab 6.5 and 2017a you practically get the same thing with maybe more colors and finally got rid of the colormap jet. Hence the user-friendliness changed none. But as you know from data science people, the world moved on to 1000000 data point plots in your browser. Hence, that's why I started this to get away and hopefully reach to a place where the user can use whatever they desire instead of firing up a mammooth Java container just to sketch some plots that doesn't even look nice. With regards to Julia, I'm following the KTH guys developing a control library and they are pretty good at it. But I can smell still the same problem, matlab legacy and old habits. Let me ask you a more concrete question, if whenever you draw a Bode plot you look for places where 180 degree line corresponds bla bla the usual stuff, why can't the computer do it for me? It's been almost 70 years now. I think we are smart enough to come up with guidelines of tuning. Why not the machine does it for me? Here is an extremely simple concept I've been playing with http://nbviewer.jupyter.org/gist/ilayn/f8cf8b0a68c6839dbcc346884511e2ed (It's a bit tough but try to hover on data points to see linked plots, and the plots are interactive if you haven't been familiar with bokeh etc.). Even this much is possible with half a page of JS code within Bokeh library. Thus I believe we are left behind by decades while the rest of the world moved on.
The reason is that function names aren't really special x = 2 def f(): print(x) x = 4 f() The output of this program shouldn't surprise you (it's `4`). The `def` statement _really is_ just an assignment underneath. So saying def f(): print(2) def print(x): pass f() really is just saying print=builtins.print # implicit def f(): print(2) print=lambda x: None #* f() Now, the only weird thing here is that `print` is a real python name and not a keyword. And so long as you don't `import *` these namespaces don't collide. *python doesn't actually create a lambda for a def but you get the idea 
Learning different modules, mostly built-ins using using HackerRank. It's been interesting, finished with basic numpy a couple of days ago. Thinking about starting with Pandas next.
Mathematically, your "dull" peaks are just areas of the signal where the first derivative is equal to zero. So you could combine a check for the derivative being beneath some small threshold value with another way of defining areas that are peaks. It might be easier to just apply a 1D smoothing to the input signal and then check for peaks on the smoothed signal. That should likely smooth out your flat top peaks enough for them to trigger in the peakutils check. There's a very simple method for data smoothing you can use from the SciPy Cookbook: [1d-smoothing](http://scipy-cookbook.readthedocs.io/items/SignalSmooth.html) Otherwise you could also look into interpolation to "fill in" the flat top areas
Our local python user group has regular meetings throughout the month. If you're in town for a week it's very likely that you could be free on a thursday night for PuPPy Programming Night. You can find them on meetup.com. [Here's the calendar for august](https://www.meetup.com/PSPPython/events/#8) If you want to spend more time doing python things with people, I am always down to pair program anywhere with anyone within a bus ride from Capitol Hill. Pairing is probably one of my favorite ways to learn new code things or share knowledge about code things. I also like mob programming, but sometimes it can be a bit overwhelming. 
Perl is returning from whence it came.
Meanwhile half the internet runs on WordPress.
Just started scrolling to see a C rant and found on the 3rd entry. They are really getting old I guess.
Ah I missed this comment. I still don't know what you mean by the library compiling into see but it's python code so you can always compile python-C? Do you mean as in XPC target way for dSpace etc? 
With an increasing number of substrings to join, ' '.join() is a sure winner: $ python -m perf timeit -s 'first="first"; middle="middle"; last="last"' "first+' '+middle+' '+last" ..................... Mean +- std dev: 346 ns +- 16 ns $ python -m perf timeit -s 'first="first"; middle="middle"; last="last"' '"".join([first, middle, last])' ..................... Mean +- std dev: 250 ns +- 10 ns 
Joining two substrings is the special case here. For more than that, ''.join() is faster. This is a classical case of microbenchmarking totally missing the grand picture.
Fun fact: embedded realtime Java has lower requirements than micropython (and is frequently used on billions of systems with less than 32K overall ram and storage: SIMs)
The issue is the principle of least surprise. You are not supposed to use PHP or some subsets of JS because they have surprising functionality, and will at first glance seem to do something different than they actually do.
Because syntax. Lisp doesn't do anything that other modern languages with a cleaner syntax which in turn makes them easier to maintain and read.
Then perhaps you'd be interested in the BBC micro:bit: https://en.wikipedia.org/wiki/Micro_Bit 256KB flash, 16KB RAM. Runs MicroPython. https://microbit-micropython.readthedocs.io/en/latest/
we really advertise cffi for that
Escape those underscores bud
iPhone and Windows are niche?
&gt;The BBC micro:bit is a small computing device for children. One of the languages it understands is the popular Python programming language. That's very cool, but maybe I should rephrase: I'd like to see a commercial product *implemented in* micropython.
FTA: &gt; (This is a great moment for us to reiterate our response to the complaint of some in years past of “HTML isn’t a programming language, it’s just markup.” At Spectrum, we have a very pragmatic view about what is, and isn’t, a recognizable programming language. HTML is used by coders to instruct computers to do things, so we include it. We don’t insist on, for example, Turing completeness as a threshold for inclusion—and to get really nitpicky, as user Jonny Lin pointed out last year, HTML has grown so complex that when combined with CSS, it is now Turing complete, albeit with a little prodding and requiring an appreciation of cellular automata.)
Having never built a compiler, I don't want to be one of those people that say "Well, it should be trivial to *JUST* do X" but yeah when you've got object literals literally in your bytecode you should be able to work with that. Perhaps posting the question to the Python mailing list would provide more insight.
It isn't though. Because if your task requires you to concatenate two strings, and you need to do that for a billion items (something I have personal experience with), then that savings is crucial. I suggest you go view the performance content of any PyCon, because there are lots of us out here doing large or massive data processing tasks with Python still, and any performance gain is significant for us.
I used to have so much fun writing Perl...
I've never used Python Tools in the full VS, but Visual Studio Code with the Python plugin works really well for me on my Mac. 
Yes, they are.
This is entirely untrue. Please, benchmark these things before you suggest them as factual. Even at four parameters, concatenation is faster. python3 -m perf timeit -s 'first="first"; middle="middle"; last="last"' "first+middle+last" ..................... Mean +- std dev: 129 ns +- 6 ns Versus python3 -m perf timeit -s 'first="first"; middle="middle"; last="last"' '"".join([first, middle, last])' ..................... Mean +- std dev: 204 ns +- 6 ns `.join()` certainly has major advantages in that you can specify the separator once and it will be repeated for every item except the last. So for convenience, `"".join()` is great. And in most cases, that's what you'd want...although I'm partial to `.format()` myself.
Except for that almost every scientific programming of meaning is programmed in fortran. Its as fast as C and super easy to program math stuff in (think matrix manipulation)
Apparently 'Arduino' is a language as well (when it's really just C/C++ with specific APIs).
I totally agree with what you're saying. But in the particular case of string concatenation, it's not a quirk that concatenating is faster than join or other methods to turn parameters into strings. It is a fundamentally simpler task, and therefore faster to execute.
They are _a_ niche for C# and Swift respectively. Personally, I thought it was pretty clear they were referring to the fact that C# and Swift aren't used much outside of their ecosystems, but if you really insist on arguing you could continue to use the other meaning of niche.
C# is used a lot outside of Windows. An an example I would mention iOS/Android mobile app and game development e.g. Unity and Xamarin.
Not free? It's Apache licensed, seems to run on Linux as well as OS X and there is no copyright assignment needed to contribute to it, unlike for most of Ubuntu projects. Apple does some unenamourous things, a lot of closed-wall ecosystems, but not all of it is.
If you want to be taken serious, you should be able to see that concatenating two strings is a specific subset of the problem joining N substrings. If you can't or won't do that, please continue downvoting anyone that happens to have a more nuanced view than yourself. But please don't bother me with your ninsense anymore. 
I agree with just physics, especially with a smoothing of your data. But if you need, I have used a lot peak detection for my phd, and I have extracted the algorithm embed in a complete yet complex library. https://gist.github.com/celliern/aff85af8ce527a6963ed8f01d79fc8a4
Nice work. I enjoy such not really package but collection of useful "simple" function.
&gt; This is entirely untrue. Please, benchmark these things before you suggest them as factual. Even at four parameters, concatenation is faster. Try it with 6, then google for the Dunning–Kruger effect... 
Your first sentence is amazing to me. As though somehow somebody here doesn't realize that the number 2 is less than any number larger than two. But the fundamental problem here is that "+" operates entirely different to other builtins like join(). The code behind the builtin is significantly simpler, and therefore it executes faster. If you'd like to benchmark this, please feel free. Choose a number larger than 2, and time how long it takes to join that number of strings with "+" versus join(). Using simple concatenation is faster. If you have an unknown number of strings to concatenate, then that's an entirely different problem. At that point, it would be faster to send the iterable directly to .join() rather than attempt to build your own loop. But this doesn't negate the fact that in the general case using simple concatenation of strings is faster. And again, I'm suggesting this is important in the case where saving small fractions of time is critical because of the number of operations to be done. If you think that's nonsense, fine. But lots of us process large data sets with Python. Maybe you don't, so saving hours of wall clock time isn't important for you. Great. But don't presume to know every use of every bit of Python and when someone else should consider something important or not.
In Python, you create a virtualenv per project and install your packages to it. When deploying, you also create a virtualenv and install your packages to it. [Pipenv](http://docs.pipenv.org/en/latest/) helps a lot with that.
If I develop a CLI tool for example, and use some libraries, and I need to distribute it to a lot of client endpoints, do I still use virtualenv on them?
Everyone loves writing it but it's write-only
If you want to distribute your CLI tool as a single bundle, you can look into [cx_Freeze](https://anthony-tuininga.github.io/cx_Freeze/).
Cool
Many possibility. You can use virtualenv, use cx_freeze, nuitka or other to embed your cli in an executable. You can embed all the dependency in the same folder as your module. You can carefully deal with the dependency in the setup.py and deploy it with pypi. You can make a [wheel](https://packaging.python.org/glossary/#term-wheel) .
You think I don't take my own advice? Of course I've tried with six.
&gt; proprietary https://github.com/apple/swift 
Is this due to the machine learning/deep data movement in tech? It seems like that is becoming something you must know
+1 for Perl, so great for easy scripts. Planning to pickup Perl6 this year.
This is what companies are using Simulink to do: https://www.mathworks.com/products/embedded-coder.html https://www.mathworks.com/videos/introduction-to-embedded-coder-68810.html If BMSpy can't do that, it won't replace Simulink.
For the curious: &gt;&gt;&gt; import dis &gt;&gt;&gt; dis.dis("s = ''") 1 0 LOAD_CONST 0 ('') 3 STORE_NAME 0 (s) 6 LOAD_CONST 1 (None) 9 RETURN_VALUE &gt;&gt;&gt; dis.dis("s = str()") 1 0 LOAD_NAME 0 (str) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 STORE_NAME 1 (s) 9 LOAD_CONST 0 (None) 12 RETURN_VALUE Of course, this sort of performance difference should almost never matter. If you need the sort of performance where the difference between these two matters you should seriously be considering using a different programming language.
I'd count Micropython as embedded for sure, check the memory usage: https://github.com/micropython/micropython/wiki/FAQ
Well, i think it makes more sense for rapid prototyping, if you're doing mass manufacturing, the cost of developing the embedded software is only a very small part of the total cost, so it would probably end up costing more when shipping embedded micropython to every customer.
You can be dogmatic or you can be employed
&gt; many Three isn't many
I'm employed and dogmatic. Even the hell of Java is nicer than some parts of the JS and PHP world.
I would say there is a lot of perl out there and plenty of people still using it. Not to mention PHP.
Recently gave a talk thingy somewhere. In the last slide I said included a point that said that "Mature, Boring technologies are still great." This was given the fact that PHP, Java and C# are still in the top 10 languages despite everything, especially in India. So I just asked people to chill out about any shiny new toy that may be out and still understand that some people may just end up, god forbid as VB programmers.
&gt; Coming, personally, from ECMA land, {} is a quite natural way of creating a dictionary. But then, you can't do `{1, 2, 3}` in ECMA land, right?
The idea is not replacing simulink and we've already dumped simulink for various reasons. For the embedded controllers, none of our embedded coders accept simulink based code. so in that sense, there is no intention. BMSpy is meant for simulations not code generation. 
How about 1-5 at least, and potentially more as the numbers get higher...but at that point you're probably doing something screwy.
Dunno if its in the rest of the script, but you need to call myline =random.choice(lines) everytime you want a new comment. so like this: for i in range(1000): myline =random.choice(lines) comment.reply(myline)
"Embedded" headless PCs or "Embedded" *embedded*. This is what the current chip I'm working with has: - 2 x e200z4 in delayed lock step operating up to 200 MHz - Up to 2.5 MB flash memory w/ error code correction (ECC) - Up to 384 KB of total SRAM w/ECC 
I don't have this. Thanks I'll give it a try!
&gt; none of our embedded coders accept simulink based code They don't? It's C or C++. And in my experience has less errors than human C.
you could just skip the "myline" variable and use comment.reply(random.choice(lines)) or use a function for choosing a line if you want the random line as a variable import random lines = open('file.txt').read().splitlines() def randomLine(x): a = random.choice(x) return a myLine = randomLine(lines) comment.reply(myLine)
I'm a python noob so I'm having trouble figuring out how to add this within the code. This is what I have now: for comment in r.subreddit('testsubreddit').comments(limit=1): if "test" in comment.body and comment.id not in comments_replied_to and comment.author != r.user.me(): print ("String with \"test\" found in comment " + comment.id) comment.reply(myline) I tried adding your for loop but I got indentation errors and I also think that I probably added it to the wrong spot.
Their argument is that matlab generated code is bloated with unnecessary headers and unused code. They prefer industrially tested, for this case FPGA, but in general C libraries. We are having a lot of trouble making customers accept any matlab based tools. In the end we just gave up and dumped matlab usage. 
Combine it with what xDarkistic said: for comment in r.subreddit('testsubreddit').comments(limit=1): if "test" in comment.body and comment.id not in comments_replied_to and comment.author != r.user.me(): print ("String with \"test\" found in comment " + comment.id) comment.reply(random.choice(lines))
&gt; Their argument is that matlab generated code is bloated with unnecessary headers and unused code. Turn on optimizations in the compiler. &gt; They prefer industrially tested, Simulink is industry tested in dozens of industries. From automotive to aerospace.
&gt; Turn on optimizations in the compiler. Won't help. they are included by default. &gt; Simulink is industry tested in dozens of industries. From automotive to aerospace. For low sampling rate, mission-noncritical plants yes. I did too. But for high performance systems there is no way. 
Not only it's closed source, it's also unmaintanable later version freezing is a nightmare. They are also computer generated hence there is no proper structure to get a handle on.
I use try else quite frequently to avoid putting code that might throw a nrelated exception in the try block that I don't want to catch. Though I only do this when I have a finally block as well. for-else and while-else are more confusing as they mean "if the loop by break." I don't find these as useful unless I'm doing some sort of linear search, e.g. for foo in foos: if cond(foo): found = True break else: found = False 
A python core developer explains this [here] (http://www.youtube.com/watch?v=OSGv2VnC0go&amp;t=15m52s).
Thank you for proving my point: it's counter-intuitive. Your two examples are *not* equivalent.
Thanks! It worked. 
&gt; But for high performance systems there is no way. Yep. It's used there too. https://www.mathworks.com/solutions/aerospace-defense/standards/do-178.html https://www.mathworks.com/videos/series/model-based-design-for-do-178c-software-development-using-matlab-and-simulink-95160.html https://www.mathworks.com/products/iec-61508/features.html 
An ARM is quite overpowered for a toaster. So what we need to define is what this nebulous concept of "embedded" really is. Your collection of gadgets is most likely different from mine, but I count the following: **Able to run micropython** * Printers (2) * ADSL router * TV * Sattelite tuner **Not able to run micropython** * Toasters (2) * Blenders (3) (Two of them are the hand-held thingy on a stick) * Microwave * Freezer * Refrigerator * Oven * Clock radio * Variable speed power tools (8) * Children toys (12) I've left my (EDIT:) phone out of the count, as it doesn't feel like a gadget with an embedded CPU. Include it, if you want. It won't change the fact that for my collection of things with embedded computational power, the large majority runs on a 8-bit pic with at most 1024 bytes of RAM and 4 KB of ROM (Except for the toys with long samples in a lousy quality). I'd be curious to hear how your spread is. EDIT: Added the word phone.
The first edition is Python 2. The second edition is Python 3. You can get both as PDF from http://greenteapress.com/wp/think-python/ 
In your *specific* case I prefer found = False for foo in foos: if cond(foo): found = True break I can see where it can be used but it looks more Perly than Pythonic, IMHO.
Yeah, you could write it for Python 3.
Good bot. 
Thank you RegmasterJ for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://secure-dawn-77807.herokuapp.com/).
iirc using sync frameworks with aiohttp is deprecated 
https://en.wikipedia.org/wiki/No_true_Scotsman http://wiki.c2.com/?WhyWeHateLisp http://wiki.c2.com/?WhyWeLoveLisp Lisp syntax is easy to learn and keep in your head if you can understand json or xml you're already there. Most things that one would attribute to programming language features are just functions and data structures. And that's the hurdle for newbs, the lack of an authoritative "standard library" because it's so easy to just compose what you need out of what already exists. and thus lisp programmer do just that, write their own stuff. -- my opinion
Trust me that's not the matlab version you are using that those places are using :) Testimonials are one thing, actual codebase is another. There is absolutely no way closed source code goes into those machines.
&gt; Trust me that's not the matlab version you are using that those places are using :) Is there a secret second version of Matlab? All the places I've worked have gotten it from the same place. &gt; actual codebase is another. I work in those industries. It's the auto generated C that comes out of Simulink Embedded Coder. I can tell you for certain that the Simulink Models go through Embedded Coder, get incorporated with any of the Hand C and comes out on the otherside of the compiler as a binary. &gt; There is absolutely no way closed source code goes into those machines. You can read the C it generates before it touches the compiler. Jobs using Embedded Coder are in demand: http://www.indeed.co.uk/jobs?q=Embedded+Coder http://www.indeed.com/jobs?q=Embedded+Coder&amp;l=
Yes. I use py3 or py2 depending on the platform.
Congratulations, you've just got my award for the worst comment I've seen in 17 years of using Python, and it's been upvoted!!!
It's an honor. 
This is absolute rubbish. You can reassign any builtin name at any time you like and the interpreter does nothing about it. &gt;&gt;&gt; first_name = 'You ' &gt;&gt;&gt; last_name = 'burke' &gt;&gt;&gt; str = first_name + last_name &gt;&gt;&gt; str 'You burke' &gt;&gt;&gt;
Some things to check: - Is the data transfered as float (because you unpack float)? Transmitting floats is rather uncommon. - How ist the data sent over? How do you detect a "data package"? Line Based or simply take three values and convert them? - If you know how many bytes a data package contains, why not just read the exact size?
Years back str.join was always the winner but the + operator has been optimised over time so there's not much in it, **BUT** there are edge cases where the optimisation doesn't work so it's safest to stick with str.join.
Who cares about a mere six?
My original comment clearly mentions industry inertia. Just because everyone is using it because legacy projects doesn't make it right. 
&gt; Why doesn't the interpreter do constant folding? Numerous attempts have been made over the years but have usually failed owing to the dynamic nature of Python. However [FAT Python](http://faster-cpython.readthedocs.io/fat_python.html) seems promising, see also this [recent thread](https://www.reddit.com/r/Python/comments/6msl3r/fat_python_the_next_chapter_in_python_optimization/).
Thanks for your reply! The data is transferred as bytes, I convert the float to bytes, transmit the bytes, then unpack the bytes with the struct library. I detect a data package from a built in pyserial function, inwaiting(), which states that X bytes are in the buffer. I then read until the buffer is empty. I'm honestly not sure how big the data package is, because I assume the library is "padding" the packing. That's a good idea though, I could find out how big the data package is then read the exact size. Cheers for the input.
&gt; This intermediate unnecessary list creation slowed each request a little bit. I'd have thought that not creating the list would have saved you an arm and a leg, but as always I guess it comes down to how much data you have to process each time that you create the dict.
 In [5]: for i in range(4): ...: for j in range(4): ...: for k in range(4): ...: print(i, j, k) ...: if i == j == k == 2: ...: break ...: else: ...: continue ...: break ...: else: ...: continue ...: break There's nothing quite like it :) In all seriousness it's an occasionally useful feature, but poorly named.
&gt; If speed is the issue, then you rewrite bottlenecks in a different language (typically C) or use statically compiled language for the project. First read and implement [Python Speed Performance Tips ](https://wiki.python.org/moin/PythonSpeed/PerformanceTips).
Yes, function call overhead in Python is known to be high.
Everyone: this is a survey of IEEE Spectrum readers. The vast majority of IEEE Spectrum readers not SW developers, but HW developers. Also, they tend to be young (within 5-6 years of graduating college or still in college). So really, this says that young EEs like python more than anything else.
Anybody concatenating six strings.
It's not going to change after 25 years so why discuss it for the one trillionth time?
Any programmer worring about the performance of concatenating six strings is very likely to end up in an asylum pretty quickly as there are bound to be far more important things to think about.
If you are happy with it you should keep using it. I'm just providing my own subjective experience. You can just search for the injected nonsense and other rants online; first google hit https://stackoverflow.com/questions/10940669/matlab-coder-vs-hand-coding I have to emphasize we would love to use it if it was possible since we pay truckload of money to matlab licenses. 
Proprietary *platform*, not the language itself.
What's more is that there are non-Turing complete programming languages that can do pretty much anything you want. So Turing completeness really shouldn't be used as a barometer for "programming language".
That's simply not accurate, MB and GB of RAM is extremely uncommon in IoT devices.
Seems about right to me. I'm about to rewrite several spring boot apps in flask. For this particular use case, java is a massive resource hog (500M memory overhead for a 1000 line microservice [!!]), and it's not even more portable. I can't find any reason to use it except that java programmers are cheaper.
You're not using it correctly.
If they are using it, clearly they think it is fine to use.
Hmm looks like that might land in plain cpython via PEPs
Depends on how you imply 'new'. In the CG/VFX fields most of the 3D apps (except Blender) use a modified Python 2 interpreter. So any scripts we write have to be in Py2. External scripts can be Py3, but anything that the app runs needs to be supported by 2.7. So if I wanted to write a 'new' script, it would still have to be 2.7, but if I'm not held back by an architecture dependency then I'm writing 3.
I always add a `# no break` comment behind the else because of this talk.
I read it and don't agree with it.
It works for hundreds if not thousands of companies are that many more products. 
Wait..What the Fuck!?
The PyGotham program committee is looking for potential attendees, speakers, and the community to help shape the conference by voting on talk proposals. Open voting runs until August 7th. The votes will help inform the program committee as their build the conference's schedule. 
What? No. I have to use shell, Perl and other glue stuff which is unsafe, ridiculed throughout the industry because it's part of the legacy project and we can't afford to change all of it. Just because I use it, doesn't make it fine. I do it extremely grudgingly and making everyone aware how pained I am when I have to do it. 
Who am I to object if it serves their purpose. But for us and many companies it is not useful. MAybe we are a tinkering bunch I'm not sure. But for control purposes especially for motion control, we don't touch matlab at the embedded design stage even if we design the controller via matlab. We only use XPC target for quick prototyping, for production we use other technologies. 
It's important to note that dotnet core and VSCode allow for very streamlined dev outside of Windows
Without Cocoa and whatnot it's just another language though, with no standard, one implementation that is entirely, let's say guided, by Apple and technically cross-platform but realistically with no uptake anywhere else.
You might have better, more compact results with PyInstaller - give that a shot if you haven't already? Also, in either case, you can't make an executable for Mac from the Windows version of a Python app. You need to build the executable for the Mac on a Mac.
If you pack the data you know exactly how many bytes there are! The library sends exactly what you tell to send, there is no such thing as padding. Two more things: - Check the endianness (big / little) of the beaglebone and make sure to pack/unpack the data accordingly. - If you just start reading at any given time, it is pure luck when start reading the data leads to a valid package which you try to unpack.
Efficiency is the key to several major sites and products. In my case, I needed to process huge event logs and output certain data for customer and developer requests. This led me to viewing tons of research on speeding up python in situations like that. It turns out a ton of Australian government data research is done with python, and when you have a time boundary on data life or processing time, and you need to process a huge amount of data, saving fractions of a millisecond makes a massive difference. You don't have to like that fact, but that doesn't change it. Some of us need to wring efficiency out of python in any place we can. It doesn't sound like you do. Which is fine. I'm not trying to convince you that you have to do what I'm talking about, I'm simply pointing out these cases exist.
Please refrain from using that kind of disappointing language in this sub.
I suggest you reread my comments if you think you're saying anything new. 
Yah that's correct. There's no sets like that.
Wow
First of all, don't use parentheses around your conditions, this is not C. Then, you have an actual bug: instead of `while (ser.inWaiting())` you should have `while len(serialbytesdata) &lt; 3 * 4:`, and use `ser.read(1)` to avoid accidentally discarding data. The way the code is written, if you're lucky to check if there's some data in the buffer when there's exactly one packet in the buffer, then everything is all right, otherwise you'll either try to unpack an incomplete packet or discard the beginning of the next packet.
It's not a problem if you have a decent editor that highlights matching parens. And I see that sort of thing plenty in other languages, too -- any time you embed function calls as the last/only parameter to other function calls the parens start to stack up.
I always enjoyed working with Lisp. I love the extremely simple and clean syntax, and the direct mirroring of code &lt;-&gt; data.
Doesn't the Arduino platform come with it's own language which is very much like C but not quite?
Damn that Ubuntu and it's proprietary platform.
I have never used cx_freeze but have used py2exe and yes, you have to include whatever you have to include. But 350MB??? Are you sure you don't mean 35MB? 350MB seems about 10x too big for a "tiny" Python program. In fact, even 35MB seems too big: When I made .exe files for a 25k LOC program with a GUI, the resulting executable was about 12MB (and even that was annoyingly big, but that's what you get with Python, which can't compile to machine code, and the GUI libraries can be sizable). Long shot, but could it be that your build folder is pulling in every 3rd party library you have ever added to your Python ecosystem? Having not used cx_freeze I don't know how it works. I know in py2exe you can request various libraries be excluded, which cuts things down in size. And, yes, as the other commenter said, you can't cross-compile with cx_freeze, py2exe, or PyInstaller (anymore; they tried it between Win and Linux but dropped it), making an executable on a Windows machine that will run on OSX. *Maybe* with Nuitka, but I have no idea. EDIT: If you just want the guy at work to be able to run your script, have him install Python for OSX (actually, it comes with it, just not sure if it is the compatible version--try that first) and you can just email him the script. It's trivially easy, particularly if you are only using Tkinter for the GUI, as it sounds like you are, and no other libraries that he'd have to install. 
&gt; So Turing completeness really shouldn't be used as a barometer for "programming language". Even though many consider Turing Completeness to be the defining attribute of programming languages? Or, more pragmatically, even though all widely used general purpose programming languages are Turing Complete? Why should the barometer for judging whether something is a programming language not be "possesses the defining attribute of programming languages", or "possesses the attribute most commonly observed in things considered to be programming languages"? 
I actually tried PyInstaller but it isn't compatible with Python 3.6. Ah, yea I saw that now too. There seems to be some ways around it like emulating OSX but I'm pretty sure that would be too heavy for my computer.
Python and R are utterly dominant in Data Science and very widely used in Machine Learning and Natural Language Processing. It's also very easy to build Python wrappers around C and C++ code, so you see a lot of applications being developed in Python that are built on top of high-performance, memory efficient libraries written in C/C++. 
If you're into automated builds, check out AppVeyor for a Windows environment and Travis CI for Mac + Linux environments. They're free for open source projects, and can be used to automatically generate and distribute stand-alone Python executables for whichever OS. Building this way avoids the hassle of setting up the environment and handling the build process manually. Just make sure you have some way to test the results in OSes you don't normally use, or at least very cooperative and patient co-workers. EDIT: For private projects, looks like GitLab's hosted builder is free for private projects up to 2000 minutes/month. No personal experience here.
The size of the actual .exe is just 23kB so yes it definitely feels unnecessarily big. And yea inside the 350MB folder there are libraries that I don't use, so I suppose I should be able to ignore those. The thing is, I guess, that all my .exe's are put inside the same folder ('build') by cx_freeze, so I'm pretty sure most things aren't needed really. It's just that trying to figure out exactly what is and what is not needed is such a pain since the crash I get doesn't give me any info. But perhaps the only things I would need to include are the libraries that I use? Plus the .dll's. Are you saying OSX comes with Python installed already? Is the process of downloading and installing extra libraries as simple as using pipinstall? I'm using some extra libraries that I would need to download.
If you work in an IDE like every other developer, it's really not a big deal. 
If you're transferring data continuously it may make more sense to use a buffer and a termination byte to read in your data than to use inWaiting(). Consider reading one byte at a time then unpacking the set of bytes after you hit a specific byte/byte pair. Much less system overhead this way. 
It says rusts first stable version was release this year. Hasn't been updated since 2015. 
How to use it? Can you post a general command line search for "thefileiwant.txt" so we dont have to read the instructions? Also what is it searching?
Perl is still being developed and has been proven over time unlike newer languages. I am sure there are plenty of people who would be happy to argue that Perl is safe over at /r/perl/
Looks nice... I was recently working on the *next* step, that is adding a torrent to the client from its magnet... Not really worth gitting, cuz it was basically just filling forms in webui using requests.push()
IIRC it does do some preprocessing, but in the end it all gets thrown into a C/C++ compiler. Regardless, the syntax and semantics seemed no different, at least to me. But it has been a while since I last did Arduino stuff.
That's not what /u/bastibe meant. He was talking about Microsoft and Apple their proprietary platforms: Windows, macOS, iOS etc. 
Huh, those are basically websites that'll build the .exe's and the OSX/Linux counterparts for you? Instead of having to use a Macboox for example? That sounds like exactly what I need.
What's hacker rank?
Its simple. For file suppose 'thefileiwant.txt' - $ torrench 'thefileiwant.txt' It searches for torrents. It basically scraps pre-existing torrent sites (thepiratebay proxies), and displays results in console. Refer documentation for details.
Essentially. They can be used to run automated tests, builds, deployment, etc. Very useful for maintaining a standard environment and process that gets executed the right way every time, on time without wasting your time. No more problems with different team members crunching things differently or having dependency mismatches, which means reduced bus factor since there is no The One Who Builds that might not be available or whose computer might explode at a bad time. But remember to at least skim your releases in their target environments, if only by friend or co-worker. Even something "cross platform" like Python has a few OS-dependent gotchas, especially once GUI comes into it.
For me, when I click magnetic link, the torrent is automatically added to client ;)
Well they would be wrong.
EDIT: Never mind, looks like Facebook OSC isn't suitable for my use cases for a bunch of reasons mentioned in the 'Limitations' and linked 'Q&amp;A'. Chiefly, it doesn't work on RBR unless you're using Facebook MySQL... Pfff. I see no mention of Galera support, so I assume it doesn't. Anyone know for sure? Right now we have to option of RSU for non-replication-breaking changes, but if a schema change breaks replication then bets are off. We've used pt-online-schema-change tool, but there are situations where that fails for us, so it's nice to have alternatives. (gh-ost does not support Galera)
Oh shit you're gonna love this if you're beginner-intermediate https://hackerrank.com Basically you pick a topic and solve problems related to it. Topics could be sorted by language like Python, C, Java, SQL, etc. or by the kind of problem like Data Structures, Algorithms, etc [like so](http://i.imgur.com/FrvpEOU.png). The part where you solve problems has clearly defined rules, like the kind of input to expect and the output o produce, along with how to use the functions and modules you'll be needing, especially in the earlier challenges of said functions and module, [like so](http://i.imgur.com/0MrXwsj.png), and [this is what the solving part looks like](http://i.imgur.com/GyNGvlQ.png) You should really give it a shot
Time to learn more C++ and ASM to make money.
I am not saying you are wrong for doing so, as there are potentially many reasons one might prefer using Python over Java, but don't forget that the JVM is highly tunable. If you're seeing excessive memory usage, I would guess that neither your code or the JVM has been optimized. You can get insight into the problem by using a profiler like VisualVM or JMC.
Yes, joining 3 words is faster than adding 5 words :)
Trying to find occurrences of different phrases in Harry Potter and Deathly Hallows for kicks... anyone who can suggest ways to speed up making global changes to the book's txt in sublime? It's a huge text and any edit takes up a couple of minutes, and I'm on i7
You have a good eye for details. However, that doesn't change the conclusion: $ python -m perf timeit -s 'first="first"; middle="middle"; last="last"' '" ".join([first, middle, last])' ..................... Mean +- std dev: 263 ns +- 12 ns This is with python 3.6 on a x86_64 Linux btw. Addendum: &gt;&gt;&gt; dis.dis(lambda: first+second+third) 1 0 LOAD_GLOBAL 0 (first) 2 LOAD_GLOBAL 1 (second) 4 BINARY_ADD 6 LOAD_GLOBAL 2 (third) 8 BINARY_ADD 10 RETURN_VALUE Each time another string is added, it takes another BINARY_ADD. This will allocate an increasing number of temporary strings, that becomes unreferenced as soon as the next BINARY_ADD have completed. That will yield a huge overhead of memory managment. &gt;&gt;&gt; dis.dis(lambda: ''.join(list)) 1 0 LOAD_CONST 1 ('') 2 LOAD_ATTR 0 (join) 4 LOAD_GLOBAL 1 (list) 6 CALL_FUNCTION 1 8 RETURN_VALUE str.join() on the other hand is a single call into C (at least in CPython), which calculates the storage requirements all for the resulting string, so there's no overhead there. 
Now you have the minimum understanding required to make something.. anything. What would you like to create? What's the first step? Can you break it down if it is to large, and work on it one piece at a time.
Not sure about "best" but this oneliner is useful for reading japanese encoded text files when you copy the path of text file: python -c "import pyperclip ; pyperclip.copy(open(pyperclip.paste().strip('\"'), 'rb').read().decode('cp932'))" Then I paste into google translate. I'm trying to find a translation API that isn't as restrictive as google's. Too lazy to make context menu item.
Alright, thanks a lot! That sounds really useful.
First I would like to thank you for responding this, 72 people saw this only you responded. Second I was thinking about combining tkinter and maybe socket or urllib to make port scanner :) Thanks again
Selenium shouldn't be the first step when introducing someone to web scraping. Your code selectors are also kind of poorly done, making the final structured output kind of confusing. The use case would be much more suited for just using requests and beautiful soup. 
You might want to look at something like selenium
Incase you are using Python 2.X go for the libraries Mechanize and Beautiful Soup. Incase you are using Python3.X go for RoboBrowser as Mechanize is not present. I used Python 2.X and made programs to download data/files/attendance. Feel free to take some ideas from my programs on girhub (shivam1104) 
Set literals were actually introduced in Python 3.0, and the empty set was denied. See these ([1](https://mail.python.org/pipermail/python-3000/2006-April/001286.html), [2](https://mail.python.org/pipermail/python-3000/2006-April/001406.html)) mailing list threads. `{}`, `{,}`, `{/}` and `{-}` were suggested at various points. These solutions were found to be too arbitrary, and gives you a 'gotcha' when removing elements - `{1, 2} = set`, `{1} = set`, `{} = dict`!, so you need to remember to do `{/}`. 
I suggest using pyqt5 + pyqt designer for the gui portion.
I made a Mortal Kombat-themed tic-tac-toe with my own (really simple) AI for school. It's pretty basic (I think) but it felt like a real accomplishment when I finally got it to work.
This is the best example for when to use for/else, and shows why the name might make some sense: Looping over the foos, you test the if many times. The else clause is only executed of all of the if's were false, just as in an if/else statement.
JVM tuning is the worst, let's please just not use java.
Awesome! I could never "understand" AIs. In my head, it's just tons of IFs, but obviously it's wrong that way.. do you mind to give me the most brief and simple explanation you can come up with? I don't want to programm one or give a speech about it, but I'd like to get the IF-Thing out of my head.
What are you coding the website in? Any framework?
Yes, then, you should *definitely* be able to [exclude most of all that stuff in the build folder](https://stackoverflow.com/questions/27281317/cx-freeze-preventing-including-unneeded-packages). And what happens if you do this? 1. Note down the size of the build folder. 2. Back up the current build folder to somewhere secure. 3. Delete everything in build. 4. Rerun cx_freeze. 5. Now look at what's in build. Is it much less? What's the size now? &gt; Are you saying OSX comes with Python installed already? I am. However that's about all I know about it, since I don't use any OSX machines. What version of Python are you using? I don't know what OSX currently comes with; it used to be 2.7. I don't know if these days it uses 3.x. I ask that because, a) you have to be compatible with the version your colleague at work uses and b) post Python 3.4, pip comes included with Python. But before that one had to install pip itself first and I've found that a big pain (you have to first install easy_install or something...it was non-trivial). I'd Google around or ask here which OSX comes with which Python. 
Hey, I've also been playing with ML stuff in python. If you havent yet, check out the youtube channel [Sirajology](https://www.youtube.com/channel/UCWN3xxRkmTPmbKwht9FuE5A/videos). He has some good videos and nice sample code that you can use to get all sorts of fun ideas in motion.
That's a good point. What I have done in the past was to read some bytes at first until i found the "package delimiter". From then on I switched to a mode where a fixed size was read and evaluated. This worked quite good but it need to be mentioned that you need control over both ends, sender and receiver, in order to make it stable.
I can't speak for Swift, but with .NET Core, C# is rapidly losing its status as a Windows-only language, even outside of use cases like Unity and Xamarin.
You could look in to using the free tier of [EC2](https://aws.amazon.com/free/) to host your Twitter bot.
I'm not aware of how Ren'py works, and I'm not a great python programmer either, but I'd do something like this: myLunch = "" def myFunction(): global myLunch myLunch = raw_input("What do you want for Lunch?") I don't know if every action in ren'py is or has to be a function, but myLunch would then be accessible from every other function or part of your code. Like: def laterDialog(): print("I see you ate " + myLunch +" recently") print("How did you like " + myLunch) or without a function: print("This chef cooks the best " + myLunch) There might be a better way to do this, thou... Or for later dialogues: if (myLunch = "Salmon"): print("Did you like your Salmon?") else if (myLunch = "Steak"): print("I love Steak, i prefer it medium rare") else print("Hm.. I never ate " + myLunch + " before, tell me how you liked it!")
Oh OK I did some QT with c++ so will try thanks again! :) Can I do urllib and at at same time in qt creator?
That's cool. Will do. What's the best/ challenging/fun python one you've done?
A lot of AIs work by looking different scenarios, and uses some math or algorithms to assign scores to each of them. After considering and scoring each situation, it simply picks the one with the highest score.
Django, and some Flask for the talk voting module
My best creation is an app for a friend that runs an in home childcare center. It let's you select which child you are inputting data for, and then you can select from set of accordions for diapers, bottles, nap, burpings, items needed, and a notes section. Once you select the info for the child and hit save it saves it to a local file and then at the end of the day she can hit send to send an email with all of the details to the parent. I am working on a parent companion app so that they can communicate dropoff and pickup times and the person doing it. And also working on allowing pictures to be sent straight from the app to the parent.
Why the switch from python to java? I can understand moving from flask to django, but java is generally quite tricky to optimize and scale compared to python...
Yep you can use any library with it I would suspect
Oh, so I just have to declare it as a function, and then start the dialogue with "if (function= "Decision")"?
Made a raycaster using Tkinter https://github.com/vesche/raycaster-tk
According to the source code, the output image should be in the same folder as the video. However if there are some special characters in the video filename or path, it might fail.
Oh, thank you! That makes a lot of sense, thanks!
You don't have to declare it as a function. I think it makes sense to group it a bit. And yes, you could basically do that, but you'll need a "return" at the end of your function to put it into an if statement. like def askQuestionAndDoStuff(): chosenFood = raw_input("give me value") return chosenFood Then go to your if statement and say if (askQuestionAndDoStuff() == "chicken"): do something About grouping it: def secondPart(): do something else here print("dialog from the next chapter") ... def firstPart(): input = raw_input("..") print("Dialog") if(input == "chicken"): do stuff print("something") .... .... secondPart() is much easier to read. you can also do input = raw_input("....") print("dialog") print("another dialog) if(input == "chicken") do something here with chicken ... print("dialog from second chapter") .... but to me it's very hard to read, especially if it's getting reeeeally long.. 
Never used Python for web development. How does the index of a website made in Django work? When I go to pybay.com it works, but if I try say pybay.com/index.py the site appears to be broken? Or is index.py not how it finds the root?
Is there any way to specify an output location? I renamed the movie file to just "movie" and it doesn't change anything. Still just a temp .bmp that I cant open
It's missing key pieces of C++, notably no exceptions and also a different string implementation.
AI Chatting cat www.talkigy.com
Good bot.
Perhaps more of a service architecture approach, not a pure language approach, and in line with the framework linked. An API/web service in python is quite straightforward to scale/distribute with a reverse proxy, micro services, and simply breaking your application into services that better fit your infrastructure. I have never come across using Java for this end, and do have some doubts on how flexible can one be on the application design given how tricky JVM optimization can be...
&gt;Who is maulynvia? "I'm not sure what to say" Ice cold.
Just for fun I wrote an emulator, assembler, and debugger for a 6-bit microprocessor I made up. Six bit. The entire memory space fits on a chess board, with each byte holding values octal o00-o77. The memory space has a reserved range for "hardware" I/O including a four-character display. Since bytes are only 6-bits, the character set was redesigned to fit useful characters in it. The debugger lets you load programs, and run free or single-step through. I am pretty sure all that, including copious documentatuon, is under 500 lines.
Check out mqtt for a messaging protocol.