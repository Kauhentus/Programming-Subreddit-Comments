We had issues with proxies and encryption for s3 buckets. Worked just fine in Python 2.
Shameless plug: [Pynsist](http://pynsist.readthedocs.io/en/latest/) is the tool I wrote to distribute Python applications on Windows, after I ran into problems with the freeze tools you mentioned. With pygame, pyglet and PyQt5 it can pull the wheels from PyPI to build an installer, even building a Windows installer on Linux. There are examples in [the repository](https://github.com/takluyver/pynsist). This isn't a complete or final solution - I think using MSI packages would be technically superior. But NSIS is easier, and I'm pretty pleased with how it works. 
There are a couple web dashboard frameworks: [spyre](https://github.com/adamhajari/spyre/blob/master/README.md) and [pyxley](https://github.com/stitchfix/pyxley/blob/master/README.md) and a newer viz library called [altair](https://github.com/altair-viz/altair)
About their product "Nikola".
&gt; code written against 2.0 is extremely unlikely to break on 2.7 and onward That's incredibly false. Pure Python will have hopefully have only a few changes. Libraries change though. Do you remember numeric? Do you remember PyQt defaulting to PyQt3? Those don't work on modern Python. I run a 70k lined open source Python 2.7.7+/3.3/3.4/3.5 project. It's not that hard, but you need to test regularly. That 2.7.7+ is a requirement because the struct module changed in that version. I also write a Python 2.4/2.7 module for work. That code is significantly harder to keep robustly working because I have to backport libraries, can't use with, exceptions changed, you can't use list comprehensions, the behavior of `float('1.0245D+6')` changed. It's annoying.
You got me curious. Here are my two versions. The first is single-process and the second is multiprocess (with that balancing I was talking about): `single_factorial` #!/usr/bin/env python import sys def main(): n = int(sys.argv[1]) result = fact(n) #print result def fact(n): result = 1 for i in xrange(1, n + 1): result *= i return result main() `multi_factorial` #!/usr/bin/env python import sys import multiprocessing def main(): n = int(sys.argv[1]) result = fact(n) #print result def odd_fact(q, n): result = 1 for i in xrange(1, n + 1): if i % 2 == 1: result *= i q.put(result) def even_fact(q, n): result = 1 for i in xrange(1, n + 1): if i % 2 == 0: result *= i q.put(result) def fact(n): q = multiprocessing.Queue() p1 = multiprocessing.Process(target=odd_fact, args=(q, n)) p2 = multiprocessing.Process(target=even_fact, args=(q, n)) p1.start() p2.start() p1.join() p2.join() return q.get() * q.get() main() If I run these with a large enough number, the multi-process version is faster: $ time ./single_factorial 30000 real 0m0.190s user 0m0.184s sys 0m0.004s $ time ./multi_factorial 30000 real 0m0.139s user 0m0.200s sys 0m0.008s The funny thing is that if I make the number larger (e.g. 40000 on my comp), the multi-process version seems to suddenly take way longer. I'm not really sure what's going on there, but I presume it must have something to do with how the data is passed back to the main process. Possibly something in the pickeling protocol (which is how the Queue works) is really slowing down the larger value from being sent. Kind of interesting...
Yes - when my co-worker inherited some code from a third party, I was amazed at how fast the Intel compiler crashed with an internal error.
Take a look at the Jupyter Incubator projects, specifically Dashboards and Declarative Widgets. It's incredibly easy to use these to make simple data-driven single page web apps directly from a Jupyter notebook. They also have preconfigured docker containers that you can use to deploy. https://github.com/jupyter-incubator
It could be, but I find it odd he would have chosen Node.js in the first place as these issues aren't exactly new.
Working on an algorithm called "Progeny clustering" to estimate the number of clusters present in a data set. There's an R implementation of it but no python one yet so I though what the hell. Not sure if this is kosher but I'm fairly new to python so if someone wants to check it out and give me a tip, it would mean a lot to me: [pyprogeny](https://github.com/baasman/pyprogeny/blob/master/pyprogeny.py)
For the names of classes and variables go read pep8.
There is a bunch of examples of what not do do over on /r/learnpython ..... where you should be posting this question
&gt; If you are about to ask a question, please consider r/learnpython. Homework-style questions will be removed, and you'll be encouraged to post there instead.
The Explorer declarative widget looks pretty cool. 
I'm looking for feedback, feature requests, example use cases, or general comments on my new pypi package: [gzint](https://pypi.python.org/pypi/gzint/)! Feel free to comment here, or submit [issues/pull-requests](https://github.com/pirate/gzint) on github.
This is really good. Your recommendation on appointments makes sense. I mentioned working in UTC, but I will update the guide to mention storing in UTC as well. Thanks!
Yea, actually the first time I used utcnow, I expected it to be aware, but it certainly wasn't. Quite weird.
I see the issue. The original multi-threaded version I had was deadlocking. This version does not have the same problem as far as I can tell: `multi_factorial` #!/usr/bin/env python import sys import multiprocessing def main(): n = int(sys.argv[1]) result = fact(n) #print result def odd_fact(q, n): result = 1 for i in xrange(1, n + 1): if i % 2 == 1: result *= i q.put(result) def even_fact(q, n): result = 1 for i in xrange(1, n + 1): if i % 2 == 0: result *= i q.put(result) def fact(n): q = multiprocessing.Queue() p1 = multiprocessing.Process(target=odd_fact, args=(q, n)) p2 = multiprocessing.Process(target=even_fact, args=(q, n)) p1.start() p2.start() result = q.get() * q.get() p1.join() p2.join() return result main() Note that I move the `result = q.get() * q.get()` to _above_ the joins. It's pretty clear what's going on. The queue has some sort of internal buffer which is getting full. I.e. the main process needs to read out a piece from the buffer before the subprocess can continue to write to it. But the problem is that in the previous version the main process was trying to join on the subprocesses before it would actually read from the queue. This means that once we were passed the limit of what the queue would hold the program would deadlock. Btw for me the magic number at which the old version failed was 38052. I.e. the old version would finish computing with 38051 and would deadlock with 38052. I looked at the sizes of the numbers involved and the two numbers that the subprocesses were trying to write to the queue were sized 34968 and 34964 bytes (the odd number is the smaller one). So I guess what happens is that if you pickel those numbers and try to write them both to the queue you get larger than the internal buffer. I'm not sure what that buffer is, but with overhead maybe 34968 + 34964 = 69932 rounded up to 2^17 = 131072 bytes in my system? Maybe 2 ^ 18 = 262144 bytes? (I'm assuming a power of 2 which is pretty normal.) Anyway this ended up being a fun little exercise...I guess the lesson is that even in (what I thought were) the easiest multiprocessed applications you can run into deadlock.
Sorry for the late reply... I think my problem right now is that I don't know what I don't know. So far for me, Python and Django have both been very streamlined and usable that I don't know what to even write a utility that could help solve some of their problems! So that's why I'm sort of at a loss for ideas. 
Details? Code? Wanna check out.
But why does this work? The only reason why a gzipped string should be more efficient than the bits directly are if there is repetition in the representation that the gzip encoding can optimize. Random, large numbers won't have this property, and their representation can't be made smaller, gzip or no gzip. Or is there something I'm missing?
This code doesn't display anything. Nor, as far as I can tell, have you said what's displayed. You'll probably be given a link to /r/learnpython but I don't think that'll help. Unless you've missed copying something significant, I suspect your assumption "This code displays it" is wrong, and your question has nothing to do with this snippet of python. What are you asking?
It's annoying, but manageable. You can (and should) pin your dependencies, and when you do that, your code will simply not break overnight.
I like [PyCharm](https://www.jetbrains.com/pycharm/). Especially with the linter enabled for both 2.7/3.5.
Once you have an account, you can add short scripts in their Gist section so that you're not having to create an entire project. Gists are similar to pastebins.
I'm wondering how to get rid of that message and I'm not sure what's causing it
It might not be too late to apply for an internship at bank of america. search about for how to to do so?
1. PEP 8. It's not a religion, but when we all do things the same way, we all win by easily being able to parse each other's code. When you go to an entirely foreign project one day, and can immediately read it all, you'll feel a kind of joy that's all too rare these days. 2. Get comfortable with what duck typing is. Look at what a file-like is and how some implementations enforce the interface. Try ABC in a project. You'll learn more by doing than trying to research and get it right the first time. Programming is iterative. 3. Give PEP 484 a skim. 4. Folders become libraries/modules when they have an `__init__.py` in them. once there is one, you can do a relative import in the same folder with a `.` `from .foo import bar`. You can go up one level with `..`. It's a lot like relative navigation of a file system, but there's no slashes.
Commenting for posterity 
I love pycharm but I wouldn't call it particularly lightweight. @OP you'll need to be more specific with what features you need. An ide is not required to "import libraries". All you need for that is any text editor and a terminal. Would that suit your needs? Personally I like sublime text with a few addons.
If you go for the factorial of 10000 and above then your computer will freeze up that is why we need thread
Examples all use powers of 10 as well, which would compress well. 
What message? This? &gt;RESTART: filename That has nothing to do with the python snippit you posted. Maybe your editor / IDE does this? Maybe some other command does this? Maybe it happens as part of launching your python interpreter? Searching for the word `RESTART` isn't going to be very fruitful. If your script _did_ produce output, would it appear after the word `RESTART`? Try tossing a `print("maybe")` in it and find out. 
You're right, it's absolutely not an IDE but does everything asked for in the question. Hence op needs to be a little bit clearer about what he's actually after.
I can't agree with you more!!!! :)
Thanks for all the input guys! I decided to stick with 2.7 since a lot of the libraries I want to use still rely on 2.7. Also, everyone keeps saying it wont take long to transition once I have a good grasp with 2.7. 
you can't get whiskey just by itself. you have to get flask-whiskey
Actually, you are right, this does not work, and this cannot work. This is well explained in the answers of [this question](http://math.stackexchange.com/questions/3419/is-it-possible-to-represent-every-huge-number-in-abbreviated-form), this is a basic concept of information theory from what I understood. Another issue is that `__sizeof__()` is misleading, because it does not return the deep size of the object (with the attributes, I mean), it simply returns the size of a `Class` Python structure which is 32 bytes. The examples given by the author are thus unfortunately erroneous. &gt;&gt;&gt; a = 10**1000000 &gt;&gt;&gt; b = HugeInt(a) &gt;&gt;&gt; a.__sizeof__() 442948 &gt;&gt;&gt; b.__sizeof__() 32 &gt;&gt;&gt; b._value.__sizeof__() # Where the gzipped int is stored 1025 Using a random number, it can be observed that the compressed number is actually heavier than the number itself. &gt;&gt;&gt; c = a + random.randrange(a) &gt;&gt;&gt; d = HugeInt(c) &gt;&gt;&gt; c.__sizeof__() 442948 &gt;&gt;&gt; d._value.__sizeof__() 470415 
You might want to try out http://thonny.cs.ut.ee/
It's just off putting to people that are actually trying to learn something. The guy made a grammatical error and was legit excited about writing something. Something nice might have been like "hey nice job, but just for future reference python is an interpreted language so it doesn't have executables. Instead they are called scripts." I didn't downvote but that's my assumption as to why people are. 
Interesting idea.
It's pretty simple and straight forward, you don't need to learn anything, just add a line of code when you need it, and comment it out or remove it when you don't. Issues and prs are welcome.
This is of course true. It is impossible to compress random data without losses due to the pigeon-hole principle. The purpose of this project is to exploit the fact that most data we work with in real life is not actually random, and often compressing the base-10, base-2, or hex representations of a number will provide huge memory savings. I'll add a section to the README explaining the theory and limitations, I shouldn't assume everyone looking already has a good grasp of the limitations of compression. If you take a look at the bottom of the README, I have plans to add more compression methods besides simple base-10 gzip (gzipping other bases, fourier transform compression, etc.). Regarding \_\_sizeof\_\_, thank you for catching my mistake about 32-byte class size, I will patch that now. \*Edit: I've updated the README with a new **[theory](https://github.com/pirate/gzint#theory) section**, and fixed the incorrect \_\_sizeof\_\_ example.
Fixed. Good point about graphs, I'll add some once I have some more compression schemes and have time to tune the performance a bit.
Could you provide a link to what you're doing?
It's not a grammatical error. The sentence was grammatically correct. Maybe a semantic error, if you'd prefer. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
I disagree with that. You should learn to write code that supports a wide range of versions. When numpy 1.10 went and deprecated a very fundamental way of slicing arrays, I was pissed. Then I found out that they did it because people used it wrong. I found multiple bugs in my code due to that change. When scipy accidentally breaks cKDTree in scipy 0.18.0, your code should still allow a user to use the most up to date scipy. My Qt/VTK based GUI supports PyQt4, PyQt5, PySide for the Qt part of things. It supports VTK 5, 6, and 7. It supports Python 2.7.7-3.5, not including 3.0, 3.1, and 3.2 because those are unsupported by my dependencies. I develop on Windows, yet it supports Linux, because I run the unit tests on Linux. Installing your software shouldn't be hard. Projects have dependencies that force library versions to make it easier to develop them and share code within an organization. Libraries should not force you to do the same. Every time numpy and scipy have a new major release, my code breaks because I use the functionality. Every time a new Python is released, my code breaks. They're small issues, but you have to test. The good news is when my code breaks overnight, I know a new version of numpy/scipy/VTK/Qt was released. It's worth it to have a bulletproof code.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
&gt; Random, large numbers won't have this property, and their representation can't be made smaller, gzip or no gzip. Take a 100 MB ASCII file of integers preferably that mean something to you. Now make a binary file of the same integers. Add some compression. The ASCII file will probably be a lot smaller.
Its just a .txt file, and I'm not allowed to convert it. Would said function still work?
I'll still hold out on someone else maybe having run into this as I won't have time to try it out until next weekend, but I'll update for anyone else that might run into that particular combination once I do
Inflammatory title, and OP doesn't even understand how free lists or the GIL work in CPython.
I guess this retard went straight from /r/learnpython to blogging bad advice
I like this. Stealing it.
&gt; Yeah, pretty much any CMS can handle shit loads of traffic with modern caching techniques, but that is because 99% of your visitors never touch any of the CMS code. So? Not sure I undersand your point. &gt; You are essentially turning your CMS into a static site generator. So? Yes, a CMS generates HTML before serving it.
I think scripts can be considered executables (e.g. with the +x permission bits on *nix systems); their counterparts in compiled languages would be binaries.
That was super satisfying to watch. Thank you.
Fourier? Isn't that lossy?
I used Inno before on the output of cx_Freeze. It's nice enough, but NSIS can be used on other platforms, and it's open source. I believe that with a correctly built installer, you can avoid the tricks that freeze tools have to do, so it makes sense for a build tool to integrate building the installer, rather than leaving it as a separate step.
FWIW, [Altair](https://altair-viz.github.io/) is based on [Vega Lite](http://vega.github.io/vega-lite/), which was designed to provide an holistic [Grammar of Interactive Graphics](http://idl.cs.washington.edu/papers/vega-lite/). 
Haha &gt; python in fact NEVER frees memory. which is alleged to be an optimization
&gt; ray hettinger Yep, I guess so.
Very similar to [Maze](https://www.youtube.com/watch?v=-u4neMXIRA8), from xscreensaver.
Haha，Let me explain you the story behind this gif image. This image is generated by a python script, no third-party lib/software, nor PIL/tkinter-like graphics modules, just pure python, there is no drawing command in it! This image shows you how Wilson's algorithm works on a 2d grid, so to understand this image, you must understand this algo first. Consider the following problem: given a finite, connected graph G, G might have many spanning trees, how can we choose one from them with uniform probability? Wilson algo says: 1. Choose any vertex v, and maintain a tree T. initially T = {v}. 2. For any vertex w with w not in T, start a loop erased random walk from w, until the walk hits T, then add the result path to T. 3. Repeat step 2 until all vertices are in T, then the final T will be we want. This algorithm is short in words, but quite tricky to prove, and the proof in Wilson's original paper would take one more than a few days to understand and even more time to absorb it. But it's not that hard to implement into code, The first animation I saw was [Mike Bostock's awesome Js animation](http://bl.ocks.org/mbostock/11357811) , which inspired me to make my own animation of Wilson algorithm, but with Python ! Python has its graphics modules like pygame/pyglet/tkinter, and there is no doubt that one can use these libs to make his animation, but what I want is a gif version. The first thought was to implement it in pyglet/pygame, and then save many frames into .png images, and then convert them into a gif file. But this way is very very inefficient: + For a reasonable size (150x120 cells) the animation would contains several thousands of frames, saving so many frames into image files in disk and read them back would be a horrible task. + I'm not sure if other gif tools can be smart enough to see there are only 4 colors in the animation and set the minimal code length to 3. I have seen many implementations use 8-bit length as default. So I hacked into the gif coding standard "GIF89a", and manually encoded each frame into byte streams with LZW encoding by recording each frame's window size, this approach is comparably succinct and fast. For a 1000x800 version, I got 7600+frames but only 2M file size! The code is on my [github repo](https://github.com/neozhaoliang/pywonderland), it's not commented yet and not very clean -- I have just finished it just this afternoon, but it will be cleaner soon. Hope you like it , and don't forget star the repo! BTW: currently the code only works for python2.7, not python3 ... I'll look back to the code later ...
Wouldn't it be better to apply the compression to a _set_ of data, instead of to the integer itself? Since information repetition in data sets are usually larger when the set is considered as a whole (2**100000 vs 2*100000+1), as real life datasets has their values within a certain range. Storing delta values with a large based could be enough in a case like this, if the variability in the data set is low but the values are large.
This is great.
Winpython (https://winpython.github.io/) has all, numpy, scipy, pandas, jupyter, spyder (light IDE); if running Windows are the best option. Spyder still work in Linux and Mac. 
How is this better than just redirecting `python foo.py &gt;tmp.log`? For anything more than that Python provides a logging framework.
Ha, TIL don't give Python advice when you've been drinking. Thanks for schooling me :D
I have a related question. For those of you running static blogs, do you just use a 3rd party comment system such as Disqus?
I'm not your guy, buddy!
That looks great!
Man, you're right that must be one hell of a proof lol
This algo seems very inefficient given the amount of times it just retries each path over and over and over. 
That could say something about all life. 
There's no reason for python interpreter to not free *d* after del'ing *d* as it makes the reference count of *d* zero, which in turn makes refcounts of each element to zero and eventually free all of elements of *d* and *d* itself. CPython has nothing to do with such memory optimization on custom types. As soon as object's reference count reaches 0, it calls C function free() on it and then system's object allocator takes care of it. There are free lists for often-used integers and strings like "", 0, -1, and so on, though. I've tried the example with python 3.5.2 on my macbook air '12: It took 886M before pressing enter, 6504K after. Nice counter-example huh? 
/r/titlegore ?
XScreenSaver was released in '92 and is created/maintained by Jamie Zawinski. Maze was first created in '85 by Martin Weiss and has been update by many (Including Jamie) since. Reading the source code it looks like the last major update to the maze code was '08 by Jamie. Interesting side note reading the official site: &gt; There is no Windows version of XScreenSaver, and there never will be. Please stop asking. Microsoft killed my company, and I hold a personal grudge. I don't use any Microsoft products and neither should you. I had always wondered why there the ports to things like Android were official but the many Windows ports pushed to the side.
Awesome!
Thanks! :)
That doesn't sound like lack of support, but a bug, did you reported it? 
It seems like it only concentrates on DST, it still doesn't answer of why not make datetime TZ aware and internally storing time in UTC format. That would resolve DST issue and possibly other ones as well, and it would not require local parameter, it could determine whether there is fold or gap based on time zone informations.
Thanks for pointing out this, corrected now.
I assume this is inspired by [Mike Bostock's version](https://bl.ocks.org/mbostock/11357811) from [Visualising Algorithms#wilsons](https://bost.ocks.org/mike/algorithms/#wilsons).
&gt; "GIF89a" Where did you find documentation for "GIF89a"
&gt; Hope you like it , and don't forget star the repo! We youtube now
Trying to work with some services, but wmi wont run, and im scared of pywin executables from sourceforge...
&gt; To expand your example, if you have 100 MB of random integers represented as ASCII, the binary encoding of those same integers will at least be the same - as the compressed version of the ASCII representation of those integers. I do it regularly due to only having a 500 GB SSD at work and no hard drive. It's non-random data, so it works. Binary data is 100x faster to do I/O on, but it's not more compressible. Seriously, though, try it.
7zip is pretty good. I'm not inventing my own crappy compression algorithm. I just do it on real problems.
I know some of these words
Looks like it's making a maze. It leaves a gap of one, then worms about until it finds its tail, closes off the selection, and repeats. That'd be a reasonable way to make a maze with long dead ends 'n' shit. That's a guess though.
I was telling my buddy that when gif first came out we had to code them manually. He didn't know what the hell I wad talking about, like code a gif generator? I was like, no, you code a gif. I wasn't really sure what I was talking about because I never did it back then, just read about it. Now I want to look at your code and say, see, that's what I meant. I still don't really know as I haven't done it myself. And as fun as it sounds...it doesn't really sound that fun, to tell the truth. Perfect solution for your purposes though, way to homegrow entire project!
`%` in this context means the name of the current buffer; it's quoted so that it won't break if you have any spaces or shell metacharacters in your filename.
Based on the tone of your responses here, the feeling is mutual. Have a lovely day!
"Python is [...] fast" Riiiight. Because there haven't been a shit-ton of benchmarks calling out CPython specifically for being slow. Like that hasn't been the focus of several alternative implementations, improving the speed of the default interpreter. Why this guy shouldn't run Python in production? That's a simple question; he shouldn't be tasked with running anything in production until he learns the basics. 
I wonder where Dropbox, Instagram, and Pinterest get their unlimited system memory from? They've been running Python in production for years! They are contributing to a global memory shortage and it's all Python's fault! \s
Why the hell can't I find a job? I've been working with the same company as a freelancer making very little compared to most developers for the past year, but I haven't even been to an in-person interview in almost a year now. I feel like I'm good at what I do, but even jobs where I'm like "HOLY CRAP! THIS IS A PERFECT MATCH!" I get a form letter response saying "Thanks, but we're going with someone who's experience and skills are a better match." Like wtf? Is it because I didn't finish college? I only went for a year or two and didn't do very well, so I said screw it and went to one of those developer bootcamps instead. I also educated myself via online courses such as Treehouse. I'm located in Portland, OR.
No ethical scientist should touch this data.
why is that?
In context lib i think
What company of his did microsoft kill?
Nah, I generally Alt+Tab, up, enter.
You might want to look at rrdtool. it has python bindings. It's made for storing data like sensor data, and also helps you view it on different time scales, like last hour, last day, last week.
[removed]
Because if ethics suggested that it was OK to analyze data like this, more data like this would be produced, and that's bad. Basically, it's the same reason why courts throw out evidence that was gathered illegally. 
I don't know the details of how Im works, but most common js/py gif libs I have seen use 8 bits as minimal code length (for holding all 256 colors). Whereas we need only 3 in this case. Also saving thousands of frames into image files in disk and read them back into memory would be a heavy task.
I'd love to see the source code, I've been wanting to make something similar for bass practice but I'm pretty new to coding. 
This is a bit out there but you could use jupyter notebook?
I've never seen bareback used in this context lol
For me it is.
Because the library also serves to *store efficiently at rest*, not just compare. Use case: read 1000 huge ints out of a file, then write the sorted list to a new file.
For long term archives, daily CSV files with our 5 second data. For realtime add InfluxDB or other DB when needed.
why not use pydev?based on Eclipse.not very light,but much better than pycharm.
Seconding Sublime. Fast, lightweight and with the proper plugins you can make it an IDE. Free option would be Atom.
actually that wasn't the main reason. when we started there wasn't a good containerization story on windows that we could use. linux/docker was the obvious choice. we dont have much religion regarding which OS to use. if someday windows has a better story that's better for customers we may switch back. the good thing is that with python/r and their stack being mostly OS neutral, the underlying scaffolding shouldn't much too much.
Wait python alone can handle image processing like this? I thought you had to use a library that was coded in some other language...
This will likely be an unpopular opinion, but I really dislike this. Auto-generated API docs lead to people not writing actual documentation (prose), something I've noticed especially in golang (and to some degree in the JS world), where there's barely any prose documentation. So everything is "documented" in a sense that it tells you what the function names etc are, but nothing tells you *why* you should use a certain function or how the whole thing fits together. I'm a huge fan of readthedocs, because it made writing documentation a lot easier and taking away some of the excuses we make up for ourselves not to write docs, pydoc.io is a step backwards in that now you have an excuse that you've already "documented" your library because it's on pydoc.io. Hopefully I'll be proven wrong and people will only use this on top of RTD...
But then it's non-interactive.
In point for you say "other app in Windows". Are you saying you are making a client application for your piece of hardware that needs to work in Windows. Would it be an option for your device to provide a web interface that you could implement in Python?
Right, what was not entirely clear is if your Python programs will be running on your hardware, in which case the issue of installation is not that important, or if you are talking about client software that will run on the user's computer, or if you are talking about both (implementing an API in Python on the hardware and client software for computers). Why will an Internet connection be necessary? The hardware is not next to the user but it's an online service somehow?
The total participants is probably 50-75 across 9 departments. Honestly a brute force try like /u/duckythescientist suggested could probably get the job done. If I'm doing the math right there's only like 10k permutations possible and a ton of those will stop early, and you're exactly right it only needs to run once. I'm thinking psudo code: loop through each department list match one person from department to a person in another department that and who is not giving to them if not possible selections exist: break and retry Interesting package, I'll look into it. 
I see. The software is strictly for the PC. It's not for use on the hardware. It simply generates files the hardware needs. Some of these files contain data that require an Internet connection to retrieve. I updated my OP to include this info.
can you explain what the author did wrong?
how does that IDE help with numpy and pandas?
Very cool. I'm interested in how well this works out in terms of quality and how many projects actually use docstrings on PyPi. Edit: At a glance(finally got on). These docs remind me of the times when I would have to read auto-generated documentation from poorly documented Java APIs but worse because there are no types. I think for some of these libraries I'd rather just read the source code than a function statement with no docstring. By the way, Chrome is blocking the fonts readthedocs is trying to load from media.readthedocs.com because the blog.readthedocs.com is over HTTPS but the fonts are being requested over HTTP. The link to https://pydoc.io doesn't resolve properly. Going to http://pydoc.io redirects to https://pydoc.io and properly renders the page however.
There is the http://www.py2exe.org/ to distribute programs for Windows. You would need to ensure you comply with the licenses of any libraries you use by for instance showing credits, showing license information and supplying source code as required. Also if you use tkinter you may need to fiddle a bit to include the required binary libraries in your executable or installer.
yeah, that's a great way to start exploring what's going on with Pandas. You get tab completion and a bunch of other functionality, too.
&gt; last, **if you can live without graphics your system** resource utilization will be greatly reduced by not starting desktop environment I can only imagine what someone trying to get into Python and setup an environment is thinking when the response to "got a good IDE?" is "can i interest you in a graphics free lifestyle?" Pitch 'em on elinks, too! 
not sure why you're down voted here. PyCharm is a memory beast, but most other comments aren't offering IDEs, just text editors. Maybe OP doesn't need it, but you're answering the question.
Please like and subscribe, and leave a pull request!
Combining the two would be an interesting task!
So long as you also remember to remove each selection from the department list as you go, that should work well.
Good to know about py2exe. I think that answers question 4. So, in general, are these libraries hosted on Github free to use even if you are "profiting" so long as they are credited? 
That depends on the specific open source license they are under. I would suggest checking which license the libraries you plan to use are under, and look them up on https://tldrlegal.com for starters. You should also look up what policies your employer has for using third party software under public licenses. Someone may have done some of the decisions for you already. You can not assume you can use everything that's on GitHub. It may only be free for academic use for instance, or just have unclear licensing 
Exactly. The brute force attempt is probably 10 lines of code or so. I might write it tomorrow just to see what happens. For the past few years, it's been someone's job to arrange this, I figured this year I could create an automatic way of doing it. The way it works at our company, everyone emails this person 3 things you like and 3 things you don't like, and your santa is supposed to use that as a guide. I can spin up a Slackbot that everyone can message and then, in the background one night it can do the sorting, and the next day ping everyone in the office with their person. 
When you post the abstract from a published paper it's bad form to not post the proper attibutions
Maze algorithms generally all look pretty neat. Here's one I made: http://ehsankia.com/pjs/1 And here's a bunch of much cooler ones: http://www.jamisbuck.org/mazes/
I like Maching Learning, and prefer Pelican with ipynb plugin.
Sweet. I've been looking for a package in Python to do factor analysis for some of the surveys I'm analyzing at work. 
thank you
In your example, `itertools.accumulate` is more expressive
Although I agree with general sentiment (OP would be better off using python as-is), your response deserves a reaction. No, he solves a problem you and other bigots refuse to acknowledge: some people prefer braces. You taking a dump on / marginalizing tastes of others helps nothing.
maybe it's for their own posterity. Now long after they've left us, someone's NLP / scraper will discover their comment.
I highly recommend http://www.rmotr.com They sometimes post in /r/learnpython see here: https://www.reddit.com/r/learnpython/comments/55um9l/were_doing_our_python_programming_course_again/ It's virtual but it's a live class. You have classes every week. Coding sessions three times a week. At the end you work on a group project. They incorporate git as well.
&gt; normal_int = 10**1000000 # huge, but compressable (lots of 0's) Lots of zeros? Are you storing integers in decimal format? Why?
Nicely done, just a tip: With Blender you could've imported an image strip in the format name_1.png, name_2.png ... very easily.
I might look up those things you mentioned while the brute force is running. I might run it tomorrow with placeholders just so I'd have an idea how much time it might take once we get the exact number of names. 
Don't drink and drive your light cycle.
What is it ? Path finding ? Maze generator ? Looks neat
You can try [GraphDash](https://amadeusitgroup.github.io/GraphDash) if you are looking for something more picture-oriented.
Thanks guys for your input, I updated the article. Obviously my argument has proven to be false on newer python versions. Apologies for ill-informed article.
well, its only executable dependencies, not the full build and its a bit too late, setup.py is already an executable build/install system
Coupon Save 100% . Learn Python In Under 10 Hours of Video Time. We will cover the important stuff with RECORDED Videos and we will work as a team with the Live Streaming Work Sessions!
&gt; and its a bit too late, setup.py is already an executable build/install system Which is exactly why python wheels were introduced.
I used that second one to make own maze generator for an LED at display. https://goo.gl/photos/zGJxHmrNxNfVkaV19 
Bigots? Let's get real. Python is a language that uses white space to delimit blocks. It takes an hour to get used to. OP is solving a 'problem' that does not exist by creating an actual problem. 
Sorry if I misunderstood the problem, but can't you just do the following: 1) Shuffle every department list 2) Pull the names from the shuffled lists in a round-robin fashion into a list and use that list as pairings? For example, if you 3 shuffled department lists A, B, C, you can just do this: A1 -&gt; B1 -&gt; C1 -&gt; A2 -&gt; B2 -&gt; C2 -&gt; ... -&gt; An -&gt; Bn -&gt; Cn -&gt; A1
Is there also any xkcd about making a passive-aggresive comments without reading the whole thing first? The executable step there is just to generate a JSON file which is then distributed.
Very quick intro but thats it. I can also recommend to use css selectors, that will be _much_ faster (as long as you know what you want to select.) Here is an example: https://www.crummy.com/software/BeautifulSoup/bs4/doc/ "If you want to search for tags that match two or more CSS classes, you should use a CSS selector:" css_soup.select("p.strikeout.body") I have done some quick n dirty performance test for my rpi scraper where it became obvious that "findall" etc will make you iterate a lot and that consumes CPU. lxml xpath and bs4 css selector is much faster.
When I thought about it yesterday I thought I had an issue if the Dept are different sizes. I'm going to code something to see if that's actually an issue. The issue I have with your solution is it's too predictable for the company. Everyone in tech gives to someone in marketing, everyone in marketing to customer service. You solved it, but think it misses the spirit of the event. 
&gt; Wheels are the new standard of python distribution and are intended to replace eggs. Can I haz potato?
Wouldn't it be better to use requests instead of urllib?
If it doesn't support installation of dependencies from local files then it sucks just like the current solutions. Why everyone always assumes every package a piece of software depends on is on pypi (or equivalent internet source)? Or did I miss the memo and it is only allowed to do community and open source work in python?
This is in fact the most pragmatic approach. Build a simple, naive brute force (which should not take longer than a few minutes to write) and perform other research while the brute force is running. Politically, you should make sure your program is deterministic and uses a seed you have no control over (closing value of stock exchange on day X?) in case your "santa-ing" is challenged by allegations that one person gets more gifts. Of course, if this is a problem in your workplace, it may be time to talk to some recruiters :-) But this is a general guideline for other similar tasks where this may be important.
Thanks NoahTheDuke for the pointers, much appreciated! Annnnnnnnnd thanks to edimaudo for pointing out my lack of observation, haha. I don't visit reddit often, and am very accustomed to assuming all content in the sidebar of webpages is purely shitty ads, and didn't bother to pay the side bar any attention. I think I have all I need, thanks again!
In regards to functionality, how does this compare to Amazon's Alexa?
yedpodtrzitko's response was the passive-aggressive one!! 0x256's was just aggressive (and interesting and on-point IMHO).
No no no, sprugel is the new flit replacement for jabbagabba, and wawawa replaced doorhandle and canned, because deadlift and snargle didn't work with rumpskins and whatevertthefuckingrandomnamesomedrunkcameupwith.
This is something I've done myself, and it worked out well for me. Some notes though: 1) Don't raise SystemExit. If you absolutely *must* exit the program, call sys.exit(). Otherwise, give the API's user a chance to handle the exception in a sane way. It's trivial to define a new exception, and if it's not handled, it will just bubble up and exit the program anyway, with a stack trace attached. class NotLoggedInException(Exception): pass 2) You probably shouldn't hang on to a password longer than you have to. Also, getting a password from the user doesn't mean it's accepted by the system. You should get a nonce or session id, or something like that. If you have one, then you can consider the user to be authenticated. 3) Return the value from func on line 8.
Thank you for the answer, very helpful. Regarding point 2: Yeah, I didn't mention this is in the OP, but I'm already checking if the user successfully authenthicated or not. 83 if request.status_code != requests.codes.ok: 84 raise AuthError("Authenthication failed! " 85 "Error code: {}".format(request.status_code)) 
Another question -- if I want to raise a custom exception in the decorator, should I create it in the decorators.py or create exceptions.py and then import the exceptions into decorators.py?
Yes and no. Maven is supposed to be declarative, but in the end the exact behavior depends heavily on the exact maven and plug-in versions you declare and you cannot predict the outcome of a build without actually executing maven. This is mostly because all the interesting stuff (e.g. building jars) is implemented by plug-ins, and their behavior is not formally defined. The `pom.xml` is a static file, yes, but you can barely do anything with it. IDEs have to re-implement most of the maven plugin functionality to work with pom files, or have to actually call maven in the background. This introduces a lot of additional complexity and possible incompatibilities. Eclipse m2e for example breaks easily for all but the most simple setups. Code that can be compiled and run in eclipse does not build with maven, or the other way around. It's ugly, really. Maven is still a better approach than gradle, I think. But not by much. 
I'd go for the exceptions.py route. The decorator is an implementation detail, it's not important to the user of the API.
Even though the guy "doesn't see much need for new Python code", my opinion is that he should just start a new project in Python 3 (be it a personal project or not). Because the only real way to get used to a technology is to actively use it.
[PyWavefront](https://github.com/greenmoss/PyWavefront) + Pyglet to actually view it.
Really? Can you also combine it with setuptools, so that pip automatically installs the dependencies which are included as other (setuptools) packages in the package? I spent a really long time looking for a solution and didn't find anything that worked. At most I could install the dependencies manually from local files before the installation of the target package.
Have you checked out [Rodeo](https://www.yhat.com/products/rodeo)? Its pretty lightweight and runs on windows/osx/linux. Its also gotten a lot stabler recently
There's now a centralised issue to discuss whether the format should be executable: https://github.com/pypa/pipfile/issues/10
I don't think I used the word 'constructive.' But ... when you post something for public inspection, critique is one of the things you can expect. If someone believes the fundamental premise is flawed, they're not likely to submit a pull request to touch up some minor issues. 
I'm curious which other countries allow this.
Where do you see this in the code? I haven't looked through the whole codebase, but from what I did look through, I didn't see anywhere where external connections being made beyond fetching data for triggers
It wasn't clear to me initially, but this is an actual project by the developers of pip. This will eventually be baked into pip. What's scary to me is how little discussion I can find about this. Python language changes are accompanied by proposal documents, filled with rationales, alternatives, etc. People then discuss the proposal and edits are made, until a final version is agreed upon by the core devs, or it's rejected/withdrawn. Here we have a tiny bit of discussion scattered across some gists and GitHub issues, and then *someone started solidifying it into code*.
There is a link to a book on the right called Automate the boring stuff with Python. There is a section in there about reading and writing to text files which will be useful. the basic syntax is file = open('path', 'r') #return a File object to read from fileContent = file.read() #read from the file and store its contents in a variable file.close() #close the file
Are you satirising the fact that there are new tools? If so, I'm happy to have a conversation about the balance between stability and replacing things we don't like. Or do you just not like the names people have come up with? Remember: "There are only two hard problems in Computer Science: cache invalidation and naming things."
Check the `stt` directory. The speech-to-text functions can be run through Google, Bing, MS's Wit AI, Houndify, etc. There is not a built-in speech analyzer with this package. 
You are probably right. Maven works well enough for the simple case and if you use pom-files just to declare some dependencies, then they are pretty declarative. Still, as soon as you use some third-party plug-ins or tap into the details of the core plug-ins, you find a lot of bugs and odd behavior and the build process quickly grows into a complicated mess. &lt;rant&gt; * A test-scoped dependency on a test-jar package does not include the test-scoped dependencies of that jar. Whyyyy? * generate-sources phase is executed twice under certain circumstances. Huh? * It is not possible to exclude certain dependencies based on a build profile and then also exclude the source files that need these dependencies. You will get build errors, even in source files you explicitly excluded from compilation. Great... &lt;/rant&gt; In the end, I think maven is to complicated and powerful to really count as a declarative build description. If you *can* do horrible things with it (antrun build steps, custom plugins), people will, and you loose most of the nice benefits of a declarative approach. It's like a `setup.py`. It looks clean and declarative in most projects, but it is not. You can, and people will, abuse it. 
Am I missing something or is there just nothing in the repo aside from promises? 
"TCO is incompatible with nice stack traces" - nope, you can heap-allocate [TCO-ed] activation records for debugging purposes.
This generates lock files, but the file that is used to generate the lock file is considered too powerful, being able to execute arbitrary code. The consensus on Reddit is that this is a very bad idea for a variety of reasons.
What's the total size of the dataset? I believe you'll eventually convert the raw data into an numpy array? In that case, as long as the numpy data fits in memory, the raw format does not matter. You could also store the raw data in sqlite, which seems to be a good fit for this use case. 
Gah, thanks. Not sure how I missed that... At the very least, it's good that the STT modules are decoupled like that. It looks like there does exist at least one offline speech recognition engine ([CMU Sphinx](http://cmusphinx.sourceforge.net/wiki/), [python bindings](https://pypi.python.org/pypi/pocketsphinx)), though I can see how training/hosting the software make it ripe for SAASes
Thats Obvious :D. So that someone will not have to write this code again :P
Why not both? Between the ten thousand tools in various states of replacement and all the ridiculous fantasy names it becomes a huge stinking mess. Maybe it is a good thing though, it keeps out of lot of low the effort packages.
So these scripts need to run on your windows machine? Or is your Windows machine remotely executing these scripts that are actually running on another machine? Does it matter what machine these scripts are run from (what do they do)? Do you have other machines (linux server?) that you can run these from? Are you saying you want your laptop to turn on every night at midnight and run these?
A quick and dirty solution could be to get a Raspberry Pi and set up a cron job. You could start with a git pull to make sure you always have the latest version of the script. Edit: Considering the [additional information](https://www.reddit.com/r/Python/comments/5e4uj7/easy_and_straightforward_way_to_deploy_python/da9ocd3/), I would consider something more reliable than a Raspberry Pi.
I don't know how this particular one works, but with Amazon Echo, it detects the keyword (Alexa) locally, and only then starts streaming to the cloud.
Here's a direct link to your example instead of the full (giant!) documentation page: https://www.crummy.com/software/BeautifulSoup/bs4/doc/#searching-by-css-class
http://sirius.clarity-lab.org http://lucida.ai
It's a package build tool. setup.py doesn't go away. You can still use it. Woe betide anybody who tries to improve the tooling around Python packaging, eh? /s
I find py2exe etc a massive pain: I'd recommend writing this using JavaScript (JS single page app) and hosting it on your company website. Everyone has a browser and those that don't have access to The Internet can be directed to save the page as an archive file
Thanks for posting this. I'm always confused about why other languages get so excited about closures, makes me think I should be trying to use them more in Python. 
/r/learnpython did you not read the sidebar?
/r/learnpython
Yeah, this is just more or less like Gemfile/Gemfile.lock in Ruby (although Pipfile.lock has a different format).
what does this do, that `pip-compile` (of https://github.com/nvie/pip-tools) cannot? `pip-compile` collects and "locks" requirements of requirements incl their versions. does pipfile do that too? in the examples it does not look like it.
Exactly, though the use of a Turing complete language (even if it's just really used to generate the lock file) worries me a tad.
If you're getting an `IndexError`, it's because you're trying to access something beyond (or below, but let's ignore that for now) the maximum element of your list, right? And you have two lists, `numlist` and `intlist`, right? And you know what each list have? (tip: one of this lists is being build in the wrong way)
Oh ok you're right I guess I missed it. I'm still starting out with Python so I'm still trying to understand the basics like which modules to use.
Why is it that xpath is faster? i'm guessing it has to do with how lxml structures and searches the data, is there an explanation anywhere?
Tox is for a lot more but it also neatly describes dependencies. 
IIRC, if you are using PyPy, pg8000 is faster than psycopg2 since it is pure Python without C extensions, but not sure if it's faster than psycopg2-cffi
Tox might have a a neat way to describe dependencies which is really useful for doing testing, but that functionality isn't tox's primary focus, and tox can't be used to do the same thing as pipfile is intended for. The purpose of pipfile is to generate a lock file which pip can subsequently read. Tox's generative dependencies are for generating multiple virtual environments so that testing can be done against different versions of different dependencies: it's more akin to having a whole bunch of automatically generated requirements.txt files. While superficially similar, they serve different needs.
Give me cargo for Python and I'm set. Executable definition is probably a bad idea, but the .lock file is pure gold.
I've started using [TOML](https://github.com/toml-lang/toml) over YAML/JSON/XML/etc anywhere I need a hand-editable, machine-parseable config file. Much more readable than JSON; much less prone to parsing quirks than YAML. It's basically an INI file on steroids, so it feels very Pythonic.
Great feedback. I like this solution and appreciate the time you took to code this out. It's extremely helpful.
I've had varying success with css selectors. It also depends on which parser you use for the html (html5lib, lxml, etc). Sometimes the parsed html never makes it past the head tag, which baffled me for a while.
I wrote this to rip out the quirks from YAML: http://github.com/crdoconnor/strictyaml minus quirks, I think YAML is more readable than TOML. Complex TOML gets pretty messy.
namedtuples, classes, optional typing. The author needs to learn more Python and write Pythonically.
so meta
what does that mean, can you list all "the different methods to do recursion"
vbscript and HTA are windows only proprietary technology and run in one web browser: IE. You should use web standards like JavaScript to run in web browsers. Microsoft is killing IE and encouraging everyone to move to modern web standards in Edge
I've been using [pip-tools](https://github.com/nvie/pip-tools) for a while now and am very satisfied with it.
@Beemo56 ^^^ THAT
If u wanna tag him you probably want to do /u/Beemo56 :P
Windows applications are usually distributed as an installer, not a standalone app executable. Make an installer that includes a private embedded copy of Python and required dependencies. You do not have to wrap it into a single executable with py2exe. The shortcut will start the application using the included pythonw.exe to avoid opening a console window. The user need not know or care if the application is written in Python (unless they are in the habit of digging into the application directory). 
Yea... This is why I've abandoned the HTA idea. 
Well what are you having trouble with exactly? The code you linked to does most of the work for you already for line in infile: number = int(line) nbrcnt += 1 print(format(nbrcnt, '2d'), ') ', number) So `number` is going to be each number in the file - do you know how to test if a number if even or odd? You can use `%` (the modulo operator) &gt;&gt;&gt; 5 % 2 == 0 False &gt;&gt;&gt; 4 % 2 == 0 True `x % y` gives you the remainder left when `x` is divided by `y` - so if `2` divides in evenly - the remainder is `0` meaning the number is even. As for the counts and the sums - you could use separate variables if number_is_even: even_count += 1 even_total += number else: ... Or you could store the numbers in 2 separate lists and use `sum()`
My latest idea was to build a Python gui that contained a browser window to display a map. There are so many ways to do this in Python. Especially when you add modules. So much of the community has already solved many of these challenges in Python. Is opinion that JS and NOT Python would be the most sensible approach?
Thanks this is all really helpful !!!
&gt; The Python version is better, right? Let's consider two definitions of "good code" so we can be clear what we mean by better. &gt; &gt; * Code that is short, concise, and can be written quickly I don't think that's a proper definition of good code. To quote PEP20, "Readability counts." High readability does not necessarily imply short nor concise. Just because you *can* do something in Python, doesn't mean that you should or it's a good idea.
Authentication and authorization should be two different services. You might want to check permissions for a user that is not logged in, for example (think about background tasks that work on behalf of a user). 
This sounds like what I'm after! Good to know it can be done.
JS has a great load of modules on npm. You might want to get started with https://cli.angular.io/ it will hold your hand through creating a great modern single page app that you can deploy to your users as easy as sending them a URL.
Who handles permission between services in this type of auth flow?Does the authorization service manage all permissions between services? Does each service handle it individually? [EDIT]: Why bother splitting them into different services?
I love the idea... Kind of what Bumblebee does, only with one character only 
Had a similar dilemma recently, wound up with an authentication service and a separate permissions service. It's a bit of a bear to deal with at times, but worth it in the long run. Most of our other services use the permissions service but don't care about the authentication service, so its logical for them to be separate services.
Why bother abstracting them into different services? Can't you just have an `/v1/auth` endpoint for creating the authorization token and then creating a `/v1/permissions` endpoint to retrieve the scope of access?
I have a Python tool which scrapes a website, and conceptually I need the same type of tool but for another website. The HTML looks exposed, so I'd like the job to login and download a series of files. PM me.
I suggest you go over to the Python ideas mailing list with your thoughts, if they haven't been discussed all ready.
``pip freeze`` shows all the installed packages.
I see your edit and it makes sense. Thanks!
One of the most useless articles I've read in years.
Honestly, I'd recommend either going through the trending page on Github for a specific language and see how if there's anything you can do for a project that interests you or start making your own projects
Great article, but two points I want to bring up. You said you do either: import datetime or from datetime import datetime #I would actually do: from datetime import datetime as dt #Saves you time when you continue to use the module Anyway, these two are not the same actually. The from datetime import datetime line is actually making a reference to the class, while import datetime is a reference to the module. This has been known to cause some AttributeErrors with method descriptors and module objects. Second, I really like the datetime objects, but it's caused too many issues on the simplest of things. Here's an example of a simple problem I had with the datetime module. I'm hoping they make it better in the future, but I'm not sure they'll be able to: def thirdProblem(): from datetime import datetime, timedelta, time, date timeInput = input("What time are you leaving your house to run?") newTime = timeInput.split(":") newTime = [int(i) for i in newTime] timeLeftHouse = datetime.combine(datetime.date.today(), datetime.fromtimestap(time.time(hour = newTime[0], minute = newTime[1]))) **EDIT:** Lots of formatting 
IIRC, the Google Photos Desktop Uploader is a windows application written in Python. You can use it for reference. 
I'm going through the ThinkPython book right now, along with Project Euler. Highly recommend both. Afterwards, I might do some OpenCV stuff with it
There is also a similar project called Jarvis I believe
I've been researching around and there are several articles that conflict with this point of view... they recommend that micro-services should manage their own permissions internally... curious what your thoughts are... https://blog.andyet.com/2015/05/12/micro-services-user-info-and-auth/ https://www.quora.com/What-are-some-effective-patterns-for-access-control-in-a-service-oriented-microservice-architecture
It just seems a little bit redundant as the built in module has a dictionary interface, and there are in turn many serializers for dictionaries. Are your mappers more efficient for large files or something than the csv module DictReader? 
What I want to achieve is get a list of Python packages. I know of pip list/freeze and a programmatical way which does that. I want to know if there is another way to get something similar to pip freeze.
This sounds REALLY cool. Looking forward to playing with this one. I learned long ago that no one likes the "PEP8!" guy, but I gotta ask...8 space tabs? 
you can try AWS Lambda: * http://docs.aws.amazon.com/lambda/latest/dg/python-programming-model-handler-types.html
&gt; Personally I think YAML would be a better fit for an extended pipfile. yeah, I think JSON would have the advantage to be in the standard lib though -- if minimum external dependencies is a goal 
Sure, and it is easier that way, especially at first. We needed to make lots of little, discrete, permission checks, so having a highly-optimized permission service that we could quickly scale up was a requirement. You might not have the same requirements, so it might not make as much sense in your case (though, I agree with /u/defnull's points above (and splitting auth and permissions into two services is a great first step in switching to a full microservice architecture)).
I'm not a web Dev, but I'd think a JavaScript onClick event that sends Ajax to something serverside to catch it and update a database would be the way to go. You could use flask for the rest api. But setting up python for this seems like a pain. Php might be easier.
Django recommends using psycopg2. It's a solid choice.
You should *really* provide criteria for what you want if you're going to be excluding all of the most common methods because you want/need something else. Why is `pip freeze` or `&gt;&gt;&gt;help("modules")` insufficient? If you want to recreate what `pip` does, review [its source code](https://github.com/pypa/pip/tree/master/pip) and recreate that functionality yourself with tools that fit your requirements.
Good point. Will look at the source code. There are a few systems that do not have pip installed in our lab and hence this predicament.
Is this yours? Your commit messages are absolutely useless.
Looping is one of the method but when the number is huge then your program will freeze up if you select looping
Shocker: most people write useless commit messages.
In fact, I see 2 tabs not 8 spaces indentation in the source code.
What I really want is a Vin Scully bot...could this do that?
You would hate me
Add beancount and enjoy! http://furius.ca/beancount/
That is because I don't get package versions there.
Great to hear it is maintained again. One problem I always had with livestreamer was skipping into a Twitch VOD. Twitch itself accepts time offsets in the URL (?t=2h30m) and similar, but livestreamer would just ignore that and run it from the start. Typically I wan't to skip at least 15 minutes in for the stream to start. Does streamlink fix this particular issue?
Finishing up a little command line app for checking and notifying when esport games go up called [gosutick](https://github.com/Granitosaurus/gosuticker) and working on a little webservice (with flask) that would be pretty much a wrapper around this cli app for users who aren't versed in cli and just want to know when the games are on. I'm pretty happy with cli app already but the web service is a bit more work than I've expected. Flask has some tricky areas and I'm struggling with pushbullet integration since I've never touched oauth before. 
Thank you for responding! I will try the HLS passthrough next time.
VTK isn't going to do it without work setting it up. I'd punt you my GUI, but again setup time. Just use Paraview; it's made by the people that make VTK.
&gt; You would hate me (actual commit message)
Speaking from an investment banking prespective, you would ideally want your predictions/models to be fast and in practice floats just work fine for most of the "predictive" calculations. For the article, given that this was meant to replace some Excel functionality, floats work just fine because that's what Excel uses by default.
Does anyone have a proper example of this?
I am looking for freelance gigs related to machine learning, data analysis, web scraping, programming, and web development. I have used R and Python for data analysis and machine learning projects I also have experience working on complex projects in C++ I have also worked on personal projects using Flask and Django to create web applications PM for my portfolio
When asking stuff like this, ALWAYS post the code directly and describe the problem. This post is just a waste of time. 
Very cool! I'll admit that after not finding exactly what I wanted from an initial google search, I decided to just try my own hand at writing a simple tool for fun. If I'd searched a little harder, I may have found your library. I think it's cool that our api is almost identical where the context manager is concerned. Yours definitely seems a lot more full-featured and well-tested. I just wrote mine to scratch an itch. Thanks for sharing!
[relevant xkcd](https://xkcd.com/1296/)
Working on a project involving triangulation of surfaces in 3D space. There exist packages and methods already but in trying to rewrite them to better understand the algorithms. My goal is to compare multiple interpolation/triangulation methods and calculate the volume of the shape comparing to the analytical volume. I'll use both mesh grid (uniformly distributed points) and randomly drawn points calculating the volume as n-inf. Also evaluate computational cost of the various algorithms. Then build a GUI that builds in sliders, and animated some of the parameters discussed, as well as drawing or constructing a custom surface mathematically.
The first link has only a very simple permission system (no groups, no roles) and the second is not very specific about the requirements at all. In the end, it depends on the use-case. I'd use a PDP if: * Your permission model is non-trivial (groups, roles, even nested groups/roles). If it's more than just a UserID field in a database, then implementing it again in each service and keeping everything in sync is a nightmare. * Your want to revoke permissions at some point, and you have a lot of services. Again, keeping the information in sync in all the services is a really hard problem. * You want to define permissions that affect more than a single service. * You need to integrate several administrative domains into a single userbase. This requires admin interfaces for lots of administrative tasks and the PDP quickly grows into a full featured IdP service on its own. You don't want to tell your customers that they'd have to use 12 different APIs to change a single username or revoke some idiots 'canOperateCoffeeMaker' permission. * You need reliable access and audit logs because your resources are protected by law. But then, you'd probably just buy a PDP and don't code it yourself. There are still situations where it makes sense to manage *additional* permissions in the service itself, even if you have a PDP: * If permissions are part of the resource. For example, the 'owner' of a resource is often stored together with the resource. It does not make sense to ask the PDP if a user can edit a resource, if the service already knows that the user is the owner. Or if a resource is marked as 'public', so no user context is required at all. Edit: Keep your permission model as simple as possible, as long as you can. If you don't need a PDP, be grateful :) 
Flawed data == flawed analysis.
learn python 3 they said.. it's the future they said.. 
For a minute I read "flash drive" as "floppy disk"... I was like... now here is a computer OG.
If you want your permissions to be "if you are logged in you have permission to do anything" then it makes sense to combine them. Even when implementing something like "group A has permission B; check if user C is part of group B" you might get by with just putting the authorization inside same service as authentication. But think about this situation: "if you have this many reputation points you are allowed to use this service"(think stackoverflow, or various forums). If you combine authorization and authentication, you will need to add all these cases to the AA service, which will mean a lot of business logic which has nothing to do with AA.
license?
release DL link: https://www.python.org/downloads/release/python-360b4/ 
Finishing migrating an old legacy code-base (Django 1.6, everything run off 'runserver') to AWS with split out database &amp; compute instances. Currently trying to make the AWS instance talk to our existing CRM server's database remotely. Working across 7 databases (two MS SQL, two My SQL, 1 access, one SQLite and one Postgres (mine, for 'New World'.), 4 local machines running variants of the software. And oh yeah, when I arrived, we didn't have any proper git infrastructure or automated deployment, so I've mostly been monkey-patching the live server. /Tuesday. 
Can someone package this with Docker?
Will do. Thanks again.
Awesome. I'm going to check that out.
To be honest, I started to try it in Decimal and couldn't easily make it work so I decided to stick with floats. As mentioned in the above comment, I figured floats were fine for this level of analysis but do acknowledge there are rounding errors encountered in the float solution.
This! I code in my own constraints all the time. I use Python to parse Excel spreadsheets made by people that don't know a string from a datetime, and then I insert that into a database. Everything breaks otherwise. 
 numbers = [] with open(path) as fd: for line in fd: if line.strip() != "": numbers.append(int(line.strip())) 
There are a number of packages out there where people have dropped the `setup.py` in favor of a `requirements.txt`. Actually one of the bigger projects for replacing pypi.python.org (soon to be pypi.org) is called `warehouse` and you would be hard pressed to find the setup.py in that repo: https://github.com/pypa/warehouse That said, I agree with your assessment. `install_requires` is the right place to do this. The problem that most people have is that if they do not know python well, they do not want to learn the ins and outs of building a setup.py file. There are a few people I work with that are staunchly against using `setup.py` because `requirements.txt` is far easier to immediately grok. 
How do I attach a file I've built in memory? Say a zipfile of documents that a user had requested? 
SimulateMe! maltress6911
Release changelog here: https://docs.python.org/3.6/whatsnew/changelog.html#python-3-6-0-beta-4
If you can't post your code like /u/kakyo and /u/p10_user suggested, run pylint and pyflakes on your code and clear any warnings you get. That may point a problem that you can fix.
Ok, a few tips: 1. Post your code. If it's a homework, you *should* have done something already. 2. If you have an specific question, search the web with that specific question. There are a lot of resources around, one could be exactly the question you're asking. 3. /r/learnpython is usually the subreddit for this kind of content (as you can see in the sidebar).
If you're saying you want to know the list of installed packages in the current environment, within a Python script, you can do the following: import pip packages = pip.get_installed_distributions(local_only=True) for package in packages: print('{} : {} : {} : {}'.format( package.project_name, package.key, package.version, package.egg_name ) Edit: without pip, help('modules') will be one of the few ways to get what you need.
It looks like the answer is "no". There are lots of third-party libraries that do it, but no standard lib stuff.
What about using heapq? Ultimately there aren't many good choices. A balancing tree based on ndes will need to be written in C to perform adequately, unless you use a list as your primitive storage structure (like heapq does). Its definitely one of the more frustrating things about python. There aren't really any datastructures beyond lists or dicts.
Not in the standard library, but http://www.grantjenks.com/docs/sortedcontainers/ may be up to what you want.
Although it does not offer any performance advantage, as it uses the standard csv module only, a unique feature is that csv files can be mapped to groups with different fields(or properties). See this example in the repo - https://github.com/samarjeet27/CSV-Mapper/blob/master/examples/code-map/main.py
I think it is premature to be scared. There is no promise that something is going into pip, and something like that would likely go the PEP route. It's an experiment. Even though I disagree with the current thinking, I want them free to try things. They've earned the right.
Thanks /u/daneah! I know of these ways. What I want to know is if there is another way to get this list.
&gt; * PEP 487 - Simpler customization of class creation I *really* dislike how this ended up. You now have metaclass definition, baseclasses, and all of the custom class creation keyword arguments inside of the same parenthesis.. class Player(BaseEntity, IInventory, prototype='m_iEnt2', metaclass=_PlayerMeta): Although it might be that there's absolutely no need to use this new method if a metaclass is being used. Regardless, I find it awful that they can't come up with a new syntax...
web2py, django, turbogears, pyramid, cubic web
I already downloaded it, and now I just can't live without format strings.
I didn't write that program. That is not my Github repository. I just found a link to this code from a Linkedin group I'm a part of. It got alot of upvotes so I thought it'd be a good idea to share it here too.
Post some code if you need help.
/r/learnpython
I'm really excited about the new File System Path objects. Going to be so useful.
I'm writing an application to migrate documents out of SharePoint and into a different document storage system supplied by our POS vendor. Yea!
I was reading through some of the issues in the repository. The issue regarding whether or not the format should be executable definitely caught my eye. If they do go down that path aren't they essentially re-implementing `setup.py`? I don't understand what they are trying to accomplish with this. Frankly, it seems unnecessary.
I know this will sound like heresy, but they've been developing Python for 27 years now. It's really great! It's so great that I wonder if they really need to keep adding new features? I mean, can they ever just be finished with developing it? Maybe just pushing out security updates? Seems like a lot of open source mindshare going to a product that's already fine.
Yes, they need to keep adding new features so they can keep the language in sync with other languages in terms of features. There are lots of languages that still get updated and they've been around for longer.
Just wanted to second this. The sortedcontainers library is insanely great. Pure Python yet faster than all those fancy C extension module implementations. 
Just finished up a Flask app (with some JavaScript) that generates reports on shooting victim's known associates for my local police department that they use for officer safety and awareness.
JSON is out as it doesn't support comments. It's not a configuration language and it was never intended to be one, so let's not force it into this purpose. (Personally I think it was a stupid decision to not allow comments but oh well.)
There is an unconventional way to use format strings in Python 2.6..3.5: use Cython. Cython supports this syntax and generates C/C++ extension compatible with many Pythons.
This should be really good for people looking to get their feet wet. The module docs for asyncio are intimidatingly large. I definitely felt like I was stumbling through my first attempt at using it when it showed up with Python 3.4
&gt;Yes, they need to keep adding new features so they can keep the language in sync with other languages in terms of features. There are lots of languages that still get updated and they've been around for longer. Maybe I'm dumb but what's left to add? We want to keep things so there's "one right way to do it", right? If anything I don't think Python needs new language features but rather more utilities or libraries. Distributing Python projects is still a major pain point. The GIL is a major pain point. What is some new generic custom classy thingy and new string formatting really solving?
I've used bisect with collections.deque to try to get closer (O(1) for append/pop from either end, but rotating to get there is [not necessarily efficient](http://bugs.python.org/issue16398), and the real efficiency for that depends on the platform and memcpy implementation). The unfortunate issue with going this route for the sake of efficiency is that indexed access gets worse as you get closer to the middle (O(1) at the ends but O(n) in the middle), effectively negating the efficient insertion :/
The link is basically an advertisement for a paid online course.
What if someone thinks of a completely new thing that changes the way programs are made. Like inventing something like OPP or something. Would be nice for an old but still used language to support it and not die out of old age. Or just make old stuff better by fixing mistakes or something. 
If it works so good on CPython, I can't imagine how good it is on PyPy :)
&gt;What if someone thinks of a completely new thing that changes the way programs are made. Like inventing something like OPP or something. Would be nice for an old but still used language to support it and not die out of old age. Sure, I agree when that happens we should bring it in. But when's the last time Python put in a new programming paradigm? Asynchronous stuff seemed pretty huge, def kudos to that. Type hints was a nice idea in 3.5. But 3.6 seems like a release for the sake of a release. 
I do not think that analogy is perfect, but I do feel I should have taken the criticism of the dataset more seriously. So I have decided to unpublish the post. Thanks for taking a stand. I obviously needed it.
I'm going to be putting Vim stickers on my keyboard and then probably writing stuff in moonscript. Because I'm a heathen. **Edit:** specifically, an [IRC bot](https://github.com/wiseguiz/Moon-Moon)
It might be worth to prefer `async/await` and target at least Pyhton3.5 rather than `asncyio.coroutine/yield from`. I don't see the point of trying support Python3.4
Python is scripted, which means that it is interpreted at run-time. If you have an error, the program will execute until it gets to that error. JAVA is compiled, which means that if there is a syntax error, the program will not run. This makes JAVA faster than Python. Python supports object-oriented programming, but JAVA can only be programmed in an object-oriented manner. This makes JAVA better for larger applications and Python better for smaller applications and scripting, though there are certainly large programs done in Python and small programs done in JAVA. Python uses indentation instead of braces, which makes good programming style mandatory. JAVA does not, so you have to consciously use good style in JAVA to keep it readable. Finally, JAVA is named after coffee, and Python is named after a British comedy troupe. Those are the high-level differences.
Could you add the full stack trace please?
Adding `encoding=...` should do the job: f1 = open('different_input.txt','r', encoding='utf-8') f2 = open('different_output.txt','w', encoding='utf-8')
This is why you're getting the error: First, you create the matrix: initGameBoard = [[9, 9, 9], [9, 9, 9], [9, 9, 9]] testGameBoard = initGameBoard testGameBoard[0][1] = 1 testGameBoard[0][2] = 1 testGameBoard[1][1] = 0 testGameBoard[2][1] = 0 Now you send the matrix to your method: convertToVisual(testGameBoard) Now in your method, you have this for loop: def convertToVisual (board): for row in board: for col in row: if col == 0: board[row][col] = "O" elif col == 1: board[row][col] = "X" else: board[row][col] = "" printBoard(board) *for row in board:* in this part, you've split up your list of lists, so now 'row' is assigned to [9, 1, 1] next, *for col in row:* col is assigned to "9" Then, you say, board[[9,1,1]][9] == "" This is where your error occurs, because you think you're referencing an index, but actually referencing a list, hence, "list indices must be integers or slices, not tuples" (or, in your case, a list)
``` class myfirstjavaprog { public static void main(String args[]) { System.out.println("Hello World!"); } } ``` VS print "hello world !"
Have you checked if Maxmind can offer you this service/dataset?
This is a good place to start. https://www.maxmind.com/en/ipv6-information-and-faq IPv6 is going to be tricky because of it's portability. I currently have native IPv6 through Comcast at home, but I also maintain a IPv6-to-IPv4 tunnel from Hurricane Electric's TunnelBroker.net (completely free for anyone) for my laptops when I'm on the go, since IPv6 isn't available natively from most open WiFi access points. Since HE.net's IPv6 assigns each user a static /64 block, I can have a static IPv6 address for my laptop and use that address no matter where I am in the world, thus making IPv6 GeoIP pretty inaccurate and useless...at least in my case.
Awesome, been waiting for this. Thanks for this fantastic library
Unfortunately, there is no standard api in JavaScript to do that. Every *generation* of JS core objects uses its own api... plain objects use 'in', arrays and strings use .indexOf(), and the new ES6 objects use .has()... what a mess... My implementation just covers such cases, but may be more of them out there ;-)
Quite a few optimizations have been made; it seems like performance has been the primary focus of this release, which I think is just great. The optimization list is lengthy, and Pep 523 paves the way for JIT optimizations.
I was actually on that site you linked me prior to asking this question. What got me thinking about this was the sending email/text message section of that ebook. 
Ah great, good to know thanks! If I may have your input here on a new topic that would be great too! https://www.reddit.com/r/Python/comments/5ee4mw/pything_27_or_3x/ 
awesome thanks!
I'm working on an inherited project that's way overdue and the completion date is slipping by the day. Working with Raspberry Pis and Python / Processing mainly - yesterday the image I was working on corrupted just for loffs; luckily I'd scp'd the bulk of the code only about 20mins earlier. Today had my boss get (understandably) shouty about the situation as it turned out some previously working code now wasn't (RFID reader binary run as a subprocess of a Python script which parsed STDOUT &amp; then toggled a pin). Had to abandon that code &amp; take another approach which mercifully worked. Do you know that if you `apt-get install arduino` on raspbian you get some old version that's totally incompatible with current SPI / EEPROM libraries? It's not obvious if you usually run simple sketches so can be confusing when you start to get weird errors. The current ARM-compatible version requires a manual install. Also Python really wouldn't be my first language, although I think I'm kind of starting to get the hang of it.
I started diving into asyncio and ended up using gevent. :) I wish gevent (or something similar) were added to the standard library. The whole monkey patching part feels well. . . like a hack. No surprises there.
Writing some classes and functions for dealing with quantum espresso calculations. Primarily learning python after programming for years in LabVIEW (G). Quite the paradigm shift, but I can see the potential for python so I'm sticking with it. 
They wanted to make a recording of Woodrow Wilson speaking from clips taken from wax cylinders. 
I'm so lost too
Python is clearly open source while Java has had recent license disputes.
It is with Vega, or altair.
Thanks for your reply. I guess I thought that *row* was passing an index instead of the actual list. I changed the function as illustrated [here](https://www.reddit.com/r/learnpython/comments/5eezvl/trying_to_illustrate_a_concept_for_my_students/) due to one of the comments below pointing out that this may not be the correct forum for such a question. That got rid of that error, but gave me a new one.
Thanks for your reply and sorry if this is not the appropriate forum for the question. As mentioned elsewhere in this thread, I have re-asked the question (with some changed code based on comments here) [here](https://www.reddit.com/r/learnpython/comments/5eezvl/trying_to_illustrate_a_concept_for_my_students/) in /r/learnpython.
I was requested to re-ask the question elsewhere. See replies to other comments in this thread. As part of the new question, I have added the stack trace. Thanks.
https://automatetheboringstuff.com/ is a popular book on pretty much this topic. Chapter 11 covers web scraping, which this would be an example of.
Solving a bunch of coding puzzles with Python. 
Thank you for the suggestion. Ended up creating a Wiki article based on further digging. https://en.wikipedia.org/wiki/Comparison_of_Python_based_data_storage
I did a recent project like this. Instead of just a sleep, loop pyAutoGui. Locatecenteronscreen() until it returns a position and then proceed. This will prevent the script locking up if it takes longer than usual to load.
As pointed out on HN, the author tries to make the point that Python 3 is not turing complete, which is so insanely not-correct that it brings into question the validity of any of his thoughts. &gt; Currently you cannot run Python 2 inside the Python 3 virtual machine. Since I cannot, that means Python 3 is not Turing Complete That is precisely not at all how turing-completeness works. I think what the author is getting confused about here is the idea that you can use a turing-complete language to write an interpreter for any other turing-complete language, which is of course a completely different concept. You very well could write a Python 3 interpreter in Python 2, and vice versa. &gt; I should also mention that as stupid as that sounds, actual Python project developers have told me this I would *really* like to see a source for this.
Asynchronous IO is different in that the goal is concurrency - multiple routines share a thread. They don't usually process in parallel, but instead step out of the way when waiting on io to allow another routine to execute in the meantime. 
&gt; The fact that you can't run Python 2 and Python 3 at the same time is purely a social and technical decision that the Python project made with no basis in mathematical reality. ❯ python2 Python 2.7.10 (default, Oct 19 2015, 11:51:06) [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.72)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; ❯ python3 Python 3.5.0 (default, Oct 19 2015, 10:55:26) [GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.72)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; huh seems easy enough to me
Oh man, you just made my day! I spend a lot of time on the Python tutor mailing list, and other forums where we get a lot of beginners, and I cannot begin to tell you how many newbies to programming are needlessly confused by the backwards way the Hard Way book teaches things. Now I have a better idea of why he starts by teaching while loops instead of for loops even though for loops are **much** more useful and easy to learn. It's like you wanted to teach somebody how to iron a shirt, so you start by teaching them to take a half brick, wet it down, stick it in a hot oven until it is hot, then pound the shirt with the brick. Then, after they've wasted weeks perfecting their pound-shirt-with-half-brick skills, you say "Guess what? That was a complete waste of your time, you will never in your entire life need to iron a shirt with a hot brick, because we have these things called 'clothes irons'!"
This article seems to be about 80% bullshit to me. Neither "dynamic typing" or "Turing complete" mean what this guy thinks they mean. Like claiming that because the Python 3 interpreter can't run Python 2 code it isn't Turing complete. That's total nonsense. Any modern programming language is Turing complete. Of course, being Turing complete doesn't actually mean that much. Postscript and Brainfuck are both Turing complete, and I don't see programmers writing many programs in either of them. If you wanted to spend the effort on it, you could write a program in Python 3 that could correctly run any Python 2 code. You could do the same for any language. But nobody really wants to bother with writing such an interpreter. If you want to run Python 2 code, it's much simpler to just use the Python 2 interpreter. He's got a point that the `2to3` porting tool can't reliably convert Python 2 programs to run on Python 3. But that's usually because those Python 2 programs are buggy or ambiguous (e.g. they only worked correctly on ASCII or Latin-1 text and their programmers just never noticed their shortcomings). If you give them input that can't be handled in their assumed encoding, they'll either choke on it, or worse, silently garble the data. Python 3 requires you to be up front with your assumptions about things like encodings, and it will usually give you an error message if you get it wrong. Unicode strings and byte strings are not the same and aren't ordinarily used for the same purposes. It makes some sense that they don't have all of the same interfaces. This is what the guy somehow believes means that strings have some weird new typing system. Nope, they work just like any other types. You may need to know if you have a `str` or a `bytes` when doing operations on them. But that's just like how you may already need to know if you have a `list` or a `dict`, since they don't have all of the same interfaces. And of course, sometimes you don't care about the differences because you're only using a small part of their common interface (e.g. iterating). I'll admit that the error messages you get from Python 3 encoding errors are not always clear. But they're better than what you'd get if you were actually trying to write Unicode aware code in Python 2 (where you can get `UnicodeDecodeError` exceptions when trying to `encode()` something and other non sequiturs).
I also agree that a dictionary is probably a better choice here.
&gt;the backwards way the Hard Way book teaches things. Daily reminder that in LPTHW, the fundamentals of boolean logic are exercise **27** - and you're told that rote memorization is more reliable than trying to actually understand it.
Can you uh.. elaborate
&gt;Some people go so far as to ban my book because it does not support Python 3, even though my book is the most effective method for learning to code. Arrogant much? Even if that were true it's totally unprovable. The rest of the article is verging on insane. I used to recommend LPTHW but I'm not sure I should any more.
Thank you for mentioning brainfuck. And for your joyous mockery of the author's misunderstanding of what Turing complete means; let's examine this Brainfuck REPL written in Python 3: https://gist.github.com/aalhour/9a80c6f630df22351ce70a4a45ffea13 While it's not useful in any practical sense; neither is debating the troll authors recockulous rant against change.
There is no case anymore.
I've PM-ed you about a possible opening.
"Startup" I work for uses Python 3 since few years and there is no point for us to use Python 2 since long time ;) Initial Python 3 migration required few pull requests, but that was doable without problems.
Hello, I'm working on the REMI gui library. Look at this library https://github.com/dddomodossola/remi. This is the link of the entire gui library. Here is the link to the editor https://github.com/dddomodossola/remi/tree/master/editor. ;-)
It is a good example.
All asyncio tutorials seem to become irrelevant to me since they (mostly) try to show examples using asyncio.sleep(). It really is the worst way to demonstrate asyncio. Sleep isn't io, the only reason you have to wait for it is because it is literally a sleep function. If you demonstrate on something like reading and writing from disk or socket, then people start to see why they would even bother with asyncio in the first place, because the benefits are so evident in cases where your app has to wait for real io. I have some example 3.5 code that you can run and observe to see the benefit of asyncio for yourself. I'll post it here later (it's on my work pc)
Ugh, yeah - I've been using asyncio (because I use a library that uses it), and have built my on these sleep type examples, it feels a bit wrong really. Most of the time I want to wait indefinitely (I basically have 4 coroutines with sleeps and I cancel the sleep task to make the coroutines iterate). Since it's my first asyncio app I'm sure the structure can't be entirely right but it works, cant wait to ditch it for await syntax next time.
You will have to wait, it's quite a lot of work to add python 3 support and I imagine they are getting it working for their use Cade. It's really good there is competition in the JIT space, check back in a few years.
The exciting thing about pyston is the potential for high compatibility. Having said that the performance numbers are impressive http://speed.pyston.org I look forward to giving this a try with some of my older projects.
May I ask why this matters so much to you? Curious.
Noteworthy updates include: * Argon2 &amp; Scrypt hash support * TOTP support * PBKDF2 now has faster builtin backend, and utilizes other backends where available * Lots of API cleanups and internal refactoring * HtpasswdFile reader is now more flexible, and with improved security options. * Refreshed documentation Release notes: http://passlib.readthedocs.io/en/stable/history/1.7.html
Dont know much about pyautogui, thanks for the addition.
What is the difference between Pyston and pypy ? only speed ? pypy seems have the better performance now. If speed is not the only thing, what is the most noticeable downside of pypy comparing to pyston ?
There is a frame evaluation API in 3.6, this allows for pluggable JITs
PyQt / PySide are Qt bindings for python. You can use those with UIs created by Qt's designer. This is also my favourite GUI library for python, because of the powerful features and good looks (and the mentioned designer program). I have also worked a little bit with MATLAB's GUI designer. One feature you probably won't find in Qt Designer (or other graphical UI designers) is the "Jump to source code" feature from MATLAB.
Broken link?
It sounds like your having trouble grasping the 'Model - View - Controller' (MVC) concept, and also how WSGI works. I've found the Django 'poll app' tutorial gives you some confidence to play around with Django, but still leaves you feeling lost when you venture into making your first app. Don't give up! I used [this YouTube tutorial](https://www.youtube.com/watch?v=yfgsklK_yFo&amp;list=PLEsfXFp6DpzQFqfCur9CJ4QnKQTVXUsRy) on Django and it really helped me grasp the MVP concept. WSGI is still a little fuzzy to me, but I understand enough to setup my URLs in Django and get the site running on a server. 
GTK application development is pretty easy in Python and window layout can be done using the Glade design tool: http://python-gtk-3-tutorial.readthedocs.io/en/latest/. The applications are cross platform, but Windows and Mac aesthetics are less of a priority for GTK than Linux. Qt may give better results across platforms but for Linux, nothing looks better IMO.
GTK application development is pretty easy in Python, and window layout can be done using the Glade design tool: http://python-gtk-3-tutorial.readthedocs.io/en/latest/. The applications are cross platform, but Windows and Mac aesthetics are less of a priority for GTK than Linux. Qt may give better results across platforms, but for Linux, nothing looks better IMO.
That's a nice hack. But there are fantastic open-source, actively-developed libraries for this sort of thing. My go-tos are [dask](http://dask.pydata.org/en/latest/) and [joblib](https://pythonhosted.org/joblib/). 
Really not much to it. Googled coding puzzles and going through one by one. Just want a little practice.
Oh snap lol thanks , thought there was like a secret archive of puzzles 
Third posting to /r/Python. Whatever else it's pulling in the clicks.
Basically, doing this is a bad habit: ``` pip freeze &gt; requirements.txt ``` This would pin every one of your application's dependencies, and it's dependencies to specific versions. Best Practices suggest only defining your top-level requirements, let those figure out their own dependencies. This leaves a large amount of wiggle room to break your build. Because of this, [various solutions](https://github.com/nvie/pip-tools) exist to try and supplement the behavior desired by developers that's not included in setuptools or the stdlib.
Here is a simple svg graph: https://github.com/dddomodossola/remi/blob/master/examples/svgplot_app.py Here is an example using PLOTLY: https://github.com/dddomodossola/remi/blob/master/examples/plotly_app.py Should be easy to integrate other chart libs like https://gionkunz.github.io/chartist-js/
But first posting to /r/programmingcirclejerk !
Post on /r/learnpython: - Explain what it is you are trying to achieve - Format your code correctly - Show the error you are getting
I'm much more interested in embedding something like Matplotlib, since all of my existing code is based on it and I like to leverage the tools in pandas, seaborn, and others. How difficult would it be to create an adapter between matplotlib (maybe using the svg backend) and REMI? Any guess at what the performance hits would be?
A basic usage of matplotlib is here https://github.com/dddomodossola/remi/blob/master/examples/matplotlib_app.py But it is slow. Maybe a better integration can be done, this was just a test.
Just like last time someone posted about Scrapy I am at a loss as to what it can do that the standard library + requests can't do in the same amount of code. This is an honest question; I have not used Scrapy myself but I have written scrapers^([1]) and not found any part of my code that could have been abstracted without losing functionality. Every website is a little different and you still need all the custom logic to reflect that. For a simple crawl &amp; mirror you can just use `wget`. The only thing I found in the linked article is that Scrapy simplifies parallelism. In my opinion it is debatable whether parallelism should even be included in an all-purpose scraping library – after all the primary use case is scraping arbitrary websites, where good tone dictates that you should rather throttle than parallelize so as not to impact the site's performance. ^([1] mostly single-purpose, &lt;100LoC)
This article has one of the best explanations of event loop, coroutines, and futures that I've seen so far!
It's a framework that's got lots of configurability and whatnot. Scrapy isn't for simple crawling, although it can. we run clusters of it to index tens of millions of websites.
The example about plotly already shows how to integrate a javascript library. This can be done thanks to the fact that remi renders in web browsers, and so can use web technology for the UI visualization. This allows to access the GUI remotely, and portability.
The next level is handing off big tasks to a few co-workers (small thread pool). That makes you their manager. Now you have the best of both worlds.
Scrapy lets you easily extend your scrapers with various kinds of middleware, for example using a proxy, without adding any logic to the scraper itself. It also easily handles politeness (e.g. robots.txt). It integrates with [Scrapinghub](https://scrapinghub.com/) and [scrapyd](http://scrapyd.readthedocs.io/en/stable/) for easy scheduling and management of multiple scraping projects. This will include various statistics and result browsing capabilities. As for your last point, Scrapy does not simplify parallellism in itself. Each instance is async (through Twisted), ie. it is concurrent, but not parallel.
Not really, scrapy just excels at large scale, but it's is pretty flexible. You can definitely write a simple spider to "get pictures from the blog you like". You can run single spider with `scrapy runspider` command so you don't even need to create a project if you are looking for something simple. Also because of the extensive middleware and addon ecosystem you can save a bunch of time writing a simple spider by reusing most of your logic. Some of my personal spiders end up being like 20 lines of code for example, where it would be few times that with only requests and whatnot.
Let's all promise to just ignore Zed. He jumped the shark ages ago.
I think it is similar to why you would use a web framework vs just writing a straight Python web app. Using a framework gives you a structured format to work within and not be overwhelmed by the complexity of writing a reusable scraper or crawler.
The main use case of multithreading in Python is to avoid blocking on IO or on computation in an external module, designed to release the GIL, written in C. If this is your problem domain, then yes, there is some benefit to be had for this complexity. For pure Python computation just stick to multiprocessing.
I suggest that you [don't](https://www.reddit.com/r/coding/comments/5ehd8k/my_blog_about_learning_python_3/) [cross](https://www.reddit.com/r/Python/comments/5ehbg9/i_am_learning_python_3_and_blogging_about_my/)-[post](https://www.reddit.com/r/learnpython/comments/5eh8s4/i_am_learning_python_3_and_blogging_about_my/). Beyond that, it's very nice that you're blogging about what you learn! Keep up the great work! :)
If you have written all this stuff, then Scrapy is probably not much use to you! However, for those that want to avoid recreating the wheel, it's fantastic. Out of the box it: * will handle throttling * allow for concurrent requests * allow for concurrent throttling per domain, per ip, per x * allows for prioritising certain paths during the scrape * has dns caching enabled * handles redirects nicely * handles retrying nicely * handles switching out user agents nicely * can handle some types of http auth out of the box. * works well with enterprise/scraping proxies * provides functions for cleaning and working with data post scrape * has great great logging support with little work * has great memory handling and usage controls * will handle respecting robots.txt * can upload results to s3 * handling of data via configurable pipelines * can use multiple selector engines (xpath, css) * can export data as csv, xml, json, etc, etc * will de-duplicate URLs so you don't visit twice * have the ability to deploy to scrapycloud for free, with excellent logging and stats. * has the ability to extend with other people's code via middleware * has shortcuts for broad crawls * is x-platform, a lot of python code is already but not all! I wrote a bit [more about Scrapy vs BeautifulSoup](https://hexfox.com/p/scrapy-vs-beautifulsoup/) here, but the gist is above.
i'm not really the lead on that portion of our system, though i used to work on it. can't say i dealt with js SPAs when i was there though i heard the guys talk about it, so they're dealing with it somehow. not sure about dynamic results but i do know we're maxing out the proxies we're using because a lot of webistes don't like getting crawled ;)
Thanks for the list! Good overview.
&gt; I've tried using Scrapy. It was just too much trouble for no reason. I found it to be more pleasant to just use selenium, PhantomJS, BeautifulSoup, etc. There **are** reasons to use Scrapy but maybe your use case didn't fit. It's totally fine to use another stack if it works for you. But don't make it sound like other stacks are somehow bad. &gt; Also, good luck if you think "pip install scrapy" is all you need to do and that it works on your first attempt. I just ran `pip install --user -UI scrapy` on Ubuntu 16.04. No problems at all. Please don't spread FUD.
Still no SSH improvements? Option to use a key agent? Multi factor auth support? Proper proxy/tunnel support? Come on JetBrains...
The last time I looked, more than a year ago, I didn't find anything. And I was/am still relatively new to testing. But what I ended up doing was something like this (example uses `unittest`, but `pytest` worked and `nose` would too. from unittest.mock import patch, MagicMock MockRPi = MagicMock() modules = { "RPi": MockRPi, "RPi.GPIO": MockRPi.GPIO, } patcher = patch.dict("sys.modules", modules) patcher.start() def teardownModule(): patcher.stop() The rest of the testing could now be done normally, with a caveat that it doesn't really test interactions or reactions etc. You could, though, check many other things. For instance, that it was: * set up correctly: `GPIO.setup.assert_any_call(pin_name, GPIO.OUT)` * called with the proper values: `GPIO.PWM.assert_called_with(12, 2800)` or `GPIO.output.assert_any_call(pin_name, GPIO.LOW)` * cleaned up: `GPIO.cleanup.assert_called_once()` I hope this helps. If you learn anything new, please let me know.
[What's new in Pycharm 2016.3](https://www.jetbrains.com/pycharm/whatsnew/)
Just checked, seems to be working...
&gt; Currently you cannot run Python 2 inside the Python 3 virtual machine. Since I cannot, that means Python 3 is not Turing Complete and should not be used by anyone. Python 3 is Turing complete, python 2 is Turing complete. They are Turing complete completely separate from each other. The statement is akin to saying "Java cannot run C# bytecode, therefore Java is not Turing complete". Not to mention it's such a poor metric for judging a programming language, even HTML is Turing complete. For the most part python 2 code *can* run directly inside a python 3 interpreter, up until the point in which it needs to do some sort of I/O or string handling. Because they changed the fundamental concept of strings and bytes (rightly so in my opinion, every new language is unicode aware by default), every single library that ever touched strings (read: most if not all of them) needed to completely change how they treated them. The *other* major hurdle was the breaking of the C API which crippled scientific stacks. Numpy, SciPy, etc, were all non-usable and therefore could not be directly ported. 
I've just written a script for someone other than myself and installed Anaconda/Python 3 to their machine for the first time. Script: Scrape data from website to CSV using an Excel file for input. Learning: BeautifulSoup, OpenPyXL, the value of exception handling/logging to trace errors/debug solutions for which you're not the sole user!
I need this :(
Can scrapy trigger JavaScript commands? I thought I heard something like that but I keep reading these reviews and stuff and can't find any more about it. I have a working solution with Selenium but if I could replace that with something that's slightly less reliant on acting like a person I'd be a bit more comfortable with it. I know I should just do it with scrapy and see what comes up, but you know, what I have now works....
Hi, I'm the PyCharm dev advocate. Can you point me at some PyCharm issue tracker tickets?
And the [video walkthrough](https://youtu.be/8TRYsmhovj4) with my weird sounding voice.
I see this question a lot. The general problem is that people find themselves thinking in terms of "how do I do this in Javascript?" as you've found yourself with "can I trigger javascript commands?". But I ask you... what is your end goal? 99% of the time your end goal is to get some data. So the question you should be asking instead is "where does javascript get the data I want from?". The answer to that in most instances is embedded in the HTML itself or more likely, from an API. If it's not in the HTML, check the network requests panel in your favourite browser dev tools. If you search through what requests the page makes, most of the time you can find the raw source of the data used to render the page. Hunting for the source of the data has two major benefits if you find it on an internal API: * APIs are easy to parse and very, very machine-readable, that is literally what they are for. * internal APIs change less than the page design, so the solution you end up creating is much more resilient and performant because you don't have to pretend to be a browser to get at the data - just make an HTTP request. It really is win, win. People rely on Selenium far too much, simply because they don't understand how a browser renders the page.
I don't think Scrapy can trigger any JavaScript code, neither I think will ever be, besides mimicking basic stuff like redirects. Scrapy is based on requests if I am not mistaken, not on selenium or any headless browser.
https://gist.github.com/guimaion/9275543
/r/learnpython
Python 3 puts up with less type nonsense than Python 2, and that's basically the only reason 2to3 will not always work. &gt; Yes, we could certainly compile Python 2 to bytecode that runs on the Python 3 VM. Even if this was a thing (which forgive me if I'm wrong, but I think this is nonsense? of course it's the same?) there's no point when the behavior of Python 2 code is vague and/or reprehensible in its ambiguity for its type. Python is dynamically typed (duck typed was it?) - that's great - but that doesn't mean while we're making Python cooler/better we need to put up with code that from an author who doesn't know what types/objects they are using in the first place. Python is a language of "we're all adults here" - it doesn't have private members, anything is fair game. This assumes a degree of knowledge of what types/objects your variable is and will be. So when Shaw says he is frustrated that his miss mash of types don't work they he wants them to, that means he doesn't understand quite clearly enough what he precisely wanted to do. That's ridiculous, and the onerous task of writing reusable code is not on the language, it's on the developer - they should have got it right in the first place. I work with computers because when something gets messed up, it's my fault as a developer, it's not a people problem. And that means it's up to me to fix it because apparently I simply was not smart enough or well learned enough to trick/coerce/persuade the environment into doing what I wanted it to do. This very same coercion is what Shaw has messed up. And excuse me for being presumptuous, but is also essentially what every developer with nontrivial 2to3 conversions has messed up. The coercion is failing because Python 3 puts up with less nonsense. Developers messing up 2to3, messing up bytes vs str, dreaming for easy conversion, are all forgetting one thing about the Python 2 code that "won't run" in Python 3. From the Wikipedia article on [Duck Typing](https://en.m.wikipedia.org/wiki/Duck_typing), emphasis added: &gt; In computer programming, duck typing is an application of the duck test in type safety. **It requires that type checking be deferred to runtime**, and is implemented by means of dynamic typing or reflection. This means the onus is on the developer to ensure types work correctly whether or not they implement checks. If the language evolves in a way that requires clarification, any code that is nontrivial to change was making assumptions/simplifications about the types being used. Python is awesome: If you need that behavior back, write a personalized class that makes that object behave the way **you** want it to (with all the same assumptions you once made).
At work now?
Does this require a separate license from 5.0?
Very interesting, thanks for the write up. I'd only used Scrapinghub for the smallest of periodic scrapers.
AsyncIO is running on an event loop. The loop runs at the center of the program, and its code "spins" (essentially, a for/while loop going forever). Every spin, it checks with the system whether there can be new output sent, or new input collected. Then you attach event handlers (functions), which get run in a somewhat indeterminate way also within the loop, that are given relevant input collected or queue up new output in the loop to send out. You program all your user code to run when your attached event handlers are triggered. AsyncIO is a "python canonical" implementation of an event loop, so if everyone in the community uses it, then everyone's code can essentially work together, all running on the same loop. In this design, as long as none "blocks the loop" (the loop is the only thing that waits for input/output) then you can run an asynchronous networking design *without* using multiple execution threads. It can be completely single-threaded.
 Did you get into the new subscription plan?
I think so, when I go to "take me to my purchase" it says "1 toolbox subscription" with the next billing date in 2017 of $53
And open source projects, [and more](https://www.jetbrains.com/pycharm/buy/#edition=discounts)
For once, I don't know what a pyramid scheme is? ~/u/danishanish ----------------------------------------------------------------------------------------- [*^^[Feedback]*](https://www.reddit.com/message/compose/?to=Simulate_Me_Bot) [*^^[Get ^^a ^^bot]*](https://www.reddit.com/message/compose/?to=iNeverQuiteWas) [*^^[Info]*](https://www.reddit.com/r/FreeKarma4You/comments/5b0r6r/i_am_a_bot_that_will_simulate_you/)
I'd love this for my tone, I've been really irritable lately. ~/u/derpderp3200 ----------------------------------------------------------------------------------------- [*^^[Feedback]*](https://www.reddit.com/message/compose/?to=Simulate_Me_Bot) [*^^[Get ^^a ^^bot]*](https://www.reddit.com/message/compose/?to=iNeverQuiteWas) [*^^[Info]*](https://www.reddit.com/r/FreeKarma4You/comments/5b0r6r/i_am_a_bot_that_will_simulate_you/)
Have a look at this. https://github.com/alex-sherman/deco From the docs: "Using DECO is as simple as finding, or creating, two functions in your Python program. The first function is the one we want to run in parallel, and is decorated with @concurrent. The second function is the function which calls the @concurrent function and is decorated with @synchronized."
Gladly! Supporting SSH agents, 4+ year old ticket: https://youtrack.jetbrains.com/issue/PY-6311 Request for SSH tunnelling, again 4 year old ticket: https://youtrack.jetbrains.com/issue/PY-7986 Use of system SSH instead of builtin SSH (this one would potentially resolve the agent, MFA, and tunneling issues in one swoop), yet another 4 year old ticket: https://youtrack.jetbrains.com/issue/PY-6247 SSH multi factor auth: https://youtrack.jetbrains.com/issue/PY-21090 There are dozens of other tickets that seem to be caused by SSH related issues, but those four hit at the crux of the matter: PyCharm's internal SSH is too bare bones and is missing a ton of functionality and configuration options.
Hey man that was a great run down! Do more of these in the future !
Definitely agree with your points, and in general I do prefer to remove interface layers rather than complicate them. In this particular case I'm not just retrieving data but also sending commands that compute it (for both me and the server). My long game is to replace the tool I'm interfacing with. In the mean time, I might be well served to learn a little JavaScript so I can follow your advice and decode what it's actually doing since I haven't been able to find the commands in the HTTP requests... 
Thanks!
First learn python. Second learn some packages like Pandas, Matplotlib.Third learn how to use [Quantopian](https://www.quantopian.com/), which is what "Quants" in hedge funds use.
Interesting, this is proper edge case territory by the sounds of it! If you can work out whether it is doing the calculation client or server side you'll be well on your way to finding out how to improve it. Interesting case, happy to talk about it via PM if you ever get stuck :)
I wind up doing these for each PyCharm and WebStorm major release. I've also done an 8-part "getting star" series with two "in-depth" series (VCS and Git), with some more planned.
&gt; In an attempt to make their strings more "international" they turned them into difficult to use types with poor error messages. This line is the most offensive one for me. Because it shows that Shaw never ever dealt with different languages than english or emojis, because customers will paste every kind of shit into formulars...
I meant `make install`, sorry about that. But, pyenv doesn't quite fit my use case. 
It's also using a non-https URL which makes this terribly insecure. Payments can be MITMed to change the receiving address and amount. 
There is an O'Reilly Book on the matter, and a very good one at that (haven't finished it yet), called [Python for Finance](http://python-for-finance.com/). It also has an accompanying website that has all the code and the IPython notebooks available for free [here](http://oreilly.quant-platform.com/nb/portal/register)
[poorly] stolen content: https://www.udemy.com/python3-a-beginners-quick-start-guide-to-python/ scam site
 $ python3 1b-cooperatively-scheduled-asyncio.py gr1 started work: at 0.0 seconds gr2 started work: at 0.0 seconds Lets do some stuff while the coroutines are blocked, at 0.0 seconds Done! gr1 ended work: at 2.0 seconds gr2 Ended work: at 2.0 seconds I don't understand why the output comes in this order, and in fact it doesn't work this way when I try running this code myself. Why shouldn't the `print` call after `asyncio.sleep(5)` run last?
I started working a project that retrieves data from my company's lab data, analyzes it, and then makes set point changes to industrial PLC controllers to try and adjust the lab data in a desired direction. Trying not to (literally) set anything on fire.
It is really weird that this issue has not been fixed for such a long time. But I can confirm: setting ssh to native solves the problem. Maybe they should deactivate internal ssh until it actually works to spare people wasted time.
I'm working on a plugin for [Sunflower](http://sunflower-fm.org/). I haven't coded in Python in ages so this will be a good refresher.
Your voice does sound strange initially, but quickly becomes interesting to the ears because you're naturally polytonal. If you recorded with a mic that captured low-end better, I recommend the Shure SM7b, you would [sound like Tom Servo](https://www.youtube.com/watch?v=CISRRn3wolk).
Ahh interesting, thanks for the explanation. :)
I'd also add nice ipython shell integration for incrementally building the parsing logic. I'm a big fan of parsel (https://parsel.readthedocs.io), which is what Scrapy uses for xpath/css selectors under the hood. I often use it as a standalone library when writing a one-off scraper with requests. 
Did he actually mean any of the other factually incorrect things he said (dynamic typing, how long Python 3 has been out, translating source code being a solved problem, Python 2 and Python 3 not being runnable at the same time) or are those all jabs put in for some reason?
You could try https://github.com/quantopian/zipline if you are interested in trading algorithms. But honestly, most work in finance is just like any other field, custom business rules around custom data models in a regular relational database. The only crux is that finance regulations are a vast minefield of exceptions to the rules, so it can take more time to grasp than other fields, for a general developer.
running a ton of MCMC fits with emcee (aka my excuse to browse reddit during work), trying to make my model calculations more efficient.
Yes, this would be incredibly useful.
How would it be useful? Because MFA is absent I cannot: remote deploy, remote execute, remote debug, browse remote file structure, use the database viewer, manage remote packages, and probably a huge list of other features that I can't recall off the top of my head because I've been unable to use them for close to a year now (when our security policies changed to require MFA). That is kind of a big deal. How would it work? The same way every other SSH application works: prompt me for my authentication key when the server requests it.
Only issue is that you forgot to indent some of the code samples... :)
Is buying the other version of PyCharm worth it?
I hope you do not want to do development on production machine.
Of course! I've tried lately to get away from the "It is obvious to me..." mindset. All of my work is done on AWS instances. Every single one of our client agreements require we have MFA enabled. Some go an extra step and request dedicated hardware in a VPC which brings in the need for proxying/tunneling/forwarding. As a result of those requirement changes PyCharm went from a bad ass all inclusive tool to a glorified text editor.
All of our production, development, testing, and staging is done on AWS. All of those instances require MFA at a minimum. So no, I do not want to develop in production. I just want to connect to literally anything.
I first discovered WordNet when I was looking for an English dictionary that I could access from a script. After using it for a while, I realized that WordNet might be the most powerful dictionary/thesaurus in the world. In this post, I share some the amazing capabilities of this database. The examples are in Python/NLTK.
Try import.io instead 
Thanks a lot for the confirmation. Just downloaded, ran it before copying to applications and got prompted for a settings import, confirmed and it started up with no problems. I guess you could say it worked like a...charm?
My favorite part about it is that 3 months ago I wouldn't have been able to understand it, let alone write it.
They offer a 30 day free license when you download it. Give it a go, open a few projects with it, install a few plugins, play around see what you think. helpful plugins: - glance - .gitignore - markdown It will suggest more plugins as you encounter more artifacts in your project and target your interpreter.
I just downloaded community edition and figured its a great tool but with some short coming: 1. Does not respect shebang. My script is pointing to python3 which is not default but it shows External Libraries from default 2.7 version. 2. Just like visual studio code it shows error in print() method when used with "end" parameter. E.g. **print(c, end="-")** But overall a bliss for Linux users.
could you explain why exactly you think this should break your system? The python on mint / ubuntu is just "pre installed" it is not "baked" in. Did i miss something here? To be honest i never heard about anaconda before...
Yeah, it's obviously not super accurate. Much less so than IPv4. The testing I need to do is to ensure certain behaviors are performed based on the country of origin for the request. This is best effort, if there are proxies or tunnels, I can't really account for that. I ended up implementing the random generator approach for IPv6 and it takes and acceptable amount of time. It's about 3-4 seconds on average. Much longer than IPv4, but it's an acceptable tradeoff.
I just did it yesterday on my 2014 Macbook Air. I'm a beginner programmer and it took me about 10 minutes. No problems at all with the GUI based installer!
Ok. That's a relief to hear. Thank you.
PyCharm has a concept of the project interpreter. It uses this interpreter for running and analysing all the files. For some reason it detected 2.7 as a project interpreter by default. That explains why your script is run using 2.7 and why PyCharm shows an error for print(..., end=): in 2.7 print was a statement, not a function with parameters. You can change your project interpreter to Python 3 in Settings. See https://www.jetbrains.com/help/pycharm/2016.3/quick-start-guide.html#interpreter
Why? Already wrote my own more powerful system. Too core a part of my business to outsource to a scraping operation.
I really like the simple API of TextBlob and the built in function for noun phrase detection. However, I sometimes need to use the Stanford CoreNLP in my work, so I am sticking with NLTK because of its nice interface to the Stanford libraries. SpaCy is also quite good. They don't have WordNet integration yet, but it's on their agenda.
Anaconda by default installs as your default system Python. That also routes stuff like Pip (which is a part of your Python installation) and makes sure every package gets installed to the right place.
&gt; Terminal with Virtualenv pre-activated Yes! This is awesome, thanks.
I saw that and got unreasonably excited. Only last week I was thinking to myself how every time I open the terminal panel the first thing I do is activate the venv, and wondered if there might be a simple way to do that automatically.
You have awesome clients btw.
Your company should enforce MFA.
That is awesome. Thank you. For my big projects I don't use type annotation because DRY since I already use extensive (numpydoc) docstrings for every function or class, but not for local variables. I think I'll start using them as documentation for purely local variables. For now, PyCharm can understand the annotations and do type checking for you. How do people use type annotation with docstrings normally? Bonus: The contract package allows type annotation which includes the size of a matrix or array. This is extremely useful as pre/postcondition checking.
Hah... At least they're shitheads with strong security practices. ;)
http://www.blog.pythonlibrary.org/2013/10/29/python-101-how-to-find-the-path-of-a-running-script/
Ehh... I think it is mostly luck through extreme levels of idiocy. Some of the random pants on head retarded shit I've encountered lately from various clients: * demanded we use no USB devices. None. Ever. Thumb drives, external hard drives? That I could understand. But literally no USB devices. USB keyboard and mouse? Nope, fuck you. It is USB and USB devices can steal data. Apparently if I type on a laptop and use a trackpad it magically prevents me from doing the same. * insisted we have no visitors to the office because they might read our screens and leak their data. OK I guess, sure? We are remote, good luck enforcing that. Then they found out we just lease office space in a big generic building and there are people on our floor from other companies. They insisted we either kick them off our floor or move to another floor solely occupied by our company. Each floor had office space to handle about 60 people. Our company has 5 people. This still seemed like a valid request to them. We countered with an offer to keep the door closed. * client is scared of us using AWS because their server would be on a rack with someone else's server and they wouldn't know who owned it and what their security practices were. Other company might accidentally plug in to their server and cause a leak? They legit thought we would be buying a server, going to Amazon, and installing it in a rack. I had to explain how AWS worked to the CIO of a company doing $15 M in revenue a year. This is not bragging on the Internet. That is a factual, true statement. * demanded we disable the print screen functionality on all of our computers so we didn't leak their data one shitty screen grab at a time. Because if I want to steal the roughly 8 million records you sent me, I'm going to do it manually one JPEG at a time and not by just sending a nice .tgz dumped straight from the database. * gave us a 220 question survey on our security practices. Finally accepted that we knew what we were doing. Then provisioned me a machine on their network to use for data extraction and insisted the only way I could access was using some shitty remote desktop sharing bullshit. Not even proper RDP, it was just a screen sharing program. It didn't even establish a background session, it was broadcasting everything I did locally and relaying it to me. I discovered this because the machine was in their conference room and used to run the projector. Someone went to host a meeting, turned on the projector and saw "all kinds of hacker looking stuff happening" and reported it to IT. IT checked logs, saw it was me logged in, and called demanding to know what I was doing. Once I figured out how retarded they actually were I was able to defend myself, but that took a while. I could keep going, but I'm mentally exhausted reliving just those few examples. Time for a beer. 
I've always been a bit thrown by the necessity to provide pycharm with my private key. It's nowhere near enough of a bummer to stop me from using it but it would be a pretty sweet target for the wrong sort of people.
Lions, tigers, and morons!!.. It won't buy you a beer, but you certainly made my night. 
Sorry, I wasn't specifically replying to you, I just shot off on a tangent from your comment.
I'll admit that floats suffice for an introduction to financial analysis using Pandas, but that notion should be abandoned relatively early: .1 + .1 + .1 == .3 # False .1 + .1 + .1 &gt; .3 # True For anyone not in the know, `.1 + .1 + .1` is equal to `0.30000000000000004` Money is a discrete value, so you should represent it discretely. If I have six pennies and you have a nickel and a penny, they're interchangeable. But with floats, they aren't. There are *some* cases where an addition of floats and the supposed sum of those floats are actually interchangeable (in the system CPython for my laptop at least, though CPython follows the IEEE Float spec so it should be true for any other language that also does that), such as `.1 * 5 == .5` but I'd consider that an outlier rather than the norm. If you're trying to do fast and loose approximation (e.g. this blog post), floats will probably do just fine. I'll even concede that there's room for them in serious financial analysis (they're used at work in our data science models, and these are pretty good models to my understanding). But accuracy isn't something they're good for.
Since you don't seem to be looking for a specific character as you would with `count()`, just use `len()` word = input("Enter a phrase") print(len(word)) `len()` will also take into account spaces. Just a bunch of comments on your given code, no need to parse `input()` into a `str()` since it's already a string. Also no need to specify data type such as `int count = 0`. `count = 0` is fine. 
thx but what if i want to have them separate, and one more question how do i add nums that get put by the user more then two without doing a lot of work 
Out of interest, have you tried using a persistent connection (started before pycharm)?
Skip the blog spam: https://www.jetbrains.com/pycharm/whatsnew/ 
We do. We don't deploy via PHP storm though
I couldn't seem to get the built in terminal to work with conda environments, but may need to work with it more. Previously I could activate a conda environment, but now not only does it not automatically activate it, it seems to make it impossible to manually do so.
[pylonsproject.org](http://pylonsproject.org) is the outdated site for the Pylons Project Organization that is an umbrella for projects where Pyramid is under. The new entry point for Pyramid is [trypyramid.com](https://trypyramid.com) and two examples of more complex applications is definitely [Warehouse](https://github.com/pypa/warehouse) and [Websauna](https://github.com/websauna/websauna). 
Seems like trypyramid.com links most documentations to pylonsproject.org. Also, trypyramid.com has a different branding and logo. This is confusing.
No because since 3.5 is set to your default, everything installs to the Python3.5 folder. If you specify Pip or Python from the 2.7 folder, it'll install to or run from that folder. There's no central folder that Pip installs to. It installs everything to the Python directory it belongs to. While 3.5 is your system default python, the Pip command defaults to the 3.5 folder the same as the Python, iPython, etc. all do.
i don't like this as much because you get a `reversed` object, not the actual string back. then you have to do something like `''.join(reversed(s))` if you want the string
WordNet was last updated in 2006. I wonder how many words have been added or changed since. 
yes it links to docs.pylonsproject.org like other projects under it. This is the new Pyramid branding since two years already but we failed at properly market it. There was a confusion since the day the Pylons framework became an organization and Pyramid became its successor.
I really like the philosophy of Pyramid, too bad it has been underrated mostly due to lack of right marketing.
Yep
It depends a lot on what area you are working in. Any company that requires real quantitative research will have their own historical database/backtest/trading systems. They aren't using open source projects that popped up two years ago. Excel is pretty much the only constant. In practice I've found that interfacing between Excel and Python is rarely optimal because it makes your work challenging to share. Excel and Python also have huge feature overlap so if you start in one system there isn't really a point in adding another. When data needs to cross between systems I'll dump to CSV or interface with a database instead of tying together a mess of Python/Excel/VBA.
 wget https://repo.continuum.io/archive/Anaconda3-4.2.0-MacOSX-x86_64.sh sh Anaconda3-4.2.0-MacOSX-x86_64.sh And follow the prompts.
&gt; Why would I ever use `.format(...)`? It's worse than `%s` and slower. There are now 2 methods in my book and 1 that I can use because I write Python 2/3 code. 1. Python is already a language that sacrifices performance for legibility. The case of `%s` vs. `.format()` is, as you put it, a case of performance versus legibility. The latter is easier to read and therefore more pythonic. 2. You can use either with Python 2 and Python 3; `.format()` was introduced with Python 2.6. The new incompatibility are `f-strings`. 3. There should not be three ways to format strings, you're correct. It's not pythonic. But `.format()` isn't the one that should go. 4. All of that aside, if you're concerned about performance, use PyPy.
After reading both articles, I'm totally behind eevee here. Seriously, fuck Zed. His article is not just a criticism of Python 3 (which is totally fine - I'm more than willing to read criticism of Python 3, it helps me learn more), it's a very deceptive, sloppy hatchet-job. I'm actually at the point where I think I should petition the moderators of /r/learnpython to remove Zed's book from the wiki - I would hate for a beginner to be turned off Python 3 just because of his duplicitous statements about it. Also, it is *so* abundantly clear that Zed has never used anything above ASCII. My entire job is dealing with non-ASCII characters, and I would be unbelievably crippled if I was stuck with Python 2. 
I like eevee and this is a great rebuttal but does anybody take this guy Zed Shaw seriously? Honest question. Anyway, I enjoyed reading eevee's post (it's fun and informative) so thanks for sharing.
"Zed Shaw, your behavior here is fucking reprehensible." Jeeze, this is my first intra-language flame war since starting coding.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is more-so dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community can get disenchanted with seeing the 'same, repetitive newbie' questions repeated on the sub, so you may not get the best responses over here. However, on /r/LearnPython the community is actively expecting questions from new members, and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. Whatever your question happens to be getting help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
Great improvements! Keep up the good work PyCharm!
I also agree with eevee
Python 3 is great. Every time I see print declarations without brackets I die a little inside.
Wargh, what crap article. Full of repetive claims, rants and nonsense. That does a really bad service for the cause it adress. Very hard to take it serious. And it really doesn't help that he constantly pretends that python 3 is hard for beginners, yet most problems he have are differences between python 2 and 3, not even the language itself. I seems he has more pissed on the fact that his outdated tutorial is becoming useless and he can't anymore earn money with it till he reworks it. Probably lost some through refunding.
As a beginner I had no problems translating a majority of my python code from 2.x to 3.x. My code, in my opinion, is still pretty basic but I've had no problems with either python that I couldn't attribute to my own ignorance instead of the language itself. Seriously though, how do I subscript the unsubscriptable.
You could have presented exactly the same technical content without any of the ad hominem, and I would haven't blinked at agreeing with it. ...but heck, I've said my part; if you feel totally unashamed to respond to a *technical* article (regardless of its quality) with a *personal* attack, frankly I don't want to be involved with anything you do, least of all trying to discuss any real technical possibilities. Enjoy~ 
%s forces you to repeat after yourself. The plugged-in value knows its type, so why do you have to tell it "you are a string"? It's code smell, plain and simple. Not to mention %s is not really like interpolation, unless you use the %(name)s syntax, but format can do this too with {name}. And I'd argue that bash's ${xyz} is much more similar to {xyz} than it is to %(xyz)s
I messed with this a bit last night. Unfortunately, none of the sources I threw at it were very well parsed. For example, I converted a 20 minute long football coach's press conference video to a wav file. `cut.py` chunked this into 3200+ files, but `watson.py` only managed to filter this into 310 usable snippets. Those snippets were not one word snips like I would have expected. The vast majority of them were long phrases. Stuff like ""that's one thing you're pregnant doesn't that" (which when listened to was actually "that's one thing we were breaking new guys in in that pos...") Only 40 snips were one word clips. I listened to each of the 40. By my count, 13 of them were accurately recorded speech-to-text. Admittedly, a press conference is a pretty noisy environment which I'm sure contributed greatly to the poor showing.
By the way, anyone looking for an actual criticism of Python 3 by a very widely and well respected member of the community responsible for a number of the most popular libraries out there, should look to this by Armin Roncher: http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/ Edit: As the top reply to this points out, here's a quite recent blog from the same author about the dangers of group think: http://lucumr.pocoo.org/2016/11/5/be-careful-about-what-you-dislike/ As it relates to Python 3, I'd love to hear about what his current opinion of Python 3.5+ is compared to e.g. 3.2.
I don't know this Zed guy, but... the only thing I agree with him about is that it would really be nice if Python showed the variable names it could not concatenate in error messages instead of just their type.
[Python 3 was an inside job](https://i.imgur.com/seDzcrO.png)
I'd argue that, given the tone of the rest of LPTHW, it's well within reason.
I'm sorry, but this kind of ignorance is contributing to the issue. If there is a new set of functions that behave the same way you are used to (if you don't specify time zone it assumes current one), would it matter to you that they are also time zone aware and make other people's life easier? Maybe in the future you will move to a time zone where it matters, or you will have to write time zone aware code, you never know.
&gt; Saying that he doesn't know what he's talking about and that he should shut up is not being a jerk. This cannot be said enough. There are things that shouldn't be normalized like a very condescending and very questionable scaremongering speech. There's nothing wrong with saying something like "you don't know what you are talking about and you should shut up because you are making harm" when you show facts and good arguments. Eevee's words are justified imho.
&gt; I think I should petition the moderators of /r/learnpython to remove Zed's book from the wiki Done. (I think we left edit access open, actually, but yeah.) Zed Shaw might just be the most stubborn person ever to write a line of code, and there's a LOT of competition there. Edit to address various comments downthread: I've been considering this for a while (and advocating for teaching 3.x to new beginners for a while), but the bit where he abused a nonsense argument about "Turing completeness" like that was really the last straw. I've always thought the book's approach was terrible, but I was willing to put that aside because students have varying learning styles, I'm not some omniscient god of pedagogy, etc. I'd also extended some credit because I've heard one or two of his talks on other topics and thought they were OK, and I sympathized with that "programming, motherfucker" thing way back in the day. But the fact that Zed is still banging this drum (when I saw the /r/Python post the other day, I assumed that it was about something he'd written back when LPTHW came out, not just a couple days ago) - not to mention the completely broken drumsticks he's using to do so - gives me real reason to question his competence. If this is "political" (and I can see the argument that it is), so be it - he made it so. Zed's anti-3.x arguments are, as /u/Sugar_Horse puts it, irrational; and to me they smack of hypocrisy. (Accusing the devs of malice and going off on Twitter about "abusive" programmers? Really? Zed's best known as a programmer himself, and his descriptions of "propaganda" are themselves abusive, and it's hard not to infer that he just doesn't want to put in the work to update LPTHW - since apparently he originally planned to do so). Oh, and now he's apparently trying to play off the Turing completeness comments [as a "joke"](https://twitter.com/zedshaw/status/801827159157243904). Really.
Seconded this, thanks for adding. To the reader: you don't always need the full power of Scrapy - under the hood it uses a lot of 3rd party packages to get the job done (some that used to be part of Scrapy itself and have been extracted). Check the dependency list.
Yes that's true, a good deal of it might be worth revision
There's absolutely a nasty arrogant/condescending communication style that tends to show up in certain areas of programming culture. Zed Shaw indulges in it *constantly*. Eevee does it... pretty much never, that I've seen. I agree that that style is harmful and should be deprecated – but that [doesn't mean we have to always be nice](http://geekfeminism.wikia.com/wiki/Five_Geek_Social_Fallacies). Sometimes it means we have to call people out on their nastiness. It seemed 100% clear to me from the blog post that she wasn't throwing around language like that as empty macho posturing, but because she'd assessed what he was doing (libeling the entire Python dev team, making up incoherent nonsense to terrify defenseless beginners, with a side order of intellectually dishonest rhetoric), come to the rational conclusion that it was reprehensible and he should be ashamed of himself, and expressed that using a few well-chosen sentences at the end of a thoughtful response. This is totally different from claiming that there are no issues with Python 3. There are tons and tons of thoughtful discussions already available about the trade-offs in Python 3, and in my experience then Python devs are happy to have more of them ­– if that's the conversation you want to have. But it's pretty obvious that Zed isn't trying to start a thoughtful conversation. 
I see a rant of a salty person who can't use python2 with python3 vm. At this point they divulged too much to get any backward compatibility -- it's time to move on if you want latest PEPs
Does he want a mathematical proof that it is? Actually, that's not hard. Brain fuck is proven Turing complete (so is the game of life). Write any of those in python, and that is a proof that python is at least as powerful as them, therefore python is Turing complete.
print 'hello'
&gt;Edit: I'll put the LPTHW link back up when Zed finishes the Python 3 update. ... heh.
It's interesting you link that, because I just saw this today: http://lucumr.pocoo.org/2016/11/5/be-careful-about-what-you-dislike/
Thank you :)
It sounds like you need to work on the basics - try posting at /r/learnpython instead.
I don't feel that an understanding of Turing machines is required to write about programming with authority. However, Zed misunderstands/misrepresents the theory but still uses it in his rhetoric, which he ought to stop doing.
I wrote a library called iCalendar that parses and generates ical files. I had made loads of test, even with utf-8 etc. And yet i had managed to miss a bug before releasing it. Lines must be folded at 72 characters per the spec. And none of my tests had a utf-multibyte character at position 72 so I did not catch that a character there would get its bytes spilt in two by line[:72]. So when people started using it on their own ical files it would randomly make errors when parsing. And that is the problem with those bytestring texts. Even though the error was easy to understand when discovered it was subtle enough that it did not occur to me to begin with. 
WHY on earth would you write a rebuttal to a troll? The troll doesn't care or pay attention to responses. That's the point. Start a fire for no reason and leave. I thought it was transparent clickbait.
I've skimmed that article. The author's an idiot.
Somewhat predictably, Zed [doesn't seem to care](https://twitter.com/zedshaw/status/801495976284332032).
Under the right circumstances, it could be. But it probably comes up as a flaw more often than not.
pycharm does that.
How does advocating staying with a bug-fix-only branch of a language with arguments like this not make him a "Big Bad Coder Guy"? This is no different than saying we should only ever use C89 because everything after was a mistake, then justifying it because people who don't know any better believed you.
Yep. The old rfc's are like working through archeological records. Email is a lot worse than ical though.
Coupon Save 100% . You will Learn Manual Testing, Python and Selenium. All you need to secure your dream job in automation testing or improve your skills in automation testing.
Person A: craps on a bunch of people and their work with insults, hyperbole, unsupported assertions, rude language and stuff that reads like conspiracy theories. Person B: calls out Person A in strong terms. Person C: reaches for fainting couch and smelling salts over what Person B did, because they are shocked -- *shocked!* -- at such unbearable incivility! There are two people being a problem here, and Person B ain't one of 'em.
The thing about strong opinions that a lot of people seem to be forgetting this days is that you should have strong opinions, BUT SHOULD NOT HOLD ON TO THEM. I don't remember exactly where I read this, but I like it and think it makes sense.
Spyder is quite lightweight while it * has variable explorer that supports numpy and pandas types * IPython console * also supports Jupyter notebook style "run cell (and advance)" style execution. http://python3.codes/wp-content/uploads/2015/04/Spyder.png
I started using Python 3 for my personal projects, buy I am not going to rewrite my old code at work just because it's a better language. And in 2016, at least two big libraries we depend on, OpenCV and Panda3D, don't have prebuilt Python 3 binaries for Windows. And I prefer to have an easy way to get things running anywhere.
For linux there is - https://github.com/kennethreitz/autoenv
Turing completeness is impossible to prove. To show that a language is Turing complete you have to feed it the entire set of all possible programs to show that they can be read by it... it's just so obvious pointless to call a language Turing complete when it cannot be proven.
Nice. Thanks for sharing that.
So why are you only calling out one person here and not the other? Why does Zed get a pass but /u/lexyeevee has to be a "grown up"? You're being inconsistent and people are calling you out for it (especially because selective demands for civility have a history of being used to prop up and support uncivil people).
Not everyone uses it. Having it be a feature of the standard implementation and not a third party ide would be handy.
This is really interesting. The documentation is great, but how are templates defined? I mean I see there something about "invoice", "reports", but how can these be defined?
&gt; My entire job is dealing with non-ASCII characters THIS! I worked in a country that has FOUR national languages NOT ONE of which can be fully written with ASCII characters. I seriously get mad at how english-centric people are when they dismiss this as 'not a problem'. The VAST MAJORITY of people in the world DO NOT speak English and CANNOT write their language using ASCII characters only. Hot tip to Zed: most people are 'from another country', deal with it.
It's actually a fairly common procedure. Not necessarily BF, but proof by implementation is a well-known technique for proving Turing-completeness.
I read a bit of his Learn Ruby The Hard way back when I was getting into Rails, mostly just skimmed to see if it was worth a read. I noped the fuck out when he said we shouldn't pay any attention to the work of Dijkstra and that it wasn't worth reading or understanding. Guys a quake for even suggesting that, especially in a book that could be someone's first introduction to programming/computer science.
"Python 4 is not only Turing incomplete, but actively makes other programming languages less Turing complete just by sitting in the same hard drive. Also every time you run a Python 4 program, four kittens die. Why do you think they named it Python 4?"
Working on Sphinx-style docstrings support for [Clize](https://clize.readthedocs.org/). Got it to a basic level and feature-parity with the previous system. Next up is dealing with RST's tables, autodetection and also using `napoleon` to support Google and numpy-style docstrings. I haven't pushed my changes yet because I'm still making sure that my refactoring of the help mechanism makes sense. I really do edit my commits through interactive rebases a lot :)
Welcome, we hope you enjoy your stay!
So how would you prove that Python 2 is Turing complete? You still have to show that Python 2 can emulate all possible Turing machines. I thought the Church Turing thesis was still called a "thesis" because it's basically a hypothesis that the Turing machine itself is Turing complete. EDIT: What I mean to say is that the hypothetical Turing machine is Turing-complete, but the actual Turing machine itself is not proven to be. This is why it's impossible to prove that a physical language such as Python is Turing complete, because it can not compare to a hypothetical abstract machine as a physical language itself. From another answer online: "However, a strict definition of Turing Completeness implies infinite storage capacity, which is of course not physically possible. Given this, no physical machine can possibly be Turing Complete, but this constraint is usually relaxed (at least informally) when ascribing Turing Completeness to a programming language. One trivial test of Turing Completeness for a language is whether the language can be used to implement a Turing Machine simulator."
Precisely, Armin had thoughtful, actionable issues with Python3 back in the 3.0-3.2 days. Actual problems that needed solutions. He described them carefully, by and large resulting in them being fixed. Python 3.4 was much better for it. This second article is important reading, so much so that I almost wish he'd edit the first one to include a link at the top and the bottom. We should all be so lucky to have criticism like that.
This a fair point - it should be a standard feature - but part of being a good programmer is knowing which tools are good, and using them. I still see so many bugs that a good Python linter would catch. A while ago there a post where someone had typo'ed default as defalut, and had a bug any good IDE would have caught.
Where did you see "invoice" and "reports"? Only two templates are included at the moment, article and book. For an invoice template, you can create a new one as hinted at in the [quickstart guide](http://www.mos6581.org/rinohtype/quickstart.html#creating-a-custom-template). I think the documentation may not be complete enough yet to be sufficiently helpful for this use case. You can however look at the Article and Book template source code to learn how things work...
SimulateME! FondFondler 
This is fine for simple examples, but usually the bytes/text errors happen deep in some call stack in some ~~coffee~~ code you didn't write 
Try /r/bigseo, you'll get a better response in there.
Lots of people get upset the way Zed does. The ones that base arguments in fact and reality are the ones we should pay attention to. Zed gets off on being controversial and stirring shit up. He doesn't have regard for facts if it means he can be angry.
Yup. And then you have some expression that involves 4 strings and you get the error message "string cannot be blah", but you have no idea which string it is. I think there has to be some way of letting the user know which operation went wrong and not only which line it was.
I *don't* like Eevee, but even so this article is of course pretty much inarguable. There is no reasonable argument for not using Python 3 (or writing cross-compatible code) beyond compatibility with things like Twisted or working on legacy code.
actually turing-completeness is so easy to accidentally achieve that whole type systems have to be specially designed to avoid making them turing-complete, e.g. C++ templates vs Hindley-Milner.
Here is a [comparision of the two editions](https://www.jetbrains.com/pycharm/features/editions_comparison_matrix.html) showing what you get for paying.
 # -*- coding: utf-8 -*- from __future__ import print_function from __future__ import unicode_literals print("This works perfectly! {smile}".format(smile="😊")) Not an argument to use Python 2 instead of 3, by the way, just a reminder that Python 2 can be pretty great too. Cross-compatible code is even better.
I'm so confused. What on earth is "Turing complete"?
I'm going to do a web scraper to get some data off reddit, a couple of subreddits. I'm very new at this, but I found a couple of nice tools. There is some data I really want to look at.
That's cool but obviously it does not solve the problem. ASCII and UTF are character encoding, Noto is just a font family.
 True == 1 == 1.0 This has nothing do with it. class MyThing(object): def __eq__(self, other): return True {True: 'maybe', MyThing(): 'nope'} # returns as written However, what's really happening is that `True`, `1`, and `1.0` all *hash* to the same value -- that is 1 (because ints hash to themselves). class MyThing(object): def __eq__(self, other): return True def __hash__(self): return 1 {True: 'maybe', MyThing(): 'nope'} # I got {True: 'nope'}
&gt; Currently you cannot run Python 2 inside the Python 3 virtual machine. Since I cannot, that means Python 3 is not Turing Complete and should not be used by anyone. ...yikes
A six-year-old ticket already exists here: https://youtrack.jetbrains.com/issue/IDEA-63201 edit: [It's being worked on.](https://youtrack.jetbrains.com/issue/IDEA-63201#comment=27-1525388) Goal is for 2017.1.
But Python 3 will kill python! You know, the way perl6 killed perl by having everyone migrate to the new version so it was well supported and got bug fixes and community attention! Oh wait, no, it was the bit where everyone stuck to perl5 because eh, it was pretty good and perl6 was scary and let's just let the language die because moving to the new version is hard....
He should say that instead of the mess he managed to babble.
Yeah, I hardly write any coffee these days :)
You can definitely tell what's on my mind this morning.
Least time I checked it wasn't called /r/learnpython2 either. There are very few good reasons for starting with python 2, and many better ones for learning python 3. To give credibility to source that demonises python 3 through its inclusion in the sidebar ultimately may discourage new programmers from using python. At this point Python 3 is the canonical Python version. Python 2 is firmly in the legacy product category. 
LPTHW has been losing popularly steadily in the /r/learnpython community for at least a year now, and the community as a whole is (I think quite rationally) leaning towards Python 3. This isn't so much a knee jerk reaction as the unsurprising result of an ongoing trend. One of the main purposes of /r/learnpython is to brings together the collective wisdom of the community so that new programmers can benefit from that. If the community as a whole believes in Python 3, and finds LPTHW a little backwards, then it shouldn't be on any list of recommended books - the community doesn't have faith in it any more.
how should the python interpreter underline your code? i dont get what you want. i am sure it would be possible to write some sort of vim extension that does the same thing, but how is this supposed to work as a language feature? edit: i think now i get it. python should check the whole codebase on startup for type issues? guido commented on that when adding type annotations. he mentioned that type checks should remain in external tooling. maybe there is some overlap here.
Really nice post :) Seriously, I'm a bit fed up with people complaining about Python 3. They should spend this precious time actually learning it. This would be better for the community at large. And honestly, how big of a leap is there between Python 2 and Python 3, when you compare it to, let's say, Python 2 and Java, or Python 2 and node.js? Shouldn't this be enough to convince most Python 2 programmers to switch to Python 3?
This is a very simple (homework) problem. The problem has five straightforward parts: -use a loop to track correct answers -Randomly generate an integer between 1 and 9 inclusive. -Print two of these integers with a 'x' between them -Receive some user input -Confirm that the user is correct (or not) and increment the correct answer counter If you don't know how to do any of these parts, you need to go find a beginner's python tutorial and start working through it. 
Yeah, intuitively python is obviously Turing complete because you can write algorithms in it. This is basically the Curch-Turing thesis, but it is not a formal proof.
since this obviously [exists](https://github.com/pocmo/Python-Brainfuck/blob/master/brainfuck.py), zed’s proven wrong.
In case you guys missed it, as I'm not sure how many of you may also be C coders, but Zed Shaw is the guy who said that the K&amp;R C book (written by the **creators** of C, Kernighan and Ritchie) had examples in it that were completely unsuitable and unsafe. Again, he cites string handling as his example (he has some issues with strings, this chap). You can see Zed's C rant [here](https://web.archive.org/web/20141205223016/http://c.learncodethehardway.org/book/krcritique.html). Tim Hentenaar picked apart his C book [here](http://hentenaar.com/dont-learn-c-the-wrong-way), with focus in part 11 on the rant itself. Makes interesting reading if you're a C programmer or have an idea what he's talking about. Long story short, Zed is an arrogant arsehole.
I think that don't knowing the difference between strong and static typing is a lot more worrying for some who writes guides for beginners.
It's kind of baffling to me that this debate is still even happening. I'm in the same boat. I make sure to maintain Python 2 compatibility for any OSS work I do, but honestly, it's a drain on time (and more importantly, it makes code less maintainable) and I'm not sure I'm anyone is benefiting from it enough to justify the work any more. Yes, two or three years ago third party library support was still sketchy enough that there was an argument for continuing to use Python 2, but it's simply not the case anymore. At this point, any half-well maintained projects support Python 3, and most of those that don't are already well along the path to bitrot. Every one of those projects is now doing extra work to maintain backwards compatibility, and the only people benefiting are large companies with large codebases who have too much inertia to make the transition to Python 3 internally. At least from an OSS standpoint, I'm not sure it makes sense for the community to keep supporting Python 2 for the sake of those companies.
To answer your question in your "P.S.", the best place to post Python programming questions is under /r/learnpython. It's written in the sidebar.
Thanks for outlining this in such a complete rebuttal. I am slightly at a loss for figuring out why exactly Zed has decided to double down here, as well as post such an inflammatory-response-inducing article. I am finding it hard to believe he's buying what he's selling. I am torn between him simply doubling down for his ego's sake and him going with the "any press is good press," just to get his name/book/site back into the spotlight. I am inclined to think this is purely an attempt to drive some traffic. Sure, a lot of the traffic wont be sympathizers, but who cares about them? He'll surely get some new traffic. Drama is great business. It's just unfortunate what it does to the community. 
Please also see my reply below – this result isn't caused by having identical hash values alone.
A language is Turing complete if it can compute all computable functions. What does it mean for a function to be computable? When people tried to answer this question in the nineteen thirties they came up with a couple of different models for computation most famously: General recursive functions, lambda calculus, and Turing machines. Turing machines are the most well known model, maybe because it is more operational and less axiomatic than the others (i.e. easier for programmers and other non mathematicians to understand). Or maybe because of Alan Turing's Hollywood status It was then proved, much to peoples surprise, that all these models could in fact compute the exact same set of functions and that this set of functions also seemed to correspond to those functions a human could compute following an algorithm. It was then agreed upon that it was reasonable to look on these functions as being the computable functions. Any other model is said to be Turing complete if it can also compute this set of functions. The easiest way to show this is to simulate a model already known to be Turing complete within the model. i.e. if you can write a program to simulate for instance a Turing machine in your language it is Turing complete. It turns out that, unless you try really hard to avoid it, if you design something that can compute things it will almost certainly be able to compute this set of functions. It also turns out that you can not design something that actually works in the real world which can compute more than these function, even if you try really hard (I don't know if this is/can be proven, or just based on empiricism). This makes it a quite good definition of "computable functions".
Talk about a community that can't handle criticism: this submission has more downvotes than upvotes - https://www.reddit.com/r/Python/comments/5efe3t/the_case_against_python_3/
It's a level of expressiveness of programming languages. All reasonable general-purpose programming languages are at this level, while many restricted toy languages (e.g., some languages without while loops and recursion) are not. Any language at this level can simulate any other language at this level. For example, you can write an interpreter for Python in C and vice versa. It is theorized that the higher levels of languages beyond Turing completeness cannot be achieved in the real world and are just mathematical curiosities. 
Do you mean to say that a logical proof of a system being Turing complete is not enough: to have a real proof, you need to actually show that the system can emulate all possible Turing machines? I guess that's somewhat valid, because a logical proof will be built on axioms that are unproven (cue Gödel). However if we start questioning those axioms, we might as well stop our line of inquiry altogether, as we would also need to question the validity of the idea of Turing completeness itself. So given that we are assuming the logical validity of the idea of Turing completeness, for any system to be proven Turing complete a logical proof is good enough.
The difference is that when Dijkstra argued, he thought first, and wasn't wrong. 
Thanks. Didn't know that was a sub. Have subscribed to them as well!
&gt; I'm now left wondering how many memory leaks I've left in my wake with this flawed understanding. So true :) That's why I like this dict expression example so much–it's super simple but leads down this deep, deep rabbit hole. Alright, now I just need to update the article with a bullet proof explanation of what's going on here. Thanks for your comment btw, I appreciate it!
~~The Turing Test~~Turing Completeness basically tests if the language is strong enough to write algorithms in and if it is, it is considered Turing complete. If a language is Turing complete, then you can write any algorithm in that language. It is laughable that anyone is even suggesting that Python 3 isn't Turing complete. The only common "language" that I can think of that isn't Turing complete is Regular Expressions (I'm not considering HTML, XML languages here although [CSS may be considered Turing complete](http://stackoverflow.com/questions/2497146/is-css-turing-complete)). See: https://en.wikipedia.org/wiki/Turing_completeness Edit: brain fart - not the turing test
So you believe that people who would benefit learning from his book are not smart enough to make up an opinion of their own? I have turn many people to his book to get them up to speed on python and then none of them had any issues moving over to python3. Your request makes a huge assumption that by people learning python 2 is a bad and horrible mistake. Mistake that only you and others can fix, since these programmers who would read the book are not smart enough to do. Censorship like this based on ones own opinion is dangers. I am using python since 2.2 and since then I noved over to 3.5. Didn't need any knight on a white horse come to my rescue with censorship of a good book. But probably you have written a good python 3 book and that's why you call for such a drastic action. **Can I have a link to your book?**
I got started with Python using LPTHW, and as a complete noob to programming I took everything Zedd said as the definitive take on all things Python. It took me a really long time to change my opinion on Python 3 and I didn't really understand why so many on Reddit were against Python 2. So yeah.. probably best to leave that book out of the side bar. 
&gt; For those kinds of minor issues you have compiler switches. That isn't different from calling /usr/bin/python2 or /usr/bin/python3 where it is appropriated. &gt; And if that fails you can simply compile that piece of code as C89 and link with the rest of the C11 program, as the language doesn't even matter, being ABI compatible is enough. Fair enough. &gt; In the case of gets() you might of course want to actually change the code, as that function is just plain evil. `gets()` is just an example, I mean, while C is more backwards compatible than Python between versions, it still has sufficient differences that a program write in one version will not compile in a newer one sometimes. &gt; With Python on the other side you don't have that kind of compatibility at all, you must convert all Python2 code to Python3 code or it won't work. It would have been nice to be able to compile old Python2 to Python3-byte code or something like that. I don't understand why that hasn't been tried, most of the language changes are just syntactic sugar, but don't change the underlying semantics. This is described quite clearly in Eevee's article. Of course it is not impossible to do, however it does seem to be more work than the possible advantages that it brings. BTW, python-future offers a [`autotranslate` module](http://python-future.org/quickstart.html#python-2-only-dependencies) that allows you to import Python2-only dependencies in Python3. However it seems highly experimental, and I don't know if someone actually uses it in production (probably not).
&gt; I don't like Eevee why is that
Went ahead and added the magic encoding comment to clear up any confusion.
Of course, can you really take an article seriously when someone says that a programming language is not Turing complete? There is real problems with Python 3, however no one is really described in Shawn's article.
Thank fuck. It shouldn't have taken that blog post to remove it, though.
&gt; can you really take an article seriously when someone says that a programming language is not Turing complete? Yes, because I understand hyperbole. Anyway, I would have formulated that criticism as lack of backwards compatibility.
None of which is a dynamically typed, slowly interpreted language (Java has excellent JIT compilers).
I tend to avoid the plugins. Same thing about copying things into my vimrc without knowing exactly what it does.
huh, twitter says “she” too. i could have sworn that it was “he” some time ago. well, no matter. and yeah, i completely missed your parent comment’s start.
In all fairness, more than a couple years ago, third party library support was bad enough that Python 2 was probably the right choice for most people. Zedd stated the case a little more strongly than was reasonable, but he wasn't fundamentally wrong back then. Now he's just kind of gone crazy though. The actual good arguments he had have evaporated, but for whatever reason he refuses to change with the times. It's weird. And meanwhile, LPTHW is just starting to seem kind of dated.
I agree with your sentiment but "The Turing Test" is not a test for completeness: &gt; _"The Turing test is a test .... of a machine's ability to exhibit intelligent behaviour equivalent to, or indistinguishable from, that of a human."_ https://en.wikipedia.org/wiki/Turing_test 
Hyperbole implies at least some small amount of truth to exaggerate. Python 3 is not closer to not being Turing complete than Python 2. Wether the Python 3 VM can run Python 2 code or not has **nothing** to do with Turing completeness of anything.
See my answer to OP
What a load of horse shit.
I really used to like Zed years ago when I first heard of him. He seemed like a slightly grouchy engineer who has been burnt by bad tutorials one too many times who was trying to save others from the same growing pains. It seems as if his ego has inflated to comical proportions. His article made me cringe. There are too many fallacies and false comparisons to count, aside from the fact that he insults the hell out of the creators of the project that helped shape his writing career. What an embarrassment.
&gt; Hyperbole implies at least some small amount of truth to exaggerate. The truth he's exaggerating is that Python 3 developers don't want easy interoperability with Python 2 code, in order to force people to switch completely to the new, incompatible, language.
What string libraries exist for C or where can I read more about them? 
The book sucks in my opinion. 
Hey, I wrote a [turing machine emulator](https://github.com/evanandrewrose/turing-lang) and a [conway's game of life implementation](https://github.com/evanandrewrose/pygame-conway) in py3 when I was in college. I knew these would come in handy some day!
What makes me upset with one of the point is that we should only use ASCII. From someone who has learned several programming languages I always hated ASCII because it was used in the 80s and 90s and was a pain in the butt to use with language than English. It was quite happy to learn that unicode was invented to introduce other languages than English. In a country where English and French are being used on a regular basis this makes programming easier now than in the past. As for the print function I don't see the problem with tagging 2 parentheses to print a set of characters. Most of the editors will do it automatically for you. Even the printf function in C uses parentheses as well. What is the big deal. I still use Python 2 right now but I will switch over to Python 3 as most modules that I use have switched over. I could bring other subjects in the discussion but I like the way Python is going with unicode. 
It's called Brainfuck because it's seemingly impossible to read by humans, which is an important job for real programming languages. From the perspective of the computer/interpreter, it's much easier to understand (and therefore write an interpreter for) as [it only has eight operations](https://en.wikipedia.org/wiki/Brainfuck#Commands). It's practically just assembler code without all the semi-English names given to the commands for readability.
&gt; Currently you cannot run Python 2 inside the Python 3 virtual machine. Since I cannot, that means Python 3 is not Turing Complete and should not be used by anyone. Zed...oh Zed... I never realized you were stupid enough to write something this dumb.
So should I start learning 3 and stop listening to Zed? I've been debating the switch for a while now and Zeds curmudgeoness has been the driving force so maybe I should stop listening to him?
There was a [comment from another sub](https://www.reddit.com/r/badcomputerscience/comments/5egg0r/python_3_is_not_turing_complete/dad3rck/) that I think explains it. He's mad because he doesn't want to (or doesn't know how to) rewrite his guide for Python 3. It's like a kid throwing a tantrum because he has to redo his incorrect homework.
I think you actually nailed it, and I feel like I made a noob mistake on the highest order 
&gt; Done. (I think we left edit access open, actually, but yeah.) &gt; &gt; Zed Shaw might just be the most stubborn person ever to write a line of code, and there's a LOT of competition there. No offense but I honestly can't believe it took you guys this long to remove his book as a learning resource from this sub. It has an incredibly toxic mentality that his way is the only way despite him being stuck a decade in the past. And I don't even think it does that great of a job at teaching Python to people who read it
Back in 2011 even Raymond Hettinger was recommending against using Python 3 in production, so I'd take that article with a grain of salt.
 
Wow. That whole Twitter page is just *covered* with the hallmarks of someone who only understands that being wrong is the second worst possible thing a person can do, while admitting that you could be wrong is the worst possible. ([Claiming the thing about 3 not being Turing complete was a joke?](https://twitter.com/zedshaw/status/801827159157243904) Backpedaling is for winners, I guess.) I'm concerned that this guy actually gets listened to in the first place, let alone has a full-time position as a programmer in the real world.
The book is not just stating 'I like 3 more than 2'. It's giving false reasoning and using scare tactics to convince people new to Python that 2 is good and 3 is garbage for completely false reasons. 
Copying my comment from elsewhere: &gt; That bit is clearly facetious. He's saying that the devs claim it's impossible to run python 2 code from python 3. Now, the only way that could be literally true is if python 3 were not Turing complete. Therefore, the python devs are claiming python 3 is not Turing complete. This is Zed's way of calling them liars. &gt; Of course the devs' real reason is that it's hard, not mathematically impossible. But if they were claiming it were literally impossible, Zed would have a point. It's not impossible, just hard, and the debate is really about whether it is hard enough or useful enough to have been attempted.
You could make a numpy array that uses that area of memory as its buffer: https://mail.scipy.org/pipermail/numpy-discussion/2010-September/052953.html In Linux, your target process would have to be a fork of your python process to have access to that memory I believe. Not sure about windows.
This is what it says: &gt;A programmer may try to get you to install Python 3 and learn that. Say, "When all of the Python code on your computer is Python 3, then I'll try to learn it." That should keep them busy for about 10 years. I repeat, do not use Python 3. Python 3 is not used very much, and if you learn Python 2 you can easily learn Python 3 when you need it. If you learn Python 3 then you'll still have to learn Python 2 to get anything done. Just learn Python 2 and ignore people saying Python 3 is the future. I don't consider this to be scare tactics. It's a point of view. For instance, Macs come with Python 2 preinstalled. Most Python code I come across still now is Python 2 although Python 3 compatibility has improved a lot recently. I wouldn't censor the book because it supports this practical standpoint. If someone learnt Python a few years ago, learning 3 instead of 2 would have been definitely a practical problem. There's an argument for learning both still.
&gt; Which has nothing to do with Turing completeness what so ever. You need to read the article carefully. He's replying to Python core devs who said that it's not possible for the Python 3 VM to interpret Python 2 bytecode. The only way this would not be possible is if Python 3 wasn't Turing complete, right?
My first thought too.
But that's not a truth, it's a conjecture and stunning that it's the case by making up crazy conspiracy theories and hamstringing yourself by making statements that a third year cs student will know are false is stupid, even if you are right.
This statement is incorrect, just like Zed's. If you're looking to understand more about Turing completeness, go ahead and continue to ask questions, and check out a book on theory of computation. But don't make false assertions like "Turing completeness is impossible to prove".
Appenlight. See the clone-url in the middle of the screen: https://code.rhodecode.com/rhodecode-appenlight 
Python 2 support is getting cut off in 2020, you're learning something you know will die and be replaced, this is harmful to beginners because they have absolutely no good reason to learn Python 2 unless they are already a programmer in another language, in what way is Python 2 better than Python 3 for a beginner, all the good libraries have migrated, they have no need to edit existing applications, they do not want to spend years learning a programming language for it to be abandoned as soon as they start to get the hang of it. The reason it is censored is because beginners don't know any better, they'll just follow the book's instructions without consideration, much better for them to learn Python 3 and discover this book later on by themselves when they know the pros and cons, if transitioning from 2 to 3 is easy as the book claims then it would be just as easy vice versa.
One interesting thing to note is how his Python 2 and Python 3 examples is that are slightly different. In Python 3 he does `bytes("hello", 'utf-8')`, and in Python 2 he does `bytes("hello")`. If he had done `bytes("hello", 'utf-8')` in Python 2, he would have gotten the following error: TypeError: str() takes at most 1 argument (2 given)
There's so much wrong with Zed's rambles that I missed that. 
&gt; Yes, two or three years ago third party library support was still sketchy enough that there was an argument for continuing to use Python 2, but it's simply not the case anymore. At this point, any half-well maintained projects support Python 3, and most of those that don't are already well along the path to bitrot. Most machine learning libraries are still on Python 2 and it is infuriating. Well maintained stuff from Google like Tensorflow refuses to switch to 3 despite being a relatively new library.
~~Still on the wiki, last I checked though.~~ edit: spoke too soon. looks like the comment I got right after yours was the mod removing it! 
He always seemed this full of himself to me. I get that his target audience was not programmers, but his entire book is full of "You're going to mess this up, so just CTRL-C and CTRL-C the code and it will still not work. Think pensively about how stupid you are and then try again because you clearly can't get it right." He spent more time being condescending in his book than actually trying to teach anything. And he always glossed over useful, important, and fun to know information
[Zed is dead!](https://www.youtube.com/watch?v=y7Yp2L6c2KM)
English can not be written entirely in ascii either. Try spell café , naïve or née with only ascii characters (you could even argue that the limitations of first typewriters and then computers played a major role in these words losing their accents or even just falling out of use in some cases).
First of all, you may want to look in /r/learnpython. The way `and` works is, that it returns the second value if the and evaluates to `True`. Since a non-empty array is truthy, the second non-empty array will be returned. If you were doing `b and a`, the result would be [True, False] [Edit]Solution which does what you expect: `[ele1 and ele2 for ele1, ele2 in zip(a, b)]` -&gt; [True, False] Edit: Or: `or` returns the first truthy value (if there is one) Example: print([1, 2] or [2, 1]) -&gt; [1, 2]
Actually, `and` does not inspect the contents of an iterable. &gt;&gt;&gt; a = [1, 2] &gt;&gt;&gt; b = [3, 4] &gt;&gt;&gt; a and b [3, 4] You're getting `[True,True]` because both variables are truthy (they are non-empty lists). The correct expectation would be `True`, actually, but ([from the docs](https://docs.python.org/3/reference/expressions.html#boolean-operations)) &gt; The expression x and y first evaluates x; if x is false, its value is returned; otherwise, y is evaluated and the resulting value is returned. The evaluation of a list is the list itself, and that's the result.
Yep. Actually, 1/3 of English words are of French origin.
Is it really such a big deal for you? It makes things more consistent, too.
I don't think I would be asking if I didn't feel it was a hinderance to my adoption of Python 3. 
`from __future__ import print_function` and use the same syntax on Python 2 as well, so you don't have to switch.
I'm completely aware this exists and it doesn't really help. It forces adoption of the syntax but that's not really what I'm asking. Switching to Python3 completely would achieve the same thing but I would still be annoyed by writing out the parens. 
Yes, implying that the volunteer development team has sinister motives as part of conspiracy (Zed) stands in contract to measured, measurable, constructive criticism (Armin).
Are you also annoyed by writing out parentheses for all function calls?
Nope, just print because I write it out much more than other functions. I've spoken to other developers who share this same gripe. I'm asking how people get over it or ease into it, not just jump into it. 
Compared to P′′, it's friendly! Also, it's implementer-friendly: parsing and tokenisation are trivial, as is implementing the interpreter. I wrote a 260-byte-long one in ARM assembly language back in the '90s just for fun. Coding anything in Brainfuck, well, that's another matter!
What kind of code are you writing that uses `print` so extensively?
Do you mind if I quote this elsewhere on Reddit? The question gets asked a lot on /r/technology and this explanation is basically perfect ELI5 material.
that would be because old C code is still compile-able with the new compilers and will run exactly the same (save some edge cases because C is weird that way). Py3 is a new runtime meaning old Py2 code won't run on it (unless written in a specific way). this in one of the few valid criticisms of Py3.
Get a time machine, get into the habit of using `PrettyPrinter` from the `pprint` module for printing the things you want to show. That way you'll be used to saying something like `ppr.pprint(eggs)` whenever you want to see something, making it an easy transition into regular prints via muscle memory.
He's completely lost his fucking marbles. I don't think he makes a single correct point the entire article. The man is either senile, maliciously lying, on drugs, or flatly stupid/insane.
That statement is totally uncalled for. Surely one can make point without resorting to swearing, especially since there's nothing personal here.
&gt; English can not be written entirely in ascii either. That's a technicality, most native english speakers write these words in ascii (because they're terrible people).
there's /dev/mem 
It's more that English *can* be written with accents rather than it can't *not* be written with them - all of the words you mentioned would be considered to be spelled properly by most English language authorities when written without their accent marks. Contrast that with French, Spanish, Danish, Portuguese (or, God help you, Vietnamese), where writing a word replacing the non-ASCII characters with their ASCII equivalents would definitely be considered a misspelling. German is kind of a middle case - the umlaut can be replaced by a following 'e' and the ß by 'ss' and the word is still considered to be spelled correctly, but by far the most common spelling would be with the umlaut and ß. I'd hazard to guess the average German-speaker would find a spelling like "ueber" far more off-putting than the average English-speaker would find "cafe" or "naive". 
Thanks for this long response. I want to note that a number of big libraries in the scientific ecosystem have pledge to also stop supporting Python 2 by 2020. See http://www.python3statement.org/ and that Software Carpentry which teach python to a lot of undergragds, graduates and onfirm researcher has been really happy with the Python 3 classes (which go much better than the Python 2 ones), is not teaching Python 2 be default anymore and ha also said they will not have Python 2 material By 2020. So you are right that Python 3 is growing and if anything Python 2 is losing speed as a language to use for new projects.
Except that his comparisons are forth running Ruby and Fortran running COBOL. That doesn't sound like the same vm. And if the next thing you say is that he deserves respect and that you just have to understand how he's making the point and that he's really smart, if I have to trust that the author is smart and knows what he's talking about and I have to go in understanding what he means to get the article, then it's a bad article. It's badly written and doesn't support its point well, especially if it's ostensibly written for beginners and experts alike, as it claims.
He writes: &gt; Currently you cannot run Python 2 inside the Python 3 **virtual machine**. Since I cannot, that means Python 3 is not Turing Complete and should not be used by anyone. 
How do **WE** go about petitioning to get the book removed from the wiki?
FWIW, me and most others on this subreddit's IRC channel stopped recommending LPTHW years ago for pretty much the same reason for which it was now removed from the wiki. Constructive criticism of Python 3 is and should be allowed, but Zed is pretty much just bikeshedding while the rest of the world has to accept that Python will stop being supported 4 years from now. It is not a question of whether you want to make the switch, it is simply a question of when.
Oooh, i like this.
I am confused. Tensorflow definitely does support Python 3(.5).
Well, here's to hoping he does the same thing with our community!
Thanks for the explanation. It was difficult to get over it (despite it not coming from you) since I did not recommend anything irrational or unprofessional. I thought in the programming world we value logical arguments and rationality more than emotion. But apparently not so in this subreddit. In return to your comment: 1) certain people downvote whoever said anything positive about anything related to Zed Shaw, whereas those who expressed negativity and unprofessional words would receive upvotes. Is this how discussions and disagreements take place here? Just because somebody is wrong or annoying does not mean the mass becomes mob against this person. 2) If learning Python and learning the terminal the same time would be problem, then I would not have chosen to program at all. They are exciting challenges and not "problem" or I would not recommend myself or anyone to proceed with such mindset.
I like the new format over old percent way. I'm not sure about f strings but I'm sure I'll like them one day. I wish I could build a normal string and then turn it into a f string... That'd be very nice.
If this is a legit complaint, you'll hate almost any language... parens are pretty common in the majority. That said, depending on your editor, look into "snippets", "live templates", or similar names. You could type `p&lt;tab&gt;` and it expand to `print(|)`, where | is your cursor location. Snippets are much more powerful than this even shows.
Only 9 down vote in 5 hours? Glad I am not the only one who feels this kind of censorship is bad :))
Apparently already done
"Guido van Rossum tempted Eve to eat the forbidden fruit of Python programming. Now I see everything clearly."
What are you talking about? Dijkstra's work is still used as the foundation for many technologies we use today. The internet wouldn't exist without him.
&gt; The latter (`.format()`) is easier to read and therefore more pythonic. See I disagree with that. I have to make a dictionary that I don't have rather than doing something like `'x={x} y={y}'` % (y, x)` where the code is smart enough to see that I wrote the variables backwards. &gt; You can use either with Python 2 and Python 3; `.format()` was introduced with Python 2.6. The new incompatibility are f-strings. I know. I think f-strings are great, but I can't use them because I support Python 2.7.7+. It's `.format()` that I find hideously verbose. &gt; There should not be three ways to format strings, you're correct. It's not pythonic. I don't actually mind that. If it's useful, keep it. There's also now going to be 4 methods if you include `str.Template()`, which I just learned about today. It's older than `.format()`. I just want something that's terse and clear. &gt; All of that aside, if you're concerned about performance, use PyPy. Unfortunately numpypy, scipypy, matplotlibpypy, PyQt5pypy, and VTKpypy are not a thing. PyPy uses a very restricted set of Python. Shoot, it doesn't even support past Python 3.3. Python 3.3 is about to be lose support in numpy; it's old.
I just checked and it did start supporting 3.5 at the start of the year. Thanks!
Sure but at a certain point it stops being relevant. Just because I might live in the States I don't need to know what Lincoln has to say
scikit-learn supports Python 3. BTW, check this: http://www.python3statement.org/
Thanks for the lengthy reply and this was mostly what I was getting at that the Turing machine has infinite memory, while a Python program cannot have infinite memory, so it is a bit of a problem mapping from an abstract idea to a concrete implementation and saying they are the same. 
I can accept that certain fields need to know the stuff but in general you definitely don't need to.
&gt; I'm teaching python 3 to anyone who wants to, no charges, but will be glad if you teach to others. &gt;Today is the teachers day in Turkey. Many of my students thanked me. Thank you very much.
I'm looking at something much more complex than that. I want to find a project root regardless of where the script is ran from, and regardless how deep above a project root might be. 
So you have a machine with infinite memory? The way people are proving Turing completeness it sounds like they very first thing is to assume the machine has infinite memory. It is a huge hand waving for a mathematical proof. Seems half of the replies are that since Python can do loops that proves it is Turing complete.
Right, tuples require a clunkier syntax to be safe, and that's obviously problematic. I talked about this and the non-Pythonic nature of string formatting in the blog post above. As ridiculous as it sounds to introduce a new standard (incoming XKCD), I really hope f-strings can replace the other styles altogether for new code. Probably a bit too hopeful, though
I prefer 2 space.
http://web.archive.org/web/20080103072111/http://www.zedshaw.com/rants/rails_is_a_ghetto.html I think you are referring to his 'Ruby is a ghetto' post. It's real demonstration of a lack of any self-awareness. Makes his Python post look kind of tame.
So the proof is just to show that a Python program can simulate a Turing machine? It seems that can just be proven by showing the language supports recursion and variable storage? Yea, I was confusing it with the halting problem by the way as well, thanks for pointing that out.
Nice work, thanks! Was browsing on my iphone and you should know that it's not easy to read. The sidebar scales proportionally as I pinch-zoom and the main bar never reaches readable size unless I use Safari's Reader mode. Best to use a media query to hide the sidebar for all phone width screens.
Thank you! Yeah, I hadn't tested the sidebar on mobile in a while and just saw how bad it looks. I'll try to get that patched up tonight. Thanks again for taking a look!
Ah gotcha, I did not realize that proving Turing completeness is so trivial as most people have told me by now. I am surprised it is as simple as showing the language has recursion and variable storage and that counts as a rigorous proof though. I think in my head I was thinking of the halting problem which needs to run on all possible inputs to show that it will halt/not halt. What I meant earlier by "physical" was that the proof involves creating an actual implementation that runs on a computer, whereas the universal Turing machine is a abstract concept... I am still a bit unclear how actual program or proof can map to an abstract concept like that. If the Python language was a purely abstract language with no implementation, then it would be more clear to me.
&gt;Most machine learning libraries are still on Python 2 Anaconda has a python 3 version so I really doubt that is actually true. Plus, as mentioned below TensorFlow is also adapted to Python 3.
Don't live under a rock. Most projects follow 4-spaces, only tensorflow related projects (and other google projects) use 2 spaces. Take a look at the top 50 most downloaded pypi packages; all of them use 4 space indentations.
Tab anyone?
Tabs vs. Spaces - Flamewar in 3 ... 2 ... 1
Wait, no. A tab is a single character. Four spaces are four chars. You use 4x memory with them. And you indent a lot.
&gt;[**Tabs versus Spaces [2:51]**](http://youtu.be/SsoOG6ZeyUI) &gt;&gt;Silicon Valley - S03E06 &gt; [*^freakpants*](https://www.youtube.com/channel/UCf6N1JKxxV3S3l8eJESHOiA) ^in ^Gaming &gt;*^192,868 ^views ^since ^May ^2016* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Can you give a tl;dr of the algorithms/libraries you used to accomplish this?
I started with Python 2, and moved to 3 almost as soon as it came out. From what I saw it isn't even that different, probably the biggest changes are print needs parenthesis, raw_input and xrange aren't a thing, strings are now in Unicode, and [some back end changes](http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html) (all of which are better things) Personally I think it is way better, and has added some cool new libraries for handling IP addresses, new generators, and performance improvements.
Sure, but the point is that what kills languages is lack of adoption of version n+1. In perl's case, there were indeed genuine issues moving to 6, but the biggest issue was the feedback loop where perl6 didn't do much because nobody used it because it didn't do much .... Python3 doesn't have the specific issues of perl, but you can see the same "people won't use it because the libraries aren't ported because people don't use it ..." loop which is fixed by people using it and porting libraries. 
If this is indeed a typo, please change it, it is confusing.
You can continue to argue, and if I had the patience and time, I could educate you, but you can educate yourself by searching for stack overflow questions about Turing completeness, and even browsing Wikipedia. Aw what the hell, I'll indulge a little longer. Turing completeness of a programming language assumes infinite memory. So yes, loops and infinite memory generally give you T-completeness, though it depends on the specifics. 
Too bad they didn't make it in time for Debian's Stretch freeze.
You can still handle unicode properly in Python2. Python3 just forces you to do so.
I just finished mine with Pyqt!! I used vlc to do the audio but I know there is a photon extension to play media in PyQt. I honestly don't know much about about pyglet but pyqt is a good GUI and has QTCreator which makes the beginning design very quick.
All I know is that occasionally when I am googling around looking for solutions to some 2.7 code I am working on I see some snippiness about how the OP really should be using python 3. Did not realize there was a war going on. 
Pyglet isn't really a gui library, but if you are keeping the GUI very minimal might be OK. As well as pyqt you might consider kivy, it also supports android giving you a route to mobile.
&gt; Just because I might live in the States I don't need to know what Lincoln has to say Oh. My. God. Yes. You. Do. You cannot understand the present or the future unless you understand the past. You will be doomed to repeat it. 
By the time you explained the problem via Skype, you'd have already spent your huge $200 budget.
It's also not a knee-jerk response because I've read suggestions in this subreddit to remove LPTHW from the sidebar and wiki every week for over a year.
There is so much more to `import`. https://www.youtube.com/watch?v=0oTh1CXRaQ0
If you're gonna Reddit, you should try to get used to downvotes. They happen, move on.
I didn't like the lack of backwards compatibility and am still a little annoyed by the cavalier attitude behind that choice; but zed shaw's arguments are thin and shrill.
Yeah, that's why we don't teach addition in math anymore. Shit's moved on. I'm not sure what field you think Edison is relevant to, but in EE, we go back before Edison to Ohm and Faraday because to understand the field you need to learn the underpinnings. Even if you don't write compilers, you use state machines, and if you don't understand them, you probably use them badly. Ditto Boolean algebra. "Why are we doing this? I think that some of the biggest mistakes people make even at the highest architectural levels come from having a weak or broken understanding of a few simple things at the very lowest levels. You've built a marvelous palace but the foundation is a mess. Instead of a nice cement slab, you've got rubble down there. So the palace looks nice but occasionally the bathtub slides across the bathroom floor and you have no idea what's going on." -- http://www.joelonsoftware.com/articles/fog0000000319.html
Yeah... He sounds a bit... Unstable?
It's like November 8 never happened. I want to live in that world!
The fact he kept referring to strings as statically typed in python 3 is just one of many hilarious things about Zed's post. This is a really good rebuttal.
You're wrong about words in Germany “still being considered to be spelled correctly” with “ue” and so on. You can only replace those when there's no possibility to spell it correctly (e.g. in the codes on official ID documents) Otherwise it's definitely wrong and weird.
You can build a normal string and turn it into an f-string - using the `.format()` method! That's pretty much the difference between the two. Use an f-string if you have a static string literal and you want to put text in it. Use the `.format()` method if you have obtained a string from somewhere, and want to insert specific values in.
While I agree broadly that the Python core devs have screwed the pooch with Py3 (and are in no hurry to clean up the mess they've made), I honestly can't agree with a single one of his arguments. Hell, many of his arguments *against* Py3 are things I consider arguments *for* Py3. I don't believe his &lt;30% stat, but I also don't believe JetBrain's stats. They're based on PyCharm users, which isn't exactly a majority of Python devs. What's more, the stats are dominated by web developers, which is a group for whom Py3 is *unquestionably* better. They are almost entirely shielded from Py3's problems by the frameworks they're using (whose developers have dealt with Py3's all-text-is-Unicode shitshow for them) and by the fact that webapps run in carefully-controlled environments. Py3's changes also haven't killed Python. But they *have* killed Python for a certain class of program for which Py2 is eminently suitable, namely UNIX command-line-oriented programs (and other bytes-oriented stuff).^* Py3's fundamental fuck-up vs Py2, IMO, is that it not only insists on treating all text as Unicode when we still live in a world full of strings of unspecified encoding (URLs &amp; HTTP, email, UNIX filenames), but is so fundamentalist about it, it just doesn't give you the tools to work with encoded strings or undo its magic decoding when it's picked the wrong encoding. What I think *is killing* Python is that the core devs are sticking to the GIL, which makes Python (2 or 3) a second-class citizen in a world where even smartwatches are multi-core. IMO, the core Python devs definitely fucked up in making Py3 incompatible with Py2 without offering any substantial benefits. If you have working Py2 code, there really isn't a lot to be gained by porting. This has been, IMO, the major reason for the slowness of adoption amongst seasoned Py2 devs. Py3 is a much more newbie-friendly language, but offers at best trivial benefits for experienced Py2 coders (and is in many cases a total PITA). So Zed might be right in that regard, in that developers faced with re-writing their projects to support Py3 may well decide there's basically bugger all benefit in re-writing *working* Py2 code for Py3, whereas re-writing in, say, Go may bring a 10-20x speed-up *plus* the ability to use multiple cores. Certainly, as someone who mostly codes the command-line programs that Py3 is unsuited for, I'm starting a lot of new projects in Go, seeing as my weapon of choice—Py2—has been EOLed. ^* The UNIX command line is basically bytes. Py2's text model is also the POSIX text model, so it Just Works with other POSIX tools, like `find` or `grep`. You have to fight Py3 all the way to get correct POSIX behaviour. Py2 is also largely insensitive to environment settings, and will keep on chugging in situations where Py3 dies in flames, like SSHing to a machine that doesn't support the locale set on your *local* machine.
I'd wager that if all the devs who hadn't read the basically archaic articles and books did, then the landscape would be wildly different. I'm also going to say that it's cool that you can criticize the huge projects that have that shaky foundation, because without that foundation the projects might not exist in the first place. Hard to argue one way or the other without examples though. I don't need to write perfect code if it never gets to the point where it matters. Theoretically I'd take the time to write absolutely bug free code but I don't have the time or the patience. 
Think of a boss who gives tasks to his workers, which can only be done by one worker. By default, he gives a single task to a worker1, then waits for worker1 to come back, and then gives any other worker the next task, for example worker2, and waits again for worker2 to come back, and so on. Therefore, if the boss has multiple employees the work will not be completed faster than in the case where he has one employee. AsyncIO allows the boss to give a new task to worker2 after giving a task to worker1, while worker1 is busy. Therefore all tasks are completed many times faster than before. In the first case, the time until completion is the sum of the time for each task. In the AsyncIO case, the time until completion is that of the task which takes the longest, as long as there are enough workers to give only one task to each worker. Threading is like multiplying the number of bosses(threads) to match the number of workers. This is, of course, inefficient since we do now have many bosses doing nothing for the majority of the time, while they wait for their assigned worker to come back. Back to IO. However, explaining a task to a worker also takes a little time, this is the analogy to CPU load. Once we have enough workers such that there is a queue of workers forming in front of the the single bosses desk waiting for the boss to give them their next task, it makes sense to increase the number of bosses as well. This will only be effective on a multicore CPU. A single core single thread CPU can only execute one thread after the other, and thus is effectively one boss doing the work of many bosses, who goes from one table to the next. We would rather have a beefy core i7 with 8 threads, resembling 8 bosses working simultaneously at 8 tables.
To be fair, I think he meant "more-strongly typed." There are many typos throughout the article that give me the impression that this was typed in a hurry.
The position of the Done.
Yeah, strong vs static are similar words, but that's a mistake I expect and understand on a reddit comment, not some long, authoritative post on why you shouldn't use something.
SimulateMe! BuffaloChickenReddit
&gt; What I think is killing Python is that the core devs are sticking to the GIL, which makes Python (2 or 3) a second-class citizen in a world where even smartwatches are multi-core. This has nothing to do with Python 2 or 3. This is an implementation detail of CPython. You're free to write your own Python implementation if you think you can do better. Personally, I would suggest putting effort behind a JIT like PyPy.
Well Lexy's response is just what Zed expected. No surprise. 
Ah, thanks for that. I knew it was somewhere in between the French and English examples, but I wasn't sure where on that spectrum it would be. 
While python 3 is definitely better, you might still run into problems splitting in the middle of a [grapheme cluster](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries) if you use a naïve approach.
Just for the sake of argument, Ruby (MRI) and JavaScript (V8 which Node uses) both have a GIL too and seem to take a lot less flak for it. It's definitely an area were Go, Erlang, and Rust are stronger though (and Java/ObjC).
It's been available in both EL (RHEL/CentOS) and Ubuntu for basically the whole lifecycle of Py3 so far. Ubuntu 16.04 actually went further and Python 2 is not included in the server base install anymore (but Py3 is).
Going through Shaw's article, I can't tell if he's purposefully being stupid, or if he's a factory reject, cast aside from common sense. A bytearray is not a string. You should not be able to throw those together. Bytearrays are for bytes. As someone that lives in a country where common names have characters not included in ASCII - fuck off.
I'm still using 2.6 since I'm stuck on RHEL6 &gt;.&lt;
From my observation around year ago there was a shift toward 3. I think it was triggered when 2.7 entered maintenance mode. IMO if Python did this sooner (like other languages usually do[1]) a lot of FUD would be saved. [1] For example Ruby had significant breaking changes in a minor version release 1.8 to 1.9. But people moved on, because they knew the 1.8 will stop being maintained.
And class logger: critical = print error = print warning = print info = lambda *a, **k: None debug = lambda *a, **k: print("Good luck!") (please don't do this)
Pretty sure RHEL6 has 2.7 in the repos. But yum will need 2.6
&gt; is that it not only insists on treating all text as Unicode when we still live in a world full of strings of unspecified encoding (URLs &amp; HTTP, email, UNIX filenames) You mean a world full of *bytes* of unspecified encoding, and that's why I like this new distinction being enforced. Yeah, it bumps up the timing of when you teach beginners the difference between bytes and strings. Good. This might be bad for bootcamps who crank out low quality cargo culters, but for actual education of beginners it's a non-issue. If you aren't working on toy problems, then the encoding guessing heuristics or assumptions are *guaranteed* to fail when used on real world problems. This is the hell I've lived in more than once and the best case scenario was to try and minimize the unnecessary failures. Now they can be completely eliminated, if you know what bytes are. I totally agree with you about the GIL, as well as the new pains trying to integrate with POSIX (but it's not *that* much harder). It was the right call to switch to Go.
I don't know about vscode or sublime but if your used to using Intellij why wouldn't you use PyCharm (assuming your asking about this for Python development since this is /r/python)? They are both by JetBrains so there are likely features in Intellij that similar in PyCharm. I'm certain that PyCharm has the feature you asked about.
 # no-op on Python 3.6, but please don't do this from collections import OrderedDict as dict If your dict needs to be ordered, use `OrderedDict`! In 3.6 this is implemented as an alias for regular `dict`, but this way your code will also work on other implementations and older versions.
Go for it, it really isn't that hard. The variables you need are: - 1 string containing the actual brainfuck program - 1 int containing the position in the program - 1 list of ints containing the cells that form the data storage - 1 int containing the active data cell being manipulated - 1 local int containing the indentation level when returning to the start of or skipping over loops.
I have both Intellij and Pycharm but their window system is kinda glitchy when used on multiple monitors
Take two async functions. Under CPython, you know only one of these functions can run at a time, because of the GIL. How does that code execute (and what considerations are there) when using an interpreter that doesn't have a GIL? 
I think you should not rely on system python. With many systems for example RedHat the system python is mainly there to support the system, and you don't want to rely on it, even if it's version that matches your current need, because if need change you'll be stuck with it until vendor decides to update their tools. Most of other languages (Java, Ruby, Perl, Go, Node etc) are not used by system, so the developers can use whatever version they wish to use. If you guys use RedHat or CentOS, I recommend to try https://ius.io/ repositories, the main difference is that they make packages that do not have name or file conflicts with system packages, so you can install any python version you want and be sure it won't conflict. In fact you can install multiple versions of python and use whichever version you want.
Every Python implementation has to have the same semantics. Even if the interpreter doesn't have a GIL, that must be invisible to your code.
&gt;Great programmers don’t defend stupid, they stamp it out and own up to their mistakes. ...
So if the code is no different with or without a GIL, what exactly is the issue? Wouldn't you still need to use the multiprocessing module the same way? Or would no GIL allows threads created from the threading module to run on different cores, and thus run simultaneously? 
That's the point of my first comment: there is no issue with the language and the "crackers"'s complaint about the core devs is misplaced. Some people dislike the GIL because it interferes with parallelization, but removing it causes other slowdowns, so it's not that simple.
I only speak english, and I'd rather have Unicode for all strings. A string is a string, I shouldnt have to think about bytes and encoding. If I need to care about the underlying bytes, that's what bytes() is for. 
RedHat officially supports 2.7 and several 3.x releases (though not 3.5+) on RHEL6 via the RHSCL program. It's a little funky to work with, but it does work and does get some level of support from the vendor.
&gt; I have to make a dictionary that I don't have rather than doing something like 'x={x} y={y}' % (y, x)` where the code is smart enough to see that I wrote the variables backwards. `'x={1}, y={0}'.format(1, 2)`.
The memory available to the process is not an aspect of "the implementation". If I install more memory, I am not automatically running a different version of Python. The point is simply to disregard memory limits when evaluating claims of Turing completeness, because they aren't practically relevant.
Only officially available at certain support levels. Unfortunately, our developer seats are self support, which does not even let you access the RHSCL repo &gt;.&lt; I have sideloaded it from CentOS a couple times... but eventually it's not worth the bother (we just use it for tools, our core code base is C and Java). 
I'm in the same boat. I only speak English, but I would rather use Unicode by default, so that I don't need to worry about the encodings. The earlier post was my best understanding of where the opposition comes from.
You have no scapy module that works in 3, forget it. I program on the stack. If you can't accommodate, I'm not interested. 
That's pretty cool! Now if you were able to add beat matching to match up similar tempos... hmm.. 
The author of this article says about Python's typing: "That means I do not have to know the type of variable to use it. " This is not really true. If the type of a variable is string, then you can't do arithmetic on it, because Python is strongly-typed (it's not statically typed, but it is strongly typed). Any programming language that fails to present beginners with strong typing is a bad language to start with, IMO; both Python 2 &amp; 3 share the same approach to typing. Personally, I enjoy coding Python 3 much more because of the fairly elegant type-hinting. I only use Python 3 for my projects, on Windows and Linux, and it's fine. There is hardly any stuff not ported to v3, as long as you're happy with 3.5, and why wouldn't you be. The performance improvements in python 3.6 seem very promising. The abstraction required to understand the difference between unicode strings and bytes doesn't seem very challenging to me: if you can't master such a basic abstraction, you will certainly struggle with modern programming in any language, including many other parts of Python. I suspect that it wouldn't even be an issue if you have never expected characters and bytes to be the same (after all, we are all quite happy dealing with numeric types which are abstractions of implementation details we mostly don't care about). 
and with the modern Internet even for English users you probably want Unicode else your precious Emojis will show up as mojibake :P
Perl 6 made a design decision that it would run Perl 5 code. That worked out well. 
DEVELOPER: Hey English speaking users, do you generally stick to ASCII characters? ENGLISH SPEAKING USERS: `¯\_(ツ)_/¯`
The idea that Python 3 is harder for newbie programmers is beyond baffling to me. My job got noticeably easier when I switched from teaching Python 2 to Python 3. The stuff Zed is talking about aren't issues for beginners.
What are you talking about? Zed's? or Eevee's?
&gt; The Python project's efforts to convince you to start with Python 3 are not in your best interest, but, rather, are only in the best interests of the Python project. This makes sense. Not saying it's objectively correct (who knows what's going on behind closed doors?), but that I totally get that as a reason But then. . . &gt; Ask yourself, why are they so keen on having you use a language that has only about 30% adoption, is constantly changing, and full of issues? I'd like to see the same adoption metrics for Node 12 vs 4+, ECMAScript 5 to ES6+, etc, using the logic he's using here. . . AND THEN I'd like to know what makes Python any different from any other language. I'm betting that anyone involved in an ecosystem would say that it "is constantly changing and full of issues." IOW I don't think the stated problems are any different than any other modern language. It's easy to stand in the walled garden and decry "python is busted".
You could install the following "python" plugin for vscode . https://marketplace.visualstudio.com/items?itemName=donjayamanne.python This supports searching through symbols in your project
Sorry it is a bit ambiguous. Zed's. Eevee's makes perfect sense.
Even if they do speak english and nothing but, I don't see how *anyone* can have escaped having user data entered containing U+2018 and U+2019, Microsoft Word's infamous smart quotes. The number of times I've had users paste a name like "O'Kelly", when what they actually pasted was "O\u2018Kelly"... if you think you're safe with just ASCII, and you have users pasting data. I promise you have some surprising byte sequences in your database that will make you go "oh god, what encoding(s) did I just accept in here?"
Still a massive overhead for the one-off point solution scripts I'm usually creating.
There is a full game project in the pyglet/examples/astraea directory, but I'm not aware of any related tutorial. I'm thinking that OpenGL primitives might even be a bit much for a tutorial. Not that they're hard, but the image and sprite classes are so simple that they might be a better start. 
Assuming someone who doesn't know Python will recgonize that the resource they're learning from is based on outdated ideas is silly. It absolutely makes sense to get rid of guides that are no longer as relevant to modern Python programming. Would you recommend they keep around old guides that teach Python 1 or Python 2.2? Someone agitating for Python2 only is several years behind the curve at this point. 
&gt; I don't agree. I'll have to say that since I'm not formally trained here I don't know how you can't (or can) agree with something you just don't know. &gt;Yes, there's certain cases where if you want to learn about how it used to be done Just because something was developed "many" years ago does not mean it is not used anymore.
I do Python 2 at work since we've yet to transition our product (pushing for it, but it'll take time!) but everything I write personally is Python 3 these days. No reason not to start everything new in Python 3. 
I'm an American and on plenty of occasions using 2.7 I've had problems opening CSV files where using "rb" fixed the problem. Fuck if I have any idea why I had to open the files using byte mode, and I definitely appreciate Python 3 being smarter about this kind of thing. It really does seem like the people who were fine with the 2.7 behavior and are actively pissed about the 3.x behavior just happened to be operating within the space of some exception to the general rule that made it seem fine. 
I'm surprise it took Zed this long from his Rails is a Ghetto rant. That's how Zed is. Nothing is ever his problem, "Python 3 is all propaganda but let me just vaguely use incoherent mumbo jumbo to fear you from using it". 
&gt; This document serves as a collection of reasons why beginners should avoid Python 3 as of November 22nd, 2016. What are you talking about?
PyCharm's SSH is too retarded to utilize connection sharing. I've also tried setting up a tunnel and then pointing PyCharm at that, but SSHD is too smart and still requests MFA for anything going through the tunnel so once again PyCharm is thwarted. It is entirely possible I fucked up the config (sshd, ssh, pycharm's ssh, plenty of failure points...) on both of those work around attempts, I'm not infallible. But I am fairly confident I was on the right track. Testing against a machine with MFA disabled worked without an issue so I'm leaning towards me being correct. 
Ugh; I frequently use 2.7+ features and don't notice until someone tries to copy my scripts to a VM with a 2.6 system python. Testing multiple versions with `tox` would catch this. But simple one-off single-file scripts are rarely tested so rubustly (worked on my machine!) then it comes back to haunt me months later.
The entire tone of that book is discouraging in general. Add to that the the stubborn conservatism, bad explanations, chaotic organisation, and weird prioritisation, and you have a learning resource that is just plain bad, whether you have a good reason to start in Python 2 or not.
I've been hoping that since I started learning Python 5 years ago, but still every second poster in r/learnpython seems to be trying to learn from this hacked together document. It's painful.
No clue where OP got 'Lexy' from, at first I thought there was some other prolific "eevee" I didn't know about.
On linux systems you can type `which python` or any other command to find out which executable is being run.
yeah I just use both
I'm not sure whether to make a product out of this or to open source it at this point. I will let you know as soon as I know
RHEL is a bigger one. Even 2.7 isn't a safe assumption in the corporate world. Apple is kinda irrelevant when it comes to deploying production code, and it's not the hobbyists who are clinging to 2.6. 
Funny thing is, when we're not stuck with a computer keyboard, even English speakers use non-ASCII characters all the time, like °, ÷, ×, ©, ™, ®, ½, …, →, ´, ¨, etc. (never mind emojis) You see these characters in print texts everywhere, we just don't use them on computers because they aren't (readily and universally) available. Granted, we can work around most of them with ASCII alone, but any of those symbols is probably more used in English print than the tilde, pipe, backslash, or caret (or the @, apart from email addresses). This English speaker looks forward to the day when ASCII is just a bad memory, and we can make use of our full set of symbols without fear.
I live in the US where ASCII is king and I still wholeheartedly agree with you
My one real gripe about Python 3 lately is how sorting changed. So, say I have a list of some custom object that I created that can't meaningfully be sorted by [].sort() or sorted(). In python 2, I'd write a short function that does the comparison and pass it as an argument to the sorting methods above. In 3, I'm apparently supposed to override up to six methods in the class and hope that that's the only way I'm going to have to sort my objects. There's a workaround where you can instead use a short lambda, but that really doesn't seem ideal. Honestly, the old way didn't seem broken to me, why was it fixed this way? 
&gt; Or would no GIL allows threads created from the threading module to run on different cores, and thus run simultaneously? Without a GIL those threads could run on different cores simultaneously. That's the goal the GIL'less Python versions are going for. In that case you wouldn't need multiprocessing. Multiprocessing just spawns a new process instead of a thread, but without the GIL, a thread will do just fine.
From https://www.tensorflow.org/versions/r0.11/get_started/os_setup.html it seems like python 3 is supported in tensorflow. Theano is also python 3 now, as is scikit learn. It's true that it took painfully long for the scientific community to migrate to 3, but it has really taken off lately. Maybe they @ operator in 3.5 has something to do with that. NB Google app engine is also coming to 3, but it's taking foreeeeeever...
Basically what you're saying is we shouldn't be teaching kids about basic addition in school, because we have new things like calculus, and economics. Or we shouldn't be teaching biology students about evolution, because it's old. Or physics students shouldn't learn about Newton's work, because now we have Einstein and Hawking. If you want to be proficient in a field you need to learn and understand the building blocks of that field. Sure, you know how to write some basic programs, but I bet you're only about 1/4 as good at it as you could be, because you have no idea how any of the tools you use got built up over time. You're clearly very ignorant about how important it is, because you've admitted you've never really looked into it. You really aren't able to properly form an opinion on something you know nothing about, considering you probably don't even know any of his algorithms, which could probably make some of your work a lot easier.
[He now says he was trolling.](https://twitter.com/zedshaw/status/801885519412006912)
Do you mean the name of the executable? I've always had the new one installed as python3. Is the Python project telling OS distributors to call it just 'python'?
Ruby gets a lot of flak for being slow in general. In JavaScript—I don't know if this is true in Node but it certainly is in the browser—you can't write code that uses multiple threads with shared memory, so the GIL doesn't matter. (The closest you can come to multithreading is Web Workers, but you can only communicate with them [via `postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage), and you lose access to whatever you post on the sending side. Not that the GIL in Python has ever affected me personally, tbh.
Well, I don't know about his books in general, but "Learn Python the Hard Way" is a mess (or exceptionally true to its title), and that article confirms why that's the case. 
Brew? Anaconda? Wtf
No it doesn't, the bubble chart can be made in matplotlib but the bubble chart on a map is not there. I think i'll have to import a separate world map and then overlay the bubble chart over the map. 
Armin specifically said that you shouldn't argue using his past views on anything that has changed since (e.g. Python 3).
Same problem as you. Python3 is fine except for the removal of the print statement. There is a work-around though: class Print(type): def __sub__(cls,*other): print(*other) class prin(metaclass=Print):pass if __name__=="__main__": prin- "HELLO WORLD" 
Even besides names, nowadays it's not uncommon to come across emojis and other non standard characters when web scraping or God forbid allowing user entry. 
What I'm saying is that I don't need to know about the dude who invented addition to use addition. I don't need to know the motivations about the man who invented addition because it's pretty well understood, thanks to the knowledge that person helped create. If you need to study specifically addition, read what the latest person has to say about it, not the person with literally the least amount of idea about it. He invented whatever, but then in the next 50 years other people came along and improved and grew the general body of knowledge. Our buddy D dog here was the first caveman to discover fire, why not look to more knowledgeable scientists who studied pyrotechnics their entire lives? Because it really sounds like you're saying he would know more and be able to help the reader better than the scientists who came after, and that sounds like bogus to me. Maybe he is a genius, and no one else can capture the ideas as effectively as the original authors but man do I ever not believe it. &gt;You're clearly very ignorant about how important it is, because you've admitted you've never really looked into it. Yeah exactly. I'm not saying it's good to be ignorant, but I'm saying that not knowing something isn't always required. In this case I'm specifically saying you should be learning relevant things. Personally, I don't know that reading anything he wrote would help me be better faster than reading something written in the last ten years. That's also why I specified that I didn't know what I was talking about specifically, to clear up where I'm coming from. 
It's easy to compile Python. I do this all the time. It has the advantage, you will be able to work with many different versions. 
Apologies, I wasn't trying to argue that his 2011 point remained valid criticism in 2016, but that I still have a great deal of respect for the effort he took in 2011 to clearly detail his concerns. In my mind it's the difference between constructive criticism and empty rhetoric. Armin was trying to start a conversation. Zed is trying to preclude one.
Things at work are a bit more complicated than that :(
You can absolutely debug a running program with gdb. In fact, you don't even have to start the program under the debugger, you can attach to any existing process. The ability to also debug a memory dump is just an added bonus, for cases where you didn't have the debugger attached at the time of the fault. But it's certainly not the only use case. 
FWIW I do all my dev work on a Mac. Homebrew is a necessity to begin with, and once you have that you can install pyenv and use it to manage and select any arbitrary Python version you want, without messing up the system Python. I keep around at least one virtualenv for each version of Python I support in my personal projects, to use in testing.
&gt; frameworks they're using (whose developers have dealt with Py3's all-text-is-Unicode shitshow for them) For what it's worth, Django went down this route *before* Python 3 happened. It was the right approach then, and still is the right approach now. &gt; and by the fact that webapps run in carefully-controlled environments Oh, my sweet summer child.
&gt; Django strongly pushed users towards using Unicode everywhere internally and only converting to/from bytestrings at the system boundaries Sure. That's always been the right way to do text in Py2 if you're really dealing with text. The problem with Py3 is that it makes it much harder to work at the bytes/string boundaries (it *really* doesn't want you to treat bytes as strings), which makes writing the *framework itself* hard (where all the HTTP IO is dealt with). It's no coincidence that one of Py3's long-standing critics, Armin Ronacher, is the author of a web framework. It's getting better as the core devs slowly add back some of the bits they ripped out, but you still have the problem of surrogate escapes, which are IMO harder to deal with than errant bytestrings in Py2, which is precisely what Py3 was supposed to solve. At least `unicode` and `str` are different classes in Py2; Py3 `str` objects containing surrogate escapes are neither marked in any way nor round-trippable. &gt; asyncio At this point, `asyncio` is still an inferior version of Twisted. The baked-in syntax in 3.5 is pleasant, but `asyncio` lacks features, is badly documented (even compared to Twisted, the poster child of bad documentation), and [so complex that it's really hard to get your head around](http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/). &gt; all the new shiny is being added to Python 3 So far, there aren't really any compelling new features (they should have based Py3 on stackless, imo. That would have made it a much more interesting proposition.) By all appearances, for many developers, Py3's new features don't outweigh its propensity to die in flames in situations where Py2 copes just fine. &gt; the fact that Python 2 is in maintenance mode Quite true. But that's also a "fuck you" to Py2 developers. Py2 developers have some very real concerns with Py3's currently half-baked text handling (which [the core devs acknowledge](https://thoughtstreams.io/ncoghlan_dev/missing-pieces-in-python-3-unicode/)). EOLing Py2 without addressing them was not the right way to go, imo. At this point (Py3 is &gt;8 years old), it looks like they aren't going to be addressed. At least not any time soon. So if, like me, you write the kinds of programs Py3 is not suited for, and with the core devs showing little interest in making Py3 more suitable for those kinds of programs while killing off Py2, it's time to look elsewhere.
Shaw is a well known blowhard. 
There is one important change to sorting in Python 3: if you have disparate types for which a defined ordering is not available, you get `TypeError: unorderable types`. In Python 2, disparate non-numeric types for which no ordering was defined were... sorted alphabetically by their type names. [I am not joking about that](http://www.b-list.org/weblog/2015/nov/15/real-python-wat/).
Point taken but 1/2 is ASCII 171. 
Oh right. I forgot about that one. But python2 makes sense. no really.
Yeah I see that, but no, I've literally never had those problems. I've only made tools for technical people to use, and I can easily just tell them not to do that shit (and they just wouldn't most of the time anyway), or I've made things so simple that there were no such problems (e.g. a web app with three buttons that talks to some other services). Honestly &gt; 50% of my Python code has probably never been run by anyone else except me, since they were just scripts to automate tasks or visualize data.
This one
My theory is he has a Python 2 book to sell and doesn't want to rejigger it for Python 3. Aka the "tenured professor" approach to education. 
He's absolutely correct that Python errors COULD and SHOULD give the variable names. The problem with his argument is that python2 sucks in this regard in the exact same way. 
For me it seems that there are not that many debates about py2 vs py3, at least reasonable ones. And arguments generally are about design decisions which've been made and maybe that PyPy in many terms much better next generation python than python 3 itself. And I think following article of Armin is the most popular one on this problem and arguments in it are actually really on point (http://lucumr.pocoo.org/2011/12/7/thoughts-on-python3/). I personally don't like the tone of both Zed's articles especially of his response. This is just not the way how grown up people handle the business. And I don't like his tutorials either, but its maybe just me, 'cause it seems that there are a lot of people who like them. But i never did and never would recommend it to any python beginner, it just the approach is wrong somehow. There are tons of much better materials for learning python, Dive into Python 3 in my opinion is one of the best. And for everyone saying python 3 bytes vs str stuff is hard, I'm pretty sure that You never faced UnicodeDecode/EncodeError in python 2, which was pain in the arse for beginner. And try to explain why You need to subclass from `object` in python 2 right of the way for people who never coded in other languages. What I'm trying to say is that python 2 also has it flaws in terms of learning, but everyone just got used to them.
The documentation mentions invoice, but only as an example of what types of documents can be created using rinohtype. Don't hesitate to contact me if you have any questions or suggestions for the documentation.
This Zed guy is probably stuck with a giant mess of a legacy python 2 codebase and feeling alone and left behind. 
Sure. The difference, as I see it, is that Py3 was deliberately re-tooled to be a better language for writing applications (as opposed to scripts). When you look at other application-focussed languages (Java/ObjC), the GIL is a standout issue. WRT JavaScript, its selling point has always been running the same code on the server and client.
Why is it terrible?
If it's some troubleshooting that can be resolved within a couple of hours it's not too bad. However, if it is, you could probably get the equivalent help here for free by just stating your question.
&gt; I call them what they are: a ticking time bomb lurking in your code. Only if you don't test your code. My own machine is full of non-ASCII (I speak German), and this has never been an issue in Py2 *because I test my code with non-ASCII*. Sure, you have to keep in mind which objects are `str` and which are `unicode`, and Py3 *theoretically* solves that issue. The problem is that when (not if) Py3's automatic decoding fails, it gives you a `str` object containing surrogate escapes. These objects can't be encoded and they aren't marked in any way. IMO, that's a *worse* problem than errant `str` objects in Py2. In Py2, you at least know that when you've got a `unicode` object, it won't explode when you encode it. So in the end … &gt; make naïve string-handling code blow up badly … this applies just as much to Py3. Instead of watching out for `str` objects like in Py2, you have to remember which APIs may return surrogate escapes and handle those instead. 
The only difference is where they get their variables from, and also that f-strings force you to use the explicit named-variable form of formatting. The `.format()` method can do everything that an f-string can, it just requires you to be explicit about which variables are being formatted. This is a good thing! With an f-string, the variables are named in the string, and must be accessible from the same scope as the string. With the method, the string could have been defined anywhere, and you have no way of knowing which variables are being used - hence why you have to explicitly insert them using the format method.
How would unicode help you with that one? O'Kelly, O‘Kelly, O❛Kelly and O’Kelly will look the same or close enough in many fonts, so users will continue to use any ' character regardless of unicode... or even thanks to unicode, as it is unicode that presents the user the possibilty to use the multiple versions of quotation marks. Then again, if you just intend to display the user input in some way, then any version of the quotation mark lookalike chars would do fine. At least if the font used to display the character supports it.
I will be messaging you on [**2016-11-25 13:50:50 UTC**](http://www.wolframalpha.com/input/?i=2016-11-25 13:50:50 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/Python/comments/5esfv7/zed_shaw_responds_after_his_controversial_article/daev51a) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/Python/comments/5esfv7/zed_shaw_responds_after_his_controversial_article/daev51a]%0A%0ARemindMe! 4 hours ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! daewrso) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
What a shame, I wanted to open a pullrequest to add homebrew support but stumbled across so many issues that I couldn't even install it and gave up. :-(
Read a few hundred text-based comp. Chem. output files, find the last number for energy, and put all of them into a CSV file. Also a script to generate all the possible permutations for molecule inputs.
To start with: http://sopython.com/wiki/LPTHW_Complaints Basically, aside from the Python 3 issue, it uses a really condescending tone, teaches in kind of a backwards order to how would be most helpful when learning how coding actually works, uses confusing terminology (either using the wrong term until the correct term is taught or advising students to ignore the correct term entirely), and teaches un-Pythonic code.
Yeah, you're completely right. I remember discussing with Armin about this and I really felt we both got through to the other.
This does look very interesting to me. Has anyone played with it already? First impressions?
Do people actually use PyCharm?
The problem is that the data you deal with on a Unix system, like filenames or streams, are not Unicode. So just getting the data into a Python program and out of it, which used to be trivial, is now a major effort as you have to be extra careful for Python to not interpret it the wrong way. Python3 does have the option to read that data as bytes, but that is extremely annoying to deal with as none of the string processing functions work on bytes. The alternative is pumping the data through `os.fsencode()/os.fsdecode()`, which will give you a Python string, but the problem with that is that your Python string is now no longer proper Unicode. If you try to `print()` such a string you get an exception. $ python3 -c 'print("\udcff")' Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; UnicodeEncodeError: 'utf-8' codec can't encode character '\udcff' in position 0: surrogates not allowed At that point you can fiddle with: PYTHONIOENCODING=utf-8:surrogateescape and: sys.stdout = io.TextIOWrapper(sys.stdout.buffer, errors="surrogateescape", line_buffering=True) sys.stderr = io.TextIOWrapper(sys.stderr.buffer, errors="surrogateescape", line_buffering=True) This will make things mostly working, but you still have to be still careful whenever your Python string tries to leave your program (e.g. when storing it in SQLite) as it is neither proper Unicode nor representing the original bytes. Essentially, Python used to be really nice and easy for scripting and Python3 made it a lot more complicated.
[removed]
If they hadn't included so many pointless changes like print(), import .. and // then it would've gone better.
People like to jump on semantics when finding an actual argument is difficult.
&gt; Also python3, node.js, and openssl are all the same group of people btw, what's wrong with OpenSSL? Of course, I know about Heartbleed, but IMO real reason was the total project underfunding considering OpenSSL ubiquity. 
&gt; that's the only way that can express all characters Not all characters are expressible in unicode.
That's called damage control. He's not a politician, so he can't have his aide say "Mr. Shaw was badly informed about the case" for him. Someone [a friend] should explain to him that the more tantrums he throws, the less seriously people will take him.
Well there used to be. Years ago, when I started learning...
&gt; real Unicode support Python 2's Unicode support is very good. The issue is developers not knowing (how) to use it.
&gt; Python has nothing like Rails to drive the community forward There's certainly no Python library of such enormous stature relative to all the others. OTOH, are there *any* big Python libraries that are 3.x only?
Sure, but you can't use unicode and byte strings in a pythonic way. Their APIs overlap so much, but duck typing causes massive issues here. They're similar until they aren't. The whole philosophy of do it and ask forgiveness doesn't help here.
No they're [telling them to use `python` for python2 and `python3` for python3](https://www.python.org/dev/peps/pep-0394/) &gt; for the time being, all distributions should ensure that python refers to the same target as python2 . But not all distros (looking at you archlinux) follow this advice.
Then my next question obviously is, why did it become very popular if it's terrible?
Javascript is an incredibly different case. Browsers force the issue. Whereas OSes ship with 2. 
&gt; Just try to write code that will also work under Python 3 (\_\_future\_\_ imports etc) to ease the eventual transition. Might as well write 3 at that point. I'm so glad I still get to use 2 and avoid float division for integers, verbose print statements and however you're meant to deal with import .. (I'm guessing I get told "fuck you" for the last one. Thanks pydevs.)
Support Toolset/Portal to handle heterogeneous System data analysis. Its a command line toolset with a UI Adapter. It handles command line calls and convert it into generic structures. This result can forward by mail client, stdout or as result after calling by webui over network. I like this toolset because i can only create a new command line tool and have automatically a web ui mapping too. The web ui control form are generated from argparse object which was converted into JSON. If i need i can append an other view based on templates für each command. Code less do more ;).
The only valid items seem to be 7), 13) and 14). The rest is subjective, unexplained or just downright silly.
Sometimes I just want some fucking output. That error is of no fucking use what so ever. So I have to write a bunch of functions to provide an ordering, after finding out what types are in the collection? Before I can finally see what is actually in the collection? You know what I'd do in that situation? I'd probably fucking sort them by their type name. **I'm not joking**
You just described every python programmer I know. Except for feeling alone and left behind.
Well... it's relative. If you're dealing with rails you've really got to compare that with DHH. So... y'know. It's not *that* bad.
Good question, and one I can't answer since I learned Python the actual hard way (by reading the documentation and experimenting) instead of from a tutorial.
[PEP 394](https://www.python.org/dev/peps/pep-0394/) says that `python2` should always open python 2, `python3` should always open python 3, and code that says it runs with `python` should probably be compatible with both because one or two distros now package python 3 by default.
How many years ago was that?
&gt; You could use Python 2, until it dies… or you could use Python 3, which might die. What a choice. &gt; By some definitions, Python 2 is already dead They're talking past each other. By Zed's account a living language is used and developed in. She ignores this rather obvious definition for some reason. &gt; But this is not static typing. That’s strong typing, Semantics. Irrelevant. Once you go here you're looking desperate. No one cares about your debunking of your misunderstanding of an argument. You know exactly what he means. &gt; the alternative is to silently produce nonsense in some cases The alternative is to produce output. This goes against the whole duck typing philosophy python was based on. Or you know, you could read the article and see the alternative he suggests. Which could provide an error in the case the utf-8 conversion could not happen. &gt; How would Python even report this error when I used literals instead of variables? Gee, maybe print the fucking literal. &gt; Why do you have a text string and a bytestring in the first place? Because libraries are garbage. &gt; I could swear Zed, an experienced professional programmer, just said he couldn’t easily figure out these new formatting systems. No he said it was stupid to have to teach three to a beginner. &gt; What “constant changing status”? The language makes new releases; is that bad? Backwards incompatible and program breaking changes. You know the thing you encounter when you actual use the damn thing. Starting to suspect she doesn't by the way. She's done amazing work through out at missing the point and being condescending. She is exactly the kind of thing she rails against. It's so easy to argue against a deranged reading of an article. Bit more difficult to actually tackle the reasons behind the writing of one. Which in this case is the fucking frustration of dealing with python 3 and the unnecessary changes they've made for fucking language purity. I rather her 1.5 Zed Shaws out of 2.
It was about Python 5 years ago.
Yup, check [this](https://eev.ee/blog/2016/11/23/a-rebuttal-for-python-3/) out. 
It's not though. Just one screaming dude on one side. It's like the debate over evolution or something. 
What exactly do you mean by 'all characters', and 'unicode'? I mean, the actual list of characters that Unicode defines is pretty huge, and while it is impossible not to miss _something_, pretty much every major alphabet used today is represented. So did you mean the encoding? Because I'm pretty sure UTF-8, UTF-16, etc. can represent every codepoint, but don't quote me on that - I don't really know much about Unicode.
Between this and his sensational, completely unfulfilled promise to expose the corrupt world of coding bootcamps, I don't know if anyone does anymore.
&gt; The strings in Python 3 are very difficult to use for beginners. In an attempt to make their strings more "international" they turned them into difficult to use types with poor error messages. Every time you attempt to deal with characters in your programs you'll have to understand the difference between byte sequences and Unicode strings. To be honest, this is already true in Python 2.7. I can't even tell how many times I've had mysterious errors because I tried using unusual characters.
The reason is performance and now that has gone away. So no there is no reason. 
To be fair: I acted unilaterally, expecting (and receiving) no resistance from the other mods. The incident from two weeks ago refers to this sub rather than /r/learnpython, I think.
I think one of Zed's big complaints is about strings in Python 3, and that they are too difficult to use for a beginner. Does anyone know what the specific problem is? 
&gt; I'm kind of confused of why the 2 vs 3 debate is still continuing. Do some people think that eventually Python 3 will be cancelled and we'll all go back to 2? I'm kind of confused why people insist on python3. Can someone explain how using python3 will improve my life in any way?
It seemed like it, until this surprise with responds and rebuttals we see here. Got curious, so I asked.
&gt; For me it seems that there are not that many debates about py2 vs py3, at least reasonable ones. I'm not sure what could possibly come out from random coders who have no input on design decisions "debating" them on reddit and hacker news, besides tickling their feelings of self-importance.
Why don't you explain your problem here, so people can decide for themselves whether they are able and willing to help you for a few 100 dollars?
Not a developer. I work as a financial analyst. I wrote a script to extract data from an unwieldy xml periodically published by a regulator and write the interesting parts in a excel sheet, that I can manage with my usual tools.
Improve Your life in comparison to what? If to some other language than which one? If comparing to py2 than there are a lot of stuff - You'll get maintainable platform and language with new features and support for reasonable amount of time. You actually will have future - imagine all those possible bug and performance improvement which You won't get in py2. And I'm not talking about asyncio and async/await and curio and all other async related stuff. Better question would be why would You not peak py2 instead of py3 right now? If You have large business related project running in production in py2, than I feel You bro, maybe its really not worth it. But if You're just learning or starting new project from the scratch in python and its no py3 then You should have some real reasons to do that.
Maybe Numpy is a good equivalent ?
To remove docker Images from hosts after not being used for one Week. 
&gt; And his response seems kind of...juvenile? Is this your first experience with Zed? That is his style...
Are you using 2.3 or something? 
thats seriously fun. wow. well done
Trying to get a job at a University that rarely has openings so rather than checking their site over and over I have a Python script that emails me everytime they post a new IT job. Another recent script was helping my wife combine images, she had a picture of a full dress and then a close up of the pattern on the fabric, about 150 of them, it was slow going with Photoshop to put the images side by side then watermark it. Python + Pillow made short work of it though. 
You think you have a product here? Srsly. Just open source it and be a good guy.
I'm working on a web scraper using aiohttp. I found a couple of pages that made async programming in Python sound much more useful to me.
How is connecting to somebody handled?
There's a reason the urllib docs suggest using requests at the top of the page. Also, to add to your example, I've had to deal with pages that have one encoding in the header, another one or two completely different encodings in HTML meta tags, then turned out to actually be in yet another encoding.
English can be written without accents, but English-speaking people still cannot live by US-ASCII alone, since their monetary unit symbol (pound or euro) may not be part of the ASCII set. Other often-used characters (degree sign) aren't part of ASCII either.
You mean censored any mentions of his book as a power play. Edit: /s. Really folks? 
"Unicode is hard and I don't want to learn." 
No at all.
&gt; And for everyone saying python 3 bytes vs str stuff is hard, I'm pretty sure that You never faced UnicodeDecode/EncodeError in python 2 Oh man, you just brought back a lot of memories. This is why I love the whole Py3 bytes/str thing. Sure, you can solve this kind of problem in both py2 and py3, but it's much easier to understand in py3. Most people I know that use py2 that have chanced on this problem just mess around with `.encode()` and `.decode()` until something sticks. Py3 makes handling this very explicit and thus straightforward to work with. 
I created a business name brainstorming website: http://nameamigo.com The idea is you type in some words, or sentences that relate to your idea and the website will generate business names for you. I have found it quite helpful when just looking to brainstorm ideas, or to find an open URL that sounds good.
&gt; If you want to use filename that is in bytes, you simply pass a bytes object to open. If you want functions such as os.listdir() to provide filenames in bytes, then you specify their argument in bytes. All of this is described in documentation. If it worked as smoothly as that in all cases, we wouldn't need `os.fsencode()` and [PEP 519](https://www.python.org/dev/peps/pep-0519). Now I am not saying it's broken, because it isn't, but it is slightly harder in 3x than it is in 2x.
Unicode is hard for beginners. This is true. so don't start with Unicode in chapter 1, you can cover basic string functionality without the intricacies of unicode.
Some would say node's selling point is that it's a very fast, expressive, dynamic language. It's certainly significantly quicker than Python for some tasks (e.g. cpu bound), and - for small codebases - doesn't require the boilerplate or static typing hassle of something like Java or Go (although it is slower than Go and Java in most cases). Personally I would choose something saner, but node does get work done.
To be serious, I think the real issue is that Zed doesn't understand the difference between a string and a byte sequence, at least in Python. So he'd need to admit he was wrong, which I'm not personally convinced he's capable of. Instead he doubles down on the Python 3 strings are unusable, when what he, hopefully, means is there's no interop between strings and bytes without converting one to the other. The reality is that for most programmers, there's a whole set of problems that vanish, never to be seen again. 
I'm interested in a context menu to pull the latest changes. Mind if I take a look?
I'm interested, how were you able to detect new offers?
As I said- an excellent case against python.
I feel the need to remind people that a lot of py3 code was backported to 2.6 and more still to 2.7. Sure there were backward incompatible changes made in py3, but Python is not a closed community, everybody who wanted to comment could have done so. Here are the [Python 3000 mailing list archives](https://mail.python.org/pipermail/python-3000/) for anybody who's maybe interested. As for the bytes vs str stuff that's been done to death, why it keeps coming up I really don't know. As the late UK comedian Frankie Howerd used to say "my flabber has never been so ghasted" :-)
My high school physics teacher said this about my code on my TI to solve all sorts of gravity problems
If all the libs you are covering are usable with Python3 then stick with that. I don't know about OpenCV. If there aren't good reasons to still use v2 for new projects I'd stick with v3. If there aren't that many tutorials about v3 that will make yours even more valuable. I wouldn't care about backwards compatibility unless it doesn't need much more than a few remarks.
Wrote a SoundCloud/BandCamp/MixCloud downloader: https://github.com/Miserlou/SoundScrape
http://stackoverflow.com/research/developer-survey-2016#technology-development-environments Pycharm is showing more users than Emacs - and this survey is across all languages.
&gt; extract data from an unwieldy xml periodically published by a regulator and write the interesting parts that qualifies you as a developer in my eyes
I had made a script to scrape my various banking institutions and update a spreadsheet with account balances but due to me not knowing shit about security and caring less and less about weekly fluctuations I dropped it
I wrote a [script to automate whitelisted dot file version control](https://github.com/tstringer/dotfiles/blob/master/automate.py) including a desktop notification when there are changes to dot files I version control.
I built a selenium webdriver bot to automate mobile bank account creations. We set up clients to have access to mobile check depositing using an app that they need a user name and password for. Instead of giving the task to someone to perform manually, I built the webdriver bot to accept a csv with all the vital data, open a web browser, navigate to the bank site, and perform all the data entry and clicks,and preserves the temp password produced for the account. Once complete, it takes all the temp passwords and exports those to another csv. It all happens very fast. I'm sure there are even faster ways of doing it, but this is how I've automated it so far.
Very cool but I did see ChildFactory on the first list I saw haha.
Back in highschool when I took AP US History, the teacher had us do 300+ flash cards. So I fed a spreadsheet of them to a script that would search it and use Google's definition box that appears near the top of the page.
I think he meant that his first job is not develop software, not that he not able to do so (because he clearly is)
I created a python application (and full installer too on Windows) that allows for a user to right-click on any ".py" file they created and compile it to a single EXE file (either that app will run in the console or non-console mode)...It's PyInstaller all in one shot
Is that un-reservable game checked in to my local library? No? Fine, I'll check again in an hour...
Is he repeatedly going through his own code and play-pretending he's a beginner who only knows Python 2 and making the same mistakes about strings even though he knows better, then using that as reconfirmation that Python 3 sucks? What a lunatic.
They had a back end json service so I reverse engineered that using the chrome devtools. I use SQLite to store a list of the job IDs it's already sent me so I don't get duplicates
My band had dozens of hours of raw camera footage and the task of making sense of it to form a coherent promo video was so daunting that it kept anyone from doing it. Instead I just wrote a script to randomly draw video snippets and combine them under our studio recordings. See finished product [here](https://youtu.be/nFW0vHi_me0) and [here](https://youtu.be/h8jv3yzYnZo)
I honestly think it's the name. I know it sounds stupid but it's one of the the reasons I picked it. 
That's just wonderful.
There isn't any problem imho for beginners. The majority of operations are exactly the same, for a large majority of the world it'll be even easier. It's only for the ascii speaking world, and only for a fraction of them that it will be an issue. Most people won't even notice the difference between python2 and 3 other than print now has parentheses and you get a bunch of new features. 
A script to download U.K. Index fund prices from a broker's site. Google/Yahoo doesn't list all U.K. Funds prices. 
* A bunch of web-scrapers. * A video converter with hardsubbing function to watch any video on any device (it also saves all fonts found within MKVs to my font collection; one TV series had more than a hundred!). * A scan splitter which detects the border between spread pages of a book. * A web-comic splitter which cuts 4000x500 pixel files into something I could read on my tablet (naturally with a scene detection). * A program which adds 'fingerprints' to image file names, so similar images would stay together when sorted alphabetically. * A program converting image folder to PDF which can be opened on my e-book. * A bilingua maker which combines two language version of the same book into a 2-column PDF, so I could practice other languages. * A program which converts an English book into cyrillic phonetic transcription, so I could practice this insane pronunciation while reading.
But brainfuck is easy to intepret. So you could write a program and then run it anywhere. INTERCAL intepreter are harder to write.
Can you expand on that? I'm just learning Python and I've never had to specify a character set at all.... Is it that Py2 would be able to handle cyrillic/kanji/(etc...) characters, but Py3 can't?
Hi, thanks for trying ! Well, as for the install and init, I know I must check on different (and bare-bones) configs (I didn't mark it as ready yet for that reason). I'd love to know what were the issues though. I personally use it daily with success :) Thanks !
Win7 v Win8. You might love Win7 and will stick to it for as long as you can, but eventually (like with Win2k/XP), you're going to have to make the switch. The only hope is that by the time you do switch, the current Py3 release will be something you can live with (ie: Win8.1/Win10/etc)
IIRC I heard that the dictionaries being ordered by design may not make it in the actual release of 3.6. Anyone know anything about that? 
I wrote a stupid little script that will go into multiple repos, and compare their requirements.txt files looking for potentially bad pinning choices and version disagreements in common libraries, it exports it to github/gitlab flavored markdown. 
There seems to be a bit of a pattern, yeah. I'm sure it's just everybody else that's stupid and wrong though. ^^^^/s
what world is zed living in?
Please continue
As a Python newbie, the book appealed to me because it appeared to be a fully comprehensive introduction to the language, all for free on the web. 
Wrote a script that randomizes a bunch of options for people watching so regulars at the bar can play bingo during peak times this holiday. It outputs to a BINGO grid. Got the idea on day before thanksgiving. Options include things like: puking on bar, ugg boots, make out, crying, etc. it was a huge hit on Weds lol. 
Sorry for double post, but I also wrote a stupid little script that scrapes a fanfiction from ff.net to a markdown file with relatively preserved formatting, I get into totally disconnected situations a lot and want something to read. 
What library do you use for XML parsing?
Could you share this?
[Cloning Linux hard drives incrementally to any drive, including smaller ones](https://github.com/DonyorM/weresync)
Is that you, Zed?