Lecturer at university decided that he was going to teach my 3rd computer graphics course in Python. Mainly because they were planing to switch 1st year Intro to Computer Science from Java to Python the next year, the lecturer was basically learning Python at the same time as us. Of course, by the time you get 3rd year computer science, you have already encountered 10+ languages and learning python basically consists of remembering to indent correctly and not hit semi-colon at the end of each line while keeping google open.
Theres also pybrain, bigml, ntlk (to a small extent), pyml, mlpy &amp; shogun. And probably more.
So, essentially, since PHP is the most used language in web dev it's ultimately the right choice?
from a shaolin monk in the himalayas. no just kidding, i started during my physics class using it to automate basic data analysis and am still learning even more to this day for project euler problems and the like.
I also learned Python from them. Here's a link: [MIT 6.00 Intro to Computer Science &amp; Programming](http://www.youtube.com/playlist?list=PL4C4720A6F225E074) The lectures are great and they made me realize how bad the Intro to CS courses at my local university are.
The specificness of some apps on the app stores both amazes and confuses me.
No of course not. But an announcement of a new book, yes absolutely.... that would probably mean around half a dozen posts per year. Merchandise doesn't teach, so of course that wouldn't be the same. I can write a tutorial on my blog about how to do something with Python, and post it here, but if I write a book of tutorials, you don't think it should be here in this sub? Slippery slope is not a valid argument in this instance. We have moderators with common sense who can delete the trash.
Do not use class based views. There are a few people promoting the idea, but those of us that have been using Django a long time see them as merely complications. They are good when you are creating a library of views to be duplicated across multiple projects. But even then, they need to be used with care.
I have doodled in python earlier, and made some more or less successful attempts at solving some problems with Project Euler. But I first started learning Python properly when I took a University Class (http://www.uio.no/studier/emner/matnat/ifi/INF1100/index-eng.html) which focus on teaching programming thorugh scientific problems (which are, at least for me, more interesting than the endless stream of trivial assignments normally given in intro-courses). The class used http://www.amazon.com/Scientific-Programming-Computational-Science-Engineering/dp/3642302920 for the syllabus, and I can heartily recommend to read through it if you want to learn python to do math-problems (but also get knowledge about general programming). I don't have enough fingers or toes to count all the times I've just used Python and matplotlib to visualize data instead of being frustrated with excel in the last 3 months alone. I've started to use python for sysadmin-tasks, as both me and colleagues that are less proficient in programming find it more readable and easy to understand than perl (or bash for that matter).
&gt;This is an easy enough fix, all I need to do is to fill up the lists like this: list["","",""] and let the program replace those empty spaces....By filling the list from the beginning, the program's fail-safe feature of checking whether or not the list is as long as it needs to be does not work anymore. You could try initializing the lists as you've suggested and then test to see if any of them contain ``""``. This would involve modifying the following line: if len(AHscore) == 3 and len(AHscore) == 3 and \ len(BAscore) == 3 and len(BHscore) == 3 and \ len(CHscore) == 3 and len(CAscore) == 3 and \ len(DAscore) == 3 and len(DHscore): (Note there are actually a few bugs in this line: you've checked `len(AHscore)` twice and not checked `len(AAscore)`; you've also failed to test if `len(DHscore)==3`.) You could try something like: all_scores = AHscore + BHscore + CHscore + DHscore + \ AAscore + BAscore + CAscore + DAscore if ("" not in all_scores): print("We have collected all of the data we need.") Since you've pre-populated your lists there's no longer any need to check their length, but if any of them still contain a `""`, you know that you need more data.
I never really learned python. I learned ruby by reading a book, but never wrote anything and just started writing stuff in python instead. When ever I would get stuck I would just look up stuff in the docs. 
it's interesting that you refer to the fallacy since djangos main appeal is it's popularity amongst the python web frameworks. nobody gave a shit about django until Guido(who's not a web programmer) said he liked it. 
I got a job out of college for a publishing company. All their work was done with regular expressions and Perl. I also started reading xkcd at the time. After reading [this comic](http://xkcd.com/353/), I became curious about Python and picked up O'Reilly's Learning Python. I've been a Python programmer ever since. Now, onto how to start learning. I usually learn new things by diving right into a project. I learned Django a few years ago by working through the tutorial. I think the key is to follow the tutorial, but build something different. This way it's relevant to you and you learn more about the language when you run into something that is not working for you. It's like test driven development for learning.
Keep this reference close while getting to grips with class-based views. http://ccbv.co.uk/ Stick with it and they do eventually make sense, but in my opinion not a particularly satisfying sense.
To echo Daniel's story, I was on a government Java project that was actually really well run (continuous integration, high unit/functional test coverage, tight build scripts), but getting anything done still felt like a chore. I started programming with Python at night and felt like I was more productive in a couple hours with Python than all day with Java. Something about the language just "clicked" for me compared to using C, C++, or Java. To OP, if you work with Python for a bit and feel the same way that's a really great sign. For resources, I always point people to Ken Reitz's [Hitchhiker's Guide to Python learning resources](http://docs.python-guide.org/en/latest/intro/learning/) as well as my own [Full Stack Python best resources list](http://www.fullstackpython.com/best-python-resources.html). There's a lot of overlap in those lists which should help you narrow down where to spend your time first.
To be honest, that is not exactly the most shining endorsement. "We took too long to make this page for you," anyone?
 import random will import all methods from the random module but force you to call them via the syntax random.randint(3,7) from random import randint imports solely the randint (so random also has a .choice method, but you won't be able to use it) method from the module and allows you to call it simply by using randint(3,7). This can occasionally lead to namespace issues, especially when using multiple large imports, and so importing only what you need and using the from module import method syntax is generally considered cleaner, even if it rarely matters and ends up leading to uglier code. 
using just import without from will import the entire module. if you want to access a specific function or class from the module you then have to fully qualify it with the module namespace: &gt;&gt;&gt; import random &gt;&gt;&gt; random.randint(3, 7) using a from statement allows you to import a class or function from a module without importing the entire module. its generally consider cleaner. it also allows you to use the imported class or function without having to fully qualify it after the import: &gt;&gt;&gt; from random import randint &gt;&gt;&gt; randint(3, 7)
You can do it out of the box with web2py, maybe you can take a look on how web2py does this to develop the same using Flask. 
Good question. I doubt it is possible to do in a clean way. I'd love to be able to create a single stand-alone self-contained web application and ship it across different platforms. The closest thing I've seen to that was some examples done in Go where they had embedded all the static assets from the web application as binary inside the source code of the Go program and it included the http server and everything and it was compiled down to a single executable.
"random" is the the module. Think of it as a container full of different functions, one of those being "randint". By typing "import random" you ask python to let you access all of the functions available in random, but to do so you will need to always type "random.&lt;function&gt;" to access it. On the other hand by typing "from random import randint" you are explicitly telling Python that you would just like to load the one function randint, and that you would like to be able to call it without prefixing "random"
I got tired of fighting with Drupal. Found django, and from there got interested in Python. I'm by no means a python programmer though... haven't done too much more than some simple template tags, a gallery plugin (using PIL), etc.
please try to learn some real history instead of making stuff up http://en.wikipedia.org/wiki/Django_(web_framework) Django release date: 21st July, 2005 http://en.wikipedia.org/wiki/Ruby_on_Rails Rails release date: 13th December, 2005 the two systems were developed independently of each other at approximately the same time. django is even slightly older. 
I started by going through [Grey Hat Python](http://shop.oreilly.com/product/9781593271923.do). If you're an experienced programmer and enjoy the low-level stuff once in a while it is a very fun way to learn Python. If you're specifically looking to learn how to program the Rasberry Pi **and** learn Python at the same time (which will keep your interest up), [Programming the Raspberry Pi: Getting Started with Python](http://www.amazon.com/Programming-Raspberry-Pi-Getting-Started/dp/0071807837) is a great book for beginners of all skill levels. If you are a newbie programmer, buy this book.
https://www.learnstreet.com/lessons/study/python Takes you through the basics step by step in a sort of live environment where you can test what you learn as you learn it. 
Great post overall! I disagree about the origins of the ORM and about class based views but otherwise fantastic. 
Anaconda might help with installing and running Python on windows. Especially on the game front.
I wrote a library that does basically exactly this a little while ago: https://pypi.python.org/pypi/Dispatching It uses function annotations rather than arguments to the decorator.
Jesus man.. you really need to learn what a function is. You're violating the "DRY" (don't repeat yourself) cardinal rule of programming! lines 29-45, 47-63, 81-97, etc should be written ONCE in one place in a function that you call on. Please fix this then come back because this is unwatchable.
I am amazed that there is a site that explains xkcd comics...
It's important to note that the shorter function name is the only advantage, and Python still loads the entire `random` module into memory (without giving you actually access to the rest of it.) There is no performance benefit, but from a readability standpoint it is usually preferred as you are explicitly stating the functions you want to import. 
ipython notebooks are amazing.
On mobile right now or of just look at the source, but does yours support type matching over *args, I didn't see it used in the docs. This is cool though, and I'm totally taking a look after class. 
That's actually an interesting question. I'll have to check. My *guess* is that it'll match on the literal type of `args` (ie, a tuple).
They really are, they make running through quick ideas like this a breeze. Especially when you are going back and forth constantly making changes.
You seem to have some decent responses, which you keep turning down by providing more information - please just accurately describe the project and you will get the response you need What is wrong with doing whatever you do in development? (Install python and run the server?) What exactly failed when you tried to make a single exe version?
I used pyinstaller to successfully deploy a one-file flask/flask-restful/sqlalchemy python app. The trick to getting flask/flast_restful/sqlalchemy working with pyinstaller is to produce a giant list of all of the "hiddenimports" in your pyinstaller spec file. It was painful to build this manually, so I think I ended up grepping for all import statements within the packages. Example pyinstaller spec snippits: a = Analysis(['.\\run.py'], pathex=[blah], hiddenimports=["flask", "flask_restful", "flask_sqlalchemy", "flask.views", "flask.signals", "flask_restful.utils", "flask.helpers", "flask_restful.representations", "flask_restful.representations.json", "sqlalchemy.orm", "sqlalchemy.event", "sqlalchemy.ext.declarative", ...&lt;lots more&gt; "flask_sqlalchemy._compat", ], hookspath=None, runtime_hooks=None, ) pyz = PYZ(a.pure) exe = EXE(pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name=blah, debug=False, strip=None, upx=True, console=True ) 
Once you are familiar with the basics, I suggest you learn a basic workflow which includes the use of a virtual environment (such as virtualenv).
Wow. Excellent! Thank you so much. This weekend I'll be investing some time into django hacking. You'll be seeing more of me on this subreddit! Thanks to everybody else who have contributed to this post. Also I'm very interested in this conference in Ohio. I'm out of Michigan so I'd love to be around the py community.
Cool use of Python for some statistical analysis, but it isn't really answering the question "What if NCAA basketball players were paid?" - at least not the way I though the question was being asked. Comparing NCAA statistics to NBA statistics is awkward, especially considering the game lengths are different.
In terms of the haskell /python comparison, I'm will aware that much of the difference comes from haskell's concise syntax in list comprehensions, but I also feel that the code is cleaner and clearer, so in part my goal was to emulate functional style which had the side effect of requiring static typing. Could you elaborate on the parsing issues you had? Also dogescript is so kinds of awesome. 
So that wouldn't happen in any other language? The problem you mentioned there is more a database problem than a Python problem btw.
Look into apps for windows chrome. They can embed your web app completely within it's own frame. The only caveat right now is that Chrome must be installed on the machine, but they said they are working on removing that dependancy too. https://developer.chrome.com/apps/first_app
I have seen some apps come very close to this using cherrypy. 
Indeed. I do that at work for some internal stuff with CherryPy, SQLAlchemy, Mako, etc. I use py2exe to bundle the whole of it and then NSIS to make an installer from it (never tried pyinstaller myself but people seem to like it). It works well enough once installed as a regular windows app. Never tried on Linux but I assume it could work just as well with a deb or rpm.
Python compiler (or translator) which resolve dependencies : http://nuitka.net/ By the way, this may be better than SQLAlchemy, Native object database for Python: http://www.zodb.org/
Even reading sample codes in tutorial only should be enough for experienced coders, that's actually how I learned it.
It is definitely possible. I've used [cx_freeze](http://cx-freeze.sourceforge.net/) and the my setup.py is this: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import os import sys import datetime from cx_Freeze import setup, Executable # This is ugly. I don't even know why I wrote it this way. def files_under_dir(dir_name): file_list = [] for root, dirs, files in os.walk(dir_name): for name in files: file_list.append(os.path.join(root, name)) return file_list includefiles = [] for directory in ('static', 'templates', 'data'): includefiles.extend(files_under_dir(directory)) # GUI applications require a different base on Windows (the default is for a # console application). base = None if sys.platform == "win32": base = "Win32GUI" dt = datetime.datetime.now() main_executable = Executable("example.py", base=base, icon="static/example.ico") setup(name="Example", version="0.3." + dt.strftime('%m%d.%H%m'), description="Example Web Server", options={ 'build_exe': { 'packages': ['jinja2.ext', 'flask_sqlalchemy', 'flask_login', 'flask_wtf', 'os', 'flask_sqlalchemy._compat', 'sqlalchemy.dialects.sqlite', 'sqlalchemy'], 'include_files': includefiles, 'include_msvcr': True}}, executables=[main_executable], requires=['flask', 'wtforms']) This could do with some cleanup, but it works. I haven't tested it yet for Linux or Mac OSX, but I don't expect all that much trouble (famous last words :)) Some tips that I found out the painful way: 1. `'include_msvcr': True`: Very useful. A clean PC will not have the proper version of msvcr.dll 2. `'include_files': includefiles`. You will need to include the HTML templates and static files manually. I'm not sure if I could load these files in a single zip file (I probably could, but I don't know how to configure Flask to do so) 3. Test your setup in a clean PC (preferably freshly squeezed VM).
I thought Chrome apps must be written in HTML5/CSS/JavaScript? I know py2js compilers exist, but I doubt they are robust enough to put into production. 
Sure. 1) I took the headline question to mean "What would college basketball be like if players were paid". In reality it was "How much would college basketball players be paid if salary ranges were comparable to NBA salaries using NBA statistics?". 2) I'll stand by my comment that the comparison is awkward. Could have very well been arbitrarily been comparing high school statistics and cramming them into the NBA salary formulas devised. Or even NFL statistics if there was a way to map them.
Thanks for the feedback, I see where you are coming from with your second point and I have been discussing it on r/machinelearning. This was just a quick analysis I threw together quickly, there are certainly many different roads to go down to dig deeper into this. One I definitely would like to explore is finding how much money college basketball programs bring in and then seeing how much NBA players are paid as a percent of their teams entire cap and then put these two together to come up with a more accurate number.
I am glad you found it interesting. I plan to go back in the future and go a bit further with it, if you have any ideas please let me know.
Nice work very thought provoking. 1. I would be interested to see the comparison to how much revenue a NCAA Basketball team creates vs an NBA team, and then use that to see if the ratios align with your individual player salaries in the NCAA and then real NBA. Just another way to proportionally check how realistic your data is. 
Thanks. How up-to-date is "Dive into Python 3"? I remember that it has been around for a long time.
Thanks for reading, I believe I described almost exactly what you are saying below and think it would be very interesting to see what results that would provide.
Just heard about it today and started searching for info about it. I'll definitely be looking into using this for some of our commercial projects; in the past we used AIR but Adobe seems to be slowly choking the life out of it, and I've been on the lookout for a cross-platform RAD solution with good graphics/animation support. Hopefully Kivy will work for us, I love Python. 
You: &gt; Comparing NCAA statistics to NBA statistics is awkward, **especially considering the game lengths are different**. Article: &gt; PER takes into account both positive and negative contributions by the player, it is than adjusted to a per-minute basis so that every player, whether it be a starter or a sixth-man, can be compared equally.
I knew PHP fairly well, and was miserable at my support job at the time. A friend who worked at my current job asked "hey what other languages do you know?". I then used a mix of Python.org docs and StackOverflow to convert a bunch of my misc PHP stuff to Python, and a few weeks later I had a new job writing Python code. 2 years later, I'm still doing it.
It's for 3.1, but A) if this is for beginner-level learning, it should hardly make a difference, and B) it's completely free
Why do python C extensions perform poorly and Pypy ? And is there not a way to correct this behavior without having to rewrite all libraries ? 
C extensions use a pretty horrible CPython C API which enforces certain design decisions (it's horrible for interoperability, I think it's allright for CPython). In order to support them, you need to e.g. fake refcounting and do a few other tricks that are expensive.
* `os.fdopen` is simply an alias for `open`. You can do `sys.stdout = open('/dev/tty1', 'w')` to achieve the same thing. * If you want to write to both streams at once, you'll have to create an overlay stream. Something like this: import io import sys class TeeMixIn (object): def __init__(self, *streams): super().__init__() self.streams = list(streams) def writable(self): return True def write(self, x): return max(st.write(x) for st in self.streams) class Tee (TeeMixIn, io.TextIOBase): @property def buffer(self): return RawTee(*[st.buffer for st in self.streams]) class RawTee (TeeMixIn, io.BufferedIOBase): pass sys.stdout = Tee(open('/dev/tty1', 'w'), open('/dev/ttyS0', 'w')) Though it'd probably be better to use [syslog](http://docs.python.org/dev/library/syslog.html) in this case.
If you want to compute your charts server side, you can also take a look at [pygal.org](http://pygal.org/) ([demo](http://cabaret.pygal.org/))
As mentioned by others there are python libraries that might help, but using a javascript plotting library might be overall easier (if your stuff is simple). I've been trying to find time to look at Bokeh, but for your use case this might be overkill.
Chart.js gives you very simple charts done in the client. http://www.chartjs.org/
I've used Matplotlib, but I've found the documentation very lacking for that kind of thing. Matplotlib assumes that you'll use it for isolated plots (it must store state in globals somewhere), so it's unsuitable for use in a web app (which may be multi-threaded). It has a mode where you can control the state object, but it wasn't easy.
This looks seriously sexy and quite simple. Will give it a go!
Nope &gt;&gt;&gt; def foo(*args: int): return None ... &gt;&gt;&gt; import inspect &gt;&gt;&gt; inspect.signature(foo).parameters['args'].annotation &lt;class 'int'&gt; &gt;&gt;&gt; inspect.signature(foo).kind &lt;_ParameterKind: 'VAR_POSITIONAL'&gt; since you're using `.bind` on the signature object, you should just get the right type automatically and shouldn't necessarily need to test for `.kind` being VAR_POSITIONAL (I haven't tested your code) EDIT: **this is incorrect** it will show up as tuple, but if you check for VAR_POSITIONAL, you can get it to work correctly (I'm a moron)
I just pushed version 1.2.0 in response to this, which adds support for matching `*args`.
Yeah I just started "An Introduction to Interactive Programming in Python" on Courera yesterday. It's still on week 0 (introduction week). :D
Also the `x = lamda ...` thing. How ugly is that?!?
i found this one to be quite nice: http://programarcadegames.com/ otherwise, SICP for python !: http://www-inst.eecs.berkeley.edu/~cs61a/sp12/book/
 hidden_imports["flask", "flask_restful", "flask_sqlalchemy", "flask.views", "flask.signals", "flask_restful.utils", "flask.helpers", "flask_restful.representations", "flask_restful.representations.json", "sqlalchemy.orm", "sqlalchemy.event", "sqlalchemy.ext.declarative", "sqlalchemy.engine.url", "sqlalchemy.connectors.mxodbc", "sqlalchemy.connectors.mysqldb", "sqlalchemy.connectors.zxJDBC", "sqlalchemy.connectorsodbc.py", "sqlalchemy.dialects.sqlite.base", "sqlalchemy.dialects.sqlitesqlite.py", "sqlalchemy.dialects.sybase.base", "sqlalchemy.dialects.sybase.mxodbc", "sqlalchemy.dialects.sybaseodbc.py", "sqlalchemy.dialects.sybasesybase.py", "sqlalchemy.engine.base", "sqlalchemy.engine.default", "sqlalchemy.engine.interfaces", "sqlalchemy.engine.reflection", "sqlalchemy.engine.result", "sqlalchemy.engine.strategies", "sqlalchemy.engine.threadlocal", "sqlalchemy.engine.url", "sqlalchemy.engine.util", "sqlalchemy.event.api", "sqlalchemy.event.attr", "sqlalchemy.event.base", "sqlalchemy.event.legacy", "sqlalchemy.event.registry", "sqlalchemy.events", "sqlalchemy.exc", "sqlalchemy.ext.associationproxy", "sqlalchemy.ext.automap", "sqlalchemy.ext.compiler", "sqlalchemy.ext.declarative.api", "sqlalchemy.ext.declarative.base", "sqlalchemy.ext.declarative.clsregistry", "sqlalchemy.ext.horizontal_shard", "sqlalchemy.ext.hybrid", "sqlalchemy.ext.instrumentation", "sqlalchemy.ext.mutable", "sqlalchemy.ext.orderinglist", "sqlalchemy.ext.serializer", "sqlalchemy.inspection", "sqlalchemy.interfaces", "sqlalchemy.log", "sqlalchemy.orm.attributes", "sqlalchemy.orm.base", "sqlalchemy.orm.collections", "sqlalchemy.orm.dependency", "sqlalchemy.orm.deprecated_interfaces", "sqlalchemy.orm.descriptor_props", "sqlalchemy.orm.dynamic", "sqlalchemy.orm.evaluator", "sqlalchemy.orm.events", "sqlalchemy.orm.exc", "sqlalchemy.orm.identity", "sqlalchemy.orm.instrumentation", "sqlalchemy.orm.interfaces", "sqlalchemy.orm.loading", "sqlalchemy.orm.mapper", "sqlalchemy.orm.path_registry", "sqlalchemy.orm.persistence", "sqlalchemy.orm.properties", "sqlalchemy.orm.query", "sqlalchemy.orm.relationships", "sqlalchemy.orm.scoping", "sqlalchemy.orm.session", "sqlalchemy.orm.state", "sqlalchemy.orm.strategies", "sqlalchemy.orm.strategy_options", "sqlalchemy.orm.sync", "sqlalchemy.orm.unitofwork", "sqlalchemy.orm.util", "sqlalchemy.pool", "sqlalchemy.processors", "sqlalchemy.schema", "sqlalchemy.sql.annotation", "sqlalchemy.sql.base", "sqlalchemy.sql.compiler", "sqlalchemy.sql.ddl", "sqlalchemy.sql.default_comparator", "sqlalchemy.sql.dml", "sqlalchemy.sql.elements", "sqlalchemy.sql.expression", "sqlalchemy.sql.functions", "sqlalchemy.sql.naming", "sqlalchemy.sql.operators", "sqlalchemy.sql.schema", "sqlalchemy.sql.selectable", "sqlalchemy.sql.sqltypes", "sqlalchemy.sql.type_api", "sqlalchemy.sql.util", "sqlalchemy.sql.visitors", "sqlalchemy.types", "sqlalchemy.util._collections", "sqlalchemy.util.compat", "sqlalchemy.util.deprecations", "sqlalchemy.util.langhelpers", "sqlalchemy.util.queue", "sqlalchemy.util.topological", "flask_sqlalchemy._compat", ], 
Python is mostly limited by its strengths at this point.
much appreciated! thank you.
In my opinion, and I think this is up for some controversy, GUI programming in Python is horrible. No fun at all, especially since I dislike Tkinter.
YUP
Not saying you are wrong but have you worked with more recent Tk versions? It is actually usable and cross platform using native UI widgets. No where near as powerful as Qt bindings but more than enough to get started. 
Distributing an application and its dependencies. Fortunately this has slightly been addressed with the inclusion of virtualenv and pip in 3.4.
Second for web2py. Great way to get started in the Python MVC camp. You can always bring what you learn there to other stacks/frameworks. 
The only thing that worries me is 2 to 3 transition. I find it troubling that 4 last major releases were done without proper wide community feedback. The situation improves from year to year, but I'd really like to finally see some kind of breakthrough. 
I don't have a good basis for comparison, but I find GUI programming with wxPython fine, and the community amazingly helpful when I do get into a confusion or concern. It's not *perfect*, but what is?
Both SIP (PyQt) and GObject Introspection (GTK) provide 1:1 mappings to the underlying libraries. If you think GUI programming in Python is horrible, other languages will not make it much better.
* Deployment (as a commercial product, virtualenvs and wheels is not a fix for everything) * [Slow](http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=python3&amp;lang2=java&amp;data=u64q) * GIL * GUI development (easier to just make it into a web frontend) 
For reference, here's a Quora thread on [why Google uses Java and C++ rather than Python](http://www.quora.com/Google-Engineering/Why-does-Google-prefer-the-Java-stack-for-its-products-instead-of-Python) for a lot of its products. The Google engineer that posted specifically mentions performance, tools (profiling and debugging) and concurrency. The GIL/concurrency issue seems like the biggest issue to me, particularly in light of the last ten years of hardware development. There is a whole class of applications that are perceived as being solidly outside of Python's competence because of threading/GIL issues.
Another couple to add to that: http://www.flotcharts.org/ http://www.jqplot.com/
I haven't gotten into GUIs in python. But have you tried PyQt?
Another option would be to run your application server in a small virtual machine with [Portable VirtualBox](http://www.vbox.me/). You can write a small startup script with runs the virtual box and opens the browser with the correct URL.
To add/rebute some of those points: * Cleaner syntax by default. * Can be translated to C with Cython * Yeah, that sucks. Hopefully we recover from that. * No comment. * No comment. * I would go as far as saying it isn't as enterprise as Java, plain and simple. That is both a drawback and a strength. Java is extremely verbose, and tries to restrict users from making major mistakes. This is good for large projects, but can make coding smaller project tedious and can distract from the actual logic of the program.
Nice!
The worst part is that this problem has just gotten worse. Practically every system you're interested in, desktops, laptops, phones, etc. all have multiple cores. Having shitty CPU bound thread performance just hurts.
See GIL.
the newbs #offmylawn
* Hard to distribute as a single executable. There's libraries/tools like ~~py2exe~~ cx_Freeze but they're not guaranteed to work, it would be better to have a official built-in tool. There's also the option of translating everything to Cython. * Slow, other scripting languages (implementations) on the same league are at-least one order of magnitude faster (Luajit, V8, Julia). PyPy is great and could be the solution, but it's a small community that receives very little support. I think it would be better to have a Jited interpreter as the official implementation. * Really bad support for mobile programming. Lua, for example, has several mobile crossplatform frameworks and game engines. Python at-least has Kivy which is a great crossplatform GUI library! So, I want 1) easily distribute it as a single binary, 2) speed, and 3) More penetration on the mobile realm. For that to happen the community can focus on the current best-solutions in each case (cx_Freeze, PyPy, Kivy... + iPython for good measure!).
Like I said, this is probably going to be up for a bit of controversy. As far as I'm aware, and I may be wrong since I don't really use Python that much, wxPython isn't in the standard libraries. That's my main issue; it can be a little bit of a pain when you want to distribute the software you've developed without the usage of `pip` or similar. I send the odd python script to friends every now and again, so it really helps when something's in the stdlib so they can avoid having to download and install dependencies. Thanks for the response. :)
I have, yeah. PyQT is great, but the main issue is that AFAIK it's not in the standard libraries, which can make it pretty annoying for when I want to send a quick script to a friend. Hell, I'm probably just making a big deal; just because I don't like Tkinter, doesn't mean other people don't either. Having used Java's Swing library beforehand, Tkinter just feels kinda bare.
&gt; I think the code evolver would just sit there forever. Maybe you could write a program to verify this hypothesis.
probably just the metro areas like NYC/Boston...
Well, its not the **only** advantage; doing "random.foo" involves two lookups, where "randint" is only one. This optimization is likely not going to matter in the vast majority of cases, but if you have a tight loop binding to a local name is a common technique. Local lookups are special (they have their own opcode) and are very fast (comparitively).
Absolutely and 100% completely agreed. I have voiced my concerns about this multiple times on this subreddit, and while there are ways to distribute applications, all of them have major flaws. I wish it was a little more like node.js's npm. :(
Wait, your second point. &gt; Can be translated to C with Cython Can you translate any given Python program (given you give variables their proper types) to C and compile that? Would the performance be better? How reliable is this? Just wondering about it, I could definitely see some applications where I might be able to use that.
Let's hope that pip becoming *the* Python package manager helps. :-) 
Any reason why you don't think the GIL is a significant issue?
Hmm. Maybe WebOb would be like arch here.
I don't have a lot of experience with Python, but I'm starting to play with it a little bit. What do you suggest I use, version 2, or 3? And why don't you like 3?
Its not that OP doesn't like version 3, so much as he doesn't like the transition from 2 - 3. Python 2.x and Python3.x are incompatible, a lot of code written for 2.x has to be rewritten for 3.x. The good news about this is that 3.x fixes a lot of problems that were inherent to Python2.x and gets rid of them entirely. If you are just starting to learn it, you should use Python 3
Okay, thanks!
Done! I pushed up version 1.2 through 4, which add: - 1.2: `dispatching.each`, which causes a matcher (type, predicate, or value) to match against each individual element of `*args`. - 1.3: When a type is used to match `*args`, it implicitly instead matches all the arguments in `*args`. - 1.4: Support for tuples of types, just `isinstance`.
I started on a mac and as a beginner I didn't find it very easy to get started. Java was a lot easier. You download eclipse and five minutes later you write java. Python was command lines and a lot of Google. I am still not sure what the best OSX ide is. 
Bought it and read through about 80% already. It's an opinionated source for the authors workflow, but that is probably a good thing. Sometimes trying to tie in a complete start to finish for structuring, packaging and implementing a project can be problematic. Especially, if you are referencing material from different sources, each being opinionated in their own way. The source code is nice for places where the author isn't thorough enough, so you look at his source and realize what he meant. 
Typically performance doesn't improve by much more than maybe 10%. Adding a very small amount of cython-specific markup to key areas can dramatically improve performance. On the other hand, typically running the same vanilla Python code using PyPy can achieve the same or even better performance improvements than hand-optimised cython code. Also, you don't need to compile to C to package a Python application. Look into pyInstaller for a cross-platform application packaging solution that doesn't suck as much as py2exe or the others.
Unless you have a strong reason to do otherwise go with python 3. It is the main language looking forward. 
IIRC, Cython aims to convert any Python code to C code, but you don't get much speed up just by converting it, because it still has to use all the Python machinery to work out what to do. The main speedups come when you add type information, so Cython can actually start optimising things. The other main thing Cython offers is ways to call into native C code.
Okay, thanks. I misinterpreted what he said. I thought arandomtoolbox meant the community as a whole in his third point. I didn't realize that 2.x and 3.x weren't compatible. 
!== is not CPython either
You must be some kind of savant for being able to get rolling with eclipse in 5 minutes
I'm a big fan of [Flask](http://flask.pocoo.org/), it comes with all the basics, and isn't bogged down with silly semantics like MVC patterns etc.
When I need to do that, I py2exe up the whole thing and just send them that, they click, it runs. But if you're averse to this, really, installing wxPython takes, what?, a minute or two? Just have them install it.
&gt; That the various versions' interpreters are compiled with proprietary Microsoft compilers The requirement that you need to use Microsoft compilers to get the *reference* implementation of Python to build on Windows has always bothered me. Don't get me wrong, I actually like Visual Studio, and I do use it for work on occasion. However, the Python docs say that everything should compile with a C89 compiler. They should add "...provided that compiler is GCC (not on Windows, though), Clang (maybe?), or Microsoft Visual C." I've actually been working on revamping Python's support for the [Open Watcom](http://www.openwatcom.org/index.php/Main_Page) compiler. Why Open Watcom? I'm glad you asked. It's mostly because a) I'm pretty damn familiar with it and b) it does a better job than some others (MinGW) mimicking Microsoft's runtime, meaning fewer patches are needed. However, a few patches I've submitted have been largely ignored or died off interest-wise in Python's issue tracker: [19355](http://bugs.python.org/issue19355), [20596](http://bugs.python.org/issue20596), and [20597](http://bugs.python.org/issue20597). A couple that fixed C89 support were accepted, to be fair. With maybe one or two more small changes (haven't submitted yet, pointless until 19355 is at least examined by someone), Python 3.4 runs on Windows after being built by Open Watcom. There are some small issues I'm still working out, but it isn't anything major. 
Ah, good to know.
Worse case scenario is you ship all the odd modules you use with your program... not a very clean solution though.
I actually like Tkinter programming, but I completely understand why people don't like it. Then again, I also enjoyed Swing on Java, so... Tkinter is rather barebones, but it usually provides "enough" for what people want to do. I don't think there's really a good alternative in terms of "capabilities versus complexity and size." With the inclusion of ttk (Themed Tk) in the standard library, they have at least eliminated the butt-ugly aspects of the toolkit.
I also started out with python on a Mac and just downloaded the Python package with IDLE, found it pretty straightforward. Now, I write most of my code in VIM and often make use of the just awesome IPyhon notebook. Once it is installed, IPython notebook is prob. the best tool for every beginner
I'm developing a Django web app that runs on a desktop inside VirtualBox. This arrangement has worked out really well. It's easy to install and works on any platform that VirtualBox works on without modification. The only real drawback is that you have an extra VirtualBox window hanging around. For our users it's not a problem but I could see it being a challenge for non-savvy users.
I would actually consider using http://knockoutjs.com/ for the frontend part in this case. It's quick to grasp and the data binding features you gain are awesome. For the charting feature I would consider using http://www.chartjs.org/. However as always, start out with something simple that works. Charting and such seems like a nice to have but something you can probably add afterwards. W.r.t backend I would agree with cosmicr that Flask is probably a great choice.
A surprising lack of dogs.
JavaScript is the language of the web, unfortunately. 
I think the uptake of python 3, I think for us to move forward as a community we really need to speed that up. 
That's the one I took
You got me there. 
Eclipse has gotten a lot easier lately... *if* you're just doing simple things and you happen to download the correct installer.
I started working on a project a while ago. It was an "ugh, pygame really sucks!" moment. I had grand ideas about how to improve the situation with a set of C++ libraries to do the heavy lifting. The problem is that my new laptop isn't well supported by Linux right now, so I'm stuck in Windows. No problem, I'll just install mingw to get started... You can't build python with MinGW. Only Visual Studio. Really? An open source project that RELIES on a closed-source software to function? This isn't even a super-low-level one like the Linux kernel relying on closed-source BIOS systems. This is the freaking C compiler! After a week of fighting with Visual Studio, I gave up. I started working in Java again. LibGDX is pretty fantastic.
&gt; but Python still suffers from the GIL. Have you ever encountered GIL in your code? People need to seriously shutup about GIL unless you are using `import threading` heavily with &gt;1000 LoC. And yet it's better just using ctypes or C module to release GIL entirely
We want... a shrubbery!
Thanks a lot I appreciate it!
&gt; using native UI widgets Is it real native or just native look-alikes? 
many people tried to promote the "a package to bundle everything to get started" to python mailing lists, official attitude was always "do whatever you want as third party but we don't give a fuck about end-user experience." So please try thirdparties. They are actually very good, ActivePython, Anaconda, PyCharm, etc. 
In my personal experience, people complain about GIL in real life have never written any significant code with `import threading` People does have a problem with their `import threading` with a GIL problems are often doing it wrong. 
Now that you mentioned, Mozilla's implementation might be indeed faster! But both are a lot faster than Cpython ; - ; I just throwed V8 because it's what Node.JS uses. Hopeful PyPy (or another JIT implementation) will rescue python from slowness!
Hands down the religeous war between 2.7 and 3.x. The risk is that people will stick with 2.7 so long that the switch to another language is almost as easy as the switch to 3.x. For instance. I didn't go from vb.net to c# I left the entire MS ecosystem. But until recently I stuck with PHP for years because upgrades were generally painless. I barely noted the differences between on version and another. But on the otherhand PHP did go through a 4.x-&gt;5.x war. The difference there was that the improvements between the two were extreme. Fundamental things like objects were added. So the 5.x version might have pissed off a few PHP'rs but it would have attracted lots of new people (like me). 
getting everything to be fully compatible with: pypy, py3k. the pypy runtime is *fantastic*.
You're doing God's work, son. I'm no Windows guy, but this is exactly the kind of contribution needed to keep Python strong on all platforms. 
So what is the top scores, non-cheating scores. Mine on my first try playing the game was 759,808. I just want to know how far behind that is from the top scores.
I am perfectly comfortable with the command line yet found PyQT a tiny bit of a challenge. 
update: second time playing I got 1,290,240
The pants build tool is listed in pypi as [twitter.pants] (https://github.com/twitter/commons).
Haha, yep!
PyCharm
That's great. Was there ever any support/enthusiasm for seeing this through to be a viable option for wider use? And do you know if Python 2.5--2.7 runs after being built by Open Watcom? And if one can use py2exe to bundle into a single executable afterward? (I know nothing about compilers and Python, so excuse me if these are way off base questions).
You can get some of the network information such as IP addresses, interface names, and types using netifaces (though I prefer netifaces-merged....). For other information such as bytes sent/received/errors you could use psutil. As for link state and line speed, my go to would probably be the /proc file system on Linux or cytpes/pywin32 on Windows. I honestly would really like to have some single network library to handle all this but I've yet to find one. At the very least this avoids having to parse command line output which comes with its own set of issues.
been working on trying to get fast at building django apps, and that `request.POST or None` trick alone will save me 10s of lines
As far as I know, there is no *easy* built in way to do this. An alternative to creating a subprocess and parsing its output, is to just parse `/proc/net/dev` or `/sys/class/net/` yourself. EDIT: clarified
Have you seen this?: http://mpld3.github.io/
Do it whatever way looks best to you. You don't need someone else to tell you how to do something so trivial. 
I honestly don't know enough about it to answer that, sorry. 
First off, as a language, I really /really/ dislike using java - its restrictive paradigms tends to narrow the views of programmers - however libGDX is such a good library that actually makes using java worth it. *Sigh* If only something as well designed existed for python...
In two words: Unfortunately underdeveloped.
virtualenv shipped with 3.3.
I'd probably be inclined to format it like: def function(abc: "default", def="ghi": "default") but that's from a two-minute reading of the linked PEP documents... and zero experience in Python 3.
I'm not sure I understand exactly what you mean, could you elaborate?
I never learned Python. Remember the old ipod/iphone commercial when they say 'you already know how to use it'? That's how I feel about python. I come from a C background. The logic of python is very similar to C IMO, just the formatting is a bit different. Obvously as time went on I found out about 'Pythonic' concepts etc, but if you already have a programming background Python takes about 10 minutes to pick up. I discovered it when I was poking around in the source code for SickBeard.
While as nice as that is, OP asked for an *easy* built-in way to find the information. Looking up defined values in a C header file is far from using an easy built-in. Also, I have updated my original response to say there is no *easy* way of finding the information.
The way is easy enough, there's just no *lazy* way. Programmers nowadays are toooo dependent on libraries. from github import library library.do_my_work()
Fair enough
Ahh okay I see what you're saying now. All of the data and code is available on my github account if you would like to play around with it.
Yep, my mistake.
Why not link them here? FWIW, it appears the Flask tutorial is tagged with '[Flask Biography Tutorial](http://pythonthusiast.pythonblogs.com/230_pythonthusiast/categories/390_flask_biography_tutorial.html)'
THIS THIS THIS 100 times . Application distribution is the biggest pain. Golang and Java has us beat hands down in this area. For non-compiled languages, nodejs's npm package manager beats python's pip + virtualenv combo without a doubt in terms of producing "relocatable applications". I wish we could package up a python program and all its dependencies (c libraries and all) into a single zip file and drop it somewhere and be reasonably sure that it would **just run** . virtualenv, cx_freeze, pyinstaller, and py2exe aren't enough. Portable, relocatable, self-contained application packaging needs to be core to the python experience and distribution for this problem to truly be solve. 
There are a few syntax and logic errors in there...
What about it? 
Yup. It's a rough draft of mine and very unfinished. I really wish this wasn't linked here. :-( I've made the mention that this is a rough draft more obvious.
I'm the author of this article and I'm disappointed that you took my ROUGH notes (there was a warning at the top saying it was unfinished) and posted them here. I don't appreciate that you linked to an article that stated it was in rough draft format. For what it's worth I've now taken the liberty of putting a very stern message at the top of the article.
Just made me chuckle, what with the comment about devs being too reliant on libs. Where as I consider django to be one of the worst examples of this personally. (Not saying it is bad - I use libs, I love libs, more libs more better, just funny.)
I just deleted the repo. Discussion over.
I just deleted the repo. I'm not annoyed at you, but I am annoyed by the poster. 
It's not cgi-bin era where you can printf a whole website anymore, buddy. Django's forms, admin is unprecedented for fast development with a deadline. Yes I use django, but I don't use any of thirdparty Django extensions. 
I'd say the libraries. When I'm working on something, there's almost always a library that is exactly what I'm looking for. And it's been developed to a mostly stable state. And then it's been dormant for years. I've started to notice this trend on more libraries that I depend on, and it's unsettling. Bigger libraries still get a lot of attention and updates, which is great. But smaller, important libraries tend to get left behind. I'm still on 2.7, because of certain libraries I depend on. I never even bothered learning 3.x syntax since I can't use it yet. I wonder if it's just that the community is relatively small, so there's not much demand out there. Thankfully there are more alternatives popping up for sine of the longer abandoned libs, but it's still a precarious situation sometimes.
IDE is not generally the place to start for a beginner.... but PyCharm might be what you're looking for.
I don't see plotly mentioned yet... https://plot.ly/ Google's plotting api used to be popular as well, but I seem to read more about these other fancier tools these days.
Again, not saying it is a bad thing - just made me chuckle.
1) If you write stateless services it's not even an issue. Which isn't so hard if you're using a database, redis, rabbit, etc. 2) import multiprocessing
There happens to be a very active Python and Django community in Ann Arbor, including a very active [PyLadies](http://www.pyladies.com/) community. You should checkout the [Michigan Python Developers Group](http://www.meetup.com/Michigan-Python-Development-Group/) in that area as well.
stop being so annoyed at everything! please.
Five minutes? And you think that's a *good* thing? With Python, it's already installed. Open a console and thirty seconds later you're writing Python. Seriously, if you plan to be a programmer, but cannot or will not deal with the command line, you won't be a good programmer. http://michaelochurch.wordpress.com/2013/01/09/ide-culture-vs-unix-philosophy/ I mean it. You can write Java code but typing `python ENTER` at the command line defeats you? I don't think so.
I didn't have python 3 and there weren't any libraries installed. When looking at a lot of libraries websites/tutorials they seem to be projects written by a group of friends for that group of friends. Not some random guy trying to do some scientific computing. Also a command line isn't exactly a great development environment. Not everyone aims to be a professional programmer, some of us just want a script once in a while.
Go to website, click download, wait a minute, click yes on every popup when the program is done downloading, profit.
Parallel programming is simply not a significant issue for vast reams of code that isn't CPU bound, or doesn't need to be super-fast. A few threads to handle I/O, if you can even be bothered, and fast enough is fast enough. Why deal with the complexity of threads? For the rest, multiprocessing is no more complex to use than threads, and is as good or better.
how is g-i + gtk coming along? Have former pygtk2 applications ported over?
Are they both on 3.4?
The take up of Python 3 is pretty much right on target compared to expectations. The transition was planned to be a long process, to minimize disruption for the 95% of users who are actually using Python to get work done and don't need or want to have to upgrade their code for no good reason. In other words, if you're an application developer, and you haven't moved to Python 3 yet, you're not letting the side down. The Python core developers knew that you wouldn't be in any great hurry to migrate, so relax and take your time. Migrate when you're good and ready. (Library developers, on the other hand... come on guys, it's been five years.) However, for *new* code, people should seriously consider writing new code in 3.x unless there is a compelling reason to stick with 2.x. 
In fact I know what is ML. A simple linear regression model or logistic regression are instances of algorithms used in ML, and are implemented in Numpy/Scipy. To make work on ML you can use scikit-learn or orange and use it as a black box, or go to Scipy and implement your model yourself. In both cases 'crunching', ploting and interactive use are needed during the ML work.
PEP 8 is the style guide for the standard library. Since the std lib doesn't use annotations -- GvR doesn't want to standardise on a single use for annotations this early in their history -- it's not surprising PEP 8 doesn't give much guidance on them. I prefer the look of your second example: def function(arg:str='default'): pass 
I'm not sure this is pattern matching. It seems more like generics, which has been available in Python for many years, but not documented. In 3.4, it's now documented and fully supported. http://docs.python.org/3/whatsnew/3.4.html#whatsnew-singledispatch
If pep8.py shows an opinion, I'd be inclined to follow it as a de facto standard.
I agree with a lot of the points in that thread. Python to me is more of a quick prototype or piece things together language. For my large applications with extensive sql interfaces, large text processing, fast math algorithms, etc are in Java. Python just doesnt scale easy and is slow and can be buggy. 
I'm not sure what you mean by "duplications", but I claim cffi is a better way to call C from python than CPython C API, whether you're on CPython or not.
The library situation can be bad. So many good libraries just not kept up to date. I hope it changes as more corporations start using it.
They have only broken backwards compatibility *once*. As far as I'm aware even the transition from Python 1 to Python 2 was compatible, and besides that was *[15 years ago](https://en.wikipedia.org/wiki/History_of_Python#Version_release_dates).* Python 3 broke a little bit of syntax and changed the structure of some libraries, to clean up the duplicate and redundant features of Python 2 that those fifteen years had given rise to. In no way is breaking backwards compatibility a thing that is done regularly or without reason.
It *is* PyCharm.
Is there some sort of push/trend in the main CPython community to get that adopted as the best/first/easiest way to wrap some foreign code ? I don't know, I mean Europython is coming...
there was a project for using python with libgdx ...
Use Qt, it has it's own logic but it is quite easy and very powerful. Gtk on linux is quite a good choice too (but less powerful).
cffi is incredibly popular on pypi, so I guess so?
Their proper use is undefined. @type def f(x:"what", *, key:"ok"=None) -&gt; "huh?": "don't do this" 
There's psutils, which will solve most of your needs. You may want to check it. It's cross-platform so maybe it won't fit all
Sadly that's not the syntax. It goes `argument` `:` `arbitrary_object` `=` `default_value`. Weird eh? Might as well be C or something. Nobody can read that.
Oh dear.
With G.I., assuming you can handle the raw data, you can load a file asynchronously through the Gio async methods which delegate the asynchronous loading to the native library avoiding the GIL. I wish I had a way to load Zip files asynchronously like that, though.
Hm. I see. I'm still stuck using Python 2.7 because of Twisted, so I won't be using that for a while yet.
Out of interest, why are for loops in python be so slow? Surely it just calls on highly optimized C anyway?
Was he suggesting PyCharm to the nice redditor?
He asked how this was better than Sublime Text or PyCharm.
I've done some of Project Eulers problems also, I enjoyed them but damn I had to learn some more maths also that I either never learned or forgot. Kind of a 2 birds with 1 stone place for me.
I use the Community Edition of PyCharm and Eclipse PyDev. And still don't know why people love PyCharm so much. I am missing something, I know. But what? What am I missing?
If it is a remote network device you want information of, a better solution would be to use snmp. Python has pysnmp to make snmp calls and collect data.
Hi there, I was wondering if you possibly know how to sort an issue I'm having with mutagen, installing it is a nightmare but apart from that .. I can't find any documentation online about how to enter the info returned from the API into the corresponding ID3 tags. I've tried faffing about with it, but since it's due tomorrow I am getting to the end of my wits lol! Do you have any idea?
Head of nail and hammer just met, romanced and made an epic action movie with Dolph Lundgren and full penetration scenes and what have you.
&gt; Was there ever any support/enthusiasm for seeing this through to be a viable option for wider use? None, but I haven't really publicized the work (yet). I did submit a PyCon lightening talk proposal for this work, but it was rejected for whatever reason. &gt; And do you know if Python 2.5--2.7 runs after being built by Open Watcom? Python 2.x is considerably easier to port in my experience. With similar patches, Python 2.x could be built, but I don't really see the benefit of doing so at this point. Python 2.x is dying. &gt; And if one can use py2exe to bundle into a single executable afterward? Any Python extension that works with MSVC Python would work with OW Python. However, I don't believe py2exe works with Python 3.x, so you'd need to use cx_Freeze. I haven't yet tried it as there are still issues with the standard library test suite. 
Use the VIM, Luke
Not actually "native".
I do a lot of hard-core server programming with Python and feel like it is an overly fragile environment for doing anything complex. For example many libraries don' say if they are thread-safe and if you dig into code you can find all kind of landmines waiting for you. Multi-processing is overly complex and fragile, try killing one of the workers and see how it is handled. As servers grow in complexity, I lament the lack of type checking. Finally, for CPU bound tasks, writing code that you know is 10x slower than a good compiled language is depressing. Python is a well rounded language, but isn't really great at anything. Perhaps that is a compliment and not a criticism. 
I'll leave this here https://github.com/AppEnlight/channelstream Its a websocket server written in gevent with http master/client communication, check out the demo :-) Its architectured so all kinds of services can broadcast messages to clients, worker queues, crons, php whatever you want that talks json and can do plain http requests.
I started going to Python conferences in the late 90's. The "downsides of Python" lists in those talks were pretty much the same as these. 
I don't mind java as much as a lot of people seem to, especially when working with others. Libgdx is really the result of a perfect storm of technology around java. I don't think it could ever happen in python.
I've seen posts on here for this sort of thing. Send a link to myself not too long ago. In mobile right now, but I'll check my inbox in a bit. I'm also interested in this. I would assume it has something to do with parsing XBRL. You Dan also check out YQL tutorials. They have some pretty decent examples and may be transferable into what you're looking to do. 
It's not such a biggie, but most of the code I wrote for [PyPrind](https://github.com/rasbt/pyprind), my little Python Progress Indicator, e.g., to calculate the estimated time left until a loop finished: def _calc_eta(self): """ Calculates estimated time left until completion. """ elapsed = self._elapsed() if self.cnt == 0 or elapsed &lt; 0.001: return None rate = float(self.cnt) / elapsed return (float(self.max_iter) - float(self.cnt)) / rate 
thanks - hope to hear back once you're off mobile
That's fine if you use annotations for typing, but that's not their only potential use.
Backwards compatibility problems in that code that worked on 2.6 was broken when running on Python 2.7?
Who would downvote vim ;-;
Ugh... I'm going to get downvoted to hell for this but... No! Please, GOD no! PLEASE let Python 2 be riddled with holes and inferior and insufficient! Please let Python 2 DIE. I don't care about your business needs. This isn't about your business needs. This is about Python. This 2 to 3 transition is taking too damn long. Instead of a path to 3.x forming, we've got a community divided. We need to make it important to upgrade to Python 3, not coddle the lazy developers/companies so they can keep their old dusty codebases working.
Yea I work with windows and linux, almost no issues on linux but it's a huge pain to setup a c compiler with windows. I find myself install pre-built binary packages most of the time.
&gt;This isn't about your business needs. This is about Python. Erm... yeah... the two are *totally* unrelated...
Heavily disagree. Python 2.7 exists as an older language. It is silly to think that all programs need to be updated to new languages, especially if they're only in maintenance. I personally think these fixes are reasonable because I find the idea of shitty security really, really bad. If someone has my account details, they should have the support to keep that account safe. This isn't about *them*, it's about the users.
This is not about old software! NEW software is being written for python 2.7! There's a lot of great Python technology out there that STILL doesn't work with 3.x! This is, quite simply, insane. If we didn't have the schism problems that we're facing right now, I'd be right there with you, but this is really starting to get out of hand. We need to light the proverbial fire under their asses. Declare Python 2.x EOL, and move on.
I don't get why you're so irked about it. That people decide to use an old language doesn't impede your ability to use the new one. New libraries are almost exclusively Python 3 compatible, so that side is fine. The core developers aren't moving their focus away from Python 3. The wonderful new load of features and fixes is a testament to that. 2.8 is *not* happening. There's no need to feel threatened by people using 2.7. You have the upper hand already; just give them time.
http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html is a really good tutorial on using hon and gtk+3.
This definitely got me going in the right direction. I seem to still be having troubles getting pyinstaller to find the flask-login module I am using, but all the SQLAlchemy and basic flask stuff seems to be importing properly now. Thanks. Edit: Took a lot of effort trying to get some of the extensions tracked down and figure out the formatting, but it does work and everything is nicely packaged. Thanks again!!
&gt; I don't get why you're so irked about it. That people decide to use an old language doesn't impede your ability to use the new one. Yes, it does. I can't use Python 3 for one of my clients, because RedHat doesn't support Python 3. Yes, they could build and install a custom Python. Yes, they could pull an RPM from EPEL. They won't do either, though, because their security auditor doesn't permit them to install system packages from non-mainstream repositories. If they found out there was a security problem with Python 2, they might consider changing their policies. They might put pressure on their developers to upgrade their codebases to support Python 3. Those developers might put pressure on the writers of the libraries they use to support Python 3. Instead, we propose to take away one of the most influential motivators we could ever introduce to getting people to upgrade. 
I've never had problems with embedding PyQt when building a binary (I use PyInstaller). 
Too expensive, I'll just wait until I can find it on the pirate bay
&gt; Yes, it does. I can't use Python 3 for one of my clients, because RedHat doesn't support Python 3. Isn't RedHat still pre-2.7? If they can't do that, what makes you think not back-porting a security fix to 2.7 will make a difference? &gt; If they found out there was a security problem with Python 2, they might consider changing their policies. Firstly, people's security isn't so unimportant a thing that communities with as much responsibility as CPython's should hold it hostage. Secondly, this is a security enhancement, not a problem found in it. Security fixes are already backported.
&gt; Ugh... I'm going to get downvoted to hell for this but... I wonder why... &gt; I don't care about your business needs. Oh that's why! That was easy. &gt; This is about Python. Oh so Python is now language used for toy demos and little github projects. Ok, cool to know. &gt; we've got a community divided. Hmm, I wonder why that is. &gt; I don't care about your business needs. Oh that is why! &gt; not coddle the lazy developers/companies Companies/developers are the reason Python exists and is used today. If you wanted a toy language used for demos, find the latest fad and live on the bleeding edge.
Yep. I am going to fork the mechanize (headless web browser) library today and try to make some changes (and find a way to merge the pull requests that are on the original repo on GitHub). This library is great, though it has some issues. But the last commit was 4 years ago... As you may imagine, it doesn't work with Python 3 either, so I'll try to address that as well. 
&gt; This is, quite simply, insane. Yes the world has gone crazy and one sane lone warrior -- the_hoser is left preaching the truth. Or maybe it is not the world that is crazy.... &gt; If we didn't have the schism problems that we're facing right now I wonder why that is? Oh yes, you don't care about business needs, that why. &gt; Declare Python 2.x EOL, and move on. Ok, but it won't be a move to Python 3. It would be a move to Rust, Go, Node.js, C++11, Java, Scala 
&gt; REALLY wish you could make stand alone/GUIs in Python that I could share amongst co-workers rather than having to run scripts for them... Well, you can... it's just kind of a process. PyQt application + pyInstaller to create binaries. 
That depends on the project. I have alone written a desktop application (powered by Qt) with over 40.000 lines of code (probably some DRY, but oh well). You bet I'll use an IDE (and I was using PyCharm). 
Yep
Every time I try to install eclipse I spend hours trying to make it work the way I want, always fail, and then go back to vim. 
&gt; Ok, but it won't be a move to Python 3. It would be a move to Rust, Go, Node.js, C++11, Java, Scala Some would sure. But it would not be very many I believe.
Ugh... honestly, that's wading into "I'd not use python for that" territory, personally.
Except these changes require you to actively implement them in your program in order to use it. Chances are that it will never be used in legacy code and instead it will increase number of new applications and libraries for 2.7. It would be also one less reasons to update. Kind of like currently many people complain that there is no new things in 3, and that is exactly because they were backported to 2.7.
I've spent quite a bit of time attempting this with S-1 prospectuses. The filings (.txt files direct from sec.ftp) generally bundles the filing with a bunch of gifs, exhibits and headers, e.g: [Twitter] (http://www.sec.gov/Archives/edgar/data/1418091/000119312513390321/0001193125-13-390321-index.htm) . You need to read the file and remove the SEC tags: import lxml def remove_PEM_tags(filing): body = filing.split(b'&lt;SEC-DOCUMENT&gt;')[1].split(b'&lt;/SEC-DOCUMENT&gt;')[0].strip() return b'&lt;SEC-DOCUMENT&gt;' + body + b'&lt;/SEC-DOCUMENT&gt;' def remove_pagebreaks(filing): filing = re.sub(b'&lt;page&gt;', b'', filing) filing = re.sub(b'&lt;/page&gt;', b'', filing) filing = re.sub(b'&lt;!--.+--&gt;', b'', filing) return filing filename = '0001193125-13-390321.txt' # Twitter S-1 with open(filename, 'r+b', encoding='latin-1') as f: body = remove_pagebreaks(remove_PEM_tags(f.read())) root = lxml.html.fromstring(body) tdoc = root.xpath('//text')[0] Only the tdoc (&lt;text&gt; elem) will contain useful information, the rest of the elements are binary image files. From here you can use any of the html/webscraping modules like pyquery or beautifulsoup. For example, if you want to grab all the bolded elements in all the tables, you might write something like this: from pyquery import PyQuery as pq titles = pq(tdoc)('table')('tr')('td')("b") titles.outerHtml() titles.text() # +lots of nifty functions on the pyquery site Because the documents are quite large, it's better to split them up into sections, e.g. 'Selected consolidated financials' or 'Management's Discussion and Analysis' (titles in the contents page). The titles in the body of the filing almost always follow an &lt;a href&gt; tag that links back to the contents page. Warning: the table cell spacings are often off (lots of &amp;nbsp) and split across a few rows. It might be better to pull the entire table into excel. Around 70% of filings use similar standard language but there is quite a large number of edge cases. XBRL maybe be better for recent filings, [pysec](https://github.com/lukerosiak/pysec) looks promising although it looks difficult to extend. You can ignore the django/database parts of the tutorial, just download the filings from SEC manually and test out the parsers. 
&gt; I don't care about your business needs. really? &gt; I can't use Python 3 for one of my clients, because RedHat doesn't support Python 3. then grow a pair and make that client port off red hat and quit whining like a big pussy. Or, you actually do care about someone's business needs. Hope you learned something. 
is PyLadies open to PyMen as well? :)
No, they're not. They're wish-washy, and open the flood gates to the idea of backporting *features* to Python 2. These changes won't fix legacy code. They only make it possible to take advantage of a *new* feature in *new* code.
Seriously?! try: # .... except Exception, e: print "ERROR: Caught exception: " + repr(e) raise e sys.exit(1) - It's completely useless, the interpreter will do everything you do here for you. - Your 'sys.exit(1)' will never execute, since you re-raise the Exception one line above ~~It's really sad how much blogspam this subreddit has been getting lately....~~ Had a bad day, sorry. Still, serializing an SQLite query result into a dict and then into JSON doesn't really qualify as insightful....
The other points you made are uncompelling, imo.
It's better than reinventing the same wheel a thousand times. Then you end up with ~500 square wheels.
because using threads for CPU-bound work is a very small use case. once you need the work to span multiple hosts you need a multiprocess design, and that's a more maintainable and debuggable configuration anyway.
Not a significant or interesting limitation.
I've discussed this with a few others. I use Qt a lot of the time, but the issue is that it's not in the stdlib by default which can be a huge pain when you want to distribute a quick script.
Yeah, sure. It's largely an opinionated thing. I come from a Java background, so I've had plenty of experience developing GUIs under Swing (Java's standard GUI package). Having liked Swing, I probably already have high standards set for what I believe to be a good GUI package. Swing just feels more sophisticated than Tkinter. With Tkinter, at least in my opinion, everything feels slung together. I'd advise learning it since it's not exactly difficult, and it's already in the stdlibs so I guess that's useful. I understand that this is going to be really subjective.
sorry, I meant applications.
I've just had a quick look through and I'm not an expert, however.... By the look of it the program goes through the text and splits it into sentences. It picks a sentence and then counts how many words, on average, it shares with every other sentence. It then picks the sentence with the highest number of words in common with the rest of the text. Hopefully that makes sense, just say if it doesn't. Just bear in mind I may be incorrect.
I understand but you may be biased : most languages, excepted java, don't include a gui library in their standard library.
Wow, this is really cool
&gt; this module is almost entirely synchronised with its Python 3 counterpart, bringing **TLSv2**, SSLContext manipulation, Server Name Identification, access to platform certificate stores, standard library support for peer hostname validation and more to the Python 2 series. Should that read TLSv1.2?
A lot of these example remind me why I avoid re-using names basically at all costs. There are so many bugs that are caused by misunderstanding of what references what when, this is why I try not to use loops or mutability.
You can pip install an editable copy (which is just a link). You do so like this (in the directory of the package you want to install (which must have a setup.py): pip install -e . 
http://www.pip-installer.org/en/latest/reference/pip_install.html#editable-installs pip install -e git+ssh://git@github.com/pyqtgraph/pyqtgraph#egg=pyqtgraph Clones the sourcecode from GitHub into `./src/pyqtgraph` (with git over SSH) and then creates a `pyqtgraph.egg-link` file in `site-packages` containing the path to the cloned source; which functions like a cross-platform symlink. python -m site Should list the source code directory in `site-packages/pyqtgraph.egg-link`. *If you'd rather avoid globally installing in-development code*; `pip install -e` should work with all of the following: * http://docs.python.org/2/install/index.html#alternate-installation-the-user-scheme * http://www.pip-installer.org/en/latest/reference/pip_install.html#cmdoption--user * http://www.virtualenv.org/en/latest/ * http://virtualenvwrapper.readthedocs.org/en/latest/ * http://conda.pydata.org/docs/ (`conda install qt`)
Great post, working through these gotchas with [python tutor](http://pythontutor.com/visualize.html) really helps to understand python better!
Thats pretty ingenious actually. I had a little bit of a dig myself, it uses nltk.corpus for its stop_words dictionary, that seems to be a list of words that provide no contextual relevance to a sentence, if that makes sense (worlds like the, and, or, actually) Those words are not included in the comparison so the algorithm can determine the subject of the text easier. Fantastic idea!
&gt; you grab hold of all the global and local variables and let the values dangle. Anything that isn't directly or indirectly referenced by one of those names will fall to the ground and is garbage. That's one great visualization for GC!
I'd say [virtual environments](http://www.virtualenv.org/en/latest/virtualenv.html), or something like [Rockstack](http://www.rockstack.org) if you're lazy.
That seems to only support functions with a single generic argument, where as both implementations here support multiple dynamic arguments and have support for different numbers of arguments and such. For example, if you wanted to implement add(x, y) where x was a float or an int, and y was also a float or an int, and you wanted different things to happen in each case, the functools method would not be enough. This is all kind of silly though, since using this would be heretical anyway. 
seeAlso: http://www.reddit.com/r/Python/comments/21i1x0/pep_466_would_allow_some_network_security/
Competition from the ever-growing community of scripting languages. * JavaScript * PHP * Perl * Erlang * Lua * Lisp * Haskell * Bash * Zsh * Sed * Awk * Tcl * VBScript * MS-DOS Batch * PowerShell * Frink * UnrealScript * FOSE * Squirrel Sometimes they even make *not*-Python, an odd facsimile of actual Python. * Boo * BeanShell * Groovy * Ruby If only Matsumoto and van Rossum would combine efforts...
&gt; I tested it out and it turned out to have some problems in reaching the 4098 tile in a reliable way I'm not surprised. I would be extremely impressed with any AI that could manage to get a tile that wasn't a power of 2.
What was the code that broke? What was the fix?
Basically, writers naturally include a summarization sentence in each paragraph. Generally that summarization sentence will have the largest word intersection with other sentences because it's including thoughts from all those sentences. It's not doing anything really smart, just exploiting a common style of writing. That said, it works pretty well, if I can say so myself :P
Backporting features (+syntax changes) is what has made it possible to write code with dual support for Python 2.7 &amp; the latest 3. That has done more to aid me moving from 2 to 3 than any not porting would have done.
https://wiki.python.org/moin/GlobalInterpreterLock
I put a comment on the original blog post about this issue, linking to this thread. So it's linked both ways now, which should help readers notice the issue and your comment. 
If you could find your code and send it to me that would be fantastic, and I would love you forever. I'm currently working in VBA (much better in VBA than Python), but the data I'm able to get is not clean at all.
A threat to move to Ruby would be more credible than most of the languages you just listed.
Yay. Another reason for developers to not update their program's/libraries to python 3!
Yes. Indeed it is.
First, cool idea. Second, if you are doing stuff with real file paths you should probably use `os.path.split(fp)[-1]` to get the filename. I'm not sure what system you are running this on, but if the webpage is simple enough couldn't you do a "wget" or "curl" command into a temporary directory and then copy the image file? That is probably 3 lines in a bash script, doesn't require python, and will likely run on all unix systems. Does the image filename actually change over time? If not then you could just learn what it is and "wget/curl" it. If it does change then there is probably a way to configure the filename format on the oscope itself. If I was going to do this and the bash way was too ugly and had some weird requirement where I could only use the standard library I would probably use a TCP socket and the "SAVE" command: http://www.home.agilent.com/upload/cmc_upload/All/4000_series_prog_guide.pdf?&amp;cc=US&amp;lc=eng Again, neat idea. Edit: After skimming that PDF I'm not sure how you would download the image.
Great, PM'ing now - thanks
&gt;if you are doing stuff with real file paths you should probably use `os.path.split(fp)[-1]` to get the filename. All HTTP URLs are POSIX paths, so `x.rsplit('/', 1)[-1]` is also correct (as is its slower form, `x.split('/')[-1]`.)
Lecture materials at: https://developers.google.com/edu/python/
sad but true. 
I wasn't suggesting that they needed to use os.path in this script, but for some reason I thought it was useful to mention it (not sure why). I also made the assumption that everyone uses linux...which kind of defeats the purpose of using os.path.
&gt; Another reason for developers to not update their program's/libraries to python 3! another reason is, I enjoy people getting all butthurt about "slow adoption" of python 3. So much time and energy wasted bitching about it. Meanwhile I will instead use the time I save making awesome things that people will pay me for in hard currency rather than fake internet points. it thins out the competition, makes my job easier.
Not really checked it out. Taking a look now.
Just trying this out. I need to download something from nltk. Which package/collection/corpora/models do I need? Edit: Followed the error messages to download what I need. Perhaps include the nltk.download() instructions in your readme?
should != is
Hmm any way to tweak how general or specific the summary is? Like include more output/less generalization?
It's actually not just for loops, it's the whole python interpreter that's slow. It's just easiest to see in big for loops because those execute a lot of python instructions. This is pretty annoying, and is the reason pypy exists. You can't use numpy with pypy though, so instead people rely on vectorization to make numeric code fast in python. All of the fast versions of this operation that have been posted (mine here, and the others on stack overflow) are fast because they execute fewer operations inside the python interpreter. np.apply_along_axis and friends loop over the axis in python, the vectorized versions push these loops into BLAS where they are fast.
It's a process of elimination: Rust is too young, most Pythonistas don't want to be in spitting distance of C++, they make fun of Java. That leaves Go, which seems to be mostly contained within Google, Node.js which is JavaScript, another language Pythonistas like to make fun of, and Scala. I could see Scala being a threat, except its momentum seems to have died down because of all the conflicting abstractions and approaches to programming have made it intimidating to many newcomers. That really leaves Ruby (or possibly Lua, depending on domain) to be the real threats.
Fair Use allows you to share selections, charts, etc as long as you're not sharing a significant body of the source. A few paragraphs and diagrams from a text book will probably fall under that
It depends on the domain. Web-by things - Ruby or Node.js Concurrent IO backend systems (includes in Web-by things) - Go, Rust, Erlang, Java, Scala Scientific Computing - Julia, R, Matlab 
&gt; I'd love to be able to create a single stand-alone self-contained web application and ship it across different platforms. Maybe this is something for you? https://www.docker.io/ 
You answered your own question. Its best to use google apps calendar api v3. IIRC even for public calenders you need to use the auth and most definitely need to use your api key (for abuse purposes). 
I picture the python 2 crowed working on windows xp.
i'm digging clojure myself
If your package has dependencies upon other packages, then your setup.py will need those packages to be installed first. This is a path to madness ... The version information _only_ needs to be kept in the setup.py (or setup.cfg) file. The installer will take care of writing out the version information in a metadata file. If you want to read the version information at runtime, you can use pkg_resources (um, there is a similar API within disutils itself, isn't there?). This is the best way because it's the use case that supports all cases: &gt;&gt;&gt; import pkg_resources &gt;&gt;&gt; pkg_resources.get_distribution("setuptools").version '2.2' If you want to support the old-school style of getting the package version from a \_\_version\_\_ attribute (old habits die hard!), then you can put this in your package: &gt;&gt;&gt; import pkg_resources &gt;&gt;&gt; __version__ = pkg_resources.get_distribution("mypackagename").version 
Google provides a client library that eases the oAuth signing flow. It is called, rather unimpressively [Google API Python Client](https://developers.google.com/google-apps/calendar/setup). Once you set it up, you need to configure a the `service` object in your python code, the full code for which is available here: [Configure your App](https://developers.google.com/google-apps/calendar/instantiate) The end-product of the code is: service = build(serviceName='calendar', version='v3', http=http, developerKey='YOUR_DEVELOPER_KEY') Once you get a properly configured `service` object in your python code, reading a public calendar is just the matter of accessing the `list` method of `Events` with a specific `calendarId`, as explained here: [Events: list](https://developers.google.com/google-apps/calendar/v3/reference/events/list#examples)
Pypy not viable for any of the scientific users of python. Unfortunately numpy and co are pretty tightly tied to CPython.
Oh so the screen capture doesn't happen until the http request? I guess that makes sense. Depending how it stores the images and how long it holds on to them you could probably do (on linux, sorry): wget http://10.20.20.91/getImage.asp?inv=false &gt; /dev/null wget http://10.20.20.91/source/temp/*.png Not that using python isn't cool, was just curious if this was possible.
Wait... so having a ``__version__`` variable in your ``__init__.py`` is no longer recommended? I've never heard that.
Yeah, but you are putting *all of your application logic* inside a single try-catch block. This is really bad style, in every programming language that supports exceptions. It would be better to only catch and print custom error messages for errors that you actually expect. Not to be be rude here, but I really wonder if all those qualifications you list on your web site can be taken at face value if you code like this...
Well, I don't know if it's been explicitly discouraged, Python packaging hasn't completely settled on one method. It's certainly not the way forward though. The Standard Library is still packaged in an ad-hoc manner, so you still have to rely on module.\_\_version\_\_ for packages that come shipped with Python. For example: &gt;&gt;&gt; import pkg_resources &gt;&gt;&gt; import json &gt;&gt;&gt; pkg_resources.get_distribution("json").version Traceback (most recent call last): ... pkg_resources.DistributionNotFound: json &gt;&gt;&gt; json.__version__ '2.0.9' But if it's a project where you care about the versions of packages you are using, you should be pulling the packages from PyPI (e.g. use the 'simplejson' package instead) and not using the ones in the Standard Library. The Standard Library packages aren't packaged and they have no maintenance releases other than getting pulled into updates to the Python language release itself. But updating your entire interpreter to pull down a bug fix for a package dependency is crazy. 
I subscribe to the Rob Pike definitions of concurrency &amp; parallelism, so if we're talking about keeping the GUI responsive while you have a compute heavy loop running, parallelism is needed there. In any case, we're talking about the interaction between the GIL and the python threading module (which is the exact situation where you're trying to run things in parallel). The GIL doesn't make any difference (besides making your life a whole lot easier) when you're just writing straight up async code.
In addition to the options listed in the other comments you could also use the abstract syntax tree to parse an \_\_init\_\_.py file that looks like this: import os from package.foobar import foo """Some documentation""" __version__ = (1, 2, 3) Using this: import ast with open("/tmp/__init__.py", "r") as init_file: module = ast.parse(init_file.read()) for node in ast.walk(module): if isinstance(node, ast.Assign) and node.targets[0].id == "__version__": major, minor, micro = map(lambda v: v.n, node.value.elts) break print major, minor, micro This really is not a great option if you don't have to use it but if you're working with a bunch of internal packages at a large company that vary quite a bit in terms of structure then the abstract syntax tree can sometimes help
As this thread shows, a splintering of constituencies due to popularity is a problem facing Python. For example, many of the wish list items for people in this thread aren't really important for someone writing servers or doing scientific computing. This is a symptom of popularity. Many people have come to Python for different reasons, and now they'll start pulling it in directions it wasn't necessarily mean to go. Personally, I think Python should focus on it's role as glue code for connecting complex systems. The one to rule them all idea is dead for languages. Distributed services and little nodes all over the place means we'll need the handy Swiss-army-knife-language that I use Python as.
F#? is that still a thing? 
If this happens, CPython 2.7 will be forked off and still have ongoing continued development to support the endless production systems currently using Python 2.x in production. At that point Python 3.x will basically be considered a completely different language developed in parallel to the forked off 2.x branch until the end of time. I'm sure will probably be worse for 3.x adoption.
Tried contributing upstream?
Enough backporting pls
I know I'm late to comment but the question is what I've been thinking about recently, so I post it anyway. My answer is: Python 3. No, I didn't mean the transition to Python 3, which is forced by killing Python 2. Python 3 itself IS the biggest problem. As a hobbyist programmer, I don't think breaking backwards compatibility is so bad. I live in the world where beautiful is better than compatible. But the way Python 3 breaks that is awful. In other words, Python 3 is a horrible *language*. Python 3 is horrible mainly because it lacks byte-strings. `bytes`? That is similar to Python 2's true byte-string type `str` but have significant differences. That is, Python 3's `bytes` is not a byte-string type but a list-of-8bit-integers type. This problem is well explained in [/u/mitsuhiko's article](http://lucumr.pocoo.org/2014/1/5/unicode-in-2-and-3/). I'm going to describe it in my words. Python 3 doesn't have byte-strings as I just said. Which means, Python 3 doesn't have what Python 2 has, what even C has. Since C and other mainstream languages have them, many things assume the existence of byte-strings, especially network protocols. Consider generating a simple HTTP request. In C, the code would be like `sprintf(buf, "GET %s HTTP/1.0\r\nHost: %s\r\n\r\n", path, host)`. No problem of course. The same goes for Python 2: `"GET %s HTTP/1.0\r\nHost: %s\r\n\n" % path`. But sadly in Python 3 one have to do things like this: `"GET {} HTTP/1.0\r\nHost: {}\r\n\r\n".format(path.decode('ascii'), host.decode('ascii')).encode('ascii')`. The reason such cumbersome code is required is that Python core developers intentionally made the change to "distinguish" unicode strings and byte-strings, removing formatting functions from `bytes`. This is the result. You can find almost the same code in [the official documentation](http://docs.python.org/3/library/asyncio-stream.html#example). To excerpt: url = urllib.parse.urlsplit(url) reader, writer = yield from asyncio.open_connection(url.hostname, 80) query = ('HEAD {url.path} HTTP/1.0\r\n' 'Host: {url.hostname}\r\n' '\r\n').format(url=url) writer.write(query.encode('latin-1')) This specific problem can be solved by adding formatting functions to `bytes` again. ([Guido apparently feels the same pain](https://mail.python.org/pipermail/python-dev/2014-January/131340.html) so that is likely to happen I think.) But the fact `bytes` being list-of-8bit-integers would keep causing problems everywhere. For example, indexing (`__getitem__`) of `bytes` returns an integer, `int(b'42') == 42 and bytes(42) == b'\x00'*42` though `int('42') == 42 and str(42) == '42'` in Python 2, etc. I wish Python 3's `bytes` were identical to Python 2's `str`. I'm now thinking porting Python 3's cool features (such as `yield from` and `nonlocal`) to Python 2.7 and create an unofficial Python 2.8.
I can't help you specifically, but I can also point you to [Nuitka](http://nuitka.net/).
"""Exception Handling""" ^^^^using ^^^^triple ^^^^sarcasm ^^^^quotes
&gt; No! Please, GOD no! PLEASE let Python 2 be riddled with holes and inferior and insufficient! Please let Python 2 DIE. Tell that to millions of decade old Linux/BSD distros. Hell some of them even run Python 2.4
use `bytearray()`
&gt; neither string.Template, format, nor str.format are under consideration The PEP reads, but I can't find the reason. Does anyone know why `bytes.format` is not included?
Lol, in the last two days I've seen the following sequence of posts &gt;I need to share my application, how do it? &gt;&gt;Use pyinstaller. &gt;I need to share my application, how do it? &gt;&gt;I used to use pyinstaller, now I use py2exe. &gt;I need to share my application, how do it? &gt;&gt;I used to use py2exe, now I use cx_freeze. &gt;I need to share my application, how do it? &gt;&gt;I used to use cx_freeze, now I use Nuitka. It's even the top comment here http://www.reddit.com/r/Python/comments/21ftfn/what_are_the_biggest_problems_facing_python/. The fact that it's damn near impossible to distribute python programs to either 1. someone who doesn't have python (semi fixable as long as they...) 2. don't have python and run a different OS to you, or even the worst one 3. have python but haven't installed the third party dependencies your program needs (not everyone can install them and it's apparently not possible to package up any dependencies to distribute) This, at least for me, is what really kills python as a language. To be honest, it's still a toy language. This is why so many people don't take it seriously. It has the potential to be the best programming language. But it's so fragmented and impossible to distribute that it's not worth it.
Just what I am thinking of!
Python isn't a toy language, but it's a toy when it comes to writing and distributing GUIs. Python is heavily used on web servers, in scientific computing, and system scripting - all cases where you control the environment and don't need to ship exes to users. Also, it's normal for Linux and OS X to come with Python already installed, although that can be an old version. Oh, and if you want yet another option for distributing GUI apps, I wrote a template [Python NSIS installer](https://github.com/takluyver/py-nsis-template). It's very much a prototype, though - if you want to use it, be ready to hack on it.
Right - your first wget would generate the latest image of what's on the scope screen, and the second would grab everything in the temp directory. I tried looking in the temp directory to see how many previous screenshots were stored in there, but directory access is locked. I just do it by reference by generating a new URL with the first request and grabbing that .png instead. 
This is my point. The language itself is fantastic and I love using it. But can I write anything useful and easily distribute it? No. If I can't write a program and send it to someone for them to run, it's useless. 
To not completely butcher the quote: &gt; This alternative represents the status quo. Unfortunately, it has proven to be unworkable in practice, as the backwards compatibility implications mean that this is a non-trivial migration process for large applications and integration projects. While the tools for migration have evolved to a point where it is possible to migrate even large applications opportunistically and incrementally (rather than all at once) by updating code to run in the large common subset of Python 2 and Python 3, using the most recent technology often isn't a priority in commercial environments. &gt; Previously, this was considered an acceptable harm, as while it was an unfortunate problem for the affected developers to have to face, it was seen as an issue between them and their management chain to make the case for infrastructure modernisation, and this case would become naturally more compelling as the Python 3 series evolved. &gt; However, now that we're fully aware of the impact the limitations of the Python 2 standard library may be having on the evolution of internet security standards, I no longer believe that it is reasonable to expect platform and application developers to resolve all of the latent defects in an application's Unicode correctness solely in order to gain access to the network security enhancements already available in Python 3. &gt; While Ubuntu (and to some extent Debian as well) are committed to porting all default system services and scripts to Python 3, and to removing Python 2 from its default distribution images (but not from its archives), this is a mammoth task and won't be completed for the Ubuntu 14.04 LTS release (at least for the desktop image - it may be achieved for the mobile and server images). &gt; Fedora has even more work to do to migrate, and it will take a non-trivial amount of time to migrate the relevant infrastructure components. While Red Hat are also actively working to make it easier for users to use more recent versions of Python on our stable platforms, it's going to take time for those efforts to start having an impact on end users' choice of version, and any such changes also don't benefit the core platform infrastructure that runs in the integrated system Python by necessity. &gt; The OpenStack migration to Python 3 is also still in its infancy, and even though that's a project with an extensive and relatively robust automated test suite, it's still large enough that it is going to take quite some time to migrate fully to a Python 2/3 compatible code base. &gt; And that's just three of the highest profile open source projects that make heavy use of Python. Given the likely existence of large amounts of legacy code that lacks the kind of automated regression test suite needed to help support a migration from Python 2 to Python 3, there are likely to be many cases where reimplementation (perhaps even in Python 3) proves easier than migration. The key point of this PEP is that those situations affect more people than just the developers and users of the affected application: the existence of clients and servers with outdated network security infrastructure becomes something that developers of secure networked services need to take into account as part of their security design, and that's a problem that inhibits the adoption of better security standards. &gt; As Terry Reedy noted, if we try to persist with the status quo, the likely outcome is that commercial redistributors will attempt to do something like this on behalf of their customers anyway, but in a potentially inconsistent and ad hoc manner. By drawing the scope definition process into the upstream project we are in a better position to influence the approach taken to address the situation and to help ensure some consistency across redistributors. &gt; The problem is real, so something needs to change, and this PEP describes my preferred approach to addressing the situation. TLDR: The "circlejerk" still exists. Python 3 is *still* better than Python 2. As always, though, the core devs understand that legacy code exists and want to allow secure practices to exist nonetheless.
Please be more civil. Thanks.
&gt; Except these changes require you to actively implement them in your program in order to use it. This is for code under *active* maintenance or large projects under development where updating versions is too large an upfront cost. It will get used in existing code. Heck, it makes it a *tiny* bit easier to port to Python 3 as they'll already have made this particular change.
Is this a python3 specific issue? Python 2.7.5 (default, Aug 25 2013, 00:04:04) &gt;&gt;&gt; b"what"[0] == b"w" True 
I agree that it's off. I imagine it's because the only people who really pushed for this predominantly used `%` formatting.
Yes. In Python 3, indexing into a `bytes` object produces an `int`.
Interesting. I don't spend a lot of time in Python3 (I use Python 2.x at work, so I use it at home for consistency). Thanks for answering!
 &gt;&gt;&gt; b"amstan"[0] 97 &gt;&gt;&gt; list(b"amstan") [97, 109, 115, 116, 97, 110]
I don't know what you mean. It's not broken. The "bytes" type is a sequence of bytes, which are best represented as integers (since they can be ANYTHING, the numeric value is the only one that makes sense). Asking that to work is like asking this to work: &gt;&gt;&gt; [1,2,3][0] == [1] That's just absurd. This works just fine: &gt;&gt;&gt; [1,2,3][0:1] == [1] and so does this: &gt;&gt;&gt; b"am"[0:1] == b"a"
I feel your pain, man. This is a real problem that the Python developers need to address. Until there's a standard way to solve this problem, I can't really take python seriously outside of web development. Problem is that... it's been a problem for YEARS. I think it's been pushed into the category of "very hard" by the developers, and nobody wants to touch it. Don't expect it to get any better for a LONG time.
In Special Case int and str, shouldn't line 6 be &gt;&gt;&gt; get_ref(x2) instead of &gt;&gt;&gt; get_ref(x1)? 
Its only an int if it produces one result, if its anything bigger then 1 byte in length then 'bytes' object, which makes sense cause bytes are basically just ints 0-255
You're right! Fixed :)
Okay, I got the form created... But how do I render it with Jinja2?
How do you feel about Java? I feel the way you do about Python for Java. I need the person to have Java installed (and I I'm pretty sure it's illegal to redistribute yourself) and from there I don't even know. Send a jar? 90% of JARs I've seen people attempt to send as an executable just don't work. Often they will come with a JAR and a BATch script for Windows that'll run the JAR from command line with special parameters just to make the piece of shit work. Then anything even like py2exe, etc I've seen for Java is a professional $500 a license or some crazy paid solution. The only 'solution' of sorts I've seen is people using proper Windows installers generated from an outside program to extract necessary files, setup shortcuts for user etc. Then from there they had to have an exe/bat to run their Java program. Just awful.
python setup.py develop
The python 3 behavior actually makes more sense (it is more consistent with other elements that can be sliced). If you use index you get single value. If you want to get a list with a single element you should do this: b'what'[0:1] == b'w'
2.x is broken, this is more consistent behavior with any other type that can be sliced.
Never mind, I am just about to implement it. Almost done, will sum it up with some context and write-up in an IPython notebook and post it. Thanks!
/r/machinelearning ***** [^report ^a ^**problem**](http://reddit.com/r/LinkFixerBotSnr) ^| [^delete ^comment](http://www.reddit.com/message/compose?to=LinkFixerBotSnr&amp;subject=Comment%20Deletion%20%28Parent%20Commenter%20Only%29&amp;message=%2Bdelete+cgdzn7t) ^| [^source ^code](http://github.com/WinneonSword/LFB) ^| [^contact ^developer](http://reddit.com/user/WinneonSword)
Yes. Only str does it differently, because there is no char type in Python. But bytes are widely represented as integer from 0-255, so Python 3 makes a lot of sense.
yeah it’s pretty stange. `.format` is the recommended string formatting method, yet the `bytes` type only gets the old one?
 I am not saying that shim is stupid idea, etc. but just to spread knowledge that there is another "fork" of vim under construction http://neovim.org/ good stuff, keep it up!
It's very possible and quite easy to distribute compiled python programs. That's exactly what pyinstaller/py2exe/cx_freeze/Nuitka are for, and they work well. What is the problem here exactly - having more than one choice among compilers?
aww, poor python babies need everything dumbed down to their level :3
sorry mom
btw, one very minor nitpick: in Python context "garbage collector" usually refers to the code that finds and deletes reference cycles and is accessible via the `gc` module. Basic reference counting is just that, reference counting. So for example to really see "garbage collector kicking in" you'd want to do something like a = {} b = {'a': a} a['b'] = b # insert code to get the reference counts a, b = None, None # see that the reference counts are still positive! gc.collect() # and now they are not (I guess, if the gc bothers to reset them)
Yeah sorry, I also use `nltk` for hobby projects so I just always do `nltk.download('all')`. Do you remember which corpra you needed to install? I can put that in the readme.
That's not currently in the library, it's hardcoded to 1 sentence per block, but it wouldn't be too tricky to add. If you open a Github issue describing the feature a bit more I'll take a look at it.
The wire formats thing is pretty big, as without it a lot of that code can become pretty onerous.
It's not at all. Firstly, they don't work well. Maybe for very limited and simple programs, yes. But I can assure you that they all fail (for various reasons) to be reliable. Secondly, you can only compile for the platform you're writing on. This just seems to go against one of python's biggest advantages. So the problem is that pyinstaller/py2exe/cx_freeze/Nuitka do not in general work for any sizeable program that makes use of third party packages, and even if you can get them to work, you can only compile for the platform you're working on.
What? How did you get that from my comment?
Oh dear god, why is it pointing to numarray?
This isn't true. I'll concede that these tools can be difficult to work with, but they do work very well. I have used cx_Freeze to package complex GUI apps on Windows, Linux, and OSX, all from one packaging script. You do have to package on the platform you're targeting, but that's because cross-targeting is a very complex problem, especially when you have multiple binary dependencies involved. Have you ever tried to package or cross-compile a complex GUI app written in C/C++? It's far from simple. Now you have all sorts of compiler and cross-compiler version conflicts to worry about. I'd take Python and cx_Freeze over that any day. edit: accidentally some words
I've seen it being done!
Python 2! Hoist by our own Python 2 success makes the migration to 3 take longer. 
I get so much hate for being an emacs guy in a office of vim users
I think I mis-interpreted your comment. I thought you wanted to say, that the comparison between the learning curve of notepad and vim is invalid, because notepad is not something you would use your entire career. I just wanted to point out, that there probably are people who use notepad exclusively. And for them, the comparison is valid..
That's called slicing, and it's a totally different thing from indexing. A one-element slice will produce a `bytes` object.
Can you be more specific as to how they fail? I have packaged big and complicated programs with Pyinstaller, for example a streaming video processing application with embedded GStreamer. All working reliably. Having to compile platform-specific binaries is a mighty strange complaint.. Exactly how else would you distribute applications to different operating systems? The browser you are currently using - is it not a platform-specific compiled binary? Does that make C/C++ a toy language?
Well, vim is itself a fork of vi, so that's hardly surprising.
My complaint is not that you have to compile platform specific binaries. It is that it is not possible to compile on one platform for another.
Why are you getting down voted? Because you like emacs? I use emacs...
You can start using something like Sublime Text, or hell, emacs, without reading through a massive manual. You won't be using most of the features initially, but you can learn them as you go, and most people can be fairly productive in these without much effort and without rewiring the entire way they think about editing text. That's what vim is competing with. Personally, editing text for me is a visual thing, rather than "apply these transforms to this text". Vim is one step too abstract for me. Of course, I have most of the things vim can actually do (just not the interface) behind keyboard shortcuts for when I need them, but visual tools tend to help me more often. Of course, I can use vim just fine, including a few tricks, but I don't enjoy it. It doesn't fit my mental model of what I'm doing. Luckily, I barely ever need to touch a terminal these days (except for git, of course), as my sysadmin toolkit no longer requires it.
If you're looking for an example, I did a small project that uses the gdata API: https://github.com/alexjh/kobocal
Aha, I misunderstood that point. I concede that this is a valid annoyance. Myself, I use virtual machines for this.
[this](http://en.wikipedia.org/wiki/Superiority_complex), but in reality it is playful more so than real hate lol
You guys are trying to mimic vim and in the end you'll end up like vim to satisfy all developer needs. I never heard of project going more simple with time, most people add new and new features till they have too much of them. Which brings me to the point, lets just keep coding in vim and mark this project as not useful. But well, this is just my point of view.. 
Why is that?
[Here's the link](http://dorey.github.io/JavaScript-Equality-Table/) to the original JavaScript truth table. The code I used to generate the Python one is: def pythonequality(): thingstoTest = [ True, False, 1, 0, -1, 'True', 'False', '1', '0', '-1', '', None, [], {}, [[],], [0,], [1,], ] for thing1 in ['',]+thingstoTest: sys.stdout.write('%10.10s'%thing1) sys.stdout.write('\n') for thing1 in thingstoTest: sys.stdout.write('%10.10s'%thing1) for thing2 in thingstoTest: sys.stdout.write('%10.10s'%int(thing1==thing2)) sys.stdout.write('\n') 
Even in 2008 (when article was posted) numarray was out of date.
Under Linux just run `vimtutor` and learn the basics in 30 minutes. Well, I had to do this tutorial 2 or 3 times until I memorized the most important things :), but it was worth it.
&gt;or hell, emacs, Yeah, no! I use vim all the time. I have no idea how to use emacs. I'm still just as lost on emacs as I was on vim the first day. Loster, even.
And I doubt OP used the vim codebase. What's your point?
Cool! Please consider cross-posting this to /r/pystats
Blogspam of the worst kind, and I bet it was already 6 years ago...
His point is that your use of 'fork' is incorrect.
I remember when I first learned C++, I started porting a program I wrote in Basic hoping for a major speedup. This was a CPU-intensive program that worked with big numbers (1024-bit). I was going to go nuts using vector processing for maximum optimization. I coded it up, ran some initial tests, and OMG IT WAS 50x FASTER! **50!** Beyond my wildest dreams. Except it was really about, oh, ~0% faster. It only seemed faster because my initial tests used much, much smaller numbers than the real-world data. Turns out operating on big numbers is harder than operating on small numbers. By about 50x. Oopsie! It also turned out that the bignum library I was using in Basic was already very well optimized, so I wasn't going to get any big performance boost anyway as long as bignum operations were the bottleneck. I might as well have left the whole thing in Basic. Oh well. At least I learned C++ from the experience.
I didn't [start it](http://www.reddit.com/r/Python/comments/21koop/shim_a_vim_inspired_text_editor_for_all_written/cge191z), I just reused someone else's terminology.
OP used quotes. You continued the usage without quotes. The language changes minutely. You've just changed it.
&gt; The language changes minutely. Well, yeah, that's how language works. Quoting things all the time is tiresome. I assumed you were all smart enough to understand me. Please don't tell me I was wrong about that.
pkg_resources isn't part of stdlib and also requiring that the package be installed in order for `__version__` to be present means you cant use the package from source, e.g. git checkouts + PYTHONPATH, etc., building sphinx documentation in the source tree, running tests, etc. +1 for open the `mypackage/__init__.py` file and parse `__version__` from setup.py, it's what I do in all my packages.
So it goes.
I'm involved in developing cx_Freeze, and it really doesn't work terribly well, compared to the tools for distributing applications built with C++ or .NET, for example. You can almost always make it work, but it often takes some fiddling and understanding what's going on. I mentioned my [template NSIS installer](https://github.com/takluyver/py-nsis-template) above. It's a very rough prototype at the moment, but I think it could avoid a lot of the pain of solutions like cx_Freeze. It works by installing a full copy of Python, and creating a start menu shortcut which launches your Python file. If you're interested in this, I'm happy to describe it in more detail.
You should note that "bool(x)" and "if x" have special behaviour that doesn't match the equality test with True or False. &gt;&gt;&gt; bool([]) False &gt;&gt;&gt; bool([1]) True &gt;&gt;&gt; bool('') False &gt;&gt;&gt; bool('nonempty') True &gt;&gt;&gt; bool(None) False
A text editor is a rock-bottom basic tool. If you have to memorize counter-intuitive commands and wrestle with counter-intuitive editing modes just to make it do the most basic of edits while similar tools are intuitive and invisible, why use it? It's like saying "You should really use this hammer! The learning curve is ridiculous, it doesn't work well with nails, and it has a ton of features almost nobody uses, but it's a great hammer!"
Quote from the PEP itself: &gt; Originally this PEP also proposed adding format-style formatting, but it was decided that format and its related machinery were all strictly text (aka str) based, and it was dropped. So thats why. 
Don't strikeout your blogspam comment. We're all thinking it. This caught my eye because I do a LOT of work in json over rest, and this sounded interesting. However, it's not anything a semi-seasoned pyguy wouldn't do on his own. It's a nice how-you-can-do-it for the beginner, but it's not revolutionary. 
It's interesting to see the table that results if you use cast the variables to be a bool with: sys.stdout.write('%10.10s'%int(bool(thing1)==bool(thing2))) instead of sys.stdout.write('%10.10s'%int(thing1==thing2)) (if foo: uses bool(foo))
Hello fellow UIUC camper :) Good work!
&gt; A text editor is a rock-bottom basic tool. If you're implying that because it's so basic it should also be simple and intuitive, why did we ever move past ed or notepad.exe? Why does Word exist? Why does Visual Studio exist? Why does emacs? &gt;If you have to memorize counter-intuitive commands and wrestle with counter-intuitive editing modes just to make it do the most basic of edits while similar tools are intuitive and invisible, why use it? Why do you think that the non-modal model of text editing is necessarily the best one just because it's more intuitive? Just because you can't "just start typing" doesn't mean it's inferior. Just because you have to read docs to use it doesn't mean it's inferior. For systems that you spend a significant portion of your day to day life using, an investment in learning for effeciency gains is worth it, and to be clear I think this argument applies to all of the editors I listed above. If all you care about is the initial investment in time to do basic stuff, you're optimizing for onboarding and nothing else. The idea that text editors are one of the basic tools you need on a system does not imply that they should match your intuition about things.
Great info - thanks. Also, searching around, it sounds like ``pkg_resources`` can cause some strange errors, especially when it's used with virtual environments.
I have used vim on and off for the last 15 years and I still hate it. The whole command/edit mode thing never made any sense to me at the start and still doesn't. It's completely counter intuitive and awkward. 
&gt; If you're implying that because it's so basic it should also be simple and intuitive, why did we ever move past ed or notepad.exe? Why does Word exist? Why does Visual Studio exist? Why does emacs? Each of which can be used by a novice without reading manuals due to intelligent, intuitive, or helpful interfaces. That novice can then learn more powerful commands within the interface, or read manuals and memorize commands to become a power user. But not everyone wants to be a power user. &gt; Why do you think that the non-modal model of text editing is necessarily the best one just because it's more intuitive? Just because you can't "just start typing" doesn't mean it's inferior. Just because you have to read docs to use it doesn't mean it's inferior. For systems that you spend a significant portion of your day to day life using, an investment in learning for effeciency gains is worth it, and to be clear I think this argument applies to all of the editors I listed above. If all you care about is the initial investment in time to do basic stuff, you're optimizing for onboarding and nothing else. The idea that text editors are one of the basic tools you need on a system does not imply that they should match your intuition about things. Sorry, i was not clear. I'm not really trying to argue that Vim is not powerful or inferior, nor even that modal operation is bad. If I had need to become a power user I might give it another shot. I just think the interface is pointlessly obtuse and about as unhelpful as it can get. Just like my imaginary hammer: maybe it really is the best hammer in the world but most people would scoff at an unwieldy hammer that requires users to memorize counter intuitive gibberish commands just to sink a nail.
The GUI of Emacs is a big unorganized mess and some of the defaults could be better, but the core is really no different then Notepad or any other editor around (outside of Vi and it's mode-mess).
&gt; If you have to memorize counter-intuitive commands and wrestle with counter-intuitive editing modes just to make it do the most basic of edits while similar tools are intuitive and invisible, why use it? Well, the answer is trivial and obvious; because the payoff is worth it. You don't have to agree that that's the case, or you may feel vim is not for you, but it's a bit disingenuous to pointedly ignore the reason so many people like vim so much.
Vim is the powered screwdriver of the toolbox where notepad is a coin. 
Perhaps because it adds nothing to the thread. We all know some people use emacs, and the 'vim users hate me' joke is rather played out at best.
Good question, why *does* emacs exist?
As a nice middle ground, you can follow the python packaging authority's late trend of creating an __about__.py in your main module that contains this type of metadata (see https://github.com/pypa/warehouse). Then your __init__.py will *only* import that metadata and you can feel safe about importing about['__version__'] in your setup.py. Upside, this is super clear in my opinion and quite safe. Downside is it's more of a "how do I do this well in my package" suggestion than a solution for importing version from arbitrary other packages.
Thanks, will do.
Thank you for the explanation :-)
&gt; 10 commands. :w :wq :wq! :w! :q :q! :help :h yeah that's all I know.
Yeah, it works for almost anything. Even strings and collections. to check if those are empty
As much as I love python, why exactly do we need a text editor written in python?
I've been playing with [concurrent.futures](http://docs.python.org/3.4/library/concurrent.futures.html) on &gt; 3.2 and love it. No more queues and everything is concise and simple.
Quick question about this scenario: considering the performance aspect of the rPi (512MB, single core, ["real world performance is something like a 300MHz Pentium 2"](http://www.raspberrypi.org/faqs#performanceSpeed)), would you serve the entire app with Flask, static assets &amp; all, or would it be better/smarter/safer/etc to use a "proper" frontend server &amp; just reverse-proxy back to the app? Just curious, thanks!
 &gt;Still, serializing an SQLite query result into a dict and then into JSON doesn't really qualify as insightful.... I said clearly in the post that I'm printing the dict for comparison with the JSON output. Nor was the code intended to be either particularly insightful or "revolutionary" as another user comments below. I even said in the post that it is simple code. Intended as a basic demo of using the Python json module (to convert DB data to JSON), nothing more. Also said in the post that there can be different ways of improving the code, or just better approaches to it: "Here's a simple Python program I wrote for that. It can be improved in many ways (*), and there may be many other ways of implementing it, but this program shows the basic approach" Not all blog posts in the world need to be about intermediate or advanced stuff only. There are many beginners in the world too, and I know that many of them read my blog and probably this subreddit too ... Let's try to be more inclusive, shall we? And finally, like you, I had a bad day too, otherwise I'd probably have remembered either a) to use the traceback module to print the actual exception and stack trace if using that catch-all except clause, or b) would have caught a more specific exception, and also not put in the incompatible raise and sys.exit() together. 
I usually use the approach of having a separate `version.py` module that only contains `VERSION` and `__version__`. Then I `exec` that in setup.py, and import the version info from it in `__init__.py`. That's the approach we use for [SKLL](https://github.com/EducationalTestingService/skll/blob/master/setup.py#L6-L8) I've encountered issues in the past with just importing in setup.py because of our package having too many dependencies that weren't usually installed. 
&gt;It would be better to only catch and print custom error messages for errors that you actually expect.mm And what do you do when an error you do not expect (but can happen) happens, then? the program will crash. Many experienced programmers do both of these: catch specific exceptions for inner blocks of code, and also have an outermost catch-all try-except block, particularly in early stages of program development (and sometimes only the outermost one initially, then as they test the program and find the inner blocks that cause errors, add code incrementally to catch those. I realize this is a matter of preference, but many people tend to prefer to catch all possible errors so that you can do a graceful shutdown, close files, other resources, etc. And repeating what I said in the other comment above, I too had a bad day, so missed out some of the points that I did. 
You say you import it `setup.py`, but the example you point to explicitly uses `exec` instead of `import`, because importing a module from a package will cause `__init__.py` to be imported too, which is the whole problem we're trying to avoid.
&gt; Quoting things all the time is tiresome. I assumed you were all smart enough to understand me. You spoke lazily, therefore you were misunderstood. You are responsible for your own choice of language. Do not blame others' intelligence or lack thereof.
same story. tried to rewrite an R library in C using GNU Scientific Library. turns out both implementations wrapped the same FORTRAN code in the long last and were almost exactly equally fast. but i also learned C and was underwhelmed. Rust is definitely the way to go in that area once it’s stable.
It's been a long time since we started using vim, so it's hard to remember what it was like to learn, we just know how we feel now about it. But I think what you're saying has merit, that it could be made easier for the user, if only by having "use :h for help" displayed at the start. 
As for my qualifications ... https://www.google.com/search?q=xtopdf , as one example, has been around for a while and is being used in production by some well-known organizations in the US/UK/NL, among others. http://slid.es/vasudevram/xtopdf Not to mention the fact that I've been working for years and have delivered many projects, both custom projects and a few products, for employers or clients. 
i and then you're good.
&gt; What's counter intuitive about it? Editing and inserting text are not things I would consider to be separate tasks and basically every piece of software I ever used, outside of Vi, didn't treat them as separate. Keeping them separate makes some sense when you are using `ed` on a teletype, but ever since the rise of displays that separation just feels completely out of place. It doesn't help that the common examples of why it's good, like "delete 5 lines with '5dd'", are things I never ever needed. I don't want to count how many lines I am looking at before being able to delete them, I want to mark them and throw them away. And yes, there is visual-mode in vim, but that already feels like it's leaving the core vi user interface design and behaving more like a regular editor. And if you want some literature on the topic, [The Humane Interface](http://en.wikipedia.org/wiki/The_Humane_Interface) makes plenty of good arguments why modefullness in software makes for terrible user interfaces.
Heh.
A help menu would be a great start. Realizing that for about 30 years now keyboards have come equipped arrow keys would also be great...
Nope. Gonna need the Escape key to get back to command mode to run the first 10.
I find it hard to believe adding a menu, help function or support for standard keyboards would hinder it's usability goals.
I'll give you that sometimes it makes sense. But from your code I can tell very well that you did not give a thought to closing resources cleanly at all. Otherwise you would have used a context manager for that SQLite connection. And as for your qualifications, when I look at the xpdf source, I see a single top-level directory where documentation, test-files, python-code and weird `.py.png.pdf` files are intermingled with no structure at all. Digging into the code, here's a random sample: https://bitbucket.org/vasudevram/xtopdf/src/75232bccde0aafe92042a36cb6ece056a5cb6cdb/pdf_flask.py?at=default Let's take a look... * Another catch-all, not because you need to close any resources, but because you want a stack trace. Well, guess what, Flask will do that for you, it will even give you an interactive debugger along with it if you run in debug mode. * You are using a single method for poth GET and POST on an endpoint while the logic for both is completely different, hence the huge if-else blocks. Or here: https://bitbucket.org/vasudevram/xtopdf/src/75232bccde0aafe92042a36cb6ece056a5cb6cdb/XMLtoPDFBook.py?at=default * A global variable `sysargv`. Seriously? Are you too lazy to type out that single dot in `sys.argv`?! * A custom `debug` function that just writes to stderr, while not even flushing it oO You know there is a `logging` module that has a `debug` function, right? * Debugging calls in production code that cannot be deactivated? Or hey, because it's fun, another example: https://bitbucket.org/vasudevram/xtopdf/src/75232bccde0aafe92042a36cb6ece056a5cb6cdb/MongoDBToPDF.py?at=default * Hardcoded database connection parameters? * All logic runs at import time? * Code is inserting random data into a MongoDB database and printing it back? I'm not sure if I'm being trolled here, and I really don't mean to be nasty, but I cannot believe that this 'tool' of yours is used by anyone. You *must* have made the quotes on that slide up...
Don't forget the whole [False Midnight](https://lwn.net/Articles/590299/) issue though.
this 
I guess it comes down to use cases. For me something like `5dd` is exactly what I need. Or I need to delete everything after the current line until the end of the file. I can accomplish that with `dG` in a fraction of a second, there's no cumbersome highlight and waiting for the file to scroll by, or ctrl+shift+end del, or maybe I wanted to actually pull those lines to the copy buffer so I could paste at the top of the file, so now I accomplish that with `dG 1G P` rather than ctrl+shift+end ctrl+x ctrl+up home ctrl+v...or whatever. Get my drift?
That learning curve is only if you try to use it without reading manual. Once you go through vim tutor, you know enough to make it useable. And that doesn't take long. So I partially agree, you don't pick it up in two seconds. But people make the dam things sound like a brick wall. And it can be, but they provide a door(:help/vimtutor). I hope that makes sense.
I think you're missing the point of open source. Yes, Python 3 is "better than" Python 2.7. Great. If people want to continue using Python 2.7 and are willing to continue expanding on it, great. If you want to make Python 3 more accessible, the best thing you can do is port existing libraries to Python 3. Slightly less effective would be to write a popular library that isn't available in Python 2.7.
Ya or Ctrl+] since that is easier to hit than escape
I don't miss the point, and I understand that there are people that want to use 2.7, and it's totally within their right to do so. And I think they're wrong for it. That's my prerogative. 
Well that explains it, I'm arguing with an emacs user :)
You missed midnight. edit: This was a glib and wrong comment, and djimbob most politely pointed out why. I am again impressed with the seemingly typical level of discourse shown by Python developers.
Not if you rebind your caps lock to escape. 
True, I just never done that so I don't get all caps if I switch apps
I prefer :x over :wq. And :q! is the essential command. Because let's face it, you're going to ruin a file and you need to get out unharmed.
&gt; Once you go through vim tutor, you know enough to make it useable. The problem isn't making Vi usable, but making it pleasant. It always just feels awkward and backwards. Good enough when you have to fix something on an old Unix box in an emergency, but that's about it. Random question: Does Vim have typeahead search? 
I rebound caps lock with pc keyboard hack. It's always escape for me. 
It looks like you have an off by one in the middle there staring after -1.
Truth. But if you warp the truth a little, you can make it fit in a nice box. I think the numpy is written in C/FORTRAN becasue the libs it requires (fast blas &amp; lapack libraries) are written in C &amp; Fortran. Sure C is fast, but lots of languages are fast (see Fortran, Pascal, Ada, Forth, etc.), I think numeric and embedded systems use C for the same reason it's used everywhere: compatibility (numpy for software compatibility with dependencies, that includes Python, and embedded systems primarily for hardware compatibility) Also I think people (like myself) always forget how different the entire embedded ecosystem is.
&gt; I can't remember the last time I actually used == to compare to True good, that’s an anti-pattern 
Very good point indeed
Ctrl+]? Do you mean ctrl+c?
When Python was initially developed, 200-400 MHz CPUs were state of the art. :) If you wanted to benchmark things, look into SAR. It's fairly easy to set up. Python might be suitable for you, but you might also want to look into lua for a smaller footprint.
i also wouldn’t say it’s dead, i’m just saying that rust might just have the potential to be used anywhere C is. 1. it’s compatible with it 2. it has awesome feature-gating that allow you to use it without its runtime (making it fully suitable for embedded) that doesn’t mean it will replace C, only that you can use in instead of C everywhere if you choose so.
You've raised (pun intended :) a number of points. I'm going to reply to them, but don't have the time today, since some need slightly detailed answers; I will, in a day or two. Meanwhile, I noticed a couple of obvious errors in your comment: the project is xtopdf, not xpdf (there's another project with that name, that does the reverse, more or less); and stderr is not buffered, or at least only line-buffered, so there's no need to flush it, as per my understanding, since the calls to debug() include a "\n" at the end of the string; that flushes the line buffer, if at all there is one. http://www.cplusplus.com/reference/cstdio/stderr/ http://linux.about.com/library/cmd/blcmdl3_stderr.htm And yeah, it's likely that I "made up" the quote about Steve Holden, isn't it [not!], when I actually mention him by name in the slide and he's a well known figure in the Python world, and the ex-chairman of the Python Software Foundation. If I was making things up (which I'm not), I'd obviously not do it using the name of such a well-known person. He could easily call me out on it if I had made it up, couldn't he? And notice that I'm repeating his name here. That quote from him was on his del.icio.us account a while ago, with the tag "python". It may or not be there now, after the Yahoo acquisition of delicious, or if they truncate old entries after a while (the entry was posted some years ago, a while after I first released xtopdf). More replies later, as I said, but it's already pretty obvious to me that you jump to conclusions with some of your claims, if not all ... 
I actually love vim, but why not ``ZZ``. It's so much faster to type
Stop making python [equality look worse than it is](http://strilanc.com/visualization/2014/03/27/Better-JS-Equality-Table.html)!&lt;/sarcasm&gt; But seriously, it looks slightly cleaner if you group True &amp; 1 and False &amp; 0 next to each other. Then it becomes super-clean: | | True | 1 | False | 0 | None | -1 | 'True' | 'False' | ... | |:--|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:| |**True**| True | True | | | | | | | |**1**| True | True | | | | | | | |**False**| | | True | True | | | | | |**0**| | | True | True | | | | | |**None**| | | | | True| | | | |**-1**| | | | | | True | | | |**'True'**| | | | | | | True | | | |**'False'**| | | | | | | | True| | |**...**| | | | | | | | | True | with all the blank squares being False. Personally, I would like it better if `True == 1` and `False == 0` didn't evaluate `True` (yes you can use `is` and it makes sense coming from C, and its not that surprising since `bool(1)` is `True`, and `bool(0)` is `False`). EDIT: minor formatting.
Yeah, I fucking love Rust too from what I've seen of it. Really hoping we get a viable, stable release sometime this year. 
Have to say that when I saw the table I thought "that's not true" ... but yes, indeed, Python has `True == 1` and `False == 0`. I'm (mildly) disappointed. It's even true with Python 3, so I guess it really is deliberate. 
Afaik, True and False are just treated as numbers anyway. Try stuff like "10 * True" or "2 - False - True" or "int(True)" in your python interpreter.
And `float("nan")`
Coming from C, you think of a bool as a 1-bit int, with False = 0 and True = 1 just being convenient mnemonic alias. From that perspective, it makes sense -- similar to how in python2 `0 == 0L` and `1 == 1L`, despite `type(0)` being `int` and `type(0L)` being `long` (in python3 there's no long type so this example doesn't make sense). Granted, its a subtle point and I think the other way `True == 1` evaluating to False is conceptually cleaner.
Alas, I only have one upvote to give.
I'm sorry. I don't have enough experience with tinypy to give you valuable input. Maybe the standard Python would be enough. I would suggest you to try it out. In case it doesn't work, I know that Lua is a good embeddable language. Maybe would be good to look it out. 
I wish it was a just a diagonal line would have saved me from some nasty bugs. But still so much better than most languages. 
And another small reply: &gt;You know there is a logging module that has a debug function, right? Sure I do, and did earlier too, when I wrote that code. You know that people sometimes (or even often) write their own custom functions (for any purpose, not just debugging) when they don't need/want all the overhead of some module, or want somewhat different behavior, right? or even write their own code for the fun of it, or to learn about some language feature, or to experiment with different approaches to the same problem, right? 
I took a look at your article/blog and I think that writing up exercises like these is a great experience and can help you learn a lot about what you're doing. That said, I just wanted to point out a couple of things that I thought you should be aware of with respect to this article. The first thing is just a side note, in your diagram of the ML process you use an unsupervised learning model, however the processes you go through are supervised learning. I would use [this diagram](http://www.astroml.org/sklearn_tutorial/_images/plot_ML_flow_chart_1.png) instead. Secondly, while 80% accuracy doesn't seem bad you have to consider what randomly guessing would do. If you were to have someone blindly categorize your testing data they would do so with a 50% accuracy rate (not bad for random guessing). If you were to analyze more than two artists you would likely see your accuracy rates take a steep dive. Finally, you've overlooked a large part of computer vision, which is the features. You use the raw pixel values for your features, which is of high dimensionality and won't help capture local patterns. Take a look at some intro computer vision material and you'll see that a lot of thought goes into what features are used and that they are a crucial part of CV.
Thanks a lot for the feedback! This was my first experience with CV so it was pretty much a learning experience. I will look into CV literature as you stated to try and get a better feel of the field, do you have any suggestions? Edit: Fixed the diagram as well.
 Another small reply (longer ones later, as I said): This is the (now former) marketing manager at Packt Publishing, who was also quoted in the slide: http://www.linkedin.com/in/jimmykarumalil He and his sysadmin initially tried xtopdf at the time when I was writing this article about xtopdf for Packt (and I got a Packt book on Plone in exchange for the article, under a scheme they had): http://www.packtpub.com/article/Using_xtopdf (The layout of that article is now a bit messed up after they made some changes to their site, but the article is still readable.) And he later told me they like it and are using it in their book production workflow - not for final output to print, but at an intermediate stage, to view book/chapter drafts in PDF format. xtopdf is not a high-end PDF tool like the Acrobat family of tools, but it works reasonably well for what it aims to do (it has restricted goals), and has its use(r)s. 
Why? You could just read the code. If you don't trust it, don't use it.
I don't mean autocomplete, [typeahead search](http://en.wikipedia.org/wiki/Incremental_search) means that when you do a text search the search runs instantly after you type the first letter and continues to refine itself the more you type. This is in contrast to classic search where you have to type your whole search string and hit enter before you see any results. Firefox and Emacs are apps with typeahead search, even Google can do it these days. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Incremental search**](http://en.wikipedia.org/wiki/Incremental%20search): [](#sfw) --- &gt; &gt;In [computing](http://en.wikipedia.org/wiki/Computing), __incremental search__, __incremental find__ or __real-time suggestions__ is a [user interface](http://en.wikipedia.org/wiki/User_interface) interaction method to progressively search for and filter through text. As the user types text, one or more possible matches for the text are found and immediately presented to the user. This immediate feedback often allows the user to stop short of typing the entire word or phrase they were looking for. The user may also choose a closely related option from the presented list. &gt;The method of incremental search is sometimes distinguished from user interfaces that employ a [modal window](http://en.wikipedia.org/wiki/Modal_window), such as a [dialog box](http://en.wikipedia.org/wiki/Dialog_box), to enter searches. For some applications, a separate [user interface mode](http://en.wikipedia.org/wiki/Mode_(computer_interface\)) may be used instead of a dialog box. &gt;==== &gt;[**Image**](http://i.imgur.com/LZIcHMf.png) [^(i)](http://commons.wikimedia.org/wiki/File:Firefox_FAYT.png) - *Screenshot of performing "Find as you type" in Mozilla Firefox. "ency" was being typed and the first matched text was highlighted in green.* --- ^Interesting: [^Incremental ^heuristic ^search](http://en.wikipedia.org/wiki/Incremental_heuristic_search) ^| [^D*](http://en.wikipedia.org/wiki/D*) ^| [^Delimited ^search](http://en.wikipedia.org/wiki/Delimited_search) ^| [^Traktor](http://en.wikipedia.org/wiki/Traktor) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgehnvn) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgehnvn)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Twisted deals with a great many network protocols, and a great many network protocols treat binary data as ascii text. So as such, being able to format bytes as if they were ascii text is a massive convenience for the library that was removed in python 3 - every time you wished to do so, you'd have a verbose decode-format-encode loop to run through (and making sure you're dealing with bytes at the start every time).
It's not a matter of hindrance, it's a matter of deliberate design. Besides, vim is actually designed to be embeddable, and has plenty of instances that has those menus and buttons you describe, e.g. gVim in Ubuntu. When I have to use gVim, removing those buttons is the first thing I do because it occupies precious screen estate and I never ever touch my mouse to actually click them for example.
This sounds like a good idea, but in practice it's impractical.
Ah wrong key I meant "control+[" which escapes back to command mode. control+c would kill the vim instance in the terminal.
Are you trying to print things to screen or actually to a physical printer? (Because win32print is for physical printers; the sort that print paper) If you are talking about physical printers I can't help. If you are talking about printing text to a screen then you'll want to use a graphics/GUI codebase like PyGame or Tkinter. Tkinter should come with your Python installation and there are *many* tutorials available for it.
http://docs.python.org/3.4/library/stdtypes.html#truth If anyone wants the official truth testing.
A bit of a late delay in reply.. but.. If your client is running RHEL6 64bit they can get Python 2.7 and Python 3.3 via the SCL RHN Channel. These are Redhat supplied packages.
For things that need to be put on paper, I usually build them in ReportLab and then use some pdf reader or viewer to get them sent to a printer. wxPython has a pdfviewer widget that works great for simple reports. There is also Ghostscript. As well as Adobe Reader, Foxit, Sumatra, etc. viewers; I believe all of them can print.
Yes. It displays a box with text option underneath when you do crtl-P/crtl-N and it will update as you type. And [this pligin](http://www.vim.org/scripts/script.php?script_id=2620) allows you to have that box all the time. There is also AutoComplPop plugin that specifically does what you want. The one linked is just a more fleshed out autocomplete with that functionality built into it. Edit: Words, and stuff
In JavaScript's defense, while that table is pretty ridiculous, you're only ever going to get bitten if your design is terrible to begin with. In real life using `==` almost never causes bugs. If you're comparing two variables and you have no idea whether they're `true` or `"1"` or `[1]`, you really shouldn't be relying on the result.
c'mon, let's not scare away JavaScript developers...
Python should run fine on such systems. For performance monitoring Python includes a [profiler](http://docs.python.org/3/library/profile.html) in the standard library. For memory, look into [heapy](http://guppy-pe.sourceforge.net/#Heapy) or [meliae](https://pypi.python.org/pypi/meliae/). As for Cython, I would advise against using it for everything, but it's fine for performance-critical code (e.g. number crunching). All that matters is what you are going to use it for, just don't try to write a raytracer on that. :-)
I'm not sure what's more frightening about the JS one - all the equalities off the diagonal or all the inequalities on the diagonal.
Yeah... midnight clearly shouldn't be false, and the idiom of if ~ to mean is not none is fine.
I mean, it is a diagonal line. Bool subclasses int.
Guess I've never met this [mis]feature before, don't think it's bitten me, but ... just eww.
&gt; If you have a datetime value, attempting to use it as though it were a boolean is foolish. The issue is when you have code like this: def do_shit(when=None): if not when: do_shit_now() schedule_shit_for(when) You should be doing `if when is None` there, but it's still an unexpected bug.
I always wonder why it's not also exposed as `float.nan` or so.
That's because Python had no True and False up to 2.1 or so. They are backwards compatible to the values that were used before: 0 and 1!
The JS one is a mess, but the diagonal inequalities aren't that nonsensical. Most of it comes down on this: |number|string|object -|-|-|- __number__|duh|as numbers¹|as numbers² __string__|as numbers¹|duh|as strings __object__|as numbers²|as strings|reference equality ¹ if the string looks like a number ² first convert to a string then compare as numbers¹ In JS, `[] != []`, just like in Python `[] is not []` or in Lua `{} ~= {}`. The sad thing is that objects are so easily converted to strings and numbers otherwise, which means JS `==` would be less inconsistent if comparing two objects would convert both to strings, even though that would be a really bad thing. (In particular, any two objects that don't override `Object.toString()` or whatever, would compare equal.)
Well, that makes sense ... but it's not all that good, it's just a backwards compatibility hack. I do wonder why it didn't get dropped in 3. Maybe just not worth the hassle and argument.
Thank you for the explanation.
Adding in midnight `datetime.time(0,0)` would make no change to the chart. He's comparing equality and python does this sanely (one possible weird exception is `True == 1` and `False == 0`). Granted yes the following `empty` or `zero` types will convert to `False` when cast to a `bool` (which is automatically done whenever you have `if x:` which is equivalent to `if bool(x):`) * None * [] * set() * () * {} * "" * 0 * 0.0 * 0L * 0j * complex(0,0) * datetime.timedelta(0,0) # time interval of 0 days, 0 seconds * datetime.time(0,0) # this last one possibly will change after python3.5 (becoming True) while most everything that's not empty, zero, or null will generally convert to `True` on `bool()`.
geocar's point was `float('nan') == float('nan')` evaluates to `False` (despite `float('nan') is float('nan')` evaluating to `True`), which naively seems weird. But this isn't a python flaw, its a floating point flaw. 1. First, its difficult to get `NaN` to arise in python (e.g., `0.0/0.0` will raise a ZeroDivisionException and not return NaN as it would in JS) without using non-core libraries (like numpy/scipy), or going out of your way to create it. 2. the floating point standard IEEE 754 explicitly defines that on equality tests NaN should never returns true, even if its the same object. That is `a = NaN`, `a == a` should be False, even though `a is a`. So python does the right thing. From [What Every Computer Scientist Should Know About Floating-Point Arithmetic](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#1063): &gt; There are a number of minor points that need to be considered when implementing the IEEE standard in a language. ... The introduction of NaNs can be confusing, because **a NaN is never equal to any other number (including another NaN), so x == x is no longer always true.** In fact, the expression x != x is the simplest way to test for a NaN if the IEEE recommended function Isnan is not provided. Furthermore, NaNs are unordered with respect to all other numbers, so x &lt;= y cannot be defined as not x &gt; y. Since the introduction of NaNs causes floating-point numbers to become partially ordered, a compare function that returns one of &lt;, =, &gt;, or unordered can make it easier for the programmer to deal with comparisons. 
Looks like empty string in the vertical got swapped.
I'm a big fan too! I wrote [this script](https://gist.github.com/thomasballinger/9845985) to send code to Online Python Tutor - if you use bpython, setting the pastebin_helper to this file (under [general], in the file ~/.bpython/config on unix or wherever bpython config goes in Windows). edit: a big fan of Online Python Tutor, not my own post
why not just use sublime?
True and False quack like the ints 1 and 0, so why not?
Great job writing your own thing, I really mean it. But taking on VIM is going take a heck of a lot more thought and planning. Personally, I'll be sticking to my Sublime for GUI and Vim for anything console. But seriously, keep working if for nothing else than learning.
I guess it depends on how you think of it. But it makes no sense to have bool be a subclass of int. 
&gt;C is ... not unlike latin in science. &gt;(ninja edit:) C is (basically) dead, Unintentionally overly apt analogy.
That's fair. I guess I was thinking of more of an API.
This is the correct answer.
Do you mean an off by true error?
A trick I learned from JavaScript: !!, which would be `not not` in python To turn a truthy or falsy value which is not in [True, False] into it's truthy or falsy equivalent: `&gt;&gt;&gt; not not []` `False` `&gt;&gt;&gt; (not not []) == False` `True` etc. useful in the REPL if you forget if something is truthy or falsy
You should take a look at MSWinPrint 1.1, https://pypi.python.org/pypi/MSWinPrint - it's a wrapper around win32print which hides you from most of the Windows API stuff. I've written a few programs with it so can give you some tips if you have any trouble getting it working.
If you're going to go the os.path way, just use os.path.basename()...
Hm? For comparison, yeah, that makes sense. But don't let that be any sort of indictment on duck typing whatsoever. The lesson should be that _comparison_ is a tool to use only when you're quite sure what you're dealing with. There are still many, many times when that's not the case, and comparison is the wrong tool to use.
c = change
Dang -- 30 upvotes and no comments. That's some serious bystander effect there, lol. Edit: Tell the coding mods that the function "update_wiki_tracker" has some terrible coding practices in it, and needs to be rewritten (preferably factored). I'm reviewing the current base now; if I get around to contributing in the next few days, this will be done as well. Edit2: At least for the leaderboard flairs, twould be easier for an outsider like me if you went ahead and created some CSS for me to plug in. (I would say something like top 10 and maybe top 3 get special flairs, but in any case, you'd have to make the CSS yourself, since I couldn't.)
Hi there, I just responded to your PM a bit ago. I'm looking into the issues list at the moment.
Oh! Fun anecdote from learning python. I learned the and opperator was written as the keyword 'and' and the 'or' opperator was just 'or'. Following this logic, I correctly undated there would be an 'is' oppressor. It took me an embarrasingly long time to realize it was not a Boolean equality opperator. (just pretend like I looked up how to spell embarrassingly, better for everyone.) 
Cheers for an informative response to my misunderstanding.
Completely, agree from the perspective of how values in the place of conditionals work, in both C and python. All non-zero values will cause if/for/while, etc. to go to the True branch, while zero values (NULL, 0, and '\0' are just ways of writing the literal value 0) go to the False branch. But my point was that in recent C standards (after C99 I believe), in [stdbool.h](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdbool.h.html) you'll see: * true - Expands to the integer constant 1. * false - Expands to the integer constant 0. which is exactly how python treats it. To quote the BFDL in [PEP285 that introduced True and False to python](http://legacy.python.org/dev/peps/pep-0285/): &gt;The bool type would be a straightforward subtype (in C) of the int type, and the values False and True would behave like 0 and 1 in most respects (for example, False==0 and True==1 would be true) except repr() and str(). Granted this convention has existed in C well before C99, usually with `#define` statements like `#define FALSE 0` and `#define TRUE 1`. (Also in C, are just three ways of writing the same literal value (0); the only difference is typically '\0' will be one byte and `0` will be the default int size.)
Yeah, ML is more are more turning towards python nowadays... ...Until Julia gets of age, then we all Data Science folks will move there.
pylearn and theano seem very interesting too
I would give you a hand but I found CMV kind of unpleasant, tbh
&gt; This is, quite simply, insane If my stupid dependencies would update, yeah I'd use Python 3.x as well. I use the latest version of all my libraries, but I can't use the latest Python.
conditional_1 and _2 being booleans middle_range_calculation_result = conditional_1 * coefficient_1 + conditional_2 * coefficient_2 If the reader understands the reasoning behind it I think it results in easier to read code in this case, instead of either having conditional expressions in there or having nested if-clauses or having two additional temporary variables.
Be aware your dunder filenames just look bold thanks to the markdown formatting.
I specifically hate that they've confused `requirements.txt` with `install_requires `. They're meant for different purposes.
I absolutely agree that if Python is aiming for some kind of moral purity here 1 == True and 0 == False comparison by coercion is unacceptable, where [] == False and '' == False are not True. Along those lines I also feel that given the fervent mantra "explicit over implicit" what Python offers in [1] == [1], or [1, 1] == [True, 1], deep comparison, is magical. What Python calls "special methods" are employed clandestinely and responsible for this behavior to function, and are commonly called "magic methods". To me, Javascript does things more non-magically, by comparing by reference, and issuing that [1] === [1] is false because they are indeed not the same array.
While that's a common JS idiom, don't use it in python when you can just cast to bool. In [1]: bool([]) Out[1]: False In [2]: bool([]) == False Out[2]: True 
I don't think it does... It displays a message saying `Type :quit&lt;Enter&gt; to exit Vim`, if you are in normal mode. If you are in any other mode, it puts you back to normal mode. Try it. Ctrl+[ does the same thing, but without displaying the message telling you how to exit vim, which is for people who accidentally get into vim and don't know how to quit.
Very cool analysis! A few questions: 1. Do you think that the warm-cold month analysis should factor in the rise in the number of bicycles during the warm months? If there are more bicycles on the streets, then more of them will be stolen, but perhaps the overall level remains the same? 2. I think that a heatmap would better represent the data instead of points on a map [like here](http://thinkdatavis.com/2013/08/26/how-to-make-a-heat-map-with-hexagons-d3-js-hexbins-js-open-street-map-inkscape-and-paint-net/). 3. I also think there's a way to generate IPython html that you can paste right in your blog instead of screen shots. I hope I don't come off as rude. I'm in a similar boat as you are (python, data crunching, machine learning) and I'm always looking to explore and learn. Btw, I've read your other posts and damn, I really like the one about artists and analyzing images.
It does fully support language constructs, but it does not fully support language semantics, which is a much harder topic to cover. Translating to C++ is not a particularly useful exercise - there are limits what optimizations you can perform (since you need to prove things, which are incredibly hard in Python), the compile times are large and the executable size tend to be something very non-cache friendly. HipHop team learned it the hard way by making the PHP-to-C++ compiler and then writing a JIT. Besides, nuitka did not post any useful info on their blog in a while.
Could you please clarify which semantics are not supported?
&gt;If you are interested, please have a look through the code on GitHub, particularly the issue list which contains four feature requests, two of which haven't been started at all. Will see what I can do.
This. If checking for None, actually, really check specifically for `is None` or `is not None`. 99% of the time it won't matter, but there will be some point in your python career where it will stop you writing a horrible, horrible, insidious logic bug in your code.
There's a nice homomorphism from the integers into booleans.
&gt; homomorphism Can you explain what you mean by this? Too me they are conceptually completely different. I assumed the only reason for how python works is its c heritage. But is there some other reason? At the very least it has caused be two really annoying bugs that I remember. 
dynamic imports that change contents of unrelated modules to start with. sys.{getframe, exc_info, set_trace etc.) (can you run a pdb in nuitka?), I didn't care enough, but I'm sure tons of corner cases
Depends what you mean by nonsense. I think Javascript seemingly randomly being strict is far more nonsensical than it always or never doing so.
[x] == [x] is true however if x = float('nan'). However [float('nan')] == [float('nan')] is False. Strange.
Here's a crappy partial refactor I did of update_wiki_tracker if you're interested. I don't have any way to test this and I probably won't look at it again. https://gist.github.com/anonymous/04840a6fff136e954fa7 It's pretty hideous though and could use a more total rewrite by someone with access to some sort of test data or a working version of the bot... I have no idea what that will do. I think if I were to spend more time on it I'd make all/most of those functions private methods of DeltaBot (well, '_'-prefixed) or something. The nesting got a bit icky too.
This changes everything!
 &gt;&gt;&gt; bool('empty') True Oh no Python!
it's not about that. Those issues are well known and as far as I remember, the author considered them "not crucial" for being Python (which is in stark disagreement to say Guido). They make it incredibly hard to do anything optimization-wise and a lot of optimizations in nuitka are not very well thought out to start with. In short I'm saying that the whole project approach is essentially doomed to get anywhere and not that the implementation is buggy.
There's almost no limit to what we can blame on IEEE 754. I think the behavior makes more sense if we look at the literal behavior. Any number with all of its exponent bits set high is a NaN. They're unorderable because all precision information is lost without the exponent field. For people who think more easily in concrete bits, looking at the values makes a light explanation of that essay. http://i.imgur.com/fiH7Lx6.png
You can already `PyRun_SimpleString` with embedded libpython. It's like calling `exec`.
Last time I tried it, more than a year ago, it was slow as CPython. Cool project, but for speed there is pypy and cython, maybe numba, but this one is tricky.
How did you go about plotting the data on the map out of curiousity? I mostly use python for scientific computing, image analysis, and simple simulations, so that is pretty far out of my scope.
I'd use it to make a standalone executable more often than for any supposed speed improvements.
Performance aside, so this thing will make a standalone .exe? (Which doesn't have sourcecode in it?)
Thanks for taking a look! &gt; At least for the leaderboard flairs, twould be easier for an outsider like me if you went ahead and created some CSS for me to plug in. I was under the impression that all you needed for the code was the CSS class (which could be any word), and the rest of the CSS would just be in the stylesheet, not the deltabot code? I say this because we originally added the delta symbol after the number on the user flairs using CSS. Here's the current piece of code from the config file: "flair": { "point_text": "%s∆", "css_class": "points" }, But it would have originally been: "flair": { "point_text": "%s", "css_class": "points" }, In conjunction with this in the subreddit stylesheet: /* Post-text for the user flair added by deltabot */ span.flair.flair-points:after { content: "∆"; } In fact, I'm not sure why *"css_class": "points"* hasn't been removed from that part of the config, seeing as it's no longer needed (I think). So I thought that someone would write the deltabot code that followed the logic of: * Number 1 viewchanger of the month has CSS class "x" * The remaining 9 viewchangers of the month have CSS class "y" And then in the subreddit stylesheet I'd include some code that went like: * CSS class x makes user flair full gold (for example) * CSS class y makes user flair have a gold border. Apparently the hard part is writing deltabot code that changes the users this applies to when the month is up. I imagine it would work with the monthly leaderboard somehow, and remove the CSS class from the previous month's viewchangers. As for your first edit, I'll let the others know :)
Awesome. Thanks :)
It would help Mercurial to be ported to Python 3.
Shedskin works fine for standalone exe. 
&gt; Does Vim have typeahead search? Yes, it has. To activate incremental search, enter the command `set incsearch` (or put it in your .vimrc). 
Something like [cx_Freeze](http://cx-freeze.readthedocs.org/en/latest/script.html) is probably an easier and more stable way to make a standalone executable.
I informally benchmarked some programs with Nuitka 0.4.2, and it seems to be slower than CPython by about 20 or 30% on average (sometimes faster, sometimes slower). I don't know how 0.5.1 compares, but as fijal says, there are very-hard-to-overcome limits to what can be achieved by compiling through C++. It somewhat doubtful that Nuitka will ever consistently reach and exceed CPython's speed for common programs.
Well positionally they are off by one, but if you go by the top it is a off by double quotes.
Yes, vim has incremental search. If the `incsearch` option is set, then the `/` key starts a "typeahead" search, taking you directly to the first match as you type the pattern. Once you hit enter to confirm your pattern, `n` jumps to the next match, and `p` jumps to the previous. I can see how vim wouldn't be pleasant to use if you didn't know that it had incremental search, as it's one of the best ways to move around a buffer. Oh, and incremental search is a motion in vim. So if you see a word up ahead (say, `reddit`) and you want to delete everything between your cursor and it, you just type `d/` and start typing a pattern that matches the word, then hit enter when the pattern matches what you want.
Based on the academic skills you've developed, C++ would be highly valuable. I'm currently looking for jobs in machine learning or computer vision, and pretty much every job I've seen wants significant prototyping skills (in matlab or python for instance) but also significant development skills - usually in c/c++ because of their speed. You should also refresh your knowledge of algorithms and data structures - I know this will take you back to undergrad, which feels like a step back, but this is why cs phd grads have a reputation for performing worse than ordinary graduates in tech interviews. If you can implement and use all the standard algorithms and data structures (hash maps are a big one) you'll stand out from the crowd.
&gt; If you can show your ability to solve tough problems, industry experience is far less of a factor in hiring. This. I've interviewed a couple dozen people this year and this more than anything else will get you noticed. Also the ability to communicate, if you're asked a tough question with no prior knowledge or experience talk though the issue and try to solve it anyway. Saying "I don't know" is perfectly fine so long as you have a follow up answer and can explain what you *do* know about the problem or how you'd go about solving it. 
I've read that for people who transition from classified work to the private sector, a common solution is to give a presentation on the types of problems they're able to solve (you'll have to sell them on this obviously, but you're basically saying that you're going to try to prove your competence rather than just claim it, which is how tech jobs work anyway, so it shouldn't be that hard). So for example, if you made a laser only shoot people if their face is in a secret terrorist database that's accessed through an unreliable satellite network, you could talk about how you'd implement a system to recognize customers walking into a store even if the camera was low quality and had latency issues, or something like that. All that said, smart people are in short supply. You're probably way more marketable than you realize.
I would say most importantly, what industry do you want to work in? Finance? Tech? This would be a huge deciding factor on what to invest in. I know JP Morgan does a fair bit in python, as does AQR.
This is more than a decade old, and `dict.values()` no longer works as described in those messages. (In 3.x.) 
Apply to google. They're hiring PhDs left and right. 
Search for data mining and I page processing jobs on the internet. Most companies hire PhDs for their domain knowledge, not their professional experience. Also, there are few jobs where high proficiency in any given language is an absolute requirement. There are some, but it is definitely not the standard. 
It is possible to create 100% standalone exe. There is a way to compile your own code to native code while embedding stdlib as bytecode (this is way faster than compiling entire stdlib to native code). It is even possible to just compile your code to native exe (no bytecode inside ofc) and ship it in same folder with rest of python runtime.
that does not really hide source code very well does it?
Data mining and visualization would go a really long way in finance or any of these modern sites that rely heavily on analytics as a service. Have you heard of HubSpot? They might be a good choice since their business depends on driving traffic to sites and showing feedback for it. I have no idea if they're a Python shop or not however.
Sure. A homomorphism is a "structure preserving map". This means that if you take any true statement in the first domain, and do the translation, you'll still get a true statement. In this case, all the even number map to False, and all the odd numbers map to True. Addition becomes "xor", and multiplication becomes "and". In this sense, the booleans are a bona-fide representation of the integers mod 2, and it makes sense to identify them with the canonical representatives 0 and 1. (Using this homomorphism, it's harder to justify mapping even numbers to True, but there are other good reasons to do that, and good homomorphisms exist that do that, but they're a bit more tricky to grasp.)
the tool I like to use for version management: https://pypi.python.org/pypi/bumpversion
It's funny how asyncio satisfies basically none of these
This is my initial version. I am 99.99% sure that there are many code improvements to be made, and I would be glad to hear your suggestions!
Write some smallish library or utility that relates to what you know from your phd and make the source available. Link to it from your resume. There are lots of academics who can't write decent code, so this gives some assurances to potential employers that you can transition out of academia.
1. Become a committer on an open-source big data project. There are a lot of projects out there, just find one that is a good match for your skill sets and interest. Learn how to use it, answer other people's questions, find a missing feature, and implement it. These are the kinds of things companies are hiring for; if you can do it open source and have others review and approve of your work. Even better if you can become a committer on several projects. These this look better on your resume than almost anything else right now. 2. Understand hardware. You should be able to speak intelligently about the major factors affecting the performance of your code. Most CS types talk like their code runs on a single multicore CPU. I want to hear about RAID controller cache pollution, IO queue depth, network RDMA, and utilization of every QPI/PCIe/SAS/ethernet link in the cluster.
May I ask why?
Technically, asyncio is not a new feature. There was already a module for asynchronous I/O, [asyncore](http://docs.python.org/3.5/library/asyncore.html).
Don't forget everyone's favorite; async hat!
Calling it a floating point "flaw" was too strong; I should have said "this isn't a python flaw, its a proper implementation of the floating point standard". I totally agree that things like `NaN == sqrt(-1)` should return false. But it makes sense to me that if x = sqrt(-1), so `x is x` is true than `x == x` should be true -- in this case we are assured the LHS and RHS are the same not a number. Something like this would be possible to do in python (where things are GC'd and have reference count behind them), e.g., if NaN had equality rules similar to large numbers (things outside -5 to 256 in python2 I believe): In [1]: a = 300 In [2]: b = 300 In [3]: c = a In [4]: a is 300 Out[4]: False In [5]: a is b Out[5]: False In [6]: a is c Out[6]: True But wouldn't make sense in the floating point standard (where a floating point has to fit into 32 or 64 bits), and the extra complexity isn't really worth it.
There are definitely jobs specifically for machine learning, and I assume there are jobs for computer vision as well. http://careers.stackoverflow.com/jobs?searchTerm=computer+vision&amp;location=
That video is a year old (although they still use it on their website). http://www.chris-granger.com/lighttable/
Here's the source on Github https://github.com/LightTable/LightTable
Well, excluding Java and perhaps C# (with Mono runtime), which any other language has that kind of cross-packaging support you're asking for here? Honest question. I wrote a game with C and a couple with Python, and it's exactly the same thing (C is slightly worse, as I have to "compile" instead of "package"). See, for example: http://www.usebox.net/jjm/lunar/ I don't have Mac packages because that "non cross-packaging" issue you're mentioning, but I don't see how this could be avoided. EDIT: clarified, I used "cross-compiling" and that's not the same.
I was asked to implement a Hash Map in Python in an interview. I understand it demonstrates that you know the fundamentals of what it is and maybe how it works, but I thought it was completely ridiculous given it was a Python job and I'd never need to implement my own HashMap that only takes strings as keys on the job. I was tempted to write: class HashMap(object): def __new__(typ, *args, **kwargs): return {}
A link to the channel would help, don't you think? ;) http://www.meneame.net/m/python
&gt; Data mining. Instead put 'Big Data' on your resume and you'll have recruiters calling you day and night.
I got sucked into using python on a 400mhz system for work and we haven't had many problems that we can trace to it. Every now and then we have found the python interpreter screwing up and developing a memory leak, so we just run scripts to check on that kind of stuff and kill the process to then restart it. It isn't ideal but the real world never really is. 
&gt; I recently got my PhD in Computer Science, and noticed all work experience I have is Academic. I've been programming in Python for the last 6 years or so, mostly with data mining, image processing and data visualization. I worked a few very meaningful but classified (government sponsored) projects I'm not allowed to talk about, which is a HUGE pain as they can't go to my resume. &gt; &gt;I enjoy science and research, but I really want to start working "for real" now. What kind of skills should I develop to become more hirable than the fresh PhD with no real-world experience I am right now? It sounds like you are talking about making the transition from academic Research and Development (R&amp;D) to Production Systems Development. * https://en.wikipedia.org/wiki/Technology_transfer#See_also * https://en.wikipedia.org/wiki/Non-compete_clause * https://en.wikipedia.org/wiki/Reputation_management#Justification &gt; What kind of skills should I invest on? &gt; &gt; For those of you with academic background that were able to join the (non academic) market, what kind of skills you had to learn to be hire-able? &gt; &gt; (Sorry about the English, non-native here) I would imagine that different environments require different hard and soft skills. Open Source development could help distinguish your quality of work. * Ohloh metrics with ohcount * https://www.hackerrank.com/ * https://projecteuler.net/problems * http://rosalind.info/problems/tree-view/ * http://pages.github.com/ Many of the following Wikipedia links are translated to multiple languages: http://www.reddit.com/r/Python/comments/1sa5ot/for_employable_purposes_what_skills_do_i_need_to/cdwgwaa : &gt; Software Development &gt; &gt; * https://en.wikipedia.org/wiki/User_story &gt; * https://en.wikipedia.org/wiki/Pair_programming &gt; * https://en.wikipedia.org/wiki/Distributed_revision_control [1] &gt; * https://en.wikipedia.org/wiki/Test_automation [2] &gt; * https://en.wikipedia.org/wiki/Test-driven_development#Test-driven_development_cycle &gt; * **https://en.wikipedia.org/wiki/Continuous_integration#Principles** &gt; * https://en.wikipedia.org/wiki/Code_review &gt; * https://en.wikipedia.org/wiki/Release_management &gt; * https://en.wikipedia.org/wiki/Build_automation &gt; * https://en.wikipedia.org/wiki/Continuous_deployment &gt; &gt; Communication: Documentation &gt; &gt; * https://en.wikipedia.org/wiki/Technical_communication &gt; * https://en.wikipedia.org/wiki/Software_documentation &gt; * https://en.wikipedia.org/wiki/Specification_(technical_standard)#Information_technology &gt; * http://docs.python.org/devguide/documenting.html &gt; * http://write-the-docs.readthedocs.org/en/latest/ &gt; &gt; &gt; Open Source Teams &gt; &gt; * https://en.wikipedia.org/wiki/Open-source_software [3] &gt; * https://en.wikipedia.org/wiki/Open-source_software_security &gt; * https://en.wikipedia.org/wiki/Business_models_for_open-source_software &gt; * https://en.wikipedia.org/wiki/Comparison_of_free_software_licenses &gt; * https://github.com/blog/1530-choosing-an-open-source-license &gt; * https://github.com/pydata/pandas/blob/master/CONTRIBUTING.md &gt; &gt; &gt; [1] Revision Control (CVS, SVN) and Distributed Revision Control (Git, Hg, Bzr) &gt; &gt; * http://documentup.com/skwp/git-workflows-book &gt; * http://book.git-scm.com/index.html &gt; * http://hgbook.red-bean.com/ &gt; &gt; [2] Automated Testing &gt; &gt; * http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/c9tfxgd &gt; &gt; [3] The Art of Unix Programming: Best Practices for Working with Open-Source Developers &gt; &gt; * http://www.catb.org/esr/writings/taoup/html/ch19s02.html http://www.reddit.com/r/Python/comments/1sa5ot/for_employable_purposes_what_skills_do_i_need_to/cdwh2u6 : &gt; Teams &gt; &gt; * https://en.wikipedia.org/wiki/Team &gt; * https://en.wikipedia.org/wiki/Team_building &gt; * https://en.wikipedia.org/wiki/Tuckman%27s_stages_of_group_development &gt; * https://en.wikipedia.org/wiki/The_Five_Dysfunctions_of_a_Team &gt; * https://en.wikipedia.org/wiki/Collaboration#Technology &gt; * https://en.wikipedia.org/wiki/List_of_collaborative_software 
as a hiring manager (and a phd), the biggest worries i have about academic-only coders are: - code that isn't robust or efficient - projects that were solo and not collaborative working an OSS project - preferably with a team - will go a long way to relieving those worries i have - can you work with others, do you write clear, communicative code, things like that. barring that, code samples in github or something like that help me see your work (e.g. side projects). blogging is a great way to shortcut this, too - e.g. i interviewed someone who had done some data analysis of NBA teams and had some interesting takeaways. pick a domain with data that's available and do some interesting analysis, show your code, make some pretty graphs, etc. you'll impress me. i'd be curious to know your area of focus, i need to hire a research engineer with those skills in the DC area. if you'd like, get in touch via a private message and we can talk more to see if our domain is of interest. 
Being from academia you should hopefully have gotten this NO BSing lesson driven into your head so that's good.
Java. Just because it's not commonplace doesn't mean it's not useful. I use Java or Python generally. Python if it's personal or for fun. Java if it's serious and needs to be run by people other than me. I'd rather not do that because Python is so much better (I think) generally to work with. At least with C or C++ you can easily make something that will run on someone else's computer that's running the same system as you. Whereas on Python if you want to send something you either need to package it into a .exe (that generally doesn't work I've found), or you have to give them a long list of other things they'll need to install for you program to work. 
Your first example is cool. I think it would make more sense if it was int(x&lt;y) but I can see how convenient that looks. 
PyPy is about the only thing I can think of emitting native code with a hint of obfuscating. As I remember last time, you stated that it is very difficult to export the state of the JIT to be resumed again later. I could see a frozen, just started PyPy state being very close to a native executable. Then again, I could be wrong and would like to hear why. Thanks
I don't have any experience with Oracle but it sounds like you just don't want to directly work with cx_oracle and want something a little higher level? If that's the case you might want to look at [sqlalchemy](http://docs.sqlalchemy.org/en/rel_0_9/dialects/oracle.html), it will still require cx_oracle but you won't typically be interacting with it directly anymore. It does add on things like an ORM but you can still use sqlalchemy without using the orm directly plus you get the added benefit of being able to look at other backends too. Considering I don't know enough about Oracle or its features sqlalchemy may not be the right thing for you. But without much additional information it kind of answers the *"does anyone have a go to module for interfacing with &lt;db name here&gt; databases that isn't &lt;python module name here&gt;"* question by abstracting away the need to directly use a database driver.
I remember that kickstarter... lots of interesting ideas, did he actually deliver on the promise? It really seems like something that would work amazingly well for toy projects but would fall apart in a giant legacy app. curious to see if that's right or not
Honestly, the market is on fire for good Python devs. If you can discuss the techniques and domain knowledge you have around data mining, image processing, etc, you should have no problems. I work in media (where everybody has unusual backgrounds) and know a few prestigious places that are hiring. If you're interested, DM me for specifics.
Your experience distributing Python applications has been bad, but my experience is completely different (note that I don't say "opposite", because it isn't easy... but still perfectly possible). "At least with C or C++ you can easily make something that will run on someone else's computer"; exactly the same with Python, I had my own problems finding out which DLLs I had to distribute (and if I could, because licensing of runtimes and such). I think you need to research a little bit further on how to package Python apps.
Difficult to get working? How so? You have to point it to an Oracle client directory. If you don't want to install oracle client, download their oracle instant client and point the correct environment variables at it. .. Why is this difficult? 
If you can't get people involved in a project, why not try and raise some funds and offer them as a reward, or if you get enough money hire someone to fix the code?
Thanks for reading and the feedback! For your first point I think that could play a part at some points but from personal experience the number of bikes I see locked up around the city stays pretty high year round, especially around the college campuses. Regarding the heatmap, I tried to do this using google fusion and they only allow the first 1000 rows of a spreadsheet so it didn't work to well, I am working on finding a way to do this in python. For the iPython you are correct and I have been looking at a way to post the cells inline using html using ghost but am having trouble finding an easy way to do this. Thanks again for reading, if you have any more questions or tips dont hesitate to email me.
For this project I used google fusion https://support.google.com/fusiontables/answer/2571232?hl=en which is very easy to use. But I have been working on learning https://github.com/wrobstory/folium to do mapping directly in python. Thanks for reading!
In my production environment (CentOS) its pretty easy to lay out. I understand the whole reason for needing the instant client and truth be told, they can't do much on this. However, in my development environment (OSX), its a pain because we basically to compile from source. Also, it appears there are some issues with this step as of XCode 5.1. I guess my phrasing of the question is wrong. Again, I am not saying the code is bad in anyway. I am just curious if there are other implementations out there. :) 
I am in no way against working with the DB directly :) I posed this question as a general inquiry. My main challenge is the following: I have a application that talks to a Oracle DB and works! However, as this project is expanding, I find myself helping others get started with the code base. While I definitely don't mind assisting, in fact I scripted most of it, there are usually always a quirk that is involved with cx_Oracle. Mind you, not all of the people committing to the project are full time developers (more of the devops role). 
Ah. I guess that's what answers my question then, thanks.
Only a tiny percentage of stdlib modules were initially released outside of the stdlib. I have no idea how to even begin measuring how much less competition this would even create if it were true. Same for the last assertion about quality. There is a focus on better packaging tools (i.e. wheels vs. eggs) and distribution methods (pip vs. easy_install).
"Here's how I would implement a turret system that would fire an M26 2.36 inch Gas grenade right into a customers face"
Yes of course, what I said was ambiguously worded. What I meant is that if you went ahead, made an executive decision and added the new classes to the stylesheet, then an outsider could actually do as you requested (rather than having to wait for a decision about what people on the scoreboard get what different flairs). Basically I meant what you said. I believe that a "css_class" is required by PRAW for setting flairs, but I'm not entirely sure if that's true or not. If I here about what Zenmodo is hoping to accomplish and/or how far he is with that, I'll look into actually writing/submitting some code tomorrow.
Yeah, that's a lot better; most importantly, the try/excepts did what the original author intended, and not way more than he intended.
I've been reading a book on coding interview problems. The book gives answers in Java and I was thinking I'd do the exercises myself in Python. The very first one was implementing a hash map, and I was like...dict()? So did you really implement the hash map in Python and did it work interview-wise?
People that have to deal with your code in a few years won't hate you (as much). Also the option of [functional annotation](http://legacy.python.org/dev/peps/pep-3107/#syntax) for either enforcing type-safty or just better documentation is cool. 
There's been a lot of good advice here, so I'll try to share a bit of what I've seen that doesn't overlap a lot with what others have said. First of all (and please don't take this as a criticism; you seem to already get this) recognize that your Ph.D. makes you highly qualified in a very narrow specialty, but that your "industry-worthy" cred is next to nil outside of that specialty. Unless you apply to a job looking for someone with research ability, your degree may be viewed as a liability. Be confident but humble in interviews to counteract this. Nothing will disqualify you faster than perceived "academic airs", even if they're invented by your interviewer's prejudices against academics. I have personally worked with Ph.D. holders that were so focused on their particular research area that they completely neglected what they learned outside of it from their undergraduate work. Make sure you brush up on the basics through a broad range of CS topics, especially if you're going to apply to a big-name company like Google or Facebook. They hire a *lot* of freshly minted BS in CS, and their interview questions reflect that. Possibly one of the most valuable things you could do is contribute to open source projects in a way that you can demonstrate on your resume. But don't do this *just* as a resume-builder; do it because you are interested in the projects themselves and commit to improving them. Being able to show that you've got coding chops as well as the ability to research will go a long way. Finally, I'd suggest taking the time to learn industry tools and practices. Make sure you have a solid understanding of revision control tools (git, svn, etc.) and processes like maintaining documentation, test suites, and doing code reviews. Often academic software is written in a hurry by a small team, and only needs to be 'good enough' to illustrate the research. Industry software teams want to know that you are aware of established code standards in the industry and the practices in common use to maintain those standards. And keep in mind that these practices and tools will vary a bit depending on the industry! Be sure to do some research in that direction for jobs you're interested in.
Define an API that you essential can never change and establish a need for it in the larger community by the vast majority of people. If something like numpy can't get into the standard library, a one off feature certainly won't. The standard library is supposed to be sparse such that you should learn all of it. Packages go to the standard library to die, so you better have it right. The API in Python 2.2 is probably the same as it is in Python 3.4. Also, since you can't backport standard library modules (except in very rare circumstances), you are forced to wait for Python to upgrade to add a feature.
Did you manage to get cx_Oracle working on OS X yet? I noted the steps last time I did it -- it was a PITA at the time if you still need to get it working, let me know and I'll dig them up.
I did! Fortunately. I had to write down the steps just in case I needed to redo the process too! http://joelvasallo.com/?p=276 However, a few people seem to have issues compiling it recently due to the upgrade to XCode.
No worries. :) Thanks for the suggestion on sqlalchemy. Its one of those, I should look into kinda projects. I only heard good things. Thanks again!
Okay, cool. I added this to the CMV stylesheet: /* Top Ten Flair */ .flair-numberone { background-color: #DAA520; border: 1px solid #B8860B; color: black; font-size: 11px; font-weight: normal; height: 14px; } .flair-othernine { background-color: #FFF; border: 1px solid #B8860B; color: black; font-size: 11px; font-weight: normal; height: 14px; } The css class is "numberone" for the top viewchanger of the month, and "othernine" for the remaining nine users on the leaderboard. Is this what you meant?
Where are you located? It sounds like you have a strong foundation in big data. Master R, hadoop, map/reduce, MARS and MADLIB so you can practically apply your analytics/clustering/modeling expertise. Study marketing classification so as to draw the line in from the business side to your technical/science focus. This "data science" skill set is in very high demand and you can write your own ticket. If that doesn't work then create your own blackjack system and hit Atlantic City.
This is a kickstarter for low end embedded systems and isn't really required to run Python on a Linux system. It replaces an RTOS on even more restricted hardware than I am referring to, not embedded Linux which is typically capable enough to run most of Python normally. There are also questions regarding using this in a production environment.
If that's what I put into [this function call](https://praw.readthedocs.org/en/latest/pages/code_overview.html#praw.__init__.ModFlairMixin.set_flair) then yes. (That's probably correct, but when I look at it tomorrow I'll try and double check that it is correct.)
You mean the words "numberone" and "othernine"? The code I copy and pasted there only goes in the stylesheet, right? Because that's CSS and not python? The last time we used CSS in conjunction, we used the css_class "points", which is still in the config. I'm a bit confused about the link you gave me if I'm honest :P Edit: Yeah, I think all you need is css_class="numberone" and css_class="othernine"
There are several ODBC interfaces that are more or less easy compared to cx_Oracle to get working. It is a generic interface, so you are limited to doing only those things that ODBC supports, of course. There is an ADO interface that you can use on Windows systems. Again, it's not very portable. ODBC is not as portable to non-Windows systems. If you are using Jython, you should be able to use the JDBC interface. If you are using IronPython or another .NET enabled version of Python, you should be able to use any available .NET db library. But, there are a few simple rules that can help work with cx_Oracle. First and foremost, you must use a version of cx_Oracle that matches your version of Python, and matches your Oracle client. Oracle recommends that you match the Oracle client version to your Oracle server version, but there is a lot of flexibility there, and all clients above level 9i are backward compatible with Oracle servers down to level 9i. Clients are not fully upward compatible with higher level servers, although they will usually work for basic CRUD sql. You can use either the Instantclient or the full client with cx_Oracle. I'm going to assume you have exactly one oracle client and one python installed. If you do, remember that cx_Oracle will only work with one client at a time. So, install Oracle client software that is on-level or higher than your highest level server. Make sure it works with SQL Developer or SQL Plus. Install the cx_Oracle version that matches this client and your Python version. Open the python console and "import cx_Oracle". If this fails, check the ORACLE_HOME environment variable. It should contain the path to the directory 1 above where the sql plus executable resides. E.g. if the path is c:\oracle\home1\bin\sqlplus.exe, ORACLE_HOME is c:\oracle\home1 Setting up cx_Oracle on linux or anywhere else where you do an install from source is often a lot easier than trying to setup on Windows. Just make sure you have ORACLE_HOME set properly before running setup.py. TL;DR Follow a few simple rules to make life with cx_Oracle easier. 
Look at Bank BJOrgan. Massive python project on the go, likely to be for a good few years yet. Just dangle your academic 'clean slate' in front of them. They like minds that are malleable and unsullied by critical thought. Ie you'll work mental hours on non transferable technology (except Python) but may be well rewarded. 
Python 3.3 got a sane [hierarchy for IO and OS exceptions](http://docs.python.org/3.3/whatsnew/3.3.html#pep-3151-reworking-the-os-and-io-exception-hierarchy).
All I meant with the link is that when I set a flair, I need a "flair_text" and "flair_css_class" (and that's all I can set from a Python bot). It seems that with your edit, you've come to the same conclusion and are telling me exactly what I needed, thanks :D
It would have worked, but I was told not to waste time trying to implement a hash function, so there was no way to run it. I was basically told a NotImplemented raising function `hash(self, s)` would return a number between zero and two million. Then I was supposed to take the modulus 50 of that function and use that result, which of course forces many collisions. I stumbled on collision resolution, where I suggested to maybe place another hash table in that bucket and use a different algorithm, or you could just append a specific character to the end so it hashes to a separate value there, and so on recursively. If you look up methods to deal with collisions, that's not a standard solution, so it's probably not the best answer, and it wasn't what he was looking for. He pushed me into doing something else, so I worked out to use a list of two-tuples of key/value so you just iterate down it until you match the key. He was satisfied with the final code, and I'm almost positive it was bug-free. There wasn't much to it. I understand he wanted to see how I would handle the input of the hash function, and how I would handle collisions, but it's just such a trivial problem in the context of what I would be doing, and if I actually *did* run into this problem on the job, I'd have quickly googled hash-function collision and implement the standard, best performance for the input, version of one. This was for a dev/ops engineer position where I'd be writing Python code to deploy and maintain virtual machines in the cloud, handle monitoring, build systems, configuration management, etc, so it was a very unexpected tangent that I'd expect for an entry-level position. I have already built deployment tools for all of this before, and knew from memory how to use boto, fabric, AWS, and puppet, and I wasn't asked about any of that. It was strange. I didn't get the job. That was one of five coding tests, four others which I had finished without any trouble.
[asyncio](http://docs.python.org/dev/library/asyncio.html) is pretty cool. But Python 3 isn't just about cool stuff. Python 2 is in maintenance mode, so it doesn't get any better. Some bug fixes (especially security bugs) get applied, but behavior doesn't improve. Working in my current Python 2 codebase, I increasingly find places where we had to do something hacky or awkward because of a bug or lack-of-feature in Python 2, only to find that it has since been corrected in Python 3. Example: When you stat a file *in Windows* in Python 2, the result isn't entirely useful - the inode and device numbers are both zero, and if the file was a symlink, the stat is for the wrong file. In Python 3, the results are much more useful.
Cool. The flair_text will be whatever their delta score is, and the two css_classes are those two words. Thanks :)
Yup! Like I mentioned in a later comment above, I am more familiar with Linux setup, but there was just a few oddities when doing all the usual steps on a Mac (I guess its something I did to myself hehe). I like the instant client, kinda lightweight and no need for the full especially for portability. 
Not so in some settings where funds are from large-scale, applied projects. By nature, there are regular dog-and-pony shows and some students end up believing some of the BS they have to regurgitate. 
!!! What? I must be living under a rock because I know nothing about cxfreeze. I've been looking for something like that forever!
You appear to have ended up with a Django clone
Why do your prod/dev environments have different OS?
What downloading to oblivion? Are you talking about the standard Reddit-fuzzing? 
Note that a port of asyncio to Python 3.2 and below is available through the Trollius project. It lacks some of the nice syntax of asyncio under 3.3+, but is a good way to start out with asyncio for people who cannot currently work with Python 3.3+.
http://www.reddit.com/r/Python/comments/21np57/how_come_there_is_so_little_talk_about_nuitka/cgeunxy That's the parent to the answer I was looking for.
Ah. I see. Thanks.
Another example: I wanted to make a table of all ASCII characters using reStructuredText. GitHub didn't show a preview so I filled a bug. Turned out that the quote character I used for the table broke things because it's 2 bytes in utf8, and the stdlib CSV module parsing the table uses byte strings while only accepting one byte as quote string. I also helped them fix another python2-only quirk by hacking the default encoding to utf-8
Python 3 is free
So is Python 2. Free as both in beer and freedom.
python 2 isn't seeing anymore development and enhancements
If you're talking about [PEP 466](http://legacy.python.org/dev/peps/pep-0466), those are security enhancements. Security is very important, and Python 2 will keep getting updates in that area for quite some time.
That is the main one! I thought there was one more that I ran across as well, but I am easily confused and could be mistaken. &gt; Security is very important, and Python 2 will keep getting updates in that area for quite some time. It *is*. I was a little surprised that it took Guido so long to get around to approving PEP 466 actually. I think the point I was trying to make is that even though 2.x is in "maintenance mode", there are some functional improvements beyond simple bug-fixes going on. Not a lot, though, I grant you. I'm a lazy goof, so I have been slow to move off of 2.7.x. And I really haven't felt the need until recently, which has been different packages that I use making the (often slow) transition over. I spend most of my time in NumPy and SciPy, which I guess work with 3.x. I don't think that MayaVI does, but I haven't checked recently, so it may well do now. 
Am just starting on Flask but it does seem to converge to Django in a slightly terrifying way ... if only Bottle was more mature
Find places that want your current skillset. 
Besides the advantages others already mentioned you will have to switch eventually, if all the modules you use already support it - why not switch now?
Got to say, ... indeed it was :( And I even haven't add manage.py to sum up all script task using Flask-Script
Honestly? There's no truly great feature in 3.4 that's missing from 2.7. Anything remotely amazing will be backported (Tulip -&gt; Trollius), already available (pip, virtualenv, mock), or really isn't that groundbreaking to begin with. I work on Solaris (specifically the Install stack and OpenStack) where everything is Python. 2.6. Yes we're way behind and we're working on fixing that but 2.6 is perfectly adequate for ours and out customer's needs. The primary reason we're moving away from 2.6 is due to security reasons. 2.6 is totally unsupported now and 2.7 will be unsupported except for the most dire of security issues. The amount of work required for Solaris to move from 2.6 to *anything* else is staggering. We have to move a huge amount of code all in lockstep and that's a pain in the ass.
Cool -- that was pretty much it. The only issues I've had with Apple LLVM 5.1 compiler were with some other python packages but I fixed with the ARCHFLAGS env variable you listed on your blog but had to try cx_Oracle yet.
I used to run the same setup as my Prod but you shouldn't have to do it. Good code should run everywhere, especially with Python. :) I do have a vagrant box with a similar setup however.
It's open sourced now, but you're right, not really much use for a big legacy project
install hadoop/PIG on your laptop (or spend some pesos on amazon's elastic map reduce) and learn how to use it. brand yourself as a data scientist and profit
The integration with python is still buggy but it's pretty neat.
You know the economy's bad when a guy with a PhD has to "become" hire-able.
Interesting idea. You know about the various libraries for embedding Python in the application itself and distributing as an executable, right? Here's a good [list](http://docs.python-guide.org/en/latest/shipping/freezing/) to get you started.
cx_oracle is a very quirky driver with some annoying limitations too, SQLAlchemy smooths over some of the quirks but it was tricky to accomplish. the cx_oracle dialect probably has the most caveats listed of any SQLAlchemy dialect (as does Oracle overall). Taking a look at the issues we've worked around is a good intro to how to deal with this DBAPI in general: http://docs.sqlalchemy.org/en/rel_0_9/dialects/oracle.html#module-sqlalchemy.dialects.oracle.cx_oracle
Yes, I am aware of it. What I meant is, to have users recognize Python as 3rd party application framework that give a new features in Operating System, in the same level as Dot Net framework does. At the current state, users still think of Python as a huge application libraries that tied only to a single application they were installing. You don't ship and link .NET framework with your application. It will install itself in OS: later application can use this same framework. At the moment, it's not the case with Python. If the .NET application ship its own DLL, well, it just sit there in the software installation folder. I would love to have this same feature in Python for Windows.
It's a good learning experience. I've done it a few times with what I though were going to be small Flask applications. I'm actually rewriting a Flask app I wrote in Django and it's fairly obvious now I'm doing it I made the wrong choice initially. Oh well :) 
Typically it arises when using this idiom: sum(x&lt;y for x in z) (and, occasionally, `x += some_flag`). 
IIUC, Numpy's non-inclusion is due to the fact that it has its own development process that suits their community well, and Guido thinks things will work more smoothly if that isn't disrupted. It's not that it's not important enough to be in the stdlib, it otherwise would be.
I really curious for the next phase in my learning experience : converting some package into flask-extension. Have you done this?
&gt; its a pain in that @#$ to get setup Isn't that pretty much what defines Oracle? ;)
So, some of the bot's code is a bit hard to follow. I decided to start simple and rewrote strip_quotations() to improve the functionality so that it could: remove all quotes, even blockquotes -- and so that it would no longer remove all lines with an '&gt;' symbol. I may need some help to figure out how to test the code, though.
So.. It says right there that you still need the private key, which isn't a big surprise. This is simply a slightly more trustworthy script to decrypt the files once you pay the ransom and get the key. 
Did you read the page you linked? &gt; The decryption engine only works if you have the private key. Given the encryption algorithms in use by CryptoLocker, there is no known way to recover the private key without paying the ransom. If she's not going to pay to get the private key, it's game over, just reimage the machine and set up better backups for next time.
I came here to say the same thing as /u/issackelly and /u/n0t1337. Without the private key (the file needed for file decryption), the script will not work. Here's a [intro to encryption](https://ssd.eff.org/tech/encryption) provided by the EFF.
You cannot recover the files without paying
So I read your question, and it's hard to really respond without stating the obvious: you're focused on the moss of a tree rather than the forest. The right type of question you need to ask yourself is -- how can I help this company with the deep knowledge that I already have? How can I manage the timeframe that a business has with the project management skills that I have? How can I mentor other members of the team since I have a much deeper understanding of software? Businesses need engineers and programmers with soft skills as well as hard skills. Can you adequately explain a problem in simple terms to your direct management? How about a presentation about highly technical information to non-technical people so they "get it"? When you disagree about an approach to a problem, how would you convince a coworker that your approach is better? How would you convince your management? Could you accept the wrong approach gracefully? Your resume's purpose is to get you an interview. After that it is up to you to convince the interviewers that you can fit into the company culture and prove to be a solid addition to the company. Most companies have the following interview/on-board process: 1) Quick interview with a non-technical to gauge interest in company and potentially provide some information about the positions available 2) A timed programming test which will test your basic understanding of a language paradigm (often in the language of your choice) 3) A face-to-face interview with a team where they will ask you: a) algorithm questions (O-complexity, optimization, etc.) b) description of a project you've worked on and how you solved problems c) a design problem to solve with the team or on your own Sometimes there's a follow-up interview, but the 3 steps above seem to be fairly common across the U.S. 
Honestly, if PEP 465 goes through, there would be an even stronger case for adding (a subset of) NumPy to the stdlib...
I have to say as much as i like the idea behind it, i simply can't work with any editors that don't have vim mode available. Guess that's the price you pay when you work with it on daily basis. 
This is hilarious but true.
I'm a total noob as well, but from what I discovered so far, you should only use lambda if you want to assign a throw away in side some call, like sort: `mylist.sort(key=lambda x:x[-1])` to sort the list by the last character. If you just want to define a short function, you should use 1-line def: `def myfunc(x, y): return x+y` instead of `myfunc = lambda x, y: x+y`
To say they shovel "every popular library in the stdlib" is fairly -- hilarious. They are extremely conservative in adding libraries to the stdlib. Some say, too conservative. I think they have a decent balance. But, to address your concern, they have been steadily focusing on packaging tools. The whole "py" command line thing is an example, and in 3.4 the inclusion of pip bootstrapping. Pip works quite well. It occurs to me you may mean "packaging" as bundling an application into an .exe or such-- py2exe, pyinstaller, cx_Freeze and the like; the core python-dev maintainers will never focus on that kind of tooling -- if people are interested in that they should contribute to those open source projects. That said, what exists works fine. There's some complexities and edge-cases and sometimes its not as nice as clicking 'Build', but its entirely functional. For real, huge complex applications with numerous third-party libs even. It isn't ideal, it may take a day or so to figure out when you're just starting out -- and someone should look into that. Someone should get motivated to making that better. But, people are motivated as they are, and python-dev seems largely comprised of people who are in institutional environments. Python being there and Python having requirements (maybe in a virtualenv?) is not a big deal for them. That said, for my part, I deal with delivering python applications to users who don't have python installed or can readily get it (ie, linux distros and the like). My huge, complex application can be readily distributed to diverse environments. The only real complaint I have is that I can't cross-compile a distribution for both windows, mac and linux is a problem. I don't know that core Python-dev are the ones to answer it, because frankly its a very hard problem. 
The syntax is not intuitive. I personally get data the way I need in sql and then push into pandas for analysis. 
Coincidently, I just posted on shim issues about the same topic (https://github.com/swong15/shim/issues/21). There is no super amazing feature only on Python 3, but Python 3 is much more consistently and robust thanks to the general cleanup of the language. And Python 2 is on maintence mode, while Python 3 gains new features (like Enum). You can get the majority of changes from Python 3 on Python 2 using __future__ imports, but this make the code less idiomatic.
Very nice list. Just one correction, argparse exists on Python 2.7.
Any time! I think the subject you chose is really interesting as it brings data closer to real life. Might help someone's bike not get jacked. Good luck with the work and I'll be checking in on your RSS every once in a while.
I was somewhat disappointed - I funded the kickstarter but in my opinion he has lost his way. The value of the system was supposed to be seeing the results of your coding in real time but for some reason - possibly practicality - it turned into a system where you had to hit a key combo to see eval results and didn't show results for non-assignment and... at that point I kinda gave up, I can already get all that from other IDEs. Perhaps the clojure support is better but the python stuff isn't any use at the moment.
I knew when I posted, but the concept is valid in Python 2.7. `dict.values()` behaves same in 2.7. 
LightTable didn't exactly become as radical a departure from the typical IDE/code editor as was intended, but it's still pretty great. It feels a lot like Sublime on the surface, but the emphasis on in-line eval is super useful. I'll say that it's my preferred way to work with ClojureScript (Clojure in, JS out), as I can eval my code in LightTable and see results in my browser without having to recompile and/or refresh. This works for JS too, AFAIK. [Watches](http://www.youtube.com/watch?v=d8-b6QEN-rk) are great as well. Not sure what the support is like for Python, but they can be crazy useful when writing Clojure or JS.
Is your Matrix a list of lists? If so, you would reference a single value as `Matrix[i][0]`. And if you want to retrieve a few values from a row, you could use list slicing like this `Matrix[i][n:n+count]`. Is your function `fun` in your own code? It might be simpler to modify it to take a list, but if you want to use variable arguments, something like this should work: fun(*(Matrix[i][n:n+count])
Ah, numpy. Give this a try: fun(*Matrix[i,n:n+count]) In your `fun` function, the value `args` with be a list.
Check out PySide/PyQt. 
THANK YOU!!! I had everything right except I did not have the * there... I was trying to call fun((Matrix[i,n:n+count])) *facepalm* It's been a long day You made my day.
These articles were useful for me to get how it basically works: [Pandas top 10](http://manishamde.github.io/blog/2013/03/07/pandas-and-python-top-10/), [Intro to Pandas](http://www.gregreda.com/2013/10/26/intro-to-pandas-data-structures/); useful to get the basic idea. After that i skimmed through some presentations on [pyvideo.org](http://pyvideo.org/search/?q=pandas), but I've mostly been playing around with it with datasets learning things as I need them. As for gantt-type graphs that is more a matter of learning **matplotlib**, right? In any case I don't know that there is a dead simple way to get exactly what you want with labels etc., but you can start [here](http://stackoverflow.com/questions/18066781/create-gantt-plot-with-python-matplotlib).
That's a very nice list. Thank you!
It's a rich tool which is young, so continuously evolving. The first time I approached it, I needed to do just one thing, and the versatility of pandas made it seem like overkill, so I didn't use it. If you take the time to work through some tutorials, you'll see it will really simplify your workflow. After a some months, I use it even to do small dataset work, plreparing linear data for matplotlib, etc...
It has vim keybindings
Work through the pain with the documentation opened until you learn the subset of the API you need
At least some of Hubspot's work is in Python, I think. Source: I've seen tweets by their CTO @dharmesh mentioning him using Python (and maybe Django). Not sure whether it was for an internal tool or their external products, though. 
You probably want to write a SAX parser. Look at xml.sax in the stdlib.
Boo! Blowing the horn for your own project on reddit, you should be ashamed of yourself!
thx for sharing also `q` is useful for debugging https://pypi.python.org/pypi/q
Malkovich Malkovich!
Posting a link on reddit is work? This is great news! (On a more serious note though, it was actually published on friday, I just didn't get around to posting this yet)
Here's another project that seems similar: http://pyrasite.com/
I think one part of the reason it's hard is that it's limited by Python syntax. They can't just use dollar signs, double square brackets, and other random syntax as used in R dataframes. So you end up with functionality which is spread across functions (`ix`), attribute access (dot notation) and key-value access (square brackets).
Well that's the point isn't it? Instead of doing work stuff during work hours you're doing it Sunday morning which should be your leisure time. You couldn't wait until Monday during work? Don't let life pass you by while you work for free on Sunday. 
Seriously, they should just shut the place down on Friday afternoon. They can rename Google Now to Google Eventually.
Ah yes, I forgot about that, thanks for pointing it out. Pyrasite's nice, but its code injection is less stable than pyringe's. (If the currently executing thread already has the GIL, but the interpreter is not in a state in which it's safe to execute the injected code (there's tons of non-reentrant functions in cpython), pyrasite will just segfault the interpreter. Pyringe gets to a safe place first before injecting.) (Not trying to imply pyringe &gt; pyrasite, they have different feature sets, and pyringe doesn't let you do profiling, but if you only want code injection, I'd humbly suggest you rather use pyringe)
i think python was initially created on guido's free time... well not only python but just saying
Inventing a programming language which grows and grows and gets you hired by Google isn't the same thing as posting a non-unqiue project to github during non-work hours when you already work for Google.
In my case, "Monday during work" doesn't exist, my internship ended on friday. It's back to university for me. I'm just trying to get people to use pyringe. ;) I get what you're trying to say, but seriously, working overtime or during the weekend (except for on-call rotations) is frowned upon even at Google.
&gt; I get what you're trying to say, but seriously, working overtime or during the weekend (except for on-call rotations) is frowned upon even at Google. That is such bullshit. Just something they tell the interns. In most groups if you don't spent at least 9 hours a day at work (not counting working on the shuttles), you aren't going to meet expectations. Go to campus on the weekend and you'll see plenty of people working, not just doing laundry or working out, but sitting at their cube and working. 
People work on the weekends (and not just Googlers). Some even enjoy their jobs.
i coded many small closed source software on my free time for my previous job and i dont even have the code nowdays and i didnt get paid extra for it. It was fun I also learned a lot from them. i dont see whats wrong with having fun coding? Also i dont think the goal of creating a language is to get hired by google
This question really belongs in r/learnpython. I'd just use BeautifulSoup for simple XML parsing tasks. Something like: soup = BeautifulSoup(xml_str) rec1_tag = soup.find("rec1") rec1_str = "|".join([ child.string for child in rec1_tag.children if child.name.startswith("nested")])
I love my job, but it's my job not my life. There is a difference between working to live and living to work.
&gt; Work to live people, don't live to work. anyway i prefer working than arguing with people i know i wont agree with. i don't say i am right just saying this conversation is going nowhere so just end it 
&gt; i think python was initially created on guido's free time... well not only python but just saying Just out of curiosity do you consider that comment as arguing? Anyway i'll follow your advice and work. thx it was very useful advice! 
Um I don't think this is the case here. Plus I don't know about you, but I like programming. At my job if a project runs out of funding, but I want to finish a feature I will work on it in my free time. It is my hobby. I love to program. If someone wants to program on work stuff on the weekends let them.
Do you seriously think posting a link to reddit is work? How about reading about programming on reddit on a Sunday. Is that okay with you? Is commenting on something programming related? I assume you would answer yes to those, because you are doing both yourself. How is posting a programming related link that different?
"The Internship"? I tried, I really did, but the movie was too cringy for me.
Too cringy because humor was horrible/forced, or it hit too close to home? Do interns still have separate colored badge picture backgrounds then everyone else? (I think they were yellow..)
Literally jijler
Haha, wtf did this thread turn into? Look at yourselves people... OP - thanks for sharing, just got to learn that it exists.
Can you perhaps tell us a little bit about the history of your project? Since at least the open sourcing has been a one man job, and with the "by Google!@!" bells and whistles leading the description, I'm wondering just how long this code has been around for, and whether or not it's actually seeing use internally, and in what kind of systems. It seems all too common for the 'google' Github account to be a dumping ground for random employee's "prestige" projects that have very little to do with the reality of software inside the company.
Mine is getting the data via sql and push to excel 2003 (*gasp*) for analysis. Maybe because we're already invested too much in sql? 
would love to use this, however pip install not working. https://pypi.python.org/pypi/pyringe gives a 404
Should be fixed now, sorry about that.
Showing off your cool project to reddit is definitely a leisurely pursuit and a great way to spend a weekend, whether you were paid to build it or not. Kudos, OP :)
Cool it, pander monkey
This is all I wanted to know :) Looks like a decent piece of code, congrats on the release
thank you, all good now.
&gt; she's not going to pay the $400 in bitcoin they demand Well then, good luck with that, 'cuz just like everyone else has pointed out, that script only performs the decryption *when you provide the key*. You don't get the key unless you pay. CL isn't some amateur shit that you can just Google your way out of - ["This is REAL!"](http://images2.fanpop.com/image/polls/343000/343131_1261109611839_full.jpg). Also, my condolences. $400 to hackers is a pretty bitter damn pill. Pay it, and start working on a better backup scheme.
For those familiar with both, how does this compare with ipdb? It's the debugger I currently use but I'm always open to new options.
I would recommend Kivy.
Thanks for this, this sort of worked except that I have the child.text data elements printed without any intervening spaces rec2_str = "|".join(["".join(repr(child.text)) for child in rec2.children]) print rec2_str gives #u'1000A1-100Non| where there should be spaces between number and text
its better than pyODBC in my opinion. pyODBC seemed to struggle with Oracle timestamps (converting them to a datetime object) whereas cx_Oracle handled that fine.
Nice! The ability to attach and inject code to an already running process is something I miss from [pudb](https://pypi.python.org/pypi/pudb)..
I thought you would be under some NDA?
You hate child abusers don't you? Why are you just blaming them for doing something they want to do? Not comparing the two, just pointing out the flaw in your logic.
pandas isn't (that) hard. the problems that require pandas are hard (mostly). grouping, applying functions to whatever axis, pivoting, etc are things that just need some practice. after a while, when you know what does what without having to use google every time, pandas won't seem so hard anymore.
kivy so cool
You're right, I didn't consider all the poor children hurt when op puts in some weekend hours.
Whoa, no, I would so be getting fired or even sued. Google has the rights to this thing, not me. What I meant is: I'd guess releasing something made on Google's dollar "as me" (with me having all of the rights to it), would be quite a bit more involved (but that's just guesswork).
Think of all the children's fathers who have to work on the weeked or they get "misses expectations" and eventually fired, because their loser co-workers with no hobbies and no life outside work sets the stacked ranking curve. Or all the people who have life outside work that feel like they have to put in more then 40 hours a week because their loser coworker has nothing better to do then work.
I thought it was funny.
Are you actually even being serious?
Well, it's on Google's github after all ...
It's looks like a useful project and I will keep it in mind. Thank you for your work. The only nitpick that I have is with the coding style. Is Google's style guide for Python so different from PEP8?
Unfortunately, [yes](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html). The coding style is also not python 3 compliant, as it forbids "unnecessary parens" around the arguments of the print statement. :(
Well, your code uses 2 spaces for indentation and the style guide says 4 spaces. Also, you use `CamelCase` for function names and I don't find any reference to that in the style guide.
Cool! If you're an intern I suppose you're going back to school soon? Are you going to be coming back to Google once that's done?
Yup, I'll spend at least two more years at university. I don't know if I'll come back yet, but I'm considering it (assuming I haven't completely embarrassed myself out of the hiring pool with this post). 
Since this is getting way more attention than expected: This is just an internship project that got open-sourced, it's not "Google's Pyringe" (as some guy on hacker news calls it).
Ah, for simple data transformations - Pandas is unnecessarily complex, and slower than toolkits more dedicated to that exact purpose. I'd use either: * [csvkit](http://csvkit.readthedocs.org/en/0.7.2/) * [datagristle](https://github.com/kenfar/DataGristle)
Python 3.0 and above uses the print function as opposed to the keyword print. Try print("Hello World") If you want to be able to do what you have tried, download and install the latest version of Python 2.x, which is currently Python 2.7.6
Like /u/ToweringTriumph said the version is mismatched with whatever you're following. If you are learning from a source that uses Python 2.x you'll want to download the [Python 2.7.6 installer](https://www.python.org/download/releases/2.7.6) instead.
&gt; Maybe because we're already invested too much in sql? I don't think that's quite it. My recommendation after building huge analytical environments for a very long time: * SQL - use it mainly for data access. * Python (vanilla) - use it mainly for data transformation. * Pandas, IPython, Excel, R, OLAP Tools, etc - use it mainly for data analysis. Of course, each of these tools can do more than just one job, and is sometimes the best tool for one of the other areas. But they'll all start having problems in those other areas and start forcing you to make weird decisions.
http://shop.oreilly.com/product/mobile/0636920023784.do Python for data analysis helped me learn basics of pandas and ipython 
You can learn R first. For me pandas is just like R ported to python.
Sorry, I'm new to python. Can you pleae (briefly) explain what the * does? Thank you
Not a bad thought, but... I really recommend that the OP install Anaconda instead. When I teach python, I usually have the people I'm working with use the IPython notebook, because the documentation and multi-line editing make experimentation more fluid. Anaconda: https://store.continuum.io/cshop/anaconda/ 5 minute video introduction to IPython: https://www.youtube.com/watch?v=H6dLGQw9yFQ
You should use a python 3 tutorial: http://docs.python.org/3/tutorial/
Three different ways to access data in a dataframe, and I was never sure which one would generate a list, an array, or a new dataframe, is one of my main complaints about R. On the other hand pandas lets you access either rows or columns of a dataframe with the same square brackets, so I'm not sure it's a huge improvement.
Guido has said he'll accept @, but I don't know about @@. The order of operations still needs to be decided on. Numpy is going to go away at some point. Blaze is the obvious replacement.
Hey, I'm taking a class now at Coursera for beginning Python programming. Week 0 is just wrapping up. You can take the class for free, or you can pay $49.00 and get a document from Rice University proving that you took the class and passed (or failed :). My 14 year old son and I are taking it now. https://class.coursera.org/interactivepython-004 
I found the indexing system a bit counter intuitive, so I made some notes to kick me into gear whenever I want to use it, here they are, give it a shot. It might do the trick: https://gist.github.com/why-not/4582705 
I recommend PyQt or PySide (although there's a bit of lack of development on the PySide lately and still some serious issues). I have a YouTube video tutorial series - search for YouTube channel Deusdies2
The IPython REPL is very nice.
It is a great tool if you want to try out code and document it in once swoop! Just yesterday I used it to implement 5 [Sequential Feature Selection Algorithms](http://nbviewer.ipython.org/github/rasbt/algorithms_in_ipython_notebooks/blob/master/ipython_nbs/sequential_selection_algorithms.ipynb?create=1)
Thank you for sharing!
Can you control the indentation a bit ? Eg, the defaults: {"a": {"b": 2, "d": 3} } But imho this would be better: { "a": { "b": 2, "d": 3 } } 
Google hires people like you all the time. I knew a guy at MIT who didnt even finish his Ph.D who got a job there. Just submit your resume and pass all their tech tests and they will put you to work.
Combine this with MMA and generate some cool MIDI files for sure!
I really like Lilypond!! Here's a link to MMA http://www.mellowood.ca/mma/ it is kind of like band-in-a-box sort of. Great job! 
The one thing I do like in Flask is the routing - much clearer than Django. That being said, the Bottle demo is more my speed (raw sql) and I'm dubious about the utility of WTF forms ... so in some respects I think Flask doesn't need to converge to Django - it's just what people do - for some reason. Kind of like the Werkzeug stuff too - guessing it takes care of a lot of the web side of things. Maybe I'm just a raw-sql head and I need to drop SQL Alchemy from my Flask projects - and then I'll be converging to Bottle + Werkzeug!
Another option is GTK+ via PyGObject (using gobject-introspection) http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html A fourth option is [wxPython](http://www.wxpython.org/) The important thing is to understand callbacks and the hierarchy / object model the library uses. It's fairly easy to transition between them all if you get those fundamentals down pat &amp; can then just use the doco to figure out what a button or text entry or whatever is called in library X. 
I wrote a short demo, it loads your items from a config file. It lets you remove the repeated if statements. You don't have to use csv, I used it since it's simple. You could add another config file for starting classes. Edit the config to modify what items they start with. import csv items_db = {} class Item(): # basic item stats def __init__(self, name="Stick", damage=2, damage_crit=4): self.name = name self.damage = damage self.damage_crit = damage_crit def __str__(self): return "Item(name={}, damage={}, crit={})".format(self.name, self.damage, self.damage_crit) def load_items_db(file): # read all items from external config with open(file) as f: reader = csv.reader(f) # grabs all items, and append to `items_db` dict. for item in reader: name, damage, crit = item items_db[name] = Item(name, damage, crit) if __name__ == "__main__": load_items_db("items_db.csv") print("loaded items:") for key, item in items_db.iteritems(): print(item) You can create the csv using excel, or a regular text editor. items_db.csv Item,Damage,Critical Stone Dagger,5,8 Adamantite dagger,57,69 
This book is a must for anyone using Pandas. The guy who wrote it, Wes, invented Pandas for the hedge fund AQR, then open sourced it!
Wow, I'm working to get away from Excel altogether. I want to do as much as I can in pandas dataframes. But I'm still new to this.
Yep, sorted(set(my_list)) is my solution, but it doesn't work if the elements of my_list aren't hashable... probably should mention that.
If your elements aren't hashable, then any equality test is going to be relatively inefficient. You might be better off converting the elements into a hashable form first.
Yep, that's my solution, but stable isn't important, as we want them sorted in the final state regardless. What is problematic is that set requires elements to be hashable, and so unhashable elements wouldn't work.
The only thing I can think of that's wrong with sorted(set(my_list)) is that it won't work if the elements aren't hashable. I don't see what you mean by your other idea though, seems like it would be a roundabout way of using set regardless. How would the binary tree solution work?
Tell me more please. I know something about embedded systems.
Nice, echoes more a PHP var_dump/print_r style.
it better have the ability to print query result...
That is the default :) The first example in the readme is the `pprint` module, which does it the disgusting way.
Which query result?
something along the lines of the following should work (untested) with open('log.txt', 'r') as f: for line in f: if 'Error' in line: print(line)
Might wanna look at [r/learnpython](http://www.reddit.com/r/learnpython)
any, like accepting ODBC cursor and print out the data grid. 
Cool!
Thanks!
Wow that website needs some love.
I think this is great for someone with a CS and stats background. I also think the NLTK book though is an in depth and very approachable guide to learning NLP: http://www.nltk.org/book/
If you are to make a whitelist of encodings for web scrapping of arbitrary websites, the definite list should be the [Encoding Standard](http://encoding.spec.whatwg.org/) and not a list of encodings you've personally chosen. The Encoding Standard reflects the list of encodings, exact algorithms and lookup tables supported by most modern browsers. Well, unfortunately not all those encodings have the direct Python counterpart, but I can say with a confidence that you need to include those encodings for CJK support: * `cp949` (aliased to `euc-kr` in the Encoding Standard) * `cp932` (aliased to `shift_jis`), `iso-2022-jp-ext` (aliased to `iso-2022-jp`) and `euc-jp` (oh, the Python implementation conveniently supports JIS X 0212 by default) * `gb18030` (aliased to `gbk`, it is a superset of `gbk` so why bother using it) and `hz` * `big5hkscs` (aliased to `big5`) UTF-7 is deprecated for the reason, you know, but all other encodings are supported for the reason too. Do not disrupt them.
by sticking to HTML 4 and no heavy JS it is surprisingly quick to load on my phone tho heh and no need to zoom the text but yeah maybe heh
Thanks for linking to that standard. I'm glad other people have thought about this. I still don't think I'd whitelist `iso-2022-jp` and `hz`, though; they're considerably different from other encodings, they're not supersets of ASCII, and they don't seem to be in common use. Most people aren't trying to make a web browser, after all. I don't think anyone is under an obligation to actively support an encoding just because WHATWG says so. I think if you're in a situation where you need to decode `hz`, you'll know. I've only encountered it when trying to decode the "20 Newsgroups" corpus from 1993, and that was just by deduction, because newsgroup text that's in `hz` isn't even marked.
Make sure you know how to use version control well! Having come from an academic background as well, there is a big jump to working on a team effectively and knowing how to use a big internal code base. 
&gt; I still don't think I'd whitelist `iso-2022-jp` and `hz`, though; they're considerably different from other encodings, they're not supersets of ASCII, and they don't seem to be in common use. While I'm not sure about Chinese, I have seen lots of Japanese pages with `iso-2022-jp` though its use in the newer pages is diminishing. &gt; Most people aren't trying to make a web browser, after all. I don't think anyone is under an obligation to actively support an encoding just because WHATWG says so. No, the Encoding Standard is a *snapshot* of common denominators for modern Web browsers, not a standard by committee (*cough* XHTML2 *cough*). The lookup table is [not up to date since the newer version is not supported](https://www.w3.org/Bugs/Public/show_bug.cgi?id=16947), the error handling (for U+FFFD) is [changed to match the current behavior](https://www.w3.org/Bugs/Public/show_bug.cgi?id=16771) and so on. It is always up to you to decide whether to support those encodings or not, but you at least have to be aware of the consequence (does not support some encodings in the Encoding Standard, does not support some web pages) when you don't support them.
Nice functionality but weird name.
Now if only it printed nested lists of lists...
If you're on Linux, grep works too (and would be faster/less work): grep -Ir Error &lt;path to log files&gt; If you're looking at a *single* log file, don't use `-r`. If you want to show additional lines around the matching line you can use something like `-C 5`. So it would end up looking something like this: grep -C 5 Error log.txt If you're not on Linux cygwin would work for this if you already have it installed. If not, well I hope this is useful some day at least.
Unfortunately that seems a little bit too specific... really the cursor should have a `repr`, since it's stateful and would be difficult for a library to implement correctly and sensibly.
Just glanced at the readme. I have a background in music theory and computer science. With that said, I really don't get why a note object has a scale method. I feel like a more appropriate thing to do would be to have a plain `scale(root, type)` function or a subclass of `list` or `tuple`. What is currently implemented just doesn't make sense to me. A note shouldn't be responsible for generating a scale. If anything, it should be the other way around.
I thought it was because of the common `from pprint import pprint as pp` or the fact that in pdb, pprint is the pp command. Shows what I know.
I'm on windows
And I suddenly think of Flask... :) http://denied.immersedcode.org
It gives off the impression that the software has been abandoned even though it has not.
These links might come have some stuff to help you out with matrix operations in numpy: http://wiki.scipy.org/NumPy_for_Matlab_Users and http://mathesaurus.sourceforge.net/matlab-numpy.html They're written for using matlab functions in numpy, but if you just use the descriptions it's a great reference for utilizing matrices in python. Been converting a lot of Matlab code (with lots of matrices) to Python and those have been super helpful for me
It could be cool if you could have settings, and be able to pass in your own preferred rules at initialization
I don't want others to do my homework I want someone to show me how to do a For Loop function while printing the same things listed in my past homework. What is not formatted correctly? I took it from Wing IDE so yeah. I will post in there as well thank you for letting me know about that.
If a general-purpose library like this starts chasing lots of the data formats out there, things will get ugly fast and maybe never get better. For your query result, you're better off writing a small wrapper that prepares the data and then calls pprintpp.
&gt; I don't want others to do my homework I want someone to show me how to do a For Loop function while printing the same things listed in my past homework. Well, I don't know if it's just me, but this definitely sounds like a assignment that builds on your previous homework: &gt; ...but I now have to change it into a range function in a for loop &gt; What is not formatted correctly? I took it from Wing IDE so yeah. Code has to be indented by four spaces to be correctly formatted.
&gt;pandas isn't (that) hard. the problems that require pandas are hard (mostly) I think this is the correct answer. I'll also add that much of what Pandas does is modeled after SQL (or relational algebra in general), so if you're not familiar with that the concepts and terminology might seem foreign. I know that was a big stumbling block for me.
It is an assignment that builds on the previous homework I just don't know how I would implement a for loop into it and was wondering if someone would show me how. Edited it to format it. Thanks for letting me know about that.
You know you have to use `range` and a for-loop. Read the documentation on how `range` works and you should be able to do it without any difficulties.
Yes, if you're serious about natural language processing with Python you should take advantage of the NLTK. Another interesting library to check out is [pattern](http://www.clips.ua.ac.be/pages/pattern).
Apart from the first statement, this could be easily ascii-artified, since you'd just use single-character tokens as required. Actually applying this method to a longer/more complex program would be more painful, though, since it takes so much space to do anything useful... and I'd need to actually ascii-artify it. You're welcome to give it a crack if you want, though ;-)
There was an obfu years back that did what you suggested, BTW -- see &lt;http://www.reddit.com/r/Python/comments/6vsak/ive_recently_tried_to_translate_some_perl_code/&gt; applies.
I'm under an obligation to support whatever damn encoding is in use on the pages my employer is being paid to scrape. Disabling support for multiple encodings because of a bug in a single decoder is just absurd. Hell, taking a look at his example all it ends up doing is moving the place an exception happens. Sure the ideal is that the exception happens at decode time, and this is what the patch does, but it doesn't segfault Python so it's cool. The list of encodings in the OP misses some important ones, and this will lead to exactly the same kind of issues that this UTF-7 issue would cause, namely a bug report that some input file is breaking the software and a maintenance programmer scratching their head trying to work out why UCS-2 support is explicitly disabled. 
Love how that standard tries to refer to a bunch of encodings as legacy. Wishful thinking in action.
I love you, thanks!
I'll need to read this carefully. Of note is that this notebook is by professor Peter Norvig
Since .Net is Microsoft, it makes sense that it is acceptable to link to something that is supported by the OS vendor and expected to be there. In the Linux world Python is installed by default typically so you can do things a little a different. This isn't a Python thing, a program written in Qt for example or many other environments would have to package all of it's own libraries as well to be distributed properly. If you can make the installation package all of the required libraries using pyinstaller, py2exe, nuitka, or something else, it all looks the same to the end user when installing.
Deobfuscated: [https://gist.github.com/pyos/75667c883d6a182cc07e](https://gist.github.com/pyos/75667c883d6a182cc07e)
With the typical size of RSA keys, using pow is going to be very slow. Rather use a square and multiply algorithm.
Can someone explain what is happening, sure looks concise! 
Published by Packt? No thanks.
Just to let you know that I'm working on a pull request at the moment: * I'm working on some refactoring so that you can test more easily! * I've improved the IO functions. * A lot of formatting (PEP-8 everywhere) * Writing tests against everything I change. I like the idea of working on this project, so I plan on sticking around.
Great, thank you!
Glad to see people are using asyncio for stuff. I am looking forward to aiohttp to get some love also. 
By square and multiply, do you mean the type where a^2b becomes a^2^b ? I'd be surprised if the provided implementation doesn't do that.
I was referring to what micropython was in that post not really my own project, but I wouldn't mind explaining my own project in more detail.
I would not trust a book published by them because they just ask random people to write books for them. See: http://johncleaver.com/blog/2013/04/03/packt-publishing-authorship/
You have a function that is really hard to reverse (as in, get the starting numbers if you have the result). You and a friend each agree on a shared number I'll call S. You and him each come up with a secret number called a and b, respectively. You send him f(S, a), and he sends you f(S, b). You take the number he sent you and apply a to it, and he applies b to the one you sent him. Now you have f(f(S, b), a) and he has f(f(S, a), b), which by the construction of the function are equal. Now you have the same number, but you never transmitted that number and you never transmitted anything that can easily be used to determine that number. You now have something you can use as a cryptography key.
Even if you're just using UTF-16, you can get some weirdness: &gt;&gt;&gt; s = '\uDC00\uD800' &gt;&gt;&gt; s.encode('utf-16') b'\xff\xfe\x00\xdc\x00\xd8' &gt;&gt;&gt; s.encode('utf-16').decode('utf-16') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeDecodeError: 'utf16' codec can't decode bytes in position 2-3: illegal encoding IMHO it should have failed on the `.encode()`; U+D800 through U+DFFF are not legal Unicode characters to begin with and the Unicode consortium has explicitly banned their allocation. Yet Python will cheerfully emit illegal Unicode containing them, and in UTF-16, this results in an invalid surrogate pair. EDIT: This has been fixed in 3.4. You get a `UnicodeEncodeError` on the `.encode()`.
Oops, why didn't I do that! def dh_keypair(g, p): """ return keypair (a_sk, a_pk=(A, g, p)) """ a = random.SystemRandom().randint(1, p-2) A = pow(g, a, p) * Use an established prime number (p) and group generator (g) for D-H * Generate a secret key: a random number between 1 and p-2 * Generate your public key: Compute *A = g^a (mod p)* . def dh_shared_secret(a_sk, b_pk): """ return shared secret """ (B, g, p) = b_pk return pow(B, a_sk, p) * Take your own secret key `a` and the partner's public key `B` * Generate the shared secret *s = B^a (mod p)* * Your partner computes *s = A^b (mod p)*, and the crux is of course that both of these result in the same shared secret: *s = A^b = (g^a )^b = B^a = (g^b )^a = g^ab (mod p)* just fun to learn about it this way since python has the small pieces needed included (modular exponentiation in `pow` and arbitrary size integers).. compared to other languages where you have to find a number library just to get started (that's the explanation for my joy) 
Pet Peeve Moment: Why not use full variable names? I have no idea what a g is, nor what a p is. PEP8 specifies this as a best practice. The code should be readable and self documenting. It's not much more work and is infinity better for long term maintenance, or in this case, for others to understand what the code is supposed to do. It's not just the OP's example either. This was just the straw/camel. Even the official docs are full of single letter variable names. /rant
I think `pow(a,b,c)` [already does that (implementation, see especially lines 3945+)](http://hg.python.org/cpython/file/8017e8df6a30/Objects/longobject.c#l3811)
You should indent using spaces. Every text editor worth it's salt will convert tabs to spaces. How would you post tab stops in a web comment? Just for the ability to store code snippets alone you should be using spaces.
Actually, this is pretty common in crypto. The variables may derive from names like "prime", "base", or "shared key", but they're really best understood as abstract values. This also matches how they're described in the literature.
You should support aliases. UCS-2 is just an obsolete version of UTF-16. I should point out that I'm not saying you have to use my whitelist, I just think you should have a whitelist. With a blacklist, you might forget about some sort of hacky zip codec (although Python 3 at least changes the way you access these in a way that happens to make it safer). Of course encodings that are in your code's requirements should go on the list. It kind of sounds, though, like you consider your requirement to be "all encodings", and that's not a realistic requirement. Are you under an obligation to support popular encodings that Python doesn't decode, like CESU-8? Where do you stop? I think there will always be some data you have to give up on. 
They're using insufficiently descriptive variables, I can tell you that much.
I took this course and really enjoyed it. A great introduction to python and object oriented programming.
The correctness of the code depends on its adherence to the mathematical formulas. Why make it more difficult by changing the names of the variables between the two?
FYI, a bit from the Python docs: &gt; class random.SystemRandom([seed]) &gt; &gt; Class that uses the os.urandom() function for generating random numbers from sources provided by the operating system. Not available on all systems. Two points of interest here. First, **not available on all systems**. That should be pretty self-explanatory. The second is that it uses **os.urandom**. This is os-specific, and as far as randomness goes, /dev/urandom is inferior to /dev/random on most (all?) Unices [edit: looks like I'm wrong. See below]. /dev/urandom is designed to provide the best randomness it can *without ever blocking*. That means that if its entropy pool runs out, it doesn't care, it'll just spit out whatever it can. /dev/random, on the other hand, will block until it can replenish its pool, so it will always return high-quality randomness. There is some debate over whether this *really* matters in practice, or just in theory. When it comes to crypto, you should probably err on the side of theory. This is actually one case where I think Python needs a lot of work. It does very little to insulate the programmer from platform-specific intricacies and instead just ports over all the confusing parts from multiple platforms. It makes it easy to do things wrong.
&gt;As for what if a new person joins the team... Well, this is crypto. If they don't know what these variables are then they really shouldn't be allowed to touch this code. you could say this for anything... "well this accounting" &lt;- billions of dollars at stake. "well this is engineering" &lt;- lives could be at stake etc. 
What would you rather? Remembering two different names instead of only one?
… and how poorly that particular aspect has been documented :|
So confused to see something about April fools on the morning of the 31st.
(♡ᵉ̷͈ัॢωᵉ̷͈ัॢ )
I took this course, you may struggle a bit but stick with it!
I have to agree with Workaphobia: it is simply convention and makes the code far quicker to read than longer, non-convention names where I have to first translate in my head which part of the formulate they are standing for. For somebody already aquainted with crypto, these are the reasonably descriptive names, even if it feels paradoxical. Someone not aquainted with crypto should not mess with such code anyways....
I took it. I have Java/.Net/etc./etc. under my belt already and I found it to be pretty interesting. My only complaint was CodeSkultor in that it doesn't translate to the real world in the sense that it's not an IDE that you'll uses again. So I would recommend adding Python to Eclipse or Visual Studio and doing the lessons in those IDEs instead and then copy it into CodeSkulptor so that you are also leaning Python in a common IDE at the same time and that will be helpful after the class is over. 
I actually meant an *executed* cursor, which points to everything the wrapper needs to get column names and data rows or if that's too much just accept a list of lists/tuples &gt; you're better off writing a small wrapper yes that what I did with [prettytable](http://code.google.com/p/prettytable/)
what's it like ? human instructor ?
I agree and disagree. In this case, 'a', 'b', and 'c', are all the same kind of thing. What we've done is reduce the more formal: def solve(coefficient_a, coefficient_b, coefficient_c) ... to eliminate the redundant information: def solve(a, b, c) *In this case,* it both improves readability and looks more like the source material. However, in the case of cryptography, you're not always passing to keys or two certs to the same function for processing. You almost always have two distinct kinds of things, so the names should be similarly distinct. Also, it's not uncommon for programmers learning a given codebase to have a background in algebra or calculus. It *is* unusual to have a similarly strong backround in crypto, hence the need for avoiding single-letter arguments.
hi i am not the author of the lib i just found it liked it shared it, i was just thinking the same with you, now i have it outside of wsgi. probably you should start github issue. I guess it must be in the plans but asyncio is still new :)
some of us were taught using "normalized form" so we will use *x^2 + px + q = 0* instead!
[about urandom: this guy explains much better than I could -- I prefer to err on the side that the cryptographers fall on](http://www.2uo.de/myths-about-urandom/)
&gt; Note will have a __sub__() method that takes a Note and returns an Interval? It'd be great, I will look into coding that whenever I get the time. Thank you!
No, those two numbers aren't equal. For r = a**b % n (taken from http://eli.thegreenplace.net/2009/03/28/efficient-modular-exponentiation-algorithms/) : def modexp_rl(a, b, n): r = 1 while 1: if b % 2 == 1: r = r * a % n b /= 2 if b == 0: break a = a * a % n return r Although this is a naive implementation and it susceptible to side channel attacks. 
I'm in it right now! 
We can all agree that "coefficient_a" is a ridiculous name for a variable. It's too long; it obscures the formulas it appears in. The fact that "a" and "b" are of the same kind is not important. What's important is that they directly correspond to the quadratic formula. You could use "p", "q", and "r", and those would be much worse names. And I reiterate: A programmer without a strong background in crypto has no business editing production crypto code. You extended that by analogy to accounting and engineering. Okay. Let's say that in any piece of critical software, we should *always* be careful and use names most likely to be understood by experts in the field.
Sure, but that's a different algorithm, `solve(p, q)`.
This is the norm for any field with a mathematical background, so get used to it. These are probably the variable names from the original paper.
I signed up for it, but find it is too much like school. I learn differently, often on my own. I use various websites and YouTube to learn. I find that YouTube is great. Pause, rewind, copy script, learn. One of the best Python 2.7 tutorials on YouTube is by Derek Banas. www.youtube.com/user/derekbanas‎ He goes through stuff rapidly, giving the watcher salient Python skills and understanding. He also does a fantastic job of linking ethereal Python concepts together. There are others. But school is tough for me.
I think CodeSkultor killed it for me. I use Eclipse, and want to develop in one, standard IDE.
I will bet you dollars to donuts that somewhere in that paper it is specified that "a is a reference to ????", while "A is a reference to ???". That "p" is an integer (most likely a prime, but that would be a guess). In a paper those should be abstracted out for clarity. In code, it's the exact opposite. It's not describing the process, it's implementing it in a manner that will need to be updated and maintained in the future. Also the paper needs to be short and concise. A computer program loses very little and gains a lot from having descriptive variable names. If non-crypto experts aren't supposed to use and learn from this code than why post it in /r/python with a headline specifically stating "learning crypto"? What exactly am I learning from this? That I should go out and read a bunch of white papers, then come back and marvel over how amazing this code snippet is. Or could it just use nice concise variables such as "prime", "shared_key" or "pubic_key". Note: I want to reiterate that I'm not attacking OP over his contribution. This is a nice piece of information. More of the general case of using descriptive variables when attempting to teach something, since the process of teaching starts with the assumption that the audience doesn't know the subject matter.
It is indeed free, unless you want a 'Certificate', for which you'll have to pay 59USD if the price hasn't changed.
I'm totally the opposite. I can't stand looking at video lectures, I just start to think of something else, but give me an assignment and a deadline and I'm all over it. It is very interesting that everyone learns so differently yet all schools treat every student in the same way.
I took this class and enjoyed it. I found [this online book](http://interactivepython.org/courselib/static/pythonds/index.html) to be a good next step. Goes much more into classes and other stuff not covered in the course, while also teaching basic algorithms and data structures. Beyond this, there are also topics like generators and metaclasses, etc. that you should look up on your own.
It's a series of videos and interaction on the forums with TAs and other students. They made a pretty cool web interpreter/GUI so you do everything online without installing anything locally.
Signed up
I've read a couple of books from Packt and I had a good experience. Expert Python Programming, Mastering Web Applications with AngularJS, Data Visualization in Python, they were all great books that I'd recommend to everyone interested. It's no O'Reilly but it's still good.
I was not saying that they are not allowed to do so, to widen their knowledge... but it is generally a bad idea to write own crypto ;) 
Yes, the implementation behind the scenes here should be written by experts. However this is supposed to be abstracted out for regular programers to use. For example, a 200 person company with three developers will not have a crypto expert on staff. Still they may want an automated process to secure some documents for a flash drive that will be sent out to a remote location. In a few years the original dev may not be with the company and someone new has to manage this code. That code should be easily readable. If this was posted in /r/netsec then I would have no complaints. But it's not. The audience are not crypto experts that know what each of those variables mean.
&gt;That I should go out and read a bunch of white papers, then come back and marvel over how amazing this code snippet is. Yes! I wouldn't call them "white" papers, but other than that I'd say you're pretty spot on. Anybody who is "updating and maintaining" this code has read the papers or at the very least attended lectures with slides directly based on those papers.
I disagree. Lots of small companies have need for simple cryptography without employing crypto experts. I'm a web dev. I implement tons of security features such as CSRF validation and whatnot. But I certainly am not a security expert. Experts code the behind the scenes stuff and I implement it from there. Same in this case. People who read the papers are the ones who wrote pycrypto. However, you shouldn't have to be a security expert to implement the library. If that were the case nothing would ever get done because every dev would have to become an expert in every field that they ever write code for.
I am taking the course free, but I am seriously considering the signature track. It cost is 49USD currently and there are two weeks four days left to register for the signature track. The first graded assignment for the class will be due next Friday / Saturday depending on your location in the world.
Check https://pypi.python.org/pypi/JsonWeb/0.8 for a cleaner solution. You can encode and decode your objects as well.
I took this course as well, and recomend it, I will be taking the follow up course in 3 months 
I had not seen this. Thanks, I've bookmarked it now.
I am genuinely concerned for your clients.
Is the 'certificate' worth it? 
Use a shared password for the generator and you get EKE (Encrypted Key Exchange). g = 2 * int(hashlib.sha1('password').hexdigest(), 16) If the two sides agree on the password a shared secret is generated that may be used for mutual authentication or as an encryption key. Unlike a hash based challenge-response authentication algorithm this is not susceptible to offline password guessing attacks. The "2 *" avoids a certain mathematical weakness.
thanks. just enrolled!
Taking the one starting in June. Python!!!! :)
I am in the middle of writing a library to access the transit tracker for Portland, Oregon. It's been a pleasure working with asyncio + aiohttp. More docs would be good, though.
Two solutions for non-hashable items, both with caveats: The first one is pretty hacky and not stable. The idea is to use pickle.dumps as an ad-hoc hash function. Works for your example and probably many cases, but because it uses pickle's notion of equality and not the object's ``__eq__``, it fails in the general case of objects with an arbitrary equality definition. &gt;&gt;&gt;my_list = [['a'], ['a'], ['b'], ['c']] &gt;&gt;&gt;list(map(pickle.loads, set(map(pickle.dumps, my_list)))) [['b'], ['a'], ['c']] The second one is stable and works for all items that implement ``__eq__``, but it has quadratic runtime: from functools import reduce # not necessary in Python 2.x def add_if_not_in(items, to_add): if any(item == to_add for item in items): return items return items + [to_add] def unique(items): return list(reduce( lambda dones, to_add: add_if_not_in(dones, to_add), items, [])) l = [1, ['a'], 4, 3, 4, [1, 2, 3], ['a', [1]], ['a'], [1, 2, 3], 1, 7] print(unique(l)) # [1, ['a'], 4, 3, [1, 2, 3], ['a', [1]], 7]
Context: http://python.6.x6.nabble.com/quot-A-simple-printer-of-nested-lists-quot-td1972316.html
It was worth it to me simply as a motivational tool. Once I put 50 bucks down I knew I'd stick with it just to get my money's worth. The certificate has no academic value. Might impress your employer if you are in a non-technical field (marketing, etc.)
Go ahead and do that. You can get a lib to emulate the codeskulptor GUI lib locally! I can look the name up for you if you like, but not for a couple of hours. It's not terribly difficult to find though. :) 
I took it too and am totally pumped that they are finally announcing follow up courses! https://www.coursera.org/specialization/fundamentalscomputing/9?utm_medium=listingPage If they can make the algorithm courses as fun as game programming, I will be duly impressed!
Why not go the whole way and name it "pprintnirpp"? ^^^SCNR
I think this is an awful solution. For one, it can only be applied on objects that are not inherently iterable. (You can't make a list subtype if all it ever returns is a serialized version of itself) Next, it can't be applied to non-iterable objects either, not without changing the semantics of your objects. (It makes them iterables, after all) If you're going to define a new method for all of your classes anyway, why not just do what you ought to have done in the first place and add a `serialize` method or something similar and do what you're currently doing in `__iter__`? That way you get the desired behavior without abusing a magic method.
I have an idea for a RESTful service I want to build at work and the lack of docs and the freshness around the libraries cause me to want to wait a bit. I am thinking of using flask but just for its routing and request/response objects. Since those are the only two bits of flask I want to borrow however I did think that writing my own minimal framework on aiohttp and borrowing from another routing library and possibly webobj. I am not certain though that we will need async io at this point but it seems like it could be useful under load. 
What are the real benefits of a coursera certificate though?
You *can* use REfO for want you were thinking it would be cool. That's exactly what it was made for :) You could use it, for example, to match a network dump for suspicious sequences of packages where "network packages" are scrapy objects. I've used it to match natural language queries in Quepy, example: https://github.com/machinalis/quepy/blob/master/examples/freebase/freebase/basic.py#L48 Project demo: http://quepy.machinalis.com/ Disclaimer: I'm the author :)
I would use PyCharm and avoid Visual Studio. I haven't used Visual Studio for development, but haven't ran into any problems using anything else for Python.
Which could be true as well. If you aren't familiar with the problem domain then you'll be doing far more learning initially than editing any code.
In practice, not getting DoSed by /dev/random pool depletion is a far more serious concern for crypto implementations. The entropy estimation it tries to make use of is also flawed at best.
Poor choice of words; I meant to say more complete solution.
Well then, consider this the "implementation behind the scenes" and very little else. If you don't ever wish to study crypto in any great detail then this code short should never mean a great deal to you, which is fine.
Is it meant to teach? I thought it was just a bit of show and tell, although considering how specialised it is its not of great value to everyone. 
&gt; this is Python where one of the goals is readability. I've already conceded this point partly, but now I noticed something: This is **not** Python. This is *me learning about cryptography*, using Python. Sometimes when working with computers have to make sure you have it clear who is the operator and who is the tool.
I'm not sure of that. Perhaps it is my own bias. When I created http://ProgramArcadeGames.com I put in tons of example code for people that learn that way, video for people that learn that way, text for people that learn that way, worksheets for people that learn that way, and labs for people that like that. I tried hard to cover lots of learning styles. I know I'm not the only instructor like that.
Well the post name says: "learning crypto"
I believe that's what OP is referring to themselves as doing; not what everyone else should be.
what you are looking for is called linux :)
I actually like how Coursera provides a wiki of what's covered in the videos - I'm not a video guy either, I've always been able to pick up more from simply reading and doing labs/assignments.
I agree; I don't think hijacking \_\_iter__ is the way to go; I'd prefer "serialize". However, here's a weird thought; what about making your own magic method? I'm thinking a top level function named "serialize" like "iter" or "getattr", and then any relevant class can implement \_\_serialize__. This is a cross-cutting concern, and is kind of "meta" to the classes expected behavior, so it'd be nice to mark it as such. But then, perhaps this is too wonky. def serialize(serializable): serializable.__serialize__() class MyClass(object): def __serialize__(self): return dict("field"= self.field, "field2"=self.field2, ...) my_obj = MyClass() print serialize(my_obj)
&gt; This is **not** Python. Yeeesss it is. If it was only you learning about cryptography using a tool, you wouldn't have posted it referencing an iconic Python phrase about another awesome facet of the language. I'll stop now because I'm just starting to be a dick at this point. To be fair, the rest of it was mostly awesome.
The benefits of a certificate in real life? No idea. I was really interested in the Signature Track thing, but it ran super bad on my machine so I just passed. YMMV.
It's posted in /r/Python Also, as a note, I'm a fan of the post. This content is awesome. 
well its up to you take your time. i always considered linux to be a better development enviroment. well my graphics card is a bit broke, my wireless card too but it doesnt matter to me
I dropped out of this course last time, but I still made it to week 3. Thanks for the reminder, I'll sing up for it again. 
Brilliant! After consideration, I do agree that it's nasty to hijack the `__iter__` method. This solution seems very nice; I'll explore it some more.
I haven't read any of your books, but the fact that you're so passionate about helping other people get into Python/programming is absolutely inspiring. I also admire the fact that you're donating all proceeds from your ciphers book to the EFF. You're an awesome person Al. Well done.
Python + VC + compiling is a royal pain. I'm playing with a win7 64bit VM with Python 3.4 (64 bit binary from python.org) and VS2012 Express and I can install Pillow from pip fine. You just have to make sure that you run your pip install from within VS' "x64 Cross Tools Command Prompt"
Aww, thanks! :D
Why not use python's built-in serialization library, [pickle](https://docs.python.org/2/library/pickle.html)? Or using the methods it defines with a custom serialization format?
Yes, it is a joke. This is actually the issue that made me install Ubuntu (I dual-booted Ubuntu and Windows), because I use mathematical libraries like numpy and sympy for my development. To be 100% honest, if you often need libs with C-extensions I *highly* recommend installing Ubuntu. It's a bit extreme I know, but that's my suggestion after having gone through the exact same thing. Ubuntu is not without its pains though - don't believe everyone that says or implies that Linux beats Windows for development in every way. Most ways yes, but not every way.
I have played with pickle a little bit. For this project, I'm building an API that speaks JSON. This does give me an interesting idea though! I wonder if I could try interpreting pickled objects in javascript on the client?
Thanks for informing us about this! I want to learn how to do what you are telling us would be best. For those of us just starting programming, and getting what you are saying, how would you do a lesson in IDLE and then copy it into CodeSkulptor, please? Thank you!
Surely if you were in the business of crypto you'd be familiar with the mathematical letter conventions and it would in fact make it easier to read.
I'm the same way...I end up having to watch videos 2 or 3 times because I zone out. I managed to get through most of this course because I thought it was one of the more useful ones that I've tried - but I actually sped up the videos to go (I think) 1.5x the normal speed. Basically I sped it up until right before it would have distorted the voices too much to understand. 
I am also taking the course. I'm somewhat familiar with the language already, but thought it a good idea to get the 101 down just be sure I'm ready for future steps.
Install Ubuntu on a VM locally.
I'm planning to take the whole specialization. Looks really well put together. Really looking forward to the algorithmic thinking class.
I prefer reading to watching, too. Having them both there, plus assignments, really reinforces the material for me.
I'm generally against pickle, for security's sake. I prefer safe, controlled de|serialization.
I am taking the course (2nd week now). So far, I am not opinionated on the matter, but seems promising.
The same as any other certificate... it's just another thing to add to your CV. So its value is in the eye of the beholder... whichever potential employer is reading your CV.
Coursera needs to make money in order to continue to publish and host great courses. We all benefit from the few folks who pay for a certificate. The drawback of *not* paying for a certificate is that we could lose Coursera if they don't make money.
I stand corrected!
That's awesome. Learning new stuff is awesome.
Getting a "Channel does not exist" on that YouTube channel. Is that the correct url?
&gt; return dict("field"= self.field, "field2"=self.field2, ...) Since this solution has been repeated twice now without verification, I feel obligated to point out that quoting the argument names is a SyntaxError.
Thanks! I don't think /u/AustinCogriBart's code is meant to be drop-in ready. I haven't had time to test it but there should be a disclaimer on my blog.
It's able to execute arbitrary code, if I recall correctly.
One I rember needing to an isinstance(foo,int) and it was letting booleans through. Another was doing an if foo: that was intended to be using for booleans but because two variables got confused from a function with multiple returns it was always getting a number instead of the intended boolean but no error was thrown.
And you'd better have a damn comment with something along the lines of `// solves x^2 + px + q = 0` in there.
Thanks. That makes a little more sense. I am still of the opinion that python should attempt to be as explicit and easy to understand as possible which this still seems to violate. But at least now it seems more consistent. 
I don't understand why that would be useful.
Pickle can only pickle certain objects. If you want general serialization, you have to define the steps yourself. (If you really want to use pickle, you can. I don't remember what you have to define to make pickle work in general.)
I accept the argument as wonky; I wasn't convinced it was a good idea. My thought was that it was a cross-cutting concern, and it should be recognizable as something distinct. But it's probably over-engineering.
Sounds great! Email me so I add you to my spreadsheet. al@inventwithpython.com
There is a fork of Flask that uses asyncio instead of one of the other methods. Check it out!
I have, the dev says it's only a hack and really ugly. 
Sent you an email. :)
Awesome, thanks!
Thank you!