I am kinda biased but try http://shoebot.net a drawing bot (close cousin of http://nodebox.net ), you use python to draw stuff. A few lines of code, and you can load dynamic data from a data source (or web) and draw it on a svg or pdf. Disclaimer: I'm part of the devell team of Shoebot
Start working through the PythonChallenge via class participation. It'll hopefully get them hooked on it, and they'll learn a bunch more if they try to complete it on their own later.
Great question. I always thought that refactoring in Python is a huge PITA. I'd love to learn that I've just been doing it wrong...
oh yes: [subprocess](http://docs.python.org/library/subprocess.html), and [example](http://magazine.redhat.com/2008/02/07/python-for-bash-scripters-a-well-kept-secret/).
I rotate my 24's as well. Taller is better than wider. Viva la 80 char limit!
Spyder is a decent enough IDE.Give it a shot.
&gt; Why do people insist on sticking to the 80-char limit? Most 80+ character lines look like shit?
things I think are cool: * sockets! connect to raw network devices and either run your own protocol or implement a RFC'd protocol (IRC is fairly simple). I also used a socket device to hook into a Quake3 server (could be TF2) and use it as a console. * HTTP parsing. you can create large datasets from pretty much anything on the web. find some APIs, turn XML into objects and manipulate them. you can even do a lot of this "live" just using `ipython`. the world is made of data and there's a lot of ways the create and manipulate it in Python. * mathematics and science. I've heard python has good libraries for math and science. science is meaningless without statistics, so if anyone is planning on continuing in physics/chemistry/biology, Python might be a useful tool in analyzing data. for students continuing in compsci, I used `itertools.permutations()` to check my discrete math homework O_o * not directly programming, but I'm really excited about Minecraft circuits. I like the ability to go play with the physical blocks of computing (AND/OR/NOT) after learning the formal mathematics of them.
You mean like "pprint"?
I used to be a staunch supporter of spaces, but then thought about it and realised that tabs just make so much more damn sense by separating content from presentation. I still code with spaces for compatibility, but I'm always considering switching at some point.
Two reasons to stick with &lt; 80 or maybe even less. 1/ It's easier to scan downwards when the lines are shorter, that's why newspapers have narrow columns. 2/ Wide columns are the exception not the norm. So if you chose 240 for example, only a small percentage of you code is greater then 80 c. So you end up having a lot of white space on your screen. 
That's the only part of PEP-8 that I loathe. I do not follow it, nor will I ever, no matter how much other developers harangue me about it. What's more work: * making an editor that allows you to configure the size of a tab character * or making an editor that allows you to press the tab key and get a configurable number of spaces, which then have to be handled through some kind of magic if you want to backspace or cursor across them to a different indent level without pressing the key a whole bunch of times. Almost all text editors do the first thing. Problem solved. Few editors do the latter, and even fewer do it satisfactorily. That limits my choices significantly. I'll use tabs and the editor(s) of my choice, thank you. Also, tabs give *me* the choice of how to view any code I come across. With spaces, what if I prefer 2-space indents and some other developer uses 4 or even 8-space indents. Well, I can use some tool to convert their indents I guess, but it will constantly be going back and forth as we both check in code. It's basically just a "fuck you" "no, fuck you" situation. With tabs, I can choose to display it as 2, and they can choose to display it as 100 if they want, and we can both share and work on the same codebase without any confusion or difficulty.
Classes are also objects.
So what do you do when you have a variable that points to a class? Face it, what you're describing is a rather limited type of static typing, but with no language support, so you get none of the benefits. If you want some static typing (which is fine, IMO) then use a language that supports it, like Ruby does with @ and @@.
They are all the fucking same thing.. Maybe this is why: "This module is an example module from "Head First Python" by Paul Barry and is to be published by O'Reilly Media in late 2010."
1. Markov chains 2. Robotics
Ah, that explains it!
Well, it's a game library for an interpreted language. Of course the speed isn't going to be up to par with anything that's industry standard. However, I'm going to call you out on this: &gt; It teaches really bad habits; it is missing very basic features. What terrible habits does it teach? And what basic features are missing?
The column limit is not due to 18th century terminals. It's due to readability. Narrow lines are readable because the eye isn't a perfect line-feeder. The shorter the line-feed distance, the better. It's also why newspapers and magazines split their text into columns much narrower than 80 characters each.
 [student.get_mindblow() for student in students if student.is_interested()]
You try to have your eye follow up to 20" line feeds. That's what you get by using a full 24" monitor for a single text file. Compare that line feed to the one found in a magazine nearby. Which one is easier to read?
Web crawler and search engine. You're not going to rival Google, but you can string together a bunch of common libraries and put together something halfway decent. urllib2 or pycurl for fetching pages. BeautifulSoup to grab the links of new pages to fetch. BeautifulSoup + split() to tokenize the page into words. Dictionaries for inverted indexes. Django for the web UI. Another possibility, if you've got an online school directory: emulate the scene from The Social Network where Zuck downloads all the pictures from the different houses and creates a webapp that lets you rate girls against each other. This should take no more than a weekend or so...a day maybe to grab &amp; parse the pages, and a day to write a webapp that lets you rate them. It'll probably get you fired, but your students will idolize you. (And then you can go start a social network, move to California, and make a billion bucks.)
i miss that pep8 says nothing about braces though :{
actually, the name of pdb++ does not come directly from the (non existing) ++ operator, as C++ does for C. In pypy, we have a pdb+ that adds some useful commands for our translator toolchain: http://codespeak.net/svn/pypy/trunk/pypy/translator/tool/pdbplus.py So, when I started the project, the ++ came quite naturally.
This looks like someone wanted to rewrite Django. But I don't get the sense that they know what they are doing.
It's not hackish at all, it makes it all much easier to read, then when you see the variable actually being used, you know it's internal, but if you really want to use the internal variable, so be it.
I wouldn't say newspapers column-widths is a particular good analogy - code is usually read very differently to text such as news/articles - with code, the overall structure is far more important than reading every line from start to end. This is why I dislike the 80 character limit - forcing a line of code over multiple lines just to satisfy a slightly-arbitrary limit often obscures the structure and flow of a function However, 80 characters is a perfectly reasonable guideline - in many cases long lines can be rewritten in a much clearer manner - i.e if a line is 90 characters, consider if the line merits being that long - if so, carry on. If not, don't just find the first space before 79 chars and add a backslash-and-newline
django does it the Right Way(TM) (IMHO) with `shortcuts` module. some uninspired thinking leads to: from logging.shortcuts import syslog log = syslog('/dev/log') log.warning('Watch out!')
what do they know already? I would say the simplicity of doing stuff compared to alot of other languages would blow minds. the only problem if they haven't been exposed to other languages. for example: f = open(csv,"r") stuff = csv.reader(f,delimiter=",",quotechars='"') for x in stuff: print x something as simple as cycling through a csv file in so little lines is freaking awesome imo.
I've had this thought myself, but you run into problems with tabs when you start aligning code, which at least you'll usually do with wrapped lines.
That last paren always gets to me in multi-line function calls, list declarations, etc. I want it on a line of its own of course so I can re-arrange the elements. But un-indenting it seems to defeat the purpose of python's method of indentation. I tend to do this: blah = moo(whatever, "some string", oh_hey, ) Though I'm not really sure what I think of that either.
The problem is alignment. *isari* posted [this](http://www.emacswiki.org/emacs/SmartTabs) solution but it seems more complex than either of yours.
I (and a lot of others) like having a bunch of windows open and splitting vertically. Going beyond 80 ruins that for me. I stick to under 80 almost always in most languages. But with something like HTML it's not practical.
I prefer 2 space indents too. But I'm a ruby guy at heart, so it makes sense to me. I still always code python with 4 space indents though. (never 3 on anything, ever! yuck. powers of 2 plz.)
Yep, this is exactly the reason why I keep everything under 80 characters. 
Well I see it as being in line with the statement, and that is the whole equals thing. I find looks weirdly awkward in the way you do it. In PHP I'd do something like: $sth = $this-&gt;pdo-&gt;prepare(" INSERT INTO sessions ( sid, tok, remote_addr, data, latest ) VALUES ( :sid, :tok, :remote_addr, :data, :latest ) "); $current = new \DateTime(); $ok = $sth-&gt;execute(array( ":sid" =&gt; $actual['sid'], ":tok" =&gt; $actual['tok'], ":remote_addr" =&gt; $this-&gt;remote_addr, ":data" =&gt; json_encode($this-&gt;data), ":latest" =&gt; $current-&gt;Format('r') )); I find those two parenthesis look neat. 
You probably need to install [SIP](http://www.riverbankcomputing.com/software/sip/intro): &gt; SIP is a tool that makes it very easy to create Python bindings for C and C++ libraries. It was originally developed to create PyQt, the Python bindings for the Qt toolkit, but can be used to create bindings for any C or C++ library. 
Tabs make sense in theory - they're clearly the better solution. The problem is code generated by people almost invariably ends up being completely fucked up and not working with variable width tabs.
For web crawling, take a look into [scrapy](http://scrapy.org/).
We dont even follow pep-08 completely for my company's our python code. We have different convention to use first-word-low-others-title-Case for method names, not lower_seperated_by_underscores. (and then my peers, keep introducing their own coding style o_0) For personal projects, I however, do follow pep-08, even for languages other than python.
FretsOnFire is open-source and coded entirely in Python, that might get a few people thinking.
Tabs only make sense if you don't break your lines. Otherwise, your line break locations will look really weird to someone who uses different tab sizes. 
This is not python's fault. Ninja-ide is not in the cheeseshop and doesn't have the 'install_requires' list defined in setup.py. I do think that it should exist (let me know if it already does!) a module/class resolver service where you'd input 'sipconfig' and it'd list the packages that provide it, but python shouldn't try to fix poorly written setup instructions.
I'm pretty sure it says you need to install SIP in the PyQt documentation. If not there, there have been numerous tutorials that do. Not that it isn't a pain, but still, I know it's documented. 
Whatever amount of monitors you have, you're going to fit many more files in them if you use less width for each.
As code is indeed different from prose, code gets the luxurious 80 columns. Newspaper text is rarely over 50 columns.
have an upvote and an orangered. anyway, naming things is one of the two hard problems in programming, so i'll cut you some slack. sometimes I call my dad(74) when i have something arbitrary but hugely important - he has a way of wandering just on the edge of reason and making-shit-up that leads to some great names.
Yes, it's easier to be consistent across all the languages you program in, instead of changing the style for each one. Especially if you need to use multiple languages on a daily basis. In the end the important thing is that the style isn't changed within a project, not that a specific or "recommended" style is used.
You can read the instructions of How to Install NINJA-IDE in a Mac: http://code.google.com/p/ninja-ide/wiki/MacOSX_Install It's kind of annoying to install Qt in a Mac, but that guide explain it all. Regards!
 &gt;&gt;&gt; from __future__ import braces File "&lt;stdin&gt;", line 1 SyntaxError: not a chance 
Some basic AI with vector behavior. Predators and prey AI for instance. You could also create a flock or herd AI. The easiest selling point would probably showing them that they can do their homework with it. :P
How about EVE Online? I think the ["EVE Never Fades"](http://www.eveonline.com/download/videos/) trailer remains the coolest one, even though it's five years old. And for the record, both the client and the server are written in Stackless Python.
The mayavi 3d plotting demos are really slick, and just a few lines of code because of the matlab-type array manipulation you get from numpy. http://code.enthought.com/projects/mayavi/docs/development/html/mayavi/mlab.html Everything you see on this page is a 3d scene you can spin around and zoom in on. Demos of crawling and scraping data from a website (reddit headlines?) are nice too.
Another commenter posted a good solution: Tabs to indent and spaces to align.
The only aspect of PEP-8 I've never been fully convinced of is the indentation rules for breaking apart long lines. Rather than this (example from PEP-8): class Rectangle(Blob): def __init__(self, width, height, color='black', emphasis=None, highlight=0): if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong' or highlight &gt; 100): raise ValueError("sorry, you lose") if width == 0 and height == 0 and (color == 'red' or emphasis is None): raise ValueError("I don't think so -- values are %s, %s" % (width, height)) Blob.__init__(self, width, height, color, emphasis, highlight) I've always envisioned something more like this: class Rectangle(Blob): def __init__( self, width, height, color='black', emphasis=None, highlight=0 ): if ( width == 0 and height == 0 and color == 'red' and emphasis == 'strong' or highlight &gt; 100 ): raise ValueError("sorry, you lose") if width == 0 and height == 0 and ( color == 'red' or emphasis is None ): raise ValueError( "I don't think so -- values are %s, %s" % (width, height) ) Blob.__init__(self, width, height, color, emphasis, highlight) Which I think of as more Javascript-y, where you just indent a single time to break apart the long lines, and keep the parens on the upper line to indicate the continuation. Looking at it, I'm not sure if it's actually more readable or not. I do know it's a bit easier to maintain, because you don't have to go re-spacing all of your earlier indentations every time you make a change to your code.
Why not? I don't see a reason, if you're consistent...
For me - it's always two editor instances open side by side (or vertically split viewing two files in Vim or MSVC). Giving 80 chars to each, and taking into account another pane (project browser, for example), it pretty much takes most of a wide screen. So I still stick to 80.
They used something called homebrew, just tried it. Real nice. It's like easy_install for macosx
That's a view where logger == destination, which is fine for simple needs (in which case you could just use the syslog module). I'm not sure if the standard library is the right place for all conceivable shortcuts, and even Django only defines *some* shortcuts, not everything anyone could think of. There are lots of minor disagreements between people about how even simple things should work (as you'll see if you look at the whole of the python-dev thread linked-to), so even if logging defined some shortcuts, they'd be sure to not suit some people. OTOH, people can always write shortcut functions for themselves that suit their usage patterns more closely than any general solution could hope to do.
I've not done a cheat sheet, but I have reorganised the [in-development logging documentation](http://docs.python.org/dev/library/logging.html) in line with some of the comments made by you here and Glenn and others on the python-dev thread. Feel free to take a look and give feedback.
I can't believe nobody has mentioned matplotlib. You can do some crazy plots and map overlays with relative ease
django doesn't have all conceivable shortcuts either and it isn't a problem. the problem is that there's no really simple but working options in the allegedly batteries-included stdlib. (btw I mostly develop on windows; the syslog example was simply related to parent post.) the idea is that there should be options that would allow a developer to use the logging infrastructure with absolutely minimal amount of brain effort to get something done in the right ballpark. currently it's easier to define a wrapper around print than to setup a logger and that's what shortcuts should aim for, because IMHO that's the root of the problem.
OpenCV Python bindings + a webcam. You can have face detection with faces marked on the feed from the webcam in just a few lines of code.
I guess, I'm still conflicted myself, I find it doesn't look right either way. I think it looks best if you close it after the last element instead of on a line of its own, but that's inconvenient for editing later and defeats the purpose of being able to end the last element with a comma. The comparison with PHP is kinda my point, too. unindenting the closing bracket seems like a C-like language thing to do. Bah I dunno, I'll make up my mind someday. :)
Agreed, and perhaps its not so necessary, but I find the dbapi to be quite awkward. Tangentially related, I find indexed parameters to be particularly bug prone. This package doesn't address this, but its a move towards simplification.
Decorators. If that doesn't scare them, you can pretty much throw the kitchen sink at them.
Yes, but in my earlier example about syslog, it's a one-liner (apart from imports): logging.getLogger().addHandler(SysLogHandler('/dev/log')) whereas for the NT event log it's another one-liner: logging.getLogger().addHandler(NTEventLogHandler('appname')) On each of a Linux and Windows system, I only had to sandwich one of the above lines between the import line and the logging.warning('Watch it!') call to get something into the NT event log or syslog. How much simplification beyond this is really required? I don't see any one- and two-liners in Django's shortcuts.
Well, in general terms, the brevity (compared to C++, Java) means that there's far less code to change. The clarity means that it's easier to read someone else's code (I usually have no problem picking up code I wrote five years earlier). Features like properties help me avoid writing a lot of code that would later have to be changed. 
yes they are such jokers but i do lol everytime...
what about [cocos2d](http://cocos2d.org/) ? the [hello world](http://cocos2d.org/doc/programming_guide/hello_world.html) looks pretty easy to understand. also this: # create a ScaleBy action that lasts 2 seconds scale = ScaleBy(3, duration=2) # tell the label to scale and scale back and repeat these 2 actions forever label.do( Repeat( scale + Reverse( scale) ) )
actually, django shortcuts in the trunk have, in order, 2, many, 7, 5 and 5 lines. ability to compress an expression into one line doesn't have any meaning here, because it's not the line count that matters, but number of terms which one has to remember. you only tend to setup logging once per project and it's always an unnecessary trip to the documentation, i.e. a burden which is easier avoided by just typing def log(s, *args): print s % args i'd happily take a from logging.shortcuts import stdout_logger log = stdout_logger() but i really don't want to remember import logging logging.getLogger().addHandler(logging....) # forgot how to log to stdout see the problem? there's no such thing as too simple here.
Sure, but what's the benefit of having this in the stdlib rather than in your own utility library, which you can maintain according to your needs? Then you can arrange it exactly to suit you once, and use it again and again. You're less likely to forget it, too. The problem is, every one's tastes as well as needs are different, and the general guidelines for the stdlib don't encourage a lot of proliferation of what may or may not be used. Notice how even popular projects like django-registration aren't automatically put in Django core, even though they're well established as being useful for a lot of people. I'm not discounting your feedback - just saying that I have no way of knowing, for any particular short-cut implementation, how many people would use it exactly as is, and how many would say "I can't use it, because I need a slightly different setup." Remember that anything that gets added to stdlib becomes almost set in stone for backward-compatibility reasons - if you get it wrong, you have very limited ways of putting it right. With dictConfig() available, there's no reason why people can't put any number of their favourite configurations in a (say) JSON file, then just load one by name.
for me, the greatest advantage to using an IDE (namely, PyCharm) over notepad++ was the vcs (git in my case) integration, refactoring tools, and autocompletion. As far as I know, all of these things are accomplishable with vim and plugins. 
I'm surprised no one has mentioned PyCharm. This is a Java based IDE from the makers of IntelliJ that does a lot of things right in my opinion, and is being very actively developed at the moment.
As a highschool student, I really liked being shown things beyond my understanding. So, since you're a computer science teacher, show them some *basic* math needed for GPUs (linear algebra) and DSPs (fourier transform), and then give them wicked cool examples of what they can do.
Installing dependencies on OSX has generally been more painful for me than it is in Linux (I don't even bother in Windows!)... Homebrew made it a lot less painful in many cases.
Ray tracing. Easy to do, teaches nice concepts about geometry and physics and the results are (at least can be) beautiful.
Python and the JVM are implemented in C. How can you claim Python and Java are Turing complete, but C isn't?
Someone who has tabs set to 8 spaces is still going to break the same 80 character line a lot sooner than someone who has them set to 2 spaces. 
Was JUST looking for this. Thanks
Sure, that works. I originally called S the "Kate" button, aptly named for my girlfriend. You could also call it a "stress the game engine to see if it can maintain 60FPS" button.
Was previously called pocco ( not to be confused with [pocoo](http://www.pocoo.org) ).
Automated screen-scraping would have blown my mind when I was in high school. I use mechanize and BeautifulSoup all the time now for personal projects (if they're into sports, let them know it's possible to scrape every play-by-play or boxscore available on the internet). I think they'd find the [NodeBox gallery](http://nodebox.net/code/index.php/Gallery) interesting, too. Creating visualizations with Python is pretty awesome.
Works on more than just Python: ".coffee": { "name": "coffee-script", "symbol": "#" }, ".pl": { "name": "perl", "symbol": "#" }, ".sql": { "name": "sql", "symbol": "--" }, ".c": { "name": "c", "symbol": "//"}, ".cpp": { "name": "cpp", "symbol": "//"}, ".js": { "name": "javascript", "symbol": "//", "multistart": "/*", "multiend": "*/"}, ".rb": { "name": "ruby", "symbol": "#", "multistart": "=begin", "multiend": "=end"}, ".py": { "name": "python", "symbol": "#", "multistart": '"""', "multiend": '"""' }, ".scm": { "name": "scheme", "symbol": ";;", "multistart": "#|", "multiend": "|#"}, ".lua": { "name": "lua", "symbol": "--", "multistart": "--[[", "mutliend": "--]]"}, ".erl": { "name": "erlang", "symbol": "%%" }, 
There is a package called "lol."
If your display is small, don't set your tabs to 8 spaces. With spaces, you don't even have this option.
How do I aquire this? Do I just copy the code from the left?
FTA: *To install Pycco, simply* pip install pycco *Or, to install the latest source* git clone git://github.com/fitzgen/pycco.git cd pycco python setup.py install
edited : don't have pip, new to programming. installing pip now.
A language is different from the implementation. Also, it is possible to stop a Java program and transfer it to a different JVM, say from 32bit to 64bit. It's theoretically possible for any Java program (as well as for Python programs) and it is actually really possible right now for systems written according to the JEE recommendations. Like, each interpreter is limited, but you can recompile the interpreter to use an arbitrarily sized address space. I'm honestly baffled by the fact that my explanations are downvoted. It seems like people take it as an offense, as if I were saying *"C sucks, it's not even Turing complete"*. Well, I am not, and what makes it all even more perverse, I guarantee that I know C better than any of the downvoters, in fact my comments provide a valuable insight to the darker corners of the C standard.
Well once your code is written entirely by robots, you'll be right. Problem is people absolutely cannot ever make tabs work properly. It just always ends up at "it looks fine here, just set your tab width to [2,4,8]".
There was a talk at PyCon a few years ago about using Python to write plugins (or whatever they're called) for Source game servers. A demo of that would be badass.
That's the way they teach it, and I'll concede that it's pretty bad, but nothing is stopping you from having having logic and graphics separate in pygame. I think the snippets they give are just that, small pieces of code that demonstrate a concept. As for the opengl stuff, that's more of a Python thing than a pygame thing. As far as I'm concerned, taking into account that we're talking about an interpreted language's game library, pygame is pretty darn complete. The OP was asking how he could get people into Python, and pygame is a completely valid suggestion. 
I don't understand where someone would have trouble. The only place to spend a bit of thought getting it right is when lines break, otherwise it will look very wrong if you make a mistake.
Well I guess you could say that the bracket is to encapsulate the information and is not part of it, thus it should not be on the same line as it. You could double indent the information but unless you're OCD it makes no sense to waste space, as long as it is consistent throughout the application. The main goal of readability is not to make pretty source code, but to make something someone else (or yourself) has minimal difficulty of understanding, so if it achieves that goal then I don't see an issue.
Or someone accidentally uses spaces for no good reason (perhaps their editor wasn't set up right, perhaps they're idiots, etc). It *will* happen.
Same thing can happen now when someone uses tabs for no good reason. It's just your innate resistance to tabs :P
No man, I'm with you! It just happens, and it makes me sad. So I've mostly given up on tabs for now.
I made this as part of a few articles that walk through creating a nice script for optimizing png files (easily modified to act on other files.) Anyway I noticed there weren't a lot of good examples of using Pools so I spent a little time going through the different ways of tasking worker processes.
I've seen eclipse take close to 3 gb on Win7 x64 during Android development. 
Me too, but that's because other people fuck your tabs up by using spaces, it's nothing innate to tabs... It would work if everyone used tabs...
I installed PyQT recently with [Homebrew](http://mxcl.github.com/homebrew/), `brew install pyqt` - took a while to build (an hour or two), but worked perfectly first time.
Look up some public APIs and use those in class (if your class lab is connected to the net). The del.icio.us API is public - you can get top posters, links from top posters, filter them using regular expressions, make a top count for popular links and get your pupils to make their own data mining application (eventually as a class project). You can find other public APIs as well.
I like [mechanize](http://wwwsearch.sourceforge.net/mechanize/) for higher level web stuff than urllib2. 
Just out of curiosity, what do you use it for?
Here is a full implementation of space invaders: from Tkinter import Tk, Label, Canvas, PhotoImage from math import sin from thread import start_new_thread from time import time, sleep root=Tk() canvas=Canvas(root,width=800,height=400,bg='black') canvas.pack() label=canvas.create_text(50,380,text="0",fill='white') canvas.create_text(650,380,text="(Space Invaders by Massimo Di Pierro @ 2006)",fill='white') score, aliens, missiles=0, {}, {} img1=PhotoImage(data='R0lGODlhHgAPAPECAAAAAP8AAP//AAAAACH5BAAAAAAALAAAAAAeAA8AAAJDjIGpy2l3mmTQhfXyw5d2DW5A1GTCCZ5CNo2PmqJiGdYgbeezdQuAD6x5er/iKiTR2XBKnYKEUEmnFF7rioCwsMxAAQA7') img2=PhotoImage(data='R0lGODlhCgAUAPEDAAAAAAD/AP8AAP//ACH5BAAAAAAALAAAAAAKABQAAAIphBFxm7nY3IkSUmWpuY77C21Kh5FhaKJjuZ7kBw2CLDmCcCKArD/4UgAAOw==') for x,y,p in [(100+40*j,160-20*i,100*i) for i in range(8) for j in range(15)]: aliens[canvas.create_image(x,y,image=img1)]=p def fire(event): missiles[canvas.create_image(event.x,390,image=img2)]=10 canvas.bind('&lt;Button-1&gt;',fire) while aliens: try: for m in missiles.keys(): canvas.move(m,0,-5) if canvas.coords(m)[1]&lt;0: score-=missiles[m]; canvas.delete(m); del missiles[m] for a in aliens.keys(): canvas.move(a,2.0*sin(time()),0) p=canvas.coords(a) items=canvas.find_overlapping(p[0]-5,p[1]-5,p[0]+5,p[1]+5) for m in items[1:2]: score+=aliens[a] canvas.delete(a); del aliens[a] canvas.delete(m); del missiles[m] canvas.itemconfig(label,text=score) sleep(0.02) root.update() except: break
Obviously, you gave it that much, and if you understand how generational garbage collection works, then you'll know why it took what you gave it.
I'd rather use something that processes docstrings. Using comments like this doesn't feel very Pythonic.
I am pretty sure the original version was for Coffeescript and was written by its creator, Jeremy Ashkenas.
I knew someone would come up with something smarter than me- thanks for this, makes a lot of sense.
&gt; Well, it's a game library for an interpreted language. Of course the speed isn't going to be up to par with anything that's industry standard. The speed of Python is not that important since crucial parts are written in C (SDL and whatnot). But Pygame seems to me to be semi-dead. I sometimes wonder whether LÖVE is better...
Pygame is currently being rewritten for Python 3. It's called Pygame Reloaded or something like that. There are alpha builds available. Anyway, it's far from dead.
Yeah, and sometime ago there was a fruitless port to ctypes.
Actually it does process docstrings, but you can make it process anything you want by changing [this line](https://github.com/fitzgen/pycco/blob/master/pycco/main.py#L284): ".py": { "name": "python", "symbol": "#", "multistart": '"""', "multiend": '"""' },
Eww.
I agree. When it crashes after installing from pip, I get the error: pygments.util.ClassNotFound: no lexer for alias 'coffee-script' found
I think its an issue with pygments, try rebuilding the lexers: $ python2 /usr/lib/python2.7/site-packages/pygments/lexers/_mapping.py
I've been using PyCharm for a few weeks, and really like it so far. It's lightweight and the Google App Engine integration is better than Aptana3. I'm just a bit worried that it'll end up being abandoned if it's ignored by the Python community because it's not open source, and lacks a Free version. Haven't spent $99 on it yet because I'm still in the 30 day trial, but seriously considering it.
Awesome! Thanks for the attention to the project everyone! Make sure to give it up for everyone listed [here](https://github.com/fitzgen/pycco/blob/master/AUTHORS) as well as for Jeremy Ashkenas, who started all this with [Docco](http://jashkenas.github.com/docco/). PS I love getting pull requests on Github!
ok. Thanks. I will give it a shot.
&gt; There were no matches. wtf ?
Why would a Python user use this over Sphinx? Personally, I find the side-by-side view awkward.
[Pyglet](http://www.pyglet.org) is fun to play with, and can do many things a teenager might find cool (it's a multimedia lib). edit: fixed link
Ah, thanks for that! =)
 The builtins True and False are the only two instances of the class bool. Constants in Python are capitalized, see also: [python.org:docs/constants](http://docs.python.org/library/constants.html) TL;DR: Consistency
Same reason as in other languages where you must type `true` instead of `True`: because the language defines the booleans that way.
Unfortunately, the libraries are not very consistent. For example the string constants are all lowercase, the re constants are all caps...
A simulation of a snake robot. I am working on developing gaits (motions) for the robot using genetic algorithms as my master thesis. http://imgur.com/m4JnH.png
this utility library of mine will contain functions that do the exact same thing as somebody else's, but with a different name. it's better to just bless one particular name so everybody knows what they're talking about. for a example which isn't as far away as django, see itertools. technically those too are functions that could be implemented in my own utility library on an as-needed basis. it opts to list several less-used functions verbatim in the documentation instead of providing a module, but technically it's the same thing, except there is about 20 recipes. i honestly don't expect more than 3-5 logging shortcuts, because as you say, you can't suit everyone - but you can provide a starting point for people who a) don't have the slightest idea how logging works and b) don't have their own utility libraries written.
&gt; it opts to list several less-used functions verbatim in the documentation instead of providing a module I'd have no problem with this. I've been thinking about re-organising the docs into basic tutorial + advanced tutorial + reference + cookbook, and there could be this sort of documentation in the cookbook section.
Python prides itself to be a *designed* language. There should be a reason behind this.
Why is this being downvoted (2up 3 down)? It's a legitimate, interesting question that hasn't been answered here yet. Rpython needs to read the reddiquette.
It seems to have been answered 2 hrs before you posted.
What I meant is that readability is dependent on display organization and splitting at 80 often is arbitrary and sometimes counterproductive. Having to manually wrap 80-100 char lines just makes the whole code block less readable and improves nothing when you're working on a decent, large sized display. I just think the rule makes sense to avoid insanely long lines but that applying it religiously to 80-100 char lines ends up messing the code more than it helps it. Ymmv though.
Yes, and cleaning up inconsistent warts is an ongoing project -- note that no-one claimed the entirety of Python is or has been perfectly consistent on style (and indeed PEP 8 has some things to say about that).
The specific reason for Python was given two hours before you posted. Perhaps you didn't bother to read the rest of the thread?
baring constancy, it's kind of annoying. (seriously guys, whats with the downvotes? not good reddicate) 
custom_builtins.py: true = yes = True false = no = False none = null = None Then: from custom_builtins import null, yes if what_i_want_to_check is yes: # ... reset the object ... my_obj = null
&gt; Constants in Python are capitalized [...] Was an incomplete response. And [this issue was unanswered as of my writing](http://www.reddit.com/r/Python/comments/ekw8a/askpython_why_do_i_have_to_capitalize_my_true/c18vad9): &gt; Unfortunately, the libraries are not very consistent [..] 
I think this is to clearly show that True and False are not types of their own, but rather singleton *instances* (as opposed to subtype) of bool class. That way you can use (something *is* True/False) comparisons and you can differentiate between boolean value and an integer: 1 == True and 0 == False : True 1 is True or 0 is False : False int(True), bool(1) : (1, True) isinstance(True, int), isinstance(False, int) : (True, True) 
not obvious to me either... i suppose if you couldn't be arsed 'learning' sphinx...?
or just: if what_i_want_to_check: # do whatever 
That might as well be false = True true = False There's no need to fuck up your code by doing horrible things like that.
I would actually prefer using 'True' than doing that.
I was just trying to be funny.
Not the same thing when you want to check for exactly True (in this case, true).
Because it's classier.
Is JPython != Jython ?
but isinstance being special *built-in* function and True and False striving to follow convention of singleton instances of something also hurts my brain. 
Gaah, my poor DSL hosted domain .. it can't handle reddit :) We're moving to better hosting in future. As it says on the page, we're currently working on web interface and it's progressing very rapidly. If anyone is interested joining the project join project IRC channel. We have ~200 unit tests and continuous integration &amp; building via hudson.
Exactly.
Because it's "None" instead of "none".
It's bad API design, but one could write a function that returns booleans or other things, and need to check for exactly True. Feature, not bug.
Panda3D is a billion times better. I don't understand why so few people ever heard of it here in reddit.
I've had pretty good luck with [Console 2](http://sourceforge.net/projects/console/) as well. +1 for Putty though; it's fantastic, apart from the minor nuisance that it "confuses" AltDrag (heh ... you can't tell I'm a Unix guy stuck on a Windows box, can you?).
Not every function which returns one of True, False, None is probably a bug. Though you would probably be checking for `is not None` usually, but still!
it's not really used in the same light as sphinx. It's following the idea of literate coding, where the documentation is inline with the code it describes. Side by side is just making it simple to see said code.
RunSnakeRun is awesome.
bigO of log(initial max) complexity if I'm not mistaken. Edit: I came down to this thread after seeing your latest post on the SS ragecomic. You're an awesome coder = win in itself.
How about None? Also a singleton.
Why not? They had to pick one. Why pick the same convention as variable names use? It's not variable at all.
I personally don't like this "no-one claimed" attitude. Python is a language that prides itself on its design and consistency &gt; There should be one-- and preferably only one --obvious way to do it. Noting the lack of a "binding contractual clause" in the documentation concerning consistency, isn't that interesting. I do agree with everything else you wrote.
Let me paraphrase our conversation, enlighten me if I misunderstood something. OP: Why "True"? ubernostrum: Just because. temptemptemp13: Python should have a reason. ubernostrum: that reason was posted elsewhere. temptemptemp13: ill paraphrase the conversation to see if I don't understand something [...] What value have your comments added to the conversation that you deserve the upvotes, sir?
Yes indeed, generally not a good idea but there are situations where you want a special kind of dispatch on a boolean value (as opposed to everything else) and `a is True` is more readable than `a and isisinstance(a, bool)`.
&gt; It's following the idea of literate coding Really, it's not. It's following an even more restricted reinterpretation of literate programming than Python's own preexising doctests.
Isn't having the capital T less efficient because it requires me to use the shift key every time I want type "True". It messes with my flow!
I can't think of any time I would want to have two constants or two variables that are identical except for the case. Back in the old days (1980s) none of the languages were case sensitive. What happened? Is there ever an advantage in having a language case senstive? If not then why do they all do it? 
Gotcha I agree wholeheartedly, but what makes the capital T more sane that a lower case T? Is the reason as simple as "Humans naturally expect statements to begin with a capitalization", or is there some other innocuous reason?
Python 3.x has already made large strides towards consistency in design, and that will likely continue. Like ubernostrum suggested, it is an ongoing project.
Downvotes are applied automatically by reddit to defeat spammers. temptemptemp13 needs to be more informed before accusing Rpython of not knowing the reddiquette.
True, but I have yet to see a single argument for why True would be more readable than True. Capitalizing cost an extra keypress, so there ought to be some type of motivation in there somewhere for why it's needed.
TL;DR please. I have no idea from the title what the article is about.
PEP 8 recommends ALL_CAPS for constants. String constants are lower case, most all other constants actually follow PEP 8. How exactly is using StudlyCaps for True, False and None and a small number of additional constants in any way, shape or form _more_ consistent? Also not that of the built in constant one (\_\_debug\_\_) doesn't start with an upper case letter. 
Even still it's a closer interpretation that using sphinx which is usually written independent of the code (though autodocs helps still not inline) plus i don't think it's going to compete with sphinx at all. I can't see this fitting anything more than a one file script, and at that I feel it's nice to see code in the docs.
not as annoying as methods of unittest and their camel-casiness (e.g. setUp, tearDown)
[scipy.weave does not work on Python 3 yet; the other parts of Scipy do.](http://mail.scipy.org/pipermail/scipy-dev/2010-December/015811.html)
tl;dr: Real world usage requires optimizations. Three pretty graphs show a history of optimization in SQLAlchemy. And other cool stuff.
I read somewhere (while back and don't remember the source) that they have them as "True" and "False" because of legacy code that used "true" and "false" variables before they were reserved words. Of course that might not be True.
&gt; Even still it's a closer interpretation that using sphinx Sphinx does not and has never claimed to be literate, neither a literate programming system nor a literate documentation system. &gt; which is usually written independent of the code (though autodocs helps still not inline) Not being written inline is *the whole point* of sphinx, whose purpose is to product crafted documentation which stands heads and shoulders above extracted APIDoc in the style of javadocs or pydocs. That's like saying a turd sandwitch stands closer to being an eatable sandwitch than a plate of pasta.
C was. Consistent and CONSTANT :)
DAK if matplotlib has been ported yet? If so, I'm moving :)
same for *None*
&gt; TL;DR: Consistency yeah python is all about consistency &lt;giggles /&gt;
But PEP8 convention is that almost all Python should be lower case to make it more readable!
I tried that. POLICY_NEVER disables the scrollbar, meaning not only is it not shown, but also you cannot scroll. I want to hide the scrollbar, but still be able to scroll.
Ticles my memory too!
I see, your explanation is much better than the highest rated one. The top rated post might make sense for people who already understand what's going on, but sometimes more detail is better. and why is everyone down voting me? I'm just curious and want to become a better programmer, jeez.
No, Python classes are uppercase. Variables are lower case. You probably know this, but you said "almost all". A cursory look over one of my files (views.py in a django app) and I'd say it's 70% lower, 30% CamelCase and mixedCase.
lol the shift key messes with your flow? Try emacs. I press control and alt as much as shift...
I like it because (as a strong relativist) I argue that there are no "capital T truths". But in computer programming there are. In real life truth is circumstantial, subjective and ephemeral. In computer programming (and I guess pure math as well), when you ask: user.username=='dustinechos' The answer is True. I guess with python's dynamic typing this is less true than in other languages (so 1==True is more true than True lol)
Pep 8 begs to differ. Python's recommended coding style is underscore_case for variables, functions and methods, UPPER_CASE for constants, lowercase for modules and builtins, and CamelCase for classes. So True and False are captitalized the same way that classes are. Of course, pretty much every single python library breaks these conventions, so you might argue that using True and False is consistent with the inconsistency that is the Python library.
I must really suck then. Also, I prefer vim, though I'm a novice at both... emacs' interface weirds me out.
In return, it kind of looks like True and False are classes, cause that's the only other thing that uses CamelCase. TRUE and FALSE would at least make sense logically, even though it's crazy ugly.
The only serious, valid argument I've seen is that there was already some code out in the wild that used true and false as variable names. Other than that it's just silly stuff like «constants should be capitalized» (Almost all constants use ALL_CAPS, CamelCase is reserved for _classes_, not constants), or jokes like «it's classier». Care to point out where exactly in the discussion these tons of arguments are presented?
it still doesn't work
[File a bug](http://bitbucket.org/birkenfeld/pygments-main/issues).
Eating habits aside, I wasn't meaning to say that sphinx was styled after literate programming, just that the original comment wondered why someone would choose to use this instead of sphinx. Main reason being that they want to code in a more literate style, and have pretty (my opinion) docs out of the deal. I also wasn't attempting to imply one was better as you really seem set on trying to do. Be less butt hurt over people deciding for themselves if they want their docs inline or not, as docs a dev likes to write are going to be better than shoehorning them into a tool they dislike.
A downvote for you, sir! The emperor is obviously well clothed, don't you see?
My main point is that if you follow a convention like "variables lower case, classes uppercase" this could easily be done automatically by your IDE. This would give you readability without any confusion over doThis() and DoThis(). 
I really hadn't thought about that. Never actually used pygame on anything professional. But now that you mention it I kind of got an itch to code. So what engine on Python would you say is nicer for this purpose?
&gt; Yes, we are going to support re-theming, not only for the editor, but also for the IDE through something similar to CSS Oooh, I'm intrigued. Is it currently in the codebase? I've checked out the latest snapshot, and I'm just wondering where I should look if I'm curious to see... &gt; With Code Completion we mean something similar to IntelliSense, currently is supported but with some limitations... but we are working on it. Any opposition to using something external? Like an external library that provides the functionality? As I said before, I've actually started and stopped a library to provide essentially what I wrote above several times now, and I think a generalized third-party library (perhaps Apache 2.0 licensed to maximize license compatibility) would really be nice so it could be used in any editor that might want such a thing. My biggest problem has been time- I've started it and never had time to actually even get it to a prototype phase... I keep mentioning around other Python people in the hopes that someone with more free-time than I might take the idea and run with it :-)
Have you tried eric IDE ? (http://eric-ide.python-projects.org/) This IDE is python + pyQT based, has a lot of functionnalities (projects, syntax checking, many modules as for using pylint), and it does not need a lot of memory (I use it on my netbook). It lacks in dynamic autocompletion, but has a great asset : it's post-mortem debugger. With it you can run your code in a normal way and in case of a crash, have access to the traceback, variables, and it's console is context aware so that you can do introspection of your code with no pain. I've tried eclipse, netbeans, pida, komodo and many more, but this one is definitely my favourite. 
I easily get upset at things "messing with my flow". Specifically numbers and the symbols above the numbers used to slow me down. I worked a whole month with my keyboard under my desk to force myself to not look at those keys. emacs and vim both are nice because, if you learn all the hotkeys, you can code without leaving the home row for anything. My current flow killer is my dependency on the arrow keys. I'm getting out of that habit as we speak. It's all about flow, lol.
Well it is consistent with other *global singleton instances of type classes* (and this is what I meant in 1^st post). Except \_\_debug\_\_, which is not meant to be used in production code and that's why it gets special private instance-like variable treatment. Or something simpler like it simply predates PEP-8.
I keep my terminal around 80 because I like having a browser open next to the terminal (and another browser on the other monitor). Short lines are easier to skim. When a line wraps it ruins the whitespace structure. What are you doing that needs more than 80 characters? unless you're unnecessarily piling on list comprehensions or have java style names (20+ characters) I don't know why you need more than 80 characters. As d0ugal points out, code over 80 characters is likely a result of "long variable names, bad structure, [or] overly nested code blocks".
Refactoring! Hurray! I've been waiting for this. I actually only need the renaming functionality. That helps a lot if you have a large project. There's also a "revert"-button, so you can rename, run your tests and in case of any failures revert, easily deselect the usages that caused problems and rename again. P.S.: I'm not from Wingware ;-). I like PyCharm also a lot even if it doesn't work properly on all my projects (some tests and refactoring don't work on an exisiting project). Now the choice is hard. Good for us.
&gt;Case sensitivity forces you to follow a convention for a given object once you've established it. It does not force anything. I can use pep8 - variable. My colleague can then call something Variable ignoring the convention. And I can make a mistype Variable which won't get picked up because of the case sensitivity.
That's awesome! Great job to the teacher and I'm sure the kids are getting a ton out of that class.
I won't be moving back to Wing until it gets "quick diff" functionality similar to what's available in Eclipse. I tried Wing Pro 4.0beta4 last week and this is the only thing I miss from Eclipse/PyDev.
So do what I do then, add this to your ~/.vimrc: au FileType python iab &lt;buffer&gt; true True au FileType python iab &lt;buffer&gt; false False au FileType python iab &lt;buffer&gt; none None Tada. If you ever need to keep it lowercase (I've really had to do this, but sometimes I do in comments), after you type true&lt;space&gt;, just hit c-[,b,~ to lowercase the t/f/n.
No-one claims == no human is perfect Just one of those accepted truths
This is huge -- the Python 3 migration path gets a lot easier for many people with major libraries like SciPy making the conversion.
So there is really no alternative in Python? Really not performance wise. I am not thinking of releasing it or anything, just learn something new so I don't pygame anymore.
[lxml](http://codespeak.net/lxml/) is generally better than BeautifulSoup and is more actively maintained (although the documentation isn't as entertaining). It can also [interface](http://codespeak.net/lxml/elementsoup.html) with BeautifulSoup if you have a use case where it is still superior.
Regular constants use UPPER_CASE, but the built in constants use CamelCase, because they're singletons. But aren't many, (most?) constants singletons? Is that a new rule, then? Regular constants are UPPER_CASE but singletons are CamelCase? Also note that there are a few all lowercase constants, like license and copyright. Do you have an amazing retcon explanation for those too? :-) Seriously, the lack of consistency in Pythons standard library is infuriating. Why is the datetime constructor called now() and the date constructor called today()?
i've been using flexget for about a year now and couldn't be happier with it. that in line with a deluge daemon which auto-starts when on my home network (work IT guys get miffed when i download in the office) and tvrenamr give me the ultimate in lazy tv downloading. i do nothing but add new shows i want to watch to my flexget conf and the episodes just pop up, renamed and shorted for me when they're done.
I would have to disagree on several points. First of all my tutorial builds from previous tutorials and is expected to maintain that previous functionality. The whole basis of that script is not only optimizing but also identifying files to be optimized. In your example where does the variable files come from? As well I do basically the same thing in my first three pieces of example code (starting with apply then apply_async and finally map). Using a main function with your pool makes very little sense. In fact it isn't really a main function at all in your example, simply a function you have arbitrarily named main. One would naturally assume when reading your code that main is executed when the script starts but in fact it is merely a function called by the script which doesn't make use of a main function construct. Additionally I can not import your script and make reasonable use of it from other code. You can see that in my examples I do almost the same thing, calling my example function consume and eventually transitioning to a well functioning python module with a proper main function (while the example I'm mainly referencing doesn't have a good main setup at least it is clear from the fact I don't use the word main). I used the os module to identify in which process particular data elements are actually processed, print some results to the screen, include a dataset to be fed into the map function and properly close and join the pool at the end (which you should have done) but otherwise my third example is identical to yours. With the rest of the article I explore issues in how to actually do parallelism well and explain the pros and cons of the different methods of tasking a worker pool. For the particular use case that I'm building a solution for map is a terrible choice for reasons I identify in the article. My goal wasn't just to impart on people how to make python do multiple things at a time with the multiprocessing module but to try and have them understand how to choose a reasonable method to do so which is heavily dependent on how the work is divided among processes.
&gt; But aren't many, (most?) constants singletons? Is that a new rule, then? Yes, you're right. I guess the keyword was 'global' or 'builtin'. It all comes down to usability and clarity. The reason PEP-8 encourages to use UPPERCASE_CONSTANT_NAMES is so that you know that something is a constant with a blink of an eye. However, with True, False and None the fact that they're singletons is merely an implementation detail. If there's no upside to typing TRUE and FALSE everywhere then why bother. Of course then one wonders why not simply 'true' and 'false'. And for that I must say what I've said earlier—that is to acknowledge the fact that we have singletons for booleans rather than explicit types. And to acknowledge it without being obnoxious about it—the Python way. &gt; Seriously, the lack of consistency in Pythons standard library is infuriating. Why is the datetime constructor called now() and the date constructor called today()? That is hardly the most infuriating thing about Python standard library, in my opinion. But as someone's noticed, this is why we have Python 3.
I got it from Jason Kirtland. It was basically like magic to me until I went hunting through the Python docs for why it works.
You can help PyPy by donations: http://morepypy.blogspot.com/2010/11/speeding-up-pypy-by-donations.html
[Tool to determine what lowest version of Python required?](http://stackoverflow.com/questions/804538/tool-to-determine-what-lowest-version-of-python-required) - https://github.com/ghewgill/pyqver
**Python Osmosis** &lt;= Background on Python http://python.sourcequench.org/?m=200905&amp;paged=2 The USB part should be trivial. 
Hope it's goin well. The only things that holding me back from python 3 is lack of numpy, matplotlib, and scipy.
"protecting your code" is a good way to miss the point in Python.
No i think that'd probably be a comment about regular expressions. This would be #2 for sure though.
oh this is awesome. thank you
Try: from Tkinter import * 
Numpy is available for Python 3. Otherwise scipy wouldn't be able to have their release here.
Actually, don't do this. Do this instead: import Tkinter as tk then, do this: root=tk.Tk() Most likely you already have Tkinter installed by default though. Avoid import *, in order to avoid name collisions, among other reasons. (Although, it will still work as a good test to see if Tkinter is installed) Also, if you are using python 3, tkinter has a lower case t.
If you are using Python 2.x do this: import Tkinter as tk root = tk.Tk() If you are using Python 3.x do this: import tkinter as tk root = tk.Tk() Note that Python 3 has made tkinter lower case.
I use dual monitors or a high res monitor and yes with one window it's no problem. Then when you need multiple windows open for other stuff or for diffing then you find all of the sudden things can feel smaller and that 80 char limit makes sense. Plus if I recall most people don't do well reading long lines of text so it's better to use more space vertically than horizontally. This applies to anything not just code.
thanks was looking for something like this for a project.
For those developing on Debian based Linux, these are the steps: 1. Install python-opencv package with apt-get/aptitude 2. You can get the Haar cascades here - http://alereimondo.no-ip.org/OpenCV/34 3. Run the same code, just make sure to use one of the cascades downloaded from step 2 Line 60: parser.add_option("-c", "--cascade", action="store", dest="cascade", type="str", help="Haar cascade file, default %default", default = "/usr/local/Cellar/opencv/2.2/share/opencv/haarcascades/haarcascade_frontalface_default.xml") Change default to the haar cascade file path, or use --cascade option to specify it. 4. Execute **Edit: For non-Deb based distros**, use your package manager to download/install opencv for python (or compile it) and continue from step 2.
Last time I used wing it was really slow and sluggish compared to its older versions.
What does "quick diff" do? (Is this the feature that saves changes locally and allows you to diff or revert independently of version control?)
now and today are not the constuctors of those classes - they are class methods for returning instances representing, respectively, now and today... 
The Python development community generally values consistency but it is not an obsession. 
http://infohost.nmt.edu/tcc/help/lang/python/tkinter.html http://wiki.python.org/moin/TkInter http://www.ferg.org/thinking_in_tkinter/index.html http://www.tutorialspoint.com/python/python_gui_programming.htm 
Because "now()" is not the same thing as "today()". Today can have an infinite amount of "nows".
That part works. When I try root=Tk() I get the problem. After Googling for a while I figured out that it means that I have TkInter but not tcl/tk.
Learning Python by O'Reilly http://oreilly.com/catalog/9780596158064/ But, if you don't want to spend all that money, you can buy it in e-book form on iPhone/iPT/Android for like $5 a lot of the time.
Search for Learn Python the Hard Way, best book ever seen for teaching programming.
Thanks for the resources but none of them tell me how to get tcl/tk onto my computer...only how to use it afterwards.
With zero knowledge, the book Learn Python the Hard Way is without doubt the best option. http://learnpythonthehardway.org/index Furthermore you should check out python.org for references. Seems you have found some. Also the python irc channel might come in handy if you are stuck. Last word of advise: find a practical purpose. It will keep you motivated if you have a simple program or web-application as a goal. edit: dont use any em fancy tools or IDE's. Notepad++ / kate / gedit will do.
How beginner friendly is it? I have a gigapedia account (holy grail of ebooks) so that's not an issue, there are plenty of editions though, I want to learn for 2.7 so which Ed is better then?
Wow, seems to be what I am looking for. Thanks
Yeah although I have Visual Studio and Aptana with py plugins, Notepad++ is my favorite though, will it be better to learn without IDE's? I guess they can help by minimizing a lot of the typing but then again learning is about doing everything yourself.
It's honestly one of the most beginner friendly books I've read. It's concise and well worded, and has plenty of examples as well as reasoning behind explanations. That also makes it quite a bit longer than a lot of the books I've read as well. For me, they went into TOO much detail, on things that seemed pretty basic to me. But that may be exactly what you need.
Awesome thanks! And the 3rd Edition is from 2.5 and up.
Make sure to use the setting to use spaces instead of tabs when using notepad. Python does not require a lot of typing. I spend 80% of the time thinking out my next move and that comes form a slow typer (and lousy programmer). I more or less started with django and got into a bit of python from there. I don't necessarily proclaim that to be the best course of action though.
I am also interested in what niche you are trying to fill here or in what ways the other frameworks have shortcomings you address here. Do you have the ambition and manpower to grow it into a production ready framework (or is it already?).
Try to write a program to solve a real problem for you. This is the fastest and best way to learn something.
I just noticed that it does not catch ''' for multiline-comments in Python. I demand a patch immediately! (not really)
I used Dive Into Python with a moderate amount of programming experience, and it confused me at points. Python is an amazing language, but you might be better suited to learn C first, till you get the concepts down. To answer your question about math; math is important in programing because that's all computers really do. Compute things. Programmers tell computers what to compute. Synonymous with compute is calculate. Calculate is synonymous with math. Ergo, Programing **is** math.
I personally think that "How to Think Like a Computer Scientist: Learning with Python" is a better introductory book because it teaches the concepts. to Sember: I wouldn't worry about having to use math in programming or dictionaries or why things are important. Work through the book, and make your own very small projects, and post them here so you can get some review and advice. Learn Python the Hard Way will teach you how to do stuff in Python, but How to Think Like a Computer Science will give you the sort of knowledge that you will need to acquire eventually and make learning other languages much easier.
I honestly didn't find it very beginner friendly. Its very detailed, and a great reference to the language, but for a first time programmer (no experience with other languages), I would not recommend it.
http://code.google.com/edu/languages/google-python-class/index.html Can't stress how useful these videos are, check the lecture links on the left. Its really worth watching them (and following along ofcourse)
Thanks for the answer, I was contemplating on learning C or C++ but that would probably take much longer to learn than Python and I am more interested in Web Applications anyway. About maths, I understand that most computing is maths but I don't get how maths fit into the whole scripting, say I wanted to create a web app that fetches a web page and then lets you comment on the webpage (this would be a layer on top of the actual page, so not commenting on the webpage itself), how would math play a role in the programming process?
Learning Python the Hard Way is better then? Anything else you would suggest?
Nice find! Thanks!
Thanks Python the Hard Way is nice too it seem, and it's just 165 pages so not a lot of reading required, I plan on going through that one, How to Think Like a Computer Scientist and then Dive into Python, I am not great with maths so I wanted to know how much of a problem that would be.
Both functions return an object describing the current place in time to the maximum precision of the data structure. That one of the two structures has a few more digits of precision hardly makes them conceptually different. Also, since datetime has finite precision, saying that today has an infinite number of nows is wrong and misleading.
well one thing you should understand, the term 'programming' is thrown around a lot lately. There is an ongoing debate saying that languages like python, javascript, ruby, and perl shouldn't be called 'programming languages' but instead 'scripting languages'. C is 100% a programming language. Perhaps the most low level, hardware centric language there is (aside from Assembly or *gasp* PLC programming). scripts automate things at a very superficial / application level, programs go much deeper into the hardware and OS of a system. So a programmer might need to know more math than a scripter. That being said, scripting still uses tons of maths. Not maths in the sense of algebra or calculus, but algorithmic. Say you have an application which allows you to specify x number of nodes. Each node is connected to each other node (full mesh). Each connection has a certain speed (y) which is user inputted. Those speeds are entered into a list (array) of numbers in a certain order. This list is passed from one page to another. How does the second page know how to unpack the list? How does the first page know how to build it? It's all in the algorithm. You don't have to know tons of math to learn programming, but you have to be good at it.
Technically, they're not constructors, they're factory methods. But they fill the same role. The fact that they're implemented as factory methods, something that is generally avoided in Python because they're not really needed just adds to the annoyance. The obvious way to construct a date/datetime representing the current place in time would be to call datetime.date()/datetime.datetime(), but no, we need something different that is longer, harder to remember and at least to me, no more readable.
This is beyond useless.
I started on C. It's not terribly hard to learn as a first language. Especially since many popular languages are derivatives of C, it's an excellent first step.
Don't go through several book at once. Just stick to one (my vote is also for "How to Think Like a Computer Scientist", the book I learned Python from). 
You can set it to diff against local or VCS history. I use the latter. You always have an overview of your changes, additions, and deletions, and you can revert any single line or selection of lines.
Django no doubt. Very consistent, well documented, under massive development and huge following.
Turbogears migrated to ride on top of Pylons with Python Paste in version 2.0, and presents a particular set of default tools and configurational choices made on top of a Pylons installation. Pylons is at version 1.0 and will remain so for the foreseeable future. Pyramid is the next generation of Pylons which is constructed on Repoze BFG, which in turn borrowed a lot of ideas from Zope. The trend is that of an un-splintering of very similar frameworks, all composed around WSGI as a central concept, into an ever more solid and singular core set of tools, patterns, documentation, and support communities. 
That's akin to learning Latin to learn Spanish. Sure, it can be a useful path, but I would never steer someone toward C/C++ who has zero development knowledge. "Once you fully learn this thing you'll likely never use often again, then you can really begin learning what you wanted..." it's a horrible way to learn. Similar to you don't go showing off vim's power to a first day Linux/Unix user. You set them up with GEdit, nano, or something similar to their knowledge level. There is zero harm in going back to learn C/C++ if the need arises. Which assumes he continues to program for more than a couple of months. 
Definitely avoid IDEs until you have the basics down, they will confuse you more than help you. As in, if you switch form Visual Studio to say Eclipse, you would in a sense be "learning Python" all over again. Instead of knowing what the IDEs are doing for you behind the scenes, which should make it easier to adjust. Granted, I've never liked IDEs, but I started developing long before they were fashionable (or even really existed in their current forms). 
I just put these two lines in a file named test.csv and loaded in OpenOffice.org 3.2.1 (go-oo.org version): 1,2,3,4,=SUM(A1:D1) 5,6,7,8,=SUM(A2:D2) The result is reproduced in [this image](http://imgur.com/V7xe8). I didn't use any special option, so maybe you could still use CSVs with formulas (if they're not too complex). **EDIT**: There must be another way, but I was able to export the formulas to CSV. I marked the option to show the formulas instead of the values ([here](http://imgur.com/GyYDx)) and set the text delimiter to an empty string. If you keep the delimiter, you must uncheck the option "Quoted field as text" while opening the file.
interesting - thanks for the link
[python-excel.org](http://www.python-excel.org/) should have what you need.
While it's nice to see a switch from Subversion to a good DVCS, there are a **lot** of branches, here! I think it might have been better if they just kept the old trunk. Anyway, I hope the switch helps PyPy's progress; it's an exciting project!
Python is an amazing learning language. 1. Managed memory means you can focus on algorithms without worrying about buffer overruns. 2. It's multi-paradigm so you get to learn about imperative, object orientated and functional programming. 3. It has a big standard library so you can do cool stuff easily. 4. You can develop both web apps and desktop apps. 
Pyramid, because that code is *tight*.
Python packaged for Windows from Python.org comes includes Tkinter. Do you have python installed and the PATH to the python.exe mapped in windows? 
&gt; While it's nice to see a switch from Subversion to a good DVCS, there are a lot of branches I thought the comments were joking, and that there were probably not *that* many, but holy crapola there are 68 branches in the repo.
No, that book is terrible (written by a sadist for masochists). Do "How to Think Like a Computer Scientist" instead.
[Flask](http://flask.pocoo.org/): nice API, awesome documentation, great extensions, extensible design, powerful kudos [Werkzeug](http://werkzeug.pocoo.org/) and [Jinja](http://jinja.pocoo.org/) (though I use [Genshi](http://packages.python.org/Flask-Genshi/) myself). Being small and simple and using the best libraries, it should be performant. Anyway, Pyramid is the future Pylons, and Turbogears is a mixture of third-party technologies.
"Dive into Python 3" is good ("Dive into Python 2" is OK but out of date), but it's written for people who already know how to program in some other language. I'd say read "How to Think" first, then the official Python tutorial, then DiP3.
I have python installed and properly added to Eclipse. I know that Tkinter comes with it and that isn't the problem. It's tcl/tk that isn't with it and that is what I need.
Don't call it "C/C++". C is an elegant, simple enough language. As long as someone explains to you what pointers/arrays are and how the type system works, it's understandable. C++ is a crazy monster beast. C is OK for beginners, since they're going to need to know how memory and pointers work at some point anyway. C++ is not OK for beginners because it throws in too much crazy stuff.
My suggested order would be "How to Think Like a Computer Scientist" followed by Learning Python. Learning Python is incredible, and its the perfect second programming book, but I find it a bit too hard to be the first. Oh, and really don't worry about math with programming. Its similar thinking but you don't actually use math too often.
I can certainly agree with the C vs C++ distinction there, force of habit. However you said "as long as someone explains pointers to them" to someone with ZERO development experience. Pointers are the single biggest issue people have when developing in C. So as long as they can quickly get the hard part they'll be fine is a pretty weak argument for it being a good first language. 
yes, but most of them are "dangling" branches that have been around in svn for a while and can be considered dead. We will close them in the next days, probably. Anyway, I don't get why having a lot of branches is bad wrt mercurial
It is all a bit confusing, so here's a history lesson that explains how the pieces all fit together: Pylons: Pylons is a lean, non-opinionated web framework. "non-opinionated" means that it doesn't make many choices for you. It supports any number of templating engines, persistence libraries (ORM, etc.), form processing libraries, etc. You're a few layers above HTTP itself, but you still get to make a lot of choices yourself. It relies heavily on the PythonPaste WSGI development toolkit, which it is "on top" of. Pylons has been quite successful, widely used by people who want to do web development in Python with a lean but well supported framework. Ben Bangert, the author, has officially put Pylons in "maintenance mode" because he feels some of Pylons design choices have hampered the evolution of the framework. TurboGears: TG has billed itself as a "meta-framework". It's an attempt to construct a full-featured, relatively opinionated web dev framework out of a collection of smaller, more focused tools and libraries, with custom code to integrate these tools and to hopefully provide a smooth developer experience. The particular tools and libraries upon which TG is based has changed over time; TG2, which is backwards incompatible with TG1, counts Pylons among its dependencies. repoze.bfg: You didn't ask about this one, but it's relevant, so I'm including it anyway. repoze.bfg is an attempt to build a framework similar in scope to Pylons. It is a lean, unopinionated framework with a "pay for what you eat" philosophy. "Pay for what you eat" is a glib way of saying things should be fairly loosely coupled, so if there are features you don't need, you won't suffer performance or complexity issues from any code that may exist to support those features. bfg's primary author is Chris McDonough, a very active member of the Zope community for many years. As such, bfg makes use of some of the good ideas that developed out of the Zope ecosystem. (There are some who would say that the Zope ecosystem has never generated any good ideas. Anyone who would say such a thing is wrong.) Pyramid: As Ben was considering the design choices he had made in Pylons that were restricting its ability to evolve as he'd prefer, he began investigating all of the other web toolkits in the Python ecosystem, including repoze.bfg. He realized that bfg, in part due to some of the extensibility hooks stolen from Zope, had not made these same mistakes, and in fact had managed to provide a great deal of flexibility with a bearable amount of added complexity and, surprise surprise, no performance penalty. In fact, bfg consistently outperformed Pylons in handling requests, mainly b/c the call stack (i.e. the number of function calls that are made) for a bfg request is much smaller than that for a Pylons request. Thus a decision was made to merge their efforts. Pylons and bfg were both put into maintenance mode, meaning there will be no more active development for either of them in their previous forms. bfg was renamed to Pyramid, which is now a "Pylons project", in an attempt to take advantage of Pylons established and respected brand name. Additional features were added to Pyramid to support certain development idioms to which Pylons users had become accustomed. What would I use? That depends on the project. I don't love Django, for various reasons, but if I were going to do something in the "content management" space, or something well supported by Django's many available add-on packages, I'd definitely use it. It's the best choice right now, IMO, if what you want is a full-featured framework that gives you lots of functionality out of the box, and if you don't need to do any of the things that it's not good at. I'd also recommend Django to a novice; Django makes a lot of decisions for you. An experienced web developer like myself might not agree with all of those decisions, but a novice is likely to be overwhelmed by having to make them. Django will hold your hand a lot more than any of the other choices we've mentioned so far, I think. For anything else I'd use Pyramid. It's only an alpha, but since it's quite literally an evolution of the very stable and production-ready repoze.bfg, the code is mature and battle hardened. It's extremely well documented, the code is efficient and well written, and it has 100% test coverage. The community is helpful and friendly, the framework has momentum, and all in all it's nice to work with. TL;DR: Pylons is lean, light, and end-of-lifed. TG is more feature rich, is on top of Pylons (the latest version, anyway), future isn't so clear. Pyramid is an evolution of repoze.bfg, and is "the new Pylons", in some sense; it's officially a "Pylons project". I'd use either Django or Pyramid for a new project. If the project fit within Django's sweet spot, I'd use it, but I'd rather use Pyramid b/c I like loose coupling and leaner frameworks in general.
It might not be *bad*, but you just don't *need* that many named branches. You have local branches already.
Sounds useful. Wing will diff against supported VCSs but diffing against recent local changes would be nice.
I just used this a few days ago for a machine learning project. I needed to sort a bunch of newsgroup postings from 1993 (the 20 Newsgroup data set) by date/time, and this made it a snap: time.mktime(dateutil.parser.parse(DT_STRING).timetuple())
You're incorrect, both date and datetime have perfectly standard constructors. The additional factory methods are *not* the same thing. datetime.date(...) and datetime.datetime(...) (the actual constructors) do perfectly reasonable things and the factory methods both seem appropriately named (and ridiculously easy to remember - the time is now and the date is today...). On the other hand you *may* find some people who agree that calling the date / datetime constructors without argument should be the equivalent of .now() / .today(). By all means post a feature request on the Python bug tracker and see if other developers agree with you.
It would be helpful if you posted the error message and described why you think Tk is not installed.
db.prepare is all about exposing the native parameter style. I do think a higher level interface (named parameters) would be useful. fwiw, The dbapi side of the package supports named and positional parameters.
True. Pointers are hard and are rarely explained well. So maybe C's not that great. Also the whole ; thing is a pain in the ass for newbies. But you really do have to figure pointers out eventually. Even in a dynamic language like Python, it helps to understand what the stack and the heap are in order to understand when a variable's ref count is going to hit zero. So, maybe C shouldn't be a first language, but I still think it's OK as a second one.
&gt;when I try to do root=Tk(), it says I have an undefined variable Tk. I did post that. After Googling, I found that TkInter is pacakged with Python but tcl/tk may not be. Since I am getting an undefined variable for something that should be part of tcl/tk, then it could only be because I do not have tcl/tk. 
I said post the error message. Not a description of the error message.
It will be interesting to read about the mechanics of how they performed the migration. I notice on the new [PyPy project page at BitBucket](http://bitbucket.org/pypy/pypy/overview) the branches list is massively long, which looks like they were using 'feature branches'. This raises the question of how to manage feature branches on a large project. Is this list for all branches, or just open ones? It would be easy for release branches (big picture) to get lost among feature branches (small picture).
That is literally what it is. I get a red x next to the line that I type that on and when I hove over it, it reads: &gt;Undefine variable: Tk I don't know what else I could post for this. 
[MIT Open Courseware](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/) has an introductory computer science course that is delivered in Python. I *do* have programming knowledge but used this to a)learn Python and b)brush up on basics. Good stuff.
awesome, great job
I just started yesterday. I have some very basic programming experience and [Byte of Python](http://www.swaroopch.com/notes/Python) has been very helpful. Its simple and illustrates the basics very well. After that I'm probably going to go through some of the other suggestions here and then get down to solving my problem.
Lol, didn't realize you were hosting it from home :D Might be time for at least a vps.
Supports 3.x. Awesome.
Seeing as how they were using Subversion before Mercurial, it really depends on the version control system. Feature branches can be a good practice when using Subversion. However, I don't think these feature branches should necessarily translate into Mercurial named branches. As soon as you clone the repository you already have your working copy, which is a feature branch. If you need something more sophisticated, you can use something like the Bookmarks extension.
But are they running Mercurial *with* PyPy?
People really still want more of these things?
Do employers look at these favorably? In my experience, why waste the money when your work experience can speak for itself.
I don't when looking at resumes. About the only certifications that carry any weight for me are the Cisco ones, and even then it is only the higher level ones. If it isn't a CCIE, I want to either see some useful experience or better yet a code portfolio. Save your money, include your github profile link on your resume instead.
Actually we're not hiding closed branches well on Bitbucket. We're rolling out a fix for this in a few days.
I am EDIT: Argh, I was wrong, hg doesn't respect my virtualenv
I will alway advocate for the no GUI (command-line vim or emacs) approach, but it is not popular opinion. IDEs have tendency to hide some of the more painful details that give you a better picture of your dev environment.
There's little to call between the two tools. I would choose mercurial for its better Windows support, better GUI intergration and general nicer command-line interface. Bitbucket is also excellent (the main mercurial hosting service - vs. git's GitHub) with better terms for closed-source repositories. Other (minor) advantages of mercurial: no repo maintenance required (git repos need repacking from time to time), Mercurial queues (mq) extension, anonymous branches, built-in server for on-the-fly publishing. Advantages of git (as I understand them ... I not a regular git user): fine grained selection of what-to-commit (i.e. the git index - mercurial selection is file-by-file at it finest), I think gits design of its tag-implementation works better than mercurials. 
I hope they fix the c extensions now.
Hg has better UI but git has more powerful raw version control operations. Also re: hosting, use github. And yes you can use hg with github via hg-git.
To me it's really just, do you want to use Bitbucket, or Github? If you're not going to use either, they are so similar, that it really doesn't matter. You're thinking too hard about it.
Soon you have to make a second blog post called "Mercurial migrates to PyPy".
* Git has cheap-as-water local branches. Last I looked at Mercurial, a branch is essentially a clone of the repo, which is *not* the same thing. * Git's Windows support is pretty good these days. The GUI integration, while improving, is still lagging behind. * Git repos repack themselves these days. * Git is measurably faster.
&gt; Git has cheap-as-water local branches. Last I looked at Mercurial, a branch is essentially a clone of the repo, which is not the same thing. Mercurial's named / anonymous branch models are as cheap as Git's. Mercurial also has bookmarks extension, so you misunderstand how Mercurial works.
Here is a nice link of why git in general is a good pick http://www.markus-gattol.name/ws/scm.html#sec2 I realize it's not directly git vs hg but then I figure it can only help you figure out the best solution for you.
&gt; * Git has cheap-as-water local branches. Last I looked at Mercurial, a branch is essentially a clone of the repo, which is not the same thing. You should look again, this is no longer true.
&gt; However, I don't think these feature branches should necessarily translate into Mercurial named branches. Why?
yes, but so far all the named branches come from svn. For the future, I think we will experiment with various workflows until we find one which satisfies us. Speaking by myself, I like to keep the whole history, including the one of "bad" experiments which are not merged
I prefer mercurial for 2 reasons: 1. It's easier to learn - you just use it, while with git you have to actually understand what it does underneath to use it effectively. 2. TurtoiseHG - designers don't use Linux and this is (about) the only way you can get them to use DVSC. I also don't see github being (much?) better than bitbucket. Now that bitbucket is with Atlassian, you have unlimited private repos. Bonus: It's written in Python. :)
&gt; fine grained selection of what-to-commit (i.e. the git index - mercurial selection is file-by-file at it finest) The [record](http://mercurial.selenic.com/wiki/RecordExtension) extension is bundled with mercurial. "This command lets you choose which parts of the changes in a working directory you'd like to commit, at the granularity of patch hunks." 
&gt; mercurial selection is file-by-file at it finest This is not quite right. Mercurial can select what to commit on a hunk-by-hunk basis. However, the git index gives you a bit more control to split a hunk or otherwise edit a patch.
http://mercurial.selenic.com/wiki/CrecordExtension gives you ability to select line-by-line and also has nice curses interface
Mercurial also has [revsets](http://hg.intevation.org/mercurial/crew/help/revsets), which are better than git-rev-parse, and better ability to format data outputted - templating versus printf-style formatting in git.
I tried to answer that in my second paragraph. It unnecessarily clutters up the branch list. Why do that when you have other (better) options?
the current list of branches comes directly from the svn hisory (which is 7 years old). We decided to have one named branch for each svn branch, not to loose any history
Understanding how Git works? I'm not so sure about that. I just read [this](http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html) and it all works.
&gt; yes, but most of them are "dangling" branches that have been around in svn for a while and can be considered dead. We will close them in the next days, probably. I understand that, I think a1russell's point was mostly that they could have been pruned/stripped during import. &gt; Anyway, I don't get why having a lot of branches is bad wrt mercurial It's not bad, it just makes for a messier listing, especially when (as is the case in pypy) most of the branches are dead.
I was facing the same dilemma a few months ago. After some research it occurred to me that there's really not much difference between them - both are excellent tools for the job. So I chose Mercurial because it's written in Python.
Thanks for clearing that up.
Nope, sorry. Since 1.7, we hardcode the library path where Mercurial was installed into the ‘hg’ script and insert that into sys.path before loading the libraries. The motivation for this is that Mercurial first and foremost should be considered a command line tool; the fact that it's implemented in Python is of less importance. Prior to 1.7, installing Mercurial in a custom location would require setting PYTHONPATH. Now, you can install it wherever, and Mercurial will do the right thing itself.
I'm not a heavy user of any (used to work with Pylons, but since Pyramids I'm re-evaluating). Thing is... I don't understand the hate on the GPL. For this kind of work, the GPL is pretty much "the licence" I would expect. For some reason, everybody wants to make a spin-off framework now and keep the derivative work closed? The GPL seems to fit this kind of work perfectly. It's exactly what the GPL was thought for. It won't affect your applications AT ALL.
Personal opinion: because people have a very limited understanding of OSI licences. This may lead to a "good impression", but really it shouldn't make any difference in the case at hand.
If you're doing any serious work you'll surely hit the ton of quirks that git has. And when it comes to having ways to break your repository or lose work - git offers you a whole arsenal to shoot your feet with. With mercurial you can't lose work - the history is immutable. (well, you can - if you use *some* extensions, but fact is, fiddling with history is discouraged and disallowed by default - and I find that important) 
Could you talk some more about git quirks? I mean, "ton" is a pretty bold statement.
Git seems to be winning the war. Regardless of any technical advantages of one over the other, I'd pick the winning horse if I were you.
Unfortunately, no-one is, as Mercurial doesn't work in PyPy. In the past, no-one has bothered to run Mercurial with anything other than CPython: none of them really had much to offer. As a result, Mercurial implicitly relies on how CPython manages memory by using reference counting. When a file handle is no longer referred to, it's immediately flushed &amp; closed. With PyPy, you get a transient leak — of sorts — where the file handle is kept open for a short while before being closed. This causes all sorts of breakage, and can even exhaust file descriptors, causing Mercurial to immediately abort. I have some patches to address this that are pending review, but there are still a few outstanding issues which prevent PyPy from running 'hg verify' on the Mercurial repository itself. My hope is that I'll get it to work before the next major release of Mercurial, but no promises. Finally, there is the point as to why you'd want to do it. I can't really think of any reason other than a PyPy developer wanting to eat his own dogfood. Mercurial has been heavily optimized for CPython; for example, some hot loops cache built-in functions in local variables to avoid costly global lookup. The core logic has been implemented as heavily optimized C code, with optional pure Python fallbacks. Benchmarks on my Mac suggest that running 'hg verify' in pure Python with PyPy is approximately twice as slow as doing it in CPython. As expected, the optimized C modules provide only a slight speedup with PyPy. I'd like to be able to run Mercurial on PyPy, but unfortunately, there aren't yet any advantages to doing so.
This is so true. I think there's not much practical difference between the two tools, but if people coming onto the project are more likely to know git then that's the deciding factor for me. Only hg thing I miss when using git is how it can tab autocomplete for filename parameters.
Small suggestions: Tab width = 4 Rename constructor parameters. Coin toss should decide who goes first and that player will be 'X' CPU should be COMPUTER boardinit can be: return [[BoardCell(i, j, (i+1) * (j*3)) for i in range(3)] for j in range(3)] 
Nose is awesome.
Although jm_ is for some reason being downvoted by expressing his opinion, my experience is similar. Git is awesome... until something goes wrong. At this point, the tools become rather mysterious. I've used git for a year after being a RCS/CVS/ heavy Subversion guy for 20 years. I(used to) go in phases of git being awesome, then cursing at it until I fix it or someone helps me out. After a year, I love Git and would never use anything else. I've used Mercurial some and quite like it. Fast like git, easy learning curve like Subversion. But Git, like a database, gives you some incredibly cool and *useful* tools. I suggest using both, putting one smallish project in each camp. Once you have enough experience to pick one or the other, you can migrate the history, or just toss it and import the flat file tree.
&gt; Finally, there is the point as to why you'd want to do it. I can't really think of any reason other than a PyPy developer wanting to eat his own dogfood. And testing how hg (especially in pure mode) responds to the JIT.
Most of the pypy branches are not marked inactive (yet?) so the impact will be limited: fast-forward 39529:ae12768dbfbd default 39527:0c24ef1bebbc out-of-line-guards 39497:55d92d35c5b4 jit-unroll-loops 39495:c9e8ed0461c7 arm-backend 39494:9c2aca640d70 jitypes2 39482:6f6dc96c294b fast-forward-darwin 39421:c3ad518be64b inline-shadowstack 39353:591df60495cf freebsd-compat 39299:e3c3cf3e700a 1.4.x 39210:7a4f79c299da gdbm 39201:e55f434a9021 reflex-support 39154:b90828c4445c psycopg2compatibility 39123:74abc57530af spaceop-sep-classes 39077:edda6f9d13b1 jit-free 39029:e7245843a068 smalllong 38810:b0d7d2fb042a ootype-virtualrefs 38692:56dc2fe0ef46 32ptr-on-64bit 38514:84598e81707c jit-profiling 38140:5a6fee6f24ea minimark-jit 38121:dfcd7b5612cb jit-str 38105:09b2cd5f94e1 jit-loop-invaraints 38039:3dee5e35ea94 micronumpy-resync 37867:d534f73ae390 gen2-gc 37863:62a63ef67d8b unicode_filename-2 37263:99fcff9922db 1.3.0 37059:6b9dc457b750 cpyext-init-cleanup 35851:98a287f0385b fast-ctypes 35751:e0dd3b956cb9 multilist 35485:53f260952156 jit-stackless 34958:28988600e36d dist 33426:d471900af1a3 jit-constptr 33349:53700bafa2a7 unroll-safe-if-const-arg 32818:7857f9ac8b0e bridges-experimental 32714:0546d3d51f6b separate-compilation 32675:fba9888eaec4 micronumpy 32560:14cbc93ae4e9 sepcomp 32301:74f1e741f7bb cli-jit 32119:305aba08bf03 avm 31545:1cfacef15177 gc-arena 31265:3de710b834b1 unicode_filename 28022:fa190204bf9b run-django 25002:a0f247016b2c eval-loop-experiments 24487:a1118947f49a build-external 24400:7a32d1f65c1c oo-jit 23944:ccec386587b5 ctypes-stable 23407:9456fedf0b76 1.0.0 17843:d6acb4ed9d3c 1.0.x 17840:c7d1ccbd57b5 0.99.0 16724:99e82f3da507 0.6.x 14647:466d18cb3de3 0.9.0 12245:80a81975cd0f dist-ext-someobject 8527:4dfbdbf89444 0.8.0 8068:df2fef0b5463 pypy-0.6.1 7518:f6bf9b60f9c1 0.7.0 7516:a3a3e0cc9eef 0.7.x 7515:a7bcd2a835ab pypy-0.7.0-beta 7512:9150d7544715 0.6.1 4405:ce2a17ee1db8 1.3.x 36842:b57d2be3d4a7 (inactive) 1.2.0 33425:118b826008e5 (inactive) 1.2.x 33222:0d8825b8f377 (inactive) 1.1.0 28529:916de73ff7a4 (inactive) 1.1.0beta 27886:20ae6119f7fd (inactive) 1.1.x 27884:cea45b491bf7 (inactive) 0.99.x 16602:70ebbf5eff5b (inactive) 0.9.x 12243:3d172f4365a0 (inactive) 0.8.x 8065:d2955dbc52ba (inactive) 0.6 4402:db6775c79405 (inactive) 
Thanks for the suggestions. Really appreciated. But I think I'll stick to CPU for this one. :P
[Am I doing this right?](http://i.imgur.com/swlsL.png)
I'm curious why you ended up writing so many lines of code for detecting a win condition. First time writing Python code?
&gt; Git’s model is fundamentally fairly simple (a DAG of immutable commit objects where branches are named mutable pointers into it), but *you are expected to understand it fully* to use git effectively. [Credit](http://blog.nelhage.com/2010/01/on-git-and-usability/) 
My 2c: * Use more descriptive variable names. * Function isin can and should be: return val in list * But it can also be (if you reverse the order of operands): from operator import contains as isin * Clearing the screen like this is not only annoying, but also bad practice. Use ncurses. * Functions checknum and getwnum are unnecessarily ugly, both could be simplified by looping over a proper data structure. * Function tgame should return the winner or None when the game ends in a draw. Hence, attribute Player.won is useless. * Similarly, Player.first is a flag more related to the game state than to the player and as such could and should be gotten rid of. Either use a third argument to tgame signalling that the cpu should go first, or better, fix your game loop. edit: * The way you take user input and only accept given choices should be factored out into a function. 
another suggestion: instead of comments above function declarations, use [docstrings](http://www.python.org/dev/peps/pep-0257/). In drawboard, you might want to check out some more advanced [string formatting](http://docs.python.org/library/string.html#format-string-syntax). You can do something sort of like Python 2.7: #TODO get all of the cell contents into a single array boardStr = " {} | {} | {} ".format(*contentsArray) Python 2.6: boardStr = " {0} | {1} | {2} ".format(*contentsArray) ... and so on. It will probably be easier to read, and more closely matches the idea ("draw a board / with each cell filled in with its contents").
Maybe it's just me, but having gone through the (albeit well-written) Pyramid docs I can't help thinking how over-engineered it is: 1. Three different kinds of configuration - imperative, "scanning" (decorators) and ZCML (!). What's the advantage of using an XML format in a Python framework of all things ? Why not just have one way to do it ? 2. ["Models"](http://docs.pylonshq.com/pyramid/dev/narr/models.html). I've read that document a few times and I'm still confused. They're sort of "models" but not ? Why would I use this pattern ? What the hell do I need all that Interface boilerplate for ?Again, no real explanation of why I should use this; it reminds me of a Java framework, "do X, Y and Z to do this, just because". 3. Configuring views. Tying up configuration with the output template seems kind of wrong. Typically the decision to return a template/redirect/JSON or whatever should rest entirely inside the view callable (as it does in a Django view, for example). I can't see what it buys me to be able to configure this elsewhere, other than making the code harder to maintain. I'm sure all this fits nicely together, and maybe I'm just plain stupid for not getting it, but there's a lack of examples to really see how it all works as a complete whole. The framework perhaps wins points for architectural purity, but seems hugely over-designed compared to the conceptual simplicity of Django, Flask or Pylons. I'd really like to see an example (a blog app or something) that shows the advantages of Pyramid's architecture, because I really can't see it.
Name it PyTacToe ^_^
idk what could be easier than git. It is basically 2-4 commands and you are golden. 
I'm just a messy coder. But, as you can see, I'm interested on how people look at those and suggest improvements. From that I can improve..
Mercurial is not [dead](http://www.google.com/trends/viz?q=mercurial,+git&amp;date=all&amp;geo=all&amp;graph=weekly_img&amp;sort=0&amp;sa=N) :-) Edit : Red Git Blue Mercurial 
The change-log seemed oddly difficult to find (although I was probably missing something obvious...), http://somethingaboutorange.com/mrl/projects/nose/1.0.0/news.html#detailed-changes &gt; 1.0 &gt; &gt; Made nose compatible with python 3. Huge thanks to Alex "foogod" Stewart! 
No legend?
Fancy! There is also an [Inventing with python](http://inventwithpython.com/chapter10.html) chapter with tic tac toe if you want some code to compare to.
&gt; Use more descriptive variable names. Agreed. From a quick scan I saw loads of abbreviations. Remember that code is 'write once read many', so it's worth the extra few keystrokes. A decent text editor will auto-complete long variable names for you anyway.
You are asking in the wrong place -- mercurial is written in python -- so there will be bias for sure. Some projects like Python(the main one) are moving to mercurial than git only because git is not that well on windows, so keep that in mind. IMO git is better in terms of performance for one thing -- sure it has a learning curve but it is worth it and there are plenty of good tutorials on interwebs.
Many version control systems don't let you change previous commits. Git does. It's pretty hard to do this by accident (unless you type --amend a lot for some reason) but it does present an opportunity for trouble. Can be convenient, too, though. You forget to commit something which should have been committed, it's fixable. 
Both are rather similar, both on the beginners level and on the advanced level it seems. Mercurial has TortoiseHG with context menu integration (which I dislike), git has gitk, and I kinda enjoy working in command line even on Windows ([Console2](http://sourceforge.net/projects/console/) is your friend). I've used Mercurial for about a year for my personal projects, then tried git and am now switching. It's not because of features or bugs or speed or anything, it's my __subjective__ feeling: it feels like HG guys wanted to make a world-class DVCS while Linus wanted to develop Linux kernel. As a result, git feels much more polished where it is needed and stays out of my damn way otherwise (no need to install and enable extensions ("batteries included"), there's one obvious and true way to do anything (so no tens of extensions which kinda do something kinda like rebasing), also `gitk` is nice and installed by default). I repeat, it's my subjective feeling, everybody else should try both things and choose what they like best.
seems to be some zope legacy , I puke every time i see the ZCML or the template language from plone or the zopedb and it's orm plone world :Also nothing seems to be stable , when one thing is done they change everything and over engineer it I prefer the django way , easy access to core sql in cases i need some weird joins and the template is OKish for me (I come from a php world of cake, and sometimes simple echo style apps) Django seems to be created by people who understand relational systems zope/plone seems to be from another world : orm with no contact with real life but pyramid seems to be different bending towards rdbms storage (see at the end) http://docs.pylonshq.com/pyramid/dev/narr/introduction.html 
Sweet now I can apply to that Cox media job who requires me to write a tictactoe AI before applying. 
 # Checking if a value exists in a list def isin(val, list): if val in list: return True return False *bashes head against wall* Also: `if wep == cwep:` ` num == 0`
One interesting thing you can do in otherwise boring project is: primes = {(0,0): 2, (0,1): 3, (0,2): 5, (1,0): 7, (1,1): 11, (1,2): 13, (2,0): 17, (2,1): 19, (2,2): 23} win_states = [2 * 3 * 5, 7 * 11 * 13, 17 * 19 * 23, 2 * 7 * 17, 3 * 11 * 19, 5 * 13 * 23, 2 * 11 * 23, 5 * 11 * 17] def check(players): for p in players: for i in win_states: if p.state % i == 0: return p.weapon return False Each player will have self.state = self.state * primes[move] EDIT: This is one of the ways to check if there's a winner. 
What?
Mercurial has a good windows story right now. Visual Studio integration and HGTortoise are great. Having the core and extensions written in python instead of a mix of half of unix makes it nice to work with and port the source code.
Why not just use http://bitbucket.org? Much better than github in my opinion (and is built for hg). It also offers unlimited public and private repositories.
It's not going to land you a job, but it could very well get you past the first round of sorting through resumes. And if you've been laid off for any length of time, it could be a huge plus. It would show that you've actively maintaining your skill set rather than letting yourself get crusty.
My suggestion is to spend an few hours with the following: **Mercurial** http://hginit.com/ http://hgbook.red-bean.com/read/mercurial-in-daily-use.html http://blog.medallia.com/2007/02/a_guided_tour_of_mercurial.html http://www.ibm.com/developerworks/aix/library/au-mercurial/index.html **Git** Scott Chacon Git Video Series http://chacon.blip.tv/posts?view=archive&amp;nsfw=dc Git in One Hour: http://oreillynet.com/pub/e/1394 http://hoth.entp.com/output/git_for_designers.html IBM Git Basics Article http://www.ibm.com/developerworks/linux/library/l-git/ Git Reference http://gitref.org **Source Control Links** Intro to VCS http://betterexplained.com/articles/a-visual-guide-to-version-control/ Intro to DVCS http://betterexplained.com/articles/intro-to-distributed-version-control-illustrated/ http://www.ericsink.com/scm/source_control.html Set up some dummy test cases to get familiar with the operational flow of both DVCS tools. *********************************** **DVCS Tools (Windows)** **Mercurial** http://tortoisehg.bitbucket.org/ **Git** http://code.google.com/p/msysgit/ http://code.google.com/p/gitextensions/ http://code.google.com/p/tortoisegit/ *********************************** MTA: Blip.tv Link 
I'm seeing one persons opinion, expressed almost an entire year ago. I'm not seeing official documentation saying I'm *expected to understand it fully* in italics. Let us not forget we're talking about *distributed* version control, not RCS, having a basic idea how it works is a requirement for any VCS.
Personally, I could suffer with git quirks and hacky UI. But I'm not explaining it to other people... So it would be mercurial until some writes a redesigned git UI (not gui -- command line).
&gt; You are asking in the wrong place It's also the wrong place because it has nothing to do with Python
He's playing with math. Because all the positions are prime numbers, any sequence of multiplications will result in a unique product only divisible by each position's prime number.
Have you tried typing the commands directly into the Python REPL? import Tkinter #tkinter if using python3.exe root=Tkinter.Tk() #Should pop up a window **Start run cmd.exe ** **at the prompt type python (or python3 if 3.x python is installed)** If python doesn't show up, edit your PATH variable to add the directory were the python executable resides. 
http://docs.pylonshq.com/pyramid/dev/designdefense.html explains (or apologizes for) some of the things you mention above. "Models" are slated to be renamed soon (perhaps to "resources" or "nodes"), to prevent confusion. As the documentation explains, you don't actually need to use interfaces; it's a rarity that you do, you can use the class instead if you want to limit a view to being rendered for a particular kind of object. You can also just use "url dispatch" (ala Pylons routes or Django urlconf) and not even think about "models". Turning template choice into configuration instead of making the view callable render the template itself means that you can a) use the same view callable with different templates/renderers (perhaps a Mako template and a json renderer) and b) you can unittest the view callable more easily, because it will typically return a dictionary instead of HTML. Of course you *can* just render a template inside a view callable without naming it in the view configuration via http://docs.pylonshq.com/pyramid/dev/api/renderers.html#pyramid.renderers.render_to_response and friends, just like you might in Django. http://docs.pylonshq.com/pyramid/dev/index.html#sample-applications is a list of sample applications.
Mercurial has serious speed issues on larger projects. It takes me 45 minutes just to pull a 150MB project. This is with a local server and a quad core. Large commits take time also, so if you modify a lot of files (like 75+) in one commit it is quite slow. Cloning is also terribly slow unless your project has only a handful of files. One thing I can say for mercurial is that it has Windows support, if that is important to you. With Redmine I've had issues on ruby 1.9 (I know, it's unsupported with Redmine) where it will slowly consume more and more resources to the point of hanging apache and the box so you have to keep an eye on it. 
You're not the first person to make criticisms about Zope relations: http://docs.pylonshq.com/pyramid/dev/designdefense.html Pyramid uses some Zope libraries. It does not depend on ZODB, nor are you required to use ZPT (Mako and Jinja2 are supported). It supports a style of application creation much like Pylons. 
Looks about right!
Because a large factor in the usefulness of these sites is the social element, and a lot more of the Python community uses gtihub than bitbucket. Bitbucket has improved since the acquisition, but historically it was much slower and was down more frequently. Github has made it clear they are committed to keeping hg working with their site, which is why they wrote hg-git in the first place.
I really dislike git branches. Git branches seem to act as separate repositories within the same depot, so you have to treat them that way. When you push code, you only push code for the active branch, for example. Mercurial just seems to handle them so much better.
Bookmarks cannot be cloned from repository to repository. I am not aware of a way to name or tag a branch in Mercurial that: 0. Can be used as a temporary name for a topic branch 1. Can be cloned or shared with others Named branches live forever in Mercurial and unnamed topic branches are utterly useless to other developers to indicate what the topic branch is for.
I wish Mercurial had a way of, perhaps, "Archiving" a branch or even series of commits, so that you don't download them normally when you clone, you'd have to request the full history.
Fixed it.
You say you disagree, but you don't, because you talk about something different. coderanger mentioned that the certification doesn't carry any weight when he's looking for people to hire, and you say that you wouldn't rely on it, which is basically the same thing. What you added was that the program was useful for you in learning Python.
And now, on to nose2 ... 
&gt;Function isin can and should be: &gt; return val in list How is `isin(1, t)` better/clearer than `1 in t`? It's not, IMO.
Thanks. TIL. I struggle working with git but I've only gave hg a short glance since github is just so awesome. I hope this changes that. 
Don't use an IDE, but do use ipython, which is a better interactive environment than the basic "python" interpreter. It gives you easy completion of function names and text coloration among other things.
Dictionaries are used like textbook indexes, to look things up quickly. Let's say you wanted to count how many times each word appears in a document. You could loop over the words in the text and, if they're not in your dictionary yet, add them with a count of 1. If they're in the dictionary, you increment the count. A lot of the math in computer science is about understanding how much a program will slow down as the input gets bigger. Dictionaries are designed to allow you to look up an item quickly regardless of how big the dictionary gets. Imagine instead if we solved the word count problem by keeping a sorted list of words and counts. Every time we saw a word, we'd have to search the list of counts for where it belongs, and insert it if it's missing. The search process gets slower as the number of words in the list increases. Eventually the whole word-counting program would bog down as you tried to add more text. 
&gt; You can also just use "url dispatch" (ala Pylons routes or Django urlconf) and not even think about "models". I'd suggest toning down the language "References to [Models] classes and instances of such classes are omnipresent in Pyramid" to something more like "Models are a key concept when using *Traversal* to resolve URLs".
The course material is by Steve Holden, a very experienced Python developer and trainer. The course material will *undoubtedly* be worth the entrance fee and whilst I'm *personally* sceptical of the value of certification I can see how it might be useful in some corporate environments.
Failure. That is like script kiddie vs. programmer talk. Not knowing what you don't know and stumbling through things is really bad practice.
Ah thanks for the explanation :)
I'd be fascinated to know what you think those 2-4 commands are. I gave up on Git and switched to Mercurial precisely because everyday use of a DVCS *should* only require knowledge of a small number of commands representing quite simple ideas, yet I was never confident that I was doing the right thing with Git and all its similar-but-not-quite-the-same operations. I managed to actually break my Git repository system several times (though I later learned that some of the time it wasn't really broken but appeared to be so due to a bug in the then-latest version of Git) and never did find a simple, productive workflow. Mercurial, on the other hand, Just Works for me, and has the added benefit of being more pleasant to use than having your nails ripped out with pliers if you run Windows, particularly if you have TortoiseHg as well.
have you tried git push --all? &gt; Instead of naming each ref to push, specifies that all refs under refs/heads/ be pushed. 
this is either a troll post or you're sorely misinformed. gits history is immutable as well (it's almost the whole point!). if you do such things as rebase or accidentally amend or something, you get an "alternate history", but the old one is still there. just use the reflog to rewind your branch to "5 minutes ago" or "2 changes ago" or whatever and you're golden! edit: clarification
PyCharm is a great IDE though. It doesn't do anything too crazy, but has a lot of things integrated well, like version control and code completion. I use it daily, and love it.
Well, hg-git is not well maintaned right now. Actually current maintainer (which is not from github) doesn't have a lot of time to put in.
I didn't say there weren't ways to use them, I just said that I dislike how branches are essentially largely disjoint entities. I like how branches are highly integrated into codelines in Hg.
ipython is what I was looking for, thanks!
&gt; Bookmarks cannot be cloned from repository to repository. They can.
It is a good idea to use 1 and 4 as values for marking cells - think about it ;-)
&gt; Git is measurably faster. Well, certainly not on Windows.
Also GUIs like hgtk which is widely used, has it built in.
Saying "the zopedb and it's (sic) orm" only shows that you have no idea what you're talking about. The ZODB is an object store, much more similar to the (currently quite vogue) "NoSQL" solutions like CouchDB or MongoDB than it is to a traditional SQL database. There's no ORM there, because there's no relational data representation to map to. ZODB is solid technology that would be a fine choice for a number of applications. Don't get me wrong, I think there's lots to complain about in the world of Zope and Plone. But just because something doesn't fit within the patterns of your limited experience doesn't necessarily mean that it's crap. It just means that you don't understand it.
The dominance of github over bitbucket is enough of a reason to make me consider migrating all my projects from bitbucket to github. And while in my experience, mercurial is actually significantly slower than git on large projects, it's not that much of a problem. Bias alert: As someone who does kernel development, I kind of have to use git... 
Orly, $1200 for an O'Reilly certificate. Those suits need to come the fuck down and stop trying to print money. 
Well, this simply isn't true. I just did a clone of big project with a lot of files via LAN and it did it in 1m 30s. This is for 60mb (excluding working copy) repository.
Do `hg clone -r default` then?
Where does the ".. omnipresent .." quote come from?
 &gt;&gt;&gt; import json &gt;&gt;&gt; print json.dumps([1, [2, 3, [4, 5], 6], 7, [8, 9]], indent=4) [ 1, [ 2, 3, [ 4, 5 ], 6 ], 7, [ 8, 9 ] ]
Looks like much of those packages are deleted from PyPI, but still available in [PyPM Index](http://code.activestate.com/pypm/search:nested+list/).
&gt; with git you have to actually understand what it does underneath Based on what? Every freely-available video or text tutorial I've seen has been sufficient to get a benefit.
One thing that hasn't been mentioned yet, on line 117: coin = ['Heads', 'Tails'][random.randrange(0,2)] is better written as coin = random.choice(["Heads", "Tails"]) :) 
I'm on my iPhone at the moment but that was the first line from the "models" link referenced above...
How are you cloning? Over ssh it has always been slow for me.
&gt;Only hg thing I miss when using git is how it can tab autocomplete for filename parameters. This works for me using git, so maybe your bash profile got screwed up.
Time will tell :)
Does it not try to win? I thought it was going to be a stalemate every time I went first. | | O | O | X | | ------|-------|------ | | | X | O | | ------|-------|------ | | X | | X | | WINNER: User (X) Moves: 4 Record: User: 1 CPU: 0 DRAW: 0 Play again? [Y]es or [N]o: Y 
[Pyglet](http://www.pyglet.org/) is the main Pygame alternative. The primary docs are much better for initial learning (but they're not as nice as Pygames for "I know there's a function to do this, but I haven't used Pygame in three months so I don't remember the name or the arguments"), and the secondary documentation (tutorials, other project's source code) isn't as good: Pyglet is newer and not as commonly used as Pygame. Still, I'd give it a try. 
I made videos for my game programming class using Python: http://synapse.cs.iupui.edu/Mediasite/Catalog/Front.aspx?cid=6d8a3243-451c-460c-8c15-fff771bc51f5 They go along with my book http://aharrisbooks.net/pythonGame/ You can use the examples and videos without the book, of course. The first few chapters are just a review of programming and Python, and then we get to the gaming content. See if that helps. Drop me an email if you need more help...
Yes, which 2-4 are those? If you're working on your own, without using branches and you ignore the index, then you can probably get away with `init`, `commit -a`, `log` and `diff`… But `diff` counts as six commands because of all the options it takes (and because you've got to know about the [crazy index](http://www.ericsink.com/entries/git_index.html) for `diff` to be useful).
I tried browsing through your book looking for the answer for this question, but since it's all .ppt I couldn't find it easily. Do you use any public library like Pygame or Pyglet? 
Thanks for the suggestion, I'll look into it.
Meh, not really. I use Mercurial with Github via `hg-git` all the time. Also, I would disagree that "they are so similar that it doesn't really matter". In theory, yes: they are both mature, dag-based, have lightweight branching, and a good community. But in practice, as many of the other commenters have mentioned, the UI couldn't be more different. For example, to clear out any uncommitted changes in your repository, the git command is `git reset --hard HEAD^`, while the Mercurial command is `hg revert --all`(which also backs up any changed files, something git doesn't do).
I didn't know about the O'Reilly Online Certificate programs. My employer requires us to set at least 2 goals for ourselves each year. They also reimburse up to a certain point for educational/certification expenses. So while you can put down "update documentation" as a goal, choosing a certificate is a popular choice. So while I'm already planning on taking my VCP in Januarry of 2011 and completing my OCA (already took the 1Z0-051, just needthe 1Z0-052) for next year, I'll keep this in mind for 2012. One thing my company is looking to do is institute quarterly goals. A 4-part course like this would play nicely into that scenario. On the other hand, I have been wanting to learn Python for a while and have plans on going through the learnpythonthehardway.com PDF. However, if I could get my work to pay for the 4 courses, I might just consider that.
panda3D. good doc. largish community. 
http://inventwithpython.com A free book aimed at total beginners on how to program by making games.
I second this. Active development and has been used in commercial products as well. It was pretty easy to pick up when I was playing around with the basics of it.
There is no reason to make it as complicated as that. If it is just basic web gui you can just use SimpleHTTPServer/CGIHTTPServer. If the webserver is just a thread in your application, the additional memory usage will be pretty minimal. Even if you need more of a web framework, it really won't be worth the additional complication. It could even be worse peak memory usage because when it does need to hit the webserver it will have the webserver, the proxy, and the client all up at the same time instead of just the webserver and client.
Got it. Fixed in the trunk, thanks.
Thanks for the reply and references. I don't want to come across as over-critical - it is a well-written, well-documented framework. However it seems to have a large number of options and moving parts which seem to be there for legacy reasons, rather than simplicity and practicality. I'm not entirely convinced that mashing together two different frameworks with different philosophies is a good thing. That all said, it's clearly still under development and probably worth another look in the near future. 
You're overengineering. IMHO, you should always build your program the "easy way" first. If your memory requirements are that intense, you can always build your proxy later. But more often than not, the easy way is the right way. In this case, I strongly doubt that a web server that isn't handling any requests would take up more memory than a proxy that you would have to create.
Thanks!
By the start of 2009, Git was measurably faster on Windows according to my own investigations. Perhaps things have changed since then?
&gt;IMHO, you should always build your program the "easy way" first. If your memory requirements are that intense, you can always build your proxy later. This is how I normally design things, but this is a "first impressions count" sort of situation, I'm worried that if I deliver a 1.0 that is seen as being too wasteful, the users will uninstall and not wait for a 1.1 that fixes it. But yeah, with two "go simple" comments I'm probably just going to drop the proxy idea and just use a simple webserver (that restarts after some period of inactivity to free some used up RAM)
I have your book! I wrote the Apress Pygame book. To the OP -- the pygame docs aren't the best, but the community is fantastic.
As I understand it, I don't know if they can upgrade or not.
This wont help you free RAM. The OS will happily page out memory when it is not in use. In effect, you already have the behaviour by default that you are talking about building.
I have the feeling that git is more reasonable for small teams but mercurial with bitbucket is really making some steps these days into becoming the major corporate DVCS.
I like the phrase 'written with people's feet.' Consider it stolen. 
I'd put Dive into Python away for now. The book is designed to introduce Python to people for whom Python is not the first, and most likely not the second programming language. Just as others suggested, "Learn Python the Hard Way", is a good place to start, combining it with "Learning Python" will give you strong fundamentals, then you can try approaching "Dive into Python" if by the time you're done with the first two you don't have a project in mind.
Yeah I am learning with Py the Hard Way right now, and will probably pick up Learning Python simultaneously. Right now I am making good progress and I have a project in mind which I will split up into different steps, what I was thinking of doing is a web music player, using gstreamer then after that, trying to use audio from youtube videos, this should be easy I think since I can skip including the video part and just use the audio encoding sans video, the final project is more advanced than this and these are just the simpler parts of it all. 
Basically it goes like this for me: hg for hg, git for GitHub.
How would you do this in mercurial now? topic branches were a big part of my git workflow and now that I'm using hg at work I've stopped doing it because there didn't seem to be an easy way. Do you still need to use an extension? Bookmarks?
I don't know mercurial's revert behavior, but if you want to back up your changes befor resetting git to the current HEAD, you can either use ``git stash`` or create a new branch, commit your changes into that and switch back. ``git reset --hard`` is dangerous and the documentation states that very clearly. 
That may be the case, but when I've asked git people how they would do what I described, they usually say `revert --hard`. Also, yes, it is *possible* to "backup then revert" with git… But it's not *the default*, which is my point: by default, hg general does the "helpful thing" (in this case, backs up your modified files) where git doesn't usually do the "helpful thing" by default.
Does anyone know if a feature like git's reflog exists in Mercurial? I really love git's ability to recover from almost any OH-SHIT-moment.
Sure. We can definitely do better on docs. FWIW, there are a number of reasons that mashing together two different frameworks with different philosophies *is* a good thing: - The philosophies aren't *that* different. Only the way that URLs are mapped to code is different. The rest of the frameworky stuff is largely identical and pointless to reinvent for N different frameworks. - Although you may not need traversal or URL dispatch right now, you may find yourself needing it later; if you use Pyramid, you can get it without throwing out a bunch of other knowledge you've gained. Using URL dispatch (routes) usually requires less thinking. But using traversal has an advantage when you're looking to build sites where a) URLs matter and your URL space needs to be extensible as people add more subsections (a URL might be "N" elements deep) or b) your site structure mirrors your "domain model" (data model) or c) you need to build an application which is extremely extensible ("routes" fall down here because they require ordering, while traversal does not). - Combining two into one means less support burden for each framework author. - Combining two into one means less confusion for people who want to choose a web framework (repoze.bfg and Pylons were quite similar in scope). - Eliminating competition between the two competing frameworks makes it possible to market the single combined successor better. - Combining the two without loss of functionality means that people who used Pyramid's predecessors (Pylons and Zope people) can now work on the same platform instead of shooting at each other across some imaginary DMZ and endlessly building competing implementations of the same concepts. The Python web framework world is still "a community divided by a common language." We're trying to reduce this division by working together rather than competing. 
Yes, It will page it out, but it most likely won't free it. So if they ran the web app bit for 10 minutes and it used 200mb of ram during that period, then they stop using it for five hours and then check their task manager, I want them to see "10mb" because of the always-running bit, not the 200mb of paged out memory. It's not a problem, they're not really wasting that much memory, but like I said: First impressions. Even inaccurate bad first impressions are still bad first impressions. 
Cannot recommend this enough.
``stash`` seems to do the exact same thing. It creates a backup and reverts your working directory to your latest HEAD.
These are good points. One suggestion is that the Zope-y/ZCML/Traversal stuff is relegated to another part of the docs. Most people coming to Pyramid will be either ex-Pylons developers looking to migrate over, or Django/CherryPy/whatever developers taking a look out of curiosity. On seeing the reams of XML and zope.interface code they will bug out, quickly. This may be terribly unfair - as was my original comment - but first impressions really do count. For people coming from Zope/Plone/Grok/BFG - which I suspect will be a smaller number - have a link to guide them to the "Zope" part of the docs. 
This is already mostly true. ZCML has been relegated to a separate "declarative configuration" chapter at the end of the docs. The "reams" of zope.interface code of which you speak is mostly relegated to the "Hooks" chapter. No developer is required to understand interfaces. They are an implementation detail of the framework that a developer can choose to use if he wants. Traversal hasn't been relegated anywhere. This will likely not change. We are trying to improve the cohesiveness of the docs in the meantime, and hopefully we can do a better job of explaining it. You'd probably be surprised at the percentage of "potential" Zope vs. Pylons users. There are a *lot* of Zope developers. They just don't hang out on reddit much because they get punched in the stomach all the time. 
Historically, yes. Over the past 3 months, we've improved reliability immensely ([described in this post](http://blog.bitbucket.org/2010/12/09/horizontal-scaling-and-a-revamped-user-picker/)), and we've grown our team 900%. Downtime hasn't been an issue for us for a while now. :)
Sure, but because of the pains long ago, more people migrated to github and few people seem to be moving back because of the network effect. This is most noticeable in the Django world, but it isn't exclusive.
&gt; The design for concurrent.futures was inspired by java.util.concurrent.package. Oh, that's worked out so well in the past, modeling python packages after Java packages... Seriously, though, I'm glad there will be a single namespace in the std lib for these. Hopefully there won't be too much required boilerplate.
Well, you wouldn't be wasting your time learning python2, by any means. Python 2 is alive and well, and still the dominant form of python in the world. Python 3 is currently just getting its sea legs. If you were a junior or senior, I would strongly advocate against learning Python 3 first, as it's not going to be in major use in the job market for some time now, but as a freshman, you'll probably be able to use it by the time you graduate, though Python 2 will also still be quite useful for several years after that. So to answer you question, you might look into Mark Pilgrim's Dive Into Python 3, available in Real Book form, and for free on the web.
What's a decent text editor? I've been using TextWrangler, but I don't think it has this functionality.
I love this engine. You can get a fully interactive 3d-world in less than one day using this engine and blender.
Cool, I imagine that would improve navigation for large projects.
I'm pretty sure you do not need tcl to use tkinter.
I at least need tk. From what I can understand, from all of the tutorials I am looking at, I need to have root=Tk() and I can only do that if I have tk installed. Everything that I have found about downloading tk shows that it downloads both tcl and tk.
Why cast it in terms of a war in which one product must presumably vanquish the other? This implies that there is only room for one DVCS, which is clearly not the case. Both git and Mercurial have thriving communities, tool support, documentation and infrastructure projects. Choice is important, and competition is better for everyone in the long run.
What kind of recovery beyond what `hg rollback` were you thinking of? When you perform mutating operations such as `hg strip` which deletes subtrees, a bundle containing the removed data is saved so you can always replay it to undo. This is quite a common feature for destructive operations. It's not precisely like the reflog, but it seems to have the same effect AFAICT.
Thanks for submitting a useful response instead of simply up/downvoting based on your opinion. I do realize that basically EVERYTHING is still python2 right now, but I honestly would like to take advantage of the fact that Python3 is brand new right now and if I learn its in-and-outs now, they will last me all the way until any other major revamp (such as Python4). I have a very bleeding-edge mentality and I'd rather not waste my time learning something dated, even if it is going to be used for a long time. This also goes with C++, I've already began using C++0x, even though to my knowledge the standard isn't finished yet.
GitHub is certainly very popular, but BitBucket seems to be rapidly gaining ground in terms of features and popularity. Hopefully now BB has had a big boost with the Atlassian acquisition, they will be in an even better position to advance.
http://diveintopython3.org/ - Mark Pilgrim's book on learning Python with Python 3.
Yes - bookmarks are the equivalent of git's lightweight branches. IIRC bookmarks is in the core distribution too.
Is this a new feature? How do you do this (without resorting to manual copying of the relevant files)?
Fantastic - just what I've been wishing for! (I love the way GitX allows you to manage your patches before committing.)
Cool, this is what I wanted to know. Thanks!
But would you not still be taking a risk? After all, it is still within the realm of possibility that Python3 will never catch on in a significant way. There ain't no such thing as a sure thing...
Python 3 isn't exactly a new language. Aside from some small syntax changes (print is a function, except as, don't need to subclass object) you can go a long time before noticing anything. Unless you are writing your own web framework or something it isn't super likely that the str vs. unicode vs. bytes stuff will bite you.
I was interested so here's an experiment I just ran that may interest you too. Open up a python interpreter and task manager and look at memory use during the experiment. biglist = [[i for i in range(1000)] for i in range(10000)] del(biglist) import gc gc.collect() The memory (on this machine) went from 5M to 150M to 5M
For learning basic syntax Dive Into Python 3 as others recommended will be great. For anything else (specific libraries, solving python specific problems, learning to do different kind of stuff on the web etc.) it shouldn't matter much to you if the tutorial/docs is written for python 2.x or for 3.x as once you get over basic syntax differences you will be easily able to use the knowledge/solution from 2.x in 3.x programs. You may think that learning 2.x syntax is waste of time but it's not. Many libraries/frameworks which are considered essential for developing in Python are not ported to 3.x, one example is PIL (Python Image Library) without which you will be struggling hard to do anything with image processing. A lot of 2.7 code will run on 3.x with very simple adjustments and you will be losing a lot not being able to learn from it or use in your programs.
`hg push --bookmark MYBOOKMARK` 
Unless it's been two weeks (according to `git help gc /--prune`).
Not surprisingly garbage collection works, who knew! Unless you are leaking RAM or caching data, memory usage will drop back to the amount needed.
For me, it's "hg for hg and GitHub via hg-git", "git for oh-dammit-this-project-i-installed-with-pip-uses-git".
My thoughts on the topic: http://stevelosh.com/blog/2010/01/the-real-difference-between-mercurial-and-git/
so your long running stuff requires 10mb and your webserver 190mb? what webserver is that? look into bolapara's suggestion. a webserver can be really tiny.
The `[py]` markup didn't work on author's site. From my understanding from the charts, the tl;dr version of this article is: uWSGI and gevent kicks ass.
Now, I don't claim to know much about python, but I was under the impression that the only big differences were syntax changes. The fact that when I call "/usr/bin/env python" it calls Python3 and not Python2, encourages me to at least keep up with my distro. Sure it's still a risk, but I'm sure if you think back to when you were in college/university, you hated the fact that they used old shit. This has given me OCD to stay ahead of the curve as much as possible.
&gt; I'd be fascinated to know what you think those 2-4 commands are. * git add * git commit * git branch * git checkout You can largely do pretty much everything with those four. Not a windows user so I cannot really speak to it.
well init is a must and you don't need to use it often, just once. So the 4 other than unit are * git add * git commit * git branch * git checkout
I was really really hoping for this to say GIL dissipatedly, unfortunately it's just another library ?
Hang on, Vladev is arguing that Hg is better because you don't have to know how it works. And you're essentially arguing because I'm not a Git developer I shouldn't be using it. Obvious troll is childish.
90 days for objects reachable from the reflog. Loose objects, which expire after two weeks, are unusual. They mostly appear when you git add but don't commit.
I love PyGame, but I feel the same way about the documentation. It's outdated, the tutorials are outdated, but the community makes up for it. I would plug my game, but I'll resist the urge.
Ah, that's a bit better. Still, I prefer Mercurial's approach of making bundle files as backups that you can delete when you need the disk space (i.e. never). Maybe I would feel differently if I often worked with repositories that contain large binary files. I don't, so I consider it a disadvantage whenever a VCS throws away my data, even if it's old.
That isn't quite what I'm writing... there are features in Git that don't exist in other version control systems. Understanding all of the extra functionality leads to better practices.
Great, that's very useful. It seems it has been available since [hg 1.6](http://mercurial.selenic.com/wiki/WhatsNew#A1.6_.282010-07-01.29), I just didn't notice it in the release notes.
The overall differences in the languages are very minor. Using 2 or using 3 won't hurt you when you're writing toys for practice. When you start looking at how things work, a lot of things have changed between python 2.0 -&gt; 2.7 to get ready for the move to 3. Compared to that, 2.7 -&gt; 3 is pretty minor because most of the big features are already available (e.g. yield, os.walk, with..., decorators, "string {0}".format(var), etc. If you learn 3, you'll be able to write in a current version of 2.x. Same goes for 2-&gt;3. Currently you won't have a wide range of options for libraries you can use in 3 compared to 2 though. The c-level API and the minor changes to the language mean that larger packages need to be carefully brought forward, so it's happening at a deliberate pace.
Or using strings on Python 2.4 (I think, might have been 2.5). &gt;_&lt;
So you do not push and pull?
no reason to, atleast for my needs.
With both futures and multiprocessing in the core, Python is at least taking multi-core programming seriously and trying to support it in a way that is pragmatic (spawning processes) rather than getting caught up in a nearly-unsolveable problem (removing the GIL). I only hope that enough people (ie. more than Jesse Noller, much props be upon him) can contribute to these libraries to keep squashing bugs and make them stable and reliable. The devil is in the details.
This, without a doubt. And while we're here, feel free to give Mark a bit or karma if you feel like it. http://www.reddit.com/user/MarkPilgrim
http://inventwithpyton.com/ - Al Sweigart's book on learning Python with Python 3 and Pygame (which works in py3k).
This, without a doubt. And while we're here, feel free to give Al a bit of karma if you feel like it. http://www.reddit.com/user/AlSweigart
I do pretty heavy processing using multiprocessing already and the GIL is the least of my worries. I'd be very happy to see more work done on the built-ins for process interaction.
this may be a good for learning PyQT programming
Plug away. I am trying to learn PyGame and would like to see it.
They are much of a muchness. They are similar enough that once you have learnt one of them, the other comes pretty easy. Just pick one and run with it.
please consider adding instruction on installing/configuring the rather BIG and thick dependencies: Qt, PyQT, SIP ad-nauseum.......
Have the first program write to sys.stdout and pipe the output into the second one: $ python script1.py | python script2.py
The Pythonic way would probably be to make those modules instead of scripts. Then, from a different module or script, use the functions provided by the first module and provide the results to the functions of the second module. The Unix-y way of doing it would be to make your first script write its strings out to standard output, and have the second script read the scripts from standard input. Then on the command line, you'd have something like: python script1 arg1 arg2 arg3 | python script2 argA argB argC You would of course need to arrange for the output of script1 to be intelligible by script2. 
Others have suggested pipes on the command line, but you can pipe from within a script as well. Check out os.popen().
The two tools are very close in terms of actual functionality, and in the end, they are only source control utilities. People who actually develop stuff have other things two do than learning 5 different ways of doing the same thing. Thus projects will probably very gradually move to the most popular DVCS, and forget about it.
Pretty cool. If you're into this type of stuff UofAlberta's [CPRG](http://poker.cs.ualberta.ca/) is a great place to browse. They deal with computerized solutions to games like poker. If you're up for an big challenge try taking on Texas Hold'em. State space ~O(10^17). 
**[Head First Python](http://www.headfirstlabs.com/books/hfpython/)**
I second the 'How to think like a computer scientist' suggestion and would also recommend highly [Head First Programming](http://headfirstlabs.com/books/hfprog/).
I thought you were going to produce an Ascii version of the comment. Imagine my disappointment ;)
I've been using Sublime recently. It's pretty nice, has syntax highlighting for python in uber-leet dark themes and does autocompletion on ctrl+space. http://www.sublimetext.com/
Unrelated to the IDE itself, but I just visited your website, and the snazzy paper-flipping-over effect on each transition is kind of cool the first time, but it slows down the whole page and stutters just enough to be annoying. I'd suggest that your web team consider whether it's really a useful feature. The IDE itself, however, looks pretty cool. If I give up on Vim, I'll check it out...
There are already a lot of insightful suggestions in this thread, but I'll chime in anyway... Start with Python: it's easy to learn, flexible, elegant and has a great community of users. For your development environment, use an advanced text editor such as Notepad++, an interactive interpreter (IDLE, IPython or bpython), side by sid. Start hanging out in the #python channel on the Freenode IRC network and following the discussions there. It's amazing how much you will learn; just don't get discouraged if you don't understand what everybody's talking about at first. Be humble and clearly state that you are an absolute beginner and you will befriend the experts there. My final tip: learn to unit test your programs as soon as possible. Once you are proficient with the language, I suggest buying K&amp;R and begin learning C.
I mean, everyone already know the optimal moves in tic tac toe right? When playing against people there is no single correct move, since you want to permute everything to keep non clever opponents confused.
Oh well, probably there were some network troubles yesterday, because today it cloned in 41s through http, 1m 24s through ssh and 38s through ssh uncompressed (hg clone --unc).
Mercurial has a sane user interface.
Reminds me of learning that my simple Tic-Tac-Toe algorithm using [Minimax](https://secure.wikimedia.org/wikipedia/en/wiki/Minimax) could now beat me at &lt;insert any game with reasonably-sized discrete state space&gt; with a few tweaks. Not that it needed much. I suck at &lt;insert any game with reasonably-sized discrete state space&gt;.
Nice, great code. Totally better than mine. :D
I just love how funny ideas from XKCD can turn into real life things :). This Tic Tac Toe thing, the autobuy bot, Python's "import antigravity". I spose that's what happens when your main audience is an army of people with geek superpowers.
Can I just check we're talking about the same thing, as it defs doesn't work for me. Say I have a project with no local modifications. I do: cd somedir touch somefile.txt cd .. hg add &lt;tab&gt; will automatically guess that I want to add somedir/somefile.txt as it's the only file with modifications. git add &lt;tab&gt; will just give me the standard bash autocomplete. It's not a deal breaker or anything, but definitely something I notice.
Depending on your style of learning, you might find this: [Head first programming (With Python)](http://headfirstlabs.com/books/hfprog/) worth a look. It uses pictures/diagrams and simple exercises (both programming and just understanding exercises) to simply explain concepts in a very friendly manner. You might look at it and dismiss it as a 'kids book' but despite having previous programming knowledge, I still found this book really useful for explaining some python concepts easily, and it was definitely the most fun book I found, and the easiest to sit down and read. Used as a 'break' between other more advanced books it can check you know what you're doing, and can make a welcome difference from the more standard text heavy tutorials.
Does multiprocessing do shared memory? Heavier sharing between processes may cause large overheads... In Haskell, they use "threads" which are actually more like processes (since everything is immutable, and you must explicitly use thread-able variables to communicate between them much like IPC), but that means an "IPC" message between these threads can easily share a whole lot of data between them. If multiprocessing allowed sharing immutable data you could get the performance benefits without the shared-state-thread hell.
Learn Python the Hard Way and [Al Sweigart's book](http://inventwithpython.com/), combined with a simple text editor, seem to be the consensus. Dive into Python and IDEs are for programming vets. And I always recommend [Python Osmosis](http://python.sourcequench.org) for when you decide to go through the official tutorial. These videos step right through it in bite-sized chunks. There's a torrent floating around in the history of this subreddit.
If you're the starting player it's fairly easy to trap people who think all games necessarily end in stalemate.
Thanks for the awesome info, some people here have also suggested learning C as well, I wonder what the connection between C and Python is, and is it easier to learn C once you know Python for some reason? Thanks again.
I actually read a little on Head First JavaScript a while ago and found the book very beginner friendly and something I can easily pick up, I totally forgot that they probably have Python too, thanks for reminding me!
But let's write this like how you'd actually do a simple CGI script: import BaseHTTPServer class TestHandler(BaseHTTPServer.BaseHTTPRequestHandler): def do_GET(self): self.send_response(200) self.send_header('Content-Type', 'text/plain') self.end_headers() biglist = [[i for i in range(1000)] for i in range(10000)] print &gt;&gt;self.wfile,'OM NOM NOM RAM IS TASTY' BaseHTTPServer.HTTPServer(('', 8000), TestHandler).serve_forever() Run on windows (I have no idea of Linux acts any differently, I didn't test: My app will be run on Windows), you get 6mb of ram before you load the page, 123mb during the page, and 123mb after. (It stays at 123mb if you load it again) Python doesn't return the memory to the OS, it just reuses it internally. This is the behavior I see, and this is what I'm trying to avoid. But it does tell me that I can just set up my server to call gc.collect() after an idle period, instead of restarting. Thanks!
It's not the webserver, it's the work the webserver is doing. It's dynamically generating pages, and many of them require loading and manipulating a lot of data. 
...what?
not sure why you were downvoted, as there are a lot of use cases for not needing the D in DVCS. for eg. I have personal text files in a repo (notes, blog posts, etc.)
I like the implementation of [XKCD576](http://bieh.net/2010/11/08/xkcd-576/)
An ASCII version of the chart with a Python program that reads the chart and moves accordingly would have been interesting.
very neat idea using the prime numbers.
Here's the code if you want to [check it out](https://github.com/Jetstar/Glider-Forever). Here's what it looks like: http://imgur.com/2H4yD.jpg It's got a semi-functioning level editor, but I haven't done much work on it. Also, while my code works, I'm a bit wary showing it off. Still, take a look at engine.py, classes.py, and funcs.py for the bulk of it. I'll answer any questions you might have.
I routinely (well - sometimes anyway...) write code that works with any version of Python from 2.4 through to 3.2. My mock module is one example of this. So whilst there are plenty of indicators (print as a function without the future import for example) code isn't necessarily limited to Python 2 *or* Python 3.
Do you have metrics to know that your web application actually used 200mb of memory? Because that's a lot. Have you asked a user to define performance requirements? Or are you just guessing. I'm going to be blunt: you are [gold plating](http://en.wikipedia.org/wiki/Gold_plating_%28software_engineering%29) your software. Trust me, we all do it: it's fun to try and do neat things like this. ***Don't.*** Write clean code and ship it. You will win more users if you do that.
Actually - old style class syntax in Python 2 works *fine* in Python 3. You just get a new style class instead as they are the only sort that work in Python. Likewise `__future__` imports work fine in Python 3.
Nope works fine in Python 2.7.
1. Of *course* it stays at 123mb: you are holding biglist in memory, and actively serving it. What do you expect to happen here? 2. gc.collect() won't necessarily do *anything* here: even if anything gets garbage collected, Python won't immediately free heap memory. So you will still see 123mb.
Thanks. Don't let it get you down, I've been programming professionally for 5 years, and that's after 4 years of college :P. Just keep it up, keep doing fun stuff like this, and you'll get there
I agree, very elegant. 
If you mean that it's deterministic, then you are correct. However, the point is that in using this algorithm, the bot *cannot lose*. My opinion is that human nature drives a human to try different approaches, hoping we can break a hole in a computers logic. That means that eventually a person will mess up and lose. This, of course, assumes that the person *thinks* the bot can lose.
Three horns do not play with longnecks!
How well does Tic-Tac-Toe generalizes to higher border sizes? I wonder how would that XKCD map look like for higher border sizes and with filled cells.
I will also put in a vote for HTTLACS. Followed by Dive Into Python, which is also free and online: http://diveintopython.org I might also be one of the few people who thinks that LPTHW is not a great book or tutorial (too in-depth in parts (eg. print) while skimming on other more important parts (eg. modules, namespaces))
Is social element aspect really that important? From my personal experience, unless your project is sufficiently popular or you're working with other people's repository, the social aspect of both sites really aren't that important. 
I am also 2 spaces with Python - but revert back to 4 with CSS, Javascript, PHP and C
the_unix_way (hence in C it is that way, and Python functions being that way makes sense)
I find a lot of projects these days by seeing what my friends watch and/or commit to on github. The bigger that network is, the wider its reach.
The real brilliance of Django is not the holding your hand and all that, it's the amazing documentation. You say Pyramid is well documented, and I say it's well documented in the way SQLAlchemy is well documented, that is it has a lot of coverage, but the editing and organization is still quite lacking.
Not updated for 19 months?
An update on my experience with Byte of Python. Things get a bit confusing when they explain classes, objects, methods etc. If you don't have prior programming experience this can be difficult to comprehend. To refresh I found myself supplementing with dive into python and how to think like a programmer.
Its not clear what the isin function does. If I call isin(x,y) is it going to return true if x is in y, or y is in x. Beyond that, the Python statement "x in y" is idiomatic, so all Python programmers will know what it means. 
The only problem is after 20,000 games the dumb computer isn't going to want to play with that asshole smart computer anymore. I have a cousin like him.
Does it get around the GIL? 
Oh whoops; you're right. We weren't talking about the same thing. I thought you meant that standard bash autocomplete wasn't working for files while using git, as though it would get stuck autocompleting git commands and somehow not switch back to file names. That's a really neat feature. It would help if modifying a lot of files but not wanting to add all of them to the commit.
Heh, I used prime numbers in a similar way to determine patterning of squares. Each prime number represented a sub-pattern (e.g. striped, solid, etc) or color. Here I thought I was the only person that clever :P. 
With all those data structures, where's the programming?
Why didn't you use 11 in your prime number grid?
11 is an evil number
wher tf is the book ???????
A.) The languages aren't very different. There's not much difficulty in learning them both. B.) The best programmers are the kind who _want_ to learn more languages, not fewer.
You do know that python 3 doesn't come with batteries included right? 
Right. Anybody who thinks they can beat a properly programmed computer in tic tac toe is fooling themselves. My comment was mostly about the obviousness of the algorithm. But maybe people weren't as into tic-tac-toe as I was back in the day.
Maybe Pyglet? Python-Ogre is a bit of a pain to work with, but it has potential. LÖVE isn't python, but it might be a great example to show basic game design and students would be able to learn it quick. 
I can't get into cocos2d. Just dealing with Pyglet is easier for me. 
**Books** * Programming in Python 3: A Complete Introduction to the Python Language (**Personal Favorite**) Introduction + Applications http://www.amazon.com/Programming-Python-Complete-Introduction-Language/dp/0137129297 * Quick Python Manning Introduction + Application * Learning Python Big, Introductory + some, Application not so much **Videos** * Python Osmosis (50 short videos on Python Fundamentals) * Blip.tv (Pycon Videos) 
Yes. I thought it was pretty clever. Powers of two also can be used with a bitmask to check this. Here's [link](http://www.reddit.com/r/Python/comments/em5sx/tic_tac_toe_in_python/c195leq) to my original comment from where the code is inspired :)
True. We're workin on it.
I feel that the rule should be amended slightly to allow a 2-3 levels of indentation: a hard 80 column limit tends to make code harder to read in common situations where the block is indented. I find that it's really common to hit the 80 column limit but rare to exceed ~100-110 because I'm working in a nested loop inside a class method definition and am thus starting with a 12-16-character penalty.
It's a step
Love to join the project, and specifically fix that tvtorrents scraper. I'll check back in when your site is up again. 
 import subprocess args = [ 'other_python_script.py', 'arg1', ... ] proc = subprocess.Popen( args, stdout = subprocess.PIPE, stderr = subprocess.PIPE) out,err = proc.communicate() # blocks until complete # out should now contain your output from your other script. 
Ditto. A wrapper for an asynchronous function call sounds pretty nice.
From where the website linked in the description links back to bitbucket: &gt; The above link will take you to the development home page. In the upper right area of that page, you will see a link that says "download." (You can choose your desired compression format). Except it's not "download" but "get source" (I guess that changed in the meantime?).
Great! It's nice to see that 3.2 is getting better and more along the performance of the of the 2.x branch
It needs mentioning that git checkout is for both switching branches AND reverting changes you made to a particular file. If you're trying to revert a file that happens to have the same name as a branch you need to do something obscure that I don't remember anymore. I always preferred hg because the verbs they choose are more salient AND they match with most of the rest of the (D)VCS world. Git has a strange way of naming things (I'm looking at you git revert) that lives in another universe. I use hg for all my personal projects, git for my workplace.
thanks
Holy crap pypy is fast
This look very interesting. I opened up a [random page](https://bitbucket.org/BruceEckel/python-3-patterns-idioms/src/63059be05961/src/FunctionObjects.rst) and it has some good content. Looking forward for this book to be completed. 
Im new to python, should I stick with 2.x or start looking into 3? 
Because this kind of thing needs a graph: Jython:10% :###### : 2.6.5 :31% :################### : 2.7 :35% :###################### : 3.2 :36% :####################### : PyPy :100%:#################################################################: 
See [this article](http://python-commandments.org/python3.html) on it. Important note: Python 2.7, the end of the 2.x line, has come out since this article was last updated. Edit: also, numpy and scipy have since begun supporting 3.x. There's a lot more support for 3.x than there was previously. Additionally, Mark Lutz's [Programming Python](http://www.rmi.net/~lutz/about-pp4e.html) just came out with a new edition that's 3.x-only. There's a lot of momentum for 3.x. If you don't have a reason to stick with 2.x, I'd look at 3.x.
http://pinboard.in is an excellent alternative.
Cool didn't know a new programming python came out, not sure if I'll check it out at this point, but good to know. 
I'd like to contest that "a lot more of the Python community uses github" statement. In my experience I've seen just as many Python projects that use bitbucket as there are ones that use github. Unless someone comes up with good data both your statement and mine are equally reliable.
Unless you want to do web programming.
This isn't a format war or anything. It's not like people are going to amass on one side so much that the other wilts away into obscurity. There's no such thing as git "winning" over hg. What, in 2015 there'll be so many git users that I'll be force to switch my personal projects? As far as we can tell people will be using both in the long term. People should live with the fact that there are multiple systems out there. I'd suggest learn both and pick the one that fits you. No matter what choice you make I swear you'll find a job that makes you work with another.
I like [this](http://en.literateprograms.org/Tic_Tac_Toe_(Python\)) implementation, it's pretty clean
OK, I'm a p4 guy, but I didn't really want to run my own server at home to store my little code snippets. So, for me it was really between bitbucket and github. I tried out git first, and wow, did not like it. I do a lot of cross platform development, and git seemed great on Mac, but the options between cygwin, msysgit, etc etc. I was not impressed. As a python guy, I felt mercurial was just a way better fit for me. As much the [Zen of Python](http://www.python.org/dev/peps/pep-0020/) is applicable in python, I feel most of it should apply to your source control system. Once I installed mercurial, I really haven't looked back. I still use github to look at other people's things, but it's like writing Java after doing Python for so long, it just feels a bit heavy.
That's not entirely true. PyPy needs some time to warm up the JIT (0.2s is not enough in case of pystone), so running it more and more makes it faster and faster (up to 10x speed of CPython on my machine) after 4 runs of main() (that's in total 0.4s). Same applies to Jython on a much bigger scale I believe
Folks, stop being misleading. Shed Skin is not a Python-to-C++ compiler. It's a Subset-of-Python-to-C++ compiler!
Thanks for the response. 
Anyone else read this, and think the OP was planning to give gifts to his clone, who happens to be great to eat?
I wish PyPy will become the standard that all other will compare to. 
Someone forgot to include unladen swallow. Oh, wait. 
What about Psyco?
Started with the Unix-y way, which worked fine, but the Pythonic way worked even better. Thanks!
I may be interested in participating. PM Me and we'll be in touch by email.
Note that it's $7.84 (it goes up over [time](http://pinboard.in/help/fee/)) for a one-time payment, and it's refundable within three days. It helps them keep spammers off the service, they say. I was a pinboard alpha tester, and I used it until Google Chrome gained sync support across browsers. I still think pinboard is a good idea; I use it to grab my tweets with links in them. I also follow a couple of friends there.
&gt; Due to very heavy traffic, some background services (import, archiving) are running slowly well done reddit.
Other things to keep in mind: alternative implementations like PyPy which seem much more promising than CPython will stick to 2.x for a while.
I know I'm going to get some hate for this, but there's a PERL version: https://neuro-tech.net/insipid/
I wrote my own about 3 years ago. PHP/MySQL with single user capability, but still basically a clone of the delicious service. Might be interesting to do it again using a python web framework. gain multi-user capability along with a raft of other improvements. Ok, i might be interested. PM me and let's chat about it. Cheers,
Integer division might be the most surprising bite. 
not really. It's duplicating functionality of other projects for no apparent reason. They have an ORM, but there's at least three different projects that provide that functionality. They have micro-framework style routing, but why should I choose this over any of the other dozen micro-frameworks? I'm really confused by this. Sorry to be really insulting. From a code stand point, it's quite a accomplishment and I'm sure it scratches the itch of the developer, which is all that really matters in my opinion.
Welp, you just finished an argument I had with a co-worker who's position was that if you looked hard enough, almost everything has been done in perl already.
Good. Given the pace and lifecycle of books (compared to the pace and lifecycle of software development tools) this is the right choice.
Thanks, looks great.. and from the author if the "thinking in.." series.. (I guess it's not only him, but whatever)
I would assist with such a project if it is confirmed that delicious is actually closing. Contact me if you actually begin such a project.
inb4 Chrome.
Yeah? This whole 3.x is getting nowhere. 3.x will have a chance if they drop the requirement for braces for the print function. 
How is the print function even an issue? It's certainly not a real issue for any of the projects that have ported to 3.x, and I've not seen it listed as a blocker for any of the projects I've seen with a porting roadmap, or partial progress. I've yet to see anyone fully dissect print-as-a-function and show why it's legitimately worse than print-as-a-statement, using more than "because it's what I already know".
or &gt;&gt;&gt; from operator import getitem &gt;&gt;&gt; l = [['aa',100],['bb',50],['cc',25]] &gt;&gt;&gt; sorted(l, key = lambda x:getitem(x,1)) [['cc', 25], ['bb', 50], ['aa', 100]] Is the operator module just there so people can avoid lambda functions?
would you mind telling us what's fantastic about it?
I don't like typing braces where not necessary. 
In the sense that PyPy is to CPython what Chrome is to Firefox?
Your right (JIT is only done one the loop has been analyzed...) Here is an example of PyPy running pystone 10 times in a row. &gt;&gt;&gt;&gt; from test import pystone &gt;&gt;&gt;&gt; for i in range(10): .... pystone.main() .... Pystone(1.1) time for 50000 passes = 0.25995 This machine benchmarks at 192345 pystones/second Pystone(1.1) time for 50000 passes = 0.08655 This machine benchmarks at 577701 pystones/second Pystone(1.1) time for 50000 passes = 0.079298 This machine benchmarks at 630533 pystones/second Pystone(1.1) time for 50000 passes = 0.077387 This machine benchmarks at 646103 pystones/second Pystone(1.1) time for 50000 passes = 0.079177 This machine benchmarks at 631497 pystones/second Pystone(1.1) time for 50000 passes = 0.077597 This machine benchmarks at 644355 pystones/second Pystone(1.1) time for 50000 passes = 0.079026 This machine benchmarks at 632703 pystones/second Pystone(1.1) time for 50000 passes = 0.077798 This machine benchmarks at 642690 pystones/second Pystone(1.1) time for 50000 passes = 0.078652 This machine benchmarks at 635712 pystones/second Pystone(1.1) time for 50000 passes = 0.078287 This machine benchmarks at 638676 pystones/second
I &lt;3 stackoverflow. I asked that question and got good replies the same day.
I have a 64 bit machine and 64 bit builds of python in which Psyco doesn't work...
ropevim FTW :)
To be fair, the title is a direct copy from the blog's title; the use of "restricted" only appears in the blog post itself.
I'll go out on a limb here because I don't know the original either. It seems to be a dynamic proxy for python class and allows you to procedurally define assertion on how the class are being used for when you write test cases. The author should have put the doc on the front page. From the code: """ Creates mock objects or puts existing objects or classes under mock. To create a new mock object with some attributes: FlexMock('some_name', attr1=value1, attr2=value2, ...) To put existing object under mock: FlexMock(some_object) Now you can add some expectations: some_object.should_receive('some_method').and_return('some_value') --or-- some_object.should_receive('some_method').and_raise(some_exception) To generate some assertions add a times(x) expectation: some_object.should_receive('some_method').times(1) -- which is equivalent to -- some_object.should_receive('some_method').once You can also do the same thing for all instances of a class by giving the FlexMock constructor a class instead of an instance. It's even possible to override new instances created by the class constructor. Various shortcuts are supported, so: FlexMock(some_object, method1='foo', method2='bar') -- is the same as -- FlexMock(some_object) some_object.should_receive('method1').and_return('foo') some_object.should_receive('method2').and_return('bar') """ **edit** I realized I answered the question "what is it" not "what makes if fantastic" but I'll leave that here for other people who may not know what it is. 
"We are not doing PyPy justice..." to be fair, not all production code is really going to be able to fully leverage the JIT either. I'd rather see results from a greater number of passes (i.e. pystone.main(500000) ). I would find the value that results in a test run of about 10s on python2.6 and then compare that same number of iterations on each interpreter. Using that method, on my box I see pypy about 7x faster than python2.6 instead of the almost 11x that the post suggests.... still not too shabby! I may be quibbling here but over-selling pypy can only hurt its acceptance.
Honestly, pystone is about the worst benchmark ever. I believe someone once said, "it's good for knowing whether your new cpu is faster than your old one."
Good point :)
Are you sure NetworkX is installed into your PyPy site-packages? You might get a better answer on the PyPy mailing list, especially if you provide more detail. Essentially all you've said here is, "it doesn't work; help", but that really isn't much to go on. * How did you install NetworkX? * What does sys.path look like? * Can you import other modules? * How do you "launch your script"?
I'm curious, what would be the point? You couldn't read or write anything to it, I'd imagine. I would rather expect it to be a restriction of the underlying filesystem, not of python itself.
I'm trying to break out of a chrooted environment. If you're not familiar with the method, it involves opening a file handle at the jailed root, chrooting further in, then using that file handle to go above the new jail and walk all the way up to the real file system root. It isn't a restriction of the file system, *nix treats everything as files. Normally to do something like this C would be the language of choice, and I was also able to do it quite easily with PERL. However everything is roughly 10x cooler when done in Python so I was hoping there was a way to accomplish this.
&gt;everything is roughly 10x cooler when done in Python quote of the day!
I know nothing about the design decisions that led to the current implementation of the os module, but I presume that it's because this is the useful level of abstraction. If you really want to use Python for this and not C, maybe just wrap and call opendir() and dirfd() using the Python API, then read the resulting file descriptor using the python library methods? Maybe there's an existing module that does this already.
You can always use [ctypes](http://docs.python.org/library/ctypes.html) and go directly to libc.
&gt; I'm trying to break out of a chrooted environment. Ability to break out is a bug, and Python tries to hide the bugs from you.
ah, i thought your long running process does all that page-generation work. just an idea, i have never tried or looked into it in detail, but maybe you can run a webserver like lighttpd, in a way, that it automatically spawns your page-generating application and serve pages when requested and kills it again when it is unused for a while. same thing might work with a simple Python webserver, that "unloads" the webapplication it serves when it is not needed.
I see your TicTacToe in Python and raise you my [TicTacToe in R](http://www.reddit.com/r/statistics/comments/ekr13/sometimes_you_need_a_distraction_simple_tictactoe/). When in doubt, use the wrong tool. 
How is os.open not working? In [1]: import os In [2]: os.open('/', os.O_RDONLY) Out[2]: 3 edit: oh, if you want to be able to do anything with that, you'll probably need ctypes :)
You can't inside the stdlib and that's on purpose.
Yeah all of the people pimping out pinboard.in sound like they are paid testimonials.
I've never understood the use cases for -- and the fascination with with -- mock objects. It seems like a lot of effort to include an additional dependency in a project, learn how to use that new dependency, and then track down the inevitable discrepancies between the mock thing and the real thing. Sure, I get not having access to a resource like a database or a remote file system. But aren't there other, better ways to substitute for these things? I'm genuinely curious about this; can someone present an argument or a use case where using one of these mock libraries makes the best sense? 
 &gt;&gt;&gt; import os &gt;&gt;&gt; os.open('.', os.O_DIRECTORY) 4 
You can use it with os.fchdir (which may be what he's after if he's escaping a chroot).
It's one benchmark. Other benchmarks [are available](http://shootout.alioth.debian.org/u32/which-programming-languages-are-fastest.php). The fact that the JIT needs a few runs to warm up is a good bit of information. But anyone with a clue knows that the only reliable "benchmark" is how it works with your own code.
Ctypes feels like cheating, I was really trying to see if there was a purely pythonic way of doing this. Still, good to know that it is an option.
Well crap. I was trying to open it in read/write mode, which is what gave me the error that it was a directory. Using the correct flag makes it work, thanks!
My plan exactly!
TDD. Or unit-testing in general. I'm certainly not a fan of heavyweight mock libraries, but if you're testing code of any complexity, mocking becomes necessary. Here's a good explanation: http://xunitpatterns.com/Mock%20Object.html
Still not convinced. From that link: "We can use a Mock Object as an observation point when we need to do Behavior Verification to avoid having an Untested Requirement [...] caused by an inability to observe side-effects of invoking methods on the [System Under Test]." The key phrase for me is "caused by an inability to observe side-effects". How many times do programmers truly have an *inability* to observe side effects? Compare that with "it's hard because I haven't set up my development environment to match my production environment." I certainly understand why you'd have need for a mock MissleLauncher. But these libraries encourage MockThis and MockThat and MockEverythingImTooLazyToSetupRight. &gt; but if you're testing code of any complexity, mocking becomes necessary. I've written hundreds (if not thousands) of unit tests without ever needing a mock object library. 
Line 1: you are calling target.write("%r, %r, %r") and then applying the % operator to it, which doesn't work. Line 2: when you have more than one argument for string formatting, you need to put them in parenthesis () Try: target.write ("%r, %r, %r" % (line1, line2, line3) ) 
Awesome. Thank you very much. That worked perfect. Can you add to put each line on a new level? Much difficulty with this and been working on this for 3 days. This is what i have now and its laughing at me: target.write ("%r %r %r" % (line1,"\n",line2,"\n",line3,"\n")) ---- Not all arguments converted during string formatting.
Ahh i have found it... target.write ("%r\n %r\n %r\n" % (line1, line2, line3)). I have been working on this for a few hours and hitting my brain against a wall. Sorry to sound so confused and thank you very very much for the tip. If i can get a chance one day to help you too i will.
Does NetworkX import in "regular" python 2.6 or does it not import for either interpreter? If it imports in 2.6 I'm guessing your issue is that pypy and python2.6 have different path variables. For each interpreter try this import sys print "\n".join(sys.path) Then figure out where networkx is installed import networkx print networkx.__file__ If networkx is located under some directory that pypy doesn't have listed under sys.path that'd explain why it can't find it and gives the ImportError On my system (ubuntu 9.10) networkx got installed at /usr/local/lib/python2.6/dist-packages/networkx-1.3-py2.6.egg/networkx/__init__.pyc and the path entry that allows access to it is /usr/local/lib/python2.6/dist-packages/networkx-1.3-py2.6.egg edit - I swear to ***** it is not possible to get formatting right the first time
99% of the time that I see import errors with macports it's this: * You're calling the wrong python binary A little context/tips. Macports supports installing multiple versions of python. To handle this, they append a version identifier to the python binary installed, something like python2.6. If you want a /opt/local/bin/python binary, install python_select and activate the version you want that link to point to. make sure you're calling the right binary in the shebang, e.g. #!/opt/local/bin/python2.6 Or that you have your paths set such that the macports binary gets called for #!/usr/bin/env python % which -a python Should give you an idea of which one you're calling. Of course, you an also: import sys print(sys.path) to find out which one you're running.
Is it because of Django/Pylons not being ported yet or some other 2/3 specific reason ?
Perfect sense. Thanks for taking the time to explain. My brain got so scrambled from the first problem I forgot some simple rules. This is a nice trick you taught me too: ( "%r %s %r %s %r" % (line1, '\n', line2, '\n', line3). I didn't think I could set a variable for the \n too. Thank you!
For programming questions, there's always stackoverflow.com
I didn't even realize that was there. I should read through os better.
It's more complicated than that. WSGI is 2.X only as of now, so until [PEP 3333](http://www.python.org/dev/peps/pep-3333/) gets implemented, a lot of WSGI based python web frameworks will stay 2.X.
Wow. This is everything I've ever wanted to say to my girlfriend AND python.
To me, the GIL is the programming equivalent of infertility. It not by any means a dealbreaker, and it doesn't stop you from having a deep and meaningful relationship, but it's painful and closes off a world of possibilities to you. ... Please God, let there not be anyone dealing with infertility reading this... 
Eventlet/Greenlet pretty much solves the GIL with coroutines.
"I %s put my string replacements in parens, just in case." % ("ALWAYS")
Mock objects are useful when you're dealing with a framework -- wxpython, django, SQLAlchemy, etc. It's convenient to use a mock to verify that your ListCtrl widget is populated correctly, or your URL handler sends the correct response, or your database ORM received the correct query.
Yeah, I wish I had a whitespace sensitive girlfriend.
Wow, when I read that I really though he was going to dump her at the end.
Me too, I was going to cry. Also, "Google, Quora, and Facebook"? Only one of these three names would require me to look it up using my default internet search, or ask my friends on my default social networking site what it is. If you see what I mean.
Has reddit really come to this? "Oh, we can discuss stuff, sure. But if you want, you know, technical things... *programming* questions with actual answers-n-shit -- better go to stackoverflow." **edit** I've just seen the r/programming sidebar: "/r/programming is not a place to ask for help [...]". I don't know how long that's been the attitude. Regardless, I should shut up.
Everyone else is giving good advice about solving the problem. May I ask you to please edit this post, or post a new one, or message me or whatever when you've got it set up and have run some tests to see if it turns out faster? I'm about to start a new project where one of the major cpu bottlenecks will be shortest-path algorithms and similar. I'd like to use Python + NetworkX but I'm a little concerned about speed.
Look up!
fingerbob has right, this works well. I've use this in the past, works great for calling shell commands from python. 
For servers, yes. For processing, no.
How? Context switching is much cheaper, but you're still bound to a single core.
Multiprocess communication is crazy easy with Eventlet. Just fork, talk, process, etc.
This is an example of why Learn Python the Hard Way is bullshit. %-style formatting is old, and in Python 3, it's not preferred. The better way to do string interpolation is with `.format`, so that your code would be `target.write("{!r}, {!r}, {!r}".format(line1, line2, line3))`. Incidentally, the error message you get from `target.write ("%r, %r, %r") % (line1, line2, line3)` is a good example of something to be aware of: in Python, most methods that change the underlying system in some way or change the object that you're working on (as opposed to creating a new object, like `3 + 4` creates `7`), return `None`. The reason you got an error is because you're doing the equivalent of `None % (line1, line2, line3)`.
processes != threads Now, I know you should prefer processes to threads where possible... but it's not always possible. Also, not all platforms have a usable fork.
ahh, how sweet, am touched and actually LOL'ed
If the variable is a class attribute you could always use @property decorators on methods. 
&gt; On the bad side, what I've found recently is that that the 'var = None' assignment can easily look a little bit too much like it could have been a temporary addition done for debugging or code testing. In fact I almost removed such an initialization today during a cleanup pass of stripping my debugging and testing code from a program before committing the changes to the repository. Instead I suggest you stop adding testing/debugging code you have to strip afterwards. How do you know the code you tested still works after you removed the testing code interlaced with it? You don't. If you want tests, write proper unit/functional tests. If you hit bugs you have hard time debugging without touching the code, improve your program logging facility. Honestly, the code you showed looks perfectly legit to me, and the error you introduced should have been caught by a basic code review (as in skim the diff before committing). 
Do you still happen to have the original perl code? If so, mind sharing it with us?
I do this all the time and have never confused my variable initialization with temporary debugging code...
networkx used to have a top-level import of numpy- although I think with the latest versions it is only imported for certain functions. Numpy does not work with pypy- not yet anyway- I think a lot of folks are waiting for this...
Romanticizing programming languages is rampant everywhere. Why?
Well for one, I probably spend more time with Python than my actual girlfriend.
Sure thing. I slightly modified the PERL script from [here](http://pentestmonkey.net/blog/chroot-breakout-perl). The [Python](http://pastebin.com/yvFcYMa0) script I wrote myself.
Americans use the verb "shop" in many, many unexpected ways. "Looking for ideas" -&gt; "Shopping ideas" "Browse our inventory" -&gt; "Shop our inventory" 
Circle jerking. 
Don't let Java lecture you about maturity. She only looks older.
I've been doing this with IDLE for years. IDLE has a subprocess run and it communicates with the GUI through port 8833 on localhost. With a few modifications, the subprocess can be run on a remote host and sent over the network. This is extremely useful when debugging apps on the iTouch, or just even using Python-fu in GIMP to do some graphics processing.
http://scrapy.org/
[Here's](http://pastebin.com/Qfr5eb9R) a very basic webscraper I'm screwing around with. Maybe it will help you with yours. It's probably not the best way to do it, but it works. 
Perhaps not everyone knows that there exists such a site, where there are more users who are willing to answer direct technical questions, and where the entire site is built around the concept of finding answers to technical questions. In fact, I think your response has more of a "has reddit really come to this?" quality than mine.
When is it not possible, and what platforms are you using that don't fork usably?
Oy...now I'm all verklempt...
I think doing this with the else block is worse than using the conditional. The reason is that it violates DRY slightly, and introduces a place for errors to creep in. Consider: if condition: variable = something() else: varaible = None This has a bug that may produce behaviour difficult to pin down immediately. Whereas: variable = something() if condition else None only mentions the variable name once, so avoids repetition where a typo could creep in.
Thanks. This scrapes only websites which are linkes on the main-URL, doesn't it? Is it possible to go deeper into the link structure? btw, is my python-version outdated? I see this: print link.getText() TypeError: 'NoneType' object is not callable Thanks a lot!
BeautifulSoup is dead, and also slow and can't handle invalid html use lxml
Has anyone tried the service? Looks like it's still in private beta.
Agreed. Beautiful Soup Will Crash. You Will Need To Fix HTML on perhaps 5-10% of sites before BS can handle it; with regexs or something. It's retarded. As a side note, I have the regexs needed for most types of analysis ... bad html takes a lot of coercion. I'm waiting for someone to write a very simple webkit bridge that takes in fucked up html, emits proper html, and that's it (I've tried and failed twice). You know, like parsablehtml = unretardify(rawhtml)
I'll do it. I also recommend using something like Tornado and ditching WSGI in favor of non-blocking calls so you can push "live" bookmark feeds, which would be a totally boss feature.
why not just use lxml? which can handle even very retarded html:)
From the very little I've used it, it works well enough. It only supports MySQL at the moment, but postgres support should be coming "very soon". Once you've got it setup deploying simply consists of using git to push the project to djangy.
You are amazing for this. I am, in fact, using python 3 so using the lowercase t solved all of my problems. It's always the simple things that get you in the end, right? Thank you so much!
I was going to mention this, but wasn't allowed to comment on that page. Python is four whole years older!
Is this project active? I don't see any new commits or releases since Sep 09. Looks pretty interesting though. Anybody using it?
Maybe parse via lxml and then serialize into a string. That should be unretardified then.
Spotify and Bloggen =]
I use version 2.7.1 - what version do you use?
TIL
That error means that getText has somehow become None. 
I cried.
It's great actually. IDLE has had this network subprocess for the several years already. It's sad that IDLE gets overlooked because, with some modifications, it is a simple yet powerful IDE. 
On the site, look at the menu to the right. They have plenty of herp but no derp. I hate when that happens!
Thanks much for this info :)
That's my favourite website design I've seen for a while. Extreme simplicity but with a hint of class.
How strange.
When you have large lumps of shared state that are too expensive to send via messages and don't always have much choice over where you store it - eg. high performance games. Think graphics resources, for example. Windows (and thus Xbox) doesn't have a fork call. Python's multiprocessing library does have a hack that appears to emulate a fork but given that it has somewhat different behaviour and worse performance it's probably not great to use it.
It is reminiscent of http://www.iolanguage.com/
I've been on reddit longer than stackoverflow existed. Maybe that's why it seemed like a johnny-come-lately, dumbing-down attitude, to me. However, you can see in my edit that I told myself to shut up because I was wrong. Is this an attitude you should encourage, or discourage?
I suppose games are a good example. My overall point is there are less reasons than people seem to think for needing threading.
ROFL. I parsed that as "does anybody have experience with this python **book**?" 
Yeah. The university uses mediasite, which requires activeX controls. It's easier under IE. Pains me to say that. I'm looking at different technology now.
This is great. I was JUST looking for something for looking at CSV files. This has even more functionality than I need.
Awesome! We should get together some time to exchange war stories. I've got your book too. I haven't done any pygame stuff for a while, but I do have some folks working on some additional features for gameEngine. I'm currently working on a game development book using HTML5 canvas. I'm writing a game engine similar to the gameEngine described in the L-Line book.
Yes. Most of the book focuses on Pygame. In the last chapter, I describe how to build an easier game engine on top of pygame to make game programming even easier for beginners. BTW the web site doesn't have the actual book on it. Those ppt slides are the slides I use in my class, made available for anybody. The book is still in print, so I'm not allowed to post it on my web site. You should still be able to find it on Amazon: http://www.amazon.com/Game-Programming-Line-Express-Learning/dp/0470068221/ref=cm_cr_pr_product_top 
I checked and I am pretty sure she is a HE!
I actually needed THIS definition of graph, hah! Thanks dude!
If it's a method in a class, you have to add self as the first parameter. Try this: def wordcount(self, filename): ... It's used so the method has a pointer back to the class object instance. 
I tried that and got the same error. [screenshot](http://i.min.us/id8Ipw.jpg) I also set it so def wordcount(self, filename='small.txt') but it doesnt like that either for some reason
Right, you're calling it as an unbound method. You need to instantiate the class before you call the method, or make the method static. @staticmethod def wordcount(filename): ... Would do it, as would t = Test() t.wordcount('small.txt')
That totally fixed it! I just redid the for statement and it's running fine, thanks so much!
Next time you paste your code onto reddit you should paste with an indent of 4 spaces so that the code is *displayed as code*. e.g., if __name__ == '__main__': not if __name__ == '__main__': Tip #6 :)
guys are mostly heterosexual programmers are mostly guys people like to anthropomorphize the things they are attracted to into the sexes they are attracted to you get downboated not by me, jus' sayin' why &lt;/anecdotal&gt;
where's [notprogrammingnazi](http://www.reddit.com/user/notprogrammingnazi) when you need him?
Don't know who did what first, but I like the Smisk site better. Just an opinion from somone who doesn't matter. ;)
Just link to the [project page](http://code.google.com/p/csvstudio/) please
Haha thanks man I'll keep that in mind
The project page does not say much. The PDF explains it. BTW, I just expanded it.
I think calling it bullshit is a little harsh, "outdated" might be more accurate. But let's remember that python 2 is still probably 90+% of the python "out there". I think the point of learning it the hard way is that once you "get it", you'll be able to adapt to the language changes made in python 3 without having to read another book.
Happy I could help!
Nice. But the query syntax seems wrong to me. I would prefer more standard python such as 'and' for and, and using python expression syntax.
She? Am I the only one to find that a bit creapy? 
Next time, please put a warning in the subject that the link downloads a pdf.
Who still has trouble opening pdf file?
No one has trouble opening it - it's just a pain in the ass to think you're going to a website and get a pdf instead.
No, not really.
 class Test: @classmethod def wordcount(cls, filename): words = {} f = open(filename, 'rU') text = f.read() for word in text: words[word] += 1 print 'woo-hoo got:', words if __name__ == '__main__': Test.wordcount('small.txt') print 'If I print this I owe reddit a pie' Note the @classmethod and wordcount's first argument. [Python @classmethod help](http://docs.python.org/library/functions.html#classmethod).
Smisk was written by a Swede. In Swedish, smisk means spanking. Just so you know.
Willow: *Everyone's getting spanked but me.* 
Performance wise how would it compare to something like Flask?
Sweet, I wrote the WSGI for this way back when. I gave up on the project because I didn't see the advantage of it over a pure WSGI solution
Needs support for other delimiters.
I'd be really surprised if it would perform better than uwsgi
Good information even if you don't plan on writing or using a BST in Python. 
Thanks, I just read the documentation for a bit. I have to say that this seems to be complicated for a python-noob. With beautiful soup I found some very basic tutorials and could start directly with some examples. btw, is lxml only capable of processing the html or is there a mechanism to go through the nested structure of a big website automatically? I have the same issue with scrapy. It seems to be too much for me :( Thanks to all for your help and inspiration!
This has nothing to do with Flask. Flask is not a web service framework. Flask is a web application framework. With Flask you create websites/apps, with Smisk you create web services. I hope this clears things up a bit. None of them is a web server, although Flask provides one for development. From the examples I've seen Smisk using lighttpd, on which you can also run Flask applications.
We currently use Elixir in our project and I would **not** recommend it. The main reason is that Elixir is a layer on top of SQLAlchemy, and as of 0.6 SQLAlchemy has a declarative ORM system that is even more flexible than Elixir. See: http://www.sqlalchemy.org/docs/orm/tutorial.html#creating-table-class-and-mapper-all-at-once-declaratively Elixir offers a few methods that make life simpler, like `get_by` to get things by unique field, but any other even more slightly complex query requires you to use the sqlalchemy query object. Elixir's means of setting up the database are also really weird. It has a `setup_all` function, but you have to ensure you call it only when all Elixir classes in the application have been seen by the system. Otherwise strange things happen. Bottom line: it was a good idea but SQLAlchemy with declarative base is simply better. Save yourself a dependency and use that.
How did you run it? Can you post the code?
I'm wondering how many of you guys would rather write your own little helper functions than use a tool as small as this. If I want to look at a csv file, I just open it in an editor or excel or openoffice. You have to do it anyway as you can't know what delimiters are used (;,:#, I've had them all )-; ). Handling csv in Python is extremly easy then with the csv module.
 for i in range(1,10): for j in range(1,10): print(j) This runs almost instantly for me in Python3, to have any idea what's causing this we'd need to see what code you've written.
maybe your terminal is slow
Python seemed fairly quick to me. I did an array generation test with 100 million (yes, that's right) elements. It took 2.2 seconds on my system. So, I guess YMMV.
Re-run the program sending your output to a file. e.g. python my_program.py &gt; output.txt It should be done in less than an eyeblink.
I'll take a patch ;-)
sorry, next time. I cannot change title now.
Terminal buffering, maybe? Don't worry about speed until you need to worry about speed. If you aren't 100% certain Python is too slow for your application, *it isn't*.
Note that if you actually want a binary search tree, you should go with a balanced one, like a red-black tree or AVL tree.
Python is really slow but it's not that slow. If you're using the windows terminal for output that could be why.
Are folks really that lazy these days?
TL;DR - you want to change the tick labels along the X-axis. a = gca() a.set_xticklabels(['a', 'b', 'c']) 
That doesn't sound very feasible for 10,000+ entries... Maybe I'm interpreting it wrong though.
How constructive.
Yes, actually. 
Then make a for-loop to build a list. Live up to your name, hackop.
I mean, how hard is it to go to [matplotlib.sourceforge.net](http://matplotlib.sourceforge.net) and check out a few examples (of which they have a lot)?
I've actually been doing that for a few days. I've also downloaded and have been reading through the ~900 pg docs PDF at the same time. It's not like Reddit is my first stop. I just can't seem to get it to work right.
... which you can find implemented here (among other algorithms) with visualization too: http://www.web2py.com/Teaching/Algorithms Mind it is 7 years old. The zip file contains PDF with docs.
Just using python objects and basic operations I can calculate the first million prime numbers in fractions of a second. It's really not that slow.
I'd love to see the code for that. $ cat loop.py #!/usr/bin/python for i in range(1,10): for j in range(1,10): print(j) $ time ./loop.py ... real 0m0.018s user 0m0.010s sys 0m0.009s $ python -V Python 2.6.6 
If you want something simpler than Scrapy, then maybe Mechanize and PyQuery are the winning combination?
I believe you've received down votes for a couple of reasons: * Vague, unspecific problem (x is slow) * No example code to reproduce the issue you're seeing Basically, this is the equivalent of someone popping into #python and saying "my python is broke". If we could run your code we could provide anecdotal "works here" evidence that would suggest it's something with your environment. If it runs slow on our systems too, we could look at what kind of algorithm and python objects you're using. I've seen a function go from 10's of minutes to completing in just a few seconds by changing a line or two. In general, python is plenty fast enough for the vast majority of tasks. Especially if you use numpy or other specialized libraries. In the cases where it is not, using something like Pyrex, Cython, etc. to create C modules will bring you very, very near native C speeds. Of course, if you just write a C module for some intensive number crunching you _are_ at C speeds.
You're basically just testing the startup-time of Python there.. $ time python loop.py &gt;/dev/null real 0m0.028s user 0m0.012s sys 0m0.013s $ time python donothing.py real 0m0.027s user 0m0.012s sys 0m0.012s $ cat donothing.py #!/usr/bin/python pass
Just an observation that this is not an example of Pythonic code--getters, functions that should be methods, etc.
Interesting, I chose declarative couple of years ago instead of Elixir and since then I've occasionally envied how much simpler declaring model relations is with Elixir. But maybe I made right choice after all ...
&gt; smisk.mvc – (Transparent) Content Negotiation (TCN/CN), class tree-to-URL mapping, templating, ORM (Elixir/SQLAlchemy), etc. That sounds pretty similar to what a framework like Flask provides.
 import numpy as N from time import time import matplotlib.pyplot as plt import matplotlib.dates as D def gen_data(npoints, delta): '''Generate some random data and an axis of evenly spaced time points.''' now = time() x = N.arange(now, now - npoints * delta, -delta) y = N.random.standard_normal(size=x.size) z = N.random.uniform(size=x.size) return x, y, z def make_graph(npoints, delta): x, y, z = gen_data(npoints, delta) x = N.array([D.seconds(t) for t in x]) fig = plt.figure() ax = plt.subplot(111) dateFormatter = D.DateFormatter('%b %d, %H:%M') ax.xaxis.set_major_formatter(dateFormatter) plt.plot_date(x, y, ls='-', c='blue') plt.plot_date(x, z, ls=':', c='red', marker='*') plt.xlabel('Time') plt.ylabel('Some values') plt.legend(('Gaussian distributed values', 'Uniformly distributed values')) plt.title('An example plot') fig.autofmt_xdate() plt.show() if __name__ == '__main__': make_graph(100, 36000)
You can code all that in C so-to-speak. It's not aimed at the same things as Flask. For instance, Spotify's website would never run on Smisk. Their webservices do.
How does it compare to sickbeard for TV?
A comprehensive set of benchmarks, including pystone and several that are better than pystone: http://hg.python.org/benchmarks/
Agreed. I use SQLAlchemy with its declarative base and I am glad I didn't bother with Elixir. The main advantage of using straight SQLA, is that if I run into a problem, I know the answer will be in the SQLA docs and if not, I can post on the SQLA mailing list and someone will help. If my code were mixing in Elixir, I'd have two separate places to search through to troubleshooot problems and people on the SQLA wouldn't be able to help since most aren't famliliar with the stuff Elixir adds.
Really, it would be better to just have it be a freestanding function and get rid of the class entirely. http://dirtsimple.org/2004/12/python-is-not-java.html
Martin Fowler's essay on mocks is a pretty good exploration of what they offer, although he isn't ultimately a huge fan of them: http://martinfowler.com/articles/mocksArentStubs.html
People generally want to help but don't want to waste their time and don't want to feel like they're doing someone else's work for them. This page [http://www.catb.org/~esr/faqs/smart-questions.html] has good advice on how to ask technical questions on mailing lists but it also applies to reddit, stackexchange, etc. Basically, explain your problem, include relevant technical details and tell what you've already tried. 
Thanks. I admittedly wrote up my request poorly. Including some source would have been better, since then it's easier to say "Oh, adjust this line" or whatever.
I tend to use unix tools (cut, sort, uniq, grep, head, tail, awk, wc) to wrangle data files but this looks interesting. Ability to read from stdin would make it easier to integrate with other tools..
I added the --delimiter option 
Done. Just run it with csvstudio.py &lt; input.csv 
It's an outdated book that's less than a year old. That's bullshit. The whole thing about doing it "the hard way" is just braggadocio. That's bullshit as well. Maybe I'm a little too harsh, but I really don't like the approach Zed took with the book. 
&gt; EDIT: I quickly realized I should return instead of print, but I'm still getting a string error. How did you change your code? I could give you a solution that works, but I think hitting every bump on the road is better when learning something :)
Your indentation in the else case is wrong (1 space instead of 2)
Could do a string interpolation instead of the concatonation: 'Number of donuts: {0}'.format(a) will replace the {0} with the string representation of the first parameter to format.
There's a difference when you print with the syntax 'a,b' and then return a,b. When you return a,b, you return a list of items, but printing will print in that format. What you're doing is returning None at the end of the function (until you return a string that contains the answer). You should return a string added together. Here's my solution: def donuts(count): a = int(count) if a &gt;= 10: a = "many" return "Number of donuts: " + str(a) 
Can you look at what i got to work?
o_o
looks much simpler than mine, I'm going to run it and see if it passes this exercise. OK, it passes... and now I see where I can type less. Thank you.
Looks like someone's mind just got blown by Python!
When it comes to functions that have a single condition with two outcomes, sometimes you can reduce the code by using return statements, which exit out of the function when called instead.
It looks great. I would change it to return only once at the end of the function. In fact, what Le_Broccoli wrote is essentially the same, but it only returns once. Multiple returns can often be the source of the 'hackery' feeling.
that works too: return "Number of donuts: %s" % a also possible: return " ".join(["Number of donuts:", str(a)]) 
 def donuts(count): return 'Number of donuts: {num}'.format(num=count if int(count)&lt;10 else 'many') ps: don't code like this. edit: In response to your posted solution that works, let me just say you don't need the else statement. Once you return something, the function stops running e.g. &gt;&gt;&gt; def foo(a): if a is None: return 'OK foo is gonna stop running now and return this string' return 'This will only run if "a" is not "None".' &gt;&gt;&gt; foo(None) 'OK foo is gonna stop running now and return this string' &gt;&gt;&gt; foo('A string is not None') 'This will only run if "a" is not "None".' 
The answer in your second edit is fine, but a few things to observer: * The problem says it gives you an integer. There's no need to convert the argument into an integer in the first line of your function. * Don't just use "a" as a variable name. It works, but it doesn't describe what you mean. * Your better off using string interpolation than concatenation; that's just how people tend to do it in Python. * Again, no need to cast things as a str in your result. So if you took these suggestions you'd probably end up with something like: def donuts(count): num_donuts = count if count &lt; 10 else "many" return "Number of donuts: %s" % num_donuts When you get a bit better at Python, read this: http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html It'll really help you write cleaner and more readable Python code.
The first example is rather "oldskool" and the second one is just silly, being complex and all.
oldschool, maybe, but less typing. silly, on the contrary. it is faster than using % or +, because it allocates memory for the complete string at once, while the other methods create parts of strings and then a new string with all strings combined. don't know about using format(), but if you ever were to output a lot of data from lists as formatted strings (think csv), it would be silly to use %, + or format(). with regard to this example even using string manipulation is "silly"... just return "Number of donuts: many" in the else part... but since this is about learning, you should not dismiss other options so quickly.
Thank you
That was thought-out and explained very well. I hope you teach programming, because if not, you should.
this is probably the easiest way: def donuts(count): return 'Number of donuts: many' + "".join(["\x08\x08\x08\x08%4d" % x for x in [count] if x &lt;= 9]) tested on bash
is this too complex??? def donuts(count): return 'Number of donuts: many' + "".join(["\x08\x08\x08\x08%4d" % x for x in [count] if x &lt;= 9]) 
Do you have a todo list for it yet?
Agreed, but it seemed like a tutorial or something similar, so I figured it was building up to something that may or may not require a class. If that is all that is being done, you should certainly look the class.
- add auto detection of col types - add ability to spit out a web2py models with lookup tables from the data in the csv (*) - integrated with web2py wizard to auto generate an app based on the content of the csv file. (*) Could be used by django and sqlalchemy too, that is why I made this BSD and not part of web2py. Yet they are still voting me down because I am the author. :-(
Not only is it kind of a jerky thing to just fork a project because you don't like the web framework, not changing the name is likely a license and/or trademark violation.
now works with 2.4 too: donuts =lambda count: "Number of donuts: %s" % (count &gt; 9 and "many" or count)
You should tell the author. I do not know him/her. I do not even know what this does. Anyway, embedding a name into a larger name is not normally considered a trademark violation. To the author credit, he/she is probably doing it out of respect for the original project. Moreover, although I have not looked at source code, I do not think it is a fork. It must be a complete rewrite since the framework is quite different. Rewrites are not forks and not regulated by copyright law, only by patent law. EDIT: I did not realize "pootle" is an [english word](http://www.urbandictionary.com/define.php?term=pootle) of common use, which makes your post invalid. EDIT: Looked at the source code. Definitively not a fork but complete rewrite and still work in progress. EDIT: ... and I read the project description again: It does not say anywhere he does not like Django.
**This project currently has no downloads.** sigh
Wait, so you posted a link to a project solely on the basis that is uses your web framework, not because you actually think it is an interesting project?
Look harder. You should use mercurial: hg clone https://csvstudio.googlecode.com/hg/ csvstudio It consists of a single .py which in fact you can download here: http://code.google.com/p/csvstudio/source/browse/ 
It works, but it's not a good example of Python code. 
Honestly ... keep it simple: def donuts(count): a = int(count) if a &lt;= 9: return a else: a = 'many' return a print 'Number of donuts: ' + str(a) Here there is a nice separation between the function and the formatting of the output. These should always be separate. You're doing great ... I hope these lazy Sunday exercises turn into something more!
For this particular case "".join, is silly. It is also *slower*. Measure, don't assume: mg@platonas:~ $ python -m timeit -s 'a = 10' '"Donuts: %s" % a' 1000000 loops, best of 3: 0.332 usec per loop mg@platonas:~ $ python -m timeit -s 'a = 10' '" ".join(["Donuts:", str(a)])' 1000000 loops, best of 3: 0.668 usec per loop The slowdown is easily explained: you need a global name lookup for str, another one for str.join, and then there's the creation and deallocation of a new temporary list object. ''.join() idiom is appropriate in many cases, where you're constructing a long response from multiple bits. It's not appropriate here, when you're formatting a single message. Readability counts.
I guess I did not express myself clearly: I do not know how this works inside (did not look) and I do not know what this can do in comparison to the original pootle because I have not heard of pootle before. I do understand what it is intended for. I posted this link because it showed up in a search and I though it may be useful to reddit readers. Do you realize you are more touchy than my old aunt? Calm down. Have a drink. You show up in almost everyone of my threads for one reason or another. I thank you for making life more interesting. At pycon I'll buy a drink.
 donuts = lambda n: "number of donuts: {0}".format("many" if n &gt;= 10 else n)
Yes.
yea it was mostly a joke :) it relies on using the backspace char (hex 8) to overwrite 'many' in the case of count being &lt;= 9 and replacing it completely with the number and using the "4" in the print specifier
 return strB2 + strALAST, strA2 + strBLAST returns a _tuple_ containing two strings, strB2 + strALAST and strA2 + strBLAST. You want to figure out some way (ELTHR) of joining those two strings appropriately, i.e. with a space between them. I don't want to merely restate your question, but you already know how to concatenate strings. How can you concatenate strings "pox" and "mid" to get "pox mid"? Hint: you can use more than two strings.
Can you elaborate a bit more. The tree is a class with different methods: insert, delete, lookup... What's not Pythonic about that?
last line should be: return strB2 + strALAST + " " + strA2 + strBLAST
BIG SPOILER: However, I would do it like so: def mix_up(a, b): return b[:2] + a[2:] + " " + a[:2] + b[2:]
Also, so long as you're looking for friendly feedback, strALAST = a[2:] seems a little more natural to me.
im still trying to grasp [:], but what you said makes a lot more sense.
i knew i was over doing it setting all those variables. my grasp of [:] is much better now. thanks
It's code like this why I love Python.
so setting all those variables would work if i could format my return correctly. good to know.
The [preferred](http://docs.python.org/library/stdtypes.html#str.format) way now is to use the .format method, so using this your example would be: def mix_up(a,b): return "{0} {1}".format(b[:2] + a[2:], a[:2] + b[2:])
Type of num_donuts changes based on count. Looks ugly.. but whatever.
i used a bunch of lines setting variable i didnt really need, but even so i can still use that output to get the correct answer.
He has a point... Python does sound like a man's name. I mean it has Freudian innuendo written all over it.
This.
Apparently you don't follow Python development???!?
Very pythonic. I don't see the need for string appends, though. ([ref](http://skymind.com/~ocrow/python_string/)) def mix_up(a, b): return "%s%s %s%s" % (b[:2], a[2:], a[:2], b[2:]) And to the OP, [docstrings](http://diveintopython3.org/your-first-python-program.html#docstrings) are better than comments for explaining function usage. That way someone who doesn't care about the particulars of how your function works (eg "#gets first two letters of string a") can use help(mix_up) to learn the purpose and usage of the function. def mix_up(a, b) ''' Given strings a and b, return a single string with a and b separated by a space '&lt;a&gt; &lt;b&gt;', except swap the first 2 chars of each string. e.g: 'mix', pod' -&gt; 'pox mid' 'dog', 'dinner' -&gt; 'dig donner' Assume a and b are length 2 or more. ''' return "%s%s %s%s" % (b[:2], a[2:], a[:2], b[2:])
Why is this preferred?
I last typed a bit of code many years ago into a pirated version of VB6. I was, an AOL Add-on Coder, or AoHell "proggie" maker; what seems like a lifetime ago. At that time I had been around long enough to design .bas "modules" that other people used to create their own "proggies". WaReZ servers, IM bombers, auto-phishers, chat scrollers, and outright password stealers all made in the name of fun. It wasn't until today that I remembered how much fun coding actually is. Thanks to the post in /r/programming this morning I know what I'll be learning in 2011. Python. Again, thanks for the help.
s[0] == s[:1] String slicing is cool, but using it to get a single element is a bit excessive IMO.
at least one reason is that instead of: 'Why did %s chicken cross %s road?'%('the','the') you could now do: 'Why did {0} chicken cross {0} road?'.format('the')
I used to use crecord, but then I found [commit-patch](http://porkrind.org/commit-patch/). It lets you edit the diff in a text editor, and has great Emacs integration. It works with git, mercurial, and other VCSes. The only problem I have with it is that it's very picky about the changes you make to the diff. In general, it's OK to delete entire hunks and edit added lines (including adding more lines), but beyond that it seems rather arbitrary as to what it will accept. The good thing about the pickiness is that it has never corrupted a commit. 
I don't know. It's just something I've noticed in the documentation. I'm sure there's a PEP for it somewhere that discusses the reasoning.
We maintain an updated/enhanced version of that at http://codespeak.net/svn/pypy/benchmarks/ It includes stuff like twisted among other newer things. Probably would make a lot of sense to merge it back into hg.python.org, but did not happen so far
I had been meaning to pick up Python, but never got around to it. Then I saw that post, and said why not. It was a great introduction to the language without taking too long to get through the basics. I have to say that I am thankful I came across that post. 
Probably because "str" % args or "str" % (arg1, arg2) is specialized syntax (and an irregular one since taking multiple arguments looks different) whereas "str".format(...) handles that behavior but as a function. Special cases aren't special enough (from Zen of Python) and so the specialized syntax is getting the nix. The same thing happened to the print statement turning into the print function (in Python 3000). (edit for clarification)
It's great that that Google lecture posted in r/programming today has gotten so many people into Python. Python is *the* best general purpose language in-use today. Best of luck to you.
Can not unsee robot granny: s[:1]
I don't see Elixir as so bad that you have to NOT recommend it. Even the SQLAlchemy 0.6.6 docs you linked to give it a hat-tip: &gt; Yet another “declarative” method is available for SQLAlchemy as a third party library called Elixir. This is a full-featured configurational product which also includes many higher level mapping configurations built in. Like declarative, once classes and mappings are defined, ORM usage is the same as with a classical SQLAlchemy configuration. I've used Elixir from before the time that SQLA declarative existed, and although it has a couple of warts, it worked pretty much as expected. It's a very thin wrapper over SQLAlchemy, and it doesn't incur any run-time penalty which might normally be thought implicit in the term "wrapper": the Elixir query object is basically a *sqlalchemy.orm.query.Query* instance. Elixir's main value addition is in the declarative syntax for relationships. It also makes it easy to add e.g. versioning for optimistic locking, or audit trail fields to entities. On some of my projects, I defined an *AuditEntityBuilder* class based on Elixir's *EntityBuilder*, which then added "updated_by" and "updated_on" columns to specific entities just by adding an *auditable()* to their class definitions. That means less boilerplate to worry about :-) For most uses, SQLA declarative is fine. There *are*, however, situations in which Elixir makes one's life easier, so I'm glad it's around.
That's cool! a small hint, though: don't describe your functions in comments above them, place those exact comments in [Docstrings](http://diveintopython.org/getting_to_know_python/documenting_functions.html) - i.e. in strings directly below the ``def`` line. That way you tie them to the function, can look at themusing the interactive shell, can generate automatic documentation (epydoc), etc.
`%` isn't a special syntax; it's identical to the syntax used for other operators like `+` or `*`. I don't exactly know why it's being phased out, but it's not to simplify the grammar.
hey cool, I've also been going through that presentation as well. 
You can also do [unittests](http://docs.python.org/library/doctest.html)! 
in all honesty, if you know python pretty well, you should save your money and read the online docs of the various tools mentioned. this book is not worth its price.
Sounds very interesting - thanks for the pointer. I'll have to check it out.
Python does work in the commandprompt in windows. Just make sure that the folder "python.exe" lives in is in the path, then run 'python'.
Well, first of all, since you're on OSX, get [iTerm](http://iterm.sourceforge.net/). For a primer, take a look at [this](http://www.ks.uiuc.edu/Training/Tutorials/Reference/unixprimer.html).
&gt; with regard to this example even using string manipulation is "silly"... just return "Number of donuts: many" in the else part... but since this is about learning, you should not dismiss other options so quickly. There's a difference between DRY and writing overly complex code. mgedmin explained it very well. As a rule of thumb, I wouldn't use ``join`` if the number of items is a small constant, so that using string formatting for it would not exceed EOL79.
&gt; oldschool, maybe, but less typing. In 2.7 you can use '`{}`' for automatic format argument specifier. With PyDev's autocompletion I have to type '`.fo&lt;ENTER&gt;`', instead of '` % `' (i.e. one keypress more), but then I don't need to add, and, which is even more important, think whether or not I should add, parentheses around the string interpolation and around its second argument. After I installed 2.7 I switched to `.format` cold-turkey.
#bash on freenode, checkout the resources in their topic and stick around for live support!
Or use [Google Refine (formerly Gridworks)](http://code.google.com/p/google-refine/) and be done with it.
I completely concur. Back at work we had people fiddling with locks and home-rolled lockless queues and the like to try and get our proxy server to "use all the cores". My suggestion of "just... run more than one server process on that box?" was greeted as if I was a heretic.
Prove it. : ) a = 'Gorblax oggled the muffins.' How would you use the string range operator to pull 'Google' out of a?
&gt; Not only is it kind of a jerky thing to just fork a project because you don't like the web framework... Did you read the project description before deciding to call someone "jerky"? The author pointed out a couple of problems he had with the original Pootle and then explained, "I decided to develop a new version of Pootle changing what I didn't like" -- nothing to do with not liking the web framework. But what if the author prefers web2py over Django and did create the re-write solely to port the project over to web2py? What would be wrong with that? Now web2py users have a ready-made translation tool at their disposal. Do you have a problem with that?
Good job, it should auto-detect from the header though.
Why do you want go to "website" that much? As long as you click and and can read the information, I don't see how it can be more "pain in the ass", HTML or PDF. 
I tried to drag the cmd window :(
Just out of curiosity, what is the wallpaper behind those windows. Looks like it could be pretty cool.
His code may look like this, perhaps? It's the only way I can replicate the results. import time for i in range(1,10): for j in range(1,10): time.sleep(0.5) print(j) 
Go on...
oooooooh, hang on. making breakfast.
\*thumbtwiddle\*
That blog post is just a post by the author of that book.
Its one of the HD holiday wallpapers I torrented for my PS3 Christmas-day slideshow. [the image](http://imgur.com/ymkq2), [the torrent](http://extratorrent.com/download/2342393/350+Beautiful+Christmas+Full+HD+Wallpapers+1080p.torrent).
yeah, its just hiding a bunch of my experiments with slicing in the Python shell. :)
I think this is the exercise you're referring too... # C. fix_start # Given a string s, return a string # where all occurences of its first char have # been changed to '*', except do not change # the first char itself. # e.g. 'babble' yields 'ba**le' # Assume that the string is length 1 or more. # Hint: s.replace(stra, strb) returns a version of string s # where all instances of stra have been replaced by strb. def fix_start(s): strReplace = s.replace(s[:1], '*') return s[:1] + strReplace[1:] Limited knowledge here, I'm sure there a way to pass this in one line but I couldn't think of a way without slicing the first char and returning it + the modified [1:]
Those are the Google guys comments, I was commenting after code, but on the same line when i was struggling with some of the logic. Oh, and then I'd comment out my first try altogether when I was able to get it in fewer lines.
 def fix_start(s): return s[:1] + s.replace(s[:1], '*')[1:] One liner for you.
Thanks!
Stock Terminal + http://blog.toddwerth.com/entries/show/6 works great for me. No need for iTerm in my opinion.
Except % has another more predominant meaning: modulus. That's my guess as to why format function is better.
 return a[:2] + a[8:9] + a[10:13]
Speaking as someone who has been using SQLAlchemy since the early days (0.1), I'd say that it's highly unlikely that you'll end up in a clusterfuck. In fact, it's much more likely that it'll be the opposite of a clusterfuck, whatever that's called. I've known people that started using SQLAlchemy with a definite write-your-own-SQL bias and ended up preferring a combination of SA's ORM (90%) and SQL expression language. In my current code base, which contains *lots* or ORM classes, there is maybe one SQL statement... or maybe I removed that.
Its the last bit of the s.replace I wasn't getting. Now I see it belongs outside of the paren to work. Thanks.
Exactly what I was looking for! Definitely great hearing this from someone with prior experience :)
If I understand your inquiry correctly, yes, you can write SA models for existing database tables and interface with them via sqlalchemy. I did this for Radis authentication servers backed by MySQL and it worked like a gem.
It does not serve the same purpose and you cannot script google refine. 
I'd just like to point out that the same reasoning advocates removing `+` for string concatenation because it predominantly indicates addition.
Damn. Almost... return a[:2] + a[8:10] + a[11:13] Either way, how'd breakfast go? : )
My point was that you are only using the slice to return a single element, A situation in which most people would just access it by index. s[:1] returns the first character using a slice (all characters before the second) s[0] returns the first character by accessing it.
The beauty of SQLAlchemys [expression language](http://www.sqlalchemy.org/docs/core/tutorial.html) is that you can build more complex queries without having to resort to string concatenation. This alone would be a reason for me to use it. It keeps getting better though. :)
http://www.dabeaz.com/python/NewGIL.pdf Or do you mean just having any kind of GIL? Between the existing multiprocessing and the new concurrency modules I don't know why the GIL is even an issue. Also, there are Python implementations without any GIL, but that doesn't address your issue, which is the concept of the GIL.
It is not the same. s[0] can fail with IndexError while s[:1] cannot. Try with s = "". Edit: more generally, if s was a list, s[0] would yield an element (or faill) and s[:1] would yield a list containing the first element (or the empty list).
ahem... you said a = 'Gorblax oggled the muffins.' not a = 'Gorblax oggled the muffins' Spinach and Mushroom omelet. It was awesome.
OK, I understand now.
I guess same thing can be said to *. &gt;&gt;&gt; 'a' * 10 'aaaaaaaaaa' :P But + and * symbolically makes sense even in the context of strings. %'s meaning in string replacement context doesn't feel natural. I'm not arguing for % nor format. Just making observations.
Suggestion: if len(s) &lt; 2: return '' return s[:2] + s[-2:] 
You might be interested in [my offer over at /r/mentors](http://www.reddit.com/r/mentors/comments/czwc4/offer_i_will_teach_you_python_beginner_or/).
The exercise clearly says "assume the length of the string is 1 or more." A string with len &gt;= 1 will always have a [0] element.
two returns?
I hope to do this same thing over my holiday break...
A fustercluck !
Should be open source and able to be installed as a wordpress plugin I reckon. (Also need the toolbar)
In the UK we might say Shopping for ideas. Also we don't say "Write me", you might say "Write TO me"
While you definitely have excellent tastes in breakfast items, your understanding of string indices could use a bit of refinement. Recall several things: * indices start at 0 * they only start from the end if negative * the string range accepts a start index and an index at which to "stop grabbing" [Take a look at the string with each character's index shown below it.](http://i.imgur.com/Ltvew.png) As you put together, we need to concatenate three separate parts of the string to form 'Google'; we need "Go", "og", and "le". For "Go", we need characters 0 and 1, or `a[:2]`, as you said. For "og", we need characters 8 and 9, which is represented in the string range as `a[8:10]`. And for "le", we need characters 11 and 12, `a[11:13]`. Now, then, might you explain why you reckoned chopping the period would change anything? : )
if len(s) &lt; 2 the function returns the blank string, ending the function. if it's &gt;= 2, the first return is skipped and it returns s[:2] + s[-2:].