&gt; Last weekend in a few hours I got a a couple of pages working in django but most of the information online is horribly out of date Really? Did you check Django online docs? Also, one good thing using popular framework like Django is that most of your problems have already asked by someone else on the web. &gt; I am a book man myself and like to read a good book on the subject, with django everything seems horribly outdated. I doubt you'll find updated (printed) books in other frameworks. You can always bet their online docs are up to date. For just blog (with some static pages), I prefer static/offline bloging engine. There are some python products for this, my favourite is [blogofile](http://blogofile.com) If you want to go dynamic, [pyramid](http://pylonsproject.org) (pylons and repoze.bfg merge) and [flask](http://flask.pocoo.org) are good alternatives from django. I recommend pyramid (great community!), since I never tried flask. However, I really enjoy reading Flask docs.
I'm not sure what your experience is with evolving frameworks (I'm guessing mainframe platforms are pretty static), but Django has a pretty stable API as far as web frameworks go. "Most of the code changes" is an overly broad and inaccurate statement as far I'm concerned. The core concepts and APIs of Django haven't changed much since 1.0. The most dramatic change I've seen is the revamping of the generic views from 1.2 to 1.3 (which, granted was a big change). If you were planning on using generic views for your blog, then I can see that being a bit intimidating.
I've added you as a collaborator. What do you want to work on? There's a tonne of stuff that needs to get done before I'd even think of making it into a package. Here's what I can think of * Storyline * Planning out characters, items, gameplay mechanics * Item development (stats, description, usage) * Rendering of game into console * Capturing keystrokes for player movement * AI for zombies * Menu for saving / loading games Plus a lot more. Any help that you can provide is awesome. 
I have already gone through the Django tutorial, but the rest of the site in my opinion reads horribly, nothing against Django as a whole, just people learn in different ways, I feel like the Django documentation is just shouting functions at me, saying this and this do this and this, no explanation, nothing. Thank you for taking the time to get me a couple of links.
TIL that slices don't raise IndexErrors.
We have code from the 80's running in production on the mainframe, with the latest version of the OS and language (in the python world I have noticed this is very uncommon as changes are made freely) Anyway back to the point, if I am to continue to learn Django would you be able to offer any next steps? Like I said I have a very crude (aka not ready for production) blog home page and a page to display the longtext, comments etc but that is all I could get from the tutorials.
I find it very difficult to take you seriously after reading this comment. You come off as a troll, but I'll take your comment at face value anyway. I don't think you're going to find a web framework that is going to have no changes from version to version (that's kind of the point). The kind of systems to support the rapid development requirements of web projects are going to evolve much faster than what you're used to. Fortunately, there are tools to mitigate the issue. For Python projects, I would suggest using virtualenv+pip and install a specific version of Django (I'd suggest 1.3) and maintain your project on that specific version. Once your project is built on 1.3.x, you can use that as long as you like or independently test it against future versions once they are released or when a new feature is introduced that you want to take advantage of. I specifically suggest that you do research on pip requirements files and there use in bootstrapping projects.
The Django by Example: [Simple Blog Tutorial](http://www.lightbird.net/dbe/blog.html) was written against Django 1.2, but I didn't see anything that would not work in 1.3. Try that one out.
Flask is a micro web framework which has very nice documentation. My suggestion is anyhow to get familiar with python and web technologies looking into developing web application. There are simpler ways to have a personal blog than to hack your own blog software.
&gt;most of the code changes within Django version to version So develop against the most recent version, add that to your libs directory, and don't update it unless you want new functionality. Also, this is basically wrong, Django has excellent backwards-compatibility. You might have an easier time with Wordpress, which is a blogging engine written in ::gasp:: PHP. But if you want to learn Python this would be a fun project. There are plenty of blogging engines for django, which is designed to be modular ([brief list](http://djangopackages.com/grids/g/blogs/)). Django-CMS may work as well.
Looks very clean and thought out. Congrats! Bookmarked for potential future code steal. ;)
I'll definitely give this a try. I'm using the OpenCV Python bindings right now for face detection and they do leave me wanting.
if you run it from the terminal, it should give you a stack tarce. otherwise, it should also save log files in your ~/.kivy directory, unless you have changed the default config.
I actually was pretty convinced by the PEP. This feature doesn't really mix well with function annotations and new stuff coming in function definitions, pretty much no one knew about it or used it even if they did; it seems like it was a "neat" feature that just wasn't worth the trouble.
When you call the 'run' function, set host to '0.0.0.0' instead of localhost.
I've subclassed it to allow adding a class='today' to the appropriate table cell. It's not too difficult, but it is tedious to manipulate html strings. https://gist.github.com/789965
Thanks a lot for your response, it looks like you've used your CSS to sort of pre-define the properties for the classes the calendar writes. Am I right? That's probably what I needed to do for the style all along. This definitely helps, thanks again.
Both options are valid if used properly, but mostly depends on the maturity of the project. If you have a project with one or two developers, then the cost to setup properly may be too high. Using the full stack - virtualenv, buildout and pip - is nice, but this also means you have to make sure, that "network" is available, usually meaning you need to set up a PyPI mirror and/or proxy. Also, on a similar note, using Django trunk sounds like you're on a bleeding edge, when you're just fooling yourself. There will always be breakages caused by code changed elsewhere (not in your project) and you will grow tired of this, potentially even abandoning the project. Test driven development may help to some degree with this, but they also represent additional cost to development: tests must be written, run, and monitored continually (or at least periodically) if you don't want to wake up one day realizing you're digging through a code full of worms. Also, companies tend to prefer inclusion of dependencies. This reduces start up costs and overhead as you're initially (when first developing product) not interested in security or maintenance. Remember when Google first released Chrome? It was shipped with outdated libpng containing security hole, because Google copied over external projects into chrome repository. That being said, I don't think an open source project should be *maintained* that way. It's what we usually see in and get out of companies, who don't want to spend wasting time on OS integration and bugs, which occur due to changes in dependencies, instead of using that time to create new stuff somebody has asked for. Open source project "bet" on users contributing back to the project. Also, for example, django-sentry was first an internal project in Disqus, when they decided to open source it, David rewrote the whole thing because (I can envision) it was both heavily dependent on internal Disqus code and missing developer infrastructure such as tests and hooks, the important bit being that the actual first product was written before, but was not released and maintained. tl;dr - Virtualenv, buildout, pip are nice, but have high set-up costs. If you're prototyping, you probably want to avoid buildout. If your open source project is mature and has other users than yourself, you will need infrastructure to handle dependencies properly in an open-source way.
[This link](http://www.lightbird.net/dbe/blog.html) that I added to another reply has a more full featured blog tutorial. The Django by Example looks generally to have some good tutorials that are more than the usual trivial apps. You can also check out [this list of Django based blogs](http://djangopackages.com/grids/g/blogs/) to get an idea of what the scope would be for this kind of project. Blogs can be deceptively simple on the surface. The Django Practical Projects book is also pretty good, but print publishing usually lags behind, so the info on generic views will be out of date for 1.3. The Django community on (Convore)[http://convore.com/] is very active and helpful. That's good for real time discussion. If you are looking elsewhere [web2py](http://web2py.com/) is well documented and the creators are active redditors. Web2Py incorporates some architectural decisions that give it a mixed reputation in the Python community at large, but it has a devoted community, so you might give it a look too.
Then, as I said, you are almost certainly not using numpy correctly.
Is this full-time or contract, and are you open to telecommuting?
I'd love to help! [Here's my Github](https://github.com/josephbleau). I think I know enough relevant python to be useful.
full time, no or minimal telecommuting. I'll edit the post, thanks.
Awesome thanks I'll try this tonight 
Seems similar to the "modules" UNIX package. What I'm curious about is why they don't just use virtualenv for this purpose. It seems it would make it more obvious which packages are actually being used, as you explicitly install them in your virtualenv.
You definitely don't want the trunk version in your code, otherwise you'd be facing sudden regressions here and there when django developers would work on the code. Also, have a look at django trac, there are lots of bugs open. Do you need them in your code? Django maintains backward compatibility almost constantly, so migrating to a newer django version is a breeze. Definitely easier than making fixes to the trunk, not mentioning your fixes are going to become obsolete anyway. There is an alternative for virtualenv/pip. It is called buildout and it has already been mentioned. Both virtualenv/pip and buildout has a lot of functionality overlapping, so one has to know project requirements very well to make a choice. In general buildout excels at building the project: packaging it, pushing it to our local PyPi repo, etc. 
You beat me to it xamox ಠ_ಠ! Now get back to work ;) I have a background in recognition systems and I would love to help. The question is do you want to do face recognition (i.e. recognizing individuals) or face detection? I was going to try to write some code for SVMs and Eigen faces for simpleCV next week. I would love to have a "customer" so to speak. SimpleCV 1.1 should be out next weekish, I would suggest using the dev branch. 
No problem (though that eliminates me :D).
Thanks for the feedback, I totally agree it can be confusing. We'll look at standardizing this menu to make things more familiar in the next version.
MediaCore can definitely host and organize your videos, and allow searching, but we don't have IMDB integration. Perhaps that's something the open source community could contribute :)
Thanks for checking it out!
Thanks.
Interesting. You may want to cross-post with /r/computervision.
Whoops, sorry about that, correct it's http://simplecv.org. Thanks to anyone who tries it, any feedback would greatly be appreciated via the mailing list or even the ticket system. Even if it sucks we want to know.
Cool, speed is one of my major complaints with SCons. 
didn't someone post a nice blog recently about accepting the magic in python web frameworks?
i don't understand how this is reinventing the wheel? it's more like taking a wheel (and axis and drivetrain, etc - i don't know enough about cars to make the metaphor perfect) that somebody else has already made &amp; tested and putting it on your car. reinventing the wheel would be foregoing opencv, writing an svm implementation, and training it to detect faces. 
Just do it as a webapp and use something like the [JS InfoVis Toolkit](http://thejit.org/static/v20/Jit/Examples/ForceDirected/example2.html).
it's awesome, i've been using it for sometime now and it is really a great job 
I'm looking forward to your implementation. I played around with opencv haar detection and noticed that the training was VERY slow. like a week or so... and you had to run it maybe more than once to get im proved results. Also if you would run the trainer on multiple cores, the results were worse, which was totally unexpected. I then found [the work of Pham Minh Tri](http://mtpham.sharkdolphin.com/index.php?option=com_content&amp;view=article&amp;id=65:fast-training-and-selection-of-haar-like-features-for-face-detection&amp;catid=10:research-a-academic&amp;Itemid=9) who sped up the training phase. Now instead of a week it should only take a few hours. Unfortunately his code only runs on older versions of scipy/opencv and he doesn't have time to port it to newer versions.
That level of GUI manipulation and user interactivity sounds like kind of [pygame](http://pygame.org/)-ish to me.
[cheeseshop is one](http://www.youtube.com/watch?v=B3KBuQHHKx0).
Some days ago people here linked to [kivy](http://kivy.org/), which is oriented to multitouch apps, but seems to have what you need for such an interface.
It is easy to come up with one, just imagine any scenario where you have a variable ´s´ then do a list comprehension and name your inner variable ´s´ and don't realize you just changed your value.
Even C++ programmers prefer the form: for(int i = ....) In which case i would be a new variable and not affect your 56 i.
Equity.... /me laughs.
You are familiar with Python's "commands" module, right? It adds tab completion, hints, and history automatically to your program. http://docs.python.org/library/commands.html
I'm working on a module you might find handy: Pygcurse. It's a curses emulation module for Python &amp; Pygame. The code isn't quite finished yet, but it will give you cross platform capability to print anywhere on a screen of any size, and will be cross-platform. https://github.com/asweigart/pygcurse You could also make use of libtcod, which is a rougelike game engine for Python: http://kooneiform.wordpress.com/2009/03/29/241/
You will need a lot more detail than that to entice anyone that isn't a total waste of oxygen. Sorry to be blunt, but this is just generic to the point of humor.
It is built very directly for this kind of structured graph exploration UI :-)
I would've applied if I lived anywhere near NYC and was above eighteen. Sadly, I'm not. I *am* interested in your product now though ("pretty dang ambitious").
Good luck, there's *a lot* of startups looking for talent right now.
You're wrong! wxPython is way better than qt! Just kidding - thanks for the explanation.
Come on guys, cut the cynicism. If I hear of anyone who wants a job w/ a start up I'll pass your info along.
Fair. I was having trouble figuring out an appropriate level of detail and took the easy way out. I'll take another crack at it ...after I write some code. That said, some solid looking people have already replied.
I was intrigued! ...oh. 
"pretty dang ambitious"???? if your product needs a logo, you can use my headshot..
lol, equity? If you weren't aware, there's a tech talent crunch pretty much EVERYWHERE currently. No talented programmer would consider equity as payment under normal conditions, and definitely not now!
Marketing 101: Incomplete, is just a negative word for "Lightweight"... :)
WTF is "Pow"? Like x to the power of y or something?
For those who have no idea what Pow is: [http://pow.cx/docs/](http://pow.cx/docs/)
sorry ...I swore I had put a link there..but not =] ...my fault http://pow.cx watch the screencast (its very short) and you will understand
You can't have a link and text in the same post. Anyway, I don't think there's anything exactly like it. A couple of things are decent but aren't the same; this seems much easier.
heard of the pychecker plugin for vim? what's more vim comes with python nowadays, so you can trigger a check with you favorite tool. nah, not convinced about IDEs...
Because vritualenv comes with it's own set of problems, and we wanted to try to provide an alternative. Also it scales better. Suppose you have 5 optional dependencies of the thing you want to test. Then you have 32 combinations (leave alone different version of packages). You'd have to create 32 virtualenv environments and install the relevant packages into each one, but using this trick you only need 32 registry files.
True. Though python itself is written in C, if I recall correctly. So I guess that would make it understandable if implementation details like that crept into python itself. I guess what I am trying to get at is that I don't agree with the OP that this is "broken". It just doesn't work like they want it to.
What features do you need or like from Pow? I don't quite understand it. Why does it need to use node.js? A single threaded pure ruby/rack (or python/WSGI) server will serve up an app just fine for development purposes. If the goal is to make it easy for designers to run the app it's probably easiest to distribute a virtual machine image with everything set up and running for them. If you're a developer, the process for installing and running a django or WSGI app isn't that difficult. Every framework has a built-in development server. In django, you use: `python manage.py runserver`. In flask, you just run your app: `python app.py`. The hosts file thing is pretty nice though, I do like that.
You mention that you already have some experience with Django, and also that it's a side-project (and you value ease of setup). Sounds like you've already answered your own question: try Django-CMS.
If you don't mind, I'd love to see that hidden markov sentence generator, it sounds cool. 
If you think that someone will steal your idea and whatever you have will become obsolete than either: a) your idea is not that special or b) your team is not that special . Otherwise you have nothing to worry about. If I got $1 for each time someone pitched me a great idea starting off saying, oh I can't tell you until you sign a non-disclose I would have enough extra $ to throw at ideas that ask me to sign non-disclose. Just my 2 cents. 
I didn't see anything about an NDA. PM info -&gt; get job info back.
it was implied
A normal programmer who isn't desperate wouldn't take the effort to PM someone. The fact that they don't list their idea in the description shows that their execution skill is probably mediocre. Also they have to release on demo day anyways and does a few month in stealth really help someone?
Honestly, I would use something in-browser like [fullcalendar](http://arshaw.com/fullcalendar/), not Python.
gunicorn maybe? Or paster?
Sounds like a mind map. There should be some software to take inspiration from.
From the documentation: * [Spam and eggs, the Knights who say Ni, lumberjack, dead parrot, fresh fruit](http://docs.python.org/library/pprint.html) * [John Cleese, Parrot, Michael Palin, and Cheese Shop](http://docs.python.org/tutorial/controlflow.html#keyword-arguments) Videos: * [Spam](http://www.youtube.com/watch?v=anwy2MPT5RE) * [Cheese Shop](http://www.youtube.com/watch?v=B3KBuQHHKx0) * [Lumberjack Song](http://www.youtube.com/watch?v=xToPCaNxaow) * [Knights who say Ni!!](http://www.youtube.com/watch?v=2UbtcmjfKa8) * [Self-Defence Against Fresh Fruit](http://www.youtube.com/watch?v=piWCBOsJr-w) * [Parrot Sketch](http://www.youtube.com/watch?v=npjOSLCR2hE) edit: added self defence and parrot
The "with" statement was introduced in python 2.5.
but the worst algorithmic complexity and given that str has a isdigit method for such a check ...
I too would love to help. I currently am also working on a text based adventure called "Caravan!". I have programming and writing experience. As a musician, I could even write music for the game, as I have done with "Caravan!". 
i found a good woriking tutorial here [http://www.petercollingridge.co.uk/pygame-physics-simulation/creating-pygame-window](http://www.petercollingridge.co.uk/pygame-physics-simulation/creating-pygame-window) its a balls bouncing/gravity simulation from scratch ps: if you try it with IDLE, insert this as last line of code: pygame.quit () otherwise IDLE wont respond well. 
Thanks for the info man, I am going to take a look at these links today at work get a feel for what I need to do.
Thanks for the input, I'll try using the more advanced search options.
Could I see the source code to your Hidden Markov sentence generator? Rather curious.
DictShield looks nice. I probably will try to replace a large chunk of my homebaked REST-JSON library with it.
PM me with info/details. I'd a novice to intermediate programmer and I'd love to get behind you (figuratively). You however need to post more details about how the output should look, nobody seems to have a clear idea of what you're talking about. 
I wanted to try SQLAlchemy (never used any other ORM) and found it too complex. Introduction/Tutorial page was quite huge (not necessarily "hard", just exhaustive). This article is comparing it to the Django's ORM. Could someone recommend me a good starter's guide to SQLAlchemy? Something rather simple (i.e. for someone who is new to ORM).
FWIW I &lt;3 sqlalchemy, and find the django ORM more tricky when doing things I found easy in sql (but sqlchemy easy) - especially when they make new terminology that I need to learn (aggregates) etc..
I have to say Ronacher's blog is very good. Every post I've seen is explained very well with useful examples. I also like the style, nice serif fonts on plain background.
The Django ORM does a lot of weird stuff, but is it possible to make a drop in replacement using SQLAlchemy that covers all the basic use cases?
The best starter's guide to SQLAlchemy is really its own [Object Relational Tutorial](http://www.sqlalchemy.org/docs/orm/tutorial.html). If you want to use SQLAlchemy in any capacity, you'll end up back here having to read it anyway. As you said, it's not "hard" - in fact, this is the simplest and best investment of your time you can make with respect to ORM (if you're comfortable with Python).
zzzeek's article on [magic](http://techspot.zzzeek.org/2011/05/17/magic-a-new-orm/) shows how to write a base class that tips SQLAlchemy's declarative style to go further towards convention over configuration. For example, it builds relationships and foreign keys in one go, and tables don't have to be explicitly named. Armin also has a [SQLa extension](https://github.com/mitsuhiko/sqlalchemy-django-query/) to do Django-style query filtering which he mentions here. As far as drop-in replacements, I think SQLa is flexible enough to replace bits of the django ORM from the bottom layers up. This would be enough to provide much more powerful querying, but not to provide things like composite keys which need backwards-incompatible changes to Django. There were some efforts towards this (django-sqlalchemy), but they petered out, so I may be wrong on how feasible this is. 
This [quick introduction](http://solovyov.net/en/2011/04/23/basic-sqlalchemy/) was posted here recently. It does not include declarative even though it pays off big in terms of concision, so you should look at the official tutorial as well.
Honestly I hate ORMs altogether... it's like "Oh, you want to select a beer? First Build this house around your fridge" Edit: Neat, thanks for the links guys :)
"SQLAlchemy does not override all your columns when you just changed one on update" - any details on this?
SQLAlchemy is more than just an ORM. See [This graph](http://www.sqlalchemy.org/docs/_images/sqla_arch_small.png) SQLAlchemy is incredibly useful even if you just use it for the connection pooling and engine stuff: from sqlalchemy import create_engine db=create_engine("postgresql://user:pw@host/db") for row in db.execute("Select * from inventory limit 10"): print row.id, row.starttime 1 2009-07-03 10:40:01.570326 2 2009-07-04 10:40:01.780605 3 2009-07-05 10:40:02.464687 ... print db.execute("Select max(numup) from inventory").scalar() 8451 print db.execute(db.text("select * from inventory where numup=:num"), num=8451).first().starttime 2011-05-03 10:40:02.661561 The above would work exactly the same on mysql, sqlite, etc without having to deal with differences in the DBAPI. You can start simple, and then map tables, and then move onto ORM type stuff if you want. Nothing is forcing you to use the ORM
sure that makes some sense. although i've found that software devs who know how to find &amp; use the available tools are far "better" at their jobs than people who refuse to draw from the wealth of existing libraries out there, i do definitely understand the sentiment that to be able to use whatever tools properly, you should really know how they work. what kind of performance are you getting with this method? i've used python for a lot of machine learning (academically) but have found it somewhat lags when it comes to actually making production-quality efficient implementations. i'd be interested to see how pypy and/or cython could help with this, though...
In the Django ORM the update SQL statement updates every column whether you changed it or not. SQLAlchemy tracks the columns that were updated and constructs an update SQL statement only involving the changed columns.
Then SQLAlchemy's [SQL Expression Language](http://www.sqlalchemy.org/docs/core/tutorial.html#selecting) - on which the ORM is built on btw - is something for you. :-)
Writing code for an async server like Tornado can be a bit confusing to start. Your code doesn't look any different than an Flask/Apache app until you write something that can block. Examples of things that block are database calls, file reads or network access. When something blocks in Tornado, everything stops. When you are making a call that blocks, you pass along the function you want called when the blocking call returns. In the meantime, Tornado will find something else to do (like answer another request). In practice, you don't just write code as one continuous flow from receiving the request to writing back the response. Every time a blocking call is made, processing tends to pick up in a new function. This kind of breaks up the code in an unnatural way. Something I just found recently that looks interesting is Swirl (http://code.naeseth.com/swirl/). I haven't tried it yet. It uses coroutines to restore some of the traditional flow to webapp development inside Tornado. I wonder if it impacts performance as I think it would exercise the stack a lot. For some reason I find Tornado easier to understand than Twisted. Twisted uses the same asynchronous "pattern" (for lack of a better term to describe it), but seems to complicate things in a way that just doesn't seem to fit in my brain. 
If you know which database system to use and it has a well-documented Python driver, e.g. pypostgres, you should think twice before using an ORM. The truth is it takes more time to learn about these ORMs than to learn about the specific database systems. And then, you'll have to deal with the peculiarities of these ORMs. You might find out that all the ice candies that an ORM gives you, might not worth it.
[SqlSoup](http://www.sqlalchemy.org/docs/orm/extensions/sqlsoup.html) lets you use the SQLa ORM with zero setup.
You have things completely backwards. SQLAlchemy is not just an ORM(see my previous post). It takes more time to learn about the peculiarities of the various DBAPI drivers than it does to learn SQLALchemy.
&gt; f you know which database system to use and it has a well-documented Python driver, e.g. pypostgres, you should think twice before using an ORM. The phrase "Think Twice before trying !" is a clear example of FUD. &gt; The truth is it takes more time to learn about these ORMs than to learn about the specific database systems. This is true, learning two things takes more time than learning one. Using an ORM is not a replacement for having a full understanding of relational databases. This is the core philosophy of SQLAlchemy, which is really not much like whatever ORMs you've used before that have let you down. 
Pygame has a [font module](http://pygame.org/docs/ref/font.html) than can be used to draw text. But for something like Dwarf Fortress it'd also be worth checking out [curses](http://docs.python.org/library/curses.html) in the standard library.
I largely agree, but generic foreign keys, for instance, are not supported with grace in SQLAlchemy. (Yes I have example code that works, but it is a lot messier than generic foreign keys in Django which are also quite messy.) Flask integration for this? Not likely unless l find time to cobble this together myself someday. Also there are places where certain SQLAlchemy requests can be used directly in templates, but similar slightly more powerful requests cannot be used in a template without a lot of work. The dividing line between these cases seems to be pretty arbitrary. So I agree that SQLAlchemy is powerful and has much to commend it (especially the seamless access to low level SQL), but it also has more design warts than I expected. While most complex software libraries become increasingly contemptible with use, I didn't expect that SQLAlchemy would begin to approach my contempt levels for the Django ORM as quickly as it has. Not to misunderstand, both SQLAlchemy and Django ORM deliver a lot of value to me even though I am quite comfortable with raw SQL as well. Still in all I look forward to trying out a graph-oriented DB soon and I won't be surprised if it replaces most if not all of the DB requirements that are serviced by postgresql in my current Flask-based project. (We also use metakit for large transient tables.) 
&gt; I largely agree, but generic foreign keys, for instance, are not supported with grace in SQLAlchemy. This is because there is no such thing as a "generic foreign key" in relational databases. You're referring to a "polymorphic association" and SQLAlchemy has a recipe for it, which makes proper usage of foreign keys unlike other implementations, introduced here: http://techspot.zzzeek.org/2007/05/29/polymorphic-associations-with-sqlalchemy/ &gt; Also there are places where certain SQLAlchemy requests can be used directly in templates, but similar slightly more powerful requests cannot be used in a template without a lot of work. The dividing line between these cases seems to be pretty arbitrary. SQLAlchemy has nothing to do with templates ? Not sure what "dividing line" you refer to here. You can dump a whole SQLAlchemy model in a Mako template if you felt like it. &gt; I didn't expect that SQLAlchemy would begin to approach my contempt levels for the Django ORM as quickly as it has. This is a frequent issue we get with people who aren't enthused about relational databases and SQL to start with. SQLAlchemy is very much about automating the tasks surrounding SQL, relational schemas, and the DBAPI. But it doesn't hide them.
a very good blog post. there is only one thing i will say. the following statement performs a select and then an update query. obj = MyModel.query.get(the_id) obj.name = 'New Value' session.commit() we don't need that. we can just do: session.query(MyModel).filter_by(id=id).update({'name': 'New Value'}) which only generates an update query.
I sencond that, I no longer use any of SQLAlchemy's ORM features, just the SQL Exppression Language. I find it clearer and less ambiguous. It has forced me to learn a bit more SQL which in turn has decreased the amount of code I write, so that now I just offload processing to the database server through a better structured SQL query. 
And you can do `MyModel.objects.filter(id=id).update(name="New Value")` in Django, I think Armin was just using it as an example.
Your previous post is misleading. The ORM layer in your picture is dependent on the other layers. It's a matter of semantics to say "SQLA is not just an ORM". Well, it is being sold as an ORM and it is an ORM first and foremost. &gt; It takes more time to learn about the peculiarities of the various DBAPI drivers than it does to learn SQLALchemy. Well, maybe it's in your experience but not with mine. For me, Postgres and SQLite modules are much more straight forward to use and learn.
Thanks zzzeek. I really appreciate your work. Generic foreign keys is Django parlance, but yes I was referring to the "polymorphic association" code which is the same thing. Not something you would proudly display on your refrigerator door, but useful nonetheless. The "dividing line" has to do with import requirements and is probably more of a Flask-SQLAlchemy thing. Specifically filter_by() and its' ilk are trivial to use in templates, but filter() is not. I had the "pleasure" of using IBM's very first release of their first relational DB back in the 80s. At that point it was easy to craft a query that returned "Are you sure you want to run that query? We estimate it will take longer than a human lifetime to finish." I don't need my ORM to hide SQL and this is what rocks about SQLAlchemy, but at the same time SQLAlchemy introduces a fair amount of cruft of its' own which is a bit sad. Looking through the disjointed docs can also be a pain. Still in all I will enthusiastically use SQLAlchemy in the future where appropriate. 
&gt; but at the same time SQLAlchemy introduces a fair amount of cruft of its' own which is a bit sad. Looking through the disjointed docs can also be a pain. I'm smiling as I read this critique, since years ago it was so common, and now it is as rare as a panda bear in Florida. The docs/cruft/etc. have been under relentless rework and improvement for years and it's been a very successful effort. Any comments you have on the current site documentation are always appreciated. 
Color me impressed that you went and updated a four year old blog post with content for the latest version of SQLAlchemy. 
Consider me a panda bear in Austin if you wish. Being late to the party I can only say what I think based on the current status. Glad to help out. You already hit my #1 sore point. I have used django's content-type app and generic foreign keys (which are formally referred to as "generic relations") a number of times and needed to do something similar with Flask. The Flask-SQLAlchemy extension does not support this and so I looked through the SQLAlchemy docs looking for hints on how I could add this, but those docs don't exist. (I finally found your blog post a few days ago. It took me awhile to locate it due to the terminology mismatch with Django.) So maybe take a moment to see how the [Django docs discuss this](https://docs.djangoproject.com/en/dev/ref/contrib/contenttypes/#generic-relations) and add a similar section in the SQLAlchemy docs. Meanwhile I am already working up improvements for the Flask and Flask-SQLAlchemy docs as neither of these documents live up to the standards set by SQLAlchemy and Django. 
Look at that subtle off-white coloring. The tasteful thickness of it. Oh my God, it even has a watermark! 
getattr() is a builtin function that will help you here: def meanattr(input, attribute): return mean( [getattr(x, attribute) for x in input] ) print meanattr( [person()] , 'age')
Of course! Python makes such tasks easy :) &gt;&gt;&gt; class person(object): ... def __init__(self): ... self.gender = 'male' ... self.age = 25 ... self.weight = 215 ... self.height = 76 &gt;&gt;&gt; def mean(input, attribute): ... return mathematical_mean([getattr(x, attribute) for x in input]) &gt;&gt;&gt; def mathematical_mean(input): ... total = sum(input) ... return total / float(len(input)) &gt;&gt;&gt; mean([person(), person()], "age") 25.0 
Remember that getattr is a builtin function, not a "method". So replace: return mathematical_mean([x.getattr(attribute) for x in input]) with: return mathematical_mean([getattr(x, attribute) for x in input])
Yeah - I noticed that about 2 seconds after I posted, hence the ninja edit.
&gt; it is being sold as an ORM and it is an ORM first and foremost No, it's not. "SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL."
If the goal is testing with different configurations of packages then [tox](http://codespeak.net/~hpk/tox/) handles that. Definitely not as efficient since it still has to install 32 virtualenvs, but it's basically fully automated. Have you tried using it?
I think that libs like gevent use coroutines to do non blocking io. The difficulty if these kind frameworks is that they all have a somewhat different way of doing things so you can't mix them.
That's the beauty of it. I don't use the ORM features very much any more, but using the SQL expression language is awesome. Most of our apps we prototype with SQLite and then move to production with Postgres. It's great being able to use essentially the exact same code to do both.
i won't go anywhere without a reservation
Sir, you are a gentleman and a scholar. Thank you
thank you! huzzah for reddit!
Brilliant. I think this would easily solve 99% of the the problems I regularly face with packaging and namespacing. Here's hoping that it goes through.
[Vollkorn](http://www.google.com/webfonts/specimen/Vollkorn) and Palatino.
This has very little to do with C, it just has to do with Python scoping rules being not very thought out. Even C99 supports the C++ form. Relating it to C also is not very useful since, unlike Python, C differentiates between creating a variable and assigning to it. You can very easilz shadow a variable in C by creating an inner block, your original variable will be unaffected. This is somethign Python has no concept of, it isn't even possible by using a nested function.
Pygame's font module is kind of lame because it can't handle newlines and different fonts/colors in the same bit of text. These modules seem to add this functionality though: http://www.pygame.org/pcr/text_rect/index.php http://www.pygame.org/project/1002/?release_id=2901 It's incomplete at this point, but I'm working on my own Pygame module that acts as a curses emulator but for Pygame (so it's more cross platform since curses is Unix only). It's available here: https://github.com/asweigart/pygcurse PM me if you have any questions.
You're gonna want Curses, which exists outside of the pygame library. Loading them each as an image would be a little odd, however, you could put all your characters together and use one image to generate a tileset (much the same way DF does it).
For some queries there is simply no other way than to use the Expression Language. Try to do an efficient 19 table JOIN (I know, I know) using the ORM. You will get nuts, I tell you. ;)
&gt; So maybe take a moment to see how the Django docs discuss this and add a similar section in the SQLAlchemy docs. Well SQLAlchemy's relational nature makes it hard to find where a "mainstream" doc for our extension would be, other than where it is now, in the examples docs: http://www.sqlalchemy.org/docs/orm/examples.html which also links to the blog post, as well as on the usage recipes at http://www.sqlalchemy.org/trac/wiki/UsageRecipes . Having a "cross cutting" association is an application of standard relational concepts. Maybe once we further refine the relationship docs at http://www.sqlalchemy.org/docs/orm/relationships.html we can add a section for "alternate relationship styles". 
Have to tried replacing the sendall() with send() and then check that all data was, in fact, sent? For debugging, you could attempt to .send() one byte of data after the sendall and check the return status (== 1). I know it's not much help, but I hate to sit and stare at could that *should just work*.
mucho appreciated.
Are you adding try, except blocks to your code? I haven't looked but I'm guessing you can probably set the verbosity since it's a shell as well.
I've got it installed. Installing numpy and scipy were a little more involved than I thought. But I have a little script that does face detection. It's a fraction of the size of my opencv script.
Here's how to read layer diagrams - when one layer (SqlA ORM) is *on top* of another (SqlA SQL, Engines), that means you can usually use the lower layer without even involving the higher ones. 
Fair enough... I'm starting to think now that the issue may be in some of the dependencies that my partner wrote up underlying this code... I just wanted to get some community feedback before I start digging into too much code that isn't mine.
note the difference between &gt; "SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL." and &gt; "SQLAlchemy is an Object Relational Mapper"
Came here to ask more about that too - this would be huge, #1 Django pain in the ass.
In gunicorn is possible to run multiple applications? Do not know paster, I'll look at it
Via the paster integration you can. You could also use the eventlet backend and eventlet.wsgi but thats much more complex and probably not needed. Sounds like paster or paster+gunicorn is what you want.
I find that django's ORM only makes things more complex. 'Now you have two problems'; figuring out the best way to use the ORM to generate efficient SQL. 
Django follows the same long-term support model as Python: no breaking changes except in major version releases; feature deprecation is announced early on and the features aren't removed for a few releases after that (IIRC the first minor release marks them as deprecated, second gives warnings, third removes them). In other words: it's pretty stable. Also, you can and should freeze version numbers in projects as soon as you push to production. So you don't need to upgrade just because a new version is out.
Good luck finding anything that doesn't change but is actively maintained for decades. Your best bet would be Java, which has been conservative to the point of crippling itself. In Python no changes are made "freely". The language moves on, features are added from version to version; occasionally old or broken features are deprecated and eventually phased out. The only radical change in Python itself was the move from 2.x to 3.x, and even there most of the code is somewhat compatible and the most frequent differences can be resolved automatically. For Python projects this of course depends on the maintainers and their plans. Some packages are rewritten from scratch every year, some probably won't change much within your lifetime. Most packages you'll likely use won't undergo fundamental changes too often; especially Django is pretty good at remaining sufficiently stable.
Good luck finding anything that doesn't change but is actively maintained for decades. Your best bet would be Java, which has been conservative to the point of crippling itself. In Python no changes are made "freely". The language moves on, features are added from version to version; occasionally old or broken features are deprecated and eventually phased out. The only radical change in Python itself was the move from 2.x to 3.x, and even there most of the code is somewhat compatible and the most frequent differences can be resolved automatically. For Python projects this of course depends on the maintainers and their plans. Some packages are rewritten from scratch every year, some probably won't change much within your lifetime. Most packages you'll likely use won't undergo fundamental changes too often; especially Django is pretty good at remaining sufficiently stable.
This is kind of the thing that pisses me off about PyGame and using Python for games in general. Everything out there is 1/2 complete, old, buggy, and most of the time you end up just implementing everything over again yourself. Why oh why can't we have an awesome SDL binding, with an awesome, fully featured Game library?
[Scrappiest of all non-ORMs](http://svn.colorstudy.com/home/ianb/recipes/sqltemplate.py)
I am pretty new to python and have not developed a game before, but it sounds like a lot of fun and if you can still use more contributors I would be interested in helping.
If you don't want 'old', you don't want 'SDL binding'. SDL is using relatively ancient tech by today's standards.
Ok well, you get my point at least!
Yeah... I'm going to have to get you to do those TPS reports....
I'd love to contribute, sounds like the perfect project for when I'm sick of work but still craving my python fix
Technically, Pygame and SDL are just providing the barebones. When it comes to something like a text module that can implement word wrapping, etc, it would be great for some projects, and overkill bloat for others. Sometimes you need Photoshop, sometimes you just need MS Paint.
Looks cool and Tornado folks totally should take a look at it. Did you ping them already? I may want to use it for my future projects (using it for my current one would mean rewriting half of my code or mixing styles which is ugly).
The relation to C is irrelevant and was only posted to show that there are other languages which behave in a similar manner and are not considered "broken". It is just something you have to be aware of when using that language. Also, I have no trouble shadowing a variable even in python 2.7.2 and keeping the original state using a nested function: def a(): z = 1 def b(): z = 2 # z defined in a() is not available from here b() return z # z = 1 Regardless, things now behave like the OP wanted in python 3. The original post was just a troll attempt and nothing more.
Anything that makes distribution and installation easier will be welcome.
i'm writing a python program that uses sqlite, and i wanted to use sqalchemy, but it was just too darn complex. The documentation wasn't the greatest, i just started out trying to make a simple one to many relationship and i couldn't even get THAT working, let alone what i wanted to accomplish in the end. Getting on their irc didn't help, and in the end i just ditched it and been using regular cursor.execute() statements and its served me well. Maybe i'll give it a try after i finish my project. Although its annoying to have people on python irc channels scream WHY ARN'T YOU USING SQLALCHEMY!!111ONE as if its god's gift to python or something. 
Because that's not really your job, amiright?
Nice domain. I wish I had a vanity domain, but I'm too cheap. I have a fuckton of free 5-letter-word .tk's though.
the template functions in jquery are not intended to be used? you got a link for that? 
FWIW, my mac book book pro is running linux. all the web designers at work cry when they see my emacs at full screen and a bunch of terminal windows.
Both support 2.7, and are included in EPD (which is using Python 2.7.2).
Wrong. The save method overrides every column. Update only does to ones you changed. 
Can you explain this a little? How has the use of their expression language forced you to learn more SQL and how has this resulted in less code? I'm pondering SQLAlchemy for a small project and am thinking that the overhead, extra dependencies, etc may just not be worthwhile...
If you want something more feature complete, check out [Cocos2d](http://cocos2d.org). It's built on [Pyglet](http://pyglet.org) which is a great game library on its own that you can use if you don't like Cocos.
I'm guessing you've never actually used Cocos2D...it's not a game library, it's just an animation library. Good for little more than telling stories or adding transitions to stuff.
It's not the same in C though because C differentiates between creating a variable and assignment.
Actually... I made a game with it for Pyweek awhile ago. It is definitely suitable for making games.
What OS are you using if you don't mind me asking? Very cool, is your code posted? The 1.1 release has the new image.show() and featureset.roi() -or- feature.roi() Which will return an image with a bounding box, so say you did the face detection. If you like 1.0, then 1.1 is much better, we've added a ton more useful features, like a display, etc.
mind linking your project? I only see 2 games marked with the cocos2d tag.
The game is called [Nonagon](http://pyweek.org/e/teamwsu/). The code is quite messy since it was my first real game and first time using cocos but... it works.
Impressive. Maybe I'll take a second look. Their tutorials are woefully lacking. Their "examples" even more so. If you look in their examples it's just a bunch of scripts with animations pasted one after the other....it's really sad.
Yeah, the documentation is lacking. Seems like the developers moved on to bigger and better things (the iPhone). I have done a lot of reading the source to figure stuff out. I recently wrote a map loader for .tmx files from the Tiled editor and there is no documentation of the tile module. Maybe I should consider documenting my learnings at some point or forking the project.
Oh how I pine for documentation.
Do you have a particular topic that you would like addressed? I can write a tutorial perhaps.
Nothing in particular. I appreciate the offer! Honestly just *anything* other than fucking rotating, scaling, and moving grossini...............I fucking hate grossini.
Fuck grossini.
I threw it up as a gist on github. https://gist.github.com/1096373 I'm building a digital signage ad network in my hometown. Essentially these are internet connected computer hooked up to 42"ish TVs that show a loop of local information and advertising. Specifically they are running Chrome on Ubuntu 10.10. I'm using the web2py framework for both the display client and the central management server. Each of these has/will have a webcam on it that takes a snapshot every 2 seconds and counts the faces. This script runs continuously and saves a little json file. Then I can show the advertiser that X number of people actually looked your advertisement today. Trafficlight Ads is what I'm calling it. http://trafficlightads.net
Also, and this is OpenCV's fault, I'm unable to set the height and width properties of the camera. I've got several Logitech cameras that will do 1920x1080 but I can only grab frames at 640x480. Is there any magic that you know of that I have to do first?
It seems well thought out and the workaround for the "json/simplejson" scenario is acceptable, but I still wonder about the performance hit of this. Of course, as stated in the pep, the slowdown only occurs when, under current circumstances, an `ImportError` would be raised, which is fine by me. However, if such PEP was to be implemented, then there would be many libraries taking advantage of it, making that performance hit more and more common with time. When I look at my `sys.path`, it's quite big. I think it would be worth it to quantify that performance hit first. Then again, I guess this performance hit isn't that big of a deal, in the big scheme of things.
I am not sure what that point is supposed to be arguing here? How does knowing whether a variable is being created or assigned to make any difference to the scope in which it is available?
Can't blame them. vi is better.
and the clients jump for joy when I produce time sheets from org-mode. and then they look to the vi users who hang their heads in shame. 
I'm also a big fan of SQLAlchemy, and love the mix of cherrypy, SQLAlchemy, and jinja2, but I will say that django is quicker for getting a small to medium-sized website up.
What is going on with the indentation? It isn't working for me. Tabs are 8, 4, and 2 spaces randomly throughout this code.
I kinda like how java does it... where the directory structure is the namespace so edu.arizona.something will have a directory structure of /edu/arizona/something, and that way no conflicts with classes that are named the same happen, as you can have a built in class String, and another string in /foo/bar
&gt; Although its annoying to have people on python irc channels scream WHY ARN'T YOU USING SQLALCHEMY!!111ONE as if its god's gift to python or something. Raw database connections in Python are quite broken and the one standard gives room for 4 different ways to specify SQL statements. SQLAlchemy's engine unifies that, so even if you are not using the ORM support you should still use it for the unification, bugfixes on top of the lowerlevel APIs and connection pooling. People are recommending SQLAlchemy for a reason.
pyqt apps look native when they are run on os x http://www.riverbankcomputing.co.uk/software/pyqt/intro
It's possible that your sys.path is so big *because* things like setuptools are aggressively adding directories to it, to work around the fact that Python's import machinery is so lame. Adoption of PEP 402 could eventually allow much simpler sys.paths, and make straightforward imports more efficient. (And P. J. Eby, the author of this PEP, wrote setuptools. He *knows*.)
The code works for me
Off-topic: [best ORM logo evah](http://sqlfairy.sourceforge.net/).
&gt; it is being sold as an ORM and it is an ORM first and foremost. I think this is a false impression because of the common novice question "which orm?" and the automatic answer "sqla". SQLAlquemy philosophy is clear on their front page: "SQL databases behave less like object collections the more size and performance start to matter; object collections behave less like tables and rows the more abstraction starts to matter. SQLAlchemy aims to accommodate both of these principles." I read this as: yup, we offer a dandy ORM as everybody looks for one and we could not avoid it, but the coolness is that it is built on top of our abstraction layer, which can also be used standalone.
i don't need connection pooling if its a desktop application, and i dont see how there are 4 different ways to specify sql statements. and not to mention that the documentation is still confusing, even if i wanted to use this.
Ditto for wxPython.
I'm only guessing what Armin was referring to, but [`PEP-0249`](http://www.python.org/dev/peps/pep-0249/) clearly has **5** different ways to do bind parameters. Quoting the PEP: 'qmark' Question mark style, e.g. '...WHERE name=?' 'numeric' Numeric, positional style, e.g. '...WHERE name=:1' 'named' Named style, e.g. '...WHERE name=:name' 'format' ANSI C printf format codes, e.g. '...WHERE name=%s' 'pyformat' Python extended format codes, e.g. '...WHERE name=%(name)s' EDIT: If SQLAlchemy is too heavy-weight for your tastes, you might still look at something like [`dbapiext`](http://furius.ca/pubcode/pub/antiorm/lib/python/dbapiext.py.html) to solve some of these problems.
Correct me if I'm wrong, but I think SqlAlchemy ORM was added later, after the abstraction layer was set. When you realize that the ORM is built on top of the abstraction layer (many novices don't because **they arrive looking for and learning the ORM**!), it is easy to see where the foundation is and that SQLAlchemy is, *first and foremost*, an abstraction layer.
Wrong movie. They guy does kinda look like Bill Lumberg with those glasses though. http://www.youtube.com/watch?v=qoIvd3zzu4Y
well how is having 5 different ways to bind parameters bad? they do the same thing (i'm assuming) the syntax is just different. and i just don't understand what is wrong with just using cursor.execute() statements, why am i required to use a ORM or some other library to make database stuff easier? I find it already easy enough. I can see how having a ORM save objects is handy, but in my experience the time setting it up is not worth it when its easy enough to make adapter / converter methods to translate the data to and from a database. 
briefly looking at the api, I'm wondering if you are passing a directory name to tag link and not an mp3 file. that would be my first guess. maybe print out the value of "/home/else/Music2/" + i to get your bearings on what you are actually passing in. 
&gt; well how is having 5 different ways to bind parameters bad? How do you switch from a database that uses qmark to one taht uses pyformat?
&gt; I'm only guessing what Armin was referring to Yep, that's the one I had in mind.
Thanks for clearing it up, cheers.
I imagine Bicycle Repair Man isn't the only third party library. There used to be one called [creosote](http://www.youtube.com/watch?v=BlK62rjQWLk) although it seems to have shuffled off its mortal coil. You still have a chance!
Ah I hadn't noticed that, thanks.
The performance hit will be equal to one stat() per (existing) sys.path directory, plus the cost of the failed import itself. It's a one-time cost per virtual package; once the package path is initialized, the searches take place on only the existing subdirectories. If your sys.path contains mostly zipfiles or non-existent directories, I wouldn't worry, though. The stat calls won't happen for zipfiles or directories that don't exist. OTOH, if you have lots of .egg *directories*, you might want to consider switching them to zipfiles; they can be a lot faster when you have plenty of imports taking place.
&gt; It's possible that your sys.path is so big because things like setuptools are aggressively adding directories to it, to work around the fact that Python's import machinery is so lame. Yes and no. But setuptools doesn't want to add directories to sys.path, it wants to add zipfiles. Having lots of zipfiles doesn't generally create the same performance problems as lots of directories, at least if you're doing lots of imports. The "yes" part is that if I were writing setuptools today, I'd toss everything in a plain old directory like pip does by default, with the eggs-on-sys.path route being strictly a feature for application plugins (which is what they were designed for in the first place).
I gain ownership of the package from the previous maintainer and normally the pypi release i made sometime ago is just fine to use. (the github code is from mine, other was from code.google.com)
Notice how I said the 'update SQL statement' not Django's update method on the Model Manager. Save figures how if you need to do an UPDATE or an INSERT. In this case we are only talking about when it needs to do an UPDATE. When the ORM constructs the UPDATE statement it uses every field defined in the model even if they were not updated.
Alternative solution: from operator import attrgetter mean(map(attrgetter('age'), people)) Also, instead of a list comprehension you could use a generator expression if the mean function only expects an iterable: mean(getattr(x, attr) for x in input) The input iterable is consumed lazily and is more memory efficient. Similarly my solution can be rewritten: from itertools import imap from operator import attrgetter mean(imap(attrgetter('age'), *people))
what's broken about them?
Each database lib typically implements exactly one of them, and which one they choose to implement seems to be largely influenced by a desire to be different from any other widely used one. Try supporting sqlite in dev and postgres in prod and get back to me after you get tired of writing every SQL statement twice.
This isn't SQLAlchemy and You, it's SQLAlchemy and Django. Nice guide, but describing one thing in terms of another just doubles the amount of stuff you need to know before understanding what's written.
You can't refactor SQL(*). At least not in the extent that you can refactor Python code. Using Python you can factor out commonly used constructs in your queries to own variables or even functions which construct parts of or even whole queries. Using this method I commonly end up with constructs that have a whole lot more meaning to them than otherwise. Take this contrived example: order_finished = order_table.c.status_id == 15 That way you can use *order_finished* in your WHERE clause and all makes sense. (*) String concatenating SQL sucks!
Have you tried pyglet?
pyglet isn't a game engine. I'm not complaining about the graphics bindings so much as a mature game engine. You know...where I don't have to build up an entire code base from scratch every time I want to make something.
I accidentally my applications.
Try [PySide](http://www.pyside.org/) which are Nokia's Python bindings for Qt. There is an installer for Mac OS X. 
TIL. Thanks guys.
The expression language is basically a map from SQL to python. Previously I would have done a query to pull in a bunch of data from the database and processed it with some python code. Now, with the expression language, I craft a more complex SQL query to offload that processing to the database. This way the database returns less data to me, executes the query faster than the python code and I don't have to write any code to process the data afterwards. SQL can be awkward so you have to balance the complexity of the query with how simply you could do it in python + the speed with which the database can process data vs. python scripts. 
Here is some working code using stagger instead of eyeD3. The good thing about stagger is that it is written entirely in python (python 3) so you can install it with pip. import os import stagger from stagger.id3 import * def main(): # The path to where your music is mp3_directory = '.' for file_name in os.listdir(mp3_directory): if file_name.split('.')[-1].lower() == "mp3": print("Filename: %s" % os.path.join(mp3_directory, file_name)) tag = stagger.read_tag(os.path.join(mp3_directory, file_name)) # Do what you will to the tag here if __name__ == '__main__': main() Just make sure you run it with python3 and that you have stagger installed. Let me know if you have any questions 
* [Hacks necessary to figure out if a connection is closed](http://www.sqlalchemy.org/trac/browser/lib/sqlalchemy/dialects/postgresql/psycopg2.py#L283) * [Issues with sets](http://www.sqlalchemy.org/trac/browser/lib/sqlalchemy/dialects/mysql/base.py#L995) * [Workarounds for rowcount](http://www.sqlalchemy.org/trac/browser/lib/sqlalchemy/dialects/mysql/mysqldb.py#L141) * [issues with client encoding](http://www.sqlalchemy.org/trac/browser/lib/sqlalchemy/dialects/mysql/mysqldb.py#L167) * [Issues with query caches](http://www.sqlalchemy.org/trac/browser/lib/sqlalchemy/dialects/sqlite/base.py#L520) The list goes on.
haters gonna hate
This application is build on Python with PyObjC (to use Cocoa) : http://www.checkoutapp.com/
Cool, thanks. Just curious, what type of applications are you using it for?
Would love to have you incorporate some of that into SimpleCV. We are moving that direction, the base is there, many new things in the 1.1 release which will probably drop next monday.
Awesome man. Very cool. I talked about doing something like this with a buddy a while back. I was thinking of running over cell networks, and basically up fronting the cost, then just pay for ads. I was looking at using the pandaboard for the platform, and pretty much ubuntu and chrome. Never got that far though, came across Nate and got simpleCV going and working on manufacturing. Would love to keep you in the loop as it sounds like we could be very beneficial to each other. Thanks for posting the code, I will give a glance over. You mind if I tweet about it?
We haven't found a way at the moment. We've also discussed getting in contact with people like ffmpeg for getting a possible driver working for higher performance type stuff.
Why aren't you using SCP directly? import os def sendfile(local_path): filename = os.path.basename(local_path) local_directory = os.path.dirname(local_path) remote_path = os.path.join("~", filename) output = os.popen("scp %s %s@%s:%s" % (local_path,remote_user,remote_host,remote_path)) print "Blinkenlichten!" print output.read() You'll need to set up SSH keys for this, which is a tiny bit of extra complication, I guess. Here is how you can accomplish that: http://rcsg-gsir.imsb-dsgi.nrc-cnrc.gc.ca/documents/internet/node31.html The gist of it is: $ ssh-keygen -t rsa this will put some text into ~/.ssh/id_rsa.pub put the contents of that file onto your remote box in: ~/.ssh/authorized_keys It's one line long. Make sure it's in the home directory of the user that you want to log in as.
Please do tweet about it. My model is the same: I pay for the hardware and installation and sell ads on the network. Or that's the plan so far, I'm just getting the first ones out there. For hardware I'm using these: http://www.newegg.com/Product/Product.aspx?Item=N82E16856107081 with 16GB SSDs. Right now I have to bum an internet connection from the business, but a cell connection would be awesome too. I'm actually surprised this kind of digital signage isn't more prevalent. The only ones that I'm really aware of are the networks in airports and some hospitals. But those are run internally. And the off-the-shelf signage software is expensive and crappy.
&gt; well how is having 5 different ways to bind parameters bad? they do the same thing (i'm assuming) the syntax is just different. It's a terrible idea with no rationale and we're all in agreement on the DB SIG list, including the author of PEP 249 itself, that there should be only two formats, a named and a positional, and every DBAPI supports both. Look for that in DBAPI 3. As far as cursor.execute(), go nuts. I spent many years with hand-written SQL and wrote many, many "helper" layers which naturally arise after you've typed "SELECT a, b, c, FROM..." for the 45th time, before finally writing something to solve the problem once and for all.
so: * some DBAPIs accept Python unicode objects, i.e. u'', as bind parameter values, others do not, and the value must be encoded with utf-8 or similar. * some DBAPIs will return unicode objects for string results, others must have utf-8 or similar decoding applied. Some like psycopg2 or cx_oracle require special extensions to be registered on all connections for it to work. * the SQL statement itself, which can contain unicode identifiers (like in europe and asia), can be u'' on some DBAPIs, others not. * same for: the string name of the bound parameter in the execute() dictionary * the names of the columns in cursor.description. * cx_oracle often needs cursor.setinputsizes() to be called explicitly for certain types, no other DBAPI does. But you can't call it for *all* types, cx_oracle gets confused if you don't let it decide for itself for some character types. * in particular PyODBC with SQL Server, we have to check if the backend platform is Unix + FreeTDS vs. windows to determine if the encoding step is needed. If on windows, we can't use it - it breaks. pyodbc gives us almost no way of checking this so we have to parse for `".*libtdsodbc.*\.so"` in SQL_DRIVER_NAME. * Some DBAPIs support Decimal() values as bound parameters and in results for NUMERIC, others do not. Some provide extension mechanisms (like cx_oracle) to allow it. Some have no option but to return to you something that came from a Python float (pysqlite, pymssql) and precision decimals are impossible. * On older versions of PyODBC, we had to parse the decimal from a string in order to retain accuracy. We still need to do so with cx_oracle. Oracle precision numerics in particular have a ton of workarounds and caveats to get it to work consistently. * Most DBAPIs accept/return Python datetime objects, except for pysqlite which has an awkward workaround that we don't use. * PEP-249 states that the positional parameters sent to cursor.execute() should be a "sequence". Most DBAPIs accept a list for this sequence, though some accept a tuple (and will break with a list. Some that accept list break with a tuple). * Using BLOB with cx_oracle ? All your result columns that are BLOB must be read first with value.read(), as the underlying cursor used by OCI is exposed. Also, you can't read() these values if the row buffer has been consumed - this means you can't say cursor.fetchall() first. A special "pre-load-the-LOBs" is used here by SQLAlchemy to conceal this entire mess. * Want to get the "last inserted primary key" ? you can use cursor.lastrowid on pysqlite, mysql, but that's about it. For others, you need to use a sequence in conjunction with RETURNING, or pre-execute the sequence, or call a special function after the INSERT statement to get at it. SQL Server has an entirely different way from all of these, and in some cases due to ODBC issues the function to get at the "last inserted id" must be bundled into the same statement as a second call. * Should cursor.rowcount have an accurate number of rows affected when executemany() is used as opposed to execute() ? It's certainly easy to implement, just add up the numbers. DBAPI says nothing about this, so the DBAPIs are about 50/50 on this. * A bound parameter is just like a Python format string , i.e. %s, right ? Not really. On MySQLdb, psycopg2, etc. it more or less is. But if you're using mxodbc in it's default mode, the statement is parsed by the ODBC driver. you can't put bound parameters in certain locations, only in the WHERE clause, and only in a comparison operation. * kintersbasdb for firebird also chokes if you put bound parameters in too open-ended of a situation, such as "?=?". The string is parsed at some point in order to get typing information, i.e. "some_string=?" would reveal "?" as storing a string. "?=?" doesn't give us that, == boom * all of these quirks are **OUTSIDE** the realm of the SQL language understood by the database itself. This is *just the DBAPI*. The SQL language itself is another world of incompatibilities and vendor specific extensions.
And you never use jar file ... ;)
JS is a massive pain in the balls (imho), but it's not *too* difficult to slog your way through. Just go for it! (I use javascript in quite a few of my projects, although I don't really consider myself a javascript programmer)
Have you thought about using fabric? Its really nice for remote scripting. 
Yeah, I'm surprised about the digital signage as well. One thing that worried me is state to state laws on recording people, because I don't know if you are necessarily "recording", but rather sensing presence. Anyway, I added you on g+, I would definitely like to continue discussion more that way or via e-mail.
&gt; the vast majority of how-tos and questions about SQLAlchemy have been about its ORM, not its underlying functionality. Understandable. That interests a lot of users. Many have no idea that a non-ORM part exists.
Tkinter --&gt; TTK http://www.tkdocs.com/index.html I've been exploring WX and PySide lately. Pyside seems to have at least 3 different approaches to GUI creation. 
Probably your best bet is to use Jython or IronPython right now. The problem with FI is that it's not actually a compression format, it's preparsed XML; so you need parser that supports that.
object identification. In the company i'm working they needed a system that identifies an object and a few characteristics and tell the user what to do with this object
Why don't you use the parakimo sftp support? It goes something like sftp = t.open_sftp_client() sftp.put("local_file", "remote_file")
I do not agree with the idea that rpy2 is not fit for "end users" yet. I built a small framework for "omics" data analysis (GPL3, release likely next week or so if I manage), hiding the R engine over a much better Python interface. All of this couldn't be possible without rpy2.
Before this, they were using 40,000 lines of buggy Java.
And before this, 400000 lines of buggy C.
And before this, 40000000 lines of buggy ADA.
Brilliant, that clears it all up for me, thank you!
I actually just ended up setting paramiko sftp up before I got back to check for suggestions. I'd never used paramiko before and didn't know it was an option until I used some Google-fu Thanks =)
I did see that when I was looking around, and ultimately decided against it because when I am done with this it will be hosted on a server that I do not have any sort of administrative access to. I didn't want to involve any more tools that may have needed some additional files and support that would have to be set up by someone else. Thanks though =)
I would normally like to do this, but the server I am sending the file to I only have a guest account on... so I wanted to avoid using anything other than the user/pass combo that I was initially given. Thanks for the suggestion though =)
.... I think you may be onto something
He asked for a solution with a *native look and feel*.
And before this, 400000000 bullets.
Yep. &gt;&gt;&gt; a = "123" &gt;&gt;&gt; a[4] Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; IndexError: string index out of range &gt;&gt;&gt; a[4:5] '' &gt;&gt;&gt; 
Thanks, but what the fuck is up with those indentations?
Any application screenshots actually built with this? The examples I found has gui that are pretty oldschool and window looking. Also, can you submit it into the Mac App Store with this?
Agreed, fullcalendar is way better.
this sounds cool, but I haven't run into problems that numpy + scikits.learn couldn't handle (except tree based classifiers...). I would love to work on an ambitious project like this :)
Not looked at your project yet but the website design is absolutely gorgeous. Had a look at your project, fuck me you guys are polished that is impressive looking as all hell. kudos. Unfortunately I have no need for something like that at the moment since I have got the video functionality with Drupal but I will certainly look again on our next couple of projects which are gonna be video heavy.
Do you have an example or documentation of how to use this?
If you don't care about derivative works being released under the same license (e.g., the GPL), then take a look at the 'permissive' family of licenses, for example, the Apache, BSD or X11 licenses. This [License Chooser](http://three.org/openart/license_chooser/) website gives a quick overview of the main terms of each license.
http://www.oz9aec.net/index.php/gnu-radio/gnu-radio-blog/400-qt-gui-working-on-mac-os-x QT seems to fit into os x pretty well IMO. To answer your second question, [this guy](http://stackoverflow.com/questions/4337855/qt-applications-on-new-mac-app-store/5430867#5430867) claims to have had a QT app approved by the mac app store 
Some stylistic comments: 1. We tend to use `#!/usr/bin/env python` over `#!/usr/bin/python`. This is to accomodate machines where `python` is not executed from `/usr/bin`. 2. Follow [PEP8](http://www.python.org/dev/peps/pep-0008/), the style guide for Python code. It's not the law, but formatting your code according to it is considered good practice. 3. Install some debugging tools like [PyLint](http://www.logilab.org/857) and [PyChecker](http://pychecker.sourceforge.net/). Both applications check your code for logical errors, but PyLint also checks for style and convention. 4. Fix the indentation settings on your editor! Indentation errors in Python can lead to disastrous results. 5. The `if __name__ == 'main'` statement tells Python to execute the following code when the program is being called interactively, i.e., at the command line. If you are importing code as a module, anything below that statement (or in `def main()`, in your case) will not be executed. Next time, link to the web app you've developed. The HMM itself is pretty interesting. I'm not familiar with Skyrates, though—how did you download the chat transcripts you are basing the model off of?
Ok, I thought you were still looking for 'an awesome SDL binding', and pyglet is a good alternative to that. What exactly are you looking for from a 'mature game engine'? After all, when most people ask for such a thing, they usually mean the complex things funded by large companies and based around a lot of proprietary tech, eg. UDK, Unity, Torque, etc.
Something with multiple tile engines (top-down, isometric, hexagonal), fast sprite blitting (for example, built on top of rabbyt), particle effects, sprite/object/texture effects (hue, color, saturation, mirroring, alpha, the ability to explode a sprite, indexed color cycling), scene transition/state managers, sprite/object layer/depth management, dirty redraw management, some basic physics, line of sight routines, map editor, vector bounding solutions, an extendable multiple-camera class, 3D model loading, Matrix transformations, Vectors, etc Obviously, with most of the math intensive stuff coded in C/C++ or at least relying on Numpy. Obviously ***I*** don't need all of that stuff, but that's what I would fully expect out of a serious game engine. As it is, if you're just learning all this stuff...you kind of have to over time, build up your own little personal library of things to pull from. Which means there are probably tons of other people having to continually build up their own personal libraries as well...duplicating work over and over... Even if all of these could come in their own separate little dependencies, that would be a great start too.
And before this, 4000000000 arrows. 
Do you have any links to more info about their use of Python in this application? I checked their site and Google doesn't seem to turn up much info.
See [pyobjc's documentation](http://pyobjc.sourceforge.net/documentation/index.html)
Shut it down or they'll end up using it on us.
my first django project, thought i'd share :)
They are a very interesting framework. Especially for piecing together several databases. 
And before this, 40000000000 rocks.
This is actually a pretty good idea, on first glance it looks like it'll be easier to adapt to my needs than review-board.
And before this, − 2,147,483,648 lines of C++.
Would be interested in hearing more about this project
Thanks to all involved, a top notch project!
The easier script writing stuff is great. Very pleased
And before that, 0 monkeys wrote the collected works of William Shakespeare.
Weird subreddit to post this in, since it's only tangently related to Python. That said, I'd be interested in seeing the code. Python isn't the first language I'd think of to use for something like that vs lisp or prolog.
Has Pyramid completely supplanted pylons by now or is it a stand alone project?
http://docs.pylonsproject.org/faq/pylonsproject.html
Basically it originated out of pure frustration on how R handles things (I do microarray analysis and all that sorts of bioinformatics stuff). What I did was to write a series of packages that wrap the various bits of R needed for the analysis into a (hopefully better) interface, also suited for (I hope) application development or creation of analysis pipelines. Structurally speaking I use rpy to call the relevant R packages for the analysis I want to do (I cover data normalization, differential expression, functional enrichment and data clustering, plus an "extra" which I developed myself a couple of years ago). The results, which are mostly data.frames, are converted on the fly to tablib objects (I use Kenneth Reitz's excellent Tablib, in fact, and I have contributed a few patches myself). Tihs also allows me to write in Excel format directly (I don't need it, but the biologists I talk to do). If I can, I try to parallelize things using concurrent.futures (I once used Parallel Python, but it's way too fragile for such complex structures). I also added bits to support integrated processing from a series of data files: studies (whole analysis) and comparisons (the individual "experiments"). They are Python objects serialized to YAML (using PyYAML's ability of serializing Python classes). These objects (or files) can be used with a crude pipeline that reads parameters from an INI file and tries to do things automagically from data normalization to final results. Lastly, there's some reporting, done by using Mako to fill in a series of ReST templates which then are fed to rst2pdf to produce a PDF report.
As long as one of those 200 lines is "import Numeric" you can do an awefull lot in 200 lines.
Thanks! sounds cool - I'll check it out when you release it :)
upvote for the 3) also a great piece of work :-)
The documentation is a work in progress: https://gist.github.com/1047207 
Ok... you said "This is kind of the thing that pisses me off about PyGame and using Python for games in general." - is there actually an existing engine that does most or all of what you list above? For free? Otherwise it seems like you're asking for the moon on a stick and making it seem like Python's fault. I can say for sure that the mature game engines I've used, ie. the commercial ones, certainly don't cover all this. To be fair, 90% of games don't need particles, hue/colour/saturation shifts, dirty redraws (not if you're using hardware properly anyway), physics, or multiple cameras. So I don't think a lot of people are really having to write this stuff every time.
&gt; is there actually an existing engine that does most or all of what you list above? For free? You mean like XNA for C#? Or many of the separate solutions that exist for solving these problems all over the net written in C++? Python doesn't have any of that. Not even in their own separate distinct packages. XNA has tons of tile engines available out there. It has tons of stuff to throw on top of it. The Python world doesn't. Like I said: &gt; Even if all of these could come in their own separate little dependencies, that would be a great start too. In the python world, none of these exist *in any sort of refined form*...even as completely separate projects except for perhaps the Python Box2D bindings. Even then, documentation on implementing such things is nearly non-existent. And you're going to get onto ME about &gt; asking for the moon on a stick and making it seem like Python's fault Really? There's plenty of examples out there that show other languages that feature exactly what I'm asking for...with people out there doing it, releasing code, and documenting such things! How is asking for the Python world to at least be on-par with everyone else such an insult to you? &gt; So I don't think a lot of people are really having to write this stuff every time. Yeah, because they typically drop Python/PyGame and move onto a language that actually ***does*** have these things available for them to learn from on the net. Why do you think so many people are using C#/XNA? Now, I realize that Python is just a tool like any other language...I'm merely voicing my dislike of the fact that people pretty much use Python for web development, and it doesn't have the push behind it for much else even though it's obviously capable. Obviously there is the exception of EVE Online, but holy fuck...that's pretty much the only mentionable exception there is! Is there ***any*** other, commercial quality game made in python...AT ALL? Anything on STEAM? Anything in actual, RETAIL packaging?
You have just totally made my day with this info about DBAPI 3. Thank you.
Ok, so you're saying that what you "would fully expect out of a serious game engine" is actually not contained in any game engine at all, but is most closely approximated by XNA plus some number of 3rd party add-ons, or the C++ language plus a large number of 3rd party add-ons. That's fine, but recognise that you're not really asking for an engine any more, but a whole software ecosystem. The C++ ecosystem has 15 years of libraries used and tested by pro game devs. XNA on the other hand is bankrolled by a small company called Microsoft who have a fair few resources to throw into XNA, plus 15 years of experience with DirectX and an entire company division devoted to games software and hardware. You can't really expect that sort of support to just appear magically on other platforms, unfortunately. It's interesting to note that the Flash game engines, which are used far more often than XNA, are nowhere near as fully-featured as the stuff you're asking for. And Java has been the biggest programming language for quite some time and still doesn't have much good on the game library front. Yes, Python's stuff is poor compared to XNA. It's disappointing. But then most platforms are poor compared to XNA.
It sounds like maybe you should write a DBAPI 3...
Because in languages that differentiate you can shadow variables rather than mutate them. 
totally unrelated to python, but from the next bit: " The EXACTO system is comprised of an advanced targeting optic, the first ever guided small caliber bullet" ... o.0
Kudos to the team Chris.
As a django guy who never tried pyramid. What are the pros/cons betwen pyramid 1.1 and django1.3 and the soon to be released 1.4?
How does this compare against `virtualenv` which (AFAIK) solves the same problem?
If you really want to avoid frameworks, e.g. because your writing a cms, wiki or other site with completely dynamic page structure, consider werkzeug, a library that makes writing wsgi applications a *lot* easier without imposing any constraints.
i was thinking the same thing. step 1 when getting a new home directory is setting up a virtualenv at ~/local and step 2 is PATH=~/local/bin:$PATH i don't see what else might be needed
I invite you to use a web browser and check out the [docs](http://docs.pylonsproject.org/projects/pyramid/1.1/) reading the first and second level headings in the table of contents should tell you all you need to know. :)
Sweet, I'll be there sprinting on Bookie there. (https://github.com/mitechie/Bookie)
Firstly i'd strongly reccomend the python documentation (http://docs.python.org/) in answer to parts 1 and 2a, look specifically at the 'library reference' for question 2a. The differences between 2.7 and 3.2 are fairly significant, and a program written in 2.7 probably won't run in 3.2. Additionally most third party libraries work in 2.7 only (though this is gradually changing). Python will eventually change to the 3.x series, but for the moment i'd stick with 2.7. I'd also download a good IDE (such as PyDev or PyScripter)
Wait, I thought they were just going to name this one Zope 4...
From what I can see, this also manages the installation of multiple python versions, which is not a feature of virtualenv. Virtualenv would allow you to create a new sandbox based on an installed environment, but not install a whole new version of python. You would have to do that yourself.
Always good to see more documentation of open-source projects.
Reading their FAQ section I see they plan to make Pyramid compatible with Python 3 by the end of 2011. Good news, everyone!
1) I haven't personally gone through the whole thing but [Learn Python the Hard Way](http://learnpythonthehardway.org/) has been well received by the person I recommended it to and seems to be popular in the community. 2) 3.2 is the "the future", 2.7 is "the past". Unfortunately [Dark Helment was right](http://www.imdb.com/title/tt0094012/quotes?qt=qt1103289), and there are some major python libraries that don't yet work in 3.x. If you're just learning for fun and don't have a particular project in mind I'd recommend 3.2. If you **do** have a project in mind, I'd ask more questions in case one of the libraries you want is 2.7 only 2a) Searching for everything that can be imported isn't as easy. Once you import stuff there's a lot of helpful information though import math help(math) # gives you information about the entire `math` module. hit "q" to quit the help dialog help(math.sqrt) # specific information about what math.sqrt does and how you should call it
thank you
The best tip I have is to set a goal for yourself. Think of a project you could do with python. Even something simple, like parser for text files, or a prime number generator. Don't learn programming to learn programming; do something with it right away, or you will have a very hard and boring time doing it and motivating yourself. Also, answers to 2 and 3 are quite trivial to find and really something you should be able to find out for yourself if you want to be a successful programmer.
I was planning on just trying to start out with creating a program that does a Rieman sum, but am having a little bit of trouble in finding some commands.
the project I wanted to start with was creating something that would do a Rieman sum across an interval that you input, on an equation you input, and with however many subintervals you want to use.
It doesn't really make sense. In the def line you're declaring the names of the args to the function. Additionally, the option would be implicit, as there is hidden behavior happening. If I see a function with 'pass' as its body, I would generally assume that function is a no-op. You may want to take a look at [named tuple](http://docs.python.org/dev/library/collections.html#collections.namedtuple) as a replacement for simple struct-like classes as you have above. **Edit:** Yes, I'm aware namedtuple is immutable. I forgot about that fact and didn't mention it. It's still useful if you don't need mutability though.
I'm tempted to go, but I don't live anywhere near Ohio.
So, I don't get what the second option is supposed to represent. Coming from an object oriented background, there is no way in hell I would make arguments to the constructor implictily declare class member variables. There is basically no language that does that. You said you were trying to mimick C structs, and I don't understand how C structs do what you said. They most certainly do not have constructors, let alone implicit variable declarations in the constructor. Even if you upgrade to C++, you aren't allowed to declare members from inside a function definition. I guess, vaguely, I could kind-of sort-of intuit that what you really want is to mimic this: struct Obj { float x; float y; float z; }; Which can be achieved with class Obj: x,y,z=0.0,0.0,0.0 
Well, maybe I exaggerated a bit, but they will probably be moved to UI in the near future. It's certainly not something you should touch in a more general introduction to web development yet. [Source](http://blog.jquery.com/2011/04/16/official-plugins-a-change-in-the-roadmap/)
ADA is never buggy if it compiles.
Moreover - judging from an open issue [Issue 35] it simply wraps around virtualenvwrapper. So you can have different python versions for you virtualenvs, which sounds actually pretty cool. (https://github.com/utahta/pythonbrew/issues/35)
Tuple was my first thought. I didn't know there was a named tuple -- that's really cool.
First off, SQLAlchemy was a big motivation for me. I am the kind of programmer who likes to have control over every aspect of my project, with Pyramid you can do that. Django is more of a full-stack one package deal but with Pyramid you mix and match your components. 
Great job guys! 
You should post this to r/conspiracy. See, Microsoft is so afraid of the Django platform that they hired Quentin Tarrantino to create a movie so that no one can google Django anymore without getting hopelessly bogged down. If you doubt me, go ahead and find the code to the "Code Red" virus. It's pages deep by now, thanks to Mountain Dew's complicity in the New World order's d... All right, that's enough.
What? Why did no one tell me there was a python conference a hour from my house? I know what I am doing next weekend now. 
No, it's about a rogue jazz guitarist who plays by his own rules.
It'a about a runaway slave I think.
Named tuples are not mutable so they are only useful where values never change.
There are several "tricks" to achieve the same thing (eg take **kwargs and update self.\_\_dict\_\_ with them). The main test you should apply is assume that you go off on and work on many other related projects, then come back and look at this code. Will you be able to correctly determine what it does? The first form is two lines longer but is very clear. The second form is effectively a bunch of rarely used magic. Edit: Fixed formatting - thanks MachaHack
Not enough numerology.
ah right. Slipped my mind (been a while since i've had to use them). In that case, you could use UserDict to create your own subclass of dict that works in a similar way. 
&gt; Microsoft is so afraid of the Django platform that they hired Quentin Tarrantino to create a movie ... That didn't work when they did it for twisted (http://www.imdb.com/title/tt0315297/) :)
Awesome Thanks!
I read the description as &gt; A slave-turned-bounty hunter sets out to **recurse** his wife from the brutal Calvin Candie, a Mississippi plantation owner. I was confused.
If you have a class that's simply a structure for storing its parameters, just use `collections.namedtuple` from collections import namedtuple Obj = namedtuple('Obj', 'x y z') o = Obj(1, 2, 3) If you want to add methods, you can always subclass it.
I hear the whole movie takes place in a [Pyramid](http://pylonsproject.org) :P
And it's free to boot! Very sad I won't be making it this year, the last 3 have been great.
You need to type self.\_\_dict\_\_ as self.\\\_\\\_dict\\\_\\\_ or reddit just turns it bold like so: self.__dict__
This is the sequel of [Django 2](http://www.imdb.com/title/tt0093113/).
I was just as confused when my parents told me they were eating at [Django](http://www.djangodesmoines.com/)
I think it is, specially if you're learning on your own. it's good because it's clean and kinda implicitly teaches you good habits, Ruby and PHP have a more loose way of doing things so it might be difficult to get it right if you're starting. also the community is an important factor to consider when choosing a language, this because unless you're doing reseach of academic stuff you'll be needing help and libraries to work with (writing stuff from scratch isn't productive) and in this sense the Python community is the best of the three, the PHP community is too large so it's hard to find good advice and the Ruby community has a tendency of making more effort in looking cool than doing quality stuff so it's not a good pick for a beginner. besides all that, both PHP and Ruby are most used on web while Python is used in several other places and in web too. for Python resources check [the tutorial on the Python site](http://python.org/doc/), other books I know of are "[Dive into Python](http://diveintopython.org/)" by [Mark Pilgrim](http://www.reddit.com/user/MarkPilgrim/) and "[Learn Python the Hard Way](http://learnpythonthehardway.org/)" by [Zed Shaw](http://www.reddit.com/user/zedshaw/) (that last is from a guy who switched from Ruby and few months later was already "teaching" so I don't know if it is good, but afaik albeit being controversial he writes good software so it might be) surely there'll be others. good luck! ps: start with Python 3.x --- edit: I forgot these * MIT OpenCourseWare "[A Gentle Introduction to Programming Using Python](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/lectures/)" * Google Code University "[Google's Python Class](http://code.google.com/edu/languages/google-python-class/)"
As others have noted, a namedtuple isn't mutable, so it's actually closer to a C99 const struct. C99: #include &lt;stdio.h&gt; int main(int argc, char *argv[]) { int coord[2] = {0, 5}; const struct point { int *coord; const char *label; } p = { .coord=(int *)coord, .label="goal" }; int new_coord[2] = {5, 10}; //compile error: read only //p.coord = (int *)new_coord; //this works int i; for (i=0; i &lt; 2; i++) { p.coord[i] = new_coord[i]; } printf("(%d, %d, %s)", p.coord[0], p.coord[1], p.label); return 0; } Python: from collections import namedtuple def main(argv): coord = [0, 5] p = namedtuple('point', 'coord label')( coord=coord, label="goal") new_coord = [5, 10] #AttributeError: can't set attribute #p.coord = new_coord #this works for i in range(2): p.coord[i] = new_coord[i] print("(%d, %d, %s)" % (p.coord[0], p.coord[1], p.label)) return 0 Python's [namedtuple](http://hg.python.org/cpython/file/c9ebae3285e3/Lib/collections.py#l235) execs a template string that creates a custom tuple class (set `verbose=True` to see the class definition). It's probably more efficient to just use a 'bunch' class if you only need access by field name. A namedtuple is good when the order is also important (e.g. structured data to be saved with `struct.pack`). 
You can specify a python executable when making a virtualenv. I've used that to have virtualenvs with specific versions.
http://diveintopython.org/
yes.
you win :)
definitely a good beginner language. also **ruby = slow perl**
`ls` lists the files in a directory Let's say that you have the folder `LearnPython` in your home directory. You save a file as `lesson0.py` in gedit. Open your terminal. Type `cd LearnPython`. This will take you to the `LearnPython` directory. Type `ls`. You'll see the name of the file you just saved (`lesson0.py`). 
Thank you sir! I just noticed that the tutorial, if I scrolled down, told me an example. So I got it all figured out now.
+1 good beginner language. A lot of introductory CS programs (some of which have webcast lectures, course notes and sample assignments to work through) have started teaching their intro programming courses in Python. If you're familiar with the basics (conditionals, loops, functions, and even the rudiments of object-oriented programming), you should be able to pick up Python and start using it pretty quickly. As an aside, what you should be focusing on is not learning Python or C++ or whatever else, but learning _how to program_. Resist the temptation to pick up "Teach Yourself Python in 45 Seconds" to learn the language for the sake of learning the language. If you focus on learning the fundamentals (happening to use Python while you're doing it) and decide later on that Python isn't right for you, you'll be able to pick up another language with little trouble. They're all expressing pretty much the same abstract concepts, it's just a question of the degree of elegance with which you can realize some of those concepts in code.
seems you've been struck by this well-known ailment called OMG-so-much-FREE-info-making-me-confused-and-wildeyed. Take a deep breath, ask yourself : "how many books can I read and focus on at one time ?" Those 3 are all good, just pick one and dig in. If you're like me and have little patience, you might want to start with a small booklet type of intro tutorial to whet your appetite. ("Dive into Python","Byte of Python") BTW, the first book you linked to is not by that "Mustapha" guy, it's by [Professor Norm Matloff ](http://heather.cs.ucdavis.edu/~matloff/python.html) 
Also, drop by #python on Freenode when you have a problem.
Yes. The best advice I was given early on is just to try a short tutorial in a couple languages (Ruby, Python, Java... not PHP - it will give you bad habbits) and see what feels intuitive to you. For books, *Byte of Python* and *Learn Python the Hard Way* are great places to start. They're free and really well-written for technical books.
No, perl is like the dark side: powerful but will send you through an evil path.
The Windows console and Python don't play nice, especially if you want to print Unicode characters (see [unicode2.py](http://bugs.python.org/file20320/unicode2.py)). However, it's fine to instead use a GUI console on Windows such as the one provided by IDLE and other IDEs. I use [IEP](http://code.google.com/p/iep).
Thanks everyone for the feedback. I have a question, how do I know if I am "starting" with Python 3.X? 
"inspired by zope?" No longer interested.
Easy: Did you [click](http://www.python.org/download/) on Python 2.7.2 or 3.2.1?
if you've already downloaded python and don't remember, go to the command line interface by typing 'python' in your command line and it will print the version you have.
Thanks for the code and your reply, but I would really like to finish this up in eyeD3. You know. Out of spite. Well, kinda out of spite.
Thank you for replying. I commented out the "tag.link..." line of code and added the line "print "/home/else/Music2/"+i" into the for loop My results are in the following document, which I have uploaded to Scribd: http://www.scribd.com/doc/60694134/Results Here is an excerpt from the document: /home/else/Music2/PBXC.mp3 /home/else/Music2/OUZQ.mp3 /home/else/Music2/FIFB.mp3 /home/else/Music2/ACNV.mp3 /home/else/Music2/EAWS.mp3
Yes. Good resource: http://learnpythonthehardway.org/book/index.html
Maybe you should check this out: http://www.youtube.com/watch?v=tKTZoB2Vjuk
I disagree with the 3.x. I suggest starting with 2.5-7 because of module compatibility, and switching to 3 later would be a breeze.
I recommend starting with 2.xx if the person already knows programming and plans to work with Python on the near future, in this case he plans to go for the sysadmin route and is also a beginner so py3 is a better choice imo.
do you know Perl?
oh shit I forgot two big ones: * MIT OpenCourseWare "[A Gentle Introduction to Programming Using Python](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2011/lectures/)" * Google Code University "[Google's Python Class](http://code.google.com/edu/languages/google-python-class/)"
My sentiments exactly. My initial experience with Python was on a Zope project and I have to say it was probably the worst way to learn a new language. Although Pyramid has no doubt, evolved quite a bit from Zope 2.7, I get the sense that Pyramid perpetuated the architecture astronautics that made Zope such a PIA to use. My favourite quote from PyCon: 'Python takes all of the difficulty out of programming, Zope puts it all back in!'
not for the weak minded.
I didn't catch the sysadmin part. Muh bads. 
That's what I'm doing too! I'm going through Zed Shaw's Learn Python the Hard Way. He shows you how to get set up, and you don't have to install anything. Definitely the easiest way to get started. If you want to watch some videos, I definitely recommend Khan Academy's videos for the first timer: http://www.khanacademy.org/#computer-science
It just aint Zope: http://docs.pylonsproject.org/projects/pyramid/1.1/designdefense.html#pyramid-has-zope-things-in-it-so-it-s-too-complex 
import nexus7
Worthwhile giving Ruby a shot since you're in the neighborhood. Very similar to Python, and from my experience, some people are Python-minded and some people are Ruby-minded. As for resources, if you already have basic logic down like variables, loops, and classes/methods, then just jump into something and look up what you need to as you need it. Intro-level resources and chapters always bored me before it ever got to something interesting.
If you already have some basic knowledge, then the [google python class](http://code.google.com/edu/languages/google-python-class/) is one of the best resources you can use to learn python. And to answer your question, yes, python is a great beginner language.
Pyramid is not zope. It use the Zope Component Architecture in aim of give you the choice of components you use. 
&gt; Ruby community has a tendency of making more effort in looking cool than doing quality stuff Let's not air those scores here. The OP is likely receiving their first introduction to the Python community through this post, and the top-rated comment calls Rubyists poseurs. I mean, I think there are some weird issues with the Ruby community too, or at least with some of its most prominent members and the tacit acceptance they enjoy from the majority. But it's not exactly a selling point of the language that, hey, at least we're not those Ruby assholes. If you wanted to give the OP a serious reason to prefer Python to Ruby for learning programming, you could have offered an answer that actually takes the question seriously. You might have said that Python is a syntactically smaller language that stresses regularity over optimization for common cases, and is therefore easier to learn. You might have even compared some representative samples of Python and Ruby source. Instead we get a snide jibe that leaves the reader with the impression that you spend rather a lot of time thinking about how terribly nasty those Rubyists are. Instead of, you know, worrying about your own code.
&gt;"PHP is a minor evil perpetrated and created by incompetent amateurs, whereas Perl is a great and insidious evil, perpetrated by skilled but perverted professionals." -Jon Ribbens 
I would recommend using libssh python bindings, setting up a basic ssh client class, you can then simply use the scp_send(remote_location, mode, filesize) call. I've used it to do remote sending and retrieving on many small and large files, as well as remote command execution. http://pypi.python.org/pypi/pylibssh2 Documentation for its use can be found in the directory of the download.
I learned Perl before I switched to Python in disgust. poteland is right, clarke187 wrong. Edit: here's [something I wrote in anger when I switched](http://www.garshol.priv.no/download/text/perl.html).
may be but I know poteland and I didn't knew he had knowledge of Perl. maybe he does.
Talking about javascript, python and coffee - I strongly suggest checking out CoffeeScript
In my experience PyPy can speed things up considerably (depending on the app), however memory use can escalate greatly 
by the way, how are you going to switch to IT? I'm interested in switching to it too. But many entry jobs seem to require a bachelor's degree in CS or something, so I'm thinking of getting a bachelor's degree in CS (I heard German universities are awesome, so hopefully from there), or maybe a master's in CS (to make it 2 years).
Wat. *Edit: I also looked up [Jackson-structured programming](http://en.wikipedia.org/wiki/Jackson_Structured_Programming) -- even more wat.*
hmm well my opinion is not representative of the Python community nor the Ruby one, my opinion simply reflects my own experience which is what I wanted to share with OP and I'm entitled to give it like this because I've worked professionally with both languages, of course it's subjective. regarding the reasons you say I should've posed I think I've mentioned them, take a second look at my post. even so as I've said before when considering a language for any practical purpose the community plays a big role. the Ruby community is the most active of the three and they do a great deal of innovation, while that might be appealing to a programmer who wants to try new and exciting things, it's not the best for someone who's starting (again, imo). the tendency of "looking cool" is a big problem there, I feel like there's more value to them in getting a name and reputation than doing quality stuff, of course this is a great idea from an economic perspective since by having a reputation you can get better opportunities and once the reputation is set it doesn't matter what code you write, you just need to stay famous and that's all. the consequences of this are that there's TONS of similar libraries but not a single one that works well, it's obvious that the best software is the one that is most used and contributed but if everyone tries to get "his" library on top of others then you can't have collaboration. something similar happens with conferences, the Ruby community has the most conferences I know about compared to any other language and that's possible because everyone there wants to be "the guy who gave a talk about X" but the consequence is similar than the previous: lots of repeated content with very low quality. another very bad thing I've noticed is the irresponsibility which they abuse the magic, Ruby has many "magic" features like open classes, introspection, etc. but since people wants to look cool and there's many guys who know just a bit and start blogging or even giving talks, nobody has a sense of "good practices" so everything fall into chaos pretty quickly. this is something that doesn't happen at all in the Python world it's almost like the other end of the spectrum, Python people is pretty conservative and they put much weight into doing The Right Thing always (and for the record, Python is as flexible as Ruby). just an example, you as a Ruby developer are supposed to run the tests of each library you use every time you add a new one. why? because that new library has the potential of altering core features of the language (that's part of being cool, according to them) and those changes may, as you can imagine, break anything else that depends on the original behavior. now that I mention that there's something to praise :) these guys have a much stronger philosophy regarding tests (out of necessity I think) so on the Ruby world you'll probably learn a lot more about that, other languages have libraries for the purpose but it's not as embedded on the community as in this case. there's also a lot of buzz about methodologies (currently Scrum) so while I don't believe in those it may be something interesting to know as weel but probably not for a beginner.
Didn't see this in r/python, registration closes Monday the 15th of August. Unfortunately there doesn't seem to be any community info on the site for those who are going and want to meet up, so looking to get the word out there for those who are going and those who didn't know the conference was on.
http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/
ReadAhead Equivalent: from itertools import chain chars = chain(line, [None]) In Python 2.6+ you can use the built-in 'next' function, i.e. `c = next(chars)`. 
So far, the only Zopy thing I've had to deal with was to get the Jinja2 environment instance, and that code looks like this: jinja_env = config.registry.queryUtility(pyramid_jinja2.IJinja2Environment) And I only needed this because I wanted to do something that pyramid_jinja2 didn't support out of the box: configuring line-statements. 
+1 for #python. Those guys are super helpful.
i lol'd
I would say, yes. I'm teaching my eleven year old son how to program and we're using Python. Have you ever heard the term "impedance mismatch" when people are talking about programming? I've sometimes heard it used to describe the difficulty in actually achieving what you want to do - how much extra crap you have to do just to produce the results you want. A low impedance mismatch means you think of something and can make it happen, easily. High impedance mismatch means you have to jump through hoops to get it to happen. Coming from C, VB and C# I find Python has an incredibly low impedance mismatch. I think of something, have a play in the console (because I'm hardly an expert and often need to try out functions to see how they work) then code it up. And I'm constantly surprised at how often what I code up just works, straight away. No debugging, no having to think of another way of doing things because the language and its libraries don't work the way I think they do. Mostly I think this is because the language strives to be simple. Not simple as in dumb but simple as in straight-forward. Compare a Hello World program in C# with one in Python: 1) C#: * Create a Console project in your IDE of choice: Visual Studio Express or Sharp Develop. * Add a class. * Add a static method to the class, called Main. * In that Main method, call the static Write method of the Console class to print "Hello World" to the console. * Call the Console.Write static method again, to prompt the user to enter a key to continue. * Call the Console.ReadKey static method, which will hold the console window open until the user presses a key (if you don't do this the console window will flash up and disappear too quickly to read). 2) Python: * Create a new text file with a ".py" extension in any old text editor. * Add the following text to the text file: print ("Hello World") And that's it. EDIT: Formatting. 
Hey chris, when are you guys planning to switch to python 3?
I have both on my linuxmachine atm. The only reason I am hessitant to start in python 3, is because literally almost every beginner resource I can find. In lcuding all the videos on youtube and texts, are introducing you to python2. But I will keep looking.
not much, but several legacy scripts on my previous job were written in perl and I had to maintain them. What is worse: they were written in GOOD perl. I ended up porting most of it to python. Much to everybody's happiness. hey, I respect Perl, but they fuck too much with the "explicit is better than implicit" principle, for example.
I aleady have experience building everything from a normal everyday pc, to virtual server clusters, embedded devies, routers, firewalls, setting up vpn's across networks be it pptp to openvpn. I am familiar with a number of os's etc., I plan to get my A+ and Network + certs in the next month or so. This wil help me get my foot in the door. Then I can get experience. In Canada, experience + certs can equal an education(in the technician field). So long as you can prove you know what you are doing. I then may go to a two year college program which will get me a diploma and security + microsoft certs, cisco stuff etc., I could probably get into a four year computer science degree here. However it focuses more on programming then I want. I know a couple CS majors and grads and I know 10 times more then them about building networks, security, and pc's. They know 10 times moe then me when it comes to software and programming. Keep in mind, I am 26 right now. So i may be a bit "old" to make a switch. But since I have been passioniate about computers since I was 8, I can't seemyself being happy doing anything else. 
I think it is which is why I am learning it. Python lets you do the gamut of things from command line, to gui programming, to the web. So your knowledge just continues to increase. The community is very good and helpful.
You are younger than me I am 29. I'm switching for better job security and easier immigration (to Europe).
Honestly, Python 2 and 3 are not all *that* different. Some people seem to treat it as a major life choice, but not give any details as to why. In fact, for new programmers or just new to Python, learning one is *generally* the same as learning the other; they only differ in small details that make programs not be intercompatible between 2.x and 3.x. The concepts and overall structure are going to be the same. Once you've learned one, you'll know enough to get those minor differences, and realize you already know the other. Which one should a new user learn? The answer is either one, but with caveats. * Why 2.7? 2.7 will have the largest library support. You'll be able to pull in more cool things and do stuff with them. You're more likely to find 2.x code in existing production systems. However, if you do pick 2.7, once you start getting into intermediate level coding, start paying attention to bytes vs unicode - that's the biggest thing which changes in 3.x which will actually impact how *you* structure code. The other changes are superficial. But until you start caring about unicode and character set encodings, just forget that last bit :) * Why 3.2? The changes made to the 3.x series broke backwards compatibility with 2.x *specifically* for the purpose of making the language cleaner, simpler, and more powerful. It'll be easier to learn, with less implicit magic behavior, fewer "warts", and just general improvements. Once you learn it, writing 2.x code will be easy, it'll just feel "dirtier" as some things which took 1 line require 2. But not in any way feel like you're having to learn a new language. --- Really, the main thing is to learn the language - find a book that best teaches it in a way that makes sense to you, *whichever* version of Python it's targeting. Once that's done, learning other versions will a minor thing.
MY EYES.
methods are not really syntactically bound to classes, so that allowing class Obj: def __init__(self, self.x, self.y, self.z): pass would have the following implications: 1. We must either check that the method is a member of a class (this may be a little difficult as we can theoretically assign methods to classes dynamically) or make this syntax available for all def clauses. 2. self is declared in the same scope as self.x, self.y, and self.z, which means that we can't determine whether self is bound at the time of self.x, self.y, and self.z. This is only possible if we ensure that the definition is as a class member. IMO the only way that the code could work as is if we break a lot of stuff already in python. If you really want something like this, this is a very hackish decorator to do just that from types import MethodType as method def implicit(cls): if not hasattr(cls, "__init__") or type(cls.__init__) != method: return cls old_init = cls.__init__ def new_init(self, *args, **kwargs): for i,name in enumerate(old_init.func_code.co_varnames[1:old_init.func_code.co_argcount]): setattr(self, name, args[i]) old_init(self, *args, **kwargs) cls.__init__ = new_init return cls @implicit class A(object): # also works on old style classes def __init__(self, x, y, z): pass a = A(1,2,3) # Note that the variable check is no longer done as __init__ is now a *args function print a.x but in my opinion, it's really not worth the effort to just sugar coat field assignments, I mean, it may even be faster to just use a tuple as an immutable struct and a list/dictionary for mutable ones. (C structs can be indexed both by key or offset)
I would even go so far as to say that Python is the best beginner programming language. It has a gentle learning curve and yet is very powerful. I wrote a free Creative Commons book to teach programming to total beginners by making small games: http://inventwithpython.com
All fair points--like I said, I don't disagree that the Ruby community has an air of sickness to it in a lot of ways. There's just a difference between announcing an opinion and giving someone reasons to adopt it, especially when the opinion is inherently inflammatory and the person you're talking to, by their own admission, is not familiar with the domain. Think of it this way: someone posts to r/ruby asking whether ruby is a good choice for a first language, mentioning that they're also considering python. The top-rated comment advises the OP that they should learn ruby because python is for anal-retentive neckbeards. That wouldn't look good. In fact, it's precisely the kind of thing that would make you think that there is deep rot in the Ruby community. So let's not do that either.
Ha I just ran into this too; it's on the todo list to fix. https://github.com/Pylons/pyramid_debugtoolbar/blob/master/pyramid_debugtoolbar/__init__.py#L113 (and yes, that code is a shameless ripoff of a shameless ripoff ;-) )
switch, probably never. support is imminent though; we have 2 GSOC students working on porting dependencies now.
Thanks for the resources; I'm teaching myself python for GIS at the moment and those will help a lot!
I know a lot of languages and I can't think of any more beginner-friendly than Python. And this book might get you started: http://learnpythonthehardway.org/
Not only is python a good language for beginners it is also an *excellent* systems language for writing maintainable reliable code.
The one thing I can add is that whoever said C++ is fucking with you. C++ is not a beginner language in any way. C++ is for professionals who need their software to run as fast as possible, at the expense of sanity. The reason there are so many memory leaks and security holes in the world of software is that even professionals are bad at using C++ well.
The one thing I can add is that whoever said C++ is fucking with you. C++ is not a beginner language in any way. C++ is for professionals who need their software to run as fast as possible, at the expense of sanity. The reason there are so many memory leaks and security holes in the world of software is that even professionals are bad at using C++ well.
So this is ipython for not windows?
No, it is more of an ipython alternative. They have different (but overlapping) feature sets.
Apparently it's a common assumption: http://twitter.com/djangostories/status/83834350461911040
I can only go for the first day (Saturday), but I'm looking forward to talks and [speaking](http://pyohio.org/schedule/presentations/5/) as well.
I've mainly used IPython, is this a better alternative?
ah nice, you're qualified to your opinion then :)
if you use setuptools just run: python setup.py develop
If you have pip installed just use: pip install -e ./ That should do the trick...
I wasn't aware that Python is used in Singapore at all. Of course it's not terribly surprising -- there probably are Python programmers wherever there are enough programmers, which is wherever there are enough computers -- but Singapore isn't really the country that pops into my mind when I think about Python programmers. I suppose the women-in-Python thing is as relevant there as it is everywhere else, then? What's with getting an awfully generic `.com` domain for a local organisation, though? Are there plans to internationalize the effort? The domain doesn't really scream "This is only about Singapore!" to me, although the website does.
Thanks for posting this mrvar. I'm one of the organisers, can't believe I didn't think to post it here myself! Any tips to make the website more useful will be gratefully accepted.
Today, if you know java, you will likely get 20-30 calls a week from recruiters. Python jobs are slim though it's growing. Unfortunately they want you to have python experience before they hire you. Python is excellent for learning but you will need to know more than just python to land a job
StackOverflow is better suited for this kind of questions.
In other words, Python lacks a Do-While construct. 
Also, bpython believes in not adding anything to the editor in terms of magical things. So not interfering with normal interpreter behaviour.
Depending on what you use some people find it to be better. We try to do no-magic.
The website in general is good, it's informative and provides all information pertaining to the conference. I find python is quite community based, which is why a lack of information on where to discuss the conference further was surprising. A simple forum setup, additional mailing list (I noticed there was one for announcements) and/or an IRC channel would allow people to ask the social questions as well as help them organise additional meetups or code-a-thons.
Glad to see this is still around, wish they'd officially add Windows support though. The Qt front end for IPython is pretty cool in the mean time. 
what main issues do you encounter for the windows port?
what main issues do you encounter for the windows port?
i would like the author to expand on why this way of structuring code is preferable. especially how would it be relevant today.
If you have a bit of test code, just put it in the module's directory, and use 'import modulename'. Python should look in the current directory for modules as well as the PATH. I'm not sure which is first, so you may need to finagle that, but you don't need to install things to run them. Side note: IDEs for Python include IDLE (the default), Eclipse (with a plugin) and various others.
I first discovered ipython in Linux... it's available for both.
How do you define magic in this context?
iPython is iPython for not windows.
I add the directory containing the module to the PYTHONPATH during development. Another option is to add it to a .pth file in site-packages.
I think one can use Tox (http://tox.readthedocs.org/) for this. Tox will create a source distribution (*sdist*), copies it to someplace, and then installs it into a *virtualenv* environment. This ensures that the version that gets tested corresponds to the current state of files in the git repository. We can then use this *virtualenv* and import the module to interactively explore it. For my own projects I have a method that works with and without Tox. I use the following dir structure: prj/ setup.py prj/ prj/tests prj/tests/__init__.py prj/*.py src/any_c_and_cython_files doc/ ... The directory *prj/prj* is the package and the top level *prj/* is the repository. I install distribute (http://pypi.python.org/pypi/distribute) and then use the setuptools that comes with it. Now in the setup.py file I pass the option *test_suite* to the *setup()* function and point it to *prj/tests*. setup( all options needed to compile/install the module, packages = ['prj', 'prj.tests'], test_suite = "prj.tests", ...) After making any change to my code, I run python setup.py test This will cause setuptools to do everything that it normally does while installing the module, including compiling C extensions, copying data files etc., and creates a complete package inside prj/prj. Then it runs the tests in the sub-module *prj/tests*. Please read unittest documentation to see how to create a test suite and the distribute documentation to learn more about how to "point" to a test suite. Now from the top level repository directory *prj/*, I can start iPython (http://ipython.scipy.org/) and then import my package and interactively explore it. I can also use the *%run* command in iPython to run any test scripts that I have. I also run Tox, to make sure that it works in multiple Python versions and that everything works outside the repository as well.
I love how relatable this was! Great work whoever made it. 
&gt; I tried to parse a string and I think I killed 20 people! I've *definitely* been there.
Does it have searching the history yet? All the nice colors are worthless if I have to rape my cursor keys to find a certain entry. :(
Haha this is amazing :)
Brilliant
Can i have a good tutorial on how to use scipy/numpy, but with a comparison with matlab?
Very nicely put together, esp. the guest-appearance of Guido Van Rossum.
http://www.scipy.org/NumPy_for_Matlab_Users
elicited few laughters, very nice!
Spyder
TIL, that is nice!
Black Knight to the rescure, wxWidgets is excellent, PyQt or pyside are better.
I use this, and it's great! Makes it a real no-brainer to use virtual environments.
I think the official tutorial is amazing, that's how i learned to program!
Perhaps you can use ActivePython (http://www.activestate.com/activepython) or Enthought's version (http://www.enthought.com/products/epd.php) in the meantime, until the real thing is back up.
damn, and I was holding out on using it until you weighed in. :)
This could actually be worse for others' perception of my career than _The Social Network_. Thanks, Quentin.
So the only thing I see that is different about it is the shortcut to each virtualenv's bin/activate script? 
Ok this might be one of the best redubs ive ever seen. 
i'll be at the conference, not sure how much sprinting I can do though
Death to matlab, long live numpy!
If you are using Windows, i suggest Pythonxy for a free and open source distribution, if you are a student, then get enthought's distribution(EPD) (if you have money and do numerical or lab work, it is worth it to buy a license). EPD is also available for Linux and mac as well.
Does anyone know what the original movie is?
metropolis
Yep -- it's made up of around 40 rearranged clips, though, so you may be surprised by the ordering when you watch the original (which I highly recommend).
We decided that should be Guido before we knew how similar their beards were: http://www.python.org/~guido/ :D
Creating all your virtualenvs in a single location automatically (with shortcut for deleting by name too), plus allowing custom hooks for pre and post activation / deactivation. Lots more I think, but these are the features I use.
We didn't have as much luck with Dr Moler and Jack Little: http://www.mathworks.com/company/aboutus/founders/clevemoler.html http://www.mathworks.com/company/aboutus/founders/jacklittle.html
Saying pyramid is zope would be like saying twisted is zope, using zca doesn't make it zope or an evolved zope. A lot of computers share electronic parts and are not built the same, same apply for cars, etc...
that was beautiful
The problem I have with NumPy and SciPy is that the matrix syntax just...sucks compared to MATLAB's. I mean, it's a logical consequence of adding matrix support to a language already using [ and ] for lists, but still...would rather just use Octave.
Okay, I think I get it. It seems like it makes reuse of single virtualenvs easier, for sure. I could have 3 different Django projects that all use the same basic packages. The virtualenv can sit over there, while making it easy in the terminal to access it from my django project folder.
Yes, I remember that was my reaction the first time I used them (that some matrix syntax seemed slightly more verbose), but it no longer bothers me. I think it's a consequence of Python being a more general-purpose language. When I am in fact doing something with matrices, I'm ok being explicit about that, since (for me) it's not the majority of the time (I use Python for web development, for instance -- where I don't use matrices as often, but when I do, it's easy to integrate scipy calculations with my server code).
Spyder is an environment, not a tutorial. :) But here's a link anyway: http://www.pythonxy.com/ And if you are looking at PythonXY, you should also look at EPD (Enthought Pyhton Distribution), which is now free: http://www.enthought.com/products/epd_free.php
I put a wrapper around your wrapper to.....
"Learn Python the Hard Way" or "The Hard Way to Python"? Learning to code would be a lot easier if you paid attention to details like this.
He says he is using gedit, it is unlikely that he is running windows. edit: I shouldn't drink and reddit... 
No? I am using gedit.
I don't pay attention to irrelevant things because it's a loss of system memory. I usually just end process the things that are useless and go with the quickest method of getting information. The titles are of course irrelevant. Everyone knows what I'm talking about. But I understand what you're saying. Little semantic details are all too important when you're actually coding. 
The [gedit](http://projects.gnome.org/gedit) page seems to have a win32 binary. You could also compile it yourself in [Cygwin/MinGW](http://live.gnome.org/Gedit/Windows). But I was just answering the last question: &gt;Also, I was wondering if I should do my python programming on a linux based system as I have read a few things saying that windows has a lot of problems with it. 
&gt;I'm ok being explicit about that [Line 2 of "Zen of Python"](http://www.python.org/dev/peps/pep-0020/)
If only python had something as awesome as the Bayes Net Toolbox for MATLAB...
Sigh... it could have been at least a little two-sided. Matlab is exceptionally good at what it's intended for: rapid prototyping of numerical algorithms and getting graphs, tables and figures to put in your paper. There are a lot of incredibly advanced algorithms that are fully integrated into the basic syntax. Python is a much more well-rounded language, but also very immature. Python's capabilities at graphing and surface plotting are just as capable as Matlab's, but it is a lot less intuitive and interactive. Numpy's main libraries are consistently smaller and less optimized than Matlabs. That said, python is obviously a better choice if you want your software to do anything more than crunch many teraflops to produce a graph and table for your paper.
"less optimized that Matlabs" [citation needed]
Has anyone tried PEBL? http://code.google.com/p/pebl-project/ I ask because I'm planning to do some Bayesian structure learning soon, and I'm looking at what tools are out there. Another option is using some of the powerful modeling tools in R, and accessing them via RPy: http://rpy.sourceforge.net/rpy.html
We tried to be fair by capturing the Python community's reputation for religiosity. ;) But point taken.
There is some Stochastic Python stuff out there and soon to be Python ability to control Church (Stochastic Lisp/Scheme).
Unoptimized numpy is almost exactly as fast as Matlab in these 4-year-old benchmarks: http://lbolla.info/blog/2007/04/11/numerical-computing-matlab-vs-pythonnumpyweave/ When they use any sort of Python optimization, it outperforms Matlab. And just wait until PyPy adds support for Numpy! http://morepypy.blogspot.com/2011/05/numpy-in-pypy-status-and-roadmap.html
There's a good amount of structure learning software out there, but few perform inference for general bayes nets. This seems so strange since I'd consider inference to be the fundamental point of bayes nets. Maybe everybody who built such a system decided to sell it instead of open source it?
&gt; [citation needed] This is a little old but very representative. Note that they are using a recent numpy version against a 2002 Matlab version: http://mail.scipy.org/pipermail/numpy-discussion/2007-February/026026.html In particular, Matlab is much faster out of the box compared to numpy when downloaded as binaries. In fact, the version of numpy i just got from the Ubuntu repository wasn't even using my multi processor! You can recover some of the lost speed by replacing generic linear algebra libraries with optimized, machine specific versions, but this is an incredible headache. I'm doing this right now, and it's a major headache.
I always knew that Python had a Church!
Fuck MATLAB, you can't make a web interface with matlab. Nuff said.
The one thing I find annoying with Python (matplotlib in particular) is that to graph, you have to keep calling pylab.show() Much more annoying than the on demand graphing that MatLab allows. 
I appreciate the sentiment, but combining eventlet and mongrel2 into a voltronic force capable of speeds faster than Tornado was the real motivating factor. I turned it into an implementation, rather than an idea, because I love coding!
Running ipython in pylab "mode", you can just use plot(x, y), and it will pop up immediately. However, the explicit-showing approach has advantages when you want to control timing of the plot generation and plot display independently.
I hate to come off as flippant, but if you're doing web dev...just use Tornado. Failing that: http://dreid.org/2009/03/twisted-django-it-wont-burn-down-your.html/ The above are instructions on running twisted with Django, potentially out of date but they're the most recent I could find. You'll probably need to take cues from that and reapply to CherryPy.
Good idea. We've created a discussion group on convore and will be publicising it through the website and mailing list: https://convore.com/pycon-au-2011/
Gentoo mirrors have the source code to many versions of most popular open source programs. Though the download links on python.org are working for me.
I should have added that the bulk of the application is already written in twisted and relies heavily on a few other services. Mostly just aiming for a friendly environment to make a control panel for my stuff. Giving you an upvote because I didn't really specify much criteria or justification for twisted.
Give [Flask](http://flask.pocoo.org) a shot. Here's a [stackflow](http://stackoverflow.com/questions/5248825/web-interface-for-a-twisted-application) question (see accepted answer)
[bottle.py](http://bottlepy.org/docs/dev/) much simpler than flask and can run with python 3!
Thanks for explaining and for the upvote. Yeah the context would've been good, but what can ya do? You're really facing the prospect of using the link I provided as a basic template for how to approach re-wrapping Twisted with CherryPy.
Any chance of making the next one during the normal working week? Going to a Python conference for work is a bit easier when its on during work hours rather than on a weekend. Also, the last few have been in Sydney. Any plans to make future PyCon AU somewhere else - Melbourne perhaps? :-)
http://www.sagemath.org/tour-benchmarks.html Yep.
Not sure if it helps, here's a Tornado clone written using Twisted library. [https://github.com/fiorix/cyclone](https://github.com/fiorix/cyclone)
What's the supposed advantage of doing so? (Just curious.) Also fix your link and remove the .git
I've used Cyclone and found it very easy. It replaces the standard twisted.web, and rocks.
There are much more libraries for twisted, and much more production use.
Okay, and reasons to want to make it look like Tornado?
I actually use Tornado for a few projects already, but here's my thought: For people who already wrote large amount of code in twisted (e.g. their model layer), there's not much incentive to re-write it using Tornado's thin model layer. Using cyclone allows them to continue using twisted.enterprise.adbapi That said, Tornado's latest master branch have (some) support for Twisted libraries. So, my suggestion might not be very useful. (Fixed the link, thanks)
I definitely find it interesting, I'm just trying to understand the trade-offs of each for most people (my use-case is odd) and why one would use cyclone specifically.
with two fingers on his left hand
I'm fairly certain the conference is designed so as many people as possible can come, including those who can't take days off (e.g. Students). However, I'm sure rfkelly can explain further. On an additional note, the sprints are during the working week.
Support for Py3 isn't so important until Twisted goes to 3, but some support for my preferred templating engine, Mako, gives it a couple points ahead of flask.
I hear ya, but there are also a lot of people who find it easier to come on weekends rather than during the week. Given that the conference is just starting out, a weekend seemed like the best way to get the most people along. We're following the usual PyCon tradition of handing the conference off to a new organising team every two years. Not sure if it's all "officially official" yet so I won't spill any beans, but the next one will almost definitely be somewhere other than Sydney.
Lots of hip tools in here, which is great, but what exactly is 0MQ adding to the mix that couldn't already be done with greenlet? 
From a python core dev: &gt;Definitely watching this with keen interest. Early days yet, but I'm hopeful the API will eventually stabilise sufficiently that this could be a candidate for stdlib inclusion (assuming you're interested in that prospect). Perhaps not for 3.3, but maybe 3.4... as you say, the current stdlib doesn't make HTTP as easy as it could :P Holy crap dude, congratulations, that's awesome!
I'm curious but, if you're only doing webdev, why not staying with CherryPy in the first place if you're already using it?
There are some pretty clear benefits to using twisted or tornado if you want to wring more performance out of your front-end.
I've ran Django on Twisted's WSGI provider. Not too much, it was a fun experiment. Calling into long-running Twisted tasks from old Django logic is damn attractive.
Well, considering Tornado is single threaded, it will have terrible performances in many use cases. Obviously it'll handle well a large amount of opened connections but does it mean it'll perform better all the time? My personal experience has shown me it won't. As for twisted, it's a great framework but for web processing, CherryPy has been known to be more performant. So I'm foggy as what you consider to be "clear".
0MQ is for distributed setup: &gt; We'll be using ZeroMQ pub/sub sockets to manage communication in this demo. Pub/sub sockets have the nice feature that published messages get distributed to all subscribers currently connected, or if no subscribers are connected, the message simply gets dropped. 
Cool, thanks mate :-)
You can use Mako with Flask through the Flask-Mako extebsion :)
I knew that cat will work!
thank you from my cat http://dl.dropbox.com/u/865508/thanks_reddit.jpg
think of 0mq as the thingy you use when you need to pass messages between processes and don't want to use rabbitmq or something else enterprisey. it has nothing to do with green threads. 
gst - thanks for the submission (I'm the author of the report). The v0.1 report was submitted here a few weeks back (http://www.reddit.com/r/Python/comments/ic77c/high_performance_python_tutorial_v01_from_4_hour/), I've tried to address some of the comments for v0.2. I've also added descriptions for the pyCUDA code and extended most of the sections.
Granted, my experience with matlab was about 10 years ago, but the only really compelling feature of matlab to me was the DSP toolkit. The syntax was abhorrent, the pricing (unless you were a student) extremely high.
Working buildout for this, i get it only running on google chrom :/ 1.) Get a bootstrap.py 2.) http://pastebin.com/v1wjqqxf 3.) python bootstrap.py 4.) bin/buildout 5.) bin/python demo.py 
There's a number of options: * Set up a virtualenv manually * Test with ``setup.py test`` - handles package and test dependencies * Do ``--user`` installs to keep the system clean * Use tox to automate testing in clean virtualenvs against arbitrary python runtimes Tox is clearly the "best" option but might be seen as a little overkill for small contributions. I tend to set up a virtualenv for everything, using virtualenvwrapper + virtualenvwrapper.project + virtualenvwrapper.github etc: ``mkproject -t github foo; git pull`` (though the github template is for your own repos).
Actually, you can't if you've agreed to the MATLAB EULA (at least the commercial one...) during the installation. It specifically forbids access to the MATLAB engine through a web interface.
&gt; the pricing (unless you were a student) extremely high The pricing has always been my problem with MATLAB. It is shockingly expensive. As for "unless you were a student," I'd argue that it's still expensive. When I was a grad student around '01-'02, I had to use MATLAB for a class, but the student edition was US$100 or so. While this is "cheap" compared to the base price of MATLAB, it was way too much for me as a student. So, of course, I relied on Octave. Additionally, the student edition had (at least at the time) plenty of limitations on it.
You can use a [Flash implementation of WebSocket](https://github.com/gimite/web-socket-js) on browsers where native WebSocket is not available. On the server, you only need to take care of serving policy-request.
This looks like a much less obnoxious way to talk XMPP versus any of the existing libraries.
Have you looked in to commands.getstatusoutput? that might be helpful.
I was looking for XMPP Frameworks last weekend and none of them did convince me. Will have a look at XmppFlask for sure.
&gt; [...] codename Schraubschlüssel ... I have to ask, why does it have a codename that means "wrench"?
Because Werkzeug is a toolkit. Hence: Schraubschlüssel = wrench Hammer = hammer Schlagbohrer = drill Schraubenzieher = screwdriver Faustkeil = axe Wictorinoxger = Swiss Army knife 
Great job to everyone involved. Really enjoying working with Pyramid.
Hm, I guess that makes sense. I just thought it was a curious codename - generally, projects tend to use more "flashy" code names (ref. Ubuntu), or do cool stuff with it (ref. [Fedora - this is actually pretty cool](http://fedoraproject.org/wiki/History_of_Fedora_release_names#Fedora_16_.28Verne.29)). No offense intended :-)
communicate() waits for a program to terminate. http://docs.python.org/library/subprocess.html
&gt; --password isecretlyusedjango Not so secretly if you put it in the command line. `ps -e -o pid,args` will tell on you.
Works fine in Chrome
I tried to find a link to the EULA, but no luck. I'll let you know when the next terrible release becomes available.
Managed to find a [copy of the SLA](http://www.eecs.utk.edu/matlab/_media/license/mathworks_r2008a_sla.pdf). "4: Licensee shall not, and shall not permit any Third Party to:" "4.8: provide access (directly or indirectly) to the Programs via a web or network Application, except as permitted in Article 8 of the Deployment Addendum" The addendum says: "WEB APPLICATIONS. Only Programs licensed under the Network Concurrent User or Designated Computer Activation Types may be called from within a web Standalone Application, provided the web Standalone Application does not provide access to the MATLAB command line, or any of the licensed Programs with code generation capabilities" Then, see section 3.1 for license types; "Concurrent License Option" seems to be the one that universities use to allow institutional members to run Matlab if connected to the intranet and licensing server. I kept following the chain of definitions for a while, but the clearest picture I have is that you could probably allow web access to people covered by an (your) institutional license, and in the same country as you. IANAL, YMMV. tl;dr: use an open source tool like Python's Scipy, in concert with a Python web development framework like Django.
Our codenames have no meaning and are never publicly advertised except for maybe the release announcement mail. It's just for fun :)
Use `setup.py develop` instead of `setup.py install`. That will set up an "installed" version that is linked to your local directory.
I could see this clip being use to compare Facebook and Google+ too.
I'd suggest having a look at [Construct](http://construct.wikispaces.com/) if you haven't already.
This is wonderful, you have no idea how well timed this exact functionality is, thanks for sharing.
How is the length of the variable length strings determined? Do they have a terminating character like C string, or a length value at the start, or is there an index block at the start of the file like TIFF format? Or do you have to search until you find "aaaa" or "bbbb" etc. How big is the file? Is it feasible to read the whole thing into memory at once and treat it as a big string?
Thanks, take a look at that. I need more time to make that easier to use and I think I need to switch from old and horrible xmpppy to something else as a server.
Yeah, I will soon make config files and getpass support.
Well, that's the whole point of being a framework, not library. I now need to choose one of libraries instead of xmpppy.
You can use werkzeug with Bottle through the Bottle-Werkzeug plugin :) Jinja2 is supported anyway.
+1 for Construct. It's a great library
Your question answers itself. Bottle has no external dependency. bottle.py is a framework. flask.py is not a framework. Flask depends on a huge networking library and template library. The latest version of Flask paves the way for it to become a heavy-weight framework. Flask is no longer a "micro-framework". 
A decent GUI toolkit to use is wxPython (wxWidgets). However, I personally use PyGTK for everything (I find it to be a little nicer to work with, than wxPython).
Not to be confused with [PyLadies](http://pyladies.com/). :)
Interesting new features. I'm wondering if signal support and and delta tracking can be combined into something like [mongoid-history](http://rubygems.org/gems/mongoid-history) (or is such a feature already available for the Python drivers?).
If you're coming at this completely GUI-framework-agnostic, you might want to check out [this thread](http://www.reddit.com/r/Python/comments/is1hq/kivy_python_framework_for_next_gen_uis_gpu/) on Kivy? "kivy is the most awesome framework (for any language) for creating stunning user interfaces with support for a wide variety of input modalities like multi-touch, object/marker/fiducial tracking, kinect/gestures. Packaging for windows (exe), osx (.app/.dmg), and android is now available for easy distribution of kivy apps. It's licensed under the LGPL, so you can use it in both open and closed source projects. Info, downloads, and extensive documentation available here: http://kivy.org/ official github repo: http://github.com/tito/kivy From the release notes: Kivy is a full featured framework for creating novel and performant user interfaces, such as multitouch applications, under the LGPL 3 license. The framework works on Windows, MacOSX, Linux and Android. iOS support is coming soon, and available to brave hackers in repos." There's a focus on mobile features for sure, but it looks nice for more traditional use as well (GPU-accleration!)
What's new: * Revised multiprocessing implementation so that it works for test generators (#399). Thanks to Rosen Diankov for the patch. * More fixes to multiprocessing implemented by Buck Golemon and Gary Donovan (also part of #399). * Lots of improvements to the attrib plugin by Bobby Impollonia (#412, #411, #324 and #381) * Code coverage plugin now uses native HTML generation when coverage 3 is installed (#264). Thanks to Timothee Peignier for the patch. * Xunit plugin now shows test run time in fractions of a second (#317) @attr (from nose.plugins.attrib) can now be used as a class decorator (#292) * Fixes Xunit plugin to handle non-UTF8 characters (#395) * Fixes Xunit plugin for reporting generator tests (#369) * Fixed problems with SkipTest in Python 3.2 (#389) * Fixed bug in doctest plugin under python 3. Thanks to Thomas Kluyver for the patch. (#391) * Fixes mishandling of custom exceptions during failures (#405) * Fixed subtle bug in --first-package-wins that made it unpredictable (#293) * Fixes case where teardown_class() was called more than once (#408). Thanks to Heng Liu for the patch. * Fixes coverage module names – ‘cal’ used to also match calendar which was a bug (#433) * Fixes capture plugin when exception message contains non-ascii chars (#402) * Fixed bug in tests for twisted tools. Thanks to Thomas Kluyver for the patch. * Makes --plugins more succinct when there are no options (#235)
Haven't seen that plugin before, currently I do my versioning in an embedded document - which can be stored in a list on any document ... I quite like the separate collection approach used by the Ruby plugin will definitely look into that some more.
The only problem is that the Windows version requires at least Windows 7.
Yeah, saw that. Although OP is coding for Linux I think
Oh shoot, completely missed the headline! :) In that case, good luck to OP.
0.3 Released * Add indicator icons to PyAnalysis output list * Fix bug with not being able to debug GUI programs on Linux * Fix crash that could occur while debugging when plugin is unable to retrieve * Fix crash when setting configuration (caused by PYSTUDIO_CONFIG: should be PYTOOL_CONFIG) * Fix conflicting modules crash (MessageDialog needs self.mainwindow not self) editor instance from main application * Fix crash when switching between variables subshelves when not debugging * Remove quotes around pylintrc file that stopped it being recognized * Clear expression values when Go button pressed * Only evaluate expressions when debugger is broken to prevent "Debuggee has to be waiting at a breakpoint to complete this command" dialog * Add refresh button to Expressions shelf for use when pausing wx apps * Adding a new expression "checks" the check box * Right click on pyVariable tree item to add a variable to pyExpression * Type column added to pyExpression * Fix crash that could occur in compile check during file save. * Add filtering of variables by regular expression
http://code.google.com/p/editra-plugins/wiki/PyStudio Above is link to PyStudio documentation
There's also PySide. It's Nokia's python bindings for Qt. You can do some pretty slick stuff with QML.
http://www.marzocca.net/linux/baobab/baobab-usage.html
Yep, it looks like websockets isn't terribly portable. I'll be looking at doing another version with socket.io (for which there is a gevent wrapper) Real Soon Now.
I'm not really sure where I ought to post this. Really I'm looking for feedback from other developers, about the functionality and core design of the site. (I realize that it's butt ugly)
You need to log people in with accounts created on demand and linked to cookies, and then let them connect it to a real account. This way, people can preview the logged-in features without requiring signup. As cool as your site may be, you will get a small percentage of people actually willing to sign up to demo it.
...and even less people willing to take the time to tell you that. What a nice guy. Upvote.
good idea. There are readonly permissions on projects, I'll just have to open things up to unauthenticated users. thanks for your input :) **edit** I've updated the front page, to let visitors browse a live example from the site.
Woohoo! Go JP!
Can't wait to try it out!
Having built GUI apps in both, I much prefer PyGTK.
If I may hijack this a bit, what would redditors use: nose or pytest? I often see both but I fail to grasp their major differences.
Why don't you [support OpenID](http://openid.net/add-openid/)? I really don't want to generate or figure out another password for another random site.
[Begin Python](http://www.beginpython.com/) [Learn Python](http://www.learnpython.org/#) [Free Python Book](http://diveintopython.org/) If you need help with logic, operators etc [this is handy](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/video-lectures/) For web development python is a very good language. For design you still need to learn HTML as it is the only formatting language of a webpage.
Web design or web development? Front-end or back-end? If you want to do web design, you should look at learning HTML/CSS/JS, not Python. Web frameworks are written in many different languages, such as Django (Python), CakePHP (PHP), Ruby on Rails (Ruby). Python alone has tons of web frameworks.
Don't bother. Dive into Python 3, Learn Python The Hard Way and even the official tutorial at docs.python.org are more than sufficient to get a good grasp of the language. 
The official Python tutorial is good. [Project Euler](http://projecteuler.net/) is [awesome](http://www.theatlantic.com/technology/archive/2011/06/how-i-failed-failed-and-finally-succeeded-at-learning-how-to-code/239855/)!
Honestly, you don't need anything but the Python.org documentation / tutorial. I think it's one of the best guides there is, it was a treat learning Python with it. In my opinion stuff like this makes or breaks a language, somewhat. Try learning say, Powershell with Microsoft's documentation, I think it sucks hard. You shouldn't even need all that babble babble babble, you just need good dumps of available methods for all the modules/classes/etc. and you're most of the way there, add a couple of code examples and that's it. 
[MIT 6.00 Introduction to Computer Science and Programming](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/) Complete course materials and it is taught in Python. You can find all sorts of tutorials for web design using Python / html / javascript, but your chances of getting good will be much improved if you start from the top.
MIT open courses are great. Using this now and finding all the supporting elements attractive!
In the modern era, I've only ever used nose. It does everything well enough (and has a healthy enough plugin/module community) that I've never had to look elsewhere.
And: [HN's initial dissection](http://news.ycombinator.com/item?id=2810373).
where's the unit tests showing 100% statement coverage?
The one thing nobody's mentioned is whether you should learn Python 2 or 3. Python 3 was an overhaul that cleaned up a lot of things. Not all libraries are compatible with Python 3 yet, so this may make a difference where you begin. Have a look at http://wiki.python.org/moin/Python2orPython3
And now Cleve Moller has chimed in: https://plus.google.com/u/0/101406471263985999518/posts/eaYMgZqyMhB
&gt; JP [Jason Pellerin](https://bitbucket.org/jpellerin). Edit: I had mistakenly linked to github instead of bitbucket.
http://code.google.com/edu/languages/google-python-class/ Google does a class on it.
it looks like it throw a lot of wsgi features just to do some easy simplification and without understanding why things are designed this way in the first place.
I do plan on implementing [social login](https://github.com/uswaretech/Django-Socialauth) options, which'd include google, facebook, and OpenID. But right now, creating your teams within the program is strictly email based, so requiring email on registration keeps things clean and simple from a coding perspective.
No request body?
Hmm, the response dict looks like this: {"status": 200, "headers": {"content_type": "text/plain"}, "body": "Hello!"} Am I wrong in assuming that he's thrown long running calls out of the window by not using an iterable for the body?
WSGI is simple, cute and dandy. No need to hide it, thank you.
I like books, especially in the early learning stages. Here are some benefits to reading a book : - Reading print will allow your eyes to take a break from the screen - It is much easier to focus on a complete section of the language at one time when you have a complete syllabus laid out for you - allow yourself to focus on a section of the language at a time - if you skip any parts of the syllabus, you know that you skipped them Some of the above apply to good online resources as well. I recommend Learning Python by Mark Lutz (O'Reilly) : http://www.amazon.com/Learning-Python-3rd-Mark-Lutz/dp/0596513984/ref=sr_1_2?ie=UTF8&amp;qid=1311773578&amp;sr=8-2 also : http://www.reddit.com/r/learnpython
##THAT FONT NEEDS TO BE BIGGER
Also forget everything you learned in Java. Python is designed to be easy to get into. If you find something hard to do, you may be doing it the wrong way. Work with the grain and everything else should come naturally.
there's a thread like this every 2 days at least, fyi
yep that's exactly what he is doing. The discussion on HN is very informative about this framework flaws
Not sure why you got downvoted... If I don't see tests, I'm not touching it.
KahnAcademy has some decent beginner videos that don't assume any knowledge, if that style of learning is your thing. http://www.khanacademy.org/?video=introduction-to-programs-data-types-and-variables#computer-science
How does this differ from other (excellent) abstractions like "Werkzeug" or "WebOb"? (Different Intentions?)
I'd highly recommend [SleekXMPP](http://github.com/fritzy/SleekXMPP) if you're shopping around for a new library. Disclaimer: I'm co-author of Sleek. That said, I'd love to help with any integration, etc issues you might have since XmppFlask has a lot of potential. 
exactly. as of now webob has 100% statement coverage. Thus it is high quality in my mind. it just seems a tad arrogant of the author to make assertions that certain things suck and wish me to believe that they have a better way when it hasn't even been demonstrated that effort was put into making sure the stuff they want me to use actually works. i can swallow arrogance if there's tests to back it up. 
And you can have multiple headers with the same name, it's not a hash map it's an ordered multimap. Hell, even the sequence can be important, so you can't just use a hashmap of lists.
Not only that, but the first bit of code I saw that interacted with WSGI used a threading.local to do something that could be accomplished with a simple closure -- and *still* doesn't support the spec correctly. Basically, only WSGI apps that don't use any framework features (like error handling or write() callables) will work under his WSGI adapter.
http://inventwithpython.com
Actually, that wasn't too hard thanks to XMPPWSGI: https://gist.github.com/1109928
[Dive Into Python](http://diveintopython.org/)
Very, very rarely do I need to decrease the font size when reading content; it's usually an increase. This appears to be one of the rare exceptions.
Not trying to be defeatist or critical, but how does this, differ,for example, from numpy? I can make an array of numbers as a 'probability distribution' if I want, and do arithmetic operations on the entire array in parallel just as is done here.
Yes, thanks!! I saw that SleekXMPP is both library and a framework and I of course had plans to integrate that too. We will make XMPPWSGI a bit complex (maybe), but don't think that will be the case. More complex thing that we also have plans to make things like: app.run() (we will write some interface for running xmpp-webserver from the app, so it will be simpler), another one is that we need (I think) to make some default behaviour of xmpp servers that will 1) automatically add users to roster (when they add you, that's useful for bots), 2) register it's xmpp if it's not there (because people are lazy :-) Anyway thanks, SleekXMPP seems great library. Join xmppflask@conference.jabber.org if you want to discuss something. I will continue "fast" development in a day or two, I guess.
And while I'm at it, here's one for use with multi-user chat: https://gist.github.com/1110035
and thanks for leaving my name in header :-P :-) p.s.: I really need to add Armin Ronacher and whole Werkzeug crew to AUTHORS.
gevent uses greenlet for coroutines (not yield) This helper lib (adisp) attempts to accomplish what is already the case with gevent but with an odd api. With gevent you would just do: some_socket_call_a() some_socket_call_b() In gevent when you do an operation that would block the current greenlet is scheduled to resume when the operation can continue. You write traditional 'synchronous' code but any 'blocking' that occurs only blocks the current green thread (you would have many at the same time). This seems to me a much more natural approach to evented programming in python. For example vanilla redis-py works (as well as things like Django, etc) thus eliminating the need for specialized projects like this one (brukva). I don't see how this is desirable to the gevent approach (which is faster too IIRC).
0mq would typically be used as part of your messaging layer in a more complex ecosystem. More complex 0mq examples start needing multiple threads or processes -- you can usually express these examples easily in a single process without going to threads. An example use-case would be that you could easily take an 0mq environment that is written in c for speed but then attach gevent to the 0mq pipes and turn the messages into websocket messages easily. Lots of use cases here.
This is nice. Does it work with distributions defined implicitly from data? 
I don't know how this works, but I'm sure it's way faster and more accurate than doing a histogram or some other density estimator, particularly for discontinuous distributions.
It decides that WSGI is bad, where Werkzeug and WebOb build on top of WSGI.
You can use existing python code because gevent monkey patches blocking calls with non blocking calls (using a greenlet). I wonder how performant this is?
I thought you guys might be interested to see this. I recently worked for this guy on two projects: the Plasti(k) Pavilion in downtown St. Louis (here's a pic of it finished: http://imgur.com/lkYOT ) and the Pompidou project, and I'm still blown away by his work. He uses a series of Python scripts he wrote to create incredibly complex shapes that can be constructed out of flat pieces of plastic or aluminum that are then custom cut to make some of the most odd/futuristic structures I've ever seen. Marc Fornes is also a really good guy, as far as I know, and really puts everything he has into these projects
Why would that slow things down? Gevent performs very well.
An explanation would be helpful. 
Upvote for LPTHW. But it needed a link: http://learnpythonthehardway.org/
An array has to be finite, and with discrete components. A probabilistic distribution in R is continous and unbounded, so it has an infinite domain, which cannot be represented accurately with an array. If you do plotting in countinous space by interpolation with numpy, you may miss some non-integer important stuff, but with PaCAL it will work.
Truly awesome stuff. I'm not technologically naive, by any means, but I'm amazed almost every day by the things people're doing with computers.
So is it storing the data internally using a computer algebra system? Storing the distributions symbolically?
Is that ironic?
Is that ironic?
I highly recommend this. It is a great start even though it covers only a small subset of python features. I still use it as a reference sometimes. But I'm still novice myself.
This looks really interests. Can anyone who know more about statistics than me ways in? For example, even if I had data I wants to use this one (and lets face it, I am metals musician so when woulds this ever even happen?) and did it and looks at the output and the source and it all looks fine, I don't knows enough about statistic to know whether to trust the operations it performs. And while gallery on web site am really great - very well documents and lots - one thing what ams missing is just some reassurance into how close it ams to if you did all the calculation manually. So this would be first opinions I woulds want, because whole beauty of library like this is for people who maybe don't know all the specific statistics math (but just general application, when to do what with data) to be able to manipulate things accurately too, which woulds be great.
You break the back button a la twitter, bad web monkey bad! no cookie for you. Joking aside though, not cool, users get *pissed* when you break functionality like that.
Roughly 50% of what gets posted in here should go to /r/learnpython.
[Arithmetic on random variables](http://www.google.com.au/search?sourceid=chrome&amp;ie=UTF-8&amp;q=random+variable+transformation) doesn't work the same way.
because P(A+B) != P(A) + P(B)
Yes ^ . Design or development? That sums it up. I might be considered a heretic for saying this, but learning the ins and outs of a CMS (content management system) will get you far. HTML is still relevant but the first thing you gotta learn is that its not a *programming* language -- its a *markup* language. Having a good reference and consulting it is enough. Don't thing you need to **absorb** all of HTML before you move on. That's like thinking you'll be a good writer once you know what all the buttons do in microsoft word. CSS + HTML + javascript is something people make way more complicated than it needs to be, in that you only need to know the *right* stuff, not *all* of it. But ask yourself: *Is what I am trying to do something that can easily be done by a content-management system?* I swear I could kick myself for trying so many times to reinvent the wheel. But, if you think you're going to be inventing some new wheels... go right ahead and learn whatever languages you can/need. But if you are only into the design aspect, you could skip most of the programming and just do the theming / skinning niche. Learn python anyway.
Factorials, Factorials, Factorials, Factorials, "Python 3 is not backwards compatible with Python 2" -- Duh., Fibonacci, Fibonacci, Fibonacci...I don't see much of particular use there. Like 5 total videos are worth anything...the rest is...bleh. 
That list is unreadable without mousing over it.
Python works really well with Rhinoceros, the 3D modeling program. So the Python script runs in Rhino, creating these shapes out of developable surfaces. For the plastic one, the digital model was disassembled and the flat pieces were programmed to a CNC Mill (this is what I do, pic related http://i.imgur.com/pIhnf.jpg), cut out, melted, formed, then screwed together. Takes a long-ass time, but produces pretty mind-bending results
Why is it more expensive than Pycon?
Less sponsorship?
For a moment there, I was wondering what's so weird about architects learning another programming language. Then it dawned on me. Real architects.
Neat. There's also another module called [PyMC](http://code.google.com/p/pymc/) that, as I recall, might provide basic functionality like this, but it's also geared towards Bayesian modeling/analysis using Markov chain Monte Carlo algorithms.
Not sure. You might also find [PyMC](http://code.google.com/p/pymc/) interesting for working with data sets.
Now on github w/unit-tests https://github.com/devdave/txWeb
this doesn't teach me python 3
Because they're totally independent, unrelated events, and Github is free to run it however they like. In this case, I assume it means: for a profit.
bravo sir
Its a day shorter and has less talks. I can't justify spending more for less.
If I understand what's going on here correctly, we're saying that X and Y are distributed in a certain way (assume they're uncorrelated) and ask what the distribution of X+Y or X/Y is. That is not the same as simply adding or dividing the densities. In fact, the result of adding the densities would not be a density since it wouldn't integrate to one. I wish I knew more about the implementation details. There are ways of doing this involving Fourier transforms, but I'm not sure how numerically accurate they are.
thanks
Why is "Dive into Python" always advocated? The book is outdated: it advocates the and-or trick and has no idea of inline if's. Are you sure you want to advise this to anybody? Some much better references are given here: official tutorial, learn python the hard way and I would like to add: http://openbookproject.net/thinkcs/python/english2e/ 
I'm pretty new to python myself and didn't know where to begin, had some experience in c++ and c# through school and a friend recommended dive into python. I liked the writing style and helped me get started, but here probably are way better resources (many have already been pointed out and am still getting the hang of python). Looks like Learn python the hard way is what I'm going to work through next. 
When architects learn javascript !
Not everyones happy with it though it seems - Bbb certainly wasn't. Makes you proud to contribute to open source...
It may have changed since I was looking at it, but the thing I didn't appreciate about Funkload was that it was that running tests programmatically was a major PITA. The author doesn't seem to have considered that anybody might want to run it any other way than from the command line.
It's interesting that you mention this: I am working on a web app to drive Funkload, so you can run tests and create reports visually. It should be merged... one day.. :)
I've just published part 2 : http://tarekziade.wordpress.com/2011/07/28/how-to-stress-test-your-app-using-funkload-part-2/
Cool. I was working on a django app so we could store tests in the project and discover and automatically configure and run them. Hope you manage to push changes upstream that make that kind of thing easier.
The plan is to provide a single script that will run a web app with a plain Python, using wsgiref. -- so it can be run behind any kind of server. The web page will let you generate reports by selecting xml files, and also run benches. It's still in its early stage, but Ben said he would merge it as soon as it's ready. I did not work on a discovery stuff but you're welcome to join -- my fork is at https://github.com/tarekziade/FunkLoad
it's always seemed to me that for any task which *might* at some point become multi-computer, you're best off making it multiprocess rather than multithreaded *anyway*, because it'd reduce the amount of redesigning needed to make the jump to multi-computer.
Just because you have more content does not mean that the content is of a high quality.
nice writeup. it doesn't seem easy to write more complex session-driven "paths" for testing though - i guess you could do it by parsing res, and then doing various self.get's in a row, or by having multiple tests (but then you lose the sense of a path a user would take through the application). the ability to easily script such a use-case via configuration files is why i've tended towards using Apache Flood for my load testing, but then I'm on my own to track what's going on with server load, etc and to make anything useful out of the data Flood and my own metrics spit out. On a related note, [this article on agile testing](http://agiletesting.blogspot.com/2005/02/performance-vs-load-vs-stress-testing.html) has been a huge help for me in getting my bearings with load/stress/performance testing.
&gt; it doesn't seem easy to write more complex session-driven "paths" for testing though I did not get into great details here, but you can do as much get/delete/put/post you want in your tests, and check the responses to decide what's next. See some complex examples here: http://hg.mozilla.org/services/server-key-exchange/file/aa24c20caa18/keyexchange/tests/stress.py#l193 Funkload comes with helpers like basic authentication etc. Since you are in a unit test class, you can do whatever you want, and I've never been limited like I could have been with tools like JMeter. The Grinder allows the same, in Jython. Never heard of Flood, will check it out. 
cool, that does seem to be more like flood than, e.g., apache bench (that just does a single request a bunch of times - helpful for testing the actual server's performance, but not particularly useful for testing &amp; diagnosing the web-app itself)
I want to say I have extended the funkload classes to work programmatically, but it wasn't an easy task, it didn't look pretty, and i absolutely positively was not proud of the finished product (something my boss made me do to scrape data off of a competitor's site).
Hmm.. probably a browser-specific issue. I haven't really done much testing in that department. Thanks.
Glad to hear I'm not the only one that's been there and not enjoyed it.
Damn, here I was hoping he had a real fix, or perhaps a direction to suggest for finding one, and then he said, "let's just use JavaScript instead". [look of disapproval] (Oh, also, if write() doesn't work with your middleware, your middleware is broken. It's just that 99+% of middleware is written by people who don't understand how middleware is supposed to work, which is why [I proposed changing this four years ago](http://dirtsimple.org/2007/02/wsgi-middleware-considered-harmful.html). &lt;/rant&gt;) 
Anyone downvoting, criticism is welcome
Isn't every piece of middleware broken? It's not exactly the easiest thing to write. The linter helps, but I suspect I should try to come up with some commentated examples of "middleware written right" as I think folks would be more judicious with their creation of middleware if they knew just how hard it was to do right.
Read [this.](http://docs.python.org/tutorial/controlflow.html#defining-functions) It sums it up nicely.
If you do it wrong, is the middleware still useful? If so, what does that tell us? 
Read up on input() and eval(). Both are evil and bad practice for "real code," but I'm going to treat you like an adult and let you decide for yourself whether you care. The concept is quite intuitive to new programmers, and it will get the job done until you're comfortable enough with the language to write "real" input parsing and validation code.
I've written my fair share of WSGI apps. I even wrote a framework, but it didn't live long in the wild. The problem isn't the spec, IMO. The problem is programmers making huge assumptions about where their code lives in an app; instead of playing nice with the environ, wrapping start_response with a closure, etc., lots of folks just assume that their app or their middleware is the place to respond to the client, set the headers, and write the body. WebOb is particularly guilty of this. Pluggable middleware is possible if you write for it. It's not if you assume that the stack is your playground and no one else is playing with you. That said, an improved spec could provide for better conventions and maybe even an alternate communication channel between WSGI handlers. Decorating the environ with your arbitrary keys isn't enough. 
It would be nice if this assertion went with something to back it up: &gt; But what I do not believe in is that magical plug that is called &gt; “framework independent pluggable application”. I don't know where &gt; this idea came from that it might work, but it does not. The idea &gt; that you can reused code on top of WSGI to work with Framework &gt; 1 and Framework 2 is not working out. Perhaps I misunderstand, but.. Fanstatic is a WSGI framework component (it's not a pure middleware). It works with Grok and with Pyramid. It also works with Django as WSGI, but not so well, but that's Django's fault - WSGI is harder to configure for Django than its native pipeline system. Presumably it'll also work with other stuff. 
The quick method is using eval, unless you're experienced making your own parse trees for mathematical functions. Input the function of t, y to a string. Create an anonymous function with eval. Test to make sure the function doesn't raise a NameError exception at t=y=0. You can call this from within your Euler program in a loop until the return value is not None. def getf(): """ Return a function of t and y; else return None if the entered function is invalid. """ func_str = raw_input('Enter a function of t and y: ') try: f = eval('lambda t, y: ' + func_str) f(0, 0) return f except NameError: return None Change `raw_input` to `input` for Python 3. 
you mean inputting function NAME , yes ??? Please, for the sake of helping people help you - learn how to ask question effectively. Be precise.
I've ranted about this in the past, and for me basically it comes down to the fact that WSGI is, well, a gateway interface. It's not an API that different applications can use to talk to each other, and every attempt to use it for that has involved ad-hoc conventions for things to stick in the environ, or non-WSGI channels for passing information back and forth. Both of which have major drawbacks and introduce a certain amount of coupling. (also, not sure what you mean about Django -- we still support a legacy mod_python handler, but it's deprecated and due to be removed, which means the *only* officially supported/recommended way to run Django is as a WSGI application)
Edit: Adding lib should suffice if the imported packages are all there: import sys, os sys.path.append(os.path.join(sys.path[0], "lib")) You could also add an `__init__.py` to lib to make it a package, and in subdirectories as necessary, and then import with "`from lib import Crypto`". The latter assumes you've moved the Crypto package into lib.
It is yup.
I will give that a try, and hopefully it will work. As an aside question though, why would this work differently than the existing imports that append directly to the modules within the lib folder? I'm not asking to be a dick, but more because I don't have an expert understanding of Python and sys. Thanks for any reasoning that might help me think about this =)
&gt;If you want to replace WSGI, you would not replace it, you would put a new layer on top of it. One that has extensive knowledge about everything that happens. You would have a standardized request/response library that covers every single case that is currently needed and make it extensible enough to handle future cases as well. Agreed
&gt; Damn, here I was hoping he had a real fix, or perhaps a direction to suggest for finding one, and then he said, "let's just use JavaScript instead". [look of disapproval] Heh. One of many solutions is JavaScript. I was just pointing out that composition of applications does not necessarily have to happen on WSGI itself. I think right now with WebOb/Werkzeug we have the tools to to deal with the uglier parts of WSGI just fine and what does not work there, we have alternatives for. I just don't think replacing WSGI with something new will solve any of our problems :)
That perfection != usefulness?
I just compiled and installed pycrypto to my local site-packages (i.e. relative to `PYTHONUSERBASE`). It installed to the `Crypto` subdirectory. It needs the folder containing the Crypto package to be on the path, which I presume is pycrypto in your install. So I don't know. How are you running the main script?
How about we replace it with this: from peak.util.decorators import rewrap def provide_wsgi2_to(app): """Wrap a WSGI 2 app for use in a WSGI 1 server""" def wsgi1_app(environ, start_response): environ['wsgi.version'] = (2, 0) s, h, b = app(environ) start_response(s, h) return b return rewrap(app, wsgi1_app) ;-)
I would not mind this at all, but ... would people upgrade? I mean, for the average user WSGI is not really a concern. The nice thing about that however would be that you could probably support both by defaulting start_response to None and seeing if start_response was provided. At the moment I think `start_response` is not really a concern, but that's just my opinion. At least it is *one* standard and not more than one :)
for now the main script is just being run directly from the command-line: ./run which is the code from above. I am fairly sure that the issue is that since I altinstalled python it is confused as to where I want it to look for the packages. I just ran the code again, but printing the path, and it looks like this: ['/root/aws_scraper', '/usr/local/lib/python26.zip', '/usr/local/lib/python2.6', '/usr/local/lib/python2.6/plat-linux2', '/usr/local/lib/python2.6/lib-tk', '/usr/local/lib/python2.6/lib-old', '/usr/local/lib/python2.6/lib-dynload', '/usr/local/lib/python2.6/site-packages', '/root/aws_scraper/lib/mechanize', '/root/aws_scraper/lib/paramiko', '/root/aws_scraper/lib/pycrypto'] which is a lot of crap, but it does have /root/aws_scraper/lib/pycrypto in it, so I feel like it should be able to figure it out... Thanks for you help btw =)
The only reason to use it is if you want to write some code that's heavily middleware-ish, in the sense that you want to compose an app out of functions that call each other. In such a case, you win big, as long as you have a way to call back into WSGI 1 apps. (Which unfortunately takes another 80-90 lines of code, not to mention greenlets if you want to support write()). Still, I should probably just publish my sketches of this and see if anyone takes the bait. The recent attempt(s) at "WSGI replacements" suggest there's some interest out there in having simplified WSGI. Edit to add something I just noticed: &gt; The nice thing about that however would be that you could probably support both by defaulting start_response to None and seeing if start_response was provided. Brilliant! That actually means we can make a small (140 lines so far) module that lets you simply declare functions @wsgi1 or @wsgi2 -- and if you pass something that's already bilingual to either decorator, it does nothing. Then, code that wants to support calling either WSGI 1 or WSGI 2 code just wraps its targets with @wsgi1, and you decorate all your wsgi2 functions with @wsgi2. Voila... no need to "rewrite everything" - just write new code with @wsgi2 decorators, and call old code with @wsgi1.
I agree that more is needed than just WSGI itself. Fanstatic introduces a separate API - but that's the API you need to actually use it. And yes, it will stick something extra into the environ as well. That's why I call it a framework component, not a middleware. I don't see where the "major drawbacks" are coming from though. I think with Fanstatic we've kept the coupling at a minimum. Using it in your application is a buy-in you must be willing to make, but that's the same as for any library. Concerning Django: you can connect to a web server using WSGI. I understand that works fine. But to install and configure WSGI *middleware* (or framework components) such as Fanstatic is, as far as I understand, left up the developer, as opposed to the Django middleware system which can be configured the Django way. Anyway, Fanstatic can plug into that too. That's all I know about this - I'm not a Django developer so I may be wrong. 
That should work, though I'd prefer to have the packages all in the lib directory and only have to modify the path once. Have you recompiled pycrypto's shared libraries for the target platform/interpreter?
What I'm getting at is the question of what use cases does this "wrong" middleware not support that it would support if the wrongness was fixed? If there are use cases, and wrong middleware typically breaks the same use cases over and over, can't we have two classes of WSGI components, instead of "wrong" and "right" components? If there are no use cases, well, that's interesting, right? Or are these WSGI components typically broken in different ways? 
Obviously I am, because I don't get the point you're trying to make. 
That too, I guess. But I'm trying to figure out whether we can define a useful class of WSGI components that lacks some features and then instead of calling it "broken" we call it "WSGI components that don't support X". And then this can perhaps be formalized. But for that we need to figure out whether there's a coherent X. 
What is this about?
Well, Django's "middleware" and WSGI's "middleware" are two different things, serving different purposes, which happen to have the same confusing generic name. There is some overlap in terms of things they can do, of course, but Django's middleware is more about providing hooks into the request/response lifecycle, while WSGI's middleware is more of a "decorators for web applications" type wrapper.
Tried to get qwebirc to work on windows. Failed at installing the necessary environment. The timeline on that downloads shows me fail at frustration tolerance. Not even half an hour worth of trying:)
Do you mean for downloading the right package/interpreter pairings? Or do you have all of those installed? [This site](http://www.lfd.uci.edu/~gohlke/pythonlibs) has Windows packages nicely organized if you like to install exe's.
&gt; Still, I should probably just publish my sketches of this and see if anyone takes the bait. The recent attempt(s) at "WSGI replacements" suggest there's some interest out there in having simplified WSGI. Of course there is, please do it and push for it, python badly needs it IMHO. At the moment the barrier to write any simple and well behaving middleware is too high for us, only an handful of people really know how to write a middleware "the right way" and this is not acceptable. Look at how many middlewares are provided out-of-the box by [rack](https://github.com/rack/rack) and [rack-contrib](https://github.com/rack/rack-contrib), why we still (after so many years) don't have something like this in python? rack was inspired by wsgi but they made it simple enough so that anyone can pick it up and easily contribute useful and well behaving components. For instance, compare the complexity and side effects you need to take into account to write a gzip middleware in wsgi [1] (the right version is the last one) vs rack [2] &gt;As you can see, this version will work correctly, but it wasn’t exactly a piece of cake to write. Although changing the response is one of the more difficult things you can do with middleware, it really makes you appreciate all the things Pylons does for you! is that acceptable? and no, I don't want to depend on any of the abstraction provided by Werkzeug or WebOb to write a simple gzip middleware, thanks. [1] http://pylonsbook.com/en/1.1/the-web-server-gateway-interface-wsgi.html#altering-the-response [2] https://github.com/rack/rack/blob/master/lib/rack/deflater.rb
If they dare! Actually, an xpost of this video is one of the most upboated things on r/matlab at the moment: http://www.reddit.com/r/matlab/
&gt; please do it and push for it, python badly needs it IMHO Ok, here you go (untested sketch): http://pastebin.com/QRLKYXwi It needs the [DecoratorTools](http://pypi.python.org/pypi/DecoratorTools) library, and can optionally use [greenlets](http://pypi.python.org/pypi/greenlet) to support WSGI 1 apps that call write(). All you do with it is wrap apps that (might) need WSGI 1 with wsgi1(), and apps that are written in WSGI 2 with wsgi2(). As a practical matter, this means that you decorate all your new code with @wsgi2, and old code with @wsgi1. And, if you want to write a sane piece of WSGI 1 middleware, what you do is decorate the middleware as @wsgi2, but have it wrap its app with @wsgi1. (At least, that's what it will do if it *works* -- I haven't written any tests or documentation as yet!)
Middleware is a good thing, I'm not suggesting it shouldn't be used. Rather, it's really easy to write middleware that is incomplete and broken in some circumstances. Even middleware that has been around forever and has seen wide use often requires continual patching for some surprising "edge cases" over time (not really edge cases, but not used frequently) conditions: https://github.com/repoze/repoze.who/commit/b01f4465c387fd76247ecfe97eb0601c0c9c22ac ; https://github.com/repoze/repoze.zodbconn/commit/d49213a5841de339f285af8e83baa55858df270e I think some examples of "correctly written" middleware (without a ton of domain logic clogging them up) would go a long way to let people create middleware that performs properly and surprises fewer people. 
Ideally, all middleware (at least things that are not "endware", which is a different class of middleware entirely) would support all pipelines, no matter which server they're being called by or application(s) they're serving. This is not some sort of unattainable goal, it's just not particularly easy to know that you have it right and as a result there's a ton of really bad middleware out there (some of which I have written).
You could potentially bind functions to key values pairs in a dictionary. So you *could* have: def printx(): print "x" def printy(): print "y" functions = {"x": printx, "y": printy} Furthermore you can call the function like this: input = raw_input("Enter function: ") functions[input]() This is not the best way to do it at *all*, but it's actually useful in some situations.
Get Python 2.7.x 32 bit aka the latest version of 2.x, then get Twisted 11.0.0 for 2.7 and pywin32 for Python 2.7... Or well, download the Ubuntu ISO from their home page :)
Avira is getting active on that site. Malware? Uh oh. Don't want something bad along with 10 different python installs...
Funny: the second of your examples is *still broken* - it doesn't call close() on the response. ;-) 
Run ipython in pylab mode: ipython --pylab Interactive plotting can then be turned off and on with ioff() and ion() 
Ugh.
Thanks. PyWin for 2.7 was the problem. I gues now I'd have to deinstall all of them and then reinstall correctly for it to work. But It's definitely too much hassle for me just to get an IRC client running.
The page is by Christoph Gohlke at the Laboratory for Fluorescence Dynamics, University of California, Irvine. I've seen Christoph post on several issues at python.org. He's not exactly a masked hacker out to root kit your computer. It's probably just the onclick JavaScript code: &lt;a href='javascript:;' onclick='javascript:dl([110,112,121,49,116,100,50,47,56,102,84,119, 54,46,104,120,97,53,109,105,101,115,118,45,48,52], "98FBD&amp;gt;927:;CE4D5G33=H=H=;C0G@B5&amp;lt;IG126=A=D?D")'&gt; Quote: &gt;If downloads fail: reload this page, enable JavaScript, disable download managers, disable proxies, use Firefox. Please only download files as needed. 
That's the worst problem. I started tearing down stuff after returning the response instead of attaching close callbacks because every second middleware screws up the close thing :)
On the bright side, I've just modified my WSGI 2 sketch to support a 'wsgi2.add_cleanup' environ key that allows WSGI 2 apps to forget about close() entirely, even in middleware. WSGI 2 servers just call their accumulated registered cleanup functions post-request. My @wsgi2 decorator transparently implements this via a close() method when running under WSGI 1, and the @wsgi1 decorator registers any close() method with the cleanup registry provided by the calling WSGI 2 middleware. Sanity at last!
I didn't know it existed. Wow how nice people are there! (at least the answers I've read)
Bah, disregard this comment, I just saw you're not able to use `exec_command`. 
[Irssi Windows Binary](http://irssi.org/files/irssi-win32-0.8.12.exe) The only client of the future.
And Django makes it non-standard to use WSGI middleware, so to integrate Fanstatic the Django integrators decided to use Django middleware. Even though we already had a WSGI middleware component. 
I have been invastigate websocket on wsgi model for some time. But I have didn't got the way to integrate event-driven model with wsgi. Do you have any ideas for that ?
I felt pycon had very good talks. Only part that disappointed me was the dropbox keynote
If you're accessing the program from the python interpreter, you can just define a python function and then pass it as a parameter. Your code in mymodule.py: def do_something(function): t = 1 y = 2 print(function(t,y)) Then in the interpreter: def myfun(t,y): return t * y from mymodule import do_something do_something(myfun) Doing things this way is probably more like how a real program would work, except myfun would be in another script that imports your module.
*And Django makes it non-standard to use WSGI middleware* As they say on Wikipedia: "citation needed" :) Django runs as a WSGI app. If you've got WSGI middleware you want to use, well... use it. The fact that there's another thing called "middleware" (oh how I would love a better term) which does something different for a different purpose in no way means using WSGI is "non-standard".
&gt; I felt pycon had very good talks Oh, certainly. But does it mean that every single talk was good? I am not yet talking about the quality of talks at a conference that has not yet happened, but the ticket price should not just be decided based on the number of talks. From my personal perspective as a speaker at PyCodeConf I can only say that due to various factors I feel obliged of having a high quality talk there which was not necessarily the case for PyCon. While of course I tried to do my very best at PyCon there are differences. At PyCon you are paying for the ticket as speaker which is not the case at PyCodeConf so the pressure is increased :)
why don't you use [pexpect](http://pexpect.sourceforge.net/pxssh.html) . Also, I am guessing that channel.recv() blocks unless you are using non-blocking IO 
Try this: names = [] file_contents = open('your_file.txt').readlines() for line in file_contents: names.append(line.split()[1]) Which gives me... ['named', 'brad', 'allan', 'polycom', 'gary', 'mailnull', 'sandy', 'rob', 'william', 'louise', 'diana', 'walter']
[split](http://docs.python.org/library/stdtypes.html#str.split) is your friend. Try somethig like this: for line in open("file.txt").readlines: other_file.write(line.split(" "))
Do you really need to use python? That seems like something that could be done easiest with awk. If it's gotta be done in python... well, what have you tried so far?
 awk '{print $2}' &lt; myfile
If you want to print it: python -c 'for word in [line.split()[1] for line in file("myfile")]: print word' but the awk answer is better If you want a list: python -c 'print [line.split()[1] for line in file("myfile")]' 
Don't do that. That way leads to madness. Use virtualenv. Use pip. things will work fine, without resorting to ugly hacks.
That actually worked perfectly thank you so much!. I'm a huge bash noob though, how to I output the results into a new .txt file?
you can also use Fabric, and make a new sudo command. It'll keep your channel persistent, and you can just call su a lot def ssudo(cmd): run("su - user -c '%s'" % cmd)
You don't even need to specify the separator if it's white space.
 awk '{print $2}' &lt; myfile &gt; output.txt
will this put each name on a new line in the output file?
Yes. It copies the output that is otherwise put on the screen into a file. Windows CMD works the same way.
You actually don't even have to use readlines: for line in open('your_file.txt'): names.append(line.split()[1]) If you want something really concise, it can be done in a single line: open("output_file.txt").write('\n'.join(map(lambda x: x.split()[-1], open('your_file.txt')))) But please don't do that for the sake of all that is good and readable.
Ah, good to know. I think I'm just used to specifying a separator that repeats, and then winding up with a bunch of empty strings in my list. e.g. "abbbbbbbbc".split('b') gets you ['a', '', '', '', '', '', '', '', 'c'] 
Yeah, if you leave split empty, it automatically truncates whitespaces for split. It's inconsistent and (I think) undocumented, but it's a nifty feature nonetheless.
then you shouldn't have given that one-liner
If on linux, use cut: cut -f2 inputFileName &gt; outputFileName
Sadly, I have to use a Windows machine at work, and pexpect isn't supported (although I suppose I could go the cygwin route mentioned) http://www.noah.org/wiki/pexpect#Requirements_for_use_of_Pexpect . So, you're saying channel.recv(), if called after a send, should stop the next send from executing until it dumps its entire buffer?
mann dont be a jive turkey....I got what I needed to know 
thank you this is what I needed, and it works 
ok I will, thank you 
thank you this is what I needed, and it works 
thank you for your response
While this syntax works, I find it the parameter order confusing. Two alternatives with a more logical "pipeline" flow: awk '{ print $2 }' input.txt &gt; output.txt or cat input.txt | awk '{ print $2 }' &gt; output.txt but yeah, parent's suggestion works great.
This might be a noob misconception, but when I see '/lib/pycrypto', I believe that that path is &lt;root&gt;/lib/filename. I.e., it's looking for pycrypto in the lib subdirectory of the root directory. Please tell me if I'm wrong.
This is neat, i might have to use this code :p
[cat abuser](http://en.wikipedia.org/wiki/Cat_(Unix\)#Useless_use_of_cat)
Well no, Django does make it harder than it should be to use standard WSGI middleware, for example it's not easy to use with ,`manage.py runserver`. Luckily there's a really easy solution, have `startproject` generate a WSGI file and `runserver` use that. Armin has even implemented this.
I thought about doing something like this with Paramiko, and just issuing a list of separate "su - -c command" commands with *exec_command*, and authenticate separately on each one, but I had issues getting that to work. The bonus of using exec_command is that you can poll recv_exit_status() to see if your command is done executing ( http://www.lag.net/paramiko/docs/paramiko.Channel-class.html#recv_exit_status ). Fabric looks interesting though, thanks for mentioning it.
If you're going to bundle your 3rd party libs in a "lib" directory, there's a more pragmatic pattern: import os import site site.addsitedir(os.path.join(os.path.dirname(__file__), "lib")) 
Well, yeah, the dev server is weird. But to be honest I don't really use it all that often ;)
Fabric is fantastic. I use it extensively for similar things on a group of identical servers.
http://pyspread.sourceforge.net/
I'd use awk, and agree with some of the other comments, but I just want to make a comment about your loop here. This lend itself really well to list comprehension which are faster than a loop: file_contents = open('your_file.txt').readlines() result = [ x.split()[1] for x in file_contents ] 
The HUGE advantage of your first solution is that it won't run out of memory on a big file (which all the other solutions which slurp the file in (readlines()) will).
gnumeric: http://projects.gnome.org/gnumeric/doc/sect-extending-python-console.shtml
What do you mean about WebOb? It's more careful with WSGI than any other library I know of.
So what do I, who is just thinking about starting python web programming, have to keep in mind?
And this is what scares new users away from web programming with Python and back to other languages whose file type extensions end with p.
I think this is what I'm looking for. I hope gnumeric doesn't require too many gnome dependencies 
In this case it is joining /lib/... to the end of the path to the current directory. So if it was /lib on its own it would be looking at the root, but not in this case.
Apologies, Ian. I was wrong to write that about WebOb. I must have been thinking of another framework. 
If you're writing apps, nothing other than picking quality libraries and frameworks. If you're writing web servers or frameworks, consider contributing to an existing project first. 
From my personal bias, on the plus side: * WSGI has made easy to switch servers which have proven handy in many instances. * WSGI has forced a certain level of communication between web developers in the Python world On the the negative sides: * Middlewares have failed in my book. Most frameworks have their own design where middlewares don't play nicely. They should be dropped entirely from WSGI. * The start_response bit is not intuitive at all and slows the comprehension of WSGI down. * The difficulty to play nicely with async servers, which seem to be quite relevant these days.
I **always** read that package name incorrectly.
Yes, but doing it as a `for` loop is conceptually a bit simpler for a beginner :)
Most of our community does though ;)
Fabric wraps paramiko, if you want something lighter look at the source code
Thanks! It looks promising along with the fact that YOU seems interested in pushing WSGI 2 forward. ;) PS just wondering, apart from 2.3 compatiblity, is it really necessary to depend on DecoratorTools rewrap instead of functools update_wrapper/wraps?
 with open('your_file.txt') as f: print("\n".join(( x.split()[1] for x in f ))) The other examples in comments so far leave dangling filehandles, which is just poor practice. Edit: my original version just printed the list - the original request was for the items in the list one per line. Fixed (&amp; using a generator expression instead of a list comprehension so we don't chew so much ram on big files)
This simply repeats the input file, because the default delimiter for cut is tab and there's 8 spaces between the number and name in the input; cut by default prints the lines not containing the delimiter. Also, you're assuming the person is on a Unix system. Not necessarily true in /r/python 
Best to teach beginners the right way from the start, regardless of their previous experience (somebody who has never programmed in anything before may have no idea what a for loop is) 
I don't remember it being *too* harsh, just gtk n' such.
Yeah, it just required gtk and gconf (which I had installed anyway). I've had some problems with Gnome programs pulling in hundreds of MBs of dependencies, fortunately this wasn't one of them.
I might not be understanding what you want exactly, but Django (the web framework) would give you perhaps more customisability than you need. ;)
I am loving django-cms
I like Plone.
http://www.resolversystems.com/products/resolver-one/ Specifically designed to allow python scripting, mostly because it was built in python!
This is what you want - it's a really neat system. They have a web version too, called Dirigible. http://www.projectdirigible.com/
Your post title is terrible. I don't know how you expect to get help when you don't put the problem in the title.
I was just there in the room when the Django integrators for Fanstatic had to give up on WSGI middleware (they tried) and switched to Django middleware and explained their reasons. I'm not a Django user myself, but this is what I heard - do you want to hear from those people yourself? And is there a chance that this will get fixed in Django if you do..? I want to know whether it's worth the trouble. 
Thirded. Absolutely great piece of software. I highly recommend it.
Er, [OpenOffice Calc](http://wiki.services.openoffice.org/wiki/Python)?
Quite difficult to script, I hope the other ones offer a better API, better docs, etc.
Actually Plone has become less of a beast in recent years. I am a Python enthusiast working hard to make sure Python people don't skip Plone. Please at least give it a try: http://dist.aclark.net/build/plone/4.1.x/README.rst . Also, don't get me wrong. I use and love Django, too. But strictly in terms of CMS, it has nothing to offer that comes anywhere close to Plone (that I've seen).
Since you started the thread asking someone to back up their assertions: please spill the beans.
If you are looking for a CMS, use Plone. A library (ie.,Django, Django-CMS etc.,) are NOT finished products. Plone is a complete, feature-full, well-tested, end-user ready CMS. The code you write to extend Plone, If at all you need to, is idiomatic python. FWIW, I'm using Django since 2006 and Plone since 2004.
No, in fact the newer version [here](https://bitbucket.org/pje/wsgi_lite/) uses functools as primary. I'm also now calling it WSGI Lite rather than WSGI 2, since it really isn't a change in protocol, just in calling convention. (WSGI Lite apps are also now valid WSGI 1 apps.)
You have got to be kidding.
Nice, in fact I was wondering what were the differences between WSGI 1 and WSGI 2. This looks really great, I love the latinator example, that's exactly what I meant with my previous rant, writing correct WSGI must be easy for anyone, that's the only way we can build and trust a WSGI ecosystem. Thaks PJE, keep it up! /me hopes this works out well, ie: pep -&gt; stdlib (hopefully bringing along another great thing like greenlets)
&gt; It's more careful with WSGI than any other library I know of. :(
I was unaware that using map would force a generator into a static iterable. I'll have to test that later.
How about "whatever actually works for you"?
Try GNUMERIC for sure. Excellent little spreadsheet software. 
This will also process .pth files if you need to add additional paths.
Thanks for asking the question as I have references now that I've not seen before. I actually was thinking of trying to spin my own spreadsheet (probably more than I can chew on). The idea was to have each cell formula be python code though, instead of a separate scripting language. 
What's wrong with the CSV module?
Replying to bookmark - I missed out on buying this when they had a $5 or so sale around a year ago. Must remember this piece of software exists. Also note: iirc, built on IronPython, and thus offering a convenient hook into everything .NET.
It's not a spreadsheet application that allows Python scripting?
Google spreadsheets allows api access to the spreadsheet and to write and retrieve data.
http://www.vistrails.org/ Might be overkill for the typical spreadsheet uses, but for large data it's awesome. 0. written in Python 1. "spreadsheet" to compare various processing pipelines. 2. huge number of visualization options (VTK included) 3. built-in Latex support
If you're on a windows box and you have office, you can write a purely python program to plug data in and out of the spreadsheet using a few different packages, though that escapes me at the moment (Google would know). Not exactly what you're looking for, but assuming you're on Windows, you should be able to achieve the same result.
Xlrd and xlwt are pavkages that allow you to read and write to Excel files. it works very well. Also, look into Pandas. 
You're thinking of COM. I use it a fair bit, but you need the win32all modules. From there, you need the Dispatch method from win32com.client.
Agreed. List (and now dictionary) comprehension, generators, etc.. are what makes python python, they should be learned early on.
Drupal is a better option than Plone.
gnumeric isn't a gnome application, it's a GNU tool, it existed long before gnome, IIRC.
Google refine can use some python syntax http://code.google.com/p/google-refine/
It's now been renamed to [WSGI Lite](https://bitbucket.org/pje/wsgi_lite/), by the way, since it's not really a version upgrade to WSGI, just a way of replacing WSGI from the inside out with the "pluggable pipe dream" of the original article here.
I second dirigible, but I want to propose my favorite spreadsheet replacement tool: http://www.knime.org It is a data pipelining tool and it has JPython scripting nodes (which you need to download from the "additional sw" site)
I have quite a bit of experience with Drupal and Django. 'Out of the box' Drupal is a much better CMS. However, I prefer Python and Django, but it takes much more work to get Django into a CMS where Drupal is a CMS. Put simply, Drupal is a CMS, Django is an application framework. If you want to do a lot of development and customization of your site, I'd probably recommend Django. If you want a CMS as fast and easy as possible, go Drupal. 
Yeah I agree, awk would be better if you're on winblows. Just thought I would put a canonical way of doing it so he/she would see all available options. 
In addition to the other posts here, you can take input as command line arguments. import sys # sys.argv is a list of arguments. [0] would be the name of the script, [1] is the first argument. input = int(sys.argv[1]) print input 
Seconding that... open office's scripting interface reminds me of MS Office's COM interface. The best analogy a coworker and I came up with regarding the experience of working with *that*... working with COM is like trying to juggle chainsaws through a hole in a wall.
Here's another vote for Django CMS, w do a lot of sites with it at my day job and love it.
How do you expect OP to know the answer to that question before even using any of them?
Do you have anything to do with the design of the site? If so, could you fix the element "current" on the left so that it is left aligned with the blue border. Its bugging the fuck out of me. It shouldn't appear to be indented like that.
Nice. Though I'd include Pylint and pydoc.
*Rogue*. FFS, *ROGUE*.
Agreed. I mean, it's not hard. Rogue -&gt; backstabby little bugger, steals things. Rouge -&gt; lip gloss. So, OP, you ended up asking "Have you made a lipgloss game?"
It's part of the Gnome project, and the initial release was 2001 [wiki](http://en.wikipedia.org/wiki/Gnumeric). This also just reminded me that I've been using Linux &amp; BSD for longer than Gnome has existed. 
Not only that, but "rogue" appears on the article title and *twice* in the URL. UGH!
You should read this: http://sontek.net/turning-vim-into-a-modern-python-ide it teaches you some cleaner ways to do those things.
I'll go kill myself now.
i became much happier when i just put that option in apt.conf
Creation and modification of CSV files is easily scriptable since they're plain text. By using CSVs, any spreadsheet application becomes scriptable. 
I'd have included [Pathogen](http://www.vim.org/scripts/script.php?script_id=2332) and how to load plugins with the help of [Git's submodules](http://vimcasts.org/episodes/synchronizing-plugins-with-git-submodules-and-pathogen/). It's much easier to load plugins this way since you don't need to need to put bespoke sections in your .vimrc for each plugin.
TIL :-)
this is a strange twist on the weekly "HI, WHICH WEB FRAMEWORK SHOULD I USE??" :)
Usually, I would just use the csv module. However, sometimes data is messy enough that it requires some manual tweaking to get it in shape for whatever my python scripts are going to do with it. While one could conceivably do that with csv files in vim, I've found it to be easier in a spreadsheet GUI.
Yeah, on Debian systems I put that in my apt.conf. `pacman` handles dependencies that way out of the box :)
Adding this to ~/.vimrc helped me plenty when working with vim + python autocmd BufRead *.py set makeprg=python\ -c\ \"import\ py_compile,sys;\ sys.stderr=sys.stdout;\ py_compile.compile(r'%')\" autocmd BufRead *.py set efm=%C\ %.%#,%A\ \ File\ \"%f\"\\,\ line\ %l%.%#,%Z%[%^\ ]%\\@=%m autocmd BufRead *.py nmap &lt;F5&gt; :!python %&lt;CR&gt;
ipython and gvim integration should be included. I love being able to write code in gvim and hitting F5 to run it in ipython. But then, there's already a guide on the ipython page.
in my .vimrc autocmd FileType python map &lt;f2&gt; :w\|!python -i %&lt;cr&gt; 
PySchool's [Python Tutorial](http://www.pyschools.com/) is a pretty neat place, though it's more for practicing what you've learned. It has ~200 exercises (okay, some are multiple choice questions), most of which are pretty simple for the purpose of demonstrating the use of some language feature or function.
If it keeps me in the terminal rather than using gvim, I'm a happier man. I wonder if I can direct it to a tmux window? Worth playing with. Thanks, I'll try it out. 
While I don't entirely agree with him, I do hate it when people have whiny / begging titles that bear no relevance to the problem their experiencing.
Point the guy at Pypy. Show him the JIT compiler and Pypy's speed. Profit.
I often hear people make the argument that while Java is a "real" language, Python and Lua cannot be considered programming languages as they are interpreted and are hence "scripting" languages. What's worse is that this isn't all that uncommon. It's not really the idea that "scripting" languages are not considered as programming languages that gets to me. I guess because CPython easily fits the REPL philosophy, it's more commonly associated with interpreted languages, but traditional implementations of Java are interpreted as well, and look at CH Studio, it's an implementation of the C language that is interpreted during runtime. But whatever I say, they still wouldn't listen to me, and keeps on telling me that only Java/C#/C variants are real programming languages. I eventually wrote a very naive implementation of the JVM in python capable of running a small hello world program to prove my point. But to be honest, I probably would've just completely given up if they made the comparison with Javascript instead of Python. I guess I'm just biased towards Python.
I [did one](https://sites.google.com/site/roguebandhero/) in 2010 for the 7DRL. It was awesome. Well, the experience was awesome, the game was only [11.66 / 16.0](http://www.roguetemple.com/7drl/2010/) awesome. Now I'm about a year out of date, but my impressions of libtcod were really quite good. The only issue I ran into was that some things (like the Console) would really like to be a [class](http://doryen.eptalys.net/forum/index.php?topic=448.0). Also, I learned a tonne by reading other people's code. *Note: The source code looks like poo, but that's what you get when you decide to do a major rewrite midweek through the contest with little to no sleep. Sorry.* 
How does that help this person find a spreadsheet application that allows Python scripting?
Python is usually compiled to byte code just like Java is. And if you use Pypy you even get a JIT compiler just like Java....
You mention some indentation options and suitable indentation values for python code. While you don't explicitly state where they belong to, one may think they can be added to .vimrc. This works, but has a global effect. Personally I prefer having language specific indentation options in ~/.vim/after/ftplugin/languagename.vim
What, does he program using [butterflies](http://xkcd.com/378/) or something?
If I can compile my code to an executable, I can just give that executable to someone and they can run it. If I write a program in Python, they have to install a Python interpreter (which will install somewhere stupid and come with IDLE and bunch of other crap they don't want). Java gets a pass because almost everyone has a JRE installed already (although by the same token if someone gave you a bunch of .class files you wouldn't call that a "real program"). I don't think of Python as "not a real programming language", but I do think it's an important distinction. 
Is there no method to create an executable from python source - even using an intermediate tool? I don't know much about python but everyone raves about it, so I'm curious!
* [cx_freeze](http://cx-freeze.sourceforge.net) * [PyInstaller](http://www.pyinstaller.org) * [py2exe](http://www.py2exe.org)
Find something you have a use for but doesn't exist or doesn't exist in a way that you would like it to, and start coding. When I first started learning Python, I wrote a search engine for my rather extensive chat logs.
That's actually a great idea... Thanks!
Grab a framework (Django, Pygame etc etc) and build something with it. I chose PyGame and made some little projects ([reversi](https://github.com/Teifion/Reversi), [tower defence](https://github.com/Teifion/RuneTD) and [RTS](https://github.com/Teifion/sequtus) though the latter is very much work in progress). Once you made something, look over it and think about how you could have made it better, look at the standard library and see what you could have used from there to perform something you already did.
You can certainly compile Python into an executable.
Well that's a relief, I thought I was the only one with problems running stuff in the windows console. I miss my linux install. Running things from the terminal beats the window console every time of the week. Thanks for the link to IEP, I currently use IDLE for testing stuff, but I appreciate the other options. -Another Python Beginner (well probably a little bit more advanced).
Im watching you
&gt; If I write a program in Python, they have to install a Python interpreter (which will install somewhere stupid and come with IDLE and bunch of other crap they don't want). Java gets a pass because almost everyone has a JRE installed already. python is standard on OS X and almost any linux distribution. Java on windows installs a shitty update service and often bundles crappy browser toolbars or tries to install openoffice. Last I read, Apple is dropping java from the standard OS X install.
At work I compile and distribute my Python code as .exe files using Py2exe. Works beautifully. Even fellow programmers casually reading the source can't tell it's not native code. There's a slight learning curve, but it's well worth it.
You can certainly do what C# and most .Net compiled PE files do, they embed the IL bytecode within the PE and have the header point to an invocation of the interpreter.
No you certainly can not, you can package it up with the interpreter into a sort of binary, but its not as neat as a nicely compiled C program.
and on OSX, [Py2app](http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html).
I built an exe using Python that modifies xml files, and handed that exe off to my tech writers. They use that exe to batch process directory trees of xml files; it's not a package of files, it's not a folder with an exe inside, it's one singular, tidy exe. How is that not considered an exe? It may unpack into a temp directory, but really, who cares? My tech writers never see that operation, they only see one exe that processes their files. 
I do a lot of web stuff and code primarily in Python. Having said that, the argument is something along the lines of: "Back in my day, I used to walk 3 miles in the snow to go to school..." Obviously there's some stuff traditional programming languages do better, particularly performance intensive stuff, but I think the general arguments are more emotional than rational.
Chill out script kiddie.
And cx_freeze, and bb_freeze
[pylauncher](https://bitbucket.org/vinay.sajip/pylauncher) helps by implementing shebangs.
Cooooool your jets. Python is, of course a real language. The issue might be with the fact that you can't compile it, and thus it makes things difficult for distributors of nonfree applications. For the record, I *don't* think that Google/Facebook/YouTube are worthy of praise, since they trample on the freedoms of their users. However, other applications are definitely worthy of praise, and based on Python. Besides, you're posting this to /r/python. Do you really expect to find dissenting opinion here? Try posting to /r/c_programming.
&gt; have to install a Python interpreter.... None of that is true. I can download and run Python scripts on any of my computers without anything but normal dependency fulfillment. Maybe you're using the wrong OS. In fact, I'd bet you *are* using the wrong OS.
Did it require a special package to build a .exe?
you might be interested in [this thread](http://www.reddit.com/r/Python/comments/gm7wt/anyone_ever_run_into_java_coder_who_thinks_python/) I submitted
&gt; There's a slight learning curve... learning curve on what ?
&gt; wrote a search engine for my rather extensive chat logs doesn't your chat client have this feature ?
On the less-than-awesome though standard-for-open-source documentation. Like anything, you'll have to invest a few hours to learn its ins and outs and customize it to your needs. 
YAAAAAAAWN. Honestly, who cares? Try writing a hardcore game engine in Python and see how the performance turns out. Likewise, try making Facebook in assembler and see how long that would take. Different "languages" have different purposes full stop. These flame wars are immensely stupid. Pick up K&amp;R and read about pointers instead. Or try out PyPy and giggle at the speed increase over Python. Or read a random page of Knuth. All of them will make you a better "programmer" for sure.
Thanks. And, sys.path[0] is the directory from which the script was invoked, or the empty string if the script was invoked from the interpreter.
Yes, I think I used py2exe, but it was more than a year ago.
Totally agree. That's why I became a little infuriated with what this guy was saying, b/c he obviously didn't understand the bigger picture.
lol good point. And I think those sites are worthy of praise in what they have accomplished, demonstrated by the shear number of users they provide a service to on a daily basis. As far as their business practices go, as you proved, it's up for debate.
have an upvote for another amazing xkcd reference.
Write code. Keep on hacking until you feel like a ninja, then learn how to do something alien and new. Keep playing with that until you feel like a ninja. Rinse. Repeat. What you will find is that you start developing a "toolbox" of knowledge. You may not know what to start writing now. That's okay. It happens to all of us. You just need to expand your toolbox to find inspiration. Once you have all of the tools, THEN you will find things to make. Don't be afraid of re-inventing the wheel. On the contrary, re-create everything you like and think you might understand. Even if it's practically worthless, you've learned from the experience, and that's priceless. Never stop learning. There are no truly great programmers. There are only people who are good at keeping this cycle up. Everyone who fails to do this "burns out". Only by liberal application of learning does one become a "great programmer". This is all assuming you're a novice programmer. If that assumption is incorrect, then congrats on your n-teenth language. Make a grammar parser or something.
You ever tried searching 6 years worth of logs with Pidgin on a Truecrypt volume on a 5400RPM hard drive? It's far from performant.
parfor is essentially mapping an index to multiple calls to a function, no? That's equivalent to a pool.map. For working with NumPy arrays and shared memory, check out [numpy.ctypeslib](http://docs.scipy.org/doc/numpy/reference/routines.ctypeslib.html) and [multiprocessing.sharedctypes](http://docs.python.org/library/multiprocessing.html#module-multiprocessing.sharedctypes). Example: from multiprocessing import Pool, sharedctypes import numpy as np import warnings def func(n): #ignore the PEP 3118 buffer warning with warnings.catch_warnings(): warnings.simplefilter('ignore', RuntimeWarning) v = np.ctypeslib.as_array(shared) print(n, v) return v.ctypes.data #return the address shared = None def _init(a): global shared shared = a if __name__ == '__main__': tmp = np.ctypeslib.as_ctypes(np.zeros((5,))) a = sharedctypes.Array(tmp._type_, tmp, lock=False) pool = Pool(processes=3, initializer=_init, initargs=(a,)) a[0] = 1.0 result = pool.map(func, range(3)) print(result) ctypeslib.as_array may raise a runtime warning because of a [ctypes bug](http://bugs.python.org/issue10744) that keeps the conversion from using the new PEP 3118 buffer interface. It's safe to ignore this warning. The shared array is created without a lock under the presumption that you're only processing the data and not modifying it. The initializer is used for Windows support in order to give the workers a reference to the shared array, since Windows doesn't fork new processes. After the pool is created it sets a[0] = 1 to show that the data can be modified in between the creation of the process pool and the call to pool.map. The map calls the function for each index value in the range. The function prints the index and the shared data, and also returns the address of the array to show that each worker process isn't getting a per-process pickled copy. Each worker could also use a private shared array to keep from having to pickle a returned array result. 
Thank you very much! I'll read the documentation on these and try it out, to see if I can improve my code. I'll have to work out which variables are visible within the function and whether it works with scipy.weave.
I sincerely hope that PyPy takes over as mainline.
I think it has to do with how much access to the kernel (and thus hardware) one has. I am not well aware of how much influence interpreted languages have for memory management and all that jazz. I'm fine with thinking of myself as a scripter rather than a programmer. I'm been debating for a while now if I want to learn more C and do kernel editing. I usually learn by figuring out the system and then doing it. It's a lot more time consuming for me to try to learn kernels before I'm capable of even doing small things. I'm sure this is some difference between scripting and "real languages." How fast one receives the perceived benefits. Scripts are fast and easy to write, and interpreted languages handle a lot for you.
One annoying thing with pyflakes (or at least the version I have installed, I should probably check it) is that it highlights python 3 print calls with any named parameter as invalid syntax. 
eve online is written in python ;) there is only a tiny hardware-related binary interface written in c
Thanks, now I'm just a tiny bit creeped out :P
Actually, this is my first language. I tried to learn java.. fuck that shit.
That's hardly an argument. Dropbox is used on most computers I came in contact with and it's written in Python.
I care deeply when it affects how my programs act. Don't get me wrong, Py2exe et al are great, but when I used them I ran into all sorts of bundling issues (msvcrt.dll for example) with the modules I was using. The binaries are also fucking huuuggeee because it includes every dependency of every module.
Er, why? It's bad form in that you have no idea what min int is. You're assuming a two's complement computer, for instance. Then, you're poking a new attribute (which shouldn't be used anywhere), with a made-up value in 'sys'. So, bad form.
Nice work, guys!
So it's better to initialize a maximum with None instead of something like the system's integer minimum?
A maximum what? It depends on the problem or domain of numbers. Python has arbitrary-sized numbers. You can't go over or under. If, for some reason, you need to know the largest number that, under the covers, Python can represent in a native machine word or register, then you will probably know enough to know what to do about it then.
as in, you're storing the highest seen int out of a series of ints you're looking at? Definitely "None" &gt;&gt;&gt; (1 - sys.maxint) &gt; None True Asking if **anything** is greater than "None" will always return True
 &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.maxint + 4 2147483651L 
if you have a list, mylist, and you would like the maximum and minimum values: max(mylist) min(mylist)
Great! That's what i was looking for. Thank you very much! I just leave this here: def max_subsequence(sequence): max_sum = None max_start_index = None max_end_index = None current_max_sum = 0 current_start_index = 0 for current_end_index in xrange(len(sequence)): current_max_sum += sequence[current_end_index] if current_max_sum &gt; max_sum: max_sum = current_max_sum max_start_index = current_start_index max_end_index = current_end_index if current_max_sum &lt; 0: current_max_sum = 0 current_start_index = current_end_index + 1 return (max_sum, max_start_index, max_end_index) It's Kadane's algorithm finding the maximum sum subsequence of a sequence in O(n).
SymPy is great!
I have a similar background to this guy. Instinctively, I've written a services and repository layer, but is that "pythonic"?
Other have talked about the need for minint - but there are other issues here. First, to check if an attribute exists, use hasattr: if not hasattr(sys, 'minint'): # handle it What you did is create a list with all the attributes in the sys modules, and perform a linear search in the list, while you can do a single dictionary access instead using shorter and self documenting code. Second, why do you modify a library module? you are just risking trouble with another library that may use this attribute. If you need someting for you application or framework, add your own module for this: # limits.py maxint = -42 
I see you updated that recently. Nice additions (aside from snipmate, blech!)
I upvoted because I want to see more posts like this, but I disagree with a few things. If you're a pythonista, you really should be using UltiSnips instead of emusnippets (or anything else). Not only is the syntax compatible with TextMate, but it's written in python and you can interact with it using python. As far as omni completion goes, I much prefer rope-omni. If you want on-the-fly syntax checking, check out syntastic. EDIT: Here's my vim dotfiles... [https://github.com/jmcantrell/dotfiles-vim](https://github.com/jmcantrell/dotfiles-vim)
It's no~~t~~ longer an int, it's a `long` integer or big integer, hence the L.
Join or contribute to a open source project that is written in Python. Do you use Linux? Gentoo has quite a bit of Python code, and an active community. Or just find something that suites your taste.
If this is your work then thank you very much.
As is Civilization IV, and a handful of other major titles. It's actually fairly well suited to some types of gaming. I might be interested in using it for online/mmorpg server back ends.
I don't think this is a good idea. It will fail in Python 3: &gt;&gt;&gt; None &lt; 0 TypeError: unorderable types: NoneType() &lt; int() I would use `max_sum = float('-inf')`.
It will fail in Python 3: &gt;&gt;&gt; None &lt; 0 TypeError: unorderable types: NoneType() &lt; int() I would use max_sum = float('-inf'), which will work in Python 2.6+. If you need to support earlier versions, you can use the Decimal type: from decimal import Decimal max_sum = Decimal('-inf') **Edit:** This fails in Python 3 because NoneType doesn't have a rich comparison function, in which case the default is to [raise a TypeError](http://hg.python.org/cpython/file/8862ec62f9ee/Objects/object.c#l559) (object.c, Python 3.2). In Python 2 there's a default comparison that returns an integer, which is hard-coded so that [None is smaller than anything](http://hg.python.org/cpython/file/952e83a8bc78/Objects/object.c#l772) (object.c, Python 2.7). Python 3 did away with all of the old `cmp` functionality in favor of rich comparisons.
sheer = unmitigated; shear = tool for getting wool off of sheep However well those businesses are doing, they are doing so at the expense of those many, many people. That cannot be worthy of praise....
I'll summarize again: Fanstatic is a WSGI endware that can be useful with multiple web application frameworks. I'm involved in that project. We had a sprint meeting in the Netherlands a few months ago. Django folks there tried to integrate the Fanstatic WSGI endware with Django, but decided that since Django's configuration system doesn't allow easy configuration of endware and because Django's own middleware system does, they switched to Django middleware to integrate Fanstatic instead. It wasn't a big deal, but mildly frustrating - it'd be nice if Django offered out of the box configuration facilities for WSGI middleware too. I already said all this in this thread, what more beans do you want? Am I not backing up my assertions? Unless you want evidence that these people even exist? But that's not what I mean when I talk about backing up assertions: I'm talking about giving reasoned arguments for them, examples, etc. 
Service layers aren't uncommon in larger Python applications but the difference vs. the usual Java (and I assume C# approach) is the level of fanfare/OOPness involved. A Python service layer would be a module with a handful of functions in it, instead of a set of `FooBarService` classes and a bunch of associated factories and such. I've also noticed that the placement of "service" functions tends to be closer to where the domain classes themselves are declared, i.e. both under the model/ directory and sharing the same package/module for a particular subject area. In Java it seemed there were always separate "model" and "service" file hierarchies (and of course all the Spring stuff to connect it all).
With some great charts. That (I think) you can get to dynamically update as you manipulate the spreadsheet.
There is a bug in the first, thrid and fourth link. They have &lt;br /&gt; in the href. For example *http://sympy.org* points to *http://sympy.org&lt;br /&gt;*
^Tried Java and C# aswell, but the syntax is meh. &lt;3 Python
Each block could have 4 references. You could just check those 4 of either block and see if the other is one of them. Also, a sparse boolean matrix can be used. You can also use a dictionary to keep track of pairs that are adjacent. If you can order the elements in the pairs somehow, you don't need two dictionary entries. Just be sure to write a robust code to maintain these structures accurate when manipulating the blocks.
This is totally correct. I use python for all sorts of strange little scripting jobs that make my life easier - DnD Character Sheet helpers, facebook log parsers, whatever.
Coords are easier. If you have (x,y) then you can check (x-1,y), (x,y+1), etc...
I'm not sure I'm quite following what you're asking, but I'll give it a go. Are the letters (a-p) labels for the individual squares themselves? Or are the letters representative of some kind of "token" or "item" which may reside in a square? If the letters represent the squares themselves, I'd recommend using tuples or lists of length 2 to represent the squares. Assuming zero-indexing, the tuple (2, 3) would mean "third from the left, fourth from the top" and would correspond to the square labeled "o" in your example. Then, (assuming a square should not be considered adjacent to itself) your adjacent function would be as simple as: def adjacent(square1, square2): xoffset = abs(square1[0] - square2[0]) yoffset = abs(square1[1] - square2[1]) return xoffset &lt;= 1 and yoffset &lt;= 1 and not (xoffset == yoffset == 0) If the letters represent items which may be in any particular square (like chess pieces on a chess board, except each one is unique), then the simplest option which comes to mind would be to have a dict whose keys are the letters (as strings) and the values are the tuples or lists of length 2 of the square on which the item resides. For instance: position_dict = {'a': (0, 0), 'b': (1, 0), 'c': (2, 0), ..., 'n': (1, 3), 'o': (2, 3), 'p': (3, 3)} Then, you could apply the same adjacent function as follows: def letters_adjacent(letter1, letter2): return adjacent(position_dict[letter1], position_dict[letter2])
 letters = {u"m": (0, 0), ...} grid = {(0, 0): "m", ...} def adj(L1, L2): x, y = letters[L1] return any(grid.get((x_, y_), u"") == L2 for x_ in [x-1, x+1] for y_ in [y-1, y+1])
In Python 3, they are the same (hence, there is no sys.maxint).
&gt;I tried to learn java.. fuck that shit. Haha. I tried to learn Haskell three times already and failed. Still hoping that I'll manage to do it one day.