You are probably getting downvoted because you are attempting to refute a legitimate use of such a data structure by citing the way certain applications (URL shorteners) work i.e. you make no sense
To generalize, [alternate keys](http://en.wikipedia.org/wiki/Alternate_key). That's useful enough that the OP should have his answer.
I suppose this might be useful, but if you want to take this to the next step and create a network of associations, then you probably would want to use a rules engine instead that support backwards and/or forward chaining across an in-memory graph of facts (commonly implemented using the Rete algorithm). An example of such for Python is [here](http://www.mindswap.org/~katz/pychinko/), though I haven't used that particular rules engine, but I have used a couple others.
No, we wouldn't. In fact, right now we have two lists. One with the id and the url, the other with the url/subreddit and id. The other data is cached differently. &gt; Like I said, I am seeing this consistently falling short on real world examples. I think you are just trying to be unnecessarily nitpicky to fit your preconceived notions.
&gt; Wow you guys are harsh... I believe the harshness is stemming from the way you are communicating. You are passing off an attitude of "I know better than all of you." Whether or not you think that is the case, that is how you are coming off.
Except you only were asking for examples of how it might be used, not a "killer app". Mapping a URL to it's shortened version is an example of how one might want to use a bi-directional map/dict.
morse code: r = bidict({'A':'.-', 'B':'-...', 'C':'-.-.', 'D':'-..', 'E':'.', 'F':'..-.', 'G':'--.', 'H':'....', 'I':'..', 'J':'.---', 'K':'-.-', 'L':'.-..', 'M':'--', 'N':'-.', 'O':'---', 'P':'.--.', 'Q':'--.-', 'R':'.-.', 'S':'...', 'T':'-', 'U':'..-', 'V':'...-', 'W':'.--', 'X':'-..-', 'Y':'-.--', 'Z':'--..'}) def encode(text): return ' '.join([r[c] for c in text]) def decode(text): return ''.join([r[:c] for c in text.split(' ')]) (assumes no spaces or special chars in text) 
I wonder why .get() on an integer returns a string =/
A hostname &lt;=&gt; IP address mapping for example. Sometimes you have the hostname and want the IP address, sometimes you have the IP address and want the hostname. 
I have this saved from 3 months ago. I still haven't got around to looking through it. http://www.reddit.com/r/coding/comments/aafs1/data_structures_and_algorithms_with/
I've had a pretty close experience. I'd also add that cherrypy code doesn't look good: * you have to refer to the global cherrypy module all the time to get your stuff (e.g. the *request data* is actually accessed through the cherrypy module, I believe stored in some kind of threadlocal object) * the default dispatcher is downright terrible if you have any desire to create readable URLs (and cherrypy doesn't provide any way to reverse those URLs for any value of "reverse" worth using) * cherrypy's logging API is complete and utter shit. It's a thin layer over `logging` which exists only to ensure that logging's configuration is as broken and unusable as possible by default and that the logging function cherrypy provides and tells you to use are unusable. edit: also, the logging function is called `error` (though for some reason you can also call the log manager instead, which is less insanely named), the default logging level is `logging.DEBUG` (yes, even if you call `cherrypy.log.error`), and -- just in case you still believe you can use that crap -- cherrypy enables its access log by default and sends it to the same place as the "regular" log, drowning your own logging in access spam. * the documentation is garbage. Complete, utter and unadulterated garbage.
[](http://)
gift horse mouth 
bad idea.
1. Yet you don't explain how that's actually bad. 2. It takes one config line to change to switch to another existing dispatcher: routes, selector, HTTP method based: http://www.cherrypy.org/wiki/PageHandlers#OtherDispatchers 3. that behavior is indeed not the cleanest but as far as I know this can changed http://www.cherrypy.org/wiki/Logging#CustomHandlers 4. wow, what a constructive comment. It's not as clean as Django's or Pylons but it only begs for people to contribute and make it better http://www.cherrypy.org/wiki/TableOfContents You don't like it, that's ok. But at least come up with meaningful/valid reasons for trashing it down like that. 
I do not recommend it. The code is not pythonic. It's python written in a java style. 
&gt; Yet you don't explain how that's actually bad. It's weird, and it's damn ugly. Why is it global, how does it work, where is it set, what sense does it make, how is it going to interact with other threads and/or processes? &gt; It takes one config line to change to switch to another existing dispatcher Defaults are important, and the fact that the default dispatcher is a piece of shit is annoying. Yeah I can create my own dispatcher if I want to. But I do *not* want to. Why provide a default dispatcher if you don't want to make one that can actually be used? &gt; that behavior is indeed not the cleanest Quite the understatement. &gt; but as far as I know this can changed Once again, the issues here are documentation and defaults. &gt; wow, what a constructive comment. Yeah, no need to thank me. &gt; but it only begs for people to contribute and make it better http I've yet to find a link on how and where to contribute, plus I really wouldn't enjoy contributing to a wiki doc. As far as I'm concerned, wiki docs are pretty much the lowest of the low, apart from providing only autogenerated API doc (which cherrypy doesn't do either as far as I've seen, by the way), they scream "we don't give a fuck about documentation", especially for Python packages. And to get people to contribute, you have to bring them at a level where they have the knowledge and incentive to, which means at the bare minimum: * an existing useable docset, CherryPy's isn't useable * the feeling that the documentation isn't going to bitrot, CherryPy's doesn't give me that feeling * an explanation on how to contribute, to the core and to the documentation, and of the documentary style, again [see Django](http://docs.djangoproject.com/en/dev/internals/contributing/), their "contributing" page alone is probably bigger than the biggest cherrypy documentation page... and they have [a whole section dedicated solely to the documentation style](http://docs.djangoproject.com/en/dev/internals/contributing/#documentation-style) * fucking use Sphinx already, there is no excuse *not* to, and it lets me try out patching/improving the documentation in my little sandbox on my little machine using my editor of choice and checking out the final version of the doc without being "visible" by anyone In the case of cherrypy, most of the tools aren't even documented in a meaningful way. See for instance [sessions](http://www.cherrypy.org/wiki/CherryPySessions), I'm told I can set `tools.sessions.storage_type = "file"`, and the default is apparently `memory`. That's nice. Now what the fuck are the other session storage backends? What do they point to? Can I find any example for implementing my own session storage backends? At the bottom of the page I can see an option called `session_filter`, what the fuck is this, why does it exist and how does it work? Who knows? Apparently not the official documentation, that's for sure. Now compare with [Django's sessions documentation](http://docs.djangoproject.com/en/dev/topics/http/sessions/) The "zen of cherrypy" thing is cute, but at the end of the day, what I've seen in the PyCon presentation and my comparison with my own experience trying to work with cp was "cherrypy might be nice if you already know it inside out", and TFA only reinforces that opinion.
I came here to post exactly that. All they have done is taken the java code and written it using simple python, there are much more elegant ways of implementing those algorithms in python.
I am wondering why we cannot just merge stackless python in cpython along with gevent in standard library...
&gt; It's weird, and it's damn ugly. I'm convinced then. &gt; Why is it global, I don't understand what that means compared to any other framework out there. &gt; how does it work, where is it set, what sense does it make, how is it going to interact with other threads and/or processes? Once again, are you asking the same questions to any other framework? Maybe you could then enlighten me on all the implementation details of the Django internals. &gt; fucking use Sphinx already, there is no excuse not to, and it lets me try out patching/improving the documentation in my little sandbox on my little machine using my editor of choice and checking out the final version of the doc without being "visible" by anyone http://docs.cherrypy.org/dev/ http://www.cherrypy.org/browser/trunk/sphinx I can't even begin to address the rest since your tone is just putting me out. Again you don't like CherryPy, fair enough. I suppose it's also fair to compare it to Django which has many contributors when CherryPy probably has less then 5 overall. Mind you, all your swearing did really help making it a better project. I guess you're right, no need to thank you. 
&gt; Once again, are you asking the same questions to any other framework? Maybe you could then enlighten me on all the implementation details of the Django internals. In django, the request data is collected before the view function is called and provided as a regular function parameter (akin to Python's self). The execution flow is explained [here](http://www.b-list.org/weblog/2006/jun/13/how-django-processes-request/). The relevant objects are described [on the django page](http://docs.djangoproject.com/en/dev/ref/request-response/). I don't have to wonder where the request object comes from or how it interacts with the rest of the framework in the first place, because it's just a function parameter, there's no global, so other part of the frameworks shouldn't be able to grab it and manipulate it as I do. &gt; http://docs.cherrypy.org/dev/ http://www.cherrypy.org/browser/trunk/sphinx Well that's an improvement, there's hope after all. &gt; Again you don't like CherryPy, fair enough. That's not even the case. Or at least that wasn't initially. Just as with bazaar I started out at worst neutral, at best hopeful, then reality crushed my hopes.
I will not argue whether or not the global aspect of the request/response object mechanism is the right one (personally it never bothered me) but I will acknowledge that the implicit magic may throw many people off. In fact, it's probably the main criticism I've heard about CherryPy. CherryPy internals is probably hard to document properly due to the fact it wants to keep the high level API simple and readable. The implementation is therefore not as straightforward as folks like you are hoping. But for instance, looking at the [most recent WebOb example](http://blog.ianbicking.org/2010/03/12/a-webob-app-example/) Ian Bicking provided, I'm horrified. Sure the internal implementations of WebOb is probably simpler to follow than the one from CherryPy but as a web developer, I have the feeling that WebOb just pushes the actual work of building a clean API on my back. It's a trade. I quite clearly understood you didn't approve the choice CherryPy made and that's fine. Others do and are happy with it. Luckily there is choice :)
&gt; But for instance, looking at the most recent WebOb example Ian Bicking provided, I'm horrified. Yeah, I wasn't too impressed either (though I can understand his POV, Ian is about as much a low-level guy as you can be and still use Python). I feel it can be fine for one-off stuff, but not if you're building webapps for a living, or you're going to end up rebuilding your own web framework on top of the stuff.
Marty Alchin's *Pro Django* is great for getting deeper into the nuts and bolts of Django. I've also been fairly happy with Jeff Younker's *Foundations of Agile Python Development*. It's not so much about language tricks as about development techniques--packaging, testing, coverage, continuous integration, etc. I think it probably could have used a bit more proofreading before publication, and the chapter on Mocks uses a thoroughly dated mocking tool, and advocates some weird practices that I wouldn't recommend.
I also recommend Steve Holden's [Python 401: Some Advanced Topics](http://holdenweb.com/static/files/Python401.pdf), which is a free PDF from a presentation he did at PyCon 2009. That said, don't worry about not knowing all the secret tips and tricks. There will always be more tricks to learn, but most of them are things you should probably never use in production code unless absolutely necessary, especially if they reduce readability for someone unfamiliar with your code. Remember that code is how you communicate with other programmers, and you want to make sure you're communicating clearly, and not just showing off.
One of the reasons is that CPython is considered THE Python reference implementation. The stackless features cannot be ported to IronPython or Jython, so CPython would loose its reference function. For more information read this excellent answer by Andrew Dalke, http://stackoverflow.com/questions/588958/what-are-the-drawbacks-of-stackless-python
Python Essential Reference by David Beazley and Expert Python Programming by Tarek Ziade might be useful to boost your Python-Fu.
I totally agree with that but lately I've implemented a lot of things that I found to be cleaner and easier if I've read these articles beforehand. My main problem is that I grasp the basics quite well but miss a lot of the nice python idioms. I guess that's the price I pay for picking it up from pure documentation. That's why I'm asking for book advice now.
I love Python in a Nutshell.
Not a book, but the one thing that took my python programming to the next level was spending time on the [Project Euler](http://projecteuler.net/) problems. Solving these helped me become more conscious of the scaling of my different algorithm and data structure choices, in addition to being a lot of fun.
Effective C++ :) I'm not really joking: past a certain level in python, you will probably find that you need a native language to work with it.
Take you Effective C++ and shove it up your ass!
Not a book, but many people find my PyCon/OSCON 2007 tutorial helpful: "Code Like a Pythonista: Idiomatic Python", http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html
Nah, that's when you just start writing your own C Modules for Python. :D
I've written some C and C++ but the chance that I'll need it in my current job is very small. If I ever will need it, it'll be time for a refresher course as it's been at least 5 years...
nirai uploaded a patch wich replace GIL with a scheduler: http://bugs.python.org/issue7946#msg101612 GIL death is closer
The scheduler he has proposed is still a "Global Interpreter Lock", so no - it doesn't kill the GIL.
Read the patch. Search for `take_gil`, notice how each call is replaced with `bfs_schedule`. Then read the `bfs_schedule` code. It's still GIL. Only one thread (the one whose descriptor is in the `bfs_thread` global variable) is allowed to execute at a time.
C is a possibility as well :) But you can perfectly write extension modules for python in C++, as long as you wrap them with Swig or boost.
Try hanging out on the python-tutor list. There are some hella smart people there so you can learn and teach at the same time. 
I enjoyed Ziadé's Expert Python Programming, 2008. However, the books that improved my Python code the most were actually books on other languages, mostly functional. For instance, Armstrong's Erlang book, and Seibel's Practical Common Lisp.
tl;dr 3D plotting [doesn't look like crap](http://matplotlib.sourceforge.net/mpl_toolkits/mplot3d/tutorial.html) anymore, but stick to 2D for now
Django IS Python. You don't sacrifice anything...I do whatever I want outside the framework when it needs to get done.
One thing I forgot to add was that Python isn't my first language by any metric. I've coded C, C++, Perl, Ruby, PHP. I've done glibc debugging for a previous job, leant Perl as my first scripting language, learnt PHP for a web project (and promptly never wanted to use PHP again, ever), learnt Ruby because I wanted to see what this Rails thing was all about and now switched to Python for most of my scripting needs and really loving the language with every new feature I learn. The language seems to fit the way I think very much. That's my coding experience in a nutshell, hope that helps with the book advice. Thanks for all the suggestions, so far. 
PER for ever!
How high traffic is the python-tutor list? I have problems with following very high traffic mailing lists as I don't always get the time to catch up on my lists and if it grows too fast I'll just stop reading it because my mail client shows that I have &gt; 3000 unread messages.
I'm reading that Python 401 article now and that's a great article. This is great information and something I might not have found without your link. Thank you!
Honest Q, I'm new to Python: why do you think you still need *a book* if you're "semi-advanced" ??? My understanding so far, from asking and reading on #python is that one should avoid the super-fancy, complicated stuff.
You're welcome. I'm sure Steve would appreciate a thanks on c.l.py, if you see him around there. 
[The archives](http://mail.python.org/pipermail/tutor/) show 10-20 messages a day on average. I'd say that's fairly high traffic but if you have a threading mail client, you'll be able to ignore the boring conversations entirely. The number of actual threads is a much more manageable 0.5 to 2 a day.
They were simply telling you the way of [the Tao](http://www.canonical.org/~kragen/tao-of-programming.html): simplicity and clarity are natural extensions of complete understanding, both of the problem and the language. But there is a lot going on (and changing every few years) under Python's hood that can help you if you write a lot of Python and aren't afraid to learn about it. For example, most programmers and, indeed, programs were not affected by the new style objects. But, if you plunge in and discover how they really work, you'll find a lot of useful information. Example: since all objects now inherit from a single ancestor, `object`, you can easily form a [diamond inheritance relationship](http://en.wikipedia.org/wiki/Diamond_inheritance). Do you have to know about that to write some great Python? No. Is there a case where that's important and useful? Yes. The distance between those knowledge levels is the same as the distance between "semi-advanced" and "master".
Nobody's mentioned this yet, but if you're really looking to fill in the gaps about the nitty gritty details of how the language works, it will be worth your time to start looking at the [Python Language Reference](http://docs.python.org/reference/index.html) (not to be confused with Beazley's Essential Reference (also excellent). Not easy reading, and not oriented toward teaching best practices, but I've found it can be very useful to understand exactly how things work under the hood.
Thanks ! excellent explanation
Well, the thing is, I know how to program Python but I still find new features which make me think "if I knew about this before I implemented X I could have made it cleaner, better, easier to maintain". Why I'm asking for books is that I want a reference for all these features in one place. Hunting for them on the internet is great but I have this habit of finding what I need a few days too late.
Cython.
And for Python packaging, see the still-in-development [The Hitchhiker’s Guide to Packaging](http://guide.python-distribute.org/).
So much discussion around packaging, so little around package management....
Have you done real work with it?
+1 - I revisit this on a regular basis. Thanks for the great tutorial!
I have, it's very nice. You can reach near native C speeds. It also makes for a very good means of wrapping existing c/c++ libraries. If it helps, most veteran and core python developers I've spoken with recommend it (folks who are far more skilled in python than I).
Thanks, that's useful information.
Fuck McKinley!
[core python](http://www.amazon.com/Core-Python-Programming-Wesley-Chun/dp/0132269937/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1269622189&amp;sr=8-1)
http://gnosis.cx/TPiP/ Text Processing in Python. One of the best books on functional programming I've ever read. The subject matter seems dry, but the book is truly outstanding.
It's probably been mentioned before, so forgive my lack of reading every comment. You can learn a lot from reviewing source. Reading books is great, but if you're ready to move on, then check out a good Python library and go through the source. Twisted, Django, core library. Whatever. 
But of course. Didn't you notice the two big bold words "DON'T MANAGE" on the cover of HHGTP? ;)
&gt;since all objects now inherit from a single ancestor, object, Just the ones actually using new-style objects, yeah?
well i wish i would have seen your opinion on the matter beforehand :), thanks for the pycon vids!
THE GIL IS NOT BEING REPLACED. I cannot say this in more uncertain terms, nor can anyone else who is remotely informed. Python threads will still be serialized. That is all.
Some Google Talks: [Advanced Python or Understanding Python](http://video.google.com/videoplay?docid=7760178035196894549#) along with any of the talks done by Alex Martelli.
Python in a Nutshell is pretty good. Though it does start from scratch.
From the link I provided: &gt; Python had to deal with this upon the introduction of new-style classes, all of which have a common ancestor, `object`. Python creates a list of the classes that would be searched in left-first depth-first order (D, B, A, C, A) and then removes all but the last occurrence of any repeated classes. Thus, the method resolution order is: D, B, C, A. Old-style classes before 2.2 were different and a bit non-transparent ("magical"). Here's a great and very short book about Python classes, then and now: http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html
Here's a preview/tutorial by the same author: http://www.packtpub.com/article/advanced-matplotlib-part1
Yup, I had the same issues with the PyQWT as well. Because my app was targeting MacOS X, I ended up rolling my own rendering in PyObjc. Though now there is a cocoa plotting library that could probably be wrapped to achieve the same effect.
The point was about the result of class foo: pass # intended to be old-style, not inheriting from object isinstance(foo, object) To my surprise, this returns True; but ISTM it returned False in some of the interim versions of Python after new-style classes were introduced. But there is still a big difference here: class foo: pass class bar(object): pass len(dir(foo)) # 2 len(dir(bar)) # 18 foo.__dict__ # dict with keys matching the dir results, even though '__dict__' itself is not in dir! bar.__dict__ # dictproxy instance foo.__mro__ # raises AttributeError bar.__mro__ # (&lt;class '__main__.bar'&gt;, &lt;type 'object'&gt;) - note that '__mro__' is not in dir(bar)
This is a pretty textbook use case for `__new__`.
This is a known bug in the path simplify alogrithm, as far as i know. It's fixed in the Trunk.
Python Essential Reference by David Beazley is far and away my favourite Python Book. Although it is a reference book, you will learn a lot. It is concise but detailed and readable. Highly recommended.
That beats the hell out of anything I've done in Excel. Obviously time to switch my ad hoc analysis tools.
By the time you can define what precisely "semi-advanced Python coder" means, you won't have anything to worry about! ;-P
&gt; so little around package management.... My opinionated guide: 1. Install [ActivePython 2.6](http://activestate.com/activepython) 2. Type "[pypm](http://pypm.activestate.com/) install NAME" to install packages ('pypm help' for more) 3. If pypm does not have a package, try "pip install NAME" ActivePython includes pip, virtualenv and Distribute so you don't have to install them. 
Another way to compare old style and new style classes is: &gt;&gt;&gt; class old: pass ... &gt;&gt;&gt; class new(object): pass ... &gt;&gt;&gt; type(old) &lt;type 'classobj'&gt; &gt;&gt;&gt; old.__bases__ () &gt;&gt;&gt; type(new) &lt;type 'type'&gt; &gt;&gt;&gt; new.__bases__ (&lt;type 'object'&gt;,) &gt;&gt;&gt; issubclass(old, object) False It's really the metaclass (class of the class) that determines if it is new style or old style. In Python 3.0, you will not need to subclass object to create a new-style class.
Use the source: read the implementation in Objects/typeobject.c for how it handles __slots__. You're going to need to write your own allocator for the tp_alloc in your type struct. Why do you need __slots__? It's already a built-in type if you're using C so the lookups are fast, and you can define an always-fail function in tp_setattr to deny access to assign new attributes that shouldn't exist.
Additionally, you can always subclass the type you defined in C (set Py_TPFLAGS_BASETYPE in tp_flags so it's inheritable) in Python and set __slots__ in the .py source.
Oooh, I should have thought of that. Thanks.
Thanks, pypm sounds like what I've been looking for (which to date I've described as "gem, but for python"). Curious, is that the only reason you're using ActivePython? It's not something I've ever looked at it, I've just dismissed it as a sort of marketing effort to interest businesses in Python (which is fine, but something I'd typically dismiss as "for enterprisy types").
&gt; In my experience, scientific programmers achieve better productivity when avoiding to work at the widget level and using an abstraction library. I guess this is my least favorite part of matplotlib. For anything but the simplest graph, it's as if I'm using a 2d drawing library. The flipside of that is that you can make some really compelling graphs and you're not bound by the three or four stock graph types.
I'd also like to express my thanks for that tutorial. I continue to find interesting nuggets of knowledge in it, and share it every time I know someone who wants to become a stronger Python programmer.
Use JSON when at all possible. Only reason to use XML is if you HAVE TO.
I usually mix these up, when I see a bit of code that does something I want to emulate, I'll read the source of that bit and integrate it in my own code. Then I'll go to the online documentation. Books are usually things I read when not coding or at a computer so I can get new and fresh ideas.
His post doesn't mention it, but stackless requires a small bit of assembly for every target platform.
I was there, and this introduced me to the wonderful world of Python. Thank you, Alex!
It's insane how such a simple/small script can be a real ssh server.
Alex is a really cool dude. He answered a noobish question I had on StackOverflow one time and was very helpful.
Where is the beginning of the talk?
Alex has answered 90% of my Python questions on StackOverflow. If it weren't for him, I guess I couldn't get to where I am today. 
Alex seems to be a compulsive stackoverflow player.
&gt; Curious, is that the only reason you're using ActivePython? BTW, I work for ActiveState, and I'm the developer of PyPM. :-) &gt; [ActivePython is] something I'd typically dismiss as "for enterprisy types" It has been that way so far along with the extra bits such as various tutorials, peps, and PyWin32 that are included in ActivePython. But nowadays we are spending a lot of effort in Python, and thus improve our Python distribution. PyPM is the first step, and we have a lot on the horizon (eg: something like perlapp that would make it easy to create executables/installers for win/mac/lin - whether your project uses pyqt, scipy, wx or ...) 
Alex is known as [MartelliBot](http://wiki.python.org/moin/MartelliBot). Years before StackOverflow even existed, Alex provided accurate and detailed answers to an unbelievable number of questions in comp.lang.python.
you should take a look at the twisted conch code of course it's reasonable to consider that a black box library, but it's all there for the curious
is there some logic to the name "conch"?
no
I suppose I sort of answered one of my own questions re: activestate's distro- $pypm install numpy error: Can't install numpy-1.4.0: requires Business Edition subscription so, I think we're done there... again unless the $ are worth it. But if I suppose if I'm spending money I'll go enthought.
have you looked into sage? python scipy/numpy/matplotlib/etc... all rolled into one, I've been using it after a frustrating round of trying to install all the dependencies of matplotlib
Ah- yes, thats another one I meant to mention that I haven't given a testdrive yet. Shall check into it- thanks.
&gt; 4) I could obviously do macports/fink, but I think I'd rather stick with the Apple distro. *why*? i juggle between macports' python 2.5.5, **2.6.5**, and apple's old 2.6 quite easily via macports: $ python_select -l Available versions: current none python25 python26 python26-apple $ python_select -s python26 in the time it took you to write this post, you could be up and running via macports: $ sudo port install py26-numpy py26-scipy py26-opengl macports is stupid easy to use &amp; update: $ sudo port selfupdate &amp;&amp; sudo port upgrade outdated 
why- because I didn't quite realize it was that easy to switch them to be honest. And I didn't consider that sentence well enough. I believe I tried this via macports a year or so ago and had some trouble getting numpy to compile, so just threw in the towel in pain. I'll give it a shot- thanks.
I rolled my own DMGs of hand-built Python, NumPy and Matplotlib. These got added into an installation script that I distribute to collaborators and users of our software, which has for the most part worked quite well: it bootstraps a new python, hdf5, h5py, numpy, matplotlib, ipython, mercurial and our software. I have recently started to look into adding VTK into the mix, which [I blogged about](http://blog.powersoffour.org/packaging-yt-numpy-vtk-on-os-x-snow-leopard), and Qt may also be added, but those will both need to be handled with more care. mpi4py will be added in the very near future as an automated component, rather than relying on the user to install it later. I really prefer avoiding the Apple distribution, since I'd rather leave it pristine, and since our analysis package has some homegrown HDF5-linking C extensions to Python, linking against the EPD is a bit tricky and complicated. Macports and fink usually just add more problems than they solve, although some people in my group swear by the Macports install. If memory serves, they may have had troubles in the past linking mpi4py against system OpenMPI rather than MacPorts OpenMPI, but perhaps that's no longer true. As for keeping things up to date, we have for the most part done our best to avoid upgrades that didn't happen on long intervals. The script is able to update the installation of *our* software, but it relies on standard distutils/setuptools/distribute mechanisms for updating external python software. One of the reasons for this is that we have in the past had to monkey patch to avoid incompatible changes in things like the h5py API when upgrades were made automatically. So in general we try to be a bit conservative on that front.
The MacPorts Python sucks pretty hard if you want to do any GUI stuff with it, because it uses X11 instead of the native (cocoa?) graphics libraries - resulting in ugly and slow.
Now I remember why last year's effort was stalled out. I'm trying to build it now. First, db46 wouldn't build (needed for python 2.6) and that was because Apple seems to have left a symlink off to some headers in Java. Fixed that. Now, scipy won't build because some problem with numpy/gfortran not building x64 / universal binaries (http://trac.macports.org/ticket/19397). This fix doesn't seem like it will be quite as straight forward as fixing a few links.
Ug. Yes. I mostly use OpenGL and run in fullscreen mode, so I don't live and die by the GUI. Still a bit harsh.
I like Macports and still use it from time to time, but I've had troubles with using Macports to install SciPy. I eventually gave up and compiled/installed SciPy manually, which seems to work so far.
This is a problem I've been trying to deal with the the last few months. I love Python and have been gradually transitioning away from Matlab to use exclusively Python, but I've lost a lot of hair over trying to make Python work seamlessly with 3rd party packages. Besides the Apple distro and Macports distro, I've installed the "official" distros myself and also Enthought. But at this point, I don't really know how to specify what distro I want to add a package to, if I'm installing something new. Enthought works very well, but I'm also concerned about the licensing options after I graduate.
I've recenty gone with a vanilla python installed using homebrew to /usr/local followed by installing virtualenv immediately afterwards. I create a 'main' virtualenv that I use most of the time and I occasionally create other virtualenvs when needed for testing/application specific, etc. works well enough so far... this leaves my site packages nice and clean, and using homebrew over fink/macports ensures I don't install 2 copies of all sorts of shit, while giving me an easy upgrade path ( because I'm lazy ).
Hasn't this been around for a while already?
Huh, would you look at that... *tips hat and dives back into PHP/Drupal hell*
Ye it has! I think the OP got version 2.0 of the book confused with Django 2.0.
This has been out for more than a year.
It's still the web preview and was like this 2 months ago, what's new about it?
Indeed, this is still the web preview version or the Django book homepage hasn't been updated, which is very unlikely.
Yes, I know the reasons, it was rhetorical question. For me gevent (and other libraries like that) is the only choice for network applications. threading and multiprocessing do not work for high concurrency with I/O bound apps...
yes
Yeah I'd recommend installing the macports/fink version of python though if you want to keep it up to date.
It works well with Django at the very least.
But then you can't use Cocoa/Tk stuff.
I use pretty much all of that on linux and windows without any issues I bet it will work just as well on a mac..
It's easier to do Python dev on OS X than Windows but not as easy as it is on Debian or Ubuntu. That said, Rudix and/or Homebrew go a long way in bridging the gap between OS X and a well-behaving open-source work environment: * http://rudix.org/ * http://github.com/mxcl/homebrew
never used MongoDB or Gearman, but I can vouch for flawless workings of all other stuff you mentioned. There are some minor differences but no big speedbumps. 
Should work for everything you've listed. I've been using a mac for python development for about two years, the only issue I've had has been with the MySQLdb module.
Just to clarify on that front, the MySQLdb module can be installed, it's just a bit more work to install it on Mac OSX than on Windows or other OSes. You basically have to download the full MySQL server installation package even if you don't want a MySQL server, install it, then compile the MySQLdb package from scratch (which is just a "python setup install", anyways). At least, that's what it took the last time I did it.
I believe you can install pyobjc using easy_install
I had to do a bit more than that. When I upgraded from 10.5 to 10.6, I had all sorts of issues with both my MySQL server installation and with the OSX development tools. I had to jump through all sorts of hoops before I got to 'python setup install'. Huge pain in the ass, a lot harder than 'sudo apt-get install python-mysql'. It was a pain point, and he was asking if OSX was suitable for painless development. 
Is this something specific to OSX+MySQL, or something more general ? Thanks
It's specific to the python-mysql library. It's just shit, that is all.
Yeah, it'll all work. The main thing you'll miss though is that there's nothing anywhere near as good as apt or yum. I'd love to be able to sudo apt-get dist-upgrade
I mostly use git-versions of libs I use, and apt-get for 'huge' stuff like apache or so. Any idea if Apache+mod_wsgi works fine on OSX ? My production server runs on linux,apache+wsgi and it would be great having same setup on dev machine (as I have now). Thanks
I use macports for python, php ... etc. development. I think its the painless way.
Absolutely. OSX Snow Leopard comes pre-installed with Python 2.6.1 (also 2.5 but 2.6 is default), apache, vim, emacs, sqlite3 and easy_install So really, when you get that shiny new macbook. All you need to do is turn it on, open a terminal and hit 'easy_install django' and you're done. I would also recommend using MacVim
I've been using Eclipse/PyDev/Egit with django/sqlite recently, and it works just fine on Snow Leopard.
def never had a problem with mongodb. building from source is fine, but you can save yourself the time&amp;trouble with the binaries on 10gen's site.
I just recently moved from an Ubuntu box to OSX at work. Everybody in the company uses Macs, it just took a while for me to get mine. The catch is, all devs use VMWare Fusion to run Ubuntu for development (which is what our production machines use). Editing is done by ssh'ing into Ubuntu or mounting it as a samba share and using TextMate or whatever favourite editor. I thought this was backwards at first, but from past experience it is really useful to have your development environment be as similar as possible to your production environment (even with an intermediate staging environment). You can do this easily with the virtual machine because it's separate from your usual operating system use. It just avoids a lot of unexpected surprises. OSX for everything non-development has been great.
Hmm interesting, doing primary development/editing in virtual machine is something I would like to avoid. My idea is pretty simple: * primary development on Mac * testing in virtual ubuntu server before the deployment (which is same as production) * production at ubuntu server/debian Having virtual for development does not make sense for me, as development is where I spend most of the time so I want to have it on 'primary machine'.
As does macports; you'll compile things yourself but it's got a fairly complete collection of ports.
I've used PHP, Java, C and Python on a mac. I found Python to be the most painless of them.
I installed mod_wsgi without any problems a while back, it compiles find with what's included. 
Yes. But for the most recent stuff, occasionally you are going to need to compile yourself. Then again, that's not a bad thing. Oh and ruby on rails is installed by default on a mac. Gem is installed by default. Am not sure about git, but I think that's also installed by default.
&gt; That said, Rudix and/or Homebrew go a long way in bridging the gap between OS X and a well-behaving open-source work environment: Macports has been doing that for a long time already...
last changeset was may 2009. doesn't seem all that active
Apparently I'm the only contrary opinion here, but I've found OS X to be much worse than windows for python development. I tried to install PyQT once to run qbzr and ended up with two different versions of PyQT in two different Python installations in the same system with each missing one feature that the other had. If you keep to virtualenvs it shouldn't be too bad, but it will be **nowhere** near as easy as in Linux. If you install a program/package/library, you can basically forget about upgrading or removing it, as there's no tool to do it and you have to hunt for it in the 2-3 places it can be. If you use macports it might make this easier, but my experience with it was hell too, as I had to remove all the dependencies one by one and reinstall them for a simple up/downgrade to the package I wanted. Depending on what you do, your mileage may vary, but this is one of the reasons I switched away from OS X. For some reason, nobody believes me or agrees with me.
I develop solely on my Mac. It's wonderful, especially for web development. If you get used to Expose and hot corners, you can get a pretty slick workflow going.
never done anything big but never had a problem either so I'd vote yes
bpython does just about exactly what I need it to, #bpython has been nothing but helpful, and I've got no complaints to be had going on who knows how long using it. Thanks for a great little piece of software!
Is there still that problem with the socket being in the wrong directory in the default MySQL install. Don't recall the details, but for a newb took a while to puzzle out. 
That looks interesting indeed, thanks !
In short, yes.
pyobc and tk have ports. 
really? I've had no problem with the *sql modules. *edit* the easiest, non-manual way is: sudo port install py26-mysql
I could never leave apt behind. Why can't all OSs have something this awesome?
yes, this works fine. you can use macports to install separate versions of these or if you're comfortable enough install mod_wsgi to the system (included by default) apache.
you have to self install git, but it's trivial with either macports or the official osx installer.
WING on Mac works just as well as Windows. I really like its visual debugger and hovering the mouse pointer over a variable to see its value.
In general, it's painless. How painless depends on your particular needs. For example, if you get very frustrated if a minor version (e.g. 2.6.2 to 2.6.3) is not available in your package manager within a few days of release, macports will feel lagging. Also, if you use oddball libraries they may not be as available as in linux (more contributor mind share). The last caveat is, if you *do* fall into one of these categories it's still trivial to do it yourself if you're not intimidated by editing a TCL file and changing a version number (macports). I have about 35 packages I maintain in macports now since I fall in a "niche" needs area. The vast majority took 5m to setup. A few, like the atlas/lapack library I maintain was a significant project. However, simply building atlas/lapack properly by source is a significant project. *edit* The things that are trivial on OS X, but difficult or impossible on Linux is what keeps me on OS X. Like commercial software (illustrator, photoshop), software apps I simply prefer (omnigraffle, omnifocus, omni*, TextMate). 
&gt; just use expanddrive to expose Ubuntu's disk via SSH. Or use MacFusion, a free (and as functional) alternative to ExpandDrive: [MacFusion](http://www.macfusionapp.org/)
I think it's great, Macs are meant for work. I think everyone in here covered the Python specific stuff, so I will touch on Mac OS X productivity. Make sure you try out spaces, expose, spotlight, automator, dashboard, and all the other productivity tools. There may be linux equivalents, but they are not as polished and stable. Make sure you use time machine, you have to, you have no choice. Their native apps are great too, like mail, etc... and their office tools are surprisingly nice. I also find MS Office to be better on it too. Make sure you check out iLife that comes with it, the sound and video editing is serious professional grade stuff that is great for tearing out video demos in. Finally, there is a great ecosystem of Mac only apps that just great. Remember this one: Expandrive. It allows you to mount FTP, SSHFS, Amazon S3, etc.. drives like they are local and use your local IDE's and CLI tools to operate on it. It has amazing caching and feels and makes a shitty FTP connection into a fast local drive. It is the best money I ever spent on software. There are free alternatives, but they don't even come close.
I intend this to be helpful, not just contrarian. &gt; I tried to install PyQT once to run qbzr and ended up with two different versions of PyQT in two different Python installations in the same system with each missing one feature that the other had. MacPorts is the best solution for this. I've seen the above generally happen when naive users don't quite "get" instructions and get frustrated. So they install something via macports, another python via the official installer, and then mix in a few hand installs, etc. And their path is pointing to a different python binary than they thought. The same thing can occur on linux if someone flips between hand installed to apt or rpm. Though, given the choice is much clearer on linux as the package manager is the clearest option. &gt; If you install a program/package/library, you can basically forget about upgrading or removing it, as there's no tool to do it and you have to hunt for it in the 2-3 places it can be. If you do hand installs, it's true you must know your system's layout. This is true in linux too, but the layout is very consistent. For example, all user installed system wide python packages are placed in /Library/Python/{version}/site-packages. After that, removing is just an rm -rf. The general rule for python self installed modules is "all packages are installed in the called binaries /path/to/site-packages". This can be determined in the sys module (python -c "import sys;print(sys.path)") &gt; For some reason, nobody believes me or agrees with me. As someone who has supported both new linux, new windows, and new OS X users extensively. I believe you. Usually this is due to a general lack of knowledge about one's new OS or the utilities they've chosen to work with. I've seen almost identical confusion, problems, and results with new linux users. Curiously enough, I've supported people when they were new linux users, then a year or so later new OS X users (or vice versa). Though they experienced the same learning curve they always seem to have forgotten their previous frustrations.
OS X is suitable for painless development, imho. I've developed python on OS X for a couple of years now and it was less the OS that made things painless and more getting turned on to pip and virtualenv. Seeing as you are already into those, I think you will enjoy working on a Mac.
We do Python development in OS X 10.5 (Leopard). We like MacPorts well enough. I use Python (multiple versions), SQLite, Git, Vim (I think), and Apache from MacPorts. I have a few PostgreSQL versions installed out of it, too, though for historical reasons we actually develop against a version I have built in `~/pgsql`. I see some people saying MacPorts sucks, but between MacPorts and virtualenv+easy_install/pip I get along pretty well.
I agree, however I recommend ArchLinux. Be sure to use NFS to mount your linux volume, it is lightning fast compared to SMB.
Hi! I've been using os x to do python developing for more than a year right (django, tornado, web2py, mongodb and more...) now and i can say: you can use it just like you use linux. On os x 10.6, we have python 2.6, easy_install and apache web server. You can easily install mysql/postgresql through homebrew/macports (i prefer homebrew) or through some pre-packed installers. Oh, and i use vim (macvim, to be more specific) and it's really really great.
In long, sort of.
It's a very nice example of using webob and paste. There is also a good example on the [Python Wiki](http://wiki.python.org/moin/Twisted-Examples) about how to create a very basic http proxy service (no authentication) using the twisted framework: from twisted.web import proxy, http from twisted.internet import reactor from twisted.python import log import sys log.startLogging(sys.stdout) class ProxyFactory(http.HTTPFactory): protocol = proxy.Proxy reactor.listenTCP(8080, ProxyFactory()) reactor.run() 
smart ass. ;)
eww fuck that, first thing you gotta do is 'sudo easy_install pip' then 'sudo pip install virtualenvwrapper'
there's a slight bit of pain on the occasion that some libraries refuse to build under appropriate "architecture". maybe its just my own OSX install but I sometimes have the issue where a lib only builds as x86_64 - Python's distutils builds everything with the ppc/i386 archs. I had to hand-edit some freetds buildfiles in order to get pyodbc to work, for example.
Ooh! Distro fight!
Primary dev is on the Mac, the files just sit in the VM for constant testing on a running server. 99% of my time is spent on the primary OSX machine; the vm is just running in the background. I almost never look at it, but I do have a terminal ssh'd into it which shows me the server output. YMMV. Cheers.
I do pretty much everything in OS X. Only time I deviate from that is actually staging stuff under Linux (either virtualized on the same machine, or on one of the random boxes I've got) to check behavior under a production-ish system.
Last time I tried WING it was a bag of shit. But hey, at least it's not Aptana.
Both Django BDFLs and about a majority of the Django commiters use Macs as their primary development machines. There were more MacBooks and MacBook Pros at DjangoCon than anything else hands down. Probably 80% of the speakers and attendees. I switched from Ubuntu to Mac OSX as my primary dev machine over a year ago and it was the best thing I've ever done. Don't get me wrong, I still LOVE Linux and OpenSource in general. It's all I use on servers, it's my hobby/passion, and the entiriety of my career. But Macs are just plain awesome. All the little things that are perfect and just work more than make up for the couple of little annoyances "it isn't Linux" that come up. 
If you want to make this a class, you'll need to actually instantiate the object. You also need to refer to the object within the method calls - `self.compmove()` instead of just `compmove()`. Of course, you could just not make it a class at all — just have plain old functions and globals. Not a good idea generally, but fine for just screwing around, since even "globals" are local to their module in python.
Here you go: http://codepad.org/LIqMZhCW You can't call gameopen directly because it's a method of RockPaperScissors. You need to make a RockPaperScissors object and call gameopen on that object. edit: but there's quite a few other problems with this code, give me a minute and i'll make a few more changes
God I hope not. Someone downvoted already! Still, the NFS advice is sound. :)
[Here](http://paste.pocoo.org/show/195079/)'s a working version. Here are some changes / suggestions: * The place where you are initializing variables (gamesToWin, etc.) should be made into an initializer method `__init__` ([reference](http://diveintopython.org/object_oriented_framework/defining_classes.html#d0e11720)) * `gameopen` was missing a call to `self.playgame` to start the game * When you're referring to the variables and functions defined within a class, you have to refer to them as `self.whatever` ([reference](http://diveintopython.org/object_oriented_framework/defining_classes.html#d0e11896)) * for example `oppMove = compmove()` needs to be `oppMove = self.compmove()` * use `raw_input` instead of `input`, unless you want what the user types in to be executed (for example "2+2" will be evaluated to 4 when using `input`) * this line needed some work: elif fight(yourMove, oppMove) &amp; winningMoves: First, you defined fight as an empty tuple `fight = ()`, so calling `fight(a,b)` doesn't mean anything and will cause an error. Since it seems like you wanted it to be a function call, I made a new method called `fight` that returns `True` when the first move is a winning move. Also, the `&amp; winningMoves` is not valid Python, `&amp;` is the bitwise and operator ([reference](http://wiki.python.org/moin/BitwiseOperators)), which typically only works on integers. Instead I changed winningMoves into a dictionary of (winning move, losing move) pairs. * this line is tricky: if hScore or cScore == gamesToWin: Based on order of operations, this will actually evaluate as `hScore or (cScore == gamesToWin)`, so the `cScore == gamesToWin` part gets evaluated first, which isn't what you want. It needs to be more explicitly written like this: if self.hScore == self.gamesToWin or self.cScore == self.gamesToWin: * the game should call `exit()` in the `endmatch` method if it detects the game is over
Thanks! I was having trouble with the __init__ and if__name__ and where/why/how to construct them. This helps a lot. Also, could you explain the logic behind how you compared the moves and who won the game? Finally, I thought you didn't have to be so explicit in comparing hScore and sScore to gamesToWin but I must be mixing that up with something else. Edit: Is your use of dict in the winningmoves variable pretty standard? It was obviously better than mine but is there any way to check a list/tuple against a list of tuples/lists and see in if exists in the larger set?
This is awesome. We need to have more code reviews on reddit.
Depends; you like using last year's Python? That there 3.x don't come by default. I find it okay. Just remember that if you're gonna do anything with wx, flip 'er into 32-bit mode..
Yes, an example would be: (1,2) in [(1,0), (4,2), (1,2), 2, "hello"]: which would be true. Same for lists too.
Any updates on the Windows port? I've been waiting patiently for months :) **EDIT**: there's a version of Wcurses available at http://www.lfd.uci.edu/~gohlke/pythonlibs/ that seems to compile for recent versions of Python. Would this work with bpython?
We haven't actually tried the wcurses implementation as Marien is working on an urwid part to bpython. However, your reply has got me thinking about at least trying a wcurses component to see how wcurses holds up. As for the GTK part (the part which should in the end run on windows). I need to do some work on that but life has been busy lately. It is in the works. However, if you do happen to have all the dependencies, look at this post from me: http://ikanobori.jp/weblog/2009/12/30/running-bpython-on-windows-with-gtk It is a minor alteration of the bpython 0.9.6 codebase (no redirection of stderr) which runs on windows, albeit a bit buggy. If you stumble upon any bugs in it, don't hesitate to report them to our bugtracker: http://hg.bpython-interpreter.org/bpython/issues *edit* I saw your reply at the previous submitted link about bpython.gtk, in that case, only the bugtracker part of this reply stands ;-)
Thanks for the kind words.
I actually tried the GTK Windows version a while ago, but never could get it running. Is there a newer version than the one on your blog?
When you get this working, expand it to Rock, Paper, Scissors, Lizard, Spock
Well go post that in the other thread from which I learned this bit of information, I guess.
I use both all the time, but strongly prefer Linux because it matches my release platform and there are never any surprises. In addition there are more compiled packages, and performance is slightly better (threads implementation,filesystem, etc) The only thing you get from a mac is a pretty interface. The most compelling reason for me would be the very nice macpro laptops, but I would not trade my linux desktop.
I agree.
fwiw, I find developing python on Windows just fine, I don't use any gui bindings though..
This is not quite right. Even if you're doing most of your heavy lifting in C/C++ modules which release the GIL, the GIL (at least in it's current incarnation) still makes it pretty much impossible to achieve 100% CPU usage across multiple cores. It doesn't *completely* stop you from exploiting multi-core CPUs, but it's a pretty damn big obstacle in the way.
Why not RPS 101? http://www.umop.com/rps101/rps101chart.html
I develop in Django on OS X and deploy to Linux servers, can't say I've ever had any problems. 
It would be nice to have the code examples highlighted.
I don't know, but I'd be very interested to study some as well.
[CherryPy 3](http://www.cherrypy.org/) is a great example of beautiful software design.
Thanks for this, it looks tidy and well documented to boot.
Good question. Anyone know any examples of a large, well written pyqt application?
Look at Stani Michiels projects - Stani's Python Editor and Phatch http://pythonide.blogspot.com/ 
first: s/MacPorts/[homebrew](http://github.com/mxcl/homebrew) second: work in a bare virtual env I develop on OSX and deploy to linux, and never have any problems. Virtualenvs definitely help make stuff a painless.
[Trac](http://trac.edgewall.org/) is very clean, well-tested and -documented, and has an interesting plugin architecture too.
honest questions: #1: what is everyone doing that is cpu bound that causes this to matter? #2: why threads when there's multiprocessing? after all threads will only scale so far before you have to switch to multiple processes anyway, the interface is pretty similar so why start at a dead end with threads? erlang scales pretty much linearly because it starts off as multiple processes, I don't even think it has threads in the same sense as other languages. seems to me since the # of cores will only increase over time, python would be better served by a multiple process share nothing/message passing framework rather than making threads work. my .02 
Mnemosyne? 
You can't really compare Linux and OS X... Sure, if you install a Python in Linux by hand it'll go to /usr/local instead of /usr/lib or whatever, but it's still one of two places. In OS X there's /System, /Frameworks (I might be getting the names wrong, but there are two system-wide installations) and **two user-specific ones** (same folder names under ~)! **Plus** you have one more if you use macports. It might be better if you use macports exclusively, but if you don't and try to install the official Python or some other one, you have no idea where it goes, and there are no uninstallers! The convenience of not having to install regular apps and just copying them instead **really** does not work for libraries, but the OS X app installation paradigm has affected library developers and they rarely include uninstallers in their software. Combined with the hell of upgrading a package in macports (apparently this has changed since I used it, though), where I had to remove all the packages that depended on the lib I wanted to upgrade in order to do so, I installed Linux on all my machines and now I can't even go back to Windows for development, which I've used for years and know that there's an uninstaller for everything. I understand that the visuals are a big lure, but in the end I just want my work done as easily as possible, and OS X didn't do that for me. Your mileage may vary, though.
Same here, it is the single most important thing in my Linux experience.
if someone went the extra mile and showed what you could then do with that proxy or rather how you would get logic in to manipulate the request and response that would be interesting to me personally. My struggle with twisted has always been that after the initial setup like the above example, I don't know what to do. I'm sure there's a deferred somewhere to call but twisted docs seem to lack real world examples IMO. 
Never heard of it but code seems nice and clean. Good read for the next time sitting stuck in rush-hour traffic.
Shame on me. Didn't know that Trac was in fact written in Python. Looks interesting. Saw some nice use of decorators (e.g. cache.py).
A couple guesses: &gt; 1: what is everyone doing that is cpu bound that causes this to matter? Any sort of scientific computation? With numpy/scipy, Python is actually a really nice alternative to matlab for this sort of thing. And it will be completely CPU bound with almost no IO. If numpy/scipy release the GIL when doing their computations though, maybe it's not such an issue there. &gt; 2. why threads when there's multiprocessing? Again, just guessing, but processes are significantly more expensive than threads on Windows. Probably doesn't matter if you're just using a few, but it may for large numbers. Also, if anyone's stuck on a Python version older than 2.6
Nice. Especially Phatch is definitely worth a look. Heavy use of subprocess.
I agree that threads are cheaper than processes. But it seems that the only hope to scaling cpu bound stuff linearly as the # of cores increase is going the multi-process route just as erlang does. and then you have the additional benefit that multi-process implies multi-machine for free. So it seems to me that the benefits outweigh the costs, and as cores increase, I would assume that the cost of a process would be less and less significant. In that light it seems that threads are a short term solution with benefits that are becoming less and less.
a desktop app example would be nice. 
Also I have a question: Does it make sense to use mpm-worker with mod-wsgi?
seems that a subtle takeaway from this is reduce the # of threads possibly to get around GIL thrashing? good to know 
The paths are part of knowing your system. If you self compile install on any system, there's no uninstaller. On osx, if the library is a framework (the osx way) you can just delete it. It's awfully convenient in comparison to other *nixes. Just to clarify /System is for system /Library is for user framework installs. So there's only two paths "the osx way". If you self compile a source app and it's not a framework build, it's /usr/local. For macports, I'm surprised on the upgrade travails. Normally you just sudo port upgrade foo. All I was pointing out was when someone starts linux the idea of having things installed in two different places is confusing to them, with osx it is _different_. But not really any more confusing.
[Sonata](http://sonata.berlios.de/), [PCManFM](http://pcmanfm.sourceforge.net/), [Mirage](http://mirageiv.berlios.de/)...
It's not about real world examples, it's about knowing what you need/want to do and how it's done (the standard). Then you look at [the API doc](http://twistedmatrix.com/documents/10.0.0/api/twisted.web.proxy.Proxy.html), then you click on [View Source](http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0//twisted/web/proxy.py#L166) where you discover that you need to use [HTTPChannel](http://twistedmatrix.com/documents/10.0.0/api/twisted.web.http.HTTPChannel.html) so you study that and see that it should be a base class to your MyProxy protocol. Then you create a factory as shown above, but use myproxy.MyProxy instead of proxy.Proxy. You are now Done. Twisted is basically its own best documentation and it's ,,love it or leave it''. Hard to swallow at first, but it grows on you. ;-)
&gt;going the multi-process route just as erlang does Erlang processes aren't OS processes, so Erlang isn't quite doing the multiprocess thing we're talking about here. 
Hmm, true... There are ~/System and ~/Frameworks too, though. Also, the biggest fault I see with OS X is that packages don't have uninstallers, while in any other platform they do. I would expect a program not to have an uninstaller if I compiled from source, but downloaded bundles to not come with uninstallers is a pretty big minus.
You have to sign up for their newsletter to get the links, which fortunately can be unsubscribed from. Here's the links so you don't have to deal with the bullshit, [.mov](http://bit.ly/pybitemov) [.avi](http://bit.ly/pybiteavi) [.ogv](http://bit.ly/pybiteogv) I'd get more pissed about it, but they *did* put the code under the MIT license. Edit: "our videos are DRM-free and the code is released under the MIT license." I misread that line. Edit2: Ok, I felt bad about the marking as spam, so I won't do that either. 
good to know. I had purchased the [book](http://www.amazon.com/gp/product/0596100329/ref=s9_simh_gw_p14_i1?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=center-2&amp;pf_rd_r=07GTH9AAHE9JJADV3W9Z&amp;pf_rd_t=101&amp;pf_rd_p=470938631&amp;pf_rd_i=507846) a couple of years ago, and I didn't get much out of it because it seemed to assume things about the reader that I was not. Twisted would be better served by a book geared more towards newbs IMO. 
Same here. Awesome guy!
Well I actually think that Twisted docs are OK when it comes to the basic terminology. Because above that and two blogs ([JP Calderone](http://jcalderone.livejournal.com/), [krondoblog](http://krondo.com/blog/)) the docs are just not there -- need to dive into the source. Never seen that book in person, but I'd rather read the code anyway. And I did. Btw. #twisted on IRC awesome, people there are actually really nice and helpful. :)
while that is true, I still think threads will be less and less beneficial as the # of cores on a cpu increases. there might be a threshold somewhere where threads actually degrade performance due to things very similar to what the GIL causes now. 
So let me get this straight. We give you a professionally crafted screencast free of charge. The files are DRM-free. The code is released under the MIT license. The only thing we ask is that you sign up for the newsletter, from which you can unsubscribe at any time (even immediately after receiving the links). And you do what, report it as spam to Gmail? And are _pissed_ about it? Our subscribers have the added benefit of receiving further freebies by email without having to sign up again. BTW, the videos are not released under the MIT license and we asked that the files are not distributed directly both in the confirmation email and the README file. I would therefore kindly ask you to remove the links from your message which is in violation with our license. It's not a big deal, but please understand that your behavior doesn't encourage a company to release further freebies.
There's only ~/Library, though this is similar to ~/lib, ~/bin, etc directories folks can create on linux and install to. Nothing gets installed there unless you specifically do a "user install" which is equivalent to do a --prefix=~/foo for linux. Uninstallers are left up to the developer. Some apps do have uninstallers. However, this is largely negated by the "bundle" system that OS X uses. An application and all its relative parts are contained in a single folder called a "bundle". .app/ for applications .framework/ for libraries and such. It's actually an amazingly clean way of approaching the issue of cruft. . . an aspect of other *nix's that always bothered me. The one niggling exception are the preference files and installer receipts. The installer receipts contain a list of every file created by an installer or application. They're only a few kilobytes large and over the course of years and years of use they can grow to a few a megabyte or so. But for the anally inclined, it can get under the skin. There's also the ~/Library/Application Support. This is where applications are supposed to put non-configuration application data. Like databases or icon sets, etc. It is similar to ~/.dirs (home dot directories) on *nix. Since there is a list of all files in the receipts file, several applications are available that "clean" these. AppCleaner is the one I like (free). You drag the app to its window and it'll delete everything on the system connected to that bundle. It shows a list of what it's deleting so you can choose to keep the file if you want (user config for example). I use it often, the only thing it's really made me aware of though is that, well, applications and libraries on os x really don't create a lot of cruft. All this "cruft" occurs in standard locations though. And becoming anonoyed the lack of an "uninstaller" that handles them is similar to complaining that aptitude uninstall foo does not remove the dot files in your home. To my knowledge, unlike OS X, linux does not have a nice clean way to automatically detect and clean these up that works for all applications (like AppCleaner does for you). :)
also good to know. I am subscribed to JP Calderone's blog already and have enjoyed the twisted web in 60 seconds series. I'll check krondoblog too. 
Sorry, I misread the license info. I see now that it's just the code. After a couple of disposable email addresses were rejected (i.e. mailinator), as you specifically check for that, I was getting rather annoyed. If you didn't reject those I wouldn't have posted the links. I see placing an artificial barrier, requiring users to divulge personal info, in front of the links as a rude move, even if it's a freebee. It's spammy. This isn't how posts to reddit should work. Sorry, the links are staying put. You'll have to get reddit to remove them. Or you could just shuffle your server around so the links break. Edit: I guess I was being a little rude. I appreciate the video. I just really hate the mechanism you use to distribute it. 
&gt; After a couple of disposable email addresses were rejected (i.e. mailinator), as you specifically check for that That's actually Mailchimp who rejects some temporary email addresses automatically. There are some disposable services that work.
No, you misunderstood, I'm not annoyed at uninstallers for not removing that cruft, but for not removing the services the program installs. For example, when I installed VMWare, three services started on startup and I didn't know how to remove it while also removing these services. Just deleting the bundle wouldn't remove these, would it?
For the record, it's written 90% in python with the number crunching part being the remaining 10% in GLSL
But I don't really care about whether it does. I don't need anything from MacPorts so I don't need MacPorts' Python.
Regarding your edit. No worries, I pulled the submission as per your suggestion, and bought a reddit ad, so I think it's fairer this way.
In the spirit of making Python the best language (of its type) possible, GIL has to eventually disappear. Working with threads should be easy and 'predictable' on multi core systems. (No strange blocking and performing penalties). You can change your code around to partially avoid it, but its not always intuitive and not always successful. I just don't see this as very "Pythonic". I agree that python is usable for CPU intensive things by using c modules. There are countless times when you need to prototype something, or write some quick and dirty routines, where no c modules are present. I currently have a system with 8 cores, so why wouldn't I want this type of code to scale nicely, without jumping through c hoops. I know this is silly but, non python people who are used to non-blocking threads always point out GIL like its some strange disease that Python is afflicted with. People avoid the language as a result. I hear this all the time when I mention Python. I love Python, but I am not going to become an apologist. Gil is limitation and not a feature. Python would be an even better language without it, so it is something to strive towards. The key is to come up with a good design that does not sacrifice simplicity, and that may take some time. Failure to evolve and get rid of it will make language less relevant in the future, as people will favor parallel friendly languages. (Haskal, etc)
Thanks for your concern and for responding to my concern. I've decided not to mark anything as spam after all. I have a short fuse when it comes to marketing ploys, so I was pissed at the time. 
[Django](http://www.djangoproject.com/) is typically quoted as a exemplary Python project.
If you're interested in deving on OS X but using a Linux VM to serve it, please checkout [Vagrant](http://vagrantup.com), we'd love to get the python community involved.
[bottle](http://github.com/defnull/bottle) and [python-graph](http://code.google.com/p/python-graph/)
I used CherryPy &amp; PIL to create a multi-player multiple-choice game for a Kids Day presentation, which was great because I was done so quickly after starting (I was given two weeks roughly, and was finished in a day or so). The game was just 20 questions, each team having to choose the correct answer. The progress of teams was denoted on a large display with four race cars that progressed passed along a track, first team finished wins. While trivial, it was nice to create a application with multiple users &amp; states so quickly &amp; cleanly (plus, it gave me a ton of free time whilst I "tested" my program).
You're correct. VMWare is one of the special cases. It installs kernel extensions and some other things that make it not a normal application install. Fortunately, VMWare like most other vendors who provide applications that "break the mold" so to speak provides an uninstaller for their app: http://communities.vmware.com/thread/115699 Generally, if this is necessary the vendor also places this in the aforementioned Application Support directory. VMWare also does this: /Library/Application Support/VMware Fusion/Uninstall VMware Fusion I concede this is not as nice as the virtual guarantee with many linux package managers that everything is done through the package manager. But it's not completely unusual either. If I recall from my installations of VMWare on linux, you had to use a custom uninstall script from the shell to cleanly remove everything (provided by vmware as well, something like uninstall_vmware.sh) 
The original [BitTorrent](http://www.bittorrent.com/btusers/download/directory-list#section-linux).
[reddit](http://code.reddit.com)? :)
You can also check [MoinMoin](http://moinmo.in/), which has interesting plugin architecture and various other interesting subsystems. Note however that there are lot of ugly code there.
Some key concepts: * A class is not a place to store code and share data. A class is used to **define a data type**. Rock-paper-scissors, as a concept, does not make sense as something to model with a class, because there is only one rock-paper-scissors. An individual game of rock-paper-scissors is a better fit. Or a scoreboard for a series of games of rock-paper-scissors. * Data declared directly within the class like that is shared between all instances of the class. It does not make sense that every scoreboard-for-rock-paper-scissors has the same number of games to win. Instead, we assign **member** data to each scoreboard, by setting up that value in its .\_\_init\_\_ method. * Proper organization of code requires separation of responsibilities. The part that asks the user for information is separate from the part that does calculations with that information. Here, for example, you can make the raw_input() call at the top level to ask for a number of games to play, and then use that to create a scoreboard. * Think carefully about data structures. The purpose of winningMoves is to look up what move beats what other move. The phrase 'look up' is a key that you should be using a dictionary. Similarly, a dictionary with only integer keys in order is a warning sign; you should just be using a tuple or list. (Note that the `random` module lets you select one of many options directly, using random.choice().) * Try writing less code at a time. A lot less code. Don't let yourself write the next bit until the current bit works. You're making all kinds of elementary errors, and there is no compiler to check them for you ahead of time - they're only figured out once running the code gets to the point in question. * Python does not require us to "encode" user input in "computer-friendly" ways to the same extent that other languages might. Go ahead and ask the user to type 'rock', 'paper' or 'scissors' in full; it's easy to check these values. Also, raw\_input() already returns a string. You should really never use input() (except in Python 3000, where raw\_input() is gone and input() means what raw\_input does for 2.x). Especially not if all you want to do is get a string out of it. Also notice that you currently don't actually try to check if the user's selection is a valid move - you only check that, after being eval'd by Python, a string comes out. * Think carefully about how you name things. It's a good idea to separate words, whether you do it with\_underscores or viaCapitalization. Also, imperative functionality should have imperative names. You don't tell your kid "your room needs to be cleaned"; you tell your kid "clean up your room". So start the game with start_game() or something like that. (Also, "open"? Games aren't opened.) * You should almost never exit() from a program. It's too much brute force. Just arrange to 'return' all the way out, or if it's because something is really wrong, maybe you can throw an exception. * Calling a function from itself is called *recursion*. This is a useful technique, but it should **not** be thought of as "trying the function again; starting over". It has more subtle implications than that. In your case, you don't even want to start the whole function over again if the user's input is wrong; you just want to get new input. The way to arrange this is with some sort of *loop*. * Think carefully about what you want to validate. There is no particular reason the number of games to win needs to be odd. The user will be supplying the "4" in "best 4 of 7", for example, not the "7", and as you can see, 4 is even, while a best-4-of-7 tournament has no issues with ties. [Here](http://codepad.org/isLdgaXf) is another version for your consideration.
&gt;Finally, I thought you didn't have to be so explicit in comparing hScore and sScore to gamesToWin but I must be mixing that up with something else. You might be thinking of range comparisons such as "if 3 &lt; x &lt; 5". These are Python-specific, but the 'or' logic works the same way in basically everything that looks vaguely like Python. &gt;Edit: Is your use of dict in the winningmoves variable pretty standard? Using a dictionary for look-up is standard. Using it as shown is very much not standard, and misses the point. See [my version](http://codepad.org/isLdgaXf) for comparison. The point of a dictionary is to find the key, given the value. The idea is that you have moves mapped to the moves that beat them, so given a move, you can look up the move that beats it. So in order to find out if the computer beat the human, for example, you check if the computer's move is the one that beats the human's move. You do that by taking the human's move, looking up the move that beats that one, and seeing if it's what the computer picked.
sorry for taking so long to reply: what's your system (python, gcc, etc.)? my specs: From System Profiler: Model Name: Mac Pro Model Identifier: MacPro2,1 Processor Name: Quad-Core Intel Xeon Processor Speed: 3 GHz Number Of Processors: 2 Total Number Of Cores: 8 L2 Cache (per processor): 8 MB Memory: 3 GB Bus Speed: 1.33 GHz ROM Version: MP21.007F.B06 SMC Version (system): 1.15f3 $ uname -a Darwin staff-02.local 10.2.0 Darwin Kernel Version 10.2.0: Tue Nov 3 10:37:10 PST 2009; root:xnu-1486.2.11~1/RELEASE_I386 i386 $ python -V Python 2.6.5 $ gcc -v Using built-in specs. COLLECT_GCC=gcc COLLECT_LTO_WRAPPER=/opt/local/libexec/gcc/x86_64-apple-darwin10/4.5.0/lto-wrapper Target: x86_64-apple-darwin10 Configured with: ../gcc-4.5-20100304/configure --prefix=/opt/local --build=x86_64-apple-darwin10 --enable-languages=c,c++,objc,obj-c++ --libdir=/opt/local/lib/gcc45 --includedir=/opt/local/include/gcc45 --infodir=/opt/local/share/info --mandir=/opt/local/share/man --with-local-prefix=/opt/local --with-system-zlib --disable-nls --program-suffix=-mp-4.5 --with-gxx-include-dir=/opt/local/include/gcc45/c++/ --with-gmp=/opt/local --with-mpfr=/opt/local --with-mpc==/opt/local --enable-stage1-checking Thread model: posix gcc version 4.5.0 20100304 (experimental) (GCC) i just built scipy, et. al.: $ sudo port install py26-numpy py26-scipy py26-opengl Password: ---&gt; Computing dependencies for py26-numpy ---&gt; Cleaning py26-numpy ---&gt; Computing dependencies for py26-scipy ---&gt; Fetching metis ---&gt; Attempting to fetch metis-4.0.tar.gz from ftp://ftp5.freebsd.org/pub/FreeBSD/ports/distfiles/ ---&gt; Verifying checksum(s) for metis ---&gt; Extracting metis ---&gt; Applying patches to metis ---&gt; Configuring metis ---&gt; Building metis ---&gt; Staging metis into destroot ---&gt; Installing metis @4.0.1_0 ---&gt; Activating metis @4.0.1_0 ---&gt; Cleaning metis ---&gt; Fetching SuiteSparse ---&gt; Attempting to fetch SuiteSparse-3.4.0.tar.gz from http://www.cise.ufl.edu/research/sparse/SuiteSparse/ ---&gt; Verifying checksum(s) for SuiteSparse ---&gt; Extracting SuiteSparse ---&gt; Configuring SuiteSparse ---&gt; Building SuiteSparse ---&gt; Staging SuiteSparse into destroot ---&gt; Installing SuiteSparse @3.4.0_0 ---&gt; Activating SuiteSparse @3.4.0_0 ---&gt; Cleaning SuiteSparse ---&gt; Fetching swig ---&gt; Attempting to fetch swig-1.3.40.tar.gz from http://internap.dl.sourceforge.net/swig ---&gt; Verifying checksum(s) for swig ---&gt; Extracting swig ---&gt; Configuring swig ---&gt; Building swig ---&gt; Staging swig into destroot ---&gt; Installing swig @1.3.40_1 ---&gt; Activating swig @1.3.40_1 ---&gt; Cleaning swig ---&gt; Fetching swig-python ---&gt; Verifying checksum(s) for swig-python ---&gt; Extracting swig-python ---&gt; Configuring swig-python ---&gt; Building swig-python ---&gt; Staging swig-python into destroot ---&gt; Installing swig-python @1.3.40_0 ---&gt; Activating swig-python @1.3.40_0 ---&gt; Cleaning swig-python ---&gt; Fetching py26-scipy ---&gt; Attempting to fetch scipy-0.7.1.tar.gz from http://internap.dl.sourceforge.net/scipy ---&gt; Verifying checksum(s) for py26-scipy ---&gt; Extracting py26-scipy ---&gt; Configuring py26-scipy ---&gt; Building py26-scipy ---&gt; Staging py26-scipy into destroot ---&gt; Installing py26-scipy @0.7.1_0+gcc43 ---&gt; Activating py26-scipy @0.7.1_0+gcc43 ---&gt; Cleaning py26-scipy ---&gt; Computing dependencies for py26-opengl ---&gt; Fetching py26-opengl-accelerate ---&gt; Attempting to fetch PyOpenGL-accelerate-3.0.1.tar.gz from http://distfiles.macports.org/python ---&gt; Verifying checksum(s) for py26-opengl-accelerate ---&gt; Extracting py26-opengl-accelerate ---&gt; Configuring py26-opengl-accelerate ---&gt; Building py26-opengl-accelerate ---&gt; Staging py26-opengl-accelerate into destroot ---&gt; Installing py26-opengl-accelerate @3.0.1_0 ---&gt; Activating py26-opengl-accelerate @3.0.1_0 ---&gt; Cleaning py26-opengl-accelerate ---&gt; Fetching py26-opengl ---&gt; Attempting to fetch PyOpenGL-3.0.1.tar.gz from http://distfiles.macports.org/python ---&gt; Verifying checksum(s) for py26-opengl ---&gt; Extracting py26-opengl ---&gt; Configuring py26-opengl ---&gt; Building py26-opengl ---&gt; Staging py26-opengl into destroot ---&gt; Installing py26-opengl @3.0.1_0 ---&gt; Activating py26-opengl @3.0.1_0 ---&gt; Cleaning py26-opengl it imports fine: $ ipython Python 2.6.5 (r265:79063, Mar 22 2010, 12:01:21) Type "copyright", "credits" or "license" for more information. IPython 0.10 -- An enhanced Interactive Python. ? -&gt; Introduction and overview of IPython's features. %quickref -&gt; Quick reference. help -&gt; Python's own help system. object? -&gt; Details about 'object'. ?object also works, ?? prints more. In [1]: import scipy In [2]: scipy.__version__ Out[2]: '0.7.1'
I love WingIDE and am a long-time user, but I really don't like using it on OSX. I run a VirtualBox on my MacBookPro, just so I can develop in Ubuntu. SO, Wing is great, but on OSX, it's a little wonky.
Yeah, it seems like it's inelegant, but it really works nicely. You get good OS-level support for your hardware (sleeping reliably, keyboard hot-key support, power management) that CAN be done on Linux, but require lots of work, and then you cmd-tab into your VM and you have a full Linux development environment. Also, for me, it is nice to have "work mode" and "other"... I get less distracted when my VM is full-screen, my IM isn't installed, no bookmark to reddit in the browser, etc. It's kindof like having "an office" to get work done. I was hesitant to get a Mac, because I simply don't use anything that it provides well: I don't use iTunes or iPod; I don't use iPhoto; my mail is on Gmail; my calendar, too... I don't use Safari, I don't use Quicktime. So, what's left? I don't like OSX as much as most people (it's plenty pretty, but I don't like its keyboard shortcuts or app-switching metaphors) so it was hard for me to justify buying a Mac. In the end, it was because of the quality of the hardware and the knowledge that the hardware would be well-supported by the OS; basically it was either get another Thinkpad, or get a MBP. I couldn't get a Thinkpad configured the way I wanted at any price, and the MBP was a good deal from Refurb. Maybe if I was full-on Mac always, it would be different; my workstation is Ubuntu, and has been since "warty", and before that it was Debian. Good luck.
I took a look at the code, and IMHO BitTorrent was not so pythonic then in 2.4(?), and ovbiously is so much less pythonic now in 2.6/3.1 
This is a great reply. Thanks for going so in-depth. *In my understanding of your version, you generate the computer's move as a choice of the keys in winning moves. Then, you check and see if the computer's move is the key to the human's move's value to see if the computer won and vice versa to see if the human won. *In general, is the MVC theory similar to object oriented programming? These things confuse me. *Also, when play_round() is called and then game is a tie. play_round() has no return. If it has no return, will this stop the loop in play_game because no round_winner was returned. *Finally, I understand why you suggested making sure each part worked before moving on to the next. My problem was that in previous versions I had part of it working but broke it trying to get the rest to work. I think I just need to learn how to separate calculations from data storage, etc.
There's a .dmg download that I've used, it's running just fine and I've even altered the default apache installation to use it too.
Holy moly.
Erlang processes have nothing to do with OS processes. They're much more like threads than like OS processes.
I don't know who you're arguing with, nobody has said that the GIL is a "feature", just that the costs of eliminating it are quite high.
Hmm, true, but the package manager can run programs to clean things up... I wonder if you can specify deletion hooks in OS X to uninstall things when the user deletes the bundle...
Sometimes. Usually in linux, these files just get left strewn around. I think most *nix's take the same approach as OS X...especially in this day and age of gigabytes for pennies. It's just not that big a deal. :P I'm not sure about deletion hooks.
fine whatever you want to call them. seems message passing share nothing multi-process(thingy's) has proven to scale almost linearly as you increase cores. I'd rather have that regardless of whether someone "fixes" the context switching strategy because it seems to be a more long term solution. 
Interesting. Does it provide you with a wxPython that uses Carbon (rather than X) and the other stuff that's installed by default with the included Python in Snow Leopard?
The configuration files and some other cruft does get left, but the services and kernel hooks all get removed.
Yeah. BitTorrent is some pretty ugly Python.
PyQt is good. The way I got it working on my Mac was a bit involved thought, ie download Qt SDK (QtCreator), then sip (compile), then PyQt (compile). Your code will run on Win / Linux too. If you want a super native looking app pyobjc is probably better but then you should maybe directly wrote it in Objective C.
WxWidgets library and python bindings are shipped with OSX's standard python install, and can be readily installed on other platforms. 
I've used this for a simple flashcard app. The script worked well on Linux machines. Getting it working on Windows might tax the average Windows user, though. Not that I have anything better to suggest.
py2exe makes even that pretty simple.
The only Python I've done is web-programming, but PyObjC gives you native bindings into Cocoa, so you can use InterfaceBuilder and all the standard Mac goodness. After building an AIR app and having to create my widgets from scratch, I'm a little bit jealous of PyObjC.
I just downloaded and installed WxWidgets. In the 1/2 hour I have spent with it, I really like it. Thanks for the advice.
A good article on how little getting photo metadata in python has progressed over the last few years. PIL gets the job done on simple things but it completely glosses over a lot of info. The author does this too, by dismissing MakerNotes as "a bunch of hex data" and assuming that it was worthless. This is PIL not understanding the MakerNotes section, which is more or less a way for people to stuff their own made up shit into EXIF. In general, for digital pictures, MakerNotes aren't useless. The fantastic 'ExifTool' by Phil Harvey has superior coverage of EXIF MakerNotes to anything I've ever found in python. http://www.sno.phy.queensu.ca/~phil/exiftool/ A few years ago, a friend and I attempted a python port that would actually compile exiftool's camera/maker data into a python module for use with EXIF.py. There's just a ton of model specific data out there; here's exiftool's auto-generated page on Canon tags: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/Canon.html Parsing perl is as difficult as you'd imagine, and we were too stupid to attempt to just write something in perl that could import the modules and output the information in a format we could use. But back on the tags: In some cameras, stuff as plain as ISOSpeedRatings are in the makernotes. Canon's cameras have lens details, camera orientation, metering details, etc stuffed in there. 
I second wxWidgets. I have written a couple small dual-platform Windows/OSX wxWidgets programs professionally with good results.
I've worked with wxpython, qt4, and tcl. Qt4 is by far the cleanest, most well thought out, and best supported on OS X. Well, tcl work peachy...but...it's tcl.
sudo port install py26-pyqt4
I've always wondered if there are any good Python web toolkits, and I'm not talking about things like Django or Pylons but something more akin to GWT, where developing an app like Gmail would be done with very little knowledge about web browsers and javascript (IIRC, Django still requires javascript programming if you want client-side applications). It would be kind of cool to write an app like: import pwt button = pwt.Button("Click me!") button.OnClick( lambda x: pwt.Alert("You clicked me!") ) pwt.Run() When loading this in a web page all that code is executed locally, as if it were written in javascript. EDIT: I just found [this](http://wiki.python.org/moin/WebBrowserProgramming) which seems to indicate Pyjamas as being a viable web client toolkit.
I'm not getting defensive. You were getting defensive with your "That's your job" comment. I posted because I thought I knew something others didn't, and they might like to know too. Sheesh.
Yeah, but y'know, it bugs me that MacPorts builds and installs yet another Python installation. Mac OS X already comes with two, and it would have been nice if MacPorts would make use of that.
If you're developing strictly for the Mac, you'll want to go with PyObjC. Interface Builder is not something to overlook. If not, then Wx is probably the right choice.
I gave up on Mac Ports years ago. At best I might refer to their web site if I'm trying to compile something and can't figure out what I have done wrong. Otherwise I can minimize the crap on my system by avoiding Mac Ports. 
But to really use PyObjC you really need to know cocoa itself inside and out. It's not something you use instead of Objective-C Cocoa development, it's something you use along with it, to be honest.
Ive spent a few years with gtk, qt and vx. I prefer QT in both C/C++ and python.
I'm wondering if you're getting downmodded for emacs or the use of print statements. Either way, I haven't found better than emacs yet for my personal usage.
I'm a fan of PyQt also, but speaking of involved, do you know a way to distribute the result to other users without making them install Qt? All the information I can find about doing this is old and broken, which surprises me because you'd think it would be an extremely common thing to do.
Good grief, I had forgotten all about that!
&gt; Also, if anyone's stuck on a Python version older than 2.6. True, but in that case, you’ll never see any GIL improvements either. ;-)
it crashes a lot here (ok, I'm testing on Debian etch using stackless instead of a real cpython) but when it works it's impressive!
Ha, didn't try with stackless yet. PyPy sorta runs, but a bit slow since PyPys ctypes implementation isn't as fast as the one from cpython.
&gt; I'm wondering if you're getting downmodded for emacs or the use of print statements. :-) The wisdom of crowds, I imagine. I like emacs because I can use it for many different tasks (I imagine vim is also good in this way, but I happen to use emacs). I have a friend who loves his IDE environment and is all the time single-stepping or another debugger activity. Sometimes that's handy. But he needs a separate tool for each thing he does, and he's always got to upgrade to new versions, etc. Anyway I've tried a bunch of things and I like the robustness of what I have now.
To me having to resort so much on the debugger when writing Python code means there's something clearly wrong in your program. Unless you're writing specialized C-extensions. Personally I'm not fan of IDE like because I get lost in the maze they can become and also because more than often I need to write code with a X client available. emacs or vim are then really a prime.
This is the million dollar question. It led to a [horror story](http://arstechnica.com/open-source/guides/2009/03/how-to-deploying-pyqt-applications-on-windows-and-mac-os-x.ars) on Ars Technica last time I looked for the answer (on how to distribute applications to people not having either Python or Qt, that is), so the unfortunate result of that is that I currently don't develop in Python and Qt. :S I have little doubt it's among the best Python platforms for UI out there though.
Excellent reply. Comments like this are what make reddit valuable. Thank you so much for taking the time to elaborate such a nice reply.
Unfortunately for people looking to distribute their code as some sort of packaged executable (py2app), the MacPorts environment makes it very difficult. I've been using the MP python for the last year and only one of my 3 machines was able to successfully compile with py2app under 2.5, none under 2.6. Then I took a leap and installed everything under the Python.org python (numpy, scipy, matplotlib, wxPython) and had absolutely no problems.
Oh hai sheep, my favorite library is [ one of the most popular gui libraries ]. You should use it because [ vague description ]. 
Yeah, BitTorrent is definitely no longer the handsome Python poster-child it once was (aesthetically, it never was, but the importance of coding styles have since been emphasized), but it immediately came to mind when looking to satisfy concurrency, configuration, and multiple interfaces. And let's face it, BitTorrent changed p2p forever and must be revered. [Mercurial](http://mercurial.selenic.com/) comes to mind as one of today's pretty Python candidates.
I'll grab my setup when I get into the lab. We look similar. Let me add a little complexity to the whole situation- two different machines, same exact specs, patched up, etc. One compiled/built without a hitch. Other was nothing but trouble. My laptop (mbpro semi-recent vintage) was also nothing but trouble. So, I'm suspecting that I have some ideosyncracies on those two (environment vars, paths) that are causing issues. I'm going to make virgin accounts on both and see if I can build. Thanks for the help- I'll keep hammering at it. I've had excellent luck w. Macports in the past and it seems to keep getting better. 
I've done a lot wx UI building and I recommend a simple ui designing app called [wxGlade](http://wxglade.sourceforge.net/). It's free, written IN wx.python, and kinda gives you a head start if you're going to want to create semi complicated nested UI elements and classes containing lots of widgets. It saves a lot of time messing around with sizers. 
It depends upon what you call painless and what you are developing for. The Mac is a great platform, but comes extremely short with respect to any sort of package management. Let put this as kindly as I can Mac Ports sucks royally, it is a great disappointment. So if you can install the software you need easily then Mac is an ideal platform. As a side note there is a lot of open source software available for the Mac outside of Mac ports. Some in tarballs and others in Apple disk images/packages. Aquamacs, GVIM and Eclipse all are a snap to install. Each has a varying amount of Mac'nest to it. 
Sounds good. I suspect it might be gcc; I would try wiping your macports directory (/opt/local/) if you can, then reinstalling macports, selfupdating macports, installing macports' latest gcc, then py26, then scipy. You might be able to just get away with cleaning your portfiles, configs &amp; build directories, but wiping the whole thing is probably faster. Also check your .profile or whatever your shell uses and look for anything unusual. If you need me to test anything, let me know. 
Yea get mad and downvote me. First of all, this question belongs/been asked on stackoverflow. Second, Do you want your mystery GUI app to look like other OS X apps? I assume so, otherwise why would you mention OS X. In that case, use the Obj-c bindings. Third, Do you even have an app in mind? Or are you just learning python and figure, what the hell, you'll build just build a pretty gui that does nothing. It doesnt matter what GUI library you use if your app is pointless. Fourth, fuck mckinley! 
having full control over the build components significantly reduces maintenance overhead.
Cool, but I actually think that clumsy regular expressions in python is a feature, because it encourages you to consider a different solution first.
Some good things in there. Wasn't aware of NetworkX, it looks good.
Yep- my gcc is defaulting to the Xcode-supplied 4.2.1 Now, I built and installed gcc 4.5 with macports (gcc45) but there are, curiously, no 'gcc' executable / symlink in /opt/local. The actual compilers look to be there (gcc-mp-45 and friends), but I suppose there's some special voodoo to turning them 'on'. edit- Duh- gcc_select... duh duh duh... duh. duhhhhh duh duh duh.. Now building. Turns out, at some point, some evil evil bastage of an installer installed a gfortran in /usr/bin . You know, that place that's supposed to remain pristine, etc etc. I will find this and crush it. Thanks again for the pointers. 
&gt;In general, is the MVC theory similar to object oriented programming? MVC is a set of principles for organizing your code. Separating code that does the work (Model) from the rest is considered a good idea by pretty much everyone. The separation between "View" and "Controller" is of lesser important to those who are not following strict dogma. :) OOP is a set of tools to help you organize your code. OO is a convenient way to do "modelling", i.e. creating the Model. You'll notice that good OOP code generally doesn't try to put everything in a class (except where the language forces it). In particular, you'll notice that my example uses ordinary functions to communicate with the user, and only creates a class to "model" the Scoreboard. Even this gains little, but I did it this way to illustrate how the techniques work. OOP in general is a very tricky thing to define, and lots of very wise people disagree with each other (if not themselves!) about the details. It's important to realize that it's not something you either use or don't use. A language can **support** OOP techniques to varying degrees, and support other sorts of techniques to other degrees. You can mix and match. IMO, one of the strengths of Python is that it offers decent support for a few of these techniques, and doesn't get in your way when you want to combine them. :) &gt;If it has no return, will this stop the loop in playgame because no round\_winner was returned. In Python, functions always return something. By default, they return None, a placeholder object meaning "nothing really here". Its truth value is false: i.e., code inside a 'if None:' block will never execute.\* In the loop where play\_round() is called, the resulting None value is assigned to round\_winner. By the above logic, 'if round\_winner:' tests as false, so the score is not updated. The loop continues until its condition is not satisfied, or until it is explicitly exited (e.g. with 'break', or because an exception is raised). This is how loops work. There is no 'break' here, and no reason for an exception to be raised. Thus, the loop continues 'while not scoreboard.winner()', i.e. for as long as scoreboard.winner() tests as false, i.e. *until* scoreboard.winner() tests as *true*. If we look at the definition of the winner() method in Scoreboard (the class that scoreboard belongs to), we see that it returns a string (identifying the winner, and which will test as true) when there is a winner, and None (which will test as false) if nobody has won yet. Thus, this loop continues until somebody has won (at which point the method returns a string, instead of None, and the string tests as true). Incidentally, in Python, every string tests as true except for an empty (zero-length) string. In general, objects that have a "length" test as true whenever that length is non-zero; objects representing a numeric value test true whenever the value is non-zero; and other objects test as true as long as they are not False or None. &gt;I think I just need to learn how to separate calculations from data storage, etc. It takes practice, and examination of good examples. Oh, and thinking about details. Try to make each variable name the best you can. The goal (seldom realized!) is to make it possible to understand the code in detail, without putting serious thought into it, and without writing comments. :) Even paying attention to your output text (capitalization, spelling, punctuation, etc.) makes a difference; it might not affect the program logic, but it trains you to examine things precisely. \* This is not exactly true because None is not a language keyword, but a name for a built-in, global variable. The language defines a type called NoneType, and creates one value of that type ahead of time, and stores it in the global variable None. Thus, you can re-assign None to refer to another value. This is a bad idea, however, because it's confusing and unlikely to accomplish anything.
I've actually done a bit of coding with EXIF data in Python. I found that the [pyexiv2](http://tilloy.net/dev/pyexiv2/) library was great for working with tags, perhaps even a bit cleaner than PIL. I used it to make a cute little script that transforms geocoded images to a KMZ file without going through any online systems (eg Flick or Picasa). Have a look if you're interested in the geocoding side of EXIF: [exif2kmz](http://www.awblocker.com/exif2kmz.tar.gz) It's under GPL 2.0.
I should probably also comment on this: &gt;In my understanding of your version, you generate the computer's move as a choice of the keys in winning\_moves. Right; the keys of winning\_moves are the legal moves. Notice how they are assigned to a variable called legal\_moves. This accomplishes two things: it allows referring to the legal\_moves in more than one place in the code, and gives a name to the concept. (In real code, I would not have several lines of comments there, because it is clear what legal\_moves means, and the reasoning as to "why do the keys of winning\_moves yield legal\_moves?" should be clear to anyone who actually needs to care.) At the same time, notice that legal\_moves is a local variable while winning\_moves is a global variable. This is a question of *scope*: the legal\_moves are only needed in this function, so they are only mentioned there. This is another aspect of proper code organization. In general, you should avoid global variables, because they make it very easy to lose track of what is going on - especially if you allow changes to those variables. In my Python code I set a rule of thumb to use globals only for "constants", i.e. to provide data that's fundamental to the definition of what I'm doing, and which doesn't change. In a car racing game, "acceleration of the player's car" is a poor choice for a global variable. Even "the player's car" is a poor choice; instead, pass it around as a variable. (Notice how the scoreboard is passed around in this code rather than being a global.) "Acceleration due to gravity" might be a good thing to remember in a global, though. On the other hand, if you're making a space trading game, maybe "Acceleration due to gravity on the player's home planet" is not such a good choice, but "The universal [gravitational constant](http://en.wikipedia.org/wiki/Gravitational_constant)" might be something that needs a label and global access. &gt;Then, you check and see if the computer's move is the key to the human's move's value to see if the computer won The other way around. Dictionaries are listed as {key: value}. The 'key' is the thing that gives you access to a value; you can think of it as "unlocking" access to the value filed away under that key. In my dictionary, the key is a move, and the corresponding value is the move that beats the key-move. So if the computer won, then looking up the human's move (i.e., using it as a key) will result in the computer's move.
Brilliant lineup. As a cognitive science student, I'm constantly modeling human behaviour. As a human, I love python.
Glad this list still resonates with researchers. I have added an addendum to the bottom of the list promoting the [Enthought distribution](http://www.enthought.com/) of Python, which includes most (maybe all) of these packages in a single distribution.
[igraph](http://igraph.sourceforge.net/) works better for large networks than does networkx. Though I slightly prefer networkx's interface, I use igraph due to its better performance on the networks I work with.
The book - in this version and previous versions I've seen - would be better titled "Java Patterns and Idioms Translated Into Python". For example: * the Factory chapter doesn't notice that Python already has factories - the class itself, which is a first class object that you can pass around and which will create an instance when called. * The Observer chapter doesn't mention PyDispatcher, or the important 'weakref' module. * The Iterator chapter is an obvious hangover from Java. * The Singleton chapter doesn't notice that a Python module is already a singleton - the singleton pattern is just "from foo import my_func". Or you can do "MyThing = MyThing()" to ensure uniqueness. * The Messanger pattern is basically unused in Python, due to tuples and dicts (and namedtuple in Python 2.6 and later). The version he supplied does not even prevent any typos, which would be the main advantage over a dict. For more complex needs when implementing/using these patterns, you would look at Zope3 before rolling your own solutions. In it's current form, the book is of no value IMHO. 
sadly no
I have no idea, I've never used wxPython.
Did you notice all the numbers on the list are 1?
http://sphinx.pocoo.org/ or any of the other pocoo projects are very good in terms of code quality.
Why do you say that?
Is wxGlade still being actively developed?
this is an amazing explanation...you sir, are a scholar and a gentleman...I'm picking up python as well and critiques like this help with my thought processes for when I'm coding as well.
no love for NLTK?
pyexiv2 wraps the C++ exiv2 library, and has good coverage; the one flaw I've found is that the C++ lib can handle in-memory images, and the python wrapper only has a simpler file-based path.
There is also [Pyjamas Desktop](http://pyjd.org/) which uses pyjamas to build desktop applications
Why is it that IBM always has the most interesting articles on the real meat of anything technical? No fluff. No filler. Just line after line of something very useful. Thank you for posting this. I wish I can upvote this thing a thousand more times.
[mxDateTime](http://www.egenix.com/products/python/mxBase/mxDateTime/) is quite useful for any time-stamped data sets. Finally, for any experimental studies (e.g., perceptual studies), [VisionEgg](http://www.visionegg.org/) is highly recommended.
Something that has floated through my mind recently is The way Apple hss done GCD. The thought being that Python adopt a similar model. In any event my usual use of Python isn't that demanding. So the GIL isn't a problem now. Also the comments about proceesses can make sense for some applications. 
I think im missing the point and cant't think of any use cases for this. If you're going to use redis only to get a counter, then I think you might need to look at your design again. 
Opinions, everybody has one along with something else. Mine is this stay away from Mac Ports, unless it has changed drastically since mid 2008 it is a mess, poorly concieved and at time counter productive. The biggest problem I see with Mac Ports is the installation of way to many duplicate apps &amp; libraries. There are of course good reasons to do that, your case being one. It is entirely another thing to create a distro of libs and libraries that aren't even compatible with the system you are targeting. I hope everybody sees the distinction here. Now I will get off my soap box. I should point out that I don't use Python or My Mac in general the way you do for Scientific work. So take the following with a grain of salt. 1. Get your base Python distro from www.python.org. Or build it from sources there. 2. Building open source software for the Mac can range from easy to very frustrating, but I'm convinced that it is getting better every month. The one thing Mac Ports can be useful for is finding out what special build settings may be needed. 3. I haven't looked into homebrew in a long time, but back when the project started they seemed to be on the right track. So do look into it. Let's face it a properly run repository of code is exactly what the Mac needs. 4. Open source software with Aqua skins, views or whatever you want to call them. Look into things like Aquamacs and MacVim and other usefull software. Sometimes you have to look a little harder to find the ports but some are really worth it. HOWEVER you do have to think here, because sometimes it is not worth it if the app sits in the Applications directory. Especially in the case of things that may be callable by other apps or have useful shared libraries. 5. Even though you should install it, XCode sucks as a Python IDE. So you need to look into an IDE/Editor. I unfortunately haven't settled on an editor. I use Eclipse a lot because it behaves indentically on the PCs at work. The Python support you can add to Eclipse is actually really good, but you do have to carry all of the Eclipse baggage around. So I often float between Aquamacs, Macvim and even Idle. 6. Sometimes it is frustrating working with Apples software updates. Right now I have 10.6.3 installed and python reports that it is version 2.6.1 with a build date of Feb 11 2010. (Apple Build 5646). Beyound the fact that 2.6.1 should have been upgraded to the latest what exactly is the difference with this build? Bug fixes, update libraries or what, you don't really know. This is one of the reasons to build your own, you know what is in the mix. Maybe somebody knows where to look for this info but I don't. 7. If you do decide to DIY your Python installation I'd suggest that you start right off with building a script to build your installation. Mainly because you will likely be rebuilding more than you suspect as varios updates come out. You might want to look into SCONs for guidance. This however is a lot of work that is better handled in partnership with others. You might get a better payoff helping build packages for Python for the homebrew project. That is limit your effort to maintaining SciPy and associated software for a distro or group of like minded users. Hopefully this is coherent and doesn't sound cranky as I just put in a full day. Basically what i see as most important here is to stay away from Mac Ports. Second the DIY approach may take a lot more time than you imagined. Third there are a number of interesting third party open source ports out there, just be careful about apps and that install method. Dave 
It does not appear that way on my browser. What are you using? Anyone else seeing this behavior?
Except for you can have multiple machines accessing the same counters, which without redis would be annoying at best to implement, especially atomically. 
Why use [uniqueID]? 'small\_counter', 'medium_counter' etc is the ids of the counters. Better to use multiple keys if you want more data than the value: counter:[ID]:value counter:[ID]:label EDIT: I have no idea why I'm downvoted, am I wrong? If someone thinks so say that, I don't think there's any point in having two ids in one key. Try to prove me wrong.
Sorry, I'm using the Opera 10.50 linux beta, so it might be broken here (I just figured it was more likely that you added &lt;/ol&gt; tags by mistake so I didn't check). It does appear correctly in Chrome, sorry about that.
this is begging for pythonic syntax: &gt;&gt;&gt; my_counter.increase() could override `__iadd__` &gt;&gt;&gt;&gt; my_counter += 1 instead of mycounter.read(), override `__int__` to get int(my_counter) likewise for the Comparison class, just override the comparison special methods.
I second your comment. Besides that, the author also forgot to mention that pure-python tools are limited to JPEG files (no Camera RAW support) and offer no write support for metadata (e.g. to fix a bad timestamp, geotagging,...) Yeah, no other metadata tool comes close to ExifTool regarding tag knowledge. But embedding ExifTool in Python is cumbersome, especially on Windows, because it relies on shell calls and parsing responses. Also the write performance of ExifTool is multitudes slower than pyexiv2. So the ideal thing would be pyexiv2 with ExifTool's tag knowledge. You won't have to parse Perl to accomplish that. Newer versions of ExifTool can dump out their tag translation tables as XML (i think with the -listx option), you'd only have to parse them and integrate them in your pyexiv2 class. Thus, you would be able to recognize more lens types than pyexiv2 can do by default.
i think this is fixed in the brand-new pyexiv2 0.2.0
If you want to make nice Mac apps, PyObjC is built in and has some support in XCode. I'd strongly recommend learning that as you'll need Cocoa anyway to make compelling apps - if you want to see how far this can be taken, there are some commercial apps demonstrating nice native GUIs: http://www.checkoutapp.com/
I was thinking the same thing. Could also use `__cmp__` on the Counter object for sorting purposes: counters = [Counter('a'), Counter('b'), Counter('c')] counters.sort() counters.sort(reverse=True)
Worst. Syfy movie. Ever.
I had partly wanted to make it excessively verbose (and the code excessively obvious) for non-Python people to play with (there are a lot of Redis people that don't know Python); but in the end I agree. Will push the changes today.
I still puzzle that this is an argument worth having. There are two reasons I use Python and push it (successfully) on my coworkers: 1. It is easy to learn. 2. Rich variety of third party libraries. I need to get work done and I've got better things to do than write my own Excel file parser. Energy spent attacking Ruby or defending Python could be put to better use.
Ruby was brought to popularity primarily and singularly by RAILS. Without it nobody would even know what Ruby even was. Python came up to popularity through...well, its own merit really. Feel free to argue with me but the numbers of people using each language and the growth of each gives a pretty clear view of things.
I'm confused as well, considering the blog post features no advertisements around it. Usually people post flame bait for page views.
I like Python as much as the next guy, but I really hate that the stdlib is held on such a high pedestal. Yes, it's amazing and can do almost anything. But Ruby can too, you just have to find [one of the many gems for it](http://rubygems.org/search?query=excel).
Agreed - and Rails constantly changing syntax and structure, with reckless abandon for backwards compatibility have kept me from giving it a serious look as well. I just find it hard to take a framework seriously, or even spend a significant time learning it, when entire tutorials and books are rendered obsolete between minor releases.
That doesn't mean Ruby can't stand up on it's merits. Nice appeal to popularity there too.
I've used Python for about 3-4 years full time professionally and Ruby about the same. I like both. It would be hard to choose one and only one forever. I like Ruby's blocks and Python's functions as first class objects. I dislike Python's meta programming and dislike Ruby's bigness. If I had to read someone else's code I want it to be Python. If I'm writing a very dynamic application, like a framework I would want it to be in Ruby.
Agreed. I use Rails and Django professionally. Rails needs to stop with changing the world every 6 months. I seriously find it hard to keep up sometimes.
So ruby is prototypical like javascript? When I did a crash course on Scala, I thought that creating your own operators was dumb, but I guess it is a pretty decent thing to be able to do. Maybe ill learn Ruby one day
To be fair I really wish standard python distro would just dump Tkinter for wxPython already.
I'd hate to see his opinions on Java.
Rails 2 was released almost 2 1/2 *years* ago.
You could try: http://ikanobori.jp/storage/bpython-latest-win-unofficial.tar.gz Which currently looks like: http://i.imgur.com/n5rsO.png http://i.imgur.com/TQR5Y.png In very very alpha (read some things suck), just as the previous. I might blog about it someday soon-ish with more installation instructions. One common thing is you can't yet get the pastebin url in your clipboard or select it from the statusbar, you have to manually copy it by typing it over ;-)
&gt; the numbers of people using each language and the growth of each gives a pretty clear view of things So VB &amp; PHP &gt; Python?
Awesome, thanks! I'll let you know if I come across any major bugs.
What a fascinating field. Is there anything that you can point to as examples of cool analysis that has been done in python? or second-best, cool analysis that should be done in python?
VB serves an amazing purpose when it comes to making front ends to databases, so I can see why it's use is high and climbing quickly (it makes it easy for any idiot to code a database front end). PHP has its uses as well, so...sure. My argument was tended more at languages with a similar feature-set in this case though. I thought that was pretty obvious.
Not at all. Your assumptions are: * Python and Ruby programmers form an informed group (as stated). This is clearly false. Many from either side don't know anything about the other except prejudices. To be fair, for all users of either to know both is too much to ask of people, so I don't, nor do I assume they are informed. * That the users of the more popular don't have significantly different requirements from your own. To be clear, this whole thing is obviously a matter of opinion. Just because I have a different opinion from the majority, doesn't make me wrong (nor, of course, does it make me right, because, as stated, this is a matter of opinion). Appeal to popularity can only be used to argue things implied directly from the fact something is popular. There are reasons you'd want to do this (for instance, bigger community, more potential employment). It cannot be used as a general argument to conclude, "One should use x over y". It is a well known reasoning flaw. I will not patronise you with a Wikipedia link.
The output isn't complaining about the regex, it's complaining about the urlopen. Do you need to import a package at the top of your script (or whatever the python equiv. is)?
1) You will have to do from urllib2 import urlopen 2) Use [Beautiful Soup](http://www.crummy.com/software/BeautifulSoup/).
http://codespeak.net/lxml/parsing.html#parsing-html
+1 for Beautiful Soup, it really is quite amazing once you get used to the syntax.
http://www.reddit.com/r/Python/comments/bkr7i/python_vs_ruby_a_battle_to_the_death/c0n9xq5
I know, there is way more code. I posted just a snippet to provide context because I thought this would be simple enough for some of you gurus to glance at and see what dumb mistake I made with the regex.
I know, there is way more code. I posted just a snippet to provide context because I thought this would be simple enough for some of you gurus to glance at and see what dumb mistake I made with the regex.
I know, there is way more code. I posted just a snippet to provide context because I thought this would be simple enough for some of you gurus to glance at and see what dumb mistake I made with the regex.
but if that's the error, then it's not the regex causing it. Look at Breeze99's post if you haven't got that it would explain the error.
I'm not quite sure what information you're looking for but if you want to know the the functional scope of a web framework, e.g - django being a full stack then I'd have a look here: http://wiki.python.org/moin/WebFrameworks Generally speaking though, Python frameworks be it template engine, server, ORM, etc are quite independent and pluggable of each other so you can mix and match e.g CherryPy serving requests, with a Mako template system and SqlAlchemy ORM. It's up to you to decide whats best for your needs.
Wow, you folks must get a lot of complete beginners here because I was hoping for *some* credit. The error is that the groups aren't returning anything (group(whatever) is null), so clearly the regular expression is wrong. I was hoping someone would glance at it and say, "Hey you fucked this part up." Obviously all I am going to get are people telling me to use other tools I don't even have nor will I be downloading. Guess I'll just hardcode the values as they are now. The expression debugs fine if it were a Perl one, but I couldn't find a reliable online regex tester for Python.
Are you kidding me? How do you suggest I use a simple string find to pull out a value on an HTML page that is going to have changing values in an html tag that looks like 50 other tags in the same code. It would be as ugly or uglier. I shouldn't be too snarky because I didn't fully explain the use case, but the request was pretty simple: I *know* the regex is fucked up, anyone see what is wrong with it? Not: hey, how would you have coded this using third party modules I can't even install in the environment in which this will be used?
Would you kindly...
Do you revise everything you write yourself (in English)? I highly doubt it. Sometimes you make stupid mistakes you can't see yourself, sometimes even when you know there is a mistake there. That is all I wanted (someone to "proof" the writing) and I said it plainly. 
Using BeautifulSoup you could do this from urllib2 import urlopen from BeautifulSoup import BeautifulSoup as BS URL = "http://www.bls.gov/news.release/wkyeng.t01.htm" data = urlopen(URL).read() soup = BS(data) w_th = soup.findAll('th', attrs={'id':'cps_qearn_a01.r.3.1'})[0] w_elements = w_th.parent.findAll('span', attrs={'class':'datavalue'}) white = [item.text for item in w_elements] b_th = soup.findAll('th', attrs={'id':'cps_qearn_a01.r.3.2'})[0] b_elements = b_th.parent.findAll('span', attrs={'class':'datavalue'}) black = [item.text for item in b_elements] print white print black This will give you the output of: [u'85,378', u'79,964', u'748', u'763', u'339', u'341'] [u'12,593', u'11,530', u'593', u'629', u'269', u'281'] To me this is easier than dealing with regex. Also, see this ( http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags ) for a discussion on why you shouldn't use regex for parsing HTML. If the HTML you are processing is well formed (in this case it is not) you can use the python lxml library. With lxml you can use XPath to select the elements/data you want. 
It's not surprising to see you downvoted, grimboy. Argumentum ad populum and fanboys go hand in hand, and it's *never* a fallacy when applied to whatever their cause is.
Not sure what the point of Expose is; if all you want is to be able to switch between Windows fast, then may I suggest [binding keyboard shortcuts to the most frequently accessed applications](http://superuser.com/questions/97149/fast-window-switching-without-alt-tab-or-command-tab/97153#97153)?
Using a stdlib which is pretty much standard wherever it's used or running around assembling the right mix of gems whose authors never seem to think about backwards compatibility. Difficult choice.
Skip the talk but by all means read the comments.
The error you have pasted is: Traceback (most recent call last): Line 1, in &lt;module&gt; dlsHTML = urlopen('http://www.bls.gov/news.release/wkyeng.t01.htm').read() NameError: name 'urlopen' is not defined
If you are saying that you only paste in the code and the site actually runs the code and displays the output, then you should have made that clear. I didn't know about this site and it looks like you pasted both.
Thanks for the update.
I didn't paste in an error, the clipboard site I used put that in because it tried to run it (I just used the first one I found so it would be formatted). I fixed the problem, I was just being too liberal trying to remove things. +1 for your time anyway.
That is what I am saying, I didn't know either. I just used the first one I google'd.
ooh, indeed, from http://tilloy.net/dev/pyexiv2/api.html classmethod from_buffer(buffer) Instantiate an image container from an image buffer. (0.1.3 is the latest I'd found in debian/ubuntu.) Thanks for the pointer.
You're welcome?
Wait... so you use Django and complain about *Rails* changing the API constantly? The same Django that was on 0.96 for over a year, and even minor releases deprecated API calls? The same Django that changed the name of one of the most used Model definition calls between 0.96 and 1.0? The same Django that wrote its own ORM instead of using SQLObject or SQLAlchemy, and can't do simple things like name indexes? That Django? Note: I don't hate Django. Their development roadmap simply baffles me.
Personal preference: not allowed in this day and age.
Most Python web frameworks are fairly independent of each other. There are a few (TurboGears, Pylons) that take several independent packages and combine them together. Where as say Django has all custom parts. All web frameworks have to sit on a web server. Most frameworks include their own, but most frameworks can use most servers thanks to WSGI. There are also micro-frameworks which don't have all of the features of most frameworks, but are nice for simple projects. When doing web development with Python it has been my experience that you will need to use or create your own framework for any non-trivial website (in this case trivial means "Hello World"). I don't know how familiar you are will all of the parts of a "full stack" so I'll toss out a few examples. Your average full stack framework might have a web server for handling the requests, a routing system for calling the proper function or page depending on the url, an Object Relational Mapper (ORM) for abstracting the database, and a template system for putting the data into the HTML. Generally speaking when you choose a full stack framework you do so because the framework does much of the work of joining those parts together. However, as zeroelixis pointed out you can mix and match the parts to basically make your own framework.
Web applications consist of multiple layers. At the lower layer you have the web server. All modern Python web frameworks talk to the web server using wsgi this makes the web server somewhat interchangeable. Django, Pylons, TG, CherryPy, web2py, web.py they all come with some pure python web server for development purposes. Which one it is complicated because of the versions. For example TG1 and web2py &lt;=1.76.5 used the same web server as cherrypy (wsgiserver) but TG2 uses the same as Pylons (I think) and web2py &gt;1.76.5 uses Rocket. Tornado is a non-blocking web server (i.e. it does not achieve concurrency by spawning threads, instead it does it by calling IO functions when the socket is ready) and this makes it fast when you have many small (computationally speaking) http requests. Because of its nature Tornado does not work out of the box with web frameworks not designed for it. Above the web server layer you have the dispatching. The code that maps url paths into function calls. Each framework has its own and conventions at this level are what distinguishes most of the frameworks. Above that there are libraries to deal with specific protocols, an Object Relational Mapper (ORM) or Database Abstraction Layer (DAL), and template language. Here is where framework can be divided in two categories: glued and full stack. Pylons is a glued framework. It is designed in a very modular way so that you plugin almost any ORM (although everybody prefers SQLAlchemy) and almost any template language (Genshi is the most common). Components are designed to be loosely coupled. TG can be seen as a specialization of Pylons. Cherrypy is also a glued framework because it is easy to plug and play components. Zope, Django, and web2py and full stack frameworks. You can still replace components but the standard components are designed to work together and you loose some functionality if you replace one. Zope comes with ZODB (an OOP database), Django has its own ORM and web2py has a DAL. Each of them has its own template language. I can speak for web2py as an example because I know it best. You can replace the built-in web server with cherrypy, Rocket, Paste, Apahe+mod_wsgi, cherokee+fscgi, etc. etc. You can replace the template language with Genshi, Jinja, Kid, etc. You can replace the DAL with SQLAlchemy. BUT. If you replace the template language or the DAL you loose some functionality in automatic form generation and processing. You loose it because that functionality can only exist with tightly coupled components and glued frameworks often do no have that kind of functionality for that very same reason. Supporters of glued framework tend to emphasize the ability to reuse code such as your existing database models (because of the choice of ORM) and templates (because of the choice of template languages). Supporters of full-stack frameworks tend to emphasize the portability of applications designed for the framework, since the framework is always the same for different installations. A lot of the difference is in the eye of the beholder and in the philosophy of the app developer. Developers who want to get their hands dirty and be able to customize everything will choose a glued framework. Developers who expect a framework to do as much as possible for them without need to look under the hood, will choose a full-stack framework.
Then waaaaay out front there are things to control layout and visual display... things like grid960, cross-browser css libraries, and toolkits for handling AJAX and cross-browser JavaScript. Think Dojo, JQuery, etc, which merit a question of their own.
The second one is slow because of the nested loops, and the third one from generators.
Massimo posting a perfect non-biased response with no web2py spam. I never thought I'd see the day. Why can't all your posts be like this one?
I still like my whitespace :P Interesting, though.
Seriously, it works as advertised (which means it *partly* works). YMMV though, and Python (and Whython!) is a slow compile.
&gt;# beautiful failure begins Not sure I want to try this, methinks it's a prank.
The ez_setup dependency is particularly frustrating.
With recent PyPy the case of euler 14 improved greatly (6s instead of 40s), while it's still 3x slower than CPython. It's a patological GC case here (a lot of fresh int objects living on the old object) and we're thinking about fixing that (for 1.3 probably).
So, at the Facebook Programming Puzzles (www.facebook.com/careers/puzzles.php) they must haves some way of neutralizing the threat of running untrusted Python code. I wonder if some multiversion pypi buildbot could be build that would be similarly sandboxed.
For simplicity, why not just sub-license SO itself? Also, a nicer Stats/Math focused one of these would be great. 
It's only an improvement in that it tries to fall back on code, if IPython isn't present. 
http://www.reddit.com/r/Python/comments/bfk55/enthought_is_building_a_stackoverflow_alternative/c0miram
I read your last sentence as: If I want to develop something that will continue to grow, I use Python. If I want to write something once to throw away, I use Ruby.
&gt; It’s not a real language without braces and semi colons :D
How large, and what kinds of networks? I'm curious because I've a had medium-ish (100k nodes, 1 million edges) with no problem on NX. 
You don't look like you actually listened to the presentation before you commented. It wasn't an argument, but a comparison of features — something that has been wanting for a long time because people like you either crap all over any discussion of characteristics by forcing everything into "Good" or "Bad" categories, or are too burned out from that to even consider that another form of discussion exists.
Here, have an infinite number of upvotes.
I would actually consider using this. I am writing a game in Python and want to have scripting as well, but with Python's whitespace I felt it was simply impractical for being embedded in a forgiving way in configuration files, so I started working with Lua (for the scripting part). Of course I'm not exactly making fast progress what with my day job and generally hectic life, so maybe this will be solid enough for me to use once I'm at that point. :P
Should be called *Whine*thon
For the people who think this might be a joke but didn't RTFA: **Why Whython?** * humoring trolls is fun * since this is unlikely to ever be adopted by Python (I hope!), it will remain a useful exercise * Help determine how bad a PEP/developement idea needs to be before someone gets kickbanned from #python-dev So yes, it's a joke. Sort of. It's more like testing the limits to see what you can get away with.
Why most definitely...
Actually, Django is suited for small apps as well. It will be easier for you to start with Django than Werkzeug where you determine the model and template stack. If you want something different than Django, there are always web2py which now has the official book put on line, and has very helpful wizards for creating projects.
This is redundant, the same feature has already been integrated into python3! Though the syntax is a bit different (using "," rather than ";" as the line ending). Unfortunately Guido's also read a few too many books on literate programming, so has mandated a docstring for every line, extending the ":" annotation used in argument parameters to allow every line in the new syntax to take a docstring style annotation. for ii in range(10): { print(ii) : "Print ii - note the mixed indent doesn't faze us", print("which is %s" % (['even','odd'][ii % 2])) : "display whether it is even", } All on one line is possible too, but the docstring per logical line requirement stands. (He relented a little and allows the shocked face ":0" smiley as an indication for no docstring: for ii in range(10): { print(ii):0, print("which is %s" % (['even','odd'][ii % 2])):0, }
There are also a plenty of small and tiny frameworks, like web.py (not web2py, which is a completely different beast) and bottle. Also there are lots of tutorials on building your very own framework using different libraries and batteries. Also I'd like to mention that grokking wsgi is very enlightening and rewarding thing. A good starting point is http://pythonpaste.org/do-it-yourself-framework.html, also you might have a look at http://werkzeug.pocoo.org/documentation/
I found Django to be a little complicated at first, but after a day or two everything became clear. Django is definitely worth trying, even if you're planning to create small apps. Bottle looks great, though i'm not sure about the documentation. It's been already mentioned here, but you should check out web.py.
+1 for the "do it yourself framework" that's essential reading for anyone doing web dev with python. lots of questions I see on mailing lists/stackoverflow seem to stem from the lack of understanding of how http works. Considering that you can read up on that in under an hour, there's just no excuse.
&gt; Somebody also suggested to try wsgi but it seems to be difficult for &gt; a new comer like me. [WebOb](http://pythonpaste.org/webob/) does a bit to take the sharp edges off of wsgi. Learning wsgi means learning http. knowing http is essential for web application development in any language(IMO). All frameworks do is abstract that away to varying degrees either for speed/convenience or to hide the "complexity" from the developer. This can be a good thing like for getting things done quickly and easily, but not necessarily for the purpose of learning web application development. 
Ruby is class-based, by default. Like Python. Also like Python, you can do crazy things to base classes at runtime...
You know nobody believes any claim today, yes?
Never tried bottle, but I've found Werkzeug to be well-designed and documented. It will help you to understand WSGI and there are good tutorials to help with things like adding SQLAlchemy and a template engine to your stack. Even if you decide to go from there to a more complete solution like Django or Pylons it's a good idea to start at a lower level so you get a better understanding of where and why everything fits together - and thus the decisions and tradeoffs that go into a full-stack framework.
But its trivial to verify that I'm right here! Try the above code out in python3 and you can verify for yourself that it works perfectly. The only restriction I forgot to mention is that it, because the feature is intended for programming in a functional style, it enforces a degree of functional purity: - mutable returnvalues are prohibited - Each line must be an expression, rather than a statement 
I couldn't fit that much text onto the logo! My other original name for it was CRython, and I made a wonderful logo for that, but in the end, it looked too much like CPython.
hmmm... it borked for me on a 50k node AS graph when I was testing it, so I can't rule out that I did something wrong.
Also check out bobo: http://bobo.digicool.com/ Basically just takes care of url dispatch and uses WebOb for request/response.
Strangely enough, we also use it for AS Graphs.... maybe you should look at joining us over at Renesys.com :) NX is just dicts underneath (essentially), so if your compy can handle a double-keyed (that is, each end has a key point to the other edge) dict, it should be fine. We tend to run with medium sized iron (4-8 Gb memory), so YMMV :)
If you want to learn how to do web programming in Python, I would suggest you Werkzeug. You will start with raw WSGI examples and only use Werkzeug in places, where you really need some help from library. After that, you can pick up some great framework like repoze.bfg ;-)
At first i didn't read it because i saw his username.
or P-- 
You're presenting your argument too scientifically. Trying to counter-prove a Python submission that, in all likelihood, is just an April fool's joke, takes more ironic subtlety. You're going to look silly taking the highroad on this day. **for example** &gt; lol, PyFail! Python3 has this feature built-in! What fun is this day for jokes! for ii in range(10): { print(ii):0, print("which is %s" % (['even','odd'][ii % 2])):0, } 
What the hell? It actually works! Why do we need a docstring for every line? It just makes lazy people's code uglier.
All I know is that igraph worked on my laptop, I didn't try nx on one of our servers. And I work for lgscout.com, I know that our people have had talks with your company about *something*. Small world :)
Isn't it true of any library? To use PyQt, you need to know Qt. To use wxPython, you need to know wxWindows. I mean, there's not magic GUI library that lets you use it without knowing it!
I thought it was going to be "Python for people who are Wil Wheaton"
newbies are going to just learn to finish all the lines with :0. Also it will be confusing when you have a for or if statement where the : is needed.
&gt; It wasn't an argument, but a comparison of features Filled with mis/disinformation. Look at #8 (3:00), for instance. There is no special case: Procs, lambda and methods all respond to `#call` and adding parens never calls a callable. The criticism is in solid WTF territory. And this also illustrates what's universally wrong with these "comparisons." People who would normally understand why they shouldn't get their information from FOX News suddenly wrongly believe that they can get accurate information from a Ruby vs Python presentation at a Python conference by a guy who has used Python for seven years and dabbled in Ruby mostly part time for one year.
Do you actively avoid reading documentation? Django was very up front about things changing before the 1.0 release. That's why they were at 0.96 for so long. Since 1.0, they've maintained one of the most conservative backwards compatibility policies around.
Thanks!
There isn't one, python db access has an interface that modules generally follow but it isn't portable across db engines. In the python world you generally use one module for your db engine (MySQLdb, pyscopg2, sqlite) or an ORM that can use them all like [SQLAlchemy](http://www.sqlalchemy.org/).
An unfortunate acronym if there ever was one. If there is an extension library, would it be called PDO-PEAR ?
Do you actively avoid reading comments? I specifically stated that I *don't* hate Django. I was just saying it's hardly the best example I could think of for a "stable" API, considering everyone and their dog was using it even back in the 0.96 days because they were tired of waiting *infinity years* before the API stabilized for the mythical 1.0 release. ;)
Werkzeug is equally a light WSGI wrapper, and so should be fine. But... no, learning WSGI does not mean learning HTTP. Learning WSGI means learning what subset of HTTP PJE felt wouldn't be too complicated to deal with, and then trying to figure out how to work around it.
yes the main 3 orm's would be sql object, deja vu, and sql alchemy
Noice.
How fast are they? Does the abstraction add a lot of baggage?
hmmm fast is relative, I think they are reasonable, but you would have to research that yourself as I am no expert in website databases. Just used them, but by no means on a very large scale.
&gt;an April fool's joke, takes more ironic subtlety Actually, I suspect at least one of us is being *too* subtle here. In case it's me, and I'm not being reverse-trolled here, I'll explicate. While the code works perfectly as advertised, my explanation is *perhaps* respecting the spirit of the day more than it does strict accuracy. What is *really* happening is a bit more obvious if you think about it.
Fortunately, an alternate syntax is provided to deal complaints about the first one, using non-curly brackets: for i in range(20): ( print("hello"), print(" world") ) For the second, this is prevented by applying the same restrictions as for lambdas. "`for`" and "`if`", being statements, are prohibited.
I am confused, I thought there had to be a :0 at the end of each line. Maybe I should just read the specs when I have time.
I like this.
Extremely useful guide for a new python user!
&gt; Werkzeug is equally a light WSGI wrapper, and so should be fine. did I say it wasn't? &gt; Learning WSGI means learning what subset of HTTP PJE felt wouldn't be &gt; too complicated to deal with care to elaborate?
Make sure you get that [DIY link right](http://pythonpaste.org/do-it-yourself-framework.html) (no comma!). There's also a [higher level tutorial using WebOb](http://pythonpaste.org/webob/do-it-yourself.html) and [a blog post about hand-writing an app with WebOb](http://blog.ianbicking.org/2010/03/12/a-webob-app-example/).
nice try april. nice try.
Know what's April Foolish? Heterocentrism and sexism among programmers.
indeed.
that's a bold statement
Not necessarily. Python's wxWidgets are fairly simple and there are several tutorials just giving it from a python perspective. PyObjC literally takes every single method name from cocoa directly, and maps them slightly awkwardly. You need to know a fair bit of cocoa before even attempting PyObjC.
pretty awesome couple of things I'd tweak ... $ source bin/activate before installing nose and coverage etc... after package creation $ cd foogis $ python setup.py develop to register the package you are writing 
I am learning. ;-)
Yes, The Python "db-api" means that except for the "connect" function, all DB modules generally act alike and are basically interchangable. The only thing it does NOT handle are the SQL-level differences between databases. For that, you'll need an ORM, and as mentioned, SQLAlchemy is a great choice.
Do you run the programs "as is" with cython? If you are not using any type definitions when running it, then the benchmark for cython is totally meaningless.
Uhh, cython isn't mentioned anywhere on that page.
[apparenly it is.](http://bitbucket.org/agriggio/wxglade/)
Facepalm :( I drop the "p" when I looked at CPython ...
&gt; care to elaborate? WSGI does not expose all of HTTP, just a subset. Good enough (tm) for a lot of applications, but might not suit all. There were some efforts to expand what's possible but they did not end anywhere I think.
They could be ten times slower than using the DB-specific module directly, and it still wouldn't be within an order of magnitude of how long you're going to spend blocked on the socket waiting for the DB to respond, so I'd spend my profiling on the latter rather than worrying about the DBA layer. But in my experience, sqlalchemy itself (not counting the blocking on I/O) doesn't even come up in our profiling
The Topic is closed, and nobody mentions : [Recommendation against Python?](http://groups.google.com/group/unladen-swallow/browse_thread/thread/4edbc406f544643e/). I wanna to know "is there a NEW policy in November, 2009 that Google employees are being discouraged from using Python for new projects" or not? Edit: I must to say Alex Martelli is a priceless treasure to (StackOverflow) Python Community.
Well, I'm glad to see you watched it. Thought I was dealing with someone even less focused than myself, sorry for the censure.
Alex Gaynor (Django Developer) &gt; Denied is like nothing I've ever seen before, I think it's the future of the internet. Armin Ronacher (Werkzeug Developer) &gt; Probably the most hideous code I have ever seen. nice try april baby. you are getting better.
I'm a little surprised no one's mentioned some of the popular frameworks like Django, CherryPy, Pylons. Not exactly what the OP requested, but they might be better.
As a programmer you really should of built up your own small resume library already. If you're not prepared it's probably going to show. Good luck anyhow, get to coding. If it's an email you have plenty of time to reply, that's the purpose of email, it isn't a time-bomb, it's something you can reply to when ready. But...embedded systems? Python? I hope your talking ARM processor driven devices and not *real* embedded programming. If your talking about REAL embedded programming and you only know python then you're way out in left field, buddy.
The contact email is armin.ronacher+dontbelieveanythingontheinternet@active-4.com .
nah ! i have my c program files from my RTOS class and other embedded class which i have developed, to send, python is additional to it ! I am not able to think of, what exactly to program, so put it up here for ideas :-)
"single file" my arse.
Um... something you've written that you're proud of? You *have* written Python code before, right?
yeah, but basics ! to get used to it ! but not as a part of any projects !! like, getting used to dictonary, tuples etc.. give me some damn good project, which i can complete in next few hours !, so will do it and send it off !
Or you could just be honest about your qualifications.
SQLAlchemy is a more than an ORM, you can use it without any of the ORM features and still use it as a DBA layer. We use it this way at reddit
if i don't come up with any thing, that is what I am going to do ! but got time, so started to code up some thing !
If you don't know Python, you should send back a letter saying that you don't know Python. Probably accompanied by a "but here's some other thing I've written in that vein *(you have, right?)*, and I'm willing to learn Python".
Didn't web.py start this way and then slowly grow larger? Still, might be fun to play with when docs emerge.
You have a lot of good replies here but I have to ask why you don't use Idle on Linux? Especially if you where successfully using it before. Idle is nice and compact and simple thus good for quick scripts. Eclipse with PyDev is good plus they have other modes in incubation. Being Eclipse though it needs a powerful multi processor machine to feel fluid. Plus you can write an entire script in the time it takes to startup. On suitable hardware it is an excellent IDE especially for larger efforts. I've never been a big fan if EMACS, as it never fit my learning style and it really gets in the way at times. However on the Mac you have AquaMacs which is starting to change my opinion of EMACS. For a big IDE it starts up a lot faster than Eclipse. Then you have Vim/GVim/MacVim/WhateverVim that runs just about everywhere. It is certainly worth a try. In any event back to Eclipse for more involved projects that might include various source files I find Eclipse to be nice. Especially if some of the project involves the web. I suppose that EMACS could likewise be useful but I find Eclipse fits my mind set better. 
[Um.](http://github.com/denied/denied/blob/master/deny.py)
&gt; "Python where we can, C++ where we must" 
Can someone just tell us what the file unzips to? I'm too lazy to run it.
Recently, I started using Eclipse and Pydev for Python and Django development. Although I am a hobbyist, today I was very excited to read the announcement about the new Pydev release with Django integration on the Pydev maintainer's blog. 
Looks like werkzeug + simplejson + jinga2
Why not re-raise ImportError with a nicer error message? Rather than raising MagicImportError and breaking code that relies on ImportError, like.. try: import cSomeModule except ImportError: import SomeModule 
I use both PyObjC and PyQt, and I find PyQt as complex as Cocoa, if not more. The fact that Cocoa's documentation is for Objective-C doesn't make it more complex.
Sure - here's the [spec](http://docs.python.org/py3k/reference/expressions.html#dict) :-)
That's an interesting method of distributing source code.
These vague aspersions against WSGI aren't helpful in explaining anything. I'm very familiar with WSGI and we've talked a fair amount about stuff, but even I don't know what either of you are talking about. Chunked responses or requests? There's some process model and streaming constraints, but those aren't HTTP constraints, they are just constraints on the kind of application you can write with WSGI. If you don't feel like offering some details you might as well not comment at all.
jinja2 then.
[tarball of individual files](http://www.mediafire.com/?w1vk2jwj3ze)
Yes, what could ever go wrong with this?
&gt; These vague aspersions against WSGI aren't helpful in explaining anything Why is that a point against WSGI? I was just simply pointing out that WSGI is not a full subset of HTTP. &gt; Chunked responses From what I was told there are some mobile phones that require chunked responses and that WSGI is not suitable for that in the current iteration. Again, I am not saying that this is a problem but that's just how it is.
python_select -l
My point was that all a project can do is tell you their plan and stick to it. Any expectation beyond that is user error. Django is far from perfect, but few software projects are managed so well.
Well that's weird, i always thought they were a proponent of Python.
Has anyone played around with doing DB reads in seperate threads? Although I expect the program logic would finish waaay before all the threads.
Isn't it great? All this awesomeness in one file.
It’s an April Fool’s Day joke. It finds its own file, then looks for the line `if 0:…`. That line contains (off in the distance to the right where you can’t see it without scrolling) a BZIP of all the files for a normal framework.
Well I'm more looking to see what the current way that python acts with regards to databases is done.
Given that approximately eleventy quadrillion threads discussed it when that first came up, and that the original post there is pretty much just trolling (what seems like a reasonable policy of "think up-front about what the right tool for your project is" gets twisted into "OMG GOOGLE SAYS NOBODY SHOULD USE PYTHON"), is there really anything new you'd like to see brought to the topic? 
How about you 1. Do some Python tutorials and read up on how the language works (*especially* threading). 2. Give the [DB-API](http://www.python.org/dev/peps/pep-0249/) documentation a read. 3. Actually write some code and see how it performs. And then *maybe* I'll let you get away with thinking about how you might start optimizing. But that's a really really REALLY big "maybe".
like what specifically? I'm sure you are correct about the ENTIRE protocol not being implemented in wsgi, but I would like to know where the gaps are, and whether it matters.
Okay then :) Don't worry, I'm happy with being the bitch in learning this language.
The gaps are documented in the PEP, and I don't think it matters. At least I never had a problem with that.
Actually, it's basic inspired: for i in range(10): { 10: print(i), 20: print(i**2), }
Because these have nothing to do with what he was asking.
To really learn HTTP, I would suggest you actually start with CGI. This is actually quite easy - http://gnosis.cx/publish/programming/feature_5min_python.html Then think about all the ways that raw CGI sucks, and start to write some of your own wrappers (e.g. request and response objects that wrap up the CGI protocol). For one project for which I needed CGI and absolutely minimal supporting code, I wrote my own 'framework' - http://bitbucket.org/spookylukey/lukeplant_python/src/tip/lukeplant_me_uk/bibleverses/web/cgi-bin/lib/bibleverses/webutils.py Then move to something like Werkzeug/WSGI, and you'll appreciate what they are giving you.
That limit is yet to be decided, btw, if you feel like braving the Tygers there. 
OK after ripping through the PEP, the only thing I see is hop-by-hop headers and chunked transfer encoding which are fairly exotic if you ask me. So maybe I should clarify what I meant by "learning wsgi means learning http" let's take cookies as an example. And something like ASP.net as the application platform. Someone who starts off with ASP.net would learn that to access/set cookies. var user_name = Response.cookies("UserName").value; This abstraction might work just fine for the one web site scenario. But what if several websites were contributing to the content on a given page and you needed access to the username in the cookie that was set by some other service(domain). The ASP.net programmer that only knows the Response.cookies api, would likely be baffled, confused hopeless at trying to debug the problem if for some reason that cookie stops showing up. When if they knew HTTP they may have a fighting chance by knowing that the cookies api is merely an abstraction of the cookie header and how the cookie headers are supposed to work. Or I guess an even simpler example. "How do I set a custom page/message when the page is not found?" refer to the frameworks api or Return a response with the body set to whatever it is you want to display but make sure the status code is set to 404. Which is better I guess is subjective but in my opinion learning wsgi gets you familiar with that, and then you can better understand how the framework you choose is trying to help you and if it becomes deficient in some area you at least have a leg to stand on without having to ditch the rest of the framework you chose. Hope that clears it up.
This looks exactly like Bottle http://bottle.paws.de/ *Edit:* And then I looked at the code :p
google "quitting" python, exiting China....WTF ?!
And bottle looks exactly like cherrypy.
&gt; So maybe I should clarify what I meant by "learning wsgi means learning http" I know what you mean by learning HTTP, I just replied to learning the subset and explained what ubernostrum meant.
GreaseMonkey script for this would be cool. Saw a link from cshirky a while back that should conversations threaded. Lost the link though.
To be fair wxPython is a pile of unmaintainable crap that will probably never be ported to Python 3. There's a reason why PyQt4 didn't take long to port to 3.x while still keeping compatibility with 2.x.
I know it's a non-authoritative information, and the fact I use Python everyday already convinced me "IT CAN'T BE TRUE", but I still want somebody issue a firm denial of the rumor (or even confirm it) other than a rational analysis. indulge me.
If only we could get something with the quality of pydev that wasn't tied to the shit that is eclipse. I mean, I'm sure eclipse is wonderful for Java development, but for PHP an Python, it just.... feels so wrong.
I came in here to ask if "DENIED" was the name of a python micro-web-framework. Given the odd and bizarre names given to open source projects, I think this is a reasonable question.
Don't mobile phones do the chunking in a proxy? I don't believe a client can itself force a response to be chunked, though some people have used a kind of ad hoc convention that app_iter responses with multiple items should be chunked, so it's not impossible. For chunked requests, that's fine and several servers supply that, the only constraint is you can't receive the request until all the chunks have been received. There are some ad hoc ideas for using a missing or magic CONTENT_LENGTH to represent this state. Moving to a truly file-like object for wsgi.input would be nice though. Neither of these issues seems very substantial.
&gt; Neither of these issues seems very substantial. I hope I did not say they were.
You need the answer from the DB read before you can go on and do your computation with the result anyway, so it wouldn't gain much. I've played with generating thunks that do a web request and build a sort of structured to-do list so that you can do all of the DB requests in a single round-trip (and then finish the dependent computation), but in practice most of the computation is dependent so there are no parallelisation gains, and it only gains you anything if you're doing lots of DB hits is a disorganised manner, and if you're doing that, you'd gain more by changing that instead. (And if you're doing that, there's a good chance that some of the DB reads are dependent on previous ones, so it doesn't gain you anything there either.) And yes, if you have the hit the DB, just waiting on the DB will be 99% of your time spent. That's one of the reasons that things like memcached are so popular. Additionally, Python's threading is [terrible](http://www.dabeaz.com/blog/2010/01/python-gil-visualized.html), so if you're in Python, I'd avoid the threading in the first place, opting for [multiprocessing](http://docs.python.org/library/multiprocessing.html) instead
was a decision made how WSGI will handle unicode/bytes ? 
github "hides" the huge base64-encoded zip file. Virtualenv also use this technique for ages. &gt;&gt;&gt; cool_string = open('cool_file').encode('zlib').encode('base64') &gt;&gt;&gt; 'eJzLSM3JyVcoSk1JySwBAB5GBLE='.decode('base64').decode('zlib') 
Mercurial?
I didn't find the canonical documentation on this. Does it allow you to *not install* the MacPorts Python, or does it just change the default for MacPorts after they are all installed?
It lets you switch between which Python installation is currently active. It's a poor man's virtualenv, and it's saved me a lot of headaches. 
Impressive speed on that C version. The nice thing about using python is that it is easy and nearly seamless to integrate C modules. So when you do need the performance, you can regard your slow python version as a prototype, re-code it in C and drop it in as an instant high-performance replacement.
*nix OS? Use a cronjob.
What do you mean by automate tasks? If you want to do something at a particular time check out [sched](http://docs.python.org/library/sched.html) in the Python [standard library](http://docs.python.org/library/). Different operating systems also offer ways to run scripts at a particular time, like cron on linux. You will learn to love the standard library, if you have some free time sometime just look at some of the different modules, it's amazing what you can do!
Thank you sir for the help. I meant, i wanted to run my script every couple of hours to check for the changes and notify me. Some thing like that. I am trying to learn python and build a small project to run my script every few hours.
It sounds like you could be referring to something like a daemon process on a *nix system. Perhaps this helps: while(!task I want to be done){ wait x seconds } Your program will just sit in this loop until the condition you want is met. Then you'd write code to notify you outside of the while loop. If you need any clarification, let me know.
will try to look into it. Ty :-)
Yes sir, will do some work on it and will send you a message if in case i need more help. :-)
The URL shorteners usually just do a HTTP status 301 redirect to the actual URL. When you do Request.get_host() it's not following the redirect, just checking the host on the URL you entered. You have to use a method that actually opens the HTTP connection and follows the redirect: &gt;&gt;&gt; import urllib2 &gt;&gt;&gt; test = urllib2.urlopen('http://bit.ly/aUtW5B') &gt;&gt;&gt; test.geturl() 'http://richarddawkins.net/articles/5366' Check this out for more info: http://diveintopython.org/http_web_services/redirects.html
O_o. All that tinkering around urllib2 request and I forgot the basic 101 use of urllib2. THANK YOU SO MUCH!
For what you want to do, either use Cron on *nix systems or Task manager on Windows. Unless you want to learn how to daemonise the process / run it as a service the most efficient way to achieve what you are after is Cron / Task Manager.
Somewhat more efficient than urllib(2): &gt;&gt;&gt; import httplib &gt;&gt;&gt; conn = httplib.HTTPConnection('bit.ly') &gt;&gt;&gt; conn.request('HEAD', '/aUtW5B') &gt;&gt;&gt; resp = conn.getresponse() &gt;&gt;&gt; resp.getheader('location') 'http://richarddawkins.net/articles/5366' (More efficient because it doesn't actually follow the link, just gives you the destination back; use `urlparse` to split up the URL.)
I'm not that great at Python, and I bet there's a lot of room for improvement :P. But, I wanted to see what the results would look like.
Go with Werkzeug. It is a very well designed library and gives you tools for much more in the long run. And if you want you can make your own Bottle using it.
you know what? c is the most well engineered thing of all time.
Not to be negative, but...why is this interesting? Looks like pretty vanilla Python to me...
You've got your confirmation (as much as you're likely to get on what is, after all, internal corporate policy) in the original thread: Collin works for Google. And his comments there explain it pretty rationally.
Quick question - what's the memory usage like, compared to CherryPy? I'm not familiar with Rocket particularly. Thanks
I do not know about memory usage. I guess they are about the same. Early tests using ab suggested Rocket was slightly faster then CherryPy. More recent tests using better setup suggest that are about the same and CherryPy is faster with many processes behind load balancer (there is a thread on this in the web2py list). Yet we are committed to Rocket because it was written by a member of our community, we feel there is still lots of room for improvement, and the code is more modular.
Text-to-Speech?
Evolution is faster. [Here](http://dl.dropbox.com/u/30726/evo.py) is a old script I made that evolves a string. The code is really ugly. My current coding skills is way more l33t. I promise! Or at least they don't suck as much.
windows only ...
See [pyttsx](http://pypi.python.org/pypi/pyttsx/1.0) for the cross-platform follow-up.
See above, there was a fork of pytts called pyttsx.
I was totally expecting a build bot that automatically reports failed unit tests by reading them out loud.
Does anyone know of something similar but for a product such as Cepstral, that sounds more natural?
[Twisted](http://twistedmatrix.com)
*having* to write a class to have the test runner catch it is silly, and violates the "We're all adults here" mentality of python. Convention should be enough. 
While I admire the writer's intentions and that he tested his ideas, taking this approach to working in a high level language can only lead to harm. Aside from being a highly implementation-specific detail, a single CPython bytecode can and often does result in entirely unpredictable arbitrary computation, such as calling even more Python code (eg when using ADD on an object with overridden __add__). Benchmark your code at a high level, and make high level changes to improve that performance, but measuring opcode counts alone tells you practically nothing
if your goal is to make a native looking / behaving OS X app your only real choice is to go with PyObjC and Cocoa. Any other framework will produce GUIs that are instantly recognizable as non-native. 
I've improved it: http://banter.caseybanner.ca/
I think the key to being able to integrate many pieces into something bigger lies more in how you interact with the pieces than the pieces themselves. Whether or not a module is implemented in a pythonic manor is irrelevant as long as its interface to you is simple and well defined. Most of the python types are written in C anyway, so clearly the implementation isn't as important as the API. If one of your applications had to do something like download documents from an http server, and the module you had to do http requests was used like: c = HttpClient() c.set_protocol_version(1.1) conn = c.connect("http", "reddit.com", 80, r = HttpRequest("/") conn.send_request(r) data = conn.get_response() and every time you needed to do an http request, those lines were repeated, your app would become an unmaintainable mess. Just concentrate on making sure every module you write does only one thing, and does it right, and keeping things simple from a users point of view. Edit: Just found a good example of this on r/python: http://mike.axiak.net/python-bloom-filter/docs/html/ A nmap backed bloom filter is somewhat complicated, but since the module has a sane(as well as pythonic) API, you can use one in 6 lines of code. If you have a lot of small modules that are very easy to import and use, you'll be making more complicated applications in no time.
I'm an experienced game developer... I think your code is nicely written, but here are my critiques * Move handleLogic/drawGame into the game class. Otherwise, what purpose is your game class serving? * Try to get some of the core configurable things out of your engine file. Like for example the window caption could be moved into constants.py, which fonts/images/sounds to load could be part of game.py or even gamedata.py (or hell, determine them by scanning the data/ directory!) * Re-evaluate your use of pygame.time.Clock(). I *heavily* advise against using it. Here's an example of how I write my games: def gameLoop(): lastTime = now() while Running: curTime = now() deltaTime = curTime - lastTime updateLogic( deltaTime ) lastTime = curTime ## optional setting if options.lockFramerate &gt; 0: ## a setting of 0 means don't limit framerate perFrameTime = 1.0 / options.lockFramerate deltaTime = now() - curTime ## account of game processing time if deltaTime &lt; perFrameTime: Delay( perFrameTime - deltaTime ) def updateLogic( deltaTime ): playerPosition += playerVelocity * deltaTime The idea here is to make your updateLogic framerate *independent* 
How not funny was that April fools so called joke?
Thank you for your input! &gt;Otherwise, what purpose is your game class serving? The idea is to use the Game class more of a settings class. If I'm going to have the logic/draw blocks in Game, then I might as well either have Game in main, or more likely, have all the instances of players, environments etc. in game, but then your Game becomes a full class just for that game; single-use instances shouldn't typically be in a class. If I'm going to do game=Game();game.start(), I might as well have everything in main. &gt;Like for example the window caption could be moved into constants.py That's true. Right now my idea is to keep constants uncluttered so as to be easily modified by non-programmers; adding yet another layer of obfuscation (scripts -&gt; constants -&gt; init of game class -&gt; eventual command line arguments -&gt; main class... lots of places where you can (mis)place code) is something I'm thinking off. It's hard to please everyone. &gt;Re-evaluate your use of pygame.time.Clock() Thanks! Thought making your playercode framerate independent only works for a few games. With a large enough deltaTime, you could effectively walk through walls and other things just by lowering your framerate. But I will use part of your other code (I've seen it in some places; makes sense to know how much time was used last iteration rather than to just use Clock's fps function, which I don't trust).
It was more of a prank. Also not that fun for the people receiving it, but fun for the people who made the prank. A sidenote, the Dutch accent in the screencast is quite obvious..
&gt;Denied consists of 160 lines of code Well sure, but the last line of code contains [this 300K zip file](http://filebin.ca/xkvoy/denydump.zip) in base64 encoding, which in turn contains 1MB of assorted Python scripts, C code and whatnot. Remember folks, don't run *any* code you don't trust... and inspect the Python scripts even if you do.
&gt; With a large enough deltaTime, you could effectively walk through walls and other things just by lowering your framerate. While this is true, modern games generally don't increment player positions as I showed you above, but instead move along a path at an "atomic" increment so that physics/collision engine catches any object a user might run against. 
lol, checking the domain owner is not "taking it serious"?
Besides the fact that I'm one of the people who provided a quote, if you watched the screencast and didn't catch on to the "scalable NoSQL solution" (aka JSON in a flatfile), you're probably a little slow.
Of course, in the case of bit.ly [there is an API](http://bit.ly/apidocs). Love the other responses for less robust services though.
That's cool, nice job
who were you?
Alex Gaynor
Kind of a broad question... versus what? for what?
They also use some kind of quick and dirty "swept" collision so they are not just testing the next point, but the entire path from between the frames. Also, some physics solutions run at a fixed delta_t that is &gt; 2x the frame rate (we run physics at 100hz and framerate at 30hz).
I was referring to the actual framework sources. Not the dependencies or the file that unzipped the framework and the sources. Or do you count dependencies as being part of the source as well? By that logic django would consist of django + the whole standard library for instance.
Oh comeon, django doesn't use the whole standard library, just most of it :D
As a prank, this was slightly amusing. But the post mortem reads as kind of sour grapes against bottle, et al. I dunno, that might not be the intention, but it comes across with kind of "my module, which is doing Things The Way They Should Be Done, doesn't get the cool factor of microframeworks, so I just proved anyone who thinks they want a microframework is an idiot." Instead maybe people actually want, er, microframeworks? And possibly a couple of them aren't completely retarded but actually have a use for them?
FYI, Scala has statically-checked "duck typing." 
I'm sure people do badly want good web frameworks that are micro. And I'm sure there are people who actually make good use of existing microframeworks. But I'm also pretty sure that these two camps are not composed of entirely the same people. People in the latter group usually make a reasoned decision to use a microframework for a particular project, but they are usually capable of deciding when it's a better idea to use a larger framework (or even customizations to an existing application) for another project. *Everyone* is in the former group, although there is a subset of people in the former group who just badly want the domain of knowledge required to do all web development tasks to be smaller, even though that particular complexity train left the station long ago, and the chances of something "micro" helping reduce effort are becoming vanishingly small. I think these are the folks who Armin is annoyed with.
&gt;C should have done this, but in this case, C failed. Actually, the right thing to do in this case is *highly* processor-specific. The Stack Overflow poster never says what CPU or even compiler he used, but I'm not surprised to see GCC screw this up -- it's never been that good at the tough optimizations. But while this might be the right approach for whatever CPU that was, I would be astounded if it's best for all: for instance, the newer Core 2 (Penryn and later) and i[357] CPUs have a "Super Shuffle Engine" built in. This SSE-SSE (ha) makes `movapX` and `movupX` equivalent, and no longer faults on unaligned `movapX` instructions, meaning I would expect (I don't own one of these CPUs to test) that emitting `movapX` in all cases would be the fastest solution. &gt;The big letdown is that numpy, which is supposed to be an already optimized set of numeric libraries, failed to give half decent results. Agreed.
I think you are very possibly correct in your assessment here. And I agree with the point completely. But the post-mortem comes across, to me at least, as rather shrill and doesn't actually make that point. Instead, after going out of his way to target bottle and web.py by pointing out bad practice specific to them (although a couple of those practices I will argue are a wash in the very specific domain of throw away, one day test projects, which is pretty much all I use bottle for). And the implication at the end of the day is that his joke is equivalent to those projects and that since more people looked at his joke than actually look at Werkzeug people must be stupid, because his code is "honest" and "well-written" compared the microframeworks he is slamming. He also ignores the idea that a lot of folks did get the joke, and looked at the video understanding that. I dunno, whole thing comes across as sour grapes instead of just making the point that his code can do what those other frameworks can do almost as easily, but he has been very bad at making that point in a crowded attention marketplace. And I do think the original prank was somewhat amusing. It is just the post mortem that comes across badly.
&gt; Instead, after going out of his way to target bottle and web.py by pointing out bad practice specific to them (although a couple of those practices I will argue are a wash in the very specific domain of throw away, one day test projects, which is pretty much all I use bottle for). I did not target any framework in that post by name. (Except mentioning web.py and Camping). &gt; And the implication at the end of the day is that his joke is equivalent to those projects and that since more people looked at his joke than actually look at Werkzeug people must be stupid, because his code is "honest" and "well-written" compared the microframeworks he is slamming. To explain the problem I have in detail a bit, keep this in mind: a large amount of code in Werkzeug deals with shortcomings in WSGI, bugs in implementations, abstractions for complex HTTP features, workarounds for limitations in the standard library, getting unicode right etc. Now it's already sad that WebOb and Werkzeug do not cooperate more, but at least some parts of the implementation for various things (formparser for instance) will end up in WebOb and it should be easier to exchange patches soon. However every microframework there is doing the same mistakes we already did a long ago to come up with its own set of fixes for them. Why can't we base microframeworks on stuff like WebOb and Werkzeug which exist pretty much for that purpose. I love the idea of microframeworks and I wish I could come up with one that would work similar to bottle or camping, but without the problems of relying on a stable current working directory or support for multiple applications per python interpreter. But that is really tricky and everything I came up with so far does not look nearly as neat as existing solutions. &gt; He also ignores the idea that a lot of folks did get the joke, and looked at the video understanding that. I hope your point is not that I should praise people for getting the joke :) Of course the majority did get the joke.
Basically type-classes that are auto-inferred by-name? Like Google Go? I think explicit type-classes are much nicer :-)
&gt;Re-evaluate your use of pygame.time.Clock(). I heavily advise against using it. What's wrong with it? &gt;The idea here is to make your updateLogic framerate independent How does setting something up to run every X milliseconds prevent you from writing framerate-independent code? (Hint to what I'm saying: you don't have to assume that it actually does run every X milliseconds.)
 http://dewitters.koonsolo.com/gameloop.html There's plenty of opinion on the 'net about it, so I'm sure with some googling you can come to your own opinion.
That doesn't answer my question at all. If I'm reading the documentation correctly, the following should be equivalent: def gameLoop(): clock = pygame.time.Clock() max_fps = options.lockFramerate while Running: updateLogic(clock.get_rawtime() if max_fps == 0 else clock.tick(1/max_fps)) def updateLogic( deltaTime ): playerPosition += playerVelocity * deltaTime Oh, by "your use of" did you mean "the specific way in which you are using", rather than "the idea of using at all"? 
First to note that I wasn't aware people could/would use Clock() in this manner. But your code is the same as mine, just that it encapsulates the time management. &gt; Oh, by "your use of" did you mean "the specific way in which you are using", rather than "the idea of using at all"? Yes. Also with your code, it's not *quite* clear where clock.get_rawtime() resets its time counter. I imagine it just clocks the duration between successive calls, but that's not exactly clear from its usage. 
Well, I did just cobble it together now, so no guarantees :)
Sounds good to me
Thanks for the heads up.
&gt; I love the idea of microframeworks and I wish I could come up with &gt; one that would work similar to bottle or camping, but without the &gt; problems of relying on a stable current working directory or support &gt; for multiple applications per python interpreter. But that is really &gt; tricky and everything I came up with so far does not look nearly as &gt; neat as existing solutions. [Here's my best effort to date](http://docs.repoze.org/bfg/1.2/narr/firstapp.html#creating-your-first-repoze-bfg-application) I think the trick may be in supporting multiple modes of configuration so people aren't stuck when an application outgrows configuration-via-a-single-file.
There is also a decorator-based configuration mode described within here: http://docs.repoze.org/bfg/1.2/narr/configuration.html . It uses something like http://docs.repoze.org/venusian/ to defer decorator actions.
Werkzeug is a toolset, bottle is a framework. If you like the way bottle does things, use it. If not, use werkzeug to build your own framework. 
[How To Think Like A Computer Scientist](http://www.greenteapress.com/thinkpython/thinkCSpy/html/chap01.html). This is an old version, but I like it. I don't about fun, but it gets you up to speed quickly, and with a non-stodgy tone. The updated (or adapted) book (also available for free) is [here](http://www.greenteapress.com/thinkpython/). edit: ^know
This is one of the regular texs in the online version of the MIT class. Don't just watch the lectures, do the readings and the assignments. If you want to join a group that's currently doing just that, check [this out](http://www.crunchcourse.com/class/mit-opencourseware-600-introduction/2010/jan/).
If you like problem solving then I'd suggest doing some [Project Euler](http://projecteuler.net/index.php) problems. I find that when actively solving a problem with a clear end-goal, I will go out and research modules that I could use and find out new things that Python can do.
 scala&gt; def k(f: { def charAt(n: Int): Char }) = f.charAt(3) k: (f: AnyRef{def charAt(n: Int): Char})Char scala&gt; val i = k("abcdefg") i: Char = d scala&gt; k(8) &lt;console&gt;:7: error: type mismatch; found : Int(8) required: AnyRef{def charAt(n: Int): Char} k(8) 
I really enjoy Head First Programming which uses Python.
Scripting Python for games like TF2 and Counter-Strike: Source via http://python.eventscripts.com
The only bot #reddit needs is Spinborg.
True, a lot of the PE problems I find are more about finding out how to solve the damn thing rather than coding it. XD Which isn't that bad of a thing really, although it can be frustrating when you just want to code. But yea, some mathematical grounding helps definitely. Chances are you'll still have some trouble with some of the later stuff. But I prefer the overall layout of PE comparatively.
Hire a cute girl, who is good at Python(they do exist!) to teach you or if you have game, make her your gf.
The redirect should already exist. According to [ubottu.com: Documentation for the Misc plugin for Supybot](http://ubottu.com/stdin/supydocs/plugins/Misc.html): &gt; Command|Args|Detailed Help &gt; ----|------------|-------------------------- &gt; tell|&lt;nick&gt; &lt;text&gt;|Tells the &lt;nick&gt; whatever &lt;text&gt; is. Use nested commands to your benefit here. I assume that means you can do something like: `tell Paradox460 google pineapple` (not sure the exact command syntax for Supybot), and it will do as you wish. I wasn't able to find a concrete example, but the fact that it says, "Use nested commands to your benefit here," leads me to believe that it works. 
I am a big fan of Python For Software Design. Use the current version (second link) rather than the old one (first link). Strongly consider buying a physical copy if you're serious.
Unfortunately, that doesn't work. That returns something similar to this &gt; 19:50:47 «@Paradox» .tell paradox google gorillas &gt;19:50:48 [redditalien(paradox@unaffiliated/paradox/bot/redditalien)] Paradox wants me to tell you: google gorillas A private message first of all, and doesn't parse the command. I suppose i could use {} nested commands, but that is cumbersome. Ideally, a public message would be best
Same for `.tell paradox [google gorillas]`? A little more digging turned up (in the `docs/FAQ`): &gt; You should quote arguments (using double quotes, like this: &gt; ``"foo[bar]"``) that have brackets in them that you don't wish to be &gt; evaluated as nested commands. Otherwise, you can turn off nested &gt; commands by setting `supybot.commands.nested` to False, or change the &gt; brackets that nest commands, by setting &gt; `supybot.commands.nested.brackets` to some other value (like ``&lt;&gt;``, &gt; which can't occur in IRC nicks). That seems to suggest the nesting is done using brackets around the nested command and arguments. As it says in the quoted portion, you may need to check the setting of the `supybot.commands.nested` option and the `supybot.commands.nested.brackets` option. 
It really depends on your goal is. If you want to develop web based applications than you may only to learn the core python language and some specialized libraries for the framework of your choice. If that is the case here is a minimalist introduction to python: http://web2py.com/book/default/section/2/1 ... http://web2py.com/book/default/section/2/16 This is part of the web2py book (a python web framework) but it is not web2py specific. It covers what you need to know to start using any Python web framework. Nothing more.
To **##reddit**, where there are no ops and no one is banned over silly rules.
So how about them?
Excuse me?
You're for #askreddit, silly!
Heaven forbid we dont allow people to spam lolcats and racism!
Try playing with the Turtle module, [docs](http://docs.python.org/library/turtle.html) It helped me a lot as a teaching aid back in the day when I was learning Logo as a kid (functional programing FTW) and I always wonder why no one has rescued it to teach Python.
And make her program an awesome Microblogging platform, sell it to Six Apart, keep the money and don't call her again...
Well, i had a discussion with someone, and the pipe/redirect syntax would be too open to abuse, so forget that
Because comments use markdown syntax.
Robots. Seriously you said fun right. Plus robotics can pull you into lower level programming. That is C/C++ and assembly. I like Python a lot nut sometimes I see learning it first as a mistake. Sometimes it makes more sense to build up your knowledge base from a low level. This to better understand what Python is doing under the hood. It depends of course upon your personality As to books I've yet to find one that is inspiring, I was even leafing through a few new ones at the book store yesterday. So you are on your own there. If robots don't float your boat think about things you enjoy doing. If it is sailing a navigation program might be fun. If it is shooting targets a ballistics program might be fun. If cars interest you, a program to suck information out of the cars computer ought to be fun. The thing here is that programming will be a lot more fun if you have a personal interest what the app will actually do. What ever floats your boat can have a programming element to it. Sometimes you have to look beyound the obvious to. Photography is popular thus you see a lot of code on line to manipulate or manage pics. This is all well and good but think outside the box. For example how many bits of code do you see online to do time lapse photography or spectral analyst of star light. 
I gotta agree on the robot thing. To me, anything that will fire up your creativity and make you giggle when it works (which is why I would leave out web development). Robots (whether physical or just virtual) with some sort of [genetic programming](http://pyevolve.sourceforge.net/) would be like playing legos again :)
Unfortunately I have to agree it is a shame that we have to use such a massive IDE to get a modern IDE experience with Python. I never even got decent performance from Eclipse until going to a dual processor machine, which kinda flies in the face of Python scripting. At least it seems stupid if you are working on simple scripts. Yet PyDev is very good maybe even addictive. So while I don't think Eclipse is shit it is a shame nothing similar for Python exists on a more balanced level. Sometimes running Idle makes more sense. 
I have actual Lego. I use Python for web development. I like the progression toward higher and higher levels of abstraction.
You could try out googles [python class](http://code.google.com/edu/languages/google-python-class/)
It has been pretty painful in my experience. Did you try soappy, or just rule it out because it isn't being actively developed? You might try it and see if it works with your WSDL. 1) I used suds the first time I had to interact with a ws via python, and it worked fine. 2) No. 3) Later, when the service changed its authentication scheme, I ended up having to go with a java framework (cxf.apache.org) to get working stubs generated, and it was still moderately dirty, but saved me a bunch of work over doing it manually. I suppose this depends on the size of the service you are working with, and how much of it you need to really interact with. Good luck. 
Cython rocks and all, but how exactly is this news? Should we post: `Python (python.org)` here too?
Agreed. This is a very good beginners class.
+1 for suds
Get thee to [Suds](https://fedorahosted.org/suds/).
I only wish it was easier to use. Separate compilation, files, then loading libraries as modules is just too much of a burden. Integrate it!
personally, i would go the java route. wsconsume is super slick and super easy to work with, even without running the full jboss stack, and i regularly embed wsconsume created stubs in swing apps or server daemons. axis2 is also pretty simple to work with and has been around quite a while, but as of late i have been very impressed with the entire jboss ws stack. in java it is pretty much a matter or pointing whatever tool is going to build your stubs at the wsdl (either a local copy or over the net) and letting it go to town. after that you invoke methods as normal. a great resource for webservice testing, etc is [soap ui](http://www.soapui.org/), and if you tell it where your libs for building stubs are it will actually go ahead and generate them with the library of your choosing, ntm being able to see the raw xml request/response without firing up wireshark is a huge benefit, as well as having the ability to invoke services directly.
Really, you're just going to do an HTTP POST of XML, so once you figure out what the XML is going to look like, you can use whatever HTTP library you like, no? The WSDL is a definition of the web service and is usually used to generate the client libs in Java, C#, etc. In your case, all you want is some sample SOAP messages so you can see how to marshal and unmarshal your data when you send a request and receive a response. It would be nice to have some auto-generated Python libs to wrap up the service nicely, but not a big deal to do that yourself, too....
 wrote an IVR, so ive been there before Cepstral license, yo, they charged me for 4 Reciting text just like the Roman, Cicero Too bad when it talk, it sound like c3-po
There (used to be?) a pyximport module that provided an imporrthook which automatically did compilation of pyx modules.
There's the excellent [xlrd](http://www.lexicon.net/sjmachin/xlrd.htm) for reading Excel files, and the `csv` module in the standard library speaks the Excel dialect for creating files that Excel can read. There's also [pyExcelerator](http://sourceforge.net/projects/pyexcelerator/) but I haven't personally used it.
You can mangle .docx files with [this](http://github.com/mikemaccana/python-docx)
A few years ago I had to interface with a nasty complex interface, which had been generated out of Axis, and none of the Python libraries worked. So, I built my own on top of httplib2. I used jinja2 templates to build outgoing messages, which turned out very nicely. Template inheritance worked well here, e.g. a base "soap envelope" template that was inherited by inner types etc. I used lxml to parse the incoming messages, which made it nice to pick out the elements I needed with either css selector syntax or xpath expressions. The only drawback to this approach is the amount of work needed if the WSDL changes but, in my case anyway, it was stable enough that I never had a problem. The advantages are that it actually works and also performs much better. 
That's awesome. Needed to do some EXIF manipulation a few months ago, ended up just using exiv2 via the command line, because I was looking for something quick and didn't come across this or couldn't get it to work -- I can't recall now.
Try [Pyscripter](http://code.google.com/p/pyscripter/) for windows.
python is my native language.
i'm glad there is a module for word too now. i asked once on xlrd forum and my post was found uninteresting. seems like most prefer excel to word.
You can also use http://pypi.python.org/pypi/xlwt to write excel files in combination with xlrd. I used it to generate some simple excel files at my last job. You can also use Excel/Word/etc's COM interface via the com stuff in the pywin32 package (http://oreilly.com/catalog/pythonwin32/chapter/ch12.html is a good starting point on the subject). Hope this helps.
www.pygame.org and www.pyedpypers.org Two websites for nifty pygame engine. Games development is what got me started programming, and pygame has renewed my interest.
I'm developing an OpenGL-based full-screen image viewer on Python that's able to display image comments. Back when I implemented comments this library was under development and I couldn't reliably count on binary GNU/Linux packages for it. I evaluated the other gazillion of old and/or half-broken Python EXIF reading libraries (for EXIF comment fields, the hundred of them IIRC), as well as the possibility of implementing my own (which I decided against due to batshit insane format and specifications). Out of the possible choices I went with running the independent build of exiv2 in the background when available (a few instants after the image has been shown, in order to avoid slowing anything down) because I wasn't completely happy with everything else, and exiv2 provided a complete solution for what I wanted. So, where am I getting at? I'm glad to see pyexiv2 arise, I can verify its usefulness and the quality of exiv2.
http://diveintopython.org/
Consider marijuana... or Dive Into Python. Learn Python 3. Let's start the great migration.
Apart from Denied being a April fool joke. I actually liked the idea. So I'm interested in Bottle or CherryPy. Bottle looks a lot more like Denied, using decorators for routes and Bottle also seems more lightweight(16KB vs 312KB for cherrypy) It also seems like bottle is truly a single py file where cherrypy has lots of files. So what exactly do you mean bottle looks exactly like cherrypy? It seems more like one is a lightweight solutions and the other a heavier more features solution.
I like to plug my own free book "Invent Your Own Computer Games with Python" at http://inventwithpython.com It's available under a Creative Commons license. Each chapter has the complete source code to different games (Hangman, Tic Tac Toe, etc.) and also goes into Pygame. It's made for people with no programming experience, but you can probably just skim the content and mostly read the source code. I wrote the book to provide concrete examples with Python, rather than didactic tutorials about programming concepts. Dive into Python is very good if you already know programming in another language. http://diveintopython.com
Dear Sir or Madam, I love you. Sincerely, Keene Maverick
Look through the other videos in there. Lots of good material.
Thanks, it does.
Also, I was amazed to see how many people in the audience were using macs... (watch at 37:40)
PDO is not an all emcompassing object that talks to, or portable, across all db engines. There are supplied drivers for many of the popular database engines available -- each driver which can only talk properly to a single db engine type. A given PDO connection instance can only talk to 1 host database engine (though you could have multiple connections to different databases open at once). PDO is similar to Perl's or Ruby's DBI module ... as you've pointed out it looks like SQLAlchemy is one of the few Database Abstraction Layers (not necessarily just an ORM) that is the closest cousin to ruby's DBI or PHP's PDO available in the Python language.
PyPy faster than CPython? But not faster than CPython with Psyco. On almost any numeric test PyPy is several times slower than Psyco. 
They dropped the partial evaluation JIT and wrote a tracing JIT instead? Is the new JIT also based on LLVM or did that get thrown out too?
pypy improves, psyco doesn't
the main challenge of an orm: how efficient is the produced SQL? and: how well thought out is a database scheme created "automagic" by those ORM helpers. There is a reason why there are so many designers and so little automatic design for visuals; there is a reason why people-thinking-in-SQL will on average create better databases than people thinking-in-abstractions-distant-from-the-database.
Armin Rigo the creator of psyco is now working hard on pypy. Psyco is an awesome hack, but pypy is the future. &gt; Armin Rigo and Maciej Fijałkowski tirelessly worked on most aspects of the release, be it fixing the last known bugs and performance problems, packaging or general wizardry. from http://morepypy.blogspot.com/2010/03/heroes-of-12-release.html
Aside from this being *two years old*, it's a pretty good indicator some of the sacrosanct 3rd party modules could use some optimization. **Edit:** Doh. For some reason the fact dateutil seems to be in every python install I've ever seen made me think it was an internal. My bad!
Good word! - Sacrosanct - I had to look it up. http://dictionary.reference.com/browse/sacrosanct
&gt; a fast implementation vs &gt; raw speed is not in that list IANACS, so I'm interested in the distinction here.
&gt;when I try "&gt;&gt;&gt;python" it says that the name is undefined, this is supposed to happen? Yes. When you are already in python, so you can't run the python interpreter. You'll need to import the Test2 module (like you already have) and use it as a python module. Like so: &gt;&gt;&gt; import Test2 &gt;&gt;&gt; Test2.Hello("Alice") edit: When you use an import statement, python looks for a module with that name in the current directory, and in sys.path. So either you have to be in the same directory as Test2, or it has to be somewhere in sys.path.
The only internals I saw mentioned in the article were list.sort() and heapq and they seem to work pretty well for what they are supposed to do. What are you talking about?
It looks like you're trying to run shell commands from Python. Don't do that. From your OS's shell: D:\PythonCode\&gt; python Test2.py asdf Or from Python's shell: &gt;&gt;&gt; import Test2 &gt;&gt;&gt; Test2.main() Note that `sys.argv` isn't filled in if you do the latter, which will cause your `main()` to die with an `IndexError`.
There's an LLVM backend, but it's unmaintained (it was originally worked on by a GSOC student, and they a) didn't commit to maintaining it and b) found at the time some of the JIT stuff had too many bugs and the C API wasn't good enough for what they needed)
dateutil is a third-party library - it's not distributed with Python's stdlib. (Although it sounds very nice.) And I don't think anyone regards Python's internals (or library code) as sacrosanct. (Although it's a great word.)
I think he was referring to the dateutil module which isn't technically an internal, but it's part of the "batteries included"
That works perfectly, thanks for the help! It seems maybe I'm jumping into the too quickly with all this, I guess it's time to slow down and read more about the basics of python before moving along.
Guess i've been in the wrong frame of mind the entire time, I believed the python command line interface worked exactly like CMD except that you could run code straight into it. an yeah :P I noticed that too while playing around with the program, I guess the tutorial hasn't covered what to do exactly when nothing is given. 
 Oh snap, someone hates the mac rescind lonely with his thinkpad in the back BSD userland, it aint so bad perhaps im biased I wrote this on my ipad
What I'd do is add arguments to main, so you can call it like timster121 did in his example: def main(name): Hello(name) if __name__ == '__main__': main(sys.argv[1]) Then this: &gt;&gt;&gt; import Test2 &gt;&gt;&gt; Test2.main('Alice') ... will do the same thing as this: D:\&gt; python Test2.py Alice You can also check for an empty `sys.argv` fairly easily: if __name__ == '__main__': if len(sys.argv) &lt;= 1: sys.exit("usage: %s &lt;name&gt;" % (sys.argv[0])) main(sys.argv[1])
no it's not, that'd be datetime. Dateutil is a third-party library.
I've never understood why heapq has such a strange api. Why is heapify an in-place operation on the list? Wouldn't it make more sense to return some kind of list like Heap object?
At reddit we use sqlalchemy only as a DBA later, not an ORM (we wrote our own ORM on top of it). So we write our own SQL and schema, and it's as efficient as we make it.
Just in case anyone's interested, I checked the latest dateutil and the fix has not been applied.
&gt; Why is heapify an in-place operation on the list? So that you don't have to double space usage. If it does inplace then you always have the option of creating a copy yourself, but not the other way around. 
not enough content. FTFY.
I love getting stoned and programming. I am much more open minded when it comes to breaking down problems / ideas.
Twisted docs look really rich in comparison.
Did you click the links on the right side of the screen (under "Navigation")?
Python good, mindless eweek slideshow with no real information, bad. Down arrow.
This helps a lot... but how to prevent this before "run time"? Does any pylint like solution exist to spot unexpected attributes assignments by some given rules?
Yes, but Twisted (docs) in not easy to learn IMHO.
Shouldn't it be "Charming Python"?
oh boy
[Pycon Atlanta 2010: Introduction to Internet Programming in Python](http://pycon.blip.tv/file/3359441/). The first part of this 3-hour video covers basic network programming in Python. Hint: FlashGot works great with blip.tv.
Instead of all this weird locking code, why not just use the \_\_slots\_\_ magic attribute of new-style objects? o_O
Ok. Is it slow?
cherrypy is still a very lightweight solution. cherrypy is much older though. Even lightweight projects tends to get fat with age and added functionalities. Having said that, I do prefer the API of bottle. I used to use cherrypy for some quick prototyping, now I use bottle.
He’s interfacing with C++—he’s probably just suffering from post-traumatic shock.
A Byte of Python is split in 2 different parts. 2.x and 3.x Check it out, the 3.x is a very good made wiki. http://www.swaroopch.com/notes/Python
This is a pretty poor introduction to Python network programming. Any "real" application should be using [asyncore](http://docs.python.org/library/asyncore.html)/[asynchat](http://docs.python.org/library/asynchat.html) (at the very least,) or something like [eventlet](http://eventlet.net/)/[gevent](http://www.gevent.org/). I guess Twisted works too if you're a masochist.
Right, don't they do any editorial work at Dr. Dobbs? The article is chock full of grammar and spelling errors. As for the content, I do find it sort of informative yet also a bit misguided. If this is his elegant solution then I'd hate to see what he'd consider quick'n'dirty. 
http://speed.pypy.org/
How to turn python into p++, yikes. How many of the hypothetical problems that the article tries to avoid end up mattering to people actually writing python?
What are you interested in doing? Find a small code base that does something you would like to know how to do &amp; read the code. Or, if you would rather, think of something you want to do, and try to do it. Keep the Python documentation open, and read up if there's something you don't understand.
Your opinions would be welcome :) http://www.reddit.com/r/programming/comments/bo82s/any_good_tips_or_books_for_a_network_programming/
Contrary to the advice here, never use BaseHTTPServer; instead use wsgiref.simple_server.
i found http://google-styleguide.googlecode.com/svn/trunk/pyguide.html to be very helpful too.
 def handle_one(): return 'one' def handle_two(): return 'two' def handle_default(): return 'unknown' cases = { 'one': handle_one, 'two': handle_two, 'three': lambda: 'three', } for i in ('one', 'two', 'three', 'four', ): handler = cases.get(i, handle_default) print handler() &gt;Pretty neat, huh? No, not really. I would much rather have an actual switch construct. As he writes: &gt;Python is Python, don’t try to emulate bad coding patterns from other languages
Actually after you grasp how Deferreds work there's not much surprise left anywhere. You do work on events using callbacks, reactor runs your code. The rest is network protocols frenzy. Also: interface and some slight java-ness (zope-ness?). First requirement -- read teh codes. Doable IMHO.
Also, don't use try/except everywhere without any exception-types. That will make your debugging absolute murder.
How not to write Python tutorial Never use "foo" and "bar"! Use "spam" and "eggs" instead ;) 
&gt; A Python shell like iPython is a must-have. I’m completely addicted to the tab-completion and documentation shortcuts it provides. This is bullshit, I F**king hate iPython and it can cause strange bugs.
why? Aren't they just the same thing, but BaseHTTPServer is without WSGI???
^ A million times this. I can't count how many hours I've lost debugging other people code only to find that some exception is happening and I'm not seeing it because of a try/except in some obscure part of the code.
Straight from the horse's mouth [PEP8](http://www.python.org/dev/peps/pep-0008/)
wsgiref is built on BaseHTTPServer, but WSGI is relatively sane (primitive, but sane) while the BaseHTTPServer interface is awkward and a bad fit for writing any kind of web application.
anyone have a tl;dr version?
I used to do this all the time in C# :/ -- it's pretty much universally bad 
&gt;No, not really. I would much rather have an actual switch construct. As he writes: &gt;&gt;Python is Python, don’t try to emulate bad coding patterns from other languages I'm confused. Are you saying that an actual switch construct is the "bad coding pattern"? In which case, why would you rather have it? Or are you saying that selecting a function from a dictionary is a "bad coding pattern"? In which case, (a) why? and (b) from what "other language" is this being emulated? What's un-Pythonic about (a) treating objects as functions (when "everything is an object" is one of the fundamental selling points of the language!) and (b) looking up objects in a dictionary (when the ability to create dictionaries with simple {} syntax is another one of the fundamental selling points)? I have no qualms about writing code like for item in ('one', 'two', 'three', 'four'): print { 'one': lambda: 1, 'two': lambda: 2, 'three': lambda: 3 }.get(item, lambda: 'unknown')() Of course, the example is too simple to actually require lambdas; it's just for illustrative purposes.
Yeah. BaseHTTPServer IS awkward. Ill try WSGI the next time. Thx.
&gt; I'm confused. That's understandable, because I meant something a little bit different than what I wrote(and quoted). First I meant that I don't like his example as a substitute for a switch. Then I guess I sort of put words in his mouth, using his quote. What I meant was more like: &gt;Python is Python, don't try to emulate coding patterns from other languages. My first problem with his example is that you probably shouldn't use the "switch" example to show how to write pythonesque code. Even in the toy example it's not so readable. My other problem was that Python does not have a switch construct. I would really like that and it fits so well in Python, I think. There is so many easy constructs and every time you -in other languages- need to write a lot of code you can find a construct or a low level function that does this. So why is there no switch in Python? You can emulate it and do it ten different ways - but why emulate the thing when you could just have it? I hope I made my point a bit clearer now. edit: oops, had typed "substitute for a switch-loop". Switch-loop, tsk tsk.
Can you explain this? I have read halfway through Learning Python and the author keeps using "spam" as an example. It is driving me crazy. EDIT: [Ah ha!](http://en.wikipedia.org/wiki/Spam_(Monty_Python\)#Impact) *And I suppose Idle was named after a comedian* [Oh wait...](http://en.wikipedia.org/wiki/Eric_Idle#Tributes)
Should I immediately transition to pygame? Or is it better to learn the basics and then, once having a solid understanding, move towards things like pygame?
My favorite is the Eric IDE.
Since the OP seems to have the luxury of time and not having to support production code, I'd instead suggest http://diveintopython3.org/ . Go with the more up-to-date book and the newer version of Python. :) 
&gt; Just like many other programming languages, Python allows you to add static methods to a class. Just decorate your method using the ’staticmethod’ decorator! Wouldn't it be better to just use functions instead? I never really understood the usefulness of static methods in Python. For example, they make sense in Java, where *everything* has to be in a class, and they make sense in Objective-C, where you don't have namespaces or modules to organize "loose" functions. But Python doesn't require everything to be in a class, and it has modules to organize functions, so why not use those features instead of static class methods?
Switch is great and all, but really it's a bunch of conditional statements stacked together. Why not just do it that way? for i in ('one', 'two', 'three', 'four', ): if i == 'one': print 'one' elif i == 'two': print 'two' elif i == 'three': print 'three' elif i == 'four': print 'four' else: print 'unknown' It looks exactly like a switch statement, but I think the dictionary solution is still better.
&gt; So that you don't have to double space usage. I can appreciate that but I still think the api is very un-pythonic. The point is that I don't want to have a heapified list that I have to handle with static methods from the heapq module.
A dictionary still is a better solution. The whole deal with the switch statement is that it reduces repetition. An elif block repeats i == in every condition. If I changed to something else then you have to change every elif statement.
Tcl is scary. Like Forth.
The point of switch is that it's faster in C/ASM if it's well done. You can write "goto address + var" then those addresses can have their own gotos and code blocks. No repeated testing. 
As far as I understand it, it's a "neatness" thing. Sometimes a function 'belongs' in a class (and you don't want to clutter the global namespace) or is only called by that class (which means you can use \_\_ManglingObfuscation or neatly use \_ImpliedObfuscation - both of which are technically a neatness thing). Plus, sometimes devoting a whole module for something that could be squeezed into a class is a bit messy.
That's exactly right. My example above doesn't account the use of break commands (or lack of) which I always thought was the *real* point of using a switch statement.
&gt; No, not really. I agree with you and I've used Python a lot for many years. Say you have this: def cases(): return dict() def case(cases, value): def decorate(f): cases[value] = f return f return decorate def default_case(cases): return case(cases, '__default__') def switch(cases, value, *args, **kwargs): if value in cases: return cases[value](*args, **kwargs) elif '__default__' in cases: return cases['__default__'](*args, **kwargs) else: raise ValueError("No case for %r and no default case" % value) then you can do this: spam = cases() @case(spam, 'one') def handle_one(): return 'one' @case(spam, 'two') def handle_one(): return 'two' case(spam, 'three')(lambda: 'three') @default_case(spam) def handle_default(): return 'unknown' print switch(spam, 'one') print switch(spam, 'two') print switch(spam, 'three') print switch(spam, 'four') Not pretty.. but at least smells Pythonic.
I didn't want to get into that kind of detail when talking about scripting languages. I don't even thing it's true for C any more (it's definitely not true for assembly languages, which don't have switch statements). I think most C compilers these days treat switch statements the same as if/else statements. I also think most old school compilers treated switch statements with a binary search which will still work well when the labels are spread apart. So let me clarify my original statement: These days, the main benefit of switch statements is to reduce repetition in your source code.
What, you mean ugly and pointlessly magical?
&gt; it's definitely not true for assembly languages, which don't have switch statements They don’t have switch statements per se, but a good dev will be able to do what I explained before a write a series of additions and gotos instead of a series of comparisons (remember, comparisons are fairly expensive on modern CPUs compared to doing simple math). &gt; These days, the main benefit of switch statements is to reduce repetition in your source code. True. Agreed.
I'm not sure I understand. Do you mean that you should always be catching a specific type of exception?
You don't really deserve to be all the way down here. iPython is pretty poor, and it does cause loads of strange bugs. I steer pretty clear of it now because most of the time when I was debugging I'd have to check that it wasn't an iPython problem rather than a code problem. But a little bit of TLC for your interpreter *is* a must-have, and for that you want bpython.
Name mangling is the ugliest thing in the language IMO and thankfully is just about never used from what I've seen over a short time. I don't think I'd ever even consider it. And yeah, staticmethods are a lot about context. If contextually it seems that the function belongs tied to a class, it might be a staticmethod. That one I also try to be stingy with though unless its absolutely necessary.
You should familiarize yourself with WSGI, tons of good, pluggable pieces of middleware use it.
Yes, you should. If you need to catch all exceptions, except Exception: is probably what you want. That won't swallow more important things like KeyboardInterrupt or MemoryError.
&gt; If your class is intended to be subclassed, and you have attributes that you do not want subclasses to use, consider naming them with double leading underscores and no trailing underscores. This invokes Python's name mangling algorithm, where the name of the class is mangled into the attribute name. This helps avoid attribute name collisions should subclasses inadvertently contain attributes with the same name. Seems reasonable to me. That said, I've never had a real use for name mangling. And I'd never use them to make something "private".
Thanks!
readable, comprehensive documentation
I knew this would be at the top of most people's lists, so I started documenting far earlier than I would normally do, and I made a particular point of learning Sphinx (and nose, sort-of-relatedly).
Magical means it’s unclear how it works. Decorators aren’t magic.
try except without exception type is acceptable in ONE scenario: try: foo_bar() except: transaction.roll_back() raise
a) Template language with Django's syntax, a few semantic changes for cleanup b) ORM very similar to django's but not identical. `User.objects.filter(User.name == "val" | User.name == User.spouse.name)` c) URLs and other things basically as with Django, maybe I'd do something different, I don't know.
&gt; a) Template language with Django's syntax, a few semantic changes for cleanup I'm currently using [Jinja 2](http://jinja.pocoo.org/2/), which is based on Django's template language, but with more flexibility. It's not hardwired in, though, and I always intended to make the template language switchable like in Pylons. At a later date, I'd like to have one (either new, or perhaps by extending Genshi) that gives higher level elements for things like AJAX forms, Google Maps etc. &gt; b) ORM very similar to django's but not identical. User.objects.filter(User.name == "val" | User.name == User.spouse.name) Again, switchable. I'm currently using [Elixir](http://elixir.ematia.de/) (an [SQLAlchemy](http://www.sqlalchemy.org/) ORM), but also looking at [Storm](https://storm.canonical.com/) (much simpler, but less powerful). Both of those overload operators on fields to return expression objects, as in your example. &gt; c) URLs and other things basically as with Django, maybe I'd do something different, I don't know. I've been experimenting with internal DSL syntax for routes. They currently look like this: '/' &gt;&gt; template('front.html') '/login' &gt;&gt; action('session', 'create') '/foo' &gt;&gt; redirect('/bar') It's radical. I bet some people will hate it.
Incidentally the filter example you give will parse as `User.name == ("val" | User.name) == User.spouse.name` -- sadly `|` is not a great alternative for `or`.
The DSL is radical... but what is the point? If you just like to point at things like `template('front.html')` you can do that with Routes and some of the other dispatchers.
I started on doing this myself - I wrote a simple Paste-based framework using Werkzeug, Jinja2 and SQLAlchemy: http://bitbucket.org/danjac/satchel/overview/ Please feel free to use whatever you want from that. Haven't really had much time recently to work on it, especially tests and documentation, which really take a lot of time to do right. For another Werkzeug-based framework you might want to look at Glashammer (http://glashammer.org/). 
Exactly that. Thanks for explaining it.
It doesn't use a DSL, but the semantics seem similar to juno's route decorator.
Hm, we've got exactly that in our own excercise - [svarga](http://bitbucket.org/piranha/svarga/wiki/Home). It's pretty usable right now, we're using it already in some projects and aim now is to write more documentation and tests. We use Jinja2 for templating, which is like Django templates, but much better; the same with form library - we use WTForms, which are very similar to django.forms, but much cleaner inside and outside. We have our own thin layer over SQLAlchemy to reduce amount of imports and code. Urls are taken from Werkzeug - you don't need to use regexps everywhere (but it allows to) and you have more flexibility when defining them comparing to django. Overall, I like it, and I hope maybe someone else will too. :) 
The point is to remove anything that isn't needed. I view the routes file as more of a configuration file than a code file, and in a large application it can get quite unwieldly. I wanted something that said, simply, "/ goes to a template called front.html. /login goes to a session action called create. /foo redirects to /bar." (Each of those functions actually returns a werkzeug Route object. Actually, a list of them, because I can do `'/posts' &gt;&gt; controller('post')`, which lets PostController specify its subpaths for create, edit, list, show etc. I still don't know if I'm happy about that yet.
&gt; I don't think I'd ever even consider it. mangling exists for (and is used in) a single very specific case, related to inheritance and overwritability: you have an attribute `a` in your class `Spam`, your class `Egg` inherits from `Spam` and defines an attribute `a` of its own. Now `Spam` uses the `a` defined in `Egg`. This might be what you want (usually is, document `a` as an extension point), but if it's not `Egg.a` is going to shadow `Spam.a` in `Egg`'s execution (of inherited methods) and things are going to break. Therefore, you use `__a` and the collision will not happen (actually, will be less likely to happen, it doesn't use the package name, so if your classes have the same name you'll still get a collision). Anyway the use case for mangling is real but very rarely encountered, and it definitely isn't here to emulate making shit private.
Personally, for string arguments I prefer using a class based approach. ie given the base class: class Switch(object): def __call__(self, name, *args, **kwargs): return getattr(self, 'case_' + name, self.default)(*args, **kwargs) def default(self, *args, **kwarge): raise Exception("No default case in switch.") You create switches as: class MySwitch(Switch): def case_one(self): return 'one' def case_two(self): return 'two' def case_three(self): return 'three' def default(self): return 'default' mySwitch = MySwitch() print mySwitch("one") The advantages are: - DRY. You don't have to repeat the case and the function in multiple places (both the dict and the decorator / function name) - Extensible. You can subclass an existing switch to add new cases if you're even in a position that this makes sense. If you want to go further, a bit of metaclass magic to avoid the need to instantiate the class, and use staticmethods for each case, avoiding the unneeded self parameter. More ambitiously, its also possible to do the same via a context manager (albeit with a bit of stack inspection), so you *could* have: with switch(foo) as result: def case_one(): return "one" def case_two(): return "two" def default(): return "default" print result.value OTOH, I'd actually still like a switch statement. There are a few problems with all these approaches: - Mine only works for strings, other approaches violate DRY. - Embedding the creation of the class / dict inline is inefficient. You don't really want to construct the dict every time you want to switch, which necessitates moving it outside the function body where it naturally belongs. This is probably rarely that important (constructing a dictionary isn't *that* expensive), but it's not something you'd want to do in a tight inner function. 
Any reason you can't just use an ssh tunnel? Don't reinvent the wheel if you don't have to.
&gt; "Having said that, the day uwsgi becomes available as a Debian package I'm all over it like a dog on an ass-flavored cookie." Stay classy, internet. :)
&gt;&gt; Re-evaluate your use of pygame.time.Clock() Be sure to read the classic ``[Fix your timestep](http://gafferongames.com/game-physics/fix-your-timestep/)´´ The article brilliantly explains how to use a _time accumulator_ for framerate invariant physics/animations. It effectively fixes the problem of dealing with too big time deltas. 
... why would sockets in python act differently on different platforms? This seems odd to me. 
And in case anyone's interested, here's a quick implementation of the with based switch above: import inspect _noval = object() # Sentinel class switch(object): """Act as a switch statement from within a context manager. Cases are defined as functions within the with block of the form case_&lt;key&gt;, with default being used for a default function. Optionally, arguments to the case functions can be provided. The response will have a .value field which will be bound to whatever the function returns after the block is executed. eg. &gt;&gt;&gt; foo="one" &gt;&gt;&gt; with switch(foo) as r: ... def case_one(): return 1 ... def case_two(): return 2 ... def default(): return 0 &gt;&gt;&gt; r.value 1 """ def __init__(self, name, args=(), kwargs={}): self.name = name self.value = None self.args = args self.kwargs = kwargs def __enter__(self): f=inspect.currentframe(1) self._oldscope = dict((k,v) for (k,v) in f.f_locals.iteritems() if k=='default' or k.startswith("case_")) return self def __exit__( self, type, value, tb ): if type is not None: return # Exception occurred in creating switch block - don't go any further f=inspect.currentframe(1) func = f.f_locals.get('case_%s' % self.name, _noval) if self._oldscope.get('case_%s' % self.name, _noval) is func: func = _noval # Ignore if not bound within the switch statement. if func is _noval or not callable(func): func = f.f_locals.get('default', _noval) if (func is _noval) or self._oldscope.get('default', _noval) is func: raise KeyError("Case %r not found, and no default branch provided" % (self.name)) elif not callable(func): raise KeyError("Case %r not found, and default case is not a callable function" % (self.name)) self.value = func(*self.args, **self.kwargs) 
It's pretty long and pretty detailed. I suppose that tl;dr would be: "Things are getting much much better."
This phrase is going in my rotation. Gone is "like stink on shit".
I guess my main question is what am I supposed to use for distribution these days?
I don't really get this article. This seems like basic OOP principles. Though I lost interest after the first page, does he actually go on to talk about anything interesting? Just seems like this idea of a constructor (\__init__) is new and amazing to the author.
most of the talk seemed to be about standardizing meta-data. I tuned out a lot of it, honestly. But, distribute and pip seem to be the "now" and the "future".
I suggest looking into uWSGI + Nginx. 
I desperately wish for PyPy to support 64-bit systems. I would love to try some of our codebase on it, but our entire organization runs on 64-bit machines.
PyPy works on 64 bit machines, just not the JIT. A student submitted a GSOC proposal to work on porting the JIT to 64-bit though.
Lists aren't immutable, so there's little value to returning a copy rather than simply modifying the structure in place.
i kept misreading it cython instead of cpython. It would be interesting to see some interesting mixture of cython and pypy.
There's not a ton of point in that. PyPy is written in RPython, a restricted, implicitly statically typed, subset of Python. It's not super to write in, but it's garbage collected and semi-decent. Really the goal is to make Python fast enough that users don't need to write in C.
Most importantly: What exactly is the overhead in running CPython modules? Is it merely the emulation layer that pretends to be CPython between PyPy core and the extension module?
Why don't you try appending recv to a string, and then using send instead of sendall?
It would also be really awesome if RPython became more decent and super to write in...
I disagree. The goal of PyPy is to provide awesome features with incredible performance not being a different language such as Cython. I want PyPy to be my Python implementation without bothering too much about the backend. I want PyPy to figure out how to optimize my code not the other way around. 
Someone please notify me when vim has some badass python auto-completion. Omni-complete is never omni enough :/
As you said that pypy is implicitly statically typed, which is the information cython is needed to generate efficient code. To that end, (i am just saying out of the blue) one might feed pypy's type information to cython generator and produce c code for compilation. afterall, cython intergrates well with numpy, c/c++ code and fortran very soon. 
dae get the impression PyPy is moving in giant steps forward since Unladen Swallow was pronounced to be merged?
Still does not highlight "self"...
Yes. Basically we reimplemented the CPython API, in terms of PyPy's internal functions. Overhead in general isn't too bad, some of the bad points are a) we have to emulate reference counting, so we don't get to use our awesome GC's, b) PyPy's GC's can move memory around, so if you call a function like PyString_AS_STRING (which returns in the internal char* of a python string) on a PyPy string we have to copy the underlying memory, because it could move at any time.
Correlation is not cuasation. 
I'm getting super excited about PyPy!!! I've never really gotten too excited about Jython and IronPython because of their relative difficulty to use compared to cpython. PyPy is making some really great improvements in speed, and will probably be production ready in the not too distant future. I remember when it came out and I thought , meh good idea, let's see if it comes to anything! HOLY Crap has it! I think on of the great things about this project is the depth of the metaprograming that will now be available. 
"self" is not actually a reserved word. Yes, everybody use "self" to reference the instance, but you can define your function as f(this, param1) and use "this" inside it instead of self.
What I'm trying to say that I *don't want* a list! I want a heap object.
Without the JIT doesn't that mostly void all of the performance benefits?
I know that, and I waited for that kind of reply just to shout at whoever says it, but I'm to tired for that kind of thing right now. Anyway it is used very commonly and your brain should read it automatically so highlighting it is the right thing to do. IN ANY NORMAL EDITOR IT IS HIGHLIGHTED DAMMIT.
Fijal got on me for writing a bit too much about it in my proposal, but I honestly love RPython compared to other statically typed languages. The ability to run arbitrary Python code at import time, and then be statically typed later is nice, and it's type inferenced which is even nicer (and yeah, garbage collected too). But before anyone asks, it's not intended to be a general purpose language... :-) 
try http://github.com/Shougo/neocomplcache/ it's not perfect, but works pretty well for me
Yeah, I really hate having a central place where I can just click and download the code, or see all the websites for each project. I prefer to have to have Google for each one individually, and replicate the scut work that the author had to do. 
kingkilr, you seem to know what you are talking about, do you have an idea when PyPy might be released in a form which could be used in production as a replacement of CPython? I know that PyPy has roots in research, but is there a move towards making it practical for real world use? (This announcement would certainly suggest so.) 
Yes. Having 64-bit support for the JIT is definitely a priority for this reason.
I'd say the next release would be a good time to start considering it for production use. The recent 1.2 release was a first public release with the JIT, my guess is by next release most of the bugs and such will be cleaned up, and it'll be time to start deploying it.
You append recv to a string that acts as a buffer. Then you use send which will attempt to send as much as the buffer as it can instead of trying to send it all at once.
Author does not understand definition of declarative.
That's the spirit!
I could have sworn at one point that self was highlighted within vim and that it was removed. I might be wrong though. If anyone misses it enough, it's very simple to edit the syntax file and add "self" to the list of things to highlight.
Nice. Supybot is great and all, but you should check out [Ibid](http://ibid.omnia.za.net/Ibid/Plugins). (Also has an imdb plugin amongst many others)
Most *obvious* bugs that is. Nearly all show-stoppers should be caught, not all though. Even then, it should be enough for all but the most sensitive applications!
I kinda disagree. It should highlight whatever the first parameter you put in a function inside a class. The name of that variable is "open", though.
Mostly it's because we finally found a good way after 4 previous jits. :)
Well, we'll never find out unless people try. Now is a good time!
It's PyPy group dogma that RPython isn't to be used for anything else but implementing languages, not other stuff. I understand where the dogma comes from - for years now they've had people say to them "RPython is cool, can I use it for..?" and the PyPy group doesn't really want to deal with it. It is interested in developing the interpreter, not improving RPython for pragmatic purposes. So it's easy to consolidate on the dogma "no, you can't use it for that" whenever that topics comes up again. But it's still dogma, and it still could change if enough people decide it's valuable for other purposes and work on it. They'd need to carefully manage the PyPy developers, though. :) 
I agree that PyPy should figure out how to optimize my code, but whether it can reach the performance of something like RPython remains to be seen. (and if can, if it takes 20 years, there's a certain window of opportunity..) In some circumstances such increased performance might be desirable, after all, and it could also be valuable to be able to write such performance sensitive code in a subset of Python. Of course thanks to this very cool CPython compatibility, we could use Cython with PyPy now to accomplish the same effect, but you'd think RPython would be better for that job if you're using PyPy anyway. That said, whether using RPython that way is worth the effort is of course debatable. Fundamentally of course the PyPy developers agree with me that using RPython is worth the effort in some contexts; after all, they wrote RPython and are using it. That also explains why it's so difficult to explain to other people *not* to use it! :) 
I wouldn't say that's necessary at all. Sure, PEP-8 advices for it but as long as he's consistent with *his* code, it doesn't matter ("a foolish consistency is the hobgoblin of little minds").
What advantages does it have over Supybot?
What are IBid and Supybot?
As far as I know the queue.PriorityQueue in the standard lib uses heapq internally.
That’s way too much to ask a highlighter to do. What if I define a function outside of a class then add it in later? And do I really want `cls` highlighted in classmethods? Just highlight `self`. It’s simple, and everyone either uses it or knows that they should be using it. 
Have you seen http://www.themoviedb.org/ ? It doesn't quite have as much data as IMDB, but has a proper API, which is considerably less error prone than screen scraping (each time I wrote a scraper for IMDB, it broke within a month or two) I've written a Python wrapper to it, http://github.com/dbr/themoviedb
nice, I'm a python newbie and never used Supybot, very interested in the IMDb.com info crawling part. Actually I tried to pull down some info from IMDb the other day using urllib, but turns out IMDb forbids the spiders, just wondering how you did it?
If I have some especially performance-sensitive parts of code, I'd much rather write them in (something like) RPython than C. Alternatively, maybe PyPy-with-JIT can speed up carefully written Python code so much that its performance is much like RPython's, but even then, you have to be aware of what kind of things make the implementation slow.
&gt; If I have some especially performance-sensitive parts of code, I'd much rather write them in (something like) RPython than C. So, use Cython. &gt; Alternatively, maybe PyPy-with-JIT can speed up carefully written Python code so much that its performance is much like RPython's, but even then, you have to be aware of what kind of things make the implementation slow. RPython is a moving target, there is hardly any documentation and if performance is all you need you still need to know the guts of RPython it self. If you really want to optimize your code you need to have two things. A through understanding of the machine you are running on and a complete understanding of the language by which you are talking to it. It really is much easier to create high performing code by optimizing your loop with a little bit of C than using RPython which is basically just a magic layer in between. 
Yeah, TMDb was suggested to me because of the API, and I would've liked to use it, however IMDb's data is simply superior at the moment. Especially the lack of alternate titles at TMDb was something that made me go with IMDb instead. Searching for "En lang forlovelse", which is the Danish title for "Un long dimanche de fiançailles", will return the proper result from IMDb, while TMDb returns a list of wrong guesses :P
Hi, I'm a Python newbie as well :) A simple content = urllib2.urlopen(r'http://akas.imdb.com/find?s=tt;q=' + q) works for me, and I'm pretty sure urllib worked as well when I tried using that. You can browse the sourcecode at Github, it's basically plugin.py that does it all. Take a look at the imdb method :)
From a cynic: Suck it up and write the damn tests. Stop having fun. Stop being even *proud* about whatever hideous shit you came up with.
Absolutely agree, and I've been guilty of this in the past: trying to be clever rather than a) using the best tool for the job rather than framework/library of the month and b) KISS instead of trying to be smart. I've also seen it far too often among colleagues. I'd also add: please read PEP 8 and follow it, and use tools like coverage and lint to help you clean up the crap. 
Good article but there's no point telling me to write and run unit tests without at least hinting at *how* to unit test.
I haven't heard much about the python code problems in the film industry. Anyone care to send a few links my way?
Hm, the IMDB iPhone application is using an API - not officially supported (at all), but http://code.google.com/p/imdb-php/
I do Python programming in the film (well, VFX) industry, and have never heard of such a problem before... Python is just starting to replace tcsh scripts in many situations.. The author posted something along these lines in the previous post, http://artificialcode.blogspot.com/2010/04/my-midlife-python-quality-crisis.html but I'm still not sure what the alleged problem is..
The first search result for "python unit test" should explain it: http://docs.python.org/library/unittest.html
By the same logic, every "i", "j" and "k" should be highlighted 'cause everybody uses them for loop counting (hence, they are also a "reserved" word.) 
I got the impression that the problem is clueless novices doing bad code. It appears C++ programmers at large enjoy negative reinforcement as far as Python goes. Perhaps the Python gurus should strive to be a little more noisy to drown out the novices…
I found few unofficial IMDb APIs that can return JSON - It's very useful but I think they are against IMDb's policies so most of them were unsupported and outdated. Thanks though, I'll take a look at it. Using JSON would certainly make the output faster :)
Firefox has an addon that does this: https://addons.mozilla.org/en-US/firefox/addon/5648
&gt; Stop being even proud about whatever hideous shit you came up with. *This* is what "Pride goeth before a fall" really means.
You can escape the underscores \\_: lower\_case\_and\_underscores. Or you can use backticks \`blah\`: `lower_case_and_underscore`
Unfortunately unittests is a more or less direct port of jUnit. Nose is the preferred way to do unit tests now. http://somethingaboutorange.com/mrl/projects/nose/0.11.3/
Fireshot doesn't work on Linux, and as far as I can suppose, it cannot be used in scripts. Screenshots from command line is a great advantage
&gt; Nose is the preferred way to do unit tests now. Says who?
I agree the book does have a great intro to python.
As a film nerd and a Python and a burgeoning TCL nerd, I'd love to hear more about how my worlds collide. :) (I'm not fishing for a job--I've lived in so cal and NEVER AGAIN)
What’s New in Python 2.7: http://docs.python.org/dev/whatsnew/2.7.html
Aww, Mac only.
I believe [screengrab](https://addons.mozilla.org/en-US/firefox/addon/1146) works for linux. [Not sure about command line usage yet though](http://code.google.com/p/screengrab/issues/detail?id=13)
All the cool kids who need to have their unittest.main() run by someone else.
I am almost afraid to ask: Why does it seem like Python is fragmenting itself? Is py3k just too different for people to migrate?
Although I haven't migrated yet (still waiting for PyGTK), so far the changes didn't affect me. If you follow the Python guidelines and good practices (e.g. use lists properly instead of using range(), using decorators), things should go smoothly and most of the STL changes should be caught by 2to3.py. (So far, I'm running my code with -3 to check for warnings and, so far, no warnings at all.)
Not really. It's just that there are a lot of libraries that have to get caught up first. Also realize that the Python world doesn't jump on new versions that quickly. As an example, Django is dropping Python 2.3 support in the release due out in a few weeks. Python 2.3 was released in July 2003 -- 7 years ago. 2.6 and 2.7 are there to make porting easier -- if you can run under Python 2.6/2.7 with warnings enabled, most of your code should port via 2to3 once your requisite libraries have a Python 3+ version available. (Which isn't that easy, particularly with binary/compiled extensions -- many native Python packages will run just fine with 2to3).
Learn how to use github. And for file discrepancies, looks like a line ending issue. Make sure both editors are using same style of line endings.
This is an eclipse thing, not a python thing. You need a way to use a different properties.index file for each system. Most version control systems, ( mercurial, git, svn, etc.) have a way to ignore certain files, but track/sync the rest; there are other advantages to using these systems (like being able to "undo" changes), and you should probably pick one and use it! 
Have you looked into `rsync`? There is probably a cygwin version of it, not sure about MacOS X.
You could also make a directory for your project and put the .py files into dropbox, then symlink them to your project directory. Do the same on both computers and you will have only .py files "synced." This way, each computer can have its own settings and etc., but use the same source files.
OSX ships with rsync.
awesome I will definitely look into using one of those. Do you have a recommendation for one with a decent learning curve. The projects I will be 'eventually' doing won't be too broad in scope so it doesn't have to be super feature rich
I develop with python on both os x and windows, and this is exactly what I do. Hook up CVS/Subversion (or whatever other scm plugin you care to use) and just don't add the project files to the repository.
problem with that, just by looking at it, I'd really prefer something that didn't have fee's attached, but thanks for the suggestion.
This would make sense if you're getting the "The interpreter configured does not exist in the filesystem C:\Python26\Python.exe" message on the Mac having sync'd from the PC. Python on mac should be in /usr/bin/python.
this sounds interesting. I tried googling it and was a bit overwhelmed. Do you know of any tutorials or instruction sets that could walk me through the process?
They have a free plan. The only catch as far as I can tell is that you can't have private repos on the free plan.
Says me! :-) Unittest requires you derive a class from unittest.TestCase. There's nothing wrong with it, but it's a requirement from Java that isn't particularly pythonic. Nose just expects certain conventions and handles them as you'd expect. If you've already written your tests using unittest, you can switch to nose and get immediate benefits (like coverage reports). You can also do intuitive things like put "setup()" and "teardown()" in your test's __init__.py.
I use mercurial, because I find it the easiest to use and setup. Just figure out how to 'init', 'clone', 'push', 'pull', and 'up', and you'll be fine. and a file named '.hgignore' tells it which config files to ignore. :)
&gt; use lists properly instead of using range() If you aren't bored can you explain this?
I think NumPy is testing 3.1 support now, so hopefully I'll be able to make the big jump soon!
Oh COME ON! I *just* got used to 2.6!
Some people still do things like they were using C/C++/Java and do things like: for i in range(len(a)): print a[i] instead of for element in a: print element There is also a way, using zip/map/whatever to generate pairs with the count and the item at the same time, but I used it only once and never really got a real use for it (basically, since I had the order from the start, I added it in the list straight away, so I didn't had to "calculate" it in any other way.) Another common mistake seems to try to extract keys and data at the same time with for key, data in l.iteritems(): print key, data instead of the cleaner for key in l: print key, l[key] Amongst other things.
 for key in l: print key, l[key] Certainly looks cleaner in this trivial example, but for those that aren't paying attention, l must be a dictionary. So what do we do with lists when we need an index? for i in range(len(a)): print i, a[i] or for i,e in enumerate(a): print i, e This is one of the corners of python that's less than aesthetic to me. Not that I'm suggesting a better method or syntax
Good call about the dictionary thing. Forgot about that "small" detail ;) I'm not sure if that's Pythonic of not, but if I had a list and had to put the index with the items, I'd do something like this: count = 1 for item in l: print count, item count += 1 Yes, it have more lines, but I think things get more explicit. Again, not sure if that can be called Pythonic or not.
Source??? (Please let it be so...)
Always, always use enumerate for this.
I don't see how (iter)items is any less clean and it's certainly less wasteful.
Actually you can download Win64 binaries from NumPy 2.0 (dev) here: http://www.lfd.uci.edu/~gohlke/pythonlibs/ I haven't tested them, so I have no idea if they even work.
I hate that word "Pythonic". Let's talk about clean code instead. What you're doing there is spreading the meaning of count over three lines -- for readability and reducing the opportunity for bugs, this should be clearly a bad idea. For similar reasons I'm a generally a fan of enumerate() and .items().
Git is also viable and similar to mercurial, 'init', 'clone', 'push', 'pull' (what's 'up' for?). It also has a .gitignore file which probably has the same purpose as .hgignore for mercurial. Additionally, you can setup a bare repository in your dropbox folder that will do the work of syncing your code over your two computers.
OP doesn't need github. S/he can setup a remote inside a dropbox folder and have that take care of all the syncing.
I second japherwocky's Mercurial suggestion. You can get it [here](http://mercurial.selenic.com/), and you might want to read Joel Spolsky's tutorial at [hginit.com](http://hginit.com/). As a bonus, it's written in Python. However, I've never tried to use it with Eclipse, as at work we use SVN.
&gt; **webkit**
It's not fragmenting. All new features in 2.x series since 2.6 are backported from 3.x, so it's actually the opposite.
Through the delay examples that take up half the article he seems to miss the point that [there's a common pattern here, and it already has an abstraction](http://docs.python.org/library/functools.html#functools.partial).
Symbolic links have only "existed" on windows since vista, and their format is filesystem/os dependent so you won't be able to use the same one on windows and mac. Use a version control system. Use either Mercurial or git. Mercurial is generally considered easier to use, although the basic stuff is pretty much identitical between them. Also, hg worked better and easier on windows a couple of years ago, but I don't use that OS so I don't know if it still is. Basically what I'm saying is you should probably use Mercurial. It should only take you between 10 minutes or 2 hours to be good enough to work with it, it's simple and amazing and once you're used to it you will never be able to work without it.
His examples were far too contrived to show much of anything, really. He also hasn't made a case why a class should be preferred to a closure; he merely states it.
WTF? Why on earth would anyone ever write that in Python unless they were doing a high school class on introduction to programming? Yuck. `enumerate`. 
 for i in range(len(a)): print a[i] That works fine in Python 3. In fact, it works better in Python 3 than it did in Python 2, since (as crappy as it is), at least `range` is an iterator and not a list. Agreed that no one should ever have to write that in Python, but you’re dead wrong that this has anything at all to do with Python 3.
Wow, this is the most complete python microframework I've come across. Great documentation too.
Didn't Apple kill Flask? 
Awesome Mercurial tutorial: [hginit.com](http://www.hginit.com)
no you are mistaken, it's [flush](http://en.wikipedia.org/wiki/Flush_%28song%29) a 1997 song by Mötley Crüe
i, j, and k are relics from Fortran in which they *did* have special meaning. In Fortran, i, j, and k have to be integers, which makes them appropriate for use as loop indices. Anyway, PEP8: &gt; Always use 'self' for the first argument to instance methods. And the Python tutorial: &gt; Often, the first argument of a method is called `self`. This is nothing more than a convention: the name `self` has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a *class browser* program might be written that relies upon such a convention. In other words, syntax highlighting is exactly the sort of situation in which treating `self` as a pseudo-keyword makes sense.
I agree. What's wrong with iteritems() exactly? If you're complaining about "cleanliness", that means to me you think it's harder to read/understand when you're browsing through code, which I disagree with.
yeah, it looks like this guy came to python from java rather than to python from ocaml. Some people prefer classes to closures and some people the other way
For those playing along at home, this grew out of the Denied joke framework. Armin was apparently unaware of the strong desire for tools like this, and so many people started asking for the source behind his April Fools prank that he decided to try it out for real.
My favorite reason for using classes over closures is that closures can't be unpickled.
I think your confused. Mötley Crüe is widely known for demonstrating the [floss](http://www.videojug.com/film/how-to-floss-teeth) technique.
Cute framework. But Armin - *global* request variable??? After all the stick you gave me for logging??? ;-)
Why is there a need for a method definition each time? Why isn't it as easy as ruby, something like: @route('/hello/:username'): print 'Hello, ' + params['username'] 
Because it's python, not ruby
There's [unittest2](http://pypi.python.org/pypi/unittest2), which is the Python 2.7/3.1 improvements backported to 2.4-2.6 - it's much the same as regular unittest, but with test discovery (and more assert methods, and tidier internal code) That said, I still much prefer nose (`def test_example():` \\o/)
I meant: how come the guys using python don't require such useful features? Same things with block. I actually wish I could use Python because there's a great scientific community using it, but the language features of Ruby are so nice when actually doing stuff. 
Where you see features others see bloat, maybe?
Using [withhacks](http://pypi.python.org/pypi?:action=search&amp;term=withhacks&amp;submit=search) you could make something that looks like this: with route('/hello/:username') as req: print 'Hello, ' + req.params.get('username', 'friend') A method definition is the most obvious thing to do though. I don't see any issue with it.
Disagree (I think): I want programmers in my group to take chances and write really hard code. We've written about ten really hard apps over the past five years and each one provided a lot of advantages and is still working well. A few got decommissioned because they were too hard to maintain, but even those really helped for a few years. Sometimes I've described solutions to problems that involved scoring, wrestling with billions of database rows, metadata-versioning, etc, etc and had developers say, "that would be hard" and then try to descope the requirement or reduce the usability objective - without any concern to how much it will cost the customer or what the real cost or risks associated with implementing the complex functionality would be. I prefer to avoid these programmers - they end up making very simple &amp; reliable transactional systems - that users then have to game in very complex ways to get their jobs done. 
After messing around with werkzeug for a couple of evenings, going through the tutorial and played with it's internals it took me one afternoon to build a small testsite with sqlalchemy, mako, validation decorators(pycerberus), session, cookie, a REST-ish controller class(baseclass + decorator with UrlTemplate), GET redirect on POST, Ajax, message and parameters over GET(for forms/errors) and more(logging, config-file etc). That's **very** impressive and the end-result was almost exactly how I wanted that site to work. Werkzeug is my micro-framework of choice from now on(without the framework part). EDIT: And thanks for the flask code.
That's really not possible, barring extreme bytecode hacks. Edit: There's a decent chance I can't read.
Because *@route* is a decorator and a decorator decorates functions/methods. [Why](http://www.youtube.com/watch?v=4u2ZsoYWwJA) must you ask so many questions? 
Personally I like keeping my views/controllers decoupled from the url. It means that you can simply call url_for('function_name') and then if you want to change urls you only do it in the original method (as opposed to every time the URL is referenced). I don't think this kind of introspection would be possible with the syntax you described.
You're answering backwards. I'm saying that the current state of @route being only a decorator is not optimal, and solutions like ruby blocks makes it much easier to code and read, and I'm asking why Python doesn't get things like this, I'm not saying I don't understand why in the current Python implementation it doesn't work the way I want!
Came here to say the same thing. Take Example 1, why not just: def keep_state(): return 1 ? He makes no compelling argument as to why using a class is better then using a closure. In the first example, a class and closure are both overkill.
I don't get why? You can always define it like in python ie: def my_function do ... end get '/url1' do my_function() end get '/url2' do my_function() end but since usually an url maps to exactly one function, I find the ruby syntax more appropriate. 
Here the bloat is rather on the Python side, because Ruby is DRY.
I don't see why an explicit method definition is obvious when Python guy end up doing that : @route '/my/url/1' def my_url_1: ... @route '/my/url/2' def my_url_2: ... ie clearly you are defining some method whose name you don't care about because 1. it's only a repetition of the url 2. you only use it at one point, so it is obvious that ruby anonymous methods ( through blocks ) is the way to go here!
Honestly I was just being sarcastic, because you're asking "why" questions that lead to more "why" questions. If you like the features of Ruby over Python, use Ruby. In regards to your hypothetical code example above, my best explanation as to why Python doesn't have a feature such as this is because it isn't very explicit. See [The Zen of Python (PEP 20)](http://www.python.org/dev/peps/pep-0020/)
What if you _do_ care about the function name though? What if I want to wrap more decorators besides @route around the method? What if I want to generate documentation from method definitions? What if I want to import that one function from one module to another? Using blocks you can't readily do any of those, you'd have to do extra work. Functions are one of the fundamental ways to structure python code, not anonymous blocks.
I would not generalize (you guys using Python). In web2py you can do def hello(): return 'Hello, ' + request.vars.name or 'friend' You can define routes optionally in single file as you do in Django using regular expressions or a more compact notation. web2py is designed to be more like Ruby in respect to "do not repeat yoruself" but most other Python frameworks tend to give predence to "explicit if better than implicit".
mdipierro, could you please give an example of what you mean by "protocol libs"? Also, does the code one writes (to create their webapp) call out to the protocol libs, the ORM, and the template lib, but is instead *called **by*** the dispatching portion of the framework? 
Twisted. It'd be a truckload of batteries if included in stdlib. It needs a lot more love first though.
Twisted seems like overkill though. And isn't it primarily meant for networking applications?
[asyncore](http://docs.python.org/library/asyncore.html#module-asyncore) is in standard library. But isn't my favourite one.
I will give you an example in web2py, to avoid any chance to say something incorrect. For example, you can do things like def hello(): return dict(a=3, b='hello' c='world') And if you call http://....hello.json you get the dict in JSON and if you call http://....hello.xml you get the dict in XML. You can do @service.xmlrpc() @service.amfrpc() def hello(): return dict(a=3, b='hello' c='world') to expose the function as an XMLRPC and AMF(flash) service. Web2py has similar APIs also for generating RSS, CSV, RTF and a few other protocols. Full-stack frameworks usually include modules to deal with network protocols other than HTML. web2py is the only python framework in which the user code is executed by the dispatching portion of the framework (very similar to Rails). The DAL (we do not call it ORM not to upset some people here) and a few more API are defined in the context in which the code is executed. In all the other Python frameworks as far as I know, the user code needs to import all modules it needs, including the framework API themselves.
Right now I've got a serious hardon for Eventlet, it's more about async IO than generic event handling though.
Take a look at gevent — http://gevent.org
Twisted all the way. It might seem like an overkill at start, but if you're a good programmer you'll continue to get creative as the project goes on and soon you'll need that obscure feature of Twisted which you thought you would never need.
As already said the idiomatic way to do these two things is: for i, elem in enumerate(lst): print i, elem and for key, data in dct.items(): print key, data And they both work fine in Python 3
&gt; I'm saying that the current state of @route being only a decorator is not optimal, and solutions like ruby blocks makes it * **much easier** * to code and read Really?
You've misunderstood my argument, read it again please.
The opposing way is WET -- Write Everything Twice.
I've only used PyQt and it's signals/slots system is fantastic.
I haven't had a chance to use gevent yet, but it definitely looks nice. Two things it has going for it are speed and a well-designed api.
 while true: pass
http://eventlet.net is more general purpose, gevent was a hostile fork.
It is my favorite - small, simple, hackable, built-in.
Does not run! &gt;&gt;&gt; while true: ... pass ... Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'true' is not defined &gt;&gt;&gt; 
My personal favorite is the tried and true [select](http://docs.python.org/library/select.html#select.select) function. It's actually a lot cooler than you'd think! It'll accept objects rather than simply file descriptors, so you can take advantage of the whole "duck typing" thing. I like to write lots of classes (encapsulating normal files, tcp/udp client/server sockets, etc.) that implement a fileno() and do_stuff() method. Then I let select do the heavy lifting: while True: rfds, wfds, xfds = select.select(FILE_OBJECTS, [], FILE_OBJECTS) for f in rfds + xfds: f.do_stuff() [Here's a complete example](http://gist.github.com/363925) When async-io libraries are overkill, consider this a very simple alternative :)
hmm. android swype is clearly not the keyboard for code authoring
Umm, is there much else? :P
poll/select here too. Used it extensively on a network-level layer for an automated character framework for an open-source (ish) MMORPG. Was simple, experience and easy to maintain. 
drop box or ubuntu one or launchpad ....
[Bottle](http://bottle.paws.de/) seems like a good micro framework as well. I found it on the Denied thread being compared against CherryPy. But the difference for me was Bottle is really just one file.
Never heard of pycerberus before - how does it compare to other solutions (WTForms, Formencode) etc ?
epoll checking in!
pycerberus claims to have been inspired by FormEncode. I had a quick look at the pycerberus documentation, and I would say WTForms certainly fits my way of thinking better. All of the main things which pycerberus does, I have done with WTForms, and everything has gone pretty smoothly.
looks like I got the failure whale from the python dudes ... http://www.youtube.com/watch?v=QDe6MZQjpho&amp;feature=related
&gt; while True: &gt; pass FTFY
I would be excited about it, but it seems to add more complexity and very little gain over just handling my python path by hand. Though what I would be excited about is if someone made a build system that worked off of sub-directories in your project. Like you set-up your pip file and it installs into ~/externals/modules which is in your python path or what-ever. That way you can tar up your app and give to the new guy, put it on a server real quick ... or what-ever (it makes life easier, if only a little... it is easier). Here's where it gets good though. With this build system (that I want to exist but lack the time to develop right now) you can have it set-up subrepos or svn:externals or what-ever when you add a new plugin or external tool. It would also have a system to update and manage your mirror auto-magically, etc. I feel like PIP, easy_install are a step in the right direction... Though they are missing something crucial. I fairly strongly feel that this crucial component is not virtual-env.
That's its target market. I've also used its Prospective Broker for IPC. It really depends on what you're doing.
If you look inside, its a thread-local global. I agree it would be cleaner to pass a request object to the handler though (a la juno).
I think PyPy was moving drastically forward even before. Now you started to pay more attention (and we improved our public relations I think).
[Take a look at this link](http://nichol.as/asynchronous-servers-in-python) It has code examples and comparisons of a lot of mentioned frameworks/libraries. Currently, I find myself using the Tornado / ioloop.py very often. It is the core event loop on which Tornado web is built on. Why ? No reason other than that it works and it's fast. Then again, a lot of these libs are.
how serious is the hardon ? you probably should see a doctor
Yes, and I am not happy with that. It does use a stacked thread and greenlet local object behind the scenes so it's not as problematic as logging in that regard, but I did mention that as being problematic for larger applications in the documentation: http://flask.pocoo.org/becomingbig.html#what-could-be-improved
It's lasted for more than 4 hours, that's for sure.
although I'm a python programmer, I use node.js for event handling.
Seconded. gevent is really clean, and the greenlet model of asynchronous handling is a joy. 