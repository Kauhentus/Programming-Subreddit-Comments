This
And if you do this, please, consider software assisted refactoring to check your progress.
&gt;I was thinking of making simple site to track progress of Python 3 adoption and why people are still using Python 2. Do you mean a site like this? https://python3wos.appspot.com/
In fact, PEP8 states: Some other good reasons to ignore a particular guideline: *** 2. To be consistent with surrounding code that also breaks it (maybe for historic reasons) -- although this is also an opportunity to clean up someone else's mess (in true XP style).
+1 for the twisted note that it will move on with the coming tulip pep acceptation.
scientist here with a soft spot for Qt GUIs: i use python 3 for everything and am never tempted to use python 2 since the day Django became 3-compatible.
I prefer yaml. Then validate the config with a schema validator like: * [JSONSchema](https://pypi.python.org/pypi/jsonschema) * [Validictory](https://github.com/sunlightlabs/validictory) * [Voluptuous](https://github.com/alecthomas/voluptuous) * etc
I'm stuck in 2.7 because ArcPy is for 2.7.2
Comments from the peanut gallery: * Is the import going to be 'pathlib'? I thought the renaming going on of std lib things with the transition to Python 3 sought to remove the spurious usage of appending 'lib' to libs? * Is the PyPI project still going to see regular releases or is this project going to become unmaintained? * This package is good. It makes dealing with paths a lot easier and it belongs in the std lib. Yay.
 &gt;Are you using them on production? I hate to say it but your question is a bit silly. Really what does "on production" mean? Look at the libraries and tools he is using, most likely this is a professional endeavor, then again maybe not. In any event I think you are way off base with your questioning here. You need to realize that Python is used in many diverse ways. "Production code" could be something ran once to digest data in an experiment, a system maintenance script never to be ran again or a bit of code for genome research that is updated constantly. In the end what in the hell do you mean? 
While it might not be time yet failure to move to Python 3 will be a problem. It is no different than C++ really! the new standard is very good, it is almost a brand new language, as such you can only stay with the pre C++11 standards for so long before you become outmoded At this point any good programmer that expects to stay in the field for a while should have a plan in place to transition to Python 3 in the same way any good C++ programmer is looking to expand his horizons by transitioning to C++11/14. In neither case is the transition mandatory but it would be foolish not to see the writing on the wall. Oh by the way in both cases (Python 3 &amp; C++11) the reasons to move forward are compelling. 
Production to me means that the Python code base is a customer facing system that is being used regularly. 
PyPy is currently only Python 2, there is a beta release of PyPy3k which supports Python 3. There's also no plan for PyPy to drop support for Python 2, unlike CPython.
It's not obvious, actually. It all depends on the line of work.
There are some examples in the source repository: https://code.google.com/p/tulip/source/browse/#hg%2Fexamples Generally though, asyncio/tulip is intended for anywhere you're doing concurrent IO such as: * Webs apps (handling multiple simultaneous web requests in a single process) * Game servers which communicate over a network with multiple players simultaneously * Scripts that download multiple files simultaneously and exit when all downloads complete. Some places where you probably wouldn't use asyncio/tulip are: * Scripts that read a file from disk and process the data * User interactions in a GUI application (as far as I can tell asyncio/tulip isn't a generic event framework, but I could be wrong) * Fibonacci sequence generation.
Could you suggest a language that does? I mean honestly we'd love to stick with python (Eve Online is written almost entirely in python, and at the very least their servers run stackless. Eve also has (or at least had) the record for most servers running in that way in a game, so I think that holds as a testament that python is pretty capable) but we would really love to move forward with this game - we have to really neat ideas and our over all goal is to post it to kickstarter or something to see if we can get some interest in it.
asyncore is quite rudimentary and has many limitations, for this reason it's never really found widespread adoption.
&gt; PyPy is currently only Python 2 I know that, if you read my comment again you'll see where I wrote "Let's say PyPy somehow.." I never said it does those things. I could have as well used GIL elimination or some other awesome killer feature, that was the point. What I wrote is not totally unreasonable and Python is already trying that -- adding cool new features to Python 3 only hoping it will be a sweet enough carrot to make people switch to it.
I resisted Python 3 for a long time in hopes that it would not be the future. Today, I try to do new development in 3 but old habits die hard. The "python" binary is still Python 2 so various legacy scripts don't break, and I have to remember to use python3 instead, which I rarely do. The biggest real problem is that MySQLdb isn't ported to Python 3, but I imagine I can overcome that by using [PyMySQL](https://github.com/PyMySQL/PyMySQL/) instead. It is meant to be a drop-in replacement.
Clearly it means "Are you using them to dick around with or are you dependent on them for current and ongoing work".
Wow this was an excellent explaination. Thanks for taking the time to make all that. So for example could I use this in a djang application to get and post? Like import pants and have views and templates a synchronously update? 
I am similar. I use it for most data analysis, visualization etc (still us R though for more hardcore stats, even if I call it within python). I also use it for reporting, ie generating reports and emailing them to the exec team. I use it for data harvesting, web scrapping and crawling, etc. and finally I use it for ETL processes via APIs etc with various data sources. 
If it is so obvious, why do you and /u/scopegoa understand it in different ways: &gt;Production to me means that the Python code base is a customer facing system that is being used regularly. and &gt;Are you using them to dick around with or are you dependent on them for current and ongoing work You could very well be using python (especially the whole scipy suite of libraries) for real work without using it in a customer facing system that is being used regularly.
`mock` is not part of Python 2.7. It was developed as a separate module, and put into the standard library for Python 3.3. You must have already had it installed on your machine.
do you really have a hard time figuring out what "production code" means? have you ever shipped a product before?
Only issue I have with this atm is that it uses dictionaries in it's return, I really wish I could specify returning object with attributes instead
Time to get a better font.
Like an SDET?
No, I won't complain about Sublime. Time to get better eyes, maybe.
ok, i'm totally new to this stuff so sorry to waste your time. By STM do we mean like what Clojure has with atoms, refs, watchers etc? Would Python eventually have true concurrency? 
Yes, or for what counts as production in my fields. In-house GUIs, scientific GUIs, interactive data exploration, library development and testing, teaching, algorithm prototyping and testing, automation. That's what I do.
I am using Python 3 and cherrypy for a new project at the moment, I chose it mainly because even though the GIL wasn't eliminated the way it functions has been improved. When tulip is folded into the standard library I see that as a deciding killer improvement. 
one possible example: for i in xrange(5): x = Point(3 + (i*10), 3 + (i*10)) y = Point(99 - (i*10), 99 - (i*10)) 
What do you think of the model underlying d3?
I added that into my code but it still only gave me the one rectangle and not the other ones. Is there something im missing? Sorry im really new to this and only just recently began studying
you have to put all the calls to the rectangle methods *inside* the for loop. if you want, share what you have now.
This is what i have (http://pastebin.com/UMP2jVY8) 
Agreed. Python 3 is unquestionably a better language, but for me at least, there's still not enough incentive to fully switch my projects over. Porting old code, porting dependencies that aren't version-agnostic or don't have Python 3 versions, etc. Some day (perhaps by Python 3.5?) most people will end up switching over for good, including myself, but it's not quite the time yet for me.
Yes that worked! Thank you so much for your help, I see so i have to indent all of the lines for it to be in the loop and not just the first one? I think i was over complicating it and adding code in just to try make it work. In the future I will try and go through each line and understand what it is doing. Thank you :)
yeah that is quite tricky with python if you are new. no brackets or parentheses; just indentation. don't forget the lesson: it can be more confusing with more complex programs. good luck and don't give up. 
I use Python 3 by default, but if Python 2 is the only option I try to stay compatible with Python 3+ as much as possible to make a future transition to newer versions easy. Some dependencies don't have support for 3, but it's usually quickly fixed with a fork on a pull request. :) For open source projects I make sure my code works in both 2 and 3.
This looks like good stuff. I knew there were some issues with the os.path library before, but I didn't realize how easy it could be before I read this pep.
This looks awesome. I always thought the existing os.path was a little awkward. 
i was going to say something snarky about .net already having this 10 years ago, but the api does look nice, so really I'm butt hurt that all that time spent learning os.path wishing I had something like the .net api etc... but finally getting used to it and using the shit out of it, is for nothing if I (presumably) "move" to python 3
.net API is portable ? ^_^
if os.path.exists(os.path.join(fucking, finally)): print("yay")
&gt; Is the PyPI project still going to see regular releases or is this project going to become unmaintained? Sounds like it will be maintained. Antoine Pitrou posted this the python-dev mailing list yesterday: &gt;pathlib up to 0.8 (on PyPI) has a different API - since there were so many changes done as part of the release process. &gt; &gt;When pathlib-in-the-stdlib stabilizes, I plan to release a pathlib 1.0 on PyPI that will integrate the PEP's API.
Snippets, man. I've never actually typed `if __name__ = '__main__':` on sublime, just if and them autocompleted with the right snippet.
Software transactional memory, the PyPy donation page does a better job explaining what they're trying to accomplish - http://pypy.org/tmdonate.html
Start contributing to some open source Python projects, that will give you some real world experience in a Python. Also open source contribution looks really good on a resume (i.e. giving back)
Is this a bug? print Path('test/test2/.thumbnail.jpg').ext .thumbnail.jpg I would've expected it to be a bit smarter and "detect" hidden files ... but maybe Posix defines everything after the first dot as the extension? See: https://bitbucket.org/pitrou/pathlib/src/b393963cdf9dd02b13fe5ac53709f4d4bc48363a/pathlib.py?at=default#cl-891
haha, reminds me of spending hours looking for a god damn semicolon
I have put app = Flask(\_\_name\_\_) twice, left it at the end of the file, couldn't for the life of me figure out why my @app.route decorators weren't working....
I'd guess it is a bug, since os.path.splitext goes out of its way to ignore leading dots, it seems like it would make sense to do the same here.
http://dev.mysql.com/downloads/connector/python/ The Oracle MySQL connector supports python 3.3
I'm still sad it allows `.join('..')` this makes it must easier to accidentally allow directory traversal attacks, compared to if it required you to type `.parent()`.
Has the most recent update to ArcPy sped it up? When I was using it a couple years ago on whatever version was on 2.6, a lot of geodatabase functions were painfully, atrociously slow. I talked to the lead dev of ArcPy at PyCon that year and he said major speedups were en route... wonder if that panned out.
We're using Python 3.3 and shipping to large customers. We're pretty lucky in that we don't depend on any of the big hairy third-party libraries. There was some minor porting involved, but not much. We were using 2.5 (Fedora 10), and I successfully argued that modernizing our code base would require a similar amount of effort to go to 2.7 or 3. I underestimated the work required (surprise!), but actually not by that much (remember, not a lot of external code). There have been some gotchas and some pleasant surprises, but I think we've enjoyed a net benefit.
I never liked that python naming convention.
I think it has, I have no empirical evidence for that though. I mean, I know things in ArcMap are slow with large datasets, and now, I'll write a python script to deal with large datasets, as that is faster. 
They are working on writing better documentation. http://bugs.python.org/issue19291
I find this kind of bugs is exactly where rubber duck debugging is helpful. When you stare at the code for a long time, you can become blind to obvious mistakes.
That sort of error is an indication of design defect in Python. In this case the design affords improper use.
Hm, I just cloned pathlib and there is no suffix function ...
You can change the font in Sublime Text...
hahhahahaaha! YOU are not an Idiot, or if you are idiot then so are the rest of us. But it's still pretty funny.
i was having some problems with django once not loading changes to my models, after having moved them into a new models/ directory. turns out i had missed a lingering .pyc file that it was loading. stupid .pyc
How is it any different from trying to track down mismatched brackets, or a missing semicolon, incorrect indentation, or any of the other various syntax problems that plague _every language_? I agree that it might be a difficult issue to spot, but so would `http:/www.google.com` if you're not paying enough attention. Granted, the interpreter could easily define a variable `__main__` that is set to `True` when the script is run and `False` otherwise, so that you could do `if __main__:`, and it would have raised a `NameError` instead. Except that this would conflict with the [`__main__`](http://docs.python.org/2/library/__main__.html) module, which allows you to access the otherwise anonymous namespace of the main script. And, the `__name__` variable can be used for other purposes as well. But if you have such a problem with it, why not submit a PEP suggesting an improvement? If you can provide a convincing argument of why this is actually a problem and not just an occasional inconvenience to the inattentive, it could get accepted and integrated into the Python standard.
if it makes you feel any better, it took me a while to see that you forgot an underscore in your code, and you only had 1 line. 
Been there done that. Incremental deployment trolling ya.
See the [comment](http://www.reddit.com/r/Python/comments/1r5t7n/pep_428_the_pathlib_module_has_been_approved/cdk3pkv) above from /u/nickcash. Apparently there are still a fair number of changes to be made before it gets integrated into the standard library, right now it's at 0.8 on PyPI, but the standard lib release will be 1.0 with several API changes.
I think your question has been answered sufficiently, but I have a few other tips since you are here for advice: 1. Start code with four spaces on reddit to get it to be monospaced. 2. You don't need to initialize x with `x = 0`. 3. `continues` can lead to less readable code sometimes. If the above didn't make sense, convert the problem line to something simple like for x in range(5, 10): if x % 2 != 0: print x which may help with the next troublesome line you run across. Otherwise enjoy programming and look for feedback often!
Have you tried sails.js? http://sailsjs.org/#!
This is the real way forward, TBH. Vendor-supplied &amp; supported software. It even comes with a django-specific database driver in the development version, however I was unable to get that to work (with v1.1.2, I see there's an update now) 
&gt;(i.e. an entire platform update) I'm going to armchair quarterback here and say, "Don't let your OS package manager dictate what version of software you can run!!" Build from source and use virtualenvs. Yes, I know you were speaking to the larger issue of porting (to which I agree -it is a tough sell to dedicate resources 'for nothing'), but letting your hands get tied by your OS is a no-no.
https://en.wikipedia.org/wiki/Real-time_computing
&gt;Python 3 is unquestionably a better language Examples? I honestly have not kept up too much with the development. Unicode default - no question, it is the future, but how much more has had a real impact at improving the language? Removing the functional stuff (filter, map), defaulting to xrange, expansion of the std library, etc doesn't seem like anything ground-breaking and pretty iterative.
You're not an idiot, you're a dunderhead.
...This is for Node, though, not Python.
One minor thing that really bothers me is the ordering is wrong. SELECT * FROM foo WHERE Why the hell is select at the top? It is the last thing to happen when there is clearly a sequence of events which happen in a statement. It should be something like: FROM foo WHERE x &gt; 5 SELECT *
Yup. At my company, the Test Engineers use Python/Ruby to build automated tests at the unit, integration, and functional levels. In addition, TEs are well suited to build applications for people in the business to assist with manual QA (or UAT - User Acceptance Tests). Apps to let them kick off test runs on their own against branches, or take screenshots in different browsers, etc. It's a great way to onboard SEs because they get exposed to the entire stack, from tests to deployment, and also learn how to interface with the business side effectively. IMO, it's the ideal role for junior engineers to start out and then work their way up, provided that the organization allows for it (ours is specifically built to have TEs be the 'farm team').
..fun?
As a manager, I should mention the obvious downside that this means I'm pretty much constantly hiring and onboarding. While it's difficult to manage the mentoring aspect with all my other responsibilities, we also build in a transition plan so that the TEs that are moving on to SEs assist in the training and hand-off of responsibilities.
&gt; Python 3 is certainly the future. I won't disagree there. I will. It's the present, and in fact almost 5 years (10 internet eternities) into the past. Most folks are buying a new computer in that timeframe, software has to keep pace or be left behind. The "stick with python2" movement attracted many vocal minorities who derailed the natural obsolescence of Python2 by making false claims out of sheer laziness or cluelessness. Many developers have proved how easy it is to move to Python 3, even maintain dual 2/3 compatibility, and their software will live on long after essentially unmaintained software like Twisted and gevent has long been forgotten. Don't forget to include in your ROI calculations the increasing cost of maintaining experts in long-dead esoteric hardware and software platforms, like those guys still trying to run COBOL on AS/400's today; as well as the cost associated with catastrophic failure (e.g. go find a IDE hard drive to stick in your 20 year old server with python 1). People doing up these matrices often have cognitive dissonance between the assumed cost of sticking with the status quo ('0') and the actual cost of doing so ('millions+'). 
I feel your pain op! I used Python and MySQL and played with different datasets, massaging and storing just fine! I then had to do the same at a different job. This time using MS SQL Server. Used pyodbc. Used a similar approach, did not work, no errors but the data was not saving back to the db! Spent a long long time. I then finally realized I was missing cursor.commit() !
Try a semi after a 'for' statement in C. "How come the block statement always executes? But only ONCE? And the index variable is always set to the end of the range when it does? Must be a compiler bug!" 
The thing with using software like pants or tornado is that the software has to be written to take advantage of them. Django... isn't. A lot of software isn't, in fact. The WSGI interface used by django and many other libraries isn't designed for interoperation with asynchronous frameworks. You can use django with Pants. There's a WSGI connector that you can connect to django with and serve HTTP requests using Pants, but much of the benefits of the asynchronous library will be gone. django won't take advantage and it will block, doing things like database requests. The only real advantage is that Pants will asynchronously write out the responses... though that can be bad too, as it means a new request could block an old request from being sent completely.
I used to have a ton of snippets for PHP dev back in the day, but I never really got started on building a nice library for myself in Python. Any chance you've got some "universal" ones you'd consider sharing? 
So when do I use pants? Do I have to build my own setup to use it? Like how would I fill html with asynch data? How do you use it? (If you do)
https://en.wikipedia.org/wiki/Real-time_computing
I agree there is a danger there, but de-facto banning of .. joining feels a little heavy handed.
Spent 20 minutes on 'pnrit' trying to figure out what the bug was.
Pants is still a very young library, and there's still a lot of work to be done with the HTTP stack to make it easier to use. Plus, there aren't any third party libraries for interacting with databases and other things just yet. I wouldn't recommend that a beginner starts with Pants right now. Not for HTTP, at least. If that's what you want to work with, I'd suggest starting with something like Flask. Just stick with synchronous code while you're learning. It's easier that way. There are more examples and modules for making your job easy. Answers. You will need to build your own setup, as you put it, to use Pants. To put asynchronous data into an HTML document, you'd need a string of callbacks. Something like... from functools import partial from pants.http import HTTPServer from my_app import db def request_handler(request): db.table.get(id=request.get['id'], callback=partial(part_two, request)) def part_two(request, data): with open('template.html', 'rb') as f: content = f.read() request.send_response(content.format(**data), headers={'Content-Type': 'text/html'}) HTTPServer(request_handler).listen() I use Pants for a game server under development, my [yet another pastebin](http://putco.de/), and I plan on possibly developing a multi-protocol IM client on top of it in the future. For now, most of my time with Pants is spent developing new features.
Or I guess just waiting for that first 0 art to succeed then it does the filling of the html part. 
Yeah, it only calls the ``request_handler`` method once for each HTTP request. That method calls ``db.table.get`` in that example, which will do its own work, and then call the callback ``part_two`` when it's finished and has the data ready. Note that I use ``functools.partial`` to bind the ``request`` variable as that's our only way of interacting with a specific request. In ``part_two``, we have the data, so we just have to fill in our template and send the response.
This seems to me like a kind of "classic" python shortcoming. These are the kinds of things, warnings from a compiler would be hugely advantageous but we do not get such an environment for development within python. This to me seems like THEE major crutch to development in python. EDIT: To be clear I like how quickly you can develop in python but I am saying it comes at a price.
Haha ouch... I think I can guess why you didn't, but using a list there would have saved you that trouble, so long as your semantic OCD doesn't kick in...
A graph. A list of lists should work fine. 
 &gt;not knowing how to blacktext on reddit.
http://imgur.com/ueid672 May I suggest [Anonymous Pro](http://www.marksimonson.com/fonts/view/anonymous-pro)? 
Also check out [Parakeet](http://www.parakeetpython.com/). It's sort of like Numba, but makes some different tradeoffs. Pro: * currently supports more of NumPy than Numba * high level optimizations + parallel backends = often faster Con: * Most of Python won't work in Parakeet. No exceptions, objects, &amp;c * Numba has broader ambitions for supporting more of Python in the long-term, Parakeet will always be limited to a few data types (arrays, scalars, tuples). * Currently doesn't work on 64-bit windows * Cryptic error messages with long-winded stack traces I think, at the moment, Parakeet is better for higher-level array oriented code and Numba seems better suited for code that's (1) written mostly as loops or (2) needs to interact with some Python objects besides arrays. Disclosure: I'm the author!
Why not, it's not *that* good. especially on Linux where not even drag&amp;drop of selected text passages works.
You can write a prefix tree, and have a special token to mark the end of the string. It will take O(n) to construct the tree, but it will be a lot more space efficient since file paths usual share a long portion of the prefix.
The ifmain guard always reminded me of the CPP include guard.
This is the royal we I assume.
good idea, we should subclass the path classes to create ChrootPath, whose `.root` attribute is fixed at creation and on which operators and methods can’t create a parent path: root = '/home/me' # or Path('...') parts = ['Documents', 'Python'] p = ChrootPath(root, *parts) assert p.root == '/home/me' assert p.parts == ['/', 'home', 'me', 'Documents', 'Python'] assert p.is_absolute() assert p.join('..', '..') == ChrootPath('/home/me') assert p.join('..', '..', '..') == ChrootPath('/home/me') assert p.parent(6) == ChrootPath('/home/me') assert list(p.parents()) == [ ChrootPath('/home/me', 'Documents'), ChrootPath('/home/me')] ...
The `.glob` and `.match` syntax for matching paths from PEP 428 seems similar in function to e.g. stdlib `fnmatch` and various web frameworks' route matching features: PEP 428: The `pathlib` module -- object-oriented filesystem paths * http://www.python.org/dev/peps/pep-0428/ * https://pathlib.readthedocs.org/en/pep428/ * https://pypi.python.org/pypi/pathlib * https://pathlib.readthedocs.org/en/pep428/#pathlib.Path.glob * https://pathlib.readthedocs.org/en/pep428/#pathlib.PurePath.match Python stdlib `fnmatch` and `glob` * http://docs.python.org/2/library/fnmatch.html * http://docs.python.org/3/library/fnmatch.html * http://docs.python.org/2/library/glob.html * http://docs.python.org/3/library/glob.html Web Framework Route Matching * http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/urldispatch.html#route-pattern-syntax * https://docs.djangoproject.com/en/dev/topics/http/urls/ * http://flask.pocoo.org/docs/api/#url-route-registrations 
Oh the number of compiler bugs I have found... that later turned out to be my own mistakes. 
The end result of a lot of people like you is that python is becoming incredibly unfriendly to newcomers.
I'm not sure the author made a very good argument. He seems to just state his experiences he's had with different programming languages and then points out what he thinks are couple pros and cons with each throughout his research career. He starts off talking about cons with MATLAB then talks about Python, then he mentions Octave and then JRuby. Then talks about the pros of MATLAB with being able to load an updated file and quickly do some analysis with it. Then he concedes Python is probably a good choice since most people he's meeting at machine learning conference is using Python and scikits-learn. Then he ends by saying nowadays he works with Java and Scala. Because of this, he just seems to be all over the place with toolsets or programming languages he uses. What makes matters worse, he talks about liking MATLAB because he can load data in memory with it and then quickly do data analysis with it in a step by step manner. Hmmm...hasn't he heard of IPython notebook? Anyways, I feel like maybe he is trying convey that one should use the best tool for the job. If so, then this should be his manifesto or title for his article. I get how Python became the language of choice for data science, but the way the article was written, it doesn't seem clear that the author himself prefers to use Python, but would in some cases use MATLAB, in another case use JRuby, and in another case use this, etc.
While there are differences in scope (`.schema`, `.query`, `.fragment`) from `pathlib.Path`, a comparable API for URLs and URIs might be helpful (`.parts`, [...]). http://www.reddit.com/r/Python/comments/1r7h1t/python_objects_for_working_with_urls_and_uris/ 
2001: http://mail.python.org/pipermail/python-dev/2001-August/016663.html 2003: https://mail.python.org/pipermail/python-announce-list/2003-January/001984.html 2006: http://www.python.org/dev/peps/pep-0355/ 2013: http://www.python.org/dev/peps/pep-0428/ 
Perhaps you should start getting comfortable with a debugger, getting used to stepping through code, using breakpoints etc.
I think there's actually no reason the Python compiler/interpreter couldn't give a warning here using the same heuristics as the C compiler. Right?
I agree, ```if __name__ == '__main__':``` idiom is ridiculously ugly. Huge eyesore.
That should never happen if you integrate flake8 in your editor (which you should)
Some of the hardest to find bugs are the most obvious things.
Define "production". I'm a scientific python user, I start every new project on Python 3 but occasionally drop back to Python 2 if a tool a really need isn't available. That's pretty rare now - Paramiko for ssh niceities being the most annoying . The real killer feature for my on Python3 is unicode - I curse developers regularly for producing code that claims to be unicode but manages to completely mangle commonly used accent characters *cough*java*cough* - I suspect this might be a product of so many developers being english/from USA and never giving their unicode support a real trial by fire. Python3 has solved all of those headaches for me so far. I really respect the python dev's for making that a priority over "sexier" things like addressing the GIL (now sort of done with the async module) - it's one of those not very visible things that makes a lot of non-english speaking people's lives easier - people who's voices are probably much less heard in the english-centric software world. 
Jesus Christ- I've heard *a lot* of complaints about SQL databases over the years but this is just ridiculous. Grasping at straws there, mate.
Bytes me every time I try to use sqlite prepared statements after a long break.
If you want to use GTK, I've played around with pygobject. I wouldn't recommend it because of the lack of documentation. Most of my time using it has been spent googling and reading random stackoverflow threads. 
This one is built-in on Sublime, as far as I know. Those are the only ones I use, really, the built-in ones, plus one or two I made for Jinja2 templates.
Eve Online actually uses a lot of C++ code, especially for the networking! See here, for example: http://community.eveonline.com/news/dev-blogs/2332 Python has always been neglected for games development, sadly. This is mostly a circular problem, where the lack of good support has kept many people away and convinced others that there's little demand for it. Then you get people with their head in the sand who don't admit that the GIL is a problem (it is) or that garbage collection can be a problem (it is), or that pygame should be enough for anyone (if you think rendering technology hasn't changed in twelve years), etc. The only language where I know the networking libraries well is C++, but I wouldn't recommend that beginners write a game in that language. A good compromise is C# - it's got many of the benefits of Python but is much better supported by game developers, eg. through Unity, Monogame, etc. (A better place to ask about technology for games would be www.gamedev.net/index, by the way.)
&gt; We were probably just networking with PodSix wrong. It would be awesome to find a "here's how MMOs are networked" article that goes a bit more in depth, but honestly I haven't found any. There isn't really anything MMO specific that would cause your TCP-based solution to fail but a UDP-based solution to succeed. Either the library is intrinsically broken (unlikely), or you sent too much data too often (possible), or you were using that library in a weird way (eg. not pumping the events often enough). Although I've not used PodSixNet, I've used the standard library functionality that it uses, and it worked fine for a 'small MMO' I had online last year. MMO networking varies significantly from game to game but ultimately it's not much different from FPS networking except you don't tend to send as often nor do you spend as much of your development time worrying about complex interpolation or prediction issues. As I mentioned elsewhere, gamedev.net is a good place to read about game specific issues, especially the multiplayer + networking forum.
You can apt-get fonts? TIL.
Thanks, Ill look into this.
I use snippets a little bit in Vim - especially `unit` to setup unittest boilerplate and `test` to create a new, blank test method - but there's so little long-term repetition that I rely more on word (`&lt;C-n&gt;`) and line (`&lt;C-x&gt;l`) completion based on things I've already typed.
The more I've learned about the deeper internals of python, the less elegant a lot of it has felt to me. It has some nice things going on, and some cool syntactic sugar, but I've cringed at too many things now to call it really elegant.
Not to be *that guy*, but Vim solved all of these problems for me. Well, and being able to touch type, so I'm always looking at and reading the code as I type it, but that should be a given for a professional developer, I think. Proper syntax highlighting marks lots of known oddities in red, and it's not too hard to add new matches. If I mistype `__name__`, it doesn't change color to match other known identifiers, and I'm watching as I type it, so it would stand out to me that it just looks like a bareword. The `abbreviate` command lets you create abbreviations as easily as `:abbr _name__ __name__`, which will convert the former to the latter when you finish it up with punctuation or a space, so you can add all your common mistakes and have Vim correct them as you type. I use Vim's `&lt;C-n&gt;` (Ctrl+n) to autocomplete the word I'm typing, and I've made that muscle memory, and use it for everything, so after I've typed a variable name once, I never type it out again. If I type `foobarVar = 3`, the next time I need the var, I type `foob&lt;C-n&gt;`. In the last 2 years I've mistyped only 1 identifier, and it was so bizarre, I stopped work for awhile to ponder how that used to be normal for me, and it just literally never happens anymore. I even got up and went to tell a coworker, because it was such a strange moment (if you guessed they weren't interested, you are correct). I also use `&lt;C-x&gt;l` to complete a line that I know I typed before, and don't feel like being bothered typing out again, or screwing up, so errors in duplication mismatches are also pretty much gone. I do TDD these days as well, and I can run my tests in seconds with a mapping from Vim, so I have a continuous, compiler-like check on every single thing I've added, as I work. Every minute or two I'm getting a result that says whether or not I've broken something, or have been wrong about what I typed, and if I am, it's almost always in what I just typed seconds earlier, so it's super easy to find and fix. A compiler would help with things like type-checking, but there's way more that a compiler won't check that my tests will.
This used to be the case for me, but I've recently realized that it doesn't happen to me anymore. I've been developing professionally for 11 years, and I had every problem there is in the early and middle years, like forgotten semicolons, and off-by-one errors, and so on. Now, I never have those issues. I credit this to Vim, TDD, and solid touch-typing (I wrote about why in another comment). Maybe twice per year I'll have a problem like that, and I'll disappear into my mind for a minute in sudden realization that I found my way out of the woods, and that I can focus entirely on the larger picture now. The last year was all about hierarchy, and what a mischievous devil it is, though it never appears to be.
Time to get a language that doesn't require dirty hacks for this kind of thing.
Using snippets is admitting that your programming language lacks abstraction power (or that you are incapable of using it).
Had this once: appeπd
How? I didn't notice any font options in the default or user preferences.
any missing functions can be added in. And strings 'abuse ' the % operator to use with formatting, so i dont see whats wrong with the '/' formatter for path operations
I said it was a minor thing. No different than the hordes of people who complain about Python indentation. If you wanted serious issues you could start with the utter lack of vendor standardization or the black magic required optimize queries. Honestly, though, were you to redesign it from scratch, would you really keep that style? It doesn't make sense.
How did that happen?
I think it went like this: ALT-p is PI on my keyboard, ALT is next to CTRL. I tried to auto-complete with CTRL-p in vim, accidentally pressed ALT-p and it added the PI instead, I then added the 'd' myslef. But I'm not sure.
Your font is called sublime? 
Wanna bet?
No, my [editor](http://www.sublimetext.com/) is called Sublime.
Well, at least you πoticed it before too long. That's really funny.
Following on from that -- if SQL doesn't make sense. Then what does?
Gotcha. 
The "font_face", "font_size", and "font_options" config keys are what you're looking for. 
Preferences &gt; Settings - User: { "font_face": "great looking font", "font_size": 13 }
I find it mildly amusing that someone who was working at the [Fraunhofer Institute](http://web.archive.org/web/20080704065939/http://513rocks.com/MP3_Todays_Technology_158.shtml) didn't like having to pay to use MATLAB. Anyone who has ever wondered why many Linux still [distributions](http://en.opensuse.org/Restricted_formats#MP3) cannot play mp3 files "out of the box" probably feels a similar annoyance.
Yes, my thoughts exactly. I'll be sticking to unipath in my projects but I guess having Pathlib in the stdlib at least better for the average novice user than continuing to wrestle with os.path
We are all idiots at one point in time, don't worry. Just don't forget this one. 
 aptitude search tff~n
I agree about the missing functions.
"Although mostly speculative, [number of followers] difference might be explainable by a massive wave of spam-bots targeting popular users back in 2009 when Twitter experienced some unprecedented growth in its number of users." Didn't know this. Great post!
It's hard to go wrong with either, there are plenty of dev shops that focus on any of Ruby/Python/PHP. Interestingly, Reddit itself is [built with python](https://github.com/reddit). Really learning a language, how to test, how to write it "like a native", how to deploy, what channels to pay attention to to stay up to date -- it takes a lot of time. You might consider giving your self a week on each language and see which one fits your brain better. I personally chose Python because I like the consistency and beauty of the language itself, but also that it's very strong in all the areas I tend to write code. Flask for lightweight API's and apps, Nikola for blogging, Pandas/numpy/scipi for doing number crunching, Django for "big apps"; and it's what OpenStack and Graphite are built with, both of which I use and have needed to be able to read code of to troubleshoot.
most of it is already avaiable in path.py, but it is good to see it in the future standard lib, with Pitrou behind it. (path.py is orphaned IIRC)
The direct link to the IPython Notebook is here - http://bit.ly/I2YdVW
New code should not be using the string '%' operator because it has been replaced with the string.format() function. And in any case this was always an anomaly; the only other overloaded operators in the standard library are obvious arithmetic functions like adding a timedelta to a datetime. 
this is excellent! can you put it up on pythonanywhere?
Also python prints a syntax error, instead of running it anyway. &gt;&gt;&gt; x = 4 &gt;&gt;&gt; y = 6 &gt;&gt;&gt; if x = y: File "&lt;stdin&gt;", line 1 if x = y: ^ SyntaxError: invalid syntax 
Really cool insight -- surprising to find out that O'Reilly has 3x more followers than Mayer and that Gaga has 20x more than O'Reilly.
As well as going down the prefix trie route, you might want to test it against interning strings. Something like: &gt;&gt;&gt; from pprint import pprint &gt;&gt;&gt; pprint(paths) ['/really/long/path/to/file1', '/really/long/path/to/file2', '/really/long/path/to/file1000'] &gt;&gt;&gt; saved = [[intern(section) for section in path.split('/')] for path in paths] &gt;&gt;&gt; pprint(saved) [['', 'really', 'long', 'path', 'to', 'file1'], ['', 'really', 'long', 'path', 'to', 'file2'], ['', 'really', 'long', 'path', 'to', 'file1000']] &gt;&gt;&gt; Being interpreted, some of the savings found in compiled language versions of data structures might be modified when implemented in Python.
openstack is not built with django, the openstack dashboard is though. 
either + both also nodejs 
\\\_\\\_main__
I don't have a lot of experience with Python, do you have some specific examples?
Which of these do you prefer? I'm looking for something like this, so I'm curious.
Now how do I save it to disk and do efficient inserts and lookups on disk?
See how long your comment is? That's yet another indicator that this is a design flaw. Design flaws are compensated for with copious documentation. Another good example is the GIL. Look at all that has been written about the GIL. A classic design flaw.
Is it thread safe?
from the PEP it says it was chosen after a poll: http://www.python.org/dev/peps/pep-0428/#division-operator 
I think we've all been there in one form or another. I have several cringe worthy memories of wasted hours due to tab/spaces being mixed in my code. Another favorite is a unclosed parenthesis. If it's any consolation you won't forget that lesson anytime soon :)
On a second thought. This also works for other types of media files. For music you get the music player, for youtube videos you get the youtube embedder player, for doc/docx/xls/pdf you get a google viewer, etc.
I didn't realize that a 7 sentence argument was copious (your reply had only one fewer sentence), or that extensive documentation was a design flaw. I assume what you're trying to imply is that good designs require less documentation, but that is a generalization without substance. There are plenty of well designed systems that require books of documentation, not just a few lines. Your argument is lacking. When I presented my counter, you attempted to shift the target to something else entirely, provided no rebuttal, or any evidence that what you're complaining about is a problem. That being said, it's generally agreed that the GIL is a design flaw, there are few that would defend it, and I'm certainly not one of them. 
Each insert should be O(n) where n is the length of the string to be inserted into the tree. Look up should also just be O(n).
I don't think I've lost too much from that. Honestly, I can't remember the last time I did drag'n'drop with the mouse in any editor.
But "\_\_main\_\_" is a string - the highlighting will work for \_\_name\_\_ because it's an identifier, but not "\_\_main\_\_" (unless some editors support it).
&gt; handling multiple simultaneous web requests Note that it isn't just the web request handling; it's web request handling where you need to wait for something (e.g. database; or data from the browser with e.g. long-polling) and want to process other requests meanwhile; at the same time not needing an overhead associated with using threads for that. 
It seems to me that there is some confusion with PyPy, as usual, since it both implements Python and is written in Python; the PyPy developers both refuse to re-write PyPy in Python 3 but agree to implement Python 3.
Ah, the old "I renamed that file but forgot to change one of the imports" bug.
&gt; Is node.js good for large scale apps though? How large are you talking? Are you going to single handedly write the next twitter or facebook? Are you going to capture and display the results of a query over a petabyte of data? Are you going to write a MMPRPG that the entire world is going to play? A healthcare website that an entire nation is required by law to register with? At your stage I would assume the answer to all these things is likely a realistic "No", though it is handy to be concerned about scale once in a while, for 98% of web app development it simply doesn't matter. Or rather the time it takes to get from inception to delivery and ease of maintainability should be what you focus on. Not ROFLSCALE. By the time scalability matters you should have enough experience and the financial means to make the decision for your app that needs to scale. Because that is when the technology choice matters. For example. Facebook started out as a plain jane php/lamp app. Now it's more sophisticated, and there isn't a single framework that meets the scalability requirements for them now. But they pay 100's of engineers to make those decisions and build those things. Twitter was a rails app. Now the pieces that matter are in Scala and the things they had to build in order to accomodate the enormous traffic that they sustain is highly specialized to their app. Reddit, was lisp, currently pylons, but the bits that make it scale are not your typical pylons app. And using pylons for your project does not guarantee that your app will scale to reddit levels. 
believe it or not, i've seen claims that openstack is written in django elsewhere on reddit. 
Let's see... * Something feels off to me about the type inheritance model. If you follow it back, `type` and `object` end up in a twisted loop of infinite cross-referencing each other and themselves. It just doesn't feel like that can be the *really* correct answer. * Imports are crazy. I watched a talk by the guy who implemented import, and he spends a lot of time talking about how insane and complicated it is, and by the end, the flowchart he builds up to explain how it works looks like a map of Manhattan. * Packaging is also crazy. I watched a talk by all the guys heading up all the various packaging systems, and they basically spent the entire talk apologizing for how horrible it all is. In the Q&amp;A at the end, a person asked something like "You've talked about how bad everything is in packaging... can you recommend *something* at least, for now?" The guy speaking looked back at the other guys, watched them all shrug and shake their heads, and then he said "No. It's just all terrible. I'm sorry. We're trying to fix it." The crowd reacted with a murmur. I may have some details slightly off, but that's basically what happened. I know whenever I've looked up how packaging works, it's seemed like a gigantic cluster. I have a really great idea for how to make all of it work great, but I know the world will never go for it. It's too radical, and yet, I feel like it solves pretty much everything. * I don't like having to use lambda. In Actionscript I used do either `function foo () {}` or `function () {}`, with the latter being an unbound function. Everything else was identical - it just skipped the binding to a name, because I didn't put one. This is a brilliant solution to this, and in Python it would be as sweet as, e.g. `def foo ():` and `def ():`, and you'd be able to do `foo = def ():`, and there'd be no lambda limitations. There would be some hurdles, like `return` vs. implicit return of the last expression, but they're not big hurdles. I think indentation is what makes this difficult. In AS I could do `foo = function (a) { a *= 2; a +=3; if a &gt; 5 { a = sqrt(a); }; return a }`, which is really hard to do with indentation as delimiter. Btw, I'm not saying I want to write code like this - as I'm aging I'm preferring short lines and placeholder variables - but it's a nice power for quick work in a repl, etc., and I feel that the ability to do things like this - flexible extensions of the base language - is an indicator of simple, composable power. * I really didn't like explicit naming of the containing class in super, but they fixed that in 3 (but not before I had countless people bitch at me for saying it was a bad idea how it was done in 2.x). * All the pipes, subprocess, shell, etc., stuff has always felt really thick to me. I had to do a lot of reading before I could just call a simple shell command from my module, and there are many different ways people will suggest as to how to do it. * Determining basic file things, like the directory the running script came from, or a proper path resolution, or if something is a file or not are impenetrably hard. I've read for hours through back and forth debates with a hundred different ways to try to determine these things, and at the end, the answer is never "this is the proper way," but "about the best you're going to be able to do is the following..." and that wins because of upvotes. I realize a lot of this is the problem of being cross-platform, but Python just dumps a bunch of basics on you and lets you figure it out, and if the forums are to be believed then almost everyone does these things in ways that leave dozens of broken edge cases. There must be more broken file handling in the Python community than proper file handling, because very few people will read through pages of information to find the best possible way to do this stuff. They'll just settle on something decent early on. * Python does an absolutely terrible job of letting go of things. I run it in an embedded environment (3D package in games), and we often have to exit the huge program and come back in, because there's too much cruft sitting around, lying to us. This leads to environmental situations, where "it works on my machine," or "it worked this morning," because you didn't realize it wasn't fully updating your dependencies as you made changes. I had this problem in a huge way with nose (testing framework), and the maintainer of the program responded to me a little surprised that anyone wouldn't always be running everything on-the-fly, in constantly-spawned instances of Python. That doesn't work for my industry. In fact, I shut my machine off every night, but almost no one I work with - large games company, hundreds of employees - ever does. I just had a coworker say to me "I guess I should reboot. I haven't done it in a couple months." There are many others, but I have to get back to work now.
Yeah, the problems he had with python all seemed to be things ipython was built to solve (and it does a great job too).
Am I missing something ? There no nice wrapper around os.walk in pathlib ?!
Ten bucks it's a haskell user.
http://drewconway.com/zia/2013/3/26/the-data-science-venn-diagram
Post frequency may also be useful.
Cool - I was looking through them and was probably going to setting on JSONSchema or Validictory, so I'll poke at that first. Thanks!
Has anyone gotten this to install on Windows ? I am getting errors during the install of sqlalchemy-migrate
Sublime's built in snippet for `property` is awful. I has to just delete it. 
Guilty as charged :D
If you have no skills in programing. Try both!
I like the idea. I do find it a little weird that you didn't provide tests for your test generator though.
You can also just drop them into "$HOME/.fonts" and they take effect immediately.
Way more informative than I expected!
much fail using sudo pip
how so?
And here's traceroute in one line of bash: traceroute
Exactly. All the crap that alcalde describes doesn't happen in smaller companies and especially in startups. That said, the "HR black hole" has never slowed me down. I'm not a programmer by profession...it's just a hobby. However, in my field (which is also very high demand), I've gotten every single job just by sending out resumes to strangers. I can see the "networking" thing really mattering if you're trying to get a job in a career where there's way more qualified supply than demand. But in high-demand careers, employers can't afford to be that picky. This applies to big companies as well. It's not as if Google or any other huge company could find enough programmers purely based on networking even if they wanted to. It doesn't scale. That's why they spend all that money on recruiting. If they could bypass the entire recruiting system and just recruit based on referrals, don't you think they would've done it by now? I mean, they're so desperate for workers that they're importing people from India, China, etc...why would they go through all that trouble if all the jobs go to people through networking? At my fortune 500 company, plenty of foreign programmers got their jobs from applying...no networking. I mean, how would it even be feasible to network across the world? And as a hiring manager, why the heck would you bother hiring people across the world, with all the inconvenience, unless you were truly desperate? That said, the whole networking thing is a legit strategy, but it's just one strategy. Sending resumes to strangers can also work very well, if you do it right...but for some reason networking has a ton of proponents who crap on the alternative resume strategy. Oh well, whatever. I kind of like the popular notion that resumes don't work. It leads to less competition for me :)
I'm about 3 weeks into learning Python (my first language), what do you mean by "seeing code that's not really code"? I just want to think like a coder.
Has anyone installed this on Windows ? I get errors during the sqlalchemy-migrate install.
I installed pbr first and then dataset installed successfully
You're never going to regret knowing another programming language. If nothing else, it will help you write better in your original language. 
Perhaps not ..... but. Ipython is really cool. Do your users use it? Python can improve your Powershell by making you think more purely. There is a focus on elegance in Python I really like. Python is a general purpose language. It is worth knowing at least 1.
I then recommend you write code every day. Just try for a few lines if that is all you have time for. But make it every day.
There is no reason but the design isn't there. It would require adding some extra logic. I have thought about this utility as an open source project but I lack the motivation/ability to seize such dreams.
I thought this'd be something trivial along those lines, but I was pleasantly surprised. 
I too am a vim user but it sounds like you have tapped into it's utilities a lot more than myself. I agree this is a solution and your not "that guy", you're the smart individual. However, python in general is a great language for a huge scope of users. Most of these users, I would not recommend to use Vim and thus I do not consider this a universal solution, though clearly great advice as a vim user.
I have this option. Do you feel that it's much more stable than MySQL in that it can handle these large queries? Is it typically faster? I haven't used PostgreSQL, but I am not too worried about that aspect since what I'm trying to do database wise, is not all of that complicated. 
Robots!
https://pypi.python.org/pypi/marisa-trie/0.5.1
:D
For awhile I was using `fj` as `&lt;Esc&gt;` in Vim. I wouldn't have been able to type your name.
I just mean the look of reddit, for instance. reddits comments/replies have a cascading appearance that we encounter while programming (and even reddit threads themselves (classes, etc.)) *look* like code as a result of how they are displayed.
Can you just actually create the paths with empty files in a directory? tracker/ really/ long/ path/ to/ file1 file2 file1000 You won't have to split the path strings; you can just check if the file exists in your tracker directory. If it doesn't, just `touch tracker/really/long/path/to/file1`. You can use these empty files for per-file metadata, and even keep a metadata file in any directory if you need it.
That's not exactly what I want. Let's say we have 1,000,000 files to backup, so for each full backup I'd need to create another 1,000,000 files with metadata, etc. I'm afraid I'll run of of inodes or something :) I want to save all that data in a single file. 
&gt; compiled away how's this done ?
On your phone will be one user so does not matter. Not ready for production means not ready for many concurrent requests. 
I think you'd be okay. The Linux git repository has over 3M hashed objects in the .git/objects folder. They're broken up by the first two digits of the hash, so `ab32f10...` would be in folder `.git/objects/ab/` in file `32f10...`.
I'm not 100% sure, but it seems to me that the entire model can be replicated with fork() and a GC that's copy-on write friendly.
Use a database, the principle is the same, fast inserts and lookups and you can keep everything in a single file.
TIL about the intern builtin
Try Tornado
1. not on Windows 2. Reference counting is not COW friendly (that is why they give up on RC, and made "magic arena")
Go with included simplehttp. It's fine for small amount of requests. 
While I am big fan of Twisted, that might be a tad overkill for a small footprint target env.
&gt; They solve different problem domains, and they're both useful. This is they way I started to think about it as well. I actually just finished my first Python function. I built a new automation where most of it was pretty simple in PowerShell except for one part. I tried building this part out in Python instead and it was pretty awesome. I then called the Python script from PowerShell and fed the output back into PowerShell as an object. Worked beautifully. I really need to document in the comments though because I can see how that might be a bit of a pain for someone else to support if I leave.
&gt; Ipython is really cool. I haven't seen this before. I looks awesome though. I'll check it out!
Nice idea. I'd hardly call this reverse engineering though. More like scraping.
Honestly, if your app is not going to be used by more than a handful of people at the same time, I don't think the "not for production" disclaimer means much. Having said that, the CherryPy web server (not necessarily the whole framework) *is* production ready for all but the most high-traffic sites. [Cheroot](https://bitbucket.org/cherrypy/cheroot) is the Cherrypy web server extracted from the rest framework, that's what I would use. 
Have you looked at [autobahn](http://autobahn.ws/)?
Cool, but get back when we can actually use pip-sync.
It's generally considered to be a Very Bad Thing^TM , but to be perfectly honest I'm not 100% sure why. Instinctively I'd say it has to do with the fact that `pip install` essentially runs arbitrary python code, which should be reason enough. For 99% of cases (excluding virtualenvs), you should be using `sudo pip install --user`. 
OO 101, which unfortunately falls short in the real world more often than not. 
your requirements as listed would be fine with just the manage.py runserver and having django serve the static files. 
pip-sync is a nice to have in my opinion; the real game changer is pip-compile.
and it totally matters for an app used by a single person as stated by the OP. That article is crap, it doesn't even mention the need for a content delivery network backed by a distributed file system. I mean if we're going to bring ROFLSCALE into it....lets go nuts. BALANCE ALL THE LOADZ!!!!! 
The reason why the pure python web servers have that disclaimer is simply because static web servers like Apache have around 20 years of dev behind them for serving static content, so there's no point in trying to re-invent the wheel. So most web setups see Apache/Nginix up front serving static and referring dynamic request back to Python as needed. This is also a good practice because it allows you to easily split your architecture out as your traffic grows. So they're warning you away from serving static as sort of a "there's a better way of doing it". But for a phone app it makes more sense to go ahead and stick with a pure Python solution. I'd test out a couple solutions and go with whatever is the easiest to work with and deploy in your environment.
That's interesting, but `pip` is a package manager that handles dependencies already. I don't get the appeal of `pip-compile`. What OP is calling `requirements.in` looks like a perfectly fine `requirements.txt` to me. If you run `pip install Flask`, it will automatically install Flask dependencies for you. Also, pinning dependencies of dependencies doesn't make sense. Let the package manager manage packages. `pip-sync`, on the other hand, sounds useful.
The reason why most servers say they are "not production ready" or that they "should not be used to serve static content" is related to performance and scalability, not functionality. These browsers can do the job (that is why they are okay to use for development), but they will perform poorly in a high load situation. If you have a single user, then any server configured with a single thread would work fine. Gunicorn is an excellent choice, IMHO.
i don’t like npm-style package trees. sure, node_modules and venvs have their place, as they can make things with conflicting dependencies work. but in the end, i only want to install one version of everything into my system directories. as soon as you ship something you better have each dependency with a “&lt;” symbol fixed and replaced with a “&gt;” symbol.
pip-compile looks like it's solving the same problem as buildout with the versions, so welcome to the config management party guys. :)
yeah but where's the example of unittesting your views(which are really controllers)? :)
Testing and profiling is in part 2 :)
Gonna read this later, but noticed some of the links in the article are prefixed with the articles URL. For example, the Flask-Migrate url is http://pypix.com/python/building-flask-blog-part-1/flask-migrate.readthedocs.org.
Oh, dint notice that, will fix soon. :)
See [this](http://nvie.com/posts/pin-your-packages/) for why that isn't a good option.
Check out the original post on [Hack Forums](http://www.hackforums.net/showthread.php?tid=3871588) For discussion and FAQ **FROM THE PAGE:** &gt; Version 0.1.56 &gt; &gt; UPDATE &gt; &gt; I just released 0.1.56 and tested it a TON. I truly believe that this version is the most stable, and the one that will stay for a while. If you don't already have 0.1.56 please update and restart your node. &gt; &gt; Let's see how it works out this time. &gt; &gt; About &gt; &gt; Hey there Python section! I haven't been around for a while, so I thought that I would share one of my most recent projects. &gt; &gt; If you were lurking on HF 6 months or so ago you might have noticed one of my projects called BlooCoin. An eCurrency that used a central server to handle everything, which was &gt; ultimately it's downfall. &gt; &gt; Today I preset to you zCoin, a P2P crypto currency that takes the concepts of BLC and puts it into a Peer to Peer network. &gt; &gt; I had been planning to do this project for a very long time, but it wasn't until last week that I decided I would start the planning for zCoin. I started with some sketches in my notebook last week and started the code Friday night, not finishing until Sunday morning. &gt; &gt; Currently I am the only node on the network, along with two god nodes, and as of right now there are only 2 coins in existence that were both mined by me. &gt; &gt; The current difficulty for mining is at 7, the lowest it will ever be. &gt; &gt; If you are interested in zCoin head over to https://github.com/Max00355/zCoin &gt; &gt; Read the Readme to get started and start mining yourself :) &gt; &gt; Tell me what you think, any suggestions/modifications are welcome. &gt; &gt; FAQ &gt; &gt; Q: My miner says that I have a time out error, what does this mean? &gt; A: When you run a miner, or a coin submitting script, the relay nodes themselves can not keep up with the output of your miner. To prevent corrution the relay nodes prevent any further connection. Simply run the script again, or set a time limit in between each coin being sent. &gt; &gt; Q: How do I submit coin hashes that other people have given me? &gt; A: Put your coins in coins.txt and run this script http://pastebin.com/m5gFBDA7 &gt; &gt; Q: My miner just shows "{'difficulty': 7}", what does that mean? &gt; A: That's a great sign! That means that your node is mining! Now just leave it to it's work. &gt; &gt; Q: Everyone else has coins except for me, why? &gt; A: Coins are generated based on computing power and luck. Again, just give it time. &gt; &gt; Q: I gave it time, my miner even says that I mined a coin but my balance didn't go up. &gt; A: Ah, you just aren't synced with the network. A simple restart should fix the problem. If you are a relay node become a normal node again (if you don't know what that means don't worry about it) &gt; &gt; Q: My database is broken! What do I do? &gt; A: In the 0.1.56 + This shouldn't be a problem; HOWEVER, if you are having this problem, and you are a relay node, then it means that your computer can not handle being a relay node. The only way to fix the problem in this case would be to become a normal node again then restart your zcoin.py file with the the following command &gt; Code: &gt; python zcoin.py -fixdb &gt; &gt; If you are already a normal node and you are getting this error open your shell and type "fixdb" &gt; &gt; Q: My total coins is different from someone else's totalcoins. &gt; A: Sometimes nodes get lost, just restart your node. When in doubt restart! &gt; &gt; Stats &gt; &gt; Coins in existence: 2656 &gt; &gt; Contributions &gt; &gt; Pillows - Supplied the two god node servers, thanks dude :) &gt; SoulByte - Found an exploit in the send_coin function
Info given
&gt;I like pythons syntax and typing a lot more than ruby. this python it is more readable and you'll pick it up faster once you have a python job that feeds you, feel free to learn ruby as well, that won't hurt
Seriously, that's truly awful.
If it's a controller or view depends on who you're asking. I'm guessing the author is in the Django camp.
Not sure why you'd think that; if 27MB is too much storage overhead, then perhaps python isn't the right choice in the first place.
Updated the post with another detail: about 50% of Lady Gaga's followers are suspect according to the same criteria. Will be interesting to see how some more celebrity user accounts turn out. It might bruise a few egos to find out that millions of their followers aren't followers at all.
&gt; zCoin is a cryptocurrency that looks to approach the idea of an online currency at a different angle than that of Bitcoin. Different in what way? The page has almost no information as to what differences, advantages, and drawbacks your currency has compared to Bitcoin, or why anyone would choose to use it instead.
Am I the only one around here who thinks library management should be higher up than python's system? Probably.
Well, for one, zCoin's miners play no real helping role in the network. They are just there mining, and zCoin mining is pretty much brute forcing. Also, zCoin does not use blocks. Mining does not consist of all miners competing for a block. Instead, a difficulty is set that is based on the amount of coins in existence then miners mine on their own, offline even, to find hashes that match the difficulty set by the zCoin network. 
You can simplify code like this: if request.method == 'POST': if not form.validate(): return render_template('signup.html', form=form) else: newperson = Person(form.firstname.data, form.lastname.data, form.email.data, form.password.data) db.session.add(newperson) db.session.commit() session['email'] = newperson.email return redirect(url_for('profile')) elif request.method == 'GET': return render_template('signup.html', form=form) by using the validate_on_submit method which checks for the post method and performs the form validation: if form.validate_on_submit(): newperson = Person(form.firstname.data, form.lastname.data, form.email.data, form.password.data) db.session.add(newperson) db.session.commit() session['email'] = newperson.email return redirect(url_for('profile')) else: return render_template('signup.html', form=form)
this is the very first start of zcoin.py $ python zcoin.py Generating address... Your address is EDITED Registering with broker node... Retreiving nodes db... Retreiving coins db... Syncing with network... Done! zCoin has started as a normal node. it has to be "retrieving", no big deal, it's just a typo, i noticed it just now then i've ran python miner.py and got the traceback (actually, many of them, one per thread) which i pasted above further run of zcoin.py shows a different output: $ python zcoin.py Couldn't get current zCoin version from any of the brokers, they all must be down. I suggest you restart your client in a bit to check again. zCoin has started as a normal node. then this $ python shell.py Welcome to the zCoin Shell for help type 'help' zShell$ fixdb Fixing your broken databases... Fixed! running the miner after that still spits exactly the same tracebacks i am running python 2.7, like readme suggests, on a 64bit linux system, as you can see from the traceback
nope, used python for more 10yrs and avoided easy_install, setuptools, eggs, distutils2, pip, wheels... I just don't have time for solutions waiting for a problem
getting the same traceback even when zcoin.py is starting with a clean log, without complaining about not being able to get version from brokers $ python zcoin.py zCoin has started as a normal node. still the same traceback when running miner.py i think you should write some unit tests
I think people who are downvoting this haven't actually clicked on the link, it's very well written. 
I would say that it would be a good thing to learn because it is portable across a lot of different system types. The last 15+ years for me have all been Perl and Expect and I can get either Perl or P+E to get done nearly anything I want but the world really seems to be moving in the Python direction. Having some cycles to burn I decided "why not?" and jumped on the bandwagon.
Thanks for pointing this out.
Probably a dependency for some other 3rd party package that had previously been installed.
This s much simpler, thanks for pointing out this.
Couldn't an evil relay take someone's coin announcement and try to pass it as their own? There appear to be central "god" nodes, but how do they arbitrate?
`pip install` doesn't uninstall stuff that is removed from requirements.txt, nor does it provide an easy way to see what dependencies have been updated.
Update the requirements.txt including removed transitive dependencies without rebuilding the virtualenv, I guess.
You are basing this off of Bitcoin. zCoin is nothing like Bitcoin. zCoin was an experiment. I don't know what is going to happen, but comparing it to something like Bitcoin is unfair, though I can understand why you would. 
Yes, but it would be rejected by the other relay nodes, so he wouldn't be able to spend it. ALSO, that god node is literally the same as any other node on the network. The only thing is, nodes need a way to find eachother on startup, or need a default node if it can't find a valid relay node, so that's why there is a node built into the source code itself. 
too bad. :-( 
I accept your point, but what if i want to display the specific email validation.
Awesome, i checked right now, and it worked :) Very Useful.
Do keep adding to this site. The /r/flask sidebar may have some resources, but I have found them inadequate.
to automate tasks to codify processes/tasks
&gt; That all being said, I hate Excel. erh why ? 
It's for a mobile phone, while storage on the phone isn't as critical as it used to be, its still relatively scarce compared to PC. Also there's installation to be concerned with, especially if not being used on a Wifi network.
[Here's another Flask Blog Tutorial, that I went through and thought was excellent.](http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world)
Why use a relational database for a blog?
However if you deploy the app you wil be using relational databases so working in relational database right from the beginning will remove your headaches while deploying. 
I'm a fellow sysadmin, working mostly in a windows environment. Powershell is incredibly powerful, and I have yet to run into a situation where I needed python for work, so for almost all practical purposes learning python is not going to help you specifically become a better windows sysadmin. However, learning to program is. If you're not experienced in programming, your scripting abilities will improve a lot when you learn some programming fundamentals. If you want to add a specific language (as opposed to the general skill of programming), you should probably try c#. You can easily extend powershell with knowledge of c#, to the point where you'll be able to write your own modules, and you can build .net web applications that leverage powershell (this is useful for giving helpdesk tools, tell them to click a button on a web-page instead of opening a prompt and running a script).
* The title is misleading; "pythonic" is more about idiom than whitespace. * Why not fix the push rather than rejecting it? Or at least offer...
PyPy doesn't do refcounting so no trouble there :) Maybe I'm wrong, but all that was shown could be done in PyPy faster, and during the translation phase two different interpreters could be generated, one for the main thread and another for the parallel context so no overhead to discover where it is running.
* It's more easily understood when skimming the title. * I don't think you can unilaterally change a commit. Even then, this can only be done for style issues, not for syntax errors/etc.
&gt; You can easily extend powershell with knowledge of c#, to the point where you'll be able to write your own modules, and you can build .net web applications that leverage powershell (this is useful for giving helpdesk tools, tell them to click a button on a web-page instead of opening a prompt and running a script). Providing a web GUI sounds like an awesome idea. The way I have been handling it now is to provide my own module on a network share that I load from their $PROFILE. Thanks for the reply!
I love this book! 
- Is still misleading. Sugarcoating your titles sounds like cheap marketing. You have better alternatives: "Reject no PEP8 compliant pushes with git hooks" or "Check git push request against PEP8". My English may be wrong but you get the point. - I agree with the first halve of your sentence. I would never obscurely manipulate a commit. It breaks the trust created by the "blame" mechanism. Also, I do not know why, but feels unfaithful.
I say finish what you started, lpthw is a great book on it's own.
My first programming book. So nostalgic
&gt;Wait, it can't even get the version? just sometimes, not always &gt;Are you not allowed outbound connections on that port or something? my firewall blocks only incoming connections except those from the whitelist, all outgoing stuff initiated by my host is allowed you need to add more verbosity to the code, so it reports what's going wrong
+1 for this book, it's how I started with programming and python.
I had programmed in several languages but was getting into Python and this book made me a better programmer in my other languages too. Way too good and I highly recommend it!
Use saltstack instead. ;)
Ye, that's my next step to check out Saltstack and Ansible :) But Fabric is good tool to start with I think :) it's just Python, no need to learn some configuration format etc.
yeah I don't want to have to have a master node running in order to start hacking on code. saltstack is for deployment. and I'd rather use ansible for that. 
time to replace the old copy (Version 1.1.21) I have
Why not? Not everyone loves or wants to use a NoSQL database. I'm not a fan of document based databases. I understand why other people are, though and they have their uses. Besides, with SQLAlchemy it'd be trivial to switch from Postgres to SQLite if you didn't want to use a RDB Server. And he might be using that postgres install for a much bigger site and thought, "Well, I already have Postgres running, why not make a database for the blog, too?" Just my two cents.
Exactly.
Is this amusing because the Fraunhofer Institute has the patent on MP3s? I don't get it. ELI5?
My favorite intro textbook with Python! I prefer this version: http://openbookproject.net/thinkcs/python/english3e/
Which indicates you are likely using embedded mode when you shouldn't. Use embedded mode and you will be prone to Apache restarting processes on you. Go read: http://blog.dscpl.com.au/2012/10/why-are-you-using-embedded-mode-of.html and also ensure you watch: http://lanyrd.com/2013/pycon/scdyzk/ http://lanyrd.com/2012/pycon/spcdg/ The first of these talks goes into process churn and issues of startup delays.
Except that if they were already using daemon mode they wouldn't see that behaviour at all. That is unless they had already set inactivity-timeout themselves for some reason and caused it themselves.
As great as books like this are, does anyone else feel there is a real lack of 'advanced' python material? I would love a detailed guide on writing 'good scientific code' in python. Material on useful testing, efficient design etc.
This might be a good "learn to program in Python" book, but it has nothing to do with Computer Science. This is the reason people are shocked when they enroll in a CS program and get hit with lambda calculus, recursion theory, category theory, and so forth. If you want to learn to think like a computer scientist, learn Haskell. If you want to get something done quickly, learn Python. 
This was the first book that made object oriented programming click for me. Highly recommended. 
Thanks Graham! These are definitely interesting links, and the talks give me something to consume on my way to work :) And thanks for taking the time to answer this and for posting those links!... not to forget: thanks for `mod_wsgi` \^_^
&gt; `else "%svirutal_env_%s"` A couple of places.
syntax highlithing would help :]
Update FWIW: I got the job.
This is the book that they used in my first year CS class. Fantastic Book.
Yes. I found it mildly amusing that he is complaining of being treated in a similar way to how others have been treated by him (or perhaps the people he works for/with).
There are already a decent number of salt starters and tutorials on using salt to bootstrap a django application. 
This is the text I use for the Intro Python programming class I teach.
Cool, good to know cheers.
You can find a reverse engineering of Rapportive's API here: https://github.com/jordan-wright/rapportive/blob/master/rapportive.py
I agree with you
This is the one that got me started. I loved, and recommend, every chapter, excepting the turtle stuff.
My experience with Python is that I had to dive in to enhance an existing project. I had Perl background back then. Python is so easy to jump in and write code though a lil' difficult to master the Pythonic side of things! Love Python and it is an awesome prototyping language. Start off with 3.3/3.4 if someone is starting new. Codecademy got a nice quick starter for newbies. 
Seriously? Get something done quick? Python is beautiful. Read some about Haskell but you can't just compare them both and arrive at an answer so quickly/easily!!
Awesome! Thanks!
Too bad no one is disagreeing and offering the book I'm looking for ;-)
Hurrah! A crypto network I can get on before it gets large and hopefully actually mine something. Have started already but it appears not to be doing anything... Perhaps adding some better output to the miner.py? I uncommented the print starter+str(on) line with a check to only print every 50,000 iterations or so but no idea if its actually doing anything useful.
PDF is not an ebook. How to make .epub file from .tex source?
if it shows {'difficulty':7} then it's running, but if you want a more responsive (and slightly better) miner, check out [this one]( http://www.mediafire.com/download/x0yj2yn7v035na1/miner.py) It will tell you how many kilahashes it is preforming per second, as well as how many coins mined. It will save all the coins mined to a coins.txt, so if you want you can give them away. If you want to submit them run [this](http://pastebin.com/m5gFBDA7)
Have you looked at the sequel books to this? I'm really not advanced enough to have a good opinion on what you are talking about, but the same persons who did Think Python also did Think Stats, Think Complexity, and Think Bayes that talk about those topics using the foundation set up in Think Python as a jumping off point. It might not be really advanced, but its more than the same old stuff.
I use both, it depends on the need of the developer. If I am checking to make sure that a little piece of state is right then logging is fine. If I don't understand why the state is a certain way, it's probably easier to use the debugger. 
I really like that chapters are relatively short, to the point and concise. There a not a lot of exercises embedded in the text. I like to have some small pen/paper exercises; What is the output of the following code segment? etc, etc. Not a lot of those in the text so I have to make my own. I use use Pygame for 3/4 of the semester to make it fun, so I need to supplement the text anyway.
Oh, and one of the major reasons I use it is not only is it good, but I have a real issues with having students by $100-$200 textbooks.
pandoc, I guess.
Sounds reasonable. Although for the record it does the same for coins. My client supposedly found a coin which has since gone. I would guess its out of sync, but if that's the case you should report it as an unconfirmed coin. 
Python's my current favorite language, that's not the point. Programming isn't computer science and the table of contents doesn't list anything that can really be called CS instead of software engineering. You won't get very far in a Haskell tutorial without being exposed to a lot more theory.
There is [alot](https://github.com/pazz/alot).
why so serious? I think it was a nice write-up, and while all your points are certainly valid, I think that it is unnecessary to do it in such a condescending way.
CherryPy, Paste. If you accept Gunicorn, use uWSGI instead. 
Sometimes a coin can be found (im assuming that you're using the {'difficulty':7} miner) and it may take a little while for the coin to show up as part of your total. Quick question - are you running as a relay node? If the coin was found and submitted then it is already counted as submitted on every other node, and is part of your total, even if it doesn't show up. As for the changing coin number, same as the totalcoins
/r/zcoin has been created for general zcoin stuff
Yea I just ask because some computers can't handle being a relay node and it affects how synced the totalcoins and your coins are with the rest of the nodes. As for your miner if you see a big block of text, you mined a coin. End of story. So don't worry about it showing up in your coins, because it will. If you want to be more exacting you can use the other miner I gave you because it explicitly shows ow many coins have been mined and also you can see every coin in a text file
I think I agree. I would only add that I only use the debugger when things are REALLY messed up. Like, no god damn idea what the hell is going on. Specially with a codebase relatively small like the one I am working in: I kinda know where everything is, and how it should work, so when I bug appears, I know already where to look, and how to poke the system to isolate, reproduce, and fix it. In fact, I remember that in my previous job, I had a pretty big (and stinky, too) JS codebase, and I would need the chrome debugger way more often then I do now.
Thanks you
Have you thought about putting your pygame assignments online? I'm teaching myself programming with this book, and I'd love to do some extra assignments that go with each chapter.
That's fine. As always with new things I want to see if its actually doing something without waiting too long. Have about 50 coins now :)
Subversion repo? Hopefully that doesn't take too long to download over my dialup connection.
PEP 450 is great. Having basic statistical functions standardized without needing numpy will be a huge help.
Damn, it's really called alot (and not "a lot" or "allot" or anything! :))
hi NSA
All books can be found [here](http://www.greenteapress.com/)
I wish more universities offered a Software Engineering program. You'll see a CS program, and if you're lucky a separate Information Technology/Information Systems program, but rarely one that focusses solely on applied computing and development.
Yeah! Skim around and see, maybe. Once I had been doing Python for a bit, reading about things I was unsure of in Learning Python The Hard Way was very valuable as that work does very deep dives on its topics.
Good book, read the Think Python and currently reading Think Java. I haven't been able to do much with it, yet, though. I'm having a difficult time putting the basic skills to use. Can anyone recommend a good next step? I tried downloading and getting Github working but I just couldn't figure it out for some reason. I though I'd try to get some practice contributing to other peoples' code projects, since I've seen that advice given before.
I haven't tried it with Python, but I've used passenger for ruby and node projects with both apache and nginx and am pretty happy with it.
Get Git or Github working? One is a tool, the other is a service using that tool. Anyway, Github has a "try Github" thing available (I think from their front page, actually) which should get your started with the bare minimum. 
official epub would be nice
Look [here](http://www.python.org/download/releases/3.4.0/) for links and more information.
I use uWSGI in its emperor-tyrant mode, where each vassal is a separate virtualenv. The killer feature for me is deploying an app and having only that app restart. And uWSGI also does exotic stuff like FastCGI (useful for PHP) and old-fashioned plain CGI (for those weird Perl scripts). And the docs are fun too, with their zerg modes and whatnot. This timeout of yours would be a harakiri setting. :-)
gunicorn + nginx
I'm disappointed PEP 448 doesn't appear to be included.
Yes, and they are good books. But they're really more a mix of for example 'learn basic Bayesian statistics, and the pymc package'. Don't get me wrong, that is useful, it just isn't what I'm looking for.
It's still a draft.. What a shame. More methods of unpacking vars/args is always welcome! Btw, what happened to "a, *, b = ..." unpacking syntax. Seems like it's missing in py3.4. &gt;&gt;&gt; a, *, b = range(5) File "&lt;stdin&gt;", line 1 a, *, b = range(5) ^ SyntaxError: invalid syntax &gt;&gt;&gt; a, *_, b = range(5) &gt;&gt;&gt; This works though. 
I have no preference for document based or relational databases. Each have their place and I use them when appropriate. I was hoping (as indicated by my original post) to hear the argument for a relational database when building a blog. If someone is going to give lessons on how to do something, I would hope they could back up their reasoning for using a particular technology beyond familiarity or convenience. My thoughts as to why not? I don't see the relationships being modeled and it feels like overkill for pretty simple data. Like you said nosql is a "document based database", and a blog is a document based site, there is no inherent relationship between posts. Each post, author, comments, etc, are neatly contained in a single document entry.
&gt; New code should not be using the string '%' operator because it has &gt; been replaced with the string.format() Not true. Check out Guido's presentation here https://www.dropbox.com/s/83ppa5iykqmr14z/Py2v3Hackers2013.pptx &gt; [string.format()] Considered too verbose; % will never go away
Mostly for the reasons pointed out in PEP 450.
Any chance for tutorial how to make .epub version from .tex sources in [here](http://www.greenteapress.com/thinkpython/)?
You just answered your own question. GCC on windows and mac are provided by third parties, not by default. Their official development tools contain C/C++ compilers, but not GCC.
Not if the form isn't valid or it's a GET request.
I use numpy literally every day; it's great. That said, there are also some situations for which it's overkill and in which I'd rather save that load time and use something light-weight. 
I could have used this before I finished my introduction to programming course :) Nice though.
A static site generator like Jekyll or Hyde makes a lot more sense than a DB of any kind for a blog or personal site. 
numpy, too? TIL. i think it’s time to port that old FORTRAN stuff to C. R, GSL, numpy, … i bet all those depend on the same FORTRAN libraries and would profit from that. only recently i thought of using emscripten to wrap GSL for high-performance JS matrix operations, but NOPE, FORTRAN. ;) /edit: numpy already uses [CLAPACK](https://github.com/numpy/numpy/tree/master/numpy/linalg/lapack_lite), a version of LAPACK (written in FORTRAN) that’s cross-compiled to C. so i don’t see the need for a FORTRAN compiler on windows…
You can try [this](https://github.com/dmaslov/flask-blog) simple blog engine.
 In [2]: timeit('import numpy', number=1) Out[2]: 0.1088399887084961 It also increases the python process's memory usage from 59,672 KB to 94,864KB. Not a big deal for one process, but with many, it adds up.
To me, 120 MB seems more or less normal for the total program size, i.e. the VIRT column in top output. But this statistic includes shared libraries, which is shared across all instances of the program. A better indication would be the RES column, the 'resident set size', where the program's local data is stored. For me, that's about 10-15 MB per uWSGI process.
Here's a PDF version: http://www.greenteapress.com/thinkpython/thinkpython.pdf
One more reason for choosing RDBS is to take advantage of the Full Text Search capability of PostgreSQL Database (Part 2).
Fabric is a thin layer and provides equally thin benefits. Most of the time, for single-server projects, I'd rather ssh in and run bash scripts - or use ansible.
Assuming you run Linux: There is a Makefile in the SVN repository. You need the *hevea* binary and *ebook-convert*, search your distribution repositories for that. E.g. *ebook-convert* is part of calibre on Arch Linux. Do svn checkout http://thinkpython.googlecode.com/svn/trunk/ thinkpython cd thinkpython touch header.html touch footer.html make html make epub That's it. Enjoy your ebook :)
Problem with putting a library like numpy in the standard library is that the standard libraries are supposed to be fairly static and "finished" (so developers can bank on them being rock solid). Numpy would have a very hard time getting new or experimental features in if they were part of the stdlib. That's also why scipy and the various scikits would never be part of the standard library: scientific computing is very experimental, and there are always new things to add. I guess you could put the bare basic ndarray type in the standard library maybe, and then send all of the linear algebra, fft, etc stuff over to scipy. But not everyone who uses numpy for these features actually wants to install scipy (you have to have full BLAS, LAPACK and Fortran compilers for scipy, but numpy can get by with only a C compiler and the source I think)
Hi there. I've installed Emacs 24.3 with the new python.el, pip-installed rope and elpy, installed elpy (and dependencies) by emacs package manager. Unfortunately, nothing worked. Anyway, thanks a lot for your help! 
Thank you!
Any one know how I can download everything here in a zip or to a folder http://www.greenteapress.com/thinkpython/code/
Fabirc doesnt work on python 3. 
You can now unpack like this, which will make `others` a list of all the things that weren't assigned to another value: first, *others, last = range(5) Using `*_` just assigns that list to `_`, which is used by convention for a variable that you're not going to use anywhere.
`a, *, b` seems confusing to me since empty variable names don't make much sense. I prefer `a, _*, b`.
Forgot about that, and now I'm disappointed too. I think that PEP alone would probably convince me to switch to Python 3.
I think d3 is a neat scripting interface over the DOM, and shows the power of having a first-class reactive programming environment over your data and graphic models. I've always been a huge fan of Protovis, which is the precursor work to d3. That being said, I don't think that Javascript would be my language of choice for this, nor was the HTML DOM really designed for this. The only reservations I have when it comes to recommending d3 to "regular people" is that Javascript is really a terrible, terrible language for people do have to learn, just to do simple mathematical manipulations. d3 then does additional cute things in JS, which IMO further steepens the learning curve. The fact that Vega, for instance, offers a declarative layer which compiles down to d3 shows that one does not necessarily *have* to suffer the learning curve and difficulty-of-use of d3 to get a lot of its power. It's been mentioned to me that the authors of d3 see it as an "artisanal tool", and I think it fits that role very well.
Your thing sounds very neat. Please let me know if you have thoughts/comments about our stuff. Again, just to clarify: the actual communication bridge between backend and frontend is pretty bare-bones. We store and retrieve arbitrary "models". We have a simple web server built on top of Flask (using redis for persistence), but the auto-serialization to JSON, the handling of container classes and Numpy arrays, etc. are all pretty solid. If you look at the output HTML from any of our file-based plotting examples, you can see the model objects directly in the HTML. Alternatively, you can do session.dumpjson() to get a nicely formatted dump of the JSON.
Maybe something like http://www.httrack.com/page/2/ but I'm too lazy to test it.
Don't use the SVN repository on Google Code; it hasn't been touched since 2011. The tarball of the TeX sources is up-to-date and contains the Makefile.
Java is probably the principle language which brought bytecode to the masses. Since it is not executed directly, it is possible to write code that will run that same program on multiple processor architectures, Mac, Windows, Linux. Although Java also ran on mobile phones as well (in a cut down form, called J2ME which is Java 2 Micro Edition.). Theoretically it should be possible to write a single program that would run on any platform that supports Java, however it would be a pretty limited program since the level of support of the libraries varies (I worked at Javaground and we had a a system where you could write a game and convert it to run on 2000+ different handsets, and it would abstract most of the differences and give options you can use when compiling so that you can say if (SIZE_WIDTH &lt; 160) { do some code }. I wrote a converter that would allow you to write Java programs and then they would be converted in C++ programs which was required for the Verizon BREW phones. The Java bytecode has some bad design choices, which were improved by Android when they wrote their own version called Dalvik. Python's bytecode does not run as quickly as Java's because it s a dynamic language, and so more choices have to be made when interpreting the bytecode but the language is so much nicer ;)
[Ruby does use a bytecode VM as of 1.9.](https://en.wikipedia.org/wiki/YARV) It's a common implementation method for dynamic scripting languages, although it often is not actually exposed to the outside world (i.e. it remains an internal implementation detail.) I want to point out that there is a huge difference between Python bytecode and Java or C# bytecode. Python's VM is an implementation detail, it's not meant to be a platform that other software can be built on, e.g. you don't find people implementing other languages on top of the CPython runtime like you do with the JVM. The JVM is rigorously specified with a stable format that won't change often, whereas Python bytecode is not guaranteed stable across minor versions (e.g. 3.2 -&gt; 3.3). And the JVM rigorously validates bytecode before executing it, whereas CPython does not; it's not meant to be a security feature of CPython. You can easily segfault the CPython VM with invalid bytecode, it's just not designed for that like the JVM. 
&gt; Is what I mentioned above correct? &gt; Whats the point of bytecode? Is it just something you can redistribute to people where it will run faster since its already compiled? You've got a decent idea of what a compiler does, at a very high level. The code you write in Python is only for the compiler. Your computer (at the base level) has absolutely no idea what any of it means. Here is the progression: **High Level Language -&gt; Assembly Language -&gt; Machine Code** Python being a high level language, and the byte code you're referring to being the Machine Code executed directly by the CPU. Your Python Code is compiled into Assembly Code, and the Assembly is then sent to an assembler to be turned into Machine Code. &gt; Do all languages have bytecode? Is is a scripting language thing? &gt; When I googled bytecode it seemed to have emphasis on Java only? Does bytecode stem from a Java principle? Kind of. All machines run on Machine Code (byte code), but high level languages do not have their own form of Machine Code. It is the hardware which determines the byte code, not the other way around. Don't think of it as a translation from one language to another (ie. English to Spanish). Think of it as breaking down what one language is trying to accomplish into the most basic form of communication so that anyone could understand what the message is. CPUs all have a limited number of operations they can perform. Those two numbers you just multiplied together with a few key strokes might actually take a combination of several machine operations to perform and return. I am no expert on this, but I am a student of the subject and I'm happy to answer any other questions you might have! My knowledge of compilers mostly comes from C++, but the concepts should apply to Python as well. EDIT: This info applies to C++ but not Python.
Also, you could technically implement bytecode in [brainf*ck](http://esolangs.org/wiki/Brainfuck) by assigning each instruction to a binary sequence (like [binaryfuck](http://esolangs.org/wiki/Binaryfuck)) So bytecode definitely isn't limited to scripting languages...
Actually my 2013 Python talk is about Python bytecode. The first five or so minutes will explain what it is, and if you can spare the full 40 minutes you'll know everything you need to know on the subject. http://www.youtube.com/watch?v=0IzXcjHs-P8
you're conflating some concepts here and not really giving a 100% correct response. Assembly Code is a hardware specific byte code. It varies significantly between chip architectures. This variation is the reason why cross platform portability is very difficult with ahead-of-time compiled languages like C++. You have to produce a different binary for each chip architecture you're targeting. The sort of Byte Code that is used by Python (and Java, etc.) is a virtual instruction set targeting a virtual machine implemented by an interpreter (as in Python) or some kind of runtime (as in Java). The virtual machine is compiled conventionally, targeting a specific architecture. Programs that compile into bytecode targeting the virtual machine do not have to be compiled conventionally for each different chip architecture. They can be just-in-time compiled or interpreted by the virtual machine. This is what gives them portability with basically no additional effort from the application developer. This is a big deal. This portability is a killer feature. 
(I didn't downvote, but...) Bytecode is generally not machine code for the underlying system. It's usually code for a virtual machine, which in turn *interprets* that code, not unlike an emulator. Python is not translated into the system's machine code. It's not even compiled for an assembler. The Python compiler decomposes the source code into an abstract syntax tree. The abstract syntax tree is then translated (almost directly) into a reduced bytecode. That bytecode is then executed directly by a simple finite state machine: Each bytecode instruction is read, then appropriate machine code is executed to perform the task required by the bytecode instruction. At no point does Python get reduced to assembly or machine code. It is quite literally a translation from one language to another - not like English to Spanish, but more like from spoken English to a stenographer's shorthand notation, which is faster to transcribe and, to someone who can read it, also faster to read.
Newfags can't __main__ ! Edit: shit. 
Ah, forgot the whole virtual machine thing. So if you take what I said, but change CPU to Java/Python virtual machine does most of it still apply?
Second part of my adventure. Installed on another PC and it seems to work. Lots of problem, anyway. * The yasnippet completion is replaced with C-c C-i. Of course I assumed that a quasi-universal setting has not been changed. I should have read the docs, anyway. * I've lost the nice parameter highlighting while invoking a function that I have in jedi; took a fast look to the elpy wiki and it seems there's no way to have it back. * the docs say to M-, to activate iedit-mode, while here it seems to be C-; and some other minor issues. I'll hope I can do some more tests tomorrow because regardless of my well-known bad luck (and laziness) with packages et similia, it seems very interesting. EDIT: "it seems very interesting" as it allows me to get rid of Pymacs. :-)
This'll save you 35 seconds: http://www.youtube.com/watch?v=0IzXcjHs-P8#t=36s
That's not technically correct (which is probably where the downvote came from). Python bytecode is not machine code. Python is never compiled to machine code* - even when you create an .exe from a script it's just bundling your Python bytecode with the interpreter (i.e. python.exe). Python bytecode is just a binary version of your script that is read by the interpreter. The interpreter itself if more or less machine code, that is what runs your code, not "directly by the CPU". *Unless there is some cool project\fork I've never heard of.
&gt; I want to point out that there is a huge difference between Python bytecode and Java or C# bytecode. Python's VM is an implementation detail, it's not meant to be a platform that other software can be built o Good point. Python bytecode is porbably best thought of as a machine-friendly cache of the parsed source
Sort of related: A simple way to create PDF ebooks from XML, with Python: http://code.activestate.com/recipes/users/4173351/ See the recipe with the title "XML to PDF book with ElementTree and xtopdf" at the above link. 
Thanks! I'll look into that. I think part of the problem was that the vps I was using had no swap partition configured. From what you wrote I assume I'd get some benefits in terms of shared memory usage from using uWSGI as oposed to just spawning two processes from scratch.
Yes, Fabric probably is not suitable for large amounts of servers deployment. But for me, I normally need to deploy the same project onto 3 or 4 servers, ssh into each server and run bash script is nightmare :)
A "python 4" compatible with both 2 and 3 source code would be awesome to upgrade to.
I'm also looking for tips and improvements
Ok, now I remember. I confused it with function syntax where you can disallow/limit positional arguments, for example: &gt;&gt;&gt; def foo(*, bar=123): ... pass ... &gt;&gt;&gt; foo(1) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: foo() takes 0 positional arguments but 1 was given &gt;&gt;&gt; foo(bar=1) &gt;&gt;&gt; IMHO, discard-wildcard in assignment syntax could be pretty useful; improve readability and maybe give some optimization hints to interpreter. Just a thought. 
Would you like to post the code at https://gist.github.com/ ? It would be easier if we could actually run it. 
Try /r/learnpython
From the sidebar: &gt;**If you are about to ask a question, please consider r/learnpython** Also, instead of posting your code in an imgur album, consider a website like [pastebin](http://pastebin.com/).
&gt; It doesn't always make sense to comply with PEP8 (some lines are 90 characters long because they contain a long URL etc) Indeed, which is why the config file specifies what we conform with and what we don't. &gt; Running PEP8 as pre-commit hook would make a lot more sense. Show the output to the programmers. Let them decide if they're okay with their work. People in the team should be doing that already. Why should non-conforming commits go though? At which point is it okay to say "you know what, I've considered this, and I want to override the rest of the team and just write it like I want to"?
Now that is interesting! _ is a catch all bucket?
&gt; Java programs and then they would be converted in C++ programs Interesting, I'm guessing it was easy to do with format recursion over java's AST? There is a java library for reading code .java DOM isn't there?
Technically speaking, bytecodes are machine codes that run on the hypothetical machine. This means you can run bytecodes faster than the normal interpreted source code, but not that much (since real machine codes will likely beat it). Other than this notion, there are nothing special about bytecodes. In fact, bytecodes are normally used in two different ways: * Python bytecodes are means to make the code a lot faster by *interpreting* the bytecode instead of the source code, and .pyc file is there since bytecode compilation is slow [1]. Implementing bytecodes is quite easy (making it optimal is another story though) and bytecode interpretation is much faster than normal source code interpretation, so many dynamically typed languages followed this road. * A notable exception is JavaScript: in this case, you cannot cache the bytecode at all and normal execution should be even much faster than bytecodes! So many good JavaScript implementations do not use bytecodes, and instead translate the source code into the unoptimized machine codes directly. * Java bytecodes are more shareable (and durable), and they have a good *compiler* that can translate bytecodes to native machine codes (called "just-in-time" compilation). C# and MSIL is similar. In this respect, bytecodes are not means to make the code faster (since the compiler can make it faster anyway) but rather means to make portable machine codes. Since it is not bound to a particular language (it may *prefer* some families of languages), nowadays there are literally hundreds of other languages compile to Java bytecodes and MSIL. [1] In fact, you cannot easily share bytecodes across multiple Python versions, and the first two bytes of Python bytecodes change as needed to avoid mistakes. Search CPython's `Python/import.c` or `Lib/importlib/_bootstrap.py` for the word "magic".
Oh neato, I've beard little of brew since android seems to be eclipsing the handset media. So is this how a majority of j2me applications get their smartphone ports? (windows mobile, symbian, etc) How does a stack based bytecode translate to C++? Was there really heuristics involved for something like (psuedo): load 1 load 2 add load 3 store local#1 Straight fowardly it seems you could just conveniently keep a trailing record of loads and match them based on operation. Like for here since two constants are on the stack and an add operation ensues, you can immediately assume an expression`1+2`, then that expression is converted to an addition node. Then from there the node can be treated the same as the constants I'm assuming. I'm hope I'm on the right track, I've written a compiler but it's quite interesting to think about translating to a formed language. I can only assume this is trivial somewhere in that I've seen many java .class decompilers out there.
A lot of python servers are missing from that.
Like?
bjoern, paste
I believe you're mixing up application servers and frameworks?
I'd argue that Bottle and Flask are *application frameworks* that cannot serve themselves in a production environment. This guy is reviewing servers by themselves (or in the case of CherryPy, a server that also has an app framework).
https://python3wos.appspot.com/ not too bad (most of the top of the list is green)
We use Bottle in production. It can be used as a single service (though we do put it behind nginx for parallelization instead of greenlets). I wouldn't call bottle an application framework, at least in how we are using it. Bottle handles the protocol and calls a function based off of the routing rules. After that it is hands off. Django might only be an application framework, I don't really know since it is too heavy for my tastes.
Thank you for the informative talk.
Just to add more answers to your question: meinheld, fapws3, pulsar, and wsgid... but personally I think an article like that should actually limit the number of choices that are reasonably popular and have some documentation.
This is a rally great writeup. Op didnt reply, but I just wanted you to know that I appreciate it. I'm not an algorithms guy either, but your approach makes sense and the explanation definitely gets one in the right mindset to work on similar problems.
Git might be a bad example. I've heard of issues where large codebases (I think Firefox was the one discussed) have trouble using git because once you have that many files, rebuilding everything to clone a repo is quite time-consuming.
What do you mean by "rebuilding everything to clone a repo?"
When you clone a git repo, it downloads the entire history then generates all the source files on the fly. So it'll copy in the files that were in the first commit, then apply every single diff sequentially to generate the working copy.
404 my man. 
I think you meant to reply to sbin below. Anyway, no, _ is just a variable like any other. However, it's a Python convention that _ is set to values you don't care about. In the interactive interpreter, _ also automatically contains the value of the last expression. % python &gt;&gt;&gt; 2 + 2 4 &gt;&gt;&gt; _ + 5 9
Thanks. I wonder if it has merit. It's based a lot on what I've learned from exploring git's simple data model. I also hope OP is okay, and not trapped under something heavy!
Great talk! One thing, at the end during Q&amp;A you said that opargs are specified in network byte order, I always thought network byte order was big endian, and it looked like opargs were specified little endian, am I missing something?
With the medium load my apps usually receive, I've found that CherryPy + nginx reverse proxy worked really well. All my static files are served either by nginx or through the use of CDNs. It's perhaps not the fatest solution but it's steady, reliable and fun to work with.
BUT JOSH THIS HAS LITERALLY FUCKING NOTHING TO DO WITH PYTHON WHATSOEVER. WHY POST HERE?
Can you link any articles on how to integrate cherrypy with nginx or apache it anything? The docs for cherrypy succckkk
You could also reject for spelling errors in the comments. You could.
3. The point of bytecode is reducing compile time. Compiling to machine code is expensive in CPU cycles. You'll need a specific software to execute bytecode (example: the JVM), and most of the time, it will be slower in execution time, but since computers are very fast, if you're not doing anything very intensive, it won't make any real difference.
&gt; The killer feature for me is deploying an app and having only that app restart. I believe, mod_wsgi in daemon mode can do that too.
As I was saying in a related recent thread, I've been using CherryPy+nginx (reverse proxy) with great success. 
"How best to configure the MPM settings of Apache when running a WSGI application in embedded mode is not the point of this post. I will deal with that another time." Graham pls! In the meanwhile... could you please tell me if this config is fine: &lt;IfModule mpm_worker_module&gt; StartServers 4 MinSpareThreads 1 MaxSpareThreads 16 ThreadLimit 16 ThreadsPerChild 4 MaxClients 16 MaxRequestsPerChild 0 &lt;/IfModule&gt; Thanks!
Requests is built on top of urllib3, and so does more work compared to what urllib3 does. This means in terms of raw speed, urllib3 is faster. If literally all you want is the bytes that make up a web page, use urllib3. =)
&gt; machine-friendly vm-friendly
Thank you! I read the built in cherrypy server is decent, but docs in really how to set up apache/ngnix with any other language besides PHP seem really sparse
pycurl could be something to look at, as it's just a python wrapper around libcurl, written in C. However, I fear that the overall impact will be quite small, as the majority of the time will be spent waiting for the response from the server. I suggest you write your crawler in an asynchronous fashion, so you can use this idle/waiting time by sending other requests.
Those are also things you can't fix (because commits are immutable).
https://en.wikipedia.org/wiki/CPython https://en.wikipedia.org/wiki/Bytecode * http://docs.python.org/2/glossary.html#term-bytecode * http://docs.python.org/2/library/py_compile.html * http://docs.python.org/2/library/compileall.html * http://docs.python.org/devguide/compiler.html#ast-to-cfg-to-bytecode * http://docs.python.org/2/library/dis.html#bytecodes 
urllib3 is faster, but requests has a nicer developer interface. Building a web crawler / scraper, you are more likely going to be I/O bound by network requests more than anything else.
If you need to execute Javascript too take a look at http://jeanphix.me/Ghost.py/
Is really using requests that much of an overhead? Probably using response.raw would prevent unnecessary string decoding
If you want an interactive guide, I believe codecademy has one in their Python track. 
True. Fortunately, since reverse proxying is rather neutral, it's just a matter of finding a good howto on setting nginx reverse proxy and you're almost done :)
Can't get faster than [socket](http://docs.python.org/2.7/library/socket.html) #!/usr/bin/env python import socket URL="www.google.com" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((URL, 80)) s.send('GET / HTTP/1.0\n\n') data = "" while True: d = s.recv(4096) if d: data += d else: break s.close() print data 
Huh. I never realized HTTP was just regular plaintext over TCP... I thought something "else" was going on
I define a main() so that I can test it more easily. (And then have a "if __name__" block that calls it with sys.argv.)
Check out [Scrapy](http://scrapy.org/)
It's an app framework, that also provides a server. It recommends for heavy production use that use use a different underlying server; on the other hand, it has a lot of features to simplify app writing (routes, etc). Hence, an app framework.
My thought is that MongoEngine is a very nice ODM.
&gt; I don't know much about pymacs other than it constantly seemed to be the weak point in my emacs-python setup. I don't know about it as well, I just remember that the first time I managed to configure and use it (a couple of years ago) it was a true mess. So I just keep everything in a directory with a small .el file which act as a configurator for the rope-ropemacs-pymacs. &gt; I know elpy is supposed to have a jedi mode, but I've never yet experimented with that package. I've always just used the Rope stuff. I should just take a look to the documentation and see how to configure the backend on jedi. And maybe rip off the ElDoc integration. :) &gt; I never used yasnippet until elpy provided it. I see. I think it's one of the emacs' most used extension. From my point of view, overriding the snippet expansion setting is just *crazy*. I'll let you know if my next attempts will be able to produce anything valuable. thanks.
Not to mention a language called "BASIC". :-) Some versions used an intermediate bytecode as well. 
And like someone else pointed out, you're probably io bound if you're downloading a lot of webpages anyways 
HTTP2 is a lot fancier
I'm a big fan of MongoEngine as it makes defining data models a breeze and also does some validation. I really enjoy working with objects instead of dictionaries, and I get the added benefit of attaching other properties and methods to my models in a pythonic way.
My brain shut down around line numbers
Mostly I find myself thinking about problems at a higher, more algorithmic level now when I'm using other languages. With some languages, I feel like I'm rolling in the weeds, but I'm more likely now to think about the problem at a higher level and lay out my program structure based on that and then encapsulate the complexity in other routines. Much of that is simply good programming practice anyway, but using python has helped it feel more natural. Also, I find that there are certain functions I've become addicted to in python that I want elsewhere. As an example, string.split(). A while ago, I was working on something where the algorithm begged for having that available; rather than doing it inline, I added a function to a library of utility functions that I maintain (I didn't want to subclass std::string and force casts to that type or declare everything to be of that type). std::list&lt;std::string&gt; stringSplit(const std::string &amp; input, const std::string &amp; delimiter) { std::list&lt;std::string&gt; result_list; std::string::size_type current = 0, end = input.length(), match; do { match = input.find(delimiter, current); if(match != std::string::npos) { result_list.push_back(input.substr(current, match - current)); current = match + delimiter.length(); } } while (match != std::string::npos); if(current != end) { result_list.push_back(input.substr(current)); } return result_list; } (I realize it may not be perfect; it does only scan the input string once however. Point isn't the code, but how my code in other languages has changed as a result of using python.)
http://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files Make sure you understand the access mode.
Most of the answers you'll get to this question will be the same: google it! And that's not just being snide or talking down to you. Searching for the answer to programming questions is a skill in it's own right, and you have to learn by starting with the easy stuff. A site called StackOverflow will show up frequently in your search results, and it's usually a good bet.
/r/learnpython might be a better place for questions like this but here's what you need: http://docs.python.org/2/tutorial/inputoutput.html
http://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files
Not snide at all. I use Google for everything whenever I'm in a rut. I just couldn't find anything this time around and started freaking out and thought "Reddit!"
That's awesome! We've been on the RCs for a while now and been very happy. Now for Python 3 support :-)
I cannot emphasis how much more than 1 point I would like to upvote that comment.
Google "Python read text from file". With that you should be able to figure out how to get a text file into a string, either all at once or line by line. Then you need to figure out how to parse the string to get the data you want. Hints: you can treat strings like arrays as far as accessing characters, your probably going to have to do some sort of string to number conversion
You just inspired me to move to Foxit reader from Adobe. Thank you. I wish I had known about its existence earlier.
Keep up the good work! gevent is awesome!
Cool, glad to be of help, even if indirectly :-) 
No, there's very little overhead, but there is always _some_ overhead. Requests does quite a bit to be helpful, including quite a few function calls. I invite you to take a look at the code. =)
From the very little I know about parakeet, I think it only supports a small subset of numpy. If you can't find something in the documentation (if there is any) maybe try making "test" functions that only use some of the numpy functions you are using and see if they fail. Also, maybe it is having trouble with the class instance "self" since I'm guessing you are putting the "jit" wrapper around the function. Maybe try making a separate standalone function that hard codes the values you are getting from "self".
You might be on to something regarding the self parameter! I should have thought of this earlier. Will update when I have time to change the code.
Damn, too late. Coupon is out already
Awesome, thanks for the hard work.
I'm the author of MongoKit which is the ODM behind Elkorado (http://www.elkorado.com). The math is simple: if you like something like the Django's ORM, go to MongoEngine. If you want something closed to PyMongo, you'll pretty enjoy MongoKit.
Curious if there are plans to have a pluggable backend for the new asyncio stuff in python 3. Would be great to keep the API and use the new async code.
I once tested pycurl, requests and urllib (2 I think). pycurl was like 2 seconds, requests was 5 and urllib was around 9. Obviously these are not puncutal datas, but somewhat relevant. (I just ran the script like 5 with each version, the script itself afaik logged into a page, then got something from there using the cookies)
Perhaps you can't get faster than socket, but creating a new string and copying the new bytes with `data += d` each recv is surely not the fastest way of doing that. Better to append the recv'd strings to a list and then use a single `''.join(lst)` at the end.
Finally! We already use the RC in production from a long time without any issue.
happy cake day
You don't ever have to type that again if you don't want to. That little idiom is optional, it just makes it so that you can import the file like a module and call some of its functions without executing whatever code is defined at the top-level scope. There is no reason to slavishly put that in every script you write, and I really take exception with tutorials and whatnot that keep pushing this idiom on everyone by default. Use it if and when you need it, which for most people is never. And no, it's highly unlikely that those particular identifiers would ever be changed. Those attributes are special, and the double-underscore naming is meant to remind you of that. `__name__` is the name of the current module, and it is automatically created for you, unlike regular variables. It would be very bad if that were changed to `name`, because that's a very common word and it would likely clash with tons of existing scripts that have used that identifier at the module level to name something. And likewise, `__main__` is the name of the main module. It's meant to have a name that is distinct from all other module names, hence the special name. If it was just `main`, that would again be bad as it would conflict with a potential module named `main`, a very common identifier. So the naming convention here is both to remind you that these variables have some kind of "magic" to them, but also so as to pick names that can't clash with identifiers that a user might pick, because double-underscore identifiers are supposed to be reserved. 
I posted an answer [on stackoverflow](http://stackoverflow.com/questions/20167572/optimizing-python-function-with-parakeet/20179933#20179933), which I hope people don't mind if I just copy over: --- Parakeet is still young, its NumPy support is incomplete, and your code touches on several features that don't yet work. 1. You're wrapping a method, while Parakeet so far only knows how to deal with functions. The common workaround is to make a @jit wrapped helper function and have your method call into that with all of the required member data. The reason that methods don't work is that it's non-trivial to assign a meaningful type to 'self'. It's not impossible, but tricky enough that methods won't make their way into Parakeet until lower hanging fruit are plucked. Speaking of low-hanging fruit... 2. Boolean indexing. Not yet implemented but will be in the next release. 3. *np.tile*: Also doesn't work, will also probably be in the next release. If you want to see which builtins and NumPy library functions will work, take a look at Parakeet's [mappings](https://github.com/iskandr/parakeet/blob/master/parakeet/mappings.py) module. I rewrote your code to be a little friendlier to Parakeet: @jit def parakeet_dist(x, y, z, L, periodicX, periodicY, periodicZ): # perform all-pairs computations more explicitly # instead of tile + broadcasting def periodic_diff(x1, x2, periodic): diff = x1 - x2 if periodic: if diff &gt; (L / 2): diff -= L if diff &lt; (-L/2): diff += L return diff dx = np.array([[periodic_diff(x1, x2, periodicX) for x1 in x] for x2 in x]) dy = np.array([[periodic_diff(y1, y2, periodicY) for y1 in y] for y2 in y]) dz = np.array([[periodic_diff(z1, z2, periodicZ) for z1 in z] for z2 in z]) d= np.sqrt(dx**2 + dy**2 + dz**2) # since we can't yet use boolean indexing for masking out zero distances # have to fall back on explicit loops instead for i in xrange(len(x)): for j in xrange(len(x)): if d[i,j] == 0: d[i,j] = -1 return d, dx, dy, dz On my machine this runs only ~3x faster than NumPy for N = 2000 (0.39s for NumPy vs. 0.14s for Parakeet). If I rewrite the array traversals to use loops more explicitly then the performance goes up to ~6x faster than NumPy (Parakeet runs in ~0.06s): @jit def loopy_dist(x, y, z, L, periodicX, periodicY, periodicZ): N = len(x) dx = np.zeros((N,N)) dy = np.zeros( (N,N) ) dz = np.zeros( (N,N) ) d = np.zeros( (N,N) ) def periodic_diff(x1, x2, periodic): diff = x1 - x2 if periodic: if diff &gt; (L / 2): diff -= L if diff &lt; (-L/2): diff += L return diff for i in xrange(N): for j in xrange(N): dx[i,j] = periodic_diff(x[j], x[i], periodicX) dy[i,j] = periodic_diff(y[j], y[i], periodicY) dz[i,j] = periodic_diff(z[j], z[i], periodicZ) d[i,j] = dx[i,j] ** 2 + dy[i,j] ** 2 + dz[i,j] ** 2 if d[i,j] == 0: d[i,j] = -1 else: d[i,j] = np.sqrt(d[i,j]) return d, dx, dy, dz With a little creative rewriting you can also get the above code running in Numba, but it only goes ~1.5x faster than NumPy (0.25 seconds). The compile times were Parakeet w/ comprehensions: 1 second, Parakeet w/ loops: .5 seconds, Numba w/ loops: 0.9 seconds. Hopefully the next few releases will enable more idiomatic use of NumPy library functions, but for now comprehensions or loops are often the way to go. --- I'm finishing up my thesis now but I'll try to get a tutorial of some sort online in the next few weeks. Also, sorry about the confusing state of *np.tile*, it's not supposed to be in *mappings* yet. I believe it's the only thing in there that straight-up doesn't work. Other functions are missing some of their parameters, most notably the *output* argument of ufuncs. 
Rhomboid is right that the `if __name__ == "__main__"` thing is rarely actually useful. You don't need it unless you want a Python file to work *both* as a module and a standalone script. There are few times where the other underscore features are useful. If you're seeing a lot of them, you're doing it wrong. `__init__` is the only one I use regularly, and `__unicode__` is commonly used with Django. Other than that, the underscore stuff is almost all "under the hood". If it's really that big of a nuisance, you are either way too picky or you haven't spent much time trying to use Python.
Gevent is an HTTP server comparable to nginx?
I'm new to programming and unfamiliar with bash so I stuck to python. I just tried that PNG trick in python as well, but same thing. Interestingly, if I export a jpeg from preview at a different quality, it will recompress, which makes me think it has to do with the algorithm that is used? Not sure. Thanks for the response!
&gt; rarely actually useful *I* use it all the time. 
So don't use python.
underscores should be like, 10 times thicker.
A text editor that can autocomplete snippets can help with the typing. Also, the double-underscore variables are ugly for a reason - it's meant to be painfully obvious that those are intended to be private variables. Python does not enforce private vs public but the naming convention is there for this purpose. For scripts, just use this idiom instead: def main(): do_stuff() main()
I tried your code with the latest snapshot and I'm getting this error running the function: LinkError: Command "/opt/local/bin/gcc-mp-4.5 -bundle -undefined dynamic_lookup -L/opt/local/lib build/temp.macosx-10.8-x86_64-2.7/var/folders/q9/l0k1gn1543l_2yz_zk4tyhjw0000gn/T/parakeet_parakeet_dist_OzwkPV.o -o build/lib.macosx-10.8-x86_64-2.7/parakeet_dist_00507d3f42354bb12c010a390495507a694eca1da3e7c6c2476a4e21.so -shared -lm -Wl,-undefined -Wl,dynamic_lookup -fopenmp" failed with exit status 1 gcc-mp-4.5: -bundle not allowed with -dynamiclib
Do you not use `__repr__` and `__str__`? They're so handy. I like `__call__` as well. I also have `if __name__ == "__main__"` in pretty much every script I write. It helps keep things structured well, imo.
I must say that I'm a bit disappointed that PyPy work did not get in 1.0 in time.
&gt; It'll be very much like twisted, I gather, which I'm not terribly fond of. So... he doesn't and he has brought in the wrong people. Not even joking. Gevent and eventlet are currently the most practical way to do concurrency in Python today. It doesn't fragment libraries, can spawn multiple green threads with minimum performance impact. Looks clean. But no, it was discarded right away. It was clear in his "exploratory, call-for-concurrent-IO-experts-no-green-thread-users-need-apply email". Let's talk about Twisted. For how long has it been around? Long time. Has it taken the world by storm? Nope. "Ah! But async programming is what the cool kids use". [inline define cool kids = those that use Node.js]. "Hmm...Node.js must be popular because it uses lots of callbacks, we should get us some callbacks and errbacks as well.". Except that is not why Node.js is popular. It is popular because it is fast and in Javascript. Callback-based programming is not the new-hot thing, it is something Node.js has to deal with and it is something Twisted developers have been doing for a decade or more now. If we want to copy Node.js we should copy its performance -- its JIT engine, not nested callbacks within callbacks. 
The question is not clear. If there are five lists, one for each position, then you only need to pick one element from each list. Also, this seems like a good excuse to dive into itertools
No, it's an event system and networking library for Python. It's the kind of thing you might use to write a server like Nginx, if you wanted to write it in Python.
I think the bigger problem is there are literally hundreds of man years of development into some of these fundamental libraries. Every optimization trick in the book has been used to make them as fast as the hardware can allow. Porting them would be none too straight-forward and would require a serious effort. The end result of which would be something with equal performance to the existing code base, but you could say it was not in Fortran.
I'm not sure exactly what I'm reading, but was major progress on this just made in the last two days? https://github.com/surfly/gevent/commit/0e835f9f562d3929944b4d1442f2da1644a8defd
Huh, I thought that was an exclusively ipython trick.
Out of curiosity, what searches did you try? There are other answers in this thread that are pointing you directly to the documentation you need, but I'd be interested in figuring out why your searches weren't working for you.
Probably off-topic I've been involved in a couple of projects that have used Mongo, and it's been nothing but trouble. It's all fun and games until you need transactions. Then you'll bitterly regret not using Postgres. Or if you need to do serious aggregations. Then you'll regret it too. Or if you wish you could store the attribute names once for ten million items rather than ten million times for ten million items. Or if you wish for compressed collections. Not saying it's not the right choice for your particular use case. But make sure you look into it and avoid the hype. Remember that postgres has native support for JSON columns. Hstore might suit you too.
The major progress was made a year ago by fantix, Denis has just decided to make a 'python3' branch with those changes incoporated. I'd still like to know exactly how he wants to go about incorporating that into master, given that the underlying network code is just about the hardest thing you could choose to support as a single-source python 2&amp;3 library. There's a lot of the community that would like to help but don't exactly know what PRs they should be sending and where atm.
What brings you to make so many scripts that need to be importable *and* runnable?
Ugh. Guido has said a number of times, in fact pretty much every time he gives a talk on asyncio/tulip, that yes he too is sane and hates callback based eventing just like the rest of us. Using yield and yield from (pretty much creating coroutines in the same way) is much preferred. The inventor of the language isn't a random dumbass who doesn't know what the fuck he's on about, if that's what you're implying. The reason the low level event interface has a callback compatible API is to be interoperable with other libraries, like tornado, qt, libuv, etc. Which gevent isn't. It's gevent's event loop or the highway. And either you support cpython 2 or you're done. Most complicated libraries do *not* simply work with monkey patching, which is why you see heaps of `gevent-x` adapters in PyPI. It might be surprising to some people but there is *shittonnes* of python out there that *doesn't* use greenlets, and the python standard library has to support all that too. It's easy to miss when you're in a cocoon developing your own application that works perfectly fine for you.
I'm a huge fan of SQL (at least compared to everything else, have been forced to work with MongoDB recently and can't believe just how terrible it is). But dismissing criticism like this with "I don't think it's important so your opinion is ridiculous" isn't that helpful. Nothing is perfect, and finding flaws in things and fixing them is how we make things better. The ordering certainly isn't intuitive or representative of how the query is actually run. That makes SQL harder to learn and reason about. That is a Bad Thing.
The twisted guys already know all the warts that come along with twisted best, and have advised on how *not* to add those back into asyncio.
&gt; And either you support cpython 2 or you're done. As fijal noted elsewhere in this thread, PyPy support will be merged in soon. PyPy has the mechanisms, but the integration code isn't completed yet. The other problems are still very much present, of course.
I get an authorization error trying to clone your dev branch but I removed the -shared flag manually and it fixed the error. Thanks.
are you writing science scripts? Could ipython notebook help you write it? 
Try Spyder! 
Spyder has everything you described. You can get it as a part of the free anaconda python distribution (which I highly recommend). It has it's own self contained install package and virtual environment manager, so it's very convenient to use. Find it here: https://store.continuum.io/cshop/anaconda/
You should be able to change order of operations at run time with my system (at least before the run loop starts), the operation list is just an array of tuples. Yeah, I know there's a lot of other python libraries that do the same thing, I just wanted something way simpler.
Tulip/asyncio consists of many parts, the event loop just being one of them. Gevent could adopt the asyncio event loop, but in order to do that gevent.core would need to be refactored IMHO, as it's currently very very tied to libev. Assuming that would happen, Gevent could provide something similar to this [1] to combine the use of current gevent friendly code with asyncio protocols. [1]: https://github.com/1st1/greentulip 
I didn't see C# and asp.net.
I assume You do: * 50 * 50 * 50 * ... * 50 but want: * 100 * 50 * 25 * 12.5 * ... * 3.125 etc. this could be done with quality = 100 for i in range(n): quality *= 0.5 print(quality) **Edit:** Ive wrote a script and run it on a reference image here http://imgur.com/WdiUY48 note PIL only takes integer compression values so below 1 its all the same 
&gt; pip install doesn't uninstall stuff that is removed from requirements.txt Which is why I **want** pip-sync ASAP. &gt; nor does it provide an easy way to see what dependencies have been updated. `pip list --outdated`, since pip 1.3.
&gt;&gt; nor does it provide an easy way to see what dependencies have been updated. &gt; &gt;`pip list --outdated`, since pip 1.3. I didn't know about that one, thanks!
Maintainer of MongoEngine here - thanks all for the kind words. I love MongoEngine but like MongoDB its not a panacea. I always advise learning MongoDB and using pymongo directly so you can learn about its foibles and learn more about the database as a whole. Theres even free online classes at education.mongodb.com to get you on your way. The single biggest downside to MongoEngine is its too easy for people to use MongoDB the same as they would use a relational database, which is a path to pain. I see so many stackoverflow questions that show me people are swapping out Django's awesome ORM and then using MongoEngine in exactly the same way and then have pain! I just remind them to use the right tool for the job and that sometimes you can use more than one database to solve your problems effectively O_o That said, I love MongoEngine, I picked it up to help out my team who all were used to Django and it made the transfer easier. Having models do validation and generate forms is a big plus for many people - they don't want to care about the persistence layer and want to get stuff done. Also, I'm always looking for contributors to help make it better and easier to use!
&gt; fileinput.input() creates a global fileinput.FileInput() object, which other functions in the module then access. That's a dealbreaker right there.
I was going to say… work with the standard input and output. python program.py &lt;input.txt &gt;output.txt
I'm not sure if this'll work, but try alternating the quality between, say, 45 and 50 on even and odd iterations respectively.
if you have acess to Visual Studio, there is PTVS http://pytools.codeplex.com/ which does everything you want (and more)
[this(ndb)](http://code.google.com/p/appengine-ndb-experiment/source/browse/) is pretty old now but it's a pretty substantial api. IIRC, this code led to the ideas that will be dropping into [asyncio](http://code.google.com/p/tulip/source/browse/#hg%2Fasyncio) in 3.4 
Standard library has the wav module, which allows reading frames and writing them back out, including writing a subset. That's all you need! http://docs.python.org/2/library/wave.html
The graph scales exponentially. Just mentioned. 
You can use PTVS in the free 2013 RC
whoa, nice find. Thank you!
Thanks for the reply! I'll check it out. Is it possible to allow other audio formats through another library? 
uwsgi + nginx - everything else is a bit pants :(
Take a look at Zope…
It's even worse. Keep reading: &gt;The other is that the in-place modus **hijacks sys.stdout** as the means to write back to the replacement file. 
I'm using Python all the time for Enterprise critical tasks. I just works!
I switched over to 3.3 years ago so this app is useless. More so why would you implement old technology on a device that has some pretty extreme limitations and is a relatively fresh platform. A completely new platform plus the development work that goes into supporting that platform should have gone into the Python 3.x series. 
He recently wrote [tulip](https://code.google.com/p/tulip/) (along with ~10 other commiters), the newly accepted asynchronous I/O Python API.
&gt; that yes he too is sane and hates callback based eventing just like the rest of us. Using yield and yield from (pretty much creating coroutines in the same way) is much preferred. Twisted also has yield like couroutine behavior -- see inlineCallbacks, so that is not new. &gt; The inventor of the language isn't a random dumbass who doesn't know what the fuck he's on about, if that's what you're implying. One can be a genius in one area and dumbass in another one. It is not all or nothing. &gt; The reason the low level event interface has a callback compatible API is to be interoperable with other libraries, like tornado, qt, libuv, etc. Which gevent isn't. Wrong, gevent can be made interoperable. It was using libevent, now using libev, could probably use libuv or even Twisted underneath. In fact eventlet (gevent's older cousin) had a Twisted wrapper for its hub for a while. &gt; Most complicated libraries do not simply work with monkey patching, which is why you see heaps of gevent-x adapters in PyPI. Some don't, mostly the ones that have custom C modules in them. &gt; It might be surprising to some people but there is shittonnes of python out there that doesn't use greenlets, and the python standard library has to support all that too. That is why gevent should be the default when looking at IO concurrency in Python, because there is no need to support multiple style of libraries. With Twisted or Tulip or Tornado you cannot share libraries easily between them. As you said, it is either &lt;your-callback-based-io-framework&gt; or the highway. Eventlet at least can path socket, threads and many OS services to there is not need to create a parallel set of standard libraries. &gt; It's easy to miss when you're in a cocoon developing your own application that works perfectly fine for you. Apparently this cacoon is pretty big, as gevent and eventlet are pretty popular. I would say a lot more popular than Twisted these days. 
I tend to agree with you. I find that the ODMs tend to negate my favorite features in mongo. While I wouldn't go without an ORM when using a relational DB, I have not found any reason to use an ODM on my projects. That said, my projects tend to be for small groups, the dev process iterates quickly, schema changes come fast, and using pymongo vs an ODM really helps get my projects functional quickly. I could see how users of ORMs would feel more comfortable using an ODM if they're new to Mongo. 
I'm... not sure what to say to that. That's sort of like saying instead of building a car, you could build a motorbike. They'll both take you from A to B. But if I've already started building a car, why would I start building a motorbike? From a pragmatic perspective, fork() was a non-starter for Windows, I wanted to leverage all IOCP had to offer, and the best way to do that is via threads, not processes. I stressed the importance of not trying to employ UNIX paradigms on Windows in the talk; Windows is designed differently: &gt; What works well on UNIX, doesn't perform well Windows. &gt; What works well in Windows isn't possible on UNIX. As for writing a new GC... that didn't interest me.
How would interpreters communicate object state back to each other? I lied in the presentation and said that I'm strictly shared-nothing; that's not true -- I just present it like that as it's easier to grok why we don't need to do reference counting. The details are much more involved: http://markmail.org/message/nlmqysv2db6ypx47 http://www.reddit.com/r/programming/comments/1qrnew/pyparallel_how_we_removed_the_gil_and_exploited/cdg04cc
Thanks for these great tutorials, much appreciated. Maybe you could crosspost it to /r/flask ?
Thanks! :)
I'm not arguing for this form of concurrency, as I'm not experienced enough to warrant an opinion, but I think that you're mistaken about not being able to use Twisted with other libraries. For example, a reactor was produced to share the event loop with Qt. That sounds like strong interoperability to me. Granted, it isn't as robust as monkey patching, insofar as compatibility, it seems a strong indication that it can and has been done. I can also vouch for the other side: I'm currently using twisted (with scrapy) for a small component of a larger project. After the bugs that I mentioned, it has been working quite nicely with the rest of my code.
I don't like their debugger command box vs having a standard python interpreter.
Is there an IDE with debugger associated with ipython notebook or is it just an interpreter with some more commands or something?
I'll have to give this a whirl.
I guess it boils down to Python being an easy to learn, clean, and backwards compatible language (of course except for the 2.x to 3.x migration). Java has a bit too much boilerplate. Ruby is not clean enough and changes a bit too fast. C++ has no standard solution for garbage collection. Of course these are all pretty subjective :)
When you start debugging it uses ipdb in the same window where IPython was. what do you mean?
&gt; but I think that you're mistaken about not being able to use Twisted with other libraries. So how do I use Python's standard XMLRPC library with Twisted? You can't. Why? Because a call to socket.receive() should block the current thread until data comes in. Twisted returns you a deferred. What do you do with the deferred? You use it with the another Twisted library. That deferred bubbles up to the top of your API. &gt; For example, a reactor was produced to share the event loop with Qt. The difference is between integrating Twisted's reactor with some event loop, which eventlet can also do and using Twisted libraries alongside other libraries that are not Twisted. 
We use Python in critical systems to our business. For two main reasons: Speed of development and long term maintainability (readability of code).
&gt; Twisted also has yield like couroutine behavior -- see inlineCallbacks, so that is not new. It doesn't have `yield from` though, which is key to allowing these niceties properly, and also why asyncio is &gt;=3.3 only. &gt; That is why gevent should be the default when looking at IO concurrency in Python, because there is no need to support multiple style of libraries. With Twisted or Tulip or Tornado you cannot share libraries easily between them. As you said, it is either &lt;your-callback-based-io-framework&gt; or the highway. Eventlet at least can path socket, threads and many OS services to there is not need to create a parallel set of standard libraries. You might have missed half the point of asyncio then. It's designed to solve this problem of incompatibilities everyone has - other libraries can provide the event loop implementation dynamically, at run time. Or, asyncio can provide a default one. And anything using the asyncio interface won't care. Not the case for gevent, you'd need to recompile the whole thing to run a different event loop.
WingIDE has the best debugger
How is this different / better then Flask?
There are great libraries for audio encoding, including libsndfile for lossless and lame for mp3. If you want to play sounds through a webpage (sorry I'm not clear on this), html5 can do that directly. 
I apologize, but as I went to x-post to /r/Programming, I discovered that [this link already exists](http://www.reddit.com/r/programming/comments/6dutd/generate_regular_expressions_from_some_example/), so I hope you enjoy it, and if you do, be sure throw some karma in the direction of /u/san1ty too.
Thanks! Yeah I plan on having it be web based. Users able to upload sound clips and then be able to view and play those clips from a webpage. Ive been looking at Django for the web framework. 
But isn't the power of Flask that you start out with something very minimal and then add all the stuff you need as you go. Only adding the parts that matter for your project and not have the entire kitchen sink. Also this micro framework still seems to have the entire Django library built in. If you want a micro framework that scales and can be built upon I'd say go with Flask :)
[That old code](http://code.google.com/p/appengine-ndb-experiment/source/browse/ndb/eventloop.py) really looks [out-of-style](http://www.python.org/dev/peps/pep-0008/). Hmm. Well, [`tulip`](http://code.google.com/p/tulip/source/browse/asyncio/locks.py) looks nice (wrt style), at least. ... Is there something in between?
I'll check into that. I'm using the defaults. Figures don't show unless I invoke show() and then it hangs until I close the windows. Thanks
If I can get the matplotlib thing going I'd be good to go (or good enough)
This is "just" an alternative syntax for django apps, not a new framework. So you gain the django ecosystem of apps etc.
Read on - that's the bad technique being replaced.
Python isn't exactly a saint here. Prior to 3.3, getting the proper outcome with characters outside the BMP depended on whether your Python was a "wide" build (ucs4) or a "narrow" build (ucs2). Linux distros tended to chose wide (and suffer for it with memory bloat), but the official Windows binaries have always been narrow builds. So you couldn't really depend on correct behavior at all. As of 3.3 the distinction is gone, finally, and you always get the right outcome. I'm a huge lover of Python and I'm not exactly jumping for joy that it took until v3.3 to get it right. Although, when people keep asking about why they should switch to Python 3, this is certainly one of the reasons you can present. 
Personally i am not advocating this approach. I don't know flask and i am a django dev, i have little reason to consider this. One reason why i would prefer to end up with django is the unified nature of the django core. One issue i personally have had with fleshing out microframeworks is that you end up with loads of third party dependencies developed by different people. You end up with a blotch of coding styles and less consistent APIs than when dealing with a opinionated full stack framework. Also on boarding other devs is harder than finding a django dev with the maturity of the framework, first and third party documentation etc. 
Was this library so bad they forgot even to remove it in the python2 -&gt; python3 cleanup?
Note that Google's Python style (http://google-styleguide.googlecode.com/svn/trunk/pyguide.html) is different in some small ways from PEP-8. But it's still very consistent and clean, so I wouldn't say it impedes readability in any way.
Not really much meat in the article. The only relevant bit I saw was not using MySQL "ORDER BY RAND()" on a large table which most people already know. His solution to it was interesting though. I found another way to get around the RAND issue on large tables like so, SELECT * FROM `table` WHERE rand() &gt; 0.99 ORDER BY rand() Its quite elegant I think. The trick is to make the 0.99 number capture a small amount of the total rows. So for 4 million rows I was actually using 0.99995 which returned about 200 rows which is easy to sort. I was trying it before over two databases I have sitting on my machine. The first has 500,000 records. Running a the first example over it took longer then I was willing to wait (so over 10 mins) before I restarted the MySQL. My faster version once the database was warmed up returned the results in less then 1 second. I then tried it on the database of 4,000,000 rows and it returned results in about 2.7 seconds. Of course this means doing a full table scan for every query but works quite up to a point.
While I want to make sure it's understood that I think django is a fine framework and do not have any complaints about it personally, I've got to make sure and add some clarity to the issues you've mentioned. * While django has a unified core, it is still built by "many people" and often times those people have disagreements on how things should be done. It might make you feel good to know that all of the pieces are technically part of django, but don't allow yourself to believe that means that everything has been implemented in a way that works for your application. * API consistency has never really been a problem for Python microframeworks, but it's especially not a problem for Flask. Flask has a very strict set of guidelines that extension developers must adhere to in order to get the extension listed on the extensions registry. * On-boarding devs is totally a non-issue. At present my company has over 30 devs working using Flask full time. A few of them had some experience with it before starting but most of them had no experience with Flask and many of them had no experience with Python either. The learning curve for Flask is extremely low compared to large frameworks like django.
I don't follow that sub and would've never seen this otherwise, thanks! +1 to everyone
Perhaps try: from turtle import Turtle turtle = Turtle() turtle.pendown()
When all you have is a regular expression hammer, everything starts to look like a nail. This is pretty useless, it generates the most pointless and basic kind of regexp ever; using its own example '27:Nov:2013 "This is an example"' it gives you: $re1='(27)'; # Integer Number 1 $re2='.*?'; # Non-greedy match on filler $re3='(Nov)'; # Word 1 $re4='.*?'; # Non-greedy match on filler $re5='(2013)'; # Integer Number 2 $re6='.*?'; # Non-greedy match on filler $re7='(".*?")'; # Double Quote String 1 $re=$re1.$re2.$re3.$re4.$re5.$re6.$re7; So it cannot match any other line in the same text format e.g. from the 28th of February 2011. It's also going to be horribly slow using the non-greedy .* over actually using regexp to specify what's really there, e.g. a single space or colon. Also, the double quotes around the string go into the match expression, which is almost always never wanted. This is quite poor, especially for perl which combined and augmented the regexp power of awk and grep 27 years ago (probably before the author was born) 
This looks wonderful! I am very excited to see where this goes.
&gt; when you need something more than a micro framework. What on earth are you talking about? Using a microframework does **not** mean that you're giving up features that you might need later. It definitely isn't a choice made because "we're not ready for something like django." I'd argue that most microframework users have already been down the django or pyramid or rails path. We've all just learned that what we're big boys now and we can choose the right components for our apps on our own without the need for a condescending framework telling us that we have to use it's stack.
It didn't work but I may not have done it right, this is what I have(the top three lines): from turtle import turtle turtle=Turtle() turtle.speed(10) 
I'm currently going through the codecademy course. I was thinking of using a book for when I finished to help get started on projects. I'm pretty bad at programming.
I'm not saying it's always the best tool for the job, but it's nice for those of us who need something quick and dirty, and aren't gurus in regex; you can tweak the code it generates. For my purposes, it helped me to take the output of cvadmin e.g.: http://pastebin.com/zsgtA7SS and turn it into a Python dict with the IP of the metadata controllers as keys with the value being a list of the volumes they're hosting, in this example the result would have been {'192.168.4.11' : ['Nearline02'] , '192.168.4.10' : ['Video01']} edit: fixed the spelling of quick edit: changed output of cvadmin to a pastebin link because reddit formatting didn't render it properly
Yeah, it does appear to be a few years old, but still helped me with what I needed to do.
uppercase of baﬄe works as expected in python 3.4 I don't know if that's new or not though. assert "ba\ufb04e".upper() == "BAFFLE" Diacritics definitely don't work as expected for substring, length and comparison operations without using `unicode.normalize('NFKD', x)` first which is unfortunate.
So how do you convert from Documents to your model objects?
Also, FWIW, I did tweak the code it generated, and no, I won't claim it's the most performant or beautiful snippet of code, but thanks to this tool it took less than a half hour to make it work how I need it to, and given the relatively small input, I don't care to spend a ton of time unnecessarily optimizing it: http://pastebin.com/YsCD5WWw
&gt; 2. What is the reverse? “lëon”, correct? Mostly this fails. The most common result is “l̈eon” (the dieresis is on the ‘l’ instead of the ‘e’). This is what happens without a string class, by just reversing an array of code points. &gt; 3. What are the first three characters? Mostly the answer here is “noe”, as opposed to the desired “noë”. This could easily lead into a big discussion about what a character is, but I assume most people would not be happy with the current result. This is again indicative of a string type which merely treats the data as an array of code points. &gt; 4. What is the length? The common answer is 5. And yet again, this indicates our string types are merely arrays of characters and not truly handling the text. Unfortuntely, Python (3.3 at least) also fails to solve these problems: &gt;&gt;&gt; 'noe\u0308l' 'noël' &gt;&gt;&gt; 'noe\u0308l'[:3] 'noe' &gt;&gt;&gt; 'noe\u0308l'[:4] 'noë' &gt;&gt;&gt; len('noe\u0308l') 5 &gt;&gt;&gt; 'noe\u0308l'[::-1] 'l̈eon' It seems to me like this is something that could be fixed pretty easily in Python by creating a `char` class representing a single character (as it would be perceived by a person) and having `str` act more like an array of `char`s. That way 'e\u0308' could be packed into a single `char` instance. Am I over-simplifying the problem?
I always start with Python 3, but I also try to make sure that the code could theoretically be compatible to Python 2. For example, I'd do something like float(some_int/some_other_int) in case I have to use Python 2 for some reason. These are one of the most dangerous expressions, because they dont throw syntax errors but could yield different results. However, unit tests are helpful to avoid this trap. Also, I add comment to Python 3 specific parts just to make sure I don't miss anything when I have to convert into Python 2 compatible code.
Where is the script failing? At import? do you have old versions around somewhere? Please run the following and paste the output here. import sun from sun import turtle globals()['sun'] globals()['turtle'] dir(turtle) 
The author walks you through submitting a junk package to pypi. Some kind volunteer seems to clear them out every month. https://bitly.com/gjGJE8 https://pypi.python.org/pypi?:action=search&amp;term=nested+list+printer&amp;submit=search http://code.activestate.com/pypm/search:simple+printer+nested+lists/ [Author's reaction](https://twitter.com/barrypj/status/38524574299721729)
I can't get it to work. If you're game....thanks in advance. First, I'm fairly new to python so... From the link you gave me, I invoked matplotlib's use('TkAgg') to set the suggested backend. The project properties extensions "support matplotlib event loop" (or whatever) was on. So, given that I created the code below and stepped through it. Though I am a bit surprised that the figure doesn't appear until after the show function maybe that's the way it works. I confess I'm used to matlab which would show the effects of all (implicitly) queued graphics operations in the debugger at a breakpoint. *Mind you, debugging an errant plot created with lots of graphics command requires this level of operation so you can see which statement caused the errant plot right when it happens. Is that not the job of a debugger in general?* After show is stepped over in the debugger, the figure appears but the debugger is unavailable (all the buttons are greyed etc). Only when I close the figure can I continue. That's a problem. Note that if I do this in Wing's Python Shell window, the behavior is different (and what I would expect) which is though, as in the debugger, the figure doesn't appear until show() is executed, once show() is executed, the prompt returns (it's not frozen at the point like the debugger. I don't have to close the figure to continue) and then I can enter in plt.scatter([3],[3]). Do you not see the same thing? from matplotlib import use as matplotuse matplotuse('TkAgg') import numpy as np from matplotlib import pyplot as plt plt.figure() plt.scatter([0,1],[1,2]) plt.show() plt.scatter([3],[3])
Well, with python modules themselves are inspect-able just like everything else. The error says that 'pendown' doesn't exist in the module turtle. So dig in!! 1. Find what 'turtle' is actually resolving to. The easiest way to do that is to print `turtle.__file__` 2. Open the file and look around! This will work for all python modules not implemented in C. PS: My original thought could still be correct. If there is a file named turtle.py in the same directory or in anywhere in the path before the ACTUAL turtle module you want to load, that 'incorrect' one will be loaded instead.
C++ and learning game dev are two huge undertakings. I'd rather learn some game development in a language I'm already comfortable in, then take on learning a low level language. As a beginner making anything with any tool is valuable.
For anyone interested, I came across this tool while writing this work in progress: http://pastebin.com/UtJJktGU Edit: Pastebin link updated
&gt; Any problem in computer science can be solved with another layer of indirection. But that usually will create another problem - David Wheeler It would work, yes. The problem in that case is that at a minimum you are adding an additional pointer of memory per character. On a 64-bit system narrow build (UTF-16), for example, you are increasing the size of strings by a factor of 5 at a minimum. There is another related method that I am using for a toy language I am making, though. Are you familiar with the idea of a [rope](http://en.wikipedia.org/wiki/Rope_%28data_structure%29)? The native string type is a rope, where each leaf node is an array of characters, each character having the same length within the leaf node. This makes insertions and deletions potentially a pain, but greatly simplifies some other things at the same time. In particular, length is O(1). Also, not having to deal with null terminators is nice. Although there are destructive and non-destructive versions of substring, which is less than ideal...
turtle != Turtle look over it again. how does your version differ from apiguy's? Capital letters are treated independently from their lowercase counterparts.
&gt; Learn Python the Hard Way http://learnpythonthehardway.org/book/
Yes, I knew that memory would be an issue and I actually meant to mention it in my original post but I forgot. I just figured that if any language was going to make this trade-off between lightweightness and usability, it would be Python. The rope seems a pretty interesting idea. Could you explain how this would solve the unicode issues mentioned in my original post (namely getting satisfactory results length, substring and reverse operations on unicode strings)? I can just about grasp how ropes work in the normal case but I often struggle with visualising binary tree structures and how they work in more complex cases.
This sounds awesome. Trying to do something like Audiko?
Python is, IMHO, mostly doing the Right Thing here. As far as Unicode is concerned, `'noe\u0308l'` is a five-character string. That is, it is a sequence of five code points. Now, that is rather unfortunate, but that's a problem with Unicode, not Python. Unicode defines combining diacritical marks as code points in their own right. Suppose Python disregarded Unicode and tried to make things "easy" for the programmer by treating code points as a unit if they're meant that way (never mind how we're supposed to define "meant that way"; I imagine we'd need to reincarnate `locale` for full generality (e.g. in Spanish the string `'ll'` is (usually) one character)). Consider the string 'Spin̈al Tap'. There is no precomposed 'n̈' character, so normalization is useless. We have two options: 1. The string `'n\u0308'` has one character. There's no way in hell it'd have a well-defined return value for `ord()`, so this is simply Wrong. Besides, some software might actually *want* to interact with both characters separately (or at least know that there are actually 2 code points there). 2. That string has two characters. Some code will probably be confused by this, which is bad, but each character is unambiguously a single Unicode code point, which is a lot more logical from a standards perspective.
Furthermore, Python helpfully provides [unicodedata.normalize()](http://docs.python.org/2/library/unicodedata.html#unicodedata.normalize) to help you ensure the combining marks are represented however your application wants them.
I don't know what your tolerance for other languages is, but the processing.js language is easy to use and will work wonders. I have used it to render lots of graphics for various purposes and it works really well. Have a look at this: http://processingjs.org/reference/arc_/ It's pretty easy to embed it in a simple web page and render all kinds of graphic goodness. If processing.js looks like a possibility, I'd be happy to provide a more detailed example. I know it's not python, but there's a lot to be said for using the right tool for the job. And of course, there's always this: http://interactivepython.org/courselib/static/everyday/2013/05/1_processing.html Fun stuff... 
Agreed. I wouldn't go so far as to say that this is a problem *with* Unicode, but this is definitely the problem that Unicode is meant to solve. The definition of "character" is super thorny. Does ”can't" have four characters, or five? Are different font renderers allowed to have different opinions about whether the apostrophe is a character or a modifier? Not only is this a really complicated question, the answer changes over time, as new scripts are added and writing styles evolve. You really don't want your language to take on this complexity.
Unicode does define a grapheme cluster. It would be the character you are referring to here. The first problem is that grapheme clusters do not have a fixed size. Any operation which exposes a grapheme cluster thus necessarily has to involve heap allocation/deallocation, which is not going to be nice for performance. A great deal of text use also doesn't require grapheme level access. Things like serialization, printing, and even templates can work fine at the code point level. Operations like case conversion, regular expressions, and splitting do require grapheme cluster understanding. Text basically needs a dual interface, and the light one should not suffer from the fully compliant one. 
Alright. So, the key point is this: &gt; every character in a leaf node has the same length in bytes. I'm calling your definition of a Character a "logical character". That is, it could be one or more code points in a row, all associated. It's effectively like your suggestion of the array of pointers to Characters, but with the optimization that you don't need to store the length of every single Character if they are all the same. You can collapse a run of Characters with the same length to an array with a single length variable. A leaf node has a (nullable) pointer to the next child, the number of logical characters it has, the number of logical characters in its left subtree, the length of a logical character in bytes, and an array of size (charlen*numchars) bytes. To get the Nth logical character in a leaf node, you return array[charLen*N:charLen*(N+1)]. A rope has two pointers to its children and the number of logical characters it has in its left subtree. Length is easy - as every rope has the number of *logical* characters, simply return that number. Substring is also easy. Well, there are two cases, both of which require juggling, but it's no different really than the example on the Wikipedia page. To reverse a rope, you iterate through it backwards *over logical characters* and build a new rope. (There is a fancier recursive method, but it isn't any faster either algorithmically or in practice) It's actually concatenation that is the most difficult, all told. If you want I can show you a simple Java implementation tomorrow.
Pythonista is pretty cool and really well designed. Annoying that it's missing support for so many libraries though, and I wish there was an iOS GUI toolkit. 
Thanks mate
&gt; without using unicode.normalize('NFKD', x) first which is unfortunate Practicality &gt; purity, I think. That would be overkill for many scripts and hurt performance. People who need good text processing need things like the capital of i to be İ in Turkish but not in English. For example, that's way more than I need for my English language only Django site. We need to be able to publish stories about cafés and 💩 but we don't need to be able to capitalize Turkish and I'm glad we're not wasting cycles on it.
Nice! Thanks for sharing;)
Oh. Literally :'D haha thank you
I had a little extra time and decided to try this on the interactive processing.js web site. It was pretty easy. Even if you don't decide to use processing, you should look at the logic used below. Your loop indices need some help, for instance. Additionally, I don't know if Tk (the graphics engine that your example uses) draws arcs very well. That's what you need to draw semicircles, especially ones in various orientations. So you might want to look at the arc-drawing code below as well. If I'm stuck here much longer (I'm in a hospital waiting room) I might try it in Python just for fun, but as I said before, processing.js is very convenient for this kind of thing. Just draw your picture on a web browser canvas and grab it with any number of methods. (Greenshot -- google it. :-) ) Anyway, go here: http://processingjs.org/tools/processing-helper.html Enter this code: // white background fill(255,255,255); rect(-1,-1,1000,1000); // thin red pen for strokes strokeWeight(1); stroke(255,0,0); for (x = 0; x &lt; 5; x++) for (y = 0; y &lt; 5; y++) { rotation = 0; if (x % 2 == 1) rotation = 3*PI/2; fill(255,0,0); arc(x*20+10,y*20+10,20,20,-PI/2+rotation,PI/2+rotation); fill(255,255,255); arc(x*20+10,y*20+10,20,20,PI/2+rotation,3*PI/2+rotation); } This gives you an essentially identical image. I think the stroke weight is a little thicker, perhaps, but that could be fixed. Anyway, something to look at, and it was a fun diversion...
because you want to do it the hard way ;-D
OK, last thing. The graphics library you use doesn't expose the Arc property of Tk, but it does have one. The Tk library isn't that hard to use by itself. So the following code should produce the image you want: from Tkinter import * master = Tk() w = Canvas(master, width=110, height=110,borderwidth=0) w.pack() for x in range(0,5): for y in range(0,5): xc = x*20+10+5 yc = y*20+10+5 rotation=0 if (x % 2 == 1): rotation = 270 w.create_arc(xc-10,yc-10,xc+10,yc+10,fill="red",outline="red",start=rotation,extent=180) w.create_arc(xc-10,yc-10,xc+10,yc+10,fill="white",outline="red",start=rotation+180,extent=180) mainloop() This will get the image on the screen for you. If you'd like to learn more about the Tk canvas, look here: http://effbot.org/tkinterbook/canvas.htm Time to go see how my mother's doing. :-) (As mentioned earlier, I'm in a hospital waiting room) 
Interesting, just be warned that it does not generate correct regular expressions for capturing dates: entering: txt='2013-02-30' reveals re when yyyymmdd is selected: re1='((?:(?:[1]{1}\\d{1}\\d{1}\\d{1})|(?:[2]{1}\\d{3}))[-:\\/.](?:[0]?[1-9]|[1][012])[-:\\/.](?:(?:[0-2]?\\d{1})|(?:[3][01]{1})))(?![\\d])' # YYYYMMDD Now using the regexp visualiser from /r/Programming today ( http://www.reddit.com/r/programming/comments/1rlslw/regexper_awesome_tool_by_jeff_avallone_for/ ): http://www.regexper.com/#%28%28%3F%3A%28%3F%3A[1]{1}\\d{1}\\d{1}\\d{1}%29|%28%3F%3A[2]{1}\\d{3}%29%29[-%3A\\%2F.]%28%3F%3A[0]%3F[1-9]|[1][012]%29[-%3A\\%2F.]%28%3F%3A%28%3F%3A[0-2]%3F\\d{1}%29|%28%3F%3A[3][01]{1}%29%29%29%28%3F![\\d]%29 You can clearly see that it allows invalid dates and does not account for leap years. I don't even want to try put in an email address... Still, it is very useful for quick regular expression generation for fast prototyping.
I am the author of this, please feel free to checkout slides of a talk I gave about it in Mumbai-Python meetup this month. http://amitu.com/importd/
For anybody who does a lot of regex debugging, I found this to be pretty handy: http://jsregex.com/ It's big, wastes no screen real estate and simple. Plus it works fine if you save the page offline.
And, aside from the unicode text, there's also markup text (e.g. HTML), which also sometimes needs similar operators (e.g. "trim the text to 200 characters", if not "trim the text to 200 average-character-widths; or the usual "give me the lowercase of this marked up text")). ... Question is: would it make sense to handle it the same way unicode is handled?
The most important designs in game development translate painlessly to every programming language. Except for 3D Engine programming you can use whatever programming language you prefer. Game development is so much more than actual programming like figuring out a good scaling for a feature e.g. item stats scaling per level or balancing scores for certain combos. If you look at some recent indie games that got quite a traction, you will notice some of them were made with GameMakerStudio (which is currently free ;) ) examples are Gunpoint and Stealth Bastard Deluxe. I forgot the names of the others honestly. It boils down to the question: Do you like engine programming side of gamedev or designing game features? Just like others said you can always outsouce parts of your games to another language afterwards. 
Remotely relevant: why is temporary-token obtained using password-based authentication considered to be sufficiently better than simply using the said password-based authentication? I could understand why it would be useful if it used asymmetric-cryptography authentication (or, at least, http digest auth) for obtaining the token; but with http basic authentication, the only difference would be if only few of the requests get intercepted, which is not quite likely (compared to all-or-none situations).
It might not even be possible due to the fact that C allows aliasing and FORTRAN pretends that it doesn't exist. Edit: Unless you use the non-standard `restrict` keyword.
It's not just two codepoints that can compose into a single grapheme, it's a potentially infinite number of codepoints that compose into a single grapheme. You have a base character followed by zero or more composing characters.
Note that narrow/wide builds are gone as of Python 3.3; there's an adaptive string representation using between one and four bytes per character, depending primarily on the highest codepoint in the string.
Ah, the difference between one access (to get the password from memory) and two accesses (to put the keylogger and then to get the password)?
psycopg2 should give you a dict from hstore
You're welcome :)
Seems like I was not the only one with that issue. I'm glad if it can help someone save time in the future.
Not being familiar with Selenium, would it be possible to open the tab with a line like: first_link.send_keys(Keys.CONTROL + Keys.SHIFT + Keys.RETURN) Control + Shift + Click opens a tab with focus in Chrome. I'm not so sure about other browsers. Your way might be better to make sure everybody behaves the same.
The article's [thread on r/programming](https://www.reddit.com/r/programming/comments/1rkdip/the_string_type_is_broken/) yesterday has some interesting related talk on Unicode, though less on Python.
The problem is not really about opening the tab, plenty of ways to do that. The issue was to get back the focus on the new tab and be able to grab the content. The way I found to do it was by using the "switch window" handle provided by python selenium to put back the focus on the current visible tab.
That's what I was getting at. If you hold control **and** shift when you click a link the new tab is automatically on top. There would be no need for a line to bring the newly created tab to the top.
I'm saying (and correct me if I'm wrong) that the model you get is essentially similar to fork() and a fork-friendly cow GC. If it's true, this is an important lesson - you can get the same things on unix. If it's not true, please tell me where I'm wrong. The reason why a comparison is interesting is because more people know about fork() model than pyparallel and the limitations are far better understood.
I'm not convinced this was a good example. 
I was actually very surprised that it recognized and generated regex for IPs, which was very useful for my application.
Neither am I. The thing with Python is that most of the simplest scenarios are easy to implement, but the real software rarely consists of those POC-like snippets. I really like Python, it's my favorite scripting language, but I'd go with C# or Java nearly every time on anything 'heavier'.
I've been learning python over the past 3 years and what i've found so far is that it's so easy to "slap it together" that you never take the time to actually lay down an overall architecture. Part of that may be that I'm always under fire to get things done, but the language doesn't help you. Coming from Java's Force-You-To-Architech ecosystem it's been both educational and frustrating.
"the difference of approach. They tend to use components, a lot of components, to solve each of the problems like these." - Great, succinct description of the .Net approach. One of the things I love about languages like Python and Ruby is that you don't have to memorize a ton of libraries. Might be my laziness or even inability to memorize. Either way, it's something that pulls me towards Python instead of .Net. 
sudo pip install kills kittens! (normally)
That's an option. So's using `getattr` so you can also export objects with `__slots__` or property values.
Ok first of all I think you'd better chose which framework you're going to use to write Python on the Web. There are a lot of them ( You can find a list [here](https://wiki.python.org/moin/WebFrameworks) ). Probably the most known(and used) is [Django](http://www.djangoproject.com/). Anyway when you've chosen the framework you like, search how to set up your environment based on your choice because it's hard to work the other way. If you chose Django and want to stick with Apache you can find and how-to [here](https://docs.djangoproject.com/en/1.6/howto/deployment/wsgi/modwsgi/),anyway my advice is to use something like [Gunicorn]( http://gunicorn.org/) to serve your Python app and Apache to serve static contents and proxy request to your app. Another(and probably easier) way is to use a service like [PythonAnywhere](https://www.pythonanywhere.com/) (it has a free plan too). I hope this will help you and have fun coding with Python!
It's a language with a long history, a solid ecosystem, reliable, with decent performances. In a nutshell it has lots of features for anything "heavy" (whatever that might cover). It's clearly not the sensible choice in some instances but I don't see why one would consider it a toy language.
I moved the saves out of C:\Python33\ and unfortunately it still isn't running, now it gives me this error: Traceback (most recent call last): File "C:\Users\Francis\Documents\School\Python\Sun.py", line 1, in &lt;module&gt; import turtle File "C:\Users\Francis\Documents\School\Python\turtle.py", line 2, in &lt;module&gt; turtle.speed(3) AttributeError: 'module' object has no attribute 'speed' (I will be trying to re-install and some other things later, thank you for this tip though I genuinely had no idea that it was a bad idea to keep them there.)
Can you post your code along with the output of `dir *`. Also as a sanity check, from the current working directory where you execute c:\Python33\python.exe run a shell ( `c:\Python33\python.exe` with no arguments ) and run `import sys; print sys.path` ( semicolon's are valid syntax but generally frowned upon ) The interpreter believes there is a file at `C:\Users\Francis\Documents\School\Python\turtle.py` at line 2 that is calling `turtle.speed(3)`. Incidently Python 3.3's standard library turtle.py doesn't have a any code at that line. https://github.com/akheron/cpython/blob/3.3/Lib/turtle.py
Indeed. Combining something like that with ropes would be interesting, however, where each leaf can be one to four bytes per codepoint.
&gt; you never take the time to actually lay down an overall architecture. That's not really the fault of the language is it? Having using Python extensively over the past few years for small, medium and large projects, if you take the time to do a good design, the language really really helps. 
Cool can I ask what makes something REST 
My discussions comparing Java and Python usually end up with me wondering why Java does things the way it does. I mean, why force developers to waste their time implementing stupid boiler plate code? A lot of the big achievements in these other languages, Spring for instance, simply don't make any sense in Python. You don't need an entire framework to build a flexible, pluggable website. You just need Python, maybe with a nice library to translate URLs to code. One of the reasons why there are so many web frameworks in Python is that they are so easy to write. Oftentimes, it's easier to write your own that conforms to your particular project than to try and adapt someone else's to your project. When you have a ridiculously easy language like Python, it's cheaper to roll a framework, or just skip the framework altogether, and get to the core of your app. I like comparing what it takes to write a single line of output in languages. In python 3: print("Hello, world!") When you compare that to other languages, you begin to see the thing I am talking about.
Phew! that was lucky
the lesson here is pep8 ish things are a suggestion more for the std. lib and companies/teams/projects are free to deviate for their own reasons, and professional coders can adapt to variances in said coding standards. since guido is an emacs user, it was merely a configuration setting away. it's a valuable lesson.
For development? Just install tornado and the run the py file, it's dead simple. Deployment, however, is a different matter.
One can always mmap the file as well.
What is RESTful about this authentication? There is no such thing! Can we all please just stop playing bullshit bingo? It's annoying ...
A lot of pages, especially javascript, are served with gzip compression, so you're not that far off.
In order for a directory to be considered a module, it has to have an `__init__.py` file in it, even if that file is entirely empty. So put one of those in the "swampy" directory and it should work. (That's two underscores, "init", and two more underscores, in case it isn't quite clear in whatever font you see this in.)
Thanks, it looks like it does have an "init" file. It's pre packaged from the Think Python workbook. [Here](http://www.greenteapress.com/thinkpython/swampy/install.html) is where the package is from.
Not sure I'm going to trust the insights of someone whose website doesn't work right on my iPhone browser...
From what I can gather, returning and accepting JSON.
Not really. You can implement a RESTful API with other content types, XML is also used in many implementations. A RESTful API is one that follows the principles enumerated by Roy Fielding in his dissertation: http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm.
The reason `fileinput.FileInput()` overloads `sys.stdout` is that it supports handling multiple files; you get to read from multiple files and whenever you write to `sys.stdout` you are writing to the *current file*. So you can continuously rewrite multiple files and it'll all end up in the right place. Personally, I'd just as soon loop over the filenames and open them all in turn.
Unless you're using SimpleHTTPServer and that's enough, I'd still use a framework like Django. I do not want to parse http protocol by hand. I think it's still cheaper to use a web framework than roll your own, even in Python.
I looked through the Python files in your link. From my first glance, it appears that TurtleWorld.py can't find Gui.py. Both files should be in the same directory. How did you install the swampy package? And how is your project set up (ex. IDLE or Eclipse)?
My comment was tongue-in-cheek... Thank you for the information though, and I love your Flask tutorials. I actually did go through your [Designing a RESTful API with Python and Flask](http://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask) tutorial the other day in order to whip up a quick script. 
The problem with `mmap`ing a file you are rewriting is that that won't work if you are adding in data in the middle somewhere. An `mmap`ed file will not magically make room by shifting file contents up. Often, just rewriting the file is the better option.
I find Python's greatest strength is the breadth and quality of libraries for damn near everything you can think of. Like so you can make a toy script that does incredibly heavy stuff without losing its toy-like qualities. But you're not in a dead end if you do, in fact, need something more elaborate. Python has it all for serious software engineering should you need it. But the reverse is still an important quality: if a toy will do, there's no need to have anything more.
General advice: when getting into something new, leave your old patterns, habits and mindset at the door. Especially PHP's usual environment is so much different from those of other languages. It's alright when you want to dive right in but do a little research on best practices first.
`puts 'hello world'`
Article text doesn't flow to fit on my phone's screen (Chrome 31.0.1650.59). Every line extends off the right side. Can't read it, even though I'd like to do so.
Guessing it's an inane WordPress template. 
Would you mind posting your code on pastebin? 
The best mechanics often have badly running cars, because they just can't stop messing with them. Some great doctors have preventable health issues. I had a horrible responsive issue on my sight once that took me forever to get to because I was too busy making money developingother people's web properties.
I can but all that's in it is this: import swampy.TurtleWorld world = TutleWorld() bob = Turtle() print (bob) wait_for_user()
It's also not clear to me how authentication can ever be truly RESTful, since it requires state persistence. REST is state-less. 1. Architectural Styles and the Design of Network-based Software Architectures Written by Roy Fielding’s dissertation, in which he introduces the world to REST http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm 2. Act Three: The Maturity Heuristic (aka RMM) A model created by Leonard Richardson used to best design a RESTful API http://www.crummy.com/writing/speaking/2008-QCon/act3.html 3. Richardson Maturity Model (RMM) Another article that further revs the RMM http://martinfowler.com/articles/richardsonMaturityModel.html
A.) How often do you reverse strings? B.) Unicode usernames aren't worth the hassle on an English language site. It might make sense for a site with a lot of non-Roman alphabet using users, but even those users are used to email addresses being all Roman characters.
When did I say anything about reversing? (except in the list of operations that aren't supported well for non-normalized unicode in my previous comment) I'm with you that the operations are rare, and to do it well would require excessive computation, I do a lot of string comparisons for just key names, and those need to be fast, but a normalized comparison built into the str type could be really handy (something like s1.normalize() == s2.normalize() probably). A seemless version would likely need to store a normalized and non-normalized version. Anyway, non-normalized safe unicode comparisons would be really useful I think for english-language sites, the other operations (reverse, sub-string, localized upper/lower case) not so much. Actually fuzzy unicode comparisons where `'cafe' == 'café'` (for all versions of 'café'). I'd also like to see those sorts of things as methods on `str` and not tucked away inside the `unicodedata` module.
Less WoT, more studying.
First read the page several times until you have a good general understanding of what it's all about. Then start small by picking one aspect, anything, keyboard input, reading the map, changing player position *but* don't try to solve it immediately. Instead, play around with this small aspect in simple ways, how to read a keystroke, how to use different keystrokes to do different things, how to navigate a very simple map. Keep it simple, build up slowly. Do that for several different parts of the game and before you know it, magically, it will all gel in your mind and what looked big and complicated will start looking a whole lot simpler. Not magic really, just an approach that keeps things manageable. Good luck! 
&gt; I find Python's greatest strength is the breadth and quality of libraries for damn near everything you can think of. Like CPAN once used to.
I don't know web.py,sorry :( If you want to try Django anyway [this]( http://www.tangowithdjango.com/book/) is a great tutorial I forgot to mention.
But it's due tomorrow!!!
Should have started earlier then
I see a 5x5 grid that if done on a 400x400 window would have 80x80 pixel cells. If starting from top left the first center would be (40,40) and stepped along by 80. So check your x, y and center loop vars and calcs. Print them out and check if they match what you expect.
I don't know what the issue is exactly, but I doubt it has anything to do with the GIL. However, this sort of problem requires that people be able to reproduce the issue on their own machine to be able to debug it. You should create a minimal testcase. Remove everything but only what is absolutely essential to reproduce the problem. That should result in something a few lines long at most, hopefully not much more than "create a few threads and try to import PIL". Post that code along with the exact commands/setup you used with cx_Freeze. If I can reproduce the problem, I can probably figure out what's wrong, but being able to poke it with a stick is an essential requirement. 
Nice, but NEVER use time.sleep() ... instead use [Wait()](http://selenium-python.readthedocs.org/en/latest/waits.html)
Oo this looks like fun!
Wow, I feel for ya. I remember back to the time when I was in your shoes. It sucked. And you're getting this in Intro to CS for non-CS students. You've got a troll teacher. Anyway, I have no idea what kind of skill level you're at and I'm way too lazy to offer anything big but here's a few simple things: 1) I assume your teacher's going to want this as a script. So you'll need to create a text file with if __name__ == "__main__" -- run your code below that. 2) I was also way too lazy to read that full description but it looks like your program will need to take input. You might need sys.stdin.read(). 3) Good luck. And worst case, consider submitting a different python file and say you attached the wrong one by accident.
Hmm. The procedure by which you get an auth token is not RESTful, I can agree to that. It could probably be made RESTful with some effort, but in all honesty I can't see a benefit in doing that. I think it makes more sense to not consider token generation part of the RESTful API like I did in the article and instead just make it a pre-requisite to access the API. Would you consider that a better approach?
How do you play a Steam game with Python?
 def playgame(game): webbrowser.open('steam://rungameid/{}'.format(game['appid'])) When the steam client is installed with certain options, any "steam://something" url is intercepted by the client, so it can be used to send commands to it.
 echo 'hello, world'
3) is always a good last minute plan. Usually gives you another day or two.
I've wanted to write something similar, a script which chooses a random episode of futurama to watch. It would store the last 10 or 20 episodes and pick one that hasnt been watched recently. 
Shiiiit not when I was in college.
I'm not sure, but after reviewing the section of fielding's "connectors" section, I'm inclined to believe it would be. At minimum, Fielding's does acknowledge authentication can be a part of a URI request. &gt;A cache is able to determine the cacheability of a response because the interface is generic rather than specific to each resource. By default, the response to a retrieval request is cacheable and the responses to other requests are non-cacheable. If some form of user authentication is part of the request, or if the response indicates that it should not be shared, then the response is only cacheable by a non-shared cache. A component can override these defaults by including control data that marks the interaction as cacheable, non-cacheable or cacheable for only a limited time. All said, at some point I'll probably email Fieldings or Richardson to get their opinion on RESTful authentication, as the subject has had me scratching my head for some time now.
&gt; machinalis.com uses an invalid security certificate.
It does load fine in Firefox's reading mode. 
I am not I front if a computer to try something. Try splitting 2mill in 4 and parallelize the 4 threads?
Your use of the word 'sum' as a variable in Python overrides the built in Python 'sum' method. Doing so is a legal operation in Python, but can have unpredictable results. It is possible that you are seeing a side-effect. I was hoping to confirm or disprove this by having a look at the source code of math.sqrt, but apparently that is tricky... http://stackoverflow.com/questions/5476189/inspecting-pythons-math-functions
Link not working
You've misplaced a parenthesis on line 6 of one version or the other: Int(math.sqrt(I) + 1) --- what you have in Python Vs Int(math.sqrt(I)) + 1 ---- the python equivalent of what you have in C 
Both of them look pretty correct from a quick view, so I'm suprised that your C++ code is different. I will tell you that Python does not have tail-recursion like you are trying to use, so python is really filling up the stack and is otherwise *very* slow at function calls compared to C. If you switch your algorithm to check divisors in a loop rather than by recursion, it will be a lot faster. Another hint: if you have already found all primes less than **n**, then you only need to check **n** against those prime divisors. 
Wow. I had no idea that recursion sucks that much in Python. Thanks for the info!
I'm actually casting in C++, not doing whatever the equivalent is in Python. C++ casting is like (int)(/some double or float /) whereas the Python equivalent is int(/some double or float or character/). Thanks for pointing that out, but that part of the code can be considered synonymous.
You're probably right, and I would think this is the problem, but the messed up thing is my Python code is correct, unlike my C++ code. So if the 'sum' thing is the case, then I accidentally got the right answer in Python.
You might want to take a look at the [sieve of Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). You'll be needing it in later problems, unless you want to wait hours to get answers. [It's a lot faster](http://i.imgur.com/WiWN3XC.png). EDIT: [Here's the same algorithm in C++](http://i.imgur.com/jITvWcl.png)
Explain how, please.
That is really interesting. Your code also taught me quite a bit about Python style. Thanks for the information!
C#'s data annotations are a neat feature, and I wouldn't dismiss them out of hand. Of course you can rig up something in Python to do the same stuff at runtime, but it's always nice to have the language help you out. Go has a similar feature where you can make a struct then annotate individual fields with a string tag. A common use for that are the JSON and XML marshallers, which read the annotations to figure out how to map from the Go struct into the JSON or XML data you're (de)-serializing. [Example from SO](http://stackoverflow.com/questions/19885162/xml-and-json-tags-for-a-golang-struct): type Foo struct { Id int64 `xml:"id,attr" json:"id"` Version int16 `xml:"version,attr" json:"version"` } 
it may be better to use integer math (in both C++ and python) and also avoid recursion; like def isPrime(n, i): while i * i &lt;= n: if n % i == 0: return False i += 2 return True 
As with most things python, use it it when it makes things simpler, but switch once you know you need to do better.
It's not different though. In both programs I have 'sqrt(n) + 1' inside the int call/cast.
Depends on the system doesn't it? If you use doubles/long than the native word length is used in 64 bit systems. EDIT: Actually not sure what you are talking about. What do you mean?
**The difference is due to overflow.** The result is too big to hold in an `int`. Change `sum` and `tn` to have type `long long`, and you'll get the correct answer. Python hides this from you because when a number gets too big, Python automatically makes it a "bignum" which is slower but can be arbitrarily large.
I think Python is perfectly fine for "heavy" applications, excluding things that require heavy 3D processing (in which case C# and Java probably won't suffice either). You can write speed-critical parts in C if you need to.
&gt;I do not want to parse http protocol by hand. Honestly HTTP is simple enough that you can write a very simple HTTP server implementation (supporting `GET` and `POST`) in just a few lines of code, using a networking backend like gevent or Twisted.
Problem solved. God this is why C++ is so hard for me because I don't get all these nice reminders like Java (and things don't just work anyways like Python).
These two statements happen to be equivalent whether the casting happens before the addition or after. At least for positive I, anyway.
There's nothing wrong with overriding a built-in function name. It's not like it causes the modules that use that function to refer to your overridden value instead. The other modules will look up the global in their own namespace, not yours.
Which download have you selected http://www.pygame.org/download.shtml? Which Python did you install Pygame to and which one are you running? What have you tried exactly?
Oh ha, you're right. Took me a minute to realize why. (int) ( sqrt(n)+1 ) vs int( sqrt(n)+1 ) It is the same.
I would say 'heavy' would be anything where a larger code base is required, not so much a performance argument. 
Ah, so saying `sum = 5` does not *change* the *definition* of the built-in `sum` function. It only creates a new variable that happens to shadow the existing `sum` function within your module. Variables you create in your own module *cannot* change the `math` module. To see this, make a file called `data.py` that contains the following: def what_is_the_magic_number(): return sum([1, 3, 5, 7]) Then, we can mess around with it in the shell: &gt;&gt;&gt; import data &gt;&gt;&gt; data.what_is_the_magic_number() 16 &gt;&gt;&gt; sum = 35 &gt;&gt;&gt; data.what_is_the_magic_number() 16 &gt;&gt;&gt; sum() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'int' object is not callable Sure, you've messed up `sum()` within your own shell, but the variable you just made (the one that so happens to have the same name as a built-in function) doesn't hurt the `data.py` module because modules are kept separate. Driving this final point home, we could reach into `data`'s sum variable and force it to break: &gt;&gt;&gt; data.sum = 35 &gt;&gt;&gt; data.what_is_the_magic_number() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "data.py", line 2, in what_is_the_magic_number return sum([1, 3, 5, 7]) TypeError: 'int' object is not callable But the only reason why `data` broke was because we **forcibly and explicitly reached in** and broke it. This is called "lexical scoping" because variables are "scoped" or "contained" within the lexical files/functions that use them. It's a great thing to have in the language.
Completely true that Python is slower (especially with recursion), but the 50 or so problems that I tried were still solvable in seconds with it. It definitely took some research into math concepts that I don't have a full grasp on though, because Project Euler is much more focused on math than programming. 
This is the result of me running your code on [PyPy](http://pypy.org/) (which has a much faster bignum implementation, as you can see): &gt; $ pypy test_euler_10.py &gt;Answer: 142913828922 &gt;Time elapsed: 5.14646792412 seconds &gt; 54.8535320759 seconds under the limit. Nice!
Wow that's faster than my C++ program. I realize now that it's ridiculous to compare execution time when talking about my computer and an unknown computer.
For me, it comes down to static typing. Not having to declare types is great for quick/simple projects, but as things start growing and becoming more complex, I appreciate the safety imposed by a compiler. It is too easy to have unexplored code paths which will blow up because you were able to pass unexpected data into a function. Static typing is not a panacea, but it is a nice handicap.
A Gist on github works as well. 
Look at it from the other way: Python makes it painfully obvious when the algorithm should be improved. As I tried to do Euler problems, I found that most of the problems are best solved with some clever math instead of brute force programming. (Which is what's easier for me.)
Your `isPrime` function *is* in tail form, which most Lisps and ML-like languages handle quite efficiently. If you feel like recursion is more natural than the iterative algorithm, you might check out some functional languages :)
I love python, but that is the one thing I'm not fond of, python does too much of the work for you. You don't have to worry about the size of a number or string, or dividing an `int` by a `float`. It's an easy language to learn, but these things make it a. It harder to jump to another language.
Keep in mind that this suggestion here is much of the point of Project Euler -- the "direct" method will almost never work quickly, so the hard part is to come up with a "smart" algorithm that will solve the problem quickly. In this case, you should notice that calculating whether or not one number is prime or not, you need only divide by *other primes* less than sqrt(n), rather than every odd number; furthermore, if instead of *dividing* you merely eliminate all multiples of small primes, then a lot of arithmetic is cut out. The SoE takes advantage of these factoids to *significantly* speed things up (and you can always optimize that even more; [this](https://code.google.com/p/primesieve/) is currently the fastest known implementation, though there are [others](https://sites.google.com/site/bbuhrow/) that are pretty close). (Note the algorithm above only uses factoid 2, not factoid 1; a mildly more optimized sieve taking advantage of both is [this](http://pastebin.com/EXSwFYhq), if you'll let me toot my own horn.)
You might also want to try a generator: def eratosthenes(limit): is_prime = [False] * 2 + [True] * (limit - 1) for n in range(limit + 1): if is_prime[n]: yield n for i in range(n*n, limit+1, n): is_prime[i] = False It might be even faster than building the array. On my machine, this runs in less than a second: start = time.time() print sum(eratosthenes(limit = 2000000)) end = time.time() print '%lf seconds' % (end - start)
I've tried resetting my path and still no luck. I still get the error on Gui. It looks like it gets through the first part of the import and the errors out on line 10 of the TurtleWorld module. I just don't know enough about it to troubleshoot properly. I'll have to find someone who's done this on windows. Thanks though.
FWIW, here's my implementation in Python 2. It runs in &lt; 20 seconds: import datetime def isprime(n): '''check if integer n is a prime''' # range starts with 2 and only needs to go up the squareroot of n for x in xrange(2, int(n**0.5)+1): if n % x == 0: return False return True t0 = datetime.datetime.now() prime_total = 0 for the_number in xrange(1,2000000): if isprime(the_number): prime_total += the_number print prime_total print datetime.datetime.now() - t0
Very nice! Your site looks very comprehensive and the UI is great.
Ex game developer and author of a Pygame book here. Python isn't used that much outside of scripting for the games you might buy for your PC or console. It is used a lot in the tool chain though. If your goal is to learn game concepts; game loops, animation, AI etc. then you are in a good position learning with Python. You won't be bogged down fighting the compiler, and you get results much quicker. You can also produce perfectly decent games. If you do want to move in to the C/C++ world, then the skills you picked up working with Python are transferable. You won't have to re-learn anything. I also think it is a good idea to learn with higher level language as it teaches you to think in terms of data structures rather than bits and bytes.
Java: System.out.println(Integer.MAX_VALUE + 1); Output: -2147483648 Compiles and runs without any more warning than C++ would.
This looks like the best one here. Anything more you can save by using `xrange` instead of `range`?
Maybe this could help: http://www.mypy-lang.org/
If you're using an old version of Python then using xrange would give you a speed boost as long as limit is sufficiently small i.e. small enough to fit in a C long on your platform. Since Python 3.0 though xrange no longer exists and range has the old xrange behaviour without the restrictions on the limit, acting like a generator when iterated through.
See this link with the discussion of differenct approaches. http://www.daniweb.com/software-development/python/code/217082/eratosthenes-sieve The most efficient way is using numpy with 12757.87 microseconds for 1 million prime. The pure python version is tenfold slower.
Would you prefer that python doesn't work as well, therefore making it easier to jump to another language??
You can speed this up if you use the sieving method mentioned above. That way you don't have to rediscover all those primes. It's good that you're only going up to sqrt(n), but if you do that and mark off the multiples, then you can just count off the remaining numbers afterward.
pastebin.com sucks. The IRC channel #python even has a bot that repastes everything from users who post links to this one. Use another one please.
You are right, I could make it better, but I think I started with the isprime() and built the rest around it, and since it ran in under a minute I didn't optimize it further. Thanks for your suggestion though! +/u/bitcointip $1
If you are interested in syntax, just read the user manual for the language. There's even a tutorial on the main website. Then look at some source code for some of the main modules of python to get an idea what code should look like in Python. Keep in mind that Python encourages programming the "Pythonic way" which is designed to be highly readable and reasonably explicit. This may be different from how you have programmed in other languages. Luckily, a Google search or several will take you everywhere you need to go. 
Thank you, I will try that.
 long daysToMilliseconds(int days) { return days * 1000 * 60 * 60 * 24; } It gets really funny at about two months. EDIT: `daysToMilliseconds`, damn it!
Python the hard way is a very good online book.
&gt;General advice: when getting into something new, leave your old patterns, habits and mindset at the door. tremendously useful advice. i went from python to rails for a job and struggled a lot until I was able to turn off the python parts of my brain and jump in. 
I actually wrote something kinda like this a while ago thats a bit more general, a systray rss reader. https://github.com/syamajala/rsstray
Why? You learn basic programming concepts and how to write clean, clear code. Oh, the biggest number I need is 1,000,000. I'll pick x. It's really not more complicated than that.
if you are using apache, then use mod_wsgi not mod_python. most python web frameworks are designed to work with mod_wsgi. However, you don't need apache for development, thats more of a deployment thing and is one of several options. most web frameworks come with a way to serve via http for development purposes. 
Yes, your general advice is good and that's exactly what I'm looking for here (and in my researches). Any suggestion of links to read? Thank you very much :)
An ideal computer language would be one where you could directly translate ideas from math/physics/engineering/etc. into computer code; it should just "get out of the way" i.e. it should allow you to ignore the underlying computer architecture (which, in this case, originally gave rise to this limitation for the size of an int). At the other extreme is machine code; your complaint about Python amounts to saying that it is too close to an ideal language and not close enough to machine code. I respectfully disagree with that sentiment.
I like using sets, they have O[1] performance for insertion, removal, and searching, which are exactly the operations we need for this type of problem. def eratosthenes(limit): candidates = set(range(2, limit + 1)) for n in range(2, limit + 1): if n in candidates: yield n for multiple in range(n, limit+1, n): if multiple in candidates: candidates.remove(multiple) Edit: I managed to shave about 30% off the running time by using set differences instead of removing one multiple at a time. That way you aren't wasting time testing to see if each multiple has already been removed. multiples = set(range(n, limit + 1, n)) candidates -= multiples I love sets. They should be used more. 
Same here, I did one for jenkins(and reddit, but that's still in progress)! Switched to osx since I got a macbook. :) For the ones interested, it's here: https://github.com/thijsdezoete/jenkinz
You can set compiler flags to make the compiler give you warnings, like with Java. Also, Java does not give you warnings, the Eclipse IDE does. You can get a C++ IDE too, but I don't think it's necessary.. for me, I just have `clang` (compiler) warnings integrated into my text editor (vim).
The sidebar here is usually a good place to look through. Especially [*The Hitchhiker’s Guide to Python!*](http://docs.python-guide.org/en/latest/) (scroll down to find a *Scenario Guide* on *Web Apllication*).
Try Canopy from Enthought. 
A few months ago, I converted from Matlab to Python. I use Pycharm as my text editor and IPython as my shell. It doesn't look like Matlab, but once you get used to it, I think it's actually better than Matlab. Just set up autoreload in your IPython config and learn how to use %debug, and you'll have the two most useful things from the Matlab IDE. IPython notebook is really nice too.
Sublime Text is what I use, it's a general purpose editor (my other projects and config files need love too!) that looks great and has a large ecosystem of plugins to enhance it's already awesome features. Combine that with a good command line and you're set. If you really need debugging, learn to use pdb, it works in every editor so your coworkers and collaborators can benefit from it too.
Hi, hahdawg, I'm converting to Python as well! I just wanted something to ease the pain of transition. Thank You! 
&gt; to completely secure Of course that is impossible. Still, most things are simply not worth the effort.
&gt; was merely a configuration setting away You mean the whitespaces? Certainly you don't mean the obvious-docstrings. &gt; free to deviate for their own reasons ... assuming there are reasons aside from randomness. The example I'd rather put up here is Twisted: it's very much non-PEP8 but there're historical reasons for that (it simply was started before PEP8). Still, it's weird to see code committed by Guido with deviations from PEP8 with no apparent reason. ... Also, I'm a emacs user myself. 
If you're learning, don't use an IDE. After you're pretty damn comfortable, PyCharm is great for helping you focus on coding.
btw. in Java int overflow is defined, while in C/C++ it is not..
You can also start 'multiples' at n*n instead of n because all lower multiples have been removed. For me it shaves off another 30%. multiples = set(range(n*n, limit + 1, n)) candidates -= multiples also, we can skip every even number which shaves off another 20%: if limit &gt;= 2: yield 2 candidates = set(range(3, limit + 1, 2)) for n in range(3, limit + 1, 2): if n in candidates: yield n multiples = set(range(n*n, limit + 1, n)) candidates -= multiples Still slower than your parent though, due to the garbage collection as the set shrinks I would guess.
I was on the same boat. Spyder is what came closer to what I'm used to do in MATLAB. IPython Notebook is nice and fits the type of workflow you get in Matlab with editing a cell mode script on the fly and running cells separately. However, a major nuisance for me is that when you need to make a change to some support function you wrote you need to restart the notebook so it sees the changes. I dunno if there is another way to do this but I couldn't find it at the time and nowadays I'm kind of back to using MATLAB. 
I don't think he means to say "Python should be more broken," but rather that it would be nice for Python to indicate some of the 'magic' it performs behind the scenes so that, when moving to another language without said magic, the transition isn't as jarring. I don't think it's deserving of any downvotes, since it is just an idea; but certainly the concepts he describes can be learned about via external resources, and don't necessarily need to bog down Python itself.
Python is not verbose like java. You don't *need* a python IDE at all. Learn a versatile true editor like vim or emacs and you'll never want an IDE again except maybe for java. If you're dead set on an IDE, download the free version of pycharm and give it a spin. But, it's just going to over complicate things of you are still learning. 
you can just re-run the cell you modified with ctrl+enter or whatever
Thank you for the very thorough answer, that has been really helpful ;) Regarding IDEs, I have used Eclipse a lot, but if there are even better alternatives for Python I have no problems switching to a different one (preferably with a dark background theme like VS has and which there are a few of for eclipse since I seem to be more productive with these).
Yeah. Comcast started metering our bandwidth last month. When you approach a certain percent, they inject some HTML, JS and CSS into whatever pages you visit to create an extremely annoying modal. On top of that, this injection seems to be fucking with my Roku because I'm getting a bunch of errors and buffering issues they weren't happening before. Just makes you realize that someone, somewhere will find a way to fuck with your code.
Agreed. Look at a manual or perhaps some example code if you don't like manuals.
The point of MATLAB is not to fill in boilerplate syntax for you
I also learnt Python after using C/C++ and Java. I strongly recommend Dive into Python 3. It's the best and quickest way to get start with Python. Also after knowing how to use Python 3, don't forget to spend a little time to understand the difference between Python 2 and 3. In addition, you should use iPython, it will save you a lot of time. 
A response from Wing below. In short, the answer is "No, you can't debug properly with matplotlib figures showing" but they think, from what I can tell, that's unavoidable and OK. I get to differ. If you can't successful step through your program without it hanging or closing the visuals you have a problem. From what I can tell, Matlabplotlib is the most widely used package for science/engineering plots in Python (is there even another?) Even the simple example code below shows a problem with the debug eval method. The scatter calls are interspersed using variables that update that they then use. To execute them once via eval in debug probe and again by pressing continue (to go to the next breakpoint etc) would change the values twice. You would have to select statements around the updates etc. That's really not practical. Finally, I'd like to point out that often its the figure displays that help a programmer home in on bugs. figure; x=x+1 scatter(x,y) y=y+2 scatter(x,y) ===response=== Wing's debugger is a bit different than Matlab in that it's a general purpose debugger and when it stops at a breakpoint or exception, it tries to stop _all_ activity in the process being debugged including the code that updates the window. This is because the debugger might be used for finding and fixing bugs in the window update code or in any other part of the program. As mentioned in the Working in the Debugger section of http://www.wingware.com/doc/howtos/matplotlib you might try setting a breakpoint on the show() and then work in the Debug Probe. You may be better off working interactively in the Python Shell because that does stay responsive and using the debugger when all the commands to set up a plot are in a file that can be run w/o further input. 
Something reasonably similar to this: for x in range(10): circle = Circle(Point(100, 100 + (x * 10)), 100 - (x * 5)) circle.setOutline('Red') circle.draw(win) Good luck on your homework.
&gt; ... assuming there are reasons aside from randomness. i'm going to assume the reason was to comply with the stds of the employer(google)/project(appengine) at the time of writing. 
That's not what I meant. What I mean is when I need to write a python function (in a .py file) to do some specific computation and import it to my notebook (when it is impractical to embed it). If for some reason I need to modify the function re-importing it in the notebook won't do anything, it will still run the old version when called. When I looked for solutions to this problem a while back there didn't seem to be any. People just said restart the notebook or restart the kernel but maybe that has changed.
... I recommended an IDE even if OP doesn't want to use a true editor...
This plot has a simple closed form representation in polar coordinates. r = Sin(theta) * Floor(theta/(2*pi)) Plotting it from theta = 0 to 2pi*n, will give you n loops.
Try and study python's object model to learn how it works. If you try to write python like java, it will likely be extremely overcomplicated and far more complex than it needs to be. Mostly because java can only write in the OO paradigm, while python can comfortably write in imperative, OO or some functional and enjoys a lot of its practicality from being able to be flexible with such. Dive into python 3 should be great. The biggest difference between python 2 and 3 would probably be strings being unicode-native in 3, byte-native in 2. Other than a few api changes otherwise, they are otherwise practically the same language, hardly something you need to worry about.
Have you tried %load_ext autoreload followed by %autoreload? to see how to use it? Sounds like that should do the trick.
I really liked codeacademy when learning python. The interactivity made sure I didn't miss a step. You seem to be a lot more advanced at programming so some lessons may waste your time, but you can skip the lessons you find not beneficial at any time.
Oh yeah, duh. I have no idea what I was thinking.
Hmm I'm using Eclipse for both C++ and Java. I must have the C++ perspective set up differently or something.
Python the hard way is written for complete beginners to programming.
Manually run a cell that reloads your module (not function): from foo import bar reload(bar) from foo.bar import myfunc myfunc(data) That usually works. The trouble is that `isinstance` won't work correctly if not everything is reloaded, because the type (class) objects are different if they were created before vs after the reload.
You should get the python indie bundle cause after you get a ground in python it will be worth it. its on cyber monday sale too http://www.pythonindiebundle.com/
I have ported it for reddit /r/python. Just check it out here https://github.com/yasoob/reddittray and tell me how it is.
Are... are you using imgur to post code?
thanks to everybody for your answers!!!! By the way I think an IDE will be useful for me because of some great matlab feature: for example being able to see and reach the variables on the "workspace"
Well technically an AssertionError is in the exception class hierarchy. So I guess my response is isn't that what I'm doing. I think historically assertions were used to make sure invariants were intact.
how many time do I have?
Why does this get downvoted? It's not only written in Python and a great piece to study but also very clean and minimalistic.
There was a time where I had no knowledge of decorators and was entirely content without them. I don't know how I survived during that time, but man do they make things easier once you grasp the concept, especially in web apps.
btw you're welcome to hop over to /r/learnpython!
Very interesting. I know there are a few other projects which go for the same sort of idea of providing type information. However, I'll admit to being conservative in my adoption of technologies and this is too bleeding-edge for my tastes. If it had industry support, then you would have my attention.
True, but the issue is that if you use `python -OO` asserts (among other things) will be removed.
You posted a pic of the code instead of text so people can't test run it themselves? You dingleberry.
No, thank you ; )
I'm wondering which are the authors that aren't individuals? Which are their sales?
I have not coded a game in pygame yet, but what you could do is give each enemy a rectangle as attribute which has a function that checks for collision (like: return ((bullet.x &gt; rectangle.left &amp;&amp; bullet.x &lt; rectangle.right) &amp;&amp; (bullet.y &gt; rectangle.top &amp;&amp; bullet.y &lt; rectangle.bottom))) and then do something like for enemy in enemies: if enemy.rectangle.collides(bullet): enemy.loseHealth or something like that edit: imagine correct indentation and stuff
This belongs in /r/learnpython You need `else:` clauses at the end of your if/elif statements, otherwise values that don't match anything drop through and don't get handled.
Thanks for the tip!
pastie.org, dpaste.org, ideone.com
I post my classes online if you need some extra material the first powerpoint set has a slide on all the reference material that i consider worth reading: http://codebytheneedle.com
There are some libraries that still don't support it. Off the top of my head, Twisted and gevent (networking), and wxPython (GUI framework) are some of the biggest things still missing, though there are alternatives for each that do work with Python 3.
Two scoops authors gives free copies of there book already to students and the authors give a lot of free stuff already to community including classes. Check their bio. Not sure why the hate on them. 
I don't think it's a rip off... just small time authors who didn't think it through. 
I had to use winpdb. it was ok, but not great. PTVS is better
Problemss with unicode
Cool, if you know what a variable is use one and your existing code to perform addition. NUMBER ONE&gt;40 NUMBER TWO&gt;2 42
Thank you. That was the best explanation/walk though I've ever read.
thanks, I will definately look into it :)
Wow. As one of the authors and promotors, I'm not sure what to say. I am shocked and terrible distressed. And furious that this is sitting at the top when it's clear you didn't actually bother to read our listing. There are THREE of us. Me, Audrey Roy, and Matt Harrison. We didn't intend to rip off anyone. We didn't even connect it with Humble Bundle until I saw this comment. For what it's worth, this is what we give to the community/charity: 1. We give free copies of the Two Scoops of Django to students and those in need. That number exceeded 5000 a couple months ago. 2. Every cent or dime we've ever made from teaching courses and conferences (since 2009) has been given either to PyLadies or the PSF. In most cases, as in EuroPython 2013, I didn't accept any fee for teaching a tutorial there. 3. I've never accepted nor will I accept help in getting to conferences and events. 4. I've literally paid out of pocket to help a number of people get to conferences and tutorials. I've bought plane, bus, and conference tickets. I've bought people new laptops. I've always done so anonymously, but if you want me to, I'll try to get the people I helped to post commentary here. 5. There a lot more. A whole lot more but I'm too upset to recount it all. Matt does more of his own thing, as does Audrey. What's really sad is that proceeds from Two Scoops of Django and this bundle are not enough to pay the bills. Meaning I continue to consult and often am forced to ignore the open source projects to which I would love to contribute. In fact, as I sit here and write this at 3:30 PM PST on November 29th, 2013, the Python Indie Bundle has sold a whopping 10 copies. And here, on Reddit, I suddenly find myself the bad guy. At the end of everything, all it seems that I've gained is a rant on Reddit. I give up. This isn't worth the time I take away from stuff that makes real money. Right now I'm very, very tempted to quit helping people. I'm thinking of stopping the giving of Two Scoops of Django to students and unemployed. Stop teaching and stop giving donations. Just work as a consultant and live my life outside of everything community related. Fuck you, I'm done. 
It's book collection written by a bunch of independent Python authors, most of whom donate sizable chunks of their time to open source. It's certainly not in bad taste for them to do this, though technically it does [seem that trademark is bracketed](http://tess2.uspto.gov/bin/showfield?f=doc&amp;state=4806:r6d7ak.2.1) to e-books as well so it might be potentially illegal ( just FYI to the authors ).
Nice. What kind of classes are that? Is it something you learned in school or somewhere else? I started programming at your age too. I remember being intimidated by a lot of things about it back then. Of course, I didn't know Python back then, or maybe it would have been less scary. Anyway, good luck with your classes! :)
Dear "AdvisedWang," your scorn is misdirected here. These books are DRM-free and, at least with Two Scoops, you can write in and request a free copy if you're in need. Authors make virtually no money off their books and these folks do a ton of good for the greater python community.
&lt;3 from the community
Could you please town down the rhetoric? These people aren't trying to rip anyone off. These are well-known people in the python/djsngo community who have helped in many ways. Your accusatory tone in this case is completely misguided.
i totally agree. also information should be free. they are just making money off of people. im good i got all the books in the bundle from torrents. buying ebooks is stupid.
You are making the world a worse place. I want to live in a world where authors can make a living (regardless of whether their work is available electronically or on dead trees) 
Those are some awfully bold claims you're making — in particular, “using HIB's good name” would require a high chance of confusion and it's not like this copies the HIB name or logo, design, etc. or that they should own a generic term like "indie bundle”. I'll also note that the "good name" part is also conflicted – many people in the Mac community were disappointed by the way HIB pushed for a business model which didn't encourage sustainable pricing for developers. Trying to paint this false dichotomy and introducing concerns like DRM which don't appear to be an issue but muddy the waters make you seem like you're more interested in causing bad PR rather than doing anything productive.
All of the authors in this group have offered a no price option to get their books. Disclaimer - Author
This is not our intention. We thought it would be a nice Black Friday/Cyber Monday package. All of us are pretty involved in the Python community (and other communities that we don't normally toot our horns about) and aren't trying to rip off anyone. Personally, my financial situation would be better if I hadn't given PyCon tutorials. I could have made a lot money consulting (or sleeping more) during that time. I imagine Danny and Audrey would be better off financially if they used their community time for consulting. None of us are full-time writers and there is probably a reason for that. We are pretty liberal with our open source involvement as well. There really is no malice in our intent other than to offer a deal to people who may be interested in well packaged information.
In Django, a common pattern I've found is that I'll have url patterns that tell me how to look up a particular object. I might have a whole bunch of views underneath the same root pattern that let me do different things with the object. I commonly use decorators to take the string from the url pattern, resolve the referenced object, and provide that as an argument to the view so that every view doesn't have to explicitly handle the lookup. Similarly, if I'm developing something with a bunch of views that will all return Json, I might have a decorator that deserializes an object and sets up the HttpResponse object. This can also be useful for helping with error handling. In a different vein, for load analysis I often use decorators that log how long it took for the function to execute. 
As an experienced programmer with OOP and recently learning FP -- I recently picked up Python really quickly using codeacademy. Yes it might seem it's geared for beginners, but there is so much repetition and having to type out the exercises -- it drilled the syntax and idioms into my head pretty well. I went from never writing a line of Python code to very quickly writing a few real world programs I needed for work. Once you know the syntax you can pickup 'pythonic' APIs really quickly to get stuff done. After codeacademy and some real world apps, I found [Hitchhikers Guide to Python](http://docs.python-guide.org/en/latest/) a great resource to take it to the next level. 
This is not about learning Python 3, I already grasp most of the differences, but rather how to decide if Python 3 is the right tool to use for a given project or if I need to stick around with Python 2 for a while longer.
thank you :) By the way, I've found the python naming conventions increasingly annoying since I'm typing on a qwertz-keyboard and the underscore is pretty annoying to type regularly. I'd just switch to mixedCase or CamelCase instead, but since my code is likely being looked at or changed by someone else in the not-so-near future I feel like this might become pretty annoying for them. Do you have any tips on how to deal with it more easily?
Bump for "teaches you to think in terms of data structures rather than bits and bytes."
For most of what you'd use Twisted or Gevent you could use Tornado or asyncio. For most of wxPython (which is ugly anyway) you could use pyside and use a nicer framework. ** If I sound bashy is because I'm drunk. Love you man. 
I was able to reproduce the problem, although it manifested somewhat differently. It's definitely a race condition, because it only occurred about half of the time that I ran the program. I suspect this is the reason that it triggers for you only with 3 or more threads is more proof of that -- the issue is always there, it only just triggers sometimes. And it seems to be related to the fact that you're importing modules at the function level. Why on earth are you doing that? If you change test.py to this: from threading import Thread from module import test_module class TestThread(Thread): def run(self): test_module.initialise() num_threads = 3 for i in range(0, num_threads): TestThread().start() And change test_module.py to this: from PIL import ImageGrab def initialise(): print("initialised") Then it always works, because you're not trying to import the same module from multiple threads at the same time. There should be a lock to prevent that, but apparently it's not always effective. You really don't want to be importing at function scope. 
What version of Python is this? I'm getting an error before the form ever loads.
Please, *please* use generator expressions instead of list comprehensions. He used `sum([1 for e in target_list if predicate(e)])` in his first code example, but if target_list were to be particularly large, it would needlessly create a huge new list of `1`s. Instead, use a generator expression: `sum(1 for e in target_list if predicate(e))` -- the exact same things, just without the `[]`.
&gt; I'll remove my comment. do it
A few nitpicks: * `sum([1 for e in target_list if predicate(e)])` can be written a bit shorter as a generator expression: `sum(1 for e in target_list if predicate(e))` * the docstring for `surround_with` is incomplete. * In the text you describe the search list as `['Python', 'Jeff']`, but in the code you only write `['Jeff']`. * `...is the tax rate expressed as a float, like "7"`, should be: `... like "7.0"` * In the function `price_with_tax`, nothing is done with `tax_rate_percentage` and the variable `tax` is nowhere defined.
how/where ? I don't need the django book
I don't need the django one, anyone wants to chip in ?
looks like defadvice for lisp
i've always been a heavy OO guy and went to a meetup on functional programming in F#. the interactive mode in visual studio was great. a few weeks later i found out about ipython and i was AMAZED. ipython is incredible.
Tulip is also a viable replacement for gevent isn't it?
Tulip is the proof of concept for asyncio. Asyncio is the standard library module for asynchronous I/O. It features the standardized event loop and the coroutine-based primitives.
It uses Vim's `locationlist` and puts red markers at each line where there is an error. When I got to that line, Vim's command line displays the error message. The plugin [YouCompleteMe](https://github.com/Valloric/YouCompleteMe) achieves this for me. It also gives me semantic code completion in my C and C++ projects, and has support for code completion in other languages as well.
Yeah, I'm not sure, but there's tons of info on Google about that. If I were you, I'd switch to a more powerful text editor though.. not necessarily Vim, but one that is more powerful than Eclipse's editor.
You would write it pretty similar, but you use ** for exponents; and make sure you put in a * (multiplication) between variables and '(', because even though they're implied, the computer doesn't know that.
I dare you to point me one example that qualifies as "nice" here: http://www.wxwidgets.org/about/screensh.htm
Yeah, it's hard to believe, but wx looks and feels like shit on OS X. How they manage to do it with "native" widgets is beyond me, but it does. Usually, buttons and textboxes are fine, it's when tables and outlines are involved that you can really notice the crapiness of the look and feel.
Wow, OK. I am not a OS X user, so I've never really seen it. I'm surprised to read it, though. Do you have an example screenshot you could point to? It is supposed to be the OS X native table, but maybe there is some issue with Cocoa vs. Carbon. If you have a screenshot, I'd love to see it.
It does, but it's been under development for quite some time, and I've not heard any rumblings about a release coming soon. Given that GUI toolkits are complex, important, and hard to replace in existing code, I would be reluctant to base new code on wxPython at the moment. Qt, Gtk and Tkinter all have official, released support for Python 3.
Cool. Thanks for the linkback.
I always forget to add the functools.wraps(). TY for the nice guide.
Nltk
Assuming the question is directed at me. I wanted to avoid the non-integer calculation and the subsequent type conversion of int(math.sqrt()) since that would save a bit of time. Of course if n is large the changeover from int to bignum happens and that would slow down the whole thing.
Why not just go to r/netsec?
login_required is probably the most common example. I use things like admin_required, load_db_sessions to prepare for a request that's going to require access to a DB, I have a function_logger decorator that logs the input to a function and the output, which makes debugging things a good bit easier. Access control is definitely the most common use case for web apps, but they're useful in a lot of different scenarios. Anytime you see yourself starting a few functions with the same few lines, that's a signal that a decorator might be of use.
I believe at this stage , it's just an add on for people doing projects in python anyway. If that's the case , just adding types to functions signatures, and running this gives you some extra assurances, so there's nothing to lose. But it's not ready to replace static languages yet. 
Useful, thanks.
[ReInteract](http://www.reinteract.org/) is also worth mentioning. It's neither an IDE nor similar to matlab, but its good for experimenting with python (esp. numpy/scipy/sympy) and imo better than ipython if you prefer a worksheet based approach over a shell based approach. (either have its strengths, so I use both)
Are you gonna use it on production servers? Do you expect to use it on production servers or for business? Then stick with python2. Sadly python3 adoption is quite slow when you have machines runnning python 2.6 everywhere :(
Ok... Fine... I didn't expect the wxWidgetish Inquisition... I know how wxWidgets work. And every single UI made with it handles to consistently look ugly in every platform. I like qt better. And at the end of it it reduces to taste and preference so it's a dead end discussion...
Decide by looking up libraries you need for the project at https://python3wos.appspot.com/ If all of them are green, you are good to go for Python3! If any are red, and there aren't any replacements available, you may need to stay on Python2.
I find geany is perfect for anything. I used it when starting with python. I now use pycharm.
Awesome deal, I've frequently seen Two Scoops recommended for Django learning, so I picked up the bundle to get started with python. Thanks pydanny and co.!
Try http://www.macstories.net/stories/automating-ios-how-pythonista-changed-my-workflow/
No problem :)
&gt;...is the tax rate expressed as a float, like "7", should be: ... like "7.0" It should be ... is the tax rate expressed as an int, like "7" He's multiplying by .01, so 7 becomes .07 or 7%. No need to use 7.0
It's been quite a while since I've played with wx and when I try to find an app build with wxwidgets that runs on OS X. They all seem to be Windows-only (on which wx looks fine). The wx Demo app on http://www.wxwidgets.org/downloads/demos.htm is PowerPC only and doesn't run on a modern Mac. I found [this app](http://www.seventhstring.com/xscribe/screenshots.html) but it's just another example of a shitty UI on OS X. 
six
You will miss this: Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeDecodeError: 'ascii' codec can't decode byte 0xf0 in position 0: ordinal not in range(128)
I think it comes down to this question. Are there any libraries that you think you will use in your project and are they supported in Py3? If yes use 3, else use 2.
Nobody expects--- well, you know the rest. (I guess I'm "defending" wx because I've invested time in it and have tried to make non-ugly GUIs) I develop and care a lot about ugliness of UI--do you have a screenshot of a qt app (or a gallery) that you could point me to that you think are not ugly and are actually "nice". Thanks! 
Also for sets each operation takes a long as the hashing algorithm used. Given that the list's functions will be faster than the set's function you are better off using the list. I personally love using sets, but this may not be the time to do so. A fun use of sets is finding the shortest path between two nodes, lets say they number of nodes is in the billions so [Floyd-Warshel](http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm) won't work
`g++ -Wall`
Cool stuff and all ***but ...*** 1. This is not for "Linux". It's pretty much only for Unity which is only available for a handful of distros and clearly not everybody's first choice. 1. `sudo pip install reddittray` ← Nope! Don't ever do this! I don't know how many times I've said this already: PyPI is not a trustworthy source. You should not give root permissions to stuff that comes from there. Use `pip install --user &lt;package&gt;` instead.
http://nltk.org/nltk3-alpha/: &gt; NLTK 3.0 is the first version of NLTK to support Python 3.
+1 great answer :) I was just about the reply the same.
Had I a need to start a new project today that wouldn't be bound by backwards-compatibility needs (such as working with proprietary Python 2-only libraries), I'd *definitely* go with Python 3.
I was pretty excited about that a while ago, but too bad it seems to be dead :(
The problem with using Tornado as a static file server is that it reads the entire file into memory when it's writing it. Now, you won't necessarily run into the problem in most cases. However, if you try to send, say, a gigabyte-sized file... that's a problem. There's no sharing either, so the moment you get a second request your memory use goes up again. Of course, SimpleHTTPServer has the same problem, so it's not really that big of a reason to avoid Tornado. Just thought I'd mention it. When my friend and I were working on our own networking library and HTTP server (the [file sending, specifically](http://docs.pantspowered.org/en/latest/web/fileserver.html)), we solved this problem by adding support for file objects to the output buffer, to be sent with the sendfile system call. It works pretty good. Of course, I still wouldn't use it in production for static files when existing servers in lower level languages work so much better, but at least it doesn't devour your memory.
The [google goup](https://groups.google.com/forum/#!forum/reinteract) still seams to be active: There is a slow discussion going on there on how to move to python 3. So maybe it will raise from the dead.. ;) Interestingly the last release was 0.5.10, but no one bothered updating the webpage which still announces the release of 0.5.9 as last new item..
First I've heard of Canopy. Just tried it out and it seems like an interesting project. The editor is decent, but rather basic and I wish it didn't require installing an entire new Python distribution. Personally I still prefer Editra.
It's about Django but... https://www.youtube.com/watch?v=i6Fr65PFqfk
I use the decorator module. It's distributed with IPython, which I always have installed anyway. from IPython.external.decorator import decorator @decorator def my_decorator(): ...
It's not something that I feel could be fixed in SimpleTornadoServer. Tornado's handling of outgoing data through ``web`` just doesn't support what you need. See [tornado/web.py#1933](https://github.com/facebook/tornado/blob/master/tornado/web.py#L1933) to start. In the get() handler for StaticFileHandler, it exhausts the generator that reads chunks of the file straight away, writing every chunk and effectively putting them in a list to be written later [up here](https://github.com/facebook/tornado/blob/master/tornado/web.py#L580). The generator [get_content()](https://github.com/facebook/tornado/blob/master/tornado/web.py#L2058) returns 64 KiB chunks, for the record. Later on, when it's actually *writing* the data, what does it do? It joins the entire list at once and calls write on the underlying request with that. That's in [flush()](https://github.com/facebook/tornado/blob/master/tornado/web.py#L756). It might as well have not chunked it up in the first place, really, as it's not going to actually *use* those chunks. --- If you're interested in how I've done it in pants.web.fileserver, the main implementation is in the [pants.http.server.HTTPRequest.send_file](http://docs.pantspowered.org/en/latest/web/http_server.html#pants.http.server.HTTPRequest.send_file) ([source](https://github.com/ecdavis/pants/blob/master/pants/http/server.py#L705)) method. It's still a bit rusty, but it handles the basic headers you'd want for that sort of thing, and after writing the headers it calls the [pants.stream.Stream.write_file](http://docs.pantspowered.org/en/latest/core/stream.html#pants.stream.Stream.write_file) ([source](https://github.com/ecdavis/pants/blob/master/pants/stream.py#L661)) method to insert the file into the output buffer. The buffer is handled [here](https://github.com/ecdavis/pants/blob/master/pants/stream.py#L1026) and [here](https://github.com/ecdavis/pants/blob/master/pants/stream.py#L1067).
Very nice. I was trying to use the Jack library (its API is similar to PortAudio's) from Python via CFFI, but couldn't figure how to create the C callback from Python. Reading your code I learned about `ffi.callback()`. Not sure how I missed that from the CFFI docs (it's there, of course)... Thanks for sharing your code!
thanks for the second point !
cuz it uses tornado. :) honestly I don't get it either. I don't see what advantage it has over other existing solutions.
Yup, simplicity was one of my goals too. That's why I haven't added too many features to it, though what is already there is useful. YAGNI ... 
Range requests aren't really a solution to the problem of buffering on the server. What a range request does is minimize the amount of data you have to transmit to a client, particularly when the initial request has failed to send the entire file. A client doesn't have to request a range, and it doesn't have to request a *small* range, so it's still quite possible for your server memory to be exhausted if you're not careful. With our output buffer's handling of file objects, we just keep a reference to the file around, and *only* read as much data from it as can be sent at that specific time, minimizing memory use. We even use ``sendfile`` whenever possible to keep the reading and writing in kernel space instead of user space for efficiency.
This one with the BDFL. It covers Python2 vs. Python3, the GIL, PyPy, Android &amp; Python, stdlib fixation, other interesting stuff. http://www.youtube.com/watch?v=EBRMq2Ioxsc
pydanny, don't let some internet troll get you this upset. For everyone else, these are great books and if you don't already have them the bundle is a great price.
got a link to the source?
I went over the important details in one of my [other posts](http://www.reddit.com/r/Python/comments/1rs3t7/better_simplehttpserver_using_tornado/cdqc2c6). You can also see the sendfile code [over here](https://github.com/ecdavis/pants/blob/master/pants/util/sendfile.py).
I have a folder of talks that I like, here are some with my comments: * [idiomatic python](http://www.youtube.com/watch?v=OSGv2VnC0go): talk by a core dev about some things that should be done one kind of way over the other. Helps get "into the pythonic mindset" of sorts. Good if you want to learn a bit more about what "good" python should look or at least act like. * [understanding the python GIL](http://www.youtube.com/watch?v=Obt-vMVdM8s): If you are going to do multi-threading (even for I/O!) this is a talk that you should watch, some details about the GIL make even I/O bound stuff take longer than it should. Note that these are basically all corner cases and if you know about them it tends to be easy to work around it. I found this when I (similar to the first ~5 minutes) had code running faster on a single core than my quad core! * [don't do this](http://www.youtube.com/watch?v=H2yfXnUb1S4): Python has some edges/corners that are... unpleasant if abused. However each one of them exists for a reason, (eg AST parsing, one of the big ones he plays with) a nice talk to learn about the ways in which python can be dynamically changed in weird ways. Watched this after wanting to make it possible to do `import http://secure_internal_site.example.local/py/foo.py as foo` (bad idea, friend decided to MITM me on this to show why...)
thank ya
Two of my favorite: * [Guido's keynote](https://www.youtube.com/watch?v=EBRMq2Ioxsc) from PyCon 2012 * Alex Martelli's [Good Enough is Good Enough](http://pyvideo.org/video/1738/good-enough-is-good-enough) talk from PyCon 2013 They are both general in nature. It's hard to choose a "must-watch" video on any particular subject--you really need to narrow it down first.
There are some videos from the Pycon US this year which I think are very useful, as they cover things which are in the stdlib and are framework-independent (mostly): * Logging: http://pyvideo.org/video/1737/become-a-logging-expert-in-30-minutes * Classes: http://pyvideo.org/video/1779/pythons-class-development-toolkit * Iterators and Generators: http://pyvideo.org/video/1758/loop-like-a-native-while-for-iterators-genera * Idomatic Python: http://pyvideo.org/video/1780/transforming-code-into-beautiful-idiomatic-pytho * Unicode and so on (Pycon 2012): http://pyvideo.org/video/948/pragmatic-unicode-or-how-do-i-stop-the-pain * Any talk from Brandon Rhodes: http://pyvideo.org/speaker/337/brandon-rhodes
Backwards compatibility with Python 2.7 :) This only matters if you need to support legacy code or libraries.
That would be the "Simple" part of HTTPServer. If your goal is to furnish all but a trivial number of requests from it -- you're heading down the wrong track.
yeahhh, but being able to run python -m http.server is a bit nice when you want to instruct someone to start up a web server quickly.
This is a great deal. I bought these three books before this sale and I have learned so much from them. Go and buy this bundle, you won't regret it!
The Holy Grail. Oh, you mean the programming language? Still... The Holy Grail.
I like your humour!
Ah, I'm glad I asked. So Tulip would replace gevents I/O loop but not its other functionality?
Try http://www.codecademy.com/tracks/python and this cool book http://www.greenteapress.com/thinkpython/
Great! Thank you so much :)
It's really amazing how simple the code turned out to be in the end. CFFI is totally awesome! BTW, portaudio wraps Jack, too.
http://www.youtube.com/watch?v=npjOSLCR2hE
Yeah, libsndfike and portaudio are ridiculously awesome libraries! PySoundFile and PySoundCard really are only very thin wrappers around them.
http://learnpythonthehardway.org/book/
Yeah, fetching and executing is generally terrible, but if you absolutely have to at least do it through HTTPS and use cert pinning.
* "stop writing classes" by jack diederich @ pycon '12: http://www.youtube.com/watch?v=o9pEzgHorH0 * "a billion rows per second: metaprogramming python for big data" by ville tuulos at sf python meetup: https://www.youtube.com/watch?v=rXj5nayS7Yg
thanks 
http://www.youtube.com/watch?v=jj3fQJkC1Z0
Discovery channel has some good documentaries. 
Python 3's new import system is super flaky with the import locks. Importing at function level has always been a bad idea, but it got a lot uglier with Python 3.3 unfortunatley. Just move your imports to the module level and you will be fine.
Nice. Thanks. 
Please read the sidebar.
Stop Writing Classes should be watched by anyone coming from Java. It'll make your transition to Python a lot happier. 
err... isnt that the same video? (although nice didn't see that it was on pyvideo else would have linked that one)
They should probably read this too. http://discuss.joelonsoftware.com/?joel.3.219431.12
Guido's Keynote is great and clarifying http://www.youtube.com/watch?v=sOQLVm0-8Yg
All of them really, but especially the Life of Brian.
have you used this? I am trying to do the first exercises on terminal but i'm not getting the same things as the pictures shown. My OS meets the requirements. 
Make sure you're using the same version of Python as the author. This is the most common issue I've seen people face.
Aside from the fact that you're never incrementing `counter`, I don't see much of a problem. If you put the `2` into a variable, you can easily change it if need be (even reading from `input`). Oh, and instead of iterating over a `range` object, iterate over `f`. That will read one line at a time from the file and store it in `x`, which you can then write to the file if `counter%2==0`.
Remove the whole range call: `for x in f:`
I had to go from 2.7.1 to 2.5.1 but it's still the same. for example it says to type "mkdir temp" without the "" and the pictures show Directory: C:/Users and other stuff under that. On my terminal all it says is mkdir: temp: file exists any idea?
okay. I got it working with your help and some research. Thanks! f = open('group4.txt', 'r'); g = open('data.txt', 'w'); counter = 0; for line in f.readlines(): counter+=1 if counter%2==0: g.write(line); f.close(); g.close(); 
Still very primitive right now. I wrote a http server thing with websockets, most of the meat takes place in aiohttp module. (Which when installed with pip, installs another copy of asyncio, hah!)
Ah, so it is. Silly me.
It was developed in a hurry, so I didn't go the full AST approach, but instead generated code sequences and wrote appropriate C++ code. There were are a few places where differences between Java and C++ affected me, the primary unexpected one, is that during a constructor, calls are virtual in Java but not in C++ (a client reported a bug, and it took a while to track down). So I made dummy constructors and then called init() method, which meant that virtual method calls inside a constructor worked correctly. I also had some hackish code in there, so when passing a Java string to a routine that expected a C style string, it would save the byte that would be at the end, changed it to a null, and then changed it back which meant I could avoid doing string copies that were not necessary (it used the reference count to determine if this was a safe operation).
Anyone know any good ones around Unit Testing / Test Driven Development?
&gt; passing a Java string to a routine that expected a C style string I'm assuming these routines are your shims or some such. Since you never really deal with raw strings other than byte buffers in java, wouldn't it be better to accept the actual string type in java? So what cases would you need a raw null-terminated string in your scaffolding?
definitely more efficient. Thanks.
Silly interview.
Why so much code? http://code.activestate.com/recipes/578166-context-manager-to-atomically-replace-a-file/
If you want to see something more representative of general purpose web programming rather than internals and python system code, take a look at Rietveld: https://code.google.com/p/rietveld Browse back to ~2008 for code exclusively by Guido.
Thanks a lot, I just picked up the bundle.
In one case, a developer handed me his first task to code review. It has 2 classes and a factory class! We went over it and I showed him how to reduce and reduce and reduce it, until what was left - I kid you not - was one Python module with one function. 
Thank you! 
Please don't get discouraged. I didn't feel misled or that you were trying to take advantage of the HIB name. Illegitimi non carborundum.
Pycharm for the win. Community edition is freeeee!!! IDE or die. Oh wait, that's php... I tend to slip back and forth depending on what I'm doing. For small things, text editor is fine. I've worked on a small flask project in sublime. But for web scraping tasks I debugged in Pycharm. 
Commented to save
I use KDevelop for large projects (nice Python support) and Kate for smaller things.
PyPy dev here (which is a medium-sized project in terms of codebase). I personally use customized emacs with tons of addons. It's not ideal and why I would love a decent IDE, it just seems that most IDEs are not very well suited for Python. Their auto-completion is crappier than emacs text-only one, the file selection dialog sucks, etc. etc. I *think* a decent IDE would outperform even heavily customized emacs, but I just haven't seen one. On the other hand for C#/Java Visual Studio/Eclipse is just irreplaceable, I can't imagine using emacs for that.
After using PyCharm for two months: auto-completion is awful and much worse then a simple vim-like auto-completion. And I don't know what PyCharm is doing, but when I start it, my music player stutters. During the day, my average CPU usage is about 40% for just typing text. Nope, PyCharm is not my favourite IDE.
I tend to go the same way.
Good job!
I've been doing Python for 10+ years, professionally for 5+ (mostly Django) and I've stuck to the same tools for most of that time, which is screen + vim + ipython. The reason I've stuck with this is that I typically work inside of remote/virtual machines and being able to shell into any machine and put together a familiar environment is fantastic, particularly with the ability to detach/reattach sessions.
I use WingIDE. It's got an incredible debugger, amazing introspection and great search capability. I've tried Pycharm and find it clunky since I do scientific programming and couldn't care less about web stuff. Same goes for PyDev, though I think it's a bit better.
I'm a full time Python dev. My editor of choice is Sublime text. There are a few plugins that do auto-complete and linting for Python -- and they work incredibly well. I love the linting in particular; it highlights any typos or schoolboy errors with a red squiggly line. You have a lot of suggestions here. I think you should try them all. There's no need to get possessive over your editor. I love sublime text at the moment, but if an editor comes along with a better feature set, I would dump sublime text in an instant.