Armin is spot on here. I am really puzzled by the recent effort led by Guido to add type annotations to Python 3.5. I can't help but feeling that this will bastardize a good language. Python is getting more complicated than necessary. Guido's motivation for adding type annotation is pretty weak. IDE? Good Lord. He even acknowledged that type annotation won't help improve performance. There should be only one way to do it. Don't deviate from that. The biggest challenge for Python, IMHO, is to become an expressive and high-performance language. Today, it has been proven that people can design practical, expressive and high-performance languages. In the past, people kinda brushed off the topic of high performance and claimed for most cases Python was good enough. That might be true 5-10 years ago. But today, the competition is really tough. Python will lose its edge if people keep ignoring performance issues. The concurrent module is supposed help implement *parallel* tasks. Well, even its name is misguided (concurrency != parallelism) 
I think you raise excellent points, but the idiom you're looking for is "red herring". And as long as I'm being a grammar nazi, "fewer tests" is more correct than "less tests" because the quantity of tests is countable (integers).
I guess he means write a wrapper for the subject program in python, then use this. To make a quasi GUI. Not what I'd want but it's a free world. I'd just use two terminal windows, one open to the terminal and one to the info page for this use case, like I've done for decades but it's a neat project.
The info pages are often better. Not always. And I'm not above printing cheat sheets while learning or just have them available to reference.
Oh, makes sense, thanks. That would involve implementing some fake arg-parsing also, just so this tool can extract them, isn't it? Writing a script to auto-parse man pages and generate this fake arg-parsing for each tool would be a reasonable way of doing this for a bunch of rarely-used tools. 
It seems so, I haven't really looked into this, just giving you my understanding. I'd just bang out a QT interface in Perl before I'd use this.
thanks - I edit the comment with your suggestions. I'm surprised I made the "red herring" typo.
Anyone have any examples? I can't get it to work -- keeps popping out the following but I'm not sure how to set up. &gt; alessandro_rei_checkmark = os.path.join(image_dir, "alessandro_rei_checkmark.png &gt; ") &gt; computer = os.path.join(image_dir, "computer.png") &gt; computer2 = os.path.join(image_dir, "computer2.png") &gt; computer3 = os.path.join(image_dir, "computer3.png") &gt; images = os.path.join(image_dir, "images.jpg") &gt; settings2 = os.path.join(image_dir, "settings2.png") &gt; __init__ = os.path.join(image_dir, "__init__.py") &gt; __init__ = os.path.join(image_dir, "__init__.pyc")
iv done this. the thing is, the verstion of ipython its installed is 1.2.1, and when i hit ipython into my terminal, it tells me that I am utilizing python 2.7.6, when i want to be utilizing python 3.4.1. How do I go about upgreading to the newest verstion of ipython2.2?
I use pydev. I 've tried pycharm but cet back to pydev. Pycharm was burning to much CPU for my computer ans freeze a lot.
Nit: [1-9]+ would not match any numbers with a 0 in them. You either need to write [0-9]+, or if you want to not allow leading 0's, you could write [1-9][0-9]*
That's large! How many co-developers work on it? How long has the codebase been around?
Thanks! I knew writing Regex examples in bed would be a mistake! Fixed.
if you want to use python 3.4.1, you need to install the Python3 version of Ipython. I believe `sudo apt-get install ipython3` should do the trick.
One good alternative is dependency injection and it's ridiculously easy in python: def is_my_os(system=platform.system): return system() == "my os" And then it's easy to test: def test_is_my_os(): assert is_my_os(lambda: 'my os') 
BTW. We use this module at my current project. We just added the features that we need to process info from our customers. if you think it's lacking some feature please let us know. Feedback is welcome!
But almost nobody really knows the help standards, and this is absolutely true when you get to not-uncommon edge cases. Additionally, super-consistent help messages might be great for machine-readability, but can detract from human-readability. Finally, having argument parsing that actually validates the arguments (without a clunky solution like schema) is a huge bonus. Having the valid values in the help makes even more sense. Doctopt isn't helpful here.
Is there any way to conditionally have a GUI? So, that the program could continue to be used at the command-line OR run as a GUI?
&gt;It doesn't do anything This is why I don't care. Unless they are trying to make [Compound Statements](https://docs.python.org/2/reference/compound_stmts.html). Then it matters. 
Write a regular expression that matches semicolons before a newline and remove them?
This looks convenient. Though it would be cool to also support writes and json schema via something like validictory. We're using [DataGristle](https://github.com/kenfar/DataGristle) which has a validation utility that does this. But when writing python apps we're writing the validation, csv processing, and referencing by hand. A csv module that pulled all that together would definitely save some coding.
I'm sorry but yes it is that one and yes I thought that was the standard noise module people would recognize.
one last check: you use a random z for every single sample? or one random z for all the samples you use? the latter makes more sense to me, the former sounds like... noise?
Open it up in Sublime, CTRL+F, type ;, click "Find All," hit delete.
I think Armin, though he often attempts to speak to small subsets of the Python userspace (e.g. library developers re: unicode), runs into difficulty because his popularity exposes his arguments to a much broader audience than his complaints are intended for. I don't always agree with his conclusions, but the issues he raises are valid in some sphere of interest, and I appreciate that he takes the effort to raise them.
Yes, that's true. We're currently working with CSVs, I didn't thought about other formats. Thank you for the idea!
That's a neat trick. Isn't your clockwise / counter-clockwise mixed up though?
You're welcome. And just to be clear - we're using JSON Schema &amp; Validictory with csv files as well as yaml &amp; json.
Python+game+web hint: Have a look at http://blender.org (all python scripting) and http://www.blend4web.com/en/ for bringing results to the web.
Even prettiness (readability) counts.
A quickreader on it : http://impatientdesigner.com/whats-blender-and-why-does-it-matter-to-web
That's awesome! I'm an Haskell beginner and I hope that one day I'll fully understand what's going on in there!
Might want to handle whitespace before the newline, and capture comments to preserve them, but ya.
You're thinking of FPGA's which are certainly one type of board for automation. MicroPython however is a microcontroller board on the same playing field as Arduino's, Teensy's, and Propeller boards.
In the 00's I developed, and was the CEO of the company that developed, Nuxeo CPS, a Collaborative Portal Server based on Zope and the CMF. Our code base, not including Zope and the CMF, but including the tests, grew to a few hundreds thousands lines of python code (+ lots of ZPTs and XML, IIRC). We managed the complexity by using the CMF component architecture, and most of our components were between 1 KLOC and 10 KLOC. See http://fermigier.com/assets/pdf/cps-ppf-europython-2004.pdf and http://fermigier.com/assets/pdf/europython2005.pdf 
Author here. I'd like to stress that I'm a Haskell newbie and my code might be pretty bad in certain spots. But even more so, this has been a lot more fun than I thought it would be. It also hasn't been as intimidating as I thought it'd be; but it is a lot more work than I originally anticipated. I'm just really persistent about this, and I love Python's simplicity and style, esp. compared to Ruby. I'll be writing a series of blog posts about it soon at [my site](http://callcc.io/). I'll try to remember to post them here if you all would like.
Start at the first commit and walk forward slowly. Parsec's a little weird but the beginning is just handling a print statement.
Hey there, Great work so far! I'm curious, you say you're a Haskell newbie, but are you a functional programming newbie? My impression would be no, since a lot of your code take a very denotational style (which is great!). I'll be looking forward to your blog posts. Cheers!
to get list of recording hardware /microphones try opening a terminal and entering arecord -l
Thank you for the compliment! Most of my FP experience comes from the Coursera FP class taught in Scala by Odersky, and this project. I've tried to pick up Clojure through some tutorials, and have had a few attempts at picking up Haskell through tutorials, but those didn't seem to take in the past. Thing is, Haskell's a really powerful tool, and it pushes you to write in a certain way that rewards a denotational approach. Python itself can almost be thought of as syntactic sugar atop a lot of the built-ins; it makes sense that an implementation of that should reduce to something similar. Haskell is a lot of fun, but it requires a lot of patience if you know how to program. Example: I spent over an hour yesterday adding support for tracing by setting the TRACE env var. All I had to do was check if it exists and log a debug statement. (In this case, I forgot I had to use liftIO.)
Thank you! I wouldn't have though about that! Normally I get the most recent checkout and start exploring.
The problem with something like sculpt is that it's basically an interpreter running inside another interpreter. Both do a lot of voodoo to get some decent performance, but one way or another, there is significant extra overhead. If anything, my money is on compile-to-javascript solutions, however Python is not a good candidate for that - it's just too dynamic.
Sublime Text for me too. With the right plugins it becomes the perfect mix. It's lightweight and has IDE features. I've tried all the others and they each have their merits, but ST is a perfect fit for me right now.
Ikr, hence the sarcas/light hearted tone! My language of choice is PHP truth be told, lovely language, but not so good for desktop development!
I user Spyder IDE, I really being able to highlight portions of code and then run the snipped in a terminal (Ctrl+Enter). I mainly do data analysis and also use R/RStudio a lot.
Nice tutorial. I'm basically using the same stack for RESTful servers API ATM. We'll have to start thinking soon about some of the thorny issues that are not exposed by such a simple use case: - Batching / pagination - Filtering - Binary attachements (i.e. when JSON is not enough) - ...
You are a helpful person. 
And embedded C. For whatever reason. code = """ printf("hello"); """
You realise the `;` in `%s/;//` is a regular expression? And you meant `%s/;//g` I think, anyway.
The script he wrote was short and I was able to remove them with a replace all, he doesn't even work here anymore but I just infuriates me that I told him not to use the semicolons and he didn't even make an effort to stop. 
OK, what about `ls`? $ ls --help Usage: ls [OPTION]... [FILE]... List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. (cutting off the rest for brevity) The `[OPTION]...` syntax is not acceptable to Docopt so far as I can tell; it requires the spelling `[options]` instead. For the record, in case your `ls` is different: $ ls --version ls (GNU coreutils) 8.21 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Richard M. Stallman and David MacKenzie. 
I guess BananaPotion meant something like: tr ';' ' ' &lt; file.py &gt; stripped.py 
Glad to see this writeup. Ever since I added New Relic to a project, I've been thinking a lot about Django template rendering speeds because they're often a lot slower than I would have imagined and I have figured out that rendering includes or other smaller templates inside templates seems one practice to avoid where possible (outside of template caching as a solution, of course).
I make it a point to follow PEP8 and all appropriate style guides where capable, but, there is a value in the ability to use semicolons in Python. From the code I was writing today -- I've got a script that is invoked by Django which imports some files, parses them, and dumps the output to an appropriate folder for reuse later. So, I work on the script a bit, and then, to test my progress, will do the following: ./manage.py shell from parser.utils import ParseCSV parse_csv = ParseCSV("AReallyLongTokenGoesHere") parse_csv.main() As I'm using the standard Python interpreter and all that, that's a pain in the ass. Every time I change the script, I have to exit the shell, open it up again, and redo all those commands. My carpal tunnel weeps just thinking about it. Much easier to type them all out on one line, separated by semicolons, and then just paste them in each time. from parser.utils import ParseCSV; parse_csv = ParseCSV("AReallyLongTokenGoesHere"); parse_csv.main()
Benchmark without source code? Meh...
It doesn't look like Django templates were ever tested with the cached template loader: 'django.template.loaders.cached.Loader'. This is the recommended template loader for production (in most cases) and should offer significantly better performance. I'd expect this to perform about the same as non-memoized Jinja, but I haven't seen any stats to compare. 
So this noise module is deterministic, however you can include a `base` parameter: &gt; base -- specifies a fixed offset for the noise coordinates. Useful for generating different noise textures with the same repeat interval Doing something like `seed = random.random()` and then calling `pnoise2(..., base=seed)` should get you the results you want.
Interesting, base can be a float for `snoise` but it wants an int for `pnoise`. So in that case use `seed = random.randint(0,1024)` (or some other large int, although it looks as if tings may start to repeat after 1024... C isn't my strongest suit.
this is /r/ python. keep your loaded political statements on the other subreddits.
I install ipython for Py3k with sudo pip3 install --upgrade ipython It has the same package name but you want to use the pip installation for Py3k.
This year, my kids started riding the school bus, which is super convenient and means I don't have to spend extra time getting them to school. That is, if they make the bus. Sometimes they lose track of time, and I wanted a pretty reliable way of reminding them when it's time to go outside to wait for the big yellow limousine to escort them to school. Since I am lazy, I decided to have this automated, which uses (ideally) a Raspberry Pi and Google Calendar to check for 'Get on the bus' events, and fires an appropriately annoying song snippet from The Doodlebops called 'Get on the bus.' It's dynamic in the sense that it will try and play any mp3 with the event title, and falls back to a default mp3 (my default.mp3 is an old school Nokia ringtone-- of course, you can make yours anything you wish). Currently, I'm just playing with this on a MacBook Pro-- I'm itching to get a Raspberry Pi and a speaker setup so I can put this thing into action. Thought you guys may have a use for this as well, so do what you want with it.
Cool. I tried this and it seems to be working good. 
I see your point concerning the second snippet. To be honest, even if I implemented this way of declaring a command, I do not use it, I prefer the class declaration way that seems less odd like you mentionned. Also, I like the simplicity of your solution. It feels more natural. I will think about it. About the trailing underscore it's just that input is a reserved keyword so I had to find a way to keep the whole word for comprehension purposes. I could not think of a better way.
This question is almost certainly hyper-premature, but do you have any idea what it would take to make this interpreter GIL-less using the STM abilities of Haskell?
I'm happy to hear that!
I've been coding in Vim for the last 8 years for many different languages, and that's what I also use for Python and Javascript code nowadays. I don't use much 3rd party Vim plugins, just learned how to use visual mode, how to record and reply macros, etc. and that helps me solve 99% of my problems. To help me get some things automated like running pylint, I set up Grunt.js to watch my source files and run tasks as the source files gets modified. This environment is not for everyone, but its very light weight and works really fast for me. I have a license of PyCharm, but just can't get used to it ;-)
Is this your app? long story short: I'd seen this thread but couldn't remember the name nor find the thread. I searched on github for "python gui" sorted by "recent update" and yours isn't returned. If this is yours, you might change your short description to be a bit more findable.
Seems interesting. Thanks!
"Hython" is already a thing (Houdini Python); you may want to consider a name change to avoid confusion.
While armin makes a very good argument from the technical side, i dont think he really addresses the reasons people want type annotations. For instance he mentions mypy but then talks only about cpython - but the whole point is that mypy allows faster performance thanks to the annotations. Whiles its true that till now cpython has defined then language the more recent proliferation of alternative interpreters means we will have to move to a more formal definition of behaviours that don't depend on the c implementation. In that light you have to consider why you would want annotations - tooling support (big deal on large projects), performance improvements through specilised interpreters/compilers/plugins (like numba). Given that things like mypy and cython use type annotations anyway, it would be much better to have a standardised definition than a dozen different variations.
For the performance point, the idea is partly that alternative interpreters or compilers could make use of the optional type information. If an optional type system is defined then code can run unmodified on different interpreters and compilers
More useful link: http://matplotlib.org/1.4.0/users/whats_new.html 
Yeehah! This was the last library I commonly use that still needed a Python 3.4 release. Glad it's here. Not complaining, BTW. I'd seen discussion that some of the devs just had other stuff to do so they couldn't get this release out when they had first wanted to. No problem there. Many thanks to the matplotlib developers.
Sounds good - can't use it at work though, for obvious reasons.
Argh, I hate posts which give no indication what the hell the linked package is about. You should have at least included the line &gt; Cleo eases the creation of beautiful and testable command line &gt; interfaces.
The workaround is not working for me. I am using py2exe to convert my script into an executable. but getting following error: File "command_ui.py", line 1, in &lt;module&gt; File "gooey\__init__.pyc", line 1, in &lt;module&gt; File "gooey\gooey_decorator.pyc", line 16, in &lt;module&gt; File "gooey\gui\base_window.pyc", line 16, in &lt;module&gt; File "gooey\gui\header.pyc", line 10, in &lt;module&gt; File "gooey\i18n.pyc", line 37, in &lt;module&gt; File "gooey\i18n.pyc", line 24, in get_path IOError: Could not find english language file
assuming a error-free CSV, having conversion would be nice { 'name': 'price', 'required': True, 'convertor': float }, its the final step between having data and having processable data - - - also, attribute access, `error_row.errors` is so much more nicer to type, since they all look like they are dicts... https://github.com/Socialery/BuiltinExt/blob/05ed3da104/builtinext.py#L5 is an example of how to go about it with minimal increase in complexity while preserving already existing functionality - - - all in all, it seems neat, but I'll probably stick to using `namedtuple`, `csv`, and a zipmap for conversion/validation
I write software for the financial industry. There are a lot of very specific applications needed - and over the years Python and wxPython have served me very well. 
Any idea whats needed for jython to work on android?
This was the most useless link possible.
That might not be impossible. I've used Sikuli to drive UI's using shell scripts. A command line program that run Sikuli scripts based on its arguments might work but the Sikuli scripts themselves would have to be created manually. http://www.sikuli.org/
I love you.
Thanks for the heads-up, a name change is probably necessary.
I guess it does suit SO more. Py2.7, but it's the blogger api v3 that's not playing right with service accounts.
Good idea. Thank you!
A few things I would like to point out: * use subprocess module instead of os.system * don't do *-imports * avoid using "global" statement and global variables in general. Pass the arguments you need to the functions instead. * a little bit more of [pep-8](http://legacy.python.org/dev/peps/pep-0008/) please :-)
If by ‘this release’ you mean ‘previous release’.
I'm surprised, too. I would love to see comparison of the two.
Good catch! That's what I get for careless scrolling.
I had a *ton* of trouble getting it packaged up. However, I switched from `distutils` to `setuptools` as well as had a couple of friendly pull requests to fix the `setup.py` file, so, theoretically, it should be good now. Try pulling a fresh copy of the repo and re-installing. I *think*(!) that'll fix your issue. Let me know if not. Sorry for the troubles, man! First time packaging a Python project :\
Whoop! I need to turn off those print statements. Can you run any of the examples in the `mockapplications` directory? 
Not really. If your interest is just using Python to code for Android, have you looked at [Kivy](http://kivy.org/#home) ?
The dict based syntax is almost interesting, but the one with chaining looks just ugly in Python. All those \ should hint you that you're contorting the language to look like something it isn't. [Click](http://click.pocoo.org/) has a much more pythonic syntax, and I've been able to implement all features I wanted with it, so far. 
I hope not, that's terribly confusing terminology.
If CPython is not going to improve its performance by using these optional types it should not be the leader in deciding what these optional types should look like. Let the alternative interpreters, IDEs, etc which have a real need, collaborate with each other first. Then when a mature solution has been developed and has been successful it maybe time to start talking about adding it to the language. Those who don't have a real need should not dictate the solution as they have no incentive to get the details right. They may want to do the right thing but in the long run if a premature solution is adopted it causes more harm over the long run. Python already has a long history of including things in a premature state such as TK, unittest that is based off of JUnit and is very unPythonic, the xml libraries, etc and I also expect the new asyncio library will prove to have a similar fate. BTW, some of the alternative interpreters such as PyPy would not benefit from these optional types.
I mainly like that they now have violin plots standard. The affine2d stuff is nice too.
Violin plots in the mainline. Awesome!
The docstring for `snoise2` is: Type: builtin_function_or_method String form: &lt;built-in function noise2&gt; Docstring: noise2(x, y, octaves=1, persistence=0.5, lacunarity=2.0, repeatx=None, repeaty=None, base=0.0) return simplex noise value for specified 2D coordinate. octaves -- specifies the number of passes, defaults to 1 (simple noise). persistence -- specifies the amplitude of each successive octave relative to the one below it. Defaults to 0.5 (each higher octave's amplitude is halved). Note the amplitude of the first pass is always 1.0. lacunarity -- specifies the frequency of each successive octave relative to the one below it, similar to persistence. Defaults to 2.0. repeatx, repeaty -- specifies the interval along each axis when the noise values repeat. This can be used as the tile size for creating tileable textures base -- specifies a fixed offset for the noise coordinates. Useful for generating different noise textures with the same repeat interval So I was looking at `repeatx` and `repeaty`.
Exactly, Jinja2 is bound to be faster due to the differences in design. 
Thank you.
=D
Very cool practical application. It would be cool to connect this to Hue lights (or other "smart" lights) and briefly turn your home into a rave.
&gt; Support for datetime axes in 2d plots Yesss
thank you matplotlib developers! I've been waiting for the python 3.4 release of this library, great to see it's here :)
Your first example is completely bunk. Lists are not hashable because they are mutable: &gt;&gt;&gt; l = list() &gt;&gt;&gt; d = dict() &gt;&gt;&gt; d[l] = True Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unhashable type: 'list' I can't speak to the rest of the intransitives, but a lot of them are to do with Hashable which frankly is not surprising.
&gt; As I'm using the standard Python interpreter and all that, that's a pain in the ass. Every time I change the script, I have to exit the shell, open it up again, and redo all those commands. My carpal tunnel weeps just thinking about it. Much easier to type them all out on one line, separated by semicolons, and then just paste them in each time. I agree with you here. I don't mind using them to separate everything out on one line if the situation permits. I'm not against breaking rules if there are situations in which it improves something; no use having a rule if it causes more problems. Using semicolons in python before you enter a new line, however, is inconsequential and kind of like rambling in your code.
Agreed. One of the nicest things about Python is that we have all agreed to observe [one style guide](http://legacy.python.org/dev/peps/pep-0008/) (within reason), so that we don't waste time arguing about style.
Completely agreed. 
I agree. In fact, the whole idea of building figures first and constructing plots *on them*, rather than the OO approach of building a figure from a collection of plots, is awkward to me. It also affects projects like mpl-d3, which have to [create a figure and throw it away](https://github.com/mpld3/mplexporter/blob/2766ea5209b55d54f5de524180eef219e0878bbc/mplexporter/exporter.py#L43) (they just want to dump info from plots as JSON).
Yet another reason that ABC was a bad design decision; there are many problems that arise from not treating 'class' and 'type' (or 'implementation' and 'interface') as distinct concepts.
Can the looks of seaborn, prettyplotlib, etc. be entirely replicated with styles?
Please post your code if you want "real" help :) Post a part of your data as well. it's always helpful to have data to work with.
&gt; pyplotlib I like the name.
but what about when you're using a VAX?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**VAX**](https://en.wikipedia.org/wiki/VAX): [](#sfw) --- &gt; &gt;__VAX__ was an [instruction set architecture](https://en.wikipedia.org/wiki/Instruction_set) (ISA), developed by [Digital Equipment Corporation](https://en.wikipedia.org/wiki/Digital_Equipment_Corporation) (DEC) in the mid-1970s. The [VAX-11/780](https://en.wikipedia.org/wiki/VAX-11/780), introduced on October 25, 1977, was the first of a range of popular and influential [computers](https://en.wikipedia.org/wiki/Computer) implementing that architecture. &gt;A [32-bit](https://en.wikipedia.org/wiki/32-bit) [complex instruction set computer](https://en.wikipedia.org/wiki/Complex_instruction_set_computer) based on DEC's earlier [PDP-11](https://en.wikipedia.org/wiki/PDP-11), VAX ("*virtual address extension*") was designed to extend or replace DEC's various [PDP](https://en.wikipedia.org/wiki/Programmed_Data_Processor) ISAs. The VAX architecture's primary features were virtual addressing (for example [demand paged](https://en.wikipedia.org/wiki/Paging) [virtual memory](https://en.wikipedia.org/wiki/Virtual_memory)) and its [orthogonal instruction set](https://en.wikipedia.org/wiki/Orthogonal_instruction_set). &gt;VAX has been perceived as the quintessential [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computing) [ISA](https://en.wikipedia.org/wiki/Instruction_set_architecture), with its very large number of programmer-friendly [addressing modes](https://en.wikipedia.org/wiki/Addressing_mode) and machine instructions, highly orthogonal architecture, and instructions for complex operations such as [queue](https://en.wikipedia.org/wiki/Queue_(data_structure\)) insertion or deletion and [polynomial](https://en.wikipedia.org/wiki/Polynomial) evaluation. &gt;==== &gt;[**Image**](https://i.imgur.com/PqTBdpq.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:VAX_11-780_intero.jpg) --- ^Interesting: [^Vax ^\(vacuum)](https://en.wikipedia.org/wiki/Vax_\(vacuum\)) ^| [^List ^of ^VAX ^computers](https://en.wikipedia.org/wiki/List_of_VAX_computers) ^| [^OpenVMS](https://en.wikipedia.org/wiki/OpenVMS) ^| [^VAX-11](https://en.wikipedia.org/wiki/VAX-11) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ck140ty) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ck140ty)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
That would be pretty cool! I just added a bit to enable text to speech, so an event titled say Remember to start the crock pot will announce 'Remember to start the crock pot' if you're on a Mac or (hopefully will work) Linux system.
They did add a new "style" package which seems cool though. Haven't tried it yet but seems very easily to use and potentially very useful. from matplotlib import style style.use('dark_background') People could potentially make nice custom styles and upload it for everyone to use. Things like xkcd-style, etc, could all be done and distributed easiy.
Looks like there are TTS engines on Linux, but they aren't invoked the same way. [Espeak seems to be installed by default](http://superuser.com/questions/93691/mac-os-x-say-command-in-ubuntu), at least on Ubuntu.
I think we would also need to see the Entry class to see if it's correct. Edit: http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html
Can I have the $100?
My only thought, without knowing anything about the libraries being used, would be to replace the integer with the ForeignKey-- because the ORM is probably handling the datatypes/logic/etc. being used for it... http://hastebin.com/usepopahan.py
http://hastebin.com/uyefebexul.py ?
I just recently did some foreign key stuff in SQLA. Here are 3 Models. http://hastebin.com/ebefutevub.py Not shown at the top: from flask.ext.sqlalchemy import SQLAlchemy #I just happen to be importing SQLA from the flask-sqlalchemy plugin rather than actual sqla db = SQLAlchemy() Hope this helps. 
he said the ORM is sqalchemy. Sorry I cant help much I have no idea what that means.
I'm not sure what you mean by "it does nothing except double space". I can't see anything drastically wrong with it to begin with. However, are you calling the function `GnToFbf()` anywhere?
Whenever i run it, it does nothing!!!! Literally nothing. I dont understand your question, what do you mean am i calling the function anywhere?
Yes, having interfaces in Python [makes a lot of sense](https://glyph.twistedmatrix.com/2009/02/explaining-why-interfaces-are-great.html). See [zope.interface](http://docs.zope.org/zope.interface/README.html) for a good take on this in Python.
All your code does is declare the function. In order to actually execute it, you need to call the function somewhere. You say this is for a homework assignment, so the concept of functions has definitely been covered - I suggest you revise that and try to learn what functions are, what they're used for and how they're used. Also, in the future, it might be better to post such questions to /r/learnpython . Always remember, however, that people won't do your homework for you, but will (for the most part) be happy to ask you questions that might put you on the right track. Good luck!
`input` returns a string (in Python 3), so the variable `x` is a string. You can multiply a string by a number, but it doesn't give the result you want. Call `int` on the input variable `x` to get it to do what you want. Questions like these are best asked at /r/learnpython. 
 &gt;&gt;&gt; x = input() 43 &gt;&gt;&gt; type(x) &lt;type 'int'&gt; &gt;&gt;&gt;
Do you have a GnToFbf() call outside of the function declaration?
Thanks for the help!!! I will look up how to call the function.
Is that Python 2? I believe `input` in Python 3 is the same as Python 2's `raw_input`. Py3: &gt;&gt;&gt; input() 1 '1' Py2: &gt;&gt;&gt; input() 1 1 &gt;&gt;&gt; raw_input() 1 '1' 
Was there anything that changed in 3.4 that would have prevented the previous version of Matplotlib from using it? I thought anything written in version X.y was guaranteed to work in versions X.y+?
Maybe if Ken Reitz could be gotten drunk enough or given enough money....
Even better than Grapho Van Rossum.
You have a port of [ggplot2](https://github.com/yhat/ggplot/), but I don't know if you get something Pythonic or something based on R....
keep trying. you'll get it. learning how to program is largely about learning how to understand technical documentation and find your own solutions to things. the best thing you can do at this point is go back to the fundamentals. try this one: http://learnpythonthehardway.org/book/ its a good read, available for free online, and written to be a good resource to people just learning for the first time. 
I do, but there are multiple other errors. This is confusing the hell out of me lol. 
Right-- I meant if you call the event "say whatever you want here" -- in the code, I grab the platform, and if it's a Mac, use "say", and if it's not, use espeak: system = platform.system().lower() [...] command = '{0} "{1}"'.format('say' if system == 'darwin' else 'espeak -ven+m2', event_name[4:]) Hopefully should be fine on linux, but won't have a chance in hell working in Windows.
I use matplotlib but avoid the pyplot interface. Most of my plots are done something like: from matplotlib.figure import Figure from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas figure = Figure() canvas = FigureCanvas(figure) ax = figure.add_subplot(1, 1, 1) ax.plot([0, 1, 2], [0, 2, 4]) canvas.print_figure('figure.png') It's still a bit awkward but at least it avoids relying on global state hidden in pyplot.
That does look quite a bit cleaner. I think I'll start doing this in the future, at least until something better comes along.
The last time I counted, there was about 125 KLOC of in-house code, then if you add in all the third party and generated code it ended up being about 700k. Its all ostensibly one project that goes back a decade of continuous use and development, though there are several distinct subprojects / applications that make up the whole. It's been a small team throughout, never topping over 3 employees at once.
if you want to output it to pdf, one method is using latex. but that may be overkill.
Python code written in any version 3.x should work with any version 3.y. But a big chunk of matplotlib (and many other Python packages) have C or C++ source code that is linked with the Python C/C++ code. For that reason, packages need to be rebuilt for each Python major version (ie 3.3, 3.4). They don't need to be rebuilt for Python minor versions (like 3.3.1, 3.3.2).
Fortunately all sane operating systems come with a python distribution out of the box... Don't people use that Windows PowerShell® thing for small scripts?
There's plenty of sane operating systems missing Python by default. If I remember correctly, Debian doesn't have Python by default, and Arch (which I run on my laptop) doesn't have Python by default. Then again, Arch has pretty much nothing by default. Powershell is OK, but it's one of those tools where it's not really worth getting too deep into it, if you're running mostly Linux. Microsoft-slave mostly resetting AD user passwords though, perfect. 
Quite stoked about this too. Though honestly, after transitioning to seaborn, I'm going to have trouble going back to matplotlib...
another example why it is not just like flipping a switch to make python typed... interesting read and discussion here: http://www.reddit.com/r/programming/comments/2egz66/revenge_of_the_types/
Both debian and arch come with python by default.
Current project is around 60k LOC It really needs a complete refactor, there's a lot of cruft that needs to be cleaned up, but it's fairly easy to manage once you understand how everything is structured.
just assign it to a new variable. soup = BeautifulSoup(url) soup_string = str(soup) Edit - I see you mentioned what you need is inside an li tag. You'll need to use `thing = soup.find("li", "#search string")` and then make `thing_string = str(thing)` or some variation on that. I used something similar to grab a webcomic string path on a scraper I made recently [here](http://pastebin.com/aehGnz3Y) if you want an idea of how to parse that with `re`. The relevant info is in the `comic_soup()` and `get_comics()` functions. It's likely you'll need to parse it with regex, depending on what you're trying to grab, as when you convert to string, it will grab the entire tag ` &lt;li #Here be information#&gt;&lt;/li&gt;`
Debian 7.0 Wheezy comes with Python 2.7 by default.
At least in our environment using powershell requires opening a security hole so this is a IMO more powerful solution that &lt;sarcasm&gt;doesn't require our networking and server guys to do any actual work ever&lt;/sarcasm&gt;
here's a universally applicable method to learning the api's you wish to interact with. open an interpreter, import it and play around with it. read the docs http://www.crummy.com/software/BeautifulSoup/bs4/doc/ 
[Arch doesn't] (https://www.archlinux.org/groups/x86_64/base/)
Thanks for the explanation. I appreciate the detail. Fortunately, for my application, I don't really need to parse too much raw natural language, aside from the ambiguous nodes in Conceptnet, which aren't too bad. Most of them I probably won't even use. I just need to grow the connectivity a little more so there's enough overlap between unambiguous nodes to efficiently do 20-questions. Right now, it's just not connected enough. For example, say the user's thinking "cat". Using the Wordnet taxonomy edges, the system could get down to "is it a feline?" in about 10 questions, but after that, there's nothing differentiating cat any further, and there are a lot more than 10 types of felines so it would likely run out of questions by just running through them all. The ambiguous /c/en/cat edges have more useful features, but I can't necessarily guarantee they all refer to the /c/en/cat/n/domestic_cats sense vs the other 9 unambiguous senses for "cat". Well, actually, for "cat", most of those ambiguous edges actually do appear to refer to "domestic_cats", but this assumption doesn't hold true for all words. When I looked at the other words, like "wing", I found the ambiguous edges were pretty uniformly split between several senses. For one initial WSD attempt, I tried looking up all senses for the start and end nodes and using a variation of Lesk to find the sense pairs that have the most overlap in glosses. Unfortunately, it's only around 40% accurate, which I've read is typical for Lesk. I was hestiant about trying something like Divisi for the huge memory requirements you mentioned, as well as having to reduce the number of senses. I'm considering an incremental supervised approach instead, by training a regressor to predict the same "overlap" weight given the left-hand and right-hand glosses. Have you had any success with supervised techniques?
Openstack. No idea how many lines. Probably one of (if not) the biggest Python open source project ?
Can you explain this further? As far as I understand, Powershell can run an executable from a network share no problem.
Yeah, goes along with its minimalist functionality though. I'd bet most Arch machines end up having it.
it's a matter of long term vs. short term... or the whole give a man a fish thing. thanks for the feedback, It won't affect me as much as you intended, but .... internet points!!! 
I'd have to assume that lots of people use python on windows, considering [their share](http://en.wikipedia.org/wiki/Usage_share_of_operating_systems#Desktop_and_laptop_computers) in the market
On our network Powershell requires scripts to be signed in order to be run on other computers in the domain (this is 2nd hand info from another tech) in order to get around this we would have to disable this (lowly tech monkeys don't get access to the certs (if they exist))
That's actually the default Powershell setup. To enable local unsigned scripts to run you just have to run `Set-ExecutionPolicy RemoteSigned`
I do because I run both windows and *nix and want one language that behaves mostly the same on both. The college where I work is 99.5% windows but I am not a huge fan of powershells ways (though I will learn it, and it may grow on me (required class)). This gives me a decent way to build complex scripts without requiring a change to the domain (I am a student employee so I'm under paid and over worked, so anything that automates me and the other peons tasks is great (though I am leading the implementation of GLPI and OCS-NG)
Great for ansible, and thanks for poo pooing on my learning experience. Also we are remodeling a building so no one is interested in completely changing our work environment. (Hell they never are)
You'll stop worrying about comment karma once you've got enough to not notice it going up or down anymore, don't worry. My point is that your comment wasn't helpful as it could have been, he knows what you've told him since he's shown us in his OP. 
Could be his be done on the first line of said script? Its not likely to happen if we have to do it to n each computer as most have SmartShield installed.
The Documentation is exactly what I had been poking around in the past days with no success, which is what lead me here. : /
While I have started using Seaborn extensively, it's more of a jumping off point for me when I actually need to make publication quality graphics. I still find myself doing some hand-tuning at the matplotlib level to get plots to look just right. 
&gt; thanks for poo pooing on my learning experience. How much are you reading in to his three word reply?
Probably too much but it seemed like a snarky comment saying "someone much more important than you has done this probably much better"
i have a quarter + internet points I can get a cup of coffee. I totally get what you are saying man, I just dont give a shit. you are just going to have to accept that fact. 
you didnt mention that you were poking around in the interpreter, which is an interesting conundrum. 
&gt;The thing I am trying to extract are the 4 numbers hidden in there. Definitely just get a string from the &lt;li&gt; by running BS on it and then converting to a string with standard Python string methods. From there, regex will be the easiest way to get it. If you're only looking to get the numbers, that should be cake with regex, it's just a `'\d+.\d+'` for floats, or just `'\d+'` if you only want integers. You'll probably have to `re.compile()` for both, since I'm assuming you're looking to grab them all, and not just float or int only.
or.... you unnecessarily reinvented the wheel un-necessarily. if you are proud of what you done, it shouldn't matter that the internet(life) is "poo pooing on it", but if you were doing it for internet points, I would reckon it is effort wasted. 
I don't know how useful the BS docs will be for this. I mean, yeah, you can get a string using BS, but in my experience, it's actually been easier to just convert BS output to strings and then manipulate using `re` and standard string methods in Python. Maybe you've had better luck, but I've had similar experience to OP's. BS is great when you want to grab the tag info, but doing anything with it beyond that has been sketchy for me without using other means to manipulate it.
No worries man, we're not in /r/learnpython.
I had (mistakenly) assumed based on my research that I was infact not reinventing the wheel (or if it had been invented it was kept behind closed doors). I've also had a long day so theres that too...
I've just tried it and it looks like it needs an elevated command prompt, which makes sense. If you're able to get your batch file run elevated then use something like this: powershell -Command "Set-ExecutionPolicy RemoteSigned" powershell -Script "\\SERVER\Share\Folder\Path\To\Script.ps1" 
You can usually rewrite something in a better way. But this can be a paralyzing timesink. Knowing when something is good enough and loosely coupling your components will get your work out the door and allow you to make isolated improvements as you need them. 
If you're an Arch user, you oughtn't have any problem with getting Python installed! :P
you're not wrong walter...
This reply became longer than I anticipated, but I hope it helps... Typically, the thing I find that helps a lot.. is plan out the "pseudo-code" before you actually write code. Write the comments that explain the ten or fifteen steps that make up the logic of what you want. You can write these as comments (and keep them there to explain to other programmers) or take them out.. your choice. But basically, the next step is a simple one: Write the functions that would replace those pseudo-code steps, stuff like "get_top_three_player_scores(tickets)" or maybe "delete_worst_deal(groupons)" etc. As part of that, when you notice that you have too many levels of indentation going on.. replace some of it with a function! The reason they have the 80 character limit was because terminals used to be 80 characters wide.. so that's all the room you had on a screen. But the side-effect of following the 80 character rule is that your logic isn't horrible and nested inside 10 IF blocks.. unless you had a good reason. There will always be exceptions to the rule... but the more you break up your code (you don't need to overdo it, of course) the more you can replace parts of it out. The last thing, I'd want to leave you with.. and this took me the longest to figure out for myself: take your ego out of the code, encourage collaboration, and figure out how to test your solution. If you can't test it.. how do you know it's correct? Your code is created to solve a problem. Can you identify that problem? Can you have others identify the problem? Maybe their use cases differ from yours. Ask. Then look into "writing unit tests" and write a test around your functionality.. it should FAIL to start with.. then code a solution.. so it should SUCCEED at the end. Then show someone else your code (if it was complex) and ask if they have a better way of doing it. Peer review helps. Some other small tidbits: - If it's a loop, there's typically a reason you're doing something over that loop.. maybe the looping code can be a function in itself - If it's something you do more than once, make it a function that accepts extra arguments to solve the problem, and use it twice
I thought that outlawing 'goto' was supposed to get rid of spaghetti code. These graphs are horrible!
Sorry to say, there isn't really one simple solution for this type of problem. Similarly, it's like how musicians can learn an instrument to which they can perform without making mistakes. Or how Doctors figure out the optimal treatment routes given a patients medical history. It's all part of training yourself through deliberate practice. In programming, it's hard to measure the worth of the things we make since it's so intangible. But regardless of how insignificant, just keep making things and try to explore outside your comfort zone. Eventually, you'll learn to deal with more levels of complexity and create more solid abstractions. But these things take time.
windows
For me, there's no magic bullet. But the *one* thing which helps me most is: **Pencil, Paper and (most importantly) a good rubber/eraser** When I have to tackle a larger project, I do a *lot* of planning using those good old tools. And it saves a *tremendous* amount of time. Erasing a line somewhere and re-drawing it is so much easier on paper than it is in code. When "drawing" code, I personally don't strongly adhere to some norm like UML. But I take inspiration from it, and most of my doodles are *based on* (or started as) some form of UML. But when I have to draw things which are not clearly defined in UML I simply draw as I see fit. What irks me most is the difference between UML-Class diagrams and ER-Diagrams. Especially the fact that ERD relations are inverted from UML-Compositions (for example). I always mix up the direction of the arrows... so I usually add a small note to the diagram explaining what it means. It also gives you a visual overview of your application design/architecture, and after doing that for a while you can easily sniff out code-smell before it even happens. Having a visual representation of your code helps me a lot to think about the different elements which exist, how they collaborate together and what processes exist. I have tried a few applications on the PC, but without exception they restricted me from doing something in one way or the other. Pencil &amp; Paper is pure freedom. When discussing something in a team, a **whiteboard** is very useful. The larger the better. I usually take photos of the end-result and add them either to the development docs, or our issue-tracker. The same goes for pencil-doodles. One variation on this I use is to use a transparent piece of plastic over a piece of paper (I usually use one of [these](http://imgur.com/R5cNqiB)). I can then use whiteboard-markers to draw on the piece of plastic while I can see whatever is beneath it. I have used this quite a lot to keep track of graph-traversals, or any other tracking of an algorithm. **Unit Testing** If you have never done unit-testing, you won't believe how much this influences the architecture of your code. When I started with testing, I always got fed up because it was so difficult. It took up so much time... But that was because I was trying to test *existing* code. And the architecture of that *existing code* just made testing a PITA. Beginning to code with unit-testing in mind forces you to write code in a specific way (or avoid bad patterns, like global state, singletons, impure functions, violating the Law of Demeter, ...). If you keep this in mind, your code *will* become more maintainable. But you might need to shed some old habits. And that can be hard. I still have a good deal of my code (all my legacy code) in a state which is difficult to unit-test. And getting it there is hard, because it directly affects parts of the overall architecture. **Good documentation** When coming back to a project after several months, you will want to marry yourself if you wrote good docs. The most important one: *How to run/test the project from scratch*. Automation tools like fabric, vagrant, DB migration tools, and/or shell-scripts can help with that. Just so you get started quickly and can hop into development without (mental) delay. A few other points which help are entry-points and a quick global architecture overview. The pencil &amp; paper doodles can help a lot. But only if they are still accurate. During the life-time of a project, those doodles can become obsolete. And I am personally guilty of not always updating them :( Once you found your entry-points, have your projects running, comments inside your code are indispensable. Always keep those up-to-date!
&gt;The reason they have the 80 character limit was because terminals used to be 80 characters wide We old guys remember something called "punched cards" that were 80 characters wide before they invented screens!
Draw, discuss, explain. Iteratively. "If you can't explain it simply, you don't understand it well enough."
Just transposing arrays can be handy too: columns = zip(*rows)
Self-teaching to become a better coder should probably be done after the current project is complete. It's okay to refactor small chunks of code as you go, but do not refactor a large portion of a program before the functioning unit is complete. Getting hit with a stroke of genius and self-discovering a neat optimization or an unfamiliar design pattern is really useful, but instead of trying to learn/discover/implement the idea, take a break to document your thoughts regarding a possible refactor and save your notes for much later. Don't introduce design problems which you lack experience to deal with. Later you can use your refactor notes as a syllabus and list of keywords for searching. Read up on what kind of design pattern you implemented, and what design pattern you are now considering switching to. Without compromising your progress, you can both complete the project and provided yourself with an invaluable learning resource. Your code may be a textbook example of what not to do once you learn the more appropriate pattern, and now it is much easier to implement the new pattern into a project with all the pesky, unforeseen requirements layed out.
How do you deal with functions that take WAY too much information, but they actually need that much, or it would be difficult to remove that information. For example, I'm writing a reddit client. One function, printsubmission() takes in * Subreddit For printing where the submission was posted to. * A subreddit object Because this function is called many times, and it for some reason PRAW doesn't cache the object, or I'm doing something wrong So I need to get the object and pass it in every time. * Index To print the index of the object, so I can have a number next to it. * stdscr A curses pad that everything is written to. * selected A boolean saying if this item is selected. Bold the number if it is. Also, the arguments are in that order. I feel that this is too much, but I can't think of a way to reduce it.
I look at the Twisted graph, and I think "aren't these the guys that started the hating-python-3 trend when they tried to port by doing encode/decode at each &amp; every callable shown here?" 
It could be a method on a class, only taking stdscr as an argument.
It's click bait, as far as I'm concerned. There's an official process (via PEP's) to improve Python, any genuine deficiency would be addressed thusly, and not via half-truths on a blog site with an army of trolls / multiple accounts downvoting dissenting opinions against reddit site policy. The true irony though is then being accused of ad hominem by such hypocrites, like they hold the moral high ground? 
&gt; Write the comments that explain the ten or fifteen steps that make up the logic of what you want. You can write these as comments (and keep them there to explain to other programmers) You might be interested in [literate programming](http://en.wikipedia.org/wiki/Literate_programming).
With anaconda python this chicken-egg problem is no problem at all!
well, I am simply speechless
pycharm seems to be gaining steam but I'm sticking with pydev for now. I wish I could support it some more.
I totally get what he's saying, and you're right. That *should* be the case. What I was getting at is he's really making a big fuss over what is essentially nothing. All of the examples listed have at least one "private" class that you probably shouldn't be mucking with unless you are working in Python internals. In short: not ideal. But like you say, largely a non-issue.
In python 2.x `input` is basically `eval(raw_input())`
Feel free to explain; that's not a very helpful comment.
I am intrigued by your ideas and would like to subscribe to your newsletter. Where can I send correspondence?
Thanks u/fabioz; I use PyDev all the time and am happy to support you. Keep up the awesome work!
Great! Looks like a great update.
Keep in mind the a computer will run python without any complaints. I don't know much about trojaning in it but if you want to create spyware it's a good language. All of the anti virus programs will see your code and say, this looks like normal python code, and then move on.
&gt; not a programming language Lol
&gt; Lol Was I wrong?
Python is used extensively in the security industry, as are other scripting languages. It can be used in malware for higher-level tasks, but depending on how advanced the malware is, lower-level languages are almost always involved. Flame, for example, used Lua.
This is really awesome!
here's me with 5 minutes in the interpreter data = """ &lt;li id="metal_box" class="metal tooltipHTML" title="Metal:| &amp;lt;table class=&amp;quot;resourceTooltip&amp;quot;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Available:&amp;lt;/th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;&amp;quot;&amp;gt;3.064&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Storage capacity:&amp;lt;/th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;&amp;quot;&amp;gt;10.000&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Current production:&amp;lt;/th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;undermark&amp;quot;&amp;gt;+544&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;Den Capacity:&amp;lt;/th&amp;gt; &amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;overermark&amp;quot;&amp;gt;0&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt;"&gt; &lt;div class="resourceIcon metal"&gt;&lt;/div&gt; &lt;span class="value"&gt; &lt;span id="resources_metal" class=""&gt; 3.064 &lt;/span&gt; &lt;/span&gt; &lt;/li&gt;""" import BeautifulSoup as bs bsdata = bs.BeautifulSoup(data) bstdata = bs.BeautifulSoup(dict(bsdata.li.attrs)["title"]) [x.text for x in bstdata.findAll("span")] &gt;&gt;&gt; [u'3.064', u'10.000', u'+544', u'0'] FOR THE INTERNET POINTS!!!!
What?! Python compiles to byte code in case of the CPython implementation.
/r/learnpython
so to elaborate, I am simply speechless that you had better luck with regexs over beautifulsoup based on how the above was solved without even having to import re
Amazes me a lot of MATPLOTLIB users don't know that there are 2 API styles. There's the MATLAB way and there's the [OO way](http://nbviewer.ipython.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-4-Matplotlib.ipynb)
For future reference, questions like this should be asked in /r/learnpython. Anyways. From cmd you can type (provided you are in the right directory): python scriptname.py From the shell you can type (provided you are in the right directory): execfile("scriptname.py")
I have encountered 2 different pieces of python based malware in the past month or so. Typically you see php for remote access tools and perl for connecting to command and control due to demonstration issues with php. The two samples mentioned connected back to a command and control server and ran commands pasted to the channel as with 90% of all malware code i deal with, the programmers were exceptionally bad (not obfuscation, just really really bad code)
One of the things that is planned is a script to automate the installation of our many printers and make it easy to keep up to date, we currently have a few fragmented scripts for some of our ricoh and xerox stuff but if we add a printer we have to duplicate that entire script. So i'd like to use something like a Json file that can be easily updated to add new printers.
Docopt parses the help text so it must already have a parser. I wonder if you could take their parsed structure and convert to whatever you use?
I think it's because the documentation is just a mess. I mean, everything you need to know is there, but it's not organized in any sort of intuitive way at all. It's been gradually getting better over time, but it still needs a lot of work, especially when compared to a lot of other python packages.
Nice job on this. I'll be using and contributing back. My application requires dynamic interpretation of CSV files of varying types. I'll be automatically generating the models by interpreting the inbound data then running it through your code. Thanks!
We ancient Romans remember something called "wax tablets" that were 80 characters wide before they invented punched cards!
I was not aware this capability was built into Python. There are definitely times when I want to force a mock to behave aberrantly to make sure I'm handling the behavior correctly. This allows me to avoid creating a whole new mock just to have it return a stream of random bytes for a single test. 
When you copy file you not only write file to new location, but also modify last access time, creation time and so on. Second record can be related to applying file attributes. Do you have option to parse watchdog events before creating events in celery? If so probably you can throttle log using multithreading. You can create timer for parsing events with 500 ms and drop it if event occur earlier.
When I design something new, I think about the API and the consumer of the API at every level. I've found that focusing on the API naturally flows to a working, scalable design with less refactoring later. This is especially true if you can focus on creating atomic pieces of code that are re-usable. Regardless if you push the code into a class or keep it in a function, each code piece should do one thing really well. That said, every piece of software is a work in progress and software happens iteratively over time. Each time you program in a domain, you'll have a better understanding of how to approach the design work for that domain. Asking your team (if you have a team) can be beneficial because you'll get a different perspective of what's useful. And always expect that your requirements will change, causing a rewrite. As an example, file reading and writing is generally something that is done in scripting as well as general purpose coding. To focus this example, let's suppose we know we need to dump out data into a file. We might write it like this: def write(data): file_descriptor = open('/some/path/to/file/filename.extension', 'w') file_descriptor.write(data) This does the job (dumping out data to a file), but it doesn't lend itself well when we want to write out two files. So the iterative approach is: def write(data, filepath): file_descriptor = open(filepath, 'w') file_descriptor.write(data) So that was great, but it turns out your buddy wants it to work on a windows machine. And now you could write two functions, but it'd be better to keep it in one. import sys def write(data, filepath): mode = "b" if sys.platform.startswith("win") else "" file_descriptor = open(filepath, 'w' + mode) file_descriptor.write(data) Later on, though, someone attempts to write to a folder that doesn't exist, and your script ends up killing the entire process. For whatever reason, you need the process to complete. So now you add: import os import sys def write(data, filepath): mode = "b" if sys.platform.startswith("win") else "" base_folder = os.path.dirname(filepath) if not os.path.exists(base_folder): print &gt;&gt; sys.err, "Warning: Path cannot be found, '%s'" % base_folder else: file_descriptor = open(filepath, 'w' + mode) file_descriptor.write(data) Over time, you start to use this script everywhere, and you notice that you're missing data or you end up possibly running out of file descriptors. Looking back, you realize that you're not actually closing the file descriptor after you use it. So you fix that... import os import sys def write(data, filepath): mode = "b" if sys.platform.startswith("win") else "" base_folder = os.path.dirname(filepath) if not os.path.exists(base_folder): print &gt;&gt; sys.err, "Warning: Path cannot be found, '%s'" % base_folder else: with open(filepath, 'w' + mode) as file_descriptor: file_descriptor.write(data) The point, though for all of this is that with the exception of the second iteration, so far we've not changed the API of the write function even though we've touched a lot of the underlying code. I'll give you one more idea to chew on to highlight this. So yesterday, your pal programmer decides that he wants to dump a 20GB file. Unfortunately, your machine only has 8GB of memory and cannot handle a 20GB file in-memory. So, what you do is ask your pal to stream it, and then update your function again... from collections import Iterable import os import sys def write(data, filepath): mode = "b" if sys.platform.startswith("win") else "" base_folder = os.path.dirname(filepath) if not os.path.exists(base_folder): print &gt;&gt; sys.err, "Warning: Path cannot be found, '%s'" % base_folder else: with open(filepath, 'w' + mode) as file_descriptor: if isinstance(data, basestr): file_descriptor.write(data) elif isinstance(data, Iterable): for string in data: file_descriptor.write(string) You might have been able to guess all of this at the start -- but likely that would have only happened if you had experience writing a 'write' function before. I realize this is a trivial example and not necessarily helpful everywhere, but focusing on a good, simple API can really help alleviate long-term struggles. Good luck!
For the first part, `dtach`. It is effectively the ability to attach and detach to processes, and that's it.
Python is a programming language and it is Turing complete. I'm not sure what gives you the impression it isn't a programming language.
I thought this article was awesome. As a new python programmer I've been trying to find "starter" projects and I feel this an awesome springboard project for new people like myself.
What if you wanted minimal log data in your stdout and a giant bulk of data in logs on the side?
The terminal is ephemeral, you lose it when you close it. While logging to a file could be used for later reference. Also, logging to a file is more accessible (ie: better search, historical views or charting it).
very nice!
The question might seem to target scripts but Python is also used for persistent apps.
You say you "can't hack on it", but of course you can. You want a clone of Taskwarrior just so you can avoid hacking in anything other than Python? That's weird. I like Scala, but you don't see me abandoning perfectly good software just because it's not written in Scala. I program in C, Java, Perl, PHP, PostScript, and anything else that needs programming.
Ops. Sorry for putting it in the wrong one, and that doesn't work. The cmd way says python is not recognized as a command and the shell way says it is not found. Why don't they just put a "Run" button at the top?
 import logging logging.basicConfig(level=INFO) logging.debug("entering foo") foo() logging.debug("leaving foo") vs import subprocess try: subprocess.check_output(['echo', 'entering foo']) except subprocess.CalledProcessError: pass # probably on windows, so /bin/echo doesn't exist &amp; therefore neither does logging by this method foo() try: subprocess.check_output(['echo', 'leaving foo']) except subprocess.CalledProcessError: pass # this is really ugly OP, If you can understand why the latter example isn't even as powerful as stdlib's 'logging' module (compare both examples), then you'll probably answer your own question. 
Python 3. Never plan to use python 2
You'd think that they would have but i'm honestly not real sure...
Im just starting to teach myself code and was curious about this. Went for 2.7.4 but didnt really give it much thought. Anyone with experience in both care to chime in? Thanks. 
I don't mean to be a negative nancy, but this question has been asked hundreds of times by now. If I type in "python 2 3" in the search bar just for /r/python, I get a thread in the top fiveish wth 45 replies. So...please do a basic search (if nothing else in the subreddit you're asking in) before you ask a question. Thanks!
Because the way I see it, there are only three real reasons that people stay with python2: 1. They're lazy. not a good excuse. 1. They're required to by a business. It's not their fault, but I'm not required to so I don't need to. 1. Because there aren't enough packages ported over to python3. A mildly good reason, but I feel like enough packages are now ported over that you can make do. And if one isn't, then you should create one or port it over rather than sticking with an old version. There's been a lot of work done in python 3 and I don't think it's a good idea to stay behind.
Appreciate the logical feedback and concise response. Ill be switching over to 3:-) Should I expect any of the old Fall 08 MIT ocw videos/assignments to not work smoothly with 3?
But 'lazy' is ... No, wait, that's Perl.
Kiwi Pycon ... the best little Pycon ... by a long way. Come to beautiful Wellington for a weekend of tasty Pycon. [Register now or miss out on the tee-shirts.](https://register.nzpug.org/page-1765945#idUpcomingEvent_1712963) 
If all goes well you should see Saturday talks appear on YouTube on Sunday, and all talks online by end of Monday.
I think this question has been emerging as part of the ["12 Factor App"](http://12factor.net/logs). I *think* the motivation to have separate external services take this job over from the application are: * it simplifies app development * these services are always available anyway * log management, if done poorly, could interfere with log consolidation * it centralizes log management and viewing, which is highly valuable if you're deploying to a bunch of hosts However, this doesn't mean that you wouldn't use a logging module - even if writing to stdout: minimally, the logger can ensure valuable and consistent formatting. Personally, I prefer to set up my logging so that I can control log levels, destinations, outputs (stdout and/or file) from a config file, env var, or arg. That way when I deploy to a small environment I get the benefit of managed logs, and if I deploy to a larger environment it can play nicely there as well. The key is to use a library to simplify this and eliminate as much code as possible. Especially, if you need to deploy dozens of apps.
it's also in the fucking sidebar on this very subreddit
You might need to add python to your path. Are you on Windows? If so, google "how to add python to path"
Thanks! I wouldn't have realised this was on if you hadn't posted this. Coming down for the AB's v SA game. May as well see this also!
Hope it was accompanied by several lines of comments explaining what it does and how incredibly important it is.
Python 3 has better syntax and most of the modules are repaired and they added a few more. 
That's also a good point. The sidebar is 5,000 lines long though, so it's not the most useful resource.
I used to simply just do a bit of the programing and the way I debug my program is by just printing everything out in the shell. For instance every now and then if I feel as thought my program isnt working properly I would go inside of the program and make it print the line number and then run it. If i find out that the most recent line is 70 and I went up to 90 I would know that somewhere between 70 and 80 I had messed up. Isnt logging exactly the same??
I'm sad this isn't the highest rated reply. 
Great article written by one of our newer team members!
Took a quick peek around, so don't sue me, but looks like this is highly configurable, and with the bytecode cache could even save the time with the initial compile even https://github.com/mitsuhiko/jinja2/blob/master/jinja2/environment.py ... I imagine these settings give a balance for development work, while it makes sense in production one would want to cache as much as possible.
&gt; They're lazy. not a good excuse. if ever library authors get death threats for not porting in accordance with someone elses timetables, it will probably be this guy leading the charge
sysadmins hate him!
This thread has been linked to from elsewhere on reddit. - [/r/cem1790] [How to improve PLANNING out your program. (build) • /r/Python](http://np.reddit.com/r/cem1790/comments/2es7k5/how_to_improve_planning_out_your_program_build/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
Is there any way to use this debugger outside of the IDE, even as a rudimentary API from a python prompt? 
haha yes linkbaity but also a fact. the template cache is sort of hidden in the docs, so I bet a bunch of flask users face the same issue.
Why would you want the Twitter feed to be a *template*, rather than data to feed *into* a template? Or, depending on what you're doing, something created entirely client-side with JS, as most third-party widgets are? If you're statically baking "quickly updating data" into templates, you're doing it wrong.
grok remember stone tablet have room for 80 grunts
A template being "compiled" just means that it's ready to be executed with whatever values you pass into it (it's already parsed, lexed, and ready to go). You're confusing that with caching the output of a rendered template.
You got to remember that reddit was written with Pylons about 7 or so years ago. At the time the popular python frameworks were Django, Pylons and Zope 2. I don't know who or why they chose Pylons, but it was a good choice at the time. Django was more about automating work with Models and UI (neither of which provide any benefit to a use-case like reddit). Zope 2 was outdated and oddball. Pylons was relatively small, clean and simple (but not a microframework like CherryPy or Flask). Pyramid is the spiritual successor to Pylons. It's pretty much a complete rewrite, but it maintains design goals that fill the same niche as Pylons, as a light-to-mediumweight framework. 
In this case, a template is any UI element and anything *static* within it. The purpose of the template cache is to do all of the work assembling the templates up front so only the dynamic contents of those templates need to be loaded after that.
Ran into a similar limitation with Django at my old job. A related concept you can use is partial caching: http://www.holovaty.com/writing/django-two-phased-rendering/
Part of research into wheels includes consulting the community. Not only the development community, but also the operations / system-admin community. They would gladly point you to existing tools. There's generally not anything new under the sun. There's a better mouse trap, sure. I encourage you to pursue with vigor the better mouse traps.
Yeah I'm doing everything client side. Much faster rendering.
You can do that if there is a terminal to output to. However, in many environments (like web-apps and games), it is massively inconvenient to debug using print statements. Logging is a lifesaver when it comes to those.
Awesome. This kind of collaboration is one of the things I enjoy seeing all the time in Python.
Hi Reddit! Just wanted to post a link to a framework I developed as part of the work I and others do at our company. While building large systems in Python, we found that it became difficult to reason about different system components and their dependencies. Epoxy makes dependencies between system components explicit which leads to more maintainable architectures for large systems. We have used Epoxy on several real projects in the 20-50KLOC range with great success. Also, should be noted that Epoxy is available on pypi: https://pypi.python.org/pypi/epoxy Edit: Typo
*ten years from now* "What the hell is medium.com?"
Although the same rules apply. Why are you doing development work without debug middleware?
**Python style guide style guide** 1. Correct grammar is important. 2. Correct spelling is also important. 3. Some abbreviations detract from the message. 
You don't compile a template with data, you render a template with data. They're two different things, blog post is about the former.
http://www.codecademy.com/ http://www.checkio.org/ Hope it helps.
I'd check those too, and have a look at [edX.org](http://edx.org) as well when you feel more confident. I believe there's a course with some python in it.
Wouldn't that be the first thing a developer would check if they wanted to improve performnace?
Read the documentation? What are you, a communist?
No i'm a Pinko. I never read it for myself, I just get people to read it for me, write blog posts about it and then I read those. Holy shit that sounds much worse. I'm a commie bastard.
No, use them as you need.
http://python2web.com/python-design-patterns/ at the 23 minute mark the presenter gives some real good advice on how to handle deeply nested if structures. 
http://getoneline.com/index.html is slightly more informative, but it's still not clear to me what the main goal of the project is. How does it compare to, say, sockets.io?
I get that this was done in Flask, but this is more applicable to Jinja2. I use Pyramid but not internal renderers, this problem is easily averted by setting cache_size=-1 on the Environment initialisation.
lol no. I just open up notepad and type random characters until I get a google-killer. I'm a one man infinite-monkey-army.
Yes that's great thank you :D
The article is talking about template loader cache, not caching rendered templates. This is the comparable Django feature: https://docs.djangoproject.com/en/dev/ref/templates/api/#django.template.loaders.cached.Loader
That course is literally starting today too, nice catch! 
Hi! edX.org looks like just what I need! However.. I can't find the Python course? Is it covered in the Introduction to Computer Science, or is there an individual modual?
I believe it is [THIS](https://www.edx.org/course/mitx/mitx-6-00-1x-introduction-computer-2841) one.
&gt;I get that this was done in Flask, but this is more applicable to Jinja2 It was submitted to r/python so it's relevant either way.
http://www.aaronsw.com/weblog/rewritingreddit
You can create malware with about anything. Even unintentionally. My first attempt at a daemon was a creature much like a Hydra. Traditionally, viruses are programmed in assembly. Since most windows machines do not have python from factory, it is probably not largely used for this purpose. However many network security tools are programmed in it. 
Neither of the links on the Youtube video page work, try here: http://www.dabeaz.com/finalgenerator/
Yeah, linkrot in your comments is fatal: # !!! VERY IMPORTANT, see http://bit.ly/abcde !!! Ah shit, now we'll never know.
What's print? $ man print No manual entry for print $ man echo ECHO(1) .... It helps to run commands that actually exist, to avoid activating that exception clause. If print is a builtin in some shell, then the subprocess line becomes something like: subprocess.check_output(['whatever_that_shell_is','-c','print','\"entering foo\"']) It's ugly and stupid compared to using the logging module. 
Not really... it's currently meant to be used through sockets -- https://github.com/fabioz/PyDev.Debugger/blob/development/tests_python/test_debugger.py has some test cases which write messages for breakpoints, stepping, etc and checks returns, but there's currently no easy to use command line API that does that (but pull requests for that would be welcome).
The unicode post demonstrated he hadn't read the python manual. If that's perfection... it explains the -30 on my defence of Python in /r/Python against this persistent click-bait troll. 
Thanks for sharing. I'll probably be using it someday, either as is or as an inspiration for an homegrown solution, which may also include elements/ideas from Alec Thomas' Injector, Martijn Faassen's Reg, Armin Ronacher's PluginBase, Doug Helmann's Stevedore and/or other similar projects.
&gt; Such as some Twitter feed or something. First of, that wouldn't be in the template, secondly, you probably should be doing with with an Ajax call regardless.
/r/learnpython
Is there a server listening on ("127.0.0.1", 21)?
Unless there is a service listening on port 21 of localhost, that's the expected behavior -- if there's nothing listening, it's impossible to make a connection, so the connection is refused. Port 21 is generally used by the ftp service. Make sure to read the surrounding context of the exercise to see if it assumes that you have a ftp server running when executing this snippet. 
Its tricky because I want to input it into a form that's already created. It might take a while to research it.
Very nice ! I did some experiments with shoebot* and music visualisation, but as it is based on cairo, the speed isn't so good. I'll have a play with this when I get some time, looks good ! *Disclaimer - I am one of the devs on shoebot.
Ah okay, makes sense. Thanks for clearing that up!
Awesome, I look forward to watching.
Thanks. Will look into it. 
This is what I call a inderect contribution.
7 years ago, Pylon's was awesome. Back then it felt like a toss up between Zope, CherryPy, and Pylons. I don't want to disparage Zope so will say it didn't seem viable ( I walked away from a few jobs with amazing benefits because they used Zope ). CherryPy mean while is really goddamn cool but its easy to shoot yourself in the foot with. Meanwhile Pylons felt really straightforward and easier to scale out.
It can be. And I'd say for that development it isn't that much better than a simple print statement. Where logging really shines is when your application goes into production. There it may run unattended, it may produce messages for administrators and not its users, and logging may capture similar messages coming out of dependent modules. In this latter case you could have millions of messages over time. Log rotation, consistent formatting, and log-levels make it *much* easier to manage these logs.
"debug middleware"?
abcde actually points to a page.
Yeah, I was surprised about that myself. I kinda hoped it'd be a bit more momentous, though.
Hello, So the goal of this project is not to provide bare bones implementation of websockets (like sockets.io or autobahn), more so a way to stream data provided a database. Data that changes rapidly -- for example 'lng' and 'lat' cooridnates. It does this by using websockets and (DAL) the database lib in web2py. In addition to this, provides a simple module architechure for all websockets code. For example if we wanted to write a RoR application, and one of this app's motivations was to stream data, we may find it difficult organizing all of this web socket code. Oneline gives you access to the same db, server side resources while pleasing one audience and that is websocket programmers.
I guess you know what your doing, how do I figure out what line an error occurred like in the shell? I think once I can do that logging would be great for me. 
Very good article. This is exactly what I was looking for. 
Four hours. FOUR HOURS. I've watched and learned from other Beazley videos, but the payback would have to be pretty big to give up a couple evenings of free time. Is it worth that investment to watch it vs, say, reading his slide set?
Here, this should point you in the right direction. my_list = [i**2 for i in range(1,11)] # Generates a list of squares of the numbers 1 - 10 f = open("output.txt", "w") for item in my_list: f.write(str(item) + "\n") f.close() I pulled this from [Codecademy](http://www.codecademy.com/courses/python-intermediate-en-OGNHh/0/1). Check out the link if you need further help. :)
I've been looking for something inspired by Edward Tufte's work, this look great!
Thanks. I'll try that once I get home
This is a little more pythonic: with open("output.txt", "w") as f: f.write("\n".join(my_list)) Explanation: "\n".join(my_list) would join the list into a single string with "\n" as the delimiter. with open("output.txt", "w") as f: would close the file automatically at the end of the block.
I just watched the first couple of minutes. Not only is it four hours long, he also says that this video is "Part 3 of a trilogy" of tutorials he has given on the subject. 
This was so dumb.
http://stackoverflow.com/questions/19683123/compile-latex-from-python http://stackoverflow.com/questions/8085520/generating-pdf-latex-with-python-script
Make it a habit to include your code and errors when asking for coding help.
He also mentions that you don't need to follow the first two if you're familiar with generators and coroutines in Python. The first one is a pretty basic over view of "Hey! You don't need to use generators to just calculate Fibonacci numbers. Here, process your log files with them." As well introducing coroutines. The slides are [here](http://www.dabeaz.com/generators/Generators.pdf). I can't find a video anywhere. The second one is more involved. [Slides](http://www.dabeaz.com/coroutines/Coroutines.pdf) [Video](http://blip.tv/pycon-us-videos-2009-2010-2011/a-curious-course-on-coroutines-and-concurrency-part-001-2006228)
I'll be honest, most of the content flew over my head. I happened to come across this while looking for more information on how to build coroutines in Python. However, it gives a lot of insight into the idea behind `asyncio` as well as a quick and dirty way to implement a sort of compiler.
Thanks, I was also looking to find a video for the first one but the slides will probably be good enough.
[Seaborn](http://web.stanford.edu/~mwaskom/software/seaborn/) is also nice and has some convenient data visualization functionality (e.g., nice plots of histograms with kernel density estimates).
Had a background in C/C++. Learned python on the job after being hired.
I like this approach because you're using "with open", but it may be more memory efficient to have a for loop in the "with" block rather than creating a giant string and writing the whole thing to a file at once. This would probably work since the list is small enough to fit into memory, but it would not generalize to a generator containing a lot more data. 
Pandas default is also amazing
Learned Ruby on Rails while finishing up my undergrad atmospheric science program. Interviewed a small data science tech startup that uses python. Got the job, learned python. Honestly if you know your stuff as a programmer ( I had experience with Java,C, mainly Ruby on Rails, also some MATLAB work ), learning python is not hard. It's actually easy, because the language is so silky smooth. There are some small syntax differences between other languages, but overall python is just a breeze to write! It's fun too =) My two cents for ya. List comphrehensions and dictionaries. Using the two of these things i'm able to create some pretty gnarly data structures in like 5 lines of code.
Are there any places online that you can be paid to complete jobs? Building applications for others or just doing work with python for others and getting paid? I am a college student and I'd like to work online. 
Everything makes sense but the windows support thing. Care to explain? 
Haha that's exactly my problem! I already know python and I've nearly completed my computer science degree, but everyone wants someone with .NET experience. Python is the language with which I'm most familiar and I love it. I guess I'm going to have to learn C/C++ and/or .NET to get a job, then find a Python job with that experience.
I'm curios what something like SQLAlchemy would look like.
Get your own web site, blog about your Python skills, contribute to projects, and email companies looking for Python programmers if they are interested in hiring a freelancer. Also try to figure out what's a good rate for your skills. A back on the napkin calculation that I've often recommended is to figure out what you would make in a full time job in a week, and divide that by 16 hrs. Avoid rent-a-coder, elancer, etc. like the plague.
It was an internship at a well known web company in Sydney. I had been at uni 1 year, and only learnt C (although I had dabbled in other things myself). First day of the job my manager says "Do you know python?" So the next 2 weeks was simply learning the company systems and python. In the remaining 8 weeks I worked on several projects in python (and led one myself) that made it into production. I guess my advice is that knowing python (or any language) is often secondary to being a good programmer in general, especially when starting out. If you can prove yourself as a good mind, then decent companies will be willing to invest in training you to learn whatever technologies help them. If that doesn't work, take some freelance work to show off your chops
I just started using Python.
In 2006 I was at NASA and interested in Python. At that time I was on a Java project and had a problem getting JNDI to work with a mis-customized instance of Active Directory. Fortunately, python-ldap was our workaround and it became a component of the project. The project was having some delays for various reasons, one of them being frequent requirements changes were hard to manage. Especially the way the Java application had been structured. One day, when my boss left, I spent 90 minutes and had the project working in 100% Python. Since I/O was the only bottleneck, performance wasn't an issue, in fact, by only using Python we didn't have to use a custom-interchange between systems (in those days interchange meant 'SOAP'). Since then, except for a few unfortunate occasions, Python has been my primary coding tool.
Thanks!
I really appreciate the information. Now I know what to do! 
i think more than 7 years ago, turbogears was built on top of cherrypy
Did JavaScript, PHP, and Java at uni. My first job was switching from PHP to python. Now I'm tech lead and we are staying with Python. I want to focus on Flask but the money for the company is in Django. :P
its not a catch 22. your experience doesn't have to specifically be in Python. learning a new language is not a big deal. if you've got experience doing professional software development in just about any language then you should go ahead and apply to a Python shop if you think it would be a good place to work.
don't feel obligated to learn a specific technology. developers learn new technologies for new jobs all the time. apply to any job that you want to work at. especially in your case, where you're still a student and will be applying for junior positions. by definition a junior engineer is learning on the job.
Definetely not everyone, probably the most aren't. But times are changing, and I see a lot of students failing to get jobs because they literally haven't done anything yet.CS is merely an intro, not experience, and real experience is incredible valuable. Which does definetely not mean convential education doesn't matter. With that being said, there might also be huge differences geographically, I can't really say anything about the state of things in the US. Imho free-time coding is also good because you want to live off something you have fun at. If you exclusively code at work, chances are you don't really like doing it. I wouldn't want to do something potentially this boring for 50 years of my lifetime if I woudn't like it this much.
Started my own company.
I got hired because I kinda knew Perl and 3/4 of the companies' code was written in Perl (of course without using "use strict"). I got better at that horrific language and fixed thousands of bugs over the span of 6 months. Then I picked up Python for a new project and in 3 weeks I was better at it than Perl. After 6 months, I went back to a certain part of that old program and rewrote one of the infinitely buggy modules in 3 days in Python. I never had a problem again with that module.
Thanks, I'll have a look when I have time tomorrow - it sounds just like something I'd love. I like prettyplotlib, simply because you can use all the default pyplot commands and it puts out lovely stuff instead :).
I'm pretty sure prettyplot is doing it in matplotlib, it just gives you nice defaults - pretty plots with no work. 
I went to a local Python meetup where we were asked to introduce ourselves. I mentioend a few projects that I had contributed extensively to (Kivy and pySFML to be exact) and jokingly mentioned that if anyone was looking for a quota to fill, I was looking for work. About a week later, one of the directors from work reached out and asked me to interview. I probably got lucky, but considering the number of jobs I applied for online, I think I'm a prime example of how it's not what you know, but who you know. Specifically, it wasn't having X number of hours logged or years of "professional" experience that got me this job, but my passion for coding, local networking, and a decent github profile that did. While it does prove challenging being so "green", it's a joy working with a group of diverse bright individuals creating open source software.
I just realized I never finished the title: Prettyplotlib produces beautiful graphs by default, by simply wrapping over matplotlib.
Technical director job at a major visual effects studio. They had their own programming language for their applications but I ended up building a lot of standalone utilities in python to make my job easier. Ended up mainly doing that, then getting hired to primarily do that at another feature film studio.
It's not bad, it mostly just makes plotting much easier. Does anyone know if we can trick pandas into using this? [ggplot](https://github.com/yhat/ggplot) for python is slowly coming along and is a joy to use and look at with pandas. Note that there's still a lot in the R version not yet implemented in python.
I applied to a few jobs on Indeed. Found one that needed Python and data.
Nice package! Some questions: 1. Ever consider just patching matplotlib to make these the default? 2. The histogram grid looks ugly to me. If your grid is "finer", then your style will be hard to read for bars not near the edges. 3. I think I prefer the wider boxes in the boxplot.
Ha can't resist. I know exactly what you mean but by that definition we are all junior engineers. :-)
Perseverance, confidence, and maybe a little luck. I am currently about a year and a half into my first job. I was a plumber and had very light hobby coding experience before that. In prep for beginning a new career I taught myself sql in fairly good depth. Then found a company that was willing to teach me Python. I found that I got a lot better mileage if I was able to hand someone my resume in person. I only had to do that a few times before I got the job I am at now. Been a great time with lots of learning and lots of determination at times.
"Dis ain't no uglyplotlib" - Anonymous
I started out as a help desk technician at a Fortune 50 company, working nights and weekends. The catch was that it was the most boring job in the world, since after they hired me, they forgot to tell our customers that we were now open nights and weekends. Most nights I just surfed the net til I dropped. Unfulfilled, I decided to learn how to program. First learned PHP, then Perl, then ultimately settled on Python for its readability. I was a first tier help desk technician, which meant that we troubleshot problems up to a certain point and then routed them to the second tier as necessary. Each of the second tier groups had their own knowledge base. The Lotus Notes tier 2 had a Lotus Notes DB with how to fix common Lotus Notes problems, while the Microsoft guys had a Microsoft SharePoint. None of this knowledge was accessible to Tier 1, generally, so I stayed late (early) to broker deals with Tier 2: If they let me have access to their knowledge bases, I would stop waking them up in the middle of the night. Because of my general competence, they allowed this. Ultimately, it was pretty unsatisfying, having to log in to 8 different databases, so I wrote a crawler that centralized all the knowledge, and then ultimately turned that into their knowledge base. Later, they realized that this knowledge base was great, so they created a position for me to maintain it, add features, all that jazz. That was my first "Python position". It's still their enterprise knowledge base to this day. 
I had a non-programming job, but dealt with large spreadsheets, reports, inventory counts, and other data sets daily. I learned python on the side and automated some of the more tedious and time consuming tasks. About that time a local initiative called [LaunchCode](http://www.launchcode.org/) formed and I got placed with a company a few weeks after I applied. I've been working in python/Django for about a year now.
Check out pytool.readthedocs.org - library I wrote which in pytool.lang has a Namespace class, which does this. 
I think someone used to Python would think that interacting with a dict using dot notation was as ugly as you consider key notation to be. It's just not a part of the language; it's like asking why Python doesn't have pointers or require a main() function.
And yet, enough people wanted NamedTuple for it to be added to the language - and they seem to occupy relatively similar use cases that are primarily about ease of readability. Also, except for the json part, I could also write: foo = lambda : None foo.a = 1 foo.b = 'banana' foo.c = 'saw' so the language has already has an allowance for this sort of flexibility. Just not for dicts, or objects. That's different from the issue of pointers and requiring main(); both of those are more than 'syntactic sugar', they are semantic. Since Python is all about readability, I am wondering why there is no such standard object. 
[This](http://stackoverflow.com/questions/1305532/convert-python-dict-to-object) is a nice way to do it: class Struct: def __init__(self, **entries): self.__dict__.update(entries) 
We're still working out different API approaches in Bokeh, but converging on one that uses "with" statements and such. The API design challenge for Bokeh is that we also want people to be able to link widgets alongside graph elements, for easy construction of web dashboards... It's going to take a little work but ideas and suggestions are very welcome: https://github.com/ContinuumIO/bokeh/issues/1087 https://github.com/ContinuumIO/bokeh/issues/1088 
Thank you for sharing! I'm very happy you've been able to follow easily. Cheers.
Thanks for the Chaco mention. If you want to do Chaco-like things with Python 3, and don't mind it being a web interface, you should look at Bokeh: http://bokeh.pydata.org It's still a work in progress but many of the same core ideas are there, with some improvements (e.g. incorporating graphing ideas from d3/protovis). I am also keeping an eye on Vispy, and would like to see a future when it's the primary non-web backend for Bokeh...
Well, but then: foo = Struct({'a':1, 'b':'banana'}) print foo.b works, but foo.c = 'saw' fails. 
And we even support this style in Bokeh's Matplotlib interface: http://bokeh.pydata.org/docs/gallery/xkcd_density.html
JavaScript does this, and true it works well. But keys in JavaScript objects are limited to strings (afaik), whereas keys in python are restricted only by their inability to produce a hash.
Most python programmers I know start in Java, C/C++, or .Net and pick up Python on the job. It seems like very few people start in Python. Based on that I might advise you to get work in .Net or Java, or something else that you know at a shop that was planning to transition to Python later.
Haha, not my package, I was tired of the shitty matplotlib plots, so I google pretty plotting Python and this popped up. I thought I'd share if anyone else wanted to have a look. It's the same syntax as matplotlib, which makes it easy to use. I agree on all counts, maybe I'll message the author (or you could) with the suggestions. 
&gt; I think someone used to Python would think that interacting with a dict using dot notation was as ugly as you consider key notation to be. Subjectively, I cringe at the notion of accessing a dict with dot notation. I don't know why, it just seems wrong. 
I use this implementation: class DotDict(dict): def __init__(self, **kwds): self.update(kwds) self.__dict__ = self
See, that's the thing I'm trying to understand. I was just reviewing some code that had like a 25 line code block inside a try block, followed by: except: pass and I my gut response was, um, unpleasant. The code smell, it burns!! But I'm also able to give a reason why it's a code smell, once I calm down enough to stop dancing around in agitation. Most pythonic idioms are backed up by a Story. I don't understand the 'code smell' of DotDict or the Story of why it's not in collections, unless that it's just not the way we always used to do back in the day... hey you kids, get off of my lawn! :) 
From my point of view, dot notation is for objects, and indexing is for data structures. Using dot notation to access data inside dicts means there will be confusion between actual data and methods/internals (remember, Python doesn't have external visibility controls) and that disallows you to have keys like 'update' (because that's a method and accessing it will be ambiguous) and gives you a thousand more ways to shoot yourself in the foot. JavaScript made the same mistake with objects vs. dicts and backfired for them. 
This question is like Flask vs Django - always appears from time to time. Again and again. Because pythons dict has methods, and it would be confusing if You'll assign value with key 'keys' or 'items' for example. Thats why, because simple better then easy. And yes, You can create Your own dict, with blackjack and ...
Okay, I like that better than my solution! But as I have edited in my OP, WHY isn't that a standard option in, say, collections? I assume it is because there is some argument against? Because "easier to type one character rather than 4 characters" seems like a good argument in favor...
That's the sort of opinion I was hoping for. Thanks! My opinion on this point of view is that there are many simple situations where I know I will not step on my own feet in that way. Perhaps if the class was called "DangerousDottedDict"? :)
Okay that made me literally laugh out loud. Thanks! It's not that I'm more familiar with one syntax than the other. Just as I prefer "x in X" over X.indexOf(x)&gt;=0" while they end up meaning the same thing, I certainly want to look for the advantages of one idiom over another in any language I work in. So I'm curious that the "DotDict" idiom is so unsupported; yes, you can shoot your foot with it if you're sloppy, but all the same, Python is the language for adults, isn't it?
Sometimes it's difficult to make the distinction about which code should go into the UI layer, and which one should go into a lower layer. My "mental guideline" for this is: Everything which deals with user input and output (sanitation, formatting and parsing) should go into the UI layer. Everything else is pushed down.
How do you like it?
Dictionaries are faster than classes.
Why would one use a count limit on cache size? Especially such a low limit? A timeout could be the primary method of expiration; an explicit memory-size-limit with some cache invalidation would be a relatively correct one; and since it's in the worker process memory, a restart would clean up the caches anyway (which means it could make sense to re-fill them on start). But even all that is for a some general case; if the thing being cached is a function of source code and nothing else (i.e. parsed templates) it could easily always be cached entirely in memory and/or in the way pyc-files are used (e.g. precompilation on packaging/installation/distribution/rollout).
How would your DotDict deal with an immutable object as a key? Here's a contrived example: d[('f','o', 'o')] = 'bar' How would reference that value? ('f', 'o', 'o')'s repr or str (which is ('f', 'o', 'o') btw)? The return values for those are different for different objects and in this example it would look like: d.('f', 'o', 'o') # this doesn't make sense to me as is, this doesn't work (it could if someone really wants it too) d.get(('f', 'o', 'o')) # this will work but seems counter to your goal of a single dot? By accessing elements that way your actually limiting the number of objects that you can use as keys basically down to strings without spaces which can be a really severe limitation for a supposedly generic data structure.
If you want to use dot syntax just use a class. All the class variable are dot accessible. 
it sacrifices consistency, and is error-prone than vanilla dict, and doesn't provide extra readability, and no extra functionality, easy to DIY, already many 3rd party libraries. it's too trivial to show up in BDFL's radar. (until we had a decent PEP for that)
Yah, your edit is where I agree with you: justifications for such object definitions "don't scale well" :). 
There is definitely a cost to requiring that components in Epoxy know about the framework (by inheriting from Component and calling out dependencies explicitly). Prior to building Epoxy, we did constructor dependency injection. It worked well, but it was still very easy to lose track of the big picture architecture and having to worry about instantiating the object graph was a pain. As an added side benefit of making everything explicit, we are now able to programmatically reason about the program's dependency graph (at least for components). For a talk I gave recently, I was able to whip this script together to output the dependency graph for a large application: from epoxy.configuration import YamlConfigurationLoader from epoxy.core import ComponentManager import networkx import matplotlib.pyplot as plt plt.clf() loader = YamlConfigurationLoader("src/epoxy-root.yml") config = loader.load_configuration() mgr = ComponentManager() graph = mgr.build_component_graph(config) dg = networkx.DiGraph() dg.add_nodes_from(graph.nodes) for a, b in graph.edges: dg.add_path([a.name, b.name]) pos = networkx.graphviz_layout(dg, prog='dot', args='') networkx.draw(dg, pos, node_size=20, width=0.2, alpha=0.35, node_color='blue', with_labels=True, node_shape='o', font_size=1) plt.savefig("deps-lowres.png", dpi=256) plt.savefig("deps-highres.png", dpi=1024) Which generated this diagram showing the dependencies and relationship between concretions of components in a particular configuration of the system: http://i.imgur.com/FVDpQuG.png 
I don't get it... what's wrong with this? &gt;&gt;&gt; class X: pass ... &gt;&gt;&gt; x=X() &gt;&gt;&gt; x.foo=4 &gt;&gt;&gt; x.bar=5 &gt;&gt;&gt; &gt;&gt;&gt; print x.foo 4 &gt;&gt;&gt; json.dumps(x.__dict__) '{"foo": 4, "bar": 5}' &gt;&gt;&gt; s= json.dumps(x.__dict__) &gt;&gt;&gt; q=X() &gt;&gt;&gt; q.__dict__.update(json.loads(s)) &gt;&gt;&gt; q.foo 4 
Awesome, would love to hear your feedback if you end up using it.
Just curious, what is bad about those sites?
Actually, I think the one you say would work would actually fail (it's using keyword syntax, not taking a dict), and the one you say would fail looks like it would work fine. The actual issue with it is that it's not going to act like a dict, just like a struct - so stuff like your json.dumps() call would fail on it. Though one cheap and dirty way of doing that would be making a dictionary use itself as its own `__dict__`, rather than just copy it. Ie: class Struct(dict): def __init__(self, *args, **kwargs): super(Struct, self).__init__(*args, **kwargs) self.__dict__ = self &gt;&gt;&gt; foo=Struct(a=1, b='bananas') &gt;&gt;&gt; foo.c='saw' &gt;&gt;&gt; foo {'b': 'bananas', 'a': 1, 'c': 'saw'} 
If there's a `pop` method on dict classes, and a `pop` value within your data, what should you get when you use `dict.pop`?
Nothing is 'wrong' with it, but it fails to be consistent with what I want from a dict-like object. For example, given your x = X(): then what is len(x)? 
Damn and to think I had to learn all those things the old fashioned way with djangobook and stack overload so I could hack together some shit tier code.
Check out the Python video courses on pluralsight.com: http://beta.pluralsight.com/courses/python-fundamentals http://beta.pluralsight.com/courses/python-beyond-basics We plan to have an "advanced" one later this year as well.
just skim through the slides ;)
Also if you are looking for high quality, beginner friendly, Django tutorials, don't miss one hosted by Django Girls: http://tutorial.djangogirls.org/ It's not limited to Django, but explains how to set up Python, HTML, CSS, JavaScript, database, etc. components you are playing with. Suitable for absolute beginners who have little idea where they are diving into.
Seaborn does the same. It does have some added plotting functionality that is very nice, but even if you don't use those, and just use the matplotlib plotting functions, the default rc params will be modified by Seaborn so that default plot options are much more aesthetically pleasing. 
A dotted dict would have several limitations compared to a dictionary. Here are some which spring to mind: Dictionaries can use anything that can be hashed as a key whereas a dotted dict could only use strings d = {None: 'nothing', (1, '17'): 'something'} # No hope of doing this with a dotdict ddict.None ddict.(1, '17') ... You're also limited to only keys that happen to be to be valid python variable names d = {'None': None, 'hello world': 'HI', '12': 12} # DotDict could not implement any of these ddict.None ddict.hello world ddict.12 That being said, you could just tack on dot selection to a regular dict like so: class DotDict(dict): def __getattr__(self, item): if item in self: return self[item] raise AttributeError def __setattr__(self, key, value): if key in self: self[key] = value return raise AttributeError This is still a dict but you can now select items where the key is a) a string b) a valid python variable name and c) not the name of an existing dict property. 
There's https://pypi.python.org/pypi/bunch https://pypi.python.org/pypi/attrdict and probably tons more on pypi - just search. As to why is it not in the stdlib, it could be many reasons: Guido didn't like it; There was no one to champion the idea (write PEP etc); It's not really better than using a raw dict. 
Can you explain why? Are both cases not basically just a hash table lookup? And if you would be using `__slots__`, the class should be even faster.
Wait, i can see the full title with the default CSS, but not with the /r/Python CSS? Is there a one line maximum for your title rule or something?
I just skimmed over the code in `iblt.py` and noticed something strange in the `IBLT class`. Why do you have the names like `m` and `k` as class attributes? You then have `self.m = m` in the `__init__` method. It might well be that this is what you intended and I haven't read the code thoroughly. But a quick glance makes me think you've confused class attributes/variables vs. instance attributes/variables. This wouldn't mean your code wouldn't work. It's just that the variables defined at the class level are never used (which is fine but then why have them there). For example: class A(object): class_variable = None def __init__(self, v): self.class_variable = v &gt;&gt;&gt; a = A('hello') &gt;&gt;&gt; a.class_variable # This isn't the same class attribute defined outside __init__ 'hello' &gt;&gt;&gt; A.class_attribute None EDIT: P.S. Having said that, I just realized that's for documentation. My apologies. I still think it looks strange but apparently it's fairly common. :)
In my experience the biggest downside is that you're competing with *a lot* of people who are willing to do the same work for like an $1/hr, so finding a job can be harder - especially if you're just starting out.
Went to the launchwithcode site, its got basically no content and most of it is placeholders, seems kinda stupid to class it as "live". Would've been better off finishing the site before launching it.
&gt; JavaScript does this, and true it works well. Actually it doesn't work well at all, but that's because a mixed dictionary/object thingie is the *only* name-value data structure in JS, and this means that a lot of potential dictionary keys are already occupied by JS object internals. Innocent stuff like this can cause weird bugs: var job_finding_workflow_steps = { find: "Find a suitable job opening", apply: "Write a cover letter and resume and post it", interview: "Go to job interview", accept: "Accept the job", decline: "Decline job offer" }; And it gets worse when dictionaries are filled with user-supplied (i.e. untrusted) data...
not to be rude but dependency Injection and Inversion of control are related but different things. Your framework has no inversion of control : components are fully aware of been part of the framework. Inversion of control requires a container. Usually this container is the same "artefact" that bootstrap the Dependency injection stuff. I have seen your approach multiple times in different languages. A friend of mine have developed the definition of "perversion of control" since everything tries to control everything else. I respect you work but I don't think is the way to go.
So much better since it is a written document and not a video.
I much prefer videos for introductory tutorials. Easier to follow in a brand new environment. Just thought I'd weigh in.
Tried to start a Kickstarter-before-its-time kind of startup with my brothers and failed ([microPledge](http://blog.brush.co.nz/2007/08/micro-pledge-scheme-released-to-fund-software/)). We wrote it in Python and I learned the language and learned a lot about developing and testing web apps. Now I work for Oyster.com (part of TripAdvisor) where almost 100% of our code is written in Python. I still love Python -- it's not a perfect language, but it is a very good one.
I just got my PhD in Computer Science, and I've been using python for 6 years or so. Just got temp-hired for a Data Science position for the next 6 months or so, and I mainly use Python (plus some R). Nevertheless, using Python for Data Science is different than using it for development. I can mostly do it using Ipython Notebook. 
The same issue came up where I live, but what these companies were running into was that there weren't actually that many people locally with as much Python experience as they wanted. They also frequently did not want to hire from too remotely and/or were not paying enough for someone to quit a current job and move. I was constantly getting called by recruiters about these jobs and occasionally getting interviews because I had no Python experience but many years of Perl experience. After getting shut down due to the lack of Python specific experience, I started just doing stuff in Python. A couple of small side projects and a bit of actual at work Django stuff that never even saw production combined with years of other somewhat similar languages got my foot in the door.
You're quite articulated for a 6 month old!
There's already a package that does this quite nicely called TreeDict. Check it out: http://www.stat.washington.edu/~hoytak/code/treedict/ https://pypi.python.org/pypi/treedict/0.2.2
You probably can. Both pandas and plt support styles now. To be fair, it might be an overkill to build a library just for that
That is one thing with plotting: if is not hard it will never be good enough.
I think you misunderstood the OP. prettyplotlib does in code https://github.com/olgabot/prettyplotlib/blob/master/prettyplotlib/_boxplot.py what could now reasonably be accomplished by using the new matplotlib.styles feature http://matplotlib.org/1.4.0/users/whats_new.html#style-package-added
Yes I did, thanks (I thought I was OP, what do we call top level commenter though?) - I haven't paid attention to matplotlib's development, 1.4 must be a very recent release as I just got a new work machine and was setting it up and I'm sure I installed 1.3. (Just checked it looks like it's 1.4 is 5 days old - this might take time to filter down to everyone) &gt; Note that this is an experimental feature, and the interface may change as users test out this new feature. Well, styles looks very nice to use, it's new and experimental and as such will take time before it gets used widely. While people get comfortable with it, you can just use ppl.plot(x,y) and get nice plots with no other work involved. And the maintainer, olgabot, (or a helping hand) might release the prettyplotlib as style sheet for the early adopters. While posting this 4 days after the release of matplotlib 1.4 is just bad timing, I imagine this'll still be helpful, and if nothing else, the colour themes are damn fine are worth transferring into a style sheet.
Yeah, it'd be much more convenient now if this was a matplotlib 1.4 style file.
What's the difference between this and matplotlib styles? Seems like a very similar thing to default styles. edit: I see this has been hashed. I agree with others... make it a matplotlib styles sheet.
Styles is like 5 days old, I'm sorry I'm not more up to date :(.
In Atlanta
You are right that Epoxy only helps directly with Dependency Injection. This post and some of the documentation are sloppy in that regard and should be cleaned up. Admittedly, sometimes I mix up the related terms of Dependency Injection, Inversion of Control, and Dependency Inversion.
Because the lookup methods for dictionaries are written in C and classes have another layer to go through.
The official release is only 5 days... but you could have just created a styles folder and put styles within it for months. https://www.youtube.com/watch?v=WmhdQdx8Gjo 3 months ago.
Does anyone know a good *advanced* Django tutorial? I feel like I'm pretty familiar with the basics, but I'm not sure I'm going in the right direction with more advanced stuff.
Just start exploring the deeper parts of the documentation and read a bunch of Django project source code on GitHub, that's how I did it!
You will find requests like "Make me a facebook clone, budget 500 USD" and you will see people actually underbid that budget. Even if you live in a country where you can get by with being paid 2 USD/hr I still recommend to charge a "1st world rate". I am Dutch, I live in Mexico, but I don't (and won't) charge 6 times less compared to freelancers in the USA because the wages here are about 6 times less compared to the USA. Especially not since hardware costs more in Mexico (at least 20% more) compared to the USA. Warranty? You must be joking. While there are people who recommend to start (very) low because of little experience, imagine having a lot of work at 20 USD/hour and not being able to get anywhere because you have to work 40+ hrs/week to get by. And it leaves no time to look for other customers, study, etc.
Learning a language /is/ a big deal. Why do people keep spreading that myth that one can learn a programming language in weeks if not days? It takes years to become at ease with a programming language and its libraries. While it /seems/ relatively easy to switch from language A to language B if A and B are somewhat similar, one will end up programming A in B /and/ often coding more cumbersome solutions in B because of that. It might still be perfecly readable code, but to experienced programmers it looks odd and out of place.
It wasn't a Python Job. It was a job (sys admin / jack of all trades) that required some Python development. Other options include: Creating your own software (open source or not). Doesn't have to be hugely popular or "business". More than a toy though. Something approaching a serious side project. Contributing to open source Python projects. Lie and then fake it till you make it.
I wrote a blog post about my first python job. http://kracekumar.com/post/26494437210/how-i-got-into-hasgeek-crew Short: I tweeted that I am currently looking for python job, good people in twitter stream started connecting. Worked part time on a project and then joined them.
My experience with .NET is that you can take everything you love about Python, strip it from the language, and you have .NET.
Still don't have a Python job (came close to getting one working for SaltStack, but was beat out by a PhD) - but I'm using as much Python as I can and pushing for it where I work. We're using more and more, so that's pretty awesome. Maybe in a year I can tell you I have a Python job ;)
Thanks for sharing! Are you a member of Django Girls??
Yeah same here! (although admittedly there we some videos when I was learning) That's why I make these videos-- for the newbies!
Very interesting take. Thanks for sharing! I have added it to our suggestion area: https://codingforentrepreneurs.com/suggest/ 
learning to program a language idiomatically and elegantly takes time. nobody should ever use that as an excuse to avoid learning a new language, or even taking on a new job that requires learning a new language. that's what I mean when I say "its not a big deal". nothing is instantaneous or easy, but there is still no real obstacle preventing you from doing it. its not a big deal because you can (and often should) learn new languages on a regular basis.
Great point. OPC (other people's code) is a great way to learn more as well. It does require more testing (as you don't always know exactly what's going on) than a tutorial but it will definitely help you improve! GitHub + Stackoverflow are great resources. Another thing you could try is reaching out to Django Site developers (list of sites: https://www.djangosites.org/) to see if they would share parts of their code you want to implement. I did this for advancing AJAX skills. (company omitted on purpose).
Bank of America uses a lot of python, you should check it out. I've seen people get hired there if they know any language really well and are willing to learn.
I think the issue at hand is not for students, but the perpetuating that you must code in your free-time if you just came back from coding for eight hours.
With matplotlib == 1.4 import matplotlib matplotlib.style.use('ggplot') also gives a nice result.
Weakly preferring to live near people similar to you is definitely morally different from disliking living near people different from you. The point, very generally speaking, is that the outcome is quite similar (even though the moral blameworthiness of each agent is much lesser).
There was a video game character like 20 some yrs ago called "babyhead"... it was a baby, in diapers, with a pacifier, that had designed a robot so he could save the world. The baby sat up in the neck and, as the head, controlled the robot. It was a I think 4 player, Double Dragon style arcade game. That's what I pictured him as. Being a baby, he wouldn't have the reach to type on a keyboard, but in his robot, he could type superfast. And learn Python. Gods I'll bet his wxWidgets interface is AWESOME.
I don't personally have an answer as to why it does not exist, but one of the things that I miss most in Ruby/Rails land is the [HashWithIndifferentAccess](http://api.rubyonrails.org/classes/ActiveSupport/HashWithIndifferentAccess.html) which does what you are describing. Personally I like being able to access dictionaries like objects and frequently wrap dictionaries in domain-specific objects. On the other hand it sucks when a tool wraps a dict and then you can't use that dict like it's intended. At some point you have a ton of magic __ methods on your object in order to cover all the cases. Anyway, this technique is particularly useful when you want to store raw data or data in X format, and then present it in Y format when it's pulled out of the raw data (ex: storing full API responses where a "ts" object is a unix epoch and then presenting that attribute as a native datetime object when calling blah.ts)
Friend of friend was working for somebody and they wanted a python developer... I was still at high school and had a bit of experience with Django - school projects mostly, so I went to them... It was nothing big but it was a start. (It was a startup and I made only 10000 CZK there ~ about 473 dollars these days.) But again, the experience was worth it, I made some contacts so now I don't really have to apply for interviews...
Prettyplotlib modifies the global rcparams, so most things should work on plots from pandas. 
If you've got a smartphone, I recommend downloading [the epub for the official docs](http://media.readthedocs.org/epub/django/1.6.x/django.epub) to your phone, and just read random chunks whenever you have a few minutes. It's a pretty damn good book really. :)
Hell yeah Tier 1 - we representin', mothafuckas.
Yeah I've been meaning to try bokeh - I'm on anaconda, so it should be ready to go. Vispy is releasing 0.3 like right now. What's interesting is the vispy team is also working on web and ipython type backbends.
Thanks dude! $1 /u/changetip
Yes! Finally, a non-broken HTTP module in the standard library.
Yes, well, their English might not be the best but it's significantly ahead of my Spanish.
The tl;dr, as far as I can tell, is that a person who is an executive with a Puerto Rican company called "B...p" was appointed to a Puerto Rican government entity whose role was to promote IT and other tech within the Puerto Rican economy. It's suggested that "B...p" was a beneficiary of aid from that government entity and that there might have been something improper about the way that aid was allocated due to the position held within that entity by the "B...p" executive. Reading the associated links (via Google Translate) it seems as if the whole issue of allocating aid to tech companies is an issue of some contention in Puerto Rico so I think we need to allow for the possibility that this is a political football. I've deliberately mangled the company name and not named the executive because it's not clear to me whether this is scurrilous . 
Even the tiniest preferences magnify over time
I don't tend to directly follow along with video tutorials (at least whilst the video is playing for the first time), I like to watch them, then play around myself afterwards. That lets me understand the process better. Definitely better to follow along 'inline' with text though, I agree. Also, as an aside, I usually prefer (perhaps even require) a reasonably high level of production values in videos. Those taken with a bad mic, not well prepared for, or with an awful narrator lose all the benefits for me. I tend to increase the playback speed to at least 1.5x, really useful for getting the information into my skull quickly, and avoiding boredom at the same time.
I learnt python, django, and some more framework. Did some contributions to open source projects. And then I started making video tutorials on python in my native language. Shortly a startup contacted me and showed interest to hire me. It is my first python, and infact first programming job.
Further to /u/justdweezil's point, the purpose was to study just *how much* a weak preference affects the macro appearance. Or at least, to provide some level of insight using a simple model.
&gt; Does it mean it will be included in the next 3.4.x point release, or 3.5 only? This is explained in the PEP: &gt;doing them in a patch-release isn't reasonable That means 3.5 at the absolute earliest. &gt;What about 3.3, which is still supported for security issues until September 2017 Again, no patch releases. &gt;is this a security issue? No. A security issue means Python deviates from its own documentation in ways which expose applications or end users to unacceptable security risks. In this case, Python does not deviate from its documentation at all.
whoa thank you! Totally unexpected! Cheers.
Thanks for the clarification. 
Np! Any bitcoin projects on the roadmap?
That's a great suggestion. I added it to our list of suggestions: codingforentrepreneurs.com/suggest/ -- feel free to vote up there if you're so inclined (requires at least a free account). A bitcoin project would be awesome though!
What just... what just happened down there? 
If you think that a "big deal" means an excuse to avoid something you're life must be extremely boring. I certainly didn't write that. But it does take dedication to learn a language proper. And nothing wrong in learning a few programming languages. But please, not with a book on your lap and copy pasting code; there are already so many cargo cult coders.
I'm beginning to feel like I should have sat down and researched python and matplotlib for hours before I posted anything here :(. I'll comfort myself with the extra 100 karma I earned :P, and maybe make a prettyplotlib style sheet so I won't feel so out of the loop haha.
Great material, but he has voice like someone was pinching him on the ass once in a while.
The open source project I started is ~300k lines. It's an IO reader/writer/interface for a very specific engineering format that supports 250+ cards of the 400+ possible cards (most of which nobody touches). The main code is pretty short, but there's a lot of handling of specific cards/results, which is why it's so long. It's clearly not complete, but it's fast and pretty bulletproof and trivial to add another input card/result type. Of course I know how to break it though :) It's basically only me and it's 3 years old.
FWIW the DjangoGirls folks do live in-person tutorials at most major conferences. I wouldn't be surprised if sooner or later one of them gets recorded.
So I was running chrome and ran the '[browser detect](http://pyjs.org/examples/BrowserDetect.html)' example and it said I was running safari. Interesting....
It's better to replace bash with zsh, and zmodload [zpython](https://bitbucket.org/ZyX_I/zsh/src). 
why not take [enaml](http://github.com/nucleic/enaml) for a spin? its an incredible impressive library that allows you to build PyQt apps in a highly pythonic, highly declarative way. the great thing about it ( in comparison to traitsui ) is that the approach is really scalable; its easy to implement your own set of widgets, keeping all the benefits you reap from this great lib.
Demos do nothing on my Firefox 31
I'm trying to mess around with this but I can't seem to get it to run. Should this be run in Python 2 or 3?
That might be because they both use WebKit.
http://ipython.org/ipython-doc/2/interactive/shell.html https://pypi.python.org/pypi/ipdb http://sarge.readthedocs.org/en/latest/overview.html#why-not-just-use-subprocess
On a side note, I've been compiling a bunch of stuff this week and was unpleasantly surprised to see wget complaining about invalid certificates (wrong domains) more often than not. For example: $ wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash ERROR: certificate common name `www.github.com' doesn't match requested host name `raw.githubusercontent.com'. To connect to raw.githubusercontent.com insecurely, use `--no-check-certificate'. Unable to establish SSL connection. (that's where the "raw source" link points, actually). $ wget https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tar.xz.asc ERROR: certificate common name `*.c.ssl.fastly.net' doesn't match requested host name `www.python.org'. To connect to www.python.org insecurely, use `--no-check-certificate'. Unable to establish SSL connection. And actually $ wget https://www.python.org/download/releases/2.7.8/ ERROR: certificate common name `*.c.ssl.fastly.net' doesn't match requested host name `www.python.org'. To connect to www.python.org insecurely, use `--no-check-certificate'. Unable to establish SSL connection. Am I missing something? Is wget overly paranoid? Why don't usual browsers complain? 
.
This article is about using Python scripts as a replacement for shell scripts, not as a full on replacement for bash. This is something I kind of assumed most python programmers already did...
See also: https://pypi.python.org/pypi/sh -- I've used it, it's pretty OK. https://pypi.python.org/pypi/plumbum -- I have not used it yet, but I'm going to next time I need to do some stuff like that. I'm intrigued by the fact that it was inspired by sh, but overloads "|" operator for piping etc, but the author decided to go his own way because "sh has too much magic".
It's precisely *because* Python is all about readability that there is no dotted access for dict keys. If you find yourself writing code where you are frequently looking up literals in a dict like this: mydict['spam'] your code probably needs to be rethought. Once or twice is okay, three times is a code-smell, more than a dozen times and you're probably doing it wrong. As a general rule, if you're looking up keys which are known at compile-time, then you probably shouldn't be using a dict. You should be using an object with fields known at compile time. That could be as simple as: class Struct: pass s = Struct() s.spam = "Spam spam spam!" s.eggs = "Spam and eggs on toast with extra spam" or it could be a more heavyweight solution. But the important thing is, if you know the field names at compile time, then it normally shouldn't be a dict. Use a dict when you have variable keys, and you don't know what they will be until runtime: for key in get_some_keys(): mydict[key] = get_some_value() Now, having said that, under the hood attribute access is implemented by dict lookups. That's okay. I'm not suggesting that the implementation has to be completely different. But the intent of the two use-cases is different, so the interface ought to be different too. 
http://www.zsh.org/mla/workers/2013/msg00055.html 
Started a business with Python, then another, then did some tutorials on YouTube, then started getting job offers. Python is a general purpose language, so looking for purely Python jobs might be part of the problem. Anyone requiring Python means their task probably has some legacy code that is slightly complex, or maybe they need it to work seamlessly with existing code and they don't know how easily you can mesh languages. Either way, if you are any good at data analysis/visualization, that's enough to get in the door with quite a few jobs. You can also spend some time with web development in Python and get another massive opening, but this requires some html/css/js knowledge as well. 
Looked at it before. Two releases in three years and the last one was in 2012.
Some old versions of wget only check against the first Common Name listed on the certificate, which fails for valid certs that have multiple CNs or additional domains in their Subject Alternative Name fields.
I noticed that, but if you look [their github](https://github.com/pyjs/pyjs) you can see more than 4000 commits and the last is from June. It seems to be a mature and maintained project. They don't maintain [the site](https://github.com/pyjs/pyjs.org) (last commit in 2012)
Hey, you must have seen some of my posts this week.
Huh, you're right, I checked with a newer wget and it doesn't complain.
The project is plenty mature. I've been playing around with it and a few other tools a lot this week. It's awesome.
Have you considered doing the verification locally? IE: Keep a file with all words in the dictionary, loading it into memory and checking that way? Linux distros provide such a file: http://en.wikipedia.org/wiki/Words_(Unix)
Look at [Skulpt](http://www.skulpt.org/)
To address this question directly, I too am in the process of learning PyQt (started just over a week ago). I recommend the qtdemo (and other examples) which comes with PyQt (if you're on linux, it may be in the devel- PyQt package).
cross-comment: http://www.skulpt.org/
If you have an interest and some skills in IT infrastructure (servers and such) you can shoot for a job as a Linux sysadmin and automate everything with Python. DevOps is the big thing these days, and IT desperately needs folks with development skills. Of course, you'd have to learn some other technologies (maybe Puppet, Salt, or the like) but those are good fun too!
If you don't mind doing that processing locally, I have used the library PyEnchant before. It is pretty good and pretty easy to use. http://pythonhosted.org/pyenchant/
Interesting, but man it looks like it is currently a pretty slow platform. On my system, their simple grid test took over 2 seconds to load while pulling down several files.
http://brython.info is my favourite Python in the browser interpreter - followed by skulpt.
Yes, I'm using " () " now, but the error is the same, I think " () " is optional in this case.
Hi there, looks really interesting. Will definatly get around to playing with this. Hope it gets enough traction so it becomes standard on the average web users desktop.
Why? What does each one do better than the others?
I'm tempted to replace bash with [ipython]( http://ipython.org ). 
Doing it locally isn't a problem at all! This seems a good solution! thanks!
Doing the verification locally is not a problem, however I'm using windows and unfortunately I do not know where to look for that file. Anyway thanks for the suggestion
You're accessing the signal as method, but you should access it as property instead. So change self.fromComboBox.currentIndexChanged().connect(self.update_ui) to self.fromComboBox.currentIndexChanged.connect(self.update_ui)
When I do that I get: http://pastebin.com/6a5rtNnR 
That attempt at replacing `uniq` make quite a few mistakes. --- #!/usr/bin/env python [Always use a version number!](http://legacy.python.org/dev/peps/pep-0394/#recommendation) import sys if __name__ == "__main__": Don't write this without justification; it's for when you want something to be both a module and runnable. That's often an anitpattern. names = {} You can just use the builtin types (eg. `collections.Counter`) for this. No need to reinvent the wheel. for name in sys.stdin.readlines(): Just `for name in sys.stdin` please; the above isn't lazy. # Each line will have a newline on the end # that should be removed. name = name.strip() That's absolutely the wrong way to do this unless you really want to strip all whitespace from both sides. Something like `if name.endswith('\n'): name = name[:-1]` may be longer but it's better, too. Technically `name.rstrip("\n")` will be fine here too. if name in names: names[name] += 1 else: names[name] = 1 for name, count in names.iteritems(): sys.stdout.write("%d\t%s\n" % (count, name)) `sys.stdout.write` is hardly better than `print`. --- I'd do: #!/usr/bin/env python3 # Allows optionally specifying the file after the # command, where no arguments or "-" default to stdin. import fileinput from collections import Counter counted = Counter(line.rstrip("\n") for line in fileinput.input()) for line, count in counted.items(): print(line, count, sep="\t") --- TBH, I wouldn't do that either because it doesn't support invalid Unicode, which happens when the OS gets the encoding wrong, on Python 3. Really I'd do: #!/usr/bin/env python3 # Allows optionally specifying the file after the # command, where no arguments or "-" default to stdin. import fileinput import sys from collections import Counter from io import TextIOWrapper # Warning: line buffering means this shouldn't be used at the same time as sys.stdout # if you're printing incomplete lines unless you manually flush surrogateescape_stdout = TextIOWrapper(sys.stdout.buffer, errors="surrogateescape", line_buffering=True) def clean_line(line): return line.decode(errors="surrogateescape").rstrip("\n") counted = Counter(map(clean_line, fileinput.input(mode="rb"))) for line, count in counted.items(): print(line, count, sep="\t", file=surrogateescape_stdout) so that invalid Unicode gets passed through losslessly. EDIT: Now actually works. Remember, kids, *always test*.
For simple stuff I 100% agree. The moment I need to do more than trivial string manipulations though python starts looking more appealing.
The PyEnchant seems to work only with 32 bit Python, however, by looking for this package, I found out the NLTK which seems to do the job also for 64 bit Python. Neither supports Python 3 64 bit. Fortunately I still have my 2.7 64 bit version installed.
Your error is now in the update UI method not your signal call. You also want to pass it the function not the result of the function (ie no parenthesis) because it will run whatever function you give it every time the signal is called 
like what ?
Have been posting my learning projects that use pyJS and pyJSdl in subreddits this week.
like webdev ?
Thanks, it's working now!
`/use/bin/evn python` will invoke the first Python interpreter on $PATH `/usr/bin/pythonV` invokes a specific interpreter. 
For one-liner type things, I've been playing around with this recently: https://github.com/Russell91/pythonpy For more complex, multi-line tasks, yeah -- ipython is great.
I don't understand why you brought that up. --- I was referring to [this](http://legacy.python.org/dev/peps/pep-0394/#recommendation). &gt; In order to tolerate differences across platforms, all new code that needs to invoke the Python interpreter should not specify `python`, but rather should specify either `python2` or `python3` (or the more specific `python2.x` and `python3.x` versions; see the [Migration Notes](http://legacy.python.org/dev/peps/pep-0394/#migration-notes)). This distinction should be made in shebangs, when invoking from a shell script, when invoking via the system() call, or when invoking in any other context. I'll add a link inline with the text.
and /r/learnpython 
yes know that one
The wikipedia page contains a link to a sample words file that you can download and put next to your program...
http://www.elance.com/
I see now. I'm on mobile and it displays code blocks...oddly. I thought you we're saying to specify the interpreter explicitly, rather than the version. 
How is unicode broken in python3?
It's not. I was referring to how the Unicode type can contain invalid Unicode (which I previously called "broken Unicode"), such as when the OS says that `stdin` is UTF8 when it's not. Python 2 just ignores these errors, but you have to manually deal with them on Python 3. In this example, I used `surrogateescape` to properly round-trip `bytes`→`str`→`bytes`. The other option was just dealing in `bytes` all the time, but that's a hassle as you can't use `print`, `format` and so on. --- Good question, though. I've improved the wording. You also convinced me to test the code. Try it out with: echo -n "hi\nhi\n\xde\n\xde" | python3 thefile.py `\xde` isn't valid UTF8 so the code breaks on it before the changes.
They went through [some crazy shit though](https://mail.python.org/pipermail/python-list/2012-May/623680.html). AFAIK it's the only open source project to have been hijacked.
Could someone explain how this is useful? Why not just write in JavaScript if that's what you need?
Start publishing on Github.
We have a ton of sh scripts that are just wrappers for a python script like this: PROCLOG=`date +proclog%y%m%d` ls -1 /u1/in/* &gt; /dev/null 2&gt;&amp;1 if [ "$?" = "0" ]; then # run python on input files ls -1 /u1/in | xargs -P4 -n1 -I% script-to-run.py "%" &gt;&gt; $PROCLOG.% fi We use the standard tools to check for files in the input dir. We use use xargs to spawn up to four instances at a time. Sure, all that stuff could be done in python but why? The shell versions are all really portable and don't need any mucking about to see how they work. They've been around working well for decades now. And I can still run script-to-run.py one-off on a single file without a second thought. 
I would guess that some people that learn Python as their first language can get into web development pretty quickly but aren't used to JavaScript syntax and don't care to learn it. I can tell you that I am definitely one of those people. 
I seriously hate Bash with a passion, but i have tried to replace it with python. It sucks because all you are doing is building strings and using subprocess.call(). I trashed those python scripts a long time ago because they sucked, and i hated looking at them. They made my eyes bleed...
No. Do not replace your POSIX shell with a general purpose programming language. The shell was created to serve a purpose and it serves it extremely well. Use the right tool for the job.
Use NLTK and download the official NLTK data. It includes a very good plain text list of all English words as part of its training data.
I was not aware of that. The software is currently hosted on github. Does that mean the same people that hijacked it are still in control?
Because JavaScript is a shitty language?
you can use `argparse.Namespace` if you want a dotted dictionary notation.
This is really quite neat. Very impressive to say the least. 
I know what you meant. I just couldn't resist making this joke.
so you can Python today ?
Look into the modulus operator
Try using division and the ceiling function.
FYI, there's an [r/learnpython](http://www.reddit.com/r/learnpython) subreddit that might be useful for questions like these! The `int()` built-in function will give you the integer portion of the quotient - in other words, how many times 2 can go into your amount. `int(11/2)` = `int(5.5)` = 5. You can also use the integer division operator, `//`, to achieve the same result - 11//2 = 5. You didn't ask, but you can use the modulus (`%`) operator to get the remainder (11 % 2 = 1, 13 % 5 = 3, etc.). (Another built-in function, `divmod()`, will give you both at once: `q, r = divmod(11,2)` sets q to 5 and r to 1.) e: more options.
If there's a programming hell, it has bash in it: http://mywiki.wooledge.org/BashPitfalls ;)
&gt; fake it til you make it This is my family's motto. Hoping to continue the family tradition... 
Trying this out right now. It's terrific.
How did you go about contributing to Kivy and pySFML? I did you fix bugs or update documentation?
&gt;Well, we ARE converting to it, so we're not really getting around that now are we? Why does anyone program in C rather than in assembly, given the fact that virtually every C compiler just converts code to assembly? Many of the reasons people have for disliking JavaScript can be hidden from the programmer by treating JS as essentially "browser assembly language". For example, JS has a prototype based object system, goofy scoping for `this`, and defaults locals to being global. The latter two are definitely design flaws, and many prefer a class based object system. These are all things that can be easily hidden by compiling from a more desirable language. There's also the matter of portability. One may already have Python libraries that can potentially be used on the browser with the help of a Python to JS compiler.
What does your company do?
1. Nobody has any idea what you're talking about, what kind of script? What .rar file? What tutorial? 2. I assume you mean brute force password breaking? Yeah, that won't work on pretty much any website - especially larger ones like twitter.
Summary: 3 guys form a company, one of the guys gets elected as a government official and uses his position to benefic to his company, so basically he is giving government money to his buddies and himself, that is illegal pretty much anywhere. The speaker at the very least is vicariously liable.
Might be a political move, but still the PDF from the Department of State is very clear and legitimate: https://prcorpfiling.f1hst.com/CorrespondenceHandler.ashx?WGUID=614026e8-0d0c-4011-b7c6-abfc8f276bf7&amp;SEQ=504372&amp;IE=0 and the law is very clear: "An employee may not use his public office for his own private gain or for that of persons or organizations with which he is associated personally." http://www.justice.gov/jmd/ethics/misuse.html
Data storage and insights. See http://kapiche.com and http://github.com/Kapiche/caterpillar.
From http://brython.info/doc/en/static_index.html?page=faq: *But (Brython) also aims at covering 100% of Python syntax, which includes producing the same error messages as CPython, even if this leads to a slower Javascript.* This is a statement that discuss a comparison between Brython and PyJs. Brython aims to be completely compatible with CPython 3.x; it is actively developed. Skulpt aims for compatibility with CPython 2.x 
/r/homeworkhelp
sh is really convenient, but has the unfortunate property of pumping stdin/stdout through python, even if you use its redirection capabilities. This is _really_ slow if you're working with big files. I have not used plumbum, so I don't know if it suffers the same defect or not.
Just a question off the top of my head (and hope it doesn't lend to downvotes) but why would one choose Python over R in this situation? Given that one knows both languages, what benefit would Python serve?
Oh, and this has nothing to do with http://vpython.org/ I thought about other names, but couldn't think of any i liked, and frankly, in my mind Vpython.org is pretty dead anyways. Naming suggestions welcome, i guess.
not on PyPy
 venv/bin/python script.py venv/bin/pip install myapp venv/bin/myapp 
He said js was a shitty language. Not programming js was shitty. Maybe I am missing something, but, when we port, we're still using that "shitty" language. That's all. 
I agree, as a data scientist I usually turn to R for these sorts of things, as the toolset is much more mature. Python does have the advantage that you can share the ipython notebooks with colleagues, which allow them to follow your train of thought, though, which is nice. When it comes to scripting an analysis pipeline though, I'd turn to python. 
Hey, since it's your website, I wanted you to know about the small hiccup I saw in the formatting: http://i.imgur.com/csQFrbT.jpg
IPython has an R kernel so you can use R in the notebook if you want. And by more mature toolset do you mostly mean the statistics packages? I've found pandas able to handle the data wrangling I've seen in R. 
In my experience, the things that are implemented in Python (which are a lot, nowadays) are cleaner and more consistent than the things implemented in R. My experience with R after a few classes and projects with it is that its libraries are a kludged-together patchwork of functionality. Even the file input/output libraries seemed to all work differently. And for what I was doing the performance varied greatly from library to library in R. Things written based on SciPy and the other scientific libraries in Python generally have a lot of C code and run very fast. R certainly works, and there is quite a bit of work out there already done for R. It will probably never go away, nor should it. But as someone with some experience in both (admittedly a bit more in Python), I would choose Python for the performance and consistency.
&gt; Python does have the advantage that you can share the ipython notebooks with colleagues, which allow them to follow your train of thought, though, which is nice. &gt; &gt; R has similar facilities, e.g. knitr. 
&gt;He said js was a shitty language. Not programming js was shitty. What is the distinction? A programming language exists to be programmed in.
Yes, I find the statistics offering in R more comprehensive - python is getting there, and I've seen a massive push in the last 5 years. I remember when I started my PhD it wasn't trivial to implement Hidden Markov Models in python (ones with non-discrete emission probabilities), but in R there were a range of packages for doing it. I think both a) Python needs to catch up with R on the current statistics featureset and b) authors of new stats packages need to start releasing them for python alongside R, in Python wants to supercede R (I don't know whether this is a good thing, though). For Data munding/wrangling, it's Python all the way, but the thing is with exploratory analysis I'll usually want to plot various things at some point, and IMO R with ggplot2 is much better than matplotlib (even with seaborn) or yhat's python port of ggplot2.
Also, try and do decent command line argument parsing in R with the standard library, I dare you! If you're developing for a system where each package that needs to be installed has to undergo some sort of validation or authorisation (i.e. in dustries with regulatory requirements, etc) this makes it a massive annoyance.
The repo is not. https://github.com/BruceSherwood/vpython-wx/releases 
They both have some way to go, last time I tried out some exploratory code it worked in brython but not in skulpt*. dir() and help() with no parameters don't seem to work on skulpt, but they do in brython. *This is a sample size of one so don't take it seriously. 
This looks quite nice, though I've got used to virtualenvwrapper - I quite like having the envs centralised - it makes it easy to delete old ones, that I might forget I have - since envs are quite large. 
I'd recommend Brython as well - at least; play with both and work out which works best.
This is very cool - I wonder how easy it would be to write an implementation of Cairo in the same way, just wrapping Canvas ?
I would really like to see someone do that. Would be great.
It is true but the work done is really impressive. The gallery of examples is very complete.
Apparently this was posted in the Django subreddit and the admins deleted it http://www.reddit.com/r/programming/comments/2ex8vr/djangocon_us_speaker_jose_padilla_implicated_in/ Kenneth Love appears to be emotionally involved and seems butt hurt, might be the one removing it.
Ramphis Castro's profile at AngelList https://angel.co/jramphis
The site [http://wordlist.aspell.net/](http://wordlist.aspell.net/) has multiple dictionaries some of which are American, British and Canadian. "lists have been rigorously checked for errors" Glad that someone checks the checkers. Or consider word lists used by people who do word puzzles: [http://www.puzzlers.org/dokuwiki/doku.php?id=solving:wordlists:about:start](http://www.puzzlers.org/dokuwiki/doku.php?id=solving:wordlists:about:start) 
8080 is what experimental http apps normally default to. Anything above 1024 should work. 
His talk has very little to do with Django, on those grounds alone he should not be speaking at DjangoCon.
I grew up in Fairbanks, you should hit up the university there are definitely students or departments that could off up projects. 
Wow you did a lot. What job were you at before you went to the python meetup?
Yeah, it is just as easy, and installed apps will use the venv python as well. I never understood complaints on virtualenv being too difficult to use without helper tools around it.
Meh, Virtualenv is already pretty easy. Now if someone would make pip not such a clunky piece of garbage.
Didn't know that. Thanks.
But when you are then deeply nested in your project, suddenly not so easy: ../../../venv/bin/python script.py # vs vpython script.py # or with the correct shebang ./script.py This is usually how i work, so it makes sense for me, i think. Most of my command line tools have #!/usr/bin/env vpython And suddenly they are portable across my machines. 
How it handles dependencies and installing a requirements file is horrible. For a few applications, I have a list of about 200 packages with very specific version numbers I need to use, or shit breaks, and I can't use vanilla pip to install it because it will install the most recent version of any dependency, even if a package in my requirements specifically states an older version. My workaround is make pip download, but not install all packages and dependencies to a local cache, than manually figure out the package installation order, and then run a custom bash script to iterate over all my packages and have pip install them in the appropriate order without auto-installing and upgrading any dependencies. e.g. I use Django, with a ton of packaged apps. Django's made a lot of backwards incompatible changes recently, so I can't upgrade until all the packages I use also support the most recent version. So say I'm standardized on Django 1.6, and I want to install super-django-app==2.0 and other-awesome-app==3.0. But super-django-app supports Django&gt;=1.6 while other-awesome-app only supports Django&lt;=1.6. My requirements.txt might look like: Django==1.6 super-django-app==2.0 other-awesome-app==3.0 Now if I install this with `pip install -r requirements.txt`, it will install Django 1.7, because that's the most recent version allowed by super-django-app, thus breaking other-awesome-app. So instead, I have to run: pip install Django==1.6 pip install --no-deps super-django-app==2.0 pip install --no-deps other-awesome-app==3.0 which works, but is clunky as hell and extra work I need to do when it should be pip's responsibility. [Several](https://github.com/pypa/pip/issues/1995) [bug](https://github.com/pypa/pip/issues/1337) [reports](https://github.com/pypa/pip/issues/59) were created for this *years* ago, but naturally, the main pip dev has no interest in fixing this. 
Thank you for this! Very informative. The downsides of having online classes is not being able to ask the teacher face to face. Thanks again :D 
Would like to see some benchmarks.
The script will have the same behavior no matter from where you run vpython. The virtualenv is detected based on the script, never your current directory, which is kind of the entire point. So you can write a nice python tool, shebang vpython, and add it to your path. Now you can run the script as any other executable, but all your dependencies are still stored in a virtualenv. This is the way i use it most often. I have a ton of utilities that i write in python for managing servers on AWS, etc, and having them use the virtualenv stored in each of their project folders without having to think about it every time i want to run them, is really a time-saver for me.
As far as I'm aware doing ``pip install -r requirements.txt`` with a requirements.txt as you indicated will *not* install Django 1.7. The issues you linked to also do not mention that what you're saying is broken is actually broken. Now what will cause your Django to get set to 1.7 is after you've already installed that requirements.txt, then you later go and do ``pip install --upgrade super-django-app``. This is because, as those issues mention, pip does a recursive upgrade by default. This means that when you ask it to upgrade ``super-django-app`` it'll also upgrade all of the dependencies it has. The reason for the recursive upgrade is historical and there *is* a desire in fixing it (In fact there was activity on the tickets you've listed 14 days ago by one of the other pip developers). It's not a particularly easy issue to fix with lots of gotchas involved in it. There have been bigger wins to gain in other areas of pip (and packaging in general) that most of us have prioritized over that currently. If you actually have a reproduction where the requirements.txt file you linked will install something other than Django 1.6 into a fresh virtual environment with jsut the command ``pip install -r requirements.txt`` please open a bug report with the reproduction details.
As someone coming from node.js into python I must say this whole virtualenv/pip business is really a step down from node's npm package manager. With python it is all so clunky and feels hacked together. I love the python language but the ecosystem is so crummy.
/r/learnpython
I wrote a similar tool once that simply looks for .venv directories and goes up the path until it finds one. Never released it though. This one looks nice. I prefer the folder-based virtualenvs instead of explicit ``workon`` environment switching. I forgot to switch to the right environment for my projects and installed stuff into the wrong envs all the time. That's why I don't use virtualenvwrapper very often.
I use fish instead of bash these days, and virtualfish supports putting a .venv file in a folder to link a project to an env in ~/.virtualenvs - maybe that's something that would be doable for bash as well and would make your project play nice with virtualenvwrapper
the node "ecosystem" benefits from decades of prior art without having to support legacy code. So of course it's going to feel squeaky clean to you. it sucks in it's own way though. the stack traces you get when a dependency fails to install for whatever reason is a nightmare. for one and at least as far as bower goes, I just love when installing one new lib into a project forces me to upgrade a whole slew of libs b/c author of said lib decided to fuck all and just upgrade to the latest version of angular for a fucking minor point release. and then other countless libs that simply wrap other libs api's and don't do much else causing bloat and extra added complexity. out of all the "ecosystems" I have had the "pleasure" of dealing with in my lifetime, I would consider debian to be the gold standard by which I judge all others. I'd put python in java at the same level as far as maturity in the toolchain and lib ecosystem. node/npm doesn't is just cute, and I only use it b/c I have to code js for web dev. not by choice or b/c it is somehow better than any of the available more mature alternatives. 
I think you're conflating the term ecosystem with a package manager when the two a quite different. I also think it's somewhat unfair to compare something relatively brand new to tools that have found ways to improve over the years while not breaking backwards compatibility. Pip and virtualenv were also two different things instead of one because they provide different functionality. In Python it's better to be explicit rather than implicit so this setup provides the separation of concerns and also prevents the two tools from becoming more complicated than they need to be. I'll admit, I really do not know much about npm but I thought it would be worth bringing up that what you see as 'clunky and feels hacked together' is more likely because the complexity and requirements are quite a bit broader than what you're used to working in (that and the history behind it)
Yeah, I think a wrapper for pip and virtualenv that tries to make it behave like npm would be nice to have. I need to take a look around because I'd be surprised if something didn't exist. Edit: I think if conda cleans up their interface, it could make things more smooth
Just use your IDLE. Open the Python folder, open the IDLE.exe then run it. That'll be your console window. If you want to make a new .py file, just Ctrl+N. Just use your IDLE for a while as your IDE if you're still just a newbie. If you create more complex code (need not multithreading nor GUI), then you can move on to other IDEs since IDLE is what I would call shit and what others would call disposable. I used PyCharm and it's beautiful.
Thank you very much I'm going to try this
Warning, IDLE isn't always found in the directory. May have to right click EXE and find it there or search it on the right sidebar for Win 8. 
Can you explain the workflow where virtualenvwrapper makes sense? I've never been able to figure out why I'd want to centralize all of my virtual envs in a single place, to me that seems like the exact opposite of what a virtualenv is supposed to accomplish.
A virtualenv is supposed to mantain dependencies from different projects isolated from each othI think. Sure, they're all in `~/.virtualenvs`, but each one is in a separate folder and there's no environmental contamination.
zsh with the virtualenvwrapper plugin from oh-my-zsh supports it too.
AFAIK, no release date has been announced yet. Bugfix releases go out as needed, not on a firm schedule. See https://docs.python.org/3.4/whatsnew/changelog.html
You could try using an online IDE such as http://ideone.com/ if you are not comfortable with installing the interpreter &amp; tools locally. Select Python from the language option button (underneath the text area, to the left), enter your code then select the Run button.
To fill a gap we have at work with a legacy application that no one else gives a shit about and were waiting on someone else to do the work. I **hate** developing but it has to be done. Fuck me if they expect me to do this fulltime though. I would still classify myself as a beginner even though I've now deployed a production RESTful API using Django and Django Rest Framework off of a legacy DB (**NOT RECOMMENDED**) across 4 environments. I absolutely love python however. Tried with PHP originally but PHP is such a steaming pile of shit to get up and running and *then* have to code in. Plus I can do offline coding with Python as I've essentially done the following since this weekend. Finalized my API that does GET for JSON and XML returns. Scripted auto deployments between environments using my API as a form of revision control while calling a supported deployment tool in a subprocess. ugh. FML.
You could always mix the two. # Put an environment arg into Python. MYARG="My Value" python3 - &lt;&lt;END from os import environ import sys print('Your bash arg: {}'.format(environ.get('MYARG', 'missing!'))) print('Python version: {}'.format(sys.version)) END I haven't done this yet, but it's there if you need it. Python is probably my favorite language for hacking something up really quick, but it's not always the best. Shell scripting is still useful. This little embedding trick is there for when you don't want to write the whole thing in Python. You can send arguments back and forth using environment args and printing to stdout, like: # Put python's stdout into an environment arg. MYARG="$(python3 - &lt;&lt;END print('35') END )" echo $MYARG $ 35
What's your target platform, or are you trying to make it cross platform? Linux has libnotify, which you can easily call from Python. Similarly, OSX you can install Growl for easy notifications. Windows... well I haven't worried about notifications for non-web based apps. The chrome notifications will work if you have a web based app, but I assume if you're using WxPython that this isn't the case.
I realize that virtualenvwrapper doesn't actually mix the environments together. It does mean I need to keep mental track of which environment belongs to which project though. When I delete the repo for a project from my machine I need to remember to go to ~/.virtualenvs and delete the environment too. If I have multiple copies of a project checked out then I need to remember which environment belongs to which (or have them share and remember that I'm doing that). If I forget to remove an environment a few times then I end up with zombie environments hanging around taking up space.
A bunch of years ago I was bored of playing Diablo one night, so I downloaded python and worked my way through the official tutorial because I'm a dork. I've mostly made a bunch of labor saving scripts for work and a variety of little things just to figure out how to do them. For the old timers reading this, I'm the one who used to host uselesspython.com years ago. 
OMG that's very cool, very simple thanks
Ah, I see what you mean. I don't usually deal with many projects at once, and for me at least, just naming the virtualenv the same as the directory is enough. One thing I hadn't noticed before and went to check after your comment is the amount of space they take: I have 21 virtualenvs currently sitting on my machine, taking up almost 1.5 GB of space. Gonna keep an eye out for those from now on.
R probably has more comprenhensive Statistics package and has been around for data science jobs for some time. However, Python brings the advantage of running entire operations on a single stack. Try solving this problem, for example: We were trying to do a clustering of various articles on our website. Python makes it easy as you can scrape the website and run the required text mining and clustering in a single code without worrying about any interfacing challenges. Also, I feel that for a fresher Python is easier to learn over R (might be a view rather than a fact)!
`rmvirtualenv` has tab-completion.
But what if you like to keep your virtual environments centralised? Wouldn't it make much more sense to have a .venv file in the root directory that pointed to the corresponding virtualenv, rather than have vpython go hunting for it?
Personally, I try not to be deeply nested in my project. My project is a Python package rather than a single module, and it doesn't behave correctly unless invoked from the root with the `-m` switch.
I don't see how that helps. rm -rf ~/.virtualenvs/whatever has tab completion too. I'm more concerned with _remembering_ to delete the environment (by whatever command) and remembering the mapping between environments and projects.
Another piece of the virtualenvwrapper workflow I don't understand is how to automate setting up projects. I typically write a bash script that pulls in all of the dependencies for my project and sets up a virtualenv. If I use virtualenvwrapper then I can't have my script use a standard name for the environment because I can't guarantee that name is unique.
there OP will have to compete with guys who can afford to charge less than him because they don't need to spend a lot of money to keep their house warm :)
What about [vex](https://pypi.python.org/pypi/vex)? Anybody using it? I'm using Docker to isolate the Python enviroment for my new project. Read about it: [Python: If you have Docker, do you need virtualenv?](http://www.markbetz.net/2014/01/17/python-if-you-have-docker-do-you-need-virtualenv/) 
You can write python code in Notepad if you want. When you go to save the file, first select "All Files" as the file type. Add ".py" to your file name and save. Run it from the command line as "python /your path/to/file.py" and it will run! That stuff above applies pretty much everywhere, but I recommend finding a better IDE than Notepad. SublimeText is my favorite, some people use IDLE, lots of people will swear vociferously as to why their preferred editor is the best and all others are the worst things possible. Keep trying new ones, and you'll find one you like with features that make sense to you. In the meantime, remember that programming is 90% bashing your head painfully against something you will later remember as amazingly trivial.
I've just started using PyCharm as an IDE and love how simple it is. Free download for Windows and Mac http://www.jetbrains.com/pycharm/
Note that one of the entries may... or may NOT... have been submitted by Mark Shuttleworth of Canonical.
Before virtualenv wrapper, my django projects were basically: ~/Development/projectname/VIRTUAL_ENV_HERE and within this dir is a webapp dir with my django source. I never liked having the env part of the source directory in a way. I seem to recall there is a way to set your virtualenv home but i never did that. virtualenvwrapper does that all for me. including introduces the best command ever: mktmpenv makes a temp environment and deletes it when you're done playing around in it.
&gt; Another piece of the virtualenvwrapper workflow I don't understand is how to automate setting up projects. To me, that is not the job of the wrapper (or any virtualenv manager) but the job of the project to maintain a requirements.txt (or whatever you want) with the dependencies required for the project. Then it is up to each developer/deployment team to decide how to set up their environment (use system python or isolated package management) and issue the pip install -r requirements.txt
I haven't found where to write my code lol
I've downloaded SublimeText but I have just a question, how to run the code ?
Just like in my first example, you can run the file with "python /path/to/file.py" in the command line. Alternatively, (and this is more complex, bit worth learning): find a plugin for SublimeText that allows you to run scripts from SublimeText's plugin manager. You can also probably find plugins to manage Python syntax highlighting, which will make it easier to write code. None of this is easy, I promise you. The payoff, however, can be immense!
If that is skipping a step: Run cmd.exe to get a command line window. (If that doesn't work, ask google! If you're on a Mac, it's slightly different, just search for Terminal instead of cmd.exe). Now type the command "python.exe C:\path to\your\file.py" (or whatever the filename/path may be). Press enter. Watch your code run.
I agree that setting up the project is not the job of virtualenvwrapper. But using virtualenvwrapper forces the deployment tool to deal with additional complexity, because it needs to be able to generate a globally unique name for the deployment's virtualenv. Just generating a globally unique name isn't so bad (although it is more complex than the alternative) but doing so has cascading effects because now you need to keep track of the mapping between global virtualenv names and projects. Tools or people who access the deployed environment need to be aware of this mapping and know how to traverse it. You can work around this by having the deployment tool generate entry points but at this point you're adding a whole new layer of complexity that just isn't necessary if you don't use virtualenvwrapper.
This is very nice of you to help me ! Well I successfully downloaded the plugin but I don't see anything different (like a button to run the code from SublimeText)
In my opinion having the virtualenv live in the project directory is the ideal location. I wouldn't put it in the _source_ directory, but I like to structure projects so code lives in project/src instead of the project root anyway. I think project/env living alongside project/src is a pretty natural place for the virtualenv to live.
This is exactly why I prefer it, lsvirtualenvs shows me all of them, also tbe tab completion. Before virtualenvwrapper I had loads of environments all over the place. Also if I want a temporary env then I now exactly where it is. 
 Building experience working on real-life projects plus making at least some kind of money - that's still better compared to working for a letter.
I do admit the temporary environments sound nice. I didn't know about those.
As others have said, do not use eval() like this. I don't know why he says to do it, nor do I care. But it's wrong. And if he says to do something like that, his book is crap. Eval allows execution of arbitrary untrusted code that can segfault the interpreter.
Also, if you get really stuck, the solutions are [on his website.](http://mcsp.wartburg.edu/zelle/python/ppics2/code.zip)
For Windows, check out snarl: http://getsnarl.info/ If you want to go web based and have the notifications via Chrome, check out Flask / Django / Pyramid.
This guy is very obnoxious, I was talking in tweeter to meet together with other devs and he just kept barging in. We ignored him and he just invited himself, with his own entourage walking like they own the place :P
I would like to know more, and see if I fit the job. You can contact me at mywildlife@ymail.com 
I'll have to look into this further. Still a nube but soaking it all in :) thanks for your comments.
Sublime should have a build menu, you can use that to run the file. The shortcut is ctrl + b (cmd + b on OSX).
Maybe it's just me, but if I'm in my projects directory deleting a project, I don't have any problem remembering to delete the virtualenv, too. Different strokes, I guess.
Search the interwebs for getting keyboard input. There's a thousand tutorials out there. 
Neat.
you should post such queries to /r/learnpython. Anyway, here is a simple solution in python 2.7.x: name = raw_input('Enter name...') school = raw_input('Enter school...') print "My name is %s and my school name is %s." %(name, school) 
Thank you! One more: after the output, the window closes too fast, how do I delay that? Or disable it so it doesn't close at all?
Try to [search the interwebs](https://www.google.com/search?q=after+the+output%2C+the+window+closes+too+fast%2C+how+do+I+delay+that+python).
Saw this live at PyCon. David says himself, there's nothing there you can use in production tomorrow, unlike his first two generators talks. I have done a bunch of work in Twisted, and some of it will be rewritten for asyncio as we move to Python 3. This talk provided a ton of insight on the underpinnings of asyncio, even though it's not about asyncio at all. If you know enough about generators, the concurrent module, and a little compiler theory, you can get the gist from the slides and sample code. Use those factors to decide if it's worth your time.
what justification he gives?
can you tell me more? even I am interested.
The slides and code (and the video, once EuroSciPy release it) are all public, they're based on my High Performance Python book (also linked in the blog post) which has a CC NonCommercial license. 
That's what I was thanking you for. I'll also probably read the book (not buy it, I'm a Safari subscriber) when it's out.
This isn't so much "when testing goes bad" as "when mocking goes bad". Excessive mocking is pretty terrible, because it eliminates the aspect of code correctness which is correctly calling the code the unit relies on. Indeed, it seems that the opinion on the Testing in Python mailing list is against mocking in general. While I wouldn't go that far, I do think one should identify exactly why one is using any given mock.
COBOL would be a noose for you to hang yourself.
Nope, just fan of the tutorial.
You win. Thread is complete. Fucking golden.
The 100 line limit is useless if they are not bound to 80 columns. In this case it just promotes unclean code.
Interesting project, curious to see where this goes. But I have to mention, you're doing the actual interesting part in R! Nothing wrong with that of course (myself, I teach R and Python) but I feel like there's a little bait and switch going on here :) It's worth mentioning the Python library [`seaborn`](http://web.stanford.edu/~mwaskom/software/seaborn/), your plots remind me of some of the stuff it can do. Carry on!
Yeah thanks! I actually have python in the title for this sub because the entire data mining section is in python and one of the major takeaways of this post was to show beginners how they can get started mining data using this script.
I do how would you like to see some examples? I can email or put up on my web sight
Typical post of a man who actually knows very few of the languages he is talking about, so his gun representation of other languages is based on common myths about them.
Trying too hard to be funny.
So far here there's 1 post made by just a guy and 2 posts by people that take themselves too seriously. And python would be the guy in that one joke about the American military branches who just sits there quietly stirring the fire with his disk. 
This is covered in most tutorials on the internet, often in first or second chapter. Check out some learning resources here: /r/learnpython/w/index
Well, he says that since the program is run by the user on their machine, the security risks are minimal. Basically, he's ignoring how big of a deal code injection from a background process is. To clarify, that is something that he said in class. I talked to him about it, and he wound up explaining to the class why it's dangerous, which is pretty much all I could ask for.
thanks for the reply!
Absolutely!
You are being down voted but its true. I know C, PHP and Python. Op is full of shit.
While he's right about that being completely wrong, I haven't found any issues with any other part of the book. Furthermore, it's one of the better written resources I have found thus far for beginners.
Kinda heavy go carry around
Python is a Swiss Army Knife.
link to news article which explains it: http://thenextweb.com/apple/2014/09/01/this-could-be-the-apple-icloud-flaw-that-led-to-celebrity-photos-being-leaked/
OP didn't make this.
I just donated $15: PyPy is a really neat project and is really cool thing to show people the power of Python. Keep up the good work.
Run your script from the command line rather than double clicking. That may help with your window closing too quickly problem. 
PHP garden hose FTW easily
Perl is already the Swiss army chainsaw. 
I'd believe Python as more as something shiny, new, full of features, broadly issued, and often blamed for failures sometimes with and sometimes without merit. I think it's a police issue polymer framed Glock 37 with laser sight, flashlight attachment, and taser attachment.
I knew you'd say that.
I never claimed expertise, it's just a joke post on my personal blog. They're all fine languages and people have made great things in all of them. 
[Python will also be something that will carry through hundreds if not thousands of years. So if you start a calculation today, it may be slow, but a thousand years in the future, across several iterations of hardware and software, the solution will be accessible at the proper time.](https://www.youtube.com/watch?v=2Fa9-Jmoi70)
So instead of this: fahrenheit = eval(input("What is the Fahrenheit temperature? ")) This would be the preferred method since I'm looking for a number fahrenheit = int(input("What is the Fahrenheit temperature? ")) 
We write a lot of command line tools to help automate things where I work, and we couldn't quite justify writing an achievements framework on the clock. So I got bored and wrote one at home this weekend, we can use it if it doesn't cost any time to implement right!? &gt;D Hope someone else can find it useful.
 #so instead of this fahrenheit = eval(input("What is the Fahrenheit temperature? ")) #this would be a better solution fahrenheit = int(input("What is the Fahrenheit temperature? "))
Having learned COBOL, that is an accurate description and would make RPG into a Tanto. 
Agreed; looking at the code was not a very pleasant experience.
There are people who do that kind of things as a hobby. It's a Japanese tradition called Chindogu (which translates to "unuseless"). The point is to make things that are technically not useless but so impractical that they are. Like attaching a fan on your chopsticks to cool down hot ramen before they reach your tongue. Search for Chindogu on Google image, you'll find a ton of them.
Twist: The real story here is this is an analogy of OP's skills with said languages: None.
Donated $100 to Py3k. Let's please end the schism :)
there could be all sorts of bugs in that hose and you'd never be able to see them!
There is exactly zero proof that this tool was involved in anything. As it was pointed out elsewhere: - some pics are 2-years-old - some clearly show non-Apple phones - a dropbox "start guide" was included - some of the pics had hashed names suggesting they might have come from WhatsApp So the pics were likely coming from different sources (Dropbox, WhatsApp) over a long period of time, and iCloud might not have been involved at all... let alone by this. EDIT: even the tool author says timing makes it [very unlikely](https://twitter.com/nikcub/status/506421890517200896).
So, "C# is a powerful laser rifle strapped to a donkey, when taken off the donkey the laser doesn’t seem to work as well. " what is the donkey in this metaphor? 
Likely windows.
I blame the Python programming language for the leaks.
I'm not sure that's the best description. How would one hang oneself with COBOL (*wanting* to hang yourself is another issue). It's major fault today is the mind-numbing verbosity that makes Java look like Python in comparison, e.g. MULTIPLY PRICE BY ITEMS GIVING COST In my mind, COBOL would be like a barrel of gunpowder with a corked hole in the bottom. To use it offensively, you have to uncork the hole and slowly carry the barrel over to the enemy, leaving a trail of gunpowder behind. Then you have to run back and finally light the gunpowder and watch it slowly burn over to the barrel.
Lighten up. It was a joke about each language's Achilles Heel, not a formal language review CTOs will be using to choose software stacks. For instance, what skill do you need to have with Matlab to know that it costs over $2000 for an individual license and $1000 or more for each library?
Prolog but no Delphi? Sniff... 
/r/ProgrammerHumor 
Sure but there is also confirmation bias for those with experience. 
&gt;I'd believe Python as more as something shiny, new, As someone who has been using Python for over 15 years, I always find it weird when people characterize Python as "shiny and new". Even Python 3 is almost 6 years old.
Mathematica, not matlab. Considering that Mathematica's "manual" weighs 5lbs and costs a hundred or two and one can understand the point on the link though... http://www.amazon.com/The-Mathematica-Book-Fifth-Edition/dp/1579550223/ref=dp_ob_title_bk
&gt;I am not the author btw Yep he definitely said he made it /s
Let me introduce you to csh.
Yeah, I misread it. 
**WARNING: DOCTOR WHO SPOILERS**
No Haskell. I am disappoint.
csh is the reason i use bash.
This is my... BOOMSTICK!
Yep, I was looking forward to a haskell one too :(
WOW. HOLY CRAP. Talk about Freudian... I was thinking "stirring the fire with his **dick**" and actually typed disk, which is way better if you know the original joke.
&gt; It's major fault today is the mind-numbing verbosity that makes Java look like Python in comparison MULTIPLY PRICE BY ITEMS GIVING COST This is one type of verbosity. It's not nearly as bad as most people think - since you could simply do this instead: COMPUTE COST = PRICE * ITEMS Another type of verbosity is a language with so much structure and boilerplate that it requires an IDE - where a significant amount of the language innovation takes place. This is the world of Java. And in many ways it is worse than COBOL. Bottom line: code in COBOL or coding in Java or switch careers...tough choice. 
I don't know the original. Can you enlighten me?
it's right above mine. I responded to my own post.
Thanks, guys. TIL that maybe I should learn a little C# just to have some idea of wtf it actually is. 
Oh no, no, no. I have read and written a lot of PHP. And I have also read and written many other languages, like Python. That is what has caused me to hate PHP and constantly consider it inferior to alternatives, not random Internet stereotypes or blog posts.
The PHP one was pretty funny.
C# is basically Microsoft's improved version of Java. It is a better language than Java, but it effectively only runs on Windows systems. In contrast, Java really does run anywhere with ease.
I would use float(), personally. Int() removes the ability to input decimals.
If lisp is a shiv, what does that make scheme?
Definitely bacteria.
ZF-1
You should really clarify what it is you are doing here. It's not clear why you're converting timestamps to date/time parts or why anyone would find it useful.
It is mildly useful for humor
This conversation is pretty funny... I've actually referred to Python+Flask as my MAC-10 of web application development. 
Thanks, I totally forgot to even mention that. Tell me if that clarifies some things. I threw some data visualization in there as well.
That exists for those that don't have experience as well.
That's better.
I was also thinking Fortran.
It looks like you're trying to run `pip` from inside a Python shell, rather than your system CMD prompt.
Not having used Mono, I'm curious what you feel the gaps are between Mono and the CLR? I see Mono being used in a lot of games these days and hearing some anecdotals about it being used for web apps, so I'm starting to hope it's an option for a portable platform as an alternative to the JVM.
Nothing remotely related to development. I worked mostly in customer service and sales related positions.
I like it a lot! It's amazing how much there is to learn.
Second for codecademy.com. It's fantastic!
A knife. A simple tool, sometimes used as a screwdriver, which is horrifying. But for the job it was intended for, it's hard to improve upon.
This is true, I suspect some of issues people have with PHP can be traced to its users. I have a coworker who swears by PHP + MySQL, which is cool especially when using some of its frameworks. The problem is that he also never gave a try to anything else. Seeing his "daemon" (which doesn't do anything web based) that was mix of php + bash and cron makes a grown man cry. 
Maybe something like this [survival knife](https://www.mysticarmynavy.com/images/usnusafsurvivalknife.jpg)? Works OK as a hammer using the hilt, but doesn't work as well as a real hammer. Has a sharp edge for cutting and serrated edge for sawing, but isn't as good as a real saw. Can be tied through holes in the guard to a long stick and used as a spearhead. Comes with a sharpener. That metaphor might be getting out of hand now.... :)
Thank you!!!
Why defend a crummy language is your own ego somehow mixed up in this.
http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
$100 to numpypy. I'd love some faster numpy. 
Um. Mono is a viable target if you only want to run on the mono runtime and start from the beginning with that target (unity does this for example, quite successfully). It's not even remotely viable for running code you port from the CLR** The biggest gaps are: No graphics APIs from the original CLR (all of the WPF were never implemented for mono), and that binary compatibility is non-existent; which means that DLL's compiled against the CLR (ie. everything on nugget) don't run on mono. Practically speaking that means: write your libraries from scratch; you won't be able to use any existing 3rd party open source libraries from the c# ecosystem. ...but perhaps you can use some of the mono libraries, eg. from the unity asset store. ** Some big names have talked about porting xbox code directly to monogame for cross platform stuff, and it's true, monogame is pretty good, but a lot of work has gone into making that transition smooth, and there are still *a lot* of pipeline issues with it. The path for web apps is *A LOT* rougher.
Hahahahaha. Get a load of this guy. I use Python3 in all my current Python projects. The days of "Python3 isn't ready" is over. PHP is an awful language and a great example of "no planning is planning to fail."
What year do they lose their sense of humour?
Most of the people new to Python only got here once web development with Python became a serious thing.
What's wrong with using pytz? UTC to local:- import datetime, pytz local_tz = pytz.timezone('Asia/Tokyo') datetime.datetime.now().replace(tzinfo=pytz.utc).astimezone(local_tz) local to UTC:- import datetime, pytz datetime.datetime.now() datetime.datetime.now(pytz.utc)
http://www.fullstackpython.com helped me a lot :)
Good to know. Thanks!
First of all, we aren't trying to get the local time in utc - we are working with the time that a post was submitted in utc. Second, it does us no good to convert the utc to our local time zone - we want a standardized way to look at the time these posts were submitted, and compare them to what is happening in the world (which countries are waking up, which are going to bed, etc)
I only feel like older versions of mono are lacking (which is what you usually end up with in game engines, Unity excepted. I love that shit) It's really not all that bad. The big thing with mono vs .net vm is that you won't have access to the same windowing framework which means if you want a cross platform app it has to be run on mono everywhere, you can't easily make a binary that both VM's can use. I suppose that might be possible with GTKSharp or something similar though. I would definitely be interested in a Mono app running behind nginx or apache as an alternative to ASP.NET on IIS.
C# Is a really competent language. It feels like how java should feel, it's syntactically strict, has a lot of things that make OO a lot easier (Hello friendly access policy). It's a fantastic language I'm growing to love.
This is pretty much my feeling on it, if we could get nuget binary compatibility between the CLR and Mono it would be awesome, but as it stands some of the internals are still too different for that to be viable, and as you said, the windowing kits are completely different, though it might be possibly to create a common windowing kit that can create components out of WPF or GTK depending on your platform's availability.
Donated 40$ to Pypy3k an Numpypy. Really looking forward to those!
This is essentially a circlejerk thread about how Python's the best and phpsuxlol and you're asking if *my* ego is tied up in this?
About 25% of pythonistas report using Python 3 on a regular basis despite the fact that it was release 6 years ago. I'm happy you're a part of that minority, but are you trying to say that Python 3 was a resounding success story?
Just because people haven't migrated to Python 3, doesn't mean they can't or won't. The fact that they dared to change the language &amp; break backwards compatibility is a good thing. If your measure for success is purely "not everyone has moved to the latest &amp; greatest version" then you're not really worth arguing with.
[Python: batteries included](http://imgur.com/hjzEwAe)
The idea behind the current Python one is the current controversies surrounding the v2-&gt;v3 transition.
More like the Swiss army pyramid builder: use it once, then spend 2000 years wondering how the hell you made it work in the first place.
I use python3 just fine. 
Specifically, it involves a somewhat "major" behaviour change in existing APIs, with a deprecation plan; so that means it will always go in at least a new minor (feature) version.
But when you finally work with a language you understand that those small annoyances on the surface are irrelevant compared to the !#@$* hidden deep in the language. 
PHP is fine if your project is less than 1-4k of lines everything bigger is HUGE pain in the ass to maintain. 
Basically java made for windows based on .net framework and with a some nice syntactic sugar compared to java, although still quite verbose.
You could also do it with PyQt, and here is one udemy course, at the end you will build [PyDataMan application](https://www.udemy.com/python-gui-programming). There was the code to make the course free here at reddit just I don't know where it is. You can also find videos from that course on [youtube channel from the author](https://www.youtube.com/user/Deusdies2).
&gt; If your measure for success is purely "not everyone has moved to the latest &amp; greatest version" then you're not really worth arguing with. Way to stretch what I said as much as possible. I'm all for Python 3 and I can understand why the breaking changes were made. But there's no way you're going to convince me that this was a successful release when it's still nowhere near majority share 6 years down the line.
Actually not true, but you have to take a lot more care writing PHP than (say!) Python. For internal use, I've implemented a pair of custom MVC web frameworks, one in PHP and one in Python, which are functionally almost the same. Maintenance is about the same on both. PHP is still crap though :)
Yeah, I agree that if you follow style guidelines etc. php is manageable, but you often work with projects that are made by people who dont know what style guide is... I worked with horrendous php framework this summer... I wanted to kill the author about 4-5time per day 
Well, yes. I doubt that Python is 'the best' (whatever that would mean), it certainly has its embarrassments as you said, but there is no doubt PHP is horrendous -- this is an evaluation shared by many programmers both inside and outside of the Python community, including those whose jobs require them to regularly write lots of PHP. As far as I can tell, the only people who don't recognize the severe problems of PHP are those who haven't explored many different programming languages yet. Hence you come off as defending the indefensible here. It's quite natural to question why you would do that.
&gt; It makes no sense to compare a bunch of languages to others Why on earth not?
25 % of pythonistas is a lot of people so I would say yes
imaplib? I don't see why you would need anything else for simple message checking... https://docs.python.org/3/library/imaplib.html
I haven't actually used PHP in a project lately (and still not sure I'd want to), but I do want to come to its defense a little bit. For all of its problems, it does seem to be improving lately. The language itself gained things like generators, mixins, real classes, etc. I even saw a library (kinda like jQuery/underscore) which papers over the parameter order issues in the standard lib for collections, etc. The ecosystem gained things like a package manager and packages comparable to Rack, Sinatra, and MVC frameworks. Check out this tutorial on turning an oldschool php site into MVC using Symphony2 (is pretty good as a general argument to why MVC style is useful): http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html There's also resources like PHP The Right Way which seem to give a lot of good advice: http://www.phptherightway.com/ If you know someone already using PHP or you have a need to use it yourself, make sure you're up to speed with what is going on. It seems like it'd be a much better experience than in the past at least.. Edit: That library for making the standard lib more sane is called php-o: https://github.com/jsebrech/php-o
In addition to py2exe, you may also want something like Inno Setup to build a nice installer. Otherwise you'll have to distribute a zip file and tell them which exe to run.
This is a great article to go through the basics of Scrapy. I'm familiar with requests and BS4, but might write a little web scraper with scrapy now, just to test it out. Thanks for the link! I think this read is a good one for beginners as well-- it helped me understand a bit more about what's going on behind the scenes during webcrawling/scraping.
I love it!
I would use it if it worked together with virtualenvwrapper. The idea is good.
I really like the idea of higher developer productivity in developing embedded software applications.
Good question, I'm not sure. I'd be shocked if it wasn't just a matter of merging two branches though.
I'm confused as to how a language that is a superset of another language can be represented by a completely separate (and often inferior) analogy. C and C++ in particular.
 value = raw_input() `Value` here is also a string ("str"), and in Python, you can't add strings with integers. You need to convert the input to integer: value = int(raw_input())
So there's no connection with the mathematical operation &gt; print (5/9)*(value-32) is it correct?
excellent article!
The mathematical operation is correct (I think, I don't know what the temperature conversion formula is), it's just that `value` needs to be a number, but the program is passing in a string.
Thanks for the link. When I asked him, he didn't quite justify it this way. This explanation makes a lot of sense.
This seems really cool but it'd great if you could use IPython as the embedded repl instead of plain Python.
Wow. Amazing. I wanted to make this myself and this is a really really good tutorial on how to. Much thanks. 
This is almost kinda funny, I went onto here to ask if anyone had any good articles to read about scraping for beginners and this was at the top, thanks for posting it at such a great timing
That'd be pretty easy to add actually. Could you add it as a github issue? I can get it out the door in the next day or two.
cool! you're welcome :)
Hopefuly will help me in my attempt to make a script to download all the posts made by someone (first project ever, just finnished codeacademnys course on python)
Thanks, this gave me the chance to read more about formatting and types of data in python
I agree. I mean, yeah, you should do that. Or whatever...
The whole returning a modified function aspect of using decorators is pretty clear to me, but I haven't ever seen a good explanation of what magic makes the @decorator synxtax work, especially when paramaters to the decorator are involved. I feel like that's necessary for an actual understanding of how decorators work.
Pretty nice intro to Scrapy! Great to see such a nice and comprehensive introductory material. (+1 for the graphics!)
Kind of where I am. I do a lot of scraping with [g]requests, BS4, and occasionally LXML / Feedparser, so I haven't quite understood what the use case for Scrapy is. This might help.
If you take a simple example like the one provided in OP's post, and create a simple .py file and debug it, it'll make a lot more sense about how the "@decorator" syntax get's called. Basically, the interpreter consumes the decorated function first, and then scans the rest of the file looking for methods decorated with it, when it finds the "@" syntax for the decorator, it then runs the function through the decorator and modifies it accordingly.
Same here, every now and then I see post about scrappy and I read through it but never get around to using it. Requests, BS4, LXML is all I need to do my scraping.
pupupeepee, I haven't experienced any of the issues you are having. Are you perhaps using some asset blocking plugin like Ghostery? Could you send me a screen shot with what you think isn't rendering correctly?
It works for me in incognito mode, but the blocked http-served assets doesn't appear to be related to a browser extension. http://cl.ly/image/3u0W0z1M2u2K Are you using Chrome on Windows? It has lesser security restrictions, I believe. https://superuser.com/questions/487748/how-to-allow-chrome-browser-to-load-insecure-content 
No, I'm using chrome on mac. So I did a push with those links all changed over to https but it wouldn't load the D3 library for me after I did this. Is anyone else experiencing these issues? I've had several people email and message me about it, and this is the first I've heard of a problem.
Wow, that looks way better than my current scrapper method of BS4+requests modules glued together with makefiles. 
Maybe its just me but I feel like this wouldn't be all that useful without the OCR. It's kind of glossed over in the article but in my admittedly limited experience it is non-trivial to implement. 
I'd guess that you're right about it being a browser extension I'm using. I wouldn't sweat it
It will have tough competition with rust on the future of embedded. 
Zope + CMF + Plone was something like 1MLOC last time I looked. Many years of accretion takes its toll...
I've had a recurring STM donation of $10 from every paycheck for a few months now...I'd really like to see the larger community pitch in smaller amounts continuously to get some of these things production ready. Keep up the good work!
Do you mean python 3? It's not true that there's no interest at all (google web3py).
It's a reasonable thing to do in Python. Try pygame.org and the projects listing.
I'd appreciate recommendations on good django books and/or video tutorials.
I love that migrations are built in now, looking forward to trying it out.
Follow PEP8. http://legacy.python.org/dev/peps/pep-0008/ 
You're allowed to think whatever you want, but pep8 is more or less how everybody else writes python. Really the most important thing about code formatting is keeping it consistent across a project or group. I don't particularly care what you do on your own work, even if it makes my eyes bleed, but if you work with other people you'll have to follow their standard (or agree on a standard for new projects) and "I think pep8 is wrong" is not a particularly strong argument in favor of having a style different from the rest of the world and giving up tooling like flake8.
It's your code so feel free to do whatever you want but FWIW your alignment makes my eyes hurt. run(command["makefile" ].format( **locals())) run(command["mount" ][pick_0or1].format(**locals())) This is just ugly as hell.
Spent a few hours today reading tutorials - I'm very excited to dive into my first app this weekend after a year or so of casual Rails development. 
Two scoops is great, but does assume a fair amount of Django knowledge. I'd start with the official tutorials, then go through two scoops when you start building something from scratch.
Isn't that a bad thing?
Oh yea! Build in migrations, finally.
Uhuuuuuuuu!!!
Django is very easy to get into just by reading the official documentation.
I'm not a Django user so forgive me for my idiotic comment but, their changelog seems to imply rather [drastic changes](https://docs.djangoproject.com/en/1.7/releases/1.7/#backwards-incompatible-changes-in-1-7), yet they haven't moved to a new major version. This is a bit surprising.
no digital version, which is a real shame. I know piracy and stuff but really? only physical version of a **programming** book? What is this, 90s?
rust is looking good indeed, but still very much in development. it doesn't have the wide-spread knowledge nor community yet. Also, rust is a purely compiled language, whereas Python has it's REPL. However, I agree rust is very promising, too!
Good guys, they are still maintaining and fixing bugs in older versions &gt; Alongside Django 1.7, today we are issuing bugfix releases in the 1.4, 1.5 and 1.6 series, which correct some bugs which existed after the most recent security releases. 
my path was: - Basic **HTML** so that to understand how to structure the sites and present the data - Then **Flask** to understand how GET/POST etc work - Built simple apps with Flask - then built that polling app of official tutorial of Django - Finally, started with Django docs :)
Any idea when pycharm will support it?
Right time to start new project :)
You don't want your source code to be pretty. You want it to be readable and maintainable. The rules in PEP-8 are there for a reason and it's usually because someone with a whole lot more experience than you thought about it very carefully and considered the entire life cycle of the code. For example, aligning operators might look pretty, but if you add another line to that list with a longer variable name, you have to move all the other lines to match. That makes diff'ing code more difficult and makes your source control commits less clear (yes, it is just white space and you can hide it in most diff tools, but the point still stands).
I've been using the release candidates in a new project, I never used south before, but migrations are awesome! 
Why?
Django uses 1.major.patch. You should read Django 1.5.10 and 1.7.0 as 5.0.10 and 7.0.0 respectively
You probably want to use `codecs.register` instead of writing to `codecs._cache` directly. There's also quite some code duplication between `__init__.py` and `nocolon_sys.py`.
Hey, no problem. I enjoyed the course btw. :)
Thanks, i fixed the _cache problem. ~~I merged both files since they were the same but it doesn't work system wide, I'll investigate.~~ Okay it was lacking the Incremental{En,De}coder
I heard that the authors aren't planning on doing a 1.7 version, after the shitstorm over their last edition not being digital.
Very nice, great work here!
When you do the official tutorials you build a[ "polling" app](https://docs.djangoproject.com/en/dev/intro/tutorial01/)
Official django tutorial is based around making poll web application. https://docs.djangoproject.com/en/1.7/intro/tutorial01/
well, fuck them. Someone else will make them
If you ever worked with some other web framework, such as flask for example, just go over official tutorial and docs to familiarize yourself with django - it's pretty easy.
It has been supported for quite some time - since Pycharm 3.4 iirc.
Im still a noob here, and im following the official tutorial of Django. How can one now update the django version without having to start the official tutorial code all over again?
OCR would certainly make it better or more useful for sure, but even in a simple format like this, it's definitely not useless. Any task we used to use a scanner for ten years ago (ex. scanning family photos, scanning signed legal documents, etc.) can be done using a smart phone now. These images don't necessarily *have* to have OCR applied to them, they are simply records that need to be stored digitally. Admittedly, anytime you can apply OCR, the results can become editable and searchable which makes the utility shoot through the roof.
I went to Rails from Django. why are you moving to Django?
I see. Thanks for the explanation.
I just spent 3 weeks upgrading a site from 1.2 to 1.6. Launched yesterday. Happens every time! edit: 1.2, not 1.1
To get away from the ugly Ruby Syntax :0
[x-post](/r/octave/comments/2fcl2c/oct2py_python_to_gnu_octave_bridge_run_mfiles/) from /r/octave
That's awesome because I have a fair amount of experience with Flask. 
I'm sure the book is great, but I will rather vote with my wallet and buy alternative that doesn't threat me like a criminal.
To add more: The release schedule for Django puts out major versions every 9 months that are incremented x.x.y - where x is major version number and y are minor updates that never break compatibility with their major version. So this means 2.0 will follow 1.9 in major releases but no extra significance will be placed on the first place's increment. Also, compatibility is maintained for two major releases after a feature is deprecated. The previous two major releases also receive security patches. Some major releases are additionally marked as LTS - however 1.4 is the only LTS at the moment. The project is really well run and extremely well documented - part of the reason it has had so much success, I think. 
Well, I actually sent the release notes to my colleagues as an example we ought to follow!
How did that go? Any major gotchas to look out for? I have a 1.1 looking for some love if they give me the time... 
 if out[i].rstrip()[-1] != ':': out[i] += ':' Good grief. Is it really that easy? This makes me wonder if it would be just as simple to add a "*With* semicolons" encoding. Edit: Is it typical to abuse the encoding like this to implement a preprocessor? I get the impression that this hasn't really been done before. I vaguely recall some other language bending features based on "import" instead.
God I feel old. I remember using SDL back in 1999. Time flies! Great projects, both SDL and yours ;)).
Have a look at a Python module called mechanize.
&gt; Don't use it, don't look at the source, forget this. Well, then why?
Because fun? Because learning?
I don't know. I think my dictionary is way more readable as it is above, than it would be under PEP8
thanks! 
Well the biggest advantage for you would be using a platform that utilized your primary programming language.
Nice. However I think that the BSD license is quite inappropriate. Are you aware of the [Chicken dance license](https://github.com/supertunaman/cdl/blob/master/COPYING) or the [WTFPL](http://www.wtfpl.net/txt/copying/)?
The problem i have with this example is that using the `functools wraps` you save some of the original information about the function including docstrings and such. 
Now that I look at it, apparently it was 1.2, not 1.1. There are lots of major and minor gotchas! However, it was tougher to move from .9x to 1.1 (and *then* 1.2) a few years back, though. Went from an apache/mod_python install to apache/nginx/mod_wsgi, and then there was a python upgrade, and then a hosting change. Ugh. Anyway, this time was better and not as troublesome. The biggest change this time was doing things the right way, and I had some help from a more experienced dev (that's the *real* difference). We basically kept the same models, but rewrote the settings, urls.py and most of the views. I was paid to upgrade, but we actually rewrote. Static media is handled differently (better), and some generic views were troublesome. Lots of syntax changes. I also upgraded from and ancient version of mezzanine to the most recent version. That was a bit of a bear, also. [This post on github](https://gist.github.com/imagescape/5491251) helped a bit. If I had to do it again (by myself), I would probably upgrade by version and take it all in steps. 1.2 =&gt; 1.3 =&gt; 1.4, etc.
I think using encodings for this kind of thing is novel. Using sys.meta_path with custom loaders that preprocess imported files, usually on an AST level, is "usually" how you would change the language.
do you write embedded code often?
but,i will sent 100 request in one time,and all interact in one time,maybe it will use twisted?
It fails if there is a comment right on the line that needs a colon. Also, you can already use semicolons in Python. People will yell at you if you do, but still.
&gt; I would probably upgrade by version and take it all in steps. 1.2 =&gt; 1.3 =&gt; 1.4, etc. That's my plan, if I get a chance to do it. I've done similar (non-Django) upgrades in the past and that minimizes the pain each step. Upgrade, run for a few weeks, then upgrade again. Thanks for the tips!
I felt real pain reading that example on github!
WHY!? What's wrong with colons??
Cancer I guess
yeah, because someone doesn't want to offer an ebook version of a book is the same thing as treating you like a criminal...
The silent killer.
No. But once i worked in it and i keep myself informed about it a bit. 
well I may have exaggerated a bit but it feels like they do assume that you will pirate their book if you get the chance, it's not that they have to invest resources in ebook development, especially when previous versions did offer it. to me it feels a silly and I would rather not support practices like this especially since python is open source driven language so it goes against the pythonic philosophy as well.
Fair enough. I write it often and think we embedded folk are both; super conservative when shipping code, yet super lazy if it means getting a proof of concept out the door. http://bjorn.tipling.com/if-programming-languages-were-weapons ("Rust is a 3d printed gun. It may work some day.") is a pretty profound summary. Rust will matter approximately the same time C doesnt....
Short [link](https://www.packtpub.com/hardware-and-creative/practical-maya-programming-python).
I think you may have missed the point I was getting at: your code needs to be readable AND maintainable. It's a balancing act. At the moment you're making it a tiny bit more readable (and even that is arguable) at the expense of maintainability in the future. As others have said, of course you can format your code any way you wish. But one day, when you're reformatting dozens of lines of code because you changed one character somewhere, or you're trudging through commit histories that are ten times bigger than they need to be, you might see why the programmers that came before you decided it was a bad idea to align operators.
Because learning is always the best reason when programming or attempting to be a worthwhile human being.
&gt; yet super lazy if it means getting a proof of concept out the door. Yet there's little acceptance to something like elua for proof of concepts. On the other hand , the arduino and mbed seem to be quite popular for proof of concepts. The way i read(maybe wrongfully), is: 1. people like to take code from their proof of concept towards the real implementation. 2. people dislike learning 2 languages. 3. elua and micropython only cover part of the prototyping use case. I'm not sure they have a good hard real-time story . &gt; Rust will matter approximately the same time C doesnt.... Not sure i agree. I can see a time when 10% of embedded programmers do stuff with a mix of new rust and old c libraries - and those programmers will get better results and drag the rest. But sure, like you're link - it's in the future. And a question - if embedded devs are progressive , that means they fear bugs. Shouldn't they use something like ADA ? or is the reason other? 
You are right. :) Already support it, since version 3.4.
I wonder BTW, do you see a shift of doing production work in the mbed in the future ? 
that looks so nice
If Python had more consistency with naming and syntax then I agree with you. But I went to Ruby cause it looks to me more consistent.
What about a pointed stick?
In his defense, when 2.6 was released he was getting bombarded with a ton of hate and negative messages. His reaction to you probably wasn't personal, just a result of the entire situation.
What's good about them? They're just an annoyance, Coffeescript e.g. gets by fine without them.
You can already write Python "with semicolons." This is perfectly valid: x = 0; for i in range(50): x += i; print (x);
Ruby makes things consistent by having multiple names for everything so you can use the one you prefer. Better hope everyone else chooses the same.
Only the paid version supports it.
I'm using oauth2_provider app from django-oauth-toolkit (currently the newest version). It implements south migrations. Do I have to wait for them to do django migrations before I can use it in 1.7?
I've been using them for some servers and 2 apps - they really are quite good. They've eliminated false alerts too (had that problem maybe a year ago). Free account for about 7-8 months now. Never been pestered over the phone, though I was over email - which is fine. That's to be expected I guess, got to earn now they're not a startup anymore :). Can you just delete your mobile number from your account? I never gave them one, so they never called me. I've heard AppDynamics is similar and saw a few of their ads a year ago, but have not used it. For what is purely a list, though it is a nice list, try http://www.getapp.com/alternatives/new-relic-application .
Follow the upgrade docs, and continue where you left off on the tutorial. Or just keep going with 1.6.
https://docs.djangoproject.com/en/dev/internals/release-process/
I tried both languages back in the day, picked python, the TMTOWTDI philosophy ruby inherited from perl just feels wrong, I practice the Zen now. There should be one-- and preferably only one --obvious way to do it. 
Another project that uses encodings to play with the language: https://github.com/dropbox/pyxl
If I was a jerk, I apologize. 
Yes, by "current versions" I mean &gt;= 3, since 3 was released about 6 years ago, and the final 2.x release was 5 years ago. --- I googled web3py. The first result is a thread last updated in October 2013 in which the lead developer (Massimo) says &gt; nobody has shown must interest in helping do it. --- The second result seemed more encouraging: another thread that, after leaving off in August 2013, has a post from a couple of months ago indicating that Giovanni Barillari is working on it and submitted a pull request to Massimo. So I checked Massimo's web3py repository -- it hasn't been updated since 2012. The pull request is in the history, but was closed by Giovanni 5 days ago, unmerged, without comment.
Scrapy is meant for "larger" scrapes or crawls. For instance, say you wanted to crawl many different domains, each domain having many URLs you need to hit, and then aggregate all that information into a database. Scrapy's a good pick there as it's a "framework" - a lot of scaffolding is already in place to make this easier for you. If you're doing something smaller - something that isn't really a "project" - bs4 is a great pick. It's kind of a "get out of my way and just let me scrape this data" library. You can easily just use Python's sqlite or csv modules to write the data how you need to. BS4 gives you more control, but it'd also be more work to write a large crawler. Scrapy calls itself a "framework." BS4 is a "parser." Scrapy allows you to use CSS selectors or XPath as your parser, but it also works with BS4, so you can actually use Scrapy and BS4 at the same time. If you're familiar with Python web frameworks, I'd argue that the use-case for Scrapy vs BS4 is very, very similar to why you'd use Django vs Flask.
I wrote a pretty popular introduction to web scraping a while back (was the top post here in /r/python for a day or two). It uses BS4. Hope you find it helpful. http://www.gregreda.com/2013/03/03/web-scraping-101-with-python/
Or if someone accidentally ends the line in a space.
BLASPHEMY BURN HIM AT THE STAKE.
Yes, the colon removal algorithm is really basic (this was not the interesting part). I might improve it later.
He was talking about syntax. Ruby is more flexible syntatically so it's easier to make the code look the same, whereas you run into whitespace corner cases and have to ugly up your syntax for Python moreso.
Will read it aswell :)
Just so you know, newrelic is blocked by NoScript.
No hate directed towards you OP, but this post reminds me of [this talk](https://www.youtube.com/watch?v=QPRqQH_30hU)
What syntax problems are you referring to? I don't recall any I've run into (though I do have poor memory).
Yes, but you can't do cool stuff like this: i = math.acos(t/r) if (a and b and c and d) else math.atan(r/t); You need another set of parens, which makes things slightly more confusing: i = (math.acos(t/r) if (a and b and c and d) else math.atan(r/t)) Speaking of which, I like the ternary operator a lot more because it's easier to follow when reading. You shouldn't run up against something later that forces you to reevaluate something you've already read. i = (a and b and c and d) ? math.acos(t/r) : math.atan(r/t); 
Try [/r/learnpython](http://www.reddit.com/r/learnpython/), which contains the answers to most of your questions in the sidebar.
People will probably hate me for this but I fucking love Coffeescript's syntax. It's got everything I like about Python's, plus it's cleaner and clearer to look at, **and** the lambda syntax is a million times better!
Ah, you want implicit continuation across lines (at same indentation, I assume) until a semicolon. That could be interesting...
the `rstrip` call will take care of trailing whitespace (`"hello ".rstrip()` == `'hello'`)
I really like the lambda syntax in coffeescript. Julia has the same lambda syntax which I think is awesome.
I'm talking about django 1.7, not just django period
The syntax is very nice, only thing I don't like it's permissiveness and the more-than-one-way-to-to-things philosophy I guess it took from Ruby, like optional function parentheses. It can bite you.
After skimming the source, I get the feeling something like this would break it: callAFunction("with a lot of arguments", "that span several lines.")
Mechanize would make it easier to emulate a user but it depends on what each client needs to do. If you can use twisted it would surely handle the concurrency part.
Mechanize would make it easier to emulate a user but it depends on what each client needs to do. If you can use twisted it would surely handle the concurrency part. With mechanize you will need to look into ways of running many at a time, either with the multiprocessing module or alternatives.
Derp! Missed that. 
For the record, they will likely invalidate any buyers that bid on the same items from the same client address. This would be obvious exploitation.
Try pywinauto.
Why not go through the tutorials to see if it has an advantage in your opinion?
Since you don't appear to have read why getting an ebook into an acceptable format is hard, let me summarize: * Ebook formatting is badly documented and inconsistent across devices * Getting it right is hard. Even O'Reilly messes it up on a regular basis. * Two Scoops of Django, like any Django book, has long class names. This makes it harder * Getting it wrong is not an option for us. Even if we decided to just do something that wasn't perfect, the negative reviews on e-book formatting hurts (actually kills) sales. Any author/publisher who tracks their sales knows what happens with a SINGLE middling or poor review. * For the 1.5 edition, it took about 40 days to get the book into roughly decent e-pub/kindle format. For the 1.6 edition and all the changes, getting ebook formatting right would take at least two months of full time work. * The print edition of Two Scoops of Django 1.5 has sold **over 5 times more** than all the electronic editions combined. It continues this pattern to this very day. Which brought us to the conclusion that it doesn't make any financial sense for us to **give up two months of full time work** to produce an electronic edition that will sell 20% as many copies as the print edition. I'll end this with the note that f you are willing to pay us (Audrey and myself) two months of our normal salary/rate in order to produce an ebook edition, we'll consider it. For reference, if we made minimum wage (we don't) that would be at least US$6000.
you're free to re-license the software though, so who cares?
They're passing a tuple to SetCursorPos. It only takes one parameter, a 2-tuple with elements X-coordinate and Y-coordinate. 
I honestly have no clue about ebook formatting but no one is asking for ebook, people are asking for digital edition, i.e. pdf. which shouldn't be hard to do(did more than enough pdf "games" in my time at college). Regarding the sales, the figures are of course it's skewed when the digital pdf's price is pretty much the same of printed book + shipping. At the end of the day it's your business so do whatever you please, but as a responsible consumer I'd rather support someone who provides a more reasonable alternative.
use pycharm as your IDE. it's awesome. but to start, use ipython. 
I don't hate you at all. I think Coffeescript's syntax is excellent, and should be used by all other dynamic languages. For the most part. I do think that some parts of its syntax are too lax. Examples: http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/ So when I write Coffeescript I always include parentheses and commas where I'd otherwise use them in a language like Javascript or Python, and ignore the parts of the language that are just too free-form and open to ambiguity. Never had a problem. By the way, if you're interested in Lua take a look at [MoonScript](http://moonscript.org/), which is to Lua as Coffeescript is to Javascript.
Ruby has it too, kind of. And Haskell. Hell, even Java has it now. And C# has it but with `=&gt;` instead of `-&gt;`. Python is one of the few modern languages not to have that syntax, in fact.
Your alignment is wack. Holy shit it's terrible. If you're the only one who's gonna read your code, that's fine, but if not, you should stick to PEP8 or another established style guide. Even if you personally don't think PEP8 fits your personal preference, you should make a compromise because the Python community agrees on PEP8. Every point in PEP8 has been extensively argued by expert Python programmers, and the reasons for some of the choices in PEP8 won't be clear to you for a while. The main reason why PEP8 discourages alignment is because when it comes time to make a change on one of the lines, you don't want to spend time updating the formatting of the twenty surrounding lines. This rule isn't PEP8-specific, plenty of styleguides have it. Your style is also incredibly *inconsistent*, which is the worst sin of all. Other issues: * If you're referring to `locals()`, you're probably doing it wrong. Just pass in the variables that are required. * Don't use capital letters for variables that are user-inputs. Capital letters are used for constants. This is a programming-wide convention. * `pick_0or1` is a terrible variable name both semantically and syntactically. * Don't wrap short lines like the strings in your question dict. * Don't wrap in the middle of words. * Dictionaries are overkill for constant strings. Consider either using a common variable name prefix ("COMMAND_MOUNT", "COMMAND_FIND", ...) or a class with static attributes (Class Commands: mount = "blah"; find = "whatever"; ... (but don't use semicolons, use newlines)). * Or just make a function for each command... def mount(server_name, user_name, password): run('sudo mount whatever blah ...'.format(...)) * Use empty lines to separate blocks of logic. 
Try generating an input event instead of using SetCursorPos. http://stackoverflow.com/questions/3720938/win32-moving-mouse-with-setcursorpos-vs-mouse-event
Colons serve a definite purpose [1]: &gt; The colon is required primarily to enhance readability (one of the results of the experimental ABC language). Consider this: &gt; &gt; if a == b &gt; print a &gt; &gt; versus &gt; &gt; if a == b: &gt; print a &gt; &gt; Notice how the second one is slightly easier to read. Notice further how a colon sets off the example in this FAQ answer; it’s a standard usage in English. &gt; &gt; Another minor reason is that the colon makes it easier for editors with syntax highlighting; they can look for colons to decide when indentation needs to be increased instead of having to do a more elaborate parsing of the program text. This is an admirable hack, but it would be a regression. [2] [1] https://docs.python.org/2/faq/design.html#why-are-colons-required-for-the-if-while-def-class-statements [2] You might argue that other languages which don't use colons are easier to write, but Python's primary design goal has been readability.
Depending on what information you use from New Relic, there are different alternatives. [silk](https://github.com/mtford90/silk) works seamlessly with django apps, profiling specific HTTP calls. Tools like Munin can help monitor system resources over time. 
Use AutoHotKey
you're going to hell mate
It is possible, however it will not work for all applications. [Python Screenshot of inactive window PrintWindow + win32gui](http://stackoverflow.com/questions/19695214/python-screenshot-of-inactive-window-printwindow-win32gui)
&gt; vindictive Uh really? The devs obviously talked about it and moved it forward. I doubt "because it's vindictive" was the reason.
This looks very interesting! Any screen shots, or a live demo??
Or replace line ending "then"s with colons for some serious violence.
this guy
You shouldn't use `pickle` for something like this, use plaintext, json or something.
You can run your code through a PEP8 style checker like this one: https://pypi.python.org/pypi/pep8 If you use VIM, you can use a plugin called syntastic (https://github.com/scrooloose/syntastic) that will run the pep8 tests every time you save your code. I'm pretty sure most of the Python-centric IDEs will also run these checks as well.
Does anybody using a TI calculator really need more than a few dozen bits of precision? I believe I've observed similar rounding errors on TI-84s and TI-89s anyway, are you sure they use such high levels of precision?
I suppose most people would consider the admin to be the primary advantage, but it's a fairly subjective debate so you need to make your own opnion really.
Was it when django was 0.96?
It is though. It would be different if this was punishing those who needed to fix their code. This is instead an attempt to enforce a semi-controversial policy by breaking existing good code.
Great points all around, thanks! Getting python set up can definitely be a pain; I can't imagine setting up computers for a whole class... and with restricted access, no less. Ouch. I really hope to see [skupt](http://www.skulpt.org/) or something similar work out. I've also enjoyed my limited experiences with coffeescript (somewhat pythonic language which parses to javascript). The latter is probably no good for a HS course, but skulpt and (maybe?) [trinket.io](https://trinket.io/python/2a713e9b2d) may allow your students to share simple programs more easily. Javascript has the upper hand for now, but I think python is too lovable to lose out in the long run.
I love what I've seen happening with Skulpt. Trinket is new to me.. gotta look at that. Thanks!
If you use the second example and indent lines 2 and 3 over by one more column, it actually looks pretty reasonable.
Thank you. Always looking forward to buying whatever comes out of Two Scoops Press!
I'm not at a computer right now to test, but doesn't Python support backslashes for something like this? i = math.acos(t/r) \ if (a and b and c and d) \ else math.atan(r/t)
You're probably right about the timing. The hate signal is somehow extra brutal for people putting out learning materials in the tech community. People who haven't ever lifted a finger to help anyone learn anything come out of the woodwork and attack you. Being a well known figure in teaching people a technology makes you a lighting rod for their current frustrations, incompetence and shame for not understanding something important as an adult. The audience is, by definition, incompetent and many of the emotionally unaware ones are prone to projecting that on whoever they contact regarding the technology. Couple that with the fact that hundreds of positive statements usually don't stand up to one negative one when you put your best work out there. If the scales tip negative for a while, it's definitely a hard place to be. 
I just tested this and you're right, it does!