Or you could have used mysql + phpmyadmin. ( no coding involved) Or a CMS like ofbiz or drupal or joomla. ( also no coding involved) Or heck, Google spreadsheet Docs. ( you get the idea)
No playing with a server for me. I'm hostage to a hostile IT department.
I have been meaning to go for quite a while, but every month something comes up!
gotcha.
I do not get it what is up with all that thinking that every app from now on must be web app. This trend is several years old and we are still stuck with desktop apps. Yeah, accounting program with integrated twitter/facebook status reporting, that would be a kicker. "Our company has 20k$ deficit - 29 people like it!" And then mysql+phpmyadmin. Bah! Don't get me started on that. -- Slow morning, needs more caffee.
Programming is 3rd or 4th on my list of hobbies and a nice secret to keep as I work with a lot of non-profits that have no clue on computers much less security. Can someone give me a site or academic paper that explains the significance of this please? I know enough assembly to break it really well. Why would you give up the speed of stacks? My one possibly significant though is that I only know about the x86 world. Deep mining of my memory to RISC versus CISC (I don't mean to step on to the nuclear land mine of that debate) brings thoughts of both having stacks. I appreciate the (helpful) feedback!
http://en.wikipedia.org/wiki/Stackless_Python
How is it compared to PyDev?
Stackless has moved from continuations to microthreads, and the name is no longer as directly applicable as it once was. See [this discussion](http://en.reddit.com/r/programming/comments/bmgo8/switching_call_stacks_on_different_platforms/) for detail on how Stackless works at a low-level. That is, by doing "stack slicing".
actually except Exception, e: ist the Python 2 syntax.
since exactly when jquery teaches ninjitsu?
&gt; I do not get it what is up with all that thinking that every app from now on must be web app. This trend is several years old and we are still stuck with desktop apps. Yeah, accounting program with integrated twitter/facebook status reporting, that would be a kicker. "Our company has 20k$ deficit - 29 people like it!" &gt; And then mysql+phpmyadmin. Bah! Don't get me started on that. Seriously though, you didnt make one valid point, just a bunch of non-sequiturs.
I'm sure theres a gtk based app that does what you want, I can't remember what it's called right now tho :/
Far less prone to grinding to a halt for large projects and it hasn't yet forgotten the path; overall far more stable imo. But, dont take my word for it; download and use the beta.
it's uglier than pydev
what, no love for folks in the STL?
**tl;dr** I've searched high and low. Now, it's just one of those things I want to do. :) **--verbose** [pygtkmvc](http://sourceforge.net/apps/trac/pygtkmvc/wiki) looked really nice except it listed SQLObject support as experimental and SQLAlchemy support won't be available until the next release. I promise I looked at all the Sqlite front-ends in Python I could find. For one reason or another I just didn't like them. If I remember correctly, the problem was usually that the GUI was something I didn't like (e.g. Qt) or the database was something I couldn't use (e.g. PostgreSQL). I'm wedded to Sqlite because it has to be a server-less, file-based database like Access. I think Open Office's database has this ability but I don't want to install it and I didn't like it the last time I tried it. Besides all that I like Python, Sqlite, and GTK each separately and in combination (so far). So I figured I just might as well do it myself. I may be foolishly reinventing a wheel but, Hell, it's fun anyway. As far as reinvention is concerned, it's not always bad. Sometimes re-inventors do it better; observe [tmux](http://tmux.sourceforge.net/).
Agreed. I think that the syntax highlighting is better in pydev/eclipse but I've just found pycharm to be less prone to odd behavior (like suddenly being unable to resolve imports).
I didn't see anyone mention [dabodev](http://dabodev.com/)? Sorry, if you're not terribly committed to GTK, this seems to be a more packaged solution. Multiple backends, including even SQL Server, and i think the Windows installation problem is already solved (doesn't interfere with existing python installation).
Your code works, but you should be using word.lower().endswith("py") and that function is made for this exact use case.
I think it would be useful if you could do it for any type of application, not just games. And by the way, pyjamas was really buggy last time I tried it. I'm not sure how your experience with it has been.
I suppose, yes. I was more envisioning a game engine written in python that has features limited to that of javascript, so it wouldn't really be useful for other applications
If you aren't freetarted, take a look at Gestalt/Iron Python. I can promise that it works better than Pyjamas.
I can't find what gestalt is, but Iron Python is microsoft only, and doesn't work for the web. And regular python has a lot of libraries for game development already. Although it might be interesting to program DirectX in python.
http://gestalt.codeplex.com/ - It lets you plug into your browser as a client side language. And no... Iron python runs just fine under mono as well.
and macs. As long as it's not for your silly little phone, you should have no problem running it.
Ah. I'm not sure what the overhead here is, but wouldn't pure javascript be more efficient?
&gt; Iron Python is microsoft only, and doesn't work for the web. False and False
Congrats on refuting a sentence supported by no facts with...no facts. [Citation needed]
IronPython is (right now) only a nice proof of concept that has some serious issues. Edit: try to get docutils running in it if you don't believe me. Considering the first pure python library I tried to port over died a horrible death, I'm not too enthusiastic about it yet.
[Github](http://github.com/) seems to be one of the most popular code hosts at the moment and free for open source projects.
Thanks I will take a look 
IronPython works on mono, and Gestalt makes it work in the browser.
I wonder if http://www.panda3d.org/ could be used to make the 2D games you're looking to make. I know someone suggested IronPython earlier but hell, if you're going to make them download a plugin anyways, it might as well be something non-microsoft; some of us don't want to get mono.
What is this, a school? Look around on the internet. I mean is it that hard to figure out?
Whose they? The user shouldn't download anything. It'd be a javaScript game in the &lt;canvas&gt; element. HTML5 browser would be all that's required. 
What were the specific issues you saw with docutils? What are the "serious issues"?
i'm actually working on something very similar to this. i have very little to show right now because i'm still getting the hang of javascript. i haven't considered pyjamas, but i'd rather just learn javascript since it's not going anywhere anytime soon.
The only reason I mention pyjamas is because it aims to do what I want but for applications as apposed to games. It offers a widget set instead of game engine logic. The only component of pyjamas that would be used is the python -&gt; javascript compiler.
bitbucket.org is also nice if your using mercurial
Great tool. Here is the changelog: http://sphinx.pocoo.org/changes.html#release-1-0-jul-23-2010
But it seems to require Silverlight? I think the point is to have it run without any plugins. Otherwise it's no different than a Flash game.
Can you explain how is mysql+phpmyadmin, ofbiz, drupal or joomla better than little pyGTK app accessing sqlite data?
http://paste.pocoo.org/ is nice for quick and dirty sharing.
No. This is the reddit and you are expected to support your statements, especially when they contradict someone else. Look around on reddit it. I mean, is it that hard to figure out?
At first IronPython couldn't to convert several of the BOM strings that docutils used for unicode support. Then, because IronPython has no native unicodedata module, I had to use a proxy module. Finally, after all this was fixed, IronPython itself crashed due to a StackOverflowException error. Poking around the [issue tracker](http://ironpython.codeplex.com/workitem/list/basic?field=CreationDate&amp;direction=Descending&amp;issuesToDisplay=Open&amp;keywords=StackOverflowException&amp;emailSubscribedItemsOnly=false), I discovered that there a surprisingly large and disparate number of cases where this exact type of exception could occur. At that point, I opted to simply write my own HTML generation utility instead of further trying to salvage IronPython-docutils support. Naturally, the whole thing left a bitter taste in my mouth. I can understand and work around the lack of full unicode support, but to me the StackOverflowException was the end of the line. I'm still using IronPython (as it is a really awesome project), but I am much more cautious about its use. 
&gt; features limited to that of javascript, so it wouldn't really be useful for other applications Javascript is only useful for webgames?
Pygame has been talking about this for a looooong time. The PyPy guys have been working on an AS3 (read: Flash) backend for the compiler. I think there was a JS one but its crazy slow since PyPy isn't a source-to-source translator, it is a compiler. The trick would be converting calls into Pygame into the appropriate AS3 instructions. This is a non-trivial bit of work and requires knowledge of PyPy internals, AS3 internals, and Pygame internals.
http://pypi.python.org/pypi is the right place.
I don't know, but I would love for somebody to tell me how I can possibly build SciPy, I swear I tried everything*. * Then I installed Ubuntu and watched TV and it was lovely. 
I like using [Eclipse](http://www.eclipse.org/) with the [Pydev](http://pydev.org) plugin. It's easy to [setup](http://pydev.org/manual_101_install.html#installing-with-the-update-site) and offers a lot of tools to help you out. If you've never used Eclipse before, it may look like a daunting IDE but it's one of the coolest I've ever used. Edit: Some things you might like about Eclipse (but are in no way exclusive to it) are auto-completion to help you recall methods and class members, suggestions to fix syntacticly invalid code, an awesome plugin manager once youre comfortable enough in Python to explore its many libraries and frameworks, etc.
&gt; It's easy to setup not for a newbie like OP (per my perception)
&gt;but this seems incredibly odd It's not an advanced IDE, but why is it odd?
Try Komodo.
Start with Komodo Edit, it's free, before making the jump to the (fantastic) paid version.
[Wing IDE](http://www.wingware.com/downloads) "Wing IDE 101" is the freeware edition, install and you're ready to go, no plugin this-that I do [this](http://i.imgur.com/4bdpI.jpg) all the times
Well PyDev has some [pretty good tutorials](http://pydev.org/manual_101_root.html) for beginners on how to set it up and work within eclipse.
In case you weren't aware, you could do this right now - write your code in Notepad++, save the file as a *.py, then double-click the file. Clearly most of us (me too) feel this is too many clicks, but it's worth remembering that this isn't so hard. I like [PythonWin](http://wiki.python.org/moin/PythonWin) for the time I spend with Windows doing python development, which isn't enough time for me to have explored many other options.
Just Vim which is comfortable for me and Python REPL which is enough good already.
&lt;sigh /&gt; and yet more to deal with/read before what one *really* wants to do *right fucking now*. sometimes one just want to hop into a car and drive to point X without having to build the car first. I dunno, I'm busy and jaded and life is short so I want to get going to my goal.
You could install cygwin and use the bash shell to launch python or ipython with your script name. Or save your code in a directory in your PYTHONPATH and use it as a module, and reload it when you make a change.
That's what IDLE is for.
Eclipse with PyDev rules and has worked very well for me for a long time, but lately I find myself using the Python portion of NetBeans. It's very good. 
This is a rather controversial topic, so take what everyone says with a grain of salt. That said, my $.02 is this: You're on the right track with just wanting a text editor. IDEs have a lot of fancy options that can be confusing when you're still trying to get a grip on the actual mechanics of coding. Also, some of their features can be used as a crutch. It's very healthy to *know* what the correct name for methods is, and when to indent for control flow, and what a stack trace (error message when you run the program) looks like, and not just have your IDE say, "Whoops! I think you meant *this*...and by the way, are you getting ready to type *this*? You should be." So my recommendation is [gedit](http://en.wikipedia.org/wiki/Gedit), which is the default text editor on many Linuxes (Linuces?), but has a [Windows port](http://live.gnome.org/Gedit/Windows) available. It has a few "healthy" features, like syntax highlighting, line numbering, matching-bracket-highlighting, and so forth. It also has a number of built-in plugins that you may find useful. You can get an interactive Python session running in a sidebar (actually an under-bar). You can mass-indent code (instead of tabbing each line by hand). And if you install the "Better Python Console" plugin from [here](http://live.gnome.org/Gedit/Plugins), pressing F5 will run your program. And even if you ignore most of the above...isn't [this](http://upload.wikimedia.org/wikipedia/commons/d/df/Gedit2261.png) prettier than [this](http://upload.wikimedia.org/wikipedia/commons/9/90/Notepad%2B%2B_screenshot2.png)?
Not sure if this is what you're looking for but I'll just leave this here: http://users.cse.ucdavis.edu/~cmg/courses/nlp/Software/Windows/npp.html Slightly dated since you're probably not using python 2.5, but I have faith you can get it to work. Note that you'll need to add something like raw_input('Hit enter to exit') at the end of each program if you want to see the output. Otherwise it will execute and the terminal will disappear. &gt; Can I avoid using command and other things Eh... You do realize you're programming, right? Ideally you'd want to avoid using anything but a text editor and command... You could *improve* command by installing cygwin, console2 and download &amp; install setuptools (aka easy_install) then type easy_install pyreadline easy_install ipython and now your python terminal experience is about a billion times nicer All that said... consult google and stackoverflow next time. This question has been answered a billion times before.
Get [Aptana](http://www.aptana.com/), they bought PyDev and ship Eclipse with a brain dead simple PyDev setup (free). I have a separate Aptana install (different from my other eclipse install) just for python.
Might as well just use CoffeeScript - it's built precisely to compile to JS and it gets you 80% of the comfort of Python.
Also, [sphinx 1.10 beta](http://sphinxsearch.com/) is released. I sense a standoff looming.
Very embarassing... but actually clicking the file is exactly what I was looking for. I could swear I tried this already, but I just did it again and it did what I wanted it to. Oh dear. edit: It seems to close immediately when it's finished, even if it is supposed to display information. Any fix?
then try spyder. it's good for small projects. 
add raw_input('Hit enter to exit') to the end.
ucdavis! ++
Live indexing = hellz yeah.
Was referring to the IronPython suggestion. It would require Silverlight/Mono
[Wing IDE Personal](http://www.wingware.com/downloads) It's a good windows-based ide &amp; it's free for personal use. Shame it's not open source, but it'll get you up &amp; running.
An alternative way to do this is: import os print "hello world" os.system("pause")
Yup, fellow Vim user here, this is what I do to setup my Vim the way I like it for Python... [Follow this guide](http://henry.precheur.org/vim/python) I also put the line colors evening in my ~/.gvimrc file, for windows users this is C:\Program Files\Vim\gvimrc After opening the file in question in Vim, I'll point a terminal at the directory it's located in and run it. Then when I want to test a new change I press up and enter in the terminal. That way I never take my hand off the keyboard to reach for the mouse.
Seconded!
where does it say "Wing IDE Personal" is free ? I [already said earlier](http://www.reddit.com/r/Python/comments/ct3na/is_there_a_better_way_to_set_up_for_python/c0v1gsd) that the 101 edition is free.
why don't we just all go back to vim.....
I would look more carefully at the Wing IDE posts in here. The debug mode in there is an invaluable learning tool as you'll be able to see what your program is doing, line by line. Have fun!
For what it's worth, I've written applications in Python to the tune of thousands of lines of total code across multiple files and I used IDLE. I edit my code in a new IDLE window and when I'm ready I hit F5 to re-run it. It works well.
ubuntu vm + some editor maybe geany whatever you like. Learn your editor well though it becomes your tool.
Heh, you maniacs. 
Eeer ... What's stopping you using Notepad++ ? It supports python, I believe. IDLE has more features than first appears. It's has class and module browser windows, a code-context display, code-completion and a decent graphical debugger.
I second this. The intro to programming class I'm TAing is Python through Wing IDE, and the inexperienced undergrads find it extremely easy to set up and start using.
Python modules are compiled using the flags used when python was compiled. Maybe it's possible to override distutils flags, but otherwise, what you can do is to compile your own python.
Have you tried, CFLAGS="gcc -arch x86_64" pip install … ?
Use Scite. With a little config you can run your code from within the editor.
IDLE is fucking ugly and interacting with its widget set is very, very odd for GTK+, or Qt, or Win32 users.
&gt; Can you explain how is mysql+phpmyadmin, ofbiz, drupal or joomla better than little pyGTK app accessing sqlite data? Sure. You dont have to write any code to implement mysql+phpmyadmin, ofbiz, drupal or joomla. It takes 5-10 minutes to install it on a running *nix system. and any bugs taht are found, you dont have to fix, just post the bug to the issue tracker and they will get fixed. This is way cheaper and better than desiging , writing and implementing your own solution (regardless of language you choose to implement it in)
This is not the answer you are looking for but honestly, try a linux distro (ubuntu is a great start). The difference is like night and day.
Use the ARCHFLAGS env variable: ARCHFLAGS="-arch x86_64" python setup.py build ... Do NOT use CFLAGS, etc... distutils is extremely fragile, and it will cause more trouble than it worths
Install this: http://www.python.org/download/windows/ and use PythonWin. It's quick, simple and you can run the files directly in the editor window. You also get a bunch of other useful Windows stuff installed at the same time (like bindings to control Office Apps and other OLE objects)
Seconded! And it's not too hard to set up.
Don't use Windows. Don't use an IDE. No seriously, it's only going to get in your way of learning. Just throw that shit right out. Minimize distance between your brain and your goal. Minimize "magic" tools that hide how anything actually works. Accept no free lunches, avoid sugary shortcuts and carb-saturated "frameworks". * Use IPython. Interactive experimentation on a REPL is simply unbeatable. * Use a text editor. Not an "IDE". Use vim, emacs, nano, whatever. If it mentions a "wizard" or "project settings", destroy it with fire. * Learn. The 30s bootstrap: * Download and install IPython: http://ipython.scipy.org/dist/0.10/ipython-0.10.win32-setup.exe * Start it. * Learn. Go from there. :)
Github seconded. It's very good.
Specifically (in my case) gvim + [NERD tree](http://www.vim.org/scripts/script.php?script_id=1658), + learning to use tabs. It took me ages to learn about latter two things and I'm now annoyed with myself for not doing so earlier. Might be a lot to take on at the same time as learning Python though.
Last time I used windows (some time ago) you could set up a shortcut that let you specify that you didn't want the console window to close after you program exits. Or you could just run it in a command shell (python myfile.py).
Came to suggest kate instead, it's similar to gedit but KDE based. Other than looks KDE gives it one advantage, if you decide you want a full IDE for something (say creating gui), kdevelop uses the same kpart for text editing and so behaves exactly the same.
In a perfect world, I agree - learning is about building a mental model of something. If parts of what we're learning are obscured by "magic", then that magic will become part of our model instead of the "truth". That said, something that is much more important than getting the mental model right on the first go, is having fun while doing it. In almost all cases those two goals clash. Learning "everything", not taking any shortcuts, is not as fun as quickly getting a game or a webapp or a robot or whatever up and running. I would agree strongly that you should stay away from IDE's, they have a learning-curve too, and it's pretty steep for a lot of them. But I would warmly suggest working with some framework that takes care of underlying stuff for you. Focus on building something fun, you'll pick the advanced stuff up as you go :) So UpDown - I don't know what you are wanting to build, but if you're interested in web stuff, I can't recommend the web framework Django enough. It does exactly what you ask for - you edit a file, Django notices, and you just refresh the web page you are working on to see the results.
Doesn't F5 in Notapead++ run the script? (Not used it myself.) Personally I use [SciTE](http://www.scintilla.org/SciTE.html) (in Windows). F5 runs the script and the output goes to the "output pane", which doesn't close on exit. If you get an exception, you can double-click the stack trace in the output pane and SciTE will jump to the offending line. SciTE is happily free from all the "project" nonsense of dedicated Python IDEs -- It's very similar to Notepad++, I think.
Seconded.
I like IDLE too, it looks cool and smarter than other wannabe Python editors. IDE's are just too cumbersome to use with something as slick as Python.
What config? Just press F5 and it runs :D. (assuming the python folder is on your Windows PATH variable) And that's pretty much exactly what the OP is asking. I always just take the [zip package](http://prdownloads.sourceforge.net/scintilla/wscite212.zip?download) and set SciTE to be my default program to open .py files. For the sake of completeness, adding something to your path variable: * Right click Computer * Properties * Tab Advanced * Environment variables * Choose either PATH under your username or under system variables. (system variables = for all users, not just you) * Edit * Go to the end of the line, add a semicolon if there isn't one already and add the path to where your python installation is. (in my case this line looks like `[other stuff];C:\Python26`)
I find [bpython](http://bpython-interpreter.org/) better, but agreed apart from that
&gt; You do realize you're programming, right? Ideally you'd want to avoid using anything but a text editor and command why?
 I'm just learning Python, and this is exactly my setup: cygwin, console2 and gVim.
Me too, also for parsing something like x = xmldoc('somefile.xml') for element in x.select(xpath-expression): print element.attributes # select children too: print element.select(x-path-expession) 
Ok, got it. If something bugs out then file a bug report and be done with that. When The Boss asks about it just point to bugtracker and hope for the fix to be out sooner than later.
[Amara](http://wiki.xml3k.org/Amara2/Seven_days/1) should be your friend.
Thank you for taking my hasty comment and making it actually useful. Upvote and orangered for you:).
&gt; When The Boss asks about it just point to bugtracker and hope for the fix to be out sooner than later. No. Do you know what "open source" software is? You can fix any open source software project yourself. I was giving one possible option. The other option is to fix the bug yourself since its all opensource but really, this is a rare corner case. Most of that software i mentioned is bug free for &gt;99% of use cases. You fail to understand that you have all these problems and way more if you write your own CMS from scratch (regardless of pyGTK, or C, or any other lib or language)
If one has expertise to dive in unfamiliar code/language and dispatch bugs then I doubt when writing a few hundred lines of code in familiar language could end up in steaming pile.
&gt; If one has expertise to dive in unfamiliar code/language and dispatch bugs then I doubt when writing a few hundred lines of code in familiar language could end up in steaming pile. Interesting logic. You sound like a novice programmer. So lemme get this straight, if i am able to submit a patch to an open source project, then thats the same as writing 250k lines of code for a new CMS and maintaining it? You definitely have never had a professional programming job. Good luck! 
If you just click flie -&gt; new window in IDLE you get exactly what you're looking for. When you're done coding, run -&gt; run module runs the script (F5 also works).
Might want to look at genshi.builder for some ideas.
&gt;So lemme get this straight, if i am able to submit a patch to an open source project, then thats the same as writing 250k lines of code for a new CMS and maintaining it? Full blown CMS is not what I had in mind. I am talking about simple CRUD, some logic and UI.
It might not be the answer OP is "looking for" but it is no doubt the right answer. I am not an OS fan (I use Mac at work, Windows at home, Linux at home), and I've got to say that the competitive advantage to programming (especially Python) in Linux is equal to the competitive advantage of using Photoshop or playing games in Windows. Using Python in Windows feels about as limiting as trying to do real photo work in GIMP. If you use Linux, but don't want to use a terminal-based editor (vi, nano, emacs - and yes, I know emacs and vi have X versions), try Geany. It is lightweight and easy to use, comparable to Notepad++ in Windows.
&gt; In a perfect world, I agree - learning is about building a mental model of something. If parts of what we're learning are obscured by "magic", then that magic will become part of our model instead of the "truth". Very well put. I heartily agree.
A full blown CMS can do what a simple crud can do. And logic is still being maintained by you if you write it yourself. You will have to maintain version change compatibility, etc.. I was more speaking about people with experience with software. It sounds like you havent used an open source CMS so you dont understand that bugs are rare and non-existent. You remind me of me when I first started programming. I thought all problems would be solved with C++. While its true in theory, its just not practical. Now that I am more experienced, when i see my problem solved by an open source project, I use it. If i want to add a feature, I submit a patch and it gets added. They maintain the code and compatibility. I will at the very least copy that code and use it instead of writing from scratch. For example, I've been using joomla professionally for 6 years and when I need to add something, i look up some php examples and add it myself. And yes, that is way better than coding that yourself regardless of language you choose to write it in. btw, all phpmyadmin is (and other db editors) is a simple CRUD tool.
Try NetBeans for Python. I think you'll be surprised. 
XSLT!
No, but a game engine is only useful for games.
you got that right
Chrome has pretty good webapps-for-the-desktop support, as far as browsers go. You can also easily locally serve any Python (WSGI) webapp, and if you use sqlite for database storage, it's portable and doesn't require a db server to run. So basically you just need to choose a framework to start building the app on -- my recommendations are Django or Flask. Django has a built-in database mapper, which eases the burden of data access significantly, as well as numerous other included batteries (such as contrib.admin). Flask is new, light-weight and excellently documented, but you'll have to make your own choices wrt database access. I would elaborate more, but I'm on a bus, typing this on a phone. :p
&gt; Don't use Windows. &gt; ... &gt; Download ... win32-setup.exe Say, what?
Good point. It appears that it isn't. I assume that they have changed the licensing. I was using it on a windows machine for a while and hadn't paid for it. My apologies for not seeing that before posting.
If I were you, I'd run linux in a Virtual Machine and do my development there. 
Die. Plus it doesn't help, he wants to generate XML not transform.
I'm a newbie and [PythonXY](http://www.pythonxy.com/) was easy to setup- just one install for everything: Python, Eclipse, SciPy, Numpy, Qt, etc. The only drawback is that you don't get the absolute latest versions of everything.
[XMLWitch](http://github.com/galvez/xmlwitch) basically does what your example shows. It's inspired by Ruby's Builder. Beware though, there are two branches: * master uses string munging and a custom two-parts namespaces syntax (prefix and prefix:namespace are specified for all elements) * [etree_rewrite](http://github.com/galvez/xmlwitch/tree/etree_rewrite) is implemented on top of ElementTree and uses ET's namespace support via Clark's notation or `(namespace, element|attribute)` tuples. It also has no readme, but the doctest file covers more of the library (with comments). Here is your example using XMLWitch (either version I think, since you're not using namespaces) xml = xmlwitch.builder() with xml.root as root: root['param'] = 'some param' xml.subelement('some other param') &lt;root param="some param"&gt; &lt;subelement&gt;some other param&lt;/subelement&gt; &lt;/root&gt; edit: oh in fact you could simplify it even further, @param can be specified directly on the root element: with xml.root(param='some param'): xml.subelement('some other param') the output should be exactly the same as previously.
This isn't exactly related to python (afaik) but you might look at the Xbox Media Center project for inspiration. Its a full featured media center desktop app with a web interface for control aswell. It also has a nifty Android remote control app. Hell its even open source, you could fork it if you really wanted to :P. (And yes people: XBOX media center IS FOR PC, LINUX, MAC as well as obviously xbox (original) I hate to have to explain this, but god i wish they'd change the name already. http://www.xbmc.org
Uh you can do that with LXML already... from lxml import etree x = etree.parse('somefile.xml') for element in x.xpath(expr): print element.attrib print element.xpath(other_expr) ElemenTree also supports a limited subset of xpath via `Element.findall` and `ElementTree.findall`
Also what might be of specific interest to you are the "Scrapers" that XBMC uses to find description/fan art/movie poster. If you actually setup XBMC in full, and use its "Library" mode instead of just file view mode, its INCREDIBLY amazing, best media center experience I've ever had. They do their web-integration really well to pull down as much information about your movies as possible. Sites like http://www.themoviedb.org/ provide all the data you'd want
I just started using bpython after seeing this post, and I love it. It makes doing the "scratch pad" exploratory programming a breeze. I like the terminal-style auto-complete/hinting so much I want this in my editor... is this kind of thing possible in emacs or vim? I'm new to Python and have been using mostly Textmate and PyCharm.
If I am inexperienced by writing my own code then so be it. I can see your point there. If you think that myadmin and other db editors are simple CRUD tools to you then I have nothing more to add.
&gt;Don't use Windows. Disagree with this part. Why does it matter? Komodo Edit is my favorite Python editor; I much prefer it to emacs.
Yes. This is the only right answer IMO. Programming is the #1 reason why I'm on Linux. Among other reasons of course.
&gt; If you think that myadmin and other db editors are simple CRUD tools to you then I have nothing more to add. Hey, im not knocking it, go write your own crud tool. When youre on your deathbed, maybe youll get what I was talking about. As far as phpmyadmin, it is only a crud tool. It also creates and manages crud elements. And im sure im leaving out other features, but it is essentially a way to manage your db tables. I just hate to see people reinvent the wheel professionally. If youre learning, then thats another thing.
XML! It's so easy to parse, no one's ever needed to generate any, or generate any decent tools.
One reason is that you have to compile the mysqldb driver yourself and it's not as easy as ./configure &amp;&amp; make install.
Way more complicated than it needs to be: http://gist.github.com/488871
[Even easier](http://code.google.com/p/python-twitter/)
&gt;Python and it's internal browser wat Well, no matter. You said desktop application, but I keep hearing locally-served web app. Give django a shot if you really want to build this tool in such a manner.
tornado comes with pretty functional jquery/ajax demos: http://tornadoweb.org filesystem read/write: http://docs.python.org/library/os Crawling / scraping is often done with BeautifulSoup: http://www.crummy.com/software/BeautifulSoup/ And maybe sqlite would work well as a datastore: http://docs.python.org/library/sqlite3
A quick search turned up a Firefox extension: [Command Line Print](http://sites.google.com/site/torisugari/commandlineprint2). That sounds like it would be ideal for the browser-automated route. 
See [here](http://www.xhtml2pdf.com/) and [here](http://pypi.python.org/pypi/pisa/), respectively. (Pisa package)
I just started using bpython and I think it's a great way of exploring what Pyhon can do. No windows version yet, though (I think it's a goal of 1.0).
You might get some nice (both visual as well as interactivity) inspirations from [**Delicious Library**](http://www.delicious-monster.com/)
I was surprised it wasn't possible with Python standard library… even PHP has SimpleXML!
I've sometimes used [PyScripter](http://code.google.com/p/pyscripter/)
&gt;When youre on your deathbed, maybe youll get what I was talking about. I am starting to get the picture. &gt;As far as phpmyadmin, it is only a crud tool. Form the source: phpMyAdmin is a free software tool written in PHP intended to handle the administration of MySQL over the World Wide Web. I would never give user access to myadmin for data input. &gt;I just hate to see people reinvent the wheel professionally. Why do not all people use only one given software for their need? I just reed about ffmpeg team making their own [VP8 implementation](http://www.reddit.com/r/programming/comments/ct287/making_the_worlds_fastest_vp8_decoder/). Why did they re-invent the wheel? There was already libvpx. Why bother?
What does the mysqldb driver have to do with this post?
No sense in suggesting to drop Windows just to use Python.
What are the specific limiting factors you have encountered while using Python on Windows? I ask so that the OP knows what to expect, but also because I'm a Windows user and Python committer so I'm interested to know your issues.
From experience, [Komodo Edit](http://www.activestate.com/komodo-edit) is one of the best Python IDEs. You can define repeatable commands (like 'run'), but you have to know what to do (so no magic). It's also cross-platform and free. Also, don't forget to add python to your %PATH% environmental variable. Why the heck this isn't done on windows by default is a mystery to me.
good luck with this! i also have need for app that would be able to get information about my movie collection (file info, screencaps taken from movie /so i can check quality/, move info /actors.../ , comments, subtitles, ...). web access is very important because i use linux+osx and i wan other people to browse my collection. also, some kind of info where the movie is stored (dvd, cd, or one of my many external disks). i used drupal+moviedb in combination with my python scripts (to get info from imdb, cover image, ...). you can check it here http://www.binarni.net/node/1341 . i just had to provide imdb id for the movie. was kind of ok but i wanted to write something from scratch. unfortunately, i don't have free time now. i would for sure recommend you Django + set of python scripts to get info from local files and fetch movie info from external resources (imdb or whatever). if you decide to use Django, for you (in 99% of cases) it does not matter if you use sqlite or postgres. user can choose whatever he wants. and you have already set of good libraries for imdb, or you can use beautifulsoup for scaping info from html. anyhoo, good luck! 
Check out itrackmine.com for some inspiration.
Yea, I know... I want it to be able to scrape your local hard drive, and that's why it's probably going to be desktop-based, but 99% of skills involve web development, so that's why I'll probably go for a locally-served web-app with integration to a remote site. Desktop apps just don't cut it anymore...
&gt; I would never give user access to myadmin for data input. Why not? Keep data back ups and dont give any one permissions they arent supposed to have. &gt; Why did they re-invent the wheel? There was already libvpx. Why bother? Sometimes there are reasons to bring the code in house, but they are few and far between. Now youre picking an extreme corner case with ffmpeg to prove that writing crud tools in house from scratch is better than taking existing code and modifying it. Hey whatever floats your boat, if you have a reason to write and maintain a crud tool from scratch , go for it. I am trying to show how its often a waste of time.
I don't know how I haven't mentioned XBMC and friends. The problem with them is that they are, as you've stated, full-fledged media center, and it's not exactly what I'm looking for, because at the end of the day, I'm not sitting down infront of the TV before I chose my movie, and I need a hell of a lot more features from the app to be *"only"* media-center. In a way, XBMC is too much and too little of what I need, just in different departments, that's why I want to start this project...
Have you looked at Delicious Library?
Understandable, xbmc can be a bit unwieldy. I guess i don't really understand what you're trying to make. Library mode in XBMC is very much a 'catalog' of all your media, that scrapes high resolution fan/promotional/box cover art (that "really pop") + descriptions for all your movies and TV shows automatically. You want this, but basically sharable through a web interface so you can show your friends what movies you have? If you havent used XBMC in a while, i implore you to check it out. They have the ability to setup just about everything you describe by default, if not through the use of plugins. I can respect the fact that this is a learning project through. At least checkout what they've been doing in the past few months for inspiration, XBMC constantly blows me away.
entime asked why it matters which platform you are on. I was pointing out that platform choice isn't just about an editor, etc.
Desktop apps are fine, but your experience is with the web. When you learn to build for the web, you learn certain design patterns, and switching to the desktop can be unnecessarily difficult. On the other hand, desktop apps can be really enjoyable to write. Sometimes I think the reason web apps are so popular is that "the web" has co-opted the entire network paradigm. At least in mind-share. Client-server architectures work very well on the desktop, and you can of course write Asynchronous Python and XML if you want, generating libglade XML interfaces or something similar on your platform.
Glad to see another person putting some time into Python. Thanks, Eli.
Don't know about python but that sounds like a job for cron. You look at inotify yet or are you doing this under Windows?
In linux, and probably windows has an equivalent, you can install a printer driver called cups-pdf (ubuntu and debian). Then a standard call to cups could make the PDF. There are automation add-ons to firefox, but if you can generate the exact page addresses you need, you could do it in bash even. wget $website/$subdirs/$HtmlPage2Get tmpfile cat tmpfile | lpr $HtmlPage2Get + ".pdf" or stick these in a python system call. You get the idea PS broken bash syntax PSS or try [this](http://serverfault.com/questions/48887/reasonable-automatic-html-to-pdf-conversion-in-unix-linux-environment) or [this](http://embraceubuntu.com/2006/03/23/print-to-pdf-using-cups-pdf/)
Could you use time.sleep() and urllib.urlopen() to get the html of the page every n minutes and check whether "quotes.txt" is there?
yes, sorry I didn't specify - this is on Windows
&gt; Could you use time.sleep() is this how this type of solution is implemented ?
From 0.2 to 1.0? 
I'm assuming you want to run a python script if quotes.txt is available. If so, then as DaGoodBoy mentioned already, this is really a job for cron. Since you're on Windows (XP? 7?) you might look at [this article on Scheduled Tasks in Windows](http://support.microsoft.com/kb/308569). I'm not sure about best practices for polling a url while an app is running, if that's what you're trying to do. I wouldn't be surprised if Twisted had something to help you there.
so you mean let "Scheduled Task" be the "driver" and run (some py script) every n minutes ? instead of a python backend process 
Just a bit of motivation behind this library: I am using logging myself but some decisions in the architecture make it painful for unittests and web applications. At the Europython sprints me and Georg (http://twitter.com/birkenfeld) sprinted on a replacement library that also be used transparently together with existing logging calls. Once set up properly, systems logging to the logging module are transparently redirected to whatever is configured in your logbook handler stack. Check out the docs for a few examples that explain the core concept of handling log messages. Would love to get some feedback, API is still in flux :)
Ternary numeral system
Hey, Check out [this script](http://pastebin.com/w10bPPa2). That should work out. Script can run every n seconds (configurable). It looks for the HTTP response back from the web server and then prints back if it was an OK connection or not. Replace all the 'print' stuff with your own code and customize it to your liking. **edit1** Misread this post the first time and wrote a local file checker. Posted it [over here](http://pastebin.com/XAmFFhnP) just in case anyone needed that, too. **edit2** With input from [spiffyman](http://www.reddit.com/r/Python/comments/ctc6t/question_need_a_daemonlike_process_that_checks/c0v3oyb), I wrote a [revised script](http://pastebin.com/qYCwTar3) that handles Windows scheduled tasks (I.E. it just runs and checks once and stops) and httplib's timeout feature has been added in (Python 2.7 or better to make it work right). I don't have 2.7 on this end, but the code should work right. I just deleted a few bits and added in the 'timeout=10' in the connection string. Best of luck.
In notepad++ you can add a run command like cmd /K "C:\Python31\python.exe" $(FULL\_CURRENT\_PATH) You can then bind it to a key combination like Ctrl-F5
Exactly. You can use something like tgiles' script if you want the python script running all the time. But two caveats: a) you'll very likely be wasting a ton of CPU cycles if you do it this way; and b) time.sleep() only guarantees a minimum suspension and, [according to the docs](http://docs.python.org/library/time.html#time.sleep) can suspend execution for an arbitrary amount of time after the suggested timer. Edit: Also, httplib I/O blocks, meaning no processing can occur while it's waiting for a response. This may or may not be a problem, depending on your case. See the [official docs](http://docs.python.org/library/httplib.html) and [effbot's page](http://effbot.org/librarybook/httplib.htm) for more info.
ah good idea, Thanks ! I need to get out.....I was looking into parsing the page (w/ BeautifulSoup) and look for "&lt;a href="quotes.txt"&gt;quotes.txt&lt;/a&gt;" actually got it working. This is much sensible, just try to GET the file directly
happy to help. Post back if there's something more specific you're looking for and I can give that a shot, too. Cheers,
Good luck! ;)
Love Kate. gedits terrible, syntax highlighting makes my eyes bleed and no folding markers.
See 'supporting applications' or whatever it is called in the xbmc forums. I think several people have made exactly what you're looking for in various languages... usually open source. As the question you're asking, sabnzbd can provide examples for everything you want to do. I can't speak for its code quality because I've never seen it, but the app itself works very well. *edit: Just wanted to mention xbmc also provides a web server/json-rpc so you can use its already awesome scraping capabilities to do what you want.
Thanks for input, spiffyman. I updated script in original post to allow for: * running script from Windows scheduled tasks * httplib timeout (Python 2.7 or higher) Cheers,
Warning: self promotion I wrote something to fix all this in a blog post here: http://blog.mahmoudimus.com/2009/12/python-2-6-4-and-twisted-9-on-os-x-10-6-snow-leopard/ It might be of help to you.
Excellent and another upvote. I'd probably just use a standard 30sec timeout, though. OP: The new version handles (a) and (b) above, but it doesn't change the fact that httplib I/O is blocking. If you want to make a function you can use (something like [this](http://paste.pocoo.org/show/241459/)), you'll probably want to replace httplib with something asynchronous.
A hearty upboat and tip of the hat to you, good sir. Planning for and working with asynchronous I/O in Python hits a hard limit to my current knowledge. I'll do some further reading and see how I can push past it. Thanks for the input. Cheers,
&gt; but some decisions in the architecture make it painful for unittests and web applications Care to elaborate with some specific examples? I use it with unit tests and web applications (including Werkzeug and Jinja) without any real problems. What are your pain points? I'd like to help.
As a starting point, yes. Ditching windows is still secondary to getting started *right now*. Guess I could've been more specific re that though :)
My take on it is that as a developer, being on Windows will never help you get something done. On the contrary, it'll fight you every step on the way, forcing you to conform to a fixed and predefined way of learning, developing and thinking. Comparing Ubuntu to Windows as a learning env for programming, it's simply different planets... Pretty much anything that peaks your interest is an *aptitude install* away on the former, while an unknown shitpile of tedium blocks the way on the latter. It's easier to *maintain focus* when facing less manure.
Bookmarked for a boring day ! Thanks.
I generally agree, although the ability to install libraries from a package manager is really, *really* useful. Also, it can kind of give you an indication of which package out of the list of 20 is trusted.
Why is it that every time python/django is the theme of a blog post/article, there is **always ** a reference to rabbitmq and message queues? Buzzword much?
yep.
Seconded. The amount of time collectively wasted by the whole commons-logging/slf4j/log4j/java.util.logging multi-chotomy in Java projects is mind-boggling. As the maintainer of the Python logging package, I'm always ready to listen to suggestions for improvements, as the SVN and issue tracker record will show. However, I can't retrospectively produce a solution which fits everybody's aesthetic sensibilities :-( This kind of thing is a bit like a fork. Choice is often a good thing, but sometimes it dilutes effort and hinders progress to an extent greater than the benefits it seems to offer. But hey, it's a free country.
wow. thanks!
Pleasure, if I can help any more with it, don't hesitate to ask (as you might infer from the comment above I'm the one who did the etree rewrite as I found the string munging stuff quite ugly, but credit for the library itself goes entirely to Jonas Galvez)
&gt; What are your pain points? The shared state. See how libraries work around the registry for loggers. SQLAlchemy appends random numbers to delete loggers, the majority of libraries that configure logging have all kinds of hacks to make sure loggers are cleaned up by hand by cleaning out logger.handlers so that a re-running unittest will not cause troubles etc. Logbook gets rid of the concept of a logging registry. I don't think logging can be changed to support this because this is a huge change in API.
It's perhaps a bit overkill, but instead of making up your own archive format you could use SQLite as a kind of key/value store. The sqlite3 module should be installed by default and it doesn't take much magic to make the DB appear as a plain old dictionary which should also abstract it enough to let you plug in a completely different storage back end if the SQL ever gets on your nerves. If you absolutely want the files to continue to look like files, you can still chuck the data you pull out from the database into a StringIO. It does reduce greppability somewhat ("LIKE" selects aren't as nice, though if you're lucky you'll already have FTS tables available), but on the flip side attaching some meta data becomes ridiculously easy (e.g. "log\_begins\_on\_date" and "log\_ends\_on\_date"). I currently use a similar set up for ~42k chunks of small-ish (under 100KB) text data, and it works a charm.
Actually even without FTS you can probably [just use Python re to scan your fields with REGEXP operator](http://www.sqlite.org/lang_expr.html "SQLite operators, ctrl+f regexp"). import re, sqlite3 def regexp_function(expr, item): 'Just a search, mah friend.' return not re.search(expr, item) is None conn = sqlite3.connect(...) conn.create_function('regexp', 2, regexp_function) 
Not to mention NoSQL... What are these guys building that they use message passing this much? When we needed to pass sites to the backend for indexing for [historious](http://historio.us) we just put them in the DB and mark them as "to be indexed". Seriously, how many more messages do you need to pass?
&gt;On the contrary, it'll fight you every step on the way, forcing you to conform to a fixed and predefined way of learning, developing and thinking. Why? Just because there's no package manager? I do web dev in a virtual machine running Linux and edit files with Komodo over scp. But I did my recent CoffeeScript project in Windows/cygwin because there was no need to use Linux.
I didn't know about that - very cool, thank you!
If you want to invent your own file format, okay fine, have fun. But it's not necessary in this case--zip files already do what you want. Unlike tar files, zip files have a central directory (stored at the end of the file) so you can seek directly to particular files. And zip files can store files uncompressed if you like. And zip files have checksums. And Python has shipped with zip file support for a decade.
&gt; Why? Just because there's no package manager? It's an important factor, yeah. But also, the number of available packages as well. And ease of use. I'm not saying you can't work in Windows. Of course you *can*. However, the OP wants to learn Python, with minimal resistance. If Windows is your target platform, you'll have to manage. But unless you have to, there's really no reason to spend time fighting Windows idiosyncrasies instead of learning python.
**TL;DR** Python: What the author uses.
probably depends on what they wish to do I guess. When you learn a few languages you would appreciate python more, especially knowing the effort taken to do stuff previously. I just use vim (gvim when in windows) for an editor. and use the shell/google to check for documentation. even showing the shell maybe a good thing to show off its benefits.
same here :) I've been pining on doing something like this in python.
What is this "obscure programming language", out of curiosity?
Is the underlying code written so that if I seek to a particular file using the Python zip libraries it will indeed use "seek" instead of reading the whole file first? &gt; If you want to invent your own file format, okay fine, have fun. It wouldn't be too hard and could be done in probably 20 lines. EDIT: [Voila](http://pastebin.com/LbfM2Wr6)!
I wrote up this little script using command line print, it isn't pretty but it works well: import subprocess as sub import os.path def printPage(tag,bPath): p = sub.Popen([bPath, '-print', 'http://finance.yahoo.com/q/ae?s=%s+Analyst+Estimates'%tag, '-printmode', 'pdf'], stdout=sub.PIPE, stderr=sub.STDOUT, shell=True) return 1 def findBrowserPath(): for i in ["C:\\Program Files (x86)\\Mozilla Firefox\\firefox.exe","C:\\Program Files\\Mozilla Firefox\\firefox.exe"]: if os.path.isfile(i): return i else: print 'could not find firefox' return 0 if __name__ == '__main__': bPath = findBrowserPath() if bPath: for Ticker in open('tags.txt').read().split(','): printPage(Ticker.strip(),bPath) 
I agree with you, but *only* for a limited subset of projects. If you're writing a Django app that's going to live on a Linux server, sure, use Linux. But if you're doing an NLP project that just needs to deal with flat text files, it really doesn't matter.
Komodo Edit is a very nice free Windows editor - that's what I use for Python.
Looks nice. Thanks. I wanted to point out that the code for "the says-it-all usage example" errors out when using "from xmlbuilder import builder" instead of "from xmlwitch import builder". Problem is with the div.text(':') line. Then once that is commented out a problem with keyword argument 'value'. Python version 2.6.
Was it ... [D](http://www.digitalmars.com/d/)?
This looks really good, I had some trouble getting it up and running though, all the PDFs I created would not open in Adobe or Sumatra. I got firefox's 'command line print' extension to work well though. See below.
I see no reason to "convert" your friend to Python. If he has found a good tutorial to teach him the basics of programming, the language of choice is secondary. If he later runs into problems with his language of choice, you can instruct how things might be better in the world of Python.
[Google's Python Tutorials](http://code.google.com/edu/languages/google-python-class/) If videos, readings and assignments do not float his boat, I am not sure I can find another well rounded tutorial to help him. Yes, the answers to the assignments are provided, but the onus is on him to learn without cheating
First part, yeah I fixed it but it seems I never got around to asking for a pull, so it's still broken on galvez's repo. As to the says-it-all-usage example, you tried it with the etree_rewrite branch correct? It does seem it's not ISO with master after all. I have to check that, master seems to be using `.text` as a special text hook, and I probably happened to use `value` as the argname for the text (second issue you encountered), which is slightly unfortunate. I should probably have added the says it all example to the doctest file and fixed that. I'll try to do it this evening and request a pull from galvez, if you don't mind, those issues seem rather easy to fix. edit: the existing says-it-all doesn't really work with etree_rewrite, by the way, as they don't handle namespaces the same way. I'll have to migrate it to ElementTree namespaces as well. edit2: should be fixed in my branch, should not explode anymore on the master example (though it will not work correctly due to different namespace handling and a few ET quirks, see says-it-all example in the etree_rewrite doctest for the changes between master and etree_rewrite)
[Django](http://www.djangoproject.com/) has some wrappers over smtplib that you may find useful: http://docs.djangoproject.com/en/1.2/topics/email/#topics-email edit: also twisted http://radix.twistedmatrix.com/2010/07/how-to-send-good-unicode-email-with.html
Lua ?
For the rpm, you can include the spec file in the root of the tar, and use 'rpmbuild -ta' to build from the tar.
&gt; the author deemed it "outdated" and deleted it If there was a PDF version, I might have it....who's the author ?
does urllib2 block ?
A slightly better way to create Debian packages for Python stuff. * Have a setup.py that works for distutils. * Download &lt;http://files.liw.fi/temp/debian-template.tar.gz&gt; and put it in a safe place. * Unpack at the root of your project's source tree. All the files go into a new subdir (debian). * Edit debian/* and fix anything marked FIXME or "Your Name". * Build .deb using this command: debuild -us -uc The resulting files go into the parent directory (..). This should work for many simple Python projects. It should approximately follow Debian packaging stuff. If you're serious about having a Debian package, contacting the Debian project (say, debian-python@lists.debian.org) and asking for help would probably be a good idea. There might be someone willing to help you with that. Only for free software project, of course.
I'd sort have have to agree with the two comments above. People should be allowed to do what they want with a given language but sometimes people probably should think about what they're doing. I like Java a lot but I'm beginning to dislike it more and more but mainly on the web side because it's a freaking mess. Python is nice and clean and much nicer to work with. It'd be nicer to see people submit solutions or suggest things to what is there rather than having it become like java and have a zillion frameworks to fix things. Besides, anyone can have a framework. It'll look cooler to say your code is in the main Python distribution.
The guidelines for approved extensions are here: http://flask.pocoo.org/docs/extensiondev/#approved-extensions In case you have any questions regarding the reviewing process, let me know :) So far there are only two approved extensions and it is not yet visible on the website what extensions are. With the 0.6 release, which should be out soon, badges will appear on the extension list (http://flask.pocoo.org/extensions/) for approved extensions.
[Dreampie](http://dreampie.sourceforge.net/) is a pretty nifty shell, with code completion and other goodies.
Closing something inside of a box?
[Debian New Maintainers' Guide](http://www.debian.org/doc/maint-guide/) has most of what you'll need to know (and lots you won't need for your particular package) about building (and maintaining) a basic Debian package. 
Normal distutils has a bdist_rpm command, and the stdeb project provides a bdist_deb.
you meant bdist\_rpm. Thing is it doesn't bundle a .spec file in the non-src rpm the command creates, thus dependencies are not resolved.
There's this recent discussion about different IDEs: http://www.reddit.com/r/Python/comments/ct3na/is_there_a_better_way_to_set_up_for_python/
Cheers i'll look into that. I really don't have the patience for the 1000s of lines in the official guides. Just seems completely overkill.
I was gonna go with "Step one: Cut a hole on a box".
Get all distros switch to makepkg. (wait, actually, that's not a half-bad idea)
I love Debian but I don't understand how they expect to attract people with that monstrosity. Packaging is already boring and tedious enough; a giant tome of documentation to read is enough to completely discourage tons of people.
Yeah, actually. Your best bet is to use Twisted for asynchronous communication. There are more qualified people here or in #python on the freenode IRC network than I to cover this.
it's been posted on r/programming already but maybe you should repost here :)
well haha I wouldn't have any PDF in French
Touché
Why is this guy being downvoted? :|
&gt;It wouldn't be too hard and could be done in probably 20 lines. From experience, there are likely to be a few annoying edge cases to make that balloon a bit. For example, that *one* file with a missing newline at the end messing up the concatenation. That annoying problem where you used character count to determine seek distance, but wrote UTF8 with a few multibyte characters in it... that sort of thing. Don't let that discourage you, but I'd be wary of underestimating the task.
There are currently 4 approved Flask extensions. Their testsuites were integrated into a centralized test runner. Current results: http://dev.pocoo.org/~mitsuhiko/flask-ext-test.html
"Auto-autodoc" *is* autosummary/sphinx-autogen. http://sphinx.pocoo.org/ext/autosummary.html
I'm interested in joining the project. PM me if you'd like.
Beautiful. It's the distributed, microframework answer to ``django.contrib``. I think we can expect many more approved extensions in the near future; most of the listed unapproved extensions are just missing ``MANIFEST.in`` files.
Using line numbers was only to make the example easy to read. In practice, I would probably use bytes because I did consider that I might have a few non-compliant files.
Which other arbitrary number should they have chosen?
http://inventwithpython.com "Invent Your Own Computer Games with Python" is a book that is freely available online under Creative Commons (and can be purchased on Amazon in print) that teaches programming to complete beginners by showing the complete source code to small games and then explaining programming concepts as they come up in the game's source. The games give good examples and many readers go on to make their own game programmers after reading it. As far as Python 2 vs 3, it doesn't really matter that much. The book isn't OS specific, but uses IDLE (the IDE that comes with Python).
[File crammer](http://pastebin.com/LbfM2Wr6) in ~20 LOC. :) Instream is a \n delimited source that has a file name on each line.
Well, the official guides are for people participating in building one of the biggest operating systems ever. That's a complicated project, so things are complicated. Making a Debian package for a single Python project is much easier, luckily.
A .spec file is a recipe telling `rpmbuild` how to create binary/noarch RPMs, there's no reason for it to be put into a non-source RPM. The dependency information of a binary or .noarch.rpm is stored in the RPM header, not in a .spec file. Note that RPM dependencies have to be supplied to `bdist_rpm`'s `requires` option, not whatever dependency settings setuptools uses.
How do you add files after creation? (Well done, looks good!).
Don't care. Shorter timespan between releases would have been better. 
Awesome API. I really like their style and learned/borrowed a lot from it.
NoSQL is the buzzword to rule them all. Either people don't know how to tune their RDBMS, or they are very prone to suggestion. I use Postgre and until date I haven't had 1 performance issue. With good tweaking, tuning, vacuuming, pgbouncer etc etc you will never need NoSQL.
This is the kind of syntax you can use in Nagare: http://www.nagare.org/trac/blog/namespaces-and-rss-feed
I like the idea of XMBC, but in practice I found it extremely painful to use on a pc, slow, and the setup was unwieldy and complicated. The identfy media function barely ever worked for me either. I'm sure it would be a great x-box media center, but it's a terrible pc one.
I've been needing a decent media catalog app for ages. I'd love to contibute in some way.
You might need it if you want scalability, but if you're willing to forgo joins you can do that with SQL databases anyway, so I don't see the advantage *at all*. Plus, it doesn't help that my experience with MongoDB was abysmal...
Yes, it is. When you first open the zipfile, it seeks to the end to find the size of the directory structure, then seeks back and reads the directory. After that, every time you "open" a file from the zipfile it seeks right to it.
Open outstream in append mode. Since you know the size of the header and where the last file would be, you can easily just cycle through headers with seeking. Now that I know the zip library does use seek appropriately, can't decide which route I want to take.
&gt; Since you know the size of the header and where the last file would be, you can easily just cycle through headers with seeking. …which is more or less exactly how a tar file works and how access to an (uncompressed) tar archive is implemented. Flip a coin, really. It'll be more interesting to continue with your own implementation, but if you just want to get it done... use one of the existing options.
awesome, too! thank you!
Saw a talk at Europython this weekend where the speaker demonstrated how you could write Python code and put it into html in &lt;script type="text\python"&gt; tags. By including a piece of javascript that loaded silverlight and ironpython, then automatically found these tags you could execute Python on the browser. It had an initial load-time but in subsequent requests it's seemed fine. The performance was blinding since IronPython creates .NET bytecode anyway. I think doing graphical stuff in IronPython would be faster than doing graphical stuff in HTML5+Canvas if just because the browsers aren't yet optimised enough for it. The only downside is that you need the Silverlight plugin. But you honestly never have to write a line of C#.
Actually, I'm fairly certain I could do it with my own implementation a lot faster. I've already implementing cramming files together and reading them is just as trivial. To produce a file like object, all I would have to do is use cStringIO.
Probably boils down to personal preference. I prefer the peace of mind of mind that comes with an established library, not least of which is being able to implement access to the data in another language without having to re-implement the entire stack. But then, I also tend to be overly cautious to the detriment of practicality at times, so take that with a pinch of salt :).
You most certainly have to have HDMI out + a good media center remote. But once you have that its absolutely great, the media library mode always works good for me, but i keep a pretty well organized collection.
I'm not familiar with Scipy and its dependencies, but it sounds like you have a WinSxs issue (the new variant of dll hell!). If your OS is Vista or Win7 the sxstrace command line tool will be of great help, if your OS is WinXp, Win2003 then your only recourse is the event viewer.
I bet Cephes.pyd is for another python Version then you use. Maybe it's for 2.5 while you are using 2.7? You need a version complied for your Python version, either download it or complie it yourself.
The standard logging module just needs more ability to get at existing log configuration, modify it, or remove handlers/loggers/namespaces. One example, SQLAlchemy has an "echo" flag, and it would be nice if we could ask the logging package "has a handler already been set up for sqlalchemy.engine?" so that we don't add a second one when "echo" is used. The other, just to be able to say logging.disposeLogger(name). I don't think those things are architecturally impossible. There also needs to be a standard batteries-included method of using logging to its full capability while using multiprocessing. The current solutions are http://pypi.python.org/pypi/ConcurrentLogHandler/0.8.4 and my own hack which works well for me [here](http://stackoverflow.com/questions/641420/how-should-i-log-while-using-multiprocessing-in-python/894284#894284).
This is non-portable, "pause" is a Windows specific command. 
Cheers :)
What's his age, preferences, motivation, computer background? Python may be there are also nice things in other languages. If he wants to learn programming every language is good, as far as I am concerned. At least if it is Turing complete so he will be able to do self reference stuff at it finest in two or three years.
We want entirely different products. You want a media center that runs on a pc but is designed for a remote, whereas I and presumably the OP want a media library that is designed for a keyboard and mouse.
How is xbmc not designed for a keyboard and mouse? I can use it that way just fine, great infact. I don't see how you could possibly provide an easier or more useful mouse and keyboard experience for browsing media. Its not like it was made for the xbox, and just shoddily ported to the PC. They've done a lot of work on the PC version. Its been on the PC for a long time now and is very refined.
I find it immensly slow to navigate. Doesn't really seem designed for easy pc use. Part of the problem is probably my fairly complex storage of media files across multiple hard drives, and the amount I have. It's far too difficult to navigate and find movies let alone tv series. It's not that it's a bad program, it's just that the media library I'm looking would be more like Picasa than XMBC.
Great stuff for a Python novice, thanks.
&gt;Part of the problem is probably my fairly complex storage of media files across multiple hard drives, and the amount I have. THIS EXACTLY WHAT XBMC WAS MADE FOR AND DOES *PERFECTLY* PLEASE read up on, and try XBMC again, you are clearly missing something. Im not trying to be a dick lol, you need to give it another shot. That is one of the GREATEST things about XBMC imo. It has the ability to group multiple hard drives/network shares into single stacked folders... it does this flawlessly and beautifully. I have 4 hard drives, and 3 network shares, all with TV shares, and Movie shares, all nicely compacted into one "TV" folder and one "Movie" folder in my xbmc interface. This is done by default with no plugins or config file modifications if you know how to setup your file view correctly. Methinks people havent used XBMC in a while.... And library mode (which I've mostly been ranting and raving about, and which nobody even seems to know about) takes this a step further, and not only takes all ur media across all drive/shares into one place, but also automatically downloads all the coverart/descriptions/fanart/promo art/description for you. IT COULD NOT BE EASIER OR MORE BEAUTIFUL (the way it uses the fan art/promo art in the UI is amazing)!!!!! I'll give you that the interface is a bit laggy at times though, compared to a native desktop app. And again, i understand he's making this as a learning project for Python.... but XBMC does a lot of what he (and you) mention very well.
I normally try it every couple of months, but you've convinced me to try again. Maybe my setup has just been bad previously, is there a good tutorial?
http://wiki.xbmc.org/index.php?title=Adding_Media_Sources That is what im talking about specifically. Adding multiple media sources to a single "View" will allow you to take all the "TV" folders you have across multiple shares/drives into 1 "virtual folder". The official wiki is actually pretty good, but you have to know about their custom terminology for things sometimes. Dig around, there's some good stuff. http://wiki.xbmc.org/index.php?title=Media_Sources and thats more just about the media sources that allow you to create these awesome 'virtual folders'
I assume you're have Python 2.6 compiled under Visual Studio 2008. Unfortunately, Visual Studio 2008 does not give useful error messages when dlopen() fails. If you install the Process Monitor, http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx you can actually see what exactly fails. I would assume a DLL which cephes.pyd is linked against is missing.
that rhymes.
&gt; [Referring to locking intricacies.] That kind of things are terribly tricky to get right indeed; my point however is that really few people have to deal with that level of sophistication. This is true, however if you are implementing an interpreter or runtime, you **are** one of the "really few people" who have to deal with it. If you get it right, that vast majority of your users who don't need or want to deal with those constructs won't have to. If you get it wrong, your customers are stuck with trying to work around your limitations when multithreaded performance matters to them (see: the GIL). &gt; Not that there aren many reason to complain even now, since the GIL affects CPU-dominated applications, and typically CPU-dominated applications such as computations are not done in pure Python, but in C-extensions which can release the GIL as they like. It's unfortunately true that many CPU-dominated applications are partially written in C, but there is plenty to complain about. I don't understand why writing C code to get around the GIL is a Good Thing. Programmers are using C-extensions to get around limitations of the language, not because they want to be implementing their project in C. I chose python for a reason! I write code in Python because I love the language. If something is CPU bound and performance is a factor, I don't want to have to use another language (C in this case) to get the job done. Similarly, it's fine to say multiprocessing is a better paradigm for Python development. However, when threads **are** the right solution to a problem, I don't want my language implementation to get in the way of taking advantage of what hardware is available. Like it or not, most new computers are multi-core, and that's not changing any time soon.
I wrote a snippet just for this purpose: http://github.com/grimborg/withtemp
&gt; Commit privileges I guess he didn't watch Linus's git talk... It's sad people still have trouble with these. Why does Python still use SVN? SVN is far behind the DVCS's when it comes to merging capabilities -- and makes branching much less useful. 
Agreed. Git would make much more sense for Python.
So, um... Guido is letting fairly random people decide which PEPs to approve? That's... a bad thing, right?
Python had a long consultation process on DVCSen and eventually chose Mercurial; the transition plan is PEP 385, which isn't yet finished: http://www.python.org/dev/peps/pep-0385/ Moving such a big project takes time and organisation, but they are progressing.
but doesn't scan
Hey. Not random, carefully chosen to be trusted by the community and to have expertise and interest in the PEP in question. Although Guido has the former, he occasionally doesn't have as much of the latter for particular PEPs as other people he could point at. This just sounds to me like constructive delegation, to help Guido scale.
Are you on 64 bits ? Did you use the scipy installer or did you built by yourself ?
He has hinted at before that he would like to phase himself out as the project leader.
Today, a typical desktop computer have 2 or 4 cores. In a few years a typical desktop computer may have 16 cores or even more, and *then* it may require something from desktop app programmers to make use of the full performance potential.
I'm on a 64 bit (intel core 2 duo) and used the installer.
I'm 64 bit (intel core 2 duo) and used the installer.
Thanks! I tried it, couldn't get much out of it, but that's probably my fault.
OP was probably befuddled by coding in a REPL.
The move to Hg is getting closer. The original plan was to cut to it right after 2.7 was released, but a few of the people involved are finishing up thesis work and some other stuff. It'll be here soon.
Well, we can still use the catchphrase: "Python -- a programming language invented by a guido, for guidos."
&gt; Guido is letting fairly random people decide which PEPs to approve? For [PEP 3148](http://www.python.org/dev/peps/pep-3148/) about [futures](http://pypi.python.org/pypi/futures) inclusion, Jesse Noller, the maintainer of multiprocessing, was the "PEP handler". He is very far from being a random choice.
Eventually whoever the "PEP handler" is on some PEP will make a decision that goes against the grain of the community. And maybe even against Guido's opinion. The shit will surely hit the fan then.
The core Python developers who were asked disagreed with you. Mercurial got a lot more votes than Git did. (I don't remember the exact numbers, but they were announced at PyCon 2009. I think it was Brett Cannon's presentation.) As a non-committer, I'm happy Python is switching to hg. And I'd also be happy if they were switching to Git. Anything that makes it a bit easier for non-committers to get small fixes in. Though, honestly, I don't think DVCS alone makes a huge difference, because most interaction will still be through the bug tracker. What will make a big difference is when they integrate the bug tracker with the DVCS. Reitveld is okay, but because it works with patches rather than with the version control system, there's too much extra work. Something like Gerrit or Kiln would be nice.
There are plenty of checks-and-balances in this process. It's not some closed door meeting where the submitter and the handler duke it out privately and someone is declared a winner. PEP 3148 was discussed for a quite a while with many people being involved on both the python-ideas list (at first) then later python-dev. Due to futures being on a similar topic as multiprocessing, it makes sense for a person in that domain with a few notches on their belt to moderate. They still are not in some position to make a decision which goes against the grain. If Jesse and Brian Quinlan (futures guy) decide they want foo but the 40 other people who responded want bar, it's not just going to be foo because someone is named a PEP handler. As said previously, it's really more about scalability. Guido can't read every email, track every side conversation, manage the bikeshed paint shop, etc. The handlers will probably still look to him for some guidance, but they are doing the majority of the work. I don't think he's just going totally hands off.
...use it with a smile!
The installer is for 32 bits python (which can be used on 64 bits windows). Unfortunately, there is no way that I know of to prevents 32 bits python packages to install on 64 bits. There is no official 64 bits support (yet), although you can easily build you own numpy binary with the MS tools.
Mercurial and git are basically the same thing, the poster you replied to was comparing svn to git, and in that sense, he agrees completely with the core python developers.
The first half of the article just says "programmers at high levels see high level abstractions. programmers at low levels work with the topic of this article". I was hoping he'd get more into it than that, I usually like what he writes.
Love ZODB, Used it on little single process applications and as a central store on Point of sale system with 20 + stations.
For comparison, in Powershell I've been doing the following: # get log events for named server/log function get_log() { $server = $args[0] $logname = $args[1] $outfilename = $server + "_" + $logname + "_all.csv" (([System.Diagnostics.EventLog]::GetEventlogs($server))|? {$_.log -eq $logname}).Entries | export-csv $outfilename } which dumps the events into a csv file. The main thing is the call to [System.Diagnostics.EventLog]::GetEventlogs($server)), which returns handles for each log available on the passed in server.
Cutest iΘ framework of 2010
what do you normally need that info for ?
ಠ_ರೃ
Wow, that's exactly the same as my [async.js](http://eligrey.com/blog/post/pausing-javascript-with-async-js) library (`yield` asynchronosity magic on decorated functions), but ported to Python!
@_ಠ @_ರೃ
That could actually exist in 3.x. &gt;&gt;&gt; ಠ_ಠ = "lol" &gt;&gt;&gt; print(ಠ_ಠ) lol 
The normal is required to see the abnormal. We maintain an application that logs events (and exceptions) in a custom log, and we collect log files weekly and look for out-of-the ordinary events, rollingthings up into some charts and tables that give a high-level view of what's going on. Over time, it also shows progress (and regression) as we solve issues.
Flask is awesome.
Finally, I can build a friend who gets my jokes!
After that, build a wife who gets my dry cleaning!
Can somebody explain to me some advantages of event-driven code? I'm aware of what generators are, but I'm unaware of how this paradigm involving them works and if how it's beneficial. I'm currently working for a small company building applications with Tornado. I'm also just interested in learning new things.
Found this convertor: http://www.gnosis.cx/download/relax/
I've always wanted my code to be more dapper.
&gt; But rules are for breaking. Live a little. A module description that also contains life style advice. 
"Event-driven" basically* means that everything is ran at the same time, in a big ol' loop. This is good for things like web servers that are IO-bound, because you can multitask and juggle a lot of tasks at the same time and nicely utilize your clock cycles without firing up more processes. This is how asynchronous event-driven environments like node.js and tornado are able to claim "five jillion simultaneous connections" and yet be single-threaded. Cool, huh? The problem with this is that you need two things to happen in order to have good event-driven action: 1) Non-blockingness** (that is, if something was written expecting a synchronous environment, it could easily stop everything in your event loop until it's done, making eventing kinda pointless). 2) A good way to describe ordering/prerequisites (something that's trivial for regular-type programming, but becomes an issue with asynch stuff.) As far as the former goes, it means that your libraries should be written with concurrency in mind. Regarding the latter: In javascript (I'm playing with node.js right now), callbacks and "Event Emitters" are the common tools for this. However, python's single-statement lambdas mean that the nested callbacks style doesn't work as well. For example, in javascript you can write code like this: setInterval(function () { doThisThing(function (err, results){ if (err) throw err; doAnotherThing(results); }); someOtherStuff() }, 3000); which runs DoThisThing() every 3 seconds, which then runs the anonymous function wrapped inside of it. Can't do that in python. So, there are various strategies to make writing evented code smoother in python, and @_o is one of them. Edits: \* Well, not really. Eventing is just the idea of "triggers"--like, "when this happens, do this'" But, eventing ties into a strategy for dealing with concurrency. So technically I should've said "asynchronous &amp; evented." ** Apparently there are other strategies as well, such as coroutines.
FYI: ActivePython [Business Edition](http://www.activestate.com/blog/2010/06/built-speed-activepython-intel%C2%AE-mkl-and-mathematical-computing) enables one to install Scipy/Numpy for 64-bit Windows among other platforms.
I've had success with this before: http://code.google.com/p/wkhtmltopdf/ That said, I like hobophobe's solution better.
But if you're using 32-bit Python and 32-bit Scipy, open cephes.pyd in [depends.exe](http://www.dependencywalker.com/) to find out the missing DLL.
Wow, THIS IS FUCKING AWESOME. Twisted done right.
I'm going to do that right away.
It's fair to ask if there will be a Python after Guido. If you look at languages like Fortran, BASIC, and Lisp, it's clear a language can stick around for 40 or 50 years plus if it's lucky. In that case planning to have BSDFL (Benevolent Successor to the Dictator For Life) isn't a bad idea. 
&gt;ARPACK-based sparse SVD &gt;A naive implementation of SVD for sparse matrices is available in scipy.sparse.linalg.eigen.arpack. It is based on using an symmetric solver on &lt;A, A&gt;, and as such may not be very precise. WOW
It's not really magic or based on JavaScript. The yield statement gives Python fairly simple coroutine support which is the basis of cooperative multitasking (a handy way to model asynchronous IO) on a multitude of frameworks and languages.
[diesel](http://github.com/jamwt/diesel) used to use yields to achieve coroutines and cooperative multitasking, but abandoned it in favor of greenlet's greenthreads. Generators just lack the expressiveness to easily handle cooperative multitasking beyond trivial examples. For trivial examples it's rather elegant. Others have gone where @_o has gone before: * [cogen](http://code.google.com/p/cogen/) * [python-multitask](http://code.google.com/p/python-multitask/) * Twisted [DeferredGenerators](http://twistedmatrix.com/trac/wiki/DeferredGenerator) It's nice of monocle's author to mention some of these (diesel and Twisted) as inspiration. It will be interesting to see if monocle will succeed where so many have gone before and yielded. (Edited because I've never used reddit's comment formatting before...)
Did anyone catch a description of what the app will even be doing before all the fanboys started promoting their favorite Python project?
&gt; Code editing - do you use the .NET framework without Intellisense? He probably meant: "do you ***REALLY*** use the .NET framework without Intellisense? Do'h! Another coder spoiled by its tools. 
The [official tutorial](http://docs.djangoproject.com/en/1.2/intro/tutorial01/) is a great way to get started. I think there are some video tutorials on YouTube, but I don't know how good they are.
http://code.google.com/projecthosting/ Google Code is pretty good, and has some nice built in tools for collaborating.
You have to set the PATH environment variable up properly since they refuse to change the installer to make Python work the same way on Windows as it does on Linux. You also have to work a little harder to get your extensions since you typically don't have a C compiler set up ready to go. But once you've done that, I find Python development on Windows no worse than on Linux, so I too would be interested to hear what cdawzrd has to say on the issue.
I've always managed to find mysqldb binaries. Sometimes they're not the absolute latest version.
I'd start by going through the tutorial as swac mentioned. There's also [a book](http://www.djangobook.com/) that's online. I think most people start with the tutorial and then just read through the documentation. (The documentation is excellent)
After reading the tutorial you will probably have many ideas on how to use the software. You should just start a small project and try how far you get. If you get struck, search the official documentation or the book. If you still have problems google it (also before implementing anything, google it - there are unlimited code snippets and reusable apps for django). If you STILL have problems, go to #django at freenode (IRC)... there are 600+ people in the channel. Some of them are increddibly bright and helpful minds.
That's a helpful reply. Thanks!
&gt; Do'h! Another coder spoiled by its tools. I'd have talked about another coder crippled by its tools. Though better than Java, C# is hardly a language you can use from the confines of a text editor due to the verbositoryness of the whole thing. People who have used these language exclusively for long time spans have a hard time conceiving terser options (either because they've forgotten or because they got out of a java school and never even discovered that exists) at either the language level itself or the libraries (naming in both the C# and the Java worlds tend to be quite hard on the fingers, making autocompletion a necessity). They therefore have a hard time conceiving the possibility of coding without pervasive and type-perfect autocompletion. The good news: once IDEs get smart enough, these people will be replaceable by a small script driving the IDE.
Couldn't agree with this more. I started with the book and then built a project for school, and now I do Django for a living. I've been using it professionally for just over 2 years and I'm still learning things about it, but definitely go to freenode, they're always super helpful there.
Try Showmedo: http://showmedo.com/videotutorials/django
Hello all - I too stumbled across the need for fast zipfile decryption in Python, and ended up packaging "czipfile" (which is incidentally in Cython, as a few folks here had suggested). It's available at PyPi now, so if anyone still has a need, here it is: http://pypi.python.org/pypi/czipfile/
JavaScript and Python `yield` are both for the same thing: generators (which are the same in both languages). Monocle and async.js wrap generator functions and do various function calls with callbacks that trigger the next function call in the generator.
Awesome. My project is over but this would have definitely helped. The zipfile library is so terrible, and I've opened two bug reports for it. Does this support AES decryption?
Thank you! Perfect back translation to English of the tl;dr version of my thoughts :-)
This is a great first step, but it looks like only per-release package information is available in JSON.
I'm curious about the video tutorial request. I'm an old fart, so we never used to have these. Now that my patterns are old and crotchety and set-for-life, I find video to be too slow to go through (as a tutorial), too limited in cut-and-paste goodness, and too hard to randomly index as a reference. Do you actually find video better for you? If so, why?
Not exactly what you asked, but you might also be interested in: http://www.reddit.com/r/django
Video tutorials are very helpful if it explains the concepts instead of technical stuff (code). It becomes very easy to memorize. Thanks!
I have a coworker who's obsessive about this issue, and the more I've done it his style the more I like it. If you want your CLI to be consistent with 99% of unix programs, you should follow optparse's line of thinking. Because, let's be honest, "options" are "optional". If your user can't look up how a command is used with the -h option, then you've got other issues!
Then don't consider them "optional arguments" just consider them "arguments". Just because they start with a "-m my_arg" doesn't mean they're optional - it just means they're non-positional. It's about usability. If your program has more than one required argument, I think it's a lot cleaner to have an interface that isn't dependent on ordering - especially if there are a number of truly optional arguments.
But they're not arguments. By Unix standard, anything supplied with a -\* is an option. It is about usability, but not in the way you think it is. If you're programming around user stupidity, just use a GUI. If you're targeting someone who knows Unix, they're going to be *less* confused by positional arguments than non-positional arguments. For reference: man ln man cp man mv etc.
I've got to agree with kemitche on this one. What difference does it make if your required arguments are non-positional? It affords more flexibility in the usage of the program, makes the commands more readable (the prefix hints what the argument is for) and doesn't change the functionality of the command in any adverse way. Why not allow this?
That's just semantics. Take, as a counter example, grep. Typical usage is 'grep pattern file file file', but you can pass multiple patterns with 'grep -e pattern -e pattern file file file'. Positional argument becomes non positional option. The degenerate case 'grep -e pattern file file file' is valid. edit: Interestingly, the following is also valid: ebrunsonlx(~)$ grep -e brunson /etc/passwd -e root root:x:0:0:root:/root:/bin/bash operator:x:11:0:operator:/root:/sbin/nologin brunson:x:500:500:Brunson:/home/brunson:/bin/bash 
counter reference: man dd
That's a bad counter example, because grep runs fine on its own if you only supply a file. It doesn't, for example, error.
No, there's no way to run grep with only a file, the first positional argument is interpreted as a pattern if none is specified with a -e, and stdin is used as the file to search.
And I quote the BDFL (well, Tim Peters): "There should be one-- and preferably only one --obvious way to do it." Edit: oops, my bad, it was Tim Peters not the BDFL. Should have read the PEP author!
That was Tim Peters "channeling" the BDFL, not the BDFL himself. (http://www.python.org/dev/peps/pep-0020/)
I don't think that's a counter reference. DD arguments don't have -* in front. It's "dd if=x of=y" not "dd -if=x -of=y" or "dd --if=x --of=y"
Sorry, yes. But it does run just fine with one argument only. Usage: grep [OPTION]... PATTERN [FILE]... Try `grep --help' for more information. It pretty clearly conforms to "options are optional" with "positional arguments"
And there is one way to do it. If you need to specify argument X, you say: -x ARG.
But users aren't binary - they don't fall into either "expert UNIX wiz" or "stupid GUI loving Windows mongrel" (yes, I hyperbolized for effect). And looking at the man page for "ln" is almost a counter-argument, in that the 2nd positional argument is optional - essentially saying that "positional argument does not strictly mean required". By the same token, why would "flagged argument strictly mean optional"? Also: man cpio By the way, I do agree that it's better if you can make the program work without requiring flagged arguments - but I just don't see anything wrong with having required flags in certain scenarios.
Agreed. Positional arguments are the way to go if you want mandatory "options".
Okay, then how about sed: SYNOPSIS sed [OPTION]... {script-only-if-no-other-script} [input-file]... 
Typical UNIX: ls -al foo bar *.exe There are a few commands, e.g. `tar`, which take configuration as arguments, but usually the positional arguments are just the inputs. If the above were done using options alone, it would be very awkward: ls -a -l --file foo --file --bar --regex-file '*.exe' So there are 2 reasons to use position rather than dashed options for program inputs: 1. Less typing 2. Allows easy shell wildcard expansion There's no reason to be pedantic. Just do what is logical; use positional arguments for program inputs and options for everything else.
I prefer to support both. Consider the diff program. If I have a bunch of old version of a file and I want to see how each on differs from the current one I could: find /backups -name myfile | xargs --to-file=/live/myfile If I was limited to the conventional `diff &lt;from&gt; &lt;to&gt;` positional arguments, I would have to write a shell function to swap the arguments or something similar. 
What's the beef? Argparse parses arguments. If you only want option parsing, and you want to re-invent your argument+option parsing for each script, then use optparse.
By the way, `argparse` *is* much better than `optparse`. One great thing is its support for sub-commands.
&gt; By Unix standard, anything supplied with a -* is an option. I think you mean convention. The only thing that might be considered "Unix standard" would be the Single UNIX Specification, which contains no such proclamation. &gt; man ln &gt; &gt; man cp &gt; &gt; man mv Did you read these yourself? All of those commands require a source and a destination, but the destination can be specified as either the second positional argument or using the -t switch. 
&gt; That's just semantics I hate when people who know better misuser a word and retort that it is just semantics.
Interesting. I'm with ZombieJackKemp, video is just sooo slow. I die of boredom watching screencasts when I know that I could consume the same information from a text/code/diagram tutorial in quarter of the time.
What a great oxymoron, Modern and Windows in the same sentence. I looked at the page and it made my eyes burn. I think someone messed up all the slashes.
Uhm... what about POSIX? [The Open Group Base Specifications Issue 7 - IEEE Std 1003.1-2008: Chapter 12, Utility Conventions: Utility Syntax Guidelines](http://www.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02), from [The Open Group Base Specifications Issue 7](http://www.opengroup.org/onlinepubs/9699919799/) says: &gt; [...] &gt; **Guideline 9:** &gt; All options should precede operands on the command line. &gt; [...] &gt; **Guideline 11:** &gt; The order of different options relative to one another should not matter, unless the options are documented as mutually-exclusive and such an option is documented to override any incompatible options preceding it. If an option that has option-arguments is repeated, the option and option-argument combinations should be interpreted in the order specified on the command line. &gt; **Guideline 12:** &gt; The order of operands may matter and position-related interpretations should be determined on a utility-specific basis. &gt; [...] 
&gt; I think you mean convention. While there are good reasons to keep to conventions, there are good reasons to allow required -*'s. Here's one. I write a shell script that calls a program. I want to make the program call as clear as possible because I may not open the script for a couple of years and I don't want to have to slog my way through the manual again. prog --long_argument_I_will_understand t* --another_one 64 is way better than prog t* 64
&gt; Typical **UNIX**: &gt; ls -al foo bar *.exe exe? Really?
Most of the arguments (EDIT: ha, no pun intended) here against allowing required, named arguments seem to be saying “It's terrible to force the users to employ named arguments for things that could be handled with positional arguments”, and that's true, but it doesn't seem to be the point. What's wrong with allowing positional arguments if you remember their positions, and named arguments if you don't? For example, every time I need `ln`, I (1) look up the manual or (2) get it wrong. Allowing `ln --source source --target target` *and* `ln source target` (which is, it seems to me, essentially trivial; in Perl, modulo the actual work of getting the arguments, it's just `$options{source} ||= $ARGV[0]; $options{target} ||= $ARGV[1]`) would save me that trouble, while not inconveniencing anyone else with a better memory. EDIT: This is very similar to [dvogel](http://www.reddit.com/r/Python/comments/cuorg/optparse_was_smartass_argparse_is_smart/c0vew59)'s comment.
I personally have trouble reading and processing information at the same time. When learning something completely new I'll have to reread the same paragraph at least 4 or 5 times than think about it for a moment to understand what the writer was trying to convey. I'll read a book to learn something new if I can't find a better alternative(video, outside help), but it's slower and I often come away with a worse understanding. It also takes longer for me to understand how a particular author's quirks affects their writing than it does with someone speaking over a screencast. Picking up on the speaker's unique inflection, pauses, sayings and other characteristics help me understand explanations better. 
you go to djangoproject.com and click the link that says documentation. 
You're misunderstanding me. I think argparse is an outstanding library (though personally I'd have settled for something a little **less** compatible with optarse's API and used a plain hash instead of that ugly "let's stick options on an object" thing). I'm aware that you don't have to have "mandatory options" oxymorons in an argparse-powered application. I just happen to think it's one of the things (maybe the only thing) where optparse is more correct than argparse.
Obviously, many GNU utilities happily go beyond Guideline 9 (`rm * -rf`, `ls * -l`, etc). In any case, I fail to see where your quote mentions whether "mandatory options" (aarg) are allowed.
Haha! I didn't notice that. I've been doing some DOS crap (takeown and cacls) and got confused.
Another way: ln [-Ffhinsv] source_file ... target_dir In that case, the first and last positional arguments are required, but the middle ones are not. They *could* come from a shell expansion, in which case there really is no named-option equivalent. ln *.html html_dir/ Well, maybe ln --target html_dir/ *.html That's probably how `ln` should work.
What I wonder is why neither optparse nor argparse can simply return a dict (or a subclass from it) instance holding the options/arguments instead of returning an instance of "Values" (optparse) and "Namespace" (argparse) after parsing. Specially since both allows you to `set_defaults()` by providing a dictionary mapping. Edit: dict or subclass of.
It doesn't explicitly state mandatory options aren't allowed, but my interpretation is that is implied. It makes the distinction between operands and options for a reason. Operands are meant to be positional and are the proper way to include mandatory information, where flags/options are meant to be optional and non-positional. In the full text of the link I provided there's the following (relating to your point on GNU utilities): &gt; It is recommended that all future utilities and applications use these guidelines to enhance user portability. The fact that some historical utilities could not be changed (to avoid breaking existing applications) should not deter this future goal. That said, at this point in the game there are probably enough non-conforming utilities to make it almost as bad as English. The solution may be to simply include a wrapper script that is POSIX compliant (ie, you call it correctly and it'll call the actual utility in whatever crazy local dialect the author decided to teach it to speak). 
I think he meant to say *verbositorynessification*
I find it always helps best to have a *real* project in mind when learning a new language / tool. Rather than just trying to learn something for the fun of it, you actually are forced to learn more specific things and solve real world issues. It won't expose you to everything, but it will get you in the door, and probably more invested than if you just made a simple BS project up.
Now where do I have the list with exponentially running (ir)regular expressions …
Get this book: http://apress.com/book/view/9781590599969 You only need a PDF of it. It's a step-by-step to setup right and build a simple project. I found it really useful.
The online regex tester I have been using updates automatically as you type highlighting the matches and it can test replace patterns, but this tester is nice because it has the timer and because it is in python.
Nice. I think I'll stick with [Rubular](http://rubular.com/) for now, however.
The regex tester built-in to Komodo also matches as you type.
imo, those who ask rather than diving in are the ones that never learn shit decide on a relatively complex project you want to code, and just get into it
but if= and of= are not exactly standard either so it's more of a counter-example to the "positional args only!!!!!" line of thinking than anything else.
The object thing makes the code more readable, in my opinion, especially if your options are getting used in quite a chunk of code.
You can easily turn it into a dict with dir(), can't you?
My roommate would disagree with you. He just leaves an Explorer window open and double-clicks to run the script.
But Komodo Edit is available on any platform.
&gt; I just happen to think it's one of the things (maybe the only thing) where optparse is more correct than argparse. Here "correctness" may be an artifact of a convenient word for those things that you want/need to pass to a program, whose meaning seems to have been turned into a minor religion.
www.DjangoBook.com is the best resource I've found yet. Also a shameless plug to www.PHPtoDjango.com incase you know a bit of PHP.
I did not know that. Nevertheless, the point stands - it's perfectly effective to do some types of Python development in Windows.
&gt; See how libraries work around the registry for loggers. I had a quick look at SQLAlchemy (e.g. connection pool loggers) but I couldn't readily see the motivation for setting up logging the way it has been. Certainly, it is possible with the current API to provide per-connection or per-thread contextual information in logging output, without creating connection-specific loggers (and thus without the consequent need to remove them). I will look more closely at SQLAlchemy, but please can you give other examples of libraries which do these workarounds? &gt; libraries that configure logging have all kinds of hacks to make sure loggers are cleaned up Why are hacks required? Loggers have removeHandler() and the handler can be closed to clean it up. Do you mean that some convenience methods are needed for common use cases? If so, what would those method signatures look like? &gt; Logbook gets rid of the concept of a logging registry. The shared logger registry is advantageous in many/most situations, which is why it's there. As you are perfectly well aware, you can't avoid shared state in Python, whether it be sys.modules or something else. So please expand on "the shared state is a pain point" by saying what it is you'd like to do and how the status quo prevents it. For example, Mike Bayer's (zzzeek's) comment definitely gives me more to work on.
&gt; it would be nice if we could ask the logging package "has a handler already been set up for sqlalchemy.engine"? This can of course be done using logging.getLogger("sqlalchemy.engine").handlers; are you asking for this to be made available using a formal Logger.getHandlers() API? This would be just "return self.handlers[:]" with appropriate thread safety interlocks. &gt; just to be able to say logging.disposeLogger(name) The reason this has not been provided is the possibility of other threads having references to a logger. If the logger's disable flag is set, then this is effectively the same as the logger being disposed of. Please can you tell me more about the scenarios in which you want to remove loggers altogether, i.e. when/why to want/need to do this? The [LoggerAdapter](http://docs.python.org/library/logging.html#loggeradapter-objects) class allows individual pseudo-loggers to be created (and disposed of - they're not shared state), each of which adds context-specific info to the logger's output (e.g. connection-specific info: you could have just one logger for a connection pool but separate LoggerAdapter instances for each connection in the pool). The LoggerAdapter API apes the logger API in terms of debug(), info() etc. Regarding logging under multiprocessing, I take it you mean multiprocessing in general rather than just with use of the multiprocessing module. The ConcurrentLogHandler approach doesn't work on all platforms (though it does on Windows and POSIX). I will study the SO answer you provided and see how best to improve support in the generic multiprocessing scenario.
It's not just that it's cooler - it's closer to TOOWTDI (There's Only One Way To Do It). If that One Way is a good and elegant one, fine. If it's not - as far as logging is concerned, as maintainer I'm there to try and rectify that, modulo not being able to please all of the people all of the time :-)
Your observation, while generally true, is not reliable enough in practice to be useful. The shell will handle expansion and the results of the expansion may break the utility's ability to parse your flag if it is given after the operands. i.e. $touch -- '--' $ls -l * total 0 -rw-r--r-- 1 dfndoe dfndoe 0 2010-07-28 22:40 -- $ls * -l ls: -l: No such file or directory edit: changed example a teensy bit for clarity.
An easy quick way to share code is Pastie.org - syntax highlighting is also supported
Optparse may not automagically do most of things documented as differences or advantages in the argparse docs, however it is plenty extensible especially through use of callbacks AND it is part of the standard library. It's behavior matches the expected and normal behavior as is dictated in the posix standard and it doesn't seem like there is a strong value proposition in having to ship/depend on additional non-standard libraries in order to subvert the norm.... YMMV
I'm not sure I believe in "implied" guidelines. However, I'll agree with you that most Linux command-line utilities *do not* use "mandatory options".
Maybe, but less Pythonic. AFAIK, you can't even iterate easily over the arguments set on a `Namespace` object returned by argparse. Hashes *would* be better (they work fine in [ConfigObj](http://www.voidspace.org.uk/python/configobj.html), for instance).
An "artifact of a convenient word"? Uh? In any case, wanting CLI Python programs to follow established conventions is not unreasonable. It's not like making your custom argparse class allowing for "mandatory options" would be very difficult, but it would send a clear message that "mandatory options" are heavily discouraged.
I was not commenting on how useful or reliable it was in practice. Fact is, it's supported in many GNU command-line utilities. Personally, I like this behaviour a lot better than the standard POSIX way. This lets you, for instance, write `rm &lt;stuff&gt; -rf`, which lessens the risk of pressing "enter" by accident while typing the path of whatever it is you're trying to remove.
Yeah except the behavior is dependent on the operands, which means you are introducing some potentially odd behavior to avoid the unlikely case that you would hit enter before you were done with your command. The generally better practice would be to wrap your operand with quotes such that any accidental carriage returns would not be sufficient to complete the command. 
My way is the best, pyqt and designer. flame out LOL. http://diotavelli.net/PyQtWiki/Tutorials EDIT: I have been building apps with pyqt for so long and I still love it.
I completely agree with you! I do that same :)
Thanks a lot for your advice! Getting started with the official tutorial.
&gt; The shared logger registry is advantageous in many/most situations, which is why it's there. I don't see the advantage. &gt; As you are perfectly well aware, you can't avoid shared state in Python, whether it be sys.modules or something else. That does not mean it has to be everywhere. &gt; For example, Mike Bayer's (zzzeek's) comment definitely gives me more to work on. If you want some feedback for logging improvements I can create you a list of warts I found when writing logbook. The core motivation of logbook however is the stack and I don't see how that could be integrated into logging without breaking the whole API.
Add a double-quote to the regular expression and you get a 500.
Not so much of a masterclass, more a detailed overview. 
I stopped after the first few crap pages.
I thought this would be an article about a pythonic design pattern.
I usually wrap the call to `parser.parse_args()` with a function, let's say `get_options()` that does `return dict(parser.parse_args().__dict__)`. I simply don't see any reason for them not doing that instead of returning something that is not a dict (optparse) nor iterable (argparse).
http://docs.python.org/dev/library/argparse.html
&gt; I don't see the advantage. Sure, but others do. You don't need to pass loggers around, since they can be accessed by name from anywhere in an application. &gt; That does not mean it has to be everywhere. It's not everywhere, but just where it makes sense to have it. &gt; I can create you a list of warts I found Sure, please do that. I'm always interested in improving the core logging package for all users, where it is possible to do so.
It's because of the namespace.something thing. args = parser.parse_args() args.myoption is nicer than: args = parser.parse_args() args['myoption'] Allegedly.
&gt;Hashes would be better Hashes would have the problem that you'd lose the order. There is often value in grouping related options together in your --help message (eg. --username next to --password) which you'd lose with a hash. (Though you could switch to a list of tuples or something instead).
I have always thought about doing this. vim is great, but vimscript is not. 
The WHOLE POINT of written standards is this: when everyone just knows how it works, it turns out that everyone's interpretation is subtlety different. When there is a written document, then they can be explicit about what they agree on. Your "interpretation" that it "is implied" because "It makes the distinction between operands and options for a reason." is WRONG. Now, perhaps it would be BETTER if the guidelines had a line there saying "Guideline 9.5: Not option may be mandatory - the utility should still be able to operate with any option missing." but it doesn't say that and so it's just not part of the standard.
Yeah. Using `find` instead of `os.walk()` or `os.path.walk()`? C'mon.
In "Why you should use LogBook/Advantages over logging", you state: &gt; If properly configured, Logbook’s logging calls will be very cheap and give a great performance improvement over the standard library’s logging module. It would be useful if you could substantiate this, please can you post your benchmarks? &gt; It also supports the ability to inject additional information for all logging calls happening in a specific thread. For example, this makes it possible for a web application to add request-specific information to each log record such as remote address, request URL, HTTP method and more. Logging already supports this, and has done for some time, and this is reasonably well documented - so how can you claim this is an advantage over logging? &gt; The logging system is (besides the stack) stateless Hmmm. So stateful is bad, except when *you* decide otherwise. Way to go, Armin.
&gt; Sure, but others do. You don't need to pass loggers around, since they can be accessed by name from anywhere in an application. With the logbook concept you can just import them or access them from more local places. For example in SQLAlchemy I would just get the logger from the connection I am dealing with. I might be appear to be the greatest supporter of logging, bug if you check the Flask documentation you will notice that I encourage people to use the logging library :) I just think for web applications the existing logging concept does not work good enough. In a web application I want to have all the log messages that happen during a request extended with additional information. And without a log of monkey patching that also is not very reliable due to the way logging accesses the name of the caller, there is no way to implement that.
&gt; With the logbook concept you can just import them or access them from more local places. Yes, but you sometimes need to access loggers which are non-local. For example, I may want to configure SQLA loggers in my application. For that, ISTM that logging.getLogger('sqlalchemy') is the simplest approach. &gt; the existing logging concept does not work good enough. In a web application I want to have all the log messages that happen during a request extended with additional information. But the logging documentation shows [how you can do this](http://docs.python.org/library/logging.html#adding-contextual-information-to-your-logging-output), with no monkey-patching required. If you give more specific information (e.g. exactly what you might want to appear in the output) I can probably give you a recipe. 
I mean that someone wants arguments, someone else wants flags, someone else wants options, and someone else wants mandatory parameters. The fact that the module is called "optparse" is an accident of someone taking one of these terms and embracing it with religious fervor when writing a library to help programmers write programs that allow for users to specify the behavior of the program. Let me say that again - the point of all of these libraries/modules (from getopt to optparse to argparse, to everything else that ever comes) is to let the program be used by users. All the discussions of the pros/cons of "options" vs "positional parameters" and other such crap is just crap that may as well be the froth about a discussion of how many angels can dance on the head of a pin. It gets nothing done, and makes no-one's life better.
Ah cool. I hadn't realized it was in the standard library upstream.
Yeah, it's brand spankin' new in 2.7 and 3.2
I find it nicer indeed, but I don't see a reason for `Values` or `Namespace`s not being a `dict` subclass instead.
There are few incompatibility between Ruby Regex and Python Regex isn't it? AFAIK, Ruby does not support certain subset that Python does. (Lookahead/Lookbehind stuff, I think)
yea wtf was that
First of all logger adapters came in 2.7, which I cannot depend on currently. Secondly that only works for loggers that are adapted, I cannot use this pattern to wrap *all* logging calls that happen during a request for loggers I don't know.
|Feature| Python | Ruby | |-|--------|------| |Regex Literal|no|yes |Named Groups|yes|no |Lookaheads|yes|yes |Lookbehinds|yes|no |Yes/No Pattern|yes|no |Unicode Support|yes|yes
well how would you search for files at *nix command line ? So what is wrong with letting the OS do the work ? maybe faster than "walking" ?
Not really. I love Netbeans for PHP, but I've had to switch to Aptana or Eclipse for my Python work. I've heard better Python support is coming to Netbeans in the future...
Try the glob module.
(You linked to the https version of your site, so I get an untrusted connection page from Firefox.) I recently started learning Web2Py, and now I wish I had kept a list of things that I didn't understand at first due to documentation. The only feedback I have is that [in this section](http://web2py.com/book/default/chapter/07?search=is_slug) you wrote "is converts" instead of "it converts." Great framework; I will probably buy the book.
tl;dr: * Use Python3 if you control the environment your program will run on, and you don't need any 3rd party libs that lack Python 3 support. * Use Python2 for everything else.
I'd rather read it as use 3 if you can, 2 if you must - but plan ahead and don't use deprecated features.
Uhm. I'll settle for "what works well 99% of the time". I don't write this in shell scripts...
Aren't we talking about different things? I'm discussing the `Namespace` object, ie the `args` object you get by doing `args = parser.parse_args()`. You don't have, and don't need, any kind of order on this one. Hence why it could be easily (and Pythonically) replaced with a hash.
Uh, sure. I mean, who knows what would happen if people started discussing the best way *other* people should interact with their programs, and try and agree on a certain common behaviour to ensure consistency?
I've heard aptana has better support - but I really wanted to just use one ide for everything. (The other language I use netbeans for is, oddly enough, php as well). Oh well - guess I'll give aptana a try. Thanks.
Ah sorry - I misinterpreted then. I thought you were talking about the parser object itself. Ie replacing the whole chain of `parser.add_option(...)` with `{'--opt' : details, '--opt2' : ...} style syntax. For the returned args object, does iteration matter? I've never wanted to loop over options, since they're fairly heterogenous values. Certainly I wouldn't want *pure* dictionaries, since access with barewords is generally cleaner looking. I'd have no real objection to a hybrid object that exposed both (ie `__getattr__ = lambda self, key: self[key]` ) , but don't think I'd find it useful. The only benefit I can think of would be using with interfaces that already expect a dict, where it'd save wrapping yourself. 
I recently joined the [Mac Python mailing list] (http://www.python.org/community/sigs/current/pythonmac-sig/). On it, I discovered BundleBuilder as an alternative to py2app (although I cannot get it to work) and that system Python can't be redistributed due to licensing issues. Ronald Oussoren has recently updated py2app. Perhaps a wiki that tracked the current state of things would help?
I would recommend getting a valid certificate...
I'd try and help out, if such a site existed.
Saved. SASS for CSS. SHPAML for HTML. With this, the final piece is complete. Full pythonic web development :)
If truth be told, I'm more used to Twisted's take on option parsing. I'm not arguing for hashes because they allow iteration (though it's occasionally convenient), but mostly because they're cleaner. The `Namespace` class has no method of its own, it is a hash with less methods but more sugar. And if it walks like a duck and quacks like a duck, then there is no reason for it not to be a duck ("There should be one-- and preferably only one --obvious way to do it." - and we already have it!). In addition to this, I really don't like the notion of a class whose fields will be wildly different between two instances at runtime (granted, this will not usually be a problem, but still, it looks ugly to me). And I'll be the first to admit that it's not very dynamic of me.
You could start by helping to update the existing MacPython wiki entries on the python.org wiki: http://wiki.python.org/moin/MacPython/
oops. the https was not intentional. Thanks for the correction. I am sure there are many typos and there will be a few revisions before it goes to print.
Well, if everyone was forced to do one thing, then someone would get upset and do things differently.
Oh, there's much more to come. For example, a development server with sass, PyvaScript, and pyjs (the Pyjamas compiler) integration and a PyvaScript plugin for pyjs, so you can write Pythonic code via PYVA() intead of raw JavaScript via JS(). Not a single line of JavaScript, anymore. ;)
Nope, it just supports the encryption that the base Python zipfile supports, which was the original (poor) encryption available. If the vanilla Python zipfile module ever adds AES and does so in pure Python for some reason, I'll probably update czipfile, though I can't imagine they'd actually do that. To be fair, re: terribleness, encrypted zipfile support isn't something that's commonly required. I can see their point that maintaining extra C code in CPython isn't worth the corner-cases where somone like you or I actually needed the speed. But whatever; czipfile should do for the future, now, anyway.
shoot me an email at me@kennethreitz.com. I'm going to start one.
[Translated from Spanish]
I've yet to write any Python 3 code. Maybe in 5 years...
It's OK, you can use the #@type *var* *object* declaration before your line to give the syntax highlighting a boost. Obviously not as productive as some other IDE's but it gets the job done. 
A Windows version would be great.
I've been creating invalid security certificates since before it was cool. 
Have you tried? What is stopping you?
I don't get what you're trying to do. Would you mind explaining a little more? (I know what MacPorts, etc are.)
Libraries (wxWidgets)
how about usage code, thanks
Here's a way to do async concurrency without yields (with greenlets): http://www.gevent.org
Have you thought of using [gevent](http://www.gevent.org) as a foundation for diesel? That would probably save you a lot of time. Gevent aims to be small and dependable, it should be a good start to build something higher-level.
Great book.
Sorry, the slides are [here](http://codespeak.net/svn/pypy/extradoc/talk/ep2010/talk/talk.pdf)
sadly pythonauts never caught on, :)
gevent is yet another coroutine based Python IO library that uses greenlet just like diesel or eventlet. gevent, like eventlet can, uses libevent as an abstraction layer between itself and the operating system's underlying event based IO APIs (epoll on Linux for example). diesel chose to just use Python's select.epoll module directly. gevent may reap some slight performance improvements by leaving more of the low-level networking work up to C, but OTOH libevent is just another layer between your code and your NIC which diesel does away with. I would imagine that the performance difference would be small enough as to not be noticeable in any but the most demanding situations.
I agree 100%, this is a great book to start learning.
&gt; First of all logger adapters came in 2.7, which I cannot depend on currently You can copy and paste the code from 2.7 or SVN if importing LoggerAdapter fails; the class should work in Python 2.4, 2.5, 2.6 as is. I haven't checked 2.3, but see no reason why it wouldn't work there either. &gt; I cannot use this pattern to wrap all logging calls Perhaps true, but if you have very specific needs you can always use a combination of Handlers, Formatters and Filters at the appropriate levels of the logger hierarchy (even root, if necessary) to get the necessary hooks to do pretty much anything you want. Of course that's a very general statement, but if you give a more precise description of what you need, I can give you a more precise recipe. 
This is awesome, for example, I develop on a windows machine, and site is hosted on a linux. I had to write custom code to handle each. 
Huge congratulations to you for this.I have tried a couple of times but life always got in the way. I haven't had a chance to check out the site well because am on my phone but will have more of a look after lunch.
It looks great! Very cool.
Congrats :) Keep going!
Looks nice. However, it won't work on python 3 for OS X because it uses the Carbon module :(
Well done. I've been playing with django and haven't made a complete site yet. I like what you get "for free" - so much less hassle than writing equivalent functionality with perl/php (which i'm still laboured with...) Starting projects is easy but getting them through the final stages and actually stepping back and saying "there it is. Done." is another thing entirely. Good on you for finishing it.
&gt; I knew enough programming to be dangerous. Hm... &gt; Slowly but surly... *HMMM...* 
Good work! Nice site design too. Very simple and clear, but good looking.
Wow if that's your first site then you have a bright future ahead of you.
It seems to live on through the use of djangonauts :-)
Thank you. I was a fan of python for general system stuff in, but wound up with a job in a RoR company. Since then, getting back into python has always been difficult for me. I feel motivated now. :)
Like everyone else is saying, it looks really good! Did you do the design yourself? If so, how did you go about learning?
I started replying but then noticed your username. Oh well
&gt; On Linux (and other Unices) the dir is typically: &gt; &gt; ~/.&lt;appname&gt; Nooo! Configs go in ~/.config and data can go in ~/.local/share/data
Ha, sorry, I'm from Mexico so my spelling is a little off.... :) - edit: hehehe you're right, no excuse!!! :)
I always look for a theme at ThemeForest first myself. Most graphic artists are so much better than me.
Wow. It's rare that I'm dismayed by Google software. I'd assumed that AppEngine was as amazing as everything else they produce, but it looks like a translation from C++ code. Your version is Pythonic. Any idea why it wasn't like yours in the first place? Maybe there's a good reason. ... Wow!! I just noticed the 'other discussions' tab in reddit, for other submissions of the same link. Those reddit folks never cease to amaze me either.
Thanks xlorm!!!! I just modified the original design which I bought from themeforest.net. 
&gt; You can copy and paste the code from 2.7 or SVN if importing LoggerAdapter fails That does not work due to how findCaller figures out who calls it.
We in the web2py community are excited about Pypy and ported [web2py to it](http://groups.google.com/group/web2py/browse_thread/thread/3193954396dc1892/17050e2f352090e3?lnk=gst&amp;q=pypy#17050e2f352090e3) but as you can see at the bottom of the thread, we are having a problem with it. PyPy does not close files when they go out of scope while cPython does. Why is it?
Different garbage collectors. CPython uses reference counting, so it notices right away. PyPy uses something more advanced, so it doesn't. Relying on the garbage collector to close your files (and free your resources in general) is not a good idea; try to get into a habit of explicitly closing them. The 'with' statement is often convenient for that.
Very nicely done. You've kept the performance really high, which is awesome. Adding django to that tends to increase the response time by several hundred milliseconds, unless memcache is used extensively. Nice work!
Thanks. Makes sense. I think web2py does closes all files explicitly but it is not guaranteed that applications do. Unfortunately we cannot use "with" because of 2.4 compatibility.
indeed, as mgedim already pointed, the behavior you observe is an implementation detail of CPython, i.e. that it uses reference counting to destroy objects when they are not needed. All the other Python implementations around (PyPy, Jython, IronPython) use a proper garbage collector which does not guarantee that files are closed immediately (and, in general, that __del__ is called immediately), but only "at some point in the future". Note that guido explicitly said that refcounting is an implementation detail and programs should not rely on it, although I cannot find the exact reference now.
I've been learning python / webpy for a month or so now and have just started Django this week - this is good motivation!
Ah, that's what I was looking for. Yeah, it's not elegant but it does help. Thanks
That's actually pretty cool.
Do you actually get the languages confused? Really? I find that crazy, really. 
I understand this part and it makes sense. Yet on some programs people have reported "too many open files" errors on PyPy. Although this is a OS error, perhaps PyPy could avoid the problem by calling the garbage collector for life objects before trying to open a new file.
Really excellent work for your first application/website. I've deployed dozens of Django apps over the years and this is probably the best debut I've seen from a single developer new to Django and Python. Best of luck with the site and the company.
Wow, thanks so much! Really!!!! 
The problem is to find garbage objects (including file descriptors) PyPy needs to trace all live objects (technically the live objects are partitioned into young and old, but bear with me here). This has a nonzero cost, and therefore we try not to do it excessively. Doing a GC, even of the young objects only, would kill performance in heavily file based application (such as a network server). In general, judicious use of the finally statement handles most short lived files.
How did you handle the screen capping of the sites? Manually, external provider or rendered under something like xvfb?
Then you need to just call file.close() Your code was always buggy. It just happened to work because of CPython's reference counting semantics. Guido has been warning people to not rely on reference counting to auto-close their files since Jython came out over a decade ago.
&gt; Don't reinvent the wheel Did you take the same approach with your coupon listing page design? It appears to be just a bad copy of [retailmenot](http://www.retailmenot.com/view/walgreens.com) - http://cl.ly/1pQX
I actually prefer http://www.google.com/codesearch then use lang:python in your search query. :)
What is the intent of this site? All I could tell is that it's a very stripped down docs.python.org, basically just down to function and method names.
you've earned it :)
Congratulations! I know how you feel. I've finally completed my first app after 5+ years of trying to teach myself to program than going back to college for 3 years and now (finally) a year later I've actually released something that I can say I wrote &amp; I'm actually pretty proud of. It's taken a lot, but it is so gratifying! I must say that lookingforcoupons.com looks like an impressive and focused site. Great job! I'm curious who you use for hosting and if you have any idea how well it will scale. I've got a second project (this is a personal project I've been dreaming of for 3 years now) that I had originally planned to run on AppEngine, but now that I've learned how awesome django is I want the full glory of it, not the restricted non-rel stuff. Well, that was long and rambling. Cool site.
Their's no excuse for grammer in reddit.
&gt; Set small daily incremental goals: Something that really helped me would be to set a specific goal every time I sat down to code: finish x before I go to sleep. I cannot express precisely how much more productive I am when I do this. Small features add up. Work on one thing, *get shit done*, then move on to the next thing. &gt; Avoid the internet while working: Turn off your wireless or un plug your lan cable, keep a pdf of django and python docs locally so there is no need to go back. Your reward for finishing x today is to check reddit. Myself, I prefer exerting the willpower to avoid reddit (as I'm obviously doing now :D) to disconnecting from the internet, as a) pip works better when you can hit the package index, and b) I often make use of bitbucket's private repo option (because you never know when a drive might die).
The server-side JS and GWT and RubyJS people talk about using "just one language for client and server" the whole time, so why do you find this so crazy? As far as I can see, there's a lot of interest in reducing the number of languages one has to use and learn for web development. Since I'm primarily a Python developer I forget quite often to use "var" or a semicolon and often I write stuff like "if x == y:" and I've seen my colleagues do the same from time to time. Another advantage is that it's easier to optimize performance-critical Python/pyjs code because it's much more similar to PyvaScript than JavaScript. Also, we personally don't like JavaScript's C-like syntax, at all. Call it a matter of taste, but for us it's more fun and less bugs than with JS.
Hello, this is strange, the filter in right column enables very fast search in names of functions, methods, constants, and any of the hits lead to expandable list of short descriptions and links to original documentation.
They are different problem domains. I totally expect different languages.
Now I guess I see your problem. I am so used to the system that I started to consider natural to always click on the name of the module to get to the function (method, constant, ...) explanation and link to the documentation. It would be much more natural, if it expanded immediately - I will do it in a few days - the feedback proved to be very valuable :)
We're not talking about "SQL vs JS" here. The problem domains are actually quite similar, especially if you want to write web apps. Just take a look at SproutCore, Cappuccino, GWT, and Pyjamas. Many even argue that JS is not suited at all for complex projects. This is why Cappuccino uses Objective-J, GWT uses Java, and Pyjamas uses Python. If you're only working with jQuery then JS might be fine, but the only real difference compared to pure Python is that JS supports multi-line lambdas (which we have in PyvaScript, too). EDIT: Almost forgot classes vs prototypes, but that doesn't make either more suitable for client-side web development.
I believe we do close all files we open explicitly. One year ago we went over this open by open. I have not experienced this problem "too many files open" with Jython.
If you don't mind, how much are you paying for hosting / where are you getting it from?
Trolls trolling trolls...is this SA?
Sure thing: I'm hosting at http://www.webfaction.com/ and am paying about 8.5 per month. It's probably the best shared hosting solution out there for Django!
I'm using a third party service @ http://webthumb.bluga.net/home . They offer a simple API. If you are interested I can share the code for this if you eventually sign up. 
Yep, it's a bad copy of retail me not, I'm still proud of it though :). 
Webfaction, nice, yeah it comes up here every time someone asks for a recommendation. Alright, really is time for me to get off my ass and start doing something in django that doesn't involve App engine... 8.50 I'm sure I can manage. Thanks for the motivation :).
Thanks for the feedback, I really appreciate it. My hosting is webfaction, no idea if it will scale, I'm guessing it will since it's not something db intensive. Dude, you should share your app with us, where can we find it? 
To get around this, I'm on a local mercurial repository, which I then push to bitbucket. I learned to use easy_install, but have never used pip. Ha, to be honest, I don't even know the difference... I'll have to look it up. 
Go for it! There is also a 5 dollar option. It takes a while to get through their learning curve, but they have great support and documentation. I'd recommend them any day. I did not know anything about linux or deploying django, had to do a lot of reading to get started.
It's region specific. It's called Farmshed and it's an iPhone app, but it only covers Central New York. I wrote the server side in python with django on AppEngine. If you're interested in where the last 3 months of my life went (after work hours) it's available on [iTunes (fo free)](http://itunes.apple.com/us/app/farmshed/id377668931?mt=8) If you're not in the CNY area you can set the location manually to Rochester, NY.
The fix has been easier than I have expected, if you reload the cache and try again I hope that the usefulness is now more obvious :). At least for me the possibility to browse very fast for relevant methods and functions if I just have a feeling that the method with such name must be somewhere in some module is useful (and filter can be enabled to use regular expressions)
Have you run something like lsof to verify which files are leaking, and then double-checked the code that's supposed to be closing those particular files? Are your file.close() calls in finally blocks, or just inline where an exception might route around them? I'm surprised that your code works in Jython but not in PyPy, since neither uses reference counting. I just wrote a trivial test program that creates 10000 tempfiles in a loop. On both CPython and PyPy, it crashes with "OSError: [Errno 24] Too many open files", unless I either close() the file (works in both), or overwrite/delete the reference (works in CPython, doesn't help in PyPy).
I've found pip to be something of an upgrade to easy_install. For example, whenever I start on a project, I generally create a virtualenv for it, and use pip to install a bunch of goodies into the new environment so as not to pollute my system. It's usually along the lines of `mkdir project &amp;&amp; cd project &amp;&amp; virtualenv env &amp;&amp; pip -E env install -r requirements.txt`, where requirements.txt has all of the packages that I often use. When I need something else, I add it to the requirements file, so if/when I need to shove the project onto a new box, I can just run the same set of commands. (And, of course, all of this can be pretty easily automated via [fabric](http://docs.fabfile.org/0.9.1/).)
I intentionally stayed away from judging javascript as a good language for the problem domain. I think my main difference here, is that I am language agnostic for the most part and just view it as some vehicle to reach an objective. And although I don't want to deal with complexities that aren't specific to the problem, I realize that when some complexities try to be hidden, all it does is create new, more difficult problems in its place and at the end, I just spin my wheels and squander time. I wonder if this unification effort may, at least for me, be one of those instances.
random? where did you get that from?
We have the FLUFL...
Thank you very much but it's all good, I wrote my own renderer using the webkit engine in PyQT - I was mostly just interested in how other people went about it as I'm not sure it's the greatest thing in the world - but meh, works :)
via [python-dev](http://permalink.gmane.org/gmane.comp.python.devel/115715).
I can haz bug report for that? Happy to fix it for Python 3. Do you know the appropriate API for getting that info?
Why complicate things with xml if you can use json format?
A site laying out best practices and recommendations for best-practices and python.
I have not run these these tests myself but I will talk to the testers and will make sure they are run. Thanks, these are excellent suggestions.
Next thing you'l probably learn is how to scale dJango (site is slooooowwww). Means u can abandon django and move to gae/tipfy ;-)
I added issue 1 for this: http://github.com/ActiveState/appdirs/issues/#issue/1
There's no appropriate way to get it without either having pyobjc as a dependency or by creating a C extension that will call the appropriate Cocoa call (NSSearchPathForDirectoriesInDomains)
Google follows some other conventions than PEP8, so naming and spacing is very unpythonic indeed, but other than that I think the code in the SDK is in general clean and pythonic. Some exceptions have their reasons, like `google.appengine.ext.db`, which tries to resemble Django models in some ways and for this uses some nasty meta-class magic. Same can't be said about webapp. It is very simple and pythonic, following that `RequestHandler` scheme best known from web.py and, now, Tornado. It misses features and seems unfinished, though, but you can't say that it is terribly unpythonic imo.
Why the downvotes? Awesome_Pancakes is right, it looks like a copycat of retailmenot: - "Did this coupon work for you?" - Links with scissors ("redeem") - etc. Edit: that's probably okay for the start, though. But you could be more original :-)
For *nix, just use python-xdg. Its kludgy as hell, but you follow the rules.
Perhaps I'm paranoid, but I'd be cautious about leaving the admin interface publicly exposed as /admin. I suppose you're fine as long as you have a relatively good password, though.
I agree that hiding complexities can lead to problems if the abstraction is incomplete. For example, if you use C++ for development, but you only get Assembler for debugging you totally have a problem. However, if the whole set of development tools operates at a higher abstraction level you don't really introduce any complexities. You only introduce a better abstraction to describe your problems. Indeed, PyvaScript doesn't have a complete abstraction including debugging tools, but it isn't a huge semantic abstraction over JS, anyway. In contrast, the pyjs compiler does provide a debug mode, so you get better tracebacks. It's not perfect, but it's much better than debugging the generated JS code. These things will improve and maybe pyjs can even provide a useful in-browser debugger in the future.
Nice work. Looks slick. 1 suggestion: change /stores\_that\_start_with/ to /stores/
I was thinking of these points: * Handler methods receive keyword arguments instead of positional ones. * Lazy handlers. * initialize() is replaced by a proper __init__()
I've had webfaction for over a year and pay less than $10 a month for a single host that I use for a few low-volume websites. Their customer service has been amazingly responsive so far, even when I hosed my own database on accident and they had to fetch my files from a nightly backup. I recommend it to anyone starting out!
Well, it is seems unfinished... or this is the intention -- to serve for quick start, no feature ambitions, and good enough for fast services (pubsubhubbub uses webapp). AFAIK webapp has mostly the same API/form it had on release in 2008.
this sounds like a job for regular expressions http://docs.python.org/library/re.html
yeah but! &gt; Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. &gt; - Zawinski Man I am soooo clever... 
Specifically, like: regex = re.compile(r'something') # or re.compile(re.escape(some_var)) match = regex.search(some_string, start_pos)
 sampleString = 'BOB: 6 beers, STEVE: 7 bourbon, 3 beers, GAYBOB: 2 manhattan' steve_drinks = sampleString.split("STEVE: ")[1].split(':')[0].split(', ')[:-1] print steve_drinks Yes, I know it's hideous
I live by what you said. My personal portfolio is filled to the brim with python 3 examples because a majority of them don't depend on libraries, but I state very explicitly to potential employers that I understand the differences between 2.x and 3.x and can easily change between the two if needed.
more like: re.split(r'([A-Z]+): ', sampleString) but I agree with thantik example: &gt;&gt;&gt; import re &gt;&gt;&gt; from pprint import pprint &gt;&gt;&gt; ss = [ ... 'BOB: 6 beers, STEVE: 7 bourbon, 3 beers, GAYBOB: 2 manhattan', ... 'STEVE: 7 bourbon, 3 beers, BOB: 6 beers, MARGOT: 1 RUSTY nail. GAYBOB: 2 manhattan', ... 'GAYBOB: 2 manhattan, STEVE: 7 bourbon, 3 beers', ... 'GAYBOB: 2 manhattan, MARGOT: 1 RUSTY nail..', ... ] &gt;&gt;&gt; pprint([re.split(r'([A-Z]+): ', s) for s in ss]) [['', 'BOB', '6 beers, ', 'STEVE', '7 bourbon, 3 beers, ', 'GAYBOB', '2 manhattan'], ['', 'STEVE', '7 bourbon, 3 beers, ', 'BOB', '6 beers, ', 'MARGOT', '1 RUSTY nail. ', 'GAYBOB', '2 manhattan'], ['', 'GAYBOB', '2 manhattan, ', 'STEVE', '7 bourbon, 3 beers'], ['', 'GAYBOB', '2 manhattan, ', 'MARGOT', '1 RUSTY nail..']] or a more useful approach: &gt;&gt;&gt; parse_iter = (re.split(r'([A-Z]+): ', s)[1:] for s in ss) &gt;&gt;&gt; parse_result = [dict(zip((n for i, n in enumerate(parsed_item) if not i % 2), (n for i, n in enumerate(parsed_item) if i % 2))) for parsed_item in parse_iter] &gt;&gt;&gt; pprint(parse_result) [{'BOB': '6 beers, ', 'GAYBOB': '2 manhattan', 'STEVE': '7 bourbon, 3 beers, '}, {'BOB': '6 beers, ', 'GAYBOB': '2 manhattan', 'MARGOT': '1 RUSTY nail. ', 'STEVE': '7 bourbon, 3 beers, '}, {'GAYBOB': '2 manhattan, ', 'STEVE': '7 bourbon, 3 beers'}, {'GAYBOB': '2 manhattan, ', 'MARGOT': '1 RUSTY nail..'}] 
But what about those lines he has that end with periods instead of commas? =( sampleString4 = 'GAYBOB: 2 manhattan, MARGOT: 1 RUSTY nail..' sampleString2 = 'STEVE: 7 bourbon, 3 beers, BOB: 6 beers, MARGOT: 1 RUSTY nail. GAYBOB: 2 manhattan' those 2 specifically.
I find that using a regular expression solves a lot of my text processing problems, I like regular expressions :)
Not what I'd call pretty code but it seems to do what you've asked for sampleString = 'BOB: 6 beers, STEVE: 7 bourbon, 3 beers, GAYBOB: 2 manhattan' sampleString2 = 'STEVE: 7 bourbon, 3 beers, BOB: 6 beers, MARGOT: 1 RUSTY nail. GAYBOB: 2 manhattan' sampleString3 = 'GAYBOB: 2 manhattan, STEVE: 7 bourbon, 3 beers' sampleString4 = 'GAYBOB: 2 manhattan, MARGOT: 1 RUSTY nail..' import re steve_searchstr = r'STEVE:([^A-Z]+)' steve_searcher = re.compile(steve_searchstr) for s in [sampleString, sampleString2, sampleString3, sampleString4]: match_obj = steve_searcher.search(s) if match_obj: string_you_want = match_obj.groups()[0] print string_you_want If you don't understand what each line of this does you probably shouldn't use it until you do.
Oh, so wait, let me back up .. this is *your* project? If so, good job. Trying to create valuable contributions to the open source community that people approve of is damned near impossible. I understand the difficulties in this all too painfully. Beyond that, I think the problem you are touching upon is one the classic; javascript doesn't have a great all purpose debugger that magically helps us on all implementations. Each browser project appears to want to make their own; with varying degrees of success. If anything truly awesome is going to come this way, it will come via JS. Firebug lite is ok, but I think the true problem is that using the browser as a primary debugging and development environment isn't fun; and even if you get an awesome web app together, you'll still introduce a lot of new keybindings because the browser eats up the common ones for it's own purpose. At least on windows, something may come from the lunascape people that is decent, if they figure out this is a problem.
Depends on how rigid the data is, really. To compensate for the periods you could convert them to commas first before splitting on the commas
Yeah this module completely neglects XDG which is the closest thing Linux has to an official user data layout spec.
I'd like to party with STEVE, MARGOT, BOB and GAYBOB.
Lots of ui elements look like they were taken from retailmenot.com ... like the scissors to copy the coupon code.
&gt; That does not work due to how findCaller figures out who calls it. Yes, but you can subclass Logger and override findCaller to do what you want. It's a fairly short and straightforward method. Then use setLoggerClass to specify that your Logger subclass be used, before any loggers are instantiated.
Great idea! I'll do just that! 
Dude, I forgot about that, I need to remove it. Thanks for pointing that out.
EDIT: I am indeed missing something. Apologies :)
My understanding is that dieselweb is a web framework. Gevent, on the other hand, is a concurrency/network library and will never morph into a web framework. So the scope of the two libraries is different. If you're doing greenlet-based concurrency you will need a few features beyond greenlet API - events, queues, timeouts, sockets. Those are a lot of fun to implement but if you define dieselweb as a web framework I'd say it makes a hell of a lot sense to re-use those low-level concepts and focus on the "web framework" aspect of it. Regarding libevent - it's not just about abstracting out different event APIs. It's about managing queues of events and maintaining heap of timers - those are CPU and memory-intensive operations that are in the inner loop of your application and you want them to be as fast as possible. Python code won't match the performance of C code here. Given the fact that libevent is already there, mature and fast, it makes no sense to re-implement it in Python, unless you want to learn to write event loops.
This has been a very annoying issue for a long time, so I'm very glad that it's finally fixed :) [Download Here](http://code.google.com/p/pyscripter/downloads/list).
Does not work in practice. Especially not because people monkeypatch logging classes too.
[multiprocessing](http://docs.python.org/library/multiprocessing.html) would be worth playing with It allows you to split the processing over multiple processes.. It's like threading, but gets around a limitation of Python's handling of threads (global interpreter lock) It'd be a good excursive in learning how to structure code to run over multiple processors
Thanks. I started playing with that the other day. I split the image into blocks then using one of the multiprocessing modules send that to different processors (also makes it possible to do distributed computing across multiple machines). However, I ran into problems with being unable to pickle image files, so I'd have to convert the entire to a string and back, which would have meant changing how all the functions worked. It was late and I went to bed. You've reminded me I need to take a look at that again, though.
Yes, I've written PyvaScript also as an experiment with PyMeta2/OMeta. The code is relatively small for what it does. You're completely right. It's difficult to make a successful open-source project. Lots of answering questions, lots of fighting the skeptics and misinformed claims. But it's also fun when other people use your work to build really cool projects. :) Regarding debugging, looks like pyjs has some undocumented debug support. I'll try to find out if it has a real in-browser debugger. That would make things really interesting.
How about this? import re s1 = 'BOB: 6 beers, STEVE: 7 bourbon, 3 beers, GAYBOB: 2 manhattan' def bastards(line): ms = re.finditer(r'(\w+):', line, re.I) prev = next(ms) for curr in ms: yield prev.group(1), line[prev.end():curr.start()-1] prev = curr yield prev.group(1), line[prev.end():] print list(bastards(s1)) 
NB: windows-only 
I like how your favorite IDE was unusable before.
I liked it but it was really flaky (in the way a lot of Delphi apps felt flaky). Has it gotten less flaky (for some reason I can't figure out the right word)? I've been using NetBeans of Python for big projects and IDLE (cry) or PSPad for small projects. I'd prefer to use PyScripter for small projects if it truly is getting in shape, because it always felt promising.
You're right, but I think what I need to upgrade first is my search engine. I'm currently using whoosh, probably need something like xapian. What is gae/tipfy? Need to look it up!
Oh cool, I'd like to write my own someday, can you point to some resources?
Hey, pretty cool app!!! How many downloads have you had so far? 
Cool, I'm also using virtualenv, so I need to take a look at pip and fabric. Thanks for the tips. 
Good idea, I'll put it on my to-do list.
Thanks man! 
I'm just glad to hear it is being actively developed, as I was sure it has been abandoned.
nameless project owner == no
Victims ... erm I mean alpha testers. The only real way to evaluate a UI is to watch people stumble while using your application and try to make it a better experience based on that.
Nah. I just want to make some simple automatic smoke tests for nightly build. Nothing fancy. 
I usually hate books that start with "My X is the most awesome thing ever" especially after I already got it to learn X. But I think this could use something explaining why someone would choose web2py over Django, RoR, etc.
I've tried Dogtail for testing GTK programs. It's not great, because it uses the Gnome accessibility API, and turning on accessibility makes everything slower.
Not sure I can recommend it, but [project Sikuli](http://groups.csail.mit.edu/uid/sikuli/) got a little buzz lately. It is an MIT tool using screen shots - a fancy approach which honestly did not work too well when I tried it the first time last week but this might just be my inexperience.
The printed version has a preface. It is missing in the online version. I can think of some reasons: 1) it is much easier to learn and use (requires no installation, has no concept of configuration or setup files, has no dependencies, comes with a web based IDE). 2) It always is backward compatible. 3) it has a Database Abstraction Layer that is really powerful and runs on 9 RDBS and Google App Engine out of the box. 4) It relieves the developers from decisions that have security implications. 5) It makes trivial to move an app from one installation to another and move data from one system to another (even across dbs). 6) It includes a Role Based Access Control mechanism. Here is a complete program: db.define_table('person',Field('name',requires=IS_NOT_EMPTY())) @auth.requires_login() def index(): return dict(form=crud.create(db.person),people=db().select(db.person.ALL)) 
For Windows, a great package is [pyWinAuto](http://pywinauto.openqa.org/)
My favorite too. Written in Delphi makes it a bit weird.
:) it's debugger was awesome enough that I bent over backwards to use it... 
Python 3.2a1 was released, not Python 3.2 final.
Hey, it's only alpha version!
I admit I have been paying precisely zero attention to Python development since I started writing "Dive Into HTML 5." I don't see anything in these alpha release notes that would affect "Dive Into Python 3," but I am willing to update the text if Python 3.2 breaks/deprecates/invalidates anything I mention in the book. Also, I still owe Jesse a chapter on multiprocessing. :(
I just tried running my blog on PyPy (JIT and non-JIT versions), it works! (But it uses about 2x memory, which was something I was hoping to *improve* with PyPy, sadly) EDIT: Is someone running OS X, so they can test it out? It would be very apprecited :)
Upvoted because hey I read your book to learn Python :)
diesel is not specifically a web framework, although that's initially what it was marketed as. Thanks for the clarification on libevent. I always kind of thought of it as just a unified API for epoll/kqueue/etc.
Python 3.2 is [planned](http://www.python.org/dev/peps/pep-0392/) for January 2011.
I am running OSX, what sort of testing do you want to try?
Make a virtualenv and run: source myenv/bin/activate easy_install pypyenv If you are running 32bit, run the following: pypyenv install # At this point PyPy should work pypyenv --nojit install # Will ask you about deleting old files, # after installation PyPy should work pypyenv uninstall # ENV/pypy and ENV/bin/pypy will be deleted If you are running 64bit: pypyenv install # Should give an error "rerun with --nojit" pypyenv --nojit install # At this point PyPy should work pypyenv uninstall I would be super grateful if you can do this for me and report back any errors :) EDIT: `myenv/bin/activate` instead of `workon myenv` to keep it pure
There's now a fork of virtualenv that makes PyPy (the latest trunk) work with it, hopefully that'll get merged before the next PyPy release.
Please learn to read. This is only the first alpha release - it will be several months before the actual release.
Unfortunately I couldn't get it to work yesterday. Mine is just a simple solution until everything gets sorted out properly. (With a positive side effect of keeping a CPython interpretor with its libraries side-by-side with PyPy in case something nasty shows up. Since PyPy has its own slightly modified library the only thing they share is `site-packages`) EDIT: just noticed your parenthetical "the latest trunk", perhaps it didn't work because I was using 1.3...
[Robot Framework](http://code.google.com/p/robotframework/) has bindings that allow you to test Windows and Swing applications.
Looks like people read headlines of the posts only! o_O
Can you link me to a tutorial on how to setup and use a virtualenv, I've never needed to do it before so have no idea where to start. I'm running 64bit OSX on a quad core iMac if that makes any difference.
misleading title but intersting fact about GIL, upvoted.
[This](http://www.arthurkoziel.com/2008/10/22/working-virtualenv/) looks like a good tutorial. I suggest using virtualenv for just about everything, so you won't break working programs with unexpected library upgrades, among other reasons.
The biggest reason is that sometimes it's far easier to design a threaded app than to try and do everything in one thread.
So you can do more than one thing at a time (concurrency). There might be no performance boost in doing so, but sometimes you still need two things to happen at once (like background operations in a GUI app). Of course, then there's the processes vs. threads debate, but that's a different barrel of monkeys.
Threads will run at the same time, the only thing they won't due is use multi cores at the same time. I guess the word is concurrency. There is a great deal of benefit running multi threaded python apps when you need concurrency. I use threads with python and never had a care about the GIL. Chill out, and enjoy the thready goodness.
Thanks, how could I forget a basic thing like that? Haven't done any GUI stuff for quite some time now.
&gt; Does not work in practice I'm not yet convinced - can you explain why not? Which libraries are you having problems with, which monkey-patch logging classes? AFAICT you shouldn't need to monkey-patch logging and I haven't come across any libraries which have done so - so it would be very good if you could mention where you're having these specific issues.
Python has a [list of guides](http://wiki.python.org/moin/BeginnersGuide/Programmers) suitable for people familiar with programming who want to learn Python.
In addition to the listed guides, you might checkout any of the various [Python for JavaScript programmers](http://hg.toolness.com/python-for-js-programmers/raw-file/tip/PythonForJsProgrammers.html) references available.
I really enjoyed Dive Into Python. As for something interesting you could do with the language - try the [Python Challenge](http://www.pythonchallenge.com/). It's a lot of fun!
just [dive into python](http://diveintopython.org)!
I'm not sure, but I think there were a few different proposals for a new GIL implementation. Maybe it's not the same one.
just [learn python the hard way](http://learnpythonthehardway.org/index)!
I am currently learning via http://inventwithpython.com/ It is cool that you are writing an actual program within a few short chapters. Plus the fact that he uses games as way to teach really appeals to me (and takes me back to how I originally learned to program using basic all those years ago) 
First: Python threads are POSIX threads. Second: GIL only affects execution of code that needs to hold it to run, as in usual Python level code. Third: If you write extensions you can let go of the GIL and do your stuff, then reaquire. Fourth: When you use IO you usually let go of the GIL too, not sure about new-GIL in this regard, so you can run your logic thread and IO threads in parallel. Most important, fifth: This also works for UI stuff, when you don't really need to run in parallel, you only need to appear to be doing so. Think about those five things and enjoy or use different language. I for one am in love with concurrency model provided by Clojure. There is no silver bullet.
They both call syscalls and "let the OS do the work". One invokes an external process and subsequent IPE, and is slower, more resource-intensive, and less flexible.
These posts are menses of /r/Python
At first I read that as [Menes](http://en.wikipedia.org/wiki/Menes) and I thought "WTF" It'd be great if subreddits had faqs.
[UoR](http://www.reddit.com/r/UniversityofReddit/comments/crzau/class_intro_to_programming_through_python/)
Check out [Think Python - How to think like a computer scientist with Python](http://www.greenteapress.com/thinkpython/thinkpython.html), which is a great introduction to programming and Python. It sounds as if you are already familiar with programming, so I would encourage you to just read the [official Python tutorial](http://docs.python.org/tutorial/index.html) for 2.7 or [the one](http://docs.python.org/py3k/tutorial/) for 3.1. I would encourage you to learn Python 2.x first, as you will have access to more libraries, but you might want to read [this article](http://wiki.python.org/moin/Python2orPython3) and check if the libraries you need are available for Py3k already. If you want to get into web programming you might want to learn a little Python first and then check out one of the following frameworks: * [Pylons](http://pylonshq.com/) * [Django](http://www.djangoproject.com/) * [Turbogears](http://turbogears.org/) * [web2py](http://www.web2py.com/) * [web.py](http://webpy.org/) and [many many more](http://wiki.python.org/moin/WebFrameworks) .... Have fun and welcome to the Python world!
Personally, I think [Project Euler](http://projecteuler.net/) is a pretty good way of learning not only any particular language, but learning to program in general.
http://tinyurl.com/yls3ohg You're going to have to learn Google before you can learn Python.
Thanks. I love Python, wouldn't give it up for something that is relatively unimportant to me.
Better still, help move [PEP-384](http://www.python.org/dev/peps/pep-0384/) forward and hopefully end this hassle permanently for everybody except the original extension developer.
I solved an awful lot of them and used classes only once. I used some functions from functools and something else - but I hardly ever used this things or tricks in production code. Please, before throwing away any advice, think about it
At first I was like :) but then I was like :(.
Seriously, do people just grab every item off of planet.python and submit it here? C'mon, where's the original content/questions ;)
I went to this same site and performed the same task as you sir, well played
+1 for Sikuli !
I think we're getting about 20 per day. I'm not sure if they guy I wrote it for is going to make any money, but it's been fun.
It's not an either/or relationship...
It never felt flaky for me. Mind you, I use it with the Python engine set to "remote" instead of "internal".
Of course, almost any given problem can be solved in a quick-and-dirty way, or in one of several "pretty" ways, depending on your perspective. Most if not all of those problems are small, though finding uses for classes in them are not difficult (when I used python to solve them, I used classes often). I think it is important to remember that small problems do not always require large solutions, and that when someone is learning python, he is probably unlikely to be dealing with production-level problems in the very near future. That said, it is of course important to acknowledge that just solving small problems is not going to teach you the full spectrum of usage of any language.
I put the results in a [text file](http://woarl.com/env.txt) for you, sorry it took so long to getting around to it but work got in the way!
This is not true. * Nir Aides proposed a BFS-based GIL patch which was not accepted. This is not what jojomehndi is talking about. Antoine's work originally existed in a py3k branch called "newgil", which is where the name comes from. * David Beazely found an issue with the "new GIL", as seen in 3.2, where CPU-bound threads can hamper I/O-bound threads, called a "convoy effect" [(bug report here)](http://bugs.python.org/issue7946), but he didn't write any of the GIL (at least not that's in the core) and I imagine this is what jojomehndi is talking about. I think you may have been confusing a few of the names and implementations out there.
Thanks a lot! It looks like it allowed you to install the JIT version even though you're running 64bits.. I'll look into that.
I am really surprised by the response these couple of lines got.
I'd downvote this more than once if it was possible.
The nose [docs](http://somethingaboutorange.com/mrl/projects/nose/0.11.2/testing.html) do a good job of explaining its place in relation to unittest, imho. Long story short, you can write tests in unittest form, auto-discover and run those tests with nose, and I even like to use [nosy](http://github.com/wkral/Nosy) (or my hacked up version of it) to autorun those tests through Nose whenever something applicable changes.
I'm more than happy to attempt other stuff for you if needed.
Nose will not be in the stdlib -- unittest already being there is an obvious reason why. [unittest2](http://pypi.python.org/pypi/unittest2) may be of interest to you -- it's where the newest unittest features are being developed, including the new plugin architecture.
All that, and you use plain `assert` for just about everything instead of `assertYourVariableIsEvenAndPositiveAndCanIHasMoreCamelCasePlease`-style of function.
Created issue #2 for this
Python koans is cool
Are you sure it's not a router between the 2 machines that's killing the connection?
This might sound kinda silly, but why not just break down large files into multiple parts and recombine them once they reach B? I know it might sound like a lot of extra work, but it's probably something that you could make very consistent, as opposed to trying to obtain consistency with single larger files over a slow connection. 
It may be one of the following settings in the server's config file is out of whack: * ServerAliveCountMax * ServerAliveInterval * TCPKeepAlive You might want to check out the [SSH Config](http://linux.die.net/man/5/ssh_config) file help. 
Features from nose are slowly working their way back into unittest. For example, Py3k's unittest now has a recursive discovery system very similar to nose's.
To oversimplify it, nose wraps around unittest, providing a few extra features, such as SkipTest functionality for pre-2.7, auto-discovery of files containing unittests, class &amp; module-wide setUp/tearDown, etc. The greatest advantage of nose over unittest right now is the various plugins (though apparently unittest will be getting those eventually, which is awesome). I use the plugins for generating XUnit output, code coverage reports, and PyLint audits.
you need to learn to search first...heck I will help you : google "python tutorial"....be warned your eyes will pop at the search result
so would I....on your comment I'd rather teach a man how to fish.....
beat me to it.
Then go to /r/fishing.
If Python is his very first programming language, you are right. Otherwise it will be way more fun than learning after two or three dozens of problems to get used to the syntax, generators and itertools
I've said it before and I'll say it again: WSGI is crap. As a standard goes it's what you might expect a ninth-grader to hand in for his "Introduction to Computers" class. mod\_wsgi attempts to implement this standard, to some dismay. But that doesn't change its enormous utility. I see it as just a way of reliably spitting out web from python code, but in a way that scales very well. The GIL problem is gone with mpm\_worker. I find sometimes I'm creating web pages just to try out the goofy shit I'd in the past resort to using the terminal for, simply because it's such a versatile environment. Just use the guts of mod\_wsgi to do what you want to do and ignore the yucky WSGI part. Start by using python to create an abstraction layer atop WSGI that spits out data as you see fit, then when it's time to go ricer on everything you open up the module code and implement that layer directly. Do it right and it's almost as if the entire site were written in C. Probably the best hack since zeroconf or pyobjc.
This guy is quickly becoming a legend in my book with his tutorials.
As I understand the GIL is there due to a design decision (the gil enables ref count gc which is simple and fast and probably; also, there's no need to have finegrained locking on the objects in the vm - this makes the vm simpler and faster). Threads, more exactly, system thread are there to support concurrency. Your question is why would it make sense to have system threads when you have a GIL. Well, system threads can support way more features than green threads or userspace threads. For example: * they can support concurrency for libraries or system calls that can't be switched to greenthreads (typical example: dns resolution). * they are better or faster. I guess one could argue here but usually the OS does way better job doing concurrency that what you would be able to do in userspace (the greenthreads). * can support real parallelism (avoiding the GIL) for code written in C (as a python extension) I guess you could dig up other languages to understand better this design decision; for example: java has switched from greenthreads (well, very long time ago), ruby also switched to system threads (in 1.9 if I recall right). Of course there are costs like memory requirements (each system thread has a callstack) or thread programming pitfalls like deadlocks or race conditions that a lot of people like to use as a poor pro-gil argument (that unfortunately includes Guido).
.. yeah, great tutorials, but for one thing: source? EDIT: n/m I found the mercurial repo ..
True, but it's certainly feeling like it's 90% planet.python, 10% non ;)
Threads cannot provide a performance boost for CPU bound pure python code because such threads cannot utilize multiple processors. They are still useful for other things: IO bound code, worker threads with GUIs, and CPU bound code in which the heavy lifting is done in C (numpy).
Sadly, I don't have any original content to post. I do post anything related to Python 3, on Planet Python and off it, since I'm trying to get more and more people to move (Even if only for personal projects, for now).
If this was 1998, that Part-of-Speech tagger would be pretty cool.
I put in "Matt Damon is a person I would like to hit in the mouth." and the sentimenter thing told me that was positive. I thought it was funny.
Can be enough of a reason to speed up the switch to 3. It should be.
So what's cool now? (in the interest of fruitful commenting...)
Apparently, while "Matt is stupid" is negative, "Matt Damon is stupid" is actually positive. I'm really not impressed; if you're going to make a demo, don't make it obviously bad.
Anyone know what tool was used to make these slides? I hate it. It needs forward and back buttons. Yet another example of using Javascript to make the web worse instead of better.
Heh, thanks memeresearch, you're making me blush. I'm certainly no legend, but if the sounds of my blundering around can warn others of obstacles in the path, then I've been of some use.
Both the MaxEnt and NaiveBayes are linear classifiers. Further more Matt Damon is strongly correlated to positive reviews in the training set. Hence on such short examples the result will always be positive. Take longer examples (closer to the 1000 words limit) from amazon reviews for instance and you will get better results.
Me, too. I almost wanted to note that the presentation is good, despite the poor UI.
Looks like HTML Slidy, or maybe S5. Javascript is awesome for this, all you need is a browser to do a presentation. Move your mouse over the bottom left to see some options.
Bottom right. But how the hell was yetanothernerd supposed to know that? No icon what so ever was there. And why does the ∅ symbol go to a "all slides on one page" page?
This code snippet from http://docs.python.org/howto/unicode is what usually helps me out of a jam: &gt;&gt;&gt; u = unichr(40960) + u'abcd' + unichr(1972) &gt;&gt;&gt; u.encode('utf-8') '\xea\x80\x80abcd\xde\xb4' &gt;&gt;&gt; u.encode('ascii') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ? UnicodeEncodeError: 'ascii' codec can't encode character '\ua000' in position 0: ordinal not in range(128) &gt;&gt;&gt; u.encode('ascii', 'ignore') 'abcd' &gt;&gt;&gt; u.encode('ascii', 'replace') '?abcd?' &gt;&gt;&gt; u.encode('ascii', 'xmlcharrefreplace') '&amp;#40960;abcd&amp;#1972;' (Edit: Fixed formatting)
As noted in the HTML source, Docutils (http://docutils.sf.net) was used to make the slides in S5 format. These slides were obviously meant to be a live presentation for the author to control, not for people to stumble upon on the web. The "handout" (flat, plain HTML) format should have been put on the web instead (it's a mistake to put only the slides on the web, as people have noted). I usually publish both formats, like my [Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/) talk from 2007.
Very well, but then he shouldn't have used one sentence with Matt Damon in it as the example..
There are forward and back buttons if you hover your mouse in the bottom right corner.
Turn off Javascript. Enjoy article in plain static html in one page.
And if you happen to press the left and right arrow keys.
A lambda expression is just a mini-function with an implied return. `lambda: 42` creates a function that always returns 42. You can then assign it to some variable `hgttg = lambda: 42` and then call `hgttg()`. You can use variables: `plusone = lambda x: x + 1`, so `plusone(42)` returns `43`. You can do some neat tricks too: def plusser(amount): return lambda x: x + amount You can get a function from plusser that adds a certain amount to a number: two = plusser(2) print two(3) The above will yield `5`. One place that lambda functions are useful is in functions that take a function as an argument. For example, the built-in `reduce` function. The first argument is a pointer to a function that takes two arguments: the accumulated value and the next value from a list (or other iterable thing). Let's say you had a list `foo` of numbers and you wanted to find the sum of the squares. You could write: def sum_square(x, y): return x + y ** 2 reduce(sum_square, foo, 0) or, you could write reduce(lambda x, y: x + y ** 2, foo, 0) 
not really messaging (sharing data) between threads can become a huge pain especially as the design for the app changes over time
Upvoted, but there's a syntaz error: it is hgttg, not hggtg :)
Key advice, from the article: 1. Decode early, 2. Unicode everywhere, 3. Encode late. 
In my defense, I think I fried my brain on cleaning chemicals.
 def mylambda(): return "whatever" equals to: mylambda = lambda: "whatever" and def mylambda_with_args(arg1, arg2): return "whatever %s it's %s" % (arg1, arg2) equals to: mylambda_with_args = lambda arg1, arg2: "whatever %s it's %s" % (arg1, arg2) it's just mini-functions.
That should be reduce(lambda x, y: x + y ** 2, foo, 0)
Good catch.
the NoScript-enhanced version is readable.
a lambda is not just a mini function. it's a closure: it has access to the scope of the function defining it. This access is possible even after the defining function has returned. Watch the classes on Javascript by Douglas Crockford to get some examples. consider: def fun(a): return lambda: a c = fun(10) print c() this will print 10. 
Well, if you want to be all pedantic about a tiny little typo, it would be a NameError, not a syntax error.
A "regular" function is also a closure. A lambda is just an anonymous function that has the additional constraint that it can contain only a single (value returning) expression. You could rewrite your example as: def fun(a): def inner(): return a return inner
Try this for fun: &gt;&gt;&gt; (lambda x: lambda: x)('abc')() 
I kind of understood that they were shorter ways to write functions, but do they have any specific uses apart from shortening code? Is it just for those quick calculations that you can write in one line?
Specific uses? As far as I'm aware, they are just [syntactic sugar](http://en.wikipedia.org/wiki/Syntactic_sugar). They are useful for closures, but you can do that with regular functions (see unintentional_troll's [comment](http://www.reddit.com/r/Python/comments/cx4cz/ok_i_really_dont_get_lambda_notation_for_some/c0vxczq)).
&gt; but do they have any specific uses apart from shortening code? Avoiding having to name a function which is clear enough in and of itself, and puts the body at the call/use site instead of some other random place. &gt; Is it just for those quick calculations that you can write in one line? It's not just for calculations, but it is indeed (by design and due to its limitations) for stuff you can write in one line.
&gt; a lambda is not just a mini function. it's a closure All python functions close over their context.
Surely people that interested in those news would subscribe to the blog/mailing-list anyway, wouldn't they?
They don't let you do anything functions can't do, but they can be useful especially when you've a function that takes another function as an argument, and don't want to have to define it just to use it once. Eg. suppose you want to sort based on the second element of a tuple. You could do: l = [(1, 'zebra'), (2, 'aardvark'), (3, 'giraffe')] def my_sort_key(x): return x[1] # Return second element. l.sort(my_sort_key) # Gives: [(2, 'aardvark'), (3, 'giraffe'), (1, 'zebra')] But it's a bit long winded to define that one-use function, give it a name, and reference it. lambda lets you write it a bit more concisely as: l.sort(lambda x: x[1]) Another common use in the past was with map, filter and reduce. Eg. to get a list of square numbers, you could write: squares = map(lambda x: x*x, range(1,10)) Instead of having to write a square function for this single use. As an aside, where such constructs are common, there's actually frequently a convenience method that avoids the lambda. List comprehensions have replaced the map usage in many cases, and for the sort key example there's the `operator.itemgetter` module which gives a factory function to access elements.
Back in the day some Pythonistas wanted to promote the 'functional' aspects of Python by allowing for map and reduce, and thus allowed for a lambda statement. As someone else mentioned, a useful application for lambdas is in a reduce statement, or also a map statement such as this: map(lambda x: x+1, [1, 2, 3, 4, 5]) -&gt; [2, 3, 4, 5, 6] However, lambdas weren't the best. They're forced onto a single line because of Pythons strict whitespace rules, so there's not very much you can do with them other than a simple value transformation. As time rolled on, Python acquired List Comprehensions, which look like this [x+1 for x in [1, 2, 3, 4, 5]] -&gt; [2, 3, 4, 5, 6] and map/reduce went more or less the way of the dinosaur. At that point the Almighty Guido basically said that lambda should be deprecated, and any situation in which you want to use it should be replaced by the more verbose double line definition: def add_one(x): return x + 1 This is one of those situations where, for better or for worse, Guido made a language decision and generally I agree with it. I try never to use lambda in my code, and pretty much the only time I have to do a two line definition is for sort accessors, as seen in another persons example code.
Sorts like that are easier with the operator module and key-methods, read into them :-). &gt;&gt;&gt; from operator import itemgetter &gt;&gt;&gt; sorted([(1, 'zebra'), (2, 'aardvark'), (3, 'giraffe')], key=itemgetter(1)) [(2, 'aardvark'), (3, 'giraffe'), (1, 'zebra')] vs &gt;&gt;&gt; sorted([(1, 'zebra'), (2, 'aardvark'), (3, 'giraffe')], key=lambda x: x[1]) [(2, 'aardvark'), (3, 'giraffe'), (1, 'zebra')] 
from def myFunc(a, b=1, *c, **d): to myFunc = lambda a, b=1, *c, **d: from return (a, b, c, d) # in the function to (a, b, c, d) # in the lambda Replace **def** with **myFuncName =** and there is no parenthesis in surrounding the lambda parameters. Although explicit functions may work with 1,000s of lines it is common to calculate and explicitly return a value in a single line. Just leave off the return statement in the lambda and calculate the value (it implicitly returns). 
I predict at least 1 post a week asking what the difference is between Bottle and Flask. Perhaps another asking "Whats the best way to learn Bottle?"
I guess... but my name is miles, not shirley
&gt;read into them Already aware of them. Hence the last paragraph.
While I agree that lambdas have limited use cases in present Python, I find them incredibly useful when you need to pass a very simple function as an argument. e.g: `sorted([dict(a=0, b=1), dict(a= 2,b=18), dict(a=1, b=27)], key=lambda x: x.a)` It's a pitty Python will never have proper anonymous functions (though I could imagine syntactic sugar for that), but lambdas are good enough for most purposes.
Mostly true, except `(lambda foo: foo).func_name` will always be `'&lt;lambda&gt;'`, whereas functions created with `def` will be named the way you name them.
Use [Distribute](http://guide.python-distribute.org/introduction.html#current-state-of-packaging).
You need to properly encode before parsing. Quite simple really. Check this out for reference: http://farmdev.com/talks/unicode/
Why do I need to encode? The string is Unicode, why do I have to encode it to something inferior? And what's "properly"? The real encoding of the file? The encoding the tag says?
Link provides no nutritional content of its own.
this.
HTML is a clusterfuck because web browsers have historically been extremely tolerant of bad input. The XML standards explicitly prohibit being tolerant of bad input, because they don't want to repeat that mess. So if the document claims to have one encoding but actually has another, conforming XML parsers are required to error out. To force people who can't get their encodings right to fix them, so that future parsers don't have to be super-heroic.
If you provide a patch, I wouldn't be so pessimistic about getting it approved. You could be conservative and make it work with `force_encoding=True` or something for parsing, so it won't affect any existing users. Or not, and see how the discussion progresses. I don't think you'll particularly improve any speed. lxml doesn't use Python's string representation, so it has to reencode regardless.
The patch is just removing the two lines in parser.pxi, I've done it already... Your solution about force_encoding is good, though, it would also be backwards compatible. Thanks for that, I'll update my bug report. In the mean time, I'm just removing the &lt;?xml ?&gt; header.
But there's nothing to fix here, I have to store the document as Unicode in the database, so it's already fixed before it reaches lxml. What lxml is doing is forcing me to *break* it again just so I can conform to the standard.
what's a "Unicode document" ? this is something I have not seen before. edit: oh, you mean a "Python Unicode literal". Seems like UnicodeDammit detects encodings. Use that, get the encoding value itself (somehow), then send lxml the doc in that encoding ? or, why not just send the doc as is to lxml ? if clients are sending you docs that specify one encoding but the doc is actually in another, that's their problem. 
You mean ``x['a']`` but let me suggest ``operator.itemgetter``: from operator import itemgetter sorted([dict(a=0, b=1), dict(a=2, b=18), dict(a=1, b=27)], key=itemgetter('a')) There is also ``operator.attrgetter``.
It's a document I've already decoded into Unicode.
how is an "encoded" document "broken" ? you are going to find a lot more behaviors like this when you start using Python 3. Lots of functions now require bytes as input.
Okay, say you have an XML document that declares its encoding as English but has Greek chars in it. I have correctly decoded it, ignoring its encoding, and now I'm required to encode it again in what **the document** specifies, which will fail.
You can use BeautifulSoup as a [fallback](http://codespeak.net/lxml/elementsoup.html#using-soupparser-as-a-fallback). I use this in a web crawler and have no problems. 
That's what we used before, we did indeed have no problems except the slowness. For the fallback case, does it only use it to construct the tree? I.e. will I only get the slow case if parsing fails? Thanks for your suggestion! EDIT: It works, I love you.
That's true, and I was actually somewhat surprised. On the other hand, it's cool that Gael compiled a list of good resources, most of which I haven't actually seen before.
then the document is broken. its not different from if it had dangling open tags or something. Same point as yetanothernerd makes above - its an upstream problem. The point of "conformance" is, if whatever tools were used to create this document similarly did not tolerate sloppiness, things would be better for everyone.
I'll be sure to tell the user to contact the author of the website to get his encoding fixed because I refuse to index his document if everything isn't 100% correct :( Sometimes you need to parse things no matter how broken they may be.
Use [Linux](http://www.linux.com)
&gt; Sometimes you need to parse things no matter how broken they may be. Absolutely. In such cases, I use regexes. Regexing the correct encoding into the doc and then having a completely conformant experience subsequent is not very hard and well worth it, doesn't require asking the lxml people to start accepting broken documents. 
That's a bit fragile, though, as it might break any (wrongly) quoted xml/html in the document, or you might not catch all cases... Can you post the regex you use to change the encoding?
Unicode is not an encoding y'know? Unicode is a mapping from a *number* to a character while a charset is a mapping between *byte-sequences* and a character. your database has encoding.
I never said Unicode was an encoding?
 import re import sys t = sys.stdin.read() t = re.sub(r'^(\s*\&lt;\?xml.*\sencoding=")(.+?)"', lambda m:m.group(1) + 'latin-1' + '"', t) print t if it breaks, then you'd get an error, and a new case to add to your tests once fixed. Also I've never had to change encodings before. I had to parse an entirely broken doc a few months ago though that was only in quasi-XML (had a very fixed structure though) - that regexp is: Pattern.compile("field name=\"(.+?)\"&gt;(?:&lt;\\!\\[CDATA\\[)?(.*?)(?:\\]\\]&gt;)?&lt;/field&gt;", Pattern.DOTALL); so things can be worse.
Ah, thanks for that. That's what I used as well... Have you checked to see if lxml also complains about encodings declared in &lt;meta&gt; tags?
no, these aren't the particular problems I have with lxml. I've had many battles with libxml over the years and my latest is [this one](https://bugzilla.gnome.org/show_bug.cgi?id=571271) note the reasonable question that will never be seen until archelogists unearth a harddrive 1000 years from now
Ah :/ Looks like we need some better maintainers...
then I don't know what you mean by &gt; I have to store the document as Unicode in the database
So roll your own release. Problem solved.
Obviously I encode it to store, I meant Unicode versus a simple bitstring :(
&gt; do [lambdas] have any specific uses apart from shortening code? They allow you to capture a variable from the scope in which they were created. This is illustrated in this REPL session: &gt;&gt;&gt; plus_y = lambda x: x + y &gt;&gt;&gt; map(plus_y, [1,2,3]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 1, in &lt;lambda&gt; NameError: global name 'y' is not defined &gt;&gt;&gt; y = 5 &gt;&gt;&gt; map(plus_y, [1,2,3]) [6, 7, 8] &gt;&gt;&gt; y = 10 &gt;&gt;&gt; map(plus_y, [1,2,3]) [11, 12, 13] Strictly speaking, this is something that a named function can do too, making use of functools.partial: &gt;&gt;&gt; from functools import partial &gt;&gt;&gt; from operator import add &gt;&gt;&gt; map(partial(add, y), [1,2,3]) [11, 12, 13] &gt;&gt;&gt; y = 5 &gt;&gt;&gt; map(partial(add, y), [1,2,3]) [6, 7, 8] 
Really woulda liked dabeaz to do his magic testing on the new GIL vs the BFS based one.
syntaz?
Sorry to hear your evening wasn't the best, but I find python on windows to be absolutely fine - very enjoyable, in fact! 
He wants to READ CODES
&gt;&gt; but how does that help the OP? huh wut ? OP wants to read PYTHON CODE (to learn), that is it - what is not clear about it ?
I heard a few times that django codes are well written and commented 
&gt;I learn best by well-documented code, not via book-examples. So, OP wants to read code, but doesn't want to read any code? Well, OK.
I like your sense of humor.
[Da, Comrade!](http://s3.pixane.com/lenin_packaging.png)
That diagram makes no sense to me. What does the "standard library" box in "future" mean. Is there no more distutils2 in the future?
I'm not sure how you came to that conclusion. It means distutils2 in the future. Edit with info from under the diagram: The distutils modules is part of the standard library and will be until Python 3.3. The distutils module will be discontinued in Python 3.3. The distutils2 (note the number two) will be backwards compatible for Python 2.4 onward; and will be part of the standard library in Python 3.3.
Same. 6 years of almost daily usage, and barely any issues that weren't my fault.
I'm curious. How do you guys have Python setup? How do you install packages like numpy or pygame?
Why doesn't the lower box in the "future" just say "distutils2"?
Use [ActivePython for Windows](http://www.activestate.com/activepython/downloads), which includes Distribute (a compatible fork of setuptools) among others - virtualenv, pip, easy_install, SQLAlchemy, PyWin32 and an apt-get like package manager ([pypm](http://pypm.activestate.com/)).
The diagram is just plain confusing. Basically what it looks like it's trying to say is: Past: Use setuptools and distutils Present: Use: distribute and distutils, until distutils2 comes out (really that's in the future...but it's in the near future so let's call it the present) Future: Use: pip and distutils2 Questions: -I use pip in the present and not setuptools, why does it imply I can't use pip until the future (related question: why is pip reaching back in the past to use distutils). -What is "standard library"? Isn't distutils in standard library in the present? Is distutils2 not in the standard library?
If you use pip you are using setuptools.
I don't do anything special at all. I install Python to it's default spot, then I just install whatever dependencies I use (e.g., pywin32 and wmi). When I fiddle with NumPy and other stuff, I run the binary installers, or just do "python setup.py install" or whatever it takes.
Not sure why this is getting downvotes. The source is available if you need specific fixes that are not in a released package.
Try... easy_install lxml ...and cry tears of blood. It requires you to install the libxml and libxslt development libraries (from where!?) and a C++ compiler first. A huge, huge pain. On Linux it's just apt-get intall libxml and you're done.
Really? Wow! Will try it tomorrow!
It shouldn't be *that* hard to regex the encoding declaration... import re re.sub(u'(&lt;\?xml([^?])*encoding=")([\w-]+)("([^?])\?&gt;)', u'\\1utf-8\\4', s)
It's not very hard, I'm just worried about side effects for documents that are malformed...
The best of both worlds is to convert the source to unicode with UnicodeDammit (which is quite fast) and then parse it. It will succeed greatly, except for xml documents with an encoding declaration on top.
Using an entirely different operating system as an alternate suggestion to easy_install is hilarious.
Developers tend to flock to Linux for a reason.
numpy I remember having a few problems with, since I was running python 64bit, and there weren't 64bit numpy packages. Instead of taking the easy route and downgrading to 32bit python, I installed the Enthought Python Distribution (which I cannot recommend highly enough) and never looked back. It, somehow, had its own 64bit distribution of numpy included - or at least incorporated the 32bit version well. 
Never used lxml before (I do all my xml stuff with beautifulsoup), but I just opened up a python window and typed the following: Enthought Python Distribution -- http://www.enthought.com Version: 6.1-1 (32-bit) Python 2.6.4 |EPD 6.1-1 (32-bit)| (r264:75706, Nov 11 2009, 19:42:36) [MSC v.1500 32 bit (Intel)] on win32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import lxml &gt;&gt;&gt; Lovely! As I've said in another reply in this thread, try the Enthought Python Distribution, the "kitchen sink included" python distrib. It's just perfect. 
Even if you have distribute installed?
Well no, then distribute pretends to be setuptools and pip uses it.
1. svn co http://svn.python.org/projects/sandbox/branches/setuptools-0.6/ 2. (whatever python version) setup.py bdist_wininst 3. Look in the dist folder 4. ? 5. [i uploaded 2.6 and 2.7 for you installers here, based on the latest code in the repository](http://briancurtin.com/setuptools_for_reddit/)
Use easy_install -U setuptools==dev06 to install the 0.6 branch; setuptools==dev to install the 0.7 trunk. Edit: Never mind. As it turns out, [I am a complete idiot](http://dirtsimple.org/2010/08/i-am-complete-idiot.html).
Gosh, I didn't realise I hadn't documented the converter attribute of the Formatter class. I'll rectify this soon. However, you don't need to create a subclass: just instantiate a Formatter and set the converter on the instance to time.gmtime. Due to the way attribute lookup works, the instance attribute will be found if present, else the class attribute will be used.
This is a great step, I was following this too. But it's a shame that Python isn't a fully supported language. And those xml layouts turn me off too. 
There's no Windows installer for lxml?
Nice! Now the only thing holding me back from writing full apps is getting dull API support for python or ruby.
I assume if/when dalvik can support the bytecode generated by jython you'll see python scripts as a full service app. The issue is, though, would gui apps developed in python be responsive enough?
OS package manager. By using the OS package manager I can be sure the dependencies are easily installed by end users or sysadmins. yum install myapp ... done!
True. The `operator` module makes many of these lambdas redundant.
Very interesting. I could see a direct application in my work. 
I am having the same problem with _cephes on Windows XP 64 bit
I'm confused, is this still a different thing from distribute, have they been merged yet... whats going on ?
Thanks! I'll check it out :)
distribute is an unfriendly fork of setuptools, so logically, they are not merged.
I've never tried using python on android. As much as I've never been a huge java fan, google managed to make me very happy with it on that specific platform. But looking through the api list, the python support seems to be in a fairly good state. Are things really that bad?
Facepalm, indeed. Daily snapshots are not a substitute for releases.
I never solved it either, ended up running a virtual linux.
Distribute is intended as a stepping stone to distutils2 http://tarekziade.wordpress.com/2010/03/03/the-fate-of-distutils-pycon-summit-packaging-sprint-detailed-report/ Tarek gave a 'state of packaging' talk at pycon2010, see http://tarekziade.wordpress.com/2010/02/20/pycon-slides-answers-to-gm-questions/ for slides/video.
They are not, but they solve the problem that caused the original post to bring this whole situation up.
There WAS a Jython on Android project but it was discontinued due to ASE (now SL4A); So unless someone familiar with it picks it up, I doubt it will be happening =(
"Capturing of locals" has nothing in particular to do with `lambda`s or partials. *All* Python functions are closures.
You never *need* to use `lambda`, because a regular ol' named function can *always* be used instead (never mind all these people that seem to think `lambda`s are special somehow--they aren't). IMO, you *almost* never want to use `lambda`. In the tens of thousands of lines of Python code I'm currently maintaining, I don't think there's a single `lambda`. That said, some of the sorting examples in this thread are, IMO, acceptable uses of `lambda`. The important question is, is the code using `lambda` easy to read and understandable? If so, then it's OK. If not, then think about using a named function or some other construct that makes the code readable.
True. If you see how lxml is itself checking for the encoding declaration, you could target the specific case and not try to comprehensively alter the documents. That would hopefully bring it down to a manageable level of complexity. You could even pull out lxml's own routines and use them to identify documents to perform the update on.
Yep, quite right. This is actually the best solution so far, I'll try it, thank you.
I played around with this for a while. Nomographs are pretty cool, though I found their utility limited to simple functions. Exponents, for example, can get hairy. Scale can also become an issue. If you're interested in nomograms more generally, [this guy](http://www.myreckonings.com/wordpress/) is pretty much the best online source out there when it comes to this sort of thing. He pretty much wrote the tutorial for pynomo.
For future reference: XML_ENCODING_DECLARATION = re.compile(ur'^(\s*&lt;\?\s*xml[^&gt;]+)\s+encoding\s*=\s*"[^"]*"\s*', re.U)
so beautiful. will definitely waste hours on this!
kewl
That wasn't all that much fun.
Neat server based on eventlet is spawning. It was several orders of magnitude faster than our fairly well tweaked apache/mod_wsgi setup when I tested it last... and according to our sys-admin guy faster than any of the other similar servers (gunicorn, gevent, etc).
Do not care. distribute &lt;3
The code of this site is opened, you can get the source code from http://bitbucket.org/felinx/poweredsites
If one accepts an intermediate step one can also take the route: `Sphinx -&gt; LaTeX -&gt; PDF` I have checked it out once and the single thing I missed were nice tabular representations. I believe one can get there with a little more work or embed tables as images.
not s single comment so far
There are two now. Happy? :)
Yay!
First! Oh, damn. Well thanks Dave Abrhams or whatever your name is. file:// urls wrock for deploy :)
In fact, LaTeX is currently the suggested way to generate PDF from rst or sphinx. But the LaTeX writer can't do what the article shows (AFAIK)
I came here thinking we were starting a thread on DEC RT-11 commands.
Thanks for the cool software (and informative blog posts), I just spent about an hour reading a bunch of them. I can see myself using both rst2pdf and [marave](http://code.google.com/p/marave/) from now on. Neither of which I'd heard of earlier today. I might learn pyqt now, after seeing how sexy the marave interface is, and I think your tutorials could come in handy.
Creating the Marave interface with PyQt was a bit of a pain in the butt though because it's so weird :-D 
Just curious: what is your deployment strategy in which "file://" is so handy? (I'd like to know why this rocks so much...)
Don't bother clicking, it's four sentences: &gt; I just got a report from Tracy Dunkelberger of Pearson on the state of the Python CS1 market. The market size is estimated to be about 20,300 students per year, up 45% since last year. The market has had around 40% gains for each of the last three years. She also shared with me some market share data which she asked me not to share further — I think it’s sufficient to say that our Media Computation book isn’t the top book in the market, but is doing well.
As is explicitly shown by converting the original example to a named function: &gt;&gt;&gt; def plus_y(x): ... return x + y ... &gt;&gt;&gt; map(plus_y, [1,2,3]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in plus_y NameError: global name 'y' is not defined &gt;&gt;&gt; y = 5 &gt;&gt;&gt; map(plus_y, [1,2,3]) [6, 7, 8] &gt;&gt;&gt; y = 10 &gt;&gt;&gt; map(plus_y, [1,2,3]) [11, 12, 13] &gt;&gt;&gt; 
Unless you rename them: &gt;&gt;&gt; bar = (lambda foo: foo) &gt;&gt;&gt; bar &lt;function &lt;lambda&gt; at 0x180f050&gt; &gt;&gt;&gt; bar.func_name '&lt;lambda&gt;' &gt;&gt;&gt; bar.func_name = "bar" &gt;&gt;&gt; bar &lt;function bar at 0x180f050&gt; &gt;&gt;&gt; bar.func_name 'bar' &gt;&gt;&gt; 
Setuptools is deprecated and unmaintained. [Distribute](http://packages.python.org/distribute/) is the Python community's (compatible) replacement for it.
Setuptools is neither deprecated nor unmaintained.
I also had problems with lxml mysteriously failing to handle some pages. The solution I ended up with was to pass the page through tidylib first before I sent it to lxml... this way lxml gets a well-formed page. I don't know if this would solve the unicode issue, but you could give it a try: Here is the Python module to use (PyTidyLib): http://countergram.com/open-source/pytidylib
Huh, that's a good idea, thanks!
What is a dict[ionary]? It's basically a hash table, except its data structures resize on removes, as well as additions.
It sounds like you are making assumptions about the implementation details rather than just following the language specification. A dict is not a hash table. Whether it resembles one or is implemented using one should not be relevant. Perhaps, instead of del dict['1'] you could use dict['1']= None ?
&gt; So what is a dict? I thought it was a hash table, but hash table's don't do this. A Python dict is a mapping type, not a hash table. From [the docs](http://docs.python.org/library/stdtypes.html#dict): &gt; A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary. And also: &gt; `len(d)` &gt; Return the number of items in the dictionary `d`. The length is equal to the number of items stored, not the total touched keys (as with Bloom filters, etc). Do not be confused by the fact that it uses a hash table internally; it's a mapping type.
You should check the documentation about dict methods (chapter 5.8). The answer to your question is explicitly given, see dict.items() and dict.iteritems(). The behaviour of your code is "as designed" by python. The trick is, that dict.items() returns a copy, while dict.iteritems() returns an iterator, which does not allow to change the dict while looping. Just two more comments: You really shouldn't use dict or list or any other reserved name (build-in) as names for your objects. And I would use "is" only if I really mean "compare by object identity", otherwise "==", even when compare immutable objects. Use dict.items() and your code will work.
Hash table's data structures do resize depending on implementation.
I think you're getting this error because of the differences in items() and iteritems(). I just ran the same snippet of code under Python 2.6 and I came up with the same error as you. dict = {'1':'a', '2':'b','3':'c'} for x, y in dict.iteritems(): if x is '1': del dict['1'] else: print(x) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; RuntimeError: dictionary changed size during iteration But then I changed it to items(), and then it switched. for x, y in dict.items(): if x is 'l': del dict['l'] else: print(x) 3 2 Since iteritems() returns an iter() object, this might have to do with the direct reference between the iter() object and the dictionary itself. They're insisting that you don't change the dictionary during dictionary iteration, but using items(), that returns a list of items, not the dictionary itself. Long story short - use items(). And to explain what a dictionary is, it's basically a mapping object, as some people have already mentioned.
No, del dict['1'] works just fine. The only thing is, you don't need to put it in a loop. Just do this: dic = {'1':'a','2':'b','3':'c'} del dic['1'] Done. No need for loops. If you know what you want to delete, and you know the dictionary has it, you can just delete it without any loop. If the dictionary may or may not have the thing you want to delete, you can use either an if statement or a try-except block depending on which one you think is more appropriate. I think it's generally a bad idea to modify a data structure that you're iterating over. There tend to be different approaches that are easier to understand and debug, and less likely to cause an exception. Another way you could do it, if you really insist on the loop, is as follows: dict = {'1':'a','2':'b','3':'c'} delete_list = [] for x,y in dict.iteritems(): if x is '1': delete_list.append ('1') else: print x for i in delete_list: del dict [i]
It is not resizing in memory. "Size" in this case refers to the number of keys. In python, you are not allowed to add or delete elements from a dict while iterating over it.
Here is a nice and indepth talk (video and presentation) about how python dicts work: http://us.pycon.org/2010/conference/schedule/event/12/
I saw and loved that video. Highly recommended.
I hate to be a pedant, but the plural of "table" is "tables". No apostrophe needed. Apostrophe are used to indicate possession. Pluralization is achieved by just += "s".
&gt; If you know what you want to delete, and you know the dictionary has it, you can just delete it without any loop. Yes. I can't believe no one else has pointed this out. Perhaps the OP was trying to show a minimal example of what he was trying to do. A very simple change that would make this example make more sense is to do the comparison on the value instead of the key.
I believe the OPs point was to show that dict iterators are invalid and throw an exception saying that they "changed size" after you deleted something from them.
Here's a reminder... :) Cool site, by the way. I just started working with Django/Python this summer, seeing that is inspiring!
A dictionary could be a number of things. The Python dictionary is implemented as a hash-table. Other options include balanced binary trees.
&gt; No apostrophe allowed. FTFY
&gt; ^ hash table's data structures don't resize on remove, only addition. I'd love it if someone could fill me in. Resize here means not a change in the backing, but a change in the size of the dictionary itself. You remove a key, its size is reduced by one, and it invalidates the iterators. What's hard to understand? And your declaration makes a *lot* of assumptions about the implementation details of `dict`. Why couldn't the backing get resized itself by removing a key? Dict is not a hash map, it's an associative array.
The long story short is a very bad idea in certain cases. It creates a real tuple'o'tuples for each item in the dict. If you're handling a 10,000-item dict, you create 10,000 tuples in that there call. See timeit below. There's a reason .items() behavior was changed to roughly that of .iteritems() in Py3k. Also: python -m timeit -s "d=dict.fromkeys(xrange(10000), 1)" d.items() &gt;1000 loops, best of 3: 1.77 msec per loop python -m timeit -s "d=dict.fromkeys(xrange(10000), 1)" d.iteritems() &gt;1000000 loops, best of 3: 0.505 usec per loop If you need to do iteration-and-deletion, you can store the keys of items to be deleted in another list or set, and then delete from the dict in a second sweep. 
iteritems() doesn't return a dictionary. it returns an iterator.
You're missing the point. The point is not to treat the dict as a hash table, because it's not. The point is not to modify the dict during iteration. Iterate through a copy of the dictionary. Iterate through a copy of the keys. But don't iterate through the dictionary and modify its length.
Which is, ultimately, the better way, but I only wanted to fill in why he got an iteration error. Other people already gave the advice to store keys in, remove after.
Is there a stucture in standard python that allows what the OP is trying to do, without copying the list of items? Also, why the downmods? The guy is asking a legitimate question!
Let me rephrase then: They will always be named `'&lt;lambda&gt;'` by default.
just recently PyScripter was updated to v 2.0 ;.) http://code.google.com/p/pyscripter/downloads/list 
&gt;&gt; No apostrophe allowed. &gt; Fixed that for you, old chap! Fixed that for you, old chap! 
nice tip... thanks... "think python" from Downey got me into programming in the first place...
[Obvious troll](http://www.reddit.com/r/linux/comments/cwamc/is_it_a_legit_open_source_project/) is [obvious](http://media.b-list.org/shrapnel/obvious.jpg).
It is not saying the size of the underlying structure changed, but the number of items in the dictionary. In other words, len(dict) has changed. This isn't allowed because of conflicts it makes with the dictiterator object used to loop over a dictionary like that. Again, *not* saying the underlying structure changed. Yes, a dict is a hash table.
 dict = {'1':'a','2':'b','3':'c'} if dict.has_key('1'): del dict['1'] 
has_key is deprecated. Use: if '1' in dict: del dict['1'] Just my 2 cents.
Very useful. Thanks!
in CPython, a dict does **not** resize upon removals.
regarding inner classes, can't you just have the parent object pass the child a reference to itself?
You can inspect the stack to find out what called it. import inspect print inspect.stack()[1][3] I think that should print out what called it. If it's not then you can easily print out the rest (it's basically a list of lists) and find it.
&gt; The straightforward way of doing this would be to declare one class inside the other. Not really. Nested classes are not used very often in Python, they're usually not useful at all. &gt; The constructor of the inner class would then be a pseudo-method of the outer class instance. Why? &gt; But there doen't seem to be any way for this constructor to find out which outer class instance it was invoked on ! Good. Why would that horror happen? &gt; So how do you make this work in python ? Well if it needs an instance you give it to him, that would seem sensible no? Or you could just use generators. &gt; Is there a good reason why we can't have an iterator which behaves well when the underlying collection is modified ? Define "behaves well". If you prepend an item to a list while iterating on it, what should happen? Should the iterator immediately yield that new item? Should the iterator restart from 0? Should the iterator continue oblivious? Which might yield to the current item being produced twice as its index will have been bumped? Or should the iterator work on a copy of the collection? And in that case, why can't you just iterate on a copy in the first place? And if you append it, same question. Likewise, on a `dict` the insertion or deletion of a key, value pair might very well change the whole iteration order. What then? The good reasons that the built-in iterators refuse to continue when the underlying collection is altered is that it's pretty much the only correct solution. &gt; Isn't it about time python got generic waitable objects in which the implementation abstracted away all the os-dependent nastiness, and arbitrary sets of i/o, ipc, inter-thread and clock waits could be reliably waited upon ? Like what's in `threading` or `multiprocessing`? Could you give examples of the issues you have there, because you're being very fuzzy.
don't do this.
Yeah. A method on the "outer class" defines the "inner class" with whatever references needed and returns that.
Inner class: So is the goal to have an object that produces another object? You can use the __new__() function return different objects on invocation. Iterators: The behavior of modifying a collection being iterated on is undefined. Waitables: Python is single threaded. You can use continuations (basically calling yield) though for multiplexing.
Oh, and nested classes are not special in Python. In fact class creation itself is nothing special, you can pretty easily achieve the same effect by calling a metaclass manually.
Other people have already explained why this is dumb, but here's another problem: Never write `x is "1"`. `is` means identity. With strings, sometimes two equal strings will use the same spot in memory (making `is` true), but sometimes they won't (making `is` false). Using `is` for non-singletons invites peekaboo bugs.
Use backslashes or backticks if you want your \_\_ to come out correctly and not bold things.
Inner classes: define a method on the outer class that instantiates the inner class and passes self to the inner class's constructor. Oh, and there's no pressing reason to define the inner class inside the outer class. Iterators: feel free to write one. The builtins don't support concurrent iteration and modification for two reasons: (1) performance, (2) difficulty of defining semantics. Waitables: it's called [Twisted](http://twistedmatrix.com/).
Regarding inner classes: I posted a recipe for that in the Cookbook. http://code.activestate.com/recipes/577070-bound-inner-classes/ Iterators: There's no reason why--you could easily write one yourself to do exactly what you like.
&gt;The good reasons that the built-in iterators refuse to continue when the underlying collection is altered is that it's pretty much the only correct solution. This is also true in Java, so what other language has OP been working in where this isn't the case? That's what I want to know.
A lot of open-source projects already can do this for you; if you can't find a project specifically for it, you can probably find a project that includes it, like Django.
Not sure I understand. Our SQL database already exists but I don't know how to query it from Python. It looks like SQLAlchemy might be what I'm looking for and if so I don't know what question to ask our DB admin for connecting to the DB with it. Any ideas? 
Well it does seem Ruby (or `Array#each` anyway) doesn't explode when altering the collection. But as a result it generates completely wacky results (as it should): the implementation seems to be basically to have an internal index, and execute the block then increment the index until the index gets out of the collection. This means that if you prepend an item you get the same item twice (and if your insertion depended on the current item you got yourself an infinite loop) and if you delete an item before (or being) the current one, it'll fail to iterate over one of the array's item. In fact, if you use `Array#delete` and you have multiple instances of its parameter in the array, it'll delete them all and will potentially skip *a lot* of items.
Ah. You'll probably need to ask for the hostname of the server, the port, the username, the password, the database, and the table(s)/columns.
Can you explain why? This is the only way I know how to do it.
Hostname/IP, username, password and database name. Connect to it with something like Navicat so you can see what you're working with and test your queries before putting code to them. 
Firstly, what database server is it - MySQL, SQLServer, Postgres? Once you know that, you then download the appropriate python driver. I'd start by googling "python &lt;database-server&gt;" eg. "python mysql" - that should put you on the right track. 
I found sqlalchemy really difficult to work with. 
You'd get the best foundation if you start by using the appropriate DBAPI directly. That may get old within 5 minutes or three months, depending on your level of patience. Then you can move onto the various toolsets that are available, all of which build on top of DBAPI. Lots of our users that seem confused about things (SQLAlchemy) seem like they haven't yet mastered the concepts of database connections, schemas, transactions, bind parameters. Having an awareness of those concepts makes higher level toolkits a lot less mystifying. DBAPI: http://www.python.org/dev/peps/pep-0249/ Popular DBAPIs: [psycopg2](http://initd.org/psycopg/) [mysql-python](http://sourceforge.net/projects/mysql-python/) [pyodbc](http://code.google.com/p/pyodbc/) [cx_oracle](http://cx-oracle.sourceforge.net/html/index.html) [sqlite3](http://docs.python.org/library/sqlite3.html)
If you really want inner classes to work that way, you can make a metaclass to do it: from new import instancemethod class innerclass_meta(type): def __get__(self, ob, typ=None): return instancemethod(self, ob) class innerclass: __metaclass__ = innerclass_meta class dummy: class inner(innerclass): def __init__(self, outer): print "called from", outer class subclass(dummy): pass The first argument to the inner class's constructor will be the outer instance, if it's called from an instance: &gt;&gt;&gt; dummy().inner() called from &lt;__main__.dummy instance at ...&gt; &lt;__main__.inner object at ...&gt; &gt;&gt;&gt; subclass().inner() called from &lt;__main__.subclass instance at ...&gt; &lt;__main__.inner object at ...&gt; Voila. There are many ways you could fancy it up or use decorators instead of metaclasses, other junk like that, but that's the basic version. As for waitables, see libraries like Twisted, Eventlet, etc. 
I use pymssql and its underlying _mssql for interaction w/ MS SQL Server. Works pretty much like you'd expect; it's pretty trivial to go from a query that works the way you want in the MS product to using that output in your code.
Normally I use Fabric to upload egg files and install it with easy_install. Haven't been able to figure out how to do that with pip before 0.8. Are you familiar with it, do you know if that was previously possible?
Also, tip because I've recently run into situations where this really matters: Be aware of how many queries you're running with a script and whether or not that number is the best approach. Not that I would ever have done such a thing (OK, I did, but it lasted all of one execution before I realized that was soooo wrong), but you really don't want to be performing 50,000 selects serially, returning the exact result for each item in a list of things you're querying for. You'd be way better off to run a single select that gets the entire result set for each of the 50,000 whatevers you've got, and iterating locally over that output. Just sayin'.
Thanks for the links!
Good to know. Thanks!
&gt; But there doen't seem to be any way for this constructor to find out which outer class instance it was invoked on ! So how do you make this work in python ? Classmethods provide exactly that: @classmethod def alternate_constructor(cls, whatever): instance = cls.Alternate() print 'look, ma, i'm a', cls.__name__ And they work when you subclass, too. 
IIRC, stack/frame type calls may not exist in other implementations of Python. I could be wrong.
It's evil to violate separation by inspecting implementation details. In any language. If you have to do this, either your language is incredibly shitty, or (more likely) you did not structure your program correctly using the available tools to begin with.
To better help you, tell us: What is the OS platform you'll be running the Python code ? What DBMS ? I'm on Windows and I use: * [pyodbc](http://code.google.com/p/pyodbc/) to access SQL Server * [cx_Oracle](http://cx-oracle.sourceforge.net/) to access Oracle 
+ I know 1 is an integer. + I know 1.5 is a float. + I know that 4.4 can't be added to 1 without the outcome being a float. + I know "hi" is a string. + I know "hi" can't be added to 1. I basically know anything there is to know about a variable by just looking at it. Why shouldn't my programing language also "know" these things? Also, the reason for it is primarily simplicity; as is most of the python language. Overall when you have to think less about what holds your program together you can focus on the actual problem at hand rather than some minor implementation detail.
One up his snobbiness. Throw some C code at his face and call him a hippy slob. 
It treats you as a responsible adult. As you found, various tools can do static analysis. If you have 100% test coverage you'll also find that undeclared variables will be caught. Additionally just declaring variables is not sufficient since even if you did you could use the wrong one (most functions have several active at once) or it could have the wrong units/type. 
pymssql is shit
A Perl slob complaining about not having to define your variables is probably the height of hypocrisy.
No, Python's behavior is simply different from Perl's. Python treat variables as names which are bound to values. Multiple names can bind to the same value, but you cannot use an unbound (undefined) name. Doing so raises a NameError. Off the top of my head I can think of 4 keywords used for declaring names in Python. 2 are to specify a name's type: * class - for declaring a class, optionally with base classes * def - for declaring a callable, optionally with parameters (You can actually bind names to new classes by using the type() function instead of the class keyword. The class keyword is just syntactic sugar.) And the other 2 are for changing the parser's name resolution behavior: * global - for declaring a name should be found in the global scope * nonlocal (in py3k) - for declaring a name should not be looked for in the local scope There's so much bizarre behavior in Perl, it'd just be cruel to retaliate by taunting sigils, Perl 5's lack of formal grammar, or Perl 6's immense use of operators. But do what you have to do.
 &gt;&gt;&gt; class Magic(str): ... def __add__(self, other): ... return Magic('{0}{1}'.format(self, other)) &gt;&gt;&gt; m = Magic('wheeeeee!') &gt;&gt;&gt; m + {1,2,3} + [1,2,3] + 2.9 "wheeeeee!{1, 2, 3}[1, 2, 3]2.9" EDIT: this is a pointless example, but objects are not as simple as their appearances. In python2 there are many additional ambiguities.
&gt; I basically know anything there is to know about a variable by just looking at it. Except its scope. Explicit declaration lets you distinguish between: var a = 1; { var a = 2; // shadow } var a = 1; { a = 2; // reassign to outer } More importantly (to me), it makes code more composable. Given this (in a language with implicit declaration): { a = createSomeObject(); } If I add a new line *above* that block: a = null; // add line here { a = createSomeObject(); // changes the meaning here } 
Python certainly is not written for the responsible programmer, nor are any modern high level languages. No offense but they are meant so you can use them with the absolute least amount of knowledge possible. 
Compare with Python: def outer(): a = 1 def inner(): nonlocal a a = 2 # reassign In other words, Python shadows by default, and forces you to be explicit when you muck about with variables outside the immediate scope.
Perl doesn't have strong typing on scalars. Retaliate: my $int = 42; my $float = "$int.12"; print $float / 42;
I would say in general, it leads me to write poorer code. I will say that I do NOT like suffix or prefixing the damn type onto the variable.
It is a bit sad to have to get 100% test coverage to get a really basic reliability guarantee such as that. Not *all* dynamism is a good thing. Implicit scopes are probably bad too.
So, let me get this straight: someone is complaining that one programming language is not more like some other programming language?
Remember that Python doesn't make variables global by default. Also it never "autovivifies" like Perl (sans strict) does, instead you get an error about reading from a variable before assigning to it.
Just for the sake of precision, Perl also does not force you to declare your variables: $ perl -e 'print $undeclared' (that's Perl silently printing coercing the undefined value to an empty string, and printing that instead). However, the modern approach strongly encourages *you* to force *Perl* to force you to do this: $ perl -we 'print $undeclared' Name "main::undeclared" used only once: possible typo at -e line 1. Use of uninitialized value $undeclared in print at -e line 1.
Hilarious, but wrong.
&gt; slob ... &gt; retaliate ... &gt; slob ... &gt; retaliate Maturity level, guys. There are trade-offs to various language decisions. Not having to declare variables is sometimes convenient, but sometimes leads to errors not being caught until run-time. Having dynamically-typed variables is often convenient, but sometimes leads to errors not being caught and slower-running code. Having type inference can reduce clutter and lead to easier-to-read code, but it can also mean that the type of an expression is much harder for a human to determine while reading the code. Automatic coercion between strings and numbers can be very handy, but it can also lead to errors being overlooked. There are advantages to garbage collection and advantages for manual memory management. Etc., etc. Note that I'm not just talking about Perl and Python or about one being better than the other at everything. This is something that I personally dislike about Python. Python's not perfect and it's not better in every way. Yes, you can use tools such as pylint/pyflakes/pychecker, but there is are advantages to having features built into the actual language implementation (or used at the same time as the actual compilation, like perl's "use strict"). And "100% test coverage" is often not achieved nor is it necessarily the most economical way to find bugs. 
Because it's a frackin' scripting language.
I cant believe nobody mentioned sqlite till now. sqlite, is a standalone database engine - which means you dont have to 'install' any database like Oracle, MySQL etc. Also sqlite can make your application highly portable. Remember, firefox uses sqlite internally for its bookmarks, history stuff.
As a person who had a project to rewrite a Python program into Java, I kind of agree with him. During the project we discovered small bugs, some of them were caused because of not declaring variables. I personally prefer languages that have very strict rules, for me it helps to detect most of the bugs at early stages.
&gt; A Perl snob in my office rips on Python saying that not having to declare your variables is a bad thing. IMHO, he is right - you're much less likely to accidentally declare a variable in a loop because you mistyped the name of another variable declared outside of it. It's not because Python gets a lot of things right that it doesn't have warts. Of course, some people will comment that it's because it treats programmers as responsible adults, but in this case, protecting the programmer against himself doesn't come with a huge overhead in terms of usability, so I don't really see why having to declare your variable would _not_ be a better behaviour. That said, wart for wart, Perl certainly grants many more ways to shoot yourself in the foot than Python.
The reason language should know those things is to protect you from yourself and warn you about possible bugs. Of course you'll say you're uber coder and never write a buggy program, but most people can't.
re: downvotes: Downvotes mean "I want to see less stuff like this, it's not interesting to me". That's it. Personally, I downvoted you because of the whining edit about the downvotes. I want to see less whining like that. 
Seriously? Then please elaborate on the increasing number of Universities using python as a tool for Higher Education or Google's love of Python. I'm all ears... EDIT: To clarify, a large number of well informed, responsible groups are using python in very powerful ways. Discuss.
http://www.reddit.com/r/Python/comments/cyn4x/is_not_having_to_declare_your_variables_a_bad/c0w950k
Today I learned about Pyflakes. Thanks!
All that speaks to is a lack in responsible programmers taking positions as employees and students in those organizations. C and ASM for instance are both languages that demand the programmer be a responsible expert at his craft. If he is not, the system he is creating will be insecure, inefficient and likely not stable. Pythons abstractions take away the needed responsibility, and allow a more relaxed and more enjoyable experience for the programmer and testers alike. Downvoting me, simply shows the voters ignorance to different languages. 
also check out pychecker and pylint. Pyflakes/pychecker are fast, pylint is comprehensive. Some tools import the code, so don't work after a syntax error. Emacs people check "flymake" to run your checker in realtime, annotating your code as you go. Essential in my book.
Yes, C and ASM demand a responsible programmer. Languages, however, are like tools. I'm not going to put up a wall using a tack hammer. Why should I look at development any differently? Likewise, Python (and other higher languages) are tools. They are build on other tools. Both python and ruby are interpreted languages. Example interpreters are CPython and CRuby. Yes, written in C. Everytime you write a simple script to rename files, or move data, should you be having to do memory allocation? Every time? No. You shouldn't. We all have roles in development. Those who seek to use C and ASM are found (not always, but these tasks usually require such) writing things like Kernels, Compilers and Interpreters (or embedded systems..). They're the foundation of all the other work we do. The higher level languages are an evolution of that, and programmers evolve with them. Luckily, nothing is forcing you to use such a language. If you want to write everything in C and ASM, feel free. That's your preference, however. There's no reason so say that other languages are creating irresponsibility of the programmer. It is just a different tool. Additionally, abstractions are used to make things easier. What's wrong with that? Why do we all have to be miserable while coding? I'm guessing you take pride in your C skills. You enjoy doing the work you do. Then why can't other programmers feel the same way? 
Im not saying one is better than another. I much enjoy python. Im just saying that the level of responsibility required by C is much higher than python or ruby. 
&gt; In other words, Python shadows by default In Python 3 it does, but not in previous versions, I believe. At least they finally fixed it. For what it's worth, [Finch](http://finch.stuffwithstuff.com/) handles this with two different assignment operators: Normal assignment uses `&lt;-` which is equivalent to an explicit declaration (i.e. `var` in Javascript): foo &lt;- "outer" do: { foo &lt;- "inner" } write: foo ' prints "outer" If you specifically want to *not* shadow, and assign to a variable in an outer scope, you use the "long assignment" operator `&lt;--`: foo &lt;- "outer" do: { foo &lt;-- "inner" } write: foo ' prints "inner" I chose that syntax for a few reasons: 1. I think local declaration (i.e. shadowing) is the common case, so I wanted it to have the tersest syntax. (In other words, Javascript is backwards because you do `var` more often than not.) 2. I wanted a minimum of ceremony to create a variable, so no `var` or `def`. Finch doesn't really have keywords, so those would be odd anyway. 3. If you *do* want to assign to a variable in an outer scope, I want you to be clear that that's what you're doing, since it means that chunk of code now has tendrils that reach outside of its block. 4. I think a longer arrow is a good visual mnemonic for what it's doing: it's assigning to a variable that's farther away than a normal local one. Maybe I think about these things too much.
PEOPLE LIKE THINGS THEY ARE COMFORTABLE WITH MORE THAN THINGS THEY DON'T KNOW MUCH ABOUT. MORE AT 11.
this was a problem until I realized I could use `.get()` on `locals()`
so easy to call people troll eh ?
Just because you can doesn't mean you should. It's much better to work around language-undefined area.
what is "backing" ?
&gt; It is not saying the size of the underlying structure changed, but the number of items in the dictionary. huh ? "the underlying structure" is NOT the dict ? 
i rely on my unit tests to tell me if my code is working. a language guessing that i messed up is worthless when my test knows exactly what is wrong.
&gt; Can you explain why? It's ugly, implementation dependent and not (as far as I know) guaranteed not to break between updates. And as your post hints, it's fiddly and brittle. &gt; This is the only way I know how to do it. Probably a good hint that you shouldn't do that.
Repeating your assertions doesn't them right.
Im sure, you obviously have a weak understanding of programming languages.