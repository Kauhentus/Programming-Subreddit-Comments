[I understand](https://www.reddit.com/r/Python/comments/7aq95l/stop_supporting_old_releases/dpc47ln/). But it would be trivial to create pypi3.python.org and start pointing new installs to that.
Still using asserts, so if you do -O in your production env, it won't trigger. :-( 
_that_'s a cool trick that I didn't know!
sounds interesting, I currently quit my job to learn python and deeplearning algos. I have the basics down and am currently working through a few tensorflow tutorials. Also have some day trading exp. I think our goals go in the same direction. Do you already have down created some kind of group? Maybe we can distribute some of the tasks. I would e.g. be interested at what kind of api you are planning to hoock yourself to and over what broker you are planning to go?
Not everyone works in a company that can use python 3. Whether it's legacy apps or general enterprise sluggishness (biggest one would be 'no monetary benefit to do it'), there's plenty of reasons NOT to upgrade to 3. It makes me wonder if most of the people advocating for python3 *only* work at startups or companies that do not have a long history of using python. I like python 3. I use it for my side projects. But the petulance shown by a lot of the startup python 3 community regarding python 2 support is mind boggling. New features I can understand being limited to a version, but to write off an entire project? Absurdity. You can say a project doesn't exist if it supports 2, but if a project *only* supports 3 then that project *literally* doesn't exist for python 2-based users. 
&gt; discord has someone created a discord server already??
The idea is simple: don’t do business work for free. If they need it but can’t/won’t pay or contribute, their problem isn’t worth your time. 
Interesting: &gt; The text was written in the DocOnce1 [12] markup language, which allowed us to work with a single text source for both the Python and the Matlab version of this book, and to produce various electronic versions of the book. I have heard of, tried (and hated) lots of different markup systems, but had never run across [DocOnce](https://github.com/hplgit/doconce). Must investigate.
&gt; no monetary benefit to do it So what are you going to do in 2020? https://thenewstack.io/instagram-makes-smooth-move-python-3/ &gt; Not only has Instagram scaled to become the biggest Python user in the world, but the company recently moved over to Python 3 with zero user experience interruption
Good idea, if I split it into three parts, it's the middle but I need, either letters or number, and the last two are NB, so I'm guessing 1st might be a letter and last a number but I'm honestly not sure. Just thought if I can do some sort of script to display all possibilities of number/letter combinations then I can simply copy and paste it 
Oh dear. Looking at it quickly, the very first example ends with print y which means, this is Python 2.x syntax. This is not even mentioned until Appendix A, where they say the differences are "very small" and recommend using 2to3 (without listing it among the "desired add-on packages" nor showing where to download it or how to run it). Copyright 2016. Really? 
Great question, and I will try to statisfy it by stating the objective, the obstacles and how navigating them leads to the solution. The main objective is to simplify the [split-apply-combine]() data manipulation paradigm. Even for small explorative data analysis tasks, it is not uncommon to have to do it in some way 10+ times. The manipulation verbs where designed in such a way that *split* and *combine* parts are automated. That lives the user with specifying what to *apply*, i.e the operation. The operation can involve function call or it could be reduced to a simple arithmetic statement. This is the problem. Once you invock a function or declare a statement, python executes it immediately. However, we want that operation to be delayed and independently executed on chunks of the dataframe/table that have been split up. You have 3 options, (least flexible to most flexible) 1. You can use lambda functions, but they are limited. 2. You could construct a special variable that delays the operations, but it too has draw backs. 3. Use strings and evaluate them at the right time. Now, in the python world evaluating code in strings is looked upon with suspicion, usually independent of context. On abusing the &gt;&gt; operator, it is about [readability](https://plydata.readthedocs.io/en/stable/usage.html#Usage). On top of that it is easy inspect partial results, and to insert/delete operations. 
THANK YOU! ALL MY COMP SCI FRIENDS REFUSE TO UNDERSTAND THAT ENGINEERS LEARN FROM BOOKS.
Fedora is the closest of the major distros (aside from Arch). Everything in the operating system runs on python3. But it's still called python3.
Maybe you can use your new account's credentials to retrieve your old account subscriptions and playlists using the API?
&gt; there's plenty of reasons NOT to upgrade to 3. Python2 is going to die. That alone is not only a reason to upgrade to 3, but a fact that makes it a *requirement* to upgrade to 3. There's certainly no reason to do any *new* development in python 2. &gt; but if a project only supports 3 then that project literally doesn't exist for &gt;python 2-based users. And only limiting your software to Linux, OS X, WIndows, BSD, and Solaris means your software doesn't exist for OS/2, BeOS or Atari ST users. Yet, somehow, life goes on.
&gt;"Not only has Instagram scaled to become the biggest Python user in the &gt;world, but the company recently moved over to Python 3 with zero user &gt;experience interruption" Yesterday I pointed out a user statement here that needed to be on a t-shirt. I believe this statement needs to be on a banner pulled by an airplane and flown over the next PyCon. 
but the user is not bound by bussiness model or time investment to rewrite all its code, because he is only a user who should be able to switch without problem. That there are companies who need time to adjust, I understand. But even they have to try to convert their old stuff or at least start doing their new stuff with the newer versions. Or they will one day run against a wall. I experienced this first hand with the company I was working for... they kept making modules of their software in an outdated not any more supported framework. In the end they ran into hughe performance issues which could not be solved and they lost several hughe(like really really fucking hughe) projects. Some other projects of smaller customers weren´t lost but have had to be extended for over a year to work around stuff. All of that could have been solved if they had made the switch to html5 javascript earlier. I know it is an inconvinience at first, but as a programmer you also have an responsibility to your company and your customers!! What will you do when version 4 comes out? still stay with v2?
Books are very important.
No one is perfect. Just grab the concept you need.
Yes it is a hack. Two issues worth thinking about. 1. The code in strings is usually small snippets. If it is getting longer than is visually appealing, then it can be placed in a function. 2. Code is constructed not written. Should you require it, you can use auto-completion and wrap the result into a string. 
Functions.partial won't be clean since this is an object method. 
You may want to double check that. Or undo it if it is the case. IPython is awesome, but you don't want to default execute python programs in it outside of being the interactive environment
I'll check it out, thx. 
One simple reason I still don't see it dying: Cobol is still in use. When was the last upgrade to that? &gt; And only limiting your software to Linux, OS X, WIndows, BSD, and Solaris means your software doesn't exist for OS/2, BeOS or Atari ST users. Yet, somehow, life goes on. This analogy doesn't make sense if you're not within the same vertical. A more apt example is how companies are *just recently* dropping support for Windows XP. Notice how long that took?
It can be a nightmare installing certain data science related packages on windows. Much easier to just install anaconda (which also comes with notebooks)
For what python compiler (freezer)?
Oh, I'm sure there is a ton of good teaching in this book and a diligent reader can get lots of good from it. But they say in Appendix A.1, &gt; The authors have written Python v2.7 code in this book in a way that makes porting to version 3.4 or later trivial... Well, they could have eliminated that difference entirely. Just say "Every example contains a line `from future import division, print_function` but if you are using Python 3.x you can leave it out." (BTW I will just bet that there is some dependency on 2.x style division, somewhere in *a book on numerical methods*.)
You should probably supply an example of where those objectives are met while they are not met with the normal way of doing things. Because the example given at the outset is not at all compelling imo. 
&gt; What are you going to do in 2020? I write exclusively Python 3, and I'd never think recommending anyone to use Python 2 these days. That said, the answer is that in 2020 nothing will change. There are stories going around on banks that still use a Fortran compiler from the 1980s and so on. The same thing will happen to whoever uses Python 2.7 - and also 2.6 and 2.5, and 3.4, and 3.6, and basically any other version of Python. If a large company starts a Python project starts tomorrow on 3.6, then in 10 years it will be on 3.6. When you mention that 2.7 will no longer update after 2020 you're assuming that the project managers are willing to upgrade the Python version in the first place. For a very substantial part of the software world, this assumption is incorrect.
enjoy the ride!
Thanks all for the information - I have a better understanding of the benefits of Anaconda. I would still suggest making the default installation work would be best. Clearly the OP is having an issue with the standard library, and this is either a broken installation, or misuse of the simple imports by the user; and I would suggest that user error is pretty likely and therefore including another 1/2 gig of 3rd party modules wont actually solve the issue :-) Once the OP wants to go beyond the standard library then maybe Anaconda would be right for him - I have been developing for 7 years and never needed it.
What have you actually tried? What error are you getting in your code ?
Yeah, since 3.5 considers yield inside an async block a syntax error, you avoid someone doing something nefarious like creating a site.py that monkeypatches sys to report itself as 3.6. However, since you can't really monkeypatch the interpreter to support something not in `__future__` you guard against unsupported versions. Conceivably, you could do the same thing to reliably determine if someone is running Python 3 against a Python 2 package with try: raise ValueError except ValueError, e: # invalid in 3 pass
Numerical Recipes in (*insert language here*) is one of the best texts I've ever used. I've always wanted it in python, and I MUST thank you for the lovely reading material.
Nice library.
I don't fully agree with this. The author makes it sound as if big corporations are the only ones who have a reason to care about backwards compatibility, which is just wrong. There are plenty of small open source projects that rely on a foundation of backwards compatibility. Every time backwards compatibility is broken these small projects' maintainers have to check and make sure their code still works with the new release. Talk about burning out maintainers. By carelessly updating the foundation you're only deferring the responsibility to those who build on top of it. I'm not saying that Python 2 should still be supported. Fuck Python 2. But if Python 3.7 breaks backwards compatibility with 3.6 or 3.5 there will be a whole lot of people doing an insane amount of redundant work to figure out if their various projects of any size still run in all these versions. And while OS vendors should definitely get their shit together and move to Python 3 as a default there is no reason to expect them to always be on the latest minor release.
You are welcome
Not sure what you mean by 'clean', but partial is ideal for this. with open('blob', 'rb') as f_in: for data_chunk in iter(itertools.partial(f_in.read, 2048), b''): # process data 
It's not surprising that Debian (and therefore Ubuntu) is more conservative than Arch. There's a different philosophy. But the plan is to have python3 as the default version in the upcoming Debian Buster and for Ubuntu Bionic Beaver. So it's happing soon.
I hear this a lot on this sub, but in this past 8 months I've had no trouble installing any of the usual data packages on 3 different Windows machine and a Linux.
I'm not at my house at the moment. I'll try to remember to tell you later
Of course there may be problems, but the situation isn't as bad as a lot of people say it is - but that's probably because they haven't tried it :-)
There are industries where it's not worth the time and money to upgrade. I work in a the game industry which uses a lot of python to automate tasks, hold different pipelines together, organize content, and make small tools with. We don't ship that code, that code never leaves the studio, and so their is no point in upgrading.
&gt; I didn't do that myself, and I suspect it happened with Anaconda.
In the manufacturing industry we are lucky if we can find software which supports Python at all (most use VB script or some BASIC variant). We are using some commercial software which has a scripting language written in Jython 2.5 (Python 2.5), so I really appreciate being able to download old Python 2.5 compatible modules even if they aren't supported anymore. I agree, Python 2 sucks compared to 3, but the reality is us engineers that have live in that world really appreciate it when we can at least import old modules. And it helps our industry move out of the dark ages when people learn Python, even if it is an old version.
Are you using open source python components in the JSF and other realtime embedded systems? Although whatever JSF is doing, we probably shouldn't be doing, given the software problems they're having with it.
Ok, but what have they gained as far as tangible monetary benefits? And I can guarantee that companies will deal with EOL only when it becomes a problem monetarily. The continued existence of old languages like COBOL show that doesn't always coincide with EOL.
I don't get to look at instagram's accounts. COBOL is still supported.
&gt; one of the reports is very clear where its bias lies (it does not even emphasize results where python does better whereas it does for node). The bias is in your thinking: - start the comparison with node, and the emphasis will be on results where node does better - start the comparison with python, and [the emphasis will be on results where python does better](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&amp;lang2=node) 
There's no doubt that it's getting supported past 2020, so you might as well polish your 2.7 knowledge. It's here to stay.
My workflow is : 1. Decide on a decomposition of my code (functions, classes etc). 2. Write the outline code - function/class names only, using 'pass' where necessary 3. Write test cases for the code - obvious inputs and outputs to start with - I don't delve into detail at this point; clearly those tests will fail 4. pick the first function - and write the initial code needed to make the test cases work. Where I need other functions - I write those test cases first - (i.e. back to step 3). 5. If a test case fails for which I think I have written the code I then fire up the debugger if I need to. 6. By writing test cases for each function, I avoid having to run all of my code each time I make a change - I just run the test cases around each function that I have changed. This is effectively test driven design/development. The main advantage I have is that you can freeze the functionality of particular functions/layers. by testing them completely. By having automated testing you can also use fantastic features such as unittest.mock to mock out classes, functions etc (either ones you haven't written yet or ones that you know are fully working). Using mock allows you to ensure that classes and functions are being called correctly from your other code, without having to use the debugger or print statements to test those arguments. You can also use mock to test unusual conditions - say you have a function which returns an error 1 time in 1000, you can make your mocked function return an error every time in one particular test case - so you can test that your code handles that error correctly. Mocking is also incredibly powerful for testing external resources - Say you have code which gets data from a web site; you can mock out the web library you use and automatically run your test cases with a whole range of 'manufactured' web data, without needed any of this data on the website (or even needing the website to be up). This way you know that when you connect your code to the real web site, you have a good level of confidence that your code will work. Test driven design/development isn't for everyone, but I find it very effective.
At a minimum, you should post the actual exact error message you get.
Check your bashrc. Anaconda add the anaconda/bin/ to your $PATH, nothing more.
You can raise an AssertionError directly, as well. if sys.version_info &lt; (3, 6): raise AssertionError('Requires python 3.6 or later')
By who and at what price? If you're with a business with a long term plan to remain on 2.7, I assume you've already got an answer for this?
It's a coupon for limited time
Do you think GvR is going to screw over a majority of the users of Python over ideology?
It's not ideology. It's resources required to produce 2 versions. But anyway I see you don't have a plan. You should make one. Either say on 2.7 and budget for support, or look at porting.
1: /r/learnpython 3: you haven't told us what you've already done 2: you haven't told us what problems you're having 
So far the question section and the choices I’ve done , I’m having difficulties with the log in where it makes it’s own usernames 
I believe when you try to launch another thread it will tell you another thread is already listening on port 80. 
It is probably set by anaconda in the user's .bashrc, meaning that system stuff doesn't see it - it's only relevant when the user themself has opened a bash shell. I have python3 aliased to ~/anaconda3/bin/python in my .bashrc, but system stuff still sees /usr/bin/python3. Aliases are better than just adding ~/anaconda3/bin/ to the PATH, because if you have the PATH modified for your bash sessions, and you run some system tool from there, it will see the wrong Python, whereas aliases are about translating what you actually type into the shell, and subprocesses won't see them unless they're intentionally emulating an interactive terminal session such as with pexpect.
Some hints &gt;&gt;&gt; import string &gt;&gt;&gt; string.ascii_lowercase 'abcdefghijklmnopqrstuvwxyz' &gt;&gt;&gt; string.digits '0123456789' and then &gt;&gt;&gt; for x in "123": ... print(x) ... 1 2 3 
I recommend checking out the other books written by Langtangen. A lot of his teaching material is also available online for free. He passed away 1 year ago.
Environment, you don't have control of the environment your code runs in. https://docs.python.org/3/using/cmdline.html#envvar-PYTHONOPTIMIZE
That said, if someone wants to backport your library to an older (i.e 3.4 is still officially supported) version, it's just noise. Better IMHO to leave it in documentation. If a user does take the effort to come and complain, it might even be more likely if they have a 100% failure rate vs. a few calls not working.
That's a better guard, yeah. Though you can just raise Exception or whatnot, since it's no longer a proper assertion. ( SystemError! ;)
Yes, he gave you 10 years.
GvR has already spoken, 2020 it is. Deal with it.
Yeah, Usually future proofing is okay like that, since the python stdlib is pretty good about being forwards compatible, so you don't end up with a problem. For some cases though ( Mostly web application preludes) We want it to fail _early_ rather than when it's been succesfully deployed and hitting one of those missing cases. That has led to a few places having `__init__` guards against things, just to make _sure_ that things break if you try to parse it with an older version of python. Some days the lazy dynamic behaviour of ducktyping gets to me and I end up yearning for Rust and Pascal, languages that actually tell you early on that you're a f**cking moron and should shut up and go home. Then I try to build something big in them and I'm back to loving python again. 
Yes, Cobol is still in use and so will be Python 2 as long as there are companies that have large and stable Python 2 codebases that wouldn't see much benefit from upgrading. Python user base is somewhat more dynamic that that of Cobol (I think) so I believe we'll see sharper decline in Python 2 usage as more 'Py 3 only' modules appear.
What? The last episode of Lost wasn’t that lon-oh...
Biggest python user you happen to know about. How many companies have millions of lines of python running internal tools?
I suspect we live in the same industry, one dominated by a certain giant "red database" company. Ironically, I used to work for that red database company. In the first years of PyCon UK, I used to guerrilla-attach through our office a few homemade manifests publicizing the conference, which were ruthlessly taken down shortly after. When one of their acquired products was forced to shift from VBScript to Jython (because Microsoft-anything is considered Evil there), there were a lot of humbled faces showing up at my desk. (Unfortunately, in pure enterprise style, the shift happened and that was it, the product is forever frozen at Jython 2.5. It could be worse, it could be frozen at 2.2 like Weblogic and Websphere...)
What difficulties are you having ? It seems pretty simple to me - input their name, input their age, combine the two into a user name.
IDLE is a program that handles display of text the way the people who wrote IDLE wanted it to be handled. Just as with Word, you can go in and change the defaults. In this case, you'd go to Options &gt; Configure IDLE &gt; Fonts/Tabs &gt; Size and pick the size you want click Apply. But then ALL text will be displayed that way. And that's the best that IDLE can do, because it is just intended as a simple way for newcomers to Python to get started with programming. But if you make your on program with its own GUI, you can build in whatever rules you want. You can have HTML be the way one formats text, so, yes, you could make the font of any word be whatever size/color/font/etc you want. In order to do this, you would pick a GUI widget toolkit (like PyQT, wxPython, Tkinter, PyGTK, Kivy, or whatever), learn it, and write that program.
The fact that Python 2 has even been a *thing* in this decade is bad enough. The fact that some projects still require it is a disgrace. (For example, as far as I know, NodeJS still depends on Python 2 to compile native binaries via gyp.) The time when projects should have been started both versions was back in 2008, and the time when Python 2 should have been deprecated was 2012-2013 (compare PHP, which deprecated 4.4 about four years after the 5.0 release, and will deprecate 5.6 roughly three years after 7.0). Nobody upgrades as long as the cost of using the old version is less than the cost of upgrading. But developer time is a finite resource, especially when it's donated for free on open-source projects. There's a tragedy-of-the-commons thing here where everybody individually refuses to update, and thus collectively forces projects to keep spending effort on legacy support that could be used to improve current versions instead.
&gt;One simple reason I still don't see it dying: Cobol is still in use. When &gt;was the last upgrade to that? Support has not been pulled for COBOL. In fact, it got an object-oriented extension in 2002! The latest change to the COBOL standard was 2014. Support **is** being pulled for Python 2 and there is never going to be another version of it. &gt;A more apt example is how companies are just recently dropping support &gt;for Windows XP. Notice how long that took? That's because MS was *still supporting Windows XP*. When they pulled the plug, developers did too. No one should be writing new software in Python 2 - it's for maintainers of legacy code. Hence it makes no sense to introduce new libraries - or new versions of library - with support for Python 2. 
&gt; in preparation for an eventual change in the default version of Python, Python 2 only scripts should I like the implied optimism in hoping that scripts which haven't been ported to Python3 in the last nine years might actually get updated to say "#!/bin/env python2".
Thank you, wasn't aware of this.
Using Sierra right now; /usr/bin/python is 2.7.10 (Python 3 is installed via homebrew, and I rather suspect that if I alias /usr/local/bin/python to it things will start breaking.
&gt; But if Python 3.7 breaks backwards compatibility with 3.6 or 3.5 As I understand semantic versioning and feature releases, this is by definition not going to happen. Scripts may work on Python 3.7 and not Python 3.6, but not vice versa (as long as they adhere to the API and don't rely on undocumented implementation-specific behavior).
&gt; this is by definition not going to happen Yes, and that's a good thing! My point is if I understand the article OP linked to correctly than the author thinks that this guarantee should not be given.
Does it really matter for the purposes of the example, if we debate exactly how the article measures biggest? I assume you don't believe instagram doesn't count as a fucking massive python shop?
&gt; That's because MS was still supporting Windows XP. When they pulled the plug, developers did too. No one should be writing new software in Python 2 - it's for maintainers of legacy code. Hence it makes no sense to introduce new libraries - or new versions of library - with support for Python 2. That's still 3 years afterwards. What about Fortran? Hell, at my job we still get people asking for support for 32b SPARC, which is *ancient*. 
A twitter application to be used internally by our social media team (flask, tweepy, socket.io, react, mobx, material-ui)
I tried to remove all my facebook posts once and they suspended my account and asked for my ID. Removing accounts deleting their history seems to be a quite common process for big internet companies.
For the fixed case lambas just seem simpler and there is no difference in speed as far as I can tell. &gt;&gt;&gt; import functools &gt;&gt;&gt; import timeit &gt;&gt;&gt; &gt;&gt;&gt; class Foo(object): ... def __init__(self, name): ... self.name = name ... def add(self, x, y): ... return '%s: %d + %d = %d' % (self.name, x, y, x+y) ... &gt;&gt;&gt; obj = Foo('bar') &gt;&gt;&gt; f = functools.partial(obj.add, 3) &gt;&gt;&gt; l = lambda x: obj.add(3,x) &gt;&gt;&gt; print f(4) bar: 3 + 4 = 7 &gt;&gt;&gt; print l(4) bar: 3 + 4 = 7 &gt;&gt;&gt; &gt;&gt;&gt; timeit.timeit('f(4)', 'from __main__ import f') 2.0644521713256836 &gt;&gt;&gt; timeit.timeit('l(4)', 'from __main__ import l') 2.0810730457305908 
/r/learnpython 
If someone wants to backport, that's cool but it's up to them to remove that guard. It's also up to them to backport anything that might have relied on version specific syntax. I'd rather have an install fail up front with a warning that says "You're running a version too old for the maintainer to support" than for it to install "successfully" and then fail at run time. I went to build some plugins for kegbot a while back and was very unhappy to find that while it installed under Python 3 it failed at run time do to using a library that doesn't support 3 (and probably never will). Not to mention that kegbot is older and not well maintained these days (or last I checked at least).
Understood and thank you
Neither diction nor pandas nor numpy are necessary or even useful for this…
&gt; How many companies have millions of lines of python running internal &gt;tools? If they had that much Python, we'd know about them one way or another. 
Guido gave a keynote in which he put up a slide with "2.8" in a circle with a line through it. :-) He made it clear: no more. If fact, one of the most-used Python libraries in existence, SciPy, has ended 2.x support early. Its latest release only supports Python 3. Other major libraries are also planning to make their next releases Python 3 only now.
I feel you. I was a Delphi developer for a long time and the largest website with Delphi libraries is **filled** with stuff from the 1990s (shareware, no source!). Out of curiosity this week I went looking there for an ID3 tag library and the absolute latest dated back to 2005, with most being from 2000-2002, and none supporting Unicode. 
I don't think it means that (unless I completely misunderstood the article). The whole point of semantic versioning is to add features and depreciations with backward compatibility, with a fixed target for removing the BC (the next major release). The problem happens when old major releases are still supported and used indefinitely.
&gt; The other day someone told me they couldn't accept a contribution as it required version 3. As far as I am concerned, that project no longer exists. Maybe you'll understand it easier if you think about Python2 and Python3 as different languages. Would you submit a patch to a Perl5 project that requires it to switch to Perl6?
&gt; Python2 is going to die. Based on what? on your opinion? i still work for clients that main internal apps running on java 6. 
TR3 is pushing for all new hardware to include software with no EOL within two years of full production. Given that, that means that Python 3 will be the only Python allowed.
What a stupid question though, nobody would ever write something like this.
&gt; https://thenewstack.io/instagram-makes-smooth-move-python-3/ From TFA: "Overall it took about ten months, in different stages." Now guess who can afford to pay tens of thousands of dollars for such a "smooth" process with no visible improvement...
&gt; GvR has already spoken, 2020 it is. Deal with it. Fuck Guido: https://github.com/naftaliharris/tauthon
About a year ago I wrote [a post explaining how to break different versions of Python without asserts](http://www.b-list.org/weblog/2016/nov/28/break-python/). Dunno if it's useful to you.
Maya 2017 still uses Python 2.7.5, so if that's part of your pipeline it'd be a huge pain to upgrade Python before Maya does, too.
&gt; While I don't disagree, it's quaint to get dictated at from people that don't understand all industries. Yup. VFX industry here - Maya and Nuke, the two dominant bits of vfx software are still on Python 2.7 and plan to be for at least a while longer. When it comes to choice of Python version - that's the only factor that controls our decision. Upgrading before they do would be a colossal waste of time and over-complication of the studio's pipeline.
&gt; What are you going to do in 2020? Wait for the security fix when shit hits the fan, just like dozens of hospitals did with Windows XP a few months ago.
&gt; For the fixed case lambas just seem simpler and there is no difference in speed as far as I can tell. They can also provide flexibility when you need to have the arguments in a different order. It's entirely subjective if lambdas seem simpler. Personally I find `partial` to be clearer for the most part. It is true that lambdas are more flexible, but for simple cases such as the file reading example (where you don't need the flexibility) I think `partial` wins. Partial is definitely faster. In your example you are mostly timing the execution of the `'%s: %d + %d = %d' % (self.name, x, y, x+y)` statement. If you reduce your example so that you time just the call overhead, then partial wins. &gt;&gt;&gt; import functools &gt;&gt;&gt; import timeit &gt;&gt;&gt; f = functools.partial((3).__add__) &gt;&gt;&gt; l = lambda x: 3 + x &gt;&gt;&gt; timeit.timeit('f(4)', 'from __main__ import f') 0.08098697662353516 &gt;&gt;&gt; timeit.timeit('l(4)', 'from __main__ import l') 0.11748909950256348 32% faster for what its worth. 
You mean "No visible improvement outside the company."
 On 3.6 I only see a difference of... with lambda being faster. 0.14014703035354614 0.13938496261835098 
That's fine, and I think the author makes that point clearly in the article. But if you are going to keep using that old code for arguably selfish reasons, you should at least be sharing in the costs of maintaining the tools you need on those older versions. There shouldn't be an expectation that a project maintainer will keep support for old versions they don't use if they aren't getting compensated (either with development time on their project or $$) for making that support available. The argument is that by not taking the time or spending the money to upgrade you are subtly foisting those costs onto the people who are often unfairly expected to keep their code working for you.
Yes it is. And one companies experience means almost nothing. If I have a working bespoke internal system written in hundreds of thousands or more lines of python what is my benefit to rewriting it? Why take on the risk? Just because it worked out for Instagram after a 10 month investment doesn’t mean it makes sense for me. This is especially true because Instagrams python was public facing and this needs to be secure. If I have an isolated backend system with no direct connection to the public internet, that doesn’t matter at all. It really does seem like many vocal python 3 supporters have never actually worked for a large company, or on a project which has lasted more than 4-5 years before.
I think that not supporting LTSes is crazy and the tone of the article is totally wrong. 
&gt; Ubuntu doesn't I think it does since 17.04
It was a nice idea. /** * API response */ { "error": { "errors": [ { "domain": "youtube.playlist", "reason": "channelSuspended", "message": "The channel specified in the channelId parameter has been suspended.", "locationType": "parameter", "location": "channelId" } ], "code": 403, "message": "The channel specified in the channelId parameter has been suspended." } }
While I agree that legacy software do exist, but they won't update their libraries and python version, and they should probably vendor their environment. So moving forward, accepting patches in py3 only and drop py2 support is fine
I wonder what the evil corps have against people *'deleting' the content they uploaded? If people were doing something malicious or spamming, then i could understand. But deleting our own content, jeez... Did FB lift the suspension? Did they make it easy? * They probably have copies of all content uploaded to their service regardless of whether it's 'deleted' or not.
IIRC Gentoo has used Python 3 as default for years, and its package management is all written in Python (+ a little bash). Not sure if you'd count it as major, but it does get used e.g. as a basis for ChromeOS.
Two things: 1) If by X/Y transformation you mean translation in X and Y, keep in mind that you can: reflect, zoom, shear, and translate by composing a single affine transformation. That is, don’t do these operations separately if speed is something you care about. 2) If you are doing this in the context of image augmentation to support deep learning, consider using the Keras imageDataAugmenter class: https://keras.io/preprocessing/image/ Even if you aren’t doing randomized augmentation, the implementation of zoom, translation in Pillow would be a good starting point: https://github.com/fchollet/keras/blob/master/keras/preprocessing/image.py
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [fchollet/keras/.../**image.py** (master → 3292aa5)](https://github.com/fchollet/keras/blob/3292aa5a30350c67627f173ceac713956f68271f/keras/preprocessing/image.py) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
This type of question is better suited at /r/learnpython But, assuming you're writing this in Python3, here a couple of things to look at: * 'yob' and 'current_year' should both be an integer * With your print messages and your input prompts, you can use [.format()](https://docs.python.org/3.1/library/stdtypes.html#str.format) Here's a working example: print("Welcome to the age calculator") name = input("What is your name?") yob = int(input("Enter year of birth {} :".format(name))) current_year = int(input("What year is it?")) age = (current_year - yob) print("{}, you are {} years old".format(name, age)) 
Based on Guido Van Rossum saying support ends in 2020. That's it. It's dead. Python 3 is the future. 
What kind of error message do you get? Try this (line 5): age = int(currentyear) - int(you)
gentoo is a meme distro
There's no correct answer here. However, the comment I was replying to said it was impossible because the code was too big and mature, and people proposing upgrades were ignorant. However, there is evidence that it's clearly possible, and has been done. That's all that post really says. If you're writing internal applications and aren't using open source, that's fine. If you are using open source, and are insisting open source provides you with Python 2 compatibilty for your enterprise, I'm going to ask that you pay for it, because it's causing problems for people who want to move on.
The line that most caught my attention was “We’ve cultivated a class of passive open source consumers”. This is a feature, not a bug, and something the F/OSS community has been striving for long before, say, Ubuntu. People using open source software is a Good Thing and although contributions should be welcomed, it’s poor form IMO to shame users who aren’t contributors. 
I don't know why they suspended my account. It's been +- 7 month, I never got my old account back because I didn't want them to have my ID; so I had to create another account. I then asked them to delete my previous account, and as far as I know it's still up, just deactivated and impossible to find when doing a search.
The argument in the article is not that no-one should support old platforms, but that the people who need that support should be responsible for it. The author reckons that many open source projects have people who use new platforms doing unnecessary work to support old ones, while the people who use old platforms may not even be upgrading the package anyway. He has a point, but we're often happy to support some things we don't use ourselves, because it means our software is more widely used, and we gain bragging rights.
Reduce now lives in functools
Have you tried their Compliance Support? https://support.google.com/code/contact/unusual_api_activity
All volunteer maintainers are doing some business work for free, though. It can be fun or interesting, it can earn us recognition and jobs. The question as I see it is how to balance the fun and interesting parts with producing well-regarded software that's useful to people other than you.
&gt; Do you mean "No visible improvement outside the company"? I mean no visible improvement for the paying customer who is usually a small-time shop, not some unicorn with tons of VC money to burn.
“Upgrade” implies new features, but if you’re just talking about porting a codebase with no added functionality, it’s just a fucking refactor, only with potentially fewer gains than a normal refactor might get you. 
Yep, now it's in the standard library instead of the builtins like map and filter. Kind of a strange decision to me, I'd love to have seen the justification. Haven't done the PEP dive though.
Or, of course, you can stay on older versions of the tools as well. If you're not upgrading the platform it's running on, code isn't going to break because of platform changes, so you only need to patch the bits that are important for security.
A group of projects are moving to get past the 'no-one upgrading' scenario: http://www.python3statement.org/
The correct solution is for py3 people to stop pretending python2 and python3 are the same language, and to stop trying to force those of use who remain on python2 (for whatever reason) from switching. This whole situation is so weird, it's like if C++ or Objective-C supporters had tried to force C programmers to adopt their language of choice. There are some similarities between these languages and it's possible to write code which compiles in both but that doesn't mean porting always makes sense, especially not on your personal timeline.
No it's not? I used to use it, before I switched to a Chromebook and compilation times got too painful. The package manager is wonderful.
r/learnpython or even /r/techsupport 
I think it's worth pointing out that Cobol is merely a language, for which there are multiple implementations. Some of those are still actively maintained, like Gnu Cobol, whose latest release was ~2 months ago. When people talk about Python 2 going away, what they mean is that the Cpython 2 implementation is going to be unsupported. That isn't quite the same as Python 2 *the language* going away. Technically a language can't "go away"; it can just run out of supported implementations. Pypy has a python 2-compatible release, but I'm not sure whether they plan to support it after 2020. So your Cobol assurance may be a bit misplaced.
To be fair the PEP is from 6 years ago, when it had been “just” three years...
try removing the brackets inside "Process" and "Thread", like this: t1 = Process(target=menuz) and changing if name == "main": for if __name__ == '__main__': And importing threading is not needed- [r/learnpython] (https://www.reddit.com/r/learnpython/)
Pickle can't be that bad. It's used in multiprocessing.
I think Python3 comes with Ubuntu last I checked. 
FYI just because there won't be a 2.8 doesn't mean 2.7 support is definitely ending.
Just as I expected of the community. Well done!
they don't want to loose content, other websites doesn't even allow you to delete your account
My money is on Red Hat, RHEL 7 comes with python 2 and is supported until 2024 iirc.
Programming is 80% reading code written by others and puzzles like this one make sure you understand how the language works.
Guys I need help hopefully someone can help me out or point me in the right direction. Okay so heres the question and I'm using Python 2.7 BTW "Create a program that prompts the user for an integer n the and then sums the first n integers, starting from 1. Please DO NOT! use the Gauss summation formula, USE THE WHILE LOOP."
2020 is still a while away, and EOL end does not make the software suddenly stop working.
Maya and the VFX industry will switch to Python 3 in CY2019 according to http://www.vfxplatform.com
As a relatively new python programmer (and I use that term pretty lightly) I chose to learn 3. It is frustrating that there are still whole swathes of libraries that are the best in their areas, that don't work in 3. Or their dependancies don't. I was recently starting to read "Grey Hat Python". First activity was building a debugger. The libraries all installed and imported but because of things beyond my current knowledge level (I think it involved the word unicode at some point), the debugger just won't work. And as much as I could copy the book and use 2.7, I'd rather: - not have to learn what is effectively 50% a new language - understand what I'm writing properly Surely if compilers have been written compile python to java or C code, couldn't something be written to convert to 2.7 up to 3.x to aid in converting some libraries. Or is there something there that I'm not understanding? 
In the speech that image was from, Guido van Rossum himself said that Python 2.7 support was ending in 2020. https://twitter.com/gvanrossum/status/455354868916842496?lang=en
&gt; Conceivably, you could do the same thing to reliably determine if someone is running Python 3 against a Python 2 package with That's an overly complex way to do it. `exec "1"` will do the job just fine.
The correct solution also involves stopping with exaggerations like “3 and 2 are different languages”, which are so patently ridiculous to make any further statement look silly. Just because strings are handled a bit differently and the runtimes behave slightly differently here and there, it doesn’t mean it’s a different language. You don’t want to switch, fine; just don’t ask others to do free work (patching 2.x) so that you won’t have to (port to 3).
This should really be in /r/learnpython 
Actual bugs are as far from theoretical mumbo-jumbo as you can get. And not polluting C:\Windows\System32 or the Windows Registry with executables you no longer want nor keys you no longer want because you've removed the software they refer to 10 months ago is also far from theoretical. Report this bug to the author of py.exe if you care enough, not to use. The bug title would be: "py.exe does not handle shebangs in py.ini" I hope that's not too much mumbo-jumbo for you?
Why would someone want PySide over PyQt5? It says PySide supports up to Qt 5.6, PyQt is at 5.9, which means it can compile QML and Qt Quick 2 apps. 
Yea but not as the default python.
`print "hi" ` would work too (assuming someone didn't enable the flufl module, not that I've ever done that). 
Not to feed the troll but I think [pd.read_json](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_json.html) would actually be very helpful for this. I've pulled live data from websites with it then converted it to numpy arrays for cleaning since I think they're easier to deal with.
At this point I just got home and tested the code. I have no idea what I did wrong, it's working now.
So no to 4.0-4.5?
https://pastebin.com/64vV9ub3
That wasn't an exaggeration. One you sacrifice backwards compatibility of something as core as string handling, yes, you've forked the language to something different. This isn't a bad thing, but pretending you didn't doesn't make any sense. Again, this is akin to claiming that C++ and C are the same language because some of the syntax is the same.
Yea I asked them to delete an old account, but I have a sneaking suspicion it's still one of the accounts that comes up during a search, just without any pictures or info.
Someone who can't pay $500 for the PyQt5 commercial license And the current development is at 5.9 too, check the got repo http://code.qt.io/cgit/pyside/pyside-setup.git/
PyQt is free, run by Riverbank. Qt Open Source is also free. The commercial license for Qt is for embedded applications. Mobile and desktop apps are made with the open version.
I've ***JUST*** started playing around with it so no guarantees, but check out https://github.com/barbagroup/AeroPython 
Yes the free version of PyQt is GPL , then you have to release your software under GPL too , while Qt itself and PySide are LGPL
I'll try this tomorrow and see what Google says. :)
OK, we can debate at what number of changes it ceases to become a different language. But if we regard 2 and 3 as different languages, then both needs need to stop interfering with each other. So no more 3x developers asking 2x developers to upgrade, and no more 2x developers asking for support from 3x-focussed communities.
What do you need to use it? Because I can't seem to make it work.
Certainly not, not until it's been tested on those environments.
&gt; no later than 2020
Er, I would not count Instagram as "having a long history." Try Xerox, where they started using Python well before 2000. Sometimes companies have generations of experts who work on technologies and when those experts move on or pass on, the old code base still has to be maintained until the next big upheaval.
The 2to3 program works for a lot of cases. It's bundled with python3.
Ubuntu too, as of 17.10
What if PyQT5 is installed as a system library?
So much needs to happen on top of that before we could consider switching. Autodesk and the Foundry need to actually release details of their software and confirm the move to Python 3, then Shotgun's python API need to confirm support for Python 3 and then project leads need to make the argument for updating to the newer versions of that software. ...Then pipeline dept. need to actually update the pipeline tools and system to work with Python 3. Stuff like this is why so many studios stuck with Maya 2012 for so long after their were newer versions (we went from 2012 to 2015, for example). All of this will not happen by 2019.
&gt; PIGS. I give you this: https://www.youtube.com/watch?v=qACxfKB3iP4 You're welcome.
Hi, really nooby user here. So I should alias "Python2" to ~/anaconda2/bin/python2 And also alias "python3" to ~/anaconda3/bin/python3 Rather then setting my path for one and aliasing the other? A majority of the program's I use require python 2.7, but some of the new stuff I do uses python 3. So I have aliased python 3 to my anaconda 3 but my path still exists as python 2.7 Or does it not really make that much of a difference having it setup like I did. 
Thank you. I forgot to add str to make it a string.
It compiles now.
Thank you for the help. I posted it in the wrong subreddit, I thought i posted it in /r/learnpython.
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) \#2: [Python 101 Book FREE for 48 hours!](https://np.reddit.com/r/learnpython/comments/5bmaz0/python_101_book_free_for_48_hours/) \#3: [PSA: If you have a library card, you probably have access to Lynda.com, which has tons of Python courses](https://np.reddit.com/r/learnpython/comments/6rrsdu/psa_if_you_have_a_library_card_you_probably_have/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
&gt; Pymunk is a easy-to-use pythonic 2d physics library that can be used whenever you need 2d rigid body physics from Python. Perfect when you need 2d physics in your game, demo or other application! It is built on top of the very capable 2d physics library Chipmunk. &gt; &gt; https://github.com/viblo/pymunk
https://www.reddit.com/r/learnpython/
The `time`command in linux reports execution time and the `timeit` python module runs code in a loop and reports an average run time. $ python -m timeit "['hello world' for i in range(1000)]" 10000 loops, best of 3: 38.1 usec per loop $ time python -c "['hello world' for i in range(1000)]" real 0m0.019s user 0m0.008s sys 0m0.008s 
Uhh thank you! But I still need to get past this error 
Are you using some sort of tutorial? Generally you would use `cmd` (standard Windows command line) instead of PowerShell for this. Anyway, the issue is that `python.exe` isn't on your system path. Your system path is the collection of directories Windows will look in if it can't find a given command in the current working directory. You can view your current system path by running `echo %PATH%` in cmd or `$Env:Path` in PowerShell. You can modify the path by searching for "env" in the start menu, choosing "Edit environment variables for your account", adding or editing one called "Path" in the top list "User variables for %USERNAME%", then adding the path to your Python installation directory to the list, clicking OK a couple of times then closing and re-opening cmd or PowerShell. Generally when you install Python you will get the option to add it to your system path as a checkbox so maybe just re-installing Python and checking that box would be easier.
It doesn't do finite element/difference methods for Maxwell equations :(
 This might help with some of the low level repetition and you will have to adapt it to a list or something rather than x1,x2,x3,... &gt;&gt;&gt; a = [chr(65 + i) for i in range(26)] &gt;&gt;&gt; a ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'] &gt;&gt;&gt; n = 90 &gt;&gt;&gt; end, begin = (a[(n - 65):], a[:n - 65]) &gt;&gt;&gt; end, begin (['Z'], ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y']) &gt;&gt;&gt; n = 71 &gt;&gt;&gt; end, begin = (a[(n - 65):], a[:n - 65]) &gt;&gt;&gt; end, begin (['G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], ['A', 'B', 'C', 'D', 'E', 'F']) &gt;&gt;&gt; 
That basically happened. Instagram gave a keynote talking about it. Was awesome.
You've misunderstood the meaning; "users" in this context are programmers. It is incumbent upon programmers to keep their software current. You may disagree, but there may be a time soon in which a security flaw in software you use but failed to maintain leads to major legal action, both civil and criminal, against your company and possibly even you as an individual. We're fast approaching (if not long past) the time where programming can't be treated with the same severity as other engineering fields, in which negligence is punished with criminal and civil action. Glaring real-world examples include the loss of legally protected private information such as medical records or confidential information such as credit histories.
Very good to know ..
I vote ashamed. You've got a lot of code in there that you don't need. The first two lines accomplish nothing. You build a string with a list of method names at the end, but you never do anything with it, not even save to a variable. You also don't need to use a loop to search for the requested method on the character sheet class. Since you already know the name of the method you want, you can just look it up directly using `getattr`. Here's an improved version of the code: @bot.command(pass_context=True) async def character(ctx, command=None, *args): cs = CharacterSheet(ctx.message.author.id) if command is None or command == "info": await bot.say(str(cs)) elif not command.startswith("_"): method = getattr(cs, command, None) if callable(method): method(*args) cs._save() Note that this code retains your current behavior and fails silently if you ask for an invalid method (either one that doesn't exist, or one that starts with an underscore. You may want to fail more loudly in those situations (e.g. say something like "I didn't understand you" or "that's not a valid command").
v0.0.7 released with support for BashJob along with regular python methods.
That's not what the article was about.
Their support.
Please don't use NR. Ok, that might be slightly too strong of a statement, but I mean, NR used to serve a purpose that is now vastly superseded by libraries. And not just in Python: LAPACK is usually faster than the Fortran routines in NR. Besides the licensing issue (NR is copyrighted, and in principle you cannot freely use their code for commercial application), unless you actually bought the codes, chances are you will copy algorithms from the book, by hand. This is super prone to typos… And maybe a final point: indeed, NR are a great tool to get some ideas on "how to start doing this or that". But this should be language-independent, so no need for "NR in Python".
Python is not a cloud service. Ending support won't stop your application from working. And not all python code runs at user-facing applications that it would need constant bulletproofing. So it being dead really isn't enough reason to go to 3 for everyone.
Slightly unrelated, but I remember when Google+ was new (and Google thought it would be a "thing") so they asked me to create one. I guess. I'm not going to put anything on it, so what's the harm? Well, a short time passed, and I decided, "Naw, I don't really need another place where people could potentially gain information about me" so I went to delete the account. A pop-up came up saying something along the lines of, "If you do this, you ENTIRE account is gone!" But being the fool I am (or logical) I thought, "Yeah, I want the Google+ account gone." Confirmed. It deleted EVERYTHING. Email? YouTube? Google+? No, they were playing hardball - you have the Google+ account, and it's all-or-nothing now. I was shocked they'd ransom my *entire* account with a Google+ account I voluntarily accepted at their request. I like Google. Great search engine, YouTube is nice, and I appreciate their attempts at innovation, but I never looked at them the same again.
What exactly does "meme distro" even mean?
It means I once tried to install it and finally ragequit after it was still compiling 12 hours later.
"SOME" Python users/coders talk more about 2 vs 3 than actually coding, building software or solving for certain things within the real world or language for that matter -- its gone from amusing to obnoxious over the many years I've seen this. Here's another article + thread that just proves my point to a T...I hope the new comers don't get put off from the toxicity this stirs up. What really should happen for the language (besides putting this war over different versions to bed) is better ways to proliferate it further in the world/other fields and make it comprehensible for a variety of skill levels (not Scratch, that thing is ugly as sin-- sorry; I'll never teach my daughter that way). Coding is still an island for many people and it's likely that Python could be a great gateway language for folks to harness the power of computing-- making their life/work easier. That's an area I believe worthy of time and effort for Python coders rather than this War of the Roses.
Still a problem: id GPL, not LGPL.
This post is not worth your time people. The author is blaming wrong people. Legacy cannot be prevented in the first place. Not all projects can be attended in timely manner. In fact, most of them are not even worth attention, either because they just work or they are not used that often. When issues arise, some maintainers choose to contact upstream, which is a completely sane option. If this attempt to communicate is a burden, you can draw a clear line: "no legacy is supported". End of story. I don't know why users have to be blamed in this scenario. Also, enterprises are not obliged to "pay" FOSS projects. FOSS is driven by strict rules like licenses and copyright laws, not by such undocumented vague obligation. It's true that there some leeches who abuse developers' commitment, but there are several methods used in field to *endorse* contribution and donation. Let's not forget that FOSS was successful because of its sheer efficiency, not because companies wanted to pursuit greater goods. 
Just an idea (I haven't tried this technique within pyinstaller myself but I have dealt with a fair deal of packaging some pretty huge apps via pyinstaller)...this "might work" -- please reply back here if it does: (1) Upon Start (double clicking) on YourAppLoader.exe -- in the very beginning of your program code -- it unzips a really rinky dink app (let's call it YourAppSplashScreen.exe) to a temporary directory (check out the tempfile module for this) and the app runs it with a os.popen() call or some system call. Now the splash screen is up. Perhaps animate it as things are loading?? Might be a better user experience so they know things are still "moving" and the app isn't freezing (2) Now perhaps the "real" app is also "unzipping" into some temp place (or real place for that matter) and starting up at this stage -- this is where the 20~30 seconds is happening...Conversely, this could also be happening in the first app I mentioned too called YourAppLoader.exe --- I'm not so sure about this part (2) Once the "real" app is done loading (or ready to show the inital interface), you do an os.kill() or some flag that kills the splash screen app prior to loading the real app. I feel like this could work because I often bundle multiple other smaller EXE files in my app that run different operations on the data I'm playing with (a divide and conquer approach). Break a leg and hope this works out! 
thanks for the help. for the code above, how would I use the timeit module? also, second question about arrays above. 
Linpack is totally what I use. I learned Fortran 77 in my Matlab class because I don't trust code I don't write (unless I have no other choice), but ive never had to do anything more complicated than either LU decomposition with pivoting or Newton's method; both of which are perfect universal scripts to write while learning a language (at least according to my old crotchety advisor)
Create another variable that will be the total then loop while counting down n, multiplying the total (which should start at 1)by n each time until n equals 1
&gt; Latest commit 736faed on May 19 If they're not even planning to port 2.7's security patches *before* EOL (latest [Sept 2017](https://raw.githubusercontent.com/python/cpython/84471935ed2f62b8c5758fd544c7d37076fe0fa5/Misc/NEWS)) you'd be a fool to port your company's application to Tauthon. 
&gt; If they're not even planning to port 2.7's security patches before EOL (latest Sept 2017) you'd be a fool to port your company's application to Tauthon. It's much easier to contribute those patches to Tauthon yourself instead of porting a big-ass code base to Python3.
Damn! I can only imagine how infuriated you were! I attempted to do the same many years ago. When it popped up with that message. I was concerned that it would delete everything, so i went in to the settings of G+ and attempted to turn everything off and on private.
Some distros are created essentially as a joke without really intending to be used. Gentoo is not one of them, but Hannah Montana Linux is.
No sir, thank you. Not OP but I enjoyed it tremendously. 
/r/learnpython for all of your python needs. 
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) \#2: [Python 101 Book FREE for 48 hours!](https://np.reddit.com/r/learnpython/comments/5bmaz0/python_101_book_free_for_48_hours/) \#3: [PSA: If you have a library card, you probably have access to Lynda.com, which has tons of Python courses](https://np.reddit.com/r/learnpython/comments/6rrsdu/psa_if_you_have_a_library_card_you_probably_have/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
If it's 3D graphics, and the alternative is node, i think he's working with the wrong toolbox.
You were *incredibly* right to be concerned, because it did exactly what you assumed it would. Tell you the truth, I wasn't mad about the loss of the account and the contents (email is free, and I didn't have many videos, mostly playlists of music I enjoyed), but the method they went about it. "We're going to be the next FaceBook, so have a Google+ account, and buckle up bitches, because you're either keeping it *forever* or you're losing *all* your Google accounts. Also *forever.*" And what did it accomplish? Everyone did what you did: set their accounts to everything private, or just not use them ever. At all. For *anything*, at the expense of pissing quite a few people off. ***slow clap*** Well done.
Civ IV which is reasonably close to a AAA franchise/title has a huge component of which is Python. Python is used as a tooling language for some games (usually this is done by LUA, but Python has encroached on this space here and there)
I think we need a universal python23 binary. It would need a parser that understands Py2 and Py3 grammar, and picks one as soon as it obtains evidence of which language a file is. 
That sounds good. Will try incorporating your style. What development environment do you use ?
Python3 wasn't worthy until Python 3.3. Before that it was noticeably broken.
Python 2.x will loose support in 29 months. So it would better to have python 3 version out as early as possible.
Not that hard to find the information required via a quick Google. https://github.com/bear/python-twitter
This thread started with someone saying &gt;Do you think GvR is going to screw over a majority of the users of Python over ideology? So the answer is quite clearly "Yes"
no that's not working.
That was over half a decade ago...
&gt; it's all-or-nothing now You mean "back then", many years ago when this happened to you? I'm not going to try *now*, but with Google+ strongly demoted, it is possible you can now remove most of your Google+ data without deleting your Google account.
It depends what type of system you're on, but it doesn't make much of a difference. As you are currently set up, things will be fine. System programs usually hardcode 'usr/bin/python', so even if 'python' points to anaconda when running in a bash terminal, running system programs from a terminal will still have them run with system python. The only exceptions might be rare cases where this hasn't been quite done correctly in a system program, but this would be a bug in the system program. Nevertheless I'm sure it'll come up in some context at some point, bug or not, and I'd rather be on the safe side and ensure I only have aliases for commands that already exists on the system. But you don't have to be that paranoid. Just don't go and do something like [putting a link in /usr/bin to some program that you want easy access to]( https://askubuntu.com/questions/938606/dwarf-fortress-starting-during-apt-get-upgrade) and you'll be fine.
Yeah, so not long ago.
doesn't work for more than 6 variables. 
Can you visualize binary trees? A graphviz visualization would be nice.
It's called the quine mckulsky algorithm, and it is NP-hard There are some heuristic programs-- I believe one of them is called ESPRESSO
Gentoo has been my easiest experience without any pulseaudio. Also for ZFS as root.
You need to add the Python executable to your PATH file, when you enter python in Powershell Windows searches all directories in the PATH variable to try and find 'python.exe'. See: https://superuser.com/questions/143119/how-to-add-python-to-the-windows-path
It's already in Ubuntu 17.10.
Yeah, but switching the caller from `python` to `python2` is not a huge, resource intensive or insurmountable task. He is **not** asking you to port your py2 code to py3. 
Erm... "no visible improvement"? Technological debt was measurably reduced. Codebases opened up for newer libraries which exist in py3 only, you save (depending on your project) $$$in the long run not having to invest in reimplementing the function of a library in a dead environment, for which a perfectly fine library (py3)exists. 
But that's not "venture", that's infrastructure investment. Yeah, you need free capital for that, or foresight to justify its use. But upgrading to py3 when py2.7 is rapidly deprecating and messaging end of life is a necessary investment, especially if your product is ever changing, and not done monolithic control software nor having been touched for decades and not going to be touched for several to come. 
Well, that's why open source and libre licences are the best thing that could ever happen to our world. 
But this is the point of the blog post. If a company needs a new version of the oss lib back ported to Python 2 it should pay for it. Most likely they won't upgrade anyway. Denying new features and contributions in libs because some free using company would have extra work is a bad decision.
That depends on your software. Is it one that is expected to get features added, to expand, to evolve monthly, because it is a living product? You absolutely must upgrade or die of technological debt. Is it a monolithic e.g. control software, written one, running and humming, needing minor patches once a year without major new feature introduction? Upgrading might be less capital efficient than not to do so. 
Well, someone posted thauton, which aims to be a python 2 implementation (and more) to stay. 
What's wrong with asserts, when they are used this way, which is justified and prudent? 
You really, really, really should have a look at *nim*. Head over to /r/nim !
Indeed, *now* you can do this. At the time, and for a non-zero point of time after the launch of Google+, this was *not* the case. Once you accepted the Google+ account, you were with it from that point until they decided to stop this asinine practice.
Of course it is.
Yes, it's a general kind of *packing problem*, and you should ask about it in [r/learnpython](https://www.reddit.com/r/learnpython/), which is more about how to figure out how do things with Python, rather than discussion about Python itself.
It is possible, but there are more specialized programs and programming languages for these problems. They are called "constraint solvers", if you want to go on a google and wikipedia hunt.
Well there you go then - if one thinks GPL is the superior license (and I happen to think that), then there is nothing to change.
So your program is commercial but you can’t afford a one-off $500 ? 
/u/oxyphilat was commenting on the broken tuple-checking. The first check is intending anything 3 or higher, but 4.2 fails the second check. The first thing you'll have to do to test the code on those environments is to fix or remove those asserts, before you can proceed to test the code appearing below, so now you have un-asserted, un-tested code.
Yes ,because this is around 8000 bound in the local currency :D, and for a single developer with monthly salary less than that I have to look for better solutions Thanks
Yes, it's definitely possible. I've even sketched out solutions that take similar constraints and actually interface with the PMS at the hotel where I worked to make reservations. Didn't get very far before I moved to another job, so I don't have any code to show for it, though.
&gt; better solutions You mean *cheaper* solutions. Pyside has always been qualitatively worse than PyQt and constantly behind Qt versions by months or years, even when it was bankrolled by Nokia.
Yes you are right on that, and I hope under Qt company it will become better 
One constraint solver in Python: https://labix.org/python-constraint, http://agiliq.com/blog/2009/03/constraint-programming-in-python/
Not yet. But I've heard a few ppl mention graphviz already so I'm planning to look into it for the next release.
I use Pycharm Community Edition running on Linux - but that workflow will work with any IDE and any testing environment. That work flow is ideal - sometimes I will write some functions and then write the test cases for them - but I do that rarely. It isn't wrong but it can confuse things :-)
You sure you are executing the script with python3 and not 2? At least I could install discord.py and import it to ipython just now. 
A short answer: a dataframe columns will be stored as numpy arrays and pandas operations are thin wrappers around numpy operations. For single-typed columns, you should get the same performance. The benefit is fancy indexing.
[removed]
It does. It just gets really messy. But i think i just found a new peroject.
Try to use pip3 instead of pip. Most systems I know have pip coupled with python2 and pip3 with python3 
Use the SOP method then.
It is default, sometimes even it’s the only Python. What /usr/bin/python points to is not an indication of Python default-ness, it’s python 2 to accomodate old software.
Ha thanks. I am a maths teacher. I understand it possible, as I've been helping do it manually but I wanted to make a program that all the teachers could run... From all my replies it seems it's 100% possible and I'm willing to learn on my journey so I can do it! Already loving this community!
Thank you! I'm a long way from being able to do this but at least now I know my goal is achievable! 
I am poking all through that subreddit and the 100 different methods to learn python however I am struggling to find one which isn't leaving me bamboozled in the first few pages. I am completing codeacadamy and trying to get a copy of 
Thanks! That's a little over my head atm but I'm sure once I get better it will help guide me! Thank you heaps!
All programming languages will bamboozle at first glance, especially if you've never programmed before. Python is about the easiest there is to learn, though. The problem is lots of people learn in different ways; I personally found a book called Learning Python the most helpful (it's by Katz, I don't have a link handy), as being able to physically leaf through something that's explaining from first principles works best for me, but others seem to find other resources more helpful. I'd suggest trying several and seeing which ones starts to click for you.
It's not using http (post/get), it uses `socket` directly (that are lower level), and a custom protocol that the author reverse-enginered. you can look at this method https://github.com/beville/flux_led/blob/master/flux_led.py#L656 and see that it constructs a message (bytearray), which is then written using the `__write` method. The socket is opened in the `__init__` method of the object. You might want to learn about sockets, which are the basic block of network communication for an application.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [beville/flux_led/.../**flux_led.py#L656** (master → 5d62b6b)](https://github.com/beville/flux_led/blob/5d62b6b6678a4a995106a2ca538f24d5e3d0df4e/flux_led.py#L656) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Is it actually available for python2? I got this on first try: $ pip2 install discord.py Collecting discord.py Using cached discord.py-0.16.12.tar.gz Collecting aiohttp&lt;1.1.0,&gt;=1.0.0 (from discord.py) Using cached aiohttp-1.0.5.tar.gz Complete output from command python setup.py egg_info: Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; File "/private/var/folders/jh/43nvlpd53q99_k6vpkxyq_980000gn/T/pip-build-4WJsKp/aiohttp/setup.py", line 60, in &lt;module&gt; raise RuntimeError("aiohttp requires Python 3.4.2+") RuntimeError: aiohttp requires Python 3.4.2+ ---------------------------------------- Command "python setup.py egg_info" failed with error code 1 in /private/var/folders/jh/43nvlpd53q99_k6vpkxyq_980000gn/T/pip-build-4WJsKp/aiohttp/
Appreciate it. I'll see if I can't find a copy. I did have a look at html before I started python and it seemed to come so much simpler for me.
&gt; Each student allocates 3 students they would like to share with and we promise to get them at least 1 of their friends. This might not be possible! :) But yes, this is a simple problem of solving for constraints. Not really sure how you'd do it in Python, I can't imagine it would be too difficult. E.g. perhaps you could define the variables like so: *** b = {} # dict of male students g = {} # dict of female students number_of_boys=int( input('Number of boys') ) number_of_girls=int( input('Number of girls') ) for i in range( number_of_boys ): &gt;name = input('Name: ') &gt;allocated_friends = [] &gt;for i in range(3): &gt;&gt;allocated_friends.append( input('Friend: ') ) &gt;b[name] = allocated_friends *** Similarly for girls. For rooms: *** rooms = {} capacity = 1 while 1: # Same as while True &gt;n = int( input( 'How many rooms can fit {0} people?'.format(capacity) ) ) &gt;if n == 999: &gt;&gt;break # Breaks out of the While loop &gt;rooms[capacity] = n &gt;capacity += 1 *** Then you'd want to apply the constraints. The "allocate friends" part turns what would have been a simple bin packing exercise into a maximum matching problem. There will doubtless be some module for this.
That's strange. There is still a marked difference for me on OSX with Py3.6. Python 3.6.2 (default, Jul 17 2017, 16:44:45) [GCC 4.2.1 Compatible Apple LLVM 8.1.0 (clang-802.0.42)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import functools &gt;&gt;&gt; import timeit &gt;&gt;&gt; f = functools.partial((3).__add__) &gt;&gt;&gt; l = lambda x: 3 + x &gt;&gt;&gt; timeit.timeit('f(4)', 'from __main__ import f') 0.1096094639506191 &gt;&gt;&gt; timeit.timeit('l(4)', 'from __main__ import l') 0.1606821430614218 &gt;&gt;&gt; 
i tried **pip3 install discord.py**. Still doesn't work.
I'm not at my pc atm. That was just my first thought when I saw the question..
Is Python not one of those languages though? It sounds like something SciPy would have
It's a fun problem. &gt; we promise to get them at least 1 I would not dare to make this assertion. It's easy to think of problems sets that makes this impossible. So you might consider a model that can value the solution quality. There are only a small number of combinations(100,6). Even less when you consider you don't have mixed rooms. So you can solve the problem as 2 seperate cases. Say 60/40 split, combinations(60,6) is about 50 million. That's an easy lock to pick with brute-force search. Run through every combination, keep track of the best solution based on value-function. &gt; premature optimization is the root of all evil Though i'm really brooding about how to solve it on larger scales algorithmically using stable-matching, reduce to TSP, or strongly connected components.
You picked the wrong type of installation then. There have been precompiled binaries for something like 15 years. I agree Gentoo is not for everyone (I used it *very* briefly) but at one point it was a real force for good (their wiki at one point was the canonical source of building instructions for all sorts of packages).
[removed]
&gt; What /usr/bin/python points to is not an indication of Python default-ness If there is one thing that indicates "python defaultness", it's /usr/bin/python. I'm not sure what else you would use to determine "defaultness" otherwise.
Ha it is most definitely possible. I have done it by hand the past 5 years. I think the other user deleted that comment as I tried to reply to it. 
&gt; Upgrading might be less capital efficient than not to do so. If "running and humming" has to be done in a secure way, then the capitaly efficiency of not upgrading is likely dwarfed by the potential repercussions of a security failure.
HTML is a Markup Language (that's what the ML stand for), it is *not* a programming language (it doesn't have any notion of conditional logic, while and for loops, etc), and so can be a lot simpler. Python is much more powerful, but also much more complex.
*&gt; FOSS was successful because of its sheer efficiency* How old are you? That's *definitely* not why FOSS was successful.
1. [Ubuntu Wiki disagrees](https://wiki.ubuntu.com/Python/3): their indicators are (a) using py3 wherever possible (b) py3 system scripts (c) py3 not installed by default. They plan to reach that in 18.04 fully; most of those is done already. 2. [Fedora](https://fedoraproject.org/wiki/Changes/Python_3_as_Default) has the same ideas and they completed the project. 3. [PEP 394](http://legacy.python.org/dev/peps/pep-0394/) makes both Ubuntu and Fedora leave /usr/bin/python pointing to Python 2. 4. Fedora will make /usr/bin/python point to 3 [if PEP 394 is changed](https://fedoraproject.org/wiki/FinalizingFedoraSwitchtoPython3).
What's wrong with asserts? `PYTHONOPTIMIZE` is wrong with asserts. If you set that environment variable on the _existing_ system, asserts stop being an error. That is something you can't control in a library, unless you want to do `assert sys.env["PYTHONOPTIMIZE"]` or something. 
That's defaultness for a very small subsect of people" OS maintainers. To users (a category that also includes most developers), defaultness is what happens when they type "python". &gt; Fedora will make /usr/bin/python point to 3 if PEP 394 is changed And that's exactly why I said it's high time to change that PEP.
I'd use [Pipenv](https://github.com/kennethreitz/pipenv)
wow, I was aware that this would propably cause debate. That went well. Seeing some misconceptions (general and regarding the article) in some responses shows that the debate is necessary.
I learnt by reading instructions on how to add mods to bulletin boards, then books to hello me build my own. I think for first steps, contextualising information is important. What’s the job of an if statement? When do we use it? That context should fill in most of the intuition of when you’d want to use it, and then what if statements are and for kind of falls out of that. Practical things like codecademy, installing patches/mods through line by line instructions, and most importantly *having a problem you want to solve* are, for me, the most import parts of learning programming. Books fit in there, as part of learning how to solve a problem.
thanks for your valuable contribution.
Thanks for your observation.
But that's the same as my updated example in one line.
Just keep it simple, [pip-tools](https://github.com/jazzband/pip-tools) or [pipenv](https://github.com/kennethreitz/pipenv) if you want to be on the bleeding edge.
&gt; But upgrading to py3 when py2.7 is rapidly deprecating and messaging end of life is a necessary investment No, it's throwing good money after bad. If you're going to spend 10 months rewriting your code base, you might as well port it to Go, D, Rust, Nim, etc.
Never knew about that. It seems he has make a lot contribution. 
It doesn't argue not to support LTS releases.
These have been here for awhile, but last time I tried to follow them I found some things already were out of date. Python packaging is such a mess of accreted history; distutils, buildutils, setup.py, pip, easy_install, ... The whole system could do with a cleansing fire and rebuild on the ashes.
 python -i test.py
&gt; Technological debt was measurably reduced. By how many buzzword units?
Bring on Python 4
This is a pretty robust one being used a lot in AI / Machine Learning environments: https://github.com/bulletphysics/bullet3 Some examples of agents or robots being trained to move: https://github.com/bulletphysics/bullet3/releases/tag/2.87
This has been available for literally years (since ~3.2 I think), and is no more useful than anything else on the internet. I hate to break it to you, but this is not news, and is not useful either. This post may as well be "Python 3.0 has finally been released".
You know, there do exist unconnected devices... 
Thanks for the insight. 
Do you really think that upgrading from 2.7 to 3.6 is the same amount of persondays as rewriting in legs das Rust? 
Lots of things. Off the top of my head, you get a whole bunch of time series functionalities, group operations (this is huge for me), can be used with spark, different data types in the same object, windowing functions, plotting directly with matplotlib from the dataframe, etc... I know a lot of these things can be accomplished with numpy but it won't compare to the ease of use of pandas
&gt; Do you really think that upgrading from 2.7 to 3.6 is the same amount of persondays as rewriting in legs das Rust? What part of "10 months" did you not understand?
True. Sure I can use the wrapper (Thx for the link) to build it myself. But downloading all images from a hashtag (or user, or search, or...) must be such a standard task that someone has built it already, no? But thanks for the link, very useful.
You'll get that exact question a lot because its *the* question to answer when you're asking for help. There's so many possible answers its crazy, so having a baseline of what you've tried vs what you haven't is a very very good place to start.
Yeah. I just didn't realize that I already had it.
I think you can fix the packaging tools without changing the language. Thanks to venv and pip, installing stuff is OK. It's just the years of history really show when you try to build something.
Thank you. That’s exactly what I needed. 
It’s a joke 
pyautogui, RPi.GPIO, pyvbox, pybloom, praw, grequests, redis, flask
I didn't find something like that from a quick glance via Google, did you actually check this or are you just assuming? I found https://labix.org/python-constraint though, which is what OP needs in case she/he wants to stay within Python.
I think this Python package does exactly what you need. https://github.com/geduldig/TwitterGeoPics Command line usage: python -u -m TwitterGeoPics.SearchOldTweets -words YOUR_HASHTAG -photo_dir PHOTOS_FOLDER The package also includes a similar script for streaming.
Anyway you **have to** do this in Python. You said you heard it's best to have a goal - it's not. It is in fact the only way, and the most fun and motivating way. 
Yeah like the 7000 centrifuges at Natanz.
point taken. unfortunately i can't change the title to "Hooray, i eventually realized there are packaging guides on python.org".
there's also still https://docs.python.org/3/distributing/index.html :-/
point taken. unfortunately i can't change the title to "Hooray, i eventually realized there are packaging guides on python.org".
I deleted all of my history on Facebook and they suspended mine. Which was fine because I wanted to have locked up anyways. Business-wise it makes sense. If you had people deleting their only value to you as a company, that wouldn’t be good for business.
thanks for this. precision in expression leads to precision in implementation, etc. I'm actually currently working on a project with varying patterns in time series data I'd like to be able to recognize and categorize. So, I need to wrap my head around this a little more.
Dibakar Saha used pyautogui and OpenCV,Imutils,Thread to do a Motion Gesture Recognition project. source code to the project is https://github.com/EvilPort2/SimpleGestureRecognition Since you mentioned pyautogui I thought this project will be worth trying by you.
This sounds like something that could be solved with graphs! The first thing you should do is come up with a model, a way to represent you problem. Then, given the constraints, try to develop an algorithm that gives you one solution.
Use 'py -3' instead of 'python' and invoke pip through it (using 'py -3 -m pip install -U discord.py') to ensure you're installing to python3 and to the same installation
Thanks! I can safely leave it as is then. I really appreciate the details you wrote up. 
Fun problem: feels like NP-complete, a multiple knapsack problem. &gt; promise to get them at least 1 Is not a safe assertion. Suppose your group is a directed cycle. &gt; in seperate rooms This makes the problem a lot easier, as you can roughly treat it as 2 separate problems. Actually, there may be configurations of room size distributions where it would matter, like when there are a small odd number of large rooms, and many small ones, but let's ignore this, otherwise you'd end up with a multi-dimensional knapsack problem. &gt; something I can work towards A greedy approach: I would first look for all strongly connected components. They will vary in size. Those that are to large (than max room size), you can break them in smaller pieces by removing an edge (you'll have to try this for all edges of the group to find the largest possible sub-groups). So now we still have the same problem, only with less items, which all satifsy the contraint ´at least 1´ except the groups of size 1: the singeltons. These are the ones we want to match first. The non-singeltons (ns) will be mostly cliques, which means they can be broken into parts while maintaing their SCC nature. todo = [singeltons + non_singeltons] done = [] For each room, large to small with room_size if any non_singeltons size &gt; room_size, break in 2 pieces For each non-singelton with ns_size ns_weight = ns_size calculate the number of incoming edges from singeltons, the n_weight best_match = 0 best_combination = none For number_non_singeltons in range(1,room_size) for combination in combinations(non_singeltons,number_non_singeltons) if total combination ns_size &lt;= room_size and total combination(ns_size+n_weight) &gt;= room_size if total(n_weight) &gt; best_match: best_match = total(n_weight) best_combination = combination fill room with best combintion, if (ns_size+n_weight) &gt; room_size, pick singeltons at random add/remove from todo/done If there are residual singeltons, use local search to remove them (swap with other singelton in a matching group, check if this one can be sensibly added to rooms with leftover capacity). This will not give a optimal solution, but i suspect it could perform adequatly for most.
I just wish there was better 1st party support for distributing applications in a compiled, binary form. If I write a tool for a co-worker who isn't a developer, I don't want to give him the script, help him install dependencies, get python on the path, etc. I know tools to do this so exist, but they're third party, some work different from others or support only some versions, etc. I just wish the python experience wasn't so engrained in doing things "pythonicly" all the way down to end users.
First: Read sidebar to the right of this reddit page: "If you are about to ask a question, please consider r/learnpython or the learn python discord." In other words this is the wrong place to ask questions, go to r/learnpython! Second: "that's not working" is a totally useless response, it tells us nothing at all, except perhaps you are lazy. Tell exactly what you mean by that. Third: What version of Python are using? what operating system? Fourth: This prints results for me on Windows 10 and Python 3.6.2, study it to find the differences to your code. Attention to detail is important. import threading import time from threading import Thread from multiprocessing import Process def menuz(): print("I am first") def live_view(): time.sleep(10) print("I Am 222") if __name__ == "__main__": t1 = Process(target=live_view()) t2 = Process(target=menuz()) t1.start() t2.start() 
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) \#2: [Python 101 Book FREE for 48 hours!](https://np.reddit.com/r/learnpython/comments/5bmaz0/python_101_book_free_for_48_hours/) \#3: [PSA: If you have a library card, you probably have access to Lynda.com, which has tons of Python courses](https://np.reddit.com/r/learnpython/comments/6rrsdu/psa_if_you_have_a_library_card_you_probably_have/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
What if students A, B and C, are very popular. Assume that the largest room has `n` beds and that `3(n+1)` students all pick students A, B and C. You could place students A, B and C in different rooms, but unless I am missing something not every student will get their promise fulfilled. I am only stressing this since I've tried to solves similar tasks using programming, only to find out that the problem that I wanted to solve was harder than anticipated. I don't want to discourage you, but a good piece of advice is to think about the problem mathematically before you start to program it. Even with the speed of a computer enumerating every solution might not be possible in reasonable time.
Also, lots of iteration methods broke in subtle ways.
probably starts with googling "seaborn tutorial"
You can automatically convert things in most cases. But it's the other 1% that's the problem.
There's not a whole lot more to say. The FFT method introduces 0s at the end of your time data up to the next power of 2. That affects the frequency content. It's not real, but is fine with hammer hit data. For say data from measured loads that continue after the data measurement, unless you're really lucky and have a data series length that is a power of 2, then you'll get spurious results. If you use the definition, you can avoid that inaccuracy, by not zero padding. For realtime and large data sets, you make compromises, so it's still maybe what you want. You need to be aware of it though.
I can't believe you have to install both twine and wheel to get something distributed. So much for batteries included.
fantastic, that is EXACTLY what I had hoped for. Thanks a million. 
This. Python is my favourite language cause of its simple yet powerful features. But It's a real pain to make a working app from python, unless you don't want to package the whole compiler with your app.
I'd add this to the repo ``` ### install ``` python3 -m venv env source env/bin/activate python3 setup.py build python3 setup.py install ```
Packaging and run time seems like something that is going to eventually drive a lot of people/projects to Go. 
Venv for development, docker for production 
help ("os")
Tnx realy
Well you can upload an sdist, if you don’t mind the sdist and giving your password away, so it’s sort of like including two disposable AA’s with a new smartphone purchase. 
Because you misspelled "password" the first time you check it.
Because you misspelled "password"
shit well that embarrassing lol thanks
Definitely. I do love Python but trying Go's runtime, tooling and self-contained artifacts for the first time it's really a refreshing experience compared to this ugly mess.
Kudos to the PyPA guys that were brave enough to face this chaotic face of Python.
I'm working hard to improve this documentation and help users navigate the complex landscape of packaging. However, it is volunteering so it takes time. If you're interested in helping or even just giving feedback, feel free to reach out.
I don't have a formulated plan in mind, but this sounds like a job for an arduino or a raspi. Get yer robots on.
The top comment and yours say exactly the same thing, however one is upvoted and the other downvotes. I'll leave you to wonder why that is
I have improved the documentation of that repo, and make a pull request: https://github.com/geduldig/TwitterGeoPics/pull/3 took me a bit to get it working, may this help others in the future
Yeah, I just ordered a raspberry pi! :) I've been sifting through raspberry pi projects, but none of which i've encountered so far require a lot of technical skills, just coding!
None of those three things are either in competition or really even related. Both virtualenv / venv allow you to create virtual development environments for Python. Docker allows you to run apps -- including those created in virtual environments -- in containers. Anaconda is a 3rd party distribution of Python with its own package manager. See what I mean by them not really even overlapping just at the edges? Based on the -- minimal -- context in the question, you want to use venv for creating your Python dev environment for a given project. If it's a web app or otherwise amenable to testing in a container you may want to run tests in it in Docker, you might even want to deploy it as a Docker container, but they depends on whole heck of a lot of things we can't know about. If you want to do it with a lot of extra bloat, or for some reason need the few libraries you can't get off pypi without building from source, use Anaconda.
so if you wanna test many project from github, needing different versions of the same libraries, would you use venv? thats what i tried, but there are always problems running the programs even when using the required versions of the libraries used.
I'd be interested pm if you have a discord group or something
&gt; What are you going to do in 2020? Personally, I may look for another language as suited as my needs 
I think the first two lines is an attempt to dynamically generate a docstring. No idea if it works this way... (?)
I haven't worked with quiver plots before, but from the documentation it says that the 5th argument can be the colors of the arrows: X : 1D or 2D array, sequence, optional The x coordinates of the arrow locations Y : 1D or 2D array, sequence, optional The y coordinates of the arrow locations U : 1D or 2D array or masked array, sequence The x components of the arrow vectors V : 1D or 2D array or masked array, sequence The y components of the arrow vectors C : 1D or 2D array, sequence, optional The arrow colors So compose another array of the same dimensions as your data with the color associated with your error. 
Go through the gallery and the different plot types under [API](http://seaborn.pydata.org/api.html#).
It depends a lot on the projects, and the libraries; not everything on Github is very well behaved. If it installs with pip and it's pure Python, yes, use venv. If it has a compiled component and they've built a wheel for it, yes, use venv. If you've got to compile it yourself, maybe use venv and hope they've packaged it sensibly. Basically venv manages your PYTHONPATH, and that's about it, which means it works well with reasonably well-behaved Python packages, but if it relies on other, externally managed compiled libraries (ie the sort of thing you'd apt-get install or make build install), then you might need to go to using Docker to run it in isolated, controlled environments, or Vagrant if you want/need full VMs. In other words you're asking a question the answer of which depends on knowing a lot more about your problem than I do right now.
I'm still using python2.6 and pyinstaller1.5 to create a binary for a commercial product because the build broke when upgrading either/both of them. That was a while ago; things may be better with 3.x versions, but if it ain't broke, don't fix it.
PythonAnywhere developer here -- I'm a big fan of Trinket.io, but of course you should treat everything I say with appropriate assumptions of bias and misunderstanding of Trinket.io on my part ;-) The big difference between the two platforms is where they run your code. When you enter code on PythonAnywhere, it's executed on our servers. When you enter code on Trinket.io, it's run in your browser (via, I believe, a system that translates it to JavaScript). This means that PythonAnywhere gives you access to a full Python server-side environment, where you can run pretty much any Python code -- so you can write websites, do network-y stuff, and so on. The big downside is that it's running on a server with no graphics, so you can't do graphical stuff -- no GUIs or turtle graphics or anything like that. By contrast, while I don't think you can write a website on Trinket.io, you can do loads of graphical stuff. It that's what you're most interested in learning, it's definitely a better option. PythonAnywhere does have a couple of restrictions on free accounts; for example, you can't write code that makes outbound network requests to other websites unless they're explicitly whitelisted (this is to stop hackers from using our system to attack other websites). And, of course, free accounts get less computer resources (CPU, disk space) than paid accounts. I can't speak as to what restrictions Trinket.io have on their free vs paid options, of course.
I've tried that and a couple of people told me the plot looked cartoonish... also, the number of arrows in the plot and the randomness of the error make the whole thing look really weird... If I absolutely need to do it and I can't just use the scatter plot, sure... but I will try to have the scatter plot to represent the error... also that solution leaves out the scale bar for the colored symbols...
thanks for your time
Because I was somewhat snarkier and condescending about it. No harm done. Also I gave more detail about the extended time, while the other guy also included what does work well. And also also he was first lol
That's exactly what I mean though. It seems crazy to me that there's no built-in packaging system that comes with the language. It shouldn't matter what version of python you write the app in, because that version of python should have been released with an updated copy of a packager to support it. Cases like yours are a prime example of why it needs to come from the language authors and not a third party. Instead, you're stuck on an ancient, unsupported version of python, missing out on all the speed, security, and ease-of-use enhancements that have been added since.
I think the new pyzip stuff should help at least a bit?
Most open source packages are happy to have contributors, overjoyed even. Find a package you want to contribute to, look at its "issues" tab on Github, and then fork and submit a pull request. You'll find that, so long as you follow their submission guidelines (if they have them), *most* of them will be all too happy to have you along. *Some* of them can get pretty protective of what they do... to avoid problems, browse through the existing conversation on issues, especially closed issues, and see how the maintainers respond to things. Defensive about the thing they've spent time on is understandable, but some people take it too far. The more contributors a project has, and the more popular and well-regarded it is, the less likely they are to be difficult, though.
What about this: &gt;&gt;&gt; from sys import version &gt;&gt;&gt; f'The python version is {version}' 'The python version is 3.6.2 (default, Sep 3 2017, 05:08:20) \n[GCC 5.4.0 20160609]' Should only work with &gt;= 3.6 and if it works nothing happens with the created string. /u/Darkmere also the f-string is even a cooler feature to show ;)
Thanks for the concise breakdown. As for what I'm using it for, it would be more for learning data science programming as compared to web development, graphics etc. Also as for a paid vs non-paid account, is there anyway to track how much CPU or disk space I am using to gauge what kind of account I would need?
at the very least, put it on your resume REGARDLESS of formal work experience. It's extremely common to have skills on the resume which do not map to any formal experience. (or at least it's totally non-obvious from the resume). If a would be employer cares, they will probe your knowledge during the interview.
That'd actually work on pypy's 3.5. They decided to support f-strings in their implementation 
keep all your keywords in lowercase and convert your comment.body to lowercase. body = comment.body.lower() keywords = ["marvin help", "no", "yes", "words", "more words"] if any(word in body for word in keywords):
Wow, didn't know that. But for cpython I would rather put a simple `f''` in the begining as a async _trap, maybe some code try to use that function :D
Yes they do, there is a open source cryptocurrency trade bot on [github](https://github.com/carlos8f/zenbot). Stock trading isn't cryptocurrency trading btw. 
Are there any good books on the Python asyncio standard library?
how would I add that into: reddit = praw.Reddit('bot1') subreddit = reddit.subreddit("pythonforengineers") for comment in subreddit.stream.comments(): print(comment.body) if re.search("Marvin Help", comment.body, re.IGNORECASE): marvin_reply = "Marvin the Depressed Robot says: " + random.choice(marvin_quotes) comment.reply(marvin_reply) print(marvin_reply) without breaking it? I am not sure I follow. :(
Nothing that purely focuses on asycio AFAIK. I cover it briefly in [Learning Concurrency in Python](https://www.packtpub.com/application-development/learning-concurrency-python) but not to the extent you may be looking for! I will however be trying to add more and more asyncio based tutorials to both my YouTube channel and my site over the coming months so stay tuned!
 import praw reddit = praw.Reddit('bot1') subreddit = reddit.subreddit("pythonforengineers") keywords = ["marvin help", "no", "yes", "words", "more words"] for comment in subreddit.stream.comments(): print(comment.body) body = comment.body.lower() if any(word in body for word in keywords): marvin_reply = "Marvin the Depressed Robot says: " + random.choice(marvin_quotes) comment.reply(marvin_reply) print(marvin_reply)
True. I was thinking more about using it in the setup.py to avoid installing on an unsupported version. However, now that I think about it, a wheel would by pass that since it won't run setup.py on install (and pip will cache a wheel in its universal cache even with an install into a venv). A try block that defines the trap, an except block to exit and an else block to delete it in the main entrypoint would be the only sure way to stop usage but not installation. Extending pip to use trove classifiers as guards might be better. e. g. a package declares 3.5 as the lowest version it supports, if you pip install into 3.4 it just says no. But that relies on developers properly tagging their packages. 
You can connect some sensors to raspberry pi and build an intelligent robot or something. 
Good luck with that. The Python community has always been among the friendliest and most supportive out there. The 2/3 debate is basically the only long-running flame it ever experienced, and tbh it's not even that vicious outside of places like Reddit and Hacker News. Now go talk to LISPers and let me know how it goes.
&gt; much easier to contribute [security] patches to Tauthon yourself That will end well.
Thank you so much, I believe that is an array correct? It has been some time since I have written any code. I really appreciate it :)
&gt; That will end well. If applying patches to a C code base scares you, wait until you hear that Python is supposed to a be a glue language for CPU-intensive code written in C/C++/Fortran/etc.
If you have written personal projects, even just for the sake of learning, and you consider them an ok job, open a github account and upload them. They should be well organized and documented. Add the github link to your cv (same as you add your linkedin). 
I never thought about using a github, that's a good idea. Thanks
It's an `array` in other languages, but a [`list`](https://docs.python.org/3/tutorial/datastructures.html) in Python.
It's not the language, but rather that it's extremely easy to get any security-related change horribly wrong. People doing it piecemeal, on an outdated runtime that was developed by others, is not exactly an ideal situation for getting things right; and when security things go wrong, they can go spectacularly wrong.
You really don't though. You could just as easily put your package in a git repo and pip install from the repo url. If you want to distribute packages in an efficient and uniform way then yes, you have to install 2 small packages. Dont see what the big deal is.
Although timeit is designed to directly run statements rather than scripts, it will work if you put all that code in a file, say ./my_qsort.py and use: python -m timeit "import my_qsort" 
&gt; if any(word in body for word in keywords): What a programming language.
...that's a Karnaugh Map
last question. I want to avoid getting this error message: praw.exceptions.APIException: RATELIMIT: 'you are doing that too much. try again in 9 minutes.' on field 'ratelimit' I tried this but it did not time out/sleep #!/usr/bin/python import praw reddit = praw.Reddit('bot1') subreddit = reddit.subreddit("pythonforengineers") keywords = ["marvin help", "no", "yes", "words", "more words"] for comment in subreddit.stream.comments(): print(comment.body) body = comment.body.lower() if any(word in body for word in keywords): marvin_reply = "Marvin the Depressed Robot says: " comment.reply(marvin_reply) print(marvin_reply) time.sleep(1800)
Reddit is giving that error because your account is new and has low karma. It is an anti-spam measure that limits your account to one reply every 9 minutes or so. You only need to sleep if you make a reply. You can still scan comments that come down the stream, but you have to wait to reply.
Putting dates on the pages will go a long way to knowing what is the latest. Some people need the older pages for different reasons, but if we have dates, we can at figure out what's the latest method of doing things. 
got ya but is there anyway to make the terminal stay open? right now when I get that error the script stops and I cant view the comment stream anymore 
It's an error, so you need to handle the error or sleep longer so that the error never comes up. To handle an error, read [this](https://docs.python.org/3/tutorial/errors.html).
and where is the problem? SOP + equation simplifier has the same result as a kv-diagramm. If you know boolean algebra you can even simplify it yourself.
One more question, δ(i,j) is either a value of 1 (if i=j) or 0 (if i!=j). How could I set that up to plug in i or j values and return the value of 1 or 0? In Mathematica, he uses Table[Table[If[i==j, δ[i,j] = 1, δ[i,j] = 0], {j,3}, {i,3}]
That's a pretty cool one. Use f-strings as docstring perhaps...
The easiest way is probably through Vagrant, but you can also just do a `docker run` to run your test suite or whatever.
&gt;The whole system could do with a cleansing fire and rebuild on the ashes. So that people like you can add another item to your list?
I find it odd that people complain about having to install a couple of small packages to do something while simultaneously building a small package to do something for distribution.
Hei, thank for the reply! :) Could I please ask you to explain every line of the code, what does it exactly do? I do not fully understand the " for i in range(0,x):" line and below. And thanks for the advice about keeping my code clean :)
&gt;a compiled, binary form Only if it's possible to decompress it back to the source, please.
Are you being sarcastic? Go's packaging is **awful**.
Thank man, joined that sub!
Are you talking about the quine mckulsky algorithm? It works great, unfortunately, it's NP-hard. 
&gt; People doing it piecemeal, on an outdated runtime I bet most of those patches will apply cleanly.
The ultimate goal is to make packaging.python.org up to date and clearly organize tutorials and guides so it's clear which tools and techniques should be used for each situation, including which are the current recommended tools.
Thank you! It's hard work and we have a long way to go, but these docs are improving every month due to the work of volunteers.
Hi, I could go through every line of code but it sounds like you need to read up a bit on some stuff first. Read up about how for loops work and then try some out. The most valuable skill that you can learn is learning to teach yourself. Type things into python and see what comes out. E.g. try range(0, 5) then try changing the numbers and try to make sense of it yourself. The old proverb comes to mind: catch the man a fish and you'll feed him for a day, teach a man to fish and you'll feed him for a lifetime.
yes, but the other hint was what I was actually looking for - see the https://www.reddit.com/r/Python/comments/7av7l8/twitter_scraping_one_specific_hashtag_any_tools/dpdmc4v/ above/below - I could now even contribute to that project. Better than starting a new one, no?
Seems like you can solve your problem with "backtracking". Not an easy algorithm for beginners to implement but doable, especially for a mathematician. You do not need any special libraries for that. I estimate the entire algorithm takes around 100-1000 lines (depending on how generic you make it, the amount of optimization you need to get it fast enough, and how dense you write code). I guess the biggest hassle will be to distribute your Python program to your colleagues. You better start thinking in advance what your requirements are: - Windows executable? - graphical user interface? - where will your program read the problem definition from? 
If you have a backlog I would be happy to help.
I swear I'm not sarcastic at all. Go's packaging is non-existent, but its build system allows you to have self contained artifacts, including all of your vendored dependencies and content, with zero hassle. Deployment is just a cp. It's not a Go's novelty, you can obtain the same with every language that supports static linking, while in Python you have to isolate each application in its own venv since they cannot live together at all.
`print( ','.join(e) )`
you're funny as shit XD
That's the point imho.
what do you mean by "comma separated"? can you paste the expected output? 
I got the bot up and running, but apparently I have made too many requests to the Twitter API, so no more relies from it today. Format of the solution picture is still horrible, maybe tomorrow I will have time to clean it up a bit. Also it looks like I have some competition, which looks a bit nicer. Code is [here](https://github.com/edbeeching/StandAlone_Python_Tests/blob/master/maze_solver_bot.py)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [edbeeching/StandAlone_Python_Tests/.../**maze_solver_bot.py** (master → 8fe272e)](https://github.com/edbeeching/StandAlone_Python_Tests/blob/8fe272e0534b4c05543da7ae23555e43c554e8d8/maze_solver_bot.py) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Distutils was written by a sadist and it can die in a fire
Doesn't help if you're using C extensions.
`print( ','.join( e.tolist() )`
I'm sure people much smarter than me can explain, but why can't the compiler output a binary since it translates everything on the fly? 
It can (and does, see .pyc files). The problem is that it does that on a per-script basis, and at execution-time still relies on those binary-compiled scripts and any dependencies being available in the executing environment (i.e. python path and any local modules found in __main__'s directory tree). What I'm talking about is a tool that analyzes, gathers, and compiles all modules of an application, along with those of its dependencies, and packaging it into a single executable binary file. Such tools do already exist (see pyinstaller) but they're 3rd party tools and aren't part of the standard python distribution. I want a full-on PEP written up with corresponding tools delivered as part of the base python package, because I'm being needy :P
https://imgs.xkcd.com/comics/standards.png
A different piece of advice may, try the solver built into excel and see if that does the job for you? All my attempts at optimization in Python have been less-than-fun
I normally do it by hand: https://en.wikipedia.org/wiki/Boolean_algebra#Laws But there is a Python library for working with boolean expressions, it can also simplify them. SymPi: http://docs.sympy.org/latest/modules/logic.html Simplify: http://docs.sympy.org/latest/modules/logic.html#simplification-and-equivalence-testing 
You need to str the values first print( ', '.join((str(val) for val in data)))
Define a function in your other file, `import` it, then call the function. Also, /r/learnpython.
you're in.
That's great your keeping the old docs. It can be very challenging to support something that's old and has been abandoned for some time. Its kinda scarey how much data gets lost over time. I've had projects which have relied on external dependencies that have vanished off the internet.
Ah, that did it. I'm a little new to importing and didn't think to wrap my script in a function. I was able to import it just fine and my app is working now. Wasn't sure whether to post here or in /r/learnpython, so I opted to post here. I guess this is more of a beginner question so that would've been more appropriate. Anyways, thank you so much!
Yes! Thank you
Yeah. This is a great idea. There is also micropython that runs on the cheap esp8266 modules. https://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/intro.html I have been slowly teaching this to my step son. He started off with scratch. If you find some examples and explain what is possible your step dad might have some good ideas he has always wanted to do but didn't know how to do the logic/electronic side. Just remember to start small and work up to something more complex. Or break down your complex design in to bite sized chunks and do them 1 by 1. Nothing is quite as fun as bonding with ya old man over some interesting projects. BTW, if on the off chance he us interested in radio check out rtlsdr/software defined radios. Good luck and happy hacking. 
You will need [Jupyter!](http://jupyter.org/). It presents python code in a web page, sort of like an interactive textbook. I am not very good at explaining. You'll also need matplotlib, numpy and probably a few other things commonly used for scientific python. If you're new I'd recommend [Anaconda](https://anaconda.org/anaconda/python) as a python runtime, as it has most of that stuff built in already.
Yes, check out my [GitHub](https://github.com/Remootion/atcl). Ignore all the commits, I was developing it on my personal laptop and testing it on the pc's we use at school. This most likely wont work for anyone else as I just ended up setting to click at a certain location on a screen rather than finding each button. 
Which libraries were used to create that? That's a pretty neat idea. Do you also have the script up anywhere?
I'm guessing you're talking about map/filter where repeat iterations silently do nothing in Python 3?
Ok, I'll download Anacinda and try it out when I have access to a computer again!
That exact phrase returned seaborn's docs on google. RTFM.
And you can always use them to control things like water cutoff valves, makes watering the lawn a heck of a lot easier when you can just turn the sprinklers on at a fixed time for a set period without needing one of those fancy in-ground systems.
Eli5: what does this mean?
Probably the most common issue is the laziness thing, but changing the types of all those builtins can also cause problems. One real world issue I ran into while porting some code was that I had code that did `if foo.items() == [bar, baz, etc]` where foo was an OrderedDict. It still runs under Python3, but will fail silently because .items() now returns a dict view, not a list.
Start doing your labs with Python. It will pay off big quickly especially in later semesters when a faulty reference in Excel can kill an afternoon.
I like to think of pandas as SQL tables and numpy as C arrays. Both on steroids. If you need 3+dimensions, you go for numpy. For 2d arrays you probably want pandas but numpy with structured columns and dtypes can also work. If you need query-like operations you go for pandas. Otherwise for heavy computations you will probably prefer numpy but vectorized calculations can also work on pandas. The best way to understand is pick a simple problem and solve it with both libraries.
Rust and Cargo do packaging pretty nice. Go's packaging is not very good, but it does shove it all into 1 static binary, which is a plus compared to Python's crazy.
It definitely doesn't work that way. The docstring needs to be the very first line. And, from a quick test, it doesn't look like a f-string can ever be a docstring, even if the values it used were globals.
It's a bit slow to get up and running for the first time, but once you're there it's all pretty straightforward.
Celery?
You could follow the the loading process for the example dataset using your own data. &gt; ... it is possible to download the dataset manually from the web-site and use the sklearn.datasets.load_files function by pointing it to the 20news-bydate-train subfolder of the uncompressed archive folder. http://scikit-learn.org/stable/tutorial/text_analytics/working_with_text_data.html#loading-the-20-newsgroups-dataset
&gt; I think it does since 17.04 Since 17.10, I think.
For what it's worth there are unofficial PySide2 wheels in the conda forge. https://anaconda.org/conda-forge/pyside2 It's not clear to me that there's a lot of value in the PyQt commercial license, as it doesn't seem to override the Qt license. So even if you buy a PyQT one-time license, you're likely still on the hook for a Qt license (which is US$300/month/seat last time I checked) or you're still in LGPL territory. 
/r/learnpython 
Oh im sorry i wasnt aware of that reddit.
It's listed right over there in the sidebar ----&gt;
You say that as if it's difficult. It's literally one command.
How's the Amazon scraper coming along?
Im on the phone RN (and its 1 am)
So? Google the name of your mobile reddit app and "sidebar" and don't be lazy.
I was thinking it
the state of scientific community is such that most of the popular libraries are written when python 2 was the main python. Since in most cases they are badly maintained, python 2 is __de facto__ the main python syntax in scientific communities. Remember, it's the book for people who want to use python for their scientific projects, not argue which python is more relevant for `f'{datetime.datetime.today().year}'`
I already found the reddit if that is what you want to tell me.
http://www.practicepython.org/ Admittedly some of the exercises are challenging for an absolute beginner, but the instructions are good and the concepts covered are always put down for every problem, and examples of how to use that concept are given, and you could easily use analogy to use that same concept to solve the practice problem. Plus the guy gets you familiar with how to download packages and the like and be able to look up their functionalities and use them in practice as you need them. This site was a godsend to me when I was trying to gain fluency and ease in python and I'd recommend it to anyone trying to gain ease in python.
Amazing find! Thanks, I already forwarded it to my fellow colleagues who started learning python recently. On a topic of a great book for general software craftsmanship, I always recommend [this article](http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003285), which lays down the basic ideas every seasoned programmer knows, but somehow never translates to fellow engineers. 
Its essentially a plotting library, so you should start with a project in mind that requires various types of visualization. Otherwise just checkout the docs and plot examples...
Considering py launcher is now included in the python installation http://bugs.python.org/ seems to be the proper place. And sadly I can't be the one championing your bug, those fellas over there seem to hate me, it's not a pleasant place.
It went well. I just finished it up on Friday. I am happy with it. 
The SOPform function actually uses quine mckulsky algorithm. Still doesn't work as well if you want to do a 32 bit operatiion :/ 
I am bit familiar with New Boston. That will really help. Thank you my friend. 
Most info is on the site, like GitHub link and example photos. Mainly looking for some folks to try it out, and also looking for tips on making the front end. Should I style it manually with CSS, or use a Django template? Any other ways? Been a long time since I messed with CSS, looking for the easiest way to prettify it. But the main functionality is there. May add the ability to edit the options for the image transformation, or make animated GIFs, both of which are supported by the code just not the web service at the moment. Thanks!
I am familiar with New Boston. That will help me. Thank you my friend.
I know you're joking around, but it really is a good way. Programming's full of tutorials online, it's pretty crazy.
I mean, I'd take ugly packaging before I'd take an ugly language.
Honest question, do you use Python professionally and if so, in what capacity? I use Python in web dev/devops, and packaging is hell for me. 
The book "Fluent Python" has a section on asyncio, but it might be slightly outdated. Let me know if you find something, I'm looking for this as well.
This is kind of off topic, but does anyone know what IDE this is? 
&gt; The whole system could do with a cleansing fire and rebuild on the ashes. And then deal with 15 years of schism between people who accept the new format and people who go "OMG I CAN'T WASTE MONEY PORTING MY 1231241435452BN LINES TO THE NEW SYSTEM!!"... It's really a lose-lose problem. If you build anything backward-compatible, then you still have to deal with the madness; and if you rebuild from scratch, people will flame you. I believe the current efforts are to stabilize the developer interface into something sane, to then gut some of the old cruft, but it will take years. Wheels are a step forward and maybe they could be leveraged to build that elusive holy graal: a standard compiler in stdlib that can produce single statically linked executables. I bet if we had that, nobody would care about the pile of hacks that make it run.
Yeah, I write code in Python quite a bit. I will be honest: 99.9% of it is not packaged. But, that's the thing. It's a pretty standard, solid, manual process. Once you've done it once, you've done it a hundred times.
That looks like visual studio code, pro with some plugin for python auto completion.
Any time you put a skill on a resume, make sure to also put your proficiency. That way, if you have enough experience in Python to put it on your resume but you aren't prepared to answer complex interview questions, the interviewer will take your stated proficiency into account if they decide to ask that you use Python to write a solution, or they will just ask you to use a language that you've listed as being proficient in.
I am not really following what you're asking, but I think you can use NumPy arrays (they will be `object` arrays) with SymPy expressions. Also, this is really more appropriate for /r/learnpython 
Get into automation with Raspberry PI. The most fun and practical way to use python.
Can you share it?
Sorry, I can’t. I created it for a client. Break it down into small parts and you should be able to created it. 
&gt; Zenbot 4 is functional, but is having trouble reliably making profit. my bot is now 6 weeks profitable, no comparison. &gt;people with working stock trading bots don't tell a living soul how they work. 
I mean it's decent methodology, but I'm not sure what you're trying to prove... from a practical standpoint you'd never make a linked list like that in Python (you'd just use a `list` or whatever). And in the languages where you would do this, you have tail-call optimization. The conclusion that recursion is slow in Python is a little underwhelming.
Depending on what you want the bot to do, you can brainstorm ways that could be implemented and try out your implementation in order to learn without copy paste. Afterwards, you can see how other people did it and compare. Instead of searching how to write the entire bot itself, you can search after you try out your implementation and get stuck on a certain aspect of it.
Traffic knocked it offline for a few minutes because I didn’t have autoscaling set up properly, but all good now :)
https://docs.python.org/3/
&gt; One real world issue I ran into while porting some code was that I had a unit test that did something along the lines of assert foo.items() == [bar, baz, etc] where foo was an OrderedDict. It still runs under Python3, but will fail silently because .items() now returns a dict view, not a list. (Or rather, in this case, the bug caused spurious test failures, which is how I discovered it, but it would have failed silently if it was in non-test code). Good point, did not think about the equality thing but yes it's an issue as well, that some of them flip to false unexpectedly. 
Can you show a specific example code?
There are tons of them. Generating a logic circuit from a truth table (or other logic representation is called [Logic Synthesis](https://en.wikipedia.org/wiki/Logic_synthesis) and it's an entire discipline. I have a simple [algorithm](http://it.jeita.or.jp/document/publica/standard/exif/english/jeida49e.htm) implemented as part of my truth-table (and other stuff) [library](https://bitbucket.org/sterin/pyaig) - take a look at the README for an example. If you want something more serious, then take a look at [ABC](https://bitbucket.org/alanmi/abc). The learning curve is steep, though.
**Logic synthesis** In electronics, logic synthesis is a process by which an abstract form of desired circuit behavior, typically at register transfer level (RTL), is turned into a design implementation in terms of logic gates, typically by a computer program called a synthesis tool. Common examples of this process include synthesis of HDLs, including VHDL and Verilog. Some synthesis tools generate bitstreams for programmable logic devices such as PALs or FPGAs, while others target the creation of ASICs. Logic synthesis is one aspect of electronic design automation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
As others pointed out, a constraint solver would be a good fit for this problem, /u/uweschmitt for instance suggested https://labix.org/python-constraint Thus, this problem doesn't seem very python-specific... At the risk of encouraging posts that probably should be directed at /r/learnpython, I took this post as an opportunity to enjoy a little Sunday-morning brainteaser. I used Z3 (a constraint solver developed at Microsoft Research, which can be "pip install"-ed as `z3-solver`). An ipython notebook can be found at &lt;https://github.com/krooijers/KR20171105.excursion_room_constraints/blob/9e3e33c1bcd091bf8e7a4a22a6b29f527989686f/KR20171105.excursion_room_constraints.ipynb&gt;
All this shows is something that we already knew: cpython doesn't optimize tail recursion. It might be better to make your post more comprehensive by testing other implementations and/or other languages. You could try the same experiment with stackless or pypy. You could do it with C, testing how good compilers are at optimizing recursion. But as it is, you've only shown your conclusion for one implementation of one language. Also, considering that you're testing two different ways of iterating through *one* data structure, the title seems a bit off. 
This is a solid piece of advise. You could also consider contributing to an opensource project. I've got a few patches for the Linux kernel I'm sitting on and if I got laid off tomorrow the first thing I would do would be see if I could get them in the kernel.
Tips? Don’t copy-paste. You’re right about this. Type every line of code yourself, even if you’re following along. Then dissect those lines of code. _What_ do they do? _How_ do they work? _How else_ could you write those lines, and _why_ were they written as they were?
Automate all the boring stuff you have to do. But don't just do the minimum required over engineer the shit out of it and build a Rolls Royce. If your using windows consider Linux ;)
I thought about getting linux in a vm but what is the benefit specificly for python?
What are they using python for? Analysis? User applications?
The answer is mostly: "because it doesn't". If a compiler author *really* wanted, they could write a compiler that compiles Python down to bytecode and then create a binary containing the Python runtime and other code in the build. That's part of the trickiness to it; if you're compiling down to a binary you're targeting a specific architecture. Targeting the same architecture that the build is running on is usually easy enough ( you've already compiled everything for it ) but then you have to figure out which architectures to support and to what extent, figure out feature matrices, and more. It's doable and has been done for many decades now, but it tends to be a design choice from the beginning. I'm having trouble thinking of any instances of this sort of "retrofitting" ( from interpreted/VM execution to compiled binaries ), but I'm no historian. Nobody has written such a compiler for Python. I'm not entirely sure why. I don't think it violates the language spec in any technical way, there's nothing saying Python has to be run in a bytecode VM. Maybe it's way harder than any of us amateurs really understand just by virtue of having to build a whole compiler for the language; you have to deal with targeting different architectures and build flags and all sorts of stuff. It is very unfortunate. This is part of why I've mostly jumped ship to Go; after writing Python for 10+ years, Go just came in and presented a set of solutions to a lot of tooling and language problems. It sure would be nice if Python's tooling were better though. It's most likely just a case of too little profit in the endeavor. The Python community would be grateful, sure, but nobody's getting paid a living wage to write a Python compiler from scratch, and you'd need a *team* to do it properly, before Python 4 comes out.
Packaging is hard, because there is lot of history. But once one « knows » it, it is pretty obvious. We need one source of information describing the state of the art packaging models. Knowing pip is good, but you can’t package without understanding how requirements.txt (and soon: Pipfile) works, how setup.cfg works etc. I use pipenv and PBR, they rocks. Too bad PBR does not support Pipfile so I have to generate a requirements.txt, but once this is done, I would say this would be the simpler yet most efficient way of developing and packaging a python library.
Definitely
Linux has great support for python, lots of programs written in python, even 'system' programs have been written in python.
Try setting up Alexa on a raspberry pi. That'll be really cool and you'll use it too. Helpful link: [https://github.com/alexa/alexa-avs-sample-app/wiki/Raspberry-Pi](https://github.com/alexa/alexa-avs-sample-app/wiki/Raspberry-Pi)
[/r/learnpython](https://reddit.com) Try looking into set(). You'll need to work with your data a bit first though. 
Using CUCM AXL API? 
Hey /u/jrand0n ! I don't know any Java to Python converter, but even if it exists, it might not be a good way to learn Python from a Java background. There are plenty of tutorials out there, and the core of the language is dead simple, so you can be confident with it within some days :) Anyway, I didn't quiet get what you are trying to achieve with this string merge. What is the difference with a simple concatenation ? If you are just looking for concatenation, it can be done multiple way with python: a = 'stringA' b = 'stringB' a += b c = a + b d = ''.join([a, b]) # joins every string of the list with a empty string character. (this is efficient for concatenations with numerous strings.
None. I've been a pure linux admin for more than 15 years. I just started using windows again ~3 months ago, and it's totally fine for python. If you're desperate for a linux environment, you can install the windows subsystem for linux (WSL) and you'll get more than enough of a Linux environment out of it to keep you busy.
Find an open source project to contribute to (show more skills than just technical ones) or start your own project and put the source on GitHub or Bitbucket. Code talks, but make sure you can explain what you've done and why (if I'm interviewing you, and you've put a project on your CV, I'm going to ask you an annoying open ended question)
It was already in 16.04. All Ubuntu tools are Python 3, I have a minimalist server with only Python 3 and everything works fine. That said, many other apps in 16.04 depend on Python 2, so it is often seen in installs, maybe even in the official image. But the core system is pure Python 3.
&gt; I'm not sure what else you would use to determine "defaultness" otherwise. Install core system. No Python 2 is installed, everything works fine. This was already this way in 16.04.
Perhaps we oughn’t refer to programmers as users then, eh? Because that’s lumping a huge subclass of people who use software into a larger group who may not know code from their ass, or a hole in the ground. 
What you're asking for is a compiler (or, as some would call it for the specific case of compiling to another programming language aimed at humans, a "transpiler" - there is no technical difference though, so I prefer to just call them "compilers"). I don't know of any Java-to-Python compiler though, and even if one existed, the nature of these things is usuall such that the code they output isn't intended to be read by humans. And even those that do pretty-print usually won't produce idiomatic code, that is, if you were to compile Java to "readable" Python, you'd still get code that doesn't really use Python in a "Pythonic" way, it'll be code written with a Java coding style but expressed, for better or worse, in Python syntax. If you want to learn Python, study the relevant learning materials, and write some Python code; and in this particular case, go figure out how you would do it in Python, and then compare it with the Java approach, because they're going to be pretty different, not just syntactically.
&gt; stock trading vs &gt; Cryptocurrency
Nice article, thanks. BTW, what about comparing your implementations against deque from collections? If I am not mistaken it is double linked list under the hood.
Python list despite its name is rather array. Insertion is not cheap. Thats why you should use deque in case of need.
By default version, I meant the version you get when you run `python`. Both python 2.7 and python 3.x have been included by default for a while, but you still would have to use `python3` to use python 3.
The `assert` statement is ignored and will not raise an AssertionError if you run python with the `-o` flag.
Hey there, thanks for the reply. Yes I did spend some time looking at `set()` but kept getting an error `TypeError: unhashable type: 'list'`. I did some research into that but my brain started to melt. I'll head over to /r/learnpython and see what I can dig up. Thank you.
Does anyone know how to do these? I would like to know as well
Post the appropriate formulae and I'm sure we can help you pythonize them.
Seems like homework to me 
Err, so what? That's exactly as specified in PEP 394. Just set up an alias if that bothers you. What matters is that code gets ported to Python 3 and old Python 2 code goes to the attic. And this is what has happened for several years now.
issue is you probably cant have set of lists...if you moved all "pair lists" into pairs you might get away with it...im currently on phone so i might be wrong but try it: a = your list b = [(x[0],x[1]) for x in a] result = set(b)
looks like i was right...u might need this change thou : b = [tuple(x) for x in a] im not sure if braces are considered tuples in generator notation
(e) do your homework on time. No cheating!
&gt; That's exactly as specified in PEP 394 Yes, PEP 394 needs to change asap.
Once I did something to calculate options price using B&amp;S - It might help you to figure out what you want : import math from scipy.stats import norm def opc (strike,prec,taxa,dvenc,var) : print "Expiration day"," - ", "price" for dvenct in range (dvenc, 0,-1) : c = (math.log1p((prec/strike-1))+(taxa + (var**2)/2)* (0.004167*dvenct))/(var * math.sqrt(0.004167*dvenct)) d = c - (var * math.sqrt(0.004167*dvenct)) o = (prec*(norm.cdf(c))-(strike*(2.7183**(-taxa * (0.004167*dvenct)))*(norm.cdf(d)))) print dvenct," - ",round(o,2) return # Where : # strike = strike price # prec = price of the stock # taxa = risk free int.rate # dvenc = expiration day # var = variance (volatility) 
It's a republished assignment, he probably doesn't care and is just fishing for clicks. It looks like the /r/python queue has been overrun by students at the moment.
Why? PEP 394 maintains backwards compatibility, why do you want incompatibility "as soon as possible"? What is so important about having "python" run a Python 3 interpreter?
HO DAMN! :-) I have to be honest it works but I need to learn why. I'll be sure I do that now before I move on. Thank you (both), that was way more than I expected in terms of help. print("Removing duplicates") a = hitList b = [tuple(x) for x in a] result = set(b) list(set(result)) for items in result: print("B contains: ", str(items))
/r/learnpython 
Because it holds everyone back. It forces everyone to retrofit anything they do to py2, simply because otherwise users will come up saying “it doesn’t work”. We have had 6 years of this, it’s time to move on. As others said, all distros have ported pretty much everything they had to port and py3 is shipped by default almost everywhere; but until that pep is not changed, they won’t flip the main switch. We can’t wait for 2020 to do it, because flipping the switch will break stuff and the time for addressing that last bit of breakage is now, when there are still a couple of years left, so people have time to look at their options and help is available without much stress. Anyone who wants long-term stability is on LTS releases or on RHEL anyway, so they won’t feel any pain, while people who want to move on can do so. This would also put pressure on vendors like Apple, that still don’t even ship py3, to catch the hell up before Doomsday comes. At the very least, it’s time to review the PEP (last done 3 years ago!), and really it’s time to mandate the switch. This would mean distributions can plan it for releases 16 months from now, so that when 2020 comes... nothing happens because everyone has already moved on smoothly. And authors can start safely dropping py2 hacks in the next year or so, which will improve their lives pretty dramatically.
 In this line you specify the path to the destination file. You only supply the filename, so it goes in to the 'current working directory' which will likely be the same location as the .py file. fhandle = open(filename, 'wb') If you want it to go somewhere else, supply a full path. Something like this: fhandle = open(os.path.join(path, filename), 'wb') Where `path` is the directory you want to write the files to.
Hi, thanks for the heads up! I'll use LearnPython from now on.
To be blunt, the number of packages I can code for "cold" is very small. I don't learn APIs or packages in the sense of knowing them forever, just enough to do whatever it is I need at the moment and then (more than likely) forget most of the details until I need it the next time. It's just a matter of reading documentation, and a lot of it. Once you get a lot of practice reading docs, you can zero in on what you need quite quickly. I don't know how much documentation I read per code line I write but I bet it's more than most beginners would imagine. Django in particular has excellent docs. The getting started tutorial was enough for me the first time to get me started on reading the main documentation in a productive way.
I'm sure you know it's obviously not *one command or two*. &gt; 99.9% of it is not packaged. But, that's the thing. It's a pretty standard, solid, manual process. But I think this explains pretty much everything.
sets are also possible via comprehensions result = {(x[0],x[1]) for x in a} would give the result.
Could you explain it a lil further please? I don’t quite get what you mean? Sorry, I am not a pro 😜
I don't think anything beats "learning by doing". Read the overview then find examples and start coding. I don't see the point in learning a framework that I'm not about to use since I will forget all details as soon as I stop using it anyway.
Thank you! It worked! If anybody has this problem, be sure to dubble \\ in the path. for example : fhandle = open(os.path.join('C:\\Users\\1\\Desktop\\Data\\server\\Recieved',filename), 'wb')
psssst... [attrs](https://github.com/python-attrs/attrs)
In the example above, the class would normally look like: class Point: def __init__(self, x, y, name='', visits=0): self.x = x self.y = y self.name = name self.visits = visits The last 4 lines could be removed by adding @storeargs.
Ooh that’s sweet! So basically I just import this python code, that is stored in an extra file just like a module and type @storeargs. Thanks for explaining!!’
do you ever do then when you run a setup.py?
would you run a setup.py with that option?
Thanks, I was looking for something like that, but couldn't find it. That's why I created the code above.
Really cool stuff. Gonna dissect this later thanks for sharing.
yes- you can see your cpu and disk usage for pythonanywhere accounts. I'm guessing it would probably be easier to install the data science libraries on PythonAnywere vs trinket.io. Also you can try using the jupyter/ipython notebooks on PythonAnywhere (but it's only available for paid users because the notebook server takes up a lot of CPU etc)
it told u why it didnt work before...set needs to hash its contents and list is unhashable...tuple is hash able
Thanks to everyone who uploaded, some cool results in there. Realized some things I should fix, like handling for very small images and handling of PNG files, which for some reason don’t work very well (I had only tested with JPEG photos). Will keep working on it!
&gt;Sorry, I am not a pro 😜 Never be sorry about this. The fact that you had to ask just means that OP didn't do a good enough job explaining it.
I don't. I just learn enough to do what I need to do. Over time, I've gained a thorough knowledge of a few that I use regularly. For your example of Django: it's not just a package, but a huge framework. Start by following a tutorial, and then make a small project on your own. 
"Fluent Python" describes asyncio in 3.4. It helps to understand some concepts, but so do Beazley's videos about generators. And there were some noticeable changes in async api in 3.4-&gt;3.5-&gt;3.6(with backport to 3.5.2), so majority of blog posts about asyncio look odd right now.
Both... according to what you need. I would maybe focus on written "documentation" as it seems you are less comfortable with it. Sometimes all there is is written materials to help you. Videos seem to happen second.
Or alternatively, use *raw* text strings, like `r'C:\Users\1\Desktop\server\Received'`...
Even if you manage to find a java-to-python transpiler, it would be a horrible way to learn Python. Python and Java have completely different programming styles. For example, in Java you can only do OOP, while in Python, you often do not use OOP at all. Java is full of getters and setters, Python uses attributes instead. The "best" you could end up with is writing Java code with Python syntax. Join us at r/learnpython, and use a Python tutorial like "Automate the boring stuff with Python". You could also take a look at the [official Python tutorial](https://docs.python.org/3/tutorial/), it will give you a nice overview. (The fact that the tutorial doesn't even mention classes until chapter 9 should give you an idea how different the programming approaches in Java and Python are) 
Maybe something like the current working directory is not right? Note `os.system` is a bit limited, maybe you have more luck with `subprocess.run` or `subprocess.Popen` and some additional arguments, like `cwd` or `shell`.
1. What is your current skill set/level of mastery? 2. What is the nature of your work/what do you use Python for? 3. What do you want to learn?
You probably need to modify your Python path environment variable when calling the normal Python. Unsetting it might be sufficient.
The fantasy I have in mind is some entirely new codebase that creates packages that pip can install, but shiny and clean and new. I don't really know how hard that is, and the incremental improvement path you describe is probably the better way to go. But I wonder if the problem is a lot simpler for pure-python projects that don't need to build binaries?
Of course everything is simpler for pure-python modules... but you don’t really need packaging for those. You really need packaging for the monstrosities like pillow, numpy, pycrypto and so on, where you can’t just drop scripts and run. 99% of complication in setuptools and friends is required by non-python build toolchains, that’s the bit that is being (slowly and painfully) carved away.
Ok, do it. Lynda.com, CodeAcademy.com to start. Get you feet wet with syntax. What are you going to be building? Web sites? Data analytics? Network glue? Find out what problem they want you to solve, then run in that direction.
^^^^^^what ^^^^^^did ^^^^^^you ^^^^^^say?
tabulate. So simple, yet so useful.
If one writes a book and your reading speed happens to be let's say 10x times faster than writer's writing speed - you've got a bit time saving. Can you listen to an audio file at 10x speed? I doubt it. Can you watch a video file at 10x speed? There's a very slight chance you can, if you are Bruce Lee. IMHO, this is the greatest advantage of text over anything else as learning media (well, at least until instant learning methods from the sci-fi books will be implemented). A second great advantage is fast search by keywords. For now, you can't dump a visual image from your brain into your computer and search for it inside a video file. I think video tutorials are great for learning visual activities, like 3D modelling in a GUI app. Programming, however, is different. It is an abstract task. And text is perfect for learning it.
Yes, when I said work with the data a bit I was talking about the unhashable type problem. sets work because values are unique. Lists are not unique as their values can be updated. Tuples cannot be updated, therefore converting each nested list to a valued pair works. 
Great. Just double check that your employer is well intended and won't tell you to return the money paid for your training if you quit for another job.
I prefer cron if available and you don't have a state to preserve. For example, you want to scrape a website every X minutes and save the result to a file. If you have a long-running process that builds up a state and needs to be running all the time I use http://supervisord.org/ Thanks for bringing APScheduler to my attention. Seems useful as an embedded scheduling tool. 
Probably because when the prof makes the test, he/she is clicking around the video of their own lecture, with increased probability of focusing on the longest-displayed slides. Now we need to test this! :-)
You can make more challenging for your stepdad if you build your own amplifier for sound output, since the raspberry has quite a low quality.
Yes
Where can I find them?
r/learnpython has plenty of resources to get you started
i tried. got the same error. i really have no idea why it doesnt call /usr/bin/python2.7 when i state subprocess.Popen(['/usr/bin/python2.7','sample.py'])
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) \#2: [Python 101 Book FREE for 48 hours!](https://np.reddit.com/r/learnpython/comments/5bmaz0/python_101_book_free_for_48_hours/) \#3: [PSA: If you have a library card, you probably have access to Lynda.com, which has tons of Python courses](https://np.reddit.com/r/learnpython/comments/6rrsdu/psa_if_you_have_a_library_card_you_probably_have/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Thanks! 1. I am proficient with SQL, SAS, and STATA. 2. I would be using it for some statistical analysis and machine learning to integrate back with Tableau 3. I want to expand my skill set with a new programming language and and also learn how to use it for web purposes. 
Mainly data analytics/machine learning, but I also want to learn other general uses as well.
It's a neat project and props for learning by building something. I would always encourage that. But some thoughts on responsibility... - isn't this a bit abusive to imgur and the web in general. These days, do we really need to make extra copies of random images whose content is more often than not useless garbage? - one of the recently copied images is of a gun scope pointed at man's head, from r/syriancivilwar... Do you want your bot arbitralily participating in touchy/volatile conversations like that?
Good bot
Yeah, understood. But 99% (95%? I haven't looked) of the packages on PyPI are pure python. And you do need packaging for them once you want to run them in a managed context or share them with other developers. A simple very easy tool for that case might be a real help. I've been griping this whole thread but let me say; installing binary wheels is _wonderful_. I used to try to build pygdal bindings from scratch. It'd take hours and half the time wouldn't work because of some fiddly build problem with the C code. Now it takes 30 seconds and just works, thanks in no small part to a huge amount of blood and tears shed by the packager. Grateful for that.
sounds like a job for beautifulsoup
Nice! What lib did you use to create this? * [py-midi](https://github.com/edouardtheron/py-midi)? * [pyPortMidi](http://alumni.media.mit.edu/~harrison/pyportmidi.html)? * [python-rtmidi](http://trac.chrisarndt.de/code/wiki/python-rtmidi)?
http://www.deepideas.net/deep-learning-from-scratch-i-computational-graphs/ - I just started this
&gt; isn't this a bit abusive to imgur and the web in general. These days, do we really need to make extra copies of random images whose content is more often than not useless garbage? It could be a bit abusive but as I've mentioned that the bot is active on only selected subs, namely "/r/Android" where I've noticed that many leaks that are posted on Twitter where there is someone in the comments either requesting or providing an Imgur mirror of the leaked images, these users are most of the time on mobile where Twitter can be very cumbersome when switching apps. &gt; one of the recently copied images is of a gun scope pointed at man's head, from r/syriancivilwar... Do you want your bot arbitralily participating in touchy/volatile conversations like that? That entry and the other similar entries were done when the bot was doing tests on /r/all and one of the reasons I've decided to keep it off from it. Also thanks forr the imput. 
It does call /usr/bin/python2.7 ... your problem is that /use/bin/python2.7 doesn't know where to find the dependencies of `sample.py`z For proof, edit `sample.py` and insert this at the top. import sys print("INTERPRETER PATH") print(sys.executable) print("PYTHONPATH") for p in sys.path: print(p) print("TARGET PATH") import cv2 print(cv2) Then run it with your standalone python. See how the directory that CV2 is in is one of the directories on sys.path? Now, run it again using the *subprocess* call from your embedded interpreter. It will error when importing cv2. Notice how the directory for cv2 is not in the sys.path any longer? And likely several of the paths in your sys.path are different and refer to the paths to the embedded interpreter? This is because subprocess calls hand the parent environment to the child process by default; try adding **env={}** to the arguments in your subprocess call.
You have an upload limit? would recommend one
What do you mean? Thanks!
Limit the size of the pictures you can upload, also i get a unexpected output.. you have Debug turned on? i can pm you the output
first and last defense of the shitty OSS project
That’d be great thanks! Definitely some kinks to work out, the upload limit is a good idea. May limit it to jpegs too until I work out the issue with PNGs. Not sure about debug would have to check but I think it’s on
Thanks for the background! Yeah the change from asyncio coroutine syntax to async def has caused some confusion for me. I'm looking to learn more about asynchronous client/server programming in python for building media applications.
Just a note - if you want to do something like this in production, check out the [`attrs`](https://github.com/python-attrs/attrs) library :-)
Things like this make fall in love with python more and more, it’s even easier than pseudo code
Regarding the backtracking: I've tried to implement [it](https://github.com/karelvancamp/Backtracking/blob/master/Backtracking.ipynb). Any comments? This is the first time i've used this approach. u/KezzaPwNz You could easily modify the code for your problem. Just be very patient. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [karelvancamp/Backtracking/.../**Backtracking.ipynb** (master → 41f0c18)](https://github.com/karelvancamp/Backtracking/blob/41f0c186f32d5b6b79f8625433ee7577cdb785f4/Backtracking.ipynb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
All definitely true :-) I'd also suggest using the "time" Bash command line tool for quick data about how much CPU time a given program uses. For example, time python yourscript.py ...in a bash console (on PythonAnywhere -- or locally, if you're using Linux or a Mac) will give you number for "real", "user" and "system" time used. The "real" time is just the elapsed execution time, but the sum of "user" and "system" is the CPU time. 
Will do so!!
True, i guess! Thanks for the encouragement ;)
mido, actually 
WHAT
Use requests to pull down the page if it's not rendered using javascript. Use Selenium if it requires being rendered in an actual browser. Once you've got the page's html, use beautifulsoup to parse it into whatever format you want.
RTFM
Nice, I had written [**something similar**](https://stackoverflow.com/questions/1389180/python-automatically-initialize-instance-variables/43946725#43946725) a while back, didn't know about `BoundArguments` though so this is a bit more concise. &amp;nbsp; I ran the tests from my version &amp; found that the code you posted handles all of the cases I mentioned in that link, except for variable keyword arguments. &amp;nbsp; Here's an updated version that handles all possible arg configurations: (*Note: Replace the `$` characters with newlines to unfold the included tests.*) from functools import wraps import inspect def store_args(func): '''sets all arguments as instance attributes. @store_args replaces the common self.x = x; self.y = y etc.''' signature = inspect.signature(func) @wraps(func) def wrapped(*args, **kwargs): bound_args = signature.bind(*args, **kwargs) bound_args.apply_defaults() obj = bound_args.arguments.popitem(False)[1] apply_parameters(obj, bound_args.arguments, signature) return func(*args, **kwargs) return wrapped def apply_parameters(obj, kwargs, signature): for name, arg in kwargs.items(): kind = signature.parameters[name].kind if(kind == inspect.Parameter.VAR_KEYWORD): obj.__dict__.update(arg) continue setattr(obj, name, arg) ###########################################################################################################################$#//////| Tests |//////////////////////////////////////////////////////////////////////////////////////////////////////#$###########################################################################################################################$$if __name__ == "__main__":$$#######| Positional |##################################################################################################$$class T:$@store_args$def __init__(self, a, b):$pass$$t = T(1, 2)$assert (t.a == 1) and (t.b == 2)$$#######| Keyword |#####################################################################################################$$class T:$@store_args$def __init__(self, a="KW_DEFAULT_1", b="KW_DEFAULT_2"):$pass$$t = T(a="kw_arg_1", b="kw_arg_2")$assert (t.a == "kw_arg_1") and (t.b == "kw_arg_2")$$#######| Positional + Keyword |########################################################################################$$class T:$@store_args$def __init__(self, a, b, c="KW_DEFAULT_1", d="KW_DEFAULT_2"):$pass$$t = T(1, 2)$assert (t.a == 1) and (t.b == 2) and (t.c == "KW_DEFAULT_1") and (t.d == "KW_DEFAULT_2")$$t = T(1, 2, c="kw_arg_1")$assert (t.a == 1) and (t.b == 2) and (t.c == "kw_arg_1") and (t.d == "KW_DEFAULT_2")$$t = T(1, 2, d="kw_arg_2")$assert (t.a == 1) and (t.b == 2) and (t.c == "KW_DEFAULT_1") and (t.d == "kw_arg_2")$$#######| Variable Positional |#########################################################################################$$class T:$@store_args$def __init__(self, *a):$pass$$t = T(1, 2, 3)$assert (t.a == (1, 2, 3))$$#######| Variable Keyword |############################################################################################$$class T:$@store_args$def __init__(self, **kwargs):$pass$$t = T(a="kw_arg_1", b="kw_arg_2")$assert (t.a == "kw_arg_1") and (t.b == "kw_arg_2")$$#######| Variable Positional + Keyword |###############################################################################$$class T:$@store_args$def __init__(self, *a, b="KW_DEFAULT_1"):$pass$$t = T(1, 2, 3)$assert (t.a == (1, 2, 3)) and (t.b == "KW_DEFAULT_1")$$t = T(1, 2, 3, b="kw_arg_1")$assert (t.a == (1, 2, 3)) and (t.b == "kw_arg_1")$$#######| Variable Positional + Variable Keyword |######################################################################$$class T:$@store_args$def __init__(self, *a, **kwargs):$pass$$t = T(1, 2, 3, b="kw_arg_1", c="kw_arg_2")$assert (t.a == (1, 2, 3)) and (t.b == "kw_arg_1") and (t.c == "kw_arg_2")$$#######| Positional + Variable Positional + Keyword |##################################################################$$class T:$@store_args$def __init__(self, a, *b, c="KW_DEFAULT_1"):$pass$$t = T(1, 2, 3, c="kw_arg_1")$assert (t.a == 1) and (t.b == (2, 3)) and (t.c == "kw_arg_1")$$#######| Positional + Variable Positional + Variable Keyword |#########################################################$$class T:$@store_args$def __init__(self, a, *b, **kwargs):$pass$$t = T(1, 2, 3, c="kw_arg_1", d="kw_arg_2")$assert (t.a == 1) and (t.b == (2, 3)) and (t.c == "kw_arg_1") and (t.d == "kw_arg_2")$$#######| Keyword Only |################################################################################################$$class T:$@store_args$def __init__(self, *, a="KW_DEFAULT_1"):$pass$$t = T(a="kw_arg_1")$assert (t.a == "kw_arg_1")$$#######| Positional + Keyword Only |###################################################################################$$class T:$@store_args$def __init__(self, a, *, b="KW_DEFAULT_1"):$pass$$t = T(1)$assert (t.a == 1) and (t.b == "KW_DEFAULT_1")$$t = T(1, b="kw_arg_1")$assert (t.a == 1) and (t.b == "kw_arg_1")
No just the built in Phone Services pointed at a flask app
Sure, books have more detail ...typically... than a "learn an entire programming language in 1 hour" video... no argument there, but there are a lot of more in-depth video tutorials out there. There are also books that, while still being 400 pages, cover less than a Derek Banas video. The issue I have with technical books is they often take *forever* to express a point. As someone who has authored a technical book, and knows others who have, I can tell you that there is pressure to have the book be 250-400ish pages, even when covering simple topics. The first 30-50 pages will often just be cookie-cutter "welcome to python" stuff too. Also, this is certain to offend some authors, but publishers just look for *anyone* who will write the book for the horrible deal you get when you go through a publisher. The authors of the technical books are often not actually good teachers, writers, and sometimes aren't even experts on what they're selling you, they just wanted to put a book on their resume... or didn't realize what a massive challenge, with little reward, writing a technical book is. Technical books don't typically sell in bulk. The author gets something between 15 and 25% of net sale profits in most cases. There are some better deals to be had, and some self-published books...etc, and these are where the *real* gold tends to be both in terms of great authors, with great content, getting rewarded appropriately. I personally tend to prefer text-based writeups. If a concept is exceptionally tricky for me to pick up, I look for videos. Otherwise documentation, sample code, examples, and sometimes tutorial writeups seem to be what suits me best, but everyone is different. 
This seems like an anti-pattern in Python. Pythonic code is meant to be easily understood, no? If you're obfuscating your __init__() method with a decorator, how will someone who has never seen your code understand what is going on? I'm no Python expert but I always try to make things as simple as possible and though this saves time and is convenient I feel it has potential to make things more complicated than need be.
This is fine for static site but for sites that dynamically load content, you'll need something along the lines of [Splash + Scrapy](https://github.com/scrapinghub/splash) or [Selenium](http://selenium-python.readthedocs.io/)
My tutorial notebook on web scraping with Python is probably a good starting point: https://github.com/TiesdeKok/LearnPythonforResearch/blob/master/4_web_scraping.ipynb If you are set on scraping an open tab then you probably want to use Selenium (see notebook). 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [TiesdeKok/LearnPythonforResearch/.../**4_web_scraping.ipynb** (master → c34c45e)](https://github.com/TiesdeKok/LearnPythonforResearch/blob/c34c45eb67cafe5fc2a6d956ee07cf31746c9ad6/4_web_scraping.ipynb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Automated greenhouse? Dude can build it up, you can code + rig up an automatic watering system, and you guys end up with random fresh food with minimal effort after it's up &amp; running.
My god what a genius
Right on. Thanks for sharing
&gt; Who cares? I do, when running large simulations for research purposes.
Ignore everything I said, I was deliriously tired. 
Pythons optimization is controlled with both environment variables, and with command line flags. So a [ricer](http://funroll-loops.teurasporsaat.org/) could do something like this: echo "export PYTHONOPTIMIZE=''" | sudo tee /etc/profile.d/75-python.sh And you (developer of library or apps) cannot control it. Same if it's run as a service. 
200KLoC of Python is *a lot* of code.
Very good answer. In fact I would even discourage learning these things by heart because even if a library or framework has a stable API there's still a good chance that new features are added that make it more efficient and/or reduce boilerplate that you had to write before.
I wouldn't call it an anti-pattern. Anti-pattern means that you do something in a inefficient way, not in an ununderstandable way. I agree that this is not the best usage of a decorator. Decorators are not supposed to change the behaviour of the function. But, if a decorator called store_args isn't obvious enough to make its purpose clear, you can also put an extra comment in the code to explain what's going on. This makes it slightly more work to code. However, the main advantage remains: If one of the arguments gets renamed, you don't have to change the name 3 times in the __init__, but just once.
You've inappropriately generalized. The article is context-sensitive for the audience. The user of a library is a programmer, the user of a program may not be a programmer. 
If at some point you do not reach for the [itertools](https://docs.python.org/3/library/itertools.html) module or it's child [more-itertools](http://more-itertools.readthedocs.io/en/latest/) then you will be missing out.
It’s been worse :P
Your point sounds very convincing. How do you think about Coursera courses? They have very good reputation and recommended by many, but yet they are mostly in video format. Some do not have any textbooks at all. 
Nice work! I was thinking of a more generic version of backtracking. Each bed is a variable to which you must assign a value: one of the students. As long as some beds are not assigned to a student, pick a bed and assign a student respecting the constraints. If at some point you cannot assign any student, you backtrack to the previous bed and assign another student (again respecting the constraints). You stop once you have assigned a student to all beds. You can implement this with tail-recursion or a stack as you're basically searching "depth-first" in a tree. There are some optimizations possible that are independent of the problem itself. For example, prefer variables with fewer options first. I guess this is pretty much what's in python-constraint (the library mentioned in some other posts, https://labix.org/python-constraint).
Pandas (BlockSci), lightning simulations, client integration etc.
Please what can you use it to do?
Cool - super simple ! thanks for sharing. I was struggling with crawling websites built on Java-script. Let me know if any one have any suggestion about it. FYI - I was trying to crawl - www.mybeeznest.com 
Well said! APIs are often use-it-or-lose-it types of things. The more you use it, the longer it takes to lose it. When I first decided to move my codes from `getopt` to `argparse`, I was useless without lots of examples, the API, the tutorial, and a playground script up and running. Now, I can write much of it from memory, but I *still* open up an older script and copy the initial invocation (and the raw format class since I always forget that name)
http://py.processing.org ? https://github.com/jonay2000/p5.py ? 
it sounds like you'll *love* [kivy](http://kivy.org).
I use PyQt5 and pyqtgraph for applications involving image analysis in python which requrie a GUI and interaction with mouse and keyboard events. I have worked with these libraries on OS X, Windows, and Linux. There's a somewhat steep learning curve, however there are many tutorials available online. However generally these focus on PyQt4. There are some significant changes between PyQt4 and PyQt5, so you can't always assume you can copy code directly and expect it to work. If you are going to continue working with python GUI libraries for future projects then I suggest you take the time to learn PyQt5 instead of PyQt4.
I've never got p5 to run and python mode for processing is rather a bastard of a python interpreter afaik than a real python framework or library. I'd love to use my own python environment and use some general GUI framework (not necessarily related to Processing). 
Tnx for the feedback. &gt; searching "depth-first" in a tree I considered DFS, but ran into issue that the problem can be a disconnected graph. Now that i think of it, it should be possible to deal with this (only choose disconnecred nodes when no linked ones are available).
I'm gonna second this. PyQt5 is fantastic. It comes with OpenGL support and various functions for using it. I'm also going to disagree with the above 'kivy' answer because kivy is just a nightmare to use. If you want a Java-like language PyQt5 is also able to compile QML, which is used to create mobile apps and more 'interactive' ui's. 
pyinstaller works well, assuming you don't have crazy hard dependencies to bundle like Pandas. 
I'm not sure if I interpreted your question right, but you can distribute programs over a network on Windows Server with group policies. Link - https://support.microsoft.com/en-us/help/816102/how-to-use-group-policy-to-remotely-install-software-in-windows-server
Banas is good to get your syntax and other basics, but I found that I learned way more following sentdex's practical code along projects. I often only use text based tutorials and books to find solutions to specific problems, but that's just me.
Do your users have python installed? You can zip a python program into an .egg file for distribution. Not commonly used but it works well for tiny groups of people that know what a terminal is. 
 set(map(tuple,a))
Anti-pattern doesn't have to be inefficient. It can also be insecure, arcane, incorrect in certain corner cases or brutally unmaintainable. SQL injection is caused by arguably very "efficient" way of building queries. Wrapping your python program in try/except Exception is plenty "efficient" in squashing errors but also has bad idea written all over. 
learning tuples. Just finished my coursera test on dictionaries with a little bit of help hehe, but I just started python 4 weeks ago so find my learning speed to be satisfactory. Gonna try to make a currency trading bot in the next six months. Have a friend helping me with modelling. 
`deque` is actually C code. Also it's not a naive implementation such as the one used in the blog post.
this is why I love python. It's a nice program although you should maybe just give options for gender. My program is a basic translator as follows translate = input('Translate something:') English = open('English.txt','r') Spanish = open('Spanish.txt','r') a = list() b = list() for link in English : a.append(link.strip()) if link not in a : continue for link2 in Spanish : b.append(link2.strip()) if link2 not in b : continue to_spanish = a.index(translate) translated = b[to_spanish] print(translated) to run it successfully you need my English.txt and Spanish.txt files which contain the translations but it works. 
Oh, I didn’t know that, and thought I just point you at these libs because you didn’t mention that you already tried these.
and before you say, I don't get how to upload to github (i barely use it). :P But I am sure you can figure out the indentations especially if you just use atom.
It depends on how you best learn material. Usually when I try to pick up something new, I try to get a general overview of how it works, then dive deep into the details when I need a better understanding of a certain topic. So, in my case, if I was very new to something, I would probably do the videos first to get a complete idea of the scope of what I was learning, then I would look at books. Thats just how I would do it. YMMV
Yes, we do have python installed on each windows computer at the moment. The slightly tricky bit would be trying to wrangle each python installation when we start to use libraries beyond the standard library(e.g. pyyaml). How would we ensure that every box has all the libraries we use within the company?
This (VFX Pipeline Engineering) is literally what I do for a living. The simple answer is "there is no simple answer", especially if you're working on more than one project simultaneously and these projects have different version requirements (in one of the companies I worked for we had 13 **major** feature film projects going simultaneously, spanning six different versions of Nuke, nine different versions of Maya, four of Houdini, three operating systems, and multiple customized versions of specialized libs like OpenEXR and Alembic). The best solutions I've seen have been proprietary ones, but there's a decent FOSS project called [Rez](https://github.com/nerdvegas/rez) that tackles *part* of the problem and is in use by several small to mid size shops. It does your package and dependency resolution and prepares the environment, and it works on Windows (to a degree) and Linux (to a much better degree). Basically you install everything to a central NAS "repository" (it's really just a folder structure) and you use configuration files / env vars to tell Rez about that repo. You then run a Rez command and tell it about your basic needs (ie nuke-&gt;10, maya-2014) and it figures out the required dependencies and prepares the shell with an appropriate PYTHONPATH, PATH, LD_LIBRARY_PATH, etc.; in a lot of ways it does the job of a package manager + virtualenv, but it also has some niceties like allowing your users to run off the NAS they already share access too, but also have packages cached on their local machine so that things like Maya aren't ludicrously slow. It's not the whole picture, unfortunately ... you need a way to know what the actual base configuration actually should be for each project (ie what is the Nuke version + what plugins are needed to ask Rez for, given your project, scene, and shot?), but it takes a good part of the problem and codifies it. Don't get too distracted by PyInstaller or Pipenv or Virtualenv talk; the reality is In VFX and related fields Python is the glue that holds together a lot of desktop applications that were never really intended to be used together on the same machine, much less on the same network; you can't really manage the embedded Python interpreters inside Nuke / Maya (nevermind Max and it's Jython jankyness) using the tools that are meant to manage standalone Python interpreters, though it would be nice. Ultimately every company doing this sort of work needs something like Rez, though I've seen dozens of different ways of attacking it under the hood.
pyinstaller sounds interesting. However, our environments are pretty mix and I would like to streamline that process of deploying OS agnostic code if possible.
&gt; I'm not even sure if this is possible with windows. Shared network folders is definitely possible in windows. So you can do the same thing that you are used to. **However**, if your scripts ever start to become complex and have dependencies on each other, this approach is going to cause problems. Ideally, you should store the source code for your scripts on a version control server (like git or svn) and store exports of those scripts in a package manager server (like pypiserver). That way your users can pip install the scripts that they need. If this seems like overkill, the questions to ask yourself are: * If someone accidentally modifies the code in the network share, is this going to break everything? * If someone introduced a breaking change, how easy would it be to find the change, and roll it back? * If someone relies on a specific behavior of a script and someone updates it, can they still use an older version of that script? 
Also, I did want to mention that we often write modules that we'll end up importing into other programs we write too. So it would be good that the way we distribute the program still allows it to be imported by other programs we write.
You can't use PyInstaller with the applications that OP is talking about (Nuke, Maya, etc) ... they're single executables that embed a Python interpreter inside themselves, and then get extended with Python scripting via importable modules, or modules designed to be run via the embedded executable directly. That said PyInstaller can be really useful for some of the standalone tools that artists need to launch to prepare their environment, publish files, etc., but it actually exacerbated the problem OP is speaking to, which is how to have multiple users on an enterprise network be able to discover and use a shared toolset.
Sounds similar to our codebase. We've currently solved the CI problem by throwing money at it and using bigger and bigger instances. Our tests run on c4.8xlarge instances (~$1.70 per hour), the build dir is mounted as tmpfs. While unit tests are running py.test workers consume 44G/50G of unallocated memory and 100% of 36 cores. Unit tests finish in about 6 min.
thanks @yawpitch Looks like rez or something like it is what I need. I will dig further into it. 
On a slight tangent specifically for code meant to run in standalone Python interpreters (ie the image file renamers, publish tools, etc, not not quite so much the embedded Maya/Nuke pythons that have seemingly been designed to not work well with pip), but check out [devpi](https://doc.devpi.net/), which is a local mirror of pypi to which you can add your own private projects. With it you can **pip install** your own code as if it were on PyPi, but also keep an offline mirror of everything on PyPi (very helpful for those "Marvel wants us to shut off the internet" moments). Doesn't really solve the deploy code for artists problem, but still *very* helpful for your developers.
You should give WxPython a try , just pip install wxpython will install the latest beta https://www.wxpython.org/news/wxpython-4.0.0b2-release/index.html
&gt;I'm sure you know it's obviously not one command or two. But it actually is though. &gt;But I think this explains pretty much everything. I've done it many times regardless.
Yes, I know. And your point is ... ? BTW, deque in C might be used in CPython. Not so sure for other Python implementations.
I don’t understand most of this yet :( 
Just use tk.
&gt; I think we'd be better off if we had type annotations, though they have their own potential for problems. Static typing is terrible.
We already have like 5 different ways to interpolate things into strings.
I'm glad you liked it! I'm relatively new to python so I can't give out many suggestions but I'll do my best.
I'm sorry if I gave off that vibe of "clickbait" or "idc". I wrote that I was taught two different ways and wanted to test which is better. For the record though, it's not and never was an assignment.
Anyone in the beta that can give comments on this?
This looks really cool!
Kivy and Pygame are the closest Python things to Processing (java) or OpenFrameworks(C++)
&gt; Yes, I know. And your point is ... ? `deque` will likely outperform any pure Python implementation. 
Py2exe is not really maintained any more, as far as I know. [Pyinstaller](http://www.pyinstaller.org/) is a similar tool which is still maintained, so you might want to try that. I make a tool called [Pynsist](http://pynsist.readthedocs.io/en/latest/) which makes a Windows *installer* (not a standalone exe).
it's not hard man, I started python a month ago. This pretty much asks you for an input (what you want to translate) and after you do so, it opens two txt files which have a synchronized order of words. One in English and the other with the Spanish equivalent, each in separate lines (although I don't think this matters, just as long as there are spaces between them). I then created a blank list for English words and then a blank a list for Spanish words. Then I created a for loop that goes through each English word from the txt files and Spanish words, and appends them (adds) to each designated list. Then I pretty much put a code that tells the program to match the specific English word I type to the specific Spanish word based on its location in the list. You'll get it soon enough. I am by no means an expert. 
Interesting. One caveat though: &gt; **What about Python3?** Currently, Colaboratory only supports Python 2.7. Colab has been internal-only for years, and Python 2.7 is still what we use internally. We'd like to support this, but don't yet have any ETA. 🤔
also it's not formatted. I screenshot to help. http://i374.photobucket.com/albums/oo183/XTrainusX/py1_zpsreznl6gl.png http://i374.photobucket.com/albums/oo183/XTrainusX/py2_zpsbaa6rtcv.png http://i374.photobucket.com/albums/oo183/XTrainusX/py3_zps5ndqed1a.png
subscribed because I may find this useful when I get better at python. These videos take a long time so thanks for taking the time. 
do a tutorial for the python specialization in coursera. It really is good and you can manage to do one course in the specialization within the 7 days of the free trial. 
price: your data
this seems like a cool idea and seems simple enough since it's just assigning with a library. 
Sorry for being flippant, I was a bit depressed by seeing the New and Hot queues completely overrun by people asking us to do their homework...
b.) Why would you not exercise your call option before the year for the American one?
Will do! thanks!
1) Is your program named request.py? 2) Am I being dense, or is http already installed with the standard library? 
I am planning to work on something similar. Classifying our responses to customers at work. Sentiment Analysis + Identifying Topics / Classifying conversations. 
What I am trying to work on is a python approach to a java assignment that I did. It's not like a simple ordinary concatenation but instead a string (that a user inputs something that is in lexicographic order for ex. abc) and another string (that user inputs in lexicographic order ex. abcd) then the two strings (that are user inputted) will output "aabbccd" (a merged string that will be in lexicographic order) the code is this import java.util.*; class Solution { public static void main(String[] args) { // ask user to input 2 strings String s1, s2; Scanner keyboard = new Scanner(System.in); System.out.println("enter a string."); s1 = keyboard.nextLine(); System.out.println("enter another string."); s2 = keyboard.nextLine(); // just some tests //System.out.println(s3); //System.out.println(validString("abcde")); //System.out.println(validString("aaabcde")); //System.out.println(validString("abacde")); // validate each of the 2 strings input is in lexicographic order if ( validString(s1) == false) { System.out.println("String one is not in lexicographic order, program will exit"); return; } if ( validString(s2) == false) { System.out.println("String two is not in lexicographic order, program will exit"); return; } // merge the strings String s3 = mergeStrings(s1,s2); System.out.println("The merged string is " + s3); } // call this function only after 2 strings are validated to be lexicographically order // s1 = abc // s2 = abc // return string should be aabbcc public static String mergeStrings(String s1, String s2) { char[] str1_char_array = s1.toCharArray(); char[] str2_char_array = s2.toCharArray(); StringBuilder mergedString = new StringBuilder(""); int i = 0; int j = 0; for (i = 0, j = 0; i &lt; s1.length() &amp;&amp; j &lt; s2.length();) { // loop through both arrays at the same time and compare their values // s1 = [abc], s2 = [bcd] =&gt; abbccd if (str1_char_array[i] &lt; str2_char_array[j]) { // character in s1[i] is smaller than s2[j], so add s1's character to the mergedString mergedString.append(str1_char_array[i]); i = i+1; } else if (str1_char_array[i] &gt; str2_char_array[j]) { // character in s2[j] is smaller than s1[i], so add s2's character to the mergedString mergedString.append(str2_char_array[j]); j = j+1; } else { // the 2 characters are equal mergedString.append(str1_char_array[i]); mergedString.append(str2_char_array[j]); i = i+1; // 2 j = j+1; // 3 } System.out.println(mergedString.toString()); } if (i &lt; s1.length()) { // need to add rest of s1 at position i to mergedString for (; i &lt; s1.length(); i++) mergedString.append(str1_char_array[i]); } else if (j &lt; s2.length()) { // need to add rest of s2 at position j to mergedString for (; j &lt; s2.length(); j++) mergedString.append(str2_char_array[j]); } return mergedString.toString(); } // is the input string in lexicographic order (meaning all letters are in increasing order public static boolean validString(String str) { // str = "aacd" char[] char_array = str.toCharArray(); // [a, b , c, d] for (int i = 0; i &lt; str.length() - 1; i++) { if(char_array[i] &gt; char_array[i+1]) return false; } return true; } } 
Tk kind of got broken during the python 3.5 -&gt; 3.6 upgrade. But overall it works fine, but not exactly pretty. For simple UI's it's hard to beat because it's pretty easy to wrap your head around. I'm not sure I'd recommend it for a major GUI application.
Thought for sure it was going to be "...moved to PyPy..."
Wow. That’s unfortunate and makes it a deal breaker for me 😕. 
Really cool. I gonna try.
What's terrible about being able to make promises about your code?
You reinvented an .egg file? 
Test Youtube-dl 
Upvoted. Cloud technology is the start of the next surveillance program. Further, even if it wasn't, the benefits don't outweigh the costs. Pros - You can access your media from anyone's device. - You don't use your own memory Cons - You can't access the media in any form while internet services are down. - You have enough memory in 2017 - there is no need for cloud services - even if you don't, it costs you a one time fee to buy a storage device. (It costs you monthly to have a cloud based service) - Many for the price of one (Attack one target with many users rather than target the user) - Load times are slower (I don't care if they are almost instant, they are directly related to the strength of your connection and as such aren't as fast as local storage) 
Skimmed through the post real quick so this might've been answered - but how do you determine which test cases are relevant to a certain part of the code? Especially when dealing with integration tests. 
python-google-api-client works on python 3 and does support uploading YouTube videos (at least it did a couple of years ago)
2.7 is totally fine by me
If only some of that time spent developing Colab had been spent porting to Python 3!
- PyQt5 and QML are fantastic, as mentioned elsewhere. - [PySciter](https://github.com/sciter-sdk/pysciter) is a another good one, that IMO is quite underrated (though it's partly closed-source).
I should've been more specific with the title...whoops... This packages Python applications *and* all of its declared dependencies. In addition, it's more flexible; eggs required a __main__ module, which this lets you use any entry point (and if you declare them in `setup.py`, you can just run `python setup.py bluesnow`).
Beautiful thumbnail 
First line of the screenshot shows the print statement instead of Python 3's ugly print function.
Cool to see you here! Recently used your [mask gist](https://gist.github.com/tshirtman/284f1bd71da839ada1550c51ec2c91ef) to emulate an iOS style blur: https://www.youtube.com/watch?v=KwIRVxVITEw
1) Nope. 2) If that was the case, I should get a message like "command already satisfied" when trying to install it. Anyway, I will check it out. Thank you.
Pros: you no longer have to worry about backing up your data
That's for downloading, I need uploading​.
I'd still worry about that. Maybe you don't have to worry about drives failing anymore, but you have to worry about google just closing your account for whatever reason. It's not that common, but neither a drive failure is.
Yeah, but the script for video uploading provided by Google is written in Python 2 and uses libraries that doesn't work in 3. The "hard time" I referred to is exactly trying to convert it to Python 3, something in which I am not having success.
I already heard about pyinstaller before, but for some reason I thought it worked just like py2exe. If my tester-friend is not kidding me, it works fine though. Your tool sounds interesting too, I'll make a note for more serious programs. Thank you so much man, have a nice week :)
What solver is this? My Excel skills are limited to finding p and t values 
Wow, this looks intense. Is that the whole program I was trying to create done already? Does this allow user input or is it something i' d have to modify the cells for 'friend choice ' then run it?
When I look on (https://developers.google.com/api-client-library/python/guide/media_upload), the example code looks very close to Python 3. I only see the print statement and the exception handler that need to be updated.
Yes thank you. I appreciate it, I am just not at that level yet. So it's given me something to learn which is good. Learn by doing. I probably should have asked in /r/learnpython. Thanks again 
Having to
My attempt at annotation abuse https://gist.github.com/milesrout/e0ffc2695fbe2e8bc95bf0cf02b0c89f
I'd be interested to know what it's running on. Can you run a NN on it or is it could only?
Python 3 has http in the standard library. Python 2 does not. You're using pip3, so you be on Python 3?
Not disputing your point, but in my experience the worrying really comes upfront when you're planning how to do backups. Once a system is in place it can be done with a checklist and, by that point, there's little hassle and I worry more about a cloud provider being hacked by some foreign military than about my personal backups failing.
Google now harvesting your notebook code.
Specifically though, as what: a data scientist, security researcher, scientist who does simulations in Python?… Just curious.
Agree. But httplib module doesn't work with Py3. Now it is called http.client and my biggest problem here is that I getting an error trying to install http module, so I figured I need another option. The error is the following. I run the command to install http and get a message saying it couldn't import "request" (a module required for its installation). So I install request, works fine, then I try to install http again and get the same error. Any clue?
Maybe it is something related to that. How do I check it out?
Just a normal software developer writing normal business-y stuff. The vast majority of Python usage is that. The so-called 'data science' use of Python is very niche, and the use of Python by actual scientists to do data analysis and visualisation is still niche compared to its use by programmers.
Seconding wxPython, especially if you use [wxFormBuilder](https://github.com/wxFormBuilder/wxFormBuilder) to help.
httplib was their own http wrapper. The replacement is httplib2, not a module from the standard libraries.
It's simply impossible to have the telecom infrastructure we have now (w.r.t. smartphones) without "the cloud." It's not that difficult to stuff more memory into a phone, but it *is* difficult to stuff more battery into one. The cloud offloads a lot of that power requirement to external sources.
[`pytest-testmon`](https://github.com/tarpas/pytest-testmon/) uses the `coverage` library to watch which lines of code are executed by each test. It then looks at the diff since the last test run, and if neither the test nor any of the lines it touches haven't changed, that test can be skipped.
Why do you think Python's print function is worse than a print statement?
Oh, nice, didn't think anybody would use that, it was pretty WIP… lol, never got around to fixing the issues. And your usage is totally different from what i was aiming for, love it.
Well, some hate it, some love it i guess. I've had multiple reports (on and off-line) of people who settled on kivy after trying a *lot* of frameworks and finding kivy was finally what they were looking for, and of course i also saw people go away saying it wasn't for them, i guess it's up to everybody to make their opinion. Anyway, i feel kivy is really cool for the specific use case that OP asks about, since you have a lot of room for creativity with representation and interaction.
Reddit is not any different.
Type variables and inference make that a fairly light burden though. Can you give an example of where it is hard? I seriously haven't come across one.
Think about what you want to do, Search: python &lt;what-you-want-to-do&gt; Learn.
No, it doesn't. Type inference has absolutely nothing to do with it. &gt;Can you give an example of where it is hard? I seriously haven't come across one. It's a constant pointless overhead
Cons: You have no control over securing your data. If someone penetrates the cloud companies security, your data is at risk, and you may not find out for years.
Still using a deprecated version? Honestly... I've converted thousands of scripts to v3 it really is a trivial task.
Okay so type inferencd allows me to write: printinc a = show (a+1) I haven't had to make any type annotations but the compiler knows that this is a function over things that was Numbers that can be shown. I could say: printinc :: Int -&gt; String Or printinc :: (Num a, Show a) =&gt; a -&gt; String But I don't have to, thanks to type inference. No overhead, just the compiler watching my back. This means that when I accidentally do something like: printinc "whoops" I get a meaningful error message telling me that I shouldn't pass in a string. Without it, I would be told something like '+ isn't defined for "whoops" and 1.' In python the error is "cannot concatenate 'str' and 'int' objects". Not so helpful. 
Jokes on them, reddit can harvest my shitpost as long as it wants.
Or apparently, Google deleting your files because of wrongthink.
Migrate all valid local user accounts (~700 people) from ~12,000 systems to departmental LDAP system for central authentication. Be sure to validate users against overarching but decoupled global corporate LDAP environment; accounts which exist locally but which do not exist in global LDAP should be flagged (not added to departmental LDAP - attach them to a final report for manual evaluation.) Manually extract service accounts from the resulting list for further consideration.
Are you planning on winning a "Nobel Prize" with your code and you're afraid Google is going to steal it? I'm not saying be cavalier with how you share your code and privacy, but this paranoia about Google is really fascinating.
Pythonic code scares people apparently.
/r/titlegore
 a inspiring category,thanks
Here's a code I wrote that does what I think you're going for. #This is the correct password. Change this to change the password. correctPassword = "password1" #number of tries before the user gets locked out. tries = 3 #Loops until out of tries or correct password for i in range(tries): password = input("[ENTER PASSWORD]") #password is correct if password == correctPassword: print("You're in.") break #out of tries elif i == tries-1: print("You have been locked out!") else: print(tries - i - 1, "try (tries) left.") continue If you have any questions about my code, you can ask it here or feel free to DM me.
oh damn
That's interesting. Are you saying it requires less battery to transmit 1 MiB to the nearest telephone tower than to store 1 MiB on your phone's internal storage? Got some figures you'd care to share?
You really don't understand the power of a massive pool of data do you?
Awesome! Glad to have you around. You contribute more than you realize!
Not exactly that; it takes less energy for your email provider of choice to push-notify you of a new batch of emails than it does for your phone to run a email server 24/7 (alongside all of the other services that _look_ like they're always on).
Pyinstaller also has problems around newer Pythons and newer windows. Basically, newer Python's (like 3.5 and 3.6) were built against newer microsoft c++ compilers which used a different dll model. This new dll model comes default on Windows 10 (and apparently some versions of 8.1), but not really standard on W7. You are apparently able to solve it on W7 by having the clients (the people you're distributing to) have the VC++ 2015 redistributable installed (https://www.microsoft.com/en-us/download/details.aspx?id=52685). I say all of this with "apparently" because I haven't been able to solve it yet (I'm fighting some admin issues on the computer I'm deploying to). Here's the main pyinstaller issue about this topic: https://github.com/pyinstaller/pyinstaller/issues/1566 Here's the updated usage doc that they closed the issue on: https://github.com/pyinstaller/pyinstaller/blob/38721ef440344d416e26bbaa91a0acb23d0bf948/doc/usage.rst (btw, as far as I can tell, simply building using W7 doesn't solve it either). Good luck. 
Not a pro - but that's been explained already. Let me make it real easy. When you back up your data you can verify it's backed up. When you pay a company with a guarantee of not losing your media, you can verify that you have paid a company to make empty promises.
converting print statements is so hard tho
We have around 45 microservices at our company. 99% of which are python. Keeping dependencies fresh across so many projects and teams is a big pain. In this post, I describe how we solved it. The process is 100% automated and keeps us on top of the game when it comes to security patches and updates.
Lack of Python3 is an absolute deal breaker. Looks cool though, will definitely check it out if they support 3. 
I love how Python does its best to avoid stuff like this but inversely makes it really damn easy. And yes I freely admit, this is probably the most clever abuse of code I have seen in all of 2017 (possibly 2016) as well.
Oh nice! It seems like a really well-written one and it's compatible with a lot of backends. Thanks for pointing this out, I'm gonna give it a try :)
Thanks but I already handed it in
From the thumbnail, I was hoping it was an XKCD.
Yea, I pretty much had it up in a night. Now I'm just refining it and creating my own automations. Pretty fun to come up with things to do.
what data? If you're using Google suite at work then Google doesn't have access to your data. Otherwise, it's extremely hard to parse and make sense of arbitrary and unstructured data. 
Keep practicing! It keeps on clicking a little bit at a time. I was in your spot about 6 months ago and I'm definitely still learning a lot every day. One piece of advice I would say is try to vary the sites you learn from. I spent my first couple months on just Learn Python the Hard Way and I do really like it, but it didn't complete the picture of what python can do.
Converting scripts is easy. Converting literally millions of lines of code is less easy.
I learned Python in the late 90's, right before version 2 came out. I came from Perl and PHP and Matlab. Compared to these, Python was wonderful. There were three things that I loved about it: * It was self-evident. If you chose function and variable names carefully, the Python program read like a near-English description of the problem solution. There was a story going around that some manager saw his first Python program and commented "This algorithm looks correct, how soon can you code it?" * It was beautiful. Compared to other languages, which have a host of keywords and weird punctuation, Python had almost none. Only whitespace to delimit blocks, no "public final static long long register" description of variables, just whitespace and names chosen to describe the problem. * It came with a good REPL. Combined with the simple syntax, the REPL was as easy to drive as the shell. You could print any variable's contents without using any punctuation. Without using shift. Typing with one hand. Python 3 regresses in all of these areas. It makes the language more consistent but makes programs uglier and harder to read. I see my earlier comment is at -16, so I guess other Python users do not share my aesthetic opinion.
Don't be an ass. I prefer the way that was Pythonic for the last quarter-century.
45 microservices sounds like a lot.
Thanks for replying I will check both of those out. Thank you so much 
In 2017 it is still very hard to build a server on your own for personal storage and have it easily assessable wherever I have internet
I have been able to deploy a bunch of applications to folks on a Windows network in my company by installing WinPython on a shared drive and simply running the app with fully specified paths to the interpreter and the script. Users do not need to have Python installed on their local machines. For example, WinPython is installed into C:\WinPython on a server named WBApps (a Windows Server 2012 R2 VM), and the folder is then shared, and access rights given via Active Directory security groups. On a user's desktop, I create a shortcut with a target of \\WBApps\WinPython\python\python35.exe \\WBApps\WinPython\appfolder\AppName.py WinPython itself is a portable self-contained distribution targeting scientific users and comes with many popular packages preinstalled, such as NumPy, Pandas, IPython/Jupyter, PyQT, and numerous others. It's available in a few different Python versions. So essentially I'm not distributing the app, I'm installing it centrally and distributing a shortcut to it. I'm not sure how well this translates to your scenario, but all this is just to say that such a thing works, and fairly well so far. Check out [WinPython](https://winpython.github.io/). 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
ETL data from a kafka pipe. Pump them into some OLAP, make some graphs, trigger some actions.
Yes, static typing does seem like a good idea when you look at trivial examples.
character encoding. It's super annoying. I tried to add emoji support to my [python scratchpad](http://www.github.com/almenon/AREPL) but it still can't print 🍆. How will I get users if I'm missing an essential feature like emoji printing??? ^/s https://github.com/Almenon/AREPL/issues/52
character encoding. It's super annoying. I tried to add emoji support to my [python scratchpad](http://www.github.com/almenon/AREPL) but it still can't print 🍆. How will I get users if I'm missing an essential feature like emoji printing??? ^/s https://github.com/Almenon/AREPL/issues/52
I started when Python 2.7.2 was released, so it seems you have been using 2 longer than I. I also really like Python for being self evident and expressive. I also love it's clean readability. Id be interested if you could explain specifically what changes in 3 made it less expressive/readable/etc in your opinion (I'm quite interested in programming language design, so consider this research). One reason stated for removing print was so that it didn't take a statement.
/r/titlegore
Rather than debate which framework to love or hate more, I thought I'd share my experiences which lead me to using Kivy.0 I started out with QT5 and its declarative sister language QML several years ago in order to do Android apps with an eye to converting them to Iphone. I loved the range of widgets that were available and their look. Plus the performance was pretty good. But I grew frustrated with it. First was the time lost in compiling the code each time I made a change. Second was having to learn C++. Third was with having to master three programming langiuages, C++, QML and Javascript in order to get any GUI off the ground. (I'm not a professional programmer). Javascript was embedded in QML (to handle logic decisions, and loops). And the Javascript within QML couldn't access the file system. For that I had to switch to C++. Then there was the manner in which QT raises event. Writing code that had me running up and down my widget trees just to pass along events was a bummer. I looked at PyQT but abandoned it because it still meant having to be familiar with C++ in order to understand how the widgets and the event loop worked. Enter Kivy. The learning curve for me was long. Today there are more examples, help groups and documentation which makes it easier to learn and use. Plus with the release of 1.10, performance has improved significantly and a lot of little annoyances were removed for me. Based upon my experience, here are my takeaway points for choosing KIvy vs the QT5 and its derivatives. If you are not a professional programmer with at least three languages under your belt and python is your go to language , consider kivy. Kivy's declarative language is extremely powerful because its all python. I spend far more time writing and debugging the business rules and getting the data validation and data persistence right and the passing of data to and from the widget via callbacks and event handlers than I do with tweaking the look and feel of the GUI's layout and widgets. If that time was reverse then I might be more inclined to lean towards QT5 and PyQT. With Kivy, I never leave the python ecosystem. Python's debug traces extend all the way into my business rules, the widget toolkit and even into persistence libraries like peewee. And while the range of widgets might not be as great as the QT platform, its far greater than TKinter. Also I am not as concerned about how the widgets look on each platform as pthers might be. I actally prefer that the same widget performs exactly the same way for each platform. It reduces my development time. However better widget theme support is needed and I am lead to believe that this will could happen in release 2.0. Then there is licencing to consider and I find Kivy's to be 'just what the doctor ordered'. Long and short of it, I'll trade development time versus looks any day. There are packaging issues to consider as well as access to the hardware on the smartphone. Kivy's hardware support for the iphone is not as extensive as it is for Android. And Kivy's buildozer for generating the software app only supports python2. I think buildozer and the Google's toolkit for debugging one's code on the smartphone is ummm, so so or ok for Android devices. But Iphone? I would rather a) develop a prototype on Android and b) spend the money to get a native iphone app developed by someone else rather than mess around trying to get a python3 + PyQt or Kivy iphone app up and running. And that goes for QT5 as well.
its all good pal keep up learning 
Yeah, because Jupyter is so hard to set up.
&gt;It looks like you are trying to prove man-made climate change is a hoax. Your account has been permanently suspended. -Google Colaboratory (probably)
So the niche is real time collaborative editing, basically pair programming. But yeah, I agree. I don't see why I should trust Google, and I don't see how I'm getting much out of a python 2.7 kernel, running I'm sure on some very thin environments.
OK, here's an example of the type of code I deal with. Suppose we have a power supply that takes a voltage command as ASCII over a serial port. Here's a driver in Python 2: serial_port = serial.Serial('/dev/ttyUSB0') def set_v(volts): print &gt;&gt;serial_port,volts Here's the equivalent in Python 3: serial_port = serial.Serial('/dev/ttyUSB0') def set_v(volts): serial_port.write(b"%f\n"%volts) (You can't print() to a serial port in Python 3. 2to3 is useless at this conversion.) I think the first one is easier to read. You can understand it without knowing Python. The Python 3 version is more like Perl-line-noise syntax. 
Here's a pretty functional self hosted version of this idea, https://github.com/sagemathinc/cocalc They have a hosted version, https://cocalc.com Same limitation of python 2.7, but at least it's under your control.
Could you share the links to "several Node tutorials"? Thanks!
`print(volts, file=serial_port)` not do the trick for you?
* This is uglier. "file=" is an implementation detail, and the word "file" is misleading, since it is a serial port and not a file. Tufte would say the data-to-ink ratio is reduced. * It doesn't work. Serial ports only take bytestrings, so you can't print() to one. 
I use s3.
We’re still working on converting our code base at work. It’s not been easy. Right now we’re blocked by a dependency where we have to rewrite big chunks of code to use a different library. It’s slow going but progressing. 
I agree about the repl at least. It could be ok if the repl supported syntax special syntax optimized for interactive use imo. 
I don't think it's bad but I don't think I do like it, I prefer having variables initialized , I found possible with type deductible for refactoring and static analysis tools like pycharm
I was trying to solve this issue for a while now. I even posted [a reddit question] (https://www.reddit.com/r/Python/comments/59payf/interoffice_automation_user_interface_for_python/) about this. My latest solution may work for you even better than it works for me because of a mixed OS environment: expose all your programs as RPC services. Steps: * pip install jsonrpc-pelix * Create a simple server and host it at somehost:someport on intranet. * create a method for every program you want to expose. * for client side you can either build a simple web page (jsonrpc can be called from javascript), and/or very light-weight python clients. Advantages: * RPC exposes your methods across systems, languages and operatiing systems with ease. * Central server with request/response log. No need to run around the office to troubleshoot. * Minimal to no install on the client side. Python client is literally 3 lines of code and only uses std libs. * Better security (e.g. no need to authorize user for database access, etc) Disadvantages: * not optimal for processing large volumes of data from a client PC * AJAX style calls are fairly static and client waits for server to finish request. You could fork a thread and release the client wait. 
Another weakness of 2to3 is that it doesn't convert files opened with file() to open(). I have used only file() since the docs (when 2.2 came out) said that "open()" is deprecated and "file()" is the preferred usage. But 3 went the other way, removing "file()". 2to3 doesn't fix this, or even warn about it. 
Ok I am not going to tease you anymore. All you have said is perfectly valid. But still I see no point why the deque should not be used as referential implemention in given benchmark. 😇
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython. We **highly encourage** you to re-submit your post over on there. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community is actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. No matter what level of question you have, if you are looking for help with Python, you should get good answers. If you have a question to do with homework or an assignment of any kind, please make sure to read their sidebar rules **before** submitting your post. If you have any questions or doubts, feel free to reply or send a modmail to us with your concerns. Warm regards, and best of luck with your Pythoneering!
really guys? downvoting because its fine for him? ... ¯\\\_(ツ)\_/¯
You could have an Align category for center, ljust, rjust and maybe expandtabs.
Indeed this should include all the aspects of the problem that you described, and should work for any set of students, friend choices, and roomsizes. If the problem is unsolvable, cell 13 will output "unsat". Since this is a notebook, "user input" would be given by editing the `roomsizes` and `participants` variables in cell 2. (You could make a standalone program/script out of this but if this is just something to run ~once a year, why bother?) Each participant should be listed as a tuple with (gender, friend choice). You might want to slap some bookkeeping on top of this, to keep track which student (e.g. name or student number) is the `i-th` student.
PyInstaller works fine on Python 3.5/3.6 now. Always use the latest dev version.
I think it's like when you complain about a game crashing, someone has to chime in and say their playthrough was flawless with regards to crashes.
&gt; you have to worry about google just closing your account for whatever reason Happened to me once. Was impossible to do anything about it. Couldn't contact anyone, there was just no way of getting hold of a human.
There are a number of ways to do this, though none of them are particularly robust, until you start thinking about moving off the file system entirely. The simplest is, yes, just a dumb file, but this will immediately run into problems with multiple processes, as there's no reliable way to prevent either read or write collisions. Then you can go to a disk-database like SQLite, which at least enforces the idea that there can only be one writer at any given time, but you've still got the problem of two readers both reading a count of say 21 and both then attempting to write 22... both writes will eventually succeed, but the count will be off by one. So then you can use EXLUSIVE to handle the read and increment as a transaction, but this will lock your database to all readers in all processes every time the update occurs... this will be fine for a while, but if you're trying to ramp up to lots of simultaneous processes it will rapidly become a performance problem. So then you can move to an in-memory database that auto increments on read and gets flushed to disk... this is where things start to get robust, but this requires a server process that all your others connect to, so the complexity goes up quick. The main thing is defining what your actual scale requirements are (how many simultaneous processes) and how robust your solution needs to be (if the count gets corrupt, how bad is it? Do you need to retain state across things like power failures? And so on).
So if i were to copy this 'raw code' into pycharm it would work? &gt; You could make a standalone program/script out of this but if this is just something to run ~once a year, why bother? Ideally If this works, I could begin using it for all the excursions (perhaps 12 a year) in which this program would be useful, so having a standalone script/ability for me to have teachers (or students) enter their preferences would make it perfect. I am currently reading through [Think python - How to Think Like a Computer Scientist](http://greenteapress.com/wp/think-python-2e/) and learning in Python 3.6. Do you think this book would give me the skills to be able to create this code/interpret it myself/update or would you personally suggest something else? I am blown away that you did this off the cuff as a brain teaser. You have just validated my thoughts about how beneficial teaching students CS is (the pattern recognition, problem-solving etc). 
Are you the author?
I haven't started doing any threading yet. Well, I have but my attempts were largely unsuccessful and I decided the feature wasn't really necessary right now anyway until I learn more. Nothing detrimental at all will happen if the counter fails to write, it's just a hobby project that no one but me will be using. The class I'm in is pretty basic and, due to the context of it, we've learned how to read from a file but haven't done any writing to file yet. I could ask my professor for help, but he's kind of a slacker and I worry that he won't want to spend time with a non-class-related project. I guess what I'm asking is, what's the dumbest way to do it with the least fault tolerance?
No, it's not. All you need is hardware, internet connection and right choice of Linux distribution (i.e. Freedombox, Yunohost). Dynamic dns client included in the distro makes sure your computer is always accessible from the outside. 
&gt; By clicking the button above and installing moviesFriendly Search Chrome extension, I accept and agree to abide by the EULA and Privacy Policy. WTF?!?
download guide at : https://www.youtube.com/watch?v=NoyApKuAggg
Code provided by Google for uploading has both httplib and httplib2 as requirements. Beside that, I've read that http.client is the replacement.
I know you are giving it away free and all, but you ought to choose a better file host. The current one is shady af
Could you please upload it to Yandex.Drive?
Dumbest, and least fault tolerant, would be: import os def run_times(): c = 0 if os.path.isfile(PATH): with open(PATH, "r") as f: c = int(f.read().strip()) c += 1 with open(PATH, "w") as f: f.write(str(c) + "\n") return c print("I've run {0} times".format(run_times())) Where you'd have to define PATH as whatever path you want to use. But that is really dumb, and really fault intolerant.
Google has millions of lines of inter-dependent Python modules dating back from its earliest days in 1998. You don't just run 2to3 on that.
I tried it, but loading and downloading your data is a nightmare.
I started at 1.5.2 and has followed along ever since. Some of the changes does not really add much to the language, but i dont find that python 3 is a regression. I still love coding in pythin every day. If it hadnt changed from 1.5.2 i would probably love it just as much. But i would miss iterators.
I’ve made attempts to use pypy but has run into problems and then when parts of the product work I got no speed ups. But that was a long time ago. Will probably give it another shot at some point. 
Yes, the code/input cells together make a script. You'll need to install `z3-solver`, though, and for that I recommend `pip`, the *de facto* standard package manager for python. The book you linked to seems pretty comprehensive and I think it contains the material you need to understand how to make a standalone script out of this, which for instance can read a file where you list each each student and their properties on a separate line. Or you might "cheat" and use the `pandas` package to read a CSV, TSV or Excel file with input data ;) In that vein (using already-existing tools for the job) it was also easy for me to solve this; recognizing that the problem you posed was a right fit for a constraint solver, I used Z3, which basically does all the heavy lifting (i.e. it uses sophisticated algorithms to figure out whether a solution exists and what that solution might be). As you can see in the rest of this thread, others have suggested (partial) solutions where the heavy lifting is much more exposed as part of the python program. To summarize, making a reusable python program that takes arbitrary input and furthermore does things such as the bookkeeping of student names/numbers will be trivial once you understand the basics of python, and the book you mentioned (and /r/learnpython) will surely help you progress in that direction. I hope you will enjoy that journey! Or, if anything, at least the benefits it will bring :)
Try Conda. Its standard package repository is more geared towards Data Sciences than VFX, but it has many advantages: * Works perfectly across Windows, Linux and OS X * Many important packages precompiled and up to date (lxml, Pillow, etc) * Support for self-contained virtual environments to keep dependency conflicts in check. * Atomic updates (no broken half-upgrades!) * Lots of important non-python packages (openssl, pixman, libtiff, libpng, etc) Note that conda virtual environments are a bit different from standard python virtualenv (created before virtualenv was standardized) but they essentially perform the same function. For any packages not included in Conda or for your own apps you can simply pip-install them inside the conda virtual environment or create a new Conda package. I think atomic upgrades will require Conda packages, though. Your packages can be hosted on repo.continuum.io. IIUC, all this is available for free, but you may find use for Anaconda's paid offerings. Keeping everything installed locally (with a robust automatic upgrade system) instead of using network shares should improve performance and avoid upsetting users. You can test upgrades before roll them out, keep specific users on older versions, give certain users bleeding-edge beta versions for the features they need, etc.
Fuck off Google!
Holy shmoly they finally updated the website! Last time a looked a couple of months ago it had an eye-searing 90s look to it.
Oh yes they did :D, https://wxpython.org/news/new-wxpython-website/index.html Still need a logo
Thank you! I'll give this a shot. Could I do this without importing os by just placing the file in the folder with the program or is that being used somewhere else that I don't understand yet because I don't know jack?
Never did any Python courses online, so I don't have any opinion about their quality. The only Python related videos I've watched are talks by Python affiliated people. Here is an example https://www.youtube.com/watch?v=LsfrMjcIudA But of course these are a bit complex for a beginner. I suggest starting with the official Python tutorial, especially if you have a little bit of programming practice.
Never code for free. Devalues yourself and everyone else. Go make forks on github! Improve stuff :D
FYI, might want to read the fine print first: https://www.google.com/intl/en/policies/terms/ &gt; When you upload, submit, store, send or receive content to or through our Services, you give Google (and those we work with) a worldwide license to use, host, store, reproduce, modify, create derivative works (such as those resulting from translations, adaptations or other changes we make so that your content works better with our Services), communicate, publish, publicly perform, publicly display and distribute such content. The rights you grant in this license are for the limited purpose of operating, promoting, and improving our Services, and to develop new ones. This license continues even if you stop using our Services (for example, for a business listing you have added to Google Maps). Some Services may offer you ways to access and remove content that has been provided to that Service. Also, in some of our Services, there are terms or settings that narrow the scope of our use of the content submitted in those Services. Make sure you have the necessary rights to grant us this license for any content that you submit to our Services. &gt; Our automated systems analyze your content (including emails) to provide you personally relevant product features, such as customized search results, tailored advertising, and spam and malware detection. This analysis occurs as the content is sent, received, and when it is stored. So you own the copyright but you're granting Google a worldwide unlimited license to do whatever they want with it.
It's not deprecated though.
the more and more I learn about python, the more and more I realize you can do so many things with it. this is just one of those things, but it is creative. kudos.
Hey. Thanks. Yes I just gave my environment path as an argument and it worked. Thanks.
You could eliminate the need for OS if you ensured that the file was present before you first called the function. You could also modify it slightly and get the file created for you automatically. def run_times(): c = 0 with open(PATH, "a+") as f: f.seek(0) c = int(f.read().strip() or 0) c += 1 with open(PATH, "w") as f: f.write(str(c) + "\n") return c But, as I've said, this is *not* robust. If you, for instance, set two different python sessions calling this in a while loop, you'd see the problems pretty quick.
The king of the hill really is AWS S3, and it's got good Python integration. Google is also very good. Dropbox of course includes all the nice app features, which isn't a priority for the other two.
Not exactly programming, but I’m teaching my girlfriend how to use python this week, so instead of coding I’m mostly getting ready to teach her
Works as intended, thank you a ton. Something I'm not understanding - why does the "c = 0" at the top not reset the counter each time?
Actually I've edited it, that's no longer necessary, as **c** is getting set to 0 the first time the file is read, because it the file is blank that **or** returns 0 to be the starting value for **c**. In effect it is resetting it every time, but then it's being overwritten back to the value currently in the file. The original reason for setting **c** to 0 was just to provide an initial value for the first write to file if the file didn't yet exist on disk to read from.
I saw that right after I posted, it gets redefined in two steps anyway. It's late. Not sure why my post is being downvoted, I'm just trying to have some fun with python. Thanks for helping, I really appreciate it.
If you receive the values like so: 10,20,30 What you can do is that as you read the serial line, do the following: x, y, z = data.split(',') That way, each value is being stored in different variables. 
&gt; the word "file" is misleading, since it is a serial port and not a file Everything is a file.
I actually find the Python 3 version much clearer. The Python 2 version is ambiguous (reading without knowing Python for arguments sake) between writting volts to serial_port or serial_port to volts. Anyone at all can understand the Python 3 version. Though I agree the Python 2 version is more concise.
Look at this: http://www.informationisbeautiful.net/visualizations/million-lines-of-code/ Without being able to divulge any numbers, a significant portion of that is python 2.7 Do you still think it's a trivial task?
Don't do that then. Put the information on a storage device. You are under the impression I think remote hosting is useful for personal use - that is not the case.
You're all free to your opinions regarding Google, I'm not here to defend the corporation. But having used this since I started at Google little over a year ago, all I can say is I'm a fan. And I'm excited to tell my friends that they can now use this tool too.
Good to hear! My job tends to frown upon using dev versions, but I'll go take a look. 
Monitor generic email account to assign incoming attachments to jobs and process them accordingly. Also using the same email account to allow colleagues to trigger ad-hoc jobs and have results emailed back to them.
Converting the syntax yes, but fixing logical errors can be more complex. Especially when using modules
Seriously Thank you. I will keep studying and hopefully get to a point where I can completely build this myself. I downloaded [Z3](https://z3.codeplex.com/releases/view/135729) however I'm finding conflicting info on how to install it (well to install 'PiP' for that matter. Is there anything I can do to repay you for your help mate? Wouldn't happen to be in Australia at all?
I think I'll stick to running my own Jupyter service. There's little point using it since if it becomes popular Google will undoubtedly shut it down... 
There is way more to it than that.
That's a real stretchy interpretation of Tufte.
I have thought about standing up my own Jupiter service on one of my servers. Any advice on what packages to use, preferably using Anaconda?
It might be useful summarising all the proposed solutions. My recommendation for package deployments is developing submodules and then sharing them using an internal Python package index. I wrote a customized index server a while ago since I wanted to dynamically expose python packages stored in GIT repositories to all our developers. Basically our workflow looked like this: - push package changes to private bitbucket repository and only tag installable version. - set pip to use our internal server and then it to install the latest tagged version. [Here's the server implementation](https://github.com/chriscz/mpypi) and a linux [example implementation](https://github.com/chriscz/mpypi-scaffold) for the bitbucket case. *Note*: There are many other PyPi server implementations, I just wanted to make mine simple and dynamic/programmable from the start.
link to the underlying document: https://docs.google.com/gview?url=https://img4.file-upload.com/cgi-bin/dl.cgi/53ji2i7zasvmhcn3agdiag2js35lmvmexlkpdkvhlfjd3op6xuxpega/fnf9wdw0gor3.pdf&amp;embedded=true 
Not very pythonic. Getters that basically do nothing, camelCase where snake_case should be used. Also misses the normal disclaimer when talking about linked lists: "this is almost always the wrong thing to use"
Would have to see the code. It's certainly possible to write something that works only as a command line tool.
Switch languages.
&gt;&gt;&gt; "this is almost always the wrong thing to use" Oh, is it so? Please, explain... This is probably heavy blow to the face of Fsharp and many functional languages as well. I bet they regret not having your insight sooner. &gt;&gt;&gt; Lists in F# are implemented as singly linked lists, which means that operations that access only the head of the list are O(1), and element access is O(n). https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lists Those poor bastards, such fundamental error. 
Maybe some itertools https://docs.python.org/3/library/itertools.html to get rid of some nested loops. 
If you want a "self-hosted" thing, just download Jupyter and run it yourself. If you want to share it, you can enable the access controls and open it to the internet. Cocalc (and Sage in general) are for people who want more than just Python notebooks - Sage is a computer algebra system and collection of interfaces to other computer math systems, for when you want to do serous math work.
Canonical made an ORM pretty similar called Storm, I wonder if that is still being maintained. It wasn't bad syntactically from what I remember. 
Your missing the point, Jupyter notebooks do not natively support concurrent users. If you have one notebook open on two browsers, and edit the notebook in one browser, the other browser is not updated. That's what collaboratory, and cocalc is trying to solve, a Google docs like collaborative notebook session. 
As far as what python packages to have, you should just install everything you want to use (and the dependencies of Jupyter, of course.) If you plan on doing some intense Numpy computations, you should compile Numpy on your machine. Once you have installed Jupyter, you can play around with extensions. https://github.com/Jupyter-contrib/jupyter_nbextensions_configurator is a good extension to start with, because it will help you configure other extensions, to add things like codefolding. 
Really great!!!! Thnks!!
Functional languages are different. Also mostly super slow. To make F# fast you rewrite it to use dynamically sized arrays and mutable code. Or if you’re lucky the VM/compiler does that for you under the hood. 
It looks like the ORM space for Python is getting diluted: * PonyORM * SA * Peewee
For better understanding pls show the code. (Both-.ini -.py)
Any code in a `if __name__ == "__main__":` block doesn't run when imported because __name__ is different for imported files.
How can i be as good as you guy?
[removed]
So, there's a few things here. The first is the way you're accessing your NumPy matrices. You'll want to use [slices](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html) to do this. It will let you get rid of your xdir and ydir loops entirely. Next, for you need to figure out how you're going to select the places where the neighbors match. NumPy's [where function](https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html) works for this. Between a where function and slicing, you should be able to get rid of loops entirely. Let me know if you get stuck, just post what you've got. 
 Guess I could make a wordpress website ?
What do you mean by "pen"?
Oh. My. Gosh. Why do so many people go so crazy about linked lists?! Damn, this is yet another data structure, like arrays and structures! There are tons of questions about linked lists on Stack Overflow, if you google "linked lists" you get loads of posts attempting to explain this concept while treating the readers as total dumbasses, there are a heck of a lot of videos about linked lists on YouTube. What's up with all of this?? Every freaking newbie in programming absolutely has to try to implement a linked list and face a ton of problems and then f*** around asking for help, many of people who are familiar with linked lists feel the need to tell others how good this data structure is and add tens of useless explanations to hundreds of existing ones. Why???
I always thought in visualize all stuff like (mental map) i used free app for that (SimpleMind Free - Android OS) 
holy shit
 to what extent are we arguing that horses drawn carriages are much more elegant than those new fangled cranked cars?
what dictionary are you planning on using for your sentiment analysis? Also, if your work is hiring for a Junior Developer, sign me up (:
OP here. I must mention that there is no notion of a database here. The ORM is for Python objects in the memory. Maybe the usage of "ORM" in this context is confusing.
open! Sorry, typo haha.
Canonical Storm is a database ORM, which is not what my library is about. See my reply to @metaperl's comment.
By "open", do you mean "open in the browser that the repl.it shell is open in"? I don't think so, no.
Dictionary can be found here - http://nealcaren.web.unc.edu/an-introduction-to-text-analysis-with-python-part-3/ [Positive Words](http://www.unc.edu/~ncaren/haphazard/positive.txt) [Negative Words](http://www.unc.edu/~ncaren/haphazard/negative.txt) We are not involved with Python as much. This is more of a personal project - on my own time. So no such openings.
Uh-oh, my lazy editing has been exposed! I've updated the author's post to be more Pythonic. Thanks for pointing that out :)
Google doesn't like using up-to-date code unless it's their own.
Ahhh so your one is more about keeping track of just regular objects rather than offering an abstraction for addressing databases. Makes sense
And this is why I have continued to move more and more of my personal stuff away from Google. You are the product. Me, I would be willing to pay for a service. But I am at the point where Google is more scary than almost any other tech company. 
That is interesting, but not the part where they can do whatever they want with the code you post? I guess you must live in a world where you share all of your toys.
Google is quite famously known for sticking with Python 2.7 without giving any road map on a migration path.
You could just rickroll them, but what all this has to do with Python?
But why would I want to give my notebook to Google? I'd rather start a remote notebook server and let others connect.
I am making a script that goes 'ping'.
Much better! 
True. Wasn't sure where else I could post this at. This is the only thread I'm subscribed too. 
Can someone speak to the things you can't do because it's python 2.7 and not python3?
oh I missed that entirely. I wonder if there could be few alternative approaches to this, that would save you from creating a new codebase: * use an in-memory SQLite database [as shown here](http://docs.sqlalchemy.org/en/latest/orm/tutorial.html#connecting) * create a driver for a memory-based database (I think these are called Trevayler databases) or mock one up. &gt; Maybe the usage of "ORM" in this context is confusing. The "R" stands for relational, but in your case it is relational but not a relational database.... but I immediately presumed it was for RDBMSes instead of looking closely. 
Your problem doesn't run for starters. Depending on the length of each range loop, it can be far more efficient to resort the loops.
I have the same experience myself. Unless you know what you are doing, what I rather dont :), it is superslow to create any immutable persistant datastructure. It requires probably different mindset. I just wanted to point out that single list might be used heavily under particular circumstances, if splitting your datastructure in head-tail pattern. "always wrong thing to use" statement seems rather overkill to me :)
I think he meant in Python. Between standard `list` and `collections.dequeue` most linked lists use-cases are covered.
Numpy vectorized code will be roughly 500x faster than itertools.
Python 3 was released two years before 2.7. Why was it written in 2.7 in the first place? And I've converted several million lines of code. It's not necessarily trivial but neither is it an enormous undertaking. You don't have to rewrite it so that it utilizes all the latest/best/better code/style/functions just get it running correctly on the v3 interpreter, and whenever you make code changes you then rewrite it better. Converting allows all new/changed code to utilize the new interpreter; otherwise you're stuck in v2 forever. What I'm really trying to say is why are people still building projects in v2 when v3 has been out for almost a decade. v3 was clearly intended to replace v2. If people had been more supportive over the last decade and helped to improve v3 instead of whining about the changes 2.7 might never have been necessary and all of that development effort could have been put into v3.
This! Thanks :)
Deprecated in software development means that something is in process of being replaced. Python 2.7 has a hard end of life date set. Just like when you make a breaking change to an API. You mark something as deprecated to inform users that you intend to remove that feature in a future release.
I know what deprecated means. Python 2.7 is not deprecated and it's not going to be for at least a couple of years.
&gt; you should compile Numpy on your machine. You will also need to compile Scipy, Matplotlib, and many others. It can be nontrivial. Or you can just use Anaconda/miniconda, and have access to thousands of prebuilt packages. Completely free, MIT licensed. 
Not hotdog
This seems...surprisingly robust (save for data volume limitations)...but allows the existing workflow to persist unaltered but integrated with the new RPC server.
:) seriously, you are welcome, I'm happy this is useful to you. I realize I might've thrown you in the deep end with Z3, even though I think it's the "right solution" to your initial problem. It seems `pip` nowadays comes with (recent versions of) python, but in any case the python package installation instructions can be found at https://packaging.python.org/tutorials/installing-packages/ Furthermore, I remembered that you are using PyCharm and while I'm not very familiar with it, I think there might be PyCharm-specific ways to install packages, see e.g. this thread: https://www.reddit.com/r/learnpython/comments/2j9wlh/how_do_i_use_pip_to_install_things_while_using/ The Z3 package for python (`z3-solver`) can be found at https://pypi.python.org/pypi/z3-solver/4.5.1.0 but installing it should be easy, either with `pip`: `pip install z3-solver` or using PyCharm's package browser (https://www.jetbrains.com/help/pycharm/installing-uninstalling-and-upgrading-packages.html)
Yes, this is possible.
Continuing work on my [real-time python scratchpad](https://github.com/Almenon/AREPL). [**demo**](https://raw.githubusercontent.com/Almenon/AREPL/master/arepl%20demo.gif) Progress is going good - I've fixed the issues that were pointed out last time I posted to /r/python, and added some new features as well. But I'm having trouble with marketing - I get a positive response from the people I talk too, but I havn't gotten any users yet. 😕 And this is a free open-source application too! It literally costs nothing to download and at ~50 megs is as light as an electron appliation gets. (*insert joke about heavy electron apps*). I have no idea how people convince others to pay for their software when it's this hard to get users for something that's free.
You get a decent copy of Numpy etc from Anaconda, but for top speed you should really figure out the compilation yourself for your machine.
But it's trivial!
Which is why I said “almost”. 100% of the used of linked lists I’ve seen in Java and C++ have been wrong. There are many that are correct of course, just very rarely in code normal people write. 
How? Any tips or guide. Just a hint? 
"Programs must be written for people to read, and only incidentally for machines to execute." The Python 3 version has a lot that is only meaningful to the interpreter. If you didn't know Python, what would you say the "b" character is doing there? The "f" character?
Right? I feel this way about programming in general. It's helpful that there are already so many libraries and modules you can import which do a lot of the heavy lifting for you so you can jump into completing programming projects you've been dreaming of. I have to remind myself that "Where there's data, there's a connection"
I think it comes up in interviews a lot. 
Hey, did you ever use that YouTube API? Now I am needing some help with the "client_secrets.json".
This is the first time I've used the downvote button for what it stands for.
Well, you should be careful with such omnipotent statement :) Internet is full of flamewars backed by many misinterpreted sentences. :)
Except it's not crashing, it's just running on a version *people don't like*. 
That's the wrong question: it's not that you can't do something in python2.7 or visual basic 5 or cobol 68, it's that it's harder and others don't want to continue to work in a dead-end.
You could just make a Web page and link it. Best piece of advice I could give though is don't waste your time on them. I was bullied in school, so I can understand you want to get back at the people hurting you, but ultimately you aren't going to better yourself. The ultimate revenge is years down the line when you're earning a considerable amount more than them and enjoying life, while you see them stuck in a job they hate with very little skills to their name. So learn, get better at a profession you enjoy and just let them go, or they will affect your life after school is over too. 
It’s even more full of people misusing linked lists because they think it has faster insert or takes less memory. 
Thank you for pointing these out
Seconding this. His/her functions are likely dependent on global states that haven't been set yet, because they were set in main. I would recommend rewriting the code to be more 'functional' - (not need any global states) or have those states set not in main. If you still have problems, you can post the error for further diagnosis. 
It looks like you're doing a convolution. Scipy's [ndimage library](https://docs.scipy.org/doc/scipy-0.16.1/reference/ndimage.html) has a bunch of features for that. You could use the `generic_filter` to create a function that counts the number of neighbors greater than the center point. Check the various inputs carefully because the mode and constant will be important. This [stack overflow question](https://stackoverflow.com/questions/10996769/pixel-neighbors-in-2d-array-image-using-python) has an answer that gives an example of how to use the generic filter. 
I have edited the main post and added the code
I'm an old dev, but a new python user, so I haven't tried it yet. My stuff is mostly python 3.6+ (I'm addicted to ordered dicts by default), and of a nature the extra speed wouldn't help me. But, that seems to be the upshot of so many posts with titles like yours. That said, I enjoyed the read, and am looking forward to implementing the "on demand just whats needed" testing into my own projects.
So, this is not answering the question (others have already done so), but one option for something like that would be @numba. It's potentially faster than vectorization in this case by avoiding allocating intermediate values. It's also a potential one liner change. import numba as nb import numpy as np def f(I, xneighb, yneighb): O = np.zeros_like(I) xdir, ydir = I.shape xdir -= xneighb ydir -= yneighb for i in range(xdir): for j in range(ydir): for m in range(xneighb): for l in range(yneighb): if I[i,j]&gt;I[i+m,j+l]: O[i,j]=O[i,j]+1 return O f_c = nb.jit(f) input = np.random.rand(800,800) f_c runs in 15ms, f in 3s
OK, would you mind to elaborate?
Like glitch7789 said, believe us that it's not worth your time. These people really get hit hard later in life. You will win if you stay in a higher moral character than them. What separates you from them if you antagonize them? 
Depends how you are receiving the values, are they in a list, dict, json, etc.?
I keep meaning to learn more about making a C interface. This is really interesting - very clear and simple example to illustrate the concepts. One question I had - you mention memory management here. Do you need to do anything special to delete the C object or will just removing it from the Python scope cause it's memory to be freed via the next GC?
Don't waste your time. Focus on a more productive project, one that you could show off to employers instead.
Cython is your friend! I wrote a wrapper for a C library using ctypes and found the performance to be quite abysmal. Switching to Cython greatly improved performance. There were quite a few touch-points between Python and C, so minimizing overhead across that boundary was very important.
How do you migrate data accounts?
I just started this course: * http://www.fast.ai/ 
fast.ai is great, highly recommend 
It seems great, but I think it's starting a bit above my level. Any suggestions for something that builds me up from beginner first?
What's your math background?
Official supports ends in 2020 but third party support will go a bit further. Still a new codebase should obviously try to avoid it.
I would disagree with your understanding of deprecated because it is definitely deprecated. Perhaps you should lookup deprecated and obsoleted as they are in fact different. Only security/bug fixes are being released for 2.7 no new development. In all earnest python 2 was deprecated when python 3.0 was released.
Do you mean something like this? * https://docs.python.org/3/library/pathlib.html#pathlib.PurePath.parts 
Centralized nfs shares. Let the users sort their data out. 
My background is in biology, so I could probably use a refresher on math. I've taken math and stat classes, it's just been a while.
If you are using python3, use `pathlib.parts`. from pathlib import Path old_dir = Path(r'd:\stuff\casenumber\images\evidencenumber\file.blah') parts = list(old_dir.parts) parts[3] = 'images' # replace the 4th component with 'images' new_dir = Path(*parts)
Google.com :P
Do you have to swap it? It's very easy to use format on a base path e.g. 'd:\stuff\casenumber\\{} \evidencenumber\file.blah'.format('findings') 
I really enjoyed these two courses when I did them a few years ago. Also, it looks like they use Python 3 now! * https://www.edx.org/course/introduction-computer-science-mitx-6-00-1x-11 * https://www.edx.org/course/introduction-computational-thinking-data-mitx-6-00-2x-6
There also a few “just used cython for an inner loop”. I can’t wait for 3.6 myself. Ordered dicts is a big deal. 
google told me that insertion is O(1) in linked list. Try better!
You should read closer. O(1) can be 10 seconds per insert. That would make it the slowest thing on modern hardware. Big-O isn’t everything. In this specific case dynamic arrays are amortized O(1). Oh, and the O(1) for dynamic arrays is hundreds of times smaller than the O(1) for linked lists. No memory allocation for the node means huge time savings. Go into a C++ project and compare std::vector with std::list and see for yourself. 
Why? There's an API: https://xkcd.com/json.html
OP, listen to this, it's great advice. Even better, look forward to the times when you won't even remember petty annoyances like that one.
First, this should be in /r/learnpython Second: &gt; Is there a more efficient way to transfer the data directly from rtf to csv? probably! But you need to tell us more about the rtf file. Is it delimitated? Is it well-formed? (no missing columns, etc). Does it even lend itself to columnar data? (rtf is just a file format. Says nothing about the contents. You could save a book as rtf, but that doesn't mean it makes sense as csv) How are you converting from rtf to txt? It sounds like line endings are getting messed up. 
Most likely it is a matter of newlines and operating system. Linux files use \n to signify a linechange. Windows uses \r\n for the same. If you open a linux style file in a text editor on windows there is no line change and it all ends up on the same line. If the \n is still in the file you can just set the line seperator to that directly in pythons csv module. Alternatively you can do a st = st.replace('\n', '\r\n') to make it look right under windows.
[Hiring] Python Developer - Irvine, CA - Contract, possible direct-hire - $57/hour (DoE) This role would be working with one of our largest medical device manufacturing clients on a cutting-edge real-time imaging system. While the core technology experience necessary to be successful in this role is Python, this application will be a multithreaded C++ application and our client is building the GUI using Qt. The full job description is listed below for this role: **Primary Qualifications:** - 5+ years of experience of Python development - Previous C++ development experience for multithreaded applications - Experience doing GUI development using the Qt framework - Experience developing Windows applications, stress testing and performance profiling - Experience with real-time system concepts, programming, and debugging - Experience using GIT **Plusses:** - Machine learning frameworks: Theano, CAFFE, TensorFlow - Medical Device Software Development Management tools: Jama Doors **Day-2-Day:** - Insight Global is looking for a talented Python Windows Application Developer for our Medical Device client in Irvine, CA. You will be working on a real-time imaging system, developing the GUI using the Qt framework and doing the testing and debugging as well. We are looking for a creative thinker and problem solver to join this exciting team and project! If you or anyone you know would be interested in an opportunity like this, please message me directly!
Exactly like that but Im forced to use 2.7 right now unfortunately
A sequencer library for algorithmic composition. Based on functional programming ideas. Basically a way to proces lists of dicts.
Thanks for the tips Ill be checking out /r/learnpython Unfortunately I am using Python 2.7 so im a little limited.
I dont have to swap it I just need to easily jump between the 2. The big problem is that the casenumber and evidencenumber are obviously not static so I cant really hardcore it 
me irl
 pip install pathlib * https://pypi.python.org/pypi/pathlib/ 
You mean trivial? I actually already completed it: https://github.com/StarRat/Python/tree/master/python/Audio/ping
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [StarRat/Python/.../**ping** (master → 60f781b)](https://github.com/StarRat/Python/tree/60f781b312d90bf1d7aae4d1394eb38e0b8ede87/python/Audio/ping) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dphk6m4.)^.
No, use pathlib2. Read the second line in the link you posted. 
As someone who only dabbles in Python, the first one to me seems ambiguous because I don't know what volts is and it seems like its on the caller to provide a value that serializes to the way the device specifies. The second version reminds me more of the printf statements I've used in other languages so I can infer its explicitly defining how to write to the file. I'd have to look up the syntax as to what that serialization is but I feel more confident its writing it in the way the device expects.
And your Excel code example, you are only comparing column 1. In your CSV code example you’re comparing the entire line. In your notes you say you want to compare column F, or the 6th column (index 5). Which is it?
Hmmm I guess you could do a really ugly split: import os old_dir = r'd:\stuff\casenumber\findings\evidencenumber\file.blah' drive, path = os.path.splitdrive(old_dir) parts = os.path.normpath(path).split(os.path.sep) parts[2] = 'images' # replace the 3rd component with 'images' if drive: new_dir = os.path.join(drive, os.path.sep, *parts) else: new_dir = os.path.join(*parts) 
&gt; Python 3 was released two years before 2.7. Why was it written in 2.7 in the first place? What I meant to say was of course that it was written for Python 2, which has naturally become 2.7 because of backwards compatibility, not so with 3 yet. &gt; just get it running correctly on the v3 interpreter Therein lies your first false assumption, look back on that link I gave you, if Google consists of 2 Billion lines of code (In 2015), and some significant portion of that is Python, we're talking millions and millions of lines of code. Add to that, that we run our systems on a planetary scale. We have our own IDE, we have our own systems for building, testing, distributing, etc. If it's not obvious yet, the way we do things is extremely customised for better or worse. It's not just getting the code running in the standard interpreter, it's getting the code running in our environment. Two entirely different cases. &gt; why are people still building projects in v2 when v3 has been out for almost a decade Standards. If you have a many-million line python2 codebase, starting to just sprinkle python3 in there would be a nightmare. Couple that with the above point, all the tooling has to support python3 as well, and it simply becomes a non-option. All that said, I'm not saying it won't happen, I hope it will. Until such a time comes, I will be following all the style guides at Google, which tell me to write projects for python2.
Does that mean a W7 target won't need VC++ 2015 redistributable anymore? That would be actually pretty helpful...
Awesome! I was thinking of doing something like this or a simple find and replace string manipulation. I will always be swapping images for findings those 2 words are constant. 
OH. Then just use a standard string replace: new_dir = old_dir.replace('\\findings\\', '\\images\\') This assumes you always have your path separators as `\`, never `/`. You can use `normpath` to convert `/` to `\` if that's not always the case. 
Sorry about that! The data in the rtf file is organized in tables. For example, one table is the min, max, and average for time performing different tasks. I'm converting the rtf to txt throughTextEdit itself. However, when it converts all of the column titles, row titles, and values form one long list in the new text file. I was trying to then use python to create a delimitated file with it organized correctly, and then use that to create a csv. I just didn't know If anyone knew of a more efficient way to do that.
Awesome! Thank you so much. I really appreciate the help. I knew it was something simple like this. Hopefully soon I can start returning the favor to this community.
Does this seem like the type of project that would benefit more from a new programming language or from a couple of hours with a spreadsheet?
OK, thank you. Everyday has something new :)
Have you tried CFFI?
I meant in general actually. But what you said is very true in the specific case of course. 
Fair enough. I’m not sure. I’m new to performing analytics with Python which is why I’ve posted the question.
Hmm, this seems too simple. I use a near identical strategy and end up with mismatched versions. I've suspected it's from modules that specify "setup_requires" requirements without a version, so pip pulls in some arbitrary one, probably the latest. Not sure. Anyhow, I find Pypi/pip/module complication to be too flakey to depend on. I ended up creating a wheel for every module and simply checking those into our projects. Fixes the above PLUS you get 100% reproducible deploys. 
No bokeh plot :-( 
Can you explain?
Explain what? Under the centralized system, all users' centralized home directories are mounted on all machines. Their local home dirs are moved aside. They manually migrate any data they want to from the old home dirs to the new ones. Unless I am misunderstanding what you mean by "data accounts"
The whole point of fast.ai is that it puts you in the driver's seat immediately. It let's you learn about what kinds of ML algorithms there are first and then later on gradually goes more and more into mathematical detail. I am a biologist as well and really enjoyed that aspect of not being beaten to death with math right from the start.
You could analyze the words on the notes using an algorithm or you could enter what you believe to be the theme of each note and save it in a dictionary as the key, with the value being the number of occurrences. I really don't think it's worth it because you could use pen and paper for that. I think mudclub is right with this one. Unless you really want to put hours into this project.
https://www.facebook.com/groups/pythonears/?ref=group_browse_new is great. https://www.facebook.com/groups/python.django/?ref=group_browse_new is great if you are into web development.
1. Read the docs. 2. Follow any tutorials in the docs. 3. If you don't understand something, go to stackoverflow. 4. If you don't want to do step 3, go to step 1. BONUS: Once you feel like you are starting to really understand the material, go answer questions on the stackechange. You'll find out real quick what you do and don't know. And, you'll be helping someone that followed step 3 in the process :D
There's no accounting for taste.
Cool! I'll check all these out.
My project and my pet project: building complete terrarium automation for my monitor lizards with Python and Raspberry Pi. Started with automated natural sounds playing scheduled by time of day. Will then move to sensors and power control to simulate day/night/heat/rainfall. I got it automated already, but with different solutions. Now unifying it with smarter platform with reporting capabilities.