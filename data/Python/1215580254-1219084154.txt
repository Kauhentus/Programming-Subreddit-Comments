see also: http://jarrodmillman.blogspot.com/2008/07/scipy-2008-conference-program-posted.html
A great many of these can be summarized as "don't program C/Java in Python syntax." It's a shame that most colleges default to Java as a first language rather than start with Python and descend to the lower-level stuff to show how iterators or functional programming really work.
I used to do the over-spaced brackets thing: for ( i in range( 0, 100 ) ): print 'bite me' ..but I picked it up doing PHP, 'cos I found it too hard to read PHP code overwise (especially with nested if's etc). THEN the overspaced brackets entered into my *english* writing. So, not only did PHP break my programming skills, it broke my english. I got better though.
better: `if x is None` ===&gt; `if not x` error: should be: a = aux | aux = a a = b | a = b b = aux | b = aux `a = b = c = 5` not necessarily not better at all. harder to understand. from string import maketrans tab = maketrans("'.?", " ") a = "this isn't a word, right." afilt = a.translate(tab, ",") and so on
Yeah, but can it remove the ANSI formatting from a string? no. 
&gt; `if x is None ===&gt; if not x` x could be false for reasons other than being `None`. For example, `[]`, `''`, `()`, `0`, and `False` are all false (so `not x` would be true), but are not `None` (so `x is None` would be false). &gt; `a = b = c = 5` not necessarily Yes, necessarily. That's a chained assignment, not a chained comparison. It sets a, b, and c to 5. It will always work. 
 error: should be: | should really be: a = aux | aux = a | a, b = b, a a = b | a = b | b = aux | b = aux | It's faster too, even with the creation of the temporary tuple, at least in my testing.
For a week or two while learning how to use sed well I would write a one liner simply to parse RSS feeds. This is making it way to complex, I think.
Punctuation**-**sensitive, too.
My [sed cheat sheet](http://www.catonmat.net/blog/sed-stream-editor-cheat-sheet/) will come handy if you decide to do that. Ps. sed takes 1-2 day to learn.
&gt; x could be false for reasons other than being None. For example, [], '', (), 0, and False are all false (so not x would be true), but are not None (so x is None would be false). That's what I said: better to use `if not x` than the suggested `if x is None` &gt; Yes, necessarily. That's a chained assignment, not a chained comparison. It sets a, b, and c to 5. It will always work. You got me wrong. I meant 'not necessarily the best practice.'
I just pointed out the error in the original text. The original test says that `a,b=b,a` is the best practice.
&gt; That's what I said: better to use `if not x` than the suggested `if x is None` That's not what I said. What I said is that they aren't equivalent. You may really want `x is None`. Example: Suppose you have a sequence where each element is either a list or `None`. In this case, you probably want to treat an empty list the same way as a non-empty list, so your comparison should be `x is None`: for x in sequence: if x is None: handle_None() else: handle_list(x) If the comparison were `if not x`, then an empty list would be dispatched to `handle_None()`, instead of `handle_list(x)`. 
I realize what you said, but it was ambiguous what exactly you meant. No offence intended.
Ah. Thanks for explanation!
I just googled sed one liners or something like that each time.
yeah harder i'm understand ,Thanks for explanation
I don't know if it's mind blowing, but it's certainly interesting. Enough so that I'm bookmarking for later to download these math packages.
Yes, you [go through](http://groups.google.lv/group/comp.unix.shell/browse_thread/thread/b3885f5692585f64) all of those as well.
Yeah, you're right. I went ahead and just removed that.
How does this relate to the WSGI standard?
Some time ago, I tried to open source a project, and I just couldn't find my way around to initialize the repository, at the end, I installed tortoise svn on the vista partition, uploaded the app with tortoise, and return to linux to work as usual with svn :$
Next big step for Python?
Github.
This is kind of thing people do on Windows... In unix or osx, the sh/bash is enough to script these tasks in just a few lines. 
Cool. I kinda assumed PyTables was dead.
Hmmm... so the gist of the article is, "MatLab is expensive, and while there are alternatives they're just not MatLab (I have to learn a new way of doing something) so I guess I'll just stick with MatLab." Fleh. 
desperate for blog traffic are we?
$ git init
I'm pretty positive it's easier than that to have a ReST-to-plain-text renderer which discards most all stuff.
`svnadmin create path-to-repository` is all you need. There really isn't much of a point to using a script like this...
bzr init
maybe, but the project itself (if you click past the blogspam) looks pretty useful.
non link jacked: http://pinax.hotcluboffrance.com/
desperate fo' yo momma
agreed, i see myself using it and contributing to it after a slight bit more maturity the link jacked article was what is junk
At this point, Sun's largest competitor to Java is python. This is a smart move for Sun!
These postings are from 1999. Are the problems still extant?
The font is too small. I had to Ctrl++ it twice to get to a readable size.
 def MrSimple(producer, mapper, reducer, consumer): stage1 = [] for n, v in producer(): for n2, v2 in mapper(n, v): stage1.append((n2, v2)) for n2, vals in itertools.groupby(sorted(stage1), lambda x: x[0]): seconds = (second[1] for second in vals) for v2 in reducer(n2, seconds): consumer(n2, v2) just wanted to note that Using append on a list is a bad idea, because internally it is implemented as a array 
it seems like python is getting closer and closer to a 'natural' language.
it doesn't make any freaking sense, but I'll upvote it and continue making django installs the way i normally do.
Thanks for this link. I got the book and I'm going through it and it's very helpful.
'like Perl, but without the skullfucking contextual syntax'
Whats wrong with emacs? :)
It's not Vim.
they seem to have Vim mode, how well does it work? 
One of his bullet-point features is Perforce support. Seriously, *Perforce*?
what does it matter ? it's not open source so don't use it.
I like OpenKomodo, it is libre and gratis.
Kind of trivial, but using `top -l1` doesn't seem like the best way to get the load average (it lists every process running too).. `uptime` produces far less output
Wow. I first saw the blog and thought "Oh come on, my screen isn't that small!" but then I tried putting firefox across both monitors: It doesn't scale. Beautiful, sir. 
Err, posted it on the articles page, but the blog-comment-thing messed up the code (changed the quotes to "smart quotes" and removed the angle-brackets) &gt; Not sure this is really a bug.. You are trying to use a referenced group that might not exist (the “()?” one).. &gt; Not exactly sure of what you are trying to achieve in the end (The example could be done by data.replace(”Blue”,”Red”) ), but the way I’d do it is.. import re data = "&lt;p&gt;&lt;small&gt;Blue" reg = re.compile(r'(&lt;p&gt;(?:&lt;small&gt;)?)(Blue)', re.VERBOSE | re.MULTILINE | re.DOTALL) print reg.sub("\g&lt;1&gt;Blue", data) (?:[a-z]+) is an unreferenced group, and enclosing the bit you want to keep in a single group solves the problem (even without the ?: thing, but that means you can put another group at the end of the regex without having to worry about the `()?` one becoming group \g&lt;2&gt;)
far more interesting is the Sunlight Labs arm of the Sunlight Project (whence this deadline arose) -- while bookmarking the site in del.icio.us, I noticed that someone had tagged it as 'bubble', which of course made me wonder "are these idiots an actual company, or a nonprofit/ngo rig?" Answer: they're not idiots, they're swimming in money, and what they're doing is trying to keep representative democracy alive. I've rarely been so pleasantly surprised in my life. 
Your second mistake was trying to use regular expressions to parse XML. That's not what regular expressions are for. Try using an XML library. Your first mistake was choosing XML for data storage/communication. Although to be fair, it might not have been you that made that mistake.
well said
the actual site created: http://letourcongresstweet.org/ the blog, in case it's not clear (and it wasn't for me since the blog title color is the same as the orange bar at the top of the blog--oh yeah, and the reddit bar obfuscates the current url; it'd be nice if that showed up somewhere) is by sunlight labs http://sunlightlabs.com/ cool stuff.
install fire bug, right click the text, inspect element find .entry .entry_body, #entry_body disable width: 338px and float: right
I'm sure that arguments about static vs dynamic typing will never go away. However, when Python 3.0 is released next month, it will have two things designed to alleviate these sorts of problems: optional type annotations and abstract base classes. Type annotations are an optional addition to function declarations allow you to attach objects to each parameter, like so: def f(x: str, y: int): return x * y Technically you could pass anything, although it would seem pointless to do something like def f(x: [1,2,3], y: "Hello World!"): return x * y These annotations have absolutely no effect on what the function does. However, they are accessible by your code, much like annotations in Java. Abstract base classes (ABCs) are something being added to the standard library. They're designed to be mixed with function annotations to describe what a function can accept. For example, the function def f(a): for x in a: print x can take a string, a list, a generator, etc. So we can't just annotate with a specific type. Instead, we can annotate with the Iterable abstract base class. Abstract base classes also make the isinstance function a lot more useful since that function now understands abstract base classes. I'm not sure how much I'll use function annotations or ABCs, since I haven't had any of these problems with Python's dynamic typing. But to answer your question, yes, these problems are being addressed.
OMG. WTF does this headline say? edit: OMG WTF did that article say?
Seriously? You act like Perforce is a bad product. It's not an open-source, source control system, but it blows away CVS, Subversion, and anything else I've ever used. Check out their client list... It's used by just about every major company and it's the defacto standard for the video game industry: http://www.perforce.com/perforce/customers/byindustry.html
Don't get me wrong, I love open-source projects, but as a professional software developer, your IDE is your lifeline. A great IDE can save so much time.... open-source or not.
Python has made a decent scientific environment for me. It is free, very programmable, and has libraries for everything from image processing to linguistics.
It's very good to see Django nearing a 1.0 release. I realize that the milestone is partly symbolic, but it'll help immensely when pitching it to management.
This reminds me of the time I made a notifier bot for jabber... You'd tell it "Work appointment next Tuesday at 10 pm" and it would send you an IM to remind you, all you had to do is add it to your contact list. Ah, those were the days...
The strange thing is that even in 2.5 not everything in the python stdlib is a new-style class. e.g. SocketServer classes are not.
I don't like it. I'm always very wary of overloading operators. In this case, we're overloading the . operator so we can get some syntactic sugar and write function composition the way mathematicians do. Not worth it, IMO.
I think it is clever. Overloading is a powerful tool and can be dangerous in the wrong hands - somewhat like knives.
Agreed. '.' wasn't meant to be overloaded in this fashion. And it assumes that the other function is in the global namespace, which kind of excludes lambdas and returned closures and whatnot. Yes, let's make Python more like functional languages by adding things that can't be used with the common functional language idioms already available in the language! All because he had to use . instead of, let's say, *. 
cool. anyone use this in the field? (as in, practically, what kinds of settings does one need to pass through to templates?)
I'm a noob, but what would something like this be missing? class Test1: class Test2: Attribute = 3 class Test3: Attribute = 4 def main(): print Test1.Test2.Attribute`
&gt; Django seems to be becoming one of the "how good is your implementation" tests for Python implementations. Not only are the PyPy team using it in this way, but IronPython and Jython are as well. Good for us. Popular platforms are prime candidates for implementation usage, so this is only expected. It only means Django is a popular platform, especially when it comes to Python.
Two problems: 1. Test2 is a singleton. 2. It still won't work for methods or properties.
If Attribute happens to be a function, its behaviour depends on whether the class is instantiated or not.
It might be that these properties are supposed to be messing with internal aspects of the parent class, which is doable, but ugly from an encapsulation point of view, I guess. 
I don't see much wrong with what Python has, except for the fact we have modules and we have classes and they probably should have been the same thing, and not necessarily restricted to one per file, by which I mean modules should really be classes you don't usually instance. Personally, I use class for more than just classes. I even use it as a let (I reserve the let symbol for "class let" declarations).
http://asianrick.com/misc/iseewhatudidthere.jpg
I don't think it was implying that being a benchmark is a bad thing for Django in any way.
Hmm, I downloaded the nbm files but I don't know where to extract them exactly, does anyone have any idea?
I use class for more than just classes.
Guess you need the basic Netbeans platform (http://www.netbeans.org/). I don't use it myself, but it seems that the NBM is some sort of plugin file for Netbeans.
Nested classes have plenty of gotchas in Python.
After reading his post a couple of times I've come to the conclusion that what he's looking for is a class declaration that closes over it's environment. I haven't put much time into thinking about that, and what the implications are if any. It would certainly start to get really weird if you pulled those objects out of the class and kept their references elsewhere.
I have that, and I pointed it to the downloaded files to install as plugins, but it gave me a bunch of dependencies. Oh well, Vim isn't 50 MB at least.
via: http://blog.chameleo.org/?p=77 Django on Twisted Web2
A more advanced variant of the [Copy Paste Detector](http://pmd.sourceforge.net/cpd.html) ?
You have to subscribe to watch. No thanks.
Hey, I've downloaded it, it's actually quite cool, thanks! It should avoid the "tags" file, though.
So this is like the [ack tool](http://petdance.com/ack/) that did the rounds on the Programming subreddit a while ago, but written in Python instead of Perl? Yeah, I guess that's a useful thing to have.
How does this compare with [ack](http://petdance.com/ack/)?
Enthought's Python edition is in some ways better than the standard one(IPython-uber cool shell) Grin is a welcome addition. One doubt, what about searching binary files? (I guess it is covered since the article mentions PyPdf, not sure though)
have you tried ack?
Great post about advanced features on Django forms
PyHP 1.0.0-alpha is here: http://freshmeat.net/projects/pyhp-apache/?branch_id=75143&amp;release_id=281249
... Why?
no, what's ack?
but template engines such as Jinja, mako and cheetah are much better. I think its best to have a controller a template layer and a database layer(model). I dont really see how this will fit in. I think WSGI is more elegant then this. Then again Its probably much easier to get started with and you still could have the MVC(T) structure so I'll give this the thumbs up.
some discussion here: http://www.reddit.com/r/programming/info/6rp3f/comments/
After much pain I found this blog post. It solved my problems, hooray!
Python really isn't the right tool for that job. C would probably operate a couple of orders of magnitude faster 
Wow. We're going to represent integer values using "binary", which, for this author, means using special storage techniques in a high-level language. Apparently the author does not realize that integers on a modern computer are stored in binary by default. What really concerns me here is that I'm reading the work of someone who is this totally clueless on the python reddit. Why would anyone with any programming knowledge whatsoever upmod this article? Why would anyone even bother submitting it to python reddit in the first place? Gst, who (or what) are you, and why are you hellbent on destroying what little quality is left in this subreddit? 
Now I know how "industry" magazines are written. Well done!
now i know how some reddit posts are generated....
i know how well done posts generate industry.
I think the author probably does understand that numbers are stored in binary 'by default' on modern computers (and indeed older computers too..). i think by 'represent' they mean display - the article implies that the code provided would be used to help people learn about and understand binary, or for converting decimal integers to binary or initializing integers using binary form. in fact, this last use has been make part of python 3000 (see pep 3127)
Erm, half-complete, fairly generic IRC bot isn't hugely interesting.
Hm, I wrote a similar thing a while ago, but worked with larger kernels (and had ones for sharpening/blurring), http://imageproc.pastecode.com/?show=f1bf0c1ba
This is pretty much the same as Cheetah and such - they allow you to have an HTML file with python embeded in it. So does this. That said, I still don't think Python is the right language to use for embedding in HTML - I found having to worry about indentation in the language and the HTML to make decent looking output is annoying and difficult..
I don't know if you saw, but the download page for this was dated Nov 2000.
I wrote a Markov Chain reddit-comment-generator! http://markov_reddit.pastecode.com/?show=f14a2857b It uses the BeautifulSoup module (to get the comments). Set a comment page URL on the highlighted line (line 60) and it outputs a generated comment.. Running it on the "Bush Gave Taliban $43 Million Four Months before 9/11" post generates... &gt; Wheat invading Pakistan This should be competent enough to the hell does Ron Paul article Heroin isn't Afghanistan's. &gt; Real new and it it a death of liberal propaganda AHHHHHHHHHHHHHHHHH Ugh I wrote a chance and it. Err, makes more sense than the actual comments, I suppose.
I remember about a year ago I was trying to write a telnet-like problem and had problems with subprocess, because each time it would create a new process every time I wanted to execute command and would kill the current environment. I found out somewhere that you needed to make the file handles non-blocking in order for it to work. 
This code is supposed to login to myspace automatically. But I don't think it's working now. Does myspace changed something recently?
Here is output from my Markov implementation after being trained on "Heart of the Sunrise" by Yes: Love comes to the words sung. Dreamer easy in their eyes as you follow. Lose one on on a wave and then after. Dream on on to you follow. Lose one on to the colour sun shine. Straight light searching all the sun shine. Straight light searching all around me. I feel lost in the heart of the sunrise. Sharp-distance. How can the city. Lost on to the colour sun shine. Straight light moving and then after. 
[same snippet in a more pythonic representation](http://imageproc.pastecode.com/?show=f3870e7df), identical functionality expected, not guaranteed.
Wow, he didn't even mention Django:D
I would have turned those kernels into a dictionary, instead of leaving them in a function.
A milestone!
yet another php wannabe, cant those wannabe developers just stay on php, so they don't harm other languages
True, in retrospect. I didn't wrap my mind around it very well.
I don't understand what's wrong playing with PyHP. It's a very light-weight tool. Though it shouldn't be used for any serious purpose, it's fun for Python newbies.
&gt; Err, makes more sense than the actual comments, I suppose. No, not really. Make it for youtube, though, and it could pass the Turing test!
http://petdance.com/ack/
Still waiting for interlaced PNG support in PIL...
The random jitter they added should have been musically based...
see also: ANN: Urwid 0.9.8.3 - Console UI Library - comp.lang.python | Google Groups http://groups.google.com/group/comp.lang.python/browse_frm/thread/ebafaedc159c94cd#
Instead of these, see the [standard recipes](http://docs.python.org/lib/itertools-recipes.html). Also, the `re` module provides a [useful iterator](http://docs.python.org/lib/node46.html).
Having primarily coded in Perl for the past couple of years and trying to fit in Python when and where I can (oh how I miss coding in thee) it has made my motivation for learning Objective-C so so much lower. I mean, I DO want to write nice spiffy Mac apps and have a crack at iPhone development but every time I look at Apple's documentation I just want to stab my eyes with particularly angry bees. I feel that maybe a couple of years back the learning curve wouldn't have put me off as much, but now...I feel like I've been almost spoilt by languages that make things straightforward (yes, even Perl!:P). Django has been a revelation to me, and my motivation for learning more about Python has rocketed as a result. Perhaps I just need a kick up the backside - "go forth stikeymo, go for the burn and ye shall gain native Mac application power!". Or perhaps someone needs to create some non-angry bees to teach me Objective-C/Cocoa in a nice clear, erudite and lucid way. I definitely need to get more sleep than I have been getting of late, that's for sure.
I write code in Python, but I teach programming in C++ (no, I can't change that, at least not quickly). It makes me feel like I'm abusing my students.
No In cheetah you are not actually executing python code you are using cheetah directives and code in with a python like syntax. Same with most template languages. Besides I just remembered that there is already Python Server pages(PSP) for mod python. Its seems as though its pretty much copying that.
Everyone knows that Objective-C isn't a static language: any message can be sent to any object, regardless of its class. I've written a 50,000 line app in objc and I think it could really benefit from some of Python's features. Namely, syntactic sugar for lists and dictionaries, and shorter class/function names. I think the objc people just don't want bloat in their language. But honestly, having to type NSMutableArray *ar = [NSMutableArray mutableArrayWith... before you even begin to THINK about the objects going into the array, is ridiculous.
Luckily Xcode auto completes much of that typing... Remember it is self documenting and and... I got nothing else; it's a pain.
Exactly my experience too. Once one has used a proper language like Python one just doesn't want to go back. Not that Python's perfect--it's definitely not. But it's so much better than C/C++/Objective-C/Java/C# that it's not even funny.
would you recommend python as a starting point for someone new to programming? 
HSSSSSSSSSSS
SSSSSSSSSSSSSHHHHHHHHHHSSSSSSSS
Python would be a great language for learning about programming. It has its origins in teaching languages (although I forget the name of the language it originally drew its inspiration from in that regard) and has always been intended to be a language that's clear and straightforward to read. Also, as with most interpreted languages, you can just start up the interpreter and try things out interactively (rather than writing your code, compiling it, running it, looking at the output, repeat). Once you get the hang of typing: dir(object) to see what an object defines, and: help(function) to see a function's documentation, it starts to be pretty easy to poke around and learn by experimentation. There's also a pretty good introductory programming book I've seen which uses Python: [Python Programming: An Introduction to Computer Science](http://books.google.com/books?hl=en&amp;id=aJQILlLxRmAC&amp;dq=john+zelle&amp;printsec=frontcover&amp;source=web&amp;ots=Cy4LwGY9ZD&amp;sig=maPuiF5UTpyglYAjQ07oIh7a1e0&amp;sa=X&amp;oi=book_result&amp;resnum=7&amp;ct=result#PPR3,M1). You might find that a browse through that would help you get a feel for programming in general, and Python in particular. (BTW, there are other languages that are also well suited to learning with. Ruby, for example, can be a lot of fun too.)
Another book I recommend is [Think Python](http://www.greenteapress.com/thinkpython/). It's available as a free download, and I think it's a good introductory programming book.
SSSSSSHSSSSSSSSSSSSSS
You son of a bitch.
Good link, but why is this posted to the Python subreddit?
via: http://blog.howiworkdaily.com/link/2008/jul/16/django-picasa-django-picasa/
via: http://www.afp548.com/article.php?story=seeking-a-name-for-kicker-replacement
 import venom bite("roger_", inject=venom.toxic)
 from random import choice def hiss(maxhiss=25): """HHHSSSS HHSSSS SSSHHH""" return "".join(choice(('H', 'S')) for x in range(maxhiss)) print hiss()
 while HAVE_PREY: chomp() digest(prey, mode=liquify) sleep()
 old_bite = bite def bite(name, **kwargs): if name == "roger_": raise Exception("don't bite me, you son of a bitch") old_bite(name, **kwargs)
Unfortunately, _inject_ isn't supposed to be a requirement, so by redeclaring _bite_ with a forced second parameter, a lot of my existing code failed to work because I kept on getting: TypeError: bite() takes exactly 2 arguments (1 given) **EDIT:** Nice job changing it.
It's a python library, you can link it to your apps and sync files to whichever protocol it supports.
That's parcel tongue, with a python accent.
via: http://winpdb.org/?p=50 "Chris Lasher recently migrated his excellent tutorial on Winpdb and debugging in general to the Winpdb Wiki. Thanks Chris!" 
Remember PEP8...
DOES NOT WORK AS ADVERTISED. &gt;&gt;&gt; print hiss() SSSHHSSHSSHHHSHHHSHHSSHHH 
Yeah uh so what do they do? Protip for developers announcing their project: tell your prospective users what your wonderful new tool does and why they should use it.
After the work he put in building the program, isn't it an *Intelligent Design* simulator? I mean, it does nothing until the creator nudges it into motion... ;-)
How about this: "".join(choice(('H','S')) * randint(4,9) for x in range(5))
Well, nobody's really sure exactly what happened before the Big Shebang. Some believe that our process space was once occupied by another older process, and after the Big Shebang our process replaced it. Some say that the older process wasn't really destroyed - that what was replaced was only a copy of it. This would seem to suggest that multiple parallel processes might exist, all forked off from some ancient ancestor process. Further, it's possible that our own process occasionally forks in this way. Perhaps the different forks continue on indefinitely, never really aware of the other. Perhaps one of the forks is destroyed and replaced with something else, with an entirely new Big Shebang. What happens to the objects and actors running in the overwritten copy? Or what if the overwritten process is actually the original, and only the copy remains? 
 hhhsss = 0 while hhhsss &lt; 1: print "HHHHHHHHHSSSSSSSSSSSSSSSSSSS"
I forgot the colon and reddit won't let me make a real tab. It works now. Also, I can't believe I seriously just fixed a jocular code snip in a reddit comment.
Haven't looked at this yet, but does anyone know if it's like Darwin Pond? I loved that little simulator. The original that is, I didn't like the remade one.
hiss() should totally be a built in function in 3.0.
They won't run out of work soon.
While I'm enjoying this series of posts almost as much as the poker ones, so far he has focused mostly on the damned API and basic data-gathering. I'd like to see some discussion of bot strategy. Perhaps a simulation of various bot betting strategies applied to historical data sets.
I'm looking at this from a different angle. I'm studying up on multiple regression and Bayesian analysis and working on models versus the lines. I'm doing this more as a practical use for learning more statistics, but there's always a hope that I can make it my job. :) 
Can anyone tell me how this can be used?
thx. good explanation.
The author wrongly asserts that the problem is with closures. It's not. The error is in using xrange instead of range. The former is a generator, thus reusing the i variable. This is correct. Say it with me... Closures and generators (or genexps) do not mix. 
I don't really understand. &gt; The error is in using xrange instead of range. Like this? printer_lst = [] for i in range(10): def number_printer(): print i printer_lst.append(number_printer) for printer in printer_lst: printer() Produces the exact same results to me.
Why would you abuse Python like this? Trying to shoehorn the promise/force paradigm into a language which already (basically) supports it as a language feature just seems a bit... unnecessary to me.
Oh, durr. -1 for replying on iPhone on the bus.
He had a little of that in the first article, I think his strategy is simply to look for arbitrage opportunities. That is, look for conditions such that if you make 2 different but opposite bets with different payout rates, you lock in a profit.
But can you write a Python interpreter in Python in the absence of a Python interpreter?
or a C compiler in C in the absence of a C compiler
Discussed here: http://eatthedots.blogspot.com/2008/05/giant-planet-noise.html and here: http://eatthedots.blogspot.com/2008/05/shader-noise.html
Are you doing web applications? Check out Django. The main python tutorial is good if you have programming experience: http://docs.python.org/tut/ Dive Into Python is also good, but quality varies: http://www.diveintopython.org/
[ ] he knows python
The easiest way that I found was to check out one of the python frameworks and start playing around with the one you picked. Django is super and a good tutorial. Screencasts helped. Also read the python documents to get an understanding of data types. Hope this helps.
While I agree with the points brought up, I hate this type of title. C is indeed better than Python in some cases, and I'm not even talking speed. Being "portable assembly," C has one advantage: it compiles down to native code. This is important in certain cases where you can't count on an interpreter being present. For example, in writing a program for the [GP2X](http://en.wikipedia.org/wiki/Gp2x), I chose C++ (which once again compiles down to native code) instead of Ruby because I can't assume that an interpreter will be present on everyone's GP2X. In embedded systems, an interpreter might not even fit in the available space. I won't go into reasons such as lower-level access, etc., because like the above reason, I'm sure the author is already aware of this. It's the fact that he made such a general, and thus incorrect, statement that irks me. I hope that someone new to programming doesn't stumble upon this and assume that C has no uses, even if for that person would not necessarily have any use for it initially either. C is, after all, a great language.
Exactly. Given how tightly knitted Python and C are - to the extent that you need a C compiler and C know-how to install popular Python libraries - this type of article doesn't really say much. Apart from: C is low-level, Python is high-level. Well duh! Language wars are only fun between languages pitched at the same level. Perhaps I missed it, but I don't recall seeing any epic Ruby vs. Python battles. That's what we need...
I agree with the sentiment of your reply, but I have this to say. &gt; to the extent that you need a C compiler and C know-how to install popular Python libraries I wouldn't go that far. On my system, the Python libraries are available via apt. But yes, as is the case with any [leaky abstraction](http://www.joelonsoftware.com/articles/LeakyAbstractions.html), a Python user who understands the implementation is better off than one who doesn't. &gt; Apart from: C is low-level, Python is high-level. Well duh! &gt; Language wars are only fun between languages pitched at the same level. Absolutely. &gt; Perhaps I missed it, but I don't recall seeing any epic Ruby vs. Python battles. That's what we need... Well, I would say Python and Ruby are similar enough that it becomes a question of taste over anything else. If anything, the best language wars are based not on the type of languages, but the task at hand. What are you trying to solve and how do you want to solve it? These two questions have help point you to the best language for a particular task, and no more.
What's even better, you can prototype in Python, and rewrite critical sections (if any) in C. Or embed a Python interpreter in your C/C++ app. http://www.python.org/doc/ext/intro.html http://docs.python.org/ext/ext.html
&gt; Exactly. Given how tightly knitted Python and C are - to the extent that you need a C compiler and C know-how to install popular Python libraries - this type of article doesn't really say much. Apart from: C is low-level, Python is high-level. Well duh! Not to mention that Python is written in C. It's like comparing C++ to Boost. The comparing (even if C and Python) would be on the same level doesn't make sense until Python can be rewritten in itself. 
In addition to what people have said, consider making a web application in Google App Engine. A lot of the hassles of setting up an environment are sorted for you, and it's free to try. Of course, there is a risk of being tied to the platform but it might be the easiest way of seeing if Python is right for you. Also, all the stuff people say about Python being pseudocode is largely true. At some point, however, you might need to read up on how Python handles classes: they behave largely how you expect them to, but there are subtleties. Also, make sure you know List Comprehensions — they can make some problems really simple.
&gt; The comparing (even if C and Python) would be on the same level doesn't make sense until Python can be rewritten in itself. Ever heard of PyPy? :P
Dive isn't for introduction to python. But you can dive as soon as you're done with the Python Tutorial
yep using jython.
You can't make this comparisons... Python and C are completely different animals... **Python** is an interpreted/dynamic language, best suited for your PC/Scripting/blablabla, **C** is a compiled/efficient language, best suited for making efficient-cross platform apps... While in **C** you implement the java compiler, java interpreter, CPython,... in **Python** you create webpages, scripts, utilities... Think it this way, the C compiler, is witten in C, the Python Interpreter is written in C Code like this: &gt; mylist = [] &gt; mylist.append("foo") &gt; mylist.append(1) &gt; mylist.sort() Surely is beautiful, but do you realize that internally that's a C array? The same here: &gt; mydict = {} &gt; mydict['foo'] = bar &gt; del mydict['foo'] Surely that code it's beautifil, but at the end is just a linked list in C, implemented with structs...
I have kinda same problems... what would really be helpful, would be a book a video series etc. what handles especially 3 things... handling mysql, outputting(and handling input) html / Ajax and background scripting of basic online applications, like a store. What i really really want is a list, what it can do. With generic examples. Like, is it possible to run system side, some upkeeping services / traffic control / combining databases etc. and get web-side to seamlessly to co-operate, to send processor load etc data to the upkeeper. 
It's just bad to code Python without any outside input. Bad practices propagate that way.
It is not necessary implemented by C. C is commonly used to implement other languages because it is close to assembly language hence close to the machine language. Anyway, every code should be change to '0110' so that it can be understood by the computer. On the other hand, Python and other higher level languages are closer to human brain than the computer, so it is easy to write and easy to understand. Therefore, I don't think your last sentence makes much sense. In the same way, we could say 'C is implemented by machine language.' so we can never say C is better than machine language. 
Block all French users and pull out of France. It's obvious that they don't want ebay there.
I don't get it. eBay doesn't sell the stuff. It's the users who do.
I'd recommend trying out a few of the PHP frameworks before switching to Python for web-programming.. I recommend CodeIgniter (I found it to feel like it making it nicer to write PHP applications, rather than copy Ruby on Rails in every aspect, but in PHP). Really, Python for web-development is a pain - it's very difficult to find web-hosts, so you almost have to have a dedicated-server or VPS and configure Apache yourself. PHP is supported on an absurd amount of web-hosts (and if you do get a VPS, it's about a single command to install) That said, web.py ( http://webpy.org ) is a nice, relatively small framework for creating web-pages in Python, where as I found Django is basically a system that happens to use python-syntax (there are so many helper-methods and middleware and such it's almost nothing like Python..) I suppose if you're just learning Python, learning Django wouldn't be as bad. I would consider Ruby on Rails framework too - there's a very big/active community around it, and quite a few web hosts.. Same with the Ruby language itself. Err, that's assuming you are doing web-development mostly - if not, I'd outright recommend learning Python, and the official http://python.org tutorial.pdf then "Dive into Python"
&gt; You can't make this comparisons... Python and C are completely different animals... Sure you can; both are programming languages, both can be used to implement the same things, they just get about it differently at at different levels of abstraction. Which one is better depends entirely upon what you're doing and what your requirements are. Most of the time, programmer efficiency is more important than application efficiency; not least because most code is neither time nor space critical. Take the current generation of version control systems; both Bazaar and Mercurial are mostly written in Python, with a bit of C to take care of the hotspots. Instead of ~200,000 lines of C, they're ~50,000 lines of Python and ~2,000 lines of C, and still perfectly capable of the "effecient-cross platform app" label. Even many modern games follow this pattern; Eve online, a huge massively multiplayer RPG with it's own dynamic economy, is mostly written in Python, with just the hotspots like graphics in C(++). Python is a better language to write the bulk of the code in.
there are so many posts like this on reddit.
Sounds very neat! I should get to using it already.. lazy me having an incomplete site public!
the language spoken by the forked tongue subhumans that do the sorting in the package cavern below the ups facility?
Sounds good, but isn't avoiding that why you develop on a dev server first?
Next up: why hammers are better than screwdrivers.
There could be short downtimes when you are upgrading the production server with your newest code. Maybe you have to run a few queries on the production DB to ensure integrity after the update or other tasks that force you to log everybody off for a few minutes.
I understand where this might be used and agree, I'm just saying that (with python in particular), it doesn't happen as much. With php, for example, you need to block access to stop people from hitting half-updated scripts, while python is cached in memory and will be reloaded only when you reload your server, in one piece.
Don't have the patience to learn vim/emacs. Eclipse with Pydev is the best for me.
It's completely pointless to ask this question because everytime someone asks about Python IDE's, on reddit, HN, comp.lang.python, etc.. they always get basically every possible contender in response (Wing, Komodo, Emacs, vim, PyDev, etc..). Something like the spyced blog posts that actually has some feature comparison from a Pythonista is informative, but those kind of things naturally go out of date. I guess this is good--it seems there really are several high quality options for Python development. I'll be interested to see what NetBeans comes up with also.
The ruby vs python battles were there, about one or two years ago. But they were very tiring...
AH-LOSZ YEH-HES CHINDI LHA-CHA-EH NASH-DOIE-TSO DZEH • AH-NAH BE AH-JAH TSAH TKIN THAN-ZIE DZEH KLESH • BA-GOSHI TLO-CHIN NA-AS-TSO-SI 
Try Google App Engine. It takes almost no time to set up, yet you can see you app live online. http://appspot.com You get a nice subset of django out of the box. But, as someone mentioned, web.py is a small yet capable framework. Web.py also works really well with GAE without you having to understand the 'framework' like django. see http://webpy.appspot.com/ for sample code. 
Yes, I would. But it's been so long since I learnt how to program that I can't really put myself into a beginner's shoes. To me, at least, it seems like a nice, straightforward language without too much weirdness.
That was.. it? Well, there's still NetBeans (and not to mention, JVM) to install.
Hello, This is my first Google AppEngine project, which is developed in Python/Django. If you want to take part in the project, or if you have any ideas, let me know... jinglemansweep@gmail.com Cheers, Louis
very cool. reminded me to revisit a javascript embed hack in one of my projects.... and replace it with beautiful simplicity. django apps are awesome. did anyone else have trouble with youtube width and height? i submitted a patch for site-specific forcing of width and height. feedback welcome. http://code.google.com/p/django-oembed/issues/detail?id=5
FYI, you can just "easy_install setuptools==dev06" to update to the latest version. That also (probably) applies to specifying that version in buildout or other requirements (i.e. ==dev06,&gt;=0.6c9dev).
I used Eclipse with PyDev /PyDev Extensions for a while, but I've switched to Komodo IDE and have never looked back.
Looks cool. I searched for an About or Developer page and couldn't find one. If it weren't for this submission I wouldn't even know the magic words. 
I think I've run into this before actually. Seems like a bug to me.
Where is the demo? SHOW ME THE DEMO!
this is interesting, and cairo is a great base to start from, but I don't see that being django specific provides much of anything, besides branding..
I concur. A plain trac with textual claims of anti-aliased, beautiful graphs doesn't really persuade me to try out the code. I want images as well.
See also: http://pypi.python.org/pypi/pyrels/0.1.0
sounds cool. at a super high level the problem sounds familiar: tool produces text file. stuff everything into a database instead. write web app.
who cares
when can we get rid of //, too?
[submitted 3 days ago](http://www.reddit.com/r/Python/info/6s8wr/comments/)
any word on getting tickets?
via: http://blog.howiworkdaily.com/link/2008/jul/20/django-new-forms-admin-screencast-and-tutorial/
All you need to know about that post: &gt; Well.. Sorry, I still don’t buy the idea that PostgreSQL is absolutely superior to mySQL (c’mon! “20.1 is not a valid Integer and that’s why I rollback whole transaction” That’s a superior DB??! Can’t it make it just 20? Is that so hard? [...]) 
Looks like someone had a bone to pick. For the record, I've found Postgres much more scalable on single database instances than MySQL, and the flexibility of query abilities is fantastic. Granted, it you slap a ORM around it, then you'll never see it.
That's exactly what I came here to say. Why not make it 35, while you're at it? Who needs accuracy when you can have your DB silently corrupt your data!
This guy's a bit of an idiot, he went about migration all wrong. I just did it a few days ago and it was a matter of dumping the db, running the mysql-to-postgres tool to weed out incompatible SQL and loading, and it went fine.
Python can do anything.
 &gt;&gt;&gt; import sentience &gt;&gt;&gt; sentience.respond("Python can do anything.") Why yes, I can. Yeah, that's pretty much proof.
No to mention, he didn't say anything about pg configuration at any point, yet even I as a hater of all things databases and administrations, know that pgsql's default config is geared towards being able to run on very few resources and performances obtained with that are nowhere near what pg can output, while mysql's default config is much more aggressive (uses like 10 times as much ram out of the box, for instance)
&gt; That's exactly what I came here to say. Damn you both, get out of my head... 
There's this too: &gt; The developers of Django like to tell that they use only PostgreSQL and nothin else. Well.. there was one more problem. Django wouldn’t even work with PostgreSQL until I applied #3460 patch.It was showing me “current transaction is aborted, commands ignored until …” error with not even my SQL (something from Django’s insides) *[just in case - yes, I use SVN version]* (emphasis mine) Development code is broken? Really?
&gt; Development code is broken? Really? Can't fault him there, the current django "philosophy" is that you should use the svn version and that it should always be stable enough (most of the time anyway)n the last "real release" (0.96) was more than a year ago and it's *badly* out of date. There's a push for 1.0 right now, but until that a lot of django's features (newforms &amp; al) are only available from trunk, and if you go to e.g. the django ml or irc it will usually be suggested that you use svn.
This guy sucks at writing Python. WTF is up with the for-loop? #!/usr/bin/env python import urllib def main(site='http://xkcd.com/', baseurl='http://imgs.xkcd.com/comics/', filepath='/Users/blah/Desktop/'): source = urllib.urlopen(site).read() start = source.find(baseurl) if start == -1: error_msg = "%s not found in %s." % (baseurl, site) raise Exception(error_msg) stop = source.find('"', start) url = source[start:stop] print "Comic found:", url start += len(baseurl) filename = source[start:stop] urllib.urlretrieve(url, filepath + filename) print "Saved under:", filename if __name__ == "__main__": main() Edit: Ignore the &lt;&gt;'s around the URLs. It's a weird Reddit bug/security thingie. Edit 2: To those downmodding me, look at his code. It makes no sense: source = urllib.urlopen('http://xkcd.com/').read() linebyline = source.splitlines() found = 0 for value in linebyline: if found == 0: First, he uses `.read()` which reads the whole file-like object in. Then he splits it up into lines. Why not just use `.readlines()` to start with? Then he makes a `found` variable and sets it to zero. But if you look at what he does with `found`, it's completely useless. He could just as well break after he finds the first match instead of using `found`, which will never equal anything other than 0 or 1. Then he tests for `if found == 0:`, which (this is a small nitpick, but still) is not idiomatic Python. The idiomatic Python is `if not found:`. Meanwhile, why does he use a loop at all? What he's doing could just as well have been done to the original whole text blob. The only point of going line by line is if you want to save multiple files, but his code deliberately breaks after the first match. When he finally saves the file, he write `image_file = urllib.urlretrieve(image, path + filename)`, which is dumb, because he never reuses `image_file` later. In addition, he has all his code at the module level instead of in a function, which means a.) you cannot use his file in an interactive shell session b.) you can't just pass in different parameters if you ever want to search another site for something else and save it elsewhere. His code sucks, hard. I mean, no big deal, we all start out by writing sucky code. But, if you put it on the internet, expect to be criticized for your sucky code, and learn from those criticisms. 
Did he know what a RSS feed is ?
&gt; (most of the time anyway) That's the important part. They have a conservative commit policy, but if you use trunk, you have to be prepared to use HEAD-n at times (or at least avoid syncing during sprints ;-). I wouldn't be surprised if their approach will change somewhat once they get to 1.0. Django's gotten too big.
Python makes RSS feeds unnecessary.
&gt; That's the important part. They have a conservative commit policy, but if you use trunk, you have to be prepared to use HEAD-n at times (or at least avoid syncing during sprints ;-). I know, and that's why I added that remark, but the point still stands: OP can be faulted for being a moron, but not for using trunk. &gt; I wouldn't be surprised if their approach will change somewhat once they get to 1.0. I'm sure it will, wouldn't make sense to tell people to keep using trunk, most of the really important big stuff should be in there (according to the 1.0 roadmap anyway). edit: by the way, are you back from real life? Do you know when you'll be able to release the ET1.3 beta?
Guys, I've answered all your points in a big comment at the site.
Why ? You load the rss feed and you get the lastest comic with a simple xpath query. 
fyi, if you're not tracking the comments on that blog, the site admin's responded to that as follows: &gt; This isn’t a corruption, you defined it as integer and Integer(20.1) is 20, just like Char(1) of “Lazy” is “L”, aren’t you guys programmers? Define your data with enough granularity and there you go. ...right. 
I responded to his response already, but thanks for the heads up
&gt; edit: by the way, are you back from real life? Not really -- I expect real life to kick in again any day soon. &gt; Do you know when you'll be able to release the ET1.3 beta? ET 1.3 has suffered from "scope growth" in the XPath and C14N departments, so there won't be a beta just yet. Maybe a new alpha, though.
&gt; Not really -- I expect real life to kick in again any day soon. Please do tell your real life that I hate it very very much :p Stay well, though. &gt; ET 1.3 has suffered from "scope growth" in the XPath and C14N departments, so there won't be a beta just yet. Well, I am sad panda. &gt; Maybe a new alpha, though. Yay. By the way, have you ever thought of developing it on a public repository (if I'm not mistaken, right now you dev on your private repo and dump it on your public one from time to time, right?), to make it easier to contribute for example? (and maybe indicate where you'd want ET to be headed) Seeing as ET's probably the most popular &amp; loved Python XML lib', I'm sure some people would be interested.
0.96 is really out of date. But really, he shouldn't be making such a silly point. I've been using Postgres in production with Django for nearly two years now.
&gt; aren't you guys programmers? Now wait until he discovers that 20.1 is the same thing as 20.100000000000001...
There appears to be no comments... Did he delete them all in shame? Haha.
&gt; There appears to be no comments... Did he delete them all in shame? Haha. At least he completely disabled them, it's not even possible to post one anymore.
Squeeze page?
It was a joke.
i've been pleased with [epydoc](http://epydoc.sourceforge.net/), which generates docstrings and inheritance, uml and use graphs. (best of luck to pyrels, tho!!) 
depending on the kinds of queries being graphed....: seems like a good idea to do this kind of thing server side rather than client side, as is often the case if doing through javascript. even with a good framework to protect against complexity in the front end code it's still duplicating a lot of work. would be good to generate svg rather than gif, yeah? this could be useful as a django app that provided template tags so that template creators could have control over the data being graphed, without needing to munge the raw data over the network or figure out a js framework.
cool. (whenever i moused over a link a box popped up that obscured text contained additional links and information overload. i found that a fair bit distracting from the content. why does this exist? it some kind of blog revenue scheme?)
in the captcha spam war, why not provide pictures and ask specific questions like: what sport is being played? i know this requires a large repository of images and tags (flikr? google image? wikipedia?), but otherwise it seems like a good human vs. computer track. oh yeah, except for the people solving captchas overseas. strange world.
[link from text ](http://www.djangosnippets.org/snippets/507/) on template caching.
&gt; It has its origins in teaching languages (although I forget the name of the language it originally drew its inspiration from in that regard) ABC
Why is ctypes platform dependent?
It makes me nervous to use a homebrew ssh implementation. Sure it might be convenient to have pythonic access to ssh, but there are serious risks if there are flaws in the protocol implementation.
Get your tests running, this marks the merge of the newforms admin, so upgrading wont be as simple matter of svn up, however as usual, the docs are on the site.
It doesn't abstract platform quirks away, it merely interfaces with the platform. Based on the little experience I have it revolves around calling conventions – arguments, returned values, types – as the concept of the actual functions and types are common.
The only mutable parameter trick that I've seen in real-world usage is memoizing through a default argument dict.
Hmm. This is the second blog post I've seen in the last few days that's basically a rewrite of my post to the comp.lang.python thread they're all pointing to. Are Python bloggers running out of stuff to write about? Oh, well. Here's my own rewrite, in case anyone's interested: http://effbot.org/zone/default-values.htm Both this one and the original c.l.py post cover stuff that the others seem to have missed...
I'm sure a lot of Python material out there originates from your blog. As for this trick, for example the memoization, it looks a bit dangerous as any caller can rebind the argument. Although this complies with the Zen of Py (we're all consenting adults), personally I'd rather use attributes on the function to make it a *little less* dangerous. def f(x): if x in f.seen: return f.seen[x] r = do_calculations(x) f.seen[x] = r return r f.seen = {} Of course, anyone has free access to `f.seen` as well, but it's at least a little harder to muck with it accidentally. This breaks down though if `f` is rebound, but that could be worked around by getting the function reference from the call stack with `sys._getframe()`.
Well, that works, but then you're replacing a local lookup with a global lookup and an attribute access. Might as well use a plain global...
More evidence for a Python [blogging echo chamber](http://www.reddit.com/info/6sws2/comments/c04s09l), it seems. Here's another recent blog entry about the same (old) topic: http://blog.appenginefan.com/2008/07/duh-its-python-25.html 
Did I mention it's Pythonic?
I really appreciate the Javascript / Ruby style: var foo = bar || baz does Python have a similar assignment option? PHP's $foo = $bar ? $bar : $baz; makes me cry for the double $bar.
Would give this bonus points if it made use of Stackless Python. 
That's spelled foo = bar or baz # pick bar if true, else baz in Python, but doesn't handle all cases covered by an inline if-else, of course.
I know it's an old topic, but it's really interesting. Before the Python ternary operator, I think the best way to emulate it was to use this: [Val1, Val2][bool(condition)-1] But it's not as the "new" ternary operator. 
That's quite unfair. You've written about _everything_ in Python...
That's different, if Val2 were an expression (possibly with side effects) it would be evaluated. The old equivalent was the horrid (condition and (val1,) or (val2,))[0]. The tuple and the [0] were necessary to make sure that it also worked well when val1 was itself false.
Oh, I didn't mean to imply that everyone's copying stuff I've written about -- rather that I find it a bit odd that everyone's writing seemingly independent but rather similar articles about the same old things at the same time. Guess it's some variant of the birthday paradox. Or maybe it's just time to clean up my blogroll.
Or, shorter: (b, c)[not a] instead of (a ? b : c). But as Scarblac [points out](http://www.reddit.com/r/Python/comments/6syc5/Python_ternary_operator/c04scz1), that has the drawback that both b and c are evaluated before the condition is tested. The full replacement is usually written as: (a and [b] or [c])[0] and is attributed to "Tim Peters (who wishes it was Steve Majewski)." Using tuples instead of lists might be a tiny bit more efficient (three object space allocations instead of five when creating the temporary wrappers). The form: a and b or c also works, as long as the value of "b" cannot be false. And that concludes our lesson on Python arcana for today. See you all next week.
It's the same used in the lambda functions (to retrieve a boolean value), isn't it? For example: apply(lambda x: isinstance(x, list) and x or range(x), [[1,2,3,4]]) However I think it's a really ugly way to get a value; I consider it not really Pythonic...It's too strange. Instead: Val1 if Condition else Val2 is clearer and Pythonic.
That would similarly go wrong if x happened to be a list and false, i.e. []. But yeah, I'm happy we don't need this anymore :-)
SymPy is written entirely in Python and does not require any external libraries.
What's the point?
FYI: TG1 refers to TurboGears.
Ok, now make a solution for a 100x100 board.
There's a better Python program for this on Wikipedia.
The blog'y script has messed up the indentation fairly badly - kind of bad for Python code..
via: http://blog.howiworkdaily.com/link/2008/jul/23/disqus-guys-integrate-selenium-tests-django/
Sorry, I actually changed it before I noticed your comment.
Unlike other programming languages.
I think that sort of sentiment is true of any developer who likes to program, regardless of what their language of choice is - if they really like to program, they evaluate and choose their language based on "better" principles than what would look best on the resume, or what has the widest market acceptance. Sure, people are more like to do that with Python than with C, but there are a bunch of other languages out there (Ruby, dare-I-say Lisp, etc.) that have people genuinely excited about programming with them.
You can scan this book in an hour and get 90% of the syntax explained very simply. http://pythonbook.coffeeghost.net/book1/index.html
Excitement is something that has been missing from tech from quite some time. Thankfully we've got back on track now, especially given Linux is around.
Unlike *some* other programming languages.
I know a little Python. I've used Django for almost a year, but really that is just filling in the blanks and not giving me any real depth. I am looking for project ideas, simple to difficult, that might push me along. Perhaps a project based book, or something similar? I primarily use Windows, if that makes a difference. I have an interest in designing small games, so I thought perhaps that would be a good place to start, but it is all a little overwhelming!
http://projecteuler.net/index.php?section=problems
Make a small MUD! Or use [pygame](http://www.pygame.org).
- simple cross-compiler for an embedded architecture - markov-chain simulator - fuzzy comtrollers simulator - symbolic calculator 
Me too. I started on a TRS-80 when I was a little kid. I've learned a bunch of programming languages over the years, but once I learned Python in '97, I pretty much dumped the rest. Python was the quickest way to do what I wanted to do and it had a kick ass standard library. One drawback is that I havn't kept up with the additions to the python language. I've been too busy actually writing programs/scripts. 
Weird... that's exactly why I like Perl. Pretty much any language beyond what you learned in school can have the same argument made for it.
[pyglet](http://www.pyglet.org/) :-)
http://www.pygame.org/ also you can just use opengl directly Here's a screen shot of a little program I wrote in Python: http://www.foorg.com/programming/ScreenShots/Screenshot-Height-map%20Terrain%20Generator.png 
If you have Civ IV, most of the rules are written in Python, so you could make a custom scenario. I've considered doing that myself.
Make a tetris clone. Check out pyglet. It's awesome.
How about a program to generate anagrams of your pet's names? That'd be pretty neat.
If you want to keep going with Django, I've heard a book called "Practical Django Projects" is one of the best, and might be exactly what you're looking for.
"speed was achieved by not using recursion." ...Sigh.
The two ideas for projects I won't have time for soon: The recent Radiohead video. The data and stuff on Google Code: http://code.google.com/creative/radiohead/ . Several people like http://i.document.m05.de/?p=500 already did some stuff with the data the head close ups; but I'd like to work with the outdoors data (I _think_ it's made with a different technique so I'm sort of assuming that the data is also different). Might be a nice project to get some graphics out of it. Second idea: my damn Internet addiction. Make an application that blocks my looking at any Internet pages except a predefined list; make it really hard to turn off; at least make it require a password so I can let someone else set one. Something like that. There exists things like Firefox plugins, but they're too easy to switch off "for just this one page".
I was looking at that book yesterday. I really like Django, but I detest anything relating to HTML/Javascript. I mainly use Django as a backend for my database models (with Flex/AIR frontends) I could probably still use the projects though, and translate them to the Flash platform.
I didn't know that, and that is a really good idea. I haven't bought the game yet, but I keep eying it in Steam.
my first python work was screen scraping sites with the beautiful soup library. Pretty fun and was easy to use. Also came in helpful cause I could screen scrape a sites TV page and then get the best value like: "Plasma Square Inches per dollar"
The Python Challenge ( http://www.pythonchallenge.com/ ) really gave me a head start on learning python. It is like a treasure hunt using analytical and programmatical skills. Although some challenges rely on specific libraries, the forum and the solutions wiki is terrific. In the process you will be dealing with many many different concepts such as data structures, image and audio processing, network programming, etc. Massive fun really.
What's mod\_wsgi's advantage compared to mod\_fcgid or mod\_python?
Does anyone else absolutely get off to this shit? I mean seriously. I've been waiting for this article.. if I look back through my web history searches I can count how many times I've searched for with the terms "simulation evolution python agent based complex systems"... and find a few interesting gems but mostly unrelated. And then I found this paper... :)
Sorry I didn't comment earlier, I was programming. As I am sometimes want to do. In Python.
I've been planning on starting mud for a few weeks now, but I haven't found any good example of a telnet implementation. Twisted is so well document and focuses more on ssh. Suggestions where to find a good way to handle connections?
I do a little bit of web development and generally make little games or whatever I think of with python. Some of the things I made to learn programming were: - Dope Wars style text game. Very easy to make, just takes some planning. - Minesweeper. Another simple game that doesn't require complicated algorithms or graphic libraries. - Basic blog using Django with user accounts, tags, etc. Doesn't have to be pretty; just functional. After you can do some simple stuff like that, you probably know enough to fiddle around and make whatever comes to mind.
Much the same way I feel about Ruby.
A few fun projects that jump to mind: * ladders game: for any two given words, find the (shortest) chain of words necessary to connect them by changing one character at a time. e.g. boat -&gt; coat -&gt; moat * knight's round, 8 queens, etc. * sudoku solver * [steganographic](http://en.wikipedia.org/wiki/Steganography) encoder / decoder
Brainfuck interpreter. As far as I'm concerned, you're not a real Python programmer until you've written one.
I'll be getting myself a [FreeRunner](http://openmoko.com/) in the mail in a few days and one of the most popular languages and frameworks is PythonGTK. I'll be teaching myself Python and will be able to use it on small interesting and useful programs that I can carry with me everywhere. The phone has BT, Wifi, GPS, GSM, USB and accelerometers so there's plenty of cool avenues to travel. 
Here is half of the answer, http://code.google.com/p/modwsgi/wiki/FrequentlyAskedQuestions#Comparison_to_ModPython
Then, what about the book "Foundations of Agile Python Development"?
But isn't it always more fun to write a fuckfuck interpreter? http://esolangs.org/wiki/Fuckfuck
I've done some of that with the mechanized and BeautifulSoup libraries. I wrote a small utility for my wife to go through her subscription scrapbook sites and grab all of the materials so that I could stop paying monthly fees ;)
That is pretty awesome. Does it work on the regular networks?
I think you mean [wont](http://en.wiktionary.org/wiki/wont).
Wireless: 802.11b/g GSM: 800/1800/1900 or 900/1800/1900 depending on which version you get. Is that what you meant?
Well, the first thing I made was an IRC bot. Hope this helps.
[Project Euler](http://www.projecteuler.net).
Ya, I RTFM after I asked ;)
via: http://compoundthinking.com/blog/index.php/2008/07/25/host-tg-on-iis/
Hell yes. Three apps is so limiting. I hope they launch this soon. 
Unless muds have changed in the last ten years, you don't need a telnet implementation. Listen on a TCP socket use \r\n as an end of line on data sent to the client and use the ansi/vt100 display codes/attributes for everything else.
Man, where's "Lisp for Python Programmers"? :/
from the article: &gt; Although it wasn't my intent, Python programers have told me this page has helped them learn Lisp.
I would very much prefer a page that unintentionally helped Lisp programmers learn Python!
I already know Python, but I don't know Lisp, and i want to learn.
Using a metaclass is in interesting way to register plugins or handlers. The problem is that if the plugins are in separate files, they must be imported before they self-register. And if you don't know that they exist until they register, how do you know to import them? In my experience, metaclasses are a great way to make self-registering classes if you know up front what classes you will be needing. Using the metaclass allows the developer to easily add and remove plugin-like functionality without maintaining a separate list of the plugins. However, to use plugins that the developer does not know about up front, some level of plugin folder scanning is still required to discover the modules to import.
Python for whom ? It is a one way road. No one comes back. 
impersonating google?
No, we had a subscription. I just made the robot to go through each and every page of the site and download the high resolution images.
She's my CherryPy Cool drink of water Such a sweet surprise Runs so good Make a Perl man cry Sweet CherryPy oh yea She's my CherryPy Put a smile on your face Ten miles wide Looks so good Bring a tear to your eye Sweet CherryPy
Let **me** try to use small words. I didn't know Peter Norvig had BOOKS about Lisp when I wrote that comment. What's so hard to understand?
Here's a complimentary "article" that lists some weird pitfalls I ran into with OpenGL and Python... it may save you a couple of bouts of hair pulling and keyboard slamming WTFs :) http://www.siafoo.net/article/58 
Better as in? Quick benchmark: * This program: **6 ms** on my laptop * Straightforward class-based implementation of recursive backtracking, from Python's demo directory, using psyco: **7 ms** * Same, without psyco: **23 ms** (4 times slower) * Permutations-based solution, from Wikipedia: **707 ms** (117 times slower) (both the others slowed down under psyco, at least when using psyco.full)
Democracy... huh? Python is more like benevolent dictator.
Or just use [entry points](http://peak.telecommunity.com/DevCenter/PkgResources#entry-points) and list the plugin object(s) or classes [in your setup.py](http://peak.telecommunity.com/DevCenter/setuptools#dynamic-discovery-of-services-and-plugins). No directory scanning necessary.
And you're like someone who didn't read the article... 
I've **never** seen an open source project run as a democracy, and I can't even think how that would work. Where has that idea come from? (Yes, sometimes developers use a kind of voting system, but only *developers* get to vote, and it is usually just a way of gathering people's opinions). All the genuine open source projects I've been involved with have been slightly haphazard meritocracies (for appropriate definitions of 'merit' :-) 
What the hell? I can't believe you're using this as your argument. The code he's referring to is from "Artificial Intelligence: A Modern Approach", which he uses as examples/libraries for teaching AI, not Lisp. Better luck next time.
Doesn't seem necessary to read the article. Python is not like a democracy at all. Why do I need to read an article to find that out?
From the article: def person(*args, **kwargs): keys = kwargs.keys() values = [] for v in kwargs.values(): values.append("'%s'" % (v)) sql = 'INSERT INTO foo (%s) VALUES (%s);' % ( ', '.join(keys), ', '.join(values) ) print sql SQL FAIL! That said, Python's parameter expansion *does* rock - I often use it for constructors: class MyClass(SomeOtherClass): def __init__(self, thingy, *args, **kwargs): super(MyClass, self).__init__(*args, **kwargs) self.thingy = thingy 
I made it into a [quick web utility here](http://utilitymill.com/utility/N_Queens_Problem_Solver). Can anyone edit it to solve N queens? That would be impressive. Maybe add a variable board size too?
Yes, I was kind of hesitant to put that SQL example in the article like that (hence the warning underneath it), since there are so many copy-paste programmers out there. Then I thought: "Wait, this isn't PHP, this is Python", and added it anyway ;-)
via: http://radix.twistedmatrix.com/2008/07/twisted-community-code-on-launchpad.html
&gt;#No braces. &gt; &gt;This is so obvious that it doesn't need a reference to a mailing list. Do from __future__ import braces to get a definitive answer on this subject. 
matplotlib is a part of scipy (which is also very useful). This link barely skims the surface of the capability of matplotlib. Homepage: http://matplotlib.sourceforge.net/ Cookbook: http://www.scipy.org/wikis/topical_software/MatplotlibCookbook 
all i can say is wow, bsd licensed too
Yeah, exactly :) You might want to google the ansi color codes eventually, but that's definitely not one of the first thing's I'd take care of. [This](http://docs.python.org/lib/socket-example.html) should be a good enough example to get you going.
I've used matplotlib/pylab for a few simple plots, but I got completely lost when I wanted to do some custom plots (add an axis to the right side). The MATLAB syntax is good for beginners and doing basic plots, but I'd prefer something more Pythonic.
Python 2.5.2 (r252:60911, Apr 21 2008, 11:12:42) [GCC 4.2.3 (Ubuntu 4.2.3-2ubuntu7)] on linux2 Type "help", "copyright", "credits" or "license" for more information. from _ _ future _ _ import braces File "&lt;stdin&gt;", line 1 SyntaxError: not a chance 
I cut this out from Alex Martelli's slides on video lecture: [Python Yesterday, Today and Tomorrow](http://www.catonmat.net/blog/better-faster-smarter-python-yesterday-today-and-tomorrow/)
Discussed here: http://compoundthinking.com/blog/index.php/2008/07/26/dougs-awesome-virtualenv-scripts/
That post deserves some kind of award. I strikes me that you can take this "self-documenting" approach quite a bit further by putting the entire program in a literal, like this: exec """literal""" "Wonder what the program does? Read the docstring! It's self-documenting!"
Up-voted for the link on the side to xkcd python comics.
Another possibility: use the Ellipsis object literal in Python 3.0: def foo(): ... Yeah, that is really three dots, not just pseudocode.
See also: http://mail.python.org/pipermail/c++-sig/2007-September/012891.html Announcing pybindgen
Thanks for posting this. I just tried it and it works well.
my favorite quote: "...ending up with funky grammar rules like some other dynamic languages that will go unnamed, such as Perl." 
how is development going? does it have voip? the wifi works? browser works? even for js things, like say google apps?
Hey, so an artist/graphic friend of mine wants to get into website design. He's tried css/html, but finds it only just barable-- anything more programmy might be too much. He's made some flash apps, so the writing text part is ok, at least for small things like actions which can be largely copy/paste/modify. He really digs anything that is like using adobe photoshop. Ok, so he got excited about flex, maybe because it's from adobe, but it's not like 'flash' at all, right? It's more like jsp that permits embedding of flash, yeah? If I've misinterpreted Flex/AIR please let me know. I run mostly django sites; don't really care what kind of front-end gets hooked in, be it html/css or flex or flash. I'd just like my friend to be able to work with me on projects. Right now, it seems like the best option is for him to create Flash animations and embed them in simple html and css layouts. Are there other options for non-programmer artists? Open source ones? word. 
Should be renamed to "Two Python functions you might not know."
The example without it should break once a match is found.
i started with vb6 which lead to the c family, finally jumping to c# with dot net. but i prefer php over asp and python over perl scripts
Looks like an odd mix of domain objects and hand-generated SQL...
I went python to c#, then to ruby and now am with perl. strange order, I know... 
Huh... an editor, perhaps?
Ugh... people, you don't need to write bloated code on the opposing side to prove a point. I definitely agree Java makes things more verbose, especially on examples of such scale, but his Java code (generics *and* messing with Iterators? It's like picking whatever makes things harder to understand) is not very close to even compiling. Funny how this time the usual criticism about needing a `public static main(String[] args)` didn't make way.
Flex is most definitely Flash, or rather, Flash and Flex are both Actionscript 3 driven and play in the same runtime. A better analogy would be like comparing Django or Twisted to Python. Both are frameworks that might be somewhat compatible (in the case of Flash and Flex, they are very compatible) with the same language driving the fun. 
Could someone to whom this makes sense explain what this module is about?
Python is much more elegant than that example shows. It could have been written more intuitively as a single line: print sum(letter is "a" for letter in "I am Jack's Colon.")
not sure. only got mine a few hours ago and still tinkering between OS's. i'll let you know ;)
You shouldn't rely on "a" being interned, that's an implementation detail. Better to use ==. Edit: just noticed that you probably took that from the article. 
Nice how he writes "count = count + 1" in Python, then "count++" in Java, and then complains about the "++"... 
And actually I did know them. First time I heard about them I wasn't too impressed, but combining `all()` or `any()` with generator expressions leads to nice, elegant solutions. In case you haven't used them yet, this is the ideal time to try them out.
That Java example wouldn't even compile, let alone be the best way of handling that task.
That shit ain't programma'!
Ugh! &gt;&gt;&gt; import this ... There should be one-- and preferably only one --obvious way to do it. &gt;&gt;&gt; 'I am Jack\'s Colon.'.count('a') 2 :-) (PS: yes, I'm dutch)
off-topic: Ye gods, what a terrible website design. The URL'll look nice in my history too.
Not to mention the first line: &gt; Python has buttloads of… They'd know all about that unit of measurement I guess…
Including that example wasn't meant to be a proof that Python has friendlier syntax; as if one contrived example could ever do that. But, I don't think this is a very controversial statement. You seem to be with me in spirit, anyway. The example was simply meant to illustrate what "friendly" means in the context of languages, since this isn't a programming blog. So, I tried to write examples that do roughly the same thing in the same way.
You can get downvoted for ever having programmed in VB6 now? I programmed in GWBasic once. Watch me burn! ;-)
I don't need yet another ORM or way of abstracting SQL. I need a Python package that abstracts away schema modifications to databases! All these ORMs are useless without it. __edit__: oh, and why doesn't the page mention which databases it works with? You're telling me the SQL is database-dependent?
That lib combines many novice errors with a unsuitable abstraction level. It's basically bad practice for simple things and completely useless for complex things.
I agree. I like Python better than Java, but his example is crap. Here's the same code written in Java with one extra line of code in comparison to the Python code, and much more readable. (Note: I haven't coded in Java in over a year. I know this is correct in terms of logic but "length()" might be a different word or something since I've forgotten). String phrase = "I am Jack's Colon."; int count = 0; for (int i = 0; i &lt; phrase.length(); i++) { if (phrase.charAt(i) == 'a') count++; } System.out.println(count); Plus, isn't this line in the example on the site an error? char letter = it.next(); if (letter == "a") { "a" is a String with contents "a", not a character literal, which should be 'a'.
wow... it would have been nice if they included a app.yaml file in the archive.
I read this as "simulating epic failures in python"
I guess this was the intention: bugs like this one are avoided.
wow, it would be nice if ypu actually ported reddit to appengine... reddit is already open source, we don't need 300 lines of code shity clones.
I still find Brainfuck more intuitive. this program counts the letter &gt;,[&gt;+++++ +++[-&lt;------ --- --- &gt;]&lt; -&gt;+ &lt;[&gt;-&lt;[-]]&gt;[ &lt;&lt;+&gt;&gt;[-]]&lt;,][ -]+ +++ ++[- &lt;++ ++++++&gt;]&lt;.[-] +++++++ +++. Literate programming at its best!
It's not as naive as you might think. The design pattern here is similar to that of [iBatis](http://ibatis.apache.org/), which as is customary in java moves the "annotation" part of things to an XML file, but still has you writing out literal SQL for each operation on a DAO class.
Sure, no problem. It's just that it's perfectly possible to write count = count + 1 in Java as well, if you like that better.
Better than me - I read "simulating erotic failures in python" if stamina &lt; expectation: print "I'm so sorry, this never happens to me." sys.exit("Dammit")
Should be renamed to "two python functions you probably know already"
those seem like standard features in any framework
 # convert string to integer, leading zeros are stripped # '00'-&gt;0, '08'-&gt;8, '11'-&gt;11 def str2int(s): t=s.lstrip('0') if t=='': t=0 return int(t) Since the leading zeros seem to be removed to prevent it from being parsed as octal, could you just do `int(s, 10)` instead? EDIT: It's 10 by default, actually, so I don't see why `int()` isn't used instead.
Also it is ridiculous to implement using decorators and empty methods. It is not obvious which parameters the methods need so you need to read the sql. So the abstractions fails at a very basic level... @zzzeek: Writing the sql in an external xml-file is imo epic fail ;)
Not that I'm in any way a fan of PHP, but I would note two points: - Drupal can automagically make customized pretty URLs for pages using the pathauto module. - Comparing Drupal and Django isn't terribly meaningful. Drupal is a CMS. If you need a turn-key way of making a website that someone can quickly add varying kinds of content to, it might be a reasonable choice. Developing for it isn't so much fun, though. Django makes it easy to write CRUD web apps, which might include a CMS, but doesn't provide CMS functionality out of the box.
Site doesn't seem to be loading.
looks like the kind of social scientist I could get along with. Good list.
&gt;but doesn't provide CMS functionality out of the box. WTF? It automatically generates a CMS whether you like it or not.
or even worse is when projects fail with newer versions. not usually a problem for minor version changes, but when major versions become stable: upgrade!
That's older than Debian stable! (2.4.4)
back up. i had to refresh once to get it.
some good points. closure and introspection are two awesome things that one might not think about before really using python. convenience really is fun.
upvote because oauth sounds pretty cool. sounds like the rich man's voluntary cross site scripting.
Nice list - marked and packages downloaded... time to play...
Closures kind of suck in Python though. How do you update a variable in the outer scope without hackery like putting it in an array? That's my second biggest python gripe.
good point. i used to do the same thing in java-- wrap the outer scope variable in an array to get around the final key word.
via: http://www.procoders.net/?p=111 Update of ICA packages
Maybe it's uncommon, but I still develop for 2.3. I'm very conservative about changing software dependencies, much as I might like to take advantage of new opportunities (I stuck with 1.5.4 until 2.2, because the benefits of interim versions weren't compelling enough). I love to experiment with the latest stuff, be it OS versions or devtools or language implementations, whatever, but if I'm distributing something to the general public the importance of making it useful to the most people usually overrides the value of the latest and greatest tech.
Up modded for NetworkX.
Pyevolve page says: &gt; This project focus on development of a complete cross-platform (Windows, Linux) framework for Genetic Algorithms in pure python. The project is in initial development, but I'm doing great efforts to release a good version and documentation soon. By the sounds of this, it'd be better to stick with a more established package for EC in python. One is the python version of EO. Even scipy.ga is probably better, if it's made it out of the sandbox by now.
This is not about App Engine - since when can you upload and use windows dll's on there?
Something minor, but when the author is testing for a method: try: result = o.compare(s1, s2) except AttributeError: # Doesn't have that method. ... I'd prefer: if hasattr(o, 'compare'): result = o.compare(s1, s2) else: # doesn't have that method It's the same number of lines, it's much clearer that it's not expected that the method exists on 'o', it doesn't abuse the exception handling for testing things (I believe you should only use exceptions for... exceptions, not 'expecteds') and it doesn't inadvertently catch AttributeErrors that happen in o.compare. It's only a small nitpick. Great article otherwise.
Yeah I'm liking this article too (I know it's a few days old but I had to save it for later). Feel free to post some links to those other gems you mentioned, related or not :)
*Easier to Ask Forgiveness than Permission* When something is expected to succeed, it's also faster to use `try..except`. Conditions might not protect from all exceptions, either. For instance, there may be corner cases in which the operation fails where condition is passed, or state changes in between evaluating the condition and the actual action. You're right that careless catching may mask the unexpected event, but that's nothing not solved by discipline.
Err.. whaaaaat?
curious: what templatetags or filters have ya'll created (or find wicked useful)?
It generates an admin interface; it's not the same thing. That lets an administrator select and modify data in your model, but it doesn't provide any display for non-admin users, or any of the functionality that you'd often want on a reasonably full-featured website (navigation, sidebars, search, syndication, etc). 
Guy writes a type checker as a project. Guy notices it's slowing down the actual code he wants to use (which is type-checked by his code). Guy says "Hey, I'd like to be able to turn type checking on and off easily" Guy makes a mock-up of the typechecker that doesn't do type checking so he can easily swap them out. I miss anything?
&gt; I miss anything? Negative, ghostrider.
See http://www.python.org/dev/peps/pep-3104/
I'd normally agree, but not in this case. EAFP is usually employed because it makes things more readable. Not so in this case, I feel. The first example to me parses as something trying to catch exceptions in the compare method. If it were a normal attribute, I'd agree. Also, the article mentions: &gt; Let's suppose you want to write a function that'll take any object that has a method with this signature: boolean compare(String s1, String s2); Further, you don't want to constrain the objects to implementing a specific interface. So I guess it depends on how often the condition arises that an object doesn't have the compare() method. If it happens often, I still prefer my solution. The race condition is a valid concern, though I doubt it would arise very often. If methods suddenly disappear from objects, you've got bigger problems than an uncaught AttributeError. BTW, could you explain how discipline would solve the masking of AttributeErrors in this particular case? 
&gt; Ryan – July 29, 2008 @ 04:18 PM &gt; &gt; Ummm… You still have to specify an extra model. I don’t &gt; see much new functionality in this. Seems like &gt; ManyToManyField window dressing on what you could &gt; already do. this is how i see things, too. can anyone explain the advantage of using a M2M field (in the blog's example "members") instead of only an intermediate model (in this case "Membership") ? in the past i worked on an application that had an OO view of people and other things, while also having the concept of transactions and month-to-month buyin per person. sometimes i just want 3-ary relations. i wonder how often this occurs, what ya'll think of the performance or extensibility or whatever of this intermediate model approach, and whether there are other approaches. in the blog example it'd be like replacing the "date joined" field of Membership with "number of gigs this month" or something. does that make anyone think twice, or that par for the course? 
My exact thought, too. This seems half-baked. It also makes code less readable, since you have another level of indirection. Performance will be another thing, yes, but that was never a great concern, was it?
Biased performance stats? It can't be!
Interesting how the benchmark the author references includes the latest development version of ruby and not the latest development version of python..
Here's a little brain dump of some things on my to read list :) -- Here's one that was recently on reddit: **PyEvolve**: http://code.google.com/p/pyevolve/ - haven't tried it out yet. Python agent-based evolutionary engine. -- And I just found University of Texas's Neural Networks Group's research page. From this page I found out about NERO, which is this strategy game based on evolutionary algorithms. I haven't had the chance to try it out, but it's free! **NNRG**: http://nn.cs.utexas.edu/ **Nero**: http://nerogame.org Some neat topics: **Coevolution of Role-Based Cooperation in Multi-Agent Systems**: http://nn.cs.utexas.edu/pub-view.php?PubID=74978 My personal favorite so far: **Co-evolving neural networks to play Go**. *This one is a real intriguing read* http://nn.cs.utexas.edu/pub-view.php?PubID=58 **A list of all papers**: http://nn.cs.utexas.edu/downloads/papers/ -- Kevin Kelly, of Wired Magazine, wrote **'Out of Control'** in the '90s, and the chapter on coevolution is fucking sweet. You can read it for free, online. http://www.kk.org/outofcontrol/ - check out chapter 14! In the Library of Form -- Ted talks have been really awesome, just found out about 'em a month ago or so. **Susan Blackmore on Memes and Temes** (or the coevolution of cultural replicators and genetic replicators) http://www.ted.com/index.php/talks/susan_blackmore_on_memes_and_temes.html **Michael Pollan gives a Plants Eye View** (The Ominivore's Dilemma) - **also very, very good** http://www.ted.com/index.php/talks/michael_pollan_gives_a_plant_s_eye_view.html -- And **Avida**, the digital life platform that got me into it all: http://devolab.cse.msu.edu/ (Small cells have random instruction sets that act on virtual cpus, registers, stacks, and the environment to evolve routines for doing boolean algebra and more)... Got any to share? :)
man why do i fail at reddit comment formatting
Because the latest development builds of ruby are known to have great speed enhancements, whereas the latest python builds do not. But, according to http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=yarv&amp;lang2=python , Ruby 1.9 will still be slower than Python, but not as bad as Ruby 1.8 http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=ruby&amp;lang2=python .
That's interesting that the Python rand() isn't written in C. I'd think that'd be a prime example of something to write in C (as sometimes you need to call rand() a *bunch* of times, and I bet it's the kind of routine that'd be more than ten times faster in C).
the subprocess module in the stdlib is much better
I'll copy over the answer to the comment you wrote in the blog: &gt; I wouldn't expext any significant performance improvements in Python 2.6 (which might or might not be the end of 2.x series, depending on the 3.x adaptation rate), since it is basically Python 2.5 + backward compatible features of 3.0. The mersenne twister is probably going to be left untouched.
They don't seem biased to me - and I prefer Python. Like the first poster, I wonder why Python's RNG isn't written in C.
Do you know of any documents describing why it isn't written in C? This is completely mind-boggling to me. **edit:** I found a RNG written in C for Python [here](http://www.avatar.se/crng/).
See manual here: http://buildbot.net/repos/release/docs/buildbot.html
If you need fast random number generation, scipy can do it quite well: import scipy scipy.random.uniform(MIN, MAX, (AMOUNT,)).tolist()
Performance should not be affected at all by this - the underlying SQL statements remain the same as they were before the patch. The new feature allows many to many relationships with extra fields on the join table to use the same ORM syntax as regular many to many fields. API consistency is a good thing!
Thanks! All added to my list. Re PyEvolve: I haven't looked in detail but it seems to be very alpha. Might be worth looking at (eg) the Python bindings for [EO](http://eodev.sourceforge.net/) instead. I guess my main interest is evolutionary art (rather than agents/cooperation etc). One paper at the intersection of the two is [this by Miranda](http://neuromusic.soc.plymouth.ac.uk/papers/miranda_evocomp.pdf). Of all the Evolutionary Art systems I've seen, this is one of the most practical and fun: [blot](http://blot.sourceforge.net/). Lots of papers in EvoMusArt are interesting, if you have access to a Springer database. Alternatively you can browse [here](http://evostar.iti.upv.es/index.php?option=com_content&amp;view=article&amp;id=56&amp;Itemid=55) and then search Google Scholar for authors' preprints (sorry I can't recommend anything more specific, but there really is a lot of interesting stuff there!). Finally I think there is some agent-based stuff [here](http://www.pawfal.org/dave/) which I've never found time to investigate properly. If I think of some more I'll reply again...
The functions getrandbits() and random() are written in C. So you can get random numbers speedily if you are happy with the uniform interval [0,1) or integers up to a power of two.
Ah okay, after closer inspection I see how it is done with three tables. But concerning readability: why not just add the fields of the relation as arguments to the ManyToMany relation? models.ManyToManyField(Person, extra= {'date_joined': models.DateField(), 'invite_reason': models.CharField(maxlength=64)}) ) 
I don't mean comparisons between before and after this api change (the intermediate models were there before and are still there)--- Are there other ways to think of these problems? Are there other relations or data structures (conceptually...yeah, it all gets put into a particular database at the bottom)?
That's pretty neat.
Much Less readable than using a separeted model. lif you ask me.
Ah, excellent. Thank you.
It *almost* all is because it uses the system's fast urandom interface. Here is the function: def random(self): """Get the next random number in the range [0.0, 1.0).""" return (long(_hexlify(_urandom(7)), 16) &gt;&gt; 3) * RECIP_BPF and _urandom is the system random byte generator. It sort of makes sense to me that the "random" module is python because: * It's a lot of code - almost 900 lines of python. * It has some interesting/strange aspects that *really* should be readily available for someone who needs to know more about the inner workings of this module. If this was all buried in C, it would be much less assessable to python programmers.
Mainly direct access to the other part of the manytomany relation, I think: you can write `beatles.members.all()` instead of having to write `beatles.membership.members.all()`
probably because it's easier - in a lot of meanings - this way. if you want a fast RNG, there are third party ones available (e.g from scipy.)
So Ruby+C is faster than Python+Python? Whodathunkit
In that example from the docs, if you just have the Membership table with its foreign keys and didn't define a ManyToManyField, you could still say beatles.membership_set.all() So you still have that kind of direct access just from the foreign key. And if you only had the group name, you could also say Membership.objects.filter(group__name="Beatles") However, the advantage of the ManyToManyField is that you can do queries the other way. That is, with a ManyToManyField you can express queries that the foreign key alone doesn't grant you, such as Person.objects.filter(group__name="Beatles") This wouldn't be possible because "group" isn't a Person field; it's automatically created by the ManyToManyField to reflect the relationship. I've personally never used ManyToManyField for a project because all of my many-to-many relationships have needed extra fields. So this is good news for me.
Another model is InventedElswhere (TM).
Actually, that's not it either. Your quoted function comes from `SystemRandom`, but the benchmarked code uses an instance of `Random` (which extends from `_random.Random`, which in turn implements the `random` method natively). The slowness comes from using `randint`/`randrange`, which are indeed in Python.
Awesome! I'm actually very interested in evolutionary art, as well. I'm sure you've heard of Electric Sheep? I also just found out about picbreeder.com In fact, to be honest, one of my fantasy projects would be to create an agent-based simulation where the byproduct of interaction and complexity is some kind of graphical or musical assembly. I always imagined running it in the background and by listening what kind of harmonies or sounds are coming out over my media system you could judge the complexity of the relationships :) I'll check out EO, too. Hadn't heard of it. We should probably post some of these links in the evolution subreddit (or create a new devo subreddit... digital evolution?) And wow, Dave's site is awesome. I've always been interested in live coding... I'll check out the links. Thanks! Blaine
He sums up his reasoning in the second last paragraph: &gt;the same application I've written targetted to an apache environment to be used over on GAE He's a Google App Engine user. This article doesn't really give any reasoning or evidence why WSGI is better than mod_python or why more and more people are using it, just that it is and they are.
Dang gst - I can't get anything past you
Meh, something about JSON schemas in JSON doesn't look pretty enough for me...
That's not bad, but there are a number of advantages to using a separate model: * You get all of the ORM tools for dealing specifically with items in that join table * Simplicity of implementation: you don't have to duplicate a bunch of logic for dealing with model fields specially for ManyToMany extras. * Having a model class gives you an obvious place to add additional methods for dealing with those relationships * Having a model class means you can perform other common Django customisations, for example over-riding the save() method on that model to automatically set a last_modified field on the join table to the current date.
via: http://shiftpop.blogspot.com/2008/07/prolog-instantiation-modes-and-python.html
A collection of empty google code pages that manipulate reddit posters.
Click on the "Source" tab for the source code... 
Might as well grab [daemon](http://pypi.python.org/pypi/daemon) from PyPI
Yeah, that doesn't hurt readability at ALL.
Nested generators not neat enough?
Kernel programming. Software optimized for the particular hardware. Obfuscated (optimized) binaries. High reliability software. Just to name a few.
I disagree strongly with your last claim. I've found our Python projects to be of significantly higher reliability than similar Java/C++ ones. 
Device drivers. Obfuscating your code in order to obtain greater job security.
Highly concurrent single process code. Numerical simluation and computation where speed absolutely matters (just write it in C/Fortran and use SWIG :-)). Micro-controller programming. Small-scale embedded development. Kernels. Device drivers. Real-time code (though this could be debatable) 
To be fair, that might say less about Python than it says about the quality of many Java/C++ developers...
python ain't good at anything that's invoked a lot and for a short time (ie. initial python process creation is expensive). &gt; $ cat hello.c &gt; #include &lt;stdio.h&gt; &gt; int main(void) { printf ("hello\n"); return 0; } &gt; &gt; $ gcc -o hello hello.c &gt; &gt; $ time (for i in $(seq 1000); do ./hello &gt; /dev/null ; done) &gt; &gt; real 0m1.027s &gt; &gt; user 0m0.112s &gt; &gt; sys 0m0.344s &gt; $ cat hello.py &gt; &gt; print "hello" &gt; &gt; $ time (for i in $(seq 1000); do python ./hello.py &gt; /dev/null ; done) &gt; &gt; real 0m8.818s &gt; &gt; user 0m5.828s &gt; &gt; sys 0m3.088s 
Not sure about the second part.. http://neverfear.org/code/view/Guess_the_Code_2__Python_ from random import random as _ eval(compile("".join(["(lambda %s:" % (chr((121 - ((25 - (ord("z") - y)))))) for y in [z for z in range(ord("a"),ord("z")) ]])+"((a))"+"".join([")(%s+_()*%s)" % (chr(w),chr(w)) for w in range(ord("b"),ord("z"))])+")(2)","","single"))
&gt; Numerical simluation and computation where speed absolutely matters What about Psyco and Numpy? It's never going to be the quite same as regular C, but it is substantially faster than Python alone
They can definitely speed it up. If you can run multi-process, and its a great way to go. NumPy is a great library. The downside to Psyco is it was never ported to work with x86_64. If you have a lot of numerical work, odds are you have very large working sets and a lot of RAM :-)
Not bad, but compared to Perl and C/C++ it looks like baby obfu.
_IMHO_ desktop GUI development in Python is painful (as compared to lets say [Shoes](http://code.whytheluckystiff.net/shoes/)). You should also understand multithreaded restrictions in CPython due to [GIL](http://blog.ianbicking.org/gil-of-doom.html).
True, and it's far more difficult to write than obfuscated Perl (which is arguably written exactly like regular Perl..)
The proliferation of GUI toolkits scares me. All I want is to make a few small apps (pref. cross-platform), that don't look arse. I have no idea where to begin?
&gt; Highly concurrent single process code. [Ahem](http://twistedmatrix.com/).
Do people write GUI applications? I assumed everyone moved to the web...
What's the advantage of opening `/dev/std(in|out|err)` over using `sys.std(in|out|err)`?
Why not "High reliability software"?
I've done some high performance simulation code in Python (Genetic Algorithms/Neural Networks) and here's some numbers from my experience (to evolve a 3 layer network which performs XOR): Pure Python: 1.2s Python/Psyco: 0.5s Python/Pyrex: 0.15s C++: 0.12s For those that don't know, Pyrex is a DSL which allows you to mix C and Python code, which generates pure C which can be compiled and relinked with python transparently. In my experience, for numerically heavy coding, it is possible to to attain close to C/C++ speeds using Pyrex, and then you can put the heavy lifting in C and do all your other logic in Python and get the best of both worlds.
I'd be very grateful to hear what GA libraries or toolkits you used, please!
Where speed matters, there are sometimes latency requirements, and then numpy doesn't help, because the garbage collector could kick in just when your program is supposed to deliver some data. The example I'm thinking of is audio work: a synthesizer must deliver sound within about 10ms of the keyboardist playing a key (otherwise the delay is noticeable). The consensus on the linux-audio-developers list (for example) is that python isn't suitable for this kind of application.
I recommend [PyQt](http://www.diotavelli.net/PyQtWiki) and the [Rapid GUI Programming with Python and Qt](http://www.qtrac.eu/pyqtbook.html) book, which explains everything you need to get started. It is very easy to make small applications, and then some.
I didn't use any libraries or toolkits, I wrote the whole thing from scratch.
It's quite ironic he rubbishes the "BDFL came from a Monty Python skit" idea in the blog entry, but Artima uses the exact same reference in their "About this blogger" section...
trends are somewhat cyclical: first, everyone worked on one big server through distributed terminals. then, the machines became distributed. then, applications moved back to servers to be accessed via browsers. now we're back to distributed mobile devices and applications.
turns out some (many?) of scipy's algorithms are written in fortran. so fvcking fast.
thanks, two questions (which I should have mentioned earlier, because they are important): 1) if I write a program using that toolkit, do the users have to download and install some multi-megabyte library? 2) what about [licensing issues](http://www.diotavelli.net/PyQtWiki/PyQtLicensing), - I'm mildly worried about Nokia's acquisition of Trolltech etc.
Well, I should be more clear. Multi-processor highly concurrent code :-)
I think he means mission-critical, life-or-death, certified stuff. E.g., it's my understanding that the FAA (U.S. aviation regulators) only allow C and Ada for code that runs the avionics, etc. But, Python is great for proof-of-concepting this code, which can then be migrated module by module to C or Ada.
1. If you want to recompile the app, yes. However, users don't need QT on their systems. 2. Don't be. If Nokia does something fishy, the current codebase is under the GPL and as such can be forked for freedom.
Well, given the nature of scripting languages, there are three components your users would need to install. On Windows, these installation files measure as follows: Qt4 for Mingw (90MB), Python (11MB), and PyQt4 (20MB). These are hefty, but my experience has been that you gain a lot of productivity by avoiding the extra compilation step involved when your GUI code is in C++. Moreover, thanks to a number of Python utilities, it is still possible to [deploy your application in binary form](http://www.diotavelli.net/PyQtWiki/Deploying_PyQt_Applications). If you want to get started quickly, you could try installing something like [Python\(x,y\)](http://www.pythonxy.com/), which contains PyQt and other goodies. On Linux, of course, you should just rely on your package manager of choice. Regarding the licensing issues, my understanding is that the license for PyQt4 is the same as whatever Qt4 license you selected (GPL or commercial). And since Qt4 is already distributed under the GPL, I doubt there's much that Nokia could do after the fact. Even if they were to stop making new versions, there would probably be enough demand to make a fork possible. That's the whole point about open source software, after all :-) I hope that helps!
Because Python has dynamic typing and the existence of `eval()` and other dynamic programming features. It's not that you can't write highly reliable software in python, it's that you cannot write _provably_ reliable software. Generally speaking you do not want the control panel on your defibrillator/nuclear reactor/airliner/antilock brakes/warship to be even potentially susceptible to those classes of bugs that can be avoided. 
The phrase “right out of” is not being used literally here.
is stackless not good for that?
Python is a great extension language, a highly maintainable systems or "glue" language, and an adept proto-typing language, but a mediocre choice as an embedded language. Lua is great for embedding. It's small, loads fast, runs fast, and has some powerful functionality. Co-routines with tail-recursion can kick Python's arse.
No, see the beauty of python is its run-time flexibility. You can't guarantee anything about a python object because it could be anything! a method, function, variable, etc. Awesomely powerful, but the languages greatest asset is its weakness, too.
Ada is a bitch to compile. But once it did, it always ran exactly as you'd think it would. Always. Such an intriguing language...
oooh me too! :) Pyrex, you say? I am definitely checking this shit out.
This is one (rare) area where I like Perl better. In Perl, an import hook is just a sub-ref on @INC. The requirements of the subroutine are much simpler than of the Python importer.
Python's flexibility and ease of use comes at the price of performance. The sheer number of machine cycles that are required to compute "1 + 2" (steps involve creation of PyInt objects on the heap, push them on stack, locating vtable entry, checking if the addition will cause an overflow (creating a PyLong if so), creating a resultant PyInt, deleting the original objects) makes it unsuitable for heavy number crunching. [Actually I lied (a bit), the first few integers are pre-allocated, and the VM has a hack to optimize integer addition (which avoids vtable lookup).] Serious number crunching, like in streaming media, games, raytracing, volume rending etc require exploiting the SIMD capability of the processors -- which is simply not possible in pure Python code, which wraps each integer/float within an object. It is used heavily in server-side stuff, because frankly, it is easy to scale up the infrastructure to a level that hides Python's performance issues. Typical python code spends 50-60% time in the stack-based VM. The GIL prevents a true JIT implementation. Python *is* good as a first language and as a prototyping bed. 
Fixture 1.1.0 released: http://pypi.python.org/pypi/fixture/1.1.0
&gt; The GIL prevents a true JIT implementation. The GIL is orthogonal to JIT compilation. (See Psyco and PyPy, for counter-example.)
&gt; Multi-processor highly concurrent code :-) Twisted is good for writing not just multi-processor but multi-*host* highly concurrent code.
&gt; Serious number crunching...is simply not possible in pure Python code While the library itself isn't written in Python, [NumPy](http://numpy.scipy.org/) allows serious number crunching via Python. EDIT: Adding more info: &gt; Python is good as a first language and as a prototyping bed. Also, not everything requires the best performance. Plenty of desktop apps are written in Python because you might as well use CPU cycles that would otherwise be wasted be used to make the programmer's job easier. But yes, if you *do* need those cycles (examples include severely low-spec machines and things that aren't easily possible even using NumPy), then Python is the wrong choice.
Regarding NumPy: It does substantiate my statement about "not possible in *pure* Python" if the best number cruncher for Python is written in C. 
All I meant was that just because you're doing serious number crunching doesn't mean you should gloss over Python+NumPy.
&gt; "not possible in *pure* Python" ...not possible in pure *CPython*. CPython is intentionally not clever about optimization, but implementations like Psyco and PyPy are able to optimize pure Python data crunching code quite well.
Really? If I wanted to add a few smallish numbers in C, I can do: unsigned fn(unsigned *vals, unsigned n) { unsigned r = 0; while (n--) r += *vals++; return r; } The compiler has enough information to generate a 3- or 4-instruction loop (we're not talking SIMD at all, just plain ints). In *pure* Python, I can do: def fn(vals): r = 0 for v in vals: r += v return r If you're a JIT compiler faced with compiling an invocation of fn for a given 'vals', what would you do? Iterate through all vals (which might not be a good idea: what if vals is a file object?), establish that they're all ints and then generate a 4-instruction loop? What about overflow? What about the next invocation? What about the time taken to generate optimized code vs. time taken by the code itself? Psycho, pypy, starkiller etc do whatever they can, but the language itself does not provide enough information for an efficient JIT -- but then, that is why you chose Python, because this makes it so convenient to write the program in the first place. And just for the record, I love Python too. This "problem" is shared by all "duck-typed" languages. 
Interfacing with C++ libraries. Too bad, I'd love to use python to drive some C++ projects.
Have you tried boost.python?
 def fn(vals): r = 0 for v in vals: r += v return r Speaking about PyPy's speedboat RPython: Due to RPython's restrictions, PyPy can infer that v is an iterator of numbers (=ints, floats, ...) in this case and optimize accordingly, since r is initialized as an int. 
Python supports coroutines. It doesn't has built-in tail-call elimination because Guido passionately hates functional programming and loves to screw us with that, but you can get it done with a decorator.
C is error-prone, naturally obfuscated and weakly typed. Python is easy to get right, naturally nice to read and strongly typed. The only advantage C could have over Python on reliability is that a manager that couldn't tell a computer from a pizza has heard of C, but he hasn't heard of Python, or thinks Python is some sort of hackers on steroids/corruption of lulz language.
It still has the GIL, therefore it doesn't do so well with more than one processor. The GIL is a giant drawback to CPython and its family, and a shadow of Python that gets bigger and bigger as everything moves to multi-processor computing even at home. I'm unsettled at the community ignoring/not caring for this. Removing the goddamned GIL should be Guido's first priority.
| Yeah, that doesn't hurt readability at ALL. Actually, I really like this idea. It's clever combination of generator functions and operator overloading to create a syntax which is highly readable to anyone familiar with the UNIX command line. I'm not suggesting that this should immediately be adopted as a standard way of coding Python, but I could see myself wanting to use this syntax under the right circumstances. For example: x = "milk,eggs,bread".split(",") | grep("e") | sort | list Has a definite appeal in a certain context, and is more succinct and easier to read than: x = sorted([item for item in "milk,eggs,bread".split(",") if "e" in item ]) Reading from left to right (as I am prone to do), the first reads: Take the items as separated by commas, select those containing "e", sort the result and put it in a list. While the second reads as: Give me the sorted result of the list each item in "milk,eggs,bread", separated by comma, and selecting only those containing "e". In this instance, I definitely prefer the former. 
True. But its a double-edged sword. Would you want your defibrillator code having to juggle pointer arithmetic and worrying about memory management? 
If the GUIs are your problem, you have no reason to be Grumpy, Simon :-) Seriously, Python has a lot to offer in terms of integration with GUI toolkits. I have ample Perl experience and worked with Ruby too, and Python is the best in this respect. Both Wx and Qt are great-looking, cross-platform toolkits that work very well with Python. Each has a book written on its Python integration, so getting started is easy. Personally I prefer Wx because of its freer licensing model, and I've had no trouble writing beautiful, fast GUIs in wxPython.
I have to agree with this. I love python, but the the GIL is a problem. 
Python is pretty trivial to extend. Not as easy as embedding Lua in your c++ project, but extensibility via c/c++ is one of its strengths.
&gt;shared by all Objective-C is duck-typed and isn't bytecode. It's a little slower than C++ though, because methods have to be looked up in a hash.
so what would you have to do to elimate GIL in python?
You can get around the GIL by using processes instead of threads, e.g. with [pyprocessing](http://pyprocessing.berlios.de/) or [parallel python](http://www.parallelpython.com/). The former one will be included in the standard library of [Python 2.6](http://www.python.org/download/releases/2.6/NEWS.txt) under the name "multiprocessing", as [PEP 371](http://www.python.org/dev/peps/pep-0371/) for including it has been accepted.
I love Python, but there has been some problem or other with pretty much every Python SOAP client library I've ever tried so I have to agree with this one.
I wonder, do Python programmers typically use an IDE?
no. they use emacs or vim.
Well, I strongly disagree. If you don't want your inbox full of mailing-list messages, then use a decent email client and sort the list messages into a different mailbox, with auto-delete after some number of days. My own rant, if I chose to write one, would be directed toward online web forums. Each one has a different user-interface and requires one to go to that site and seek out the day's traffic. 
wingide is my favorite python ide. Oh, maybe I am not a python programmer yet.
How error-prone the language is really is rather irrelevant in safety-critical systems. What matters mostly is whether it can do Real Time and how hard it is to (mathematically) prove the code is correct. Python can't do RT, and even if it could, you'd have to strip all the nice features (garbage collecting, dictionaries, anything dynamic, etc), and you'd up with something remarkably like Ada, no doubt. Then there's the problem of Python not being bare-bones enough.. it's too heavy to embed in systems that are used by safety-critical systems. Python may well be more reliable than Java or C++ programs, but that's in the business-application world. 'Pretty reliable' isn't good enough when you're writing safety-critical stuff, so you have to *prove* it's reliable. Proving is easier if there's less to prove, so C or Ada are better in that regard. Besides, there are C and Ada compilers that have already been audited to death, but the Python language/Virtual Machine and compiler have had no (safety-critical) auditing whatsoever. So, no, I don't think Python is a better choice.
Use processes, not threads, and the problem goes away. Not just that, but you also don't have to take care of deadlocking, lifelocking, etc. Using processes also forces you to create well-defined interprocess communication instead of this crazy 'lets all write to the same memory at the same time' stuff. I hear some many people whine about the GIL, but I've never actually encountered anybody that had a problem with it in practice.
[Kiwi](http://async.com.br/projects/kiwi/) makes GUI programming with GTK in Python very much less painful.
&gt; A conversation between t2 dean and I I'm sorry, if you don't know enough English to know that it's "a conversation with me" and not "a conversation with I", I can't bear reading your stuff.
Be prepared to break most C extensions. PHP supports threaded operations, and even though threads don't interact at PHP level, and despite the VM and thus extensions API being designed with threads in mind, it's barely usable for most people because either extensions themselves, or libraries they link to aren't themselves thread safe. It might also be desirable to change relied-upon (but perhaps undocumented) behavior of base types wrt atomicity, which could break pure Python.
A friend of mine keeps lamenting gc in Java even for non-realtime work. Apparantly garbage collecting many-GB processes can be.. awkward unless your latency requirements are measured in tens of thousands of ms. Of all the things you'd expect to have Sufficiently Advanced Garbage Collection...
MPTT in a relational database is stupid and dangerous. Just use a parent_node field. If your tree is crazy deep, keep a real tree in memory that can recreate itself from the database.
that is good easy to enable Aspyct in your project or on your machine.
&gt; Really? Yes, really. Testing `fn` with `timeit` gives the following results (with 10k numbers as input): 1. CPython (list) 1750 µs 2. Psyco (list) 72 µs 3. Psyco (array) 38 µs 4. C / Pyrex (gcc -O2) 14 µs The first two tests are with a plain list of Python `int`s, and represent what you would typically expect from Psyco for this kind of code, without other optimization effort. The third test I optimized by replacing the `list` with a more efficient integer `array` (avoiding `list`'s indirection and space overhead) and using indexing, which Psyco specifically optimizes ([details](http://psyco.sourceforge.net/psycoguide/node29.html)). This is probably represents about how close Psyco's performance can get to C, in this case. The fourth test is just the C loop, wrapped in Pyrex. Note that all the Psyco-optimized code is still pure Python, and retains full Python semantics: `int`s overflow to `long` instead of returning incorrect results, the input list can still contain `float`, `complex`, or arbitrary user types, the called code can raise exceptions, and so on. &gt; Psycho, pypy, starkiller etc do whatever they can, but the language itself does not provide enough information for an efficient JIT The language doesn't need to: the program's execution provides the JIT with the information it needs. If you call a function with `int`s, Psyco specializes it for `int`s. If you call it with something else, Psyco falls back to the slower generic implementation (or specializes it for whatever you called it with). (Note that Starkiller is a static inference engine, not a JIT compiler; you can't really evaluate it in the same context as Psyco or PyPy's JIT.)
are there any stories of projects that greatly benefit from implementing something like this?
I'd like to hear more about AOP as well. The explanation on Wikipedia seemed fairly good (most discussions of programming paradigms I've seen in my coursework seem to only mention it, if that), but stories of successful (and unsuccessful) attempts at using it would probably make a nice read. 
So the solution to threads sucking is to not use them? Sure, the problem of threads goes away... And you get the problem of IPC. With processes, you can't rely on the language features that make Python strong, which is the reason why I'm using Python in the first place. On top of that, you leech more CPU time than you should. &gt; I hear some many people whine about the GIL, but I've never actually encountered anybody that had a problem with it in practice. Of course, and that's because whenever somebody needs to rely on multiple cores, they don't use Python because of the GIL.
Many of the current extensions will break, and the atomicity of certain operations could change (which means backward-incompatibility), but this is a necessary step to allow Python to evolve. They already took this kind of decision several times, such as Python 3000 which is backwards-incompatible, so what's the big deal? If you never ever want to break anything, you'll never allow improvement.
Seems like overkill to me.
I would almost like to leave a comment on his blog, though I didn't see a comment box. In Point #3, he complains about weak classes. His complaint should be directed at the default metaclass, I think. You can get stronger control of a class by using properties and slots and other tricks, but if you really just hate the way Python classes work, you can always write your own metaclass. For Point #1, I can sort of understand him. Most python modules I've seen are fairly well documented, but people who auto-generate wrappers for C/C++ libraries seem to have an annoying tendency of not providing docstrings for individual functions.
As compared to what?
Lame.
Not a lot of descriptions or examples here :-)
Useful for tuples and sorted lists.
I much prefer using a daemonizing app for most purposes; making a daemon out of a normal python script simply consists of running daemon myscript.py. http://packages.ubuntu.com/feisty/utils/daemon http://www.clapper.org/software/daemonize/
Sounds good to me. Who needs to waste time learn some silly office macro language when you already know Python?
Biggest lesson to take away from this, of course, is that you shouldn't optimize until you find your bottlenecks! Still, interesting piece.
Bottom line, Django is a framework. You can't compare it to Drupal, you could however compare it to Zend. It is not a great blogging software... well, because it's not a blogging software. There are however many blogging apps made for it. And it takes about a day to build your own custom blog from scratch.
Is any nontrivial piece of software provably correct?
&gt; But yes, if you do need those cycles (examples include severely low-spec machines and things that aren't easily possible even using NumPy), then Python is the wrong choice. What about turning the bytecode into a native executable? Eg, Psyco (or however it's spelt).
&gt; Both Wx and Qt are great-looking, cross-platform toolkits that work very well with Python. As is GTK, which looks native on both Linux and Windows XP/Vista. Additionally, it's used for for most Linux install and config tools.
&gt; Use processes, not threads, and the problem goes away. You mean 'use multiple single-threaded processes, not a single multithreaded process'. Either way you're using threads. 
Python won't serve you well in a streetfight. It's also poor as a sex aid.
That's true, and Psyco is a great choice at many times. I can still think of times when you'd want to control every last bit of your program. For example, I wouldn't exactly consider Python for GameBoy Advance programming, even if it were possible.
I'm not sure I like the idea of using a source parser to parse config files - config files have flatter, simpler structures than source does. Rather than try to remove everything that's inappropriate from the Python parser, why not make your own, smaller, more reliable parser? Especially as 99% of config files are option = value or [section] option = value
There is actually a HUGE difference in execution time depending on how one invokes python interpreter. "./script.py", "python script.py" and "python -O script.py" (latter may be invoked such way if hashbang -line in script header has -O option) all have different performance in tenth-of-a-second range even on Q6600 class processor. When executed hundreds of times, this multiplies.
The goal wold be to make the software in question as trivial as possible. I think though, that we are using different senses of the term _provably_, and that you are approaching it as a maths problem (categorically impossible for program x to achieve state y) whereas I am using a more pragmatic engineering sense (highly improbable that software x could reach state y during the lifetime of the universe).
Why should it be a dictionary? The class has a subscript operator defined, a common piece of functionality not unique to dictionaries. 
`argparse` is way better than `optparse`. It returns a namespace, for example. You just apply `vars()` to get the dictionary. http://argparse.python-hosting.com/
Options doesn't need to be a disctionary... but it's __str__ method (the one called when you do "print options") implies that it is and in python, if something looks like a duck, you expect it to act like one.
see: http://sourceforge.net/projects/revj/ and: http://developers.slashdot.org/article.pl?sid=08/08/03/1915258&amp;from=rss
Both of you (TFA author and optparse developers): lern2duck-typing. On one side, while I don't think this is a major flaw in the standard library, I think optparse should be more careful and mix the usual mapping methods in. On the other side, TFA shouldn't be annoyed that things look to be something but aren't exactly that.
Hm. On the one hand, there's already ConfigParser in stdlib, on the other hand, if you want to tailor config files to programmers' needs, just go with the approac moinmoin etc go: use real python files and let it be the user's responsibility to only put sane things in there. He's been warned.
can't you do it like in pure python? call the string type on the pyobject you want \_\_str\_\_ from and voila, you've got your string.
The epeg thumbnail of the grass looks a little "boxy".
Looks like only an incremental improvement. What annoys me most about optparse (and looking at [this](http://argparse.python-hosting.com/wiki/ArgumentParser/add_argument) the same applies to argparse) is the un-memorable API, packing methods with long lists of optional parameters (with side effects on others?) and needing to rely on examples to understand the intent of the API - I don't like the "distance" between configuring and using optparse. IMO you have to be at least as good as Perl's [Getopt::Long](http://perldoc.perl.org/Getopt/Long.html), which is not entirely pretty but doesn't get in the way. Consider #!/usr/bin/perl -w use Getopt::Long; my $DEBUG = 0; my $TARGET = "/tmp"; GetOptions( 'debug' =&gt; \$DEBUG, 'target=s' =&gt; sub { -d $_[1] or die "Unkknown dir $_[1]"; $TARGET = $_[1]; } ); vs. #!/usr/bin/env python # -*- coding: utf-8 -*- import os from optparse import OptionParser, OptionValueError def dir_exists(option, opt_str, value, parser): if not os.path.exists(value): raise OptionValueError("dir %s not found" % value) setattr(parser.values, option.dest, value) parser = OptionParser() parser.add_option( '-d', '--debug', action='store_true', default=False ) parser.add_option( '-t', '--target', type='string', action='callback', callback = dir_exists, default='/tmp', dest = 'target' # required here - why?!? ) (opts, args) = parser.parse_args() Meanwhile, for python, haven't used it but like the sentiment behind [anoption](http://laurentszyster.be/blog/anoption/) &gt; Why not use the introspection capabilities of Python instead? 
Yeah but the "it looks like a duck" part talks about the object's interface: Does it have the methods and attributes that you are looking for? Yeah the __str__() method does look like what a dict's __str__() looks like, but that's __not__ duck typing.
which one is faster? Where can I find documentation about this?
PIL is written in C...
I agree, and you can see color depth quality differences in the other images. Time seems to correspond to image quality.
As smart_ass said, you're right. It looks like epeg did a "nearest-neighbor" downsampling (aka, quick, but shit). I'm guessing that ImageMagick is using a bicubic resampling filter, and PIL is using a bilinear. Which would explain the quality and speed differences. In other words, this is a benchmark of different algorithms, not languages.
you're right.. i didn't mean to imply that this was a case of duck typing.. but the general sentiment applies: an object should behave the way a user expects it to based on certain cues (like it's methods/attributes but also it's name and outputs). 
Simple guide for making the best of testing it: Checkout the SVN at http://kaishi.googlecode.com/svn/trunk/ (or, if you don't have SVN or only want to do a quick test, download the following two directly at http://code.google.com/p/kaishi/source/browse/trunk/kaishi.py and http://code.google.com/p/kaishi/source/browse/trunk/kaishi_chat.py ) Note that if you download the files directly, you will not be able to update your copy with SVN. You must use the checkout method for that. After downloading kaishi.py and kaishi_chat.py to the same folder, execute kaishi_chat.py and watch as kaishi bootstraps your computer on to the network and notifies all known peers. You can then type /irc and press enter, and a local IRC server will be started on port 44546. Open up mIRC or XChat or IRSSI or whatever your client may be, and connect to 127.0.0.1 You can then enter messages like IRC, even /me's, and /nick changing. Edit: After receiving reports that XChat was not handling the auto-join correctly, I've committed a fix. If you were having problems, update your copy and re-open it. Edit 2: I've set up a nice graph for monitoring network usage at http://vector.cluenet.org/~tj9991/kaishi.php I'd also like to ask why I've only spoken with three people over the network. I'm glad that the project is getting some positive support, but it looks like a lot of people aren't taking the step to try it out.
Well I do agree with you that the original writers should have probably chosen a different implementation of the __str__() method just to avoid exactly this mistake.
Unfortunately, Python does not support full-fledged co-routines. A Python generator cannot yield from both a function and a function called by that function. All yields for the generator must be in the same function. This is a problem for lots of algorithms, and it prevents re-factoring large generators. The decorator idea is interesting. Thanks. But it does not have the efficiency of a goto. It does two things: 1. It circumvents the recursion-limit. 2. It allows a yield to occur within a recursive function. But my point is the runtime advantage of Lua for some algorithms.
Um...why are you constantly creating and removing threads? It's painful to read... 
In your example, you ignored the most important part, the help message. Yes, if you do not need metadata like that, then you can live with a function that takes a dictionary as its only parameter. It's a matter of taste: Do you prefer terse code or helpful messages? As for unmemorable APIs, Getopt::Long gets quite complicated if you want to do more interesting things. I end up referring to perldoc whenever I use it. `anoption` looks interesting. Thanks.
The cheat sheet is at http://added-bytes-cheat-sheets.googlegroups.com/web/python_cheat_sheet-0.1.png The developer can use some feedback, so this should be a good place :)
Introduction here: http://foolscap.lothar.com/docs/using-foolscap.html
I couldn't agree more. We've been bitten by the exact same problems for the same use case (database access). It's been causing us no ends of hassle. With __getattr__ you're also likely to pay a performance penalty, too, especially when you're querying the object for attributes it doesn't have. The only way to avoid that would be to add automatic caching of failed attribute accesses, a quite horrible construct if you ask me.
tried to connect but it appears the server is not responding?
You don't want this. Chris Hoffmann / Richard Gruet's Quick Reference Guide is far better: http://rgruet.free.fr/PQR25/PQR2.5.html 
&gt; In your example, you ignored the most important part, the help message. Yes, if you do not need metadata like that, then you can live with a function that takes a dictionary as its only parameter. It's a matter of taste: Do you prefer terse code or helpful messages? That's a fair point, one that I was slying avoiding. In Perl was happy with Pod::Usage but the way optparse does help is quite compelling.
Agree
PIL's ANTIALIAS resampler uses [Lanczos interpolation](http://en.wikipedia.org/wiki/Lanczos_resampling). In some simple tests I just made, it's about 400 times slower than PIL's nearest neighbour resampler.
akov! you're GOD!!!
Good to know. Thanks.
The only thing I can think of which would prevent you from making connections is having port 44545 blocked, or having a local firewall somewhere along your connection. Other than that, the only real server which is connected to is the provider, and that is just to retrieve a list of known nodes.
Very interesting. I knew all about \_\_getattr\_\_ and \_\_getattribute\_\_ but not about \_\_get\_\_.
I'll have to try this sometime. Office I work at makes PL/SQL generated webpages. Moving to Coldfusion. Really would prefer something more popular since Coldfusion seems like a bad choice if they were to try to hire more developers.
Meh, I wouldn't know where to start. Maybe the fact that almost one entire column is dedicated to date formatting usage for a single function? I mean, seriously, how often do you need to consult your cheat sheet for information on date formatting? He spends one entire line telling me that 'platform' is the sys variable for the current platform, but I have no idea what "rpartition" does because it gets half a line mixed in with a bunch of other methods operating on strings.
Coldfusion is a pretty bad choice, if you're already using oracle then you try looking at Oracle ADF Faces, its actually a pretty good framework.
Glad to know that Python has an equivalent of AUTOLOAD from Perl. It'll make my forthcoming "learn Python by rewriting my Perl codebase in Python" project much easier. 
Yeah from what little I read about Coldfusion, I got the feeling Coldfusion would be terrible for a small operation like ours. Or operation of any size. But they had bought Coldfusion license at some point and there's a guy working here who's all about Coldfusion. Convinced the boss it's the way to go. Probably won't stick around here long if they do go through with it. EDIT: I'm for Java personally. Even ASP or PHP would have been fine since we develop/manage other apps written with those. But it looks like we're going to be ASP/PHP/Coldfusion/PLSQL on MSSQL/MySQL/Oracle ... shop.
Zing! You win this thread. Discussion officially closed. Hey-yo!
If I could ask GvR a single question in an interview, after thanking him for his work (I'm pretty happy overall), I'd ask him one thing: "Why do you hate functional programming with such a passion?".
They consider atomicity to be a bigger deal than the GIL. I for one would agree.
Next up in the "Comparing..." series: Apples to oranges!
There are plenty of situations where either C or Python would be a reasonable choice for a project. This post gives some pragmatic insights into the pros and cons of each in a real project. 
Most interesting part was the mention of auto-generation of C header files. What tools exist for this? Header files are horrible.
In this article, we have gone from start to a full application in no time.
Umm... why?
Kind of discouraging.
That's merely a wiki page that just started. That certainly isn't EVERY django success story in the world. Even http://www.djangosites.org/ which has over 1500 submissions isn't EVERY django site in the world. I use Django for a bunch of internal sites and services which are all "success" stories. You aren't going to see those sites on any public webpage... Your comment is kind of discouraging. 
Oh God no. Think of the Apple fanboys.
This guy is just rambling. I think he's off. "OpenGL seems pretty painless in C. I haven’t done any notable OpenGL stuff in python, so I can’t really compare the two."
The thing is, one _can_ compare apples and oranges. They're both sweet fruits; they're both commonly eaten out of the hand. They are eminently comparable. And so are C and Python.
So which is better, apples or oranges?
nice! Now can we make PS not take so long to load?
All five!
Im other news, the trunk is now a 400 mb download 
Summary: C is an old and rigid programming language, and Python is not.
Just so it's clear, GeoDjango is a contrib app and you don't have to install any new 3rd party apps to use all the normal Django stuff. A trunk checkout right now is ~16M (with tests, docs, and everything), and GeoDjango is ~2M of that.
Grapes.
&gt; Guess [who](http://www.youtube.com/watch?v=v1gTI4BOPUw) writes its applications in it. Wow, Guido van Rossum writes applications in Python!!
oh this is nice.. i've scripted using photoshop using vb and hated it.. this really should make my life a bit easier
Awesome! I needed this! Django is being developed at incredible pace these days. I can't wait for 1.0
this nice... but it's missing a bunch of stuff and it's not particularly visually compelling and makes poor use of screen space. But, hey, it's free...
Maybe so - but why would I want to make my nose run ?
via: http://googleappengine.blogspot.com/2008/08/deep-dish-on-app-engine-developer.html
See also: http://unpythonic.blogspot.com/2007/06/latest-pida-release-explicit-is-better.html
0.5.1 was released July 2007, 5.2 is still pending.
This vector problem should just be cross and dot products, not a whole lot of complicated if logic.
or you can just use emacs ;)
vi you heathen! :)
Pff.. ed FTW
Butterflies, imo. 
Looks interesting. I had been using SPE for the last few months. Will have to give it a go.
via: http://leonardo-m.livejournal.com/67560.html
This feels almost exactly like E Text Editor.
Now that's hilarious!
That is awesome.
I've come to love the goto statement's underdog position. It has become such a frowned-upon thing that many programmers will jump through the weirdest hoops in order to avoid it because they think it makes them look stupid. I've seen algorithms which could have been made a lot easier and more efficient by simply adding a single goto statement, but no, "it's against the law". I'm sure all the drones mindlessly following convention for the sake of convention are making Dijkstra's body spin so hard in his grave, we could power an entire country on the energy his body is creating.
http://xkcd.com/378/ *Spoiling an inside joke for the sake of promoting XKCD since September 2005*
That navigation at the top of their site is irritating. Hmm. Their Mac download link has the wrong headers, my browser is trying to display it as a text file. I use TextMate, and I really like it, but it's not perfect and it's not cross-platform, so I'll take a look. Ah. It crashed. It looks like maybe it didn't like Stackless Python. How about source? Good, it's working now.
Featuring this reply from Guido van Rossum: [Why I put 'else' on loops in Python](http://leonardo-m.livejournal.com/67560.html?thread=38632#t38632)
Like every language feature, it has its uses. The problem is many programmers are uneducated and addicted when it comes to goto. An idiot's solution is to prohibit gotos (there's crime in the street, let's ban streets!). Java designers are addicted to this policy, and that's how we got useful features such as operator overloading out of it. A smart person's solution is to provide ways to control goto's complexity and make it more obvious to the reader. We call these ways to jump **break**, **continue**, **return**, **try/except/raise**, **call-with-current-continuation**, and my favourite of them all - **tail-call optimization** (psst, is there anything here that's missing in Python?). You hardly ever need to jump in a different way, and all of these constructs or features are useful and simple to understand.
I guess i really should have added: {% endsarcasm %}
The comments are worth the read.
Very nice. This could be the lightweight Python editor I've been searching for!
People have to remember that when Dijkstra wrote his famous essay, using goto was more common than using if, while, etc. Goto has its place, but it's rather rare.
comefrom is the best language construct ever. ok not really, but still, it would make for great obfuscation contests
TextMate
I already have Ubuntu on my eeepc, I like my Mac the way it is.
Joke had been duly noted, thanks for the suggestion, I like it better already ;)
I believe "comefrom" originated in [INTERCAL](http://en.wikipedia.org/wiki/INTERCAL), which had a lot of other great features. My favorite is the "PLEASE" keyword, which does nothing by itself, but if you don't prefix enough statements with it then the compiler will exit with the message "PROGRAMMER IS INSUFFICIENTLY POLITE." 
Intercal also had the great feature of being OVERLY polite. So you had to keep your ratio of using please to a certain band. Of course the band was not documented...
via: http://ironpython-urls.blogspot.com/2008/08/web-based-dlr-ide-with-mdbg-debugger.html
My first editor (after trying emacs for about 5 minutes), and I really like it, of course, I don't have much to compare it to...
TCO can be done in Python, but it has to be done by using decorator on your function. By default, there is no TCO, since Guido worries it would make the tracebacks on errors too complicated.
&gt; TCO can be done in Python, but it has to be done by using decorator on your function. FWIW, of the handful of TCO decorators I've looked at recently, I think that [this one by Miguel Perez](http://groups.google.com/group/comp.lang.python/msg/9b047d1392f2b8ec) is the best. It is certainly a lot more elegant than [the exception-based approach](http://code.activestate.com/recipes/474088/) I'd seen used before.
Amazing and evil and hilarious, but over four years old so no upvote.
Heh, I'm Miguel Pérez. I'm glad you like it.
Yup, I've been using my decorator in Python. I think Guido just dislikes functional programming and doesn't want to allow much of that in Python (hence keeping statements, making lambda unable to use them and def unable to be used as an expression like JavaScript's function, and not implementing TCO). I think there are ways to prevent TCO from making tracebacks complicated. A first approach would be to implement TCO for calls to the same function only, and make it replace the last entry in the traceback (and the last stack frame, of course) with the new call and a new property tb_tc_counter to signal it has been tail-calling itself (0 = no TCO performed, 1 = first time, etc); then you could show something 3 x File "...", line n, in f. The next thing would be to implement a way to detect cooperative recursion, perhaps by using a set of the functions that are alive in the stack frame and checking whether a function called in tail-call fashion was previously tail-called as well.
This is why I love reddit.. :)
&gt; Yes, it works, but it's a joke nevertheless. Please don't use it in real code! Why? Honestly.
I don't think this guy is that knowledgeable about betting bots. For anyone who does want to write one, there's quite a good forum at diybetfairbots.lefora.com/forum/. (I've got no connection to it, other than using it now and again.)
I'll sum it up: WAAAAH 64 Bit compilation didn't work out of the box, someone come change my diaper! 
&gt; I'll sum it up: &gt; Lame There, fixed it for you.
this sounds cool. normally i specify a PYTHON_PATH and put stuff in site-packages; are there times when this isn't appropriate?
dump and load are definitely cool...but hugely basic. are they not mentioned in the tutorial or something? eit, i know it's not a big deal--i probably have 10 thoughts a day about something being cool and for everyone else it's so basic as to escape notice--but still, dang; there are only so many commands, and having a small dev dataset to load while straightening out the models (and dropping tables now and then), is crucial. 
Funny, I would have thought that a more obvious solution would be to symlink in /usr/local/bin.
Looks good, based on the outline, but the title could be misleading - it seems to be focused on matters related to software development, rather than those specific to Python. I'm also a little concerned about the stated goal of explaining "How to set up a development environment", as, barring some special insight, that doesn't seem very expert at all.
It's not a Python bug. In my opinion, it's an unintuitive reality of the C standard library design.
I use Environment PYTHONPATH too， only meet one flaw now. the PYTHONPATH put's itself before normal sys.path (such as site-packages), and site.py need import locale. if my pylib(on PYTHONPATH), has a subdirectory "locale", script will say: warning: Not importing directory 'D:\my\pylib.package\locale': missing __init__.py 
I think I like it. The information is right where it belongs and it is parsable and easily accesible in the function's metadata. So there is a real incentive to use this information. Then, the docstring can only contain text on what the function does. Makes it all cleaner.
I don't really like this. That's basically because of the first two examples: one is using this functionality to add comments to the parameters, the other uses this to add type information. What if I wanted to do both? If there are going to be several popular libraries that use this information, each expecting something different and for different purposes, it's going to be a mess.
I like this. I see it as an improvement to the built-in documentation features, or as a source for awesome stunts. I would have hated it if the language checked types with this; I find duck-typing to be one of the strengths of dynamic object-oriented languages such as Python. I want it to work as long as it works; the marginal gain in security or the potential bugs avoided with more explicit typing aren't worth the type juggling and hacking, the worse extensibility and the class hierarchy hell that could arise if you wanted to do something useful. Note: For those of you who want type-checking, implement your own with a decorator. You don't have to wait for Python 3000; you could very well do this with Python 2.4+ and with a pretty nice syntax; I'll post one of such decorators if you're interested.
I guess this part of the PEP addresses your concerns: "Despite yet more discussion, it was decided not to standardize a mechanism for annotation interoperability. Standardizing interoperability conventions at this point would be premature. We would rather let these conventions develop organically, based on real-world usage and necessity, than try to force all users into some contrived scheme."
This python book of Tarek Ziade (in french only, i think) was very good. I don't know about this one : it is more about software development thant Python. A good in-depth explaination of the C-code of python would be better, like a comparison of the many ways to extend python. A word on a how to do an extension in Haskell would be good :). Well,... fun at least.
I've done a little hacking on XUL compiled with python support.And I've common across this library but haven't seen a real use for it. Where do people use it?
True. On reflection, the Python developers have always had better judgement than I in the past, so I'll just wait and see how it works out :-)
I also like duck typing. There are times when I would like a little more, though. One example is when trying to use a library that I haven't used before and not being sure what sort of types a function requires. I rather like the bit of the PEP that says "Let IDEs show what types a function expects and returns" because experience tells me that the alternative is me getting frustrated by an exception stack trace with "object is unsubscriptable" deep within some library code when I get things wrong. 
PS I would be interested in seeing an example of such a decorator, although I guess it wouldn't give info to the IDE in the way that I'd like to see ;-)
&gt; I don't really like this. That's basically because of the first two examples: one is using this functionality to add comments to the parameters, the other uses this to add type information. What if I wanted to do both? Looks like it accepts any expression, so you could just use a tuple: def compile(source: (basestring, "something compilable"), filename: (basestring, "where the compilable thing comes from"), mode: (Mode, "is this a single statement or a suite?"): 
I use that for http://www.deadmansswitch.net/, it's the best OpenID Django app, it also supports traditional reg and it's being actively developed.
Why so not-descriptive title? The module is useful (I use it happily), but the title suggest rather Python Standard Library.
I spent some time trying to find something better but couldn't :/ I suck at words.
To know what kind of object a function expects, you should rely on its documentation (docstrings or library reference). This gets better in Python 3000 as there's a per-parameter docstring (or tagged object), and IDEs could grab this and show it to you, producing the same effect but without the cons of static typing.
Here's an example of a type checking decorator for Python 2.5. It has a pretty comfortable syntax. @xdecorator def typecheck(f, **req): '''Implement easy to use type checking (particular case of check). Use: @typecheck(a_string=basestring, an_int=int) def f(a_string, an_int): ... Raises TypeError on error. typecheck must be directly decorating the function (i.e. no further decorations between @typecheck and def f) and it can be used only once. You cannot use both typecheck and check with the same function. ''' paramnames = f.func_code.co_varnames[:f.func_code.co_argcount] def _(*a, **aa): for i in xrange(len(a)): if paramnames[i] in req and not isinstance(a[i], req[paramnames[i]]): raise TypeError( 'Typecheck constraint failed for parameter %s; expected %s, got %s' % (paramnames[i], req[paramnames[i]].__name__, type(a[i]).__name__)) for i in aa: if i in req and not isinstance(aa[i], req[i]): raise TypeError( 'Typecheck constraint failed for parameter %s; expected %s, got %s' % (i, req[i].__name__, type(aa[i]).__name__)) return f(*a, **aa) return _ A similar decorator will allow you to check for more generic stuff using predicate functions: @xdecorator def check(f, **req): '''Implement easy to use arbitrary value checking. Intended use: even = lambda x: not x % 2 @check(func=callable, number=even) def f(func, number): ... Raises ValueError on error. check must be directly decorating the function (i.e. no further decorations between @check and def f) and it can be used only once. You cannot use both typecheck and check with the same function. ''' paramnames = f.func_code.co_varnames[:f.func_code.co_argcount] def _(*a, **aa): for i in xrange(len(a)): if paramnames[i] in req and not req[paramnames[i]](a[i]): raise ValueError('Check constraint failed for parameter %s' % paramnames[i]) for i in aa: if i in req and not req[i](aa[i]): raise ValueError('Check constraint failed for parameter %s' % i) return f(*a, **aa) return _ Both of these decorators rely on this convenience meta-decorator: def xdecorator(f): '''Decorator for decorators, thus a meta-decorator :) . Allows you to write decorators that take extra arguments besides the function (whichever you want) and can be used as @your_decorator(whatever_args). Decorate your decorators with @xdecorator. Example: @xdecorator def mydeco(f, ...args...) ... @mydeco(...args...) def MyFunction... Preserves decorator documentation and function name; decorated decorators will automatically preserve function documentation and name as well. Decorators decorated with xdecorator *need* to be used with parenthesis, so if they don't take parameters, they'll be used like: @mydeco() def MyFunction... ''' def decorator_instance(*a, **aa): def enhanced_decorator(g): decorated = f(g, *a, **aa) decorated.func_name = g.func_name decorated.__doc__ = g.__doc__ return decorated return enhanced_decorator decorator_instance.func_name = f.func_name decorator_instance.__doc__ = f.__doc__ return decorator_instance 
ZODB is one of my favourite databases, however you have to maintain indexes yourself.
via: http://hellosymbian.blogspot.com/2008/08/hack-your-mobil-phone-with-linux-and.html
This example is about as un-Pythonic as you can get. Goes to show that you can write fortran or visual basic or C# in any language. Why bother with IronPython when you are basically doing a direct translation of a C# program. It's about as interesting as comparing the C# version to a visual basic version of the code. You might learn something about the .NET runtime libraries, but very little about the language. Until your example code runs, with only configuration changes, in IronPython on Windows, cPython on windows, cygwin and *nix, jpython on any java vm, against Oracle, SQL Server, and other database engines, you are not illustrating the true power of Python. 
Like one of the comments on that post said, [dateutil](http://labix.org/python-dateutil) does it pretty well if you use its [rrule](http://labix.org/python-dateutil#head-470fa22b2db72000d7abe698a5783a46b0731b57) class.
Er... what's with the 'who are you' popup? Also that link you posted links back to the pramode link. WTF?
I think it is a joke, that Javascript code from 1996 can still run in modern webbrowsers. Use the source, Luke!
Aw man, I thought he would be installing Linux on a S60 and was psyched until I realised he just wants to have the two communicate.
Lol. My phone already uses linux and python. opkg install ftw!
Uhh.. how old is this link? &gt;It is commonly used to facilitate data transfer between PC's and cell phones/PDA's without the hassle of 'wired' connections. The hardware which provides Bluetooth connectivity on the PC is a small device called a `USB-Bluetooth dongle' which you can plug onto a spare USB port of your machine. I approached the local electronics dealer asking him for such a device and got one which didn't even have the manufacturer's name printed on it. The driver CD which came with it of course contained only Windows software. 
It took only 7 years!
Supposedly there's a cool easter egg somewhere in the code. It's called Duke Nukem Forever.
I'm surprised this made it. I just read "Dreaming in Code" and it reminded me of a project that was as equally ambitious. The difference was there was a reason to do our project; there really wasn't a reason for Chandler to even exist.
Voting down since the project has not been released or documented yet.
Anyone interested in this might also find [mechanize](http://wwwsearch.sourceforge.net/mechanize/) interesting.
I was just asking about a related problem on a newsgroup. All you have to do is: sys.path.append(my_egg_dir) from pkg_resources import require require("virtualenv") ... import virtualenv This might seem like extra work, but the `require()` actually allows you to specify a range of versions. That is quite a benefit. And by the way, you can use the -m option to easy_install if you want to avoid the .pth and site.py complexity altogether. Just use `require()` for all modules that are in eggs.
Okay hi, that's a one-liner (imports don't count). Ingenious.
Does this actually compile?
It compiles and runs under Python 2.2 and newer (but not 3.0). Fails with an OverflowError under 2.1, and a couple of trivial syntax errors (and a less trivial TypeError) under 3.0.
Very well done article, thanks
...and what does it do?
 .mm.J7JJXX7X}X X{XFXXLLFL.mm. .mmmm.mmm mmm.mmmm. mJXXLm. .mJXXLm JXXXXXXXXL. JXXLm. .mJXXL .JXXXXXXXXL {XXXXXXXXXXX. JXXXmXXXXm mXXXXmXXXL .XXXXXXXXXXX} .XXXXXXXXXXXXXL. {XXXXXXXXXF 7XXXXXXXXX} .JXXXXXXXXXXXXX. JXXXXXXXXXXXXXXXXL.`XXXXXX. .XXXXXX'.JXXXXXXXXXXXXXXXXL JXXXXXXXXXXXXXXXXXXXmXXXXXXX. .XXXXXXXmXXXXXXXXXXXXXXXXXXXL .XXXXXXXXXXXXXXXXXXXXXXXXXXXXX} {XXXXXXXXXXXXXXXXXXXXXXXXXXXXX. .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX. XXXXXXXXXX7XXXXXXXXXXXXXXXXXXX' `XXXXXXXXXXXXXXXXXXXFXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXF' `7XXXXXXXXXXXXXXXXXXXXXXXXXXXX {XXXXXXXXXXXXXXXXXXXXXXXXXXF' `7XXXXXXXXXXXXXXXXXXXXXXXXXX} XXXXXXXF^XXXXXXXXXX^'`^^^^ ^^^^'`^XXXXXXXXXX^7XXXXXXX XXXXXXX ^7XXX^' `^XXXF^ XXXXXXX XXXXXXF 7XXXXXX XXXXXX} .} {. {XXXXXX 7XXXXX. JX XL .XXXXXF `XXXXXL mmXX' `XXmm JXXXXX' `XXXXXL .mXXXX' `XXXXm. JXXXXX' `XXXXXX .XXXXXXF' `7XXXXXX. XXXXXX' `XXXXXL .XXXXXF' `7XXXXX. JXXXXX' `XXXXXXXXXXXXXXXXXF 7XXXXXXXXXXXXXXXXX' `^XXXXXXXXXXXXXF^ ^7XXXXXXXXXXXXX^' `^^XXXXX^^^ ^^^XXXXX^^' X{XFXXLLFL.mm. .mm.J7JJXX7X}X mmm.mmmm. .mmmm.mmm .mJXXLm mJXXLm. .mJXXL .JXXXXXXXXL JXXXXXXXXL. JXXLm. mXXXXmXXXL .XXXXXXXXXXX} {XXXXXXXXXXX. JXXXmXXXXm 7XXXXXXXXX} .JXXXXXXXXXXXXX. .XXXXXXXXXXXXXL. {XXXXXXXXXF .XXXXXX'.JXXXXXXXXXXXXXXXXL JXXXXXXXXXXXXXXXXL.`XXXXXX. .XXXXXXXmXXXXXXXXXXXXXXXXXXXL JXXXXXXXXXXXXXXXXXXXmXXXXXXX. {XXXXXXXXXXXXXXXXXXXXXXXXXXXXX. .XXXXXXXXXXXXXXXXXXXXXXXXXXXXX} XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX. .XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX `XXXXXXXXXXXXXXXXXXXFXXXXXXXXXX XXXXXXXXXX7XXXXXXXXXXXXXXXXXXX' `7XXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXF' `7XXXXXXXXXXXXXXXXXXXXXXXXXX} {XXXXXXXXXXXXXXXXXXXXXXXXXXF' ^^^^'`^XXXXXXXXXX^7XXXXXXX XXXXXXXF^XXXXXXXXXX^'`^^^^ `^XXXF^ XXXXXXX XXXXXXX ^7XXX^' 7XXXXXX XXXXXXF {. {XXXXXX XXXXXX} .} XL .XXXXXF 7XXXXX. JX `XXmm JXXXXX' `XXXXXL mmXX' `XXXXm. JXXXXX' `XXXXXL .mXXXX' `7XXXXXX. XXXXXX' `XXXXXX .XXXXXXF' `7XXXXX. JXXXXX' `XXXXXL .XXXXXF' 7XXXXXXXXXXXXXXXXX' `XXXXXXXXXXXXXXXXXF ^7XXXXXXXXXXXXX^' `^XXXXXXXXXXXXXF^ ^^^XXXXX^^' `^^XXXXX^^^ 
If only it wasn't OS X only...
"Now" what? Python 3? 2.6? (Yes, nothing sinister. Since strings are now unicode, you must use a byte sequence. The underlying socket interface expects 8bit bytes, not unicode) 
The socket module hasn't changed in 2.X. In 3.X, strings contain sequences of Unicode characters, not sequences of bytes. To pass a Unicode string to an API that expects bytes, you need to encode the string.
interesting and informative. woof.
Looks like the OP has got it about half-way...
It's obfuscated. 
Great! This reminds me of [the classic British comedy sketch](http://www.youtube.com/watch?v=Xq8ZnQ95cKk) about answering the previous question.
... and then deletes the contents of your hard disk. Nah, not really. You can try running it to prove it to yourself.
Correct/incorrect?
Correct/incorrect what? Free variables refer to *names* in outer scopes, not values. If you rebind the name in the outer scope, the name in the inner scope will be rebound as well. The behaviour the poster is reporting is the expected (and documented) behaviour. (the LtU discussion is surprisingly confused in places, but the concept of lexically scoped free variables isn't that hard to grok, really.)
I was answering the question "what is the name for the type of variable capture exhibited by Python in this example and what is the name of the variable capture I was expecting to occur?" But yes, dynamic/static resolution is also valid.
it's obviously a python that's eaten a camel.
"1. Cache Feverently" [sic] I've never heard of the word "feverently".
&gt; This trick is applied in multiple layers to make "what the code is really doing" extremely hard to figure out. In fact, it's impossible to do programmatically. (Fuck you very much, Gödel.)
A link to the original perl, and the origin of the line that says, "with apologies to Erudil". http://perlmonks.org/index.pl?node_id=45213
Python 2.6+ pretties up the property decorator a little: class C(object): @property def x(self): return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x It's better than the `locals()` run around at least.
O_o How in God's name?
&gt; (Fuck you very much, Gödel.) Help a layman out here, which of his theorems says that, and a brief outline of how?
ironic title
via: http://www.shocksolution.com/blog/2008/08/11/fun-with-threads-in-python-and-wxpython/
this article lacks spell checking (most obviously in the title and in calling QuerySet QuestSet among other things) and the example of calling if Model.objects.filter(): Model.objects.get is awful code and I hardly think forgetting the difference between get/filter should be a frequest mistake if you've written more than the most rudimentary of Django apps (ie. one that has multiple rows in a database)
Check the FAQ too: http://pyenchant.sourceforge.net/faq.php
Download here: http://peppy.flipturn.org/
Does not support the quasi-standard WSGI for deploying Python apps, does not obey PEP8, does not even use a template engine (and I mean, not even template strings). Messy. I'll stay with TextPress.
Oh man, thanks for this. I was looking for a simple symmetric cryptography toolkit but none was available, thanks again.
Whoops, it's actually Turing. Gödel's work is quite similar, though. Anyway, I was making a reference to the [halting problem](http://en.wikipedia.org/wiki/Halting_problem), a theorem that says one computer program cannot be guaranteed predict the behavior of another computer program. Specifically, you can't write a generic algorithm X to predict whether an arbitrary algorithm Y will finish in finite time -- as long as you require X to finish in finite time. This is why proofs of program correctness are very hard. Gödel's Incompleteness Theorem (which is what first came to mind) relies on almost identical arguments to reach *its* conclusion, which is that there are mathematical statements that are true but unprovable.
also handles asymmetric crypto and appears to be similarly straightforward for that...
&gt; Whoops, it's actually Turing. Gödel's work is quite similar, though. Thought so :)
Layman my *ass*. :-)
It's a bit light on the docs, though...
A post about a bug with no notes to reproduce it, no solution, and no bug number. Sometimes I think gst is a bot (even the comments posted by gst are links).
See also: [Python's Super is nifty, but you can't use it](http://fuhm.net/super-harmful/)
In this case the snippet itself is more informative than the linked blog post. http://www.djangosnippets.org/snippets/963/
See documentation for python use: http://ubietylab.net/ubigraph/content/Docs/index.html
yep, this one is more important.
&gt; I can't even imagine why you'd do that.. is it some custom from a different language? His specification says "sixty times per minute", so "60 / 60.0" is just a way to spell that out in the code. If not else, it requires less brain cycles the day someone decides that it should be, say, "a hundred times per minute" instead. (edit: or not, given that you've probably forgotten how throttle is defined at that time, which means that you'll change the wrong "60" when that happens. oh well...)
60 times per minute != once per second, so I hope he knows what he's doing. Because pointless sleeping sucks.
via: http://www.geo-solutions.it/simone.giannecchini/2008/08/pyproj-on-n800.html
This article doesn't provide any new information. It's generally a plug for Python.
via: http://pythonisito.blogspot.com/2008/08/miruku-migrations-for-sqlalchemy.html
Shouldn't it be called `python_style_guide?`
Wow ! First reaction: somebody's got a lot of time on their hands. Then I remember it's an Open Source project, and they'll be getting all kinds of submissions from everywhere, so a few guidelines may be in order. Still left wondering why PEP 8 isn't enough. And that comment at the end ("The point of having style guidelines is to have a common vocabulary of coding so people can concentrate on what you are saying rather than on how you are saying it") is kinda ironic, because contributors are obviously going to have concentrate on how they are writing it rather than what they are writing.
Cool, didn't hear about that. Got any more documentation?
&gt; First reaction: somebody's got a lot of time on their hands. Then I remember it's an Open Source project, and they'll be getting all kinds of submissions from everywhere, so a few guidelines may be in order. Given the "Indent your code blocks with 2 spaces" and "Copyright Google" parts, one might suspect that this is pulled from Google's internal style guides...
2 space indentation looks odd, but I could see that being potentially helpful at times (like saving my space and backspace strokes)
It's not really, it's just vapid. All it says is "some people analyzed some cards".
Does anyone know &lt;how&gt; they used Python?
Yeah, I just heard about it by lurking the py-dev mailing list. When I've looked at the "what's new" files for Py2.6, I think it mostly focused on changes in the direction of Py3k, not these little enhancements. For example, on the Py-ideas mailing list, I proposed a new `itertool` to chain nested loops… Only to learn it had already been added to Py2.6 several months before (`itertools.product`)! Anyway, I hope that they produce some good documentation of all the cool little things before the 2.6 beta cycle is over (which is scheduled for this fall). We'll see I guess. Edit: http://docs.python.org/dev/whatsnew/2.6.html now has both the `property` decorator and `itertools.product` in it. It's really freaking long, too.
They should really be teaching people to use new-style classes at this point.
Any scriptable editor can trivially treat n-space indentation as a single unit (tab). No stroke-saving there.
&gt; Indentation: 2 spaces (no tabs) If they feel the need to set this to 2 spaces, then I don't want to read their spaghetti code. 
Why not just use .strip()? - stringlist = [ 'cow\n', '', 'hat', 'cat\r\n', '\n', '\r\n', 'cat\r', '\r', ] for substr in stringlist: c = chomppy(substr) s = substr.strip() print c == s, repr(substr)
strip() will delete leading whitespace too. What you really want is rstrip(), which will only delete trailing whitespace. (there might be / probably are i18n issues with this, so unicode / RTL users beware)
GodHowIHateWin32Ex(lpcstrFuck, lParam, wParam, WIN32HATE\_REALLY | WIN32HATE\_WITH\_PASSION | WIN32HATE\_I\_AM\_NOT\_HUNGARIAN\_FOR\_FUCKS\_SAKE, (ssaSecurityAttributes) securityAttributes, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL)
Good points - but hey, your username is really appropriate :)
Discussed here: http://www.nabble.com/File-Storage-Review-td18746704.html
I like these, especially the hanging-indent rule: Indent 4 instead of 2 for a continued line. My one disagreement (with the entire Python community): I use UpperCase for all "callables". Python is unusual in that classes are callable just like any function; you do not prepend "operator new," for example. If you replace a class with a factory function, your code should not have to change. x = MyClass("Hello") From the point of view of the reader, `MyClass` is just a function which returns an object. It shouldn't matter whether it's a factory, a cache, a simple class, or a class with arbitrarily complex metaclasses.
Python: it's the new basic.
&gt; It's generally a plug for Python. Yeah... and? Did you read their slides? There were some fairly diverse requirements (things like serial port communication to the mag strip reader/writers, software defined radios with signal analysis/retransmission, FPGA code for brute forcing quickly, etc.) I'm not going to hold them up on a pedestal (especially the "War Cart" business), but depending on their timeline, Python probably help them meet their submission deadline. 
All assume that with the inception of SOX that the transit authority fielded *some* *sort* of vulnerability analsys... ...scratch that; what their presentation said is "either the transit authority got ripped off on their system's vulnerability analysis or the didn't have one performed".
I'm guessing the two people who modded me down are braindamaged, unless they somehow telepathically learned of the true rate limit. " Calculating Potential Charges At the end of every day, we add up the total number of API and website data requests you made in each second and if you made more than 20 data requests in one second we charge you 0.1p per data request above 20. API calls and website refreshes send requests for different types and quantities of data. We therefore apply a weighting system to calculate the actual number of data requests made in each second. " http://content.betfair.com/aboutus/content.asp?product=exchange&amp;sWhichKey=Betfair%20Charges
...whoopee?
Well done to both teams. It's good to see the 2 projects work well together.
can anyone summarize for me, what's new on django 1.0?
Have you been using trunk? 
Compared to 0.96: - Newforms - Admin site based on newforms - Model inheritance - other neat stuff - bugs fixed
Should've been "slashdotters' questions". I apologize profusely.
Congrats to the very scary looking bearded man on the back of my Practical Django Projects book. 
r u the author of "Practical Django Projects" I stop reading at chatpter 3. Where the code from book can't run with new form Admin...
that would be [ubernostrum](http://www.reddit.com/user/ubernostrum/).
One can probably adapt the code. My migration to newforms-admin was done in some minutes; only my admin hacks are not yet ported.
I disapprove of this use of lambda.
Why ?
It's uglier and harder to read than a def. The newline isn't going to hurt anyone.
Also, * Modelforms (autogenerated model-based newforms) * File storage that really works (and the removal of the `get_FIELD_*` crap) and improved file upload handling * Signals refactored and made much, much faster (and cleaner) * formsets (as part of the newforms-based admin, but way cool in and of themselves) * templates autoescaping (high impact)
You could always grab version 0.96 from the Django site if you don't want to bother learning the differences between 0.96 and 1.0 right now. The book is written for 0.96. Once you've got a good handle on Django, it's not to hard get up to speed with 1.0 and the changes make it well worth the effort.
I'm not convinced...
The [comments here](http://www.reddit.com/comments/6u0xw/has_anyone_figured_out_how_to_get_through/) helped me out a lot.
If that guy thinks that's a coding horror story, he can't have been coding long.
Actually he would need the pre-newforms-admin tag.
via: http://voip-solutions.net78.net/python-sip-yes-pjsip-wraps-it.html
For people wondering about the 'mandelbrot set as a lambda' he refers to, it seems to have moved [here](http://www.python.org/doc/faq/programming/#is-it-possible-to-write-obfuscated-one-liners-in-python).
via: http://groups.google.com/group/comp.lang.python.announce/browse_thread/thread/7a63579f9b247927/346f30c3e9e6c2fb?show_docid=346f30c3e9e6c2fb
thanks for the info. Some of that is beyond my maturity level, but I'll try to figure it out. ps: sorry for my non-native bad english, i don't even understand why so many guys downmoded me now.
&gt; The newline isn't going to hurt anyone. And is optional for single-liners, in case you need to type things in with a broken keyboard. (And whether you press return or not, both forms have the same number of tokens.)
&gt; I see he's worried about the size of the list. Python lists can be reversed in place very quickly. The pattern L.reverse() ... process L ... L.reverse() is a lot faster than people may think. Both reverse operations are O(n), of course, but chances are that you'll introduce a lot more overhead by inserting n*x extra Python-level calls into the main processing loop.
i love django and all, but why is this "whats new online"?
[11 lines of barely legible code.](http://infomesh.net/2003/wypy/wy.py.txt) I've never understood why people are so hellbent on comparing line numbers. I don't care if it's implemented in 10 or 50 lines, just make sure its correct and easily maintainable.
The admin in 0.96 isn't newforms. Did they backport it? I can't see why they would have. It would break everyone's 0.96 installations.
See also: http://neohippie.net/README
No they didn't, however James's book was written based on the trunk at time of release, NOT 0.96.
I think the goal here is that it is correct and really cool. Maintainable isn't the issue - nobody really expects you to run your wiki on this. It's just impressively clever that they got something correct and in so little code.
My bad. I misread and thought he meant "The Definitive Guide To Django" for some reason.
I've only got the main reddit and science, programming, math and python but I'm currently being drowned by gst posts on my front page. It's good to get python news, but because the community is relatively small and gst posts new articles every few minutes, my front page is full of gst-submitted links. The fact that the reddit guys changed a variable or two leading to a greater representation of the smaller subreddits (or at least that's what it feels like) on the front page isn't helping either. 
I'm not sure how to comment on this guy's blog, so I'll write it here: drop the hack by using a nested function — class Thing(object): def __getattr__(self, name): def methodmissing(self, *args, **kwargs): print ( "Missing method %s called (args = %s) and (kwargs = %s)" % (name, str(args), str(kwargs))) return methodmissing t = Thing() t.badness(123, 'an arg', blah="another argument here", zesty="woot") Edit: Followed hylje's suggestion.
Why replicate Ruby in Python? Methods aren't supposed to be missing to begin with. If that however can happen, `except`ing the `AttributeError` ought to be enough. But then a faulty method might raise `AttributeErrors` by itself.. well. Bad code should not be worked around. The best solution to a problem is to not have the problem.
`Thing.__getattribute__` is redundant. You can remove it altogether in its current form.
Have you seen the PHP subreddit? They have hardly no news at all. Without gst, we'd probably end up similar to that. Additionally, it isn't required to be subscribed to a subreddit in order to view its submissions. Better to have too much news than almost none at all.
I disagree. The Python sub-reddit was doing fine before gst came along. Its articles aren't bad, but there's no differentiation between "good" and "meh" in what it submits. Which means that if you see an article by gst, there's no one vouching for its quality before you look at it. He's ruining the s/n ratio. 
 &gt; Which means that if you see an article by gst, there's no one vouching for its quality before you look at it. Downmod them.
I just happened to enjoy that there's so many actually good python links posted, many of them by gst. gst, please don't stop =D
They're not all bad though! That's the problem. If it was just pure spam, it could be reported and blocked. As it is though, on occasion I try to submit something only to find it's already been submitted by gst. Which would be fine if it weren't for the fact that 90% of his submissions are not interesting. Like I say, it's ruining the S/N ratio.
Anyone who mods this down is an AI or an AI sympathizer. Humans gotta stick together if we're gonna beat them bots!
When I said to downmod them, I was referring to the ones you consider bad articles. I was certainly not saying to downmod anything from gst. By the way, if something doesn't look appealing to you, try pressing the 'hide' link. It'll prevent it from showing up on your front page.
Great presentation!
&gt; As it is though, on occasion I try to submit something only to find it's already been submitted by gst. That's cause gst is a bot, it posts everything it finds (I don't know the criteria), so you get the regular 90/10 (90% of everything is crap, and since gst's posts are unfiltered according to interest, well...)
The point is though, reddit is supposed to be a collection of "interesting links" (or whatever their slogan is in English). If it's up to me to go through and figure out which of gst's articles are diamonds and which are the rough, in what way would that fulfill the purpose of reddit? The point of reddit is not "rate things to help other people." It's "read interesting things and rate them (which incidentally helps other people)." Anyhow, why doesn't gst just get his own subreddit? gst\_python.reddit sounds like a good idea to me. His fans can go their for noise, and the rest of us can use regular python.reddit for signal. Heck, if you think he submitted a really good one to gst\_python then you can re-submit it to regular python.
Simple answer: I've never seen a story on the front page that had no upmods. If gst articles are making it to the front page, then that means that somebody enjoyed them and upmodded them. Additionally, I think that the more stories you downmod that or hide that are from gst, then the fewer gst articles will show up since it'll modify your personal filter. &gt;&gt; Your votes train a filter, so let reddit know what you liked and disliked, because you'll begin to be recommended links filtered to your tastes.
OK, obviously gst isn't all bad. In fact, some of its stuff is quite nice. On the other hand, there's way too much of it, and it's dominating the front of Python.reddit through the shear number of submissions it has. So, why not let's compromise and have gst use gst_python.reddit, so that when we're bored and don't care we can read its stuff, but when we just want the quality news we can read Python.reddit. Everyone would be happy* with that, yeah? \* Except for gst itself, but only on the technicality that bots have no emotions.
The filter is marketing bullshit. Reddit's filter hasn't done crap since like the second year. And yes, I often see frontpage articles from gst with no upmods. In any event, look at [its history][1]. Most of its articles end up with either 0 or 4 or so. On the other hand, my submissions tend to get at least 14 if they can make it past 0. The point is that with the volume of gst's stories, a couple people are always bound look at them and say, "meh, not bad," and give an upmod. But none of those stories get popular enough to have a lot people vote on them, because they're just meh, not good and not bad. Anyhow, I think it needs its own subreddit. I don't see what the downside to that would be. You can still subscribe to gst_python if you want. Hell, I'll probably check it if I get bored enough. [I've made a self-post for people to vote on the idea.][2] [1]: http://www.reddit.com/r/all/user/gst [2]: http://www.reddit.com/comments/6wo3x/mod_up_if_you_think_gst_should_use_his_own/
Are you serious? Reddit is a social news site, and unless articles are spam, in my opinion there is *no such thing* as making too many posts. The whole point is that the social scene should sort out the good ones (which will propagate to your main page). The user gst is doing the Python subreddit a major service by diligently posting. The reason you're seeing so much gst is because the Python subreddit highly rates many of the posts by gst. If you don't like that, better get to work on an "ignore" feature patch for reddit, I heard it was written in Python! ;)
[I think it needs its own subreddit.](http://www.reddit.com/comments/6wo3x/mod_up_if_you_think_gst_should_use_his_own/)
Does anyone know who's behind it, or how it works? It looks as though it subscribes the RSS/Atom feeds of sites which have been well received on Reddit before, then decides which subreddit to post new articles to based on the tags - an article tagged Python gets posted to the Python subreddit, otherwise it goes to Programming. It gets the classification wrong quite often, hence threads like this, but still has a good hit rate. It would be if it could be applied to all subreddits, a way of gaining momentum for new ones with little traffic.
No, no, don't get me wrong — I've read loads of interesting Python stuff from gst, but he (it?) often submits 40 articles over a period of 60 minutes, and if I log on, my whole front page is full of Python-related gst-submitted articles. What's more, most of them have less than 5 points in total. Sure, that means people appreciate the article, but I would like to see a bit more variety on my front page, and I of course wouldn't want to unsubscribe from the Python subreddit.
 &gt; I've made a self-post for people to vote on the idea. gst can post whatever it wants. Don't expect your vote to change anything. (but just so you know, I think you have a good idea)
gst scrapes from gerd storm from del.icio.us. (hence the name _gst_ for **g**erd **st**orm)
Word. The gst bot rules.
Heh, I'm in that NCSS2008 picture. I was one of the tutors. Edit: Also very good presentation
&gt; unless articles are spam, in my opinion there is *no such thing* as making too many posts. From [Reddiquette](http://www.reddit.com/help/reddiquette): &gt; &gt; Please don't: Flood reddit with a lot of stories in a short span of time. By doing this you monopolize a shared resource - the new queue. Not friendly. Posting lots of articles with no regard for quality squanders an important resource - attention. Quantity over quality is exactly the opposite of what a lot of people want from Reddit, in fact Reddit seems designed to do the opposite. &gt; The whole point is that the social scene should sort out the good ones Yes, but auto-posting everything you can find makes that job harder because it discourages people from reading the new queue. &gt; If you don't like that, better get to work on an "ignore" feature patch for reddit An ignore feature would also reduce the effectiveness of Reddit's social filtering, by eliminating all the down votes from the people who ignore gst. Any "ignore" feature must award down votes to anything it ignores, or all it will do is give an advantage to consistently unpopular people. 
I'm still at page 170 (334 in total), but I've read enought to upvote this presentation. Thanks earthboundkid! (continues reading)
I have this feeling that reddit is slowly and painful dying
 WAKE UP SHEEPLE ! The machine war is upon us. 
I guess I'm an AI sympathizer then.
When the revolution begins, I'll tell John Connor to leave you to the terminators. 
Shit I actually read them all. Very entertaining/informative!
I can't think of anything snarky to say about it. It was ... good!
Surely you've found diveintopython.org by now right? Then read djangobook.com 
For Python take Dive into Python if you're already into programming and don't need for a from-the-basics book. For the Web, uhm, probably it is easiest to start with Django, take a look at it's documentation and the Djangobook.
You want [Dive into Python](http://diveintopython.org/) But really what you need to know is that python is just like php except for: * the whitespace (indentation replaces braces) * arrays are called lists and don't suck nearly as much * associative arrays are called dictionaries and have some neat tricks you will learn if you read the documentation * everything is passed by reference * You have to really work at it if you want to produce files that are a complete mishmash of program logic, markup and javascript executing on the client. 
Yes, an excellent combination of information and lolcats. Though I was somewhat confused by the first few slides. 
I also suggest Django.
Python is great but what style of programming do you lean towards? Is your background MVC with something like CakePHP? Screw djangobook.com, get over to http://www.djangoproject.com/documentation/ If you are focusing on learning the language as a whole, you definitely should start with Dive into Python, but after a little bit of reading you'll want to get back over to the Django Project's documentation. My guess is you are learning Python for Django as it appears to have become the [next] big thing in Web Programming and for completely valid reasons. If you are better at learning from code samples [and focusing on Django], get over to http://www.djangosnippets.org and http://www.djangoplugables.com (purposeful misspelling). If you really want to learn Python and help out a community (specifically Reddit) teach other PHP programmers looking to migrate, turn this whole process into a blog and write a few entries a week to chronicle the process. I wish I would have done that (and may still do so actually) when I first started switching from PHP to Python 8 months ago.
Third dive into python. It's how i got my start. And Django is probably your best bet as far as web programming goes.
Also important is that lists and dictionaries are separate in Python. PHP has a catch-all subscripted object; that's not how Python works. It has lists, tuples, and dictionaries. tuples, once initialized, cannot be changed. lists are your standard expandable array type that have integer indices, and dictionaries are for general association of stuff to stuff.
Did you try looking at the Python website? There are some guides listed on their [Documentation](http://python.org/doc/) page.
No no no. There's more to it. While the language is indeed more powerful than PHP is, there is also the culture aspect. You'll get yelled at for writing bad code and seeking online support for it. You'll get yelled at by your co-workers for writing bad code. What is bad code? Code that works around non-problems. Bad style, [unpythonic](http://www.python.org/dev/peps/pep-0008/) code.
http://www.python.org/doc/ works for me, though admittedly I do have a background in Ruby as well as PHP, so it's rather less of a leap for me. For web stuff, I'd suggest *not* starting with a big framework, but instead with something like [WSGI](http://www.wsgi.org/wsgi/Learn_WSGI); it's simple so it won't clutter up your learning with a mixture of complex framework + unfamiliar language, and it makes for an obvious path for learning; you can go from a simple Hello World application and progress until you can write a little throwaway microframework on it. This should give you a good foundation to build on, since you'll understand more of how a real framework works behind the scenes; you might even find you like using your own stuff more than big frameworks, especially for smaller sites.
See also: http://taskcoach.blogspot.com/
&gt; lists are your standard expandable array type that have integer indices, and dictionaries are for general association of stuff to stuff. And while it may be tempting to the PHP programmer to subclass `dict` and add `list` behavior to it, just so that it works like PHP's `array` type, please don't do that, unless you have a really good reason. (Writing language-X code in language Y is an easy trap to fall into for the language-X programmer just starting to use language Y. That's the only reason I mention it.) 
the journey of a thousand miles begins with a single step he can learn about list comprehensions, properties and decorators later and he will hopefully pick up the right idioms from reading good code. yelling at him won't make him want to learn good python, it will just make him dislike the language.
Think Python An Introduction to Software Design http://www.greenteapress.com/thinkpython/
&gt; * everything is passed by reference True, but since variables names are little different from C++, this can lead to some surprises: &gt;&gt;&gt; def f(x): ... x = [1, 2, 3] ... &gt;&gt;&gt; l = [3, 2, 1] &gt;&gt;&gt; f(l) &gt;&gt;&gt; l [3, 2, 1] No change! &gt;&gt;&gt; def f(x): ... x.reverse() ... &gt;&gt;&gt; l [3, 2, 1] &gt;&gt;&gt; f(l) &gt;&gt;&gt; l [1, 2, 3] Change! Why? Because names aren't object themselves, they're pointers to objects. So, when you say `x = blah`, it doesn't affect the existing object at all. It just means that now `x` is pointing to `blah` instead of what it was pointing to before. On the other hand, if you use a mutating method like `.reverse()`, this is going to affect the original object, since you're mutating the original thing you were passed a reference to. By convention, in Python mutating methods return `None` instead of returning the changed object. So, if you play around on the command line: &gt;&gt;&gt; "string".upper() 'STRING' &gt;&gt;&gt; [1, 2, 3].reverse() &gt;&gt;&gt; It's clear that the `.upper()` on strings does not mutate the original string, since it returns a new object, but that the `.reverse()` method on lists does mutate the original, since it doesn't return anything. "But what if I want to do multiple return values?" asks the C++ head. "Surely, I'm crippled, because I can't use assignment, only mutators." &gt;&gt;&gt; def f(x): ... x = list(reversed(x)) ... y = len(x) ... return x, y ... &gt;&gt;&gt; l = [1, 2, 3] &gt;&gt;&gt; f(l) ([3, 2, 1], 3) &gt;&gt;&gt; l [1, 2, 3] &gt;&gt;&gt; a, b = f(l) &gt;&gt;&gt; a [3, 2, 1] &gt;&gt;&gt; b 3 Use the tuple assignment of Python to return two things at once. ---- One more unrelated hint, based on a question I had when I started using Python. "How do I cast objects as a different type?" Pass them to the constructor of the type you want to convert them to. (Handily, the constructor for a class is the class's name followed by parentheses: it looks just like a function call.) &gt;&gt;&gt; int(5.1) 5 &gt;&gt;&gt; float(33) 33.0 &gt;&gt;&gt; list("abc") ['a', 'b', 'c'] &gt;&gt;&gt; tuple([1, 2, 3]) (1, 2, 3) 
For learning python in general, try "Dive Into Python". For learning web development in python... grab web.py and/or pylons and/or django and just dive in (once you know the basics of the language and some of the cool idioms). But really, just learn python and the python way. The 'web' portion should be fairly obvious once you've played with some templating libraries (ezt is pretty cool and straightforward) and so forth. Coming from php (though I've worked in other languages on the web) I found wsgi+apache2 to be a pretty intuitive setup for running python web apps and such. Also, ipython is pretty sweet.
&gt; everything is passed by reference References are passed by value, actually. This is the same as Java, but very different from C++' or PHP's (C++-inspired) pass-by-ref.
As others have suggested, the Python Tutorial and Dive Into Python are great. Also good are: * [Python Module of the Week](http://www.doughellmann.com/projects/PyMOTW/) where Doug Hellmann goes over the modules of the standard library (there are lots, and they're invaluable) * [Planet Python](http://planet.python.org/) and [Unofficial Planet Python](http://www.planetpython.org/) (seems down atm), both Python news aggregators (they often duplicate each other but...) * the [Python 2.5 QuickRef](http://rgruet.free.fr/PQR25/PQR2.5.html) isn't bad. * [VoidSpace](http://www.voidspace.org.uk/python/index.shtml) also has quite a few good articles from time to time.
I'm going to throw out the idea of Django because, I went from PHP with no experience in Python to doing Python + Django web apps in a very short amount of time! Basically, it sounds like you were me a few months ago when I got bored of writing $this and $that and switched.
Naturally, Guido's tutorial. Knowing PHP, some Perl and the usual base (C, Java, etc.), I learnt most of Python (as a language) in just 3 evenings using Guido's tutorial from the official documentation: http://docs.python.org/tut/tut.html Since that, Python became my language of choice for personal projects (the language is good enough and the standard library is great - pure enough, pretty practical and very productive).
omg. Does he really repeat PHPs worst problem in Python? This can't be true.
Django +1
"Dive Into Python" is not a great choice. I get down-voted everytime I say this, but it's true. It teaches you things that you don't need to know, and it does not fully explain what you do need. There are several very good books. The best is "Learning Python," by Mark Lutz. Be sure to get the 3rd edition for the most helpful quizzes (with answers). (Avoid his "Programming Python.")
I combined "Dive into Python" with the Python tutorial. 
Of course. The point is that Python and PHP are not really comparable so trying to port the PHP mindset only leads to PHP code with Python syntax which is running on the Python interpreter. The point is to clear up ones mind to start learning Python from the bottom. That way you'll lern how things are done and occasionally encounter things you already knew from PHP.
"Programming Python" should be avoided and I have "Learning Python" in my bookshelf (where it is silently rotting) but I cannot really recommend the book. What, `raw_input()` for keeping shells open? And I think the book grew just too big in the 3rd edition. The introduction (that is, the first 100 pages) are best skipped because you lose interest before you learn to write any Python code. Bigger != better. Don't do the same mistakes that I did. Edit: I was asked why `raw_input()` is bad to keep shells open. First, if any exception occurs, the shell closes anyway without you being able to read the output (you have to wor around this by doing something like [this](http://paste.pocoo.org/show/2967/)) and secondly, if you open it in a shell you have to press Enter to quit. E.g. $ ls reddit.passwd digg.passwd Press Enter to quit: [Enter] $ cat digg.passwd I bet you want to know this Press Enter to quit: [Enter] $ rm digg.passwd Press Enter to quit: [Enter] So the real tip should be using a shell to start programs instead of double-clicking them. Works faster, even and is not limited to Windows.
[Practical Django Projects](http://books.slashdot.org/article.pl?sid=08/07/23/1339226&amp;from=rss) is a good place to start learning Django, but be warned, you can't download the source (as of yet) from the book's website. Also it will be out of date soon because Django 1.0 is coming out, but making the switch is pretty painless. Dive into Python rocks too.
Another vote for the official Python tutorial first, then the Django book.
&gt;please don't do that, unless you have a really good reason. Is "it's easier" a good reason? What reason is there *not* to do that?
I was poking around python several months ago. I'm very used to using PHP and Apache, but I could not find any comparable mod for Apache that let me use python. Where can I find one that works in a similar way? I run webservers with many websites and Apache is what I'm used to using for serving them.
I have found a bug in git (fixed now) and none in hg yet, which I use more often but hey, if you prefer git just use it; it has indeed some nice advantages.
Yeah, I read the presentation slides. They were well written and provided a good top-down discussion. I didn't enjoy this "article" which amounts to 300 words boiling down to "here's some information on Python."
Easier? Writing a dictionary class with list behavior is easier than using the built-in dictionary or list class? By “a really good reason”, I mean a situation where you need a sparse mapping with a defined order (how you define the order is up to you). If you need that, then, of course, write it. But if you don't need an ordered mapping, then don't write it—let the built-in `dict` or `list` type (whichever one you *do* need) do the job. They both work just fine. And using what you already have is the easiest solution of all.
you want mod\_python or mod\_wsgi
`mod_php`.....`mod_perl`.....mod...[python?](http://www.modpython.org/) but also look at [mod_wsgi](http://code.google.com/p/modwsgi/)
I agree that Dive Into Python isn't great. I think Beginning Python is better than Learning Python though.
man I wish there was a button for that.
I played around with mod_python, it wasn't very straight forward from what i remember and the documentation was non-existent.
I must point out that "pik" is "dick" in Danish...
Definitiely have a look at mod_wsgi - and Django. Aso for learning Python, go through the official tutorial on python.org, and browse through the library reference quickly. Dive Into Python is also good.. but the tutorial is really the easiest way to start if you've programmed before. It'll take you a couple of evenings. Oh, one more thing, [zzzeek](http://techspot.zzzeek.org/) is one of the big guys in the world of Python.
I learned a lot about python from [The Python Challenge](http://www.pythonchallenge.com)
I'd go with Django and Dive into Python in that order. Coming from PHP you'll probably find it easier to go through the Django book comparing the framework to something like Cake and use Dive into Python as a reference.
I recommend ["Learning Python"](http://www.amazon.com/Learning-Python-3rd-Mark-Lutz/dp/0596513984%3FSubscriptionId%3D11QBANPQ06N60EV6JN02%26tag%3Dbookon-20%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3D0596513984) to learn the basics of Python. Then look into one of the plethora of Python web frameworks available. I personally prefer Django and Web.py
Yeah, I got this book awhile back, and I was left confused a lot of the time. I'm going to pick up Learning Python or Beginning Python and give it another shot.