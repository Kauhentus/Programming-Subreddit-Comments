Just a tip, karma doesn't matter and there is no better way to get downvoted than asking about why you're getting downvoted. As for the application, I haven't actually picked up python yet myself, so I'll have to ask, what does it do? :) The only thing I can figure out are couple objects with setters and getters.
It's different because it's functional; the return values are data. Python's regex is fine and quite useful, but you're getting back pure data for some things, and objects with data properties for others, and then querying the object results to extract the data you want via further `group()` and `groups()` function calls. I pointed out the groups thing (implying that I enjoy its absence) in my 2nd sentence. Because Clojure's results are data, I can map the function over a sequence and get back a lazy sequence of data elements: (map (partial re-seq #"[0-9]+") [sequence of input strings]) You can also do this in Python with a bit more code, but it wouldn't be as purely functional. Regardless of how you did it you'd be creating many objects and querying data out of them through extra function calls. Being lazy and mappable, Clojure's functional regex calls can (at least in theory) handle infinitely-long input strings without using more memory, and even parse things like stdin live, waiting for input, kicking out a result whenever there's enough to allow one. I don't know that these things actually, currently work, but they're set up for it. The paradigm allows for it, whereas OO doesn't. Also, functional process with data-only results lend themselves well to parallel processing, something else that the OO paradigm handles badly. Small nitpick, you're printing out the info at the end, whereas the entirety of my `let` statement is a value. It could be used inside of any other form as an equivalent of its resultant string. I'm not printing it out, but receiving that string back as the result of the form. This has various code-as-data/data-as-code and referential transparency consequences. Smaller nitpick: You're polluting your global scope with 4 global variables. I'm creating 4 temporary variables inside a let, which then go out of scope and cease to exist when the let finishes.
FYI, the async nesting issue is fixed in newer versions of node, via generators and a 'yield' feature. Node is good for quickly writing fast network infrastructure stuff. Its competition in that space is languages like Java, C/C++, and Go, which tend to be a lot less lightweight.
Now why would you increment/decrement a NULL value?
&gt; PHP was a great language PS: I am absolutly certain that he never used PHP. PHP was a terrible language in the past. PHP far better now. 
Objects are also data. `re` uses `MatchObject`s because they contain *way* more info than simple tuples of strings: a dictionary that maps group names (in `(?P&lt;name&gt;pattern&gt;)` constructs) to matched data, the string a regex was matched against, the offsets at which every group starts, etc. Sure, you can pack the same data into a tuple, but that's not as readable. That's it. In every other aspect, both implementations are pretty much equivalent. &gt;Clojure's functional regex calls can (at least in theory) handle infinitely-long input strings without using more memory That's not how regex work. They require backtracking, especially if you use backreferences, lookahead/lookbehind and greedy operators (`.*x` will consume the whole input looking for `x`, then backtrack to the last one.) &gt;Small nitpick, you're printing out the info at the end There's no other way to make ideone display that value. It's not a REPL. &gt;Smaller nitpick: You're polluting your global scope with 4 global variables. The reason for this is purely syntactic: there's no `let ... in` statement in Python, the equivalent being a new function that is called immediately after being defined. [dogelang](https://pyos.github.io/dg/) has `where` which is implemented that way.
Whilst I love python some of the answers in this thread feel a bit like some people drunk a little too much koolaid. * Not everybody chooses/loves python. Javascript is what we have agreed upon, for better or worse, as the client side language for browsers. This is a process that took years. Changing that now and getting all browsers on board would be a huge undertaking that would require backing by mozilla/google/microsoft to even stand a chance. * The dom is bad enough as it is in javascript. I would hate to traverse it in python. I could be wrong, but let's see that POC first. * python being whitespace sensitive makes js/html compression tricky to impossible * What would be the real gain? You can achieve your personal python in the browser if you really want through projects like brython. Some pretty impressive stuff has been achieved with js as the underlying vm already and it seems we are only going further. Why start tugging in the other direction. * We can't even unanimously decide on python 2 vs python 3. Standardizing for the web is an even slower process with more parties involved. 
Considering the deobfuscation is built into chrome now, please continue the analogy.
Some weird edge case where some function returns a NULL instead of an error for some reason, so you do your maths on it as if everything went fine. Could be any reason. What's more important, though, is that PHP has that in it at all. If it has that, what other bad stuff can be in it? :o (It's a fuckload of stuff, by the way).
There is also one other thing that you need to take into account about PHP job availability. Many of this jobs are releated to bad code-bases. People start coding in PHP, after some time they learn what are good practices, and why people dislike PHP and prefer other languages. From job talks that I had recently: Majority were PHP stuff, and only ONE of PHP shops seemed somewhat OK. It may depend on area and other stuff, but if you are going to work on legacy PHP code, there is huge chance it is terrible code. (also, when searching for jobs, more than 80% of PHP stuff is ignored, because they want PHP+mysql, JS, CSS mastery, linux, INSTALLING PRINTERS, photoshop and flash).
While PHP is better now, it is still years behind alternatives. Composer, packagist and friends helped.. What bothers me most with ecosystem is that key people who pushed things forward left, and more are starting to move to other technologies..
&gt;Objects are also data. I knew you were going to say that, but I'm going to call you on it. Some strings in a seq are definitely unlike an object full of properties. `str -&gt; (str, str, ...)` has a nice, functional symmetry to it. Besides, Clojure is a lisp, so the code itself is also data. &gt;The reason re uses MatchObjects is because they contain way more info than simple tuples of strings... True, and I've seen those things used twice, and both were thought-exercises somewhere on StackOverflow. I'm not saying they're not ever useful, but I think the use cases are few and far between. I've been using regex most days now for a decade for all kinds of crazy needs, and I've never used any of that metadata. You can get to the underlying Java regex machinery with `re-matcher`, so you could implement offsets [easily enough](http://stackoverflow.com/a/3266877/955926) if you ever needed it. Clojure is in heavy development, and because it's mostly a bunch of functions over sequences now, it's easy to add to it without changing anything else or breaking existing stuff, so if people really want this in core, it can be put in immediately. &gt;That's not how regex work. They require backtracking, especially if you use backreferences, lookahead/lookbehind and greedy operators (.*x will consume the whole input looking for x, then backtrack to the last one.) True. You would not be able to use .* on an infinite sequence (well, you would, but you'd never see the result). For everything else, it would work, even with backtracking. Luckily I don't want to do regex on infinitely-long strings anyway. I guess I should note that I never said Python's regex sucked. I just said I really liked how regex was handled in Clojure. I've only ever cared about a list of matches (a quick peek around google for anyone needing this metadata yields few results), or if something matched, and that's all it does.
The network effect. 
http://i.minus.com/iZS2hF8EgYAgO.gif
While Laravel and Symphony are nice frameworks, and PHP got some cool features.. Package eco-system is not on same level as pypi, and I do not mean that as in breadth of packages available for python, but as in average quality and stability of packages. Also, I have seen Laravel, and used it a bit, it is really nice improvement over other frameworks that I have seen. Mainly because it tries to get people to use namespaces and write at least somewhat decoupled code. About last few releases, people use features from 5.3 (namespaces). Take a few seconds and try to think about how long there was no namespace support in PHP... Traits should have been in sooner also. Generators, I am not sure if I want to read code PHP using generators written by random PHP developer. But also, I am of a mind that developers who mainly use other languages write better code than people who mainly use PHP. (or javascript too). My day job is PHP, I am working with guy who likes PHP a lot, and he has daily problems with Composer and packages that he uses. My viewpoint comes to: PHP sucked a lot, and is starting to suck less. Python is nice language, it is not perfect, but much better. What is important: Rate of improvement in PHP world is not very good. When I had discussion with same guy about which language is better two years ago, his arguments were basically: 1. It is available everywhere. (not important because we setup our servers, and with cloud does not have good PHP offering) 2. It is mature, stable battle tested and secure. (still today, I have no idea what to say to that) To nail the point, read release logs AND dates of last few years for PHP and for Python. Then compare significance of features implemented on each side. Then see when those few good features that PHP got "recently" were implemented in Python. PHP internally is hacky codebase, and new features are being hacked in. PS. Also PEP system for adding stuff to language is much much better than what is done with PHP.
The .js files would be compiled from the .py files in an automated way; you mentioned a number of possibilities in your original comment.
javascript is not nonblocking. Its just some buzzword the javascript guys throw around. Make an ajax call with async = false and you'll block the whole browser. Node.js and javascript have some nonblocking I/O libraries that use callbacks when I/O has completed but python or any other language can and are doing that as well.
Callbacks quickly degenerate into callback hell. In node.js its common to use a reactive library to help escape from callbacks. Its one of those things thats nice if you use it a little but overuse will come back to bite you.
Would you mind listing some of the alternatives?
I was thinking there'd be some kind of standards for it, but I know how well standards are implemented in browsers, so I guess you're right...
Not all code and libraries work properly with PyPy and Cython. That is the main drawback/sacrifice. 
Do you have examples? Or know where to find them?
I use scikit-learn (sklearn). I've never been able to get it to work with PyPy. http://scikit-learn.org/stable/ 
As noted both are capable of doing the same thing. Both languages have a good packages availble, and imho PHPs package manager (composer), is actually very good. It does not have the same problems (not directly related to package management) that Python has, and tries to solve with virtualenv. But as far languages go, Python is more like a real language, and PHP more a web-scripting language. You can do more than web related programming with PHP but compared to Python it does not exel in that area. For example, a GUI app is most likely to be a total mess when done in PHP. As of speed, both are decent in terms of not compiled languages. If you do web development both are solid choices, but with PHP i would not touch anything below 5.3. As of frameworks PHP has Laravel, Symfony i would not bother with the others, Python has Django, pyramid and Flask. 
Meh. I agree that the naming and the documentation is shockingly bad, but I also find that it's very useful in the code that I write. Is `defaultdict` a better solution for the same problem? Maybe. One - the only? - benefit from setdefault is that it's explicit in the call to setdefault what sort of object or value you are expecting to get back, whereas with a defaultdict you have to go and find the original declaration.
another good option, in my opinion, is http://numba.pydata.org/ 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Numba**](https://en.wikipedia.org/wiki/Numba): [](#sfw) --- &gt; &gt;__Numba__ is an Open Source [NumPy](https://en.wikipedia.org/wiki/NumPy)-aware optimizing compiler for [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)) sponsored by Continuum Analytics, Inc. It uses the remarkable [LLVM](https://en.wikipedia.org/wiki/LLVM) compiler infrastructure to compile Python syntax to machine code. &gt;It is aware of NumPy arrays as typed memory regions and so can speed-up code using NumPy arrays. Other, less well-typed code will be translated to Python C-API calls effectively removing the "interpreter" but not removing the dynamic indirection. &gt;Numba is also not a tracing jit. It compiles your code before it gets run either using run-time type information or type information you provide in the decorator. &gt; --- ^Interesting: [^Mumamba ^Numba](https://en.wikipedia.org/wiki/Mumamba_Numba) ^| [^Numba ^Mwila](https://en.wikipedia.org/wiki/Numba_Mwila) ^| [^The ^Tide ^Is ^High](https://en.wikipedia.org/wiki/The_Tide_Is_High) ^| [^O.G.C.](https://en.wikipedia.org/wiki/O.G.C.) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgy151t) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgy151t)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Are you interested in music? I'm building an online musical dojo to help more people get into music (http://musikata.com). The idea is to break the process of learning music down into bite-sized chunks, so that it's fun &amp; beautiful for anyone to get started. If it sounds interesting to you just send me PM. We'd love to have more people be involved.
Not bad for having learned Python over the weekend! You have at least one line where the code does not quite match the comment: while count &lt; 2: How important is it that this code not blow up on you if you have bad data in serialData.txt? You only check that the line is more than one character long before assuming that split(',') returns 5 values, the first 4 of which are integers.
It's only good for scalable systems if you never need to do any heavy synchronous work. 
Being dynamically typed doesn't necessarily mean that a variable can change types. It simply means that a type checking failure causes a run-time error rather than a compile-time error. Statically-typed languages typically use either type declarations or type inference to establish the types of variables before the code is ever run, and they run an algorithm on the abstract syntax tree to check whether the types all match up. Dynamically typed languages wait until run-time to determine any types, which means that a type checking failure usually manifests as an exception or similar error condition *after* some part of the code has already run. If you're familiar with Java, dynamic typing is conceptually similar to using Object as the type for everything, then inserting a cast to something more specific whenever you need to call a method or use an operator or do anything that Object can't. Your code would always "type-check" at compile time, but it might blow up with a cast exception when it runs, the same way that Python does. The reason why I'm being pedantic about "variables changing types" is that there's really nothing stopping anyone from designing a language where you can explicitly change the type of a variable and still have static type checking. As long as the compiler knows that you've changed the type, it can type-check code after the change using the new type and everything works just fine. It might be worthwhile to think about why this isn't commonly supported. It's also possible to have dynamic typing without variables being able to change their types. Clojure and Erlang are good examples of this, with Erlang being the stricter of the two.
&gt; Are we losing portability when using PyPy or Cython? To some extent, yes. For example, IIRC PyPy doesn't currently support PowerPC, though I think it does have ARM support in recent versions. This could be relevant if you're running your Python on some sort of server/mobile device/other embedded context rather than on a PC.
&gt; both PyPy and Cython are chosen when speed is critical or a requirement in the matter. pypy and cython are not the same type of thing. The first is an alternative python interpreter that supports (more or less) exactly the normal python syntax, the second is effectively a slightly different language (via extra annotations). &gt; But since the Python code is the same, we are still having its readibility, right? While you can get some relatively small speed gains using cython this way, when people suggest it they are in practice referring to adding the extra annotations, so the code is not pure python any more. Cython also sacrifices some ease of use, since it must be compiled, as well as stuff like making it a bit more annoying to get normal tracebacks from the compiled components. That said, the language itself is very readable since it's mostly normal python, even if you don't know about cython.
"why are some companies still using VB6 ?" Same kind of question. Often programming languages adoption has business and market involved.
Which is like, 90% of network servers, and largely the audience node.js is designed for.
Gzipping saves far more space than deleting the whitespace does, so I'd say it'd be a pretty bad reason to not use python in the browser. There are plenty of reasons python is not in the browser but whitespace is one of the most insignificant reasons. http://stackoverflow.com/questions/807119/gzip-versus-minify
Something I wrote up for Qt and GTK is code that will let you run a generator on the UI thread you yield function call information and that function call will happen on a worker thread. See "def set_dnd" / "def _set_dnd", "def login" / "def _login", etc. https://github.com/epage/DialCentral/blob/master/dialcentral/session.py
&gt; I too would like to know why! XMLRPC is my goto solution for these kind of things. Easy and simple to implement. I've had some success with [json-rpc](json-rpc.org). I was running django on the server side and used [this](https://github.com/samuraisam/django-json-rpc).
I don't get why apps aren't written for multiple servers if they need so many concurrent connections. I get the fact that transaction processing and other technical complexities make it harder to do, but if you're making a large application server you should think about scalability during the design, regardless of the language you are using. If one server might be overloaded, that problem needs to be solved early. 
&gt;"Program passes all tests but the output did not match the expected output for values not between 1 and 12" It says what the problem is right here. However, without knowing what the task is, it is impossible for us to help you debug it. Also, please post questions in /r/learnpython instead.
&gt; The pattern here could be that you shouldn't print anything out for numbers lower than 1 Yep, or maybe it's just off by one character. (Missing period at the end?) &gt; All the seasons are wrong if January is 1. Maybe in your part of the world ...
I'm not sure how it's passing "all" tests and then failing one- but the phrasing of the message from your system sounds like the string that it's printing when not given a number between 1 and 12 doesn't match what the system is expecting. Is it supposed to reprompt for new input? Check your error message. Then, before everyone else says it, goto /r/learnpython 
In Python 2, `input()` is equivalent to `eval(raw_input())`, so for example, "2+4" would be accepted by your program, as would "import os;os.remove('some_file_on_your_disk')". Which is *bad*. (In Python 3, `raw_input` was renamed to `input`) Maybe that's what the script is checking. Try replacing the `input` with `raw_input` and convert that to integer. Other than that, maybe you just misspelled the text in the else-clause, there is no way for us to know what the automated script expects. BTW: You do not need to escape single quotes in strings with double quotes. `print "This works fine: single quote: ' "`. The same is true for double quotes in single quoted strings: `print 'This also works: " '`. Edit: Questions like these are better suited for /r/learnpython
True true. Forgot seasons were reversed in Southern Hemisphere. Closest, I've been is Singapore and it's pretty much the same season all the time there.
The benefits of using the pypy interpreter come from it's JIT (just in time compiler). The default implementation of python is an interpreted vs compiled language. This means that each line of python is interpreted at runtime, which is slower than compiled code. The pypy jit is somewhat of a halfway between interpreted/compiled in that the JIT will compile some parts of your code to C and will promote high usage region to machine code first and swap them in during runtime. The overhead of compiling first can be detrimental if your code profile is not utilizing the jit. As for compatability, any normal python code will run in pypy. As long as you're not depending on incomparable 3rd party modules, you can just run it using pypy in place of python. pypy program.py # rather than python program.py As for Cython, you are primarily getting the boost from adding static type declarations in your own code. This is a little bit more invasive since you will need to write Cython, and your code will no longer be able to run under normal python. 
Yeah I got it. Momentary lapse in reasoning. I'm tired.
AngularJS, which is built upon JQuery and makes writing front-end code much cleaner. His SASS opinion was just that. Although I prefer LESS there is nothing wrong with SASS.
&gt; Which modern language is worse, in your opinion? Well, PHP obviously, but pretty much every language is better than PHP. [This blog post is a good summary](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/) I agree that some design decisions in JavaScript are completly insane (the weak typing and the rules for those, the context sensitive "this", etc.) But it has first-class functions, a prototype based "inheritance", etc. For the record, I'm not a fan of JS either, but if forced to choose between JavaScript and PHP, for example, I'd always go for JavaScript
PyPy has issues with unfriendly C extensions. It is not yet up to 3.x compatibility. If you have general Python 2.x code (Python is a complete Python interpreter, and uses a tracing JIT for insane speed) that you want to run stupidly fast, then PyPy is likely for you. Cython is not pure Python (at least, not if you want the speedups that people talk about getting from Cython). If you have specific Python code (that is probably already interacting closely with C code) that you want to target, Cython might be for you. You should also consider Numba, as mentioned by /u/ricekrispiecircle.
No one was using IE back then. At that time, Netscape Navigator was the browser used by everyone. Keep in mind that most of the web users at that time didn't even use Windows machines, but Unix-based systems. Netscape was the de facto standard for web browsers around 1996. JavaScript appeared in Netscape 2.0 around 1996/97, and therefore, if you wanted to include client side code in your website (which was still uncommon until 2000 or so), you used JavaScript. There was Grails, a Python based browser written by Guido himself that implemented client side scripting in Python, but it appeared in 1997 and wasn't used nearly as much as Netscape. 
Yea I never understood that term, javascript isn't the only language that can have asynchronous behavior, it just happens to focus on it.
When it comes to desktop applications it doesn't matter, people have no care in the world what you application is written in as long as it's properly packaged for installation. You want to distribute a python application on windows, great, bundle the python runtime and any extra libraries you use and users will be none the wiser. Unfortunately, you don't get to decide what languages the web browser of your users choice supports. Javascript is the lingua de franca of the web, and until EVERY browser on EVERY device supports something different we are going to be stuck with it. Besides, Javascript is fine, it's evolving, if you want some less mind-bending semantics for defining custom classes then use an ECMAScript 6 cross-compiler like Traceur or TypeScript.
I'm sorry, have you used pythons lambda syntax?
Thanks, I didn't actually realise so much was possible via function annotations.
It would be categorically impossible to embed the standard library. ...and despite what people say, python without the standard library would not be python; it would be a new 'python like' language; it would require an entirely new runtime vm. There is no significant benefit to doing this over just making an entirely new language from scratch. 
Thanks. Right now I am using QtGui.QApplication.processEvents() and it works. I have another question though. When the program ends, the GUI doesn't give the control back. ie, I need to close the GUI to get the prompt in IPython or when running from the terminal. Is there a way to get to the command prompt without stopping/closing the GUI? Thanks.
1. I have no idea what this is and the README isn't helping. 2. No license file. 3. Why not raise exceptions instead of printing errors? 4. You should check out PEP8 Overall this is, no offence intended, useless. These are just 3 (small) classes with some attributes and functions to modify those attributes...
Cython is not normal python code. It mixes C with python to get slightly lower level for a typical gain in speed. You have to worry about static typing and overflow and all that stuff that python normally handles; e.g., here's a Cython pyx file for doing pow2: cpdef int pow2(int x) except? -2: return 2**x If I place this inside `pow.pyx`, I can use it like: &gt;&gt;&gt; import pyximport; pyximport.install() &gt;&gt;&gt; import pow &gt;&gt;&gt; pow.pow2(10) 1024 &gt;&gt;&gt; pow.pow2(31) -2147483648 &gt;&gt;&gt; pow.pow2(33) 0 &gt;&gt;&gt; pow.pow(2.7) 4 &gt;&gt;&gt; 2**2.7 6.498019170849885 So for gain in speed, you lose correctness when used improperly (function doesn't take an int, or result goes outside the range that can be stored in an int). ---- Pypy is just regular python code that is run through a different compiler, specifically a (just-in-time) JIT compiler. This generally will execute code faster, assuming three conditions: 1. the work of the program is being done primarily in *python* not in some underlying (optimized) C extensions where the benefit would be minimal like `scipy` 2. there's enough work for python to optimize that its worth the extra overhead of running a JIT versus using precompiled python bytecode (e.g., its not a very short script) [[1]](http://stackoverflow.com/a/18946824/457571) 3. all the libraries you need to use can be run in pypy. All python code can be run in pypy, but some python libraries written using the python C API cannot be used; e.g., numpy, gmpy, pycuda, etc. See [pypy compatibility for a list](https://bitbucket.org/pypy/compatibility/wiki/Home).
A big issue is how much your code has to integrate with, which tends to introduce blocking libraries. Monkey-patched libraries only take you so far (and I confess, I find the concept disturbing for code that's part of critical infrastructure.) One of node's advantages is the number of compatible non-blocking libraries it has. [Why node.js is cool](https://blog.nelhage.com/2012/03/why-node-js-is-cool/) discusses this, making the point that node "makes composable networked components the default." There's also a good real-world example in [The Switch: Python to Node.js](https://journal.paul.querna.org/articles/2011/12/18/the-switch-python-to-node-js/). They were using Twisted, not gevent, but some of the same issues apply. I'm not saying node and gevent aren't competitive - a lot depends on the use case. But there are cases where node has advantages, at least currently. BTW, I mentioned yield and generators earlier, which are still new in node, but node's promises also helped a lot with the callback issue, and that's been standard for a while. 
You might be right, PHP is no beauty queen either... but at least there's a good amount of choice (without the nasty tradeoffs) on the backend. I get a sense that JS was designed by a smart autistic wanker who couldn't resist building a language around his favorite obscure theoretical concepts and sprinkling a few quirky pet behaviors... without much regard for either the specific purpose of a client-side browser language, or practical use by other programmers down the line. PHP, on the other hand, does not seem *designed*, period. If programming languages were people, PHP would be a disabled fellow (many flaws, but you can't help but feel some pity), while JavaScript is intelligent, but bizarre and overbearing, with dubious hygiene habits. 
Numba isn't a separate distribution, it's a JIT compiler for CPython that you import as a package (and call as a decorator or something), right?
The installable welcome/bootstrapping kit is one of the best ideas I've seen in the computing community in a long time. It got a lot of good attention at the [open source conference](http://greatwideopen.org/) I was at a few weeks ago. Thanks for the pointer!
http://www.skulpt.org/
You're absolutely right and I think that goes back to average skills of the users. The average python dev is much better than the average php dev. I think it has a lot to do with the barriers to entry. 1 command will get you started with php for web and most hosts already have it on by default. Python takes substantially more work to get going. This means you get a lot more talentless hacks in php than python.
http://i.imgur.com/7E92f.gif
[Here's](http://blog.perrygeo.net/2008/04/19/a-quick-cython-introduction/) a more in depth look at what it takes to write Cython code. The author writes a small function in Python, then ports it to Cython over a few steps, benchmarking it at each step as well.
PyLadies are awesome, and this is a really neat way to share the welcome kit!
I see the same thing on Chrome
Yeah, again mine was a very quick example trying to show overflow. Actually timing it, the Cython version is only ~60% of the time compared to just calling `2**i`: &gt;&gt;&gt; timeit.repeat("for i in range(30): pow2(i)", setup="import pyximport; pyximport.install(); from pow import pow2") [1.898576021194458, 1.8446509838104248, 1.8220350742340088] &gt;&gt;&gt; timeit.repeat("for i in range(30): 2**i") [3.1804258823394775, 3.1412129402160645, 3.148585081100464] And even more impressive if you keep it as a function call (Cython takes about 33% the time of this version): &gt;&gt;&gt; timeit.repeat("for i in range(30): pow2(i)", setup="pow2 = lambda x: 2**x") [5.55518102645874, 5.5896220207214355, 5.532485008239746] (Note `timeit.repeat` evaluates the first string a million times and repeats the test three times showing all three timings in an array -- with all timings starting *after* the setup code is run). 
Glad I'm not the only one who thought the font was bad. Bad font, bad color, bad size, and bad unit on the font size.
This kind of intent is specially awesome. PyLadies must be forked for all other communities. Congratulations! 
I didn't know that actually! Neat that pip runs on Windows.
I recently had a discussion involving fonts looking "faded" or badly printed. TL;DR anecdotally, the problem is likely the display rather than the browser. I was working up a layout and had picked a nice, stately, old-fashioned font for the body. When I asked for comments, one person reported that it looked like the page had been photocopied from an old newspaper, with incomplete letter-forms. We both had Macbooks, running the same OS and Chrome version, but side-by-side mine looked just fine and theirs looked busted. I had the newer (but not retina) machine. We concluded that very thin fonts (or fonts with very thin lines in the glyphs) can give substandard results on certain flat-panel displays. And as Macbooks aren't exactly known for low quality, it doesn't seem to be a cheapness thing. Also, the Mac with the problems was only 2-3 years older than mine. My only suggestion is, if possible, to tweak subpixel rendering settings to something that looks better to you.
Right. 1996, which is after 1994. Python has never been popular in client-side scripting, but Python was definitely around before JavaScript. Not sure why you think I'm saying something incorrect?
JavaScript was in browsers before Python was.
processEvents should not be used except for cases where it is absolutely needed. My understanding is that it's use is frowned upon. If you have to use processEvents then you should be using threads or timers.
 Because javascript is ugly as sin.
https://bit.ly/blibonline
I found zooming in to 125% let it render properly, as firepear pointed out it seems the issue is something about the font rendering at that size causes subpixel rendering issues. I suspect it would look alright on a high DPI screen.
I always enjoy blog posts like this and find computer vision exciting. Does anyone know any references for learning more about the field?
When I was 1 I was shitting in diapers, not coding Python. Well done!
Thanks for the feedback! I've opened an [issue](https://github.com/pyladies/pyladies/issues/90) and hopefully will get to it by later today.
Well my first language out of school was java which has 100x worse lambda. I'm quite good with javascript but its solution of anon functions gets out of hand. Pythons single line lambda or just pass a function seems like a decent inbetween, it could be better but its not bad either But expressiveness in async has nothing to do with lambda. I've seen good code written just passing functions or using a reactive library with promises and futures
I must be missing something here. Why should I install this and what does it do? Not to be a jerk but I'm not going to install this just because a group of women wrote it. There is nothing in the about page that says what that package does or what it includes other than "code written by women who like python".
On Windows, you use psexec or PowerShell Remoting, depending on how complex what you're trying to do is. If you're just trying to run a Python script, use psexec.
As stated on the page, this is a welcome kit to help women start their own PyLadies locally. You'd install it to get the welcome kit/handbook, images/assets for branding, workshop materials so you can not have to reinvent the wheel, and more stuff coming. If you know of a woman who wants to start a local PyLadies, pass this along.
I come from a programming background but have never learned CV type stuff in particular, so just learning the basics would probably be step one, got any tips on that?
Even just going to 110% in chrome allowed the 't's to look like a t. This could be avoided with a better font thou.
I wrote a lot of PHP code for many years. Then a year ago I started using Python instead. When it comes time to work on something I wrote in PHP, I die a little on the inside. The thing nobody seems to approach is that the basic paradigm for developing in PHP is very different from Python or most other web languages. More of my thoughts and experience can be read here: http://www.alandmoore.com/blog/2013/02/02/from-php-to-python-things-i-wish-id-known/
I wish everyone would switch to using CFFI instead of CPython extensions or Cython, and then migrate over to Pypy3. That is one long road, but the payoff would be more performant Python without sacrificing purity. Oh, I dream. I, for one, will switch to Pypy the moment Numpypy and pypy3 go live.
This isn't a solution if it affects the majority; only power users are expected to change settings for web pages to render correctly on their machines. FWIW the font renders poorly on my desktop as well with opera/non-retina display.
Because nobody wants to rewrite all JavaScript code they already have to Python, Dart or any language you think is better than JavaScript :) JavaScript today is what Fortran was in 90's :)
From a quick skim, it looks like the key piece for you is an application called [The Hairless MIDI to Serial Bridge](http://projectgus.github.io/hairless-midiserial/). Cool stuff, I wasn't aware of this either.
It doesn't. It tells you that is a package to start our own pyladies but doesn't explain what's this "pyladies" is about. Downloaded the package from pypy to read the source code to whatever it was but there is only a few lines of python code that launches a webpage. To be honest this package looks like a bunch of promotional material disguised as a python package.
As you've discovered, the textBrowser doesn't support full CSS. You can always use a webkit widget if you want full HTML support, though this adds some dependencies to your app.
As far as I understand, ICMP ping does, but UDP ping can be implemented without root privileges. Anyway, anyhting like Scapy or ICMP ping, which requires raw socket operation would require root - it's not a python issue, it's OS issue. This is why /bin/ping is a SUID program. Do "ls -la /bin/ping"
Check out www.pyladies.com/about/ it's not a pyramid scheme like you describe. It can be seen as a local user group for women &amp; friends in the Python community.
Check out www.pyladies.com/about/ for more info on what PyLadies is about. Also read further into the post as you see more functionality will be coming. It's an easily distributed way to start up a local user group.
Very nice! I had good results using a fairly similar approach to look for illustrations in scanned book pages: http://chris.improbable.org/2013/8/31/extracting-images-from-scanned-pages/ The code is available if anyone wants to compare something similar: https://github.com/acdha/image-mining 
Thanks!!
Don't use same names for variables and functions. Edit and you need to return values from your functions if you want to use them... Also you'll probably have issues with local/global variable scope, among other issues...
I'm not disagreeing that it can be legible on one line, that's true in either. If 'inline' is the goal: match = re.search('(\d+)', whatever, re.WhateverFlags) I'd argue Python's is clearer because of the way flags are passes in. Using `//gi` is much less clear than `re.IgnoreCase|etc`.
Python: there's an API for that.
The latest hip things seems to be writing web crawlers even though several exist already....furthermore they seem very assertive that the legal aspects are the sole responsibility of the person running the code instead of the developer who provided it. Even worse is many are poorly written, have zero documentation, no setup.py file, follow bad practices, and are prone to reinventing the wheel (again)....
&gt; I'm quite good with javascript but its solution of anon functions gets out of hand. Because it's more verbose? That's even being changed with ES6. Entire function calls are just going to be replaced with fat arrows '=&gt;' 
I thought Angular just used the Sizzle engine and a couple of extras? Like jQlite or something like that. 
You mean making sure you're using pep8 whitespace? Why not just integrate it into your IDE?
Is there any PySirs site or package?
Indent code four spaces to make it look like code: def code_sample(): pass But for longer pieces of code, it may be easier to link to them on a pastebin such as [Gist](https://gist.github.com/).
Curious, what did you think Windows users did for packages? Just easy_install and binary distributions?
I would add the best thing of all about Python: It's not good, it's just better. And that's enough for now. Btw, well said, tdammers.
That's the page I'm talking about. We are: "developers who love the Python programming language and that's what brings us together", but nothing on the about page describes what this project is about. Why do I think it's a project? Putting "contribute to github" makes me think it's a code module. On the first page there's even a post about "pip install pyladies". You mentioned (in another comment) that it's promotional flyers and such, so you should really add that in the page somewhere. Sorry, I thought it was another antigravity package to check out but I wasn't particularly keen on promotional material.
&gt; When it comes to desktop applications it doesn't matter, people have no care in the world People don't care much what language is used in their web browser either. Javascript? PHP? Perl? Server-side? Client-side. Most couldn't care less. &gt; until EVERY browser on EVERY device supports something different we are going to be stuck with it. Not really. If Google or Apple, say, decide to get behind a new technology, they can introduce it in Chrome or iOS or whatever. Some technologies will catch on. Some won't. (I would hope that change is introduced with industry support.) &gt; Javascript is fine I haven't said it isn't. Javascript is the right thing to be using now and will be for some time. I'm just saying we shouldn't stay with any particular language or platform indefinitely just because it's so widely used. Doing so is a disservice to users and technological development alike. &gt; Javascript is the lingua de franca of the web. Certainly. This is a great analogy. Lingua francas change out of practicality and necessity. Our technologies should do the same. 
put it on gist
Why in the world would a male-dominated field need a special outreach group for guys? *eyeroll*
Sounds like you need to take classes that don't involve programming. 
Have you cross-posted this to stackoverflow.com? You might get better responses there than on reddit.
I love music, but know nothing about nothing about playing music, would this be something I would still be able to assist with?
It's relevant to [Brython](http://www.brython.info/) I think.
Why in a context of a programming language there should be any sex-based separation? Just write a code.
Have you checked out [openhatch](https://openhatch.org)? Maybe a project will stick out to you there. 
If it's simple, it shouldn't be a problem. If you hate code, you should drop the class and save your money. Also, probably switch majors.
Django.
Absolutely well said. My work is heavy in JavaScript right now, it's kind of a fun language, but I feel bad sometimes for how easy it is to abuse and lever in non-traditional ways.
The reason the while count &lt; 2: loop is there is so that I can come away with a reliable serial reading on the final run through the loop. For whatever reason, ser.readline() gives me a bad reading the first time around. That is, the array generated is empty. I'm not sure why this is, and it was the source of some frustration early on. It isn't very important that the code not blow up on me if i have bad data. Reason being is this chart serves only as a visual representation of acceleration forces for my reference. Mostly, I'm uncomfortable with the idea that my program sometimes works and sometimes doesn't! I figured I could get around the issue by changing the &gt;1 criteria to ==5, but the program doesn't run at all when I do that and I haven't debugged further yet.
Also, I'll keep you posted on any progress I make with your suggestions. For now, if you're interested in seeing what I've got so far, [here](https://www.youtube.com/watch?v=gTJPeZw0Wjk) is a quick video of the plot. I've cleaned it up a little &amp; included x &amp; z axes since the original post. I've also solved the issue of lag. Although the lag is gone between physical input and plotting, you'll notice the plot still isn't very fluid.
cp -R /usr/local/lib/python2.7/site-packages/django site-packages wat.
Yes! There are plenty of companies out there looking for Django developers. I'd also recommend looking at Bootstrap which will help you make beautiful UIs easily.
IMO, you should reverse your ordering of importance.
Check out SimpleCV: http://tutorial.simplecv.org/en/latest/ It is an open source, python based OpenCV wrapper, among other things. 
That's exactly what Python is not about... but e-penises are.
:( &lt;(jorge@abril)---(lun abr 21 22:56:59)&gt; [~][1] $ pip install pyladies Downloading/unpacking pyladies Could not download the requirement pyladies Cleaning up... pyladies: I think we should be only friends. Storing debug log for failure in /home/jorge/.pip/pip.log &lt;(jorge@abril)---(lun abr 21 22:57:45)&gt; [~][2] $ 
Because one sub-demographic with a 50% representation in the general population is severely under-represented in this field, so people are doing proactive stuff to try and fix that.
Well, I still have no idea, why it is a problem. Are you trying to make balanced gender representation just for 50/50 numbers? Someone makes code, someone works in court, someone doing another job. It is a their choice.
Why langage X is better than Y? There are quite a tinge better langage, but what makes a code really worthy is the programmer, not the «fashion» or any cargo cult super cow power. So my point is programming is only -whatever the langage you choose-: hard work, more work, and working harder. PHP or python have nothing to do with it. EDIT I am an happy python, and former C, PHP, Perl, VHDL, Asyst, 68K ASM, Tcl/Tk, matlab, c++, c#, spice.... coder that loved every single langages he learnt, because programming is awsomely fun whatever the langage. And, I intend to learn even more langages if they bring me something new.
Even with "fixed" fonts (Chrome 35+ with DirectWrite flag turned on), those t's still look really thin and hard to read: http://i.imgur.com/XK0evAX.png I don't know what the person who designed that font was thinking.
I'm mostly confused as to why this is a Python package and on PyPI instead of just a normal download. To me, packages are for python extensions you use in python and code. This seems to be mostly images, brochures, etc. It's a fantastic package, but distributing it through PyPI feels a bit awkward to me. Maybe I'm just not used to seeing this sort of data being passed on that way and it makes sense to have it on PyPI.
I'd be weary of making an ecommerce site if you are asking questions like this. Web programming is hard do right in terms of security, and as soon as money is involved the risk goes way up. I was able to pay for a large chunk of my university costs by fixing poorly designed websites. 
hahahaha, thats awesome, you sir deserve a beer!
Try Camelot, it uses PySide or PyQt, and is build with responsiveness in mind ... http://www.python-camelot.com
IMO combining cffi and numba is the best way to go. You can combine the best of both worlds - using numba to speed up your existing python code (where possible) and cffi to include functionality from third-party C libraries. 
Yeah, playing with OpenCV is so fun and rewarding. I wrote one for doing OCR on FEZ ciphers (slight spoiler if you haven't played): https://github.com/EhsanKia/FEZ-OCR 
It's *essentially* a marketing gimmick, but as it's got people talking, it's done its job well! Also it has the added benefit of making sure people always have the most up to date promotional materials.
Well, a lot of very successful, stable, well-maintained, and high-volume web sites and services use it and love it, so by those criteria it's a good idea. 
Virtualenv, anyone? Don't forget the 'copy this binary from my one drive. ' :) It is a start though. Azure should likely provide the SQL connector as part of the platform. 
&gt; It is a their choice. That's only considering a single individual. There's no reason that statistically programming should be devoid of women, especially considering it's not any kind of physical job. 
1. Code/Read code 2. Be active in GitHub/Stack Overflow. 3. Maybe an awesome Python blog will also help.
I'm definitely a huge fan of what you're trying to do, but I have mixed feelings about using pip as a medium for marketing. It's clever, but I also think it's an inappropriate use of pip.
Hi, did you ever consider contributing to a simple static site generator? https://github.com/dinever/crotal
&gt; import nmap I did not know that this existed!
&gt;&gt;I think your distinction of bool as a separate type vs characters as a subset of the str type is far less important than you make it out to be. &gt;I guess then our disagreement is over the scale of the difference. But I don't think you can justify (bools being a subclass of int) based on (chars being not a subclass of int). I'm not though :/. &gt;You could justify not having bools at all in this way. For example just using 1 and 0 in there place like in C. There are readability and consistency problems there that `True` and `False` were added to fix. &gt;&gt;MyZero(int) &gt; Even if they made True and False syntatic surgar for 1 and 0 I would be ok. That's what it is. `True == 1`. `False == 0`. It's sugar. Pure sugar. &gt;&gt;Really? Python's duck-typed. &gt;Yes but this is still type checking. When you do 1 + 'a' you get a type error. The way it does type checking is by duck typing but it is still type checking. This is not C that will let you run arbitrary bits as code. There is a check to see if the right method exists. But in reference to the original point. No I don't think there is one example that does not even internally do an isinstance,is,type or something like that that will result in a difference. But my point with the json example is that the difference matters even when you are not yourself explicitly using isinstance or something. This is enough to cause problems and make the situations not the same even in practical terms. The point of duck typing isn't to remove the guarantees of strong typing, but to remove the restrictions of dynamic typing. The reason `1 + 'a'` is fine is because the types themselves define the operations and because *the supertype* is allowed to override the other's behaviour. `json` is a special case because it is a serialisation library. It interfaces with other external type systems (well, one other), complicating the ability to duck type. Personally I'm surprised it even tries. &gt;&gt;Well, that the two are indistinguishable. How does it? &gt;Obviously ints,stings,dicts and whatever else are represented as bits in memory. But they are not treated like bit strings. str(4) does not come out as hex How is hex any different from hexadecimal here? &gt; or the ascii encoding decoding? &gt; of the bitstring 4. It is '4'. It is treated like an int not a bit string. `4` = `0b100`. The fact that `str` returns a human-readable output (much like `str(bytes([97])` returns `"b'a'"`) has nothing to do with anything. &gt;&gt;My point is that bool being the LSB of an integer does not require the bool constructor to extract the LSB of the integer, much as str(iterable) does not equal "".join(iterable). &gt;Of course it is not required. You can build your programming language however you want. It is just inconsistent with expectation. You seem to have dismissed my argument on a misreading. The argument was that your suggested interpretation is far less consistent than its current behavior. &gt;I have no reason to expect the str(iterable) is the same as "".join(iterable). In general iterables do not act like stings. Strings are iterables of course but I can't do .upper on any old iterable. The point is that expecting `bool` to return the LSB of the input is like expecting `str` to "extract" the strings from iterables. Neither makes sense. &gt;But if you want to make bools a subclass of int and have them be able to be added to ints by arguing that they are just the LSB of an int there is an expectation that it will work this way when doing "if 4:" Then what would `if []:` do? Your interpretation is self-defeating. &gt;I would not have a problem if we actually treated bools as the LSB of int. But we do. They are. There is nothing about them in which they are not so. `True == an_odd_number &amp; 1` for *all* odd numbers and `False == an_even_number &amp; 1` for *all* even numbers. &gt;&gt;Python is defined for an infinity of structures; it is a language definition and not an implementation. As such the size of the computer is only of cursory concern. &gt;Yes it is but I only have to produce one mapping to show that a mapping can exist. Whilst you do technically have a relation, this is playing semantics at best. &gt;The mapping I choose is not based on python in general but one specific implementation. And thus is not acceptable for Python, which is a language spec. &gt;&gt;You lose a whole heap of useful properties (such as associativity) and get absolutely no benefits. &gt;Again I completely agree that it is insane to have {'a':1} + 5 work in python. My point is you could do it, not that it is a good idea. This is to refute the argument that True + 5 working is ok despite 5 + {'a':1} because it is not possible to create a mapping with dicts. My argument for why True + 5 is bad has nothing to do with being able to make a mapping. It has to do with the behavior being unexpected and therefore potentially leading to missed bugs. You've forgotten what this part of the argument is about. To recap, you said &gt; It would make almost as much sense to have strings be a subclass of ints as booleans. Why do 1 + {} or 'hi' + 0.1 or type + [] all thow errors but True + 3 does not? and I explained that &gt; `1 + {}` has no sensible result. There is no mapping that is consistent, symmetrical, lossless and reasonable. However, with the mapping of `True == 1`, `False == 0`, **everything** that a bool does is **obvious**. I am not using the impossibility of a mapping to justify the `int`-`bool` mapping. I am using it to answer your question. &gt;&gt;throwing away all the information in the type &gt;Its not trowing it all away. As long as there is a defined mapping you could go dict(0) and get back {1.0:0} or whatever it was. Oh, so your intent was to map each dictionary onto seperate number, instead of just coercing all `dict + int` operations to 0. Well, what about `{1: object()}`? How would you encode that? &gt;&gt;But you haven't explained why. &gt;Unless there is some good reason to do it you should not. There are good reasons to not break closure. The biggest advantage I see is that it means you are less likely to make mistakes when using the object. If I know that every operation with two bools always produces a bool it reduces the chances I will make an unintentional error. Why would you assume `True + True` would return a `bool`? Surely if you saw that you would not make the assumption that it would evaluate to a boolean as such a mapping would be insane. So why would `True + True` mislead you? You might be *supprised* that it does not throw an error, but this is hardly the same as the problem you're talking about. &gt;I just never ran into a situation where it was helpful to break closure on bool. sum(x &lt; y for y in z) index += has_finished_with_item x_pos = base_x + has_offset*5 one_bool &gt;= other_bool # more readable than "one_bool or not other_bool" &gt;I can think of harmful ones like (if something_I_thought_was_bool_but_is_int:) or (something_that_is_a_bool_I_though_was_an_int + 1) not throwing type errors. The first is irrelevant, as it refers not to `True == 1 and False == 0` but to truthyness tests. For the second you use the word "but" where you should be using the word "and". Further, why would you want a type error there? Just *duck type*. &gt;&gt;Exactly why they are the order they are in... &gt;To me 1/2 being 0.5 is more unexpected than 1/2 being 0 especially. But I can see this going either way. I dare you to find *one* non-programmer who thinks that 1/2 = 0. You've been tainted, methinks, by tradition. &gt;&gt;If fractions.Fraction was a builtin &gt;If 1/2 literally resulted in a fraction object it would not be breaking closure as (1/2) ** (1/2) would not either. If you still did Fraction(1/2) it would still be pretty explicit. But if (1/2) ** (1/2) became a float and 1/2 was a fraction I would not be happy. Would you rather it be a fraction‽ It's *irrational*! It's *impossible* to represent it as a fraction! &gt;&gt;would you be be happy with it breaking closure &gt;No. It is unexpected and could easily lead to errors. Sure it makes sense to break closure a fair amount of time. But normally this is not the case or it is very obvious when an operation is going to do it. Then I'm afraid you have confuddled me greatly. If it is not obvious there, I am not sure what would count as obvious. &gt;&gt;Why couldn't you just pass it to the json library? &gt;If an int say 23 was returned I needed to just say {'answer':23,....} but if some other unexpected object like False or 'this is weird' came out I needed to do something like {'answer':'unexpected thing returned'}. MyZero would have created a similer problem. Thanks for the details. Why would you accept "proper" int subclasses but not booleans? What's wrong about booleans? &gt;But MyZero is a bad int subclass. A reasonable int subclass would give me '0' for str(0) even if it contained additional meathods that int does not have. You are simply wrong. I suggest reading the `json` source code to understand how to properly approach such things (there are relevant comments). class MyThreeNumbers(enum.IntEnum): one = 1 two = 2 three = 3 MyThreeNumbers.one #&gt;&gt;&gt; &lt;MyThreeNumbers.one: 1&gt; str(MyThreeNumbers.one) #&gt;&gt;&gt; 'MyThreeNumbers.one' MyThreeNumbers.one == 1 #&gt;&gt;&gt; True isinstance(MyThreeNumbers.one, int) #&gt;&gt;&gt; True 
You could use Swig to create an interface between the two.
Honestly I still don't understand the project, even after reading the about page. Is their some sort of agenda? If not,... er... could someone shed a light please?
Hi, thanks for writing! I'm glad to hear you're interested. There are definitely ways folks can help out, *especially* if you're brand new to learning music. I'd love to talk more, I'll send a PM with my email to you.
I read this a lot but I have a huge amount of trouble actually finding stuff to code lately. 
You can always have it on a VPS, or in a computer accessible somehow. For "just posting" you may want to take a look at the webapp plugin, too :-)
Hadoop
Care to expand on that? 
Hadoop is a distributed computing framework primarily used for the analysis of Big Data. The ability to conduct data analysis using parallel processing is becoming more and more in demand while the supply of people who actually have that skill stays relatively stagnant. O'Reilly has a popular [book]( http://www.amazon.com/gpawd/1449326269?pc_redir=1398091651&amp;robot_redir=1 ) about data science that uses python. I'm currently building a raspberry pi cluster so I can learn about the sysadmin aspect of hadoop as well since my school doesn't offer a course that covers that material.
Thanks for the answer...that's a problem I am willing to tackle in the future.
Cool idea, but using Go instead will make more sense anyway. Recently, I was trying to write an app that will have web UI and will do some background jobs when requested - fetch multiple resources, run shell command etc. Because I was using py3, I was trying to use asyncio but I switched to Go, rewriting everything. Python is my goto language, but when it comes to concurrent programming, it's way behind Go. My opinion is that `yield from` is ugly and using it cause more problems than it solves. (I know it's `gevent` based, but there's no gevent in py3k)
Thanks AMorpork! We have just fixed it.
I haven't personally tried it; it's just in a collection of links I've been building in anticipation of needing a python speedup. I was quite surprised to find YA one. Reading their web page, they admit they are, thus far, just doing a straightforward compilation of Python to C++, handing off the hard cases to pythonlib, i.e. they are basically replacing bytecode with equivalent C++ function calls. Plus recognizing some manifest constant values and doing constant propagation, but that isn't going to gain much in realistic code. However on their [download page](http://nuitka.net/pages/download.html) they claim "A 258% speed factor for the PyStone benchmark." Two key elements for performance are their steps 4 &amp; 6 on the overview page I linked above. Doing "type inference", deciding at compile time the certain or at least most likely data types in an expression, would allow them to generate C++ code for the likely case, and call into pythonlib only when the type is not what they inferred. And I think that step 6, a "hints module", would complement that in a big way. I presume what they mean is allowing the programmer to decorate the code with type declarations in some fashion. Cython has something similar, but when you use it, I believe you break compatibility with CPython. If Nuitka could support type declarations with syntax that retains CPython compatibility they'd have something.
Yes, i remember reading [this](http://code.tutsplus.com/tutorials/how-to-build-a-python-bot-that-can-play-web-games--active-11117) blogpost on how to use image recognition for playing sushi go round, i think that kind of stuff is pretty cool too.
It's a shame that Jython has been abandoned and is a dead project at this point since it had potential. Lack of leadership has led to its downfall.
Same subject : https://github.com/benoitc/offset
I've used Node for exactly that kind of thing and liked it pretty well. Not only can you do async jobs easily, you can run an separate admin server on a different port, within the same process. Pretty slick. 
Why don't you like `yield from`? Besides the inability to use traditional iterable generators in coroutines, what problems does it create?
I know ide's have ways to do this. I want something like when you paste your python code on the browser, it will fix all the indentation errors. This is so that any text editor can be used even without python indentation detection.
thanks! this is something i am looking for. 
Like many said, JavaScript came first and became more standardized. Node.js helped JavaScript gain traction on the server side due to its ease of use and familiar language. I believe that it still performs Python's gevent and uWSGI and Oracle has been trying to get JavaScript on the JVM for some time now with their open source Nashorn project.
You seem to have downloaded the source code for python. You have to compile it to run python. The easier way would be to use a package manager to install python instead. Since you mention Unix, I'm assuming you don't mean Linux, which is just Unix-like. I'm not really familiar with any of the real Unices, so I'd suggest you ask your sysadmin to install python for you. Or if you really wanna compile it from source, just unarchive it, then: ./configure --prefix=installation/directory/ make make install 
I realize it isn't the point of your comment, but you should really use a background job system for things like that, so you can return a response to the user that lets them know you got their request, and you're doing something with it. Just not responding until whatever background job is complete can lead to user frustration.
&gt;There are readability and consistency problems there that True and False were added to fix. Yes and it was a good idea to add them. It might have even make sense at the time that they added them the way they did. But they are non ideal. My point is not to argue for not adding them but to show what if would actually mean if you wanted to create a situation analogous to str/char. &gt;That's what it is. True == 1. False == 0. It's sugar. Pure sugar. But its not pure syntactic sugar there are semantic differences. type(True) and type(1) return different things. If it was pure syntactic sugar they would not return different things. &gt;The point of duck typing isn't to remove the guarantees of strong typing, but to remove the restrictions of dynamic typing. The reason 1 + 'a' is fine is because the types themselves define the operations and because the supertype is allowed to override the other's behaviour. Not sure how this refutes my point that duck typing is still involves type checking. &gt;json is a special case because it is a serialisation library. But it is not special in a practical sense. Serialization is a common and key part of what programmers do. &gt;How is hex any different from hexadecimal here? Its not. &gt;decoding? Ascii is an encoding http://en.wikipedia.org/wiki/ASCII. &gt;The fact that str returns a human-readable output (much like str(bytes([97]) returns "b'a'") has nothing to do with anything. Its not just the human readable output. Machines/libraries read strings too. Unix is designed around using strings not binary when possible. Further it makes the point that ints are treated as ints and not bitstrings when using the str operation. Of course there is nothing inherently wrong with str(4) returning anything at all to a computer. The point is that in python it is often treated how a person would treat a number not how a person would treat a bitstring and people are the ones programming. &gt;Whilst you do technically have a relation, this is playing semantics at best. Your right this whole argument is kind of ridiculous. Of course there is a relation and of course it is a ridiculous relation. That is the whole point. &gt;&gt;1 + {} has no sensible result. There is no mapping that is consistent, symmetrical, lossless and reasonable. However, with the mapping of True == 1, False == 0, everything that a bool does is obvious. &gt;I am not using the impossibility of a mapping to justify the int-bool mapping. I am using it to answer your question. But your not answering my question. I agree that 1 + {} has no sensible or reasonable result. My point is that niether does 3 + True. This only leaves your argument that 3 + True should exist because it has some symmetrical and lossless mapping but 3 + {} does not. But I have shown a mapping does exist removing this argument. I am still not quite sure what you mean by lossless and symmetrical but my mapping seems to have these properties from what I can tell. And anyways these two properties are essentially meaningless compared to sensible,reasonable, and obvious which I argue 4 + True is not. &gt;Oh, so your intent was to map each dictionary onto seperate number Yes &gt;Well, what about {1: object()}? How would you encode that? In the same way the binary shows up on my specific implementation of python running on my specific hardware encoded as an int.. &gt;Why would you assume True + True would return a bool? Surely if you saw that you would not make the assumption that it would evaluate to a boolean as such a mapping would be insane.So why would True + True mislead you? You might be supprised that it does not throw an error, but this is hardly the same as the problem you're talking about. I think it should throw and error and it is exactly the problem I am talking about. &gt;sum(x &lt; y for y in z) sum(int(x &lt; y) for y in z) #this is much clearer. &gt;one_bool &gt;= other_bool # more readable than "one_bool or not other_bool" It is much less readable. I used to try this but I would constantly be rejected in code reviews because of readability on this specific point. &gt;index += has_finished_with_item &gt;x_pos = base_x + has_offset*5 Also should just use int(). Well in general you probably made a mistake even before this point. &gt;Further, why would you want a type error there? Just duck type. Because if at some point I wrote. an_int,a_bool = func_that_returns_an_bool_an_int() by mistake. I want an error thrown when I try an_int + 50. &gt;I dare you to find one non-programmer who thinks that 1/2 = 0. You've been tainted, methinks, by tradition. Programming languages are written for progammers. &gt;Would you rather it be a fraction‽ It's irrational! It's impossible to represent it as a fraction! No need to yell(clever trap). I actually think that should throw an exception in that case unless explicitly silenced. &gt;I am not sure what would count as obvious. a.append([]) makes sense to return None for example. &gt;What's wrong about booleans? Because sometimes the library returns 0 as a legit answer but when it returns False it means something else. &gt;You are simply wrong. Why? Take for example str(fractions.Fraction(0.5)). &gt;I suggest reading the json source code to understand how to properly approach such things (there are relevant comments). Not enough time to read the source at the moment. I don't doubt there better ways to handle my problem. After all I had to modify my code to fix it. But it should not have required those better ways. You can write great php but that does not mean php made great choices. I am not saying python disallows you from writing mythreenumbers just that it is not a great class. If you called it. OneTwoThreeEnum that would be a different story. 
Paying someone to do your homework is cheating, and if caught you can be expelled. It's probably not worth the risk. Do your best and get the grade you deserve. If you really don't want to do it, don't. Take the zero and try to make it up by putting more effort into an assignment you do enjoy. Don't risk your entire academic career on one assignment you don't want to do.
Hey so i typed python into the terminal and it said I had 2.7.5 then i tried python3: &gt;&gt;&gt; python3 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'python3' is not defined &gt;&gt;&gt; KeyboardInterrupt
I've updated my post. It is a list of my focus, not what I deem to be important. I agree that unit testing is important... important enough that I know it already so my focus is elsewhere.
Awesome. What's a real world way of getting into Hadoop? Any projects you can recommend?
Hey, when you type "python" you enter the python 2 command line. When you typed "python3" you were still in that command line. So you got to quit it first: Ctrl + D Then try "python3" again. 
I use one called Ninja. Its simple, easy to use, nice UI, free, and you dont need to install anything like Eclipse. Im currently on mobile so I cant send you the link but if you search "python ninja," you should find it.
They did not implement a new language-level feature. `asyncio` is a library that uses generators (or more specifically coroutines) and `yield` and `yield from` are how generators work.
I wish I had this problem! I've got a shit tonne of stuff I still wanna do, some half-started. Here's few of the things I've been working on. Maybe something on it will inspire you? * An UPnP implementation that automatically forwards ports on your router to an internal machine. **Keywords**: lowlevel networking, udp, broadcasting, HTTPU (http over UDP) * A simple, secure web-based HTTP server that can serve files from a single directory from a machine *inside* the network to the world. (Heavily related to above UPnP implementation). **Keywords**: UPnP, simple web framework, secure sharing * A very simple interpreted language *completely* from scratch. **Keywords**: compiles, tokenization, lexing, interpreter. * Automated database documentation generator. Basically Sphinx, but for databases. Generates db, table, column docs, diagrams, foreign key references, indexes and procs. **Keywords**: RDBMS, database independent, schema introspection, generation. * HAR (HTTP Archive) replayer / tester. A tool that takes HAR as input and replays a session and detects problems. **Keywords**: HAR, network, http, fuzzy testing. * Evolutionary Algorithm framework that can evolutionary generate Brainfuck code. **Keywords**: Brainfuck, evolutionary algorithm, computer science. Currently I'm working on a (business) process automation framework. I'm using some pretty new tech on purpose to keep things interesting. It's a framework that makes it extremely easy to hook things up to each other. For example, clients emit RSS items or Facebook Events or incoming emails or monitoring alerts to a queue. A special client matches items in the queue and emits new queue items to different queues. Other clients pick those items up and generate emails, digests, confirmation requests, etc. Software like this already exists, but it's incredibly complicated to get working. In my framework, writing a new client can be done in minutes. Anyway, as you can see, I wish I had a little more time, or less interesting stuff I'd like to work on :D **edit**: I'm aware that there already exist solutions for the things I mentioned. Usually I'm still trying to scratch an itch with what I write, but mostly it's just for my own education. **edit 2**: Some clarifications.
To be fair there is little use for the case where a task/future is a traditional generator in the first place. I consider it more than a fair tradeoff for gaining serialized "what you mean" syntax over the callback mountains node.js is famous for.
Your Unix comes with an in-built python, too, so there will be a distinction between the Python you will install and the one that is already installed. I see that you are about to use Python 3. In this case it is less troublesome to keep the in-built Python 2.x separate from the Python2.x you would install when you type `python` into the terminal. If you install packages, I would still recommend using [virtual environments](http://sebastianraschka.com/Articles/2014_install_python_sci_pkgs.html#venv) for different purposes though!
That's what I did, but it doesn't work that well for all cases. You still need separate process for every task and progress notification is not that easy anymore. It's also fine for big application but for simple tasks it's a bit of a overkill.
You just made me realize that I've been coding nearly non-stop for more than 25 years, and I'm still not bored with it. From writing databases and wordprocessors on the MSX to debugging SNES roms, from writing mouse drivers for MSDOS to writing linux kernel modules. From programming one of the first (non-web) Hypertext processors to doing web development. And I'm still not bored with it. That's pretty awesome. :)
So they both function the same? I am reading through O'reilly's "Think Python" and in the first chapter there is already a difference in the syntax of the print function, python 3 requiring parentheses while python 2 does not.
Then you've already got past the biggest difference in terms of a learner. Yes, there are more differences to be had. Will it matter to you? No. It's easy to change between 2 and 3, they're very similar.
I'm not saying it's lightweight, but once your app gets enough users, it's really the right way to go.
* Libraries - you cannot reuse those. For example you can use psycopg2 with wrapper, because those are already written, but there's no ORM. Also some libraries are having bugs because they are just not tested enough. * You need to put `yield from` everywhere which makes the code look just strange. I agree that begin explicit is good, but it's no golden bullet. You still want to use locks where required. * I really hate silent mistakes when using yield. Sometimes you're getting strange error that over time you will learn to interpret correctly, sometimes you won't realize that there was an error, because you have not checked. There's a really good article about why to use explicit yield** and while I agree with arguments, I still find writing concurrent Go code way easier and faster than in Python. I'm not saying that the approach (no hidden context switching) is wrong. It's the implementation, build on top of good-enough-but-not-designed-for-this functionality is bad choice. It all feels way too complicated compared to other languages that are supporting concurrency natively. ** https://glyph.twistedmatrix.com/2014/02/unyielding.html
Honestly, there are differences, but some so minor that it may no really impact your learning experience. I would still strongly suggest you start with Python 3.3/3.4 though. I only mention 3.3 for the third party library support.
It doesn't matter. But go with 3 anyway.
I tend to use always print('some string') now, it works in both versions and feels more natural (since it is a function call after all) 
I disagree: The easiest example is reading lines from a `StreamReader`. I set out to write a generator that provides file-like iteration over lines: def read_lines(reader): while True: line = yield from reader.readline() #yield to event loop if not line: return yield line #yield to caller Only to realize that there's no way to separate the different yield control flows.
If you're interested in Go, but also hate curly braces check out, [iGo](https://github.com/DAddYE/igo). 
I do get your point but at the same time building a crawler/scrapper (especially using python) can be a good way to learn python and make your learning project useful... Also, I do not think that it applies to every project to always have amazing documentation or to have a setup.py. A crawler/scrapper for example has the same basics and re-inventing the wheel might be kind of hard. On the other hand, this kind of project is amazing to learn AND makes it possible to potentially use it to incorporate added value some how (in my case making it distributed to gian in performance).
Start with the latest Python (3.4) and use it unless you need a 2.7 package. The major differences you can list on a few fingers, but you'll learn better habits (that mostly apply to 2.7) by learning in 3.4 (e.g. how to do division, don't used mixed type dictionaries that you need to sort). Learning 3.x isn't why everyone hasn't upgraded. There's lots of legacy in 2.x and migration is expensive, especially when your GUI is written in wx and wx doesn't have an offical Python 3 version yet.
@ your second point: [Sounds like they plan to, according to this comment on HN.](https://news.ycombinator.com/item?id=7628730)
nice!
&gt;&gt;There are readability and consistency problems there that True and False were added to fix. &gt;Yes and it was a good idea to add them. [...] My point is not to argue for not adding them but to show what if would actually mean if you wanted to create a situation analogous to str/char. I've missed the argument entirely, because I thought I just responded to that point. &gt;&gt;That's what it is. True == 1. False == 0. It's sugar. Pure sugar. &gt;But its not pure syntactic sugar there are semantic differences. type(True) and type(1) return different things. If it was pure syntactic sugar they would not return different things. I disagree. The semantics differences, which basically distill down to "it's got a pretty name", are sugar. &gt;&gt;The point of duck typing isn't to remove the guarantees of strong typing, but to remove the restrictions of dynamic typing. The reason 1 + 'a' is fine is because the types themselves define the operations and because the supertype is allowed to override the other's behaviour. &gt;Not sure how this refutes my point that duck typing is still involves type checking. Because the argument was about how `json` uses `isinstance` instead of duck-typing. Whether you want to stong typing "type-checking" or not is completely orthogonal to the point, and that's what I've been trying to explain here. &gt;&gt;json is a special case because it is a serialisation library. &gt;But it is not special in a practical sense. Serialization is a common and key part of what programmers do. It *is* special in a practical sense because it interfaces with a different type system. That breaks the ability to write conventional code. `pickle` doesn't have this problem, showing that it's not *serialisation* that makes it special. It's interfacing with another type system. And common things can be special. &gt;&gt;How is hex any different from hexadecimal here? &gt;Its not. Sorry, I meant hex and decimal. &gt;&gt;decoding? &gt;Ascii is an encoding http://en.wikipedia.org/wiki/ASCII. I realise. You decode a bit string with the ASCII codec into text. You encode text with the ASCII codec into bits. &gt;&gt;The fact that str returns a human-readable output (much like str(bytes([97]) returns "b'a'") has nothing to do with anything. &gt;Its not just the human readable output. Machines/libraries read strings too. [Then don't use `str`.](http://stackoverflow.com/a/19597196/1763356) If you need a specific encoding, format it explicitly. Again, the `json` library give one technique. Another is using `str.format`. Others are using specialised routines. `str` is for printing. `repr` is for debugging. That's it. &gt;&gt;&gt;1 + {} has no sensible result. There is no mapping that is consistent, symmetrical, lossless and reasonable. However, with the mapping of True == 1, False == 0, everything that a bool does is obvious. &gt;&gt;I am not using the impossibility of a mapping to justify the int-bool mapping. I am using it to answer your question. &gt;But your not answering my question. I agree that 1 + {} has no sensible or reasonable result. My point is that niether does 3 + True. My point was that * The rest of the conversation is dealing with why I think `3 + True` is useful and should not cause problems, so we don't need to duplicate it * There is no feasable way of having those properties (useful and should not cause problems) with an `int`-`dict` mapping. &gt;&gt;Well, what about {1: object()}? How would you encode that? &gt;In the same way the binary shows up on my specific implementation of python running on my specific hardware encoded as an int.. That can't work. a = {1: object()} b = {1: object()} assert a != b # must always produce the same result as # both inputs are immutable a + 1 # must always produce the same result as # both inputs are immutable b + 1 # ..etc.. &gt;&gt;[examples] &gt;[you think they're bad] Meh. I disagree then. &gt; Well in general you probably made a mistake even before this point. ? &gt;&gt;Further, why would you want a type error there? Just duck type. &gt;Because if at some point I wrote. &gt;an_int,a_bool = func_that_returns_an_bool_an_int() by mistake. I want an error thrown when I try an_int + 50. Why would you *ever* have a function that returns a `bool` or an `int` and expects you to treat them differently based off of the *type*? That's about as antiPythonic as it gets... &gt;&gt;I dare you to find one non-programmer who thinks that 1/2 = 0. You've been tainted, methinks, by tradition. &gt;Programming languages are written for progammers. Yes, but consistency with other languages is less important than doing the right thing. Further, the original meaning of `/` heavily broke duck typing. `//` as integer division does not have this problem. `/` as integer division would be blindingly confusing because you'd have `1.0 / 2.0 == 0.0`! &gt;&gt;Would you rather it be a fraction‽ It's irrational! It's impossible to represent it as a fraction! &gt;No need to yell(clever trap). ? &gt;I actually think that should throw an exception in that case unless explicitly silenced. So how would one do exponentiation if not by the exponentiation operator? AFAICT, TOOWTDI *forces* use of the exponentiation operator for exponentiation, especially with the requirement of duck-typing "support". &gt;&gt;I am not sure what would count as obvious. &gt;a.append([]) makes sense to return None for example. That hardly counts. &gt;&gt;What's wrong about booleans? &gt;Because sometimes the library returns 0 as a legit answer but when it returns False it means something else. Firstly, that behaviour is absurd. Secondly, the question was meant to be taken as a full pair: &gt;Why would you accept "proper" int subclasses but not booleans? What's wrong about booleans? How are booleans *special*, basically. &gt;&gt;You are simply wrong. &gt;Why? Take for example str(fractions.Fraction(0.5)). Did you not see how my example at the bottom proved my point? An example of a perfectly reasonable `float` subclass would be one that carried an extra `error` parameter (although normally I'd consider implementing an ABC and using composition instead). This error parameter could show up on the `str` format as str(FloatWithError(1.4, 0.1)) #&gt;&gt;&gt; 1.4±0.1 &gt;&gt;I suggest reading the json source code to understand how to properly approach such things (there are relevant comments). &gt;Not enough time to read the source at the moment. I don't doubt there better ways to handle my problem. After all I had to modify my code to fix it. But it should not have required those better ways. You can write great php but that does not mean php made great choices. This reasoning makes no sense to me. PHP is bad because it is *hard* to write good code. Python is better because it is far easier to write good code. Ignoring duck-typing and using type-based dispatch¹ is going purposefully out of your way to write bad code. If Python should have changed at all, it should make it *harder* for that code to have worked, not easier. [Also note that the CPython `json` serialization routine is ~300LOC + ~100 lines of docstrings](https://github.com/python/cpython/blob/2ff208e7571d1abebddfae9936ba1ba221502a44/Lib/json/encoder.py#L301). ¹ In case you mention it, `functools.singledispatch` is different because it duck-types. Typical implementations like yours do not. &gt;I am not saying python disallows you from writing mythreenumbers just that it is not a great class. If you called it. OneTwoThreeEnum that would be a different story. Why? Are you suggesting we move to Systems Hungarian notation? Obviously you aren't, but that complaint sure does look like it. The first example in the docs is &gt;&gt;&gt; from enum import Enum &gt;&gt;&gt; class Color(Enum): ... red = 1 ... green = 2 ... blue = 3 ... Feel free to write a bug report that it should be called `ColorEnum` if that is indeed what you are saying, but nobody would take you seriously. 
There are a few different ways to scale a node app: http://cjihrig.com/blog/scaling-node-js-applications/
Let's see what we have... Hm, I guess I can't disprove your "major differences you can list on a few fingers" hypothesis for now ;) And most of them don't apply for beginners anyway. Python3: - got Unicode (utf-8) strings, and 2 byte classes - range() is now implemented as xrange() - no xrange anymore - `next()` instead `.next()` - `//` instead of `/` for integer division returning an integer - the syntax of the `print()` statement - raising exceptions syntax - handling exceptions syntax 
I'd say find a large dataset that you are interested in and start analyzing it. I've heard that there are some datasets that pertain to astronomy so I may try analyzing them. I'm just getting started in learning Hadoop so I may not be the best resource. Check out /r/hadoop 
Why not ? :)
I think people are rediscovering the benefits of static typing for performance and correctness reasons. The latest generation of statically typed languages[0] all have some level of type inferencing which helps. If Python is fast enough for you, it’s a fantastic language. The problem is once performance or codebase demands scale, dynamic typing rears its ugly head and there are no simple solutions. At work we sidestep this issue by writing a plethora of tests, but now dynamic typing productivity gains are offset and we spin up a lot of AWS instances for performance. [0] Go, Rust, Scala. Haskell and OCaml have had it for a while.
&gt; the syntax of the print() statement Python 3's syntax works in Python 2.7 &gt; range() is now implemented as xrange() - no xrange anymore - next() instead .next() That sounds like a minor change to me. Also xrange and range in Python 3 are effectively the same. You get an extra one in Python 2.7. Bumping versions is a little harder, but going down should be easy if you know about xrange. &gt; // instead of / for integer division returning an integer Python 3's syntax works in Python 2.7 &gt; raising exceptions syntax - handling exceptions syntax They're basically the same. &gt; got Unicode (utf-8) strings, and 2 byte classes That's 1. I'll give you 2 if you consider bytes. It's not until stuff goes to C that things fall apart.
You ought to be writing tests no matter what language you're writing in. Typechecks are nowhere close to sufficient to ensure correctness. (To be honest, I'm not sure what the last time I had a "this is the wrong type" type of error in my code. The only kind of type failures I ever see in practice are AttributeErrors when using None as a value, but NoneType Errors happen at runtime in statically-typed languages too.)
Vai... Saber.
How does the go standard library compare to python's batteries?
which os are running exactly? I was assuming a debian based distro, but if it's not than the commands will be different.
hey so when i try to remove the old link via .. rm &lt;/usr/bin/python3&gt; it doesnt allow me, and says permission denied. also when i say which python3.4 it comes back with nothing, any clues?
Actually all of those are available in 2.7, just put this in the beginning of every file: from __future__ import division, absolute_import, print_function, unicode_literals To obtain 3.x behavior in 2.7
You simply put: from __future__ import print_function In python 2.7 and from that point print() behaves exactly same as in 3.x. In 2.7 I personally use this: from __future__ import division, absolute_import, print_function, unicode_literals 
&gt; the syntax of the print() statement &gt; Python 3's syntax works in Python 2.7 Yes, therefore I always use `print()` when I write Python 2 code, because it also works vice versa &gt; range() is now implemented as xrange() - no xrange anymore - next() instead .next() &gt; That sounds like a minor change to me. Also xrange and range in Python 3 are effectively the same. You get an extra one in Python 2.7. Bumping versions is a little harder, but going down should be easy if you know about xrange. yes, the only problem would be if you run you `xrange()`-containing Python 2 code in Python 3 - then you would get an error. &gt; // instead of / for integer division returning an integer &gt; Python 3's syntax works in Python 2.7 Yes, but what I wanted to get at is that it is dangerous! If I use my regular 3/2 in Python 3, and then run this code in Python 2, I will get an integer. Therefore I usually write 3/2 as 3/2. in Python 3 - I am afraid that a Python 2 person (or I myself) could overlook it when adjusting code. &gt; raising exceptions syntax - handling exceptions syntax &gt; They're basically the same. It's like with the print function. `raise IOError, "file error"` works only in Python 2, not in Python 3. Since Python2 now accepts both, I would always also use `raise IOError("file error")` in my Python code And the handling is also different: Python 2: `except NameError, err:` Python 3: `except NameError as err:` (note that it is a keyword now) &gt; got Unicode (utf-8) strings, and 2 byte classes &gt; That's 1. I'll give you 2 if you consider bytes. It's not until stuff goes to C that things fall apart. 
When I take a look at my to do list, one small thing would be a feature that [PyPrind](https://pypi.python.org/pypi/PyPrind/2.5.0) would get an option to display CPU and Memory usage during the tracking, not only at the end of it. If you like, I can leave it as an exercise for you :) Here is a [video](http://www.youtube.com/watch?v=iWjSGe89Pvs&amp;feature=youtu.be) of how it currently looks like. The GitHub repo would be:[https://github.com/rasbt/pyprind](https://github.com/rasbt/pyprind) 
&gt; It's like with the print function. raise IOError, "file error" Wasn't that removed at some point for Python 2.6 or 2.7? I always thought of that as bad syntax. &gt; And the handling is also different: Python 2: except NameError, err: I thought they removed that for 2.7 as well.
So, when you do all that, you basically have Python 3 just with faster performance than the "real" one - okay except for the bytestring/unicode thing...
Most major projects are now python3 compatible: http://python3wos.appspot.com/ The answer a few years ago was "definitely learn 2.7" the answer now is "probably learn 3.4" the answer in another year or so will be "definitely learn 3.x" There are a few differences, but overall it's more like speaking "Boston English" vs "Texas English" than it is "English" vs "Spanish."
hey this is what I am running: ben@benlinux ~ $ uname -a Linux benlinux 3.11.0-12-generic #19-Ubuntu SMP Wed Oct 9 16:20:46 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux 
My takeaway was that even with all that optimizing and porting an entire codebase, they only achieved 50% of the performance they expected was possible. There's some bad estimating and honestly some underpowered hardware here.
&gt;I think people are rediscovering the benefits of static typing for performance and &gt;correctness reasons. Most people never left static typing (C#, C++, Java, C dominate development). They have yet to discover the benefits of dynamic typing. &gt; The latest generation of statically typed languages[0] all have some level of type &gt;inferencing which helps. But to the degree they're obscure or incomplete or unsupported, they're hindered. &gt;If Python is fast enough for you, it’s a fantastic language. The problem is once &gt;performance or codebase demands scale, dynamic typing rears its ugly head &gt;and there are no simple solutions. Perhaps I'm too new to dynamic typing, but I've yet to see an ugly head. In fact, it seems to me mandatory static typing was one of those things, like C strings, that had a benefit 100 years ago but went on to become a huge mistake/burden later on. &gt; At work we sidestep this issue by writing a plethora of tests, but now dynamic &gt;typing productivity gains are offset You'd be writing a billion classes, interfaces, "generic" functions, templates, macros and other scaffolding code otherwise, all of which introduce new points of failure (unlike writing tests). You'd also find yourself needing to typecast in many places, which removes the one benefit of static typing. You'd also find yourself looking at code that a human knows will work but a compiler doesn't, so you become a slave to the machine, having to make it happy by doing extra work. You'd be creating seventy million different types, which are going to cause lots more type problems irrespective of whether the compiler finds them or not. Meanwhile, you have to pay this heavy price all the time, for code that really needs it or not. 
True, but it makes porting to 3.x easier.
&gt;and type errors occur all the time despite thousands of tests But 99 times out of 100, don't type errors just cause code to blow up, which makes the error completely obvious and easy to find, and thus not worth writing 2x to 5x the code to catch earlier? Meanwhile all that scaffolding code and having to satisfy the type system will introduce all sorts of other bugs and complex problems.
Yes, that was just a joke that you get the same syntax as in Python 3, but Python 2 is faster
http://continuum.io/anaconda Install this. 
You don't need to "write" numba, unless you mean sticking @numba in front of your existing python function... ? 
True. OTOH, everything should use pypy. ;-)
I've always disliked the way scoping worked for Python closures. Still it would be hard to improve without breaking things.
They... Last longer?
Your guess is as good as mine. I knocked this together because I thought it was neat :) Well its mostly a thin wrapper/launcher for regular old ipython. Full integration would be nice, but I just don't have the time.
&gt; Most people never left static typing (C#, C++, Java, C dominate development). They have yet to discover the benefits of dynamic typing. You could make the same argument that plenty of PHP / Python / Ruby / JS developers are making the opposite migration. Personally, I went from C++ / Java -&gt; PHP / Python / C -&gt; Python / Haskell / Rust over 15 years (with random Perl / Ruby / JS thrown in). &gt; But to the degree they're obscure or incomplete or unsupported, they're hindered. This is a red herring. The merits of static or dynamic typing are unrelated to ecosystem maturity. &gt; Perhaps I'm too new to dynamic typing, but I've yet to see an ugly head. In fact, it seems to me mandatory static typing was one of those things, like C strings, that had a benefit 100 years ago but went on to become a huge mistake/burden later on. - early feedback: it's cheaper to fix bugs early - evolution: static checking makes it easier to refactor as the codebase grows - communication: good type definition names communicate what's going on in addition to being checked by compilers in newer languages fn family_ages(persons: vector&lt;Person&gt;) -&gt; age { .. } &gt; You'd be writing a billion classes, interfaces, "generic" functions, templates, macros and other scaffolding code otherwise, all of which introduce new points of failure (unlike writing tests). I think you're confusing static typing with unrelated issues. FYI, these things are not related to static typing: - classes: Python objects - interfaces: Python mixins - generic functions, templates: aka parametric polymorphism, Python has those too - macros: made famous by Lisp / Clojure, yet another dynamically typed language
Agreed. There is an ugly workaround where you pass a mutable parameter to a function (a list for example) and that will act like a closure in other languages.
Me too. It's probably my only real complaint about python. Stupid late-binding.
In fairness the old exception syntax and old raise syntax are both considered bad style in any 2.x version that supports the new syntax. 
Tried it on my mac osc 10.7.5. The bundle app just loaded an empty window. Is there a way to configure the default ipython path?
&gt;But 99 times out of 100, don't type errors just cause code to blow up, Yup. Per Murphy's law, this will happen at 1am on a Saturday and bring down your online service. &gt; which makes the error completely obvious and easy to find That assumes it's trivial to find where every variable's value comes from. Otherwise you end up with something like \`error, in 'currentValue / totalValue', cannot divide 2 by "234bob2joe731"\`. TotalValue should clearly be a number, but fixing the program to make it the correct number is non trivial. The true error might be in some entirely different module, or maybe in bad data coming from a database so the error is really in a different program. &gt; Meanwhile all that scaffolding code and having to satisfy the type system will introduce all sorts of other bugs and complex problems. I've never seen this -- static types hurting perf, yes, but not hurting correctness. Could go describe an example? Was the type system too limited perhaps? (E.g. Java without generics is in practice *not* statically typed due to all those casts).
Thanks, I wish everyone would think like that! Seriously, 95% of the Python 2 projects I see don't follow that paradigm (including those that are currently being written)
My thought on this was... *In a Learning context:* 2.7 has been around for a while and will still be around for a while and has a *fuckton* of educational and support materials already available. 3.x is new, relatively un-grooved-in and relatively un-adopted. It hasn't obtained critical mass yet. Trying to utilize learning materials designed for 2.x in a 3.x context will likely result in all manner of errors and issues that will be formidable to a new student. It is my hope that, by the time I've educated myself enough in 2.7 to actually be productive as a programmer... I should have a strong enough knowledge-base built to understand the differences and "advance" to 3.x :)
&gt; To be honest, I'm not sure what the last time I had a "this is the wrong type" type of error in my code. The only kind of type failures I ever see in practice are AttributeErrors when using None as a value, but NoneType Errors happen at runtime in statically-typed languages too. To be fair, these kind of programmer errors tend to get routed out during integration and basic coding of components as the application grows. But it's purely incidental. Unless all of these type-error code paths are covered in a unittest, it's impossible to guarantee that it will recover at runtime in an appropriate way. Having a compiler between the programmer and the interpreter prevents that class of problems before they happen, which can be at any time between writing the program and in the production environment. A smart programmer can further leverage the type system to cover a wider range of errors than that.
Yep
I'm sitting here actually wondering what this is, it certainly isn't clear from the linked site. Answer the question - what does it do for me and you might see positive responses. 
Wow, I had never thought this through but yeah, that would be the implication of nesting a class inside the function...
From the linked page: &gt; This is a proof of concept desktop interface for the Ipython Notebook. That's very clear if you know what IPython notebooks are
Learn Python 3.4 first if you go the Python route at all. Learn C++ first if you really want to understand software and how it is constructed. One over riding issue I see with Python programmers is that they often don't understand software. This seems to be the result of "learning Python" instead of computer science. When you mentioned that this is your first language a fear developed in my mind that you wanted to learn a bit of programming without grasping the underlying concepts fully. Obviously I could be wrong here but the way you asked the question set off alarms. Grabbing into Python as a first language makes it too easy to ignore the science. 
 &gt;&gt; This is a proof of concept desktop interface for the Ipython Notebook. OK so what does that mean to you that is the phrase "desktop interface". Because honestly it could mean a number of things. &gt;That's very clear if you know what IPython notebooks are Well I have a word for that -baloney-! Between this response and the delivery of the info on GitHub I'm not too sure you will get many interested parties. Bad attitudes and an inability to communicate don't attract a lot of followers. 
I'm not related to this project.
Is there a reason why this is implemented in node / javascript instead of python? Seems silly to have to have another interpreter installed to use it.
Sorry for late response, do you mean allowing interaction with the shell the program is running from while the GUI is running? I don't think you can do that unless you have some curses library.
If you ever get good enough at Python to work at a job, you will know both Python 2 and 3. They are almost identical, but `print` is different, which trips up beginners. Just use whatever version your book uses for now, and learn the other version in an hour or two when you get done with the book.
I dunno... I find this approahc very error prone: sometimes it is not clear which code gets executed first, and therefore you would have to add it to every try-except loop to be on the safe side ... I think it is more obvious and cleaner if you add something like if sys.version_info[0] == 3: xrange = range on top of your prog
何〜**で！？**
with* sorry
This is at the top of the prog, it functions the exact same way except I don't have to import sys when I don't need it otherwise.
So bits and pieces were optimized by rewriting in C, but when it was decided to transliterate the whole thing, Go was chosen. How much more of an effort, or what downsides, would have resulted if the transliteration had been done to C instead of Go?
What are you building? How's it going?
This is exactly what I'm looking for, and perfect timing... However, not being able to use a relative path is a big issue for me. I'm making a distributable app with ipython as the main interface, and people receive it as a zip file, extract, and run. To use this, I'd need to be able to specify the relative location of ipython within the zip file directory. Also, I run a script before launching ipython, so I'd have to be able to do that as well.
It's implemented in Node/Javascript because it leverages node-webkit, which allows you to package a "website" as a native app so that it runs in its own chromeless browser window with filesystem access and several other useful features. Normally, the project would provide native executables for Windows/Linux/Mac which would not require Node.js to be installed, but it looks like the author of this project hasn't gotten around to that yet. I'm not sure if there's anything similar to node-webkit in Python. I've hacked up some chromeless browser windows using PyQt before, but it would take a reasonable amount of effort on top of that to duplicate what node-webkit does. (Disclaimer: Not affiliated with ipython-desktop at all.)
I'd argue that a much simpler model for scoping would be if it were analogous to mro lookup: Check the innermost scope first, then the lexically enclosing one, and so on, until you reach the module scope. And resolve it at runtime, not statically. I don't think it's fair to say the programmer wouldn't know what variable the name x referred to, any more than they wouldn't know what value is printed in x = 1 print(x) x = 2 It also can't be said Python's syntax and scoping semantics are more explicit, since Python does not even have separate variable declarations.
Yes it's supported, and that's the syntax. See https://wiki.python.org/moin/BitwiseOperators
On the first point, I wonder whether they could have sponsored PyPy ARM development instead.
&gt; I'm not sure if there's anything similar to node-webkit in Python. I made something for this purpose, [WebUI](https://github.com/Widdershin/WebUI/). It's a very thin wrapper around PySide, and I built it around Flask. It's not very feature rich or anything, but it does work.
Interesting project, certainly would help anyone that is timid with using the command line. I use a [Fluid](http://fluidapp.com/) SSB to get my iPython Notebook into it's own container and not running in my browser. You can also use Automator on OS X to create an Automator based application that loads the URL in a "Website Popup". Where did the icon come from?
And an excellent one at that! I have a friend who is fresh out of college who is finding PyLadies to be an excellent resource, both professionally and socially.
sort of kinda. twisted has a LOT of code that isn't trivial to reimplement, which would be preferable to hang on to. most likely it'll be glued together and it'll all be happy and amazing until such time as everything from twisted has been converted to asyncio-style. (never gonna happen, have you seen some of twisted's protocol implementations?)
I thought it was funny and humanizing...
I've seen worse (also intentionally goofy): https://github.com/magcius/toenail/blob/master/ailment.py
Hey, this sounds great! Suggestion/Wish: It would be even better if this could get rid of the 2.0 command-mode/edit-mode bullshit (which as far as I understood was only introduced because the different browsers have different keybindings)
Assuming you have IPython installed, you need to configure it with the full path of your IPython executable - I know it's not very user friendly, but this is alpha quality software I'm afraid. If you go to the command line and type "which ipython" it will give you the full path of the ipython executable, you must then set this path in the configuration, not fogetting to include the "notebook" and "--no-browser" options
Very simply because node-webkit provides a very powerful way to wrap a web-app in a desktop interface, giving you access to native menus, command shell, file manipulation, etc. This made it very easy to build a minimum working product to test the idea Also one idea was to monkeypatch the IPython notebook page as it loads in order to pull out its menus and place them in the menu bar. But for now I wanted to prioritize just getting it working
Glad that this fits your needs. I think if you want to make a redistributable app you could probably fork the project and hack in a mechanism to get the path to your specific python distro. I haven't yet grokked how node handles its subshell - using ipython with relative paths works in Dev mode, but not when bundled.
Yeah I looked at similar "make webapps" methods including using Automator (in fact wrote a blog post about it http://mofanim.wordpress.com/2012/01/30/ipython-as-a-mac-app/) but I wanted a couple of things: Being able to launch Ipython from the desktop app itself and being able to configure it to use any existing ipython install (I tend to switch between a couple of venvs for different projects). Also, this was fun procrastination!
Advantages * Less cluttered interface, with potential for integrating ipython menus into native window menus * Launch ipython server without a trip to the command line * easily set up different ipython servers * [edit] custom keyboard shortcuts should be possible Disadvantages * Not much! Since it's still basically a browser, you don't lose anything relative to regular mode except tabbed browsing. However it's a little shaky in its alpha state, the most annoying bug is that under some circumstances (like when you force-close) it can spawn ipython servers and fail to kill them on shutdown, leaving you with a zombie ipython processes.
How do I set this full path in the configuration? How do I get to the config setting?
Well, not really... if you want to edit the contents of a code-cell, you have to change into "edit mode". If you just start typing while in "command mode" (which is the default), your keypresses can have very weird effects: e.g. an 'x' would cut out a cell and a 'd' would delete the cell... so if you don't notice that you're in command mode, and type a sentence that contains two 'x', you will have unrecoverably deleted one of the cells in your notebook.
I was actully looking for something like this, there's also pythonwebkit - http://www.gnu.org/software/pythonwebkit/ But node-webkit is simply better supported at this point, and like tomku said once it's bundled into a desktop app it doesn't really matter whether there's node in there or not.
web2py is fantastic! it's a hidden gem that deserves to be more popular. Thank you sir, for this invaluable piece of software.
Memory management in C is a huge undertaking compared to modern languages like Go. So a lot bigger effort clearly.
Now is a good time to jump on 3.4, the differences in syntax and semantics are not significant, you might not even notice most of them. More importantly you will still be able to understand, read, and probably write Python 2.7+ if it came down to it. 
P.s. Any and all contributions very welcome. I'm afraid the JS is a bit of a mess since I really threw this together in day or so, planning to neaten things up. But if you see something you can improve don't hesitate to do so, I'm very open to contributions!
Click the "configure" button on the start page, or go to Server -&gt; Configure. If you mean that the start page doesn't even show up (the one that says "Welcome to ipython desktop" like the screenshots) then congratulations, you've found a bug! You can try going to View -&gt; refresh to see if that helps. If that doesn't then I can't do much from where I'm sitting - it works in OSX 10.9 and I have no way of testing on other versions. If you are feeling enthusiastic you can get the source and follow the build instructions and run it in dev mode (I recommend enabling the toolbar in package.json so you can see the debug console). Then you can try and figure out your problem. If you do this, create an issue on github to track your progress and I will try to help however I can. 
Udacity has a course on it I think. They're good at creating real world facsimile projects. Oh and it uses Python to teach it too!
I'm starting to wonder if all these recent pushes for Go are part of some astroturf campaign that people say happens on reddit all the time. This is at least the 3rd Go article in the last few days posted to /r/Python 
What isn't working about it? What exception/error if any are you getting? Also, try indenting your code with 4 spaces to get it to show up correctly.
Depends in what you consider "this is the wrong type" type of error. In a basic type system I would agree with you. But in a proper type system that enables you to distinguish the use of int everywhere as being the same thing. Or to distinguish a string of a given type to other strings of other types, the cases of errors of "this is the wrong type" is much much bigger. For example, the sql injection issue would be a type error.
It's the start of a home automation system and so far it's going great. Right now it's three Raspberry Pi computers, two with passive infrared sensors and pi cameras. When I'm not at home the system acts as a security system - if the IR sensor is tripped it takes a photo and uploads it to the cloud. Right now the system isn't perfect but in the coming months I'll be adding a backup 3G gateway in case the cable is out. Is that necessary? No, not at all.. but it's fun to build! Next I'll integrate Z Wave into the mix. I want the IR sensors, when tripped, and at night, to turn the lights on in a room when I walk in, or when I come home from the grocery store at night the lights will come on as I enter the house with arms full of grocery bags (and to that point what insane person put the light switches in my house where they are? I mean.. really?) After that.. I don't know, I guess I could lock and unlock the doors but I'm not sure I trust Z Wave that much. I want to hack it first to see how secure it is before I trust it to keep my house locked. But that said I can teach someone how to use a lock pick set in about thirty minutes so it's not like any standard lock is all that secure. With all these different processes going on I need to SSH back from the central computer that runs the show and the secondary Raspberry Pies and I wanted to SSH processes to run concurrently. I finally settled on Python 2.7 and the futures module. Had I not been so far down the 2.x path I would have jumped to 3.x and used concurrency (and futures) which is all built-in with 3.x. After I get all THAT working (along with Z Wave thermostats, environmental sensing, etc) I'll get a 3D printer and build a robot that can send me messages and pictures while I'm at work or that I can drive around using my phone when I get bored. I'll have the little bot packed full of temp, humidity, light and who knows what other kinds of sensors. 
Can you go into more detail? I don't understand what you mean by that. 
I feel like Python has now become that good old comforting Sunday roast. You know it won't disappoint, it'll go with whatever mood you're having that day. But, as time passes by, you start feeling like you could try something else. Edgier, foxier, spicier. Just because you want to taste something different, or because you've grown slightly bored of the roast on a Sunday. So you give Go, Rust, erlang, Haskell... a try. It's like exotic food to you. Although it's been enjoyed for years in some other parts of the World, it's new to you and, damn, it feels good. You almost feel like you're 15 again. Discovering new ways of thinking and coding. You're unstoppable. Coding at night and reading complex articles about stuffing 10 million messages/second on a single node. You hadn ot felt that with your roast for years. Being part of the happening. The here and now. You're fashionable and you're enjoying every single minute of it. But, somewhere along the road, you may come back to that Sunday roast. Purely because it's been so long and, you know what, it always tasted perfect whatever the weather. Who cares which language you're using? Just enjoy your life with it. Push yourself and learn new things if you want. Simply don't try to justify your choices. They're yours. PS: I'm not aiming the author of this article. Just a little board of those "why I dumped X for Y."
Basically, you can call everything of type string, but in reality they have different types. Xml, uris, sql queries, person name, address, etc, you can say that their type is a string. In those cases if you use the wrong string in the wrong place you get a bug, but not a "wrong type" of bug, since it is a string. But you can instead have a new type (for example, xmlString) that is kind of a string, but in the "type world" it's a different type. So if you use a string in a place that expects a xmlString it gives a type error. Now, if the input is a string, the programmer has to make a function that converts a string to a xmlString, and in there he can put validations and so on, to make sure that the result is a proper xmlString. You can do this in most languages, but if the type system doesn't provide tools to make a new type based on a already existing type, it can be very painful to do so. So in most languages you just use string everywhere. When I say strings, I'm referring to any type. For example, using int to represent day of the week, etc... A practical example, is the [NASA Climate Orbiter](http://mars.jpl.nasa.gov/msp98/news/mco991110.html). In a language like F# that has unit measurements out of the box, this would be a type error. For the string cases, [this is a long but good read](http://blog.moertel.com/posts/2006-10-18-a-type-based-solution-to-the-strings-problem.html) that focus in this issue.
&gt;The latest hip things seems to be writing web crawlers even though several exist already....furthermore they seem very assertive that the legal aspects are the sole responsibility of the person running the code instead of the developer who provided it. Even worse is many are poorly written, have zero documentation, no setup.py file, follow bad practices, and are prone to reinventing the wheel (again).... Instead of attacking his project idea why don't you give him constructive feedback. 
 def equalAction(self): tmp = self.input.get() if self.total &lt;= 1000: # This will work with 1000, change it to &lt;= 999 or &lt; 1000 self.display(self.total) else: self.display("Number too big") try: result = tmp + "=" + str(eval(tmp)) self.log.insert(1.0, result + "\n") print(result) except Exception: self.log.insert(1.0, "Wrong expression\n") Whats the problem, and what should it be doing? 
It might matter - but go with 3.4+ anyway. If you want to be hired to work on legacy systems (which applies to most current systems) then you'll want 2.7 experience but *it is easy to do 2.7* if you already know 3.4+. On the plus side there are a few strong benefits to going to 3.4 (that's where the energy is going, unicode is *just better*, the language is a bit cleaner) and if you're the new person on the team who knows 3.4 above 2.x then you might be rather useful for future-proofing and migration. Consider learning 2.7 only if you're going into scientific/engineering (math-related) work as 2.7 will be the workhorse for a while. We all trust 2.7 code to work as expected, moving to 3.x+ introduces uncertainties for the math (e.g. can we be sure bindings to rarely used fortran/C libs will work extactly as before? do the bindings use int div in a way that'll break with float div?) which'll slow the migration. In the end this domain will migrate too, just slower.
I have half dumped C++ for Python, and entirely dumped PHP for Python. My reasons are quite simple. I am at least 4-5 times more productive in Python than C++ (20+ years of C++) and some good multiple more productive than in PHP. My Python code is inherently cleaner than in both PHP and C++. And as for speed, yes Python is technically slower than C++ but the difference is between a blink of an eye and a blink of an eye. The only way I can usually tell the difference with when I run some kind of computer measuring test. Plus CPU/GPU/Memory/SSDs are all getting faster and faster. So to me using C++ is like some people arguing that C++ isn't fast enough so they over-optimize in assembler. But worst case scenario I can put some demanding code off into C++. Lastly there is a library for just about damn near everything hiding inside pip. Plus those libraries don't seem to fight with each other. I don't know how many C/C++ libraries that I have fought with over the years. You add the library and suddenly there are 800 compiler errors and 1,200 new warnings. I see Python only getting better and with things like Kivy expanding what I do with it. 
Super low traffic toy site, yeah. But it's nice that I could easily build an admin server for something like that. I would never have bothered if it was more complicated. 
Because it's much easier, node-webkit is built for wrapping webapps into desktop apps and gives you tight integration between the native platform and the web javascript context, allows you to work with pages in a reduced security context and more.
I like Python for all the mind-numbingly tedious tasks I have to do at work, e.g. parsing output into excel, creating lots of similar config scripts in whatever weird format an application wants, etc. I use the OP's trick to generate a list of commands to paste every day. Remember [this graph](http://www.howtogeek.com/geekers/up/sshot4f07447e46648.jpg)? A lot of these things are not quite painful enough to whip up something in C++, but the barrier using Python is much lower, and it's done sooner. Recently my advisor gave me a project that involved writing some code from scratch. I knew it would have to be in C eventually, but I built prototype of the algorithm in Python to check all the logic, and after that I was relatively easy to port to C.
I think it's a sign that your language has made it. Now you're the big, established programming language that people change to hip, new languages from.
wow thanks for this link!
I disagree on the speed part, while it's "good enough" most of the time, that's only because modern computers have a lot of spare cycles to waste and because there are many libraries written in C available from Python. Whenever performance matters even a little bit it becomes pretty clear that Python just isn't any good at it, being 20-100 times slower isn't all that unusual for it. The thing that makes this especially frustrating is that Javascript clearly shows that you can make a highly dynamic language really fast, the default Python interpreter just never did get as much attention in terms of optimization as Javascript. PyPy is on it's way to make this less of an issue, but it will probably take a while before slow Python will be a thing of the past. 
Extra bonus, it's versionable.
&gt; but the difference is between a blink of an eye and a blink of an eye. Well put, but occasionally you hit a compute bound task, and unless you can vectorize it (eg numpy) you're out of luck. It's a shame the Python language isn't more efficient, like JavaScript or Scheme.
Exactly. Python is already a major language in many enterprise systems. Soon, you can look forward to many jobs in accounting system programming, personnel and hr, and lots of database programming.
One of the most frustrating things for me, as a python novice, is the 2.x / 3.x split. Libraries that only support 2.x, how-to articles written in 2014 that require 2.x. It's maddening.
PyPy is competitive with JS and scheme. JS and racket aren't inherently naturally faster than python; its mostly their common implementations these days have very good JIT compilers. Python could be that good except people use a lot of stuff that relies on the C API which won't be helped a lot by a JIT.
I Googled and found this post which suggests to use `hp2xx` to convert HP-GL: https://mail.python.org/pipermail/image-sig/2010-August/006478.html
Security risk blocked for your protection Reason: This Websense category is filtered: Dynamic DNS. Sites in this category may pose a security threat to network resources or private information, and are blocked by your organization. URL: http://mroy31.dyndns.org/~roy/projects/deejayd
Seems like you're sitting behind an overly broad web filter. Reminds me of my middle school where they blocked hotmail.com, for the reason that the URL contained the word "hot", which triggered the porn filtering rule (lol).
yup .. same here. Many people say to me "do you really need python 3". Ruby community adapted to change quickly
Why speak in future tense? It's already possible to use PyPy as a drop in replacement in many cases. Your mileage may vary, of course, but these days picking PyPy is much more pleasant experience than, say, two years ago.
Well If you think python like **not** free form syntax for browser, It would have increased file size (whitespaces). This is just another point I wanted to make ... I don't know if it's valid or not. What do you think?? Edit - I think you are talking about compiling it to js
True. With that said, I've run into more and more new libs that only support 3.x so things are moving, albeit slowly. It's mostly for well-known large packages that this may be annoying. Some of them are still working things out when it comes to their code base and 3.x.
why do you compare a scripting language to C/C++ ... I think it's irrelevant 
I’m just learning it for fun, with the knowledge that it may be a while before I apply it to something ‘real’ (I’m using for real, but *personal* stuff). So I’m just going with 3.
me too ... I want to create a *personal* Django app in vacations
I had to do Python vs Ruby dance for a while. But good news is that every new book covers python 3 now like Learning Python, Programming python, Pocket reference and cookbook. Also they added pip to Python 3.4 
I make an application in one, or I make an equally functional application in the other. But with one I was done 5 times faster. From a technical standpoint there are all kinds of problems with the Python. My application (bundled into an exe or app file) is around 67 megs. I can craft an exe that might be a few hundred k (sort of including those bundled dlls) so a person can go whoa that is a massive difference. Yet the difference for downloading and storage on a modern device is basically zero and growing smaller. The same with running an application. I might notice small delays in the Python application but seeing I had it in people's hands 6 months faster then again who cares. The key is that it is all about the end product. If the product works well enough then now is better than later; plus Moore's law is making my Python code faster all the time without me having to do anything about it. But yes there are things where Python does cross that line of being too slow. At which time I break out my C/C++. For instance one project that I am working on uses OpenCL to do the critically fast bits while everything around it is Python. Also many of the Python libraries are written in C/C++ so when you encrypt a file it will run basically as fast as C++ which would simply be using the same library anyway. I am not saying that Python is a better language because if you checklist the two then C++ will crush Python. What I am saying is that Python is vastly better for the applications that I do and am planning on doing; and even better again when paired up with the occasional C++. But the applications that I do are pretty broad. Server code that is pounded for information by either web pages, desktop apps, or Mobile apps. Then I also do the mobile apps and the desktop apps. So that is servers applications, mobile apps, corporate enterprise desktop applications and shrink wrap applications. That is a pretty broad set of demands that Python can meet quite nicely. My hobby is robotics so the embedded parts are absolutely C++ but they are told what to do by mostly Python.
Yawn. Anyone else getting tired of hearing why we should learn this language? (especially, if you are already subscribing this subreddit...) 
You don't need `_` in `pip_install`.
Your error message indicates you are typing pip "underscore" install. Is this the case, or according to your prior lines are you typing pip "white space" install? I think it should be: sudo pip install -U numpy But I doubt it's as easy an error as that. I hope someone more knowledgable than me can help you out. Also nltk takes up a lot of space, especially when downloading the various corpus. Just FYI. Best of luck!
try: sudo apt-get install python-pip If you're on distro that uses apt.
When you compare two lists, they compare element-wise, i.e. the first element of list A is compared to the first element of list B, then the second element of list A is compared to the second element of list B, and so on until either a comparison fails or the end of both lists is reached. So just compare the lists: &gt;&gt;&gt; foo = ['one', 'two', 'three'] &gt;&gt;&gt; bar = ['one', 'two', 'three'] &gt;&gt;&gt; foo == bar True 
 for str1, str2 in zip(string_list1,string_list2): if str1==str2: print 'same' something like this one?
It depends on what, specifically, you want to do. Since your question is vague, I'll answer some more specific questions: **How do I check for list equality?** a == b Note, this *does* check by position. A list is defined by items in an order. **How do I check if all the elements of one list are within another?** set(a) &lt;= set(b) **How do I find where two lists first differ?** Suppose you have lists a and b. next(ifilter(lambda tup: tup[0]!=tup[1], izip(a,b)), -1) This will return the first index of where the two lists differ or -1 if they don't.
No idea really. Try suggestions on how to fix this from here: http://askubuntu.com/questions/30072/how-do-i-fix-a-problem-with-mergelist-or-status-file-could-not-be-parsed-err
I'm a big board
Okay to be more specific, say I have two lists of 20 answers. "A" "B" "C" or "D" I need to find a way to count up how many of the list b's items are equal to list a. Is that better? Haha 
ah ah yeah... sorry for the mistake.
mxDateTime is a well known alternative
 sum([1 for x in zip(a,b) if x[0]==x[1]]) I think this works. a,b are your lists, they have to be equal length
 &gt;&gt;&gt; import random &gt;&gt;&gt; choices = "ABCD" &gt;&gt;&gt; l1 = list(random.choice(choices) for _ in range(20)) &gt;&gt;&gt; l2 = list(random.choice(choices) for _ in range(20)) &gt;&gt;&gt; l1 ['B', 'A', 'D', 'A', 'C', 'B', 'B', 'C', 'A', 'B', 'C', 'D', 'B', 'A', 'B', 'C', 'C', 'D', 'B', 'B'] &gt;&gt;&gt; l2 ['B', 'C', 'A', 'C', 'C', 'B', 'B', 'D', 'A', 'D', 'A', 'B', 'C', 'B', 'D', 'D', 'D', 'A', 'C', 'B'] &gt;&gt;&gt; list(w1 == w2 for w1, w2 in zip(l1, l2)) [True, False, False, False, True, True, True, False, True, False, False, False, False, False, False, False, False, False, False, True] &gt;&gt;&gt; sum(w1 == w2 for w1, w2 in zip(l1, l2)) 6 
&gt; Can you imagine PyPy with some large company throwing money at it? I can imagine code comments. PyPy source is pretty rough reading.
since: &gt;&gt;&gt; ("A" == "A") == 1 True &gt;&gt;&gt; ("A" == "B") == 0 True sum(xa == xb for xa, xb in zip(a, b)) just works (see below) 
Right, forgot about that :)
I find the [Delorean](http://delorean.readthedocs.org/en/latest/index.html) really nicely packed if you need to manipulate date/times.
i could more reasonably imagine some large company throwing money at a project very similar but slightly distinct from PyPy... Google, Dropbox, looking at you. 
&gt; This is a red herring. The merits of static or dynamic typing are unrelated to ecosystem maturity. True, but if there are few-to-no mature static python-alternatives, that implies both that it's not an avenue worth looking at for current production, and more importantly that it may not be a niche that people need. This isn't a question about whether languages need to be statically typed, but rather which languages are the most useful in the situation you're looking at. As you say, Python is still a part of your go-to kit, despite all of it's dynamic horrors. On the other hand, most industrial solutions tend to pick Java, which is statically typed - although it must be noted that it's not usually chosen for the static typing.
Link to the book?
The &lt; and &gt; aren't actually a part of the command. Remove them and you should be fine. 
I'm running OS X. :(
The author specifically states that it's not to put down other languages, but to preside the good points on the topic of Python. 
&gt; especially, if you are already subscribing this subreddit That part is a bit odd.
All the "What can I do with Python?" stuff can also be done easily with Bash. Just saying.
This seems cool, but from reading the readme, it seems that all automation is left to the user. Has anyone written a service to connect Github's web hooks and imhotep? That seems like a fun project.
PyPy is awesome, but not comparable. There are about 8 steps to method dispatch in Python, including function calls, and PyPy has to simulate that faithfully. JIT helps, but it has to do a lot of work to prove away those various steps, and even then, sometimes it just can't. To contrast, in Scheme, a call has to be a procedure object. It can't be an object with a call method or anything else. And in practice, the language drives you to using procedure calls as the common abstraction. PyPy does great, but it's primary constraint on performance is how many helpful language features it can prove you aren't using. A language without such features (or moved into a separate feature) can be compiled better with the same compiler techniques.
Maybe this? [Matplotlib Plotting Cookbook](http://www.packtpub.com/matplotlib-plotting-cookbook/book)
How *dare* people be creative!
&gt; Also they added pip to Python 3.4 About time. And thank God.
It's ridiculous that you would generalize what I said as an affront to creativity.
I know i was poking fun at both companies for throwing mad resources at new python interpreters rather than behind pypy. Not saying there aren't good ideas behind unladen swallow and whatever dropbox is calling their project, it's just a bit frustrating to have heterogeneous efforts
yep, there's not much content in this subreddit for python users who already know what they are doing which is sad. great for the newbs though I guess.
Does 3 do strings yet?
No because I may not know all the advantages that python offers
subredditing this subscribe? better? :)
I love when things happen like what is happening to SSL. Other groups of people are going in and tearing it apart. I don't think that any of the priesthood who ran the project have anything to do with the new stuff being generated. But I suspect that those same old programmers were going to conferences and saying, "Look at me I am the god of SSL" while at the same time going, "Poor pitiful me, send us your commercial dollars if you use our code, please." I get a similar feeling from the Python priesthood. If you look at the history of most religions there comes a point where they argue over something silly and suddenly there are two churches. Arguments over the date of Easter was basically the point where the eastern orthodox church was born. I suspect that the 2.seven 3.x argument is where a new Python will be born and it will be called 2.eight and it won't be run by the original Python crew. I see a few features with the new Python. Easily compilation into nicely packaged executables. Speed. Backward compatibility while doing things like unicode in a new and interesting way. And some interesting way to interact with things like Numpy that would make it dead easy to "port" libraries to this new version. Something along the lines of happily running things meant for 2.seven if that is all that is available or using those 2.eight features that are developed. Even if this happens there is no guarantee of success. But the biggest measure of success would be if one of the major libraries such as Numpy released a 2.eight compatible version and then said that their present 3.x was the last of the 3.x versions they were going to release. BTW my suggestions get the Python 3.x faithful's blood boiling. They are so revolted by 2.eight that I suspect they search for articles supporting it and downvote them en-mass. 
Run with it. Even if it is a flop you will learn a ton. Also what graphing library do you use?
Python for me is like the world's greatest swiss army knife. I don't use it for everything but when I need a quick and easy tool it's perfect. In my latest C++ project I used Python to write both a 30 line spritesheet cropping tool (so that I could repackage it with TexturePacker to get a texture atlas) and also wrote a 100 line Make program for my project. Python is so ridiculously quick and easy to use. If Python had the performance of C++ and was statically compiled, I'd probably abandon C++ by now.
&gt; I have a webcam that I have This is far preferable than having a webcam that you don't have. :) You can use a python ffmpeg library to write the subtitles.
Develop a web app has a wider set of required knowledge than just python. You need html, css and javascript. So, if you want to learn python, that won't be the best way. For example, you can't apply what you learned about python graphics in html. You'd probably need to use SVG or canvas, so you need to add a new language to the mix. But, after saying all that, if you just want to learn to program, no matter which language, then go for it! Learn the little bits you need to solve that particular problem. Soon, you'll want to add a feature, and you'll have to learn a little more. And then one day you'll realize that you've master an impressive stack of technology. Good luck.
Sometimes both languages do the job fairly well, which may be this person's conflict.
I've heard silly claims about the text-bytes divide, but this is just funny.
I still use C++ for my game project, but otherwise I use Python for mostly everything else. A language is just a tool, and there is a tool best fit for each situation. But Python keeps being fit for MANY situations... I agree that I find myself getting thing done faster in python, especially since I know it better now!
True; I over-simplified a bit as they do have different features. PyPy has some more work to do to handle some of python's powerful features (e.g., check for integer overflow and switching to arbitrary precision). My point isn't that pypy is just as fast or faster than V8, but that its competitive. E.g., python or ruby may be ~10-100 times slower than a fast JIT language, while say pypy may be just as fast or even if its slower maybe it reaches ~1.5 times the speed of V8. (Granted in reality when you do use the C API or numpy, CPython may be faster than pypy; but then again with the C API or numpy CPython may be similar speed or faster than V8.) E.g., [this guy did benchmarks of python vs JS (V8)](http://blog.bossylobster.com/2011/08/lesson-v8-can-teach-python-and-other.html) on first 50 project euler problems and JS beat python by a landslide - JS being about 26.6 times faster than CPython on average. Later, he added a pypy column and reran comparisons on the same machine. Pypy often beat node (node won 20, pypy won 29, with one tie), with pypy being about 25.7 times faster than CPython on average. Granted, all benchmarks are flawed. But pypy can often get a lot closer to the speed of other dynamic JIT languages.
I am exploring Kivy(For iOS and Android) which seems to be right on the border of ready. The theory is that it hands off much of the multimedia stuff to things like OpenGL so that Python itself is not having to do the work. Right now I use Cocos2D-x for maintaining my iOS/Android work which is C++. But I suspect that my Kivy experiments are going to end with a released project and all future projects. 
I'm not sure how I feel about this, on one hand it does demonstrate that it isn't hard and confusing. On the other hand, this is just bad organization, and I like that Django does prescribe (but doesn't mandate) just enough organization to make large projects easy to work with. 
was anyone else's mind blown after watching this talk?
True, then it is down to syntax for me. Python looks better to me haha
Amused, I stand corrected. I didn't realize V8 and PyPy came so close. (My own benchmarks are with parser combinators which, admittedly, are an atypical use case. :-)
Just curious, as a Python novice, which libraries aren't supported in Pyyhon 3 that you need?
Web: create a django project and hook the manage.py runserver command with nginx. Graph: "processing" perhaps. You can hook this up with "celery" to create async tasks and notify the user with either emails or hook the graph up with ajax and make the user wait for the results from the server (depending on how complex the graph is). Also on an unrelated note ; wolfram may be a solution as well (i just watched the intro no idea otherwise) 
Thanks I'll try and look it up! 
I think ggplot and google charts blow matplotlib out of the water. Both are open source as well. I cannot use matplotlib for any business presentations. I've seen ggplot make it to high traffic news websites.
Hey, I request all of you guys to please help me improve and add more and more common features to this project. It would a great gift for Python and Flask community since they can simply use it to add their own idea/application logic on top of it. Please help improve the idea and work.
This is interesting. I have previously used and contributed to [cookiecutter-flask](https://github.com/sloria/cookiecutter-flask), which boasts most (if not all) of the features this has, and has the advantage of not having to rename anything. I'm not sure that it's good practice to recommend users `sudo pip install` your requirements. Not sure if it matters that much here, but I usually see people recommending that you *always* use virtualenvs. It seems that you have quite a few instances where PEP8 isn't followed (for naming)? Is there any particular reason for this? If not, I would suggest that you start using a linter. I might give this a go when I next start a moderately sized Flask project, and see how it compares to the cookiecutter approach.
Thanks dude for your suggestions. I guess i have mentioned virtualenv in 2nd point of Steps to Follow section. Is that what you meant? Of-course i didn't explain how to create virtualenv, since its very easy. I have tried following PEP8. Is there anything specific you could point out so that i could fix it? Or may be you could help me out in that. And sure dude, i'll have look into "cookiecutter-flask" to drew inspiration from it.
Considering that Guido Van Rossum works at Dropbox, whatever they are doing can't be that much of an insult to the community.
Also flaskCamel's philosophy is bit different from "cookiecutter-flask". We want it to be feature rich, so that when someone needs to validation an idea or create MVP of his web app, he/she just can download the project and add additional logic of their own and show to the world, while common functionality work as is. I would recommend him not to rename it or even change the DB. He just need to enabled to present his idea/logic in no time.
Woops, you're right in that you tell them to create a virtualenv. Then the `sudo` is unnecessary. I opened a pull request to fix that. For the PEP8 stuff, here are a few examples: views.py resetpassword should be reset_password, same for changepassword and confirmaccount. models.py userdetail should be UserDetail, userdetailAdmin should be UserDetailAdmin, etc. You should be able to pick up all of these in one fell swoop by using a tool like pyflakes or pylint. If I was at home I would do it myself. Few other things I noticed: * Why do you declare Anonymous in views.py? Is it a view? * You misspelled serliaizer_code. * I'm not sure about decorators.py. Right now it only contains one decorator, and it's for async. Is it really appropriate to group code into files based on what language construct they are? It seems a bit like having a classes.py or a functions.py. Hope this is helpful. 
https://caniusepython3.com/
Thanks for pointing out the issue. I'll fix the issues.
Maybe using pygame?
Oh wow, cheers mate :D I'm thinking about playing with OpenCV after reading [this](http://www.pyimagesearch.com/2014/03/10/building-pokedex-python-getting-started-step-1-6/)
This isn't "lightweight", it's a cluttered mess. "lightweight" in this case means "I don't feel like learning best-practices, so let's shit it all into one python module and call it a day".
It's doable but probably not ideal. You're going to have to learn 101 thing about programming that aren't "just programming". Connecting your code to a web server, parsing web requests, the HTML for the page, the quirks of a graphing library, maybe javascript to control the page... All sorts of things that are useful for a programmer to know but if you're still a noob that's figuring out loops &amp; conditionals &amp; classes &amp; functions, it's all stuff that isn't going to help you learn that any faster. You're just trading `input()` and `print()` for large, complex libraries that you have to learn how to interface with, not actually "flexing your programming muscles" more by doing more complex data transformations and data structures. A better thing to do might be to create some sort of console user interface or repeatable script around generating graphs more easily. Some sort of SciPy/iPython deal where you've organized the reusable bits &amp; can simply call up custom graphs against new data with a single command. Getting started programming tends to be unsatisfying. Making interesting programs with pretty input/output isn't hard - it's just a bunch of work. Since learners should be focused on learning, rather than fighting with busy-work, interfaces are often left out.
Sadly, this encompasses most of Reddit. Unless the subject lends itself to images or video that are easily appreciated by the unwashed masses, things that are fast &amp; easy to read and give everyone a chance to contribute to the discussion tend to dominate. ...that noobs don't know to read sidebars is only half the issue.
&gt;As you can see, by decomposing the basics of creating a Django application into smaller parts, we can create an easier way to onboard new users. We need to re-learn how to teach Django by building Django applications without the ORM and without the Django admin I don't think it's meant to be taken as a realistic method of development, just a simpler way of introducing some of the concepts without introducing too much complexity. Kinda like how some people say Flask is a good way of dipping your toes into the water 
Yep that one :)
If this for your own benefit, then yes you'll get there. If you have a deadline for this anytime soon it's a little risky.
While I do understand what the author's intentions are, I believe you are right when you say Flask should ultimately be geared towards the very new python web programmer. I still view myself learning Django first as a mistake rather than something more straight forward such as Flask. Django just has too much magic and layers to be taught this way... The person learning will develop some habits that might make it harder for them in the future.
NEVER SUDO PIP INSTALL use virtual envs.
Is it meant to catch numbers that exceed 999 ever, or just the answer being more than 999. Should 999*2-999 return an error, or not?
Both look similar for me. Requests is more popular, but unirest is only 3KB package vs requests 412KB
Requests does a lot of magic behind the curtains as well. Like gzip/deflate decoding, giving multiple ways to access the response data, cookie handling, throwing numerous specific exceptions etc. Very much an convience library, automating a lot of things in general. Unirest on the other hand is very lightweight and handles the simpler stuff with much less overhead.
That's because unirest is (mostly) just a wrapper for urllib2. I use it personally though and love it.
+1 requests
If the title had said, "An Introduction to Twisted" I could have saved a click and a few minutes! (We switched to gevent a while back and not regretting it.)
The size comparison is rather misleading. Requests comes bundled with 302KB of root certificates so that TLS can be verified by default even on systems without a pre-existing root CA store. Unirest just does the default, which means no verification at all and hence insecure connections. Requests has a considerable amount of encoding detection logic so that the response body can be properly decoded as a Unicode string even when the HTTP headers don't specify the encoding. Unirest just returns raw byte strings and lets the user fend for themselves. Requests supports Python 2.x and 3.x. Unirest only supports 2.x. Requests has keep-alive support so that connections will be reused. Unirest doesn't seem to have anything like this. Requests makes it easy to use cookies. I don't see anything in the Unirest documentation about cookies, which probably means you're on your own and have to do everything manually. ...and so on. If unirest does what you need, then by all means use it. But it's just a couple hundred lines of wrapper around the standard library -- it's really not buying you much.
Please stop that. That's neither useful for professionals, nor for newbies.
&gt;?utm_content=buffer20d3c&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer Come on, man!
&gt;&amp;utm_source=twitter.com&amp;utm_campaign=buffer&amp;utm_content=buffer8c41e&amp;utm_medium=social&amp;app=desktop Bro, really?
&gt;?utm_content=buffera7723&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer Oh, for fuck's sake. What is up with this subreddit? Why does everyone here just link the URL as is? Please clean it up before linking! I hate seeing that shit in my address bar.
And if you're just starting out you don't have the background to appreciate very much of that so it's particularly academic. People agonise over what should be their first language.
Will do, however, why does it matter so much...?
I just like clean URLs. It's a massive pet peeve of mine. I really hate dirty URLs.
It doesn't matter though as far as learning goes. The differences are negligible but, unfortunately, not backwards compatible. Use whatever the tutorial/how-to is using, and if you can use python 3 for your own (new) projects then do so.
Can't say anything against that :). What's your method of choice to clean them up?
What sort of vehicle data are you working with?
This looks better for complex interfaces, but I'd prefer [docopt](http://docopt.org/) for 90% of my CLIs.
That\u0027s the joke
+1 docopt. I don't see much difference in functionality compared to docopt, besides [user imput prompts](http://click.pocoo.org/prompts/). 
You can try using [difflib](https://docs.python.org/2.7/library/difflib.html) which is a standard module. Some examples on Python module of theweek: http://pymotw.com/2/difflib 
&gt; I don't see much difference in functionality compared to docopt [commands](http://click.pocoo.org/commands/), [input](http://click.pocoo.org/options/#prompting) and [confirmation](http://click.pocoo.org/prompts/#confirmation-prompts) prompts, [environment variables](http://click.pocoo.org/options/#values-from-environment-variables), type conversions/validation (including [files](http://click.pocoo.org/arguments/#file-arguments)), [flags support](http://click.pocoo.org/options/#boolean-flags). Docopt is nice for trivial stuff, but I find that for non-trivial CLIs the validation/conversion/selection code ends up being bigger than using a code-based CLI API in the first place (if the non-trivial CLI is even possible using docopt)
This portion is only concerned with vehicle position in each frame.
I found argparse to be easier to work with than docopt in a number of cases. And it's far easier to include input validation with than adding something separate like schema to docopt. But where argparse/optparse/docopt really don't help is when you want to allow interactive prompting to aid the user. I built one interface that needed the combination of args, options and prompts - because the utility wouldn't be used often, so prompting for missing required options really helped the user out. It allowed the developer to perform CRUD operations on any table in a database, so all the columns were potential options. This looks great for that. Unfortunately, it doesn't include as much validation as I'd like to see either. Just simple enumerated lists like choices=['red','blue','green'] would be helpful. At least it allows the developer to define types, whether or not it's required, and it looks like a validation function for the arg/option.
Their mailing list is a good place to ask questions. Anyway, why can't you update using pip? Or did you use a system package manager? What OS are you on?
automatic grading, nice!
This is pointless. It doesn't help to learn Django idioms and cramming everything into a single file doesn't achieve anything useful.
Unirest doesn't appear to do /any/ of the necessary TLS validation, therefore I would strongly avoid it: https://www.youtube.com/watch?v=SBQB_yS2K4M
Could you give a few more details? E.g. how is the camera connected? What do you mean with "display to the screen", as in embed in the image? As mentioned, ffmpeg is a way, or you could use one of the computer vision libraries like simplecv or opencv that can read, manipulate and display video.
also change it in your setup.py if you had it set to an earlier version. that's python dependency mgmt 101
A minimal Django project isn't that complicated, really. The files are all descriptively named and can be researched individually (settings.py is for settings, urls.py is for URL patterns, etc). We're roughly on par with Rails in this regard, where I don't think this is considered an issue. This, to me, looks like a solution in search of a problem. It's hard to compare with Flask, since it doesn't come with much of anything but views and URL routing.
Is this a replacement for flask_script? Its more general, not flask specific, I'll need to read on.
Because if you want to be respected and to have repeat business from worth while clients and essentially free advertising, you don't play on their ignorance you help them.
I am not able to understand what this lib does ? Anybody enlighten me please ?
I'm not sure what's stumping you, it's a library for parsing, validating and using command-line arguments (and thus for creating command-line interfaces), same as getopt, optparse and argparse. Hence "Command Line Interface Creation Kit" (CLICK)
This is because Requests is an HTTP library, not an HTML library. This is an extremely important distinction to make when designing software. --------------------- However, I put much design consideration was put in for this exact use case — `Response.encoding` is mutable, and can be set to any valid charset by the user. Or, if you'd like requests to simply autodetect the charset for you, you can set `Response.encoding = None`. If the charset you (or the server, as is the case for many asian websites) provide is 100% invalid, the detected encoding (`r.apparent_encoding`) will be used automatically instead. e.g. it "just works" 99.99% of the time, which is an impressive feat, in my opinion — and you can override it when you have edge cases or special requirements :)
Build command line interfaces
Is it me or that name a total cognitive dissonance? I click using my mouse. I don't click to type a command line...
Well honestly I'm not too certain yet. I'd like it to all be run and by Python, probably using ffmpeg like you and some have said . But my idea is that the camera is connected, and as the camera streams in real time, subtitles produced by Python are displayed to the player (again assuming ffmpeg). I think the logic makes sense....
The *default* look of the plots looks open sourcey. But if you work to snazz them up, they can look better. I mean, at some level, all plots are just lines of various thickness and color, geometric shapes and colors, and fonts. A few have some super slick graphics magic like drop shadows, but much of that can be tacked on to MPL! Too. 
What's the use of it when we can already use command line args by default, right?
What's the biggest advantage in your opinion/case ? if you don't mind me asking.
Because it simplifies a bunch of common tasks, and hopefully makes the code both easier to understand and read. 
&gt; Armin Ronacher Decorators. Decorators everywhere.
Awesome framework, thanks!
Depends, how familiar are you with *NIX systems ? How powerful is(/are) the computer(s) hosting the VM ? Pretty much any distro will do, seeing that the size probably won't be a matter (You can spare 16gb (or less) on your external drive, right?). I know some people are going to hate me for this, but if you've got little to no experience with anything but OSx, might as well go for something like [xkU]buntu. Mint, Debian are good solutions, too. Another solution, seeing you're on mac, could be to get an install of brew working inside your userspace. You could install a bunch of softs on your home directory (~), including python3 (which includes venv, pip3, etc), and work from there. I don't know much about the process to get brew working locally, but I'm sure you'll find ways on the internet.
How about [Levinux](http://mikelev.in/ux/) Qemu virtual machine running small linux distro with python? *Levinux (download ~20 MB) is a tiny virtual Linux server that runs from USB or Dropbox with a double-click (no install or admin rights required) on Macs, Windows or Linux PCs—making it the perfect learning environment, and way to run &amp; keep your code safe for life! Think of it as an introduction to old-skool “short stack” development—more relevant now then ever as Linux/Unix gets embedded into everything.*
I've been using Linux systems for years in the context of remote webservers, with SSH and "terminal" but rarely with a GUI. Homebrew requires Xcode command line tools.... Installing that now I may be fine just like that. I'll try Ubuntu, seems popular but also why the hate from the pros?
Dang if this works, it'll be perfect! Thanks.
Docopt is the only cli library that actually ends up being elegant in practice. This one doesn't even look good in the trivial example. Having a (fairly) consistent interface for a variety of languages is nice, too.
Horrendously named and presented... I wish people would just say "I tried to improve ARGV again".
This has happened before where a package that I can find on pypi (https://pypi.python.org/pypi/click/0.1) i can't install via cli using pip. Sorry for the nub question but what am I doing wrong? Or are we waiting for pypi to update?
 Successfully installed csv2xls xlwt Cleaning up... &gt;&gt;&gt; import csv2xls Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; ImportError: No module named csv2xls 
how are you generating the graphs? You can certanly reuse the code, maybe using flask (a python web framework really easy to start with), where the user insert the values, you code a form with flask-wtf to do that, and convert that graph to an image and output that in the web page, you can do that saving it to disk and serving the right url or creating a view that outputs the image as binary data with the right mime type. EDIT: I would like to add that many comments don't really get that a project should be satisfying, even for learning, if this idea that you have excite you, then go do it, you will be more involved and will be easier to solve problems you will get anyway trying to learn how to develop for the web, so yes, that would be a good project.
Raspberry PI would be cool... you can use it for others purposes as well!!
&gt; I am having trouble installing py libraries on my work computer because of root access [...] Ever heard of [virtualenv](http://www.virtualenv.org/en/latest/) or [`pip install --user &lt;package&gt;`](http://pip.readthedocs.org/en/latest/user_guide.html#user-installs)?
Docker only works with 64-bit Linux. Levinux works with many more hosts: most modern versions of Windows and OS X, for example. The real magic is in QEMU, which is the Levinux container. QEMU is the piece which when properly bundled with its dependencies in the same directory and a good launch script doesn't need any install or admin privileges.
At this point it seems the pypi page is just a placeholder, since there is no actual "release" to download yet. If you want to start playing with it, you can pip install from git. http://pip.readthedocs.org/en/latest/reference/pip_install.html#git
Part 2 is here: http://www.brettdangerfield.com/post/full_stack_mooc_app_part_1_continued_saving_to_mongodb/
Quite funny. Before Flask the main feedback I got was that I went over board with mixin classes.
&gt; /home/ben/.local/bin/pip install -U numpy Tried this ^ and got the following, any ideas: ben@benlinux ~ $ /home/ben/.local/bin/pip install -U numpy Downloading/unpacking numpy from https://pypi.python.org/packages/source/n/numpy/numpy-1.8.1.tar.gz#md5=be95babe263bfa3428363d6db5b64678 Downloading numpy-1.8.1.tar.gz (3.8MB): 3.8MB downloaded Running setup.py (path:/tmp/pip_build_ben/numpy/setup.py) egg_info for package numpy Running from numpy source directory. warning: no files found matching 'tools/py3tool.py' warning: no files found matching '*' under directory 'doc/f2py' warning: no previously-included files matching '*.pyc' found anywhere in distribution warning: no previously-included files matching '*.pyo' found anywhere in distribution warning: no previously-included files matching '*.pyd' found anywhere in distribution Installing collected packages: numpy Found existing installation: numpy 1.7.1 Uninstalling numpy: Cleaning up... Exception: Traceback (most recent call last): File "/home/ben/.local/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/basecommand.py", line 122, in main status = self.run(options, args) File "/home/ben/.local/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/commands/install.py", line 283, in run requirement_set.install(install_options, global_options, root=options.root_path) File "/home/ben/.local/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/req.py", line 1431, in install requirement.uninstall(auto_confirm=True) File "/home/ben/.local/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/req.py", line 598, in uninstall paths_to_remove.remove(auto_confirm) File "/home/ben/.local/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/req.py", line 1836, in remove renames(path, new_path) File "/home/ben/.local/lib/python2.7/site-packages/pip-1.5.4-py2.7.egg/pip/util.py", line 295, in renames shutil.move(old, new) File "/usr/lib/python2.7/shutil.py", line 302, in move os.unlink(src) OSError: [Errno 13] Permission denied: '/usr/share/pyshared/numpy-1.7.1.egg-info' 
Are decorators just functions that return functions?
That's part of it. The other part is that decorators take a function as an argument and return a function. They effectively replace the function passed in as an argument. The @ is just shorthand syntactic sugar for something like function1 = decorator(function1) Decorator functions also can take arguments themselves, that aren't functions. So you get a bit tricky. @decorator('something') is syntactic sugar for: function1 = decorator('something')(function1) Inside the functions designated as decorators you're using closures to create a function and return it. Or, like Armin does in Flask with the route decorator, you can simply execute some code and then return the same function you passed in. Hopefully that helps a little and doesn't worsen the confusion.
If the camera is a simple USB webcam, this can be done as a prototyope in just a few lines using opencv. import cv2 camera = cv2.VideoCapture(0) while cv2.waitKey(30) &lt; 0: rv, frame = camera.read() if rv: cv2.putText(frame, 'Hello World!', (50, 50), cv2.FONT_ITALIC, 0.8, 255) cv2.imshow('Video', frame)
Hmm... isn't Python 3...
Is it possible to access the VMs file system from the host? I'm using a Mac, can I use the finder to drag files in or out of the VM with afp or something like that somehow?
I wonder how many people have even worked on a project that large. It boggles my mind.
Docopt is elegant and simple, but unfortunately it usually only works for fairly simple use cases. It is a fantastic library but it can't be the end-all-be-all for CLI handling.
I've actually started following that style in my other projects after using Flask for a while. I think decorators are a really good way to pepper declarative programming on top of your imperative(-ish) functions.
I'm gonna test it out tomorrow. I'm interested to see how our test lab likes it, we have a hodge podge of...strange systems in there.
My code base at work is over a million lines, but it's in C#. Don't think I've gotten much over 10-20,000 lines in a Python project. Think how much you could accomplish with a million lines of Python!
Why python? It sounds like OBS would do this better than a home-rolled solution.
I think the key goal should be to decouple, isolate into components, split into tiers etc etc - so that work can be distributed in the team. Cause there will be lots of work for such a large codebase.
The main difference between Click and (as far as I know) any other system is that it has very strong support for composability. See this as example: http://click.pocoo.org/complex/
I thought that, too. I have a ~20k loc project that does several hundred different things… I can't even imagine if it were *50 times* larger than this.
Python is the culmination of over 20 years of work by countless people working constantly. So yeah, it boggles the mind a bit. Particularly when you include all the standard lib modules. And look at how much it has accomplished across the globe with its less than half of 1M lines of code. Now to think of a project with twice that much code... it would have to be incredible. Something like Linux, Firefox, Chrome, MySQL, Windows, Photoshop, etc. Huge well-known software. I can't imagine trying to grasp the huge breadth of code in one of those projects.
thank you for sharing this, i guess project is misleading especially when you keep in mind 1). 
Current project is ~700K loc. Last project/product was well over 1Million...granted it was a 10 year old product that was 100% python.
i have definitely seen 2 comments in /r/python in the last 10 days or so. one in particular was saying that its a "multi million loc" and tests took 2 hours or something. cant remember exactly what post was in. Just curious how such "projects" or products as mentioned by ionelmc are structured
its not flask specific.
I work on a project w/ just under 1 million LOC of python. (plus a couple million lines of actionscript, javascript, html &amp; css) 1) a lot of it lives in a single repository, but we've been slowly splitting that up into independent modules in their own repos. 2) It's difficult to even attempt a guess. but its probably less than 50% documented functions. but most that would be considered "public" are documented. 3) All changes are code reviewed, and almost all new code requires a full set of unit tests. 4) Whenever possible. Good tests make it fairly painless. 5) I haven't seen any that I'd call massive, but I'm sure there are a few. At this scale, teamwork is everything. Nobody knows the entire code base, teams own pieces of it. Good management and good QA people are really what make the whole process 'work'.
cool thank you for this, i think i should add a 6 if you consider the project "maintainable" well thats subjective tho. It sounds like the code quality is good
I'd say the code quality is so-so. At my last employer the code quality was terrible...but it was a 10 year old product that had a lot of inertia and leadership wasn't keen on commiting resources to janitorial work on the code.
thats what i assumed. It may sound crazy to some but personally i find it easier to maintain python than static typed languages (as long as its "clean enough"). Lot of people seem to have the exact opposite opinion. 
It's easy to say things like this if you're not one of the people who have to develop and maintain the code. But the reality is what they did is the opposite of shortsighted - they traded medium-term pain for long-term gain. 
It reminds me of the effort required to get iOS certificates and app signing working in the early days of the iOS development. Now it is basically brain dead easy. I am waiting for a fully working pip/homebrew solution. 
Lots of passion around package management! I changed step 7 to use pip instead of copying modules by hand. In a future upgrade, things will be simple when there's support for installing from requirements.txt. I'm hoping the $150/month BizSpark offer is compelling enough to put up with some friction in the short term.
pep8, also lol PHP
Huh, do people take python code seriously that uses argv in 2014? I mean aside from throw-away scripts.
Mixins are to OOP as Decorators are to procedural programming. You want a class to inherit functionality from another class? Use a mixin. You want a function to inherit functionality from other functions? Use a decorator. As useful as they are, it gets really hard to follow code that use multiple nested decorators. For example, I have seen django code like: @cache_page(300) @vary_on_cookie @csrf_protect @api_call @require_auth def get_foo(): return {"foo":"bar"} Sometimes changing the order of the decorators completely changes the functionality as well.
Watch some talks from previous PyCons on YouTube. http://pyvideo.org/ That'll give you an idea of whether you know enough Python to find the talks interesting and/or useful. You might want to try visiting the websites of old conferences as they often categorise talks into beginner, intermediate, and advanced which might save you a bit of time finding the right level of talk. Conferences usually also have half-day or full-day training courses for an extra fee. People often bring their laptops and work or hack during the talks, which I personally don't enjoy doing, but it is an option. Almost all the talks are free on YouTube, at least for some conferences, not sure about PyCon UK. People go to the conference to socialise, chat about Python and programming and the industry and anything, and recruit/be recruited. If you have a project you will probably discover a few programs or libraries that you didn't know about that could come in handy.
Is it wise to include 'netflix' in the domain name?
How is this better than [argparse](https://docs.python.org/dev/library/argparse.html)? 
can i ask what the project is that it takes so much code?
Are you thinking of [this thread](http://www.reddit.com/r/Python/comments/23p6hq/space_monkey_python_go/cgzcjvv)? Thanks for posting this, by the way. I also found those comments surprising and am interested in the answer.
No clue, I'm sure i'll find out if I get a DMCA. 
&gt; Think how much you could accomplish with a million lines of Python! Probably not much since you will have to add lots of extra lines because of the lack of type checking.
Under Virtual Box I've run a number of Linux distros on Mac OS. The biggest issue I run into. Is the low resolution screen it gives me. To that end I prefer Python running native under Mac OS. In your case you might want to chech Python.org for installing Python as a user, it shouldn't be hard to do. Famous last words. If you are only able to log on as a user I have to wonder if you can even mount an external drive, but ideally you want to install to an external drive. You will likely need to create a script to set up a proper environment. To do this you may need to build from source. 
Or just use `sum(itertools.starmap(operator.eq, zip(a, b)))` ^(why are you looking at me funny when this is a perfectly legitimate way to write code)
I don't mean that people should literally use ARGV, I mean that all of these libraries are just trying to make using command line arguments suck less.
Ah got it. But there are some benefits to a nice CLI: * less RSI * easier automation * easier documentation * easier to build &amp; maintain Not to say that they're always the best, but I think they've got some attractive qualities.
Not if you handle your inputs properly...
I've been using cement and have been happy with it. 
Can you rewrite that code without using decorators? Noob here, I'm still tryign to understand decorators.
I don't mean that command line interfaces are bad; I actually prefer them over GUIs. I just mean that using command line arguments correctly kind of sucks unless you have a library.
I guess you'll find out, but between the domain name and the prominent use of their logo, it's kinda begging for trouble. That stuff aside though, thanks for sharing.
Oh man, this is incredible. I have a central computer that currently handles DVR duties. I want to expand that to file sharing &amp; backup (soft raid, multiple drives). But my end goal is home automation &amp; monitoring. I have about a half dozen webcams, and I'm trying to figure out how to expand to more economically, but also how to get the functionality I want. I've been looking at RPI w/ the camera modules, trying to figure out if it would be worth it to use those (camera module, remove IR filter, get IR cut lens, add M12 lens mount, get IR board... maybe PTZ servos?) What IR sensors are you using? How did you interface with them? Also - how is the RPI + camera for a DIY IP camera? Worth it? I have the same goals for lights-on when I come home (I was thinking zwave or insteon light switches, then tasker + GPS to know when I'm "home"). I guess you figure, what's easier to hack - the zwave security, a bump-key on your door lock, or breaking glass and just walking through a window. Oh man, the robot! You and I are on almost exactly the same wavelength. I've been thinking radio shack RC car + SLA 12v battery + RPI w/ camera and wifi. Then a web UI to drive it around by desktop or mobile app. I think it'd be awesome if you had a forum/thread/blog where you posted what you've done, and when you make updates. My own progress is crazy slow, but each little bit helps.
I thought the word click was used in many way, but then it clicked and I released it really is only used in the mouse context. Also mouse used to be 100% rodent context. Language never stands still.
http://continuum.io/anaconda Just install it in your home directory. You do NOT need root access. If the home directory is not shared on all the machines, rsync it over each time you need to use a different one. If you choose to use a light linux distro in a VM instead, still install Anaconda inside that, it's more portable when you shift from your VM to something else (on Linux, OSX, or that other legacy one people are moving away from in droves now... Gringos? Nodoze? Wingnuts? ... who cares) 
While I'm sure there's a Python wrapper library for `ffmpeg` out there somewhere, you really don't need it: ffmpeg -y -loop 1 -r 10 -i image.jpg -i audio.flac -c:v libx264 -crf 22 -profile:v high -c:a aac -strict experimental -b:a 192k -shortest video.mp4 You can play around with the various parameters if you want -- there are guides on the ffmpeg site and wiki. 
It's nested function calls. cache_page(vary_on_cookie(csrf_protect(api_call(require_auth(get_foo()))))) (not possible to fully re-write it since we don't know the implemented algorithms of the decorators)
What's the problem? 
This is great, massive thanks!
`csv` module read and write chunks or `pandas` read and write chunks. All it work fine with zipped files. Was fine with 2 GB unzipped file for me.
Thank you, that's exactly what I wanted to see. So it's nested calls. I was thinking Java annotations :S
https://www.jeffknupp.com/blog/2013/11/29/improve-your-python-decorators-explained/ It's not just a syntax thing, its the fact the decorators return a function, hence can modify the behaviour of the inner function being decorated. This is why the calling order matters when you're using multiple decorators such as the given example by /u/ggtsu_00 
README should contain info why it's better than other static site generators.
I know I am late to the party but... Well if you want UI, you can try [Elementary OS](http://elementaryos.org/) comes with virtualenv preinstalled (I think) and has much cleaner interface. ~900MB.
Maybe csvkit. See [csvkit](http://csvkit.readthedocs.org/en/0.7.2/) Designed for filtering csv data. Disclosure: I have never used it, I only know of it. HTH.
As far as I know there aren't any good libraries for writing those tags, though Mediainfo does a very good job of reading them. However, the mp4v2 C API does not look all that bad, you could try wrapping it with either ctypes or cffi and create your own Python bindings: http://mp4v2.googlecode.com/svn/doc/trunk/api/index.html
THIS. Also, no need to figure out how to compile all your dependencies as Anaconda comes with PyCrypto.
( not quite 1 Million LOC, that's a lot in python. ) 1) one massive repo. many packages. 2) only the core is really documented : the (tricky) parts with a lot of maths. Over the whole codebase, the inputs are always the same so we have a convention for naming that covers a lot of ground. 3) Not manually, we pylint/code digger on the dev branch with very strict settings everyday. We code reviews what is detected by those tools. 4) yep, one afternoon per week. clonedigger+callstack graph works well for this. 5) Yep. but this is an ongoing battle.
Why? The % operator is much easier to write and read.
You probably want to format the first two JSON code blocks.
HealthCare.gov ?
 &gt;&gt;&gt; l1 ['chimp', 'champ', 'champ', 'champ', 'champ', 'dup', 'dup', 'chimp', 'boo', 'chimp', 'boo', 'chimp', 'chimp', 'dup', 'chimp', 'champ', 'chimp', 'boo', 'champ', 'chimp'] &gt;&gt;&gt; l2 ['champ', 'champ', 'chimp', 'dup', 'champ', 'boo', 'dup', 'foo', 'foo', 'boo', 'dup', 'boo', 'dup', 'foo', 'boo', 'boo', 'boo', 'foo', 'chimp', 'foo'] &gt;&gt;&gt; eq = [k for k in range(20) if l1[k] == l2[k]] &gt;&gt;&gt; eq [1, 4, 6]
You can use scp and copy files over the ssh connection. man scp
A lot of people are listing alternatives, but I'm surprised nobody has mentioned cliff yet: http://cliff.readthedocs.org It seems to be closest in goals to Click, as it has a strong focus on being able to set up sub-commands. One cool feature is that it can automatically generate bash completion functions: http://cliff.readthedocs.org/en/latest/complete.html The API is a lot more object oriented, no decorators in sight!
I don't want to be too specific, but it's a commercial product for businesses. We work with a lot of sensitive financial data.
&gt;get_foo = cache_page(...(require_auth(get_foo))))) Don't call get_foo in the inner-most brackets.
pandas is the best option. You can read the entire file in then apply a filter on the entire data set at once.
Nice! I was wondering how I was going to do this for a project of mine that I have in the works!
I suppose it's a spoiler to say that `finally` wins every time, except `continue` after `finally` is a syntax error (didn't expect that one, did expect the others).
The third and fourth ones appear to be trick questions!
IMO the first three examples should be considered buggy. The reason they work that way is because they completely skip the `END_FINALLY` instruction; all info about the exception is then silently popped off the stack, which is clearly bad (as bad as a bare `except`, only implicit). Slightly related: in [my own programming language for CPython](http://pyos.github.io/dg/) the first and the second functions are impossible (`return` is implicit, and the return value of `finally` is always discarded) while the latter two raise `SyntaxError`s (`finally` temporarily clears the stack of loop pointers, making `break` and `continue` think there's nothing to break out of.) &gt;&gt;&gt; except ... e =&gt; 1 ... finally =&gt; 2 ... 1 &gt;&gt;&gt; except ... e =&gt; 1 / 0 ... finally =&gt; 2 ... Traceback (most recent call last): ... ZeroDivisionError: division by zero &gt;&gt;&gt; while True =&gt; except ... e =&gt; continue! ... finally =&gt; break! ... Traceback (most recent call last): ... finally =&gt; break! ^ SyntaxError: `break` outside of a loop &gt;&gt;&gt; while True =&gt; except ... e =&gt; break! ... finally =&gt; continue! ... Traceback (most recent call last): ... finally =&gt; continue! ^ SyntaxError: `continue` outside of a loop &gt;&gt;&gt;
No, it's not being phased out. At least, not any more. The plan to deprecate it was in Python 3.1, I think. Fortunately, the core devs came to their senses, and the % format operator will continue to be an integral part of Python.
Huh, I've missed this then. Got any sources for this? Can't find any.
Well, for instance [3.0 docs](https://docs.python.org/3.0/library/stdtypes.html#old-string-formatting) warned that % will be obsolete, but [3.2 docs and later](https://docs.python.org/3.2/library/stdtypes.html#old-string-formatting) started stating that there are no plans for deprecation.
Welcome! I couldn't find a nice tutorial-style article outside of StackOverflow.
I'm assuming it's a typo.
Perfect thanks
I thought it was a universal rule not to put return statements in except and finally clauses. The break/continue stuff is a surprise, but it never really makes any sense to put continue/break stuff in a finally clause anyways.
&gt; plus a couple million lines of actionscript, javascript, html &amp; css The fuck? Seriously? That sounds like a lot for client-side, doesn't it? 
In learning any programming language, google is your best friend.
a) What plugin do I need to view this? b) Why does it need one?
I have the same problems quite often with Safari (I don't like to install all the Adobe Flash plugins or whatever it needs). I thought everything should technically work via HTML 5 nowadays on youtube...but apparently it doesn't for me (only in ~30% of the cases), although I set it in the YouTube preferences... Anyway, for those cases I open up Chrome (out of box, no additional plugins required), it usually works.
There's some locked-down security context with QEMU. You can also look at Recipe.sh to see how tftp can be used to copy files in. You can also move files into webspace in the guest and copy them out through a web browser on the host. Just some other options. The very brave could also try getting Samba running for actual drag-and-drop file sharing from the host.
Are these things in the standard, or just CPython implementation details?
Compiled dependencies are also going to be an issue on Levinux because it's so stripped down that the GNU toolchain is not preinstalled. You could grab the toolchain first. I may make that a menu-option in Levinux as it's coming up more frequently.
Always a solid answer, and a big part of why it exists. Enough root to be dangerous isn't so much of an issue when all you can take down is a little Raspberry Pi, and you can always reset it by reimaging the SD card. Kind of like a virtual machine, but with real hardware :-)
Look at recent py3 code from Guido. He's still using % in most places. .format has its uses, but is way to awkward to use for everything.
Why does `finally` win in the first one? It seems to me that the most intuitive situation is for a return value of 1 because it tries to return 1, does not fail, and successfully returns. I guess finally is supposed to be high priority in terms of things that should always happen, especially considering that's its main advantage over just putting code after your last catch, but I feel like a return is supposed to end the function entirely whenever it happens, and that's an even higher priority type of rule. Am I just being silly?
The author describes how he's got two files: * One that is about 200 GB with ids, timestamps and other data * Another that "can also grow big" - that has ids to filter out from the first * Finally, he wants to pull out the latest match only A few pieces of info are missing: * How fast does this need to run? * What kind of hardware is available? * How often will this need to run? * Exactly "how big" is this second file full of ids? This is basically a join operation, and there's a couple of options: * Nested-Loop-Join: read the largest file sequentially, one record at a time, look up each id in the smallest. This works best if the smallest file is either indexed or is very small. * Merge-Join: sort small file by id, sort large file by id &amp; timestamp. Read both sequentially and in sync. IE, read next rec from big file, if id greater than current id in small file, read another small rec. Etc. This works best if both files are very large. Filtering to just the most current timestamp can be handled in a second step. And finally, if you have enough hardware (cores or hosts), first split your data into multiple fragments then process in parallel. This is a fast operation and can easily give you a linear performance improvement.
As someone too thick to learn formal type theory, you show me a doge-lang that runs on pypy 3.3 and I quit my job right now and work for you.
Here's the rule: If control passes into a `try` block, and then leaves the block, it *always* proceeds to the `finally` block, regardless of circumstances.
&gt;Why does it ever leave the try block if it has a return in it? Because it leaves the whole function. It's not as if it *remains behind* while leaving the function.
Ive been watching some past talks/tuts from previous events. And I've just got my ticket. I'm excited now. 
If you look at the sidebar on the right, under the section called "asking questions", there is a link to a sub Reddit called r/learnpython. That might be a great resource, too. The Python newsgroup/Google groups group, is another good resource. There is also a Python tutor email list, which is excellent, or at least was the last time I looked at it. And, of course, there is Stack Overflow or related Stack Exchange sites. There is really no excuse at this point to not be able to learn Python on one's own.
While the function is in the process of returning 1, the finally block runs and returns 2. The previous return never gets a chance to finish.
Thanks Mike, this is great, and the whole package is great! If you accept bitcoin donation, PM an address
you can try http://www.checkio.org/
[exercism.io](http://exercism.io) is good
Great article. Very good information here. Thanks.
This was great. I've been playing with pandas a bit and I'm a big hockey fan, so all of this resonated. Thank you.
Thank you for the kind praise. I can't wait to get enough time to refine it a bit more. Just added the Bitcoin button to my site, set to .01, equal to just under $5 USD. Thanks, the Reddit community has done a great job getting the word out.
Thanks for the reference! it says on the main page hat Python support is coming soon.. not sure how long they say that though...
Thank you so much. I wanted to do something similar but didn't know where to start. You pointed me in right direction. PS I am a Rangers fan.
If you like math, project Euler is good
Unless you call `os._exit()`. But assuming we play fair, sure, it should pass through `finally`, but why should the return value be the value of the second return statement and not the first?
Thanks for reading! Tonight should be interesting :)
Thanks for reading !
Google "matplotlib chess", and there are already a few interesting resources people have put out there. This would be a really fun addition to the gallery of plots you can make in matplotlib.
Link is not working anymore
&gt; Unless you call os._exit(). That's cheating. Even C behaves weirdly if you call `_exit()`. &gt;why should the return value be the value of the second return statement and not the first? Because the second one executed last.
[Done.](https://github.com/pyos/dg/tree/pypy-23) (Requires PyPy from [branch py3.3](https://bitbucket.org/pypy/pypy/src/5ec636950a44057a5d1b030a02f99331c6a2d383/?at=py3.3).) 0 # ../pypy/pypy/goal/pypy-c -m dg -b 0 # ../pypy/pypy/goal/pypy-c -m dg -c 'print "Hello, World!"' Hello, World! Note: this branch of PyPy does not compile with `-Ojit` at the moment; use `-O2`. It'll be about twice as slow as CPython 3.4, though. (Also, it does not support [qualnames](http://legacy.python.org/dev/peps/pep-3155/#proposal).)
sent .01! although Coinbase wanted 1.01... :)
Wow, at first I thought that your language was strictly satirical, but reading the tutorial, it look pretty cool. And it's self-hosting too? Nice.
Then go complain to Guido.
This is awesome, thanks
Sure will be. BTW, do you know if NHL has play-by-play stats in JSON format somewhere?
I don't believe there is, but I do remember a project by a student at Harvard I think it was that created something using NHL play by play data. I think he was scraping it. Might have been from the Harvard CS109 class thats online. Ill see if I can find it. 
I think I saw that one... It was about Bruins and Bayesian statistics to predict outcome or the score or something...
DNS look up failed. Error code: DNS_PROBE_FINISHED_NXDOMAIN Btw just read the article. Really nice. I think I'm gonna do something similair with data from the NBA playoffs if you don't mind.
Yeah that sounds right, im not sure if he was using play by play or not. Would be very interesting to look into though.
Thats strange... but by all means go for it! I tried to make the post a pseudo tutorial in a way. Let me know if you find anything interesting.
Somehow it works now in Chrome. I did nothing, but it just works suddenly. Thanks for the libraries I did not know off (pandas and nltk) Will save me a ton of work of programming it myself, haha. 
No problem! Pandas is very useful and easy to learn.
I've just tried PyPy recently, they actually have their own patched numpy that you can use, but I haven't managed to use OpenCV with it, which is a real shame, because it would have helped me a lot.
Thanks, and I'll double-check my button code! ... update: fixed bitcoin button code. 
Awesome! I've just started toying around with Kivy, scatter widgets are waay too slow, Rect canvas instructions are a little slow and problematic to rotate. KivEnt seems to compile OK - but the examples fail with the following message: Traceback (most recent call last): File "main.py", line 7, in &lt;module&gt; from kivent import (GameWorld, GameSystem, GameMap, GameView, File "__init__.pyx", line 1, in init kivent (kivent/__init__.c:63030) ValueError: kivy.graphics.instructions.VertexInstruction has the wrong size, try recompiling I'm compiling with: export PYTHONPATH=/home/chozabu/git/kivy:$PYTHONPATH export PYTHONPATH=/home/chozabu/git/cymunk/cymunk/python:$PYTHONPATH python setup.py install I've tried re-compiling kivy, cymunk and kivent -any ideas? 
I cheated; I made them into scripts.
&gt; change the user agent to Safari for iOS iPad Would have never thought of that. Thanks!
Thanks, I tried this and it looked good! One thing though, how could it be adjusted so there would be grid lines instead of just queens in an empty square?
I don't work in Python, but I work with several projects that are 1M+ LOC. They are however in C, C++, Verilog, Perl, Ruby, bits and pieces in Python, who knows what else. You might be able to guess the company. 1. Split projects. Several repo servers. Ability to chain projects together. 2. Probably close to ~1% is documented. It's horrible. REALLY. 3. Nope. There's auto testing, and specific engineers whose job it is to qualify check-ins. 4. Rarely. A lot of stuff works by magic, is multithreaded, used by external resources, who knows what. You might think something won't affect anything, but it really might. 5. Not really. Things are split up pretty well. Too well to be honest. Finding anything requires going 20 directories deep. 6. No. I want to rip my hair out everyday. 
P.S - Belated thanks for the gold
It could be running locally and not on the browser. Making it just a downloaded app.
Y! ?
https://github.com/rogerwang/node-webkit
Try the Seaborn library to make your Matplotlib plots look more pleasant. http://stanford.edu/~mwaskom/software/seaborn/
Why do people make us do all this? is it because uploading is hard?
The Python Challenge is a good one: * http://www.pythonchallenge.com/ Regards, Marin
This really isn't the place for this sort of question, but I'll give you an example anyway: from PySide import QtGui app = QtGui.QApplication([]) win = QtGui.QMainWindow() win.show() win.statusBar().showMessage('Processing ...') app.exec_()
You just need to add a grid: ax.grid(True) And to center markers into grid cells, you need to shift either queen or grid positions: queen_xs = [x + 0.5 for x in queens[::-1]] queen_ys = [y + 0.5 for y in range(len(queens))] ax.scatter(queen_xs, queen_ys, s=1000, alpha=0.5, marker="$\Psi$") The [matplotlib gallery](http://matplotlib.org/gallery.html) has very good examples of mostly everything.
"From Python to Code: How CPython's Compiler Works" Dr. Brett Cannon. PyCon CA 2013 Video: https://www.youtube.com/watch?v=R31NRWgoIWM Slides: http://bit.ly/BrettCannon-PyConCA2013
Python was my first language and really spurred my interest in computational linguistics. Without learning I doubt I would have been able to find my intended career and fall in love with programming. 
Thank you so much. One last question though, your code seems pretty easy to generalize for an n x n board, but even after I tried to do that, it only prints nicely for an 8 x 8. With other board sizes, there are the wrong number of grid lines. Do you have any idea why that might be?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**C3 linearization**](https://en.wikipedia.org/wiki/C3%20linearization): [](#sfw) --- &gt;In [computing](https://en.wikipedia.org/wiki/Computing), the __C3 superclass linearization__ is an [algorithm](https://en.wikipedia.org/wiki/Algorithm) used primarily to obtain the order in which [methods](https://en.wikipedia.org/wiki/Method_(computing\)) should be inherited (the "linearization") in the presence of [multiple inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance), and is often termed "MRO" for Method Resolution Order. The name C3 refers to the three important properties of the resulting linearization: a consistent extended [precedence graph](https://en.wikipedia.org/wiki/Precedence_graph), preservation of local [precedence order](https://en.wikipedia.org/wiki/Order_of_operations), and fitting the [monotonicity criterion](https://en.wikipedia.org/wiki/Monotonicity_criterion). (The name "C3" is not an initialism.) It was first published at the 1996 [OOPSLA](https://en.wikipedia.org/wiki/OOPSLA) conference, in a paper entitled "A Monotonic Superclass Linearization for [Dylan](https://en.wikipedia.org/wiki/Dylan_(programming_language\))". It was adapted to the Open Dylan implementation in January 2012 following an enhancement proposal. Subsequently, it has been chosen as the default algorithm for method resolution in [Python](https://en.wikipedia.org/wiki/Python_(programming_language\)) 2.3 (and newer), [Perl 6](https://en.wikipedia.org/wiki/Perl_6), and [Parrot](https://en.wikipedia.org/wiki/Parrot_virtual_machine). It is also available as an alternative, non-default MRO in the core of [Perl 5](https://en.wikipedia.org/wiki/Perl) starting with version 5.10.0. An extension implementation for earlier versions of Perl 5 named Class::C3 exists on [CPAN](https://en.wikipedia.org/wiki/CPAN). &gt; --- ^Interesting: [^Multiple ^inheritance](https://en.wikipedia.org/wiki/Multiple_inheritance) ^| [^List ^of ^algorithms](https://en.wikipedia.org/wiki/List_of_algorithms) ^| [^D-Grid](https://en.wikipedia.org/wiki/D-Grid) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch21ao0) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch21ao0)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt;You couldn't easily rewrite this with a finally block that doesn't have return. Replace `finally:` with `except: pass`, dedent the next line, and the result will be pretty much equivalent.
No I wouldn't. If the open fails to work, you end up trying to close a closed file. However your code is hard to assess as it doesn't build. You probably meant: try: handle = open ("filename") finally: handle.close () Which is equally broken should open fail, as handle won't exist.
nope, not local. its a very large web app
Yup.
I've tried numba recently as well, but it has been a huge disappointment, because it does not seem to work with keyword arguments and such, but it isn't stated obviously anywhere on the website.
I've given up with their site and now just use google cache!
That's so awesome to hear. It's my first language, and it's opened my eyes to the world of programming. I find this article so inspiring because it addresses my motivations for learning Python: to make useful tools, and to be able to teach my young children an increasingly necessary skill. 
Cool! Taking my first bioinformatics course this semester - definitely checking this out :)
I think what you'll want is actually... try: handle = open ("filename") except: dealWithIt() try: doSomething() return "foobar" except: dealWithIt2() finally: handle.close () Or, otherwise, handle exceptions by type and try to figure out which files failed to open...
I have stood by my pledge not to post my own material, but this article deals with important issues and contains an offer for free books/tutoring for all female engineers, which I think the community would find useful. I hope you'll excuse the transgression.
&gt; Even C behaves weirdly if you call `_exit()`. C behaves weirdly if it's a Tuesday.
OK, here's the more complete reason: Because the second one executed *before the first one had finished executing*. The `finally` block suspends the `return`, temporarily setting it aside, and reinstates it once control flows off the end of the block. In this case, control did not flow off the end of the block, so the return is not reinstated. You could just as easily have something like this: def f(): while True: try: return False finally: break return True `f()` returns `True`.
Or a Wednesday, or a Thursday, or...
It'll segfault before you find out what the next day is.
It is atomic. It's not as if some parts of the system think the function returned one value and some parts think it returned a different value. The return began, then got rolled back, in a perfectly transactional fashion. (At least, I'm assuming CPython handles this correctly; there might be some nasty bug I'm unaware of, but I doubt it given the amount of thought displayed in the language reference.)
 int tomorrow = *((int*)0xDEADBEEF);
No one around here ever programmed in Pascal? :-) Think of return as assigning to a variable. In fact, in Pascal you can use a variable with the same name as the function: Function Whatever(a: integer): Integer; Begin Whatever := a * 2; Whatever := a * 3; End; When the function actually returns it returns the value currently in the return value (in this case, "Whatever"). I assume Python's doing the same thing, except less explicitly. 
The free tutoring is something that probably won't scale. Best of luck! Do let us know how it all works out.
Sorry Jeff but the rank hypocrisy in this is palpable. You have NOT stood by any pledge not to post your own material when you just posted your own material. That's the very definition of breaking the pledge! Your article says you want to give female engineers the same respect as male engineers - and then you give female engineers discounts and private tutoring sessions .... do you also give male engineers the same, or are you just another tool of the feminist agenda? I can see no evidence you discount and tutor male engineers the same, so I'm calling hypocrite again. True egalitarianism is ACTUALLY treating people the same irrespective of gender, race, skin colour, social status, body odour, ... Tipping the scales in favour of one specific group over another is discrimination. I have worked my entire life with female engineers and they find this kind of thing insulting, that a man would think they're so stupid or poor they need special discounts or tutoring to operate at the same level (especially when they're already better than other male peers). It's a kind gesture but so very, very far off the mark. 
You have to, the function is still called. func = someotherfunc() simply pollutes the global namespace with an alias to an existing function (in this case the function returned by the decorator) Without the inner call to the decorated function, it's code would not be executed.
http://sphinx-doc.org/ - people already use this to make free-form blogs and other odd sites.
I contemplated that but wasn't sure if it was actually any good as a website builder. Do you have any sites that use it for other than documentation? I looked at the examples/sites-that-use page but it all seems to be docs. **edit** Heh, had to scroll down a lot further, my bad.
No, the function itself is passed as the argument to the decorator function, not the return value of invoking that function. See the post above by /u/agrif that explains it well. 
Now you're going to piss off trans people who get rankled at the strict male/female dichotomy.
This is a really awesome project. However, I'd see it more like a toy. I really like Python's syntax, and I am already familiar with it, I don't see any advantage using this "dg", or am I missing something here? But nice nonetheless
http://haypo-notes.readthedocs.org/ http://python-notes.curiousefficiency.org/en/latest/
The open should actually be just *before* the try. The pattern looks something like this: def fubar(): f = open(filename) try: return doSomethingWithFile(f) finally: close(filename)
That's what I said. You probably replied at the wrong comment level.
Im dodging the politics here, but I do know few women that would be interested in this, I will let them know of this great opportunity.
Have you ever used Wok (http://wok.mythmon.com)? It's actually pretty much what I've been looking for, personally.
My first programming language was C++. How I wish it had been Python. Or C. Or Ruby. :)
[**@NativeWired**](https://twitter.com/NativeWired): &gt;[2014-04-25 19:17:25 UTC](https://twitter.com/NativeWired/status/459773191691698176) &gt;[@snipeyhead](https://twitter.com/snipeyhead) did you see this? RT [@IrisClasson](https://twitter.com/IrisClasson): WHAT THE FUCK!!! [*codebabes.com*](http://codebabes.com/) And pardon my language. BUT WTF!!! ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2402l9%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
So I talked to the sys admin in charge. There is an issue with their DNS service right now and are waiting for some updates from their ISP. 
Here are some (old) suggestions from /r/pydanny (he chose pelican though): http://pydanny.com/choosing-a-new-python-based-blog-engine.html
What is more expressive and faster than Sass
Stylus, Less, and pretty much any other alternative.
Can't open itself fail due to various factors (e.g path being unavailable, permissions issues)?
No. Never. What would be the point?
Yes, but if open fails you do not need to close the file. In fact, it will not even return a file object for you to close.
Uh, not available. 
Except with no `except` clause?
A statically typed language that compiles to Python would actually be pretty sweet.
That means it should still work, but you'll need to use the ip address to access it rather than doing a domain name lookup.
I think it's also important to state WHAT the finally block was intended for, as this sheds a little light as well. One of the biggest problems that the try-catch-finally (or try-except-finally) was intended to solve is file and stream operations. Specifically, the finally clause allows you to safely close your handle/reference to a file or stream. It's important, (even more so in the past) that a program always lets the operating system know when it's finished using resources to prevent dead-lock situations, memory leaks, and other hard to find bugs. By making a try-catch always exit through the finally statement, you can be 100% certain that the finally code will "clean up" your resources or do whatever you need to do to release them, even if you exited earlier.
I'm pretty happy with Nikola. http://getnikola.com/
For simple and fun scripts? Sure. In projects that other people may actually need to use/support? No. I'll stick with something that has a higher-than-zero chance of being known, thanks.
Perfect timing, I just started a google app engine project in Python... For my HTML5 javascript game. I figure using Python and app engine for the AI (it's a turn based game, so no need for fast callbacks from server), storing the game state, and handling the game logic, then delivering via restful api's all the data to the javascript for rendering into canvas. I think this works cause it keeps the game logic and player state off the front-end where it can be changed by anyone with the console, but it lets the canvas do the heavy lifting in delivering a fast UI, as well as animating sprites and being generally a great renderer. Would love to hear more thoughts on this. I love python, have used it quite a lot and think it can handle complex AI problems and handling all the units and character states really well. By using canvas and JQuery I can craft a beautiful UI and just toss commands between the server and back again.
It's scary to think that the AST stage almost didn't get implemented. I do program transformations in Python and I rely on that more than anything else.
AST is killer feature. For sure. Lots of interesting applications in goal programming.
Geeze, I'm not sure that'll be enough... Thanks, I'm definitely going to write this thing now.
Looks like a really nice language, although I'm curious why you chose `otherwise` instead of `else`. English-wise it's more correct but it's also longer to type.
Try SimPy. http://simpy.readthedocs.org/en/latest/ 
Mostly because I liked it more. Also, that's what [Haskell uses](http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:otherwise) in multi-way ifs and guards.
This has nothing to do with Python, why is it here?
Is there a mirror of the docs somewhere? I find their hosting very slow at the best of times.
It's a blurry line for me. In my rather limited experience, I've seen a few things: * Very strict presentation-only on the client-side. * Limited mixing (e.g. adjust timezones, calculate simple new fields from existing columns) * Full integration: the back end is static files, everything interesting happens in javascript on the client side. Which approach is best depends on what you're trying to do, but I think most applications will get the most benefit from an approach somewhere in the middle. I prefer Python to Javascript, at least partly due to familiarity, so I'd lean towards them for the server-side. As for tools: * Flask, Django, Pyramid, node on the server * Angularjs (I'm not very familiar with it but a lot of people I know like it) * jQuery (the old standby) There's a ton of smaller javascript libraries that are pretty popular (e.g. underscore, chosen) and I use, but I wouldn't want to be tied to them permanently in a full-stack solution.
I think I'm missing the point… What I like in Haskell: - the type system - the monadic way of wrapping side-effects What I'm not sure about: - the lazyness What I think has no specific value: - the syntax What this project brings: - well… the syntax :(
somefunc is the function. somefunc() is the return value of the function.
What you're missing is an in-joke. This language was made for a community of programmers where Haskell has gotten so overhyped, it's said to be a solution to any problem imaginable. Naturally, a lot of in-jokes revolve around it, such as a hilariously misspelt version of "monad = array", which refers to the common attempt of haskellists to explain monads as container types. This language was intentionally made to look like Haskell but not quite. As its homepage says, this coupled with dynamic typing annoys local haskellists to no end. (Besides, there isn't any point in porting Haskell's type system to Python. Native Python functions are too hard to assign types to; `*varargs` alone is a *heterogenous collection of arbitrary length*! And without that layer of compatibility, you may just as well give up and use Haskell itself.)
Great article! Its well written, and gave me ideas for something i want to do in Python. Being quite new to python, there really seems to be a library for everything. Never knew of pandas before reading your article.
But python3 has venv?
matplotlib scales the grid automatically, but you can also set all locations and boundaries yourself. Something along the lines of: ticks, bounds = range(len(queens) + 1), [0, len(queens)] ax.set_xticks(ticks), ax.set_yticks(ticks) ax.set_xbound(*bounds), ax.set_ybound(*bounds) 
The docs say that "the abstract syntax itself might change with each Python release". How can you rely on that?
seems fine to me?
sods law a few minutes after I posted it came back, perhaps problem was on my end
This is a good question. As you can see, the trend is to have backend services and everything done with javascript on the client side. I use Django for the server side and AngularJS for the client side. Altough the ideea is to have complete stand alone apps, so you can have the same functionality in your web app, mobile app, maybe expose some of the API to external services, I find it easier to have some of the templates rendered by the back end. It gives me more control on what js files to load, depending on user permissions, language, loading csrf tokens, etc. The good part about this new trend is that there's a lot of wiggle room, so you decide where the back end ends and the client side begins. It's like with all tools and patterns, you choose the one that's fit for the job and that's more confortable to you. With all the hype for automated deployment and continuous integration, it's good practice to have completely separated environments for the client side and the server side, each with it's own sets of tests (testing in javascript is a lot better nowadays), so you can have the whole "launch a minimal viable shippable product and add functionality when/if there's need for it" mentality going on. Web dev will be javascript intensive, in my opinion, and you're not gonna see a lot of HTML when working with your favourite Python stack anymore. I find this thought very satisfying. 
&gt;The big trends these days with front-end engineering are to basically do everything with Javascript... everything. Even things that aren't necessarily client-side (thanks to things like node.js)... I've gotta say, every time I've taken this approach on a project I've sorely regretted it. I see this as a passing fad, and not something that will stick with the web long term. Javascript is a great language for short, light scripts with limited scope. It's horrendous for large projects with a multitude of dependencies and complex architecture.
If you find reading ffmpeg syntax difficult (or you just like doing things in python :-), moviepy is a nice wrapper around the ffmpeg command line: http://zulko.github.io/moviepy/
Thank you, yes you are absolutely correct... what I am intending is to provide a number of endpoint URLs from app engine that I can hit with AJAX calls to perform transfer of moves to the client, and to collect new moves from the AI for display to the player. The Server will need to maintain the game in the database. The biggest reason for all of this is to adhere to the desire to "never trust the client" and use it merely as a UI. Players could hack the AJAX calls or change the JS to do whatever they want, however if the moves they submit do not fit into allowed moves on the server end then they won't be allowed. Moving the game logic to the server also allows me to "hide away" the computer AI from prying eyes.
&gt;Horrendous for the user, or the developer? Horrendous for both. The system will be buggier than any equivalent. And, unless you have a huge amount of QA/bugfixing resources to throw at it then the user will experience those bugs. &gt;I can't imagine using things like Gmail or Rdio as static sites. You can use gmail as a static site. It's not something you have to imagine. And it's perfectly fine to use. The regular site *is* very javascript heavy, but it didn't have to be. It could have been done equivalently with a much lighter touch of javascript and been just as snappy.
&gt;True, but a language can be successful even when it has significant drawbacks. Successful doesn't mean **you** should use it.
I've grown to use Django (w/ the Django Rest Framework) with AngularJS for creating my single-page applications. I feel like it works pretty well together and DRF does a great job of helping me manage my data. There are probably some more static presentation elements I could/should be using Django for, but I've been able to rely heavily on Angular for doing all that. 
I didn't say it did? 
I have to disagree. I use JS on a large project every day to create single-page applications with a relatively complex architecture. As long as proper testing is done, it is not hard to manage. When you just jump in and start coding without any architecture in mind and no unit or end-to-end testing in place, that's when you have problems. Unfortunately, as of now, a lot ofFE developers seems to be afraid of testing.
&gt; The system will be buggier than any equivalent. Because of JavaScript? Honestly curious, I'm a new developer and haven't worked on anything relatively non trivial. I feel like treating the browser as essentially another client, similar to an iOS app, would be beneficial for both sides of the problem though. The backend focuses on serving up an API, and the clients manage presentation. But again, haven't worked on anything that complex before. And I did switch to the HTML version of Gmail for a while, but it still didn't feel as responsive as the JS heavy version. That's just me though
I see, kind of: I had a problem so I thought I'd use Haskell to solve it, now I have a monad of problems…
Yes. That makes perfect sense. I would do it no differently ;) It's actually very interesting to think about how one would go about to implement a game where the state is kept on the client. It's probably doable but mind-bending :D Keeping the state on the server is certainly way easier and more secure.
Here's what I do: make the client spa it's own project and the backend its own with flask. For a while I was using [lineman](http://linemanjs.com) because you can stub out the backend if it wasn't built already but it also has a proxy to forward API calls which is nice. I just recently switched that workflow to gulp as its so much easier than dealing with grunt based configs and lineman uses grunt. I just prefer knowing how everything works up front rather than dealing with a massive (grunt) config. I use gulp-connect as it has livereload already setup and gulp-browserify (with coffeeify) because its synchronous and you don't have to deal with amd configs for a js build.
I second this one.
Right. I was looking at this, and trying to figure out if it makes functional programming easier in any meaningful way. And I still think the answer is "maybe".
&gt; am I missing something here? Well, that's my question. I think it might make functional style a little easier?
&gt;Because of JavaScript? Yes. Specifically because of weak typing and callback hell. &gt;And I did switch to the HTML version of Gmail for a while, but it still didn't feel as responsive as the JS heavy version. Of course it's not. But, it's hardly unusable. The JS heavy version also did not need to be anywhere near *that* heavy to be responsive - a sprinkling on top the HTML version would have sufficed. I can guarantee that it was a pain to debug, too. But, google has the resources for that sort of thing. Still doesn't make it right.
Sounds good. I've used JSONPickle quite a bit to serialize native Python objects to JSON to send to the browser. Works really well and saves some code doing it myself.
It's not just proper testing (though that is important), it's having a good architecture and organizational structure. The problem with Javascript is that it can be very free-form, and organizational structure can disappear very quickly if you're not careful. When I was in highschool and college, I learned PHP and thought I hated web development. Later, I learned Python and Django and decided web development was actually okay. I think the difference is that Django's MVC structure forces you to structure your code in a fairly sensible manner, and gives you logical separation of concerns. PHP applications tended to mix all of the different concerns. You might do a SQL query in the middle of some HTML code if that was where you needed the response. I think Javascript suffers from the same lack of structure, but it's getting better if you know what to look for. I use AngularJS at work, and the way it separates data management from presentation and handles user-interaction makes it much easier for me to manage larger applications in my mind than just having a bunch of callbacks that have no particular reason for being where they are in the code.
I don't know. I looked at it a while ago but settled on something else -- python-actors library. It is a library of concurrent, isolated (as much as that is possibly within a greenlet thread), asynchronous actors that send messages to each other. The reason was, I didn't need synchronous simulated events and I liked the concurrent IO aspect of eventlet. https://bitbucket.org/fzzzy/python-actors But I didn't give that as an advice because it seems like you need synchronous events. So give SimPy a try.
&gt; Yes. Specifically because of weak typing and callback hell. I would argue both of those are *trivial* problems compared to the overall issue of having to manage state on the client side. Without javascript you continously (when page reloads) ensure the state of the page is in sync with what you intend.
&gt; I think Javascript suffers from the same lack of structure Building apps with Ember I haven't had that much of an issue with this, since it's pretty clear cut where things go.
The OP did. I thought you might have been agreeing with him in some way.
Which isn't the same as virtualenv.
So why would you need to install virtualenv?
I can't disagree with any of this. The only thing I would say is that PHP vs an MVC framework isn't a fair comparison. I think PHP suffers from the same low-bar-to-entry JS does and that's why you get some of the worst possible spaghetti code. 
I agree. If you'd quoted the rest of the sentence, I mention knowing what to look for, and I think good frameworks are arising that help put sensible organization around code. 
I'm not familiar with this particular device, but similar boards run python very well. They're way more powerful than my first PC was, 18 years ago :) Linux Angstrom is a pretty dead distro by now, but will probably do an adequate job. However, getting new drivers and packages is troublesome. You might try Yocto, Debian or Arch Linux ARM.
Question: how do you secure your API? I mean, you don't want just anybody able to make a RESTful call and be able to insert/delete data.
I agree. I suspect I'd be okay with PHP now if I were using some decent framework like Symphony, just like I enjoy javascript with a nice framework behind it. I'm sure I could also find a python webapp tool that makes it easy to write shit spaghetti code. My point is that javascript leads to bad code when it lacks decent application structure, but that's true for any language, and you can get decent structure with javascript. 
Thanks, I'll look at that too. I probably do need synchronous events - indeed, I think that lack of that may have made my first pass overly complex. Looks like I may have to read around the scientific side of the subject.
&gt;I'm not trying to say JS is better than Python at anything. In simply stating that the issues you presented are an issue of people and not the language. My point was that using a poorly designed language means you have to throw **more** tests at a system in order to achieve and be confident in the same level of quality. That is not an issue of people. Javascript is hardly the worst language out there, but it's no python.
You would use signals to pass it from the tabs back to a slot on the QMainWindow. http://en.wikipedia.org/wiki/Signals_and_slots Or you could pass the reference from the QMainWindow all the way down to the tab contents.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Signals and slots**](https://en.wikipedia.org/wiki/Signals%20and%20slots): [](#sfw) --- &gt; &gt;__Signals and slots__ is a language construct introduced in [Qt](https://en.wikipedia.org/wiki/Qt_(toolkit\)) for communication between objects which makes it easy to implement the [Observer pattern](https://en.wikipedia.org/wiki/Observer_pattern) while avoiding [boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code). The concept is that GUI [widgets](https://en.wikipedia.org/wiki/GUI_widget) can send signals containing event information which can be received by other controls using special functions known as slots. &gt;The signal/slot system fits well with the way [Graphical User Interfaces](https://en.wikipedia.org/wiki/Graphical_User_Interface) are designed. Similarly, the signal/slot system can be used for other non-GUI usages, for example [asynchronous I/O](https://en.wikipedia.org/wiki/Asynchronous_I/O) (including sockets, pipes, serial devices, etc.) event notification or to associate timeout events with appropriate object instances and methods or functions. It is easy to use and no registration/deregistration/invocation code need to be written, because Qt's Meta Object Compiler (MOC) automatically generates the needed infrastructure. &gt;A commonly used metaphor is a spreadsheet. A spreadsheet has cells that observe the source cell(s). When the source cell is changed, the dependent cells are updated from the event. &gt; --- ^Interesting: [^Libsigc++](https://en.wikipedia.org/wiki/Libsigc%2B%2B) ^| [^Callback ^\(computer ^programming)](https://en.wikipedia.org/wiki/Callback_\(computer_programming\)) ^| [^Qt ^Creator](https://en.wikipedia.org/wiki/Qt_Creator) ^| [^SCXML](https://en.wikipedia.org/wiki/SCXML) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch2k8un) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch2k8un)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
yeah in theory this board should be well capable, it has some powerfull demos, unfortunately the documentation is very weak with it and there is zero on the net about it. I will check out the distro's you mentioned. 
&gt; Extensive testing might take care of most of those situations Yes it does. Extensive testing is expensive, however, and most people operate in a resource constrained environment.
I read through the article and couldn't find where they explained why they felt the need to port it from javascript to Python.
1) I've thankfully never been anywhere that had a million lines of python in a single project. Only Java/C++. But at least one place I worked at certainly had more than a million lines of Python. They were all broadly related, so a bunch of utilities all depended on certain modules, so there was massive interdependency and changing a module meant making changes all over. Modules depended on modules, etc. So, I think it counts. Aside from just python also had some ruby stuff, shell scripts, perl, native code, etc., as part of the broader "internal software stack" metaproject. 2) Much of it was "documented," but I would say &lt; 10% "usefully and accurately documented" from the perspective of anybody who hadn't written the documentation. 3) Code reviews were an interesting formalism. As far as I know, no code review was ever rejected, nor did it generate useful advice or insight. The code review system would have caught antipatterns like "Checking in mom jokes instead of runnable code," but probably wouldn't have caught anything more subtle. 4) The official corporate style guide noted the "difficulties" in working with a "mature code base" that had evolved over several years of shifting requirements. Policy was not to make changes that weren't specifically fixing a bug that users were complaining about or adding a feature users were demanding. There wasn't anybody whose job was to do testing, so bug reports only came from users who needed it to work RIGHT NOW. 5) Ha, yes. 6) I strongly advocated dumping a lot of internal stuff in the bin and replacing with off the shelf tools, and moving to a more formalised/mature release process that involved having actual testers in order to deal with a maintainable subset. I was not in a position to be listened to.
Dropbox uses Python.
Well, it's more than that. You need to edit your /etc/hosts (or equivalent on Windows) so that conference.scipy.org points to the right IP. Many web servers handle multiple sites, and the VirtualHost multiplexing relies on your client telling the server the hostname of the site it was trying to access.
At your REST-ful API layer? 
Do you mean updates to the views or tothe data?
I was wondering about changes to the data shared by different users.
To me the frontend is anything that runs in the browser. I like vanilla coffee script and jquery but that's just because I haven't sink time into learning anything else. Back end is anything running on the server... API, python process, etc
Since it is posted here, an answer using Python would be http://www.sympygamma.com/input/?i=%282**19937-1%29+%2F+52 (Rather than going straight to Wolfram alpha).
It depends on the project. If it is a site which mainly generates and displays pages of content, something like Wikipedia, then I would build the whole thing in Python using Flask or Django, then sprinkle a bit of jQuery on the client side to improve the UX. If it is more of a web app you're creating, with lots of interactivity, then I'd probably use Python to create a JSON API, then have a Node.js server which renders views and a clientside library/framework which can also query the API. Something like [Ractive.js](http://www.ractivejs.org/) would let you build most of the frontend logic and templates to be shared across Node and the browser, which would be really clean. This type of separation of data and presentation would let you plug in another client, like a mobile app, pretty easily. 
If you prefer to write the AI Python then that is reason enough to do it your way, but I don't think you need to worry about people "hacking" the JS code - if the code is minified and properly encapsulated (doesn't expose game state to the console) it would be very difficult to do that.
Oh that's a good idea. 
Wow great article! I hadn't heard of vincent before but it seems way easier and better-looking than matplotlib. A real-time tag cloud using D3 would be cool. I read that you are a junior, have any plans for summer internships? Want to come out to Colorado...we do all this "My main interests include Python, Data Science, Machine Learning, and Computer Vision." 
Thanks for reading ! I havent done anything with D3 yet but am going to look into it soon as it seems like the new thing these days. I actually have to take summer classes this year as my school does quarters instead of semesters but if you send me a PM I would love to talk.
That makes logical sense, if they have nothing better to do with their time. Why, though, if there's a perfectly good library that already does this in a language that they could make work on the client side (just like others have already) would they choose to rebuild or port it to a different language. That sounds like they're just asking for bugs in the vain of the "if it wasn't built here, we don't want to use it" mentality.
That depends on the context. If it's a single player game without consequences for other people, that's probably fine, as cheating only effects yourself. If there's a ranking system, or my outcome against the AI somehow impacts other players' experience, you want to insure against cheating. I'd also note that if I were going to cheat at a client server game, I'd probably study the network protocol if I couldn't get my hands on unobfuscated source. 
Thanks for the answer! I will try it soon!
I use tinker for blogging, I find it pretty awesome and really easy to use if you're a Sphinx/ReST person. http://tinkerer.me
lol, that is hilarious. i'd wager porting a pretty simple library to work natively with python is a hell of a lot easier and safer than trying to get js to work client side with an already python desktop app, but that's just me.
Angular has a huge learning curve compared to bootstrap, but the payoff is things like testing. It also meshes very tightly with your templates. pushing to from the server to the client depends more on the server. either you open a websocket from the client, or send a request that blocks, COMET style. Angular can definitely do both!
The advantage is that it runs in every browser and is designed to manipulate the DOM which is kinda the de facto UI now. The disadvantage for a long time has been that testing it is a pain in the ass so most projects end up without tests at all. His point is, when you push business logic into &lt;whatever language&gt;, that's where you need the tests.
I've just written a few interfaces with Angular and was working with D3 over the winter.. my experience is similar to Google's: using more javascript in the browser makes the UI noticeably snappier. 
I'd try to use Javascript for everything. You've no choice other than js for a dynamic frontend. But it's often critical to be able to prerender your UI before it hits the client too. Using one language means you can share code. If you want, you could use a language that compiles to Javascript. That mightn't be practical depending on what you need your backend to do. If you absolutely need Python for something - maybe it has a library you need to use, or something - I'd try to restrict to to serving up a JSON api, and consume that with a node.js server-side "frontend". I think you definitely want to keep all UI outside of Python. I haven't actually tried this on a large app before, but the opinion was developed working on a large app with a Python backend where our most, but not all, of our code is js.
Does this really work for facebooks messenger service?
If the frontend is to be only js, I'd use python to make an API, and then use solely js for the templating, etc.
As others in this thread have said, in the OP's last example, continue is illegal within a finally within a loop; the Python language reference says so: https://docs.python.org/3.2/reference/simple_stmts.html#grammar-token-continue_stmt "continue may only occur syntactically nested in a for or while loop, but not nested in a function or class definition or finally clause within that loop. " 
There are a lot of tools and practices that help you do the SEO for AJAX intensive web apps. The recommended way is to have your server render static html pages of the content at www.example/?escaped_fragment=/rest/of/path for www.example.com/#!/rest/of/path, as well as providing and xml sitemap, so you can tell crawlers what to search for. You can do this with a bit of code and some free apps, or opt out for a commercial solution to save you the hassle.
A question of this depth and quality deserves an answer of the same calibre. `import smtplib` and email user@facebook.com.
Thanks for the answer! Does this really work, is it really that simple. The thing is that I have no idea how the chat system works and that is why I have problems figuring this out. If this works, isn't it possible to send emails from say an gmail to a facebook account? I tried to use the facebook email on my profile that is firstname.lastname.number@facebook.com and I didn't get anything
[Facebook recently shut down it's email service](http://www.npr.org/blogs/alltechconsidered/2014/02/25/282535068/facebook-shutters-its-email-service-since-no-one-used-it) so I don't think that will work anymore. [Use XMPP](https://www.facebook.com/sitetour/chat.php).
author of imhotep here. Planning to write a for-pay version (free for open source) that will do this. That said, anyone wants to write one.. feel free.
What if the credentials entered through `/login` generated a token that was stored on the user's end and explicitly passed back to the server with every request. Is the service once again RESTful? 
The goal of http://www.mkdocs.org/ is similar to Sphinx's but it uses Markdown instead.
The focus isn't on the auth token, rather: &gt; every user will go to `/games` A token or cookie generated from the `/login` endpoint is perfectly okay, but to be truly RESTful you must still look up a game via `/games/gameid` (or even `/games/userid`). Your application can spit back a 403 error if a user tries to access a game that their token does not have access to, but the game id must be explicitly mentioned.
It's also worth checking out [scikit-bio](http://scikit-bio.org/), which is another project that Prof. Caporaso is heading and one that is gearing up to be truly awesome.
I'm a new programmer using Python who is falling in love with programming also. What do you suggest I could do with Python that would help me learn?
Right :) I forgot that it was a desktop app. My bad. It was the right choice, then. 
Client: Front-end Server: Back-end Why is this even a question? 
You could do raw websockets, I'm not familiar with any libraries that simplify that other than socket.io for node. 
It may be the finest thing since sliced bread, but your potential users will never know because the site doesn't tell much. For instance, where are the screenshots?
Honestly, if this project isn't time sensitive I'd suggest building your own. It's a great learning experience for both Python and webdev in general. 
Agreed. On my phone, screenshots are required since I may or may not make it back to this post to consider this.
Agreed 
Not entirely sure why I would use this over something like Bottle. Functionally seems much the same, layout is different I guess
Thank you for your comment, I added a screenshot.
I like this IDE. I know this isn't a bug tracker, but I don't care. The toolbar tick on the View menu is always on after a restart. I can't find a shortcut for code folding. Lacks Gtk 3 theme integration. The explorer panel changes size when the number of digits on the bottom changes. 
&gt; It really stole my hearth No! Cozy winter nights will never be the same!
Surely that just means that the language's features change and the syntax can change with it? If it is a problem then CPython can bundle the built-in `ast` module from a particular version and say, "even if you are running Python 3.5, Cython syntax is a subset of Python 3.3 syntax".
Why would you want to make a virtualenv without installing virtualenv?
This micro web framework has recently been released, however Bottle is more functional than Spinne, but Spinne as you've mentioned has a different layout, it's goal currently is to ease web development for programmers as much as possible and make it faster to make websites, we're going to keep developing it and soon it will be better, if you would like to help us in development, please send us a mail through atechsmail@gmail.com .
It is time sensitive, but the basics can still be built up and made into a platform more suited to my needs later. Curious though, do you have any guides on where to start? I know the basic idea is: Parse content files (Markdown, rST, etc...) -&gt; load template -&gt; parse template -&gt; write HTML data Guess the difficult part for me is since I haven't used Python in a little while that it feels overwhelming and would like a point of reference.
**N**inja **I**s **N**ot **J**ust **A**nother IDE
I get more than a little apprehensive when that's the first thing they want to tell me about their creation.
I considered Nikola but wasn't sure how easy it was to get "complex" structures going for it. Any feedback?
How easy is it to get "complex" structures? I.e.: I need something like /company/about/members/ehansen/index.html. For Pelican I need to do some nasty edits to make it happen. The platform I'm considering heavily is Wok as I just have to specify a URL in the Markdown file.
It's great for something that needs docs but it doesn't seem well suited for building an actual site out of it.
Wow, great review of many of the things that end up nicking people when they're new to python, or in some cases new to programming. Regarding the section "Picking True values from logical ands and ors", IMO, just don't do that. 
It seems nice, but at the same time I'm wanting this more for an actual site and not blogging. Still looks pretty nice though, thanks!
Find a small example of a static site ([my one](http://bitbucket.org/eyeballtrees/baller) is only a week old and very small) and learn from that example. Like you say, it's nothing more than applying Markdown and HTML to a directory of text files. 
I use Ninja, and really enjoy it. But I get this bug (sometimes) where when I'm starting a block like: if (this and that and the other): then when I type that colon, the line is deleted, I think. Has anyone else seen this? Is there a fix?
The developers are very active on Github, so open an issue and I am sure you will have an answer within a day. They are currently rewriting major parts of the software, so this might be a regression bug?
say you don't have sudo access to install it system wide. Theres one use. Also this doesn't require installing unnecessary modules.
Noticed a little typo that might trip people up copying and pasting: &gt; sudo apt-get **instal** ninja-ide
It seems much easier to make sure URLs load a reasonable page.
I used Ninja for a long time until JetBrains released a free edition of PyCharm, which is my current IDE of choice.
Verilog is a hardware descripction language, so I'm guessing a hardware manufacturer is more likely.
Would you recommend this over Komodo Edit?
You should change the heading &gt; Using += on lists creates new objects Since you point out right below it that `+=` actually keeps the same object, and it's `x = x + y` that creates the new object.
Under &gt; Public vs. private class methods and name mangling I think you missed the double underscores on the private function.
Link to _Be aware of the consuming generator_ is broken in the Table of Contents
came here to say that.
&gt; Using += on lists creates new objects Good catch, thank, it's fixed :) 
Oh, you mean like def __call_private_method_in_class(self): self.__private_method() instead of def call_private_method_in_class(self): self.__private_method() Changed it!
No, then your example won't work (I see you changed that too) you had `def private_method(self):` (it seems to be fixed now). `call_private_method_in_class` I don't think should have underscores to follow your examples Edit: To clarify: class my_class(): def public_method(self): print('Hello public world!') def __private_method(self): print('Hello private world!') def __call_private_method_in_class(self): self.__private_method() my_instance = my_class() my_instance.public_method() my_instance._my_class__private_method() my_instance._my_class__call_private_method_in_class() should probably be class my_class(): def public_method(self): print('Hello public world!') def __private_method(self): print('Hello private world!') def call_private_method_in_class(self): self.__private_method() my_instance = my_class() my_instance.public_method() my_instance._my_class__private_method() my_instance.call_private_method_in_class()
Apart from situations where a C compiler isn't available, when would this be preferable to Pandas?
But that's how it was before :) Now, I am confused - anyway, changed it back :P Both of them would work, but you are right, `def call_private_method_in_class(self):` illustrates it better!
 # Send 200 response (success) self.send_response(200) # End headers self.end_headers() # Setting the path to self.path path = self.path These aren't useful comments. Also, if you move your class and method comments onto the first line *after* their declaration, Python treats them as docs for those classes/methods. http://legacy.python.org/dev/peps/pep-0257/#what-is-a-docstring
&gt; print('3True + True:', 3True + True) Should this be 3 * True + True, or just 3 + True? Pretty sure that's a syntax error in any version of Python.
The Codewars developers have said that python should be supported soon by the way.
Typo alert: &gt; This can be done via a_list[:] **of** a_list.copy(). Also, yay, you took [my suggestion](http://www.reddit.com/r/Python/comments/23492a/started_a_collection_of_the_tricky_python_stuff/cgtn1hi?context=3).
*PyCharm is missing some important features and I do not want to promote closed source or deliberately limited software.* I'm interested to see why these comments are made?
Why not? I find it handy sometimes to use short circuiting, especially with an 'and' if I have 2 conditions where order matters (if var is not None and something about var). Without short circuiting, this generates an error, with it, it's fine.
And let's not forget about computational efficiency with regard to short circuiting - I am glad that it exists :)
It was built to solve exactly that problem - I was working on a system for a large corporation where there is a change-management cost to getting anything installed which requires a Windows installer. On the other hand it is dead easy to add some more wheels to our distribution. Also this is designed to be super easy to install and use. You can get started in much less time than with pandas. Most people should just use pandas. 
But what about when you want to install into a virtualenv? They pysvn installer is only good if you want to install globally. I have no idea why they deviated from normal Python windows packaging. 
I 've try this IDE last year. It was leaking lots of memory. I hope it is fix now.
Thanks for sharing this!
This is awesome, thanks for this.
who or what is aTechs?
LOL its virtualenv all the way down mate... all the way down i say!!
Brillant! It runs! I did a quick change to tutorial3 here: http://pastebin.com/2rgMPy9e dragging adds more asteroids, and applies an impulse on all asteroids directed towards the touch - to allow for a bit of a stress test. The number of entities is also printed upon asteroid creation KivEnt seems *fast* and nice to work with - I'll drop my previous kivy/cymunk stuff and dive in. I'm planning on doing a simple-ish physics level editor for my next game. Oh - I should mention, when trying to run tut6 I get: File "main.py", line 5, in &lt;module&gt; from kivent_cython import GameSystem ImportError: No module named kivent_cython I guess that is code that has not yet been updated to reflect modern kivent? and for the sample application: [INFO ] [AudioGstplayer] Using Gstreamer 1.2.0.0 [INFO ] [Audio ] Providers: audio_gstplayer, audio_pygame (audio_sdl ignored) Traceback (most recent call last): File "main.py", line 304, in &lt;module&gt; KivEntApp().run() File "/usr/local/lib/python2.7/dist-packages/kivy/app.py", line 773, in run self.load_kv(filename=self.kv_file) File "/usr/local/lib/python2.7/dist-packages/kivy/app.py", line 593, in load_kv root = Builder.load_file(rfilename) File "/usr/local/lib/python2.7/dist-packages/kivy/lang.py", line 1546, in load_file return self.load_string(data, **kwargs) File "/usr/local/lib/python2.7/dist-packages/kivy/lang.py", line 1623, in load_string widget = Factory.get(parser.root.name)() File "main.py", line 32, in __init__ super(TestGame, self).__init__(**kwargs) File "/usr/local/lib/python2.7/dist-packages/kivy/uix/widget.py", line 293, in __init__ Builder.apply(self) File "/usr/local/lib/python2.7/dist-packages/kivy/lang.py", line 1668, in apply self._apply_rule(widget, rule, rule) File "/usr/local/lib/python2.7/dist-packages/kivy/lang.py", line 1775, in _apply_rule self._apply_rule(child, crule, rootrule) File "/usr/local/lib/python2.7/dist-packages/kivy/lang.py", line 1772, in _apply_rule child = cls(__no_builder=True) File "/home/chozabu/git/KivEnt/sample_application/musiccontroller.py", line 62, in __init__ self.load_music() File "/home/chozabu/git/KivEnt/sample_application/musiccontroller.py", line 69, in load_music self.music_dir + track_name + '.ogg') File "/usr/local/lib/python2.7/dist-packages/kivy/core/audio/__init__.py", line 66, in load return classobj(source=filename) File "/usr/local/lib/python2.7/dist-packages/kivy/core/audio/audio_gstplayer.py", line 45, in __init__ super(SoundGstplayer, self).__init__(**kwargs) File "_event.pyx", line 156, in kivy._event.EventDispatcher.__init__ (kivy/_event.c:3119) File "properties.pyx", line 345, in kivy.properties.Property.__set__ (kivy/properties.c:3517) File "properties.pyx", line 377, in kivy.properties.Property.set (kivy/properties.c:3975) File "properties.pyx", line 431, in kivy.properties.Property.dispatch (kivy/properties.c:4544) File "/usr/local/lib/python2.7/dist-packages/kivy/core/audio/__init__.py", line 144, in on_source self.load() File "/usr/local/lib/python2.7/dist-packages/kivy/core/audio/audio_gstplayer.py", line 63, in load self.player.load() File "_gstplayer.pyx", line 233, in kivy.lib.gstplayer._gstplayer.GstPlayer.load (kivy/lib/gstplayer/_gstplayer.c:2332) kivy.lib.gstplayer._gstplayer.GstPlayerException: Unable to create a playbin I suspect this may be a problem with my kivy
thank you, fixed!
Because PyCharm professional is a really good editor (if not the best), but it is not open source.
Typo in the solution of "The consequences of modifying a list when looping through it": &gt;`ass="k"&gt;print(b)`
That try--except--finally bit surprised me. I didn't know finally would overrule a return statement. Thanks!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Sugarscape**](https://en.wikipedia.org/wiki/Sugarscape): [](#sfw) --- &gt; &gt;__Sugarscape__ is a model [artificially intelligent](https://en.wikipedia.org/wiki/Artificial_intelligence) [agent-based](https://en.wikipedia.org/wiki/Agent-based_model) [social simulation](https://en.wikipedia.org/wiki/Social_simulation) following some or all rules presented by [Joshua M. Epstein](https://en.wikipedia.org/wiki/Joshua_M._Epstein) &amp; [Robert Axtell](https://en.wikipedia.org/wiki/Robert_Axtell) in their book *Growing Artificial Societies*. &gt; --- ^Interesting: [^Sugarscape.com](https://en.wikipedia.org/wiki/Sugarscape.com) ^| [^Dan ^Howell](https://en.wikipedia.org/wiki/Dan_Howell) ^| [^Agent-based ^social ^simulation](https://en.wikipedia.org/wiki/Agent-based_social_simulation) ^| [^Alfie ^Deyes](https://en.wikipedia.org/wiki/Alfie_Deyes) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch3a6ln) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch3a6ln)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
If that's just a webpage (not a post in a blog) all you have to do is nikola new_post stories/company/about/members/ehansen And a couple of tweaks in config: 1) Change your PAGES setting to put them in "/" 2) Set PRETTY_URLS to True And that's it. Or not set PRETTY_URLS and create it in bla/bla/ehansen/index.md or something like it. So, not difficult.
Ah yes, of course. Thanks for the correction.
Is there a changelog? 
I'll happily entertain arguments for one IDE over another, but this sort of ideological fixation "rah rah free and open source only!" is tedious and uncompelling. People would be a lot more interested in trying Ninja IDE if you explained its advantages over PyCharm community edition and not dismissed it with Richard Stallman arrogance.
It depends on the nature of the application. If you want a read-heavy website, you'd probably want to go with the classical MVC pattern, if you don't need to have the API available to other clients, like phones or tablets. If you have a write-heavy app, with lots of forms and user input, that's available universally, the cave-eat of having an extra step for the SEO doesn't seem like such a hassle anymore, so javascript only for client side would be the best solution.
There is only the GitHub commit history. But you are right, I will make one
Couldn't agree more. I'd rather pay for good software than deliberately promote bad ones just because they are free/opensource.
Isn't there an O'Reilly track for that? If there is, I'd take a look at that.
Try to learn from one of the masters of Python who also teaches. A little searching turned up: [David Beazley](http://www.dabeaz.com/chicago/index.html) conducts master classes in Chicago. [Steve Holden](http://holdenweb.com/students/comments/) is in Portland and teaches but I'm not sure if it's just online. [Titus Brown](http://ivory.idyll.org/blog/category/teaching.html) teaches at Michigan State University.
I'm struggling to see your point here when reading your comments. You're just spurting out loads of hate for JavaScript because of its language drawbacks (I'm not saying it doesn't have drawbacks). But you're suggesting that a modern web application shouldn't use any JavaScript? Without any JavaScript you potentially have a website which is less responsive or a boring user experience. Both of which may end up not selling your product or driving users away.
&gt; So, when we want to "make" class methods private, we just put a double-underscore in front of it No, we use a *single* underscore to represent what "private" entails: *"This is an implementation detail and should not be considered part of the public api. If you use it, don't complain if it breaks"*. What a double underscore ("dunder") does, is name mangling to avoid conflicts. Consider the following example (inspired by a talk from Raymond Hettinger): class Circle(object): def area(self): .... def some_other_function_for_a_circle(self): # some calculation involving the area Now, you want people to be able to "override" your area function in their Sphere class, but you still want to use your area function in `some_other_function_for_a_circle`. The way you do it is to define a private "copy" def area(self): ... _area = area and use `self._area()` in your other functions. But wait! Now the people creating the Sphere class want to do the same, and also define their `_area` mirror; we're back where we started. So we need some kind of prefix to keep those variables apart, kind of like "_Circle_area" and "_Sphere_area". Well, guess what dunder does: class Foo(object): __bar = 42 Foo.__bar # AttributeError Foo._Foo__bar #42 dunder variables simply are renamed to `_Classname__name` (and everytime you write `self.__bar` it is actually compiled as `self._Foo__bar`) and are intended for the above use. Marking methods "private" is done by using a single underscore. 
Depending on the complexity of your application and database, changes in one project would have to be reflected in the other project. In almost any case, I'd prefer using option 2)
I recently had a project with the exact same questions. Decided to go with a RESTful api for a few reasons: * You no longer require that clients talk directly to the DB which means it's easier to do things like caching * You can put the consumers anywhere you want including outside the network segment serving the DB * Fewer dependencies on the client side * The client is no longer Python specific * If you design the REST api properly, you could replace the entire backend without the client ever knowing if you had to * Simplified interaction with the DB (which is _generally_ a good thing) 
Yes, right, should have made it more clear that: single _underscore = marked as private; double __underscore = marked as private + name mangling
I can't see why you wouldn't be able to able to use Flask-SQLAlchemy and a pip installable package.
Another thing to consider is that I didn't want to overload the API that is going to be used by actual users. Ok, I know I could separate them in several servers so the users do not compete for resources with other applications, I'm just thinking about the options. The RESTFul api seems to be a reasonable choice. I have one application that uses a shared library containing the models and I must addmit that it is a bit annoying to have to update the models in several places every time I update them.
Let me try to make this a bit more clear. In this example I have 3 separate projects. project_models - which is the sqlalchemy models Flask-App * depends on: * project_models Non-Flask-App * depends on: * project_models In this case I think couldn't use Flask-SQLAlchemy because the second project is not related to flask.
I'd love a good FOSS alternative to [**PyCharm**](http://www.jetbrains.com/pycharm/). My biggest criticism of PyCharm is that it is slow when compared to alternatives like [**PyScripter**](https://code.google.com/p/pyscripter/). 
Cool list. I have a couple suggestions for additions. * The RHS of the first clause of a generator expression is evaluated immediately, but the rest are delayed until the generator executes. This is so that an error in the first clause can be seen immediately. `v = (x for x in 1/0) # fails` `v = (y for x in [5] for y in 1/0) # succeeds... for now` * A strange scoping issue I noted in a [previous post](http://www.reddit.com/r/Python/comments/23pyfh/my_new_favorite_python_wart/). * The best part about C3 method resolution isn't just that the first base class is checked before the later base classes in the list. It's that for *any* inheritance hierarchy where B is a subclass of A, it's guaranteed that B's methods will be consulted before A's. This makes it possible to chain together multiple calls to `super()` and touch every class in the hierarchy.
&gt;But you're suggesting that a modern web application shouldn't use any JavaScript? I do believe I said "a sprinkling" or in light doses, or something to that effect. Please feel free to re-check what I wrote. &gt; Without any JavaScript you potentially have a website which is less responsive or a boring user experience. I've honestly never seen a user excited to see javascript on a website.
I've never done something like this, but this seems to work: import ctypes def deref(addr, typ): return ctypes.cast(addr, ctypes.POINTER(typ)) deref(id(29), ctypes.c_int)[6] = 100 #&gt;&gt;&gt; 29 #&gt;&gt;&gt; 100 29 ** 0.5 #&gt;&gt;&gt; 10.0 Bear in mind that I chose `29` because it's barely ever used; changing `1` this way just destroys everything. --- And here's a challenge. Try changing it *back* to 29.
This is interesting: $ python &gt;&gt;&gt; import ctypes &gt;&gt;&gt; class IntObject(ctypes.Structure): ... _fields_ = [ ... ('refcnt', ctypes.c_long), ... ('ob_type', ctypes.c_long), ... ('int', ctypes.c_int)] ... &gt;&gt;&gt; y = ctypes.cast(id(100), ctypes.POINTER(IntObject))[0] &gt;&gt;&gt; y.int 100 &gt;&gt;&gt; y.int = 101 &gt;&gt;&gt; 100 101 However ... &gt;&gt;&gt; x = ctypes.cast(id(1), ctypes.POINTER(IntObject))[0] &gt;&gt;&gt; x.int 1 &gt;&gt;&gt; x.int = 2 &gt;&gt;&gt; 1 Segmentation fault Perhaps changing 1 to 2 is a bit too deep for Python.
Same here.
I noticed you said "a sprinkling", I believe a decent user experience should use more than "a sprinkling". Basic things that should and can be done with JavaScript, form submissions, loading dynamic content, sorting tables, pagination, all of which generally require more implementation than a sprinkling of JavaScript. All of these obviously should fall back to non-JavaScript methods, but drastically improve the user experience, less of your users time wasted on them doing full page reloads for no reason. &gt; I've honestly never seen a user excited to see javascript on a website. Then your user base must be vastly different. Despite what you may believe, it *does* improve UX, in so many ways, a sprinkling or a lot.
You can always just use raw SQLAlchemy with Flask. Check out the flask-sa source code, it actually gives you very little except for some extra configuration conventions.
This was a fun exercise. I managed to do it just using ctypes. Integers in python 2.7 are stored as instances of PyIntObject structs [1]. typedef struct { PyObject_HEAD long ob_ival; } PyIntObject; To manipulate a struct with ctypes, you need to know and declare its structure, so we need to know what's in that PyObject_HEAD macro. The header is a macro defined in Include/object.h [2]. #define PyObject_HEAD \ _PyObject_HEAD_EXTRA \ Py_ssize_t ob_refcnt; \ struct _typeobject *ob_type; (the extra head stuff is only present in debug builds) So we can see the actual value of the int is stored in the third element of the struct, the `ob_ival` element after the refcount long and a pointer to the type. So now we can declare this struct in ctypes: import ctypes class PyIntObject(ctypes.Structure): _fields_ = [("ob_refcnt", ctypes.c_long), ("ob_type", ctypes.c_void_p), ("ob_ival", ctypes.c_long) ] And we can use the property that the `id()` function in CPython returns the object's address to, say, change the value of the int 666 to 777: &gt;&gt;&gt; myint = 666 &gt;&gt;&gt; myint_addr = id(myint) &gt;&gt;&gt; myint_struct = PyIntObject.from_address(myint_addr) &gt;&gt;&gt; myint 666 &gt;&gt;&gt; myint_struct.ob_ival = 777 &gt;&gt;&gt; myint 777 Again, no telling really how this may mess up the interpreter internals, but you *can* do it! Neat! Some credit goes to [3], which I partially used to figure this out. [1] http://hg.python.org/cpython/file/2.7/Include/intobject.h#l23 [2] http://hg.python.org/cpython/file/2.7/Include/object.h#l78 [3] http://pyevolve.sourceforge.net/wordpress/?p=2171 edit: lol &gt;&gt;&gt; PyIntObject.from_address(id(1)).ob_ival = 2 &gt;&gt;&gt; 1 Segmentation fault (core dumped) edit edit: it's interesting to see how other people did this. I never liked ctypes much -- I think the interface and documentation are unnecessarily confusing -- but we've all converged on almost the same thing. Also I didn't read to the bottom of that blog post in [3] to see yet another way of changing an integer value =) (I only got the trick of using id() with from_address() to get a python object as a ctypes type)
You can but part of the issue I'd see with this is if you change a model you're now changing 2-3 packages minimum. Adding more dependencies on the models increases the effort involved to make a change and like I said above there's other reasons you should share models.
&gt;Basic things that should and can be done with JavaScript, form submissions, loading dynamic content, sorting tables, pagination, all of which generally require more implementation than a sprinkling of JavaScript. No, they **shouldn't** always be done with javascript because it's hard to do it right, and it's very easy and EXTREMELY common to do it in a very broken way. To take one example - pretty much every instance of infinite scrolling (which appears to be fashionable these days) breaks horribly if there is an error with an XMLHttpRequest. That means the entire page has to be reloaded, and you have to scroll for 5 more minutes to get to, say, page 30 again. That drives me up the fucking wall. And for what? What is gained over having the regular non-javascript pagination? Nothing. The designer just thinks it looks cooler. To take another - in most javascript heavy apps, the URL can't be relied upon to be representative of what's on the screen. So, the sharing model which most users used to (copy &amp; paste the URL from the titlebar) breaks. This is now possible to remedy with HTML5 but honestly, I don't see as much evidence of that I should do. To take another - in many apps, if I lose internet temporarily and perform an action that does an AJAX request, it breaks the page entirely. That means refreshing the page and losing state. Worse, I get a cryptic message like "error trying to fulfil your request. please contact help if it happens again". Then there's the lovely sites that respond in exactly the same way if my session expires and I get logged out. In many (if not most) of the apps I use which commit these cardinal sins, I would far rather they had been done as 99% static sites that didn't try to be clever. Adding javascript just made them worse. It's not impossible to do a javascript heavy site well (gmail is one such site), it's just much harder than anybody thinks, and not at all common. Needless added complication, horrible corner case bugs just to make things look a bit snappier in demos is the norm. &gt;Then your user base must be vastly different. Despite what you may believe, it does improve UX, Despite what you may believe, it largely does not. There are some exceptions (I couldn't imagine doing a datepicker without js), but these are, as I said, sprinkles. I suspect you may not be paying attention to your user base. Either that or you vastly overestimate how much they care about the javascript on your site.
We've sent people in my office to Beasley's class, and I hear it's incredible. It's pricier than a lot of conferences, though, and if you're not near Chicago, it will involve some travel. We're in the greater Chicago area, so people have just opted out of a conference and taken 2-3 work days to do this instead. 
&gt;And here's a challenge. Try changing it back to 29. deref(id(29), ctypes.c_char)[6 * 4] = b'\x1d'
&gt;Full pagination reload will waste bandwidth and server resources as opposed to an Ajax one, is one reason. And if your userbase is mobile heavy, saving bandwidth is a great excuse. Which reminds me: I use opera mobile to save bandwidth - it saves a *lot* of bandwidth too. Needless to say, it does fine with most static sites, but it can't handle heavy javascript. &gt; All of these 'issues' are completely based on implementation. They can all be done properly Never denied it for a second. Like I said: gmail works pretty well. It's just more common for it **not** to be done properly. &gt;If you're having problems doing this then maybe you should top up on your javascript skills. Personally, I can program in javascript just fine, but I have inherited some real javascript messes that had absolutely no need to be done in javascript which have made my life a misery. Moreover, most of the time I see it used on the web, it's used badly. That is: the code I've inherited isn't abnormal in the slightest. In most of these cases, if the developers had opted for a simple static site, the user experience would probably have been mildly better. &gt;Also, the applications I work on are completely javascript based because of the requirements (web sockets etc, but that's a different story). I'm fully aware of my user base. It's possible it makes total sense for whatever it is you're doing. It just doesn't for most websites.
Just ran pylint and holy python o_o
Slightly more helpful than lmgtfy
I think the simplicity of python as well: "I learned that playing with language features in Python is much faster than in Scala. Much of the time spent coding in the Scala implementation involved an intricate dance with Scala's type system. While it's thrilling never knowing if your new tricks will allow you to save yourself from writing type-casing boilerplate, it takes a lot of time to convince the Scala type-checker that you're doing something reasonable in all cases." I know that personally, when I started using python, one of the advantage I immediately gained was that I started spending more time on my problem rather than fight with the language.
Well like I said, not all of it will matter but a lot of it will. Of course as a beginner it can be difficult to tell what matters and what doesn't and in those cases it's usually a good opportunity to take a step back and do a little research about something you might never have seen before.
The API design pattern can be applied to "classes". You have to define your model as an API, which means that the class can only change internals once it is set, until you need to update the version number. I can imagine some mechanism like this: import mymodule mymodule.set_version(1) # This exposes version 1 of your API from mymodule.models import MyModel # MyModel.method ...
Yeah you could do that but that seems less conventional than versioning the model package itself and letting either requirements.txt or setup.py dictate which version of the package to pickup. I still think that the REST api, which can be versioned too, makes more sense because it allows non-Python code to interact with the data which abstracts both the underlying data model and the infrastructure hosting it.
Using `ctypes` it's rather trivial. from ctypes import * p_null = POINTER(c_int).from_address(0) p_null[0]
If you're looking to beef up your stats/data analysis skills in Python, the [SciPy](https://conference.scipy.org/scipy2014/) conference is great, and will include two days of tutorials dedicated to scientific &amp; statistical computing in Python. The tutorial schedule should be announced within the next week or so. (full disclosure: I'm on the conference program committee) Also the [PyData](http://pydata.org/) conference series is pretty awesome, and happens several times a year in various cities around the world. The tutorials at PyData are generally shorter than those at SciPy, though. Edit: typo
I can confirm that [things break horribly](https://i.imgur.com/5Dx1sZU.png) when trying to change the value of 1.
Please, don't write code that changes the "global state" import Spinne Spinne.root = './files' # Assignment to a global This is a singleton, it's impossible to create a second instance.
Could try this: https://github.com/mitsuhiko/flask-sqlalchemy/issues/98
As my colleague says "Satisfy your customers in preference to your type system".
Whenever I have to do something at work, I consider whether it's possible to write something in Python. This sometimes winds up taking more time than doing it manually would have, but I find I'm much better at learning this kind of stuff if I'm doing it as part of tackling a specific problem as opposed to just doing random tutorials or whatever. 
One major downside for using Option 1, the shared model, would be that you have to version your model, and that may require your apps to carry around multiple versions of that model, or at least be aware that the application schema model might not match the current schema model in the database. How much of a burden this is depends on how many applications you intend to use this new model package with and how much churn the database schema will go through throughout time. You'll almost certainly want a simple static table/column in your database that your applications can use to query for the version of the model that is currently in use in the database. In the simplest system this means that your app will be able to notify a user that 'their database schema requires an update to use your app'. For actual transitions you probably want to use something like [Alembic](http://alembic.readthedocs.org/en/latest/) at that point. You could also run multiple versions of your schema in a single app such that you can operate against multiple database versions, but that can get complicated very quickly, and debugging becomes more difficult. I wouldn't be so concerned about using regular SQLAlchemy with Flask-SQLAlchemy, it's a little different, but it's not *that* different that it should be a major decision point. You'll spend a day or so (at most) figuring out how to [wire regular SQLAlchemy into Flask](http://flask.pocoo.org/docs/patterns/sqlalchemy/) and then you get the benefit of having less magic between you and the [SQLAlchemy documentation](http://docs.sqlalchemy.org/en/latest/). The second downside to using Option 1 is that if you ever decide to write an application using this schema in a different language, then you will have to duplicate the schema in that language as well. This isn't something that is thought about too often, but languages do change, and sometimes it's nice to have the flexibility to write part of the application in one language and another part in another language. Usually what prevents this is coupling a visual interface too tightly to the non-visual business logic. The upside to using a database schema across applications is that you get the ability to use all of SQLAlchemy's features across both apps without having to create a new API interaction layer for doing so. The benefit you get from being able to do this will vary quite a bit depending on your what your apps will do, but if you are doing anything involving transactions or locking then it could be nice. Ultimately the best solution is probably to do an API that isn't just the model (tables and columns), but actually the business logic of the application you are trying to write. Think of it kind of like a non-visual application whose interface is the API itself. On top of that you could implement pretty much anything while still keeping your business logic and model centralized and [DRY](http://en.wikipedia.org/wiki/Don't_repeat_yourself).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Don't repeat yourself**](https://en.wikipedia.org/wiki/Don't%20repeat%20yourself): [](#sfw) --- &gt;In [software engineering](https://en.wikipedia.org/wiki/Software_engineering), __don't repeat yourself__ (__DRY__) is a [principle](https://en.wikipedia.org/wiki/Principle#Principle_as_axiom_or_logical_fundament) of [software development](https://en.wikipedia.org/wiki/Software_development_process), a principle aimed at reducing repetition of information of all kinds, especially useful in [multi-tier architectures](https://en.wikipedia.org/wiki/Multi-tier_architecture). The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system." The principle has been formulated by [Andy Hunt](https://en.wikipedia.org/wiki/Andy_Hunt_(author\)) and [Dave Thomas](https://en.wikipedia.org/wiki/Dave_Thomas_(author\)) in their book *[The Pragmatic Programmer](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer)*. They apply it quite broadly to include "[database schemas](https://en.wikipedia.org/wiki/Database_schema), [test plans](https://en.wikipedia.org/wiki/Test_plan), the [build](https://en.wikipedia.org/wiki/Software_build) system, even [documentation](https://en.wikipedia.org/wiki/Software_documentation)." When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in [sync](https://en.wikipedia.org/wiki/Synchronization). Besides using [methods](https://en.wikipedia.org/wiki/Method_(computer_science\)) and [subroutines](https://en.wikipedia.org/wiki/Subroutine) in their code, Thomas and Hunt rely on [code generators](https://en.wikipedia.org/wiki/Automatic_programming), automatic build systems, and scripting languages to observe the DRY principle across layers. &gt; --- ^Interesting: [^Django ^\(web ^framework)](https://en.wikipedia.org/wiki/Django_\(web_framework\)) ^| [^Ruby ^on ^Rails](https://en.wikipedia.org/wiki/Ruby_on_Rails) ^| [^Single ^Source ^of ^Truth](https://en.wikipedia.org/wiki/Single_Source_of_Truth) ^| [^Code ^reuse](https://en.wikipedia.org/wiki/Code_reuse) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch3jtjr) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch3jtjr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Is it considered bad practice to post your own work here? I did not know. Thank you for an otherwise insightful comment. I blog to keep track of my own learning process. I considered posting at /r/learnpython but found it is purely for asking questions.
It's tempting to use your database for messaging, just because it's there. But unless it's just for reporting, it creates major problems down the line. When you want to do a big refactor later on (and you will) you'll be in trouble because you'll have to make changes to multiple codebases in parallel. Depending on your usage, there's a room to create all kind of concurrency bugs with the approach also. Have your schema owned by one and only one application, and then talk to the application that owns and defends it. If you're using python, it's easy to get started with xmlrpc between processes. Or have file writers/readers if you need async. rest is fine too.
Your text is [mojibake](http://en.wikipedia.org/wiki/Mojibake)d. For example, rather self-defeatingly, the string that you want to say "strings are now utf-8 μnicoΔé!" says "strings are now utf-8 Î¼nicoÎ”Ã©!" You didn't declare a character encoding, so Chrome (at least) is using the bad old default of ISO-8859-1. You should have your web server send this Content-Type: Content-Type: text/html; charset=UTF-8 If that's too hard to change, you can also set it with this tag in your `&lt;head&gt;`: &lt;meta charset="utf-8"&gt;
sys is basically already there. `import sys` just drops `sys` into the current namespace. If it wasn't already there, it would be impossible for the import machinery to interact with `sys.path` and the like.
Try to get them to buy you plane tickets to a big Python conference - lots of material but crucially lots of motivation and similarly-minded people.
Don't keep us in suspense man, did Windows find a solution to the problem?
ok thanks for the tip!
No problem. Here's an example I just remembered: needing to do stuff to spreadsheets that goes beyond simple wide/long reshapes. (I suspect some of what I wound up doing could have been done with Excel pivot tables, but he.) Just be sure to save as .csv if you're usually working with Excel (you can get modules to import .xls/.xlsx but it's easier to just save to .csv).
Well, no, that window eventually froze and I had to close it via the task manager.
I've taken Dave Beazley's intro class (remotely). A lot of fun and the exercises are really nicely paced. David was great ... really easy to listen to and learn from. I'd highly recommend it.
Thanks for your help.
I only reimplemented this bash script in pure python http://stackoverflow.com/a/5177027/1695680 Try asking Walker Hale IV, I just wanted to skip bash for platform independence .. and fun.
An organization on github where we'll put our projects.
A bunch of my coworkers and myself took dave's classes (both intro and masters) i found the exercises to be great. My one word of caution is he does deep dives in inner workings of python. You may or may not care for your uses.. It takes up a 1.25 days and some of my co-workers felt they wasted their time/money those days. 
Please send us a mail on atechsmail@gmail.com with more information.
Is it undefined, the language specification doesn't say what should happen then. It could be entirely different in Jython
With a rest api you'd never be able to subclass anything or override any methods, you have the overhead of requiring an http layer and in parsing the return serialization format, it's much more difficult to construct ad-hoc queries, you lose all the lazy relationships, can't easily get fine-grained control over your transaction/commit strategy, do dirty checking/history/events in the sqlalchemy layer...
Post your code? Multiprocessing should work the same on PyPy. Also instead of hard coding 4 processes in your multiprocessing pool use 'multiprocessing.cpu_count() + 1'
Put nginx in front of it. This is good for a lot of reasons, one of which is nginx can terminate SSL connections.
updated the post with it 
Thanks, I must have forgotten the charset! Will fix it later!
Can you use a github gist, I'm on a phone. Also use multiprocessing.Pool
What this guy says, SSL termination should be handled before it reaches your application layer. The way OP is handling it now is putting libraries on top of libraries to handle security which, generally speaking, is not a good practice to get into. This is especially true if your application layer is something like Python where it's easier to work around a security implementation. Also, it doesn't have to be nginx either. Other web servers such as apache would work too of course.
Hey quick question... I'm just cleaning up my bitbucket repo for the project, but would you like to view the repo to get a sense for what is in the current design I have in mind? Bear in mind, I'm shit at both Python and Javascript, but it might be useful a little bit? 
It's an amusing joke. ^^^Just ^^^like ^^^Haskell. ^^^^Please ^^^^don't ^^^^monad ^^^^me. ^^^^^It's ^^^^^just ^^^^^a ^^^^^joke, ^^^^^for ^^^^^Curryst's ^^^^^sake. ^^^^^^Much ^^^^^^like ^^^^^^static ^^^^^^typing. ^^^^^^^Hey, ^^^^^^^is ^^^^^^^that ^^^^^^^referential ^^^^^^^transparency ^^^^^^^in ^^^^^^^your ^^^^^^^pants ^^^^^^^or ^^^^^^^are ^^^^^^^you ^^^^^^^really ^^^^^^^glad ^^^^^^^to ^^^^^^^see ^^^^^^^bad ^^^^^^^puns? ^^^^^^^^I'll ^^^^^^^^pattern ^^^^^^^^match ^^^^^^^^myself ^^^^^^^^out. 
Okay, so how *do* you change a number back to itself when changing something?
I agree that short circuiting like you describe is both convenient and clean. In the example, though, he takes it a step further and uses short circuiting to select between two variables. That to me is difficult to read. 
I know this is the the preferred way to run python wsgi apps currently problem is I think it would mean reworking sessions and I am on windows (mainly because I need access to the word api). I know this is one possible solution and their are good reasons for going this route but the change would create a lot of additional work. I am against a deadline and pretty close to putting this app into the wild if I can get this heart bleed issue taken care of.
like the limit of the result can not top over 999
I am already running the windows distribution for 3.3.5 I could go with 3.4 but I am dependent on Oracles MySQL connector and officially it only supports up to 3.3 at the moment. 
Has it ever?
Ouch, $2500. Be grateful that your employer does that. It sounds amazing and I'm in the area... but there's no way I'd be able to talk my employer into giving me the days, much less pay for some part of it. 
Versioning your api is the best bet if at all possible. Obviously drastic changes to the database could make this difficult. I developed and maintained a web service for multiple applications and versioning was beyond helpful. It takes time to update applications. If you can update the API and then the consumers at different timed you really make things easier for yourself. This doesn't change much but will change what you are willing to do and when. I've held back changes and made them into multiple smaller changes to ease the pain. Everyone involved was much happier to make a few smaller changes than one major one. Last thought, if you are sharing a model you already should be splitting it into an api of some sort. It'll help when you need to block certain actions happening because of business logic. I've implemented both REST and SOAP APIs and found them very helpful. Sounds like you'd do best with a REST API though.
I did similar tricks when solving some academic problems because sometimes the auto grader will return a few different error messages such as Compile Error, Runtime Error, Wrong Output, and Segfault. The trick you can do to see which branches your code takes is to write code that produces a different error. So if you have three conditions on an if statement, you can split that into three different if else blocks and then have one print bad output, one cause a runtime error, and one produce a segfault. This is really useful when the code seems to work on your machine but not on the grading machine. Well anyway, the easiest segfault in python (in my opinion) is just import sys sys.setrecursionlimit(1&lt;&lt;30) f = lambda f:f(f);f(f) because to me, the concept is very simple to understand and the to recall when you don't have any documentation on hand. But if you wanna see more, there is a wiki page about it here https://wiki.python.org/moin/CrashingPython
Ah, nice, thanks for the release! I haven't used Pandas yet and this looks dead simple, will have to give it a spin sometime.
That's a sexy shell modification. Have a link?
Sure, it's called [cmder]( http://bliker.github.io/cmder/) and is effectively a console emulator. 
It's a great self teaching project. But it never reaches functionality of really extensible editors. Using it is a simple time waste.
Oh, sorry, I guess I got something mixed up there. My Windows theme is called [Bello](http://kiko-knows.deviantart.com/art/Bello-346067953) and is available for Windows 7.
What is the difference to the array + memoryview approach?
I'm curious if [airpair](https://www.airpair.com/) is any good. Anyone used this ?
No one really uses filter in python. List comprehensions are usually shorter and clearer. sum( x for x in range(1000) if x % 3 == 0 or x % 5 == 0 )
FWIU, Python 2 compatibility. https://github.com/alex/zero_buffer/blob/master/zero_buffer.py
Python
I'm into the idea of building a unity-style editor (for complex 2d physics games) but I'd like to do a couple of simpler small things on the way. Serialising to JSON sounds great. Thanks for the tip on manually moving cymunk bodys, I am currently just changing velocity and using joints but that info will soon be very handy. I am on (k)ubuntu - the sound is not just kivent, but all kivy for me. Though forcing kivy to use sdl audio in main.py works for now. I've just forked and cleaned up my changes a little, I'll send you a little pull request now (though, of course feel free not to accept as is)
&gt; You might be able to guess the company US Govt? ;)
I've taken 3 or 4 advanced classes with Dave and had my mind blown every time (and I already know Python inside &amp; out). He's an amazing teacher - worth every penny. Just be prepared to work harder than you have in years. ;-) 
why is it getting downvotes???
Downvotes are used when the comment adds nothing to the discussion. OP's comment is nonsensical and redundant, adding nothing to the discussion, hence getting downvotes.
I didn't know that parsing was so 'simple'. This type of packages opens the gate towards open-source voice input in Siri/Google Voice/Cortana style. Thanks for posting this!
There is really no way to avoid needing to manage your versions in situations like this. You are either going to need to version the rest API or the package with the SQLA model definitions. Also, you are going to need to consider how much data you are sending over the wire and how it affects performance. You'll probably need to consider restful pagination and 'summary'/lightweight versions of your resources as well. Next, how will you deal with feature / requirements drift? This goes back to versioning but it is something to consider. Personally, I've done both. My default is to throw up the rest apis but if performance becomes an issue I'll split the models into their own namespace package and distribute it.
Add your new account as an owner on https://pypi.python.org/pypi?:action=role_form&amp;package_name=your_package_name_here (note: edit URL) then remove the old account name
Happy to. Summation of a series of integers from 1 to n is easily performed by figuring n(n+1)/2. It's also fairly easy to move on from that and see that if you want all multiples of 3 less than n, you can take the summation of 1 to n/3 and multiply that by 3. So it's fairly trivial to get the summation of all integers from 1 to 1000 that are multiples of 3 and 5 - of course, you'll have added every multiple of fifteen twice, so just calculate 15 * sum(1,n/15) and subtract it from the total. Doing it this way allows your program to solve a generalized version of the problem much quicker for larger values of n. It seems petty and trivial for problem 1, but there's a problem much later on where understanding this is key. Anyway, the code is below, try comparing execution times for very large versions of the problem. def qsum(a): return a*(a+1)/2 def euler1(n=1000): return 3*qsum(n/3) + 5*qsum(n/5) - 15*qsum(n/15) print euler1()
There's a Python track at [OSCON](http://www.oscon.com/oscon2014/public/schedule/topic/1128) in Portland in July. Edit to say OSCON is big conference that covers a lot of other things, so many opportunities to learn and socialize. It's a nice venue, walking distance to several hotels, and Portland is quite nice in the summer. Well worth attending.
That is amazing, thanks for sharing it!
Very cool app!
Thanks a ton!
Inspiring and easy to follow. Thanks!
Thanks, I think I like the format of "Saturday morning hacks" and might try to do one or two other similar posts. Glad you found it inspiring, that was totally my hope!
Unfortunately the windows build of python 3.4.0 on python.org was built before openSSL was fixed. I am kind of surprised there has not been a new build put up yet I can't be the only one hurting for an update. There is a fixed build @ http://p-nand-q.com/python/python-builds.html but its built with vs2013 and python 3 is standardized on vs2010
seems to be more js than python 
Looking at the source of Python2's `json` module, it reads the entire thing into memory before parsing. That's clearly not going to work out with API responses in that size range. You are going to need a stream parser that doesn't load it all into memory. Just off the top of my Google, [ijson](https://pypi.python.org/pypi/ijson/) and [jsaone](http://pietrobattiston.it/jsaone) come up. If you're just parsing and dumping to a database, the event-driven mode of ijson looks like it might be what you need.
Haha yeah good point I didn't even think about that, there are probably about equal lines of code for each. Not sure I understand the point of your comment, though. 
i suppose my point would be that the title mentions flask, but the article has more js than flask. So the point that it was written in flask might seem kind of secondary. though I suppose one might consider it a strength of flask that the interesting stuff is written in js and not python. 
Sure. For now, all I'm doing is parsing and dumping into a database (as /u/axonxorz said below). So in that respect I definitely do not need the whole file available in memory, just dumped into the database. I hope this clarifies.
You can try [Brief Tour of the Standard Library](https://docs.python.org/3/tutorial/stdlib.html) and [Brief Tour of the Standard Library – Part II](https://docs.python.org/3/tutorial/stdlib2.html). You should also search for "Python standard library by example".
If you'd like to see it running, I threw a copy of the code up on pythonanywhere.com: http://beetlejuicer.pythonanywhere.com/
Code is emo poetry.
It /is/ pretty expensive for a 250 page book. Compare it to the Python Cookbook, which is the same price, but has mad content. The author is dreaming a bit. 
I would consider that a weakness, though not of Flask. I prefer to avoid JavaScript altogether, but it's unavoidable in any site that isn't static.
avoiding javascript will soon make it really easy to avoid employment all together. :)
I think you could run tokenize and just check whether the token string is `?` (strings would have their quotes in the token, so `'?'` wouldn't match). I just used `str.replace()` for now because it's easy.
I may or may not have deleted everything on the page without thinking. I am sorry for your loss.
My guesses would be that it should be posted in /r/learnpython and the fact that there are ZERO comments in the code.
Well I did get an official response on this issue from comp.lang.python &gt;The current release of Python 3 is 3.4.0. A 3.4.1 maintenance release, with OpenSSL updated in the Windows installer, is planned for final release in mid-May. Python 3.3.x is now in security-fix-only mode which means only source fixes for security problems are released as needed and no further binary installers for Windows or OS X are produced. (The Python 2 Windows installer is not affected since it bundles an older, pre-heartbleed version of OpenSSL.) 
that's pretty much on the job training/inventing. I would be very surprised if any college curriculum has caught up to that yet. my advice would be to keep reading and playing with the tools that are used to solve those problems. but beware of pre-mature optimization. ie: your blog doesn't need it's own data center even though you might know how to scale it that big. 
Oh crap I'm sorry I thought that was where I was posting. 
Meh, no biggie. But yeah dude, no ones trawling through your code without comments, especially if you need advice on how to improve it. Comments will tell the reader what you think it's doing, which will be flags to the reviewer where you went wrong. Take this example: # iterate from 1-100: for i in range(100): (Please don't comment something that obvious though)
Ok, thanks for the advice :)
Funniest thing I've read all day. &gt; BozoCrack is a depressingly effective MD5 password hash cracker with almost zero CPU/GPU load. Instead of rainbow tables, dictionaries, or brute force, BozoCrack simply finds the plaintext password. Specifically, it googles the MD5 hash and hopes the plaintext appears somewhere on the first page of results. It works way better than it ever should.
[The Python Standard Library By Example](http://doughellmann.com/pages/python-standard-library-by-example.html) looks good (though I haven't bought it) and [Python module of the week](http://pymotw.com/2/) where Doug Hellmann originally wrote those exercises is also helpful.
I looked at the [O'Reilly python course](http://www.oreillyschool.com/individual-courses/python1/) but didn't end up doing it. I should have done it because my employer was willing to pay for it. They did get me a http://www.lynda.com account. I haven't done the python courses but I did find the videos I watched on that site helpful.
Forgive my mental blank - this is searching for unsalted md5 passwords right?
Your username probably isn't helping with the downvote brigade.
Something that relates to them. I don't know how old they are, but with older kids interested in sports, you could do some (very) rough games analysis on real data, and get them to get Python to work out the best player. The emphasis here would be web scraping, and analysing data, and perhaps data persistence. You don't need to go very far in the actual analysis, it could just be a case of finding the player with the largest goal difference or other such characteristic, but it would be interesting and relevent.
Thanks for this, they are 10-12 or so. This is a great idea and I think it can give me a few more ideas :D 
&gt; I read the High Scalability article on WhatsApp and realized those are the kinds of problems I want to help solve on a day to day basis. Go to CS university since this where you learn how to solved these problems. CS university is not a waste of time, it is the place where you learn how to code in 4+ languages, tons of compiler theory and algorithm theory. Every day I use my knowledge I acquired in CIS school. 
What's your background and experience? Do you know anything about how HTML works? For a simple HTML site, you wouldn't even need Python--just HTML. For example, you can create an html file: &lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;Hi&lt;/title&gt;&lt;/head&gt; &lt;body&gt;Hello World!&lt;/body&gt; &lt;/html&gt; Save it locally and open it using a browser (For example, file:///tmp/code/t.html). If you want an html full of images, just use the &lt;img&gt; tag and add images. I suggest you read up HTML tags. Regardless of whether or not you're using Python, you'll still need to know HTML. Python comes into play when you want to *serve* the file over a *network*. What this means is that your local computer will wait for external (possibly local) requests and respond to that request. Responses can be of several things, most simply consisting of a response code (valid or invalid), and a body, usually something that the web browser understands, HTML. This body of text could either be generated on the fly, or statically (via a .html file that the server has access to). Either way, the body is usually syntaxed in HTML so that the web browser can understand and render it. (Sometimes it's not, but let's not go there for now...). I suggest you start by playing around with Python's built-in [HTTP server](http://www.linuxjournal.com/content/tech-tip-really-simple-http-server-python). There are, of course, lots of cool things you can do beyond this simple server (Django, CherryPy, Pyramid, Mako for templating, etc.), but from your post it seems like all of these are overkill--in fact you probably don't even need Python. 
My username has nothing to do with this thread...
Beautifully simple.
Right, but that doesn't mean that you should be using salted hashes instead of bcrypt Seriously, use bcrypt. Don't write your own password hashing. Please.
This is god damn hilarious. 
A global, or singleton is something you want to remain the same across multiple objects, aka instances of a class. Actually, if you have multiple servers you may want to individually change the root folder for each, in which case root should be a class variable not a global. Same issue here: def do_GET(self): global Handler, path # Setting the handler to self (BaseHTTPRequestHandler) Handler = self # Setting the path to self.path path = self.path 
Are you talking about attending university for a formal CS degree or something on the web? I would but I went to university for unrelated degrees and just don't need any more crazy student loan debt (not that they'd want to lend me any more money anyway)
No need to explain how HTML works, I've written a couple simple sites in DW before :) I have experience in HTML field. I've been working in Python for a while now especially since I purchased a Raspberry Pi 4 months ago, I didn't go that far with it thought. So now I'm willing to kind of combine these two fields. My other question is wether I can include Python in the &lt;script&gt; tag like so: &lt;script type="python"&gt; &lt;/script&gt; And wether it will run on any browser. (Do browsers have a python compiler by default?) I'll certainly check out the Python's built-in HTTP server. Never heard of it before.
no. bcrypt, scrypt, pbkdf2. sha* and the like are too fast for passwords.
Nope! SHA and its ilk are designed to be fast, which is the exact opposite of what you want from a password hash. Use (salted) bcrypt, scrypt, PBKDF2 or similar. An effective way to store passwords in a db is to store them as: {algorithm}:{salt}:{hash}:{iterations} so you can detect the algorithm at runtime, and update to harder hashing over time. Django and other frameworks do this automatically for you. 
Wrong. You don't want a fast hashing algorithm. 
The one downside of bcrypt is don't use it for long passphrases. bcrypt truncates input at 72 bytes (and specified it should be shorter than 56 bytes). SHA256crypt, SHA512crypt or PBKDF2 are good options. (SHA512crypt is not SHA512, its about a configurable number of rounds of SHA512, typically 5000).
Why, what is Ruby like? I've never used ruby.
&gt; No one really uses filter in python Uh, citation majorly needed
I completely agree that it is scarily good.
Oh I agree, bcrypt is what I use by choice. 
This pretty much covers how to store a pssword: http://codahale.com/how-to-safely-store-a-password/
They're large enough for that. Most organizations don't reach that scale and the number 1 rule of development: no premature optimizations. 
Even if you don't get a degree get a diploma or certificate. Most job descriptions ask for a degree or equivalent school plus experience. Having that piece of paper should be enough to get you some interviews. Your self taught stuff will hopefully get you hired. 
Whoops! Thanks, it was a silly copy/paste error!
except it pokes inconvenient holes in those claims that django scales, because it doesn't. 
Questions like this should be posted in /r/learnpython. As you surmised, there is a much better way to do this with the modulo operator. def is_int(x): return x % 1 == 0 Even ignoring the conditional itself, this: def foo(x): if x &gt; 10: return True else: return False Is actually the same as this: def foo(x): return x &gt; 10 Additionally, say I want to get the last item in a list (or the last character in a string), you can actually just use a negative indice. &gt;&gt;&gt; foo = "apple" &gt;&gt;&gt; foo[len(foo) - 1] 'e' &gt;&gt;&gt; foo[-1] 'e'
Some things to know about strings: 1. str(0) is the same as "0" 2. The string indexing you do can be simplified in python as "str(x)[-1:]" And my first thought about how to do this is given the question they ask: return x - int(x) == 0
Thanks, I set up a reverse proxy in IIS and everything appears to be running fine now.
Absolutely! The PHP team deserve kudos for making the tough decisions simpler for people. &lt;snark&gt;Now they just need to deprecate the rest of the library.&lt;/snark&gt; 
Imageboard? Somewhat like Pinterest? As you mentioned "site" ... I am considering it's a web app. Try going with the Flask.
For those of you who are curious, apache-libcloud powers [Salt](http://www.saltstack.com/community/).
Yup .. I use it as quick reference
iZ}dw~T;4y-4fJve6TBD is hard to remember. You should try https://github.com/ikkebr/pyxkcdpass