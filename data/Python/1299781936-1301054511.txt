I've [opened an issue](http://pytools.codeplex.com/workitem/13) for this on CodePlex - feel free to vote for it. 
See what I said [here](http://www.reddit.com/r/Python/comments/g0bke/python_tools_for_visual_studio/c1k43ow) about PyCharm. I'll admit I've not tried Wing, but much of what I said about PyCharm is applicable to Wing. PyDev, bleh, I *really* am not a fan of Eclipse. Every time I've used it I find it a bloated nightmarish mess. 
If you're just trying to get to/from the Hyatt, MARTA is your friend. Parking at the Hyatt (or in any of the garages around it) will run you ~$25/day and I'm not sure if it allows in/out. There are a few open lots that are much cheaper ($5-$10 per day) but they are less secure and usually fill up quickly. You can get to a fair number of interesting places on public transit, but it definitely limits your options. Most of the more interesting places are easier to reach via car, but Atlanta can be hard to navigate if you don't already know where you're going (the major thoroughfares are generally well-marked, but some of the surface streets are just odd). If I were you, I'd probably take MARTA (the unlimited 7-day pass might be a good choice) to the con, and then go in w/ people you meet on cabs to places you're interested in going if it's not easily accessible via MARTA. Be sure to check out the Public Transit directions available on Google Maps. FWIW, I'm a local from a northern suburb, and after the gouging I took on parking to volunteer on Tuesday, I'm probably going to be taking MARTA down to the con myself. UPDATE: I should have mentioned this before, but there's a lot of activity on convore: https://convore.com/pycon-2011/
Wing , at least in windows , offers very good dark themes. 
If you were at pycon you'd be learning this right now
One aspect of decorators that not many people make use of is that decorators don't have to return a new function; they can return the same function. This gives you the opportunity to attach some information to function attributes. Here's an example that adds a function attribute to a 'view' function, for some fictitious web framework: def render_with_template(template_name): def decorate(f): f.render_with_template = template_name return f return decorate @render_with_template("front.html") def view_front(request): return dict(name="Will") Presumably the web-app would know to look for the 'render_with_template' attribute when rendering the view. The advantage of this over having the decorator render the template itself, is that the function hasn't changed; it can still be used to retrieve a dictionary, which means you can call that view function if you want to build on the data it returns. Another advantage is that it doesn't change the function signature, so documentation tools like sphinx work as before. I really wish Django worked this way...
Interesting. how do you do the abstracting ? 
A word of warning: The Clermont Lounge is decidedly NSFW. Research at your own risk :-/
I went through the same thing, I started programming in Common Lisp years ago, and was a total Lisp evangelist. After a few years I started to learn Python, to make fun little web toys and what have you. As I got more familiar with Python I began to transition over, until finally I tried to go back to CL and I found that the code was just unnecessarily obtuse, and yes, finally, the parentheses did start to get to me. I think CL is an incredible language, but not one I would consider using anymore in any productive capacity. Python is all I need &lt;3
I was at a python meetup for a talk by one of the developers of pypy. He mentioned that pypy is ready for production use. I tested it on a software that parses large html files and massages the data. It runs twice as fast on pypy. I have asked all my users to use pypy instead of python. 
Should (presumably new) developers who don't understand decorators pay entry to a place like pycon? This is a sincere question... I've never been myself, but my guess is "no."
I love functional programming, but matching parens is a pain. This is why I go with Haskell. Hoogle is the killer feature for me. Python's growing on me. Maybe by Python 4 I'll love it more than Haskell. If PHP is the quick-n-dirty language, then python is the quick-n-beautiful one.
I'm not a primarily a python dev, but rather tinker. I have found pycon extremely useful in seeing what is possible in python and what I need to research. I just saw decorators in an Intermediate Python tutorial, and there were two beginner tutorials yesterday (which I didn't attend), so I get the feeling that there is the full range of brand new to python to full time python devs.
I tried scrapy, but think it overcomplicates things.
use spaces?
Of course, solutions to this problem exist, but I prefer not to use them...
I recall coverage.py getting a huge speed improvement by switching from "foo" + "bar" to "".join("foo", "bar") when generating reports. So is that SO best answer really the best one?
I like Python. I used to love Python. Then I discovered Haskell. I rarely turn back to Python, except for a few-liners in the interactive shell. I still have many more years of Python experience than Haskell experience, so when I want to whip up something small real quick, I am still quicker in Python. When something is even a little bigger, I am already quicker with Haskell. With Python, I get elegant, concise code but I pay for it with more dynamism and less "reliability by default". With Haskell I get the same conciseness and elegance (and often even more!) but without sacrificing performance. Haskell is proof that static typing doesn't have to suck, and there is little reason to give it up.
Alright... alright... And they even offer [native packages for a variety of distros](http://www.wingware.com/downloads) which is a *huge* improvement over PyCharm's tar-blob... So I'm downloading it and trying it out... :-)
Take a look at [s3cmd sync](http://s3tools.org/s3cmd-sync). It does this for you.
That man should write a book. Now that I'm thinking about it, I would be surprised if he hadn't.
It's more of a life lesson and a rite of passage more than anything else. :)
Yeah it is. My son also calls lettuce "salad" when it is on a sandwich.
I believe Pyramid works this way. 
The answer is "yes". There's a plethora of sessions for absolute beginners at pycon
Django-annoying has an implementation of this called render_to. https://bitbucket.org/offline/django-annoying/src/a0de8b294db3/annoying/decorators.py#cl-25
I was hoping for the actual presentation. 
Every time I try to learn Haskell, I feel it would be really great if I was smarter. It's a cool language, but I have yet to get over that initial barrier. I love Python. I do most of my work in Common Lisp, and I love that, too.
Two things that are _very_ useful in writing simple, clear code that does complex things: 1. Good libraries. 2. Lisp-style macros. Which is more helpful depends on what libraries are already written in a given language relevant to your task. (Of course, many of those libraries could be better-written in Lisp, but that's not what determines (or should determine) what language a library gets written in.)
awesome thanks :)
You can use the good ol' InventWithPython.com tutorials. With [chapter 17](http://inventwithpython.com/chapter17.html) they begin using Pygame. 
I just started learning both python and pygame for kicks the other day. The first think I made was this https://github.com/andrewroycarter/pykhet which is based on this http://www.khet.com/ game. The documentation that pygame provides is very good and was all I need to get started. I'd say just download that and you'll be set! I know what I made isn't anything fancy or flashy, but I think it turned out pretty cool and it was easy to make! Good luck!
iPython isn't stable for Python 3 yet, so this offers a great workaround in the meantime.
oh, that makes sense
I hate to be a downer, but that's a really bloated A* implementation. The beauty of python is that you could write it in much, much less, and have it elegant too.
This should insert a tab or do a completion appropriately. Just insert into the .pystartup file referenced in the article: completer = readline.get_completer() def new_completer(text, state): if state&gt;0: return completer(text,state) elif text.strip()=='': # Insert a tab if there's nothing but whitespace on the line return '\t' elif text == completer(text,state): # Insert a . if there's nothing to complete to. May want to change # to a tab or nothing. return text+'.' # Default to normal completion return completer(text,state) readline.set_completer(new_completer) readline.parse_and_bind('tab: complete')
It doesn't do telnet :(
And just to nitpick a bit more, G and H in the A* algorithm shouldn't be called "variables". G and H are functions that take states and give the cost from the initial state to the current state (G) and an admissible estimate of the cost from the current state to the goal state. Actually one more nitpick: It seems that the get_next_cell function is simply searching through the open list with a complete traversal of the list... A* is supposed to be implemented with a priority queue!!!
You should try Scheme.
I have also tried scheme, but python has great libraries and almost every unix system comes with some version of python installed. This keeps me from using scheme in any serious manner.
If you also call lettuce "salad" when in a salad, you get a recursive salad!
&gt; Lisp-style macros. Are you sure that lisp-style macros are really that important if you have first-class functions? As I understand it, they are only useful in removing a bit of syntactic clutter, and it's not enough to get Lisp ahead of Python in the end, to put it mildly!
Any data structure which is sorted and the sorting is done efficiently is fine for A*. Simply looping over a python list, which as far as I can tell, is not sorted, is not OK.
Design an object system using just first-class functions. Then, design a contract system with just first-class functions. Then, write something that automatically transforms some code to CPS, using just first-class functions. Or, add a static type system on top of Python, with just first-class functions. You might say "Python already has an object system!!!" (which is still inferior to CLOS). Ok, you can skip the object system part Replace it with "achieve lazyness with only first-class functions". (this would be simple, with *proper lambdas*)
I'm in the ballroom, pretty much dead center (red hair, brown leather jacket, holding a macbook) if anybody wants to meet so we can put faces with reddit nicks.
&gt; Every time I try to learn Haskell, I feel it would be really great if I was smarter. It's a cool language, but I have yet to get over that initial barrier At first, it seems like it requires a lot of smarts and difficult, especially since no other programming language seems to be this difficult to learn at first. But in actuality, it is really just very different from what we're used to in almost every other language. Also, Haskell is built upon a smaller core than Python which is more abstract (Untrue for CL, though, I believe). This means that for Pythoneers, the things that you're used to being primitives are implemented as libraries in Haskell, upon more abstract primitives. I think this is great (as it means you have power to add primitive-like operations) but it also is more difficult to learn: Instead of learning a bunch of primitives "while", "if", "for", etc, you learn a couple of more powerful primitives (recursion, higher order functions) **and** how they are used to implement the primitives you are used to. For the "basic" stuff, this seems unnecessarily tough. But it is actually simpler, from a language design POV, and facilitates much more powerful advanced techniques. Did you try learning from [Learn you a Haskell for Great Good](http://learnyouahaskell.com)?
Wait, wait. The quote I responded to was: &gt; Two things that are very useful in writing simple, clear code that does complex things I don't want to discuss things like rolling out your own object system, CPS transformer, static type system or such. And if I wanted, I'd point out that a) it's better done as a patch to the core language or at least as an honest to god bytecode transformer rather than a loose collection of glorified string substitution hacks (I've heard that CLOS is just as ugly as Boost on the inside btw, which is not surprising given their extremely similar natures), b) and in close collaboration to what passes as the governing body of the language itself, aiming at eventual merging of the code into the mainline, to avoid proliferation of buggy incomplete toy implementations used by one and a half persons each. But that's not what I wanted to discuss. I want to see how macros make life sufficiently easier for application programmers, besides removing a bit of syntactical clutter. For example, when I want to make some value lazily initialized, I have to write a trivial constructor and add a pair of parentheses to each use of that value. Yes, it would be nicer if I didn't have to add these extra parentheses. No lisper is in position to gloat about this unfortunate limitation, sorry.
Looks really great. One question: Can the debugger somehow be used with an IronPython scripting host in a C# project?
Hi, I'm a Scrapy developer. Could you provide more feedback on what parts you think it overcomplicates?. We always tried to make things as simple as possible (but no simpler ;). Of course it's no silver bullet for scraping, so it may be the case that it doesn't meet the needs of your project.
&gt; at least as an honest to god bytecode transformer rather than a loose collection of glorified string substitution hacks Oh my. No comment. &gt; I've heard that CLOS is just as ugly as Boost on the inside btw, which is not surprising given their extremely similar natures Take a look at TinyCLOS, its source can't be cleaner. &gt; b) and in close collaboration to what passes as the governing body of the language itself, aiming at eventual merging of the code into the mainline, to avoid proliferation of buggy incomplete toy implementations used by one and a half persons each. Why don't we merge *everything* in the core language, instead of having seven different buggy incomplete toy web frameworks used by one and a half person each? What's the difference between an object system and a web framework? &gt; But that's not what I wanted to discuss. &gt; I want to see how macros make life sufficiently easier for application programmers, besides removing a bit of syntactical clutter. Those things are strictly related on how macros can make your life easier. The guys at Naughty Dog wrote Uncharted using their FSM DSL (or, just a bunch of macros). I can emulate first-class functions in C++ with a class with the `operator()` overloaded. I can emulate closures in C with a struct and a `void*` pointer. I can emulate everything in ASM with, well, writing everything myself. Why would first-class functions and closures make my life easier, besides removing a bit of syntactical clutter? BASIC is Turing-complete and can do anything Python can, your `for` loops are just syntactic sugar for my BASIC gotos, your list comprehensions are just syntactic sugar for append, map and filter, that are sugar for loops over lists, that are even more sugar for gotos. How can you say \`\`X is just syntactic sugar for Y, I don't need it'', when *everything* is a syntactic sugar for *everything*? First-class functions and (impure) \`\`functional'' programming are the new hip, of course now you can't live without it and every new language should have them, and you point at Lispers and say \`\`lol macros gb2ur toy language''. Ten years ago, everyone said the **exact** **same** **thing** about first-class functions and functional languages, and they thought OOP was the Ultimate Panacea. If some language with macros will become popular, python &amp; co. will *immediately* implement them, and it will be \`\`lol reader macros gb2ur toy language i dont need them i can use macros 4 everythin''. &gt; For example, when I want to make some value lazily initialized, I have to write a trivial constructor and add a pair of parentheses to each use of that value. Yes, it would be nicer if I didn't have to add these extra parentheses. No lisper is in position to gloat about this unfortunate limitation, sorry. With reader macros I can have Python as a DSL (cl-python, anyone?) Still, I can just use a rename transformer (in Scheme/Racket) that will parenthesize that for me. Of course, it will be generated transparently inside the macro.
&gt; &gt; at least as an honest to god bytecode transformer rather than a loose collection of glorified string substitution hacks &gt; Oh my. No comment. Do any of the lisps out there have a standardized model for side effects in normal/reader macros? &gt; What's the difference between an object system and a web framework? The latter is not supposed to add new syntactic and semantic constructs (though some of them try, then experience a [sudden outbreak of sanity](http://code.djangoproject.com/wiki/RemovingTheMagic)). Look at natural languages: when dealing with a specific domain you have to learn a lot of new words, but usually no new grammatical rules. And for a good reason! &gt; How can you say "X is just syntactic sugar for Y, I don't need it", when everything is a syntactic sugar for everything? I don't. The implication is not there. What I'm saying is that in _this particular case_ I don't see too much benefits from this particular syntactic sugar. I will gladly consider any examples to the contrary you could provide. Also note that I'm not comparing modern Python with a hypothetical future version of Python featuring some form of macros, but modern Python with modern Lisps. &gt; With reader macros I can have Python as a DSL (cl-python, anyone?) With a jackhammer I can have a lot of anal pleasure. I don't consider *"with X I can have Y"* to be an argument suitable for a civilized discussion. The only acceptable form of the argument is *"with X I have Y here, and it's useful because of this"*. Subjunctive mood is not allowed. Achievements of doubtful utility are not allowed unless you are willing to demonstrate their usefulness, and not theoretically but in practice (subjunctive mood is not allowed!). In an act of blatant overgeneralization I share my suspicion that the culture of discussing architectural details of cloud castles might be playing a major role in a certain language's gradual fall into oblivion.
That is also done here, in the solve function: http://web2py.com/mazes (although not quite A*)
Erann Gat is a smart guy but he's also a bit of a troll. I followed comp.lang.lisp back then, and let's just say that whatever happened to him in his short time at Google/in the Bay Area caused him to re-examine every bit of his life (quite publicly), and he came out the other end pretty hostile to everything he had championed before. Sort of like an atheist who takes up Christianity or a drunk who sobers up or a meat-eater who becomes a vegan -- he was pretty obnoxious about the enlightenment he had achieved, and how everyone else was hopelessly primitive by comparison. I wouldn't put too much stock in his comments of the time.
&gt; Do any of the lisps out there have a standardized model for side effects in normal/reader macros? Why would you want that? Or do you mean \`\`raising errors''? If so, R^6 RS does. &gt; The latter is not supposed to add new syntactic and semantic constructs (though some of them try, then experience a sudden outbreak of sanity). Racket's object system: `(define some-object (class object% ...))`, it doesn't add a whole new construct, `class` is just the `lambda` of classes. &gt; Look at natural languages: when dealing with a specific domain you have to learn a lot of new words, but usually no new grammatical rules. And for a good reason! Programming languages are not natural languages, but see the `class` example above. &gt; I don't. The implication is not there. What I'm saying is that in this particular case I don't see too much benefits from this particular syntactic sugar. I will gladly consider any examples to the contrary you could provide. I gave your many examples, but hiding behind the \`\`yeah, but if it's so useful they should put it in the main language anyway'' excuse is too simple. By the way, at Naughty Dog, they wrote this FSM DSL to write Uncharted, and it was pretty specific for what they needed. If Racket (the dialect they used) didn't provide macros, I doubt the Racket guys would extend the core *just because* someone asked for a specific feature for a specifc job just for them. It would also be too much work for the ND guys to tweak the Racket's internals to implement their FSM DSL. They would have just deal with it and use the core language and add some boilerplate here and there. Also, putting everything in the core causes just bloat (D, I'm looking at you). When there's a bug in, e.g., the object system, you have to touch the internals, written in criptic and low-level code, which is both error prone and unpleasant. If you screw up something, you may end screwing up everything else too. When your object system is written in the same language you're going to use, it's simpler to maintain, since it's an high-level language, and it will never blow up the whole thing, since it's just a library. If the core is larger, it will also be less portable, and working at low-level is harder than high-level. We stopped writing in pure ASM because it was both architecture specific and hard, we write more and more less C code because it is hard. That's why we have high-level language. Why isn't django written in C (with Python APIs)? Because it's harder than writing it in pure Python. The same applies to the core. Note that, if the core is small and everything is written in itself, any improvement to the core will inhertly improve everything else. The core, being smaller, will be easier to maintain and improve. It's a self-improving system. &gt; Also note that I'm not comparing modern Python with a hypothetical future version of Python featuring some form of macros, but modern Python with modern Lisps. Lisp's got all this from decades. You're comparing Python with CL, which is 30 years old, was born with the disadvantage of having to unify all the Lisp dialects of the time, and now has the disadvantage of having the classic inconsistencies the languages of that epoch have, but being still one of the most \`\`advanced'' languages out there. &gt; In an act of blatant overgeneralization I share my suspicion that the culture of discussing architectural details of cloud castles might be playing a major role in a certain language's gradual fall into oblivion. It's ok, now?
&gt; Obviously this would mean that Python could take proper advantage of multiple CPUs, Removing the GIL and allowing multiple native threads to execute Python would promptly result in corruption of Python data structures and undefined behavior (a crash). Now if you could guarantee that only one native thread ran Python, i.e., if it were single-threaded, then yes, the GIL would be unnecessary, and removing it would improve performance a bit. Calls to check a mutex are pretty quick, (I'd expect the machine code to boil down to a single test-and-set operation and a conditional branch) so I wouldn't expect a dramatic improvement. 
I don't believe Jython or IronPython have the GIL in them.
but it wouldn't be able to take advantage of multiple CPUs, because it wouldn't be thread-safe ;)
Do you mean python internal data structures?
&gt; &gt; Do any of the lisps out there have a standardized model for side effects in normal/reader macros? &gt; Why would you want that? Because if I really want to extend the language in a nice, safe manner, my extensions must be stateful. Because the core evaluator has state. It has tables of defined symbols and stuff like that. These tables are not accessible to macros, and macros can't have their own. Without that your macros are still second-class citizens, glorified sequence substitutions with pure functional interface. Suppose you wanted to add a `goto` to the language, in the spirit of [this](http://entrian.com/goto/) joke module. You can't write a "label" macro which saves the current location in a "labels" table and patches destinations of all gotos pointing at it, and a "goto" macro which tries to find the label in the "labels" table and adds itself to the "goto" table if the label is not yet defined. You can't hook some kind of "moduleParsed" event to report unmatched gotos and unused labels. The only approach available to you is to apply a macro to the entire module, and this is not composable, neither with other such macros, nor with built-in constructs (for instance you'd bust your ass trying to prevent it from replacing stuff in quotations). Even a honest-to-god bytecode transformer is better than that. In part _because_ it's hard, so no idiot is going to write such a mangler which stops working when Moon is in the first quarter. &gt; it doesn't add a whole new construct, class is just the lambda of classes. So how it's different from Javascript where people use exactly the same approach instead of the built-in object system, without any macros? &gt; I gave your many examples, but hiding behind the "yeah, but if it's so useful they should put it in the main language anyway" excuse is too simple. I'm not doing that, you are mixing two separate arguments. I partially agree that being able to extend a language with your own Big Stuff (like a type system) might be beneficial in the long run. Sometimes. Maybe. But that's not what I'm asking about. Show me that single example you threatened to provide but didn't, the FSM DSL, and I'll show you how to do the same with decorators and a bit of magic. Then we can discuss if the amount of boilerplate you can remove with macros compensates for the number of parentheses you have to live with.
The way the interpreter itself works is not thread safe in the CPython implementation. There isn't a way to use the same interpreter on multiple threads at the same exact time without hitting the GIL. A multi-process model is more robust anyway - getting concurrency right in a single process application is hard. Some people have "solved" the problem by running Python in a forking environment, so the interpreter isn't taking up as much extra memory for the extra processes.
Sure. The docs where pretty good, but it was unclear sometimes how to proceed; There was a lot of structure to understand in order to get started. When I used it, I wanted to scrape a site until certain conditions where met; when the last page scraped returned no objects. I wanted all results initially returned from a page to be dropped if they where older than a certain date; Thus I wanted Scrapy to keep scraping until no new items where found. Also, I wanted the latest date of the items returned so I could use this the next time I scrape. I created the 'DropElderMiddleware' middleware to do this. I couldn't see any other way of making calculations based on items returned from a particular page. I could never figure out what the difference between input and output processors where, or when I should use one or the other. The MapCompose function flattens object by default, So I had to be careful sometimes when returning lists that represented structure I wanted to retain. The way the html match object worked was sometimes confusing; If I wanted to match multiple items, then match items within each of those, I wanted a list of lists (group matches together base based on what matches they where found in). I can't remember the details of why I found this hard, but I can try to come up with an example if you like? In the end I figured I was having to learn the structure of Scrapy for everything that I wanted it to do, but many of Scrapy's features I didn't need e.g. I didn't want command-line control (I would actually prefer not to use the interface, though didn't discover how I could write a python script to apply the spider directly). Now I prefer to use mechanize + PyQuery; PyQuery is at least as good as processing webpages as Scrapy's object, and if I need something more for opening a page e.g. complicated login, I can use mechanize. I find this a more modular approach, and think that I better understand what's going on in my scripts.
Suppose you're right. Thread over!
Not to mention that (generally) most Python web apps spend most of their time outside of the interpreter, performing I/O operations.
Also, &gt; Lisp's got all this from decades. You're comparing Python with CL, which is 30 years old, was born with the disadvantage of having to unify all the Lisp dialects of the time, and now has the disadvantage of having the classic inconsistencies the languages of that epoch have WHY THE FUCK SHOULD I CARE?! Really, what's wrong with you and the people like you? Do you see all this like some kind of heritage contest? A court case, "your honor, my client has had hard childhood"? A Turing Prize committee discussing awarding the prize to the Common Lisp Standardization Committee? What? I look at programming languages strictly as tools, taking into account only their merits here and now. Because I use them as tools for writing programs, not for self-aggrandizement or anything. What about you?
Yes, and I say that as someone who's worked extensively with both. Lisp-macros let you write code that writes code in a far more general way than first-class functions alone, and that's really useful.
Can you show some moderately simple examples of that?
Started it, seemed promising. Really need to take more time with that sometime.
&gt;Thread over! [Ba-dum tish!](http://instantrimshot.com/classic/?sound=rimshot)
Read "Let Over Lambda" or look at the CL "loop" macro or try to implement a domain-specific language in Python. (There's nothing that can be done with macros that _can't_ be done with functions, so it is a matter of syntax, and the best examples aren't "moderately simple".)
True, because they use the GC of Java and .Net respectively, which in turn makes them lose performance-wise. CPython use reference counting for GC, meaning that if there is no GIL, those count would get corrupted when 2 threads try to change it at the same time, easily causing crashes. Using some kind of lock on every changes to counters has been attempted and I beleive the result was a 2 to 3 times slower CPython. (Can't find the source) This is only one of the multiple problems having no GIL would cause.
If the IO operations are blocking and your program doesn't have much CPU bound work, it may make sense to use threads. But in the case of a non blocking server like Twisted or Tornado, a gain in interpreter speed would translate more or less directly to capacity. A GIL-less Python would be more useful in the latter case.
&gt; Because if I really want to extend the language in a nice, safe manner, my extensions must be stateful. Are you implying that purely functional languages can't be extended? Lol, Haskell without macros is ten times more flexible than Python. &gt; Because the core evaluator has state. It has tables of defined symbols and stuff like that. These tables are not accessible to macros, and macros can't have their own. Without that your macros are still second-class citizens, glorified sequence substitutions with pure functional interface. Most of my macros have a state. I can execute whatever code I want, they are not limited nor purely functional. Scheme's macros do not produce s-expressions, produce syntax objects, that basically are s-expressions with scope information attached to them, and of course you can inspect them. I'll not comment more, because that's basically bullshit. &gt; Suppose you wanted to add a goto to the language, in the spirit of this joke module. You can't write a "label" macro which saves the current location in a "labels" table and patches destinations of all gotos pointing at it, and a "goto" macro which tries to find the label in the "labels" table and adds itself to the "goto" table if the label is not yet defined. You can't hook some kind of "moduleParsed" event to report unmatched gotos and unused labels. I can use continuations for that. The macro sets up the continuation and stores it in some "labels" table. Every `goto` call will lookup a symbol (not an identifier, so you can do computed gotos) in the table and execute the continuation. Of course, this has nothing to do with macros' state. &gt; The only approach available to you is to apply a macro to the entire module, and this is not composable, neither with other such macros, nor with built-in constructs (for instance you'd bust your ass trying to prevent it from replacing stuff in quotations). Nope, see above. You can even ensure that `label` will be called in a non-expression context. &gt; Even a honest-to-god bytecode transformer is better than that. In part because it's hard, so no idiot is going to write such a mangler which stops working when Moon is in the first quarter. Not everything compiles to bytecode. &gt; So how it's different from Javascript where people use exactly the same approach instead of the built-in object system, without any macros? What‽ Javascript has a *prototype based object system*, it **does** have one. Are we talking about the same Javascript? What do you think \`\``this`'' is? The constructor syntax looks like a function definition because JavaScript has just a bad design, it's not a function. Seriously, you are being even more moronic than I was. &gt; I'm not doing that, you are mixing two separate arguments. I partially agree that being able to extend a language with your own Big Stuff (like a type system) might be beneficial in the long run. Sometimes. Maybe. I'm not mixing two separate arguments, it's you that are stubborn and can't understand they are strictly related. &gt; Show me that single example you threatened to provide but didn't, the FSM DSL, It should be [this](http://www.naughtydog.com/docs/Naughty-Dog-GDC08-UNCHARTED-Tech.pdf) &gt; and I'll show you how to do the same with decorators and a bit of magic. Decorators are a bastardized version of let over lambdas, wrapper-functions and macros, that need to exist due to a limitation of Python. Good choice! &gt; Then we can discuss if the amount of boilerplate you can remove with macros compensates for the number of parentheses you have to live with. Well, that's funny, I often write macros to remove several layers of parentheses.
&gt; What about you? I look at programming languages strictly as tools, and I don't really like to fight with my hammer.
Yes, he does. The interpreter needs the GIL to protect its internal data structures, it's not thread safe without it.
With context managers and `with`, it's not too hard to write code which does not implicitly rely on reference counting. It might be feasible one day to equip CPython with a different garbage collection mechanism.
You mean by using a with-statement for every memory allocation, or you mean by using with-statements for only those resources that need deterministic finalization and including a proper GC for everything else? The former is basically RAII from C++, and I'd rather not have my Python code look like my C++. I could get behind the latter though...I thought that was recommended practice already, because if you rely on reference counting for deterministic finalization, it's easy to create a reference that holds on to an object much longer than you think.
The general consensus on the python newsgroup is that it wouldn't necessarily make cPython faster to correctly remove the GIL, because there would need to be a significant number of changes made to the cPython code to make the interpreter threadsafe. IIRC someone did just that, and found that it made Python slower on single core machines, and insignificantly faster on multicore machines. This is due at least in part to the fact that cPython is already uses threads where it makes sense to do so, and they use the GIL as a global mutex between them. In general, if you're doing calculations to the point where you're CPU bound, you should probably look at doing those calculations in C as your first optimization. If you're still CPU bound, you can release the GIL and work in a separate thread while the cPython VM continues on. If you're still CPU bound then, you can't blame the GIL for it. Some good background on the GIL here: http://www.dabeaz.com/GIL/
Of course it would, unless you want your calculations to be correct.
Well, the point is not actually that code can take advantage of multiple CPUs, the point is that certain types of CPU bound programs don't share much state between threads (ie thread safety can be achieved easily) and may benefit from not having the overhead of the GIL. Of course, if this overhead is very small, it's not worthwhile.
Out of interest, what are the barriers to having a python interpreter per thread?
I meant using `with` statements for managing non-memory resources. It is recommended practice, but there are many cases where the `with`-less approach works fine in CPython, so I expect it will take more time (and a compelling reason, such as a high-performance VM with a tracing collector) for everyone to make the switch.
That's called forking
For people who want to use C for CPU bound calculations that don't need Python data structures, take a look at Cython's nogil feature.
&gt; Most of my macros have a state. &gt; I can use continuations for that. I have a strong feeling that you never tried to actually do this, and have a pretty superficial understanding of all this stuff. I also have a strong feeling that you don't understand what I'm trying to tell you because you're a [blub programmer](http://en.wikipedia.org/wiki/Paul_Graham_\(computer_programmer\)#Blub), quite ironically! So, to end this theorycrafting bullshit: here's a simple task for you. One of the Microsoft extensions for C and C++ programming languages is the [`__counter__`](http://msdn.microsoft.com/en-us/library/b0084kay\(v=vs.80\).aspx) pseudo-macro. It expands to an integer starting with 0 and incrementing by 1 every time it is used in a compiland. Kind of like a poor man's `gensym`. Write me an equivalent macro in a Lisp of your choice. You are supposed to go through several stages of grief: 1. You should realize that you can't do that with a simple macro because you don't have state! 2. You should realize that you can't do that with a simple code-mangling macro because it would replace the symbol in quotations! 3. You should realize that Lisp macros are fundamentally limited, then humbly ask me if there are more powerful languages. &gt; Seriously, you are being even more moronic than I was. You don't pay enough attention to what I say. Javascript does have an object system. Yet people routinely abuse it to produce a different object system, one that has encapsulation, using closures. [Here](http://www.codeproject.com/KB/scripting/jsoops.aspx), skip down to the first mention of closure. Does it seem... familiar? Truly, narrowness of experience leads to narrowness of imagination. And when coupled with arrogance, produces such gems as your "you are being even more moronic than I was". You are being a moron here. &gt; It should be [this](http://www.naughtydog.com/docs/Naughty-Dog-GDC08-UNCHARTED-Tech.pdf) Any sufficiently advanced trolling is indistinguishable from retardation. Did you give me that link in hopes I wouldn't read it, or are you just stupid like that? I'm actually kind of pissed off right now. What you did is unacceptable. You should apologize. &gt; Decorators are a bastardized version of let over lambdas, wrapper-functions and macros, that need to exist due to a limitation of Python. Good choice! Yep, good choice, exactly. It's better to have a convenient way to solve 99% of the usual problems, with some minor inconveniences for the remaining 1%, than an inconvenient way to solve 100% of the problems. If you use Lisp to write facs and fibs, this idea might seem strange to you.
Nothing at all would be shared -- that's multiprocessing, not multithreading.
Of course they would, unless you wanted them to be correct for our current mathematical axioms.
Riiiight. Then why did you write that paragraph about the history of CL?
At the least, yes. Python memory management, for example, requires the GIL.
&gt; So, to end this theorycrafting bullshit: here's a simple task for you. One of the Microsoft extensions for C and C++ programming languages is the __counter__ pseudo-macro. It expands to an integer starting with 0 and incrementing by 1 every time it is used in a compiland. [Done](http://paste.lisp.org/display/120429), where's my cookie? &gt; # You can't do that with a simple macro because you don't have state! It does! &gt; # You can't do that with a simple code-mangling macro because it would replace the symbol in quotations! It doesn't! &gt; # You should realize that Lisp macros are fundamentally limited, then modestly ask me if there are more powerful languages. Why? I did it. Whatever you said after that is now pointless. &gt; Any sufficiently advanced trolling is indistinguishable from retardation. Did you give me that link in hopes I wouldn't read it, or are you just stupid like that? Truth hurts, I know. Don't worry, I'll be your friend. Not. Pythonistas have inherited only one thing from Lisp: the arrogance. They don't even have a reason to be arrogant.
You said \`\`modern Python'' and \`\`modern Lisp''. CL is not a modern Lisp.
Instead of the loop macro I have list comprehensions and loops. I do understand that it's a matter of syntax, and that best examples are not simple (but I hope for a _moderately_ simple example!). My point is, it's better to have a convenient way to solve 99% of the usual problems, with some minor inconveniences for the remaining 1%, than an inconvenient way to solve 100% of the problems. I know that using Lisp is inconvenient in general. Using Python is inconvenient in some cases. I'd like to see an example which showcases a situation where the ambient inconvenience of CL is significantly more convenient than the particular inconvenience of Python.
Wh... Then what is? Clojure?
Do you really think that a 30 years old language can be considered modern? R5RS Scheme dates to 1998 ca., R6RS 2007. They are much more modern, don't you think?
&gt; Done, where's my cookie? Ha, it has been a long time since I first had this discussion, so I forgot the step where I ask you to define a function for making such counters. Then you go through the stages. &gt; Truth hurts, I know. Don't worry, I'll be your friend. Not. what the fuck, dude. In case you are really that stupid: the pdf you linked doesn't mention the scripting language they used. Now apologize.
There are a few good ones linked on the pygame site, but the most important part (IMHO) is that you just download the complete documentation, and then you can start hacking. Pygame is really simple and intuitive to use, and you will probably learn most of the stuff on your own. I'd definitely recommend reading a tutorial about sprites, though, as those are very important to understand properly.
And what exactly changed, in respect to parentheses and stuff? More precisely, what have I said up there that made you think that I'm comparing Python to CL and not to Scheme?
&gt; Ha, it has been a long time since I first had this discussion, so I forgot the step where I ask you to define a function for making such counters. How can I bind at runtime something that runs at compile-time? I can make a [macro](http://paste.lisp.org/display/120431) to generate them. &gt; what the fuck, dude. In case you are really that stupid: the pdf you linked doesn't mention the scripting language they used. Now apologize. Oh, you're right, [wrong link](http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf), I didn't check, sorry.
&gt; And what exactly changed, in respect to parentheses and stuff? What exactly changed from C to C++ to Java, in respect to semicolons and braces? &gt; More precisely, what have I said up there that made you think that I'm comparing Python to CL and not to Scheme? You said: &gt; loose collection of glorified string substitution hacks And CLOS. Sounds like CL to me.
Nice post, I've been hoping to learn pathfinding one day and thought this article was educational. It takes its time to teach the concepts, rather than just throwing some ready code in your face and expecting you to copy-paste it. Surely more experienced Python users can find things wrong with this implementation, but the material seems to be meant mostly as an introduction to A*.
http://learnpythonthehardway.org/static/LearnPythonTheHardWay.pdf http://www.math.ru.nl/~bosma/onderwijs/najaar09/thinkpython.pdf for starters, and then send them some moola. 
Um... &gt;"With python's brilliant introspection I can use the interpreter to find out how a library works just by using help() and dir() without even having to read the source code." * (describe 'list) COMMON-LISP:LIST [symbol] LIST names a compiled function: Lambda-list: (&amp;REST ARGS) Declared type: (FUNCTION * (VALUES LIST &amp;OPTIONAL)) Documentation: Return constructs and returns a list of its arguments. Source file: SYS:SRC;CODE;LIST.LISP LIST names the built-in-class #&lt;BUILT-IN-CLASS LIST&gt;: Class precedence-list: LIST, SEQUENCE, T Direct superclasses: SEQUENCE Direct subclasses: CONS, NULL No direct slots. LIST names a primitive type-specifier: (undocumented) * (defstruct bar x y z) BAR * (describe (make-bar)) #S(BAR :X NIL :Y NIL :Z NIL) [structure-object] Slots with :INSTANCE allocation: X = NIL Y = NIL Z = NIL 
The implementation has been modified few hours ago and it now uses a set for the closed list and a heap queue for the open list. Some of the comments here are a bit outdated.
but removing the GIL wouldn't help with that. Programs that share state aren't threadsafe without explicit locks even WITH the GIL, and without the GIL, there is **no** threadsafety, even if at the user level, threads do not share state, because the python interpreter does.
But you have to consider that even when the server is non-blocking, like Tornado, that the computer only has a limited number of cores to do simultaneous processing. If you have 4 cores, you could run 4 Tornado processes. You can't run 1000 threads exactly-at-the-same-time, even in erlang.
I don't see why you need A Star for a maze. Mazes only have one path to the end. A Star is used to find the optimal path when there is more than one. Here's a sample of solving a maze recursively with no A*. grid = [ 1, 1, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0 ] GridWidth = 6 GridHeight = 6 Wall = 1 End = 2 def CheckValid( x, y ): if x &lt; 0 or y &lt; 0 or x &gt;= GridWidth or y &gt;= GridHeight: return False return True def FindPath( x, y, g, p = [] ): try: p.index((x,y)) return [] except ValueError: pass p2 = p[:] p2.append((x,y)) if CheckValid( x, y ): if g[y*GridWidth+x] == End: return p2 if CheckValid( x, y+1 ): if g[(y+1)*GridWidth+x] != Wall: path = FindPath( x, y+1, g, p2 ) if len(path) != 0: return path if CheckValid( x+1, y ): if g[y*GridWidth+(x+1)] != Wall: path = FindPath( x+1, y, g, p2 ) if len(path) != 0: return path if CheckValid( x, y-1 ): if g[(y-1)*GridWidth+x] != Wall: path = FindPath( x, y-1, g, p2 ) if len(path) != 0: return path if CheckValid( x-1, y ): if g[y*GridWidth+(x-1)] != Wall: path = FindPath( x-1, y, g, p2 ) if len(path) != 0: return path return [] p = FindPath( 0, 5, grid ) for x in p: grid[x[1]*GridWidth+x[0]] = '*' for x in xrange(GridWidth*GridHeight): if not (x%GridWidth): print print grid[x], ' ',
I don't think Lisp is "inconvenient in general"; I didn't have that impression when I was first learning it nor after working in it for several years. However, I'm not actually arguing that Lisp is somehow better than Python in the abstract. My go-to language is generally Python. I use Lisp for my job and it's suited to that task in a way I think Python wouldn't be. I'm just addressing your "are lisp-style macros important" question. I'd take lisp-style macros over generator functions or list comprehension any day. (Though probably not over first-order functions or closures.)
Documentation is one of the things that's actually really hard to get right. And from a recent interview with one of the Pyramid's devs it's one of the main reason for the consolidation of all the efforts into a single framework.
The article describes 2 algorithms: one recursive and the A* one.
 class MyList(list): pass 
no, that's not it. I need to overload the operators and I want some example code. If someone has some code that (for instance) treats an XML data base as if it were a list, then that would be great.
Have a look at the second answer here: http://stackoverflow.com/questions/19151/build-a-basic-python-iterator Basically any function you want (iterable, lookup) has a particular method associated with it.
I just realized what I was doing wrong. My reference talks about both python 3 and 2, and I was overriding \_\_next\_\_() instead of next(). I wanted example code because I hate banging my head against code that doesn't budge. This explains it thanks. (I'm using 2.6 now) 
I'm also going through the learning process at the moment. There are some great links on the pygame site, and the demos that come with pygame are decent albeit small. (some folder like Python/Lib/site-packages/pygame/examples) I particularly liked this: http://richard.cgpublisher.com/product/pub.84/prod.11 Some concepts you need to learn are surfaces, blitting, sprites, sprite groups, event handling, and the clock/clock.tick(FPS). The main loop in pygame goes nuts if you do not poll for events, just an FYI. Before you go on your trip, download lots of small completed games and try to pour over the code. You should probably download some of the pygame API pages as well, and take those with you. I find that developing in eclipse with pydev is pretty nice. --------------------------------------------------------- If you'd like I have a large set of files i've used for learning where I've got a sort of menu built, with sound playing, event handling, and state switching between the menu and a "game". I'd be willing to share, but because this is a school project I'd rather it not be posted super publicly. Just PM me if you're interested and ill host it somewhere public/
Also check out Python [Expect](http://pexpect.sourceforge.net/pexpect.html)
That's what he said in the linked newsgroup post, isn't it? I think what he learned at Google was that productivity is in the programmer, not the programming language. Of course, I'm not sure he learned it in a way that he can articulate, because he *still* framed the conversation in terms of programming languages, he just supported different programming languages. Which is sort of a shame, because it's a really important lesson that doesn't get stressed enough on the Internet.
I suggest using [github.com search](https://github.com/search?type=Everything&amp;language=python&amp;q=gae&amp;repo=&amp;langOverride=&amp;x=0&amp;y=0&amp;start_value=1). An example I found (blog in django for app engine) is: https://github.com/matejd/gae-django-blog
The interesting feature is propagation of programming language objects through cells in the spreadsheet. This change doesn't achieve that, unfortunately.
You could actually run Python in spreadsheets for quite a while, through [Pyspread](http://pyspread.sourceforge.net).
I've been trying to convince my employers that Python is safe to use for everyday tasks, because there are modules for everything you can think of, and they are so easy to install. So, as a dramatic demonstration of my point, I can show them: easy_install pyearthquake Well, I'm getting a little hungry for lunch now. Talk to you all later. easy_install pymacaroniandcheese
happy birthday py! I was just there.
DAE think the 2 looks too much like a Z? Also, who was the lucky person who got that first corner piece?
Good point!
Brilliant programming language, almost the same age as me!
This feature alone would convert me from eclipse to VS in 1 second flat. But without it, I'm not using the hog that is VS for my lightweight coding. While i think it is awesome that microsoft did this, eclipse + pyDev is just too efficient for me to bother with converting over to this.
The BDFL himself.
that cake is no lie
Who ate the first piece &amp;#3232;\_&amp;#3232; 
It's a simple illustration of how decorators work, not string concatenation performance. I think using a join would make the example less clear. That said, yes 'join' is faster than '+' for strings.
Don't forget PostGIS!
It's been proposed a couple of times, and is probably possible, but there's a lot of global state (rather than per-interpreter state) currently in the C API, which would need to be cleaned up. It's also not that clear that it buys you much over just forking - you'll still be shared-nothing, thus it doesn't help much in the situations where people want threads and run into GIL issues.
TIL the Python logo is two pythons. :|
Guido
raise Glass()
As a professional coder, I think it is not a test to be taken into account seriously. When you code, you have time to think and you can also try your code against the compiler. You can do none of both with pen and paper. I think it is only useful as a mean of guessing how the interviewee thinks.
The Washington Times has an [entire Django site](https://github.com/washingtontimes/opensourcesite) open sourced. That might be a good place to start.
I agree. I have a professor who has these kinds of tests and it pisses me off. I have a programming job and I reference the online manual every day! I did fairly poorly on the test even though I am really comfortable with the language. Stupid old-school professors!
yeah, the only moment i think they can be useful is, for example, to get to know how the interviewee thinks without taking too seriously the correctness of the language or the use of features. 
(9) is sort of ironic in the context of this post.
It doesn't make sense to write code with pen and paper, but you can test knowledge of a programming language without requiring the testee to write code. Questions like; * "Explain this C declaration", where it's some complex 'pointer to an array of pointers to functions' sort of thing. * "Why will this piece of code not compile/why will it crash" * "Which of these two different snippets would you use to do job X", where they both do the job but one is much slower or uses a lot more memory due to something about the language
these days? ... the same thing I think about using punch cards. Many people use the enhancements in technology to for example do on the fly introspection (e.g. by using their Python interpreter). Assuming that this has become part of their workflow it's fair to say that if deprived of such a thing even an outstanding programmer might look like a fool, thus giving a totally wrong impression about his skills and knowledge. In fact now that I think about it ... it's weeks since I last had a pencil in my hands. I simply don't need to, ever. This makes the idea of being tested with pen and paper even more odd. I could do whiteboard though, I guess, maybe :-]
Well if the tester is flexible in the code you write - for example, if they are knowledgeable enough to know when your code is logically correct even when it's not syntactically perfect, and when you may be using syntax from another language by accident. I could see using it for testing general programming knowledge and looking for code that at least seems like pseudocode even if it's not perfect.
Exactly what I came in here to say. I looked at the cake, then had to look up the logo elsewhere because surely it hasn't been two snakes this whole time. Turns out I'm an idiot.
I'm also looking to learn how to use Python in webdev. It's very confusing to me, coming from a PHP background where you just drop a PHP file in the web root and it works, it's very confusing. I'm reading this if it's any help: http://www.wsgi.org/wsgi/ 
TIL Python is 20 years old. Sucks I only just started learning 3.x but I'm glad I am!
In this case, he is looking for perfect syntax. He is also looking for exactly what he taught, so if we know a different or better way to do it, it doesn't matter, because he didn't teach it. Fucking hate this guy.
Well then. I don't know any reason why that isn't just f'ing stupid. What kind of teaching is that? Rote memorization wastes space better used by programming skills despite the existence of perfectly good resources. In short, that's just brain space waste.
I'm still hurting from the pub-crawl I did last night in midtown so I'm grabbing some take-out and gator-aid and sleeping early.
Not free, but there is also [Resolver One](http://www.resolversystems.com/products/resolver-one/).
I wrote my site [avenueinsights.com](http://www.avenueinsights.com/) with [Django-nonrel](http://code.google.com/appengine/articles/django-nonrel.html) and App Engine, but ended up feeling the project was a little too heavy for what I needed to do. I've started writing a [GAE Flask skeleton on github](https://github.com/zachwill/gae-flask-html5) if you want to check that out. The code is pretty straightforward, and I documented my patch to import libraries from the libs directory in the project.
Almost all of the courses for my CS degree had written exams, many of which included coding on paper (and writing proofs, etc). There were also practical assignments where you used a computer as usual. As a result I don't really think it's anything special, but if you've never done it before, I can imagine it will be. 
Take this Python, I'm four years older than you. That means I'm your senior. @_@
That makes the picture *better*.
I think it's a great idea, and I make my students do it all the time. Simple, self-contained programs that test a single idea. Before I started doing this, I had students who could not write a simple "for" loop without errors after a semester of programming (and I am talking about major errors). They'd get help on their homework, copy and paste from online examples, etc., and never really learn what they were doing. I introduced pencil-and-paper quizzes that involved writing code (focusing on a construct or idea that the student had just practiced in a homework project), and it made a huge difference in the results. It makes cheating very difficult. Now I make the quiz after each assignment worth as much as the assignment, and students are finally starting to treat the assignments as learning exercises.
It started out funny, then I realized the dude is serious.. and very bitter. :)
IMO, 1 and 4 are on the spot.
Thread safety is the least of the problems. The whole point of threads is sharing data so without the GIL each time a reference is created or deleted a lock would have to be acquired to change the reference count, experiments such as this have been made and shown that this causes a slow down. So in order to remove the GIL in an acceptable manner CPython would have to switch to a difference garbage collection strategy, this would be an enormous effort not even taking the C API etc. into consideration. Furthermore this would mean that code relying on reference counting might fail in a more or less obvious manner depending on the actual case. If this would happen removing the GIL would become a possibility even though requiring still a lot of work. As much as people complain apparently nobody who has the skill to solve this problem seems to think it is worth the effort. It is far more likely that PyPy will remove it's GIL (they have no thread-safe GC strategies at the moment) even though that hasn't happened either. Anyway if you need the computational power use multiprocessing and if you do a lot of IO use eventlet.
It seems a lot of people assume the interview is supposed to simulate the real working conditions and assess how the interviewee is handling those directly. I think the approach is different: Interviewers are looking for measurements that may not appear to be related to the work at all, but supposedly have strong correlation to whether or not the interviewee will be a good worker. The question should not be whether or not the interview process was similar to a "real world situation", but what it is that is measured, and will it correlate well to actual performance.
Haters gonna hate.
It's like learning a martial art by reading a book with images instead of practicing.
While most of my programming is done directly on the computer, testing syntax and functionality as I build, I have also written several (relatively simple) programs by hand with pencil and paper. My AP CS exam involved a lot of hand-written programming, but I think they weren't as concerned with perfect syntax as your prof seems to be. Many job interviews I've participated in include some handwritten code, to demonstrate that you're not just one of the copy/paste or "you can do that without an IDE???" programmers. I think it's a good test of your basic understanding of a programming language to write things by hand sometimes. However, I think there should be some flexibility when it comes to syntax errors...
I'm somewhat biased, but I'd recommend the Django tutorial: http://docs.djangoproject.com/en/1.2/intro/tutorial01/ This is how I got started with web development in Python, and it's also how I started to learn Python in general. If you're already familiar with Python, you'll be much better off than I was.
I've learned not to judge a professor by the reactions of a single student. But in general I didn't like hand written programming exams. I remember I had one where we were just introduced to javascript, and on the exam he asked us to find all the factors of a really large number, in java script on paper. We had no access to any API/Library, and had never done any math in javascript. And it was a client side programming course, not a mathematics course. 
Presumably the teacher assumed that you understood what a factor was enough to implement a naive method of factorization. It actually sounds completely reasonable to me, it's fairly difficult to come up with problems that are simple and self contained but also test that you can do something other than a simple for loop or simple nested for loops for a 2D array. It sounds like the professor just wanted something like this for(int i=1; i &lt;= num; i++){ if ( num % i == 0 ) alert(num); } or if he wants prime factors instead of all numbers that divide it: int factor = 2; while(num &gt; 1) { if(num % factor == 0){ alert(factor); num = num / factor; } else { factor += 1; } } I really can't imagine how an IDE or javascript documentation would even help you write that. 
we had literally just seen java script for first time about three days hence, and then immediately moved onto java server pages/faces. But I like your solutions. I don't know if i could have come up with that prime one on the spot.
Not all talks are there. Hopefully we will see all.
They'll always be dead parrots to me.
yes, it will, the [PyCon 2011 has not yet finished.](http://us.pycon.org/2011/schedule/) they will be updating the blip.tv by new videos and uploading slides and provide blip video links to the PyCon website. kudos to the PyCon volunteers.
What about http://wiki.services.openoffice.org/wiki/Python_as_a_macro_language?
Thanks
Suggestions: 1. Use [Flask-WTF](http://packages.python.org/Flask-WTF/) for wtform 2. Do you have to bundle dependencies on GAE? Then perhaps make that part bootstrapping/deployment e.g. employing ``pip install -d``
I see you have Flask-WTF bundled so you know about it, however you're not using it in the app.
Just like [hotswap.py](http://www.krause-software.com/hotswap/)? :-)
Both my functional programming (Haskell) and Logic Programming &amp; AI (Prolog) required code to be written by hand. Most of the questions were rather simple, and of the form "Given the set of definitions: x = ... y = ... p = undefined Write a working solution for p " x, y, and p were all sanely named, and the code was fairly well commented. If it's done like that, it could be considered ok, I guess.
Excellent, thanks for linking this! I was looking forward to seeing Guido's fireside chat because I knew it was Saturday morning, but then I couldn't find the video anywhere.
You should be able to express an algorithm in long-hand using pencil and paper only, but to then expect any pseudocode or language code to run un-edited is stupid. If you are going to run code, then allow the iterviewed person to cirrect the code in a normal coding environment.
It's actually Mason, not Masen.
I don't think that there are built-in methods to talk to Excel. You can talk to sqlite though with [built-in methods](http://docs.python.org/library/sqlite3.html). Also, I don't see why you wouldn't use other modules. It will make it much easier for writing your application. As for your users, look into using [setuptools](http://packages.python.org/an_example_pypi_project/setuptools.html) or something like [py2exe](http://www.py2exe.org/). I have no experience with py2exe and only limited experience with setuptools, but it can help you a lot. If you search for a tutorial or search widget on how to package python for windows you will find what you need (for example [here](http://www.reddit.com/r/Python/comments/dhs8w/best_way_to_package_and_release_a_python_game_in/)).
&gt; I'm writing a python app for non-python users I think you should be a bit more specific here. Why not use the relevant packages and take them with your app?
Well, there goes my afternoon.
If I can read it correctly. 
Quicktime player? Seriously? 
Nice, I was wondering what that funky t-shirt was he was wearing!
I would like a piece of that.
That's a noble attempt but wouldn't it make more sense to internationalize the Japanese disaster mangagement system for the poor brothers and sisters in Europe and the US?
ಠ_ಠ
What OS? - if you are using windows, an approach I have used in the past with Excel is use win32com.client, and use COM. I'm using a browser that doesn't have RES, so I don't want to just copypasta code because it'll just apprear as a mess without a little tidying up. If you are interested, PM me, and I can send you some pointers. For mySQL, I have connected to this also, although it requires the mySQLdb - so that doesn't satisfy your requirement of not installing additional modules
[You did](http://www.23monkeys.com/designs/python)
Who is that Guido?
Yes that's Guido right after his "fireside chat" at Pycon.
Note that win32com is only included if you're using a distribution like ActivePython. You could use ctypes, which is included in the standard distribution, but some things require a lot more code than similar code from win32com. Either way, that only works on a Windows machine with Excel. There are no standard library modules to handle MySQL connections. Your best bet is to use SQLite if you need a relational database (and have the option of choosing said database).
"ExcelIO" module?
That is not a decision any of us (python community or Sahana community) can make. The Sahana developers have made this open source package with funding from some governments to provide service to local NGOs when a disaster strikes. If you have knowledge of any other DMS that is in use on this occasion, you should let the Sahana people know. There may be an API that allow to connect them and share information. Anyway, it should be stressed that Sahana is a project that originated in Asia, not in Europe.
Excellent tip. I just might have to steal that from you :-)
[Buildout](http://www.buildout.org/) is handy for making a package with all dependencies included.
vlc
&gt; 1) Django people. They are crazy. Avoid at all cost. If you don't know why, go and find a herd. Ok. &gt; 2) It's held in the same city two years in a row and that city is never Las Vegas. I'll go to Atlanta once. Under normal circumstances, why would I want to go back? That's how it works. Organizing a 1400 person conference is already hard as it is. Making it a constantly moving target just makes that even harder. I believe the two-year plan may also have positive cost effects, but I don't know for sure. If you want it to be in Las Vegas, you are more than welcome to put together a proposal for that to be so. It's not just picked at random - Python communities need to ask for the conference to come to them. As for "why would I want to go back?"...I think that might have been answered by the fact that this year PyCon was right around 1400 people, which is an increase from the previous year. Everyone else came back, plus more. &gt; 3) You know the people you work with? Imagine hundreds of such people all in one place. Imagine seeing eight copies of yourself in the hotel lobby. Now imagine yourself getting into a fist fight with three copies of yourself. Pycon is mirrored worlds colliding with frightening results and often shards of glass in eyeballs. I've never hung out with such a diverse group of people. Sure, we're all geeks and we all like Python, but that's typically where the similarities end. If you wanted to, you could have dinner with 10 people from 10 places in 10 industries with 10 distinct backgrounds. As it is in the code we write, Python is the glue that brings such a diverse audience together. &gt; 4) Guido van Rossum is lazy. The year I went to Pycon his keynote address consisted of him answering questions tweeted to him on a large screen. Would it be too much trouble to write a little something up in advance? That's easy to say. Have you ever put together a keynote to address over 1000 people? What do you want him to talk about for 45 minutes? He's been doing this for 21 years, traveling all over to PyCons and IPC before that, working on the language, etc. He's done keynotes before and I think he'd rather hand it off to people like Hilary Mason like this year. His "fireside chat" this year was actually very interesting and the questions were pre-selected via Google Moderator. It seems he's more comfortable doing it that way too. &gt; 5) Pycon is for networking and schmoozing. Don't expect to learn very much or see too many new things. It's for "pressing the flesh" and what socially awkward flesh it is! If you want to network and schmooze, that's certainly possible. If you don't want to learn, you won't. I've learned a ton so far from internals (Dave Malcolm's memory talk) to concepts (Peter Portante's co-routine talk) to libraries (Tarek's packaging talk). On top of that, I've also been educated on what people are doing and how they are solving their problems from chatting with people at lunch, in the hallway, and over beers. I literally laughed out loud at "Don't expect to [...] see too many new things". For example, every single poster in the poster session was a brand new thing to me. &gt; 6) All the talk about Python saving the planet (I'm slightly exaggerating) is nauseating. It's a freaking programming language. Get over it. It's not going to cure cancer, it's not going to become self-aware, and it's not going to make you live forever. Other programming languages can be nice too. Other languages *are* nice, but the conference is called **PyCon**. It's a conference about Python, and there's going to be a lot of love for Python. Speaking of the curing cancer thing, I had a great chat with an old acquaintance about his new job in a super-computing lab that is something like 100x faster than the IBM BlueGene series and all of the medical research they are doing. It's crazy. Mainly C and lower, but there's some Python in there as well. &gt; 7) There are five talks you think look interesting. Four of them are scheduled at the same time. You are able to go to two of the five talks. They turn out to be disappointing and the ones you had to miss were rumored to be awesome. You watch the talks you missed on video later, at home, when they are posted. The audio and video turn out to be poor and the talks really weren't awesome anyway. Sorry we selected and scheduled such awesome talks. Also, sorry that the video isn't movie quality. Donations are welcome to solve the latter. It's a volunteer organized and run conference and sometimes there are hiccups with the recordings. It happens, no one's happy about it, but we'll live. &gt; 8) If you are a single guy and are looking for a cool python chick for a relationship, forget about it. There are attractive women at Pycon. However, they are always mysteriously surrounded by huge groups of smarmy looking guys. Good luck with that. Sorry. &gt; 9) Hipsters. Pycon has them. So does the mall.
code please
&gt;Python is for gils FTFY :P
Thanks Massimo for posting this!
They're not dead. Just resting.
&gt; Python is for GILs FTFY :P
This years PyCon had a lot of quality presentations. Pretty impressive. 
It's Flash for me. Is that better or worse?
Actually, like most other Europeans I know more about Geishas and Samurai than about Japans technological and administrative infrastructure. But whenever an aspect of modern Japan is covered, like public traffic, it strikes me superior than what we have. From the media coverage of the last days I can only guess that their DM is also excellent. So consider my question as rhetoric. I hope I can learn more. 
The actual implementation will be covered in a follow-up; if you wish to understand the source code on your own until then: https://github.com/segfaulthunter/sandbox/blob/master/pdict.py
I was running into an error (I believe for not including pkg_resources.py), but yeah, I'm definitely planning on using Flask-WTF going forward -- and updating the sample app to reflect that.
*\*Pushes glasses up by the bridge and fixes collar\** Girlth? Really, where?
G r e a t !
I can't play the jpeg...
Just use whatever you want, and then use [py2exe](http://www.py2exe.org/) as tmske mentioned. Then you can either distro it as a zip or build an installer with [NSIS](http://nsis.sourceforge.net/Main_Page) if you wanna be fancy. If you need non-windows users to deal with the excel files, [xlrd](http://pypi.python.org/pypi/xlrd) is quite good. I've distro'ed pygtk apps this way and it's worked fine. No one needs to care it's in python.
I'm a CS student in France and we get these pencil and paper programming tests quite often... I can't complain, they're pretty effective at making us think hard and use our memory!
Funny I was thinking about Python in a spreadsheet last year. This isn't exactly what I imagined! Rather I'd want to be able to write each cell formula directly in Python. In otherwords do away with the old cell formulas altogether and simply enter Python code into each cell. Obviously this is a ground up rewrite and is not compatible with current spread sheets. However I can see great advantage to this sort of approach. One should be able to encapsulate a lot of functionality and data into one cell. Plus it might effectively address some of the shortcomings of traditional spread sheets. 
apparently Guido hasn't been keeping tabs on the widespread crackdown on potential sexist material/behavior in conferences
yep - hadn't heard of hotswap before, thanks! Looks like it even does the trick for event-loops too, cool...
Don't worry mate, hotswap is *ancient*, a.k.a. I'm amazed the author is still alive. :-) I do love this little script, it's served me quite well over the years!
That girl's head and feet are lifted straight from [Ant Parade](http://kei-acedera.cgsociety.org/gallery/402048/) by Kei Acedera and Bobby Chiu. I wonder if they had any part in it, or if it was just traced from their work. If the latter... not cool.
Apparently he *has* been keeping up, because I can't see anything possibly sexist about the Benevolent Dictator of a highly prominent, and popular programming language saying that his language is "for girls" as opposed to "for Real Men (tm)".
Here's [a comparison](http://i.imgur.com/5g6mq.gif). I scaled her a bit non-uniformly in the Python image, and rotated it a bit, but it's most definitely lifted from Ant Parade.
Generally, we say "for Real Programmers (tm)"
I'm not a T-shirt fan, but this one's great. It's nice how he turns the expression around to mean that even young girls can use and benefit from Python.
your particular interpretation matters little, what matters is those few people who will see it differently, and trust me when i say that there would be some. i'm sure this is tongue-in-cheek, i'm sure that the fact that he's "putting down" his own language in many ways exempts him from any claim of sexism. but the very notion that "for little girls" is a put down in the first place, or in any way different that "for little boys", is a touchy subject in and of itself. Mark Pesce's talk on web privacy at linux.conf.au caught a bunch of shit recently, and I'm 90% sure that if you watched it you, like me, would not find it offensive in the least bit. The most controversial image was 2 guys in an outlandish/joke dominatrix scene. Yet it still violated the LCA's anti-harassment guidelines. Just watch the disclaimer they ended up adding to it before putting it online: http://linuxconfau.blip.tv/file/4851926 I'd be very apprehensive wearing a shirt like that, regardless of how much i loved python or how much i respected woman and their contributions to CS
Because girls are incapable of understanding programming languages that boys can amirite? Edit: I wonder if the downvotes are due to sarcasm detection failure or misogony?
To be fair, IIRC the crackdown on minor, only vaguely dubious material is part of an attempt to use [broken window theory](http://en.wikipedia.org/wiki/Broken_windows_theory) to try and reduce the actual serious problems that have been found, like [groping, harassment, upskirt photos](http://lwn.net/Articles/417482/) etc. - the idea being that if you have an atmosphere where even minor possible sexism is frowned upon, the incidence of seriously obnoxious behaviour should reduce as well, and will stand out and shock more when it does happen. Whether it'll work as a strategy, I don't know, IANASociologist. But I don't think this is all just a case of "a few people" taking offence at everything for no good reason.
agree completely. don't get me wrong, i don't mean to suggest that the precautions are unwarranted, but they are extensive enough that it's still quite easy for someone to accidentally step over the line. this shirt for instance, completely harmless and well-meaning in every way, i'm sure, but it's still the type of thing that might stir up controversy and detract from the topic at hand.
windows.
I don't think you should have to be a sociologist to know you have the right to laugh about something.
I agree, for tasks where multi threading/processing is required there are plenty of options, that work well despite the GIL. The issue I have with GIL is the negative impact it has on when scripts run on multi-core systems. For instance I've ran the thread-ring (benchmark game) benchmark on a physical quad core machine, and inside a 1 CPU VM on the same machine and the benchmark in the VM ran almost twice as fast. I thought CPU context switching could have been an issue on the physical machine so I forced the affinity to one core only and repeated the test. While I did get an improvement in performance by forcing affinity to a specific core the benchmark still didn't run nowhere near as fast as the one in the VM.
The creator of Python saying "Python is for girls" is nothing but flattering for women. You need to be a fucking idiot to think otherwise.
you can choose the flash video or mp4/m4v, or you can stream it as html5 video. Lots of options. You can also download all the videos on their respective pages under the "Files and Links" accordion button.
Ah okay, cool!
Guido is for boys
This point was addressed in my reply
...Wha? I'm afraid I don't follow why that isn't a non-sequitur. The thing I was saying I didn't know was whether the application of broken window theory to the context at hand was going to work to achieve the described goal. Was I that unclear? 
Cool. Interesting design choices :) Here's the one I've been working on: http://bazaar.launchpad.net/~washort/+junk/perseus/view/head:/perseus/__init__.py
Doesn't enforce immutability.
sounds like it needs to make a comeback - before I tried it, I found quite a few posts on stackoverflow, etc. about doing this but with no clear solution
Why?
made me think of [coding like a girl](http://headrush.typepad.com/creating_passionate_users/2006/03/code_like_a_gir.html).
made me think of [coding like a girl](http://headrush.typepad.com/creating_passionate_users/2006/03/code_like_a_gir.html).
What is that? super(A,self).__init__(self) Please check your code before publishing it as a recipe. BTW here is a workaround object.__setattr__(a, "value", 42) 
Probably something I'm doing wrong, but hotswap won't update any changes made to the methods of a wxPython main frame. Any other alteration (even across different files) work, so not much of an issue at all. I think there was a wxPython example with a frame + toolbar button and a panel, the background colour of which you could change by pressing the button. You could then modify the hardcoded colour in the panel method and instantly, pressing the toolbar button would change the panel colour to the new one. The slight issue I'm having is that if you wrote a panel method with the colour as an argument and if in the mainframe you altered the button callback method and changed aPanel.setBackground("red") to aPanel.setBackground("green"), this wouldn't hotswap. ...like I said, probably something I'm doing wrong, or a limitation of wxPython. There are still plenty of other times hotswap will save the day :-) Sorry haven't had enough coffee yet, I hope what I wrote makes some sense! If not, I'll try and dig the examples tonight...
&gt;&gt; **CPython** is for GILs &gt;FTFY :P FTFY
I think you thcared them off, joeldavith. \**adjusts pocket protector*\*
It is not about flattering or not. It is leveraging a stereotype for a cheap laugh. How would it look if you went to a country music conference with a t-shirt "country music is for black people" or a dance conference with a "dancing is for white people" t-shirt, or a finance conference with "finance is for gentiles" t-shirt? Some things are just too touchy, or too complex, and should be considered out of reach for a cheap laugh, or any trivial treatment.
Exactly. To address a serious issue, even if it is well meaning, with a cheesy, non-humorous t-shirt slogan, is to reduce the topic to a level of triviality that belittles it. We have a LONG way to go towards improving the situation before such t-shirts can be considered appropriate.
Linking something called upskirt to an article ... now that's just mean.
DispatchNode._iwithout uses newchildren but never defines it. ListDispatch.to_bitmapdispatch iterates over key, value but uses item. Both in the latest version at time of this comment.
Does this work with any spreadsheet program or just gnumeric?
Thanks, both have been fixed. Bear in mind that this is the repository of my sandbox, so I sometimes commit broken code for synchronization purposes.
sure, just thought to mention it because it was allready 5 days old ;)
Thanks again.
only gnumeric
A barcode is just a code for a line of numbers and the scanner converts the bars back to numbers. So a barcode-scanner is just another kind of keyboard. It is just connected to the PC like a normal keyboard via usb or PS/2. 
Last time I wrote a software that used one of those, they had a keyboard wedge (at least the type we used). Keyboard wedge connects instead of the keyboard and the keyboard connects on top. When a code was scanned it was as if typed into the computer (so all you had to do was make sure the cursor was at the right place before a scan). But it was a long time ago, i don't really know how they work now. From a quick Google, they still sell a lot of those with PS/2 Keyboard Wedges. http://www.barcodediscount.com/cats/barcode-scanners/discount.htm Edit: Madcultist answered should refresh before posting 
http://pyspread.sourceforge.net/
Most barcode scanners are simple serial input devices, like keyboards. To use them you just need to be able to take standard input.
Worth Data LZ160-USB works awesome and shows up to the computer as a keyboard. It even hits "enter" after each scan for you.
Worth Data LZ160-USB works awesome and shows up to the computer as a keyboard. It even hits "enter" after each scan for you. Edit: It's not cheap ($199), but the cheap ones I tried didn't work at all...
Get one of these: http://www.barcodesinc.com/honeywell/ The 3800G is pretty cheap, and does 1D barcodes perfectly There are better ones that work with pretty much every barcode ever made, but they're 300+ EDIT: I meant to link to honeywell, but linked to an ecommerce site. I've never purchased from them directly, so I can't recommend them purchasing wize, but they have tons of products on their site for this. EDIT2: The majority of theses scanners act as standard USB input devices. They scan and interpret the barcode in the device, and output pure text to the computer. This means you wont need to do anything in your program to support the devices, or worry about crazy drivers or libraries. 
Seems like it would be less expensive to get a cheap camera and use software to interpret the barcodes. I have [zxing](http://code.google.com/p/zxing/) in mind right now.
Part 2/2 was not recorded properly but we covered similar content as http://vimeo.com/20760298 and this http://vimeo.com/20768689 (although we did not build an online store but a facebook clone)
yeah, it just emulates keyboard strokes. You can even program some of them with actual bar-codes to add in the keystroke or not. I work with em all the time at work, so any questions, feel free to PM me.
Motorla (formerly Symbol), Intermec, Socket Mobile, Barracoda and Honeywell all make scanners. Are you reading 1D or 2D barcodes? You can use a keyboard wedge like dayimproper suggested if the barcode is going to be "typed" into the active input field. What device/OS will your application run on?
Hi /r/reviewmycode, why aren't you using [Rietveld](http://code.google.com/p/rietveld/)?
I'm a fan of django + piston. Python already has built in json support. Honestly though, its cos I haven't tried anything else in pythonland.
I used [piston](https://bitbucket.org/jespern/django-piston/wiki/Home) with django to write an API. I had some trouble with csrf middlewear, but it's nothing that a couple of lines couldn't sort out. Piston is very usefull if you are using django, but I doubt it would be the best option if you were not using it.
Looks cool, thanks for the link; though not only not all of the /r/reviewmycode users use SVN...
web2py has support for json and xml built-in but we have a new feature in trunk and an open RFC. This is the time to tell suggest changes and improvements: Assuming you have this model: db.define_table('person',Field('name'),Field('birthdate','date')) db.define_table('pet',Field('owner',db.person),Field('name'),Field('info')) You can do: @request.restful() def api(): def GET(*args,**vars): patterns = [ '/person-by-id/{person.id}', '/person-by-id/{person.id}/:field', '/person-by-id/{person.id}/pets[owner.person]', '/person-by-id/{person.id}/pet[owner.person]/{pet.name.startswith}, '/person-by-id/{person.id}/pet[owner.person]/{pet.name.startswith}/:field', '/person-by-birthdate/{person.birthdate.year}', '/person-by-birthdate/{person.birthdate.year}/{person.birthdate.month}', '/person-by-birthdate/{person.birthdate.year}/{person.birthdate.month}/{person.bithdate.day}', ] parser = db.parse_as_rest(patterns,args,vars) if parser.status == 200: return dict(content=parser.response) else: raise HTTP(parser.status,parser.error) return locals() (the above is a complete program, it does not need anything else) This exposes APIs like http://...api/person-by-id/1/pets http://...api/person-by-id/1/pets.json http://...api/person-by-id/1/pets.xml http://...api/person-by-id/1/pet/Snoopy/info.json http://...api/person-by-birthdate/2005/3 and more... This functionality is in trunk but the syntax may change a bit. We may implement some shortcuts. Remember that when it is set we guarantee backward compatibility. If you use patterns='all', it will generate patterns automatically for all readable fields of existing tables. EDIT: web2py comes with [this file](http://code.google.com/p/web2py/source/browse/anyserver.py) so you can run it with any wsgi server you like. we also provide cgi, fsci, scgi adapters. EDIT2: In case this was not clear. The few lines above build the sql queries from the patters for any of the supported databases (including Oracle and Google App Engine).
From your web page it doesn't appear that web2py will work with Cassandra (and the only NoSQL db that I saw was google app engine) how hard is it to add database models/modules to web2py? 
we have experimental support for CouchDB and working on MongoDB. The new DAL is very module and has a NoSQLAdapter. You would inherit the adapter and call the cassandra API. It is not difficult and not much code to write to do but you will have to understand a bit how the DAL works inside. I eventually will write this myself but not today. ;-) Join the web2py mailing list if you want to help. 
Hmm... it seems to me [Pyramid](http://pylonsproject.org/) would fit this pattern well with its traversal routing technology.
If you like Java and other "Enterprise" web apps like Spring, then go ahead and use web2py. Otherwise stay far away! 
For a quick RESTful API I like Flask a lot. Using decorators for defining routes is really nice. CherryPy is a close second. I like that they support Python 3, but it frankly doesn't matter yet. I think most all web apps should be designed as a event driven front end tied to a RESTful API, just like Desktop Apps. This breaks the need for the design style that many "Enterprise" applications use.
Hm I can't offer much by way of comparison. I did more or less the same thing with Tornado as a backend and exposed an api that simply returned standard python data structures serializing them using the standard json module. It worked like a charm and feels super robust (ie. the occasional bad parameter passed to it while developping causing an exception in my code is automatically handled by tornado and simply returns the corresponding http error code to the client, while the server keeps running). The whole thing serves a website that templates the data structures to html using the jquery template plugin in the client.
Web2py is nothing like Java. Its syntax is more terse than Django's. It's API is smaller than Django's. Its size is smaller than Flask + SQLAlchemy. web2py has no configuration files, it is built on wsgi. The term enterprise you see in the subtitle is supposed to stress that we target not simply businesses but also non-profit (and that is called an enterprise). You should give it a try before you complain.
I've enjoyed working with Django a lot. I've recently tried out Flask which is smaller and quicker to get up and running with than Django. TBH, I think either one is fine choice.
I amy be mistaken but REST is more than mapping a URL into an action. Every web framework can do that, the difference is just whether the patterns are in the controller or in a separate files. I think the real issue is whether can the framework handle the url automatically and build db queries from them by introspecting the data model? web2py can (example below). What other framework can do it? Since the web2py API is still being debated it would be nice to have some examples so we can learn from it. The web2py mechanism may be made available for other frameworks like Django and it is already available for Flask/cherrypy (if you use them with the web2py DAL, some people do).
Django + [TastyPie](http://toastdriven.github.com/django-tastypie/tutorial.html).
&gt;If you like Java and other "Enterprise" web apps like Spring, then go ahead and use web2py. Otherwise stay far away! web2py is nothing at all like Java or Spring. Perhaps you are simply reacting to the word "Enterprise" in the tagline. That word is often misconstrued, and there has been some discussion about changing it to avoid confusion. It does not mean that web2py is big, bloated, or targeted toward large organizations. It is more about things like usability, stability, security, support, and maintaining backward compatibility of the API so organizations can rely on it over time. For a contrast with Java/Spring, see [this Spring MVC tutorial](http://www.adobocode.com/spring/a-spring-web-mvc-tutorial/) -- below is the equivalent code in web2py (actually, the web2py code adds field validation, a JS datepicker, and an image upload): from gluon.tools import Crud db=DAL('sqlite://storage.sqlite') crud=Crud(globals(), db) db.define_table('person', Field('name', required=true'), Field('birthdate', 'datetime'), Field('address', 'text'), Field('image', 'upload')) def index(): db.person.id.represent=lambda id: A('view', _href=URL('show', args=id)) return dict(people=db(db.person).select(), new=A('new contact', _href=URL('edit'))) def edit(): row=db.person(request.args(0)) return dict(form=crud.update(db.person, row, next='show/[id]') def show(): row=db.person(request.args(0)) or redirect(URL('index')) return dict(form=crud.read(db.person, row), link=A('edit', _href=URL('edit', args=row.id))) 
what other framework ? cubicweb for sure :)
Thank you. This is useful info. I will take a look.
These are great subjects, but I thought the code example could have been better. Problems with the design detracted from the discussion on how to use unit testing and follow TDD.
Most barcode scanners pretend to be keyboards. They can be configured by scanning special codes (e.g. to enable or disable awareness of a certain encoding or variants, but also specific stuff like whether to beep when a code is scanned) and if you scan a code, they will just "type" the characters represented by the barcode followed by a press of the "enter" key. They can be recognized by looking for constant split-second delays between keystrokes followed by an "enter" key press. Other than that, barcode readers are just fancy keyboards for all you need to know.
Piston is awesome. I didn't believe it until i tried it. I am recommending Piston as well.
Most of what piston does, web2py does without additional modules (including oauth1,2,basic auth). In web2py you can use routes.py to make your urls restful (in case thet are not already restful) and if you simply call them with .xml you get the returned dict in XML, if youca ll them in json, you get the return value in JSON, if you can them with .rss (under some conditions) you get them as an RSS feed (you get the idea). If you return a response.stream(file) it will stream the file (supports range requests/partial content/if modified since). And there is nothing to configure. 
I look forward to having a tinker with it as soon as I get the chance.
Thank you!
I believe mod_python is deprecated and you will want to use wsgi.
web2py by no means for me... i'm still learning, as i'm implementing, but i have to admit: i love it! i'm also coming from php background... 
I am building one with Tornado and I love the "just enough" approach that it has. 
Thanks Maximo, you really deserve that name :)
Thanks to the users and contributors. I am mostly responsible for the poor advertisement. 
Your comment was marked for removal by another redditor (so much for freedom of speech)
django-piston is the way to go if you're already using Django. Also If you you're using jQuery to talk to Piston [you should apply this patch](https://bitbucket-assetroot.s3.amazonaws.com/jespern/django-piston/20100426/121/piston-121.patch) , it fixes a kind of nasty bug with semicolons in the headers. Edit: Why the downvotes ... is there something wrong with Piston?
I know it is consistent with the rest of the Python library, but why is elapsed time (natural for a "timeout") measured using the wall clock (`gettimeofday`) instead of a monotonic clock or (optionally) user/system time? Using `gettimeofday` does funny things when an NTP daemon is running or the system time is otherwise updated. It seems like the current implementation is very rarely what the user actually wants.
The versionadded/versionchanged bits refer to 3.2 -- shouldn't that be 3.3?
Dj-webmachine!
web2py - watch the video from pycon to understand why
Definitely check out [web2py](http://www.web2py.com/). It's very easy to set up, learn, and use, but it's also packed with features and very flexible. It's easy to set up [web services](http://www.web2py.com/book/default/chapter/09) to serve JSON as well as JSON-RPC and other RPC methods. And as pointed out by mdipierro, new RESTful API functionality has recently been added. This is probably somewhat outdated, but here is a [quick introduction](http://web2py.com/AlterEgo/default/show/106) to web2py for people familiar with PHP development. I don't know what the desktop app is doing, but as a possible alternative, note that web2py apps can be [distributed as standalone binaries](http://www.web2py.com/book/default/chapter/12#How-to-Distribute-your-Applications-as-Binaries) that run in the browser on the user's local machine. If you've got any questions, there's a very friendly and responsive [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py).
This feature was requested about 2 years ago. See [issue 5673](http://bugs.python.org/issue5673) for details.
Yes, it [was a typo](http://bugs.python.org/msg130851).
Does Python even have an API for those? The only two time sources I know of are `time.time()` and `time.clock()`, the latter of which seems pretty useless on Linux.
At first, I disagreed with flukshun but I actually think he/she's got a point--because of the IMAGE on the t-shirt. The cute little cartoony girl undermines the intended message. I mean, I get the point, and I think it's a cool idea, just maybe not executed as well as it could have. Guido is still my hero though. =) 
bottle is the fastest framework to get your service up and running
I didn't say it is like Java. I said you'd only like it if you like Java. That is my opinion. And yes, I dislike web2py.
Right... Flask and CherryPy have very convenient methods of doing so. I don't consider the RESTful part a difficult accomplishment; I consider the ease of getting the job done a difficult accomplishment.
I've been using Flask and simpleapi to expose MongoDB, but after reading the comments above, I think I'll give web2py another look. 
Every CS student should be taught basic algorithms in pseudocode and tested in them before they ever are expected to learn a language. But that could just be my mathematics background talking...
Can you explain? I hate Java and I like web2py. That is shared by almost every web2py user. What thought process drove you the opposite conclusion?
&gt;I didn't say it is like Java. I said you'd only like it if you like Java. So, you're saying that web2py is *not* like Java/Spring, but for some reason, only people who like Java/Spring will like web2py? If there are no similarities between them, why would you expect preferences for them to be correlated? &gt;That is my opinion. It's more of a hypothesis than an opinion, and I do not think it is a correct one, as I doubt many web2py users are especially fond of Java or Spring.
http://docs.python.org/py3k/c-api/buffer.html#bufferobjects The relevant sentence is "Certain objects available in Python wrap access to an underlying memory array or buffer. Such objects include the built-in bytes and bytearray, and some extension types like array.array." In python 2.x strings were basically byte arrays. In python 3 they aren't, since they support unicode out of the box and unicode characters are 2 bytes. If you want to pass that string as a byte array, which should implement the buffer interface, you need to prefix it with a 'b' (http://docs.python.org/py3k/reference/lexical_analysis.html#strings).
Pyramid. Just checkout [RESTful Pyramid](http://zhuoqiang.me/a/restful-pyramid)
&gt;Flask and CherryPy have very convenient methods of doing so. Can you show some examples?
ಠ_ಠ
It's what I'm using internally in work. Not to the architects level, of course :) Still, I'm enjoying it.
Nope. 1) &gt;&gt;&gt; a.x {} &gt;&gt;&gt; a.x.update(foo=42) &gt;&gt;&gt; a.x {'foo': 42} 2) and as mentioned &gt;&gt;&gt; object.__setattr__(a, foo, 42) 
Not only isn't it relevant, it's also wrong, since Twisted still doesn't support Python 3
A socket in 3.x accepts bytes, not a (unicode) string
&gt; In python 2.x strings were basically byte arrays. In python 3 they aren't, &gt; since they support unicode out of the box and unicode characters are &gt; 2 bytes. It's a common misconception that people think unicode strings (or simply strings in Python 3) are of fixed length e.g. 2 bytes. That's only half the truth (see link below). Strings in Python 3 are UTF-8 encoded unicode strings of **variable length**. http://diveintopython3.org/strings.html#one-ring-to-rule-them-all
well, i'm interested in understanding the various approaches. please let me/us know. (also can check your reddit mail).
For such projects I use cherrypy, which is not actually mainly a web framework but more of a http framework. It is functional enough for web for my purposes, I can get it up and running in no time, and if you need more code reuse, you can add on any standalone python library you want (like cheetah templates etc), as usually glueing them is not an issue. For others I was always lazy to travel on the learning curve.
The quick and dirty fix for this is to just cast to bytes as: ` s.sendall(bytes("this is my message")) ` 
Really? I found piston to be great if you just want to expose your models as JSON/XML/YAML but rather a PITA if you want to do anything more complicated (in which case, all piston really offers is a different way of declaring your views and a slightly simplified way of outputting JSON/XML/YAML as requested - although you probably only really need one, and the simplification sometimes gets in the way).
- There's no such thing as "best web framework". CherryPy isn't a web framework anyway. Tornado, web.py, Django are designed for different purposes. - mod_python has been deprecated. mod_wsgi is what you need. - If you want to do something real quick Django/web2py is all the way. - If you want to "hit the metal", web.py and flask. You need to analyse what you need.
We build it and they will come.
Because the code I write isn't owned by me :(
There is [`signal`](http://docs.python.org/py3k/library/signal.html?highlight=signal) and [`resource`](http://docs.python.org/py3k/library/resource.html?highlight=resource). There is no reason `clock_gettime` cannot be exposed for conforming environments (it's in a POSIX extension that Apple didn't implement), but unfortunately there is no single cross-platform monotonic clock. I don't see this as a good excuse for providing a timeout parameter that can kill the child immediately or never regardless of its value. It should at least "try" to use a monotonic clock.
Best python web framework would be flask. Additionnaly, if you want to expose data as a RESTFul API, you might want to see our kalamar framework, and the JSON/Rest API it exposes: [dyko](http://dyko.org) [JSON API "documentation"](http://dyko.org/jsonapi) The Kalamar framework lays a common ground for working with various data sources, and provide a really easy to implement API if you want to implement your own data sources. The JSON API exposes the whole framework through a simple RESTful service. Feel free to stop by our jabber room if you ever decide to try it, or even mail me if you want.
For the curious: https://bitbucket.org/jespern/django-piston/wiki/Home
In general unicode strings in Python3 *are* an array of (depending on the implementation) either 16 or 32 bit values. You *can* just do everything as encoded UTF-8 but that is not specific in any way to Python3 and might actually be harder in that environment.
i am now :o
This requires asynchronous processing of some sort (processes, threading, etc) which is probably more complicated than the task that you're trying to do. It sounds like you're just using the try/except to swallow up the errors rather than actually recover from them. The best thing to do would be to find out what exceptions are actually being raised then catch them and recover from them appropriately.
You should work out exactly where it gets hung up. I'm going to assume it is getting blocked on an IO operation somewhere. In which case you should probably use a separate thread to monitor if it is blocked on IO and interrupt/close the connection when a timer elapses or some other condition is met. This will make it unblock and throw an exception which you can catch.
Well I'm not a university level CS student but finishing up my second technical diploma and I definitely agree with you. Once you get the logic down, learning the languages is trivial. And after you've got a couple of languages under your belt, the syntax is almost brain fodder. So yeah, that's why I could see why being tested on the fundamental logic of languages, even if your syntax isn't perfect.
this. Start by **not** putting in any try/except statements. Then notice where they occur, and catch **the specific types you have seen only** (This is one thing I miss about static-typed java - functions can declare what exceptions they throw, which means your IDE can prompt you to put your exception handling at the precise point, for the precise exception)
You can still extend the exception class and raise any custom exception you want to in python and then capture that somewhere else. You can also assign a value to a generic exception variable in the except statement and then take action based on what type of exception it is.
When Guido wore that shirt on stage for PyCon 2010, I heard nothing but praise from high-profile female Python programmers in the audience. He definitely meant it as pro-female-programmer, and (at least all the women I heard) definitely took it as 100% positive. The fact that a few people are hypersensitive idiots can't be helped. The rest of us have to continue to live our lives, rather than hiding in a bubble out of fear that someone might be offended.
Pyramid is the best of breed of the Python web world. What you build with it will be incredibly strong and extensible. However web2py is the most productive one. You can just start your server and execute your idea very easy and fast.
You need to run the time limited task synchronically. For code running in your process, you can run the code on a separate thread, and communicate with it using queue or condition. For running child process, it means starting the child and but NOT waiting on it. Instead, install SIGCHLD signal handler and poll the active subprocesses to find which one was terminated. Another option is to start a thread that will start and wait for the subprocess. In both cases your main thread can implement the timeout and will kill a hung process or set a flag in a running thread that it was canceled. 
Some of my favorites were: * [Timing and Implementation Attacks in Python](http://pycon.blip.tv/file/4879979/) * [Javascript for people who know Python](http://pycon.blip.tv/file/4882883/) * [Writing great documentation](http://pycon.blip.tv/file/4881071/)
I believe they still want you to pay for a business license to install *some* packages, as well as 64-bit builds. Thanks, but no thanks.
If this is a new feature, what a coincidence. I used this just the other day.
This was one of the best talks at PyCon
Yeah I started down this path, but I was just seeing a lot of different types of exceptions, so I tried the route of lots of try/except statements to log to a file. My goal was to find and fix the bugs as they filled in the log file, but I still wanted the application to constantly run.
As a female Pythonista, I think this is awesome! The only thing that's sexist about it is it only comes in men's sizes. http://www.23monkeys.com/designs/python
That PyIMSL package is pretty damn cool. I've used it for a couple projects now.
I like the idea of executing code in the console [alt+shift+e], but anything with a little indentation doesn't seem to work... mehhh... Still, the pace of development / detail put into the ide is pretty impressive...
You need Python 2.6 to use PyIMSL.
My first thought was that this: HOST = 127.0.0.1 needs to be in quotes. It won't fix the TypeError, but we all have our internal lint checkers.
&gt; I believe they still want you to pay for a business license to install some packages, Yes, packages like psycopg2, cx_Oracle, rpy2, pyOpenSSL. &gt; [...] as well as 64-bit builds. Not all, only Windows 64-bit. 
&gt; Not all, only Windows 64-bit. Yeah, but Windows users are the main ones who really need a package manager... Anyway, I can always get optimized 64 bit builds [from here](http://www.lfd.uci.edu/~gohlke/pythonlibs/).
If you think it a bug please open a ticket. That is new and they would probably like the feedback.
How's it better/different than NumPy/SciPy, etc.?
We're reading reddit too. :) http://youtrack.jetbrains.net/issue/PY-3104
Any audio of the pycons? I'd like to listen to something python while driving.
Thanks, I really appreciate that! I'm glad the response seemed to be so positive.
Yeah, I want to know about that too. I currently use xlrd and xlwt and it works okay, but if there' s and alternative I would like to know about it.
Well, building those packages on other 64-bit platforms is almost trivial.
which of these isnt free on its own? I use numpy, scipy, and matplotlib...what are the other ones good for?
http://web2py.com/examples/default/examples Do you see anything that can be run on its own? No, because the *context* is always out of sight. If your framework is enforcing a design pattern, then you are probably doing it wrong. Here's a new design pattern, html and js for the view, python for the controller, and a database for the model. Oh, I can't do that? I need a model for my model recoded in python? Thanks. You use factories. I, personally, want something that lets me code python and deliver data to the web, not a brand new language that is just abstracting stuff I would already need to know. Why would it ever be bundled with jquery?!? What, a scaffolding app... Ok, so people who don't know how to use the web at all are going to dive in starting with web2py? Obsessed with backward compatibility? That isn't pythonic. Do what is best for security, stability, functionality, and performance. People can stay with their old versions if they can't be bothered to do things properly. While that seems subjective, thats why mission statements exist. 
You know reddit is open source right? [Here](http://code.reddit.com/) is the official trac which has all sorts of links and resources to get you going, including the source. If you haven't already, then I'd suggest checking it out and browsing through it to get a better idea of what goes on behind the scenes. You might also consider contributing. Good luck.
The algorithms are more robust, and far outnumber those of Numpy/SciPy. I did a project to optimize addition of brewing salts for homebrewed beer, but the SciPy optimization routines couldn't handle constraints. It's a more professional function catalog, and you'd probably need to know what you're looking for to distinguish their algorithms from the SciPy ones. They also have pretty good "run of the mill" routines. LP, QP, stat functions, neural networks, genetic algorithms etc. 
Is that not what ActiveState is shipping? Seems strange they'd include PyIMSL if it didn't work. I just downloaded PyIMSL seperately and installed on my ubuntu machine's default Python install...
PyQt4 for Qt development (obviously), and as a fast Matplotlib backend.
blip.tv lets you download the source `.mp4`, from which you could extract the audio, if you were so inclined.
I think the point was in Java you are forced to somehow deal with all possible exceptions in one way or another. In python you might catch an exception, say a 404 error, but then your script bombs out another time with an exception you didn't know anything about. You can only deal with stuff you know about.
You are right. web2py applications need web2py to run. That is why it is called a framework. Applications run inside the framework. None of the examples can run "on its own". That does not mean it is a brand new language. It is pure Python, including for templates, as opposed the weird template language that other frameworks chose to use. We ship with jQuery but you can use any other JS library you like. We are not "obsessed" with backward compatibility. We simply care about users and made them a promise: we do everything we can not break their code, unless to fix a security issue. That does not mean we do not evolve. We have have 2-3 commits/day and one major release every other week. All come with new features and improved syntax. I am sorry you think backward compatibility is not Pythonic. You should give it a try. You may learn a thing or two about good software design and usability.
No please do not. That code is so old should be taken down. I forgot it is still there. It even predates web2py built-in authentication.
PyIMSL is tested to work with ActivePython 2.6. 
The guy who did all these builds is a saint if you're on a 64 bit windows.
Damn it. I hate BlipTV; too high bandwidth use for me to stream. I wish people would just use youtube or something.
Bookmarked for later, since I'm at work. Thanks for this
I was kind of hoping that 2 part Advanced Tutorial would be there. http://www.blog.pythonlibrary.org/2011/03/09/pycon-2011-advanced-python-1-tutorial/
Too lazy to link. Twitter and NLTK, Pipelining, Alex Martelis API design talk. The Patent talk. Zeds 0mq was good. Skip the openstack deployment one, it was crap. Protobuffers in the lightning talk was good. Hillarys keynote was alright. That's all I can think of right now. My brain is still wiped out from pycon. * Edit, Namespaces and Decorators - Another great one. 
I googled and didn't see anything mentioning "ExcelIO", so I assume the OP doesn't know what he's talking about (as if that wasn't clear anyway). FWIW, when I need to write to Excel from Python I just talk COM directly using win32com (which is included in the ActiveState distribution).
Yes, the site is incredibly valuable.
I really crave music production tools based on similar principles...
true, it's just I miss the IDE telling me "catch this exception here" the instant I call a function that mentions it throws that exception in the function definition
&gt; I have a background in engineering and have been using python for the last year or so, but mainly for scripting purposes. Have you built any sort of web app at all in python before? It sounds like not, so: * **Learn a little bit about [WSGI](http://wsgi.org/wsgi/) first.** Enough to understand the basics of how it works. * **Choose a framework.** Take a look around at some of the bajillions of python web frameworks. [Flask](http://flask.pocoo.org), [Pyramid](http://pylonsproject.org/), [Django](http://www.djangoproject.com/) are three notable ones. * **Learn your framework** by building something simple - a blog, wiki, or a simple bookmarking site. This should only take a weekend if you're comfortable with python. * **Level up.** Take what you learned and start planning your reddit clone. Take a look at reddit's source (linked in other responses) - it should give you some ideas on how to handle certain things if you get stuck. Keep in mind their data model code is specific to Cassandra. If you're using a different data store, you might have to approach things in a different way. * **Share.** Show us your results when you're done! Have fun :D **edit** I recommend Flask for getting started. Easy to use + great docs. 
Well, there's Supercollider, and Max/MSP, and the CCRMA software, and CSound, and so on. What exactly are you looking for?
torrent?
&gt;http://web2py.com/examples/default/examples Do you see anything that can be run on its own? By "run on its own," do you mean run without the framework? I suppose you're right, but what's your point? If you write an application that uses a library or framework, you shouldn't expect it to run if you take away the library or framework. Isn't the same thing true of any Python web framework (Django, Pyramid, Flask) -- the apps don't run without the framework, do they? &gt;If your framework is enforcing a design pattern, then you are probably doing it wrong. "Enforcing" is probably too strong. web2py certainly promotes MVC design (or MTV or whatever you want to call it), but you can deviate from that suggested pattern in various ways if you want (put model stuff in your controllers, put business logic in your views, etc.). Anyway, what's wrong with a framework promoting a particular design pattern? If the MVC pattern doesn't make sense for your particular app, then sure, don't use an MVC framework. But it seems that by definition, any framework has to promote at least some kind of pattern, otherwise it's not really a framework. Again, don't the other Python web frameworks all promote some kind of design pattern as well? &gt;Here's a new design pattern, html and js for the view, python for the controller, and a database for the model. Oh, I can't do that? I need a model for my model recoded in python? Thanks. Well, I think you *can* do that with web2py if you really want. web2py does not require you to use its own template engine or database abstraction layer, though I suppose if you don't want to use them at all and really want to build your own custom framework, then web2py isn't your best option. I think you'll run into the same issue with any full-stack framework, though. Even Flask includes Jinja for templates. &gt;I, personally, want something that lets me code python and deliver data to the web That sounds simple, but there's a lot that goes into "delivering data to the web" that a framework can handle for you. &gt;not a brand new language that is just abstracting stuff I would already need to know. Where's the "brand new language"? web2y is written and programmable in Python (including the templates). Like any framework, it has an API, but not a new language. &gt;Why would it ever be bundled with jquery?!? Why not? It's useful and makes some things easier. But if you don't like it or need it, drop it and use something else. What's the big deal? Even Flask includes [documentation about using jQuery](http://flask.pocoo.org/docs/patterns/jquery/). &gt;What, a scaffolding app... Ok, so people who don't know how to use the web at all are going to dive in starting with web2py? Again, why not? The scaffolding app as well as some other features probably do make web2py more approachable for people who are not experienced web developers. Is there something wrong with that? If you're an expert and don't need the scaffolding app or other such facilitators, you are free to ignore them and use web2py as flexibly as you like. &gt;Obsessed with backward compatibility? That isn't pythonic. I don't think this is an issue of being Pythonic. Clearly the transition from Python 2 to Python 3 has been a big deal, and breaking backward compatibility of the language is not likely to be repeated with great frequency. Backward compatibility will matter more in some situations than others. I don't see why Python can't have at least one web framework that cares especially about backward compatibility. &gt;Do what is best for security, stability, functionality, and performance. There may be some confusion about what is meant by backward compatibility. It simply means that the API continues to work the same as new versions are released, with exceptions for correcting bugs or security vulnerabilities. The API may grow a bit over time as new functionality is added, but old apps will continue to work upon upgrade without requiring code changes. There are many technical changes that can be made under the hood to continually improve performance and stability without affecting the API. web2py also continues to add functionality at a rapid pace, with new releases every 2 to 4 weeks. &gt;People can stay with their old versions if they can't be bothered to do things properly. The way some people "do things properly" is by adopting a framework that promises backward compatibility so they can quickly and easily take advantage of new releases that improve "security, stability, functionality, and performance" without having to do a major re-write of their code. Overall, it sounds like your criticisms would apply equally to any full-stack framework, and to a large extent even to many less-than-full-stack frameworks. It's not clear why you are singling out web2py, particularly since it appears you have not used it and don't really know much about how it works.
good point. I was retyping the code and forgot the quotes.
Right, so it would make sense if it said 'import web2py' somewhere. But, it doesn't. I Django for big things, and CherryPy/Flask for small things. I feel like too much is shoved down my throat with web2py. Promoting a design pattern is one thing. Like you said, you can blur MVC in web2py, but if you just want to use the database itself as the model, you are out of luck, and conflicting with all of the documentation. Very hard to learn how to use something when your use i &gt;Obsessed with backward compatibility Those words are taken from the web2py page. I wouldn't want to use a system that claims with. Don't be defensive... you can't please everyone. Comparing to Flask is funny. They even focus on design for their pages and documentation. I happen to like nearly everything about the Pocoo team. I'm not sure why. Maybe it is the coding style or their candor. Or how straightforward their documentation is. &gt;Overall, it sounds like your criticisms would apply equally to any full-stack framework You might be right. Using a full stack framework prevents me from separating the front-end from the backend to the extent that I like. I still Django though, so I'm not sure why it doesn't bother me.
&gt;Right, so it would make sense if it said 'import web2py' somewhere. But, it doesn't. Right, but that has nothing to do with an application "running on its own." A few boilerplate imports do not make Django or Flask apps run on their own either. This seems like a minor issue -- if you want to remind yourself you're using web2py, just type '# import web2py' at the top of your files. &gt;I Django for big things, and CherryPy/Flask for small things. I feel like too much is shoved down my throat with web2py. It appears that all of your complaints apply equally to Django (and many to Flask as well). That's not to say there are no reasons for you to prefer Django, just not the reasons you have stated. I think web2py is a lot more flexible than you imply. Perhaps if you really tried it, you would realize that. &gt;Promoting a design pattern is one thing. Like you said, you can blur MVC in web2py, but if you just want to use the database itself as the model, you are out of luck, and conflicting with all of the documentation. I don't see why you're "out of luck." You don't have to use the web2py DAL. Do you have an example of "using the database itself as the model" in Django that could not be done in web2py? Doesn't the Django documentation focus on using the Django ORM for your models? &gt;&gt;Obsessed with backward compatibility &gt;Those words are taken from the web2py page. I wouldn't want to use a system that claims with. I don't think the web2py page says "obsessed" anywhere. And it's not clear why you wouldn't want to use a system just because it promises backward compatibility, but if that's the case, then I think you'll have to [give up Django](http://docs.djangoproject.com/en/dev/misc/api-stability/) as well. &gt;Don't be defensive... Not being defensive -- just clarifying some misleading statements for the benefit of other readers. &gt;you can't please everyone. Actually, that was exactly my point -- you can't please everyone, so it's good to have some diversity in our choices. You seem to be implying the opposite -- that ignoring backward compatibility should be pleasing to everyone. &gt;Comparing to Flask is funny. Not sure why. I'm not saying it's the same as web2py, just that it does some of the same things for which you criticize web2py (e.g., apps don't "run on their own", promotes a design pattern, provides an API that "abstracts stuff", includes a template engine, incorporates jQuery). The Flask documentation even mentions that it is "based on convention over configuration."
If you check the RSS links there should be full audio in FLAC for all talks shortly, the transcoding is running now.
YouTube doesn't let us post 1) such long files and 2) all the different formats.
I'm sure one will surface soon via Miro.
We did not record tutorials this year.
er... feel badly.
that's an interesting problem. I'm not sure I entirely buy the idea of hot-swapping code; seems like it could lead to some strange bugs due to the state held by the application. My version isn't as powerful since it just restarts the entire application, but at least you avoid stuff like this.
Any advantages over http://scikit-learn.sourceforge.net/ ?
I thought about that, but it's no really going to work when I deploy the application on a Linux box later on, so xlrd and xlwt it is. 
You could try setattr(doc.main0, "H5_BC_CASE_DOC_H5_BC_GS_DOC_FLAG$0", "Y") It's very ugly, but it might work. Here's the documentation on setattr: setattr(...) setattr(object, name, value) Set a named attribute on an object; setattr(x, 'y', v) is equivalent to ``x.y = v''. 
Why?
it'd probably be better to move here http://www.reddit.com/r/WeAreTheMusicMakers/comments/g4qq8/for_those_of_you_who_are_also_into_programming_we/
&gt;K-means clustering. A simple implementation but it works well with very large datasets. Many of the clustering options on `scikits.learn` state, "It will have difficulties scaling to thousands of samples." But the [K-means](http://scikit-learn.sourceforge.net/modules/clustering.html#k-means) doesn't explicitly state that, so maybe there's no real advantage for that one.
Here is a more feature rich toolkit - [orange](http://orange.biolab.si/)
Any reason to use these over [python(x,y)](http://www.pythonxy.com/)?
Does BlipTV allow you to make a low-quality format; one that doesn't require me to buffer for half an hour?
A few reasons: * Cost: that's two extra days of video work, which isn't cheap. * Interest: we saw from last year that very few people watched the tutorial videos (compared to the regular sessions). Combined with the cost this means we'd be increasing our video costs for only a moderate payoff. * Some tutorial presenters aren't comfortable being recorded. Some do training professionally and feel that free versions of their material online could cut into business. Others don't own the material they're presenting and thus don't have the right to give us recording permission. Managing who can be recorded and who can't turns out to be a pain in the butt.
excellent ;) nevertheless, cool feature...
why not download it from Blip? there is a "Files and Links" on every video page. I download several .mp4 version.
Note, the first two thirds of the [web2py](http://www.web2py.com/) tutorial was recorded -- access [here](http://www.blip.tv/file/4879126) or [here](http://python.mirocommunity.org/video/4052/pycon-2011-web2py-secrets-tuto).
appreciate the answer but like Chomskyismyhero I was looking forward to seeing some of the tutorial sessions. :(
How easy is it to drop orange in to an existing program? From the looks of it, orange seems to be more of a stand-alone analytics tool rather than a library of useful functions and classes.
looks like they are the same one: 1/2.
I was getting worried. Over a week and no "what is the best python framework" question. 
Yes, sorry for the confusion -- those are two separate links to the same video. The video is labeled 1 of 2, and it covers about the first two thirds of the tutorial. Unfortunately, the last hour (after the break) was mistakenly not recorded -- so there is no 2 of 2. However, the second part included material similar to http://vimeo.com/20760298 and http://vimeo.com/20768689. And I believe there are plans to post a new video showing the exact coding example covered in the second part of the tutorial (a Facebook clone) -- it will probably be posted [here](http://vimeo.com/tag:web2py) in the next week or so.
From the ActiveState site: "ActivePython Community Edition now includes all the most popular and latest versions of NumPy, SciPy, matplolib and numerous other key python packages including the latest release of Enthought Tool Suite and Roguewave's PyIMSL In addition, ActivePython Community Edition distribution includes PyQT and wxpython, essential cross-platform GUI toolkits for building desktop applications." It implies that the CE comes with all these packages pre-installed. It doesn't. You still have to install them yourself. 
From the looks of it? Does import orange sounds easy enough for you? Take a look at their python scripting documentation http://orange.biolab.si/doc/ofb-rst/
The PSF funded the Cape Town Python Users Group to do some of the work [a few weeks ago](http://ctpug.org.za/wiki/Meeting20110305).
Technically, you're correct. But "ActivePython CE now includes foo, bar" is not very different from saying "Ubuntu 11.04 now includes package foo, bar in standard repository". In either case, unlike other mechanisms of install (such as hunting for .msi/.dmg in SourceForge/SO/unofficial-sites), the said packages are made available for straightforward/easy install via a single command (eg: `pypm install matplotlib`).
Hmmm no dice it seems. Getting the following error. " setattr(doc.main0, "H5_BC_CASE_DOC_H5_BC_GS_DOC_FLAG$0", "Y") File "C:\Python26\lib\site-packages\win32com\client\dynamic.py", line 566, in __setattr__ raise AttributeError("Property '%s.%s' can not be set." % (self._username_, attr)) AttributeError: Property '&lt;unknown&gt;.H5_BC_CASE_DOC_H5_BC_GS_DOC_FLAG$0' can not be set." Thanks for the help though
I just checked example_wx.py: &gt; If you want to change code inside an event handler a simple wrapper as follows makes in 'hotswappable'. The binding of _OnChar is not replaced by new versions but OnChar is. just maybe... I should've read the documentation, back in 2004. :-)
Hi Massimo, could you please post the code for your the facebook clone somewhere, it would be really helpful for people like me who are learning web2py
I forgot about that. Is there a blog post somewhere summarizing their work?
Not that I've seen, but I'd like to write a follow-up for the PSF site. Now that the craziness of PyCon has past, I'll see if I can get details from them.
Incidentally I just tested it, and Matplotlib seems to work fine now in Python 3; those folks did a great job!
click the "files and links", there is several urls for download. I have downloaded the [mp4 version](http://blip.tv/file/get/Pycon-PyCon2011AnIntroductionToTornado437.mp4), and it works.
Download it: http://blip.tv/file/get/Pycon-PyCon2011AnIntroductionToTornado277.m4v And play it with VLC.
thanks a lot guys, big help
can someone elaborate this vs django?
eventually someone will, it happens in every thread about python web frameworks. :)
web2py comment in 1...2...3....
Look at this thread. It is about Pyramid. Then somebody mentioned Django. Than YOU mentioned web2py. And somehow you propagate the meme that web2py is injecting in other threads. What you (and others) are doing is very hurtful to the Python community. I do inject ONLY if I have concrete and technical to say.
don't forget flask
I really would like to go but, it's in the middle of my final exams ... But I am confident videos will popup on Reddit anyway xD
Flask is really nice. Deployment... meh.
It's just WSGI, same as Pyramid or Django, so not sure what your problem is here.
am I missing something?
Also found out about this at http://www.blendernation.com/ - best source for blender news. bad news: They have the streaming video at blip.tv, which lags, for me :( The .ogv video file is also slow to download :( I must be patient... maybe true just for me
Abs as in muscles? I'm not laughing though ;-)
sorry, .ogv download was actually quick. google chrome estimate seemed misleading x_x and it is better than watching it from blip. 
.ogv was actually only partially completed. i better use a download manager. bad servers.
ಠ_ಠ
This is awesome work! Looking forward to migrating to Python 3 sooner than later now!
Sorry, I meant deployment in general for the WSGI. Also, Fabric on Windows with recursive directories is kind of a problem right now.
There is a unofficial mirror, too: http://rbw.goe.net/pycon/
my eyes hurt
There is a unofficial mirror at http://rbw.goe.net/pycon/ Edit: It is no longer a download mirror, but a convenient list of all talks on one page (including summaries).
I am eager to try pyramid. I read the pylons book and did some pylons projects. If pyramid is documented the same as pylons, it should be fun.
it's not documented the same, it's actually [much better](http://docs.pylonsproject.org/projects/pyramid/1.0/).
pretty useful. i love looking at mind maps, hate building them though. 
There's a link to the downloadable file on blip.tv. Sorry that my server didn't allow you to download the whole ogv? That's strange...
Just want to let you know that you have a small typo on the front page. [pic](http://i.imgur.com/3Myar.png)
To build it: sudo python setup.py develop make 
As someone learning programming, and python specifically, this is discouraging. How the hell do you know what all of those functions in pygame are and what they do? Even a simple game like that has so many parts that make sense when I see them, but I never would have thought of.
it seems that your server is very slow (at least true for me) that caused the partially completed file. Ahh.. thanks for the tip. It was hard to see the link at blip. but I got it now http://j2.video3.blip.tv/0320005191899/Pycon-PyCon2011UsingBlendersNewBPYPythonAPI687.mp4. Better download speed but still cutting in and out i have to restart my download manager now and then. Maybe you have good reasons, but is it possible for videos to be uploaded to vimeo instead? Most blender tutorials I know are uploaded there. blip is streaming very laggy. The one from your site has a generally reasonable quality. However, while you were navigating data structures, I cannot read any text at all :(. I was cool with Lossless Compression until I reached that part. This tutorial is one of a kind. Interesting perspective. And you're awesome that you are sticking with .ogg and .ogv extensions on the files on your server. Thanks for that talk mate :)
No you actually have to sing. I[t] was demoralizing and embarrassing, but I feel like I grew as a person. EDIT: F' you fingers. Salubrium, your intelligence is only exceeded by your charm and lovely eyes.
I don't have much experience with this, but my understanding is that Django is more of a full-stack solution while Pylons/Pyramid is made to be more customizable and to be used in special cases. I.e. Reddit uses Pylons, many personal and corporate websites use Django
I found this tutorial on Github very helpful... [sjbrown's Writing Games Tutorial - writing games with Python, Pygame, Twisted](https://github.com/sjbrown/writing_games_tutorial)
There are other Pygame games that have a bunch of comments in the source itself (more comments than code, even). It's part of the Code Comments tutorial series: http://inventwithpython.com/blog/category/code-comments/
I'm writing what's become a fairly complex 2D platformer in PyGame. I've done it without reading a PyGame tutorial--what I did was take the chimp.py example from their webpage (it's like those banner ads you see--punch the monkey and win $$$!), and slowly mutate it until it became a platformer. When necessary, I consulted the API (oh look, I need to get the millliseconds since the last cycle through my main loop...and here's this convenient clock object....let me just look at the pygame.time.Clock documentation for a second), but it was mostly just hacking. If I was locked in a room and had to write out an entire PyGame program by hand, I'd be absolutely screwed. But with the skeleton provided by chimp.py (which is 186 lines long, including comments, blank lines, etc.) it was easy to just modify things.
The game's nice and all (and short!), but the font on your blog is absolutely impossible. [Compare.](http://i.imgur.com/bC6Bu.png)
Really? I don't see why you'd pan some code because it uses a specific API. I thought the code was neat, logically named and easy to read. Most of the pygame function calls seemed fairly self-evident in what they do, which means the bulk of the code is focussed on game logic, and therefore seems to be suitable for someone interested in programming games in python.
No I thought the code was great. It all makes sense. I'm just a frustrated beginner. 
Thanks!
I'll take another look at the blog's design. Thanks!
Just want to let you know that you have a small typo on your comment.
No - he was actually yelling at the singers on that page and making them cry.
Don't do it inside Python interpreter. Do it inside shell.
You're welcome, I'm glad you enjoyed it, and sorry for the difficulties!
OK, Just tried. That gives me this error: Traceback (most recent call last): File "setup.py", line 17, in &lt;module&gt; from setuptools import setup importError: no module named setuptools
Just want to let you know that you have a small singer in your thread.
You need to install setuptools. Should be in repos if linux otherwise a quick google will find what you need.
You need to install distribute first.
What operating system are you running? Funnily enough, that error means you need to install the python setuptools module.
*Sigh* \**Waddles away with tail between legs*\*
 sudo apt-get install python-setuptools
Oh boy.
He may have to do a: sudo apt-get update first.
What OS are you using? Windows do thing slightly different when it comes to installing setuptools. See: http://pypi.python.org/pypi/setuptools
if they could be linked to the docs section that'd be slick... pretty cool overall!
Use easy_install, but only to install pip easy_install pip Then, use pip to install the package you want. For example, pip install django-waffle Easy as pie. Quick Edit: This of course assumes what you're trying to install is a registered python package. If it's something you created or that you've found elsewhere this won't work. For most things you want to install, though, this should be all you need. Also, it shouldn't matter where you are (which directory) in the terminal when you run this command. It should automatically know where to install new packages. 
Dude, I've been trying to install scipy for two months and have been too proud to ask about it. Thanks for making this thread.
Don't be ashamed, scipy is a tough one (I spent also a looooong time figuring it out). The FORTRAN dependencies can be very problematic sometimes. Do you have the Fortran 77 compiler installed?
they are useful for hiding liquor..
680GB upstream in 12 hours and no upvote ;)
Better title would be... &gt; Python isn't proud of its package management. And with Python being Python, we should have the very best package management out there. I blame Windows support, but Guido uses Windows so what are you going to do?
Are setuptools going to be part of the 3.x or 2.8 releases? This seems to be a major issue for many people. I am aware of dependencies and system this and that.. but really if its a major issue it should be part of the build.
Exactly my thoughts!
Here it is as a png http://i.imgur.com/T8qxd.png
About the future: &gt; PyPy has an alpha quality cpyext that will allow you to use CPython extensions (requires a recompile), and when that's polished it will be very easy for CPython users to migrate en masse, even though they may have complicated dependencies such as NumPy, SciPy, PIL, etc. I am waiting for this since the beginning of time and probably even before that. This is the main major big extraordinarily feature that will sky rocket PyPy installations. Not available yet. &gt; PyPy has the potential to eventually remove the GIL, and/or have multiple VMs in the same OS process That will be good to have, but maybe not such a big deal. &gt; PyPy could add M:N threading and concurrency constructs to the language (some stackless support already exists, but is not currently compatible with the JIT and doesn't take advantage of multiple cores) Never heard of this N:M threading. &gt; PyPy could simultaneously support Python 2.x and 3.x code in the same process, making it practical to actually make the transition (note: this is a crazy idea that would be terribly difficult) This sounds terribly not useful and maybe a little silly. 
&gt; I blame Windows support How so? After hours I'm a Unix guy (which I prefer), but by day I use windows because all of my clients do -- and I like money. I really haven't run into any particular windows issues in python land. What are you referring to? 
N:M threading means that some number N of user created «threads» are represented by some other number M of kernel threads. Typical setups include creating one pinned kernel thread per CPU core and give each kernel thread a set of preempitve userland threads to run in a round robin loop, thus completely avoiding repopulating the L2 cache when a thread jumps to a new CPU. Om some platforms, context switching and thread creation are kind of expensive operations, and by doing things this way, there is a potential to gain performance. Unfortunately, these benefits rarely pay off in practice, because what usually happens is that the user space threading implementation and the kernel scheduler starts stepping on each others toes. Linux had a N:M threading implementation a bunch of years ago, but switched back to a 1:1 threading model after some rather clever people figured that making plain old context switches and thread creation lightning quick was a better way to make stuff faster. 
I replied to this a few hours ago, but it's not here... reddit's outage issue? Anyway, what platform are you using? I use a Mac, and `pip` install numpy and scipy with no effort at all, once you've grabbed gfortran using a package manager like Homebrew. I'm sure there is an equivalent for Ubuntu and other Linux distros.
No but distribute is a fork of setuptools currently maintained and intended to go into the standard library as distutils2 in 3.x. See the proposed ["state of packaging"](http://guide.python-distribute.org/_images/state_of_packaging.jpg) here. I thought that distutils2 was supposed to be in 3.2 but I don't see it [here](http://docs.python.org/dev/whatsnew/3.2.html).
Thanks for the very good explanation.
You don't need to install setuptools through a package manager like others said, just go here: http://python-distribute.org/ Grab `distribute_setup.py`, then run it from the command line. This works on all platforms (Windows, Linux, Mac). You will now have an `easy_install` command to install packages (or you can use `python setup.py install` as you tried to do before). 
Perfect! This worked. Thank you, kind sir!
* https://bitbucket.org/danjac/newsmeme/src * https://github.com/eugenkiss/Simblin/tree/master/simblin * https://github.com/zen4ever/route53manager/tree/master/route53 * https://github.com/Jach/chatterpy/tree/
You forgot one: http://web2py.com/semantic 
The history. IIRC, \_\_init.py\_\_, os.path, file system case sensitivity, the penchant of Windows people to use .msi's all of the time all took a turn in making packager development harder than it should have been. There's a lot of demoralizing crap that you have to do in Python to support both Windows and Unix, that gets right in your face when you're contemplating writing an installer, and it is the avoidance of crap which is why people took to Python in the first place. And you can't just ignore Windows because so many people are on it, even if it is a step-child os for the language in so many ways. Add the fact that installers are deceptively difficult to write in any case, and that you've got a crowd of people who are all approaching this from the perspective of scratching their own itch, on their own platform, for the version of Python they think everybody should be running, and going so far only as to install their own code, because of course once it manages to do that, development stops. Multiply that by the fact that in Python it's so easy to write a version 0.1 installer and before anyone knew it there were like fifteen million solutions out there calling themselves installer scripts which only serves to make it even more demoralizing to fix the problem for good because now when you go installer shopping Google suddenly starts to fail you with page after page of undated installer thread spam. Whereas, if we only had unix to worry about, it'd have been done right the first time out. Links. tar. A real file system and a real shell.
am I the only one who thinks that this would be a cool way to get an overview of file system structure, as well as easily move/sort from one destination to another? (you know, something cooler than mv/cp =D)
you mean like this ? python distribute_setup.py install 
If you're on linux you may need more permissions to install the module, e.g.: sudo python setup.py install or su root python setup.py install exit
Nope just run this once: python distribute_setup.py This will install setuptools. After that, you can run: python setup.py install To install a package you've downloaded. Or you can use the easy_install command: easy_install packagename
guess that would silence many people who has never tried web2py but talks about it negative all the time. nice response massimo!
Some apps here have source: http://flask.pocoo.org/community/poweredby/
i fail to see how a wsgi server running a wsgi application is somehow an advantage specific to web2py, if you write a wsgi application it will run on all those servers. what are the complaints this is supposed to be addressing? or is it a straw man?(forgivable since it's admittedly propaganda)
you got the video wrong. there were claims such as web2py is not wsgi compliant, web2py does work on its own server and does not run any other wsgi compliant server, web2py is not pythonic, web2py tools cannot be used in stand-alone python applications, etc. this video is a response to such claims. 
The http://pycon.blip.tv archive UI really sucks. If you want to search for a specific talk or just browse for interesting topics, this overview might help.
oh but I did get that. What I didn't get is a link to the claims, only a link to the responses to the claims. That's what I'm asking. To someone who doesn't know web2py(presumably the target audience), that video demonstrates the power of python and the power of wsgi. where's the blogs and such that are making claims to the contrary in regards to web2py? 
just search web2py in reddit and you'll see. :) there are also twitter messages you can read via #web2py.
&gt; I blame Windows support, but Guido uses Windows so what are you going to do? I don't get the first part at all, and Guido doesn't use Windows.
I don't wanna. :), it's not my responsibility to validate the claims, i think that's on the author.
Nice article, you can also submit it to the [semantic web subreddit](http://www.reddit.com/r/semanticweb/) if you want (not stealing your karma ;)-).
It is not "admittedly propaganda." On the contrary, it is intended to *counter* some anti-web2py propaganda. For example, in the past and recently on Convore, several folks have claimed that web2py is not really "Python" and instead is a DSL. That claim is hard to sustain in light of the fact that all those web2py modules can be used in other Python programs, and web2py can make use of other Python libraries, template engines, etc. There was also a reddit thread a couple months ago in which a few people were claiming that web2py is not really Python and therefore prevents "cross-pollination," freedom to "float around" between frameworks, and "contribution to the community at large." I think this video makes it clear that is not true. And just a few days ago, someone incorrectly stated in a reddit thread that web2py only works with its own template engine and database abstraction layer, which this video shows to be false. There are other examples, but you get the idea. :)
The video is not just about web servers. It is about web2py working with other web servers, with other template languages and all web2py core modules being available to any other web framework. I am not pointing out the authors of the false claims (web2py does not plays well with others) because it is not my desire to inflame the situation. There is no social benefit in pointing out that Mr.X lied, is misinformed, or is simply biased. Yet, there is a social benefit in showing the truth.
Ho, completly forgot this page. A lot of code to read. Thank you good sir.
No no no no no no no no. If you'd like something to be 'private', it's name should start with two underscores `__internal_method()`. You can also define the `__all__ = ['class1', 'method2']` at the module level to tell the interpreter what's for external consumption.
That looks really nice, overall. There's just a few things I'd need to bring that into consideration: * The teased Redmine support would be fantastic. * Git support. We have mixed repo formats. * FCGI support. Can't run a new server on our server (don't ask -- really). I'll keep following it, though!
I can't think of any way in which you could expect an html parser to see an actual &lt; and not &amp;amp;lt; and have it not parse it. the solution is to use &amp;amp;lt; in your content and not &lt;
Indeed. blip.tv is great for letting you download content but their index/archive UI trully sucks. Thanks for putting this together!
Even if you use XML, not HTML, you use it to interoperate with someone else. That someone else may not go to masochistic pains to adhere to perfect form. That someone else may have information you want, and is too expensive to make fix the content's form. That someone else may be the entirety of the Internet. Internet's WWW has a lot of broken content.
There is not going to be a 2.8.
`__all__` doesn't make things really private, does it.
&gt; The history. IIRC, __init.py__, os.path, file system case sensitivity, the penchant of Windows people to use .msi's all of the time all took a turn in making packager development harder than it should have been. The history? What is the problem with __init__.py? ntpath exists on Linux as well and is not hard to implement, file system casing is not a problem. In fact there are a couple of issues on Linux that are way easier to support on Windows. Unicode filenames for example.
I actually noticed this a while ago and thought *"Cool! I love Mercurial! Good on them for using it!"* But I was afraid to point it out anywhere (like Reddit) because I honestly had no idea *when* they first switched over and just assumed I hadn't been following close enough and the switch must have happened a while ago and that I would look stupid for pointing it out....
I would argue both pages are not great. They should be ordered by views or quality. I always watch talks by recommendations by others.
Have you tried the [html5 parser](http://lxml.de/html5parser.html)? You could also massage the material before your parser sees it. How big a problem is it? If it is the one file then you can string-replace "Skladem(&lt;5)" with "Skladem(&amp; lt ;5)", or something like that. If it is a consistent problem then you can look for an re like "&lt;\w\S" and replace the &lt; with the &amp; lt ; . (No, I am not advocating parsing html with regexes. But my experience is that screen scraping is a sequence of ugly work-arounds and you just have to get used to it.)
Then including "propaganda" in the title was a mistake.
Interesting article. I'm curious though, does anyone here actually use the Decimal class?
This looks awesome. Finally there's a good solution for self-hosting hg repos for organizations - I wonder why this wasn't shown on reddit earlier. Seems that it doesn't support ssh, but it has https at least. Statistics are a nice touch (gitorious doesn't have anything like that).
No, nor should it. "Private variables" isn't really a concept that needs to exist, and will probably just make your life harder. Also, with your method, you can still access the variables from another module.
You should be able to run as a fcgi daemon (just change the server factory). Also, you could run it in mod_wsgi (see http://pythonpaste.org/deploy/#basic-usage). Haven't tested this though ...
Massimo is well known for his typos. I think the title was supposed to say "anti propaganda" (as it did in his mailing list post), not "and propaganda".
[Obligatory link to Stevey's rant on private and final access modifiers.](http://steve-yegge.blogspot.com/2010/07/wikileaks-to-leak-5000-open-source-java.html)
Awesome book. I took a class under Prof. Downey. Neat guy, innovative curriculum!
You can use a regex for detect a "&lt;" sign before numbers and fix it.
I wish that the author had linked to some official source. I've been hunting for the repository address and had trouble finding it. It seems python.org still refers to subversion in most of its docs, also. I finally started looking through the mailing list messages and eventually found [this announcement](http://mail.python.org/pipermail/python-dev/2011-March/108738.html): &gt; I'm very happy to announce that the core Python repository switch to Mercurial is complete and the new repository at http://hg.python.org/cpython/ is now officially open for cloning, and for commits by those who had commit access to SVN.
Just a guess, but it looks like sys.\_\_stdout__ is set to None for scripts run with pythonw.exe. Using python.exe from python 3.1, importing sys and printing sys.\_\_stdout__ does return something other than None. On Python 2.5, in idle, sys.\_\_stdout__.fileno() is -1, which looks like a dummy value (but I'm guessing). 
No, you can't. The function named `private` will not be visible outside `amodule`. 
[This is why we don't do it in the Python world.](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#naming)
I agree, even more so that the notion of *private* is actually a bit wrong since there isn't really anything truly private in Python ... *non-public* imo is a better term to describe semantics in Python. Also, you don't really need `__all__` in this case since prepending with a single underscore will already protect module members in case someone does `from foo import *` Info on the matter: http://www.markus-gattol.name/ws/python.html#special_forms
They have been talking about for a *very long time*. I'm glad it's finally all done with and working.
It's rather complicated, but I classified about 4000 tweets manually into the various categories that I have chosen. I then ran a term-frequency inverse-document-frequency analysis on those tweets which gave me the "most significant terms" per category. For example, 'football', 'coach', 'team', etc are the most indicative terms that a tweet belongs to the sports category. Since each word has a score associated with how likely it belongs to that category ('football': .9 for 'sports' and .04 for food, etc), then I can take the aggregate scores for a tweet. Finally, I take these scores on those 4000 tweets and run them through a machine learning algorithm. Any future tweet that comes in is given a score, and based on that score, the machine learning algorithm decides which category it belongs to. I oversimplified this extremely, and there are many other issues I've been facing (a tweet that says, "I'm watching Charlie and the Chocolate Factory gets misclassified as food instead of entertainment), but if anyone is interested in learning about my project further, shoot me a message.
I have no experience with open source projects so this might be obvious but I'm curious as to why they're not using Bitbucket? 
two underscores doesn't make stuff private either.
This is absolutely irrelevant. I am not advocating to use double underscore prefix. The `private` function from my example is truly private to the module where it is defined and cannot be accessed from outside, unlike fragile double underscored variables. 
There is a bitbucket mirror of the official repo at https://bitbucket.org/mirror/cpython/overview
As JimH10 pointed out, using html5lib to produce your lxml tree is probably your best bet; it closely follows how browsers handle invalid markup.
I do in unit tests to ensure that some (albeit simple) mathematical calculations end up being correct. As floats aren't the best for this type of comparisons, I ended up using Decimal.
If I were to bet it's because this way they have more control over it and they can probably afford to host their own. Bitbucket/Github and their ilk are great for small to mid-sized projects, but once you get to be the size of something like Python, and once you start having *actual* money donated to keep things going (and full-time employed people running stuff) more often than not the limitations of services like Bitbucket/Github start outweighing their benefits. Don't get me wrong, I absolutely *love* Bitbucket (I use them all the time and plan on putting my future stuff there), but as someone who has previously hosted his own Mercurial (and previously SVN, and before that CVS :-) setups I can definitely see how, if I was running a really large project and wanted to have very precise control over things I'd not use them. 
When you say you've placed it in a stand-alone .py file, do you mean you then ran that file with IDLE? Placing it in a .py file and running with python.exe (not pythonw.exe!) should work. If not, something else is broken. 
Ok, that's one down, but how about when there is now install.py e.g. [SIP](http://riverbankcomputing.co.uk/software/sip/intro) I get 2 errors trying to use nmake, one for visual studios cmd x86 (on Windows): link /NOLOGO /INCREMENTAL:NO /MANIFEST /MANIFESTFILE:sip.exe.manifest /S UBSYSTEM:CONSOLE /OUT:sip.exe @C:\Users\Nick\AppData\Local\Temp\nmFB0C.tmp LINK : fatal error LNK1104: cannot open file 'kernel32.lib' NMAKE : fatal error U1077: '"c:\Program Files (x86)\Microsoft Visual Studio 9.0\ VC\BIN\amd64\link.EXE"' : return code '0x450' NMAKE : fatal error U1077: '"c:\Program Files (x86)\Microsoft Visual Studio 9.0\ VC\BIN\amd64\nmake.exe"' : return code '0x2' and when using an x64 cmd prompt: link /NOLOGO /INCREMENTAL:NO /MANIFEST /MANIFESTFILE:sip.exe.manifest /S UBSYSTEM:CONSOLE /OUT:sip.exe @C:\Users\Nick\AppData\Local\Temp\nmE9BD.tmp MSVCRT.lib(chkstk.obj) : fatal error LNK1112: module machine type 'X86' conflicts with target machine type 'x64' NMAKE : fatal error U1077: '"c:\Program Files (x86)\Microsoft Visual Studio 9.0\ VC\BIN\link.EXE"' : return code '0x458' NMAKE : fatal error U1077: '"c:\Program Files (x86)\Microsoft Visual Studio 9.0\ VC\BIN\nmake.exe"' : return code '0x2' edit: I was following [these instructions ](http://mail.python.org/pipermail/python-list/2010-April/1241727.html) 
Wow..You're right..when I tried to run it as a stand-alone .py file, I was running it through IDLE and not from the command line. When I try from the command line, I get some funky errors, but I can see that it actually started to draw the screen... I'll debug the test script I made and see what I come up with.... Awesome..thanks for the reply! :)
Why don't you use the sound card for this? You can place an op-amp buffer on the D/A to reduce the output impedance to near zero ohms and then you can use a JFET buffer for the A/D to increase the input impedance to the gigaohm range. EDIT: Python has some good ALSA interfaces for realtime audio processing. 
Step 0: Make sure your OS's tick is high enough resolution. Step 1: Try to find a subset of python that will not allocate memory dynamically. Step 2: become frustrated at the lack of available solutions? How about using D? Not quite as high level as python and statically typed. But still pretty awesome. BTW, this `smu` class does not take advantage of (any?) features which are particular to python. It would not be difficult at all to rewrite it in C/C++. The source would end up looking very similar.
Having written stuff in C you can then wrap it in an interface and make it a callable python module. By which I mean you can get [SWIG](http://www.swig.org/) to wrap it for you.
I put this together because the PDF viewer on my droid sucks, and I figured other people might find it useful.
What platform are you on?
waaaaaay over me head lol
I can tell you now that a lack of a HTML version was a great barrier to me not using Learn Python the Hard Way. There's something existentially amiss about opening up a PDF vs. a page in your web browser. Thanks on behalf of everyone, really.
We're Learning Python the Hard Way. We're supposed to hate convenience.
if you see a lot of time jitter in your process, try using SCHED_FIFO scheduling policy on your process + a realtime priority level [0=min,99=max]. ** WARNING ** you might lock your machine up if you are not careful. Keep your RT priority &lt; 90 
I think newer versions of python use input() over raw_input().
shlex can also parse an input stream, so you can just create a shlex.shlex object (defaults to taking in sys.stdin) and just keep reading tokens from it, but I can't figure how to best detect a new line. There's a lineno counter but it sort of messes up when you have strings that span multiple lines like in bash: cmd "multiline arg1" arg2 arg3 The lineno will increment when you get the "multiline arg1" token as well as arg3.
I wouldn't be surprised if he asked you to take it down :( &gt;License &gt; &gt; This book is Copyright (C) 2010 by Zed A. Shaw. You are free to distribute this book to anyone you want, so &gt; long as you do not charge anything for it, and it is not altered. You must give away the book in its entirety, or not at all. I'm not sure if converting it to HTML/Sphinx from PDF counts as altering or not. 
I imagine it must also suck to type the code samples into a Python interpreter on your Droid...
+1 Let's hope Zed thinks so as well; the last guy to touch that book didn't do so well.
 OSError: [Errno 2] No such file or directory ah well
Dive into python goes much deeper.
Are you kidding me? I've been planning on writing a shell all evening and just haven't gotten the motivation to do it lol. Amazing. Thanks
Wrong /r/ ?
What about creating a subreddit for it and submitting all the videos?
What happened?
Ok, so in looking for a good source on the whole 'Learn *Ruby* the Hard Way' fiasco I found that someone had already earlier converted LPTHW to HTML and [Zed did ask him](http://news.ycombinator.com/item?id=1739383) to take it down--albeit very politely. Regarding your actual question, someone ported LPTHW to Ruby and a shitstorm kicked off when Zed asked the author to take it down. I can't seem to find a decent reference, but [this is the YC:HN thread](http://news.ycombinator.net/item?id=1874271).
http://www.pygame.org/docs/ref/time.html#pygame.time.delay Will pause for a given number of milliseconds. This function will use the processor (rather than sleeping) in order to make the delay more accurate.
To be clear, "newer" here means Python 3. In Python 2, even in the recent versions, input() will do something totally ludicrous (it will pass the result straight to *eval* with no opportunity for error checking).
try [pyev's](http://packages.python.org/pyev/) Timer or Periodic objects
I'mma get the PDF too. Thanks for showing me Zed's book regardless of format. Seems like a pretty amazing resource for people fairly new to programming and python (i.e. me).
see also: http://old.nabble.com/IronPython-2.7.1---3.x-Development-td31141448.html IronPython 2.7.1 &amp; 3.x Development by Jeff Hardy-4 Mar 14, 2011
I didn't mean that as the name of a module, just an input output module that handles Excel files.
If you are on windows you would need to use the mutimedia timers http://msdn.microsoft.com/en-us/library/dd743609%28v=vs.85%29.aspx and a bit of low level c or cython to get the clock into your application. Otherwise your clock tick is going to be arround 15ms even though the headers will tell you it is 1ms. 
I'm a great fan of multiple formats, but this ... &gt; I can tell you now that a lack of a HTML version ... simply reeks of lack of motivation. I remember driving across three states one night to get access to an article in a journal that wasn't carried by my college library. Really? Really? Jeebus, people. 
It looks nice, a bit like Djangos forms really. One thing I would consider adding is the option for a hidden field. It kind of a handy thing to be able to do, but unnecessarily in some form libraries. 
&gt; Step 1: Try to find a subset of python that will not allocate memory dynamically. What for? Are you aware that 5-10 ms is on the order of _ten million_ cycles? The only thing the dude might need is to disable the garbage collector (which, unlike most other GCs, is only used for detecting cyclical references, and will not be called unless your working set is growing).
I wanted to do that, but the reddit API requires you to solve captchas whenever you submit a link or comment. The list contains more than 400 talks...
&gt; What for? Are you aware that 5-10 ms is on the order of ten million cycles? Well, the submitter did not mention the target, but yeah, amen, CPUs and cheap uCs are fast. But you only get all of those cycles if you're prioritized higher than other ready-to-run tasks or you have some other scheduler guarantees. Worst case memory allocation is a memory-bound task, not CPU-bound. So all of those cycles are for naught when they're spent in wait states. Overall, it can take a great deal of time. Syscall trap, Push registers, walk an enormous list looking for a block big enough to allocate from, evict pages from filesystem cache, kill processes consuming too much memory, pop registers. Try it and see. On a well behaved system, you'll probably keep up with a 5ms deadline most of the time, but you will probably not be able to do it all day long.
Bluebird: Today we are at the Free Software and Open Source Software development meeting. I saw you were running Windows. I guess that you are probably the only guy in the event running windows. Guido: I am not ashamed of running Windows occasionally. I only have it on my laptop. I have a bunch of eletronic toys that come with Software that only runs on Windows. Maybe they have a Mac version but they certainly don't have a linux driver yet. When you buy a video camera or something like that, it comes with a serial cable or usb connection. There are enough reasons to be able to run windows. My primary development system is definitely linux, my desktop is linux and all the server machine at Zope corporation are linux. 
Your comment seems to be irrelevant. Please read at least the introduction of the book.
I think what he means is altering the content, not the format.
I have, I just prefer dive into python. It covers more features of python like generators and in a fairly quick way while still providing realistic examples of them.
I don't know about most people, I probably am in the minority, but I read programming books like novels. I'll read anywhere from a few pages to multiple chapters at a time, normally don't even go and type the shit in or anything, don't really have a problem learning it though. I've learned quite a few languages that way. side note: It took me awhile, but I learned c++ almost entirely on the toilet by reading 5-15 pages at a time until I was done.
Except you can: &gt;&gt;&gt; def get_cell_value(cell): ... return type(lambda: 0)( ... (lambda x: lambda: x)(0).func_code, {}, None, None, (cell,) ... )() &gt;&gt;&gt; &gt;&gt;&gt; import amodule &gt;&gt;&gt; private = get_cell_value(amodule.public2.func_closure[0]) &gt;&gt;&gt; private() 'private' And this is the reason why it's futile to come up with "clever" ways to protect access in a language as dynamic as python. (Disclosure: I didn't come up with the "get_cell_value" function. Source: http://code.activestate.com/recipes/439096-get-the-value-of-a-cell-from-a-closure/?in=user-2551140)
It totally was. And I did it on purpose because I wanted the kind of logical and artistic mind found here to read it. I knew everyone on this subreddit would see the submission and read it before downvoting it for being not relevant. None of that changes what I originally thought. It was an inception attempt by me, here. Whatever, I'm sorry for wasting your time. Truly, I am. If what I think can't pass the acid test where it counts then I have no right to circumvent that process. Sorry.
But...now that I've seen this comment I know for sure the link has no hidden connection to python. O.o wait this was a self.Python...why? Confused.
&gt;this was a self.Python I apologize for doing what I have and disrupting the consolidated equilibrium established here. Please forgive me. I lurk. and was drunk.
Too bad he didn't stay to the end.
This might be motivation to finally give PyGUI a try.
[Lemon](https://github.com/Doll/Lemon) keeps tracks of your favorite stories on [FanFiction.Net](http://www.fanfiction.net/), downloads and caches newly released chapters, assembles those into a single story file with valid Kindle HTML markup and sends them to your Amazon Kindle e-mail address. After arriving there Amazon turns these \*.html files into their proprietary \*.azw (\*.mobi + DRM) files and then forwards them to your Kindle device Suggestions, feedback, critique and contributions of any kind are very much welcome :)! I know this is most likely a niche market (FanFiction.Net + Kindle) but maybe I'll have some luck.
Dude, no matter what part of last century you're talking about, you could've had someone fax it, or at least read it to you over the phone. What a horrific waste of time and gasoline.
He should have written Dive Into Python is a much better book. 
Shit man, you cant be too proud when you're trying to get shit done. I stay asking "silly" question in #python on irc. They help, I get my work done. I even manage to answer a question from time to time
When is that from, 2003? Since he has been working at Google, I haven't seen him with a non-Mac. At the Language Summit last week, he had a Mac with a pretty sweet case sticker of the App Engine logo.
"Someone" can be difficult to come by, and it can be difficult to impose if there is a single librarian at a distant place.
I'm still using v2.5 because I use [Pygame](http://pygame.org/news.html) a lot and it's the best supported version of Python to use with it.
You need to be sure to do /bin/ls instead of ls (if you're on a unix system), because this simple shell doesn't do anything with the $PATH variable. On Windows... I don't even know. It's probably something like C:\Windows\System32\somethingorother\DIR.EXE
Very nice game. I like the retro graphics. Here's a neat little trick, though: if you change the filename to squirrel.py**w** it will run without the command line window in the background.
It would be nice to have a modern replacement to tkinter, integrated into the standard library. Although I must say PyQt is really cool, so I'm not sure if this is really needed.
Anybody have any recommendations for these packages?
Not a fan of word-play? Also there is a difference between going deeper and being better. My personal opinion is that all python books must have as many Monty Python references as possible and 42 must be used a lot as well. Everything else is secondary. ;)
I remember hearing about this a couple years ago, but I assumed it was dead.
Replacing tkinter would be good. PyQt is way too big to be a viable alternative though.
What are the advantages of this over tkinter? 
Hmm, I'm still a noob when it comes to python and I haven't looked into PyGUI much, but does anyone have any comments about how it compares to PySide? 
And how is your c++ programming? I hope not too shitty...
If you know the specifics of the article. The library can be useful, if you are dealing with a collection. And ... frankly ... if we're talking anything pre-1985 OR anything reasonably technical (I'm not in social studies) ... you don't know what the fuck you are talking about. Back to the original point: Not having HTML is a limiting factor for the OP, when the PDF was available, instantaneously for free? That's a sign of a non-motivated learner. Probably the same kind of person who always asked in any technical class: "Will we be tested on this?" or "What is for?". Morons. EDIT: And given that PDF (in the way it was encoded) can be pretty easily be turned into HTML, the OP could convert it himself, if he wasn't such a terminal lazy fuck.
Seriously: Am I wrong (upstream) here? (I was rude, and probably ought to apologize for that).
har har, but I'm not a great c++ programmer by any means. I can get more or less anything done and have it run well with enough time, but I'll reference things a lot and may reinvent some wheels.
To begin with, PySide is not just a GUI toolkit
I agree, it could fit nicely as a standard, small GUI library for python.
Good shit. I don't do much c++ since all my programming classes in school. I'm more of a web dev lover but I definitely should be continually improving my c++ skills. 
I don't think that pdf is all that difficult. To me some formats can be an impediment. For example I'll reformat something with lines that iare a few hundred characters wide before reading it, and will skip it if I am not able. I also prefer something that makes it easy to reread previous pages. Neither of those limitations are a big deal with pdf, though I suppose that the html version makes it easier to quickly refer to a previous section. The general attitude though is one that is pretty common. I don't think it is some huge problem, but I am surprised with the number of people who express an interest in developing now, and believe that there was some golden age of computing in some other time like the late 70s. The tools that are around now make it much easier to learn, and far easier to actually make something that is nontrivial. Interestingly, throughout the 80s movies' visions of the future that included something like the information availability that came with the internet. Now, it is as though the movies have given up even trying to imagine what we'll come up with next.
True, but Dive Into Python was written for programmers who want to learn Python. Learn Python the Hard Way is for people who *aren't* programmers that want to learn.
&gt; The tools that are around now make it much easier to learn, and far easier to actually make something that is nontrivial. Agreed. No reason to be illiterate though, if in fact, the documentation is in your hands this very second and you don't want to open something in Foxit or whatever.
At the language summit we discussed whether a new GUI toolkit should be brought into the standard lib. Almost no one was interested.
Considering it doesn't run on Linux, I would think the advantages are pretty minimal.
What constitutes a "highly Pythonic" API? I browsed the source for this, and it seemed to fall pretty short. At a minimum, it seems like you'd need docstrings for all of your API which seems to be noticeably deficient here. But also there are clean typing problems all over the place. For example all 'rect's are assumed to be indexable objects where [0] is the top, [1] is the left, [2] is the bottom and [3] is the right. So if you want to create an advanced rectangle object, you must implement ``__getitem__`` for it and just know about those indexes. ``rect`` by default is a tuple so you cannot mutate one once you create it. Just doesn't seem to mesh with Python's idioms to me.
Was this because tkinter was viewed as adequate, or nobody wanted to own the decision, or something else? Having used many Python GUI API's, I have to say tkinter is pretty bad. However none of them are particularly free of warts. Much of this comes from the fact that most of them are fitting a pre-existing GUI toolkit to Python.
You might want to look at Flask and Pyramid. Flask is a micro-framework like Bottle, but it has some nicer things like session management and a more structured core of technologies that it builds on top of (Werkzeug etc.). Pyramid isn't really a micro-framework but it tries to keep the WSGI component-based approach of Pylons/repose. I used bottle for a couple of toy things but am using Flask for current work.
Python believe it or not is an old language now. Look at the state of the file system on Windows back when Python was new. This is what I mean by history, ok? Not talking 2.5 here.
Yeah I had heard from someone else who was at a meeting with Guido that he runs Windows and I could have sworn the ActiveState people were propagating that idea as well. Glad to hear it isn't true, not that it's particular relevant today with Python given its mindshare.
No, you shouldn't restrict yourself. Use whatever you feel is the right tool for the job — just try and stray from reinventing the wheel (though I doubt you'll encounter that particular problem). I haven't used Bottle, but I have used both Django and Flask in the past (I do prefer Flask when using GAE).
What doesn't run on Linux? PyGUI does.
Perhaps I read the announcement wrong. "Python 3 Compatible on MacOSX and Windows" while not technically excluding Python 3 on Linux, is not how one would normally phrase such a capability on a new release announcement.
Neat trick. Here's a more understandable (but obviously less generic) way I just came up with based on the code you posted: &gt;&gt;&gt; amodule.public2.func_closure[0].cell_contents &lt;function private at 0xefaf50&gt; &gt;&gt;&gt; amodule.public2.func_closure[0].cell_contents() 'private' 
So, here's a question: why do you want this so badly?
It's pretty ambiguous because if you follow the link, there is a link to a Linux version. My guess is that it means that PyGUI is compatible with Python 2 and 3 on Windows and OS X, but only compatible with Python 2 on Linux. The Linux version depends on PyGTK, which hasn't been ported to Py3 yet.
What the hell are you talking about.
&gt; No but distribute is a fork of setuptools currently maintained and intended to go into the standard library as distutils2 in 3.x Actually, distutils2 != distribute, although it does still contain some setuptools code in it. (And distribute is not really maintained any more; it still lacks bug fixes that have been in setuptools for well over a year, and most of the devs moved on to working on distutils2.) 
My guess was also that it didn't run in Python 3 on Linux, but after holyteach's rebuttal comment, I thought the correct interpretation was that it always ran on Python 3 on Linux but now it also runs on Python 3 on OS X and Windows. Now I have no idea.
Nobody wants to own it. The release cycles are usually different, they're huge pieces of code, and they require as much TLC as anything else :)
Unfortunate, but true. I often find myself writing GUIs in Python and cursing tkinter the whole time, but I don't have the time, nor would I be likely to succeed, in convincing groups to install wxPython or pyGTK alongside their standard Python install. 
You could always go work for a Linux distributor, then you can do what you want :D
PyGUI runs on Linux, MacOS X and Windows. Unless you're using Python 3, in which case Linux isn't yet supported (due to PyGTK).
Interesting. Can you tell me which version of python that is? Because (at least) in 2.6.1 the cell objects are opaque and have no attributes.
kids have time these days... have a generous downvote.
&gt; Almost no one was interested. What are they intrested instead?
What exactly does it mean to "survive" in the PHP world? Is it like "surviving" in a third-world country rocked by decades of civil war?
Glad to see app.run() instead of app.exec_() or app.mainloop() or something
I think this is actually the second (or maybe third, if you count Zope) surge of Python web frameworks.
At any library worth visiting, "someone" has a job just to fulfill the task in question: an interlibrary loan system. I remember ordering books by interlibrary loan in Hartsville, South Carolina back in the twentieth century. Nowadays I routinely get books sent to my library here in Honolulu from libraries on the mainland. It's not an obscure thing for a library to do.
Learn Python the Hard Way was written for Zed Shaw to further pump up his overinflated sense of ego.
General improvements to the existing standard lib and builtin stuff, speed, harmonizing with all the VMs (e.g. stdlib breakout), packaging, and a bunch of other stuff. Nick Coghlan did a solid writeup: http://www.boredomandlaziness.org/2011/03/python-language-summit-highlights.html
I think it's too bad, because it really goes against the "batteries included" philosophy. But I understand it would be a lot of work.
Use what you know best. And when you find you're limited by something you can either hack around it or look for a better framework. I think bottle is great because it's relatively small and thus gets out of the way. Plus you can dive into the source code to really understant what's going on.
Love the socks and sandals.
well im starting, what else should i grab for alternate reading?
One option is to structure your program so that most of the core logic is isolated from the web layer as much as possible (preferably in a separate source file(s)). That will make testing easier and also make it less painful to change frameworks. I've had good luck with Bottle. If your game will have a full website with logins, accounts, CRUD forms, etc then you'll probably be better off with a larger framework. 
Does is support python 3 now?
i linked to 1.0b1 release because it contains description, but 1.0b2 was released today with some small fixes from me
Modifying the work is expressly prohibited in the license. When Zed asked him to take down the repository, the guy got really defensive and was acting like Zed owed him a thank you for modifying the work.
As long as his license is attached, and his content is unaltered, I'm sure he'll be fine with it.
I found it very difficult to understand what the purpose of this site/network is.
From the website: &gt;Now works with Python 3 on MacOSX and Windows! &gt;(Gtk will have to wait until I can convert it to use GObject Introspection.) So being based on Gtk on Linux, the toolkit doesn't yet work on Python 3 on that platform. And I have no idea how long PyGTK will take to port, it's one of the main things stopping me from using PyGTK itself.
&gt;I've had good luck with Bottle. If your game will have a full website with logins, accounts, CRUD forms, etc then you'll probably be better off with a larger framework. maybe I'm too blinded by the apps I have to write, but, a framework that doesn't help you with "logins, accounts, CRUD forms, etc..." does not seem terribly useful for anything you would want to use a framework for. If I didn't need those things, I'd just use webob(a library).
You're a bit late to the party; this already happened.
in case any of the python guys are reading this ,just thought id say you guys rock and thank you so much for an incredible python tool
You have a good book already, you don't need more than that.
Grab a copy of [the Python source](http://www.python.org/download/) and build the docs (run `make html` in the Doc/ subdirectory; do this online just in case you need to install extra stuff to make this work). I use my local copy of the docs quite frequently. Also, you'll be able to dig into the source code for the standard library if you get curious.
Download the Python documentation from here: http://docs.python.org/download.html It works just fine in offline mode and is a *must have* for python development, even when you know the language.
Buy the book : "Python Programming for the Absolute Beginner" by Dawson. I taught myself Python in a fraction of a summer with that book.
downloading some of the advanced python programming videos from googletalks (youtube/google video) is pretty eye opening after you run through the regular tutorials. idiomatic python/pythonic programming is very different from just translating your regular c-style code into python
By "logins, accounts, CRUD forms" I meant that it doesn't provide any built-in authentication API, ORM or advanced form-handling. Bottle is a micro framework. One nice thing about Bottle is that you don't even have to install or configure. It's a single source file that you can just download and include in your project. That gives you routing, request/response objects, simple templating, cookies, etc. It's great if you have some code that you want to be accessible via HTTP or you want to provide a relatively simple web interface. At work I have half a dozen intranet apps running that use Bottle and it's been perfect for those. In just 5 lines of code you can have the built-in webserver running and routing requests to your code. from bottle import route, run @route('/:name') def index(name='World'): return '&lt;b&gt;Hello %s!&lt;/b&gt;' % name run(host='localhost', port=8080) 
Once you're comfortable with the basics or already comfortable with coding and just need syntax help, I find these [Python quick refs](http://rgruet.free.fr) very useful. They're a bit out of date now I guess, but easily downloadable in a number of formats.
http://diveintopython.org/ is a good download.
Have you looked at a USB-based DAQ board? Their hardware and drivers handle this problem for you and you can use python to generate the waveforms and control them.
[Learn Python the Hard Way](http://learnpythonthehardway.org/index) in HTML or PDF . 
Nope, AFAIK Trent is still working on it.
It maybe useful to download all versions of python for your os. I would also try and get as many libraries as you can. But when learning it is best to stick with fundamentals. 
If you have C++ background this may look attractive to you but Python doesn't need this kind of trickery. Please don't do this.
sure Python 2.7.0+ (release27-maint:85873, Oct 27 2010, 19:38:38) [GCC 4.0.1 (Apple Inc. build 5494)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import re &gt;&gt;&gt; s = 'thing1,thing2/thing3-thing4' &gt;&gt;&gt; re.split(r'[,/-]', s) ['thing1', 'thing2', 'thing3', 'thing4'] 
That could be done more efficiently with re.split.
I don't know if I agree, managing multiple Python installations is hard enough even for experienced python developers. If you're just learning Python install either Python 2.7 or 3.2 .
You might want to check the book's website to see if there's any supplementary material (code, samples files, etc) that you'll need while working with the book.
If you don't know how to program at all "Learning Python" might be a bit advance. However, if you have just a bit of experience with programming and object oriented code, then "Learning Python" will be perfect for you. For learning offline, you need a good python book and a copy of the official python docs.
what is it?
2.6.5
Awesome, thanks Redditors at PyCon... I was stuck on it for about an hour before I started having addiction cravings for the familiar interface.
Also, grab "Dive into Python 3" if you decide to learn Python 3.
Very nice work!
Alternatively there is pyflakes. Maybe someone wants to build a django extension for that, then it wouldn't come with a stupid license :)
\&gt;\&gt;\&gt; help(module)
There was chatter on Convore about one I think.
Yes, unfortunately a lot of what people want can't actually be done statically.
But wait - I thought that writing Python macros for Excel was already easy. Srlsy - how hard is it when all you have to do is record a macro, then copy/paste the generated macro into your Python script. Clean it up a little bit, and you're done.
[https://github.com/ipython/ipython-py3k](https://github.com/ipython/ipython-py3k)
Why? 
A bit too much like Digg...but pretty cool nonetheless. :)
wow regex is really badass haha
download the internets !!!
If you want to be a good Django community citizen, it should be licensed under the BSD license. This has nothing to do with which is better, just that the django community has standardized around BSD, and you will have better uptake if you do the same.
I suggest that along with the book you download some popular modules as well, such as IPython, numpy, and maybe a good editor if you don't already have one. (Personally I like Komodo Edit, others like gvim, or pydev on eclipse.) Other interesting modules to download, especially if your retreat is long, are pygame, nltk, PIL, django, winpdb (a Python debugger), etc. Good luck!
Thanks!
 import re def split(s, seps): return re.compile('(%s)' % '|'.join(map(re.escape, seps))).split(s))
I highly recommend the book [Python Programming: An Introduction to Computer Science](http://mcsp.wartburg.edu/zelle/python/) by John M. Zelle. You can find a free PDF of the prepress version of the first edition online for free but you really should pickup a copy, it's a great book.
It's based on PyLint, which is GPL. So that isn't an option. Also, it shouldn't matter much, since it's a standalone tool that won't be a part of other software; the license only comes into play if you actually want to change or distribute Django Lint.
Although the module seems promising, the article is pretty weak in explaining why. The word `virtual` is misleading and can only be used if one speaks of the -mem layer, otherwise it is just a remapping of filesystem files to aliasses. The .ini config file is unclear, both the website and online resource give too little information, would be interested to read more about this. The fact that it abstracts away file access to different interfaces; zip, web, mem and presents just one is pretty nice. 
I like _How to Think Like a Computer Scientist_.
Wow, I didn't know this. Thanks for pointing that out.
Thanks for the review, good sir! Your review is worth as much as the article itself!
Not that I want it so badly, I was just wondering if it was possible. 
Shock and awe!
I think you forgot to correct for local time, I live in New Zealand and all the times seam to be off by 12 or so hours.
Very entertaining talk.
yikes, should work automatically based on system time. Alas it has been quite a while since I worked on it. Thanks for letting me know!
Have a look at a screencast made to explain and showcase PyFilesystem. It will be much clearer from that. http://vimeo.com/12680842
The site keeps track of the most popular reddit articles, as soon as an article hits the top 250 it appears live on the home page. The idea is that many popular articles hit page 2 or 3, but never make it to the home page. So with this method I am more aware of what is going on on Reddit without having to recheck other pages than page 1 :)
Even though `pylint` isn't BSD I found it superior (for the same reasons mentioned in the link below) over `pyflakes` and `pychecker`. I now tend to mostly use the combo of `pep8` and `pylint` so that `django-lint` will certainly see a spin over here :-] http://stackoverflow.com/questions/1428872/pylint-pychecker-or-pyflakes 
Don't forget about IPython, sometimes it is faster to figure out something new by using a cool interactive shell instead of grepping some html/pdf/whatever docs. We all know it's even faster to google it up, but having an offline copy of google is an issue :-) And while it's not strictly related to Python, don't forget about the distributed version control tool of your choice.
can't help it. lemonparty.org
Can you give examples of "It seems python.org still refers to subversion in most of its docs, also" ? This is something we'd like to fix eventually, and an effort has been made to update all documentation to reflect the new Hg repos - especially in the revamped devguide: http://docs.python.org/devguide/
1.intuitive 2.single verb 3.short 4.no underline
I'll take another look and see if I encounter any Subversion references this time. I know the Dev Guide confused me when I found it because it has a "browse" URL (pointing to the hg repo), but lacks a "clone" URL. I think the same URL works for both purposes, but I didn't know that at the time.
Sometimes you want to do more... ALOT more. Then you have the choice of whether you want to learn Basic.
Shat myself when he implemented Brainfuck using Decorators :-) Funniest thing I've seen in a very long time.
ah thanks! seems good I'll give it a try.
How about Sikuli
This sounds interesting, but I don't see any meaningful information on the project. If this is your project, @cloudform511, please add even some basic information about what I would use this for.
I do VBA....what exactly do you mean by "Python macros" in the context of Excel ?
Thats IT! You "Nailed It"!
Makes me glad I didn't go to the conference. Nothing is really learned beyond what you could find on the various sites for each editor. And they're all essentially the same with different edge features you'd use twice a year if at all. WingIDE's vim bindings are nice though, and the remote debugger is still best in class. 
Yeah, that was beautiful. 
I didn't know there was so much Python I didn't know.
I don't know why, but I just get this vibe that you are trolling.
Examples? (I'm not trying to troll, or anything, I've just honestly had *no* interaction with the web2py community yet so I'm curious).
I does seem like some people are getting caught in that web.
-2 comments. Impressive.
If you're going to PyCon for the talks you're doing it wrong anyway. :-)
If you wanted to get the web2py guys to respond. I recommend posting something about another python web framework. It acts like a bat signal for the web2py people to hi-jack the thread and talk about how web2py does it better.
I've seen two that regularly respond when web2py is badmouthed. One is the creator, not sure who the other guy is (starts with an 'a'). I apparently missed whatever controversy started it, but I do see a lot of people attacking it if it gets mentioned outside of a web2py-specific post, so maybe people are feeling defensive? I could be entirely wrong. I've used it and love it for a few reasons, dislike it for a few. Same for many other python frameworks. EDIT: Your edited in links point to exactly two people, the creator of web2py and av201001, which are the same two I mentioned. I fail to see how this demonstrates a cult-like behavior from users. 
maybe web2py is written by an autonomous ai 
Web2py is not my cup of tea and thats the end of the story. I've been following r/python for at least the last 3 years ( I reboot my account every 6-8 months or 1K karma ) and talking about web2py's flaws, its users, or anything else outside of technical subject matter is a tired, practically beaten to death subject. 
No more than jQuery or Haskell or something. We should all be so lucky as to make a project people want to push on others.
I am honestly not, I'm just wondering if we can clear up why this is the case. It doesn't seem to be this way with **any** of the other frameworks. I can appreciate your comment though. 
The creator [mdipierro](http://www.reddit.com/user/mdipierro) just seems to drop into a ton of posts and tell people to use his product. I think the crew following him makes more of the ruckus, mainly over the last 2 months or so I end up seeing some dude in the comments trying to blast people for not using web2py. 
What possible answer could someone give to this question that would make you say? "Oh I understand, I was wrong, they don't act like a cult" I'm not really sure what you are asking us to tell you.
flask.... now there's a cult for ya. 
and pyramid is built by aliens I hear. 
&gt;I end up seeing some dude in the comments trying to blast people for not using web2py. You might be referring to me. If so, could you point to some comments in which I have "blasted" someone for "not using web2py". Maybe I'm not remembering, but I don't think I have ever chided someone for not using web2py, nor do I recall having seen anyone else do so. Usually it's the other way around -- someone "blasts" people for *using* web2py, and we try to clear up misconceptions and argue that it is at least OK to use web2py (not that you *must* use web2py). If you point to something I have said incorrectly about web2py, I'm happy to make a correction. Thank you.
Lately, I see this kind of prejudice more often than actual off-topic comments about web2py. I am not sure what is more annoying. 
It seems that the Flask, Pylons, Pyramid/Repoze.bfg, Django, CherryPy, Turbogears, and Bottle community get along really well compared to web2py. Obviously people who use a framework and not another do so for a reason but I just don't see Django people coming into a Pylons or CherryPy post telling them what kind of stuff they have in their framework and why their framework is better than yours. The web2py community just seems very bitter. 
no comment from mdipierro yet?! :(
Hmm, looking through his posts I wouldn't call him "cult-like" or even crazy. The absolute *worst* thing I'd call him from what I've read is "evangelist for the project", which isn't really a *bad* thing to be for a project you're involved with and passionate about. He's not even hostile about it in any of the posts I see (in fact, seems quite friendly). Do you have any *specific* examples of persons being overly "cult"-like (e.g., not listening to reason, just mindlessly blasting with the same rhetoric, etc. etc.)? (Also, disclaimer, I'm someone who has become increasingly disenchanted with Python on the web in general, largely due to GIL-related scalability issues and the bloat of many frameworks *like* web2py... So I'm *not* some web2py "cultist", evangelist, or anything of the sort- I'm just someone who likes proof of "cultism" when claims are laid :-) 
If you find a 45 minute demo of IDEs representative of the conference, you need to look at the other talks. I attended for the first time this year, and PyCon was unbelievably valuable. Even this talk was at the very least entertaining, and where else are you going to see succinct demos of the leading Python IDEs all in one place?
Could you please point to some examples of web2py people hijacking threads about other Python frameworks? I'm not saying it has never happened, but I think you'll find it is at best very rare. Meanwhile, it is quite common for people to post about other frameworks in web2py-specific threads, such as [here](http://www.reddit.com/r/programming/comments/g5hxq/web2py_trunk_has_a_new_restful_api_that_writes_db/c1l2bj8), [here](http://www.reddit.com/r/programming/comments/g875i/building_a_minimalist_facebook_clone_and/c1lnyu8), [here](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/c18g0va), [here](http://www.reddit.com/r/Python/comments/ej0p1/new_standalone_web2py_database_abstraction_layer/c18fwcj), [here](http://www.reddit.com/r/Python/comments/dgbj1/complete_conference_management_system_runs_on_gae/c100iop), [here](http://www.reddit.com/r/Python/comments/bwitl/beginners_question_about_good_design_web2py/c0oxr5j), [here](http://www.reddit.com/r/Python/comments/er1eu/run_web2py_with_bjoern_cherrypy_diesel_eventlet/c1a9yd7), [here](http://www.reddit.com/r/Python/comments/ffu1x/hey_apparently_web2py_runs_on_ipad/c1fmbqn), and [here](http://www.reddit.com/r/programming/comments/cy3at/web2py_1821_is_out_and_everything_is_now/c0w4xf6). Note, I'm not complaining about any of these posts -- I think they're generally fine -- just pointing out that they happen. When there is a post about Python web development in general, yes, you will often see someone mention web2py as an option. But in almost all of those threads, you will also see people promoting Flask, Pyramid, Django, etc. In fact, there is probably as much, if not more, promotion of some of those other frameworks than there is of web2py.
Stop blastin me bro
I don't think I ever said your name specifically, I do however remember your name from an argument you got into with mcdonc. I can appreciate your passion for your project but judging my your commenting frequency on web2py I can definitely see where people mistake your passion for something negative. 
I attended this talk at PyCon, and I enjoyed it. I think everyone in the room went in with their biases. For example in the past I used IntelliJ for Java development, and I detested it. So PyCharm really didn't have a shot at impressing me. On the other hand, I had no idea that Komodo Edit was open-source, which made me lean towards Komodo IDE. At the very least, I've now installed Komodo Edit on my work PC to give it a shot before possibly moving to the trial IDE. Having the Emacs representative on stage was a nice touch and, well, interesting, even if my small mind cannot comprehend Emacs key bindings.
actually, it's not, that's the point
Everyone is entitled to their own opinion but to me I think it's just the constant interjection into what seems like **every** other framework post. I understand you are passionate about your framework but it's really out of control. I honestly tried web2py and thought it was okay for doing one or two things but generally disliked it's approach. For example, if somebody makes a thread called [Pyramid and Django](http://www.reddit.com/r/Python/comments/fifux/pyramid_and_django/), people tend to be become pretty turned off when there is a huge web2py discussion within it. I sometimes see other frameworks do it but it never grows to the colossal magnitude that the web2py discussion goes into lol. In any case, the word "cult" was used as a joke...I think you took it way too literal. 
Their attitude conveys that they feel under attack by the creators and users of all the other frameworks. Except that no one attacks the framework on technical grounds or otherwise until they start pissing on other stuff in the python world. In fact the first time I read anything about web2py two years ago it was on the project website and it was something like how django people said it sucked and they defended it with arguments. And I've been around django and the django mailing list two years before that, had never heard of web2py. It looks more like paranoia/schizophrenia than cult following.
Here is a [common example](http://www.reddit.com/r/Python/comments/fifux/pyramid_and_django/c1gaok4)
I can appreciate that but their constant proactive defensive strategy is doing the complete opposite of what they're trying to accomplish. 
I think they care too much about marketing the framework. And people troll them a lot http://www.reddit.com/r/programming/comments/g875i/building_a_minimalist_facebook_clone_and/c1lpr9m
Please note, that thread was not started by a web2py user mentioning web2py -- it was started by someone curious about the poor treatment of web2py on Reddit (in other words, threads like that wouldn't even exist if it weren't for threads like this one). Surely, web2py cannot be held responsible for random people asking questions about it. In any case, even if you want to count that one, it is far from a "common" example.
OK, so does that mean you're referring to someone else? Can you point to *any* examples of someone "blasting" someone else for not using web2py?
&gt;Everyone is entitled to their own opinion but to me I think it's just the constant interjection into what seems like every other framework post. Please, some examples. If it's "every other framework post," there should be many recent examples.
what do you do with it ?
ok..I'm listening.....
YAY JESSE! YAY PSF!
&gt;I just don't see Django people coming into a Pylons or CherryPy post telling them what kind of stuff they have in their framework and why their framework is better than yours. You also don't see web2py people doing that.
Anyone else without a formal computer science education stare at the Y Combinator for a few minutes (unsuccessfully) trying to figure out what it did? Also, I laughed at True = False and cried at __builtins__.True = False
Why did you jump into the conversation then? By joining "random people" in threads that are **unrelated** to web2py you're doing yourself an injustice. 
I did in the thread already, I just think your marketing strategy is just way too aggressive and intrusive. 
dude, your posting history is riddled with examples: [here](http://www.reddit.com/r/Python/comments/fifux/pyramid_and_django/c1gh1ag?context=3), [here](http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1burii?context=3), [here](http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19y7q6?context=3), [here](http://www.reddit.com/r/Python/comments/e6abx/getting_started_with_pyramid_a_notes_application/c15sp9f?context=3), [here-wtf?](http://www.reddit.com/r/programming/comments/e8kaq/a_very_basic_spoon_fed_step_by_step_tutorial_of/c166ksq) 
[here](http://www.reddit.com/r/Python/comments/fifux/pyramid_and_django/c1gh1ag?context=3), [here](http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1burii?context=3), [here](http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19y7q6?context=3), [here](http://www.reddit.com/r/Python/comments/e6abx/getting_started_with_pyramid_a_notes_application/c15sp9f?context=3), [here-wtf?](http://www.reddit.com/r/programming/comments/e8kaq/a_very_basic_spoon_fed_step_by_step_tutorial_of/c166ksq) 
No, not only did a web2py user not start that thread, but it would have stopped after a single response if it hadn't been for two non-web2py users pushing it along. Are you saying that web2py users are not allowed to respond to arguments against them? Anyway, you said "constant interjection" and "every other framework post," yet you're only able to produce one example -- and it's a questionable example at best.
Possible != good idea
Well, it's all about the people. You'll learn far more from talking directly to all the many people who are doing cool things than you will just watching them give a talk. Besides which you'll make a bunch new friends who you can learn even more off. At least that's been my experience. The talks are just a nice bonus.
You clearly have a bias against web2py. Web2py users are no more enthusiastic about web2py than users of other frameworks. This is evident when someone asks something like "which is the best framework?". Some web2py users will say they like web2py the most. Some Django users will say they like Django the most. Same for Flask, Pylons, etc. In fact, there are veteran web2py users who dabble into other frameworks when the situation calls for it. It seems they use what is best for certain particular situations. So I do not think there is a "religious" aspect for many web2py users. As someone who has seen things, I can tell you that one reason certain web2py users appear strongly advocating for web2py is that there are much mean spirits and nasty hostility toward web2py from users of other framework. I am not talking about the casual "I don't like web2py" stuffs, as people make this kind of statements all the time with any framework. I am also not talking about ignorant rants about web2py. I am talking about FUD against web2py from lead developers of other frameworks. Now you've got to understand the lead developer of Web2py has a very different background from those of other frameworks. And as such, the design choices he made for web2py are very different. It's partly from this different school of thoughts that drive these narrow minded people crazy. It's been years that these people claimed the use of execfile in web2py is "wrong". But it all boils down to nothing more than design trade-offs. Recently, they populated the idea that web2py does not "play well with the rest of the Python world" and as such web2py is "seriously harmful to the Python community". These statements are bogus and unsubstantiated. Here is the truth. Massimo has shown in a recent video that web2py does in fact play well with others. You can plug in different template engines, use web2py with various web servers; and you can use the web2py DAL with other frameworks if you wish. The truth is that if you hang out the web2py usergroup, you will witness many people coming from PHP, Perl and other Python frameworks loving web2py. 
Excellent site. Bookmarked! I'm going through some of the lightning talks at the moment and am looking forward to exploring the rest of the web site!
check your sarcasm detector
I accuse *all* web2py users of ruining the internet. 
EDIT: As explained in detail [here](http://www.reddit.com/r/Python/comments/g8hnm/why_does_the_web2py_community_seem_like_a_cult/c1lt0ul), I do not see how those links support your claim. Note, in all of those cases, I was responding to someone else's comments about web2py or the web2py community -- I was not coming in to tell anyone that web2py is better than their framework, as you suggest. Are you saying that web2py users are not allowed to respond to comments other people make about them or about web2py? That doesn't sound like a fair standard.
Congratulations! Pypy is an important project for us all.
Not to knock down your hard effort! But maybe it's best to not fragment efforts with http://python.mirocommunity.org ? edit: your site looks nice though!
No, at most only two of those are relevant, as explained [here](http://www.reddit.com/r/Python/comments/g8hnm/why_does_the_web2py_community_seem_like_a_cult/c1lt0ul), and the most recent was *4 months ago*. There have been just as many interjections by others in web2py-specific threads within the last week alone.
The Reverend is a genius.
[The PSF recently awarded a grant for some work on the PyCon Miro Community.](http://bluesock.org/~willg/blog/pmc/psf_grant_2011.html)
&gt; Makes me glad I didn't go to the conference. IDE questions make up seemingly half of /r/Python, and with new stuff like PyCharm and recent releases of Wing and Komodo, I think it makes perfect sense that this talk was added. People want to know what IDEs do, what they should use or in some cases purchase, and they want to be able to ask questions in person about it. The beauty of a panel talk like that is you get a sampling of a number of things, nothing super in depth, but then if you have a chance to grab the mic and ask a question, you do. Otherwise you at least know who you can go to for a one-on-one question, or you know which booth go to later on to chat about the products. Plus, this was one talk out of three days... (I didn't go to this talk because I already know Komodo is the best.)
Web2py can run from your laptop without internet access. Great way to create a web app.
Every morning I have to login to a web site that tracks my hours the website is stupid and you have to click a button every 30 mins or it logs you out.... So now thats what i have it set to do :)
Congratulations!!! 
Now we know why Armin got his hair cut :D
ex-web2py user here. you are wrong, sir. web2py community is defensive and aggressive because in reddit, in twitter, in irc, web2py has been attacked by many with false claims and it is just because it is not following the same design decisions with their works. it does not have to and it will not. with its decisions web2py is by far the most productive python web framework for new people, for people need things done in a very short time. nobody in the web2py community gives a fuck about what someone else is using. they just don't want to be messed with. 
Hey, this is a thread about web2py, no reason for him to hijack it.
Out of curiosity, what did you use to make it?
Rev. Johnny Healey
I really wanted to try Flask and Pyramid out. But ended up doing it with Django, only libraries I used were South and clevercss. Front end jQuery and jQuery.address helped. Shame jquery lazy_load did not work that well, so I rolled out my own. :)
Thanks, it has been a happy morning. I'm happy that you like it and find it useful. :)
Because web2py is the singularity black hole that means the deprecation of every other programming language and or framework. The non-followers have looked into the abyss and in order to keep their jobs and sanity from the singularity they choose not to talk about web2py.
Pygtk is not going to be ported to gtk3, which is probably just as important - everyone is advised to move to pygobject introspection.. (which also works in python3) there is a script to help with the conversion.
why not upload all the videos to youtube?
You are right. My apologies. I will try to make better judgments in the future. Thank you.
Because...THAT IS HOW AWESOME WEB2PY IS!!! Ask another question. :)
Please, HTML5 video support!
yes, I'm working on it! :) Thanks for pointing it out. does it work ok on iPhone/iPad devices? I'm stuck with a Blackberry for now, so can't really test this that well.
http://diveintohtml5.org/video.html excellent reference
Is there some benefit to that?
hey thanks for that! 
@checkeredface, looking at the links you have now added to your post text, I do not see how they support your point. * Your [first example](http://www.reddit.com/r/Python/comments/fifux/pyramid_and_django/c1gh1ag?context=3) is (I assume inadvertently) quite misleading. You linked directly to the comment of twillis1973, which makes it appear he was referring to me when he said "the conversation started because of your question." If you had instead linked to the [parent comment](http://www.reddit.com/r/Python/comments/fifux/pyramid_and_django/c1gaok4), it would be clear that the thread was not started by a web2py user at all, but by someone curious about the poor treatment of web2py on Reddit. I was merely responding to twillis1973. Perhaps I should have stayed out of it, but it's certainly not an example of the web2py community "trying to convert people" or being pushy. * Your [second example](http://www.reddit.com/r/Python/comments/ex54j/seeking_clarification_on_pylonsturbogearspyramid/c1burii?context=3) does not appear relevant at all, as it is part of a thread that was explicitly *about web2py* (web2py wasn't listed in the post title, but the OP did explicitly ask about web2py in the post text). Not only is it *not* an example of web2py folks trying to convert people or hijack a thread (presumably web2py folks *are* allowed to speak in a web2py related thread), but instead it is actually an example of *Flask* folks "hijacking" a thread about other frameworks to promote Flask and criticize web2py (I put "hijacking" in quotes because I don't actually have a problem with their posts -- there just seems to be a double standard). * I don't get the point of your [third example](http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19y7q6?context=3) -- that too is actually an example of a *Flask* user "hijacking" a thread about another framework (Bottle). mdipierro then made a joke, and then simply made the point that Bottle is more of a microframework than Flask (no promotion of web2py). In a separate comment, he also said, "[Bottle is definitively the best micro framework!](http://www.reddit.com/r/Python/comments/epcxj/the_bottle_web_microframework/c19vb4o)," which doesn't sound like he was trying to convert anyone to web2py. And, in my own comment in that thread, I was actually pointing out how web2py doesn't mind people posting about other projects within web2py threads (and I pointed to a comment by mdipierro making the same point). * In your [fourth example](http://www.reddit.com/r/Python/comments/e6abx/getting_started_with_pyramid_a_notes_application/c15sp9f?context=3), I was simply replying to someone else's comment in order to get some clarification about Pyramid (in particular, whether the linked blog post represented uncharacteristically verbose Pyramid code). * Your [fifth example](http://www.reddit.com/r/programming/comments/e8kaq/a_very_basic_spoon_fed_step_by_step_tutorial_of/c166ksq) is also somewhat misleading. You linked directly to mdipierro's comment providing some parallel code in web2py, but if you look at the full thread, you will see that at least three other people were promoting alternatives to Spring MVC, so the conversation had already turned into a general discussion about framework alternatives (and note, mdipierro was not downvoted). Granted, in the *parent* comment of your fourth example, mdipierro did interject in a thread about another framework, but I think that case (and if you want to count example #5) are literally the only two such interjections I've seen, and even those happened *4 months ago* (meanwhile, there have been two such interjections into web2py-specific threads just in the past week). Perhaps there are a few more examples (are there?), but clearly this isn't happening with anywhere near the frequency you suggest, and no more than it happens *to* web2py.
And you check yours.
awesome! I actually use RPyC in a distributed tournament running system for an AI competition I help put on every semester at my university. RPyC is by far one of the easiest distributed computing capable modules of python I've worked with and highly recommend it!
hmmm I have the similar .net/asp/IE crap to deal with.... so you can make sikuli do that and repeat ? also there's [this](http://code.google.com/p/pywinauto/)
`nonlocal` would work here as well as it's just one level *above* the current scope. More info on `global` vs `nonlocal` http://www.markus-gattol.name/ws/python.html#nonlocal_global
whew. seems to be working fine. 
Make sure to figure out which libraries you may need and install all of them ([use pip](http://pypi.python.org/pypi/distribute#distribute-setup-py) and, ideally, virtualenv). Learning the syntax and the standard library will get you started, but much of Python's power (just as with Perl and other languages with major repositories) comes from standing on the shoulders of giants.
Interesting. I actually switched over from `pylint` to `pyflakes` because `pylint` would often clog my logs with irrelevant messages (e.g. complaining about module-level objects not being named in uppercase even when there's a point to it). Sadly `pflakes` seems to choke on dict and set comprehensions in 2.7 (is it even being maintained anymore?). `pep8` is invaluable if you try to keep your code clean, however. Some of its nagging seems excessive at first (e.g. missing/extra empty lines, missing linebreak before EOF) but it does enforce a healthy level of self-discipline.
There is pdf documentation in the download, but this literally allows you to interface with Excel and Gnumeric as if they were numpy arrays. It is that simple. No effort required on your part AT ALL.
I mean interface with your open excel documents from python. Anywhere.
There is documentation included in the file. Check it out!
Very nice and informative talk. I think it is very important to give python programmers a better understanding of the GIL and the current state of it in python, and how it can be improved (hopefully with the goal of eventually removing it completely -- I think that is the only real solution, certain C extensions like numpy releasing the GIL and running in parallel are just deferring the issue to a later point). However, I don't really buy his argument that removing the GIL completely will exponentially increase complexity in the interpreter. He didn't really present any particular evidence for that claim, and there are other languages around that do it in highly optimized fashions, and still remain maintainable. True, those languages might be very different from python, and their internals (and interpreter) might be very different from pythons. So porting those advantages to python is not quite straightforward, but I think in the long run it will pay off and eventually become necessary, even if it requires some heavy refactoring/changes in many of CPythons internals to make it work properly and elegantly. In any case, it's a great thing we're now starting to talk about it, that is the first step to improvement, and the improved GIL is also a great first step, because it might get people interested and go back on the problem and try to solve it. Not talking about the issue means no progress.
... learn Basic or learn to translate Excel macros into Python. Python has excellent COM support, which makes translating Excel macros into Python about as easy as translating it into native VB6. I did have to write my own libraries for doing common tasks though, like finding the last cell in a range, etc. Sounds like you've packaged up the same code I wrote myself, though you tossed in Open Office scripting, which is a LOT more of a pain. Kudos and good luck :)
Like lets say you want to interface with it through numpy (i.e. matlab equivalent). Try doing THAT from a VBA macro...
... learn Basic or learn to translate Excel macros into Python. Python has excellent COM support, which makes translating Excel macros into Python about as easy as translating it into native VB6. I did have to write my own libraries for doing common tasks though, like finding the last cell in a range, etc. Sounds like you've packaged up the same code I wrote myself, though you tossed in Open Office scripting, which is a LOT more of a pain. Kudos and good luck :)
Are there any discussions on how to use PyOpenCL the right way like there are on OpenCL? 
This was a great lecture. It has also been incredibly helpful during interviews, as the GIL is one of the de facto 'advanced' topics about Python. 
http://c4158.r58.cf2.rackcdn.com/PyQt-Py2.7-x86-gpl-4.8.3-1.exe
It's unfortunate that they (riverbankcomputing) did not provide sha1 or md5sum hashes of the files they provide for downloading. Otherwise, we would be able to verify the integrity of the file that we may have obtained from another source. Here's SHA1 of the file I downloaded from riverbankcomputing and also from the link posted by kurtschwarz (they match): f2c678134034fcef7aa79758226938b5 
How do you mean? PyOpenCL is basically a python wrapper for the C++ OpenCL interface. The kernels you call are actual OpenCL kernels. Maybe you could link to some specific discussions for more context? I plan on making more tutorials that are about more effective GPU computing using PyOpenCL so it would be good to know!
Hey enjalot, I remember you were asking about pyglet vs. PyOpenGL. Why did you decide to go with PyOpenGL out of curiosity? This article looks great btw! I've been wanting to learn PyOpenCL for a while now, think this might be just the thing to actually get me to do it!
Wow, very informative. I don't understand why the interpreter uses os threads at all. It seems like GIL locking requires you to solve problems analogous to all the problems that using os threads solve anyway, so what do you gain? In general, if you can only run one thread at a time, it doesn't matter if you spread across different processors. C extensions that need to drop the GIL and run in true parallel already bypass this system and so wouldn't be affected. It seems like it would actually perform better as you're just dropping os thread signaling: the GIL locking that's there would do all the work (nothing more than what's currently being done). Obviously, this would remove any erratic behavior that could be caused by multiple processors/cores and would give us complete control over how python thread scheduling is done. I don't know much about this stuff though, so I may just be naive.
Very cool, but [PyCUDA](http://documen.tician.de/pycuda/) still looks more straightforward to me.
oh hey qiemem, glad you caught me here! Turns out pyglet doesn't work out of the box on Mac OS X Snow Leopard. I actually have a pyglet version as main_pyglet.py in the same directory that should work fine on windows (and presumably windows)
Well, CUDA is also more straightforward than OpenCL, but the main trade off is that OpenCL is a cross platform open standard. You can use OpenCL on ATI GPUs and Intel chips as well, something that wont happen with CUDA. CUDA has also been around for ~3 more years than OpenCL giving it a lot of time to mature as a language. There are more issues to consider when choosing between the two, but vendor lock-in is a deal breaker for me.
What does this line do ? dict = ast.literal_eval(data1) does it convert any arbitrary html into some kind of dictionary or it's needs to be in specific format like xml or json ?
&gt; except: &gt; print "Unknown error" ಠ_ಠ
Does he get +1 for Honesty ? : P
Weird, it wasn't earlier. Probably just an intermittent fault.
Congrats to the Django team! Now I get to coax the boss into giving me an hour or two of time to get our internal timesheet app (originally written for Django 1.1.x, seamlessly updated to 1.2 with no changes) migrated to 1.3. I suspect it'll be as smooth a transition as 1.1-&gt;1.2 was. I absolutely love Django for web development. Lightweight, fast, and it's actually fun to work with.
i tried the code, and i while running it i am seeing the following error: &gt;from pyopencl.tools import get_gl_sharing_context_properties &gt;ImportError: cannot import name get_gl_sharing_context_properties seems like, i am missing pyopengl ? but synaptic sez, it is installed :(
&gt; True, those languages might be very different from python, and their internals (and interpreter) might be very different from pythons. They are. When you write `print a.x`, roughly the following happens (after the value of `a` has been resolved and before print is called): 1. The object's class's class (aka metaclass) is determined, then its method for looking up attributes is called. 2. Assuming it was the standard `type`, x is looked up in the entire class hierarchy of that object. 3. If it was found and it is a data descriptor (implements `__set__`), then it is used as descriptors are. 4. Otherwise the object's `__dict__` is searched. If the value is found there, then it's returned. 5. Otherwise if the value was found in the class hierarchy, then it's returned/used as a non-data descriptor. 6. Otherwise `__getattr__` method is looked up in the class hierarchy, if found then called. 7. Otherwise AttributeError is thrown. I left out some details like the possibility to override `__getattribute__`. As you can see, there's an awful lot of lookups in the structures which are either immutable or nonexistent at runtime in other languages. I mean, when you write `a.x` in C, all that lookup business is performed by the compiler, which determines the necessary offset and that's that is left for the runtime. When you do the same in Java (assuming that x is a virtual method), additional lookup is performed in the vtable, but it's immutable for each class. So in other languages this machinery is either completely evaluated at compile time, or is immutable and doesn't need to be synchronized at run time. Also, it's much less powerful. Then there are _other_ other languages, such as Javascript, Perl, PHP, Ruby... You see, it's actually an interesting insight into the human nature: Python's GIL has a memorable name, so every dimwit and their little sister knows about it and just How Big A Problem it is. The utter lack of threading whatsoever in the rest of the languages (or the GIL equivalent in Ruby) doesn't have such a marketable name, so dimwits don't notice it. I mean, justifiably: it's not a problem, if you need parallelism you make a pipe and fork, or accept on a socket and fork, or fork and connect to a socket, that how it was done for at least 40 years and everyone was happy. Now you give it a name and suddenly it's a Problem with a capital P.
why would you want a descriptive error message...
It takes a string containing a Python expression and `eval()s` it, but allows only literals (i.e. syntactic types), which means it's safe, you can't inject arbitrary code.
Congratulations to the Django team!
The curry thing can be done way simpler than he does in the [Haskell module](http://pypi.python.org/pypi/Haskell/0.0.1), though. from functools import partial def curry(fn): def _f(*args, **kwargs): if fn.__code__.co_argcount &gt; len(args) + len(kwargs): return partial(curry(fn), *args, **kwargs) else: return fn(*args, **kwargs) return _f 
For me, unfortunately, no transition was entirely smooth. 
Thanks for the mirror. Much appreciated.
Thanks for checking on that. Its nice to have a confirmation some file isn't gonna lock my computer down while blasting horse porn at full volume (again).
Just do it. It's easier to ask for forgiveness than permission.
In regard to dynamic lookups et al: Those problems are fairly easily solvable/mitigatable by use of concurrent data-structures, a few locks and minor re-factoring of the interpreter. Of course minimizing the number of locks would then be another goal. &gt; So in other languages this machinery is either completely evaluated at compile time, or is immutable and doesn't need to be synchronized at run time. Also, it's much less powerful. I do not think it is a valid assumption to say that just because they happen at compile time, they are much less powerful. &gt; ...The utter lack of threading whatsoever in the rest of the languages... Certain other languages being equally or comparably shitty is really no excuse for not doing better or at least aspiring to do so. &gt; I mean, justifiably: it's not a problem That would hold if we were still all using single-core CPUs. If you watch the talk, you can see quite a few problems he is pointing out with it, and rectifying those problems would make python more versatile and elegant. The GIL is a perfectly nice solution as long as you are on a single-core system. On multi-core systems it makes the behaviour of your threads unpredictable and erratic. &gt; if you need parallelism you make a pipe and fork ... Yes, that is a good way to do it, and that is how I mostly do it, but it isn't the end-all and doesn't solve all problems, and it certainly is no reason to not think about how to make a better threading model. Also, threads have been around for almost as long. &gt; Now you give it a name and suddenly it's a Problem with a capital P. No, it has become a problem because CPU architectures change, and our way of thinking about algorithms and achieving effiency has changed. I think it is important to educate people about the details, so that they truly understand when and why it is a problem, and also eventually developers can come with new ideas on how to make these problems go away/become less important. Also, I don't know how long the term "GIL" has been around exactly, but it certainly isn't new, and a lot of people knew about it before, but it just wasn't much of an issue on single-core systems. Spending time thinking about how to make something better is never a bad thing!
You can easily coax pyglet to work by running 32-bit python. Setting an environment variable is a simple way to do this: export VERSIONER_PYTHON_PREFER_32_BIT=yes
Congratz guys, keep up the good work. 
There are two threads referred in the parent comment. I created the HTML version and later took it down on Zed's request. You can still follow the instructions I've posted there to create your own HTML without violating the license. The second thread is about the "Ruby" version shit storm.
The author is playing fast and loose with meaning of uri schemes.
&gt; Of course minimizing the number of locks would then be another goal. That's the whole point: if you have to make like two locks per attribute access, this code would run slower on eight cores than code with GIL on a single core. Plus memory management via reference counting really sucks on multithreaded programs. That's the only reason GIL is still there: there were two attempts to remove it already (some guy in mid 2010-s and Unladen Swallow recently) and IIRC both ended identically: it's easy to put locks everywhere, but this immediately decreases performance of single-threaded programs twofold, and only on eight cores it returns somewhere to the original level, sometimes. &gt; I do not think it is a valid assumption to say that just because they happen at compile time, they are much less powerful. I didn't say that, I said that they are less powerful, period. There are no metaclasses in C++ or Java. There's no `__getattr__` that is called when attribute is missing. &gt; Certain other languages being equally or comparably shitty is really no excuse for not doing better or at least aspiring to do so. It is a valid reason to believe that: 1. There are very hard problems you'd have to overcome to reconcile multithreading with certain language features, such as the ability to modify anything at any time. So you'd better aspire to something else, less hard. 2. The problem itself is not as crippling as one might think, because literally millions of people somehow make useful software not using threads at all. So you'd better aspire to something else, more useful. &gt; That would hold if we were still all using single-core CPUs. I feel like you continue to argue with a wrong thing, despite acknowledging the right thing. I'm not proposing to pretend that GIL doesn't exist. I'm saying that yeah, share-nothing/explicit sharing model that multiprocessing provides is better than multithreading almost always, so the whole problem is not a problem. And it's better than multithreading in an interpreted language always, because the only benefit of multithreading is that you can squeeze those last percents of performance, and if you want that, you shouldn't write that part in Python. &gt; No, it has become a problem because CPU architectures change You know what's the funniest part of all this? You would never be able to run 64 threads on 64 cores operating on the same shared state. Multithreading as an approach to achieving parallelism became viable in 2008 and would become unviable in 2013.
"as easy as", in other words "really annoying". I've written in VBA before, it is annoying. This is much better, try it out :D
Yeah just started an internal app using Django and picked up 1.3 this morning. I'm excited to start using it.
I'm not familiar with SVN. Does anyone knows how to checkout the specific tag to a repo that I already have that was previously checked out from trunk?
Switch
Emacs FTW! When I get some time I'll check out Komodo.
Another reason to consider Linux, many distros have PyQt in their software repositories.
Yeah, keep it simple. Thanks.
## Letter to django &gt; Dear Django, &gt; &gt; Congratulations on the new release. Thanks for adding logging (that helps greatly!) and class based views. The transaction management changes are very welcome to me personally. We know it must be hard managing a full ORM, web framework, and custom stack for a lot of things. &gt; &gt; However, I see your still confused about the MVC pattern. You don't have to make excuses that you got the pattern wrong. We understand. Shit happens. &gt; &gt; Just say it: "For silly legacy reasons and because it's to hard to fix, our "views" are really controllers, our "templates" are really views, and our models... well they are models." It's ok. We will still love you django. &gt; &gt; I know I may pick Pylons, Twisted, or Tornado (or even Node.js, rails, scala, and Manos sometimes) when I do my own stuff, but I still come back to you django for getting that site out for that pesky client as fast as possible. &gt; &gt; You are my rapid application development language. Be proud of that. You save me hundreds of hours of development time to do all the basic stuff that 90% of the sites out there all do. &gt; &gt; You may get on my nerves and burn me a little when I want to go outside the lines a little from what you give me (like wanting to support custom authentication databases that don't exactly conform to your user model concepts), but I know your limitations and how to hack you to do what I want. &gt; &gt; It's still faster than writing the entire thing from scratch usually to hack on you than to rewrite it all because you do one thing I need done different. I know the hacks aren't pretty sometimes and the ocasional forks and modifications of you are a mess sometimes (especially when I can't get a pull from you back upstream before you go and change everything again and force me to have to maintain my patches for several months), but I can take comfort that it gives me a little job security that the client will probably call me back to update the site and that I'm charging by the hour. &gt; &gt; Really I just want to congratulate you on your 1.3 release. &gt; &gt; Keep on truckin! &gt; &gt; Zac Bowling &gt; &gt; &gt; &gt; 
I can identify with those words.
Why the hell is anyone still using svn in this day and age? So sad.
Dear zbowling, MVC never made much sense for web apps anyway, but in order to get people to pay attention that's the terminology we have to start with, because managers are dumb and people distrust strange new things. That's why we have a couple FAQ entries on how this stuff works. Also, remember that class-based views don't change a thing with respect to design patterns; Django is still a framework where the view is a Python callable accepting an `HttpRequest` as its first argument. You were always able to do class-based views (by implementing `__call__()`, and the admin did exactly that), just now we ship an implementation of them to make it easier for the cases where they make sense (which isn't every case).
He overwrites a builtin. Nice work?
MVC never name much sense for web apps??? come again? Them are fightin' words. I challenge you to fistacuffs good sir! 
Well, they didn't start Django yesterday. And looks like they're already quite busy pushing new features do to some boring migration from SVN.
Unfortunately his site is down, but Malcolm's long piece on MVC ([wayback machine copy here](http://replay.waybackmachine.org/20090223170611/http://www.pointy-stick.com/blog/2008/11/30/removing-model-view-controller-straitjacket/)) is a pretty good summary of general issues.
There are [official mirrors](http://code.djangoproject.com/wiki/DjangoBranches#DVCSmirrors) for Mercurial, Git, and bzr.
Thanks, didn't know about that.
These days, it's because SVN is useful as a backend storage for all the other tools. That means you can have contributors using whatever they like -- Mercurial, git, Bazaar, whatever -- and just push back to the SVN repo, since everything knows how to talk to SVN.
That is a pretty horrible argument, everything knows how to talk to CVS too, and it is saner, simpler and more reliable than svn, still makes zero sense to use it for anything.
I'm having the same trouble, but PyOpenGL is definitely installed. Which version of PyOpenCL are you using the beta or 0.92? I can't get the beta to install it complains about missing cl_ext.h... 
Following the Docs: B[6, :10] = range(100) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "PyWorkbooks\DataHandler.py", line 339, in __setitem__ self._set_array_(rows, cols, reiter, args) File "PyWorkbooks\ExWorkbook.py", line 267, in _set_array_ rangeString, stepping = self.rowscols_to_string(rows, cols, value) File "PyWorkbooks\PyWorkbook.py", line 255, in rowscols_to_string temp_rows, temp_cols = self._determine_rowscols_(rows, cols, data) File "PyWorkbooks\DataHandler.py", line 567, in _determine_rowscols_ if hasattr(data[0], '__iter__'): # it is a matrix TypeError: 'generator' object is not subscriptable
&gt; Configurable delete-cascade FUCK! YES! :D
but but but... design patterns!
That's great stuff, thanks. I'll probably put it to use soon.
Sorry if my opinion is tainted by this, but I'm a TextMate user (no vim/emacs, here)... I've been using Komodo since I watched this video, a week ago. And I'm sold. It doesn't feel as bloated as the other IDEs I've used in the past (for Java: Netbeans, Eclipse). It's worth a shot, but it's a little steep for a student ($100)...I haven't bought it, yet. Dreading the end of my trial
Is 'nonlocal' new?
Not a moment too soon, I was planning to do this with node but this is much superior, thank you.
&gt; Which version of PyOpenCL are you using the beta or 0.92? I can't get the beta to install it complains about missing cl_ext.h... i am using the 0.92 version. i think that is one that comes with ubuntu. haven't tried to build stuff by hand though
here is another http://codysoyland.com/2011/feb/6/evented-django-part-one-socketio-and-gevent/ I've implemented it and got it working with an ExtJS frontend and two-way event system, but my exceptions seem to be getting swallowed up by gevent. Anyone know how to log or print exceptions happening within the gevent-socketio loop? Question also asked at stackoverflow: http://stackoverflow.com/questions/5414409/django-catch-log-exceptions-when-using-gevent-socketio-and-wsgihandler
That's more or less my philoshpy these days as well!
I actually need to give cody props on my article, his post is what got me started! The difference is his just does global broadcasts and I'm doing a publish/subscription model using redis, so you aren't sending messages out to everyone but only to people who need the message. (i.e many different people can play games at once without getting every games messages). I have no issues logging from my loop, want to share the code you've implemented?
I believe with the exception of web2py, none of the currently maintained Python frameworks of note pay homage to MVC. Pylons and TurboGears do, but as those are being migrated to Pyramid they will revert to calling the thing that returns the HTML for display a "View" and dropping the term Controller. Arguably Django wasn't paying enough attention to the design patterns and the terminology du jour when the framework was made, and they could have used the term Controller for their Views, and they might have been a bit more popular for it. But conversely the Zope people were arguably paying too much attention to architecture and design patterns and they also settled on the term View instead of Controller, because MVC as it was originally used in GUI applications, calling the Controller something which returns a response meant to be rendered for viewing makes no sense. That's a View. And you can't call Templates views, because templates are just an implementation detail that only some HTML rendering callables in a framework need to use. There are plenty of good use cases where you don't need a template to assist in construction/maintenance of the view, so if the View is optional in MVC it further degrades any semblance of sense that MVC makes for the web. The term Controller makes more sense for the thing which decides which thing to call to return the View, but that's called URL routing or URL traversal or other names more appropriate to how the URL mapping is actually done in a specific framework. 
Please do! Why do you consider it superior? 
Oh, just because I don't have to interface with node and keep another component running (I have no idea how I'd do that yet, to be honest).
all good! this fixed it :) http://djangosnippets.org/snippets/1654/ however I will share my code when I have something to show... working on a realtime framework linking gevent with ExtJS and planning to open source it :)
Also check out : http://hookbox.org/ We've been using it in production for quite some time now.
Is it made in Japan?
Apparently by a Japanese person. Not sure where it was done.
I strongly disagree. The MVC pattern in very valuable for web development since it is about separation of data representation, business logic and data presentation. It is a general concept and it should not be confused with its implementations Implementations are often lacking and imperfect.
Meinheld is based on a simple wrapper of epoll, and implemented mainly in C. So it's very fast. 
Again? Yet another WSGI web server...
I'd rather have an abundance of choices than a lack of them.
Ah, that is something introduced in the latest source... I'll update the tutorial with a link to this: https://gist.github.com/885214 replace the clinit stuff for creating the context with that code and it should work on windows and linux with pyopencl .92
see my response to daddyc00l https://gist.github.com/885214
The reason I went this route instead of using node.js is because I prefer having my server component in python.
Ah, I came in to ask if it dealt with the GIL problem (which is a big deal in asynchronous network I/O) and, if so, how... Looks like this is how :-) 
wtf does "lightweight" mean? apparently everybody loves it.
The GIL isn't a big deal in asynchronous network I/O.
always assumed it meant not loaded down with massive amounts of features, which could make it slow or take up lots of space. extreme example of "not lightweight" might be [GlassFish](http://glassfish.java.net/) and other application servers.
It is if you write your web servers in Python like some sort of crazy person.
Well, to be fair (playing devil's advocate here :-) there's many real benefits for writing something *like* a web-server (I'm not saying it has to be a web-server specifically, just generally a "high availability" and scalable network server) in a language like Python. Afterall, that's the reason projects like this (and Node.js, et al) exist. That's the appeal of things like this. The real problem comes when you start scaling them- any inefficiencies or blocks that might seem trivial on "small scales" become *massive* on larger scales. (I'm well aware this is stating the obvious... but sometimes it needs to be stated and re-stated :-) So I can see *both* points. 
Node.js is [not written in JavaScript.](https://github.com/joyent/node) The reason people write the I/O end of web servers in languages like Python or Ruby is because they lack clue. Or simply do not care about performance, which is often perfectly valid. Sometimes you'd rather have awesome debugging instead and can't be bothered to make the C server easy to debug, or just want people to be able to get something running immediately.
I'd start with Learn Python the Hard Way. It's a really good introductory book. Gives you the basic idea of programming with python and programming in general. Here's a link to the website: http://learnpythonthehardway.org/index Dive into Python would be a good book to once you're more experienced. The important thing is practice, practice, practice!
Other than for the fun of it, what's the point? Gevent already does this, admittedly with libevent instead of picoev. I'm sure those tiny speed boosts will be great to save 0.1ms when the other 99% of your application is the database of filesystem or code execution blocking... It'd be interesting to see a benchmark of WSGI servers where they do a mixture of database and file I/O, and see how much difference it actually makes. Gunicorn support does look nice, though. Ok, quick benchmark on my Linode 512: flasktest.py from flask import Flask, request, g, redirect, url_for, \ abort, render_template, flash app = Flask(__name__) @app.route('/') def hello_world(): return "PONG" if __name__ == '__main__': app.run() Running gunicorn with gevent worker, behind nginx: Server Software: nginx/0.9.6 Server Hostname: flasktest.0xf.nl Server Port: 80 Document Path: / Document Length: 172 bytes Concurrency Level: 100 Time taken for tests: 6.494 seconds Complete requests: 20000 Failed requests: 19859 (Connect: 0, Receive: 0, Length: 19859, Exceptions: 0) Write errors: 0 Non-2xx responses: 141 Total transferred: 3203124 bytes HTML transferred: 103688 bytes Requests per second: 3079.93 [#/sec] (mean) Time per request: 32.468 [ms] (mean) Time per request: 0.325 [ms] (mean, across all concurrent requests) Transfer rate: 481.71 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 4 4.4 3 22 Processing: 5 28 11.0 27 132 Waiting: 1 26 11.0 25 132 Total: 9 32 10.1 31 137 Percentage of the requests served within a certain time (ms) 50% 31 66% 35 75% 37 80% 38 90% 42 95% 47 98% 52 99% 57 100% 137 (longest request) james@li140-209:/var/www/scripts$ Running gunicorn with meinheld work, behind nginx: Server Software: nginx/0.9.6 Server Hostname: flasktest.0xf.nl Server Port: 80 Document Path: / Document Length: 172 bytes Concurrency Level: 100 Time taken for tests: 3.410 seconds Complete requests: 20000 Failed requests: 0 Write errors: 0 Non-2xx responses: 20000 Total transferred: 6460000 bytes HTML transferred: 3440000 bytes Requests per second: 5865.17 [#/sec] (mean) Time per request: 17.050 [ms] (mean) Time per request: 0.170 [ms] (mean, across all concurrent requests) Transfer rate: 1850.05 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 5 2.8 5 21 Processing: 3 12 3.4 11 27 Waiting: 2 10 3.6 9 23 Total: 9 17 3.4 17 36 Percentage of the requests served within a certain time (ms) 50% 17 66% 18 75% 19 80% 19 90% 21 95% 23 98% 24 99% 26 100% 36 (longest request) james@li140-209:/var/www/scripts$ So it definitely does something, nearly two-fold improvement in performance for a simple flask app that says pong. But as I said, database and file i/o would probably negate that. Nginx config: upstream app_server_flasktest { server unix:/tmp/gunicorn_flasktest.sock fail_timeout=0; } server { listen 80; server_name flasktest flasktest.0xf.nl; client_max_body_size 4G; keepalive_timeout 5; root /var/www/apps/flasktest/static; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_redirect off; proxy_buffering off; if (!-f $request_filename) { proxy_pass http://app_server_flasktest; break; } } } 
Thanks! I'll check it out fosho.
Not apache.
It is funny, that the name has a sense in german. "Mein Held" would be translateed into english as "my hero" :-) Is that just fluke or is that intended?
Well it's not python, but I find [tryruby](http://tryruby.org) to be a great, very simple, interactive introduction to programming. Ruby bears similarities to Python, so when you go into other tutorials like [The Python Tutorial at docs.python.org](http://docs.python.org/tutorial/index.html), you should have an easier time keeping up.
&gt; Node.js is not written in JavaScript. Yes, I should have been more clear... What I was talking about specifically is the appeal of writing scalable network applications in languages like Javascript, Python, et al, using something like Node.js or Meinheld (or whatever). I didn't mean to imply Node.js was Javascript.
Are you serious, it's a very clearly defined term? When people say lightweight they refer to space, be it memory usage when loaded (more common), or usage on the disk. It is also commonly used to mean non processor intensive as well.
Makes sense :) I do need to pick over the OP article as socketio looks interesting.
Oh, do we all hate Apache now? I missed the memo...
silent template error failures. grrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
You actually had one of those?
I'd rather have a good set of choices (we're already there) and see the people interested in WSGI servers contribute their efforts to existing projects so they become even better.
Please edit your post and strip lines that are not important or use a pastebin to share whole scripts or huge chunks of console output. Your post makes the thread nearly unusable. Thanks Edit: 9 downvotes for a polite request. I learned my lesson. By the way: I actually upvoted haywires post because it really is interesting. It is just the presentation that bothers me. 
Well played.
I have never heard of this. It looks really cool. Thanks.
I disagree, pastebins disappear over time. For me it was the most interesting post in the thread.
Hm, Tornado does this as well. What's the advantage of Meinheld?
I first heard of this at Pycon, its created by the guy who created orbited! It is very good but only uses long polling so you aren't utilizing websockets when available. The video about it at pycon was really good though: http://pycon.tv/#/video/18
[Best way to learn python](http://www.reddit.com/r/Python/search?q=learning+python)
I went like this: Hello World ($30 e-book) Thinking Like a Computer Scientist(Python) Programming Python(OReilly) EDIT: on the free track: Learn Python the Hard Way(Link below) Thinking Like a Computer Scientist (Python) (Either before or after TLaCS(P)) - Dive Into Python(iirc it's free)
Thanks! I'll do a bench with httperf at some point too.
I'm leaving most of it but I've got rid of some of the unnecessary output.
I wish I did open office. I WANT to, but it is looking pretty rediculous. Google will be supported (soon hopefully)
ack, I was hoping no one hit this bug. Download the code again, it's been fixed. I encountered it myself shortly after putting the code back up (it got through my doctests somehow)
What's wrong with just using .py3 as the extension for Python3000 code?
It isn't. See twisted.web, for example.
&gt; The reason people write the I/O end of web servers in languages like Python or Ruby is because they lack clue. Ridiculous. Most web app workloads aren't bottlenecked on HTTP handling.
If Mark Hammond thinks it's a good idea, I'm on board. 
The file extension is not the right place to make a fix. For one, it would only solve the problem when you execute a Python file directly by using the file association.
That's actually looks pretty cool. Where I work, we use IBM's [Rational Robot](http://www-01.ibm.com/software/awdtools/tester/robot/) to do something similar. This looks very interesting... 
If you're not executing a file directly then you can run the right interpreter yourself. Windows has a mechanism to tell different types of files apart, so it can do different things when you open them. File extensions are that mechanism. Since Python and Py3k files are different types of files, for which you want different things to happen when you open them. Why not worth *with* Windows instead of trying to work around it, and just give the two different file types two different extensions?
For starters you're going to need Mark Hammond's [win32 extensions for python](http://starship.python.net/~skippy/win32/Downloads.html). But I think what you want to do will require some low-level python hacking using ctypes and subprocess calls.
Well your link is a 404, and his isn't. Maybe they shouldn't fragment his efforts.
This may be a dumb question or a "if it were a snake it would have bit me one" but i cant seem to find the documentation for the win32 extension :P thanks for the reply
This oddly reminds me of the [MCP](http://en.wikipedia.org/wiki/List of Tron characters#Master_Control_Program)
Haha yeah kinda but im making a security application for windows computers.. hoping to hide that sensitive data. Wouldn't it be a lot easer just to turn on a program than change users or mess with windows security settings... they can be bypassed anyways
Wait, so this windows thing doesn't support standard shebangs? Well that's never going to catch on.
&gt; If you're not executing a file directly then you can run the right interpreter yourself. You could have done it that way for the last 20 years. No one wants to do that, especially beginners. People want to type "python foo.py" and have it work like it does on every other OS. The PEP aims to make that happen.
&gt; they can be bypassed anyways Don't fool yourself, even if you wrote a filesystem layer to implement these access controls, they too could be bypassed. There's little you can do to prevent any access to data short of deleting it.
i know but a man do do his best
Tried running django-lint (Ubuntu 32 bit, Python 2.6) on a very simple demo directory, but got this stack trace :( Traceback (most recent call last): File "/usr/bin/django-lint", line 25, in &lt;module&gt; sys.exit(script.main()) File "/usr/lib/pymodules/python2.6/DjangoLint/script.py", line 120, in main linter.check([target]) File "/usr/lib/pymodules/python2.6/pylint/lint.py", line 488, in check self.check_astng_module(astng, walker, rawcheckers) File "/usr/lib/pymodules/python2.6/pylint/lint.py", line 563, in check_astng_module walker.walk(astng) File "/usr/lib/pymodules/python2.6/pylint/utils.py", line 518, in walk cb(astng) File "/usr/lib/pymodules/python2.6/DjangoLint/AstCheckers/settings.py", line 43, in leave_module self.check_template_dirs(node) File "/usr/lib/pymodules/python2.6/DjangoLint/AstCheckers/settings.py", line 108, in check_template_dirs template_dirs = self.get_constant_values(node, 'TEMPLATE_DIRS') File "/usr/lib/pymodules/python2.6/DjangoLint/AstCheckers/settings.py", line 78, in get_constant_values return [(x, x.value) for x in xs if isinstance(safe_infer(x), astng.Const)] TypeError: '_Yes' object is not iterable 
But that's *not* how it works on every other OS. As it stands, `python` might be linked to `python2` or `python3`, but if you specify which one in your shebang your OS will use that when you just execute your python file (as `./foo.py`). Currently, Windows users get screwed because people use the `.py` extension regardless of version, and their OS doesn't support shebangs. People on either OS are screwed typing `python foo.py` because both of which Python version you're running and which version `foo.py` is written in are ambiguous. Both these issues could be solved by simply using `.py3` for Py3k files and specifying which `python` you want on the command line. Or we could do the big, complicated, fragile thing suggested by PEP397. The problem boils down to people not wanting to admit that Python 2.x and Python 3.x are different languages with different interpreters. We shouldn't be lying to ourselves about this, and we *especially* shouldn't be lying to beginners about it.
He said do do. ^^ Why not just encrypt the files you want to protect?
What's next? `.py27`? `.py33`? Unless you can guarantee that the Python 2.x and Python 3.x installations will always be up to date, you'll face exactly the same problems -- although minor releases generally strive for backwards compatibility. There would be no ambiguity if Windows wouldn't need to us explicit file name extensions to decide which program to pass the file to.
Minor releases will generally have great backwards compatibility, so unless you're doing something silly you have always run with the latest `python2` and `python3`. If your installation isn't up to date and you want to run newer code you're screwed anyway.
One of the stated goals is cross-platform compatibility.
Or you've profiled and determined that pushing bits back and forth over a socket isn't where the bottleneck is, so "HOLY COW I'M TOTALLY GOING SO FAST" isn't really something that applies to your choice of language there.
I'm in Windows 95% of the time and I don't see the point of this PEP. 
Using different file extensions for different languages is a good idea on any platform.
adding python to the path on install on windows would be more useful. but that's never going to happen either. the real solution is to stop using windows :)
Can't disagree with that, but this proposal also allows for backward cross-platform compatibility. And it isn't that hard to implement and doesn't have that many drawbacks.
not just about encryption 