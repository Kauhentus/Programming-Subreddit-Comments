Ah. I'm limited to what google directions api has. Bus and bike times would be nice also. Maybe the library I'm using could use some patching.
Am using php as its what I know... Not opposed to looking into flask if it solves my problem... Just need it to interact with the file server. Windows 2008 r2 with IIS on active directory domain. 
Hmm okay, so Windows everywhere? I'm afraid I can't help you then. But I guess mounting the file share like /u/sagara said, is a good idea.
Very cool! Always fun finding other applications for sensors that were never thought of :). Have you ever used the with() statement? It's pretty awesome, and you can open files like this: with open('path/to/file') as f: x,y = f.read().strip('()').split(',') return int(x), int(y) You also probably don't need to strong-type the returns as ints, but that's never a bad idea :). Oh and there's a typo in your blog post in the apt-get line. Keep up the good work though! :-D
Pretty sweet, although I'd probably still use something like Twilio.
In comparing isqrt() and math.floor(math.sqrt()), isqrt() ran significantly slower. For r = 1,000,000, isqrt() finished in 5.371 seconds, whereas math.sqrt() completed in 3.010 seconds (both produced the same value for pi). However, if you wanted to use a distributed system or supercomputer to calculate the approximation for a very large value of r, you'd need to use isqrt() because math.sqrt() won't be able to convert the long integer to a float. I'm not sure yet about part 3. I may change gears and do something in JavaScript instead (perhaps Processing).
Yes sorry ! I saw that right after posting and deleted my question.
If I get a unicode decode error in Python 2, I know I'm: * outputting unicode to something that doesn't accept it. So I need to put an .encode() in there. (possibly wrap it up in a function that does this for me) * or combining non-ascii/non-latin1 strings with unicode somewhere in my codebase. I know that I've done something wrong in my input then, as these strings shouldn't be in there combining with unicode at all. If you're going to do unicode it's unicode all the way. A unicode error to me is almost always a *bug*, not something I need to catch and handle. I'm sure there are exceptions (pun not intended) to this, but I can't really understand how it could be in this case. 
Yeah, UnicodeDecodeError in particular just smells like a bug to me, not something you want to catch and handle. In case of bugs I want to see the failure instead of code being there trying to take care of it. That's also the reason why people frown on bare exceptions - it's way too broad so might suppress bugs instead of the exceptions you care about. 
Suppose you want to print a string into a latin1 console, so you encode it to latin1 u'\u2354'.encode('latin-1') You get UnicodeEncodeError: 'latin-1' codec can't encode character u'\u2354' ... So what do you do?
They were... ummm... paraphrasing the movie.
I'd look into using various options that 'encode' has, such as replace or ignore. I'd also consider switching to a utf8 console. :) I can imagine certain circumstances where you want use a specialized output function that catches this exception and outputs using replace or ignore and also logs a warning or something like that, or perhaps simply refuses to do anything but print an error "error. can only work on a utf8-console". Those are pretty special requirements for your application though. 
Thanks man. Please cross-post this in /r/raspberry_pi.
Awesome. I've just received my RPi, looking forward to experimenting with running web apps etc. there, and this is a good start + useful thing, thanks! I'll also probably eventually add load / request time logging - I wonder how that 700mhz processor handles web apps.. in any case, this is neat.
I cnanot make my mind between a beagleboard or raspberry pi. I'd like to simply play around, nothing really fancy. Would you care to advise one by any chance? :)
from the look of the source code, there shouldn't be any need to adapt. all the commands it's grabbing data from seem to be std linux commands. unless you are planning on an OS other than linux. I think it's fair to say actually, that the project could be used on any linux variant. 
I found and used this the other day. https://github.com/armstrong/armstrong_sphinx
&gt; seems it contains goodies for every occasion. Well, the advantage of `deque` is not that big here but yeah, it's good to know. And there is even an [example for that moving average thing](http://docs.python.org/2/library/collections.html#deque-recipes) (finally I know how that is called :D). &gt; Lambda's I still do not find really intuitive t.b.h. Yeah, I don't really like what's going on in that line either, not really readable. I still have a feeling in my guts that there is something better for this in Python or maybe in Numpy but that would be overkill, I guess. Overall, there is still plenty of room for improvement. &gt; My first intuition when I have some state to track (in this case e.g. hist, cooldown) is using a class, but you switch to functions and global statements. What are the factors influencing this choice? First thing I noticed, was that you called most functions only once. No need for a function then. After I removed all the functions, [the "class" only had 2 methods left and 1 of them was `__init__()`](http://www.pyvideo.org/video/880/stop-writing-classes) (watch that thing, it's damn funny ... and true). And it was a simple script, you instantiated the class only once. No need for a class then. Also the class name didn't really tell what it was doing. Or - to put it the other way round - the class had way too much responsibilities. 
Cheers. Mostly they are variations on the built-in themes and I'm not sure they improve them a lot. Might need to give it a chance though.
Oh and price .. wow. Didn't know the difference was that high.
Thanks for the feedback.
Is the php/python backend stuff being run on a windows box as well? If so, [try this](http://verbalprocessor.com/2007/12/05/running-a-cmd-prompt-as-local-system/) to open up a command prompt under the server$ account and see if you can access the fileserver via dir \\\\fileserver\\shared\\target_folder, or do a net view fileserver
I think the most beautiful is readthedocs.org. Example: https://selenium-python.readthedocs.org/en/latest/getting-started.html Source: https://github.com/rtfd/readthedocs.org/blob/master/readthedocs/templates/sphinx/_static/rtd.css But the easiest way is just to use their service.
I think the Fabric project uses this one as well: http://docs.fabfile.org/en/1.5/ 
I went the the beaglebone/beagleboard for the potential to incorporate some higher end stuff (CAN protocols, ROS). I was starting from a lower level of awareness and wanted to make sure I learned on the system I was ultimately going to be using. As noted, many of the specifications are similar.
Managed to make it work :) Just one nitpick: berrystats.py line 48 is missing a colon at the end of line: def get_kernel_version() Probably just a typo. It runs very well, I just do sudo -u www-data python start-server.py
Awesome. Thanks for sharing this.
Oops! I fixed it locally and forgot to commit/push. Fixed in master.
Correct - this should really run on anything Linux-based.
Sounds great - feel free to fork the code and submit a pull request and I'll merge it!
Hmm, how would I get the password to the server$ account? If I try to use the sysinternals RunShellAs tool, it prompts for the user/pass. 
You can still clone the repo from git. 
[Done!](http://www.reddit.com/r/raspberry_pi/comments/18bsfv/flaskjinja_2_web_reports_for_raspberry_pi_system/)
Reminds me of [Monkeysphere](http://web.monkeysphere.info/). I never really got around to set it up, but it seems to be a quite feasible solution to the problem case ssh-import-id has in its README.
Wdroberts is the sexiest man alive.
You can still use their theme, it's available at the second link Ingineer posted.
Thanks for the comments. As a very casual Python programmer, your progression starts to level off after a certain point... Something as /r/critiquemycode or /r/isthispythonic would be nice. 
Google Voice also has an api that you can look at. There are a couple of python implementations out there as well. 
Oh, there is /r/codereview and [codereview.stackexchange.com](http://codereview.stackexchange.com).
Take a look at https://github.com/armstrong/armstrong_sphinx/tree/HEAD
you would need to know it. if you don't know it, you can run the various commands from a web call using the subprocess module. Pipe the output to a file so you can see what the error is when running a cmd /c dir on that directory.
Just curious, as I've never implemented an OAuth type process, in a typical db of users with logins, you can store a userID or other token with any given login to reference content, rights ,etc. With OAuth is there something of a token for each user that is persistent everytime they login? 
awesome!
 logger.debug("Invalid device (size: %s)" % str(size)) :x
Move along. Nothing to see here. *cough* Yeah that needs a little attention. Thanks
For those not aware, you can achieve the same thing without a separate program by writing two [udev rules](http://www.reactivated.net/writing_udev_rules.html#external-run). An extra program is definitely more accessible though (I think cuttlefish allows you to do this as well).
I followed pam_usb for a while, but never took the time to properly implement. This looks interesting too. http://pamusb.org/
Looks interesting. Will check it out, thanks
I'm planning to move to it soon, so this is handy. Thanks
Hmm but I don't remember where I got the theme file. Actually I don't think it was from the rtf github page; there is only the CSS file there. You can grab a copy from one of my project if you prefer. Example: http://xapple.github.com/track/index.html Source: https://github.com/xapple/track/tree/master/doc/themes/rtd 
As someone who is very new to Python, what's wrong here? Is it because you left debugging statements in, when you should have taken them out for the actual release version?
Aaand here comes some critique. I hope you can handle this. Your code looks overall a *bit* messy and you are not following [PEP8](http://www.python.org/dev/peps/pep-0008/). I can find weird things in basically every function/method. The biggest things are: * Your class is called `DeviceAddedListener` but it does everything else too. It has way too many responsibilities. * `DeviceAddedListener` blocks in a loop right when it gets instantiated. WTH? * `DeviceAddedListener` and `Device` are not really a classes. `DeviceAddedListener` is only instantiated once and `Device` can be a `dict` or a `tuple`. * Your code is very hard to read. I have to jump up and down every time I want to know what a function/method is doing or where a variable/property comes from. * Things like this are very strange: if not os.path.exists(CONFDIR): try: os.makedirs(CONFDIR) except: return -1 * Don't kill yourself, man. You provide **3** ways to setup devices (interactive cli, command line arguments and config file). I can't imagine how hard it is to maintain this. And btw., did you see the [deprecated warning for `optparse`](http://docs.python.org/2/library/optparse.html)? There is more but I don't really know where to start. Sorry, this may sound hard but I thought I better let you know. **UPDATE** For everyone who was following the kind of heated conversation between /u/phaedrusalt and me: [he taught me a lesson](http://www.reddit.com/r/Python/comments/18c0k4/i_wrote_a_python_script_to_lockunlock_your/c8dzduw).
I see you've just started learning p ython Please don't write: i = 1 for item in lists: print i, item i += 1 it's unpythonic. Instead write this way: for k,v in enumerate(lists): print k+1,v You'll get the same results and it's easier to read. This: if choice &gt; 0 and choice &lt;= len(self.devices): can be cut to this: if choice in range(len(self.devices)): this: elif cmp(default, "yes") == 0: to this: elif default == "yes": jeez it's not php you don't have to use cmp. Anyway thanks for the utility :) Have a good day.
I have immediately put this to use for cat facts. My friends are now receiving hourly catfacts from catfactsender015@gmail.com. 
Waiting for OS X version
One issue I see there is that `str(size)` is redundant, since the `"%s"` formatting character will automatically convert the value to a string. Another is that logger.debug() uses implicit format argument passing, so it should really be `logger.debug("Invalid device (size: %s)", size)`
Actually I don't see it either yet. There's nothing wrong with using debug messages like this. In fact you are supposed to do exactly this. Because then you can just pass some extra command line argument to configure your logger and it will output more or less messages.
You should make this a real python package with a setup.py. see distutils. That way we can `pip install usblock`
There's no need to cast the size as a string with str(), because you can use the format specifier %d: logger.debug("Invalid device (size: %d)" % size) 
&gt; I don't doubt that the old Nokia trick works and has its advantages, but it isn't going to be as portable in the case that our server farm gets moved to a new data center. AT commands are standardized and you can get different modems for. It's just easy to start with an old phone because they are cheap.
 choice in range(len(self.devices)): never ever do this. you are creating a array of every number in between 0 and len(self.devices) then iterating over the array looking for the number choice. your best bet would be to use : 0 &lt; choice &lt;= len(self.devices) also they are not equivalent, choice in range(len(self.devices)) will return True when choice is 0 0 &lt; choice &lt;= len(self.devices) will not 
 if not os.path.exists(CONFDIR): try: os.makedirs(CONFDIR) except: return -1 What's wrong with this? Other than the exception "handling", and the fact that it can `return` an error and never be handled (ln 65).
Easiest way, is to use Anaconda CE from Continuum to get the two packages installed. The founder of Continuum is the mastermind behind NumPy and has pushed for the development of SciPy a long ways. Very dedicated people people behind the team. Their package Anaconda CE is free and makes the installation process a breeze. Download http://continuum.io/downloads.html Installation instructions http://docs.continuum.io/anaconda/1.3/index.html I've given a lot of NumPy &amp; SciPy lectures and from trial and error, I would say this is the best place to start. Good luck and have fun :)
I have learned to only use %s and %r when using the logger. You almost never want to have the logger blow up your program because you used "%d" and accidentally passed a string in.
what would you replace DeviceAddedListener with?
IIRC the Pythonic way to do this is just go ahead and try the makedirs(), checking for "already exists" in the except, and raising the exception again if that's not the reason we ended up in the except block. It's a way of ensuring all the error checking for the makedirs() is in one place, rather than some outside and some inside.
oh, I should have put ? In the title so people would know I don't have this yet. Oh well, I'll link to whatever I end up with so it will eventually be a good title.
I would not replace it. I would take out some functionality and put it somewhere else. I would structure my code in a different way, a way that makes logically sense. Currently that's not the case.
&gt; you are not following the reddit style guide Actually I only see this in Python subreddits. People are overly sensitive and sometimes even whiny. And OP didn't post in /r/learnpython, so I didn't use my warm and fuzzy voice. But I wasn't harsh or impolite either. You were just reading that wrong. Programming should be fun, yes. But it isn't kinder garden. People are doing real stuff. Stuff that other people may rely on. So I'm rather pointing out mistakes and/or flaws directly than blindly saying *cool* and *amen* to every single project posted in this subreddit.
This may sound strange but most times I just have it in my guts. Maybe I've developed this feeling over time. I learn **a lot** from others, I'm actively reading in Python subreddits, I'm in IRC, I watch PyCon talks. And some things are just common sense ... logical thinking. And of course docs, I read docs. Python's docs are full of examples and best practices.
hmm, you say "Python subreddit**s**". Which do you mean?
Sidebar :)
thanks :)
From PEP8: &gt; This document gives coding conventions for the Python code comprising the standard library in the main Python distribution. People always seem to forget that this is the style guide for Python itself and not every single piece of Python ever written. Some people like to format their code differently than others.
*kindergarten
*logical
&gt;this may sound hard *harsh
There's also a race condition there where someone creates the path in between the `os.path.exists` and the `os.makedirs`. Probably not super important in this case, but that's part of the reasoning behind not doing an `exists` check first in general.
Yeah, please forgive me that I'm using Reddit as a non-native English speaker.
Waiting for Windows OS.
Are we supposed to shun constructive critique now?
&gt; you are creating a array of every number in between 0 and len(self.devices) then iterating over the array looking for the number choice. choice in xrange(len(self.devices)): fixed!
Yes, and that's an even *better* reason, Thanks for reminding me.
wrong, it is actually only slightly better than using range. it will not generate a list of all the numbers between 0 and len(self.devices), it will generate a list of all the numbers between 0 and choice. its quite easy to test. Make a generator which prints out what has been generated : def generator(): for i in xrange(10): print 'generating %d' % i yield i in this example super simple generator which will yeild up to 10. the check if a number is in it : if 5 in generator(): print 'found' results in: generating 0 generating 1 generating 2 generating 3 generating 4 generating 5 found so you doing 6 comparisons vs at most 2 using a &lt; &gt;= statement.
Oh, I see. Thanks!
and i've had to read a lot of python code and code that doesn't follow pep8 makes it harder to read. just look at all the python code in the appengine sdk the ~~4~~ 2 spaces instead of ~~8~~ 4, it trips you up if you are used to something else. Sure it's googles standard, and if I worked at google i could probably get used to it and then everything else would look weird. So, if you want your code to be easily read and easily understood go with a convention. and since pep8 is fairly ubiquitous just use that. or face the risk when you post your stuff for everyone to see that there will be bitching about not using pep8. :) 
I didn't realise Python had `a &lt; b &lt; c` syntax. Thanks for sharing!
 for k,v in enumerate(lists, start=1): print k,v
should have more upvotes
[link](http://kennychowdhary.me/2012/10/python-for-scientific-computing-installing-numpy-scipy-and-matplotlib-from-source/)
 if len(opened_files) == 0 is better written as, if not opened_files Theres no need to check len like this, much cleaner to do it this way. Also, I dont think that global declaration of logger is needed. It may help with readability, but you aren't consistent in its use. I would also change humpCase def names to underscores.
was going to rec this as well
P.S. Counter only works for *hashable* objects though.
I agree with the concept, I dont agree with how this message is conveyed. It should be Stop writing pointless / bad / wrong classes..
yup I remember this submission because I actually watched that video
&gt; this function is alter the user really ? but I don't want to change, ever
what does he want to use it for ?
I like flake8 myself.
I use [prettytable](http://code.google.com/p/prettytable/) to print out SQL results 
 ------------------ | name | surname | ------------------ | edi | budu | | budu | edi | ------------------ I can't think of the last time I saw such data presentation - ironically, other than my own (printing query results to log), much less needing to handle it. Can someone tell me what can this module be used for in your case ? Maybe copying the screen from legacy termnal program ?
I think this whole write less/more classes thing is getting a bit silly. You shouldn't be telling people to do ONE thing, you should tell people to use classes when it makes sense.
No, revelations are not important.
My thoughts exactly
Exactly what you said. The program design should fit the domain. You shouldn't use classes unless they make sense and offer a clean solution. An honest title would be more along the lines of "Write Classes the Exact Right Amount For Your Project." I get that there is this back and forth going on, but honestly any good designer will go for the more elegant solution to a given problem. At the end of the day how correct/maintainable/readable/etc a piece of code is means more than the classes vs no classes battle.
Forgot about this one.
Or a little gofmt should do the trick.
If I couldn't handle an honest and constructive critique, I won't get any better will I? I appreciate you taking the time to comment. It's the first time that I have put code out to the public (aside from just dropping stuff on Github without telling anyone) and I expected to get some critique about it. It's not like I looked at my code and thought "Yes, this is a masterpiece". I'm going to keep working on it, but I'd rather get critiques earlier rather than later on. &gt;Your class is called DeviceAddedListener but it does everything else too. It has way too many responsibilities. Yes, that bugs me too and I plan to refactor this in the next iteration. I just wanted to get a functional version out to see if the basic functionality is ok/useful. I can handle this bit of technical debt until then. &gt; DeviceAddedListener blocks in a loop right when it gets instantiated. WTH? Better way to implement this? Place loop outside the class? &gt; DeviceAddedListener and Device are not really a classes. DeviceAddedListener is only instantiated once and Device can be a dict or a tuple. Indeed. The class is named badly and the Device class will become a dictionary. &gt; Your code is very hard to read. I have to jump up and down every time I want to know what a function/method is doing or where a variable/property comes from. The refactoring should also address this. FWIW I run PyLint/PyFlakes on my code at every save. But I guess there's only so much it can do. &gt; Things like this are very strange: if not os.path.exists(CONFDIR): try: os.makedirs(CONFDIR) except: return -1 Urg, yeah, this is why it's always good to get someone else to look over stuff &gt; Don't kill yourself, man. You provide 3 ways to setup devices (interactive cli, command line arguments and config file). I can't imagine how hard it is to maintain this. I wouldn't edit the config by hand and you cannot actually add a device via arguments, to me it seems the only sensible way is via the -a interactive CLI. &gt; And btw., did you see the deprecated warning for optparse[2] ? Yup, also why I am going to move to argparse as I stated below. Thanks again for the feedback and comments. Hopefully the next version will be a lot better.
I'll be honest: I'd rather someone tell me where there's room for improvement so that I can get better myself. As long as the criticism is constructive and honest, I don't mind. I don't have to agree with everything, but I can always take things on board and make changes I feel are necessary.
~~Later on for sure, when I am happy enough with the code to do so. Right now it's still a rough implementation.~~ Ok, here you go: http://pypi.python.org/pypi/USBLock/
Has mine 
fair warning: this will more likely than not, fail to give you a numpy/scipy install that is optimized. numpy.show_config() will show which c libraries the installation is built against. If you plan on doing serious computations, I recommend compiling numpy/scipy against either a machine specific atlas build, or use anaconda or enthought to get one built against the intel mkl library. The speedup is astounding. I've gotten a factor of 1000 speed up for large matrix multiplies with an atlas compiled build.
This repository also contains several nice Sphinx themes: &lt;https://github.com/sublee/sublee-sphinx-themes&gt; Preview: - [`energy`](http://pythonhosted.org/energy/) - [`hangulize`](http://pythonhosted.org/hangulize/) - [`jdoctest`](http://lunant.github.com/jdoctest/) - [`korean`](http://pythonhosted.org/korean/) - [`ranking`](http://pythonhosted.org/ranking/) - [`trueskill`](http://pythonhosted.org/trueskill/)
If you're on an AMD machine, consider using the ACML instead of Atlas. They are roughly the same speed, but ACML comes precompiled for a number of platforms. Atlas is both an headache to compile (settings, which fortran compiler and whatnot) /and/ it takes ages.
With reddit's threaded comments it doesn't really hurt the discussion to be corrected. And as a non-native speaker myself, I usually appreciate it.
Actually, I think you want.
amazing that they combined 2 excellent libraries(Fabric and Requests) in a novel way to form such an elegant solution.
[Solar](http://vimalkumar.in/sphinx-themes/solar/html/index.html) is very nice.
He (I will ignorantly use *he* all over the internet no matter how many women are listening) did this three times though and it felt like he was mocking me for "correcting" OP.
There is also the more semantic issue that an invalid device would likely be more appropriate as an error or warn message, not debug.
yes you are right(i'll edit my comment), I blame the champagne. and most code I come across uses 4 but the [appengine sdk](http://code.google.com/p/googleappengine/source/browse/trunk/python/dev_appserver.py) uses 2 which violates [their own style guide](http://google-styleguide.googlecode.com/svn/trunk/pyguide.html#Indentation) edit: again the point is, style guides help immensely with readability, readability makes maintainability possible. Thus readability is important. So If we all agree it's important to have a style guide, the next step would be choosing one for your projects. And pep8 is an easy defend-able choice. Deviations from pep8 are more difficult to defend. so just use pep8 and go write code that does something instead of fretting about coding standards for your project. :) 
Oh, I see now. Yeah, that's strange.
Thanks for the feedback, I appreciate it! * A validation function like this is intended to be called and throws an exception if things fail, its output is never assigned. Call it a procedure. I should have made it more clear in the text; part 1 is a bit brief about it. Separating input conversion from validation is often a good idea. * Not guarding against other bad input: do it at the boundaries of your codebase, don't code overly defensive code throughout. Only guard against exceptional cases that you know can happen. If you don't know an integer can come in when you expect a string, don't guard against it. I thought I went into this into some detail in part 5 in the paranoia discussion. * I specifically discussed the None date could come in as an input. If there is no date inputted, None is a reasonable sentinel to use (the input converter would produce it). And then you need to handle it somewhere. * documenting an API is a good thing to do, but rather beyond the scope of this article. The validation function is intended as a very application specific piece of code that does some input checking, not as a library function to call. I could've made this more clear. * guarding against out of domain data in the first place without a good reason. I briefly talk about a hypothetical user interface inputting dates that can be omitted in part 1, and I've covered requirements in part 3 - what was missing? (in an article that isn't about requirements gathering, mind you). Did you want to see more of it earlier? I intentionally start at a very basic level: how to even correctly *recognize* None and cover this later. * "using in-domain sentinel values to represent something they're not". Do you mean using the end and start datetimes instead of custom (sub)classes? I discuss the pros and cons of doing so in part 6. I think a lot of your criticism is related to my lack of clarity about what a validation function is supposed to do in the first place. It's my fault for not explaining this more carefully. Software engineering is a matter of trade offs. You can judge what you do and do not like better in the context of an actual codebase with actual requirements - an article like this will have to pick some for ease of presentation. Software engineering immature is possible. I've only been doing this for a while now... 
&gt; it will launch xlock, Plug it back in and it will close xlock Xlock?? Dude... the 80's called, they wanted their hacks back. Who the hell uses xlock today? To activate the screensaver: dbus-send --type=method_call --dest=org.freedesktop.ScreenSaver /ScreenSaver org.freedesktop.ScreenSaver.Lock To deactivate: dbus-send --type=method_call --dest=org.freedesktop.ScreenSaver /ScreenSaver org.freedesktop.ScreenSaver.SetActive boolean:false
Wow, nicely considered response. A few of these things I could have inferred, or picked up if I had more patiently read the series of articles. Your defenses make sense but given the target audience I think it's a good idea to be a lot more explicit about the scenario in which you're building the function: that `None` might be used for arbitrary input seems like an arbitrary decision you made while writing it, rather than "consulting the documentation of XXX which calls our function" ... and the same goes for throwing an exception: "in the Foo framework, validators are called in sequence and can return a message to the user in the form of a `ValidationError`". ... I did the typical reddit thing and only skimmed your posts before criticising them. On looking a little more closely, my objections are pretty well covered in the prose of earlier parts of the series. Perhaps a little more discussion of the setting of the function and the contract it adheres to wouldn't hurt - and even emphasising the role of the contract in guiding the decisions you're making; this is something people in your target group could afford to have drilled into them :-). Good writing and excellent response to ill-considered criticism. Keep it up! :-)
Here is a counter argument. http://www.youtube.com/watch?feature=player_embedded&amp;v=o9pEzgHorH0#!
"a &lt; b &lt; c" is at least as readable as b in "range(a+1, c)"
exactly. You're not your code. You created some code that now it exists on its own. And if others want to help the code get better, that's great. The best thing is, they help you learn so future code you create will be even better. Thanks for sharing!
More of a preference...
upgraded our stuff yesterday. pretty much pain free. I like that using a python interpreter from a virtualenv works as expected now. having 2 methods of isolation got kind of hairy. 
did you see my correction? i put strikethroughs through them. 
On debian the following will get you numpy, scipy and matplotlib and scitools itself &gt; apt-get install python-scitools I've moved all my old matlab chores to this suite, and it's excellent.
Google has some great answers here, [this]( http://onstartups.com/tabid/3339/bid/20493/Why-PHP-Is-Fun-and-Easy-But-Python-Is-Marriage-Material.aspx) being my favorite 
"revelations" what ?????
Too much opinion not enough pull requests imo. Good work OP.
I've fought this fight several times, but haven't tried Anaconda yet. The best thing I found is to install everything from macports for python 2.7. You'll first want xcode and gfortran - google for the recommended versions. There are multiple ways to get just numpy/scipy working (brew, prebuilt dmgs), but as soon as you need a patched version of either (to work around a bug or support some new package), you'll be screwed. If Anaconda doesn't work, fall back to straight macports.
Foss World Problem: haven't setup automount yet, has USB lock/unlock script.
PHP is a terrible language. Don't use it. Also, there's no such thing as a "web language", except perhaps for HTML.
You really think Bottle will be mentioned before Flask?
Maybe JavaScript comes close to being a "web language"?
It all depends on what you want to do. I found the wealth of libraries to be very helpful and I really like the way Pyramid works.
Why the PHP hate :( I used to do a lot of work in PHP!
Alcohol is poured from the bottle to the Flask, everyone knows that. 
PHP is a horrible, terrible, bad, evil, awful thing. For a ton of detail about why it's so bad, you can (and should) [read this](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/), but to summarize, PHP's bad design fosters bugs, teaches bad programming practices, and results in a lot of extra code to get around weird bug scenarios. Python, on the other hand, is an extremely well-designed language, it encourages good programming practices, and fosters good design. The advantages of PHP are, it's available everywhere, pre-configured to run on almost every web server without setup, and its popularity over the last 10+ years mean there is a ton of code online for you to take from. (Just beware that a lot of the code you see online is not good code...) Python is also very popular, and also available almost everywhere, but it usually requires some setup for you to start serving web pages (via Django, Flask, etc). Python code is also very easy to find online, and the quality of the code you find is often very good. Advantages of python include access to such brilliant tools as *pip* for managing dependencies, *virtualenv* for compartmentalizing your production code, and *nose* for handling unit tests. (By comparison, unit tests are practically unheard of among PHP developers.) Python also makes it possible to use several great tools that every good developer should be aware of, such as *linters* which encourage better coding practices, or *code coverage* checkers, which can tell you exactly how much of your code has unit tests around it. Is python the only tool that does these things? No. They can also be done with Ruby, or Java, or C#. But the important point here is that they are not even considered by your average PHP developer.
I think giving a code review to someone who didn't ask for it is rude, at best. We were being given the gift of someone's efforts, it is up to us to take it in the manner given and respond appropriately. 
&gt; They can also be done with Ruby, or Java, or C# Python is also a lot lighter-weight that Java and C#. Nice if you're doing stuff on, for example, a raspberry pi. 
I've done several years of PHP and it suffered more so then Rails for being known to make app's with longevity problems. First there was the 2004-2005 schism with 4 &amp; 5 with object models. It's grammar can be odd, type's are sometimes ambigious `"" == array() == 0 == null`. Additionally because PHP is so beginner friendly, it has a large number of people who don't give a shit about anything/good practices and create horrible monstrosities that leave one fairly impressed by PHP's ability to execute bullshit in such a fairly performant manner. There's an endless list of other disturbing events in PHP's life time: It's still failing tests but is released anyway( honestly that's a toss up as atleast it's unit-test library exists and is growing slowly). The pre-PDO mysql library had this funny bug where the connection resource would silently disappear, odd naming conventions and std functions like `list()`. Last two points: PHP is not sexy, it's a modern BASIC. And PHP in the hands of mid-senior level engineers can be used to make fairly decent/high performance web applications ( I have worked on a mutant openx implementation that does 5-6 billion HTTP requests a month) but most of the decent mid-senior level engineers move on to other languages because most prospective employers have trouble figuring out that some kid who read a book is not of equal value to some other kid who's worked on several successful projects and might even have a degree in CS.
You mustn't have done any real work, then.
&gt; They did not ask for criticism of the underlying code. They implicitly do by posting it on reddit where you are supposed to comment on things. &gt; Yes, rude. I don't see how this line could be taken any other way: "Your code looks overall a bit messy and you are not following PEP8. I can find weird things in basically every function/method." You are ripping that line out of context! I started my post by saying it will be critique. And afterwards I provided some examples of what I mean and gave a reason for each but one. The thing is, I am how I am. I know I'm not the most sensitive person on the planet and my comments are not ... how do you say ... delicate(?) at all. But I'm totally okay with that. When I write comments like I did here, you can take it or leave it. You really should expect all kinds of reactions when you post on reddit. I'm not writing those comments to piss people off. That's not the thing that is giving me a kick. It's giving me a kick when I was able to help someone, it's like a drug for me. But I'm doing it my way. And so far most people were able to deal with it.
Don't take it personally. The typical argument is that PHP is designed poorly and encourages sloppy practices, leading to code which is ugly or doesn't work right. For some specific examples, check out [r/lolphp](/r/lolphp). Of course, there are lots of ways to skin a cat, and PHP is one among them. Criticism of PHP can be expected when you post in r/Python asking why to bother using Python instead of just using a 'web language' (meaning PHP). Problems with PHP are fair answers to this question.
If you say something like 'use classes when it makes sense' then it's good also to offer an idea of when it makes sense. Otherwise, we are not sharing much information yet. For example, what kind of domain does demand a class, and in what cases is a class a more elegant solution? I tried to sketch a rationale in [this post a few days ago](http://www.reddit.com/r/Python/comments/184oj7/pycon_2012_stop_writing_classes/c8bqrv1). I don't really care if people agree, but I'd be really pleased if more people would argue about specifics of when a class is better or worse, and why.
Simply put, Python is a demonstrably *better* language than PHP. PHP is also no more a web language than any other language. Yes, it automatically prints anything not in *&lt;? ?&gt;* brackets, but that doesn't mean it's a "web language," it means it's a language with lousy syntax. Most PHP apps these days use external templating languages anyway, making the &lt;? ?&gt; convention merely cruft. The only real advantage to using PHP is that your deployment to almost any hosting provider is going to be pretty simple, whereas with Python, there's a little more to set up on the backend for most hosting companies. So if you're making an app you intend to sell copies of to end-users, PHP is arguably easier to support. Still, I would caution you against going with a language that's pretty much universally considered awful just to make installation easier.
you forgot CherryPy. I highly recommend that.
You get around that like this: `\_\_iter\_\_`. But frankly, you should just use the grave accent (\`) like `` `__iter__` `` to make it look like `__iter__`.
A little preface: I've been coding for over 30 years, and teaching software development and techniques for about 20 of them. I've seen excellent developers leave the field because of the bad behavior of other, less talented coders, and I've seen large projects go down the drain because so-called "professionals" couldn't learn to keep a civil tongue in their heads. I wonder how many people won't share the cool, fun things that they do with Python just because of the kind of treatment that you gave this guy, who did NOT implicitly or explicitly ask for any kind of critique. It's great that you're okay with the way that you act, and I'm pleased to see that he reacted well, but how about others? Do we want to keep newbs from posting about their projects? What's more important, the fact that it's something that they built and are excited about (And might possibly get others excited about, too) or that it is/isn't PEP8 compliant? I'd rather see 10 newbs post their silly, poorly-constructed but enthusiastic code than get a chance to see how one more old-fart found enlightenment through decorators or multiple inheritance... But maybe that's just me. His post is a gift, but you reacted like the person who receives a bottle of wine from a dinner guest, and then goes on a rampage about the vintage. And if we don't start minding our manners around guests, well, pretty soon we won't have any guests. 
You got a double post: http://www.reddit.com/r/Python/comments/18e3pc/finding_python_3_builtins/
The whole PHP project started out because someone wanted better server-side include features. It was never designed to be a serious programming language, and because of that, you got things like "PHP Smartquotes" where any input and output is silently half-escaped for SQL queries. But not completely escaped, and certainly not invulnerable to SQL injection. And the configuration to enable this anti-feature? It's system-wide, so if one app is written that depends on smart quotes, and another is written in a way that doesn't work with smart quotes, well, you're out of luck. (See also similar problems in allow_url_fopen, the @ character, scream.enabled, and the installation-wide "error_reporting" level.) Then of course PHP didn't have packages. Or namespaces. Or modules. So instead of actually adding those *very basic* language features, the authors of PHP just decided to prefix function names. Switching databases? Hopefully the mysql_* functions work the same as the postgresql_* functions. And enjoy that search and replace. Of course PHP did eventually add object oriented programming in. Sort of. Except the PHP designers didn't bother reading up on OOP, so in PHP4, they screwed it up and passed objects around always by value, not reference. They fixed that in PHP5, making it backwards incompatible with PHP4, but getting it up to late 1970s design quality. And none of this discussion would possibly be complete without mentioning the fact that PHP's developers have a long and inglorious history of actually going out of their way to encourage programmers to do bad things, like using "[]" in POST parameters to change the datatypes *on the server side*. (See [this 5.3 security hole for an example of that!](http://php.net/strcmp#102677)) Look, you can Google around for more serious examples on why PHP is a terrible, awful, world-ending language that no one should ever use for anything ever. Just scanning [this article](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/) seems about right. But really, in all seriousness, PHP is a language that had made the world a worse, not better, place. It has caused thousands of bugs, tens of thousands of security flaws, and taught millions of programmers a lot of very bad habits. Including the habit of using PHP. It's the meth of programming language. PHP. Not. Even. Once.
I've never actually seen a great software engineer who didn't identify with his code. You aren't your kids or wife either, but...
Thanks, a gracious response, I appreciate it! I agree that I should have in hindsight been more explicit about the behavior of the hypothetical validation framework. 
I think the main difference between Python and Java or C# is that Python isn't written with code-generation and aggressive editor auto-completion in mind. eg, java.net.HttpURLConnection is great if you just type HttpURL, hit ctrl+space, select it, and then let the IDE import it for you. And code generation in Java is fine, because you don't notice it happening. But in Python, typing urllib is a lot easier and who needs code generation when you have dynamicness?
OH right!!!!! and there's always some nerd that recommends cherrypy but can never give a good reason that makes it stand out from anything else. :)
but the cherrpy guy gets upvoted about 1/2 as much as the corresponding web2py guy gets downvoted.
i was forced to use git by the cool kids otherwise, yes they would use hg rollback and thus wouldn't need a man page. 
Ah, come on. That whiney article again. PHP had never a real concept, that's true, but that doesn't make it unusable, nor less productive than other languages. You get stuff done in PHP and you can write rather good code in PHP too (circumventing the quirks). There are truly worse languages than PHP. I have to admit, i tend to call Python the "better PHP" - same level of productivity, more features, same speed, same if not better learning curve and most importantly a language with a inherent concept - but if you know PHP well, it's just fine to get stuff done. The core problems of PHP are the sprawled - not grown - parser and the "need" to keep a lot of bad stuff in and the mindset that you have to please everyone, so you have operators from C and Pascal and at least 4 different syntaxes for a simple "if". If they would be as hardcore as Python was with Python 3, a lot of problems would be gone by now. The biggest advantage PHP has over Python, is that companies find a crapload of people who "can do" PHP. Or are thinking that they can do. Disclaimer: Doing PHP is my job, but i'm having an affair with Python. I just like her. Sorry. TL;DR: PHP is not a "bad language", just no language i would use as an example for a programming language concept.
Oh dear god. If PHP is conceived bad, Javascript is the devil. It was literally raised in war, and looks war and behaves like war.
Not every programmer does "real work"... I did personal websites and tinkered with different things. No need to be rude!
Armin Ronacher has a great point about the value of classes as a mechanism for making extension points, particularly to allow reuse of implementations in layered APIs. The need for this is particularly painful in the standard library, so the json module is a good example (but if you need a streaming JSON parser and can install the YAJL C library, check out [ijson](http://pypi.python.org/pypi/ijson/)). Always using a class is a brute force way of ensuring that there are always enough extension points. But this has its own downsides too (typically lots more indirection and LOC, huge surface area for the public contract, more difficulty maintaining invariants for methods which call each other or share state when they can be overridden or monkey-patched quite freely). So even for the purpose of providing a layered API, I want to be more conservative than this. I think there is a lot of value in having most implementation in a basic function-based API. When the only place for an implementation is in an instance method, you cannot really reuse it without making wrappers around the instance. Cookie.py is my favorite example. Its object-oriented API is so horribly painful and dysfunctional that everybody serious had to wrap it with fixes years ago. You actually have to, because everything that isn't a complete class is locked down as _private, including most of what's needed to make method overrides useful. If you actually need to customize anything, the only alternative is to reimplement from scratch. We could have just removed the _ and make everything in Cookie.py part of its contract, then used the classes as extension points. But wouldn't it have been simpler if we could just reuse the basic imperative pieces to expose whatever interface we actually wanted without lots of wrapper-adapter cruft? This is why I would often prefer to see basic implementation pieces exposed as standalone functions. Then, if there are a lot of shared parameters or state, you can call these functions from an object that manages the shared state and exposes a nicer API. Now if your class is bad for a user, she is not forced to make a pearl around it like we did with Cookie.py and is not even forced to inherit from your classes.
Noted, thank you for the clarification!
Excellent link, thanks for that!
Apparently I'm using zc.buildout 1.4.4. I often have a problem after running bootstrap and buildout with a virtualenv that breaks the pip in the virtualenv. I bet upgrading would help with that. If only I could remember why pinned buildout to 1.4.4 in the first place.
Think of PHP as like the "bash" of web scripting, except with more inconsistencies and written by a non-experienced programmer. It's perfectly fine for short scripts or to add some basic dynamic features to pages, but for a full web application or fully dynamic website, it is a massive pain in the ass. You wouldn't write a web browser in bash in the same way you wouldn't write a full web application in PHP. Now, there are some PHP *frameworks* that attempt to alleviate this, and they certainly improve the situation to some extent, but they're still way behind the big and popular Python and Ruby web frameworks. PHP's huge advantage is that it comes on pretty much every web server by default (in the same way IE comes with every Windows computer by default). And some shared hosting environments may not have good support for Python. But if you're creating a true web application, you're going to want a real server you have real control over, and in that case you can use whatever you like. Reddit is an example of a true, large web application. It is written entirely in Python. A website with 3 pages for a local band or for a small local store is not a web application; it can really just be a bunch of HTML files, maybe with some PHP.
After all, your code is what speaks for you when you're long gone working elsewhere, people will judge you by it. Be proud of your code. It might not start off well, but aim to make it better over time, so that you are happy to put your name to it when someone else takes it on. 
***"Start writing more lambdas"*** -John McCarthy
The script works great locally... That was never the issue. Part of the problem me thinks is that it makes a call to a GIS module that requires a license (so it has to be authenticated with the network to hit the license server). I think I just about have it and will post the results for future reference. Thanks everyone!
Not sure I quite understand the point of this post. If builtins is set to None/empty in an `eval`, you're not going to be able to import `reprlib.Repr` or `os` or otherwise to get to the `__builtins__`. `[t for t in ().__class__.__base__.__subclasses__() if t.__name__ == 'Sized'][0].__len__.__globals__['__builtins__']` seems to work just fine for Python 2 and Python 3.
That would be me. And yes I have zero reasons why I still use it.
&gt; But really, in all seriousness, PHP is a language that had made the world a worse, not better, place. It has caused thousands of bugs, tens of thousands of security flaws, and taught millions of programmers a lot of very bad habits. Including the habit of using PHP. It's the meth of programming language. PHP. Not. Even. Once. Beautifully said!
you'd be surprised at the amount of "real" work that is done in php regardless of how shitty of a language it is. "real work" meaning someone pays you for it. there's plenty of real work done in COBOL too but I digress. 
I have to admit that rants about PHP crack me up. But I feel sentimental about C64 BASIC, which is frankly pretty terrible. And you only get one life. So I think there has to be a lot of room for what you enjoy using, as long as you at least try other things so you can decide for yourself. Because I don't think anyone is ever going to bother with a really convincing, systematic, dispassionate critique of PHP based on harder technical or business issues. It would be a huge undertaking and would only result in the same kind of stupid flaming we already have, in my opinion.
for one reason they pollute your namespaces, just like burning gasoline pollutes your atmosphere. Do you really want to be known as that guy who polluted the namespace? seriously, just stop doing it already.
No surprise at "real work" being done in it, surprised at someone claiming to have done work in it without discovering the festering pile of shit.
i didn't know business basic was a festering pile of shit until I got a job doing delphi, before that it was a just a job and I didn't care to post about it on discussion forums. (we trolled for cybersex on irc instead). So how about giving the op the benefit of the doubt that he/her now seeing that people hate it, will now start he/her journey towards enlightenment. 
Sure, they will. What about the other twenty megabajillion that type "How do I maek websyt?" into google to be directed at the fountain-of-ever-spouting-horseshit that is PHP?
+1 for the yucks
I knew there was a reason I was forgetting, I haven't done file I/O for a little while now so you tend to just forget these things (or at least I do!).
webfaction.com
That one is a follow-up to this one.
I never noticed a warning about using a virtualenv. I definitely pinned it in my versions.cfg file. I'm just not sure why I pinned it. Usually I put a comment in saying "Package A requires X version of Package B." so I know when I can upgrade it later. I guess me from one or two years ago thought I would know why it was pinned. I'll try updating buildout later this week and see what happens.
well if you need an ide to keep all that lined up for you..... I just don't know what to say about that(you or the framework). But good luck :)
you writing the complex templates? you might be missing the point of mvc/separation of concerns. I'm aware that I could have googled things. but I was curious to hear what this flask support means to someone that supposedly finds it valuable and not the company that makes/sells it.
saw this in the [release notes](http://pypi.python.org/pypi/zc.buildout/2.0.0#id5) &gt;The 1.4.4 release is a release for people who encounter trouble with the 1.5 line. By switching to the associated bootstrap script you can stay on 1.4.4 until you are ready to migrate.
If you use 1.4.4 now, you should be OK with downloading the "2.x" bootstrap and using buildout 2.0. 2.0 is basically a modernized 1.4 without the 1.5/1.6/1.7 complexity.
Possibly obvious note to others: don't do this unless you only have SSD's in your thinkpad!
To end all this: I watched [**The Art of Subclassing**](http://pyvideo.org/video/879/the-art-of-subclassing) and [**Stop Writing Classes**](http://pyvideo.org/video/880/stop-writing-classes) (the latter was following immediately after the former at the same PyCon; quote by Jack Diederich: *"I don't mean the disappoint but I'm actually going to agree with everything Raymond just said."*) and I read the **article above**. Nothing that is said in one of them is contradicting or disagreeing with something that is being said in either of the other ones. It's all just a matter of what you are doing and what it is for. **EDIT** Added quote.
PyGTK?
Don't be a jerk. There's a big difference between 'need' and 'is useful'. If I didn't want tools support like that and if it wasn't useful in saving time and reducing errors, then I would shun IDEs completely and just go with vim. Also, DRY is nice, but at the end of the day the client chooses whatever framework they will and, redundancies or not, I get to deal with that. Not using tools to keep it all straight for the sake of appeasing the macho demographic would just be silly. 
sorry you are right, that was pretty jerkish. and I should curb my sarcastic nature when posting on reddit. i can actually see the value for something like spring. somehow I glanced over that in your comment. But for something like flask, I have seen first hand the tool getting in the way. But no one in these threads can ever give me a convincing example of how it does save time to justify the cost and dealing with the lack of support for somethings as far as python goes. Instead a legit question will get downvoted to oblivion(which I don't give a shit about anyway) instead of actual useful information. And one can get cranky when you are hard at work happily plodding along in your editor of choice and someone on your team uses this damn thing and needs my help learning how to use their tool of choice. again, TOTALLY makes sense for java/spring
I'm very familiar with iterators and generators, so I almost skipped this, but I'm pleased that I made it to the coroutines. I wrote my final project in a programming class using coroutines that passed information to each other, but I've never been comfortable with them. You did an excellent job explaining them, and I encourage readers to try this out in a debugger to step through the process on their own. I'm looking forward to your next post.
&gt;you writing the complex templates? I'm not sure what you mean / what this sentence means. &gt;you might be missing the point of mvc/separation of concerns. I think you're confused. Flask is "just Python" and trivially easy to set up. But Jinja2 isn't Flask. Allowing code-completion to "understand" that we're working with a Flask app, and that a string argument in a "url_for" might be referring to a specific file is really useful. Things like this. Let me ask: have you actually used Flask? I saw in another comment two hours ago you said "sounds like flask can be pretty complicated to setup" — which isn't the case. Maybe you should try out Flask, which is a probably the most simple, yet well-featured Python web framework I've seen, and then we can have an informed discussion about facts. It'd be a lot nicer than whatever useless bickering this is.
I haven't coded in a few years and learned Django in a weekend. The official tutorial is great!
I have heard Flask is pretty good at making light weight pages/apps. Please share your findings!
You can have a basic flask page up in minutes, and their quickguide and tutorial are likely to be all the documentation that you need. I can't comment on any others (excepting Django, which is fine, but will take longer than Flask if you're new to it).
Did you mean to post this to [r/shittyprogramming](http://www.reddit.com/r/shittyprogramming/)?
Flask has a lot of great features, but understanding how to put them all together is not very well documented. I'll explain differently, it's like seeing code: if exists(filename): with open(filename, 'rb') as fd: # do something But you never really see the necessary first part: from os.path import exists While you can google it out and find what you really need, it becomes more time consuming than necessary to put together even a small project. That said, for a small project, I think Flask is excellent after you jump over the documentation hurdle. And the snippets and small examples are really great, they just feel disjointed. I'm not a fan of Django, but it IS the best thing you can train yourself to use if you have the time because it will open doors for you later. 
Sorry! Autocomplete on my phone. It was supposed to be "duplications" lol
CherryPy, security through obscurity.
wats the difference between flask and django?
I was more discussing design in general. Classes are great when you need something that maintains state and will be instantiated in multiple places, maybe some type of inheritence scheme. All I was saying is that you have to evaluate your problem and design for it. For example, if I was building a linked list (since you would like a concrete example) then making that a class makes sense. I can implement the functionality to operate on the structures as well as maintain the state of each structure so it can be used in multiple places. It is why in python 'list' is a class. If you tried to implement a list without using classes (pretend that list doesn't exist in python) then how would you do it? A class makes a lot of sense. Then on the other hand, everything doesn't need to be a class. Lets say you just need to package data together with some form of identifier. There is no need to create a class, you could used a named tuple for immutable data, or a dict for mutability. A class in this case would be a lot of overhead for such purposes. My whole point wasn't to list the times when classes vs non classes are necessary. Each program will need different classes/modules/structures in different combinations. Ideally as programmers we should be looking at a problem and pull apart the pieces into units like classes and functions. The reason we all go to school and study different design choices is because there is no hard and fast rule. I can't say "always use classes," or "never use classes" with any amount of integrity. I feel that sensationalist titles lack the honesty for what we really do. We get paid to determine when to use which tool in our toolbox. As for your post I agree that if you could do it with a function then there is no reason to do it with a class. To be more concise when I need to maintain a state of something as well as operate on that state, a class is the simplest and most concise way to do this. If that isn't my goal then I would use something different.
Anaconda and AnacondaCE are both entirely relocatable, and install cleanly into a single directory of your choosing. By setting your $PATH to point to the anaconda/bin/ directory, you pick up the python executable and all the Anaconda packages. If you are trying to handle multiple versions of libraries (e.g. Numpy), the 'conda' tool in Anaconda is your friend. This blog post explains more about how you can easily and robustly manage multiple versions of packages (even those with complex dependencies on extensions or shared libraries): http://continuum.io/blog/conda
&gt; sounds like flask can be pretty complicated to setup Flask itself is trivial to se up, having a flask-aware editor is more complex (absolutely not necessary, note, Flask remains pretty much bog-standard python aside from the context-locals — and templates of course — you could use PyCharm with flask before it had specific/dedicated support) &gt; does it support zope too? PyCharm? Not that I know. At this point, it supports Django and Flask I believe.
So tiny but so awesome!
That may very well be. Wasn't really commenting on the design of JS but more that one cant make a "modern" web site/app without using JS (which is not the case for PHP, Python, Ruby/Rails, etc.).
Yup, it just prints the first and then every second item from then on. People who write articles and books with code examples should actually run and test that code in my opinion.
Your example in the readme doesn't work. You can't *print* inside an *eval*, which is what your code uses. It's simple to solve: You could either 1. use *exec* 2. import print_function from future 3. always print the result of the eval
Wow. That's really strange. I *did* run all these examples in ipython and the article is generated from its output. I'll have to check the history in git to see what happened. Thanks for the report!
so you're doing all these shenanigans instead of using the [csv parser](http://docs.python.org/2/library/csv.html)? the fuck?
An object-oriented layer on top of struct is interesting, especially if it saves me having to look up struct's format characters every time I use it ('H? What is H?'). So the criticism below is suggestions for improvement, not trying to get the author down. First, I don't want to specify the data structure in a big multi-line string. It's another format for me to remember (is whitespace important? case sensitive? why colons for delimiters?), and it's fiddly to manipulate programmatically. Instead, why not just pass in tuples: BinIO([ (1, uint32, objectID), (32, string, objectName), ... ]) The `new()` function seems completely redundant. Instantiating the class directly should be the 'one obvious way to do it.' The name of the main class (`BinIO`) isn't very meaningful. It represents your data structure without any specific values, so perhaps something like `ModelStruct`? Finally, it would be nice to put the code in Github/Bitbucket, so that people can easily view it and submit changes. 
I am not the OP, but I checked out pyp recently. I love the concept, but it is *horrendously* slow.
Thanks for the comments. I am not convinced about the "ModelStruct" name since the BinIO class is more like a codec, but I see your point. The name comes from the first version, where the data was being stored in the object itself (and that is still offered with the read() and write() methods). I left that in place to not break code that is already using this module (I am using it in my job). The issue I see with the tuples to describe the struct is how to specify non-constant item counts. The current code parses the definition (a DSL), and checks that the count expression is valid (previously defined items of any scalar (i.e. count 1) integer type, constants and a few operators). The count expression is actually evaluated in the read and write methods. This can be done with strings in the tuples but it starts to get too bloated for complex structures (too many unneeded chars). Regarding bitbucket or github, I have never maintained an open source project, so I would need to read a bit about how to do it properly. Finally, the new function is there to allow for a possible future optimization in case the struct has a constant size. In fact that was my first version of the code until the need for variable counts arised. If the struct is constant size it can be read/written with a single call to struct.unpack/pack. In this case the new function would return a different object (i.e. not the current BinIO).
If there are more requests for the definition in a list, I can implement it as an option. I prefer the current DSL because it is closer to the way this kind of structures are defined in documentation (at least the way I am used to see). The choice of colons for separators is just to simplify parsing. Empty space is not important and identifiers are case-sensitive. I have to update documentation to clarify that.
Coroutines in Python are wonderful, mysterious (and incredibly useful) things; thanks for posting this. I'm looking forward to part two. For those interested, David Beazley's [A Curious Course on Coroutines and Concurrency](http://www.dabeaz.com/coroutines/index.html) is also a great read.
I've enjoyed [from python import podcast](http://frompythonimportpodcast.com/) but they are infrequent. [Radio Free Python](http://radiofreepython.com/) is also good. Those are the only two I've listened to with any regularity.
Oh man, that's awesome. Been using unittest for a while and wondering what the deal with nose is, and this one feature alone has got me going "oh, I see why nose is a big deal". Time to give it a try!
Similar projects: - [`transdate`](http://pypi.python.org/pypi/transdate) - [`lunardate`](http://code.google.com/p/python-lunardate/)
There is also the [Scipy Superpack](http://fonnesbeck.github.com/ScipySuperpack/) that includes the science stack: Scipy, Numpy, Matplotlib, iPython, Pandas, statsmodels, &amp; scikits-learn. I remember having a hard time installing 64-bit versions of all of these, but the Superpack makes it pretty easy.
so basically, you wrote a wrapper for the wrapper for the API? EDIT: Holy nested if statements! I strongly recommend you write a few smaller if statements at the top of "main" whose sole purpose is to validate the commandline parameters (and their combination). Raise exceptions as needed, then move along. Also, it looks like you could definitely compartmentalize your code into a few different, smaller functions to be kicked off based on what command line parameters you received. Especially where you find yourself repeating blocks of code, this should tip you off that you could simplify by writing that code into a function. Right now, it's very, very difficult to follow a path through your code by just eyeballing it. Readable code saves future headaches. One last tip: it's sort of funky that you do all your argparse legwork inside of "main." The reason this is bad (to me) is that I generally write code under the assumption that I might want to reuse some of it later. Because you do all your commandline stuff inside of "main", you're basically precluding using main anywhere outside this script. If you chop up main into more functional pieces, you leave yourself the option to reuse them elsewhere by dealing with argparse below an "if \_\_name__ == '\_\_main__':" block, and then passing the results to your functions. Does that make sense? EDIT3: Ok... guess I'm a little bored at work. Went ahead and refactored your code per my above recommendations. I was going to submit a pull request to your repo but this includes some pretty heavy reworking (86% diff per git commit message) and, frankly, I'm more interested in you reading and understanding why this is better than I am interested in your public repository being clean. Mainly, take note of how much easier it is to read and follow what the code is doing. I didn't put much thought into how I (re)named new variables and functions, but you get the idea. [alien.py refactored for readability and to simplify future maintenance](https://gist.github.com/dmarx/4947902)
Can you give some examples?
&gt; (1, uint32, 'objectID'), &gt; (32, string, 'objectName'),
radio free python 
Just because there is a csv parser does not mean it is always the best tool for the job. In this instance I was extracting part of a cell of uniform width, so csv parser would have been more typing for no real benefit. When writing throw-away code you can and should do whatever comes to mind. Single-use code need not be robust
Good catch! I don't actually use eval much (maybe once before) and I arigionally used OUT.write, but thought people would be more familiar with print so I put that in the readme. I think using print_function import is the best, I almost did it anyway because I rather like the future
Interesting, Solving a different problem I think. But interesting concept nonetheless.
Actually really interesting. +1 good work
So a couple more questions: - should I figure out how to get this on pypy at all? - if so, what to name it? (I think 'py' is taken) - anything else from the stdlib should be imported?
Ok, it is in the to-do list, for the next version: binio.new( [ (1,uint32,"n"), ("n*3",float,"positions") ] )
My second paragraph was meant to say generators can be used to create classes that are iterable or have iterator methods. I'm just not sure that definining iterators as a type of iterables is useful. A key feature (to me) of an iterable is that it is re-usable while an iterator is a stateful and only good for a one time pass.
:)
...nor reusable, why publish it then?
You should definitely package it for pypi, that means people can install it with pip or other python package managers. As to a name, how about "pype"? (I almost wish I had done it now so I could use the name :P)
I love python and all, but I really think this is better in perl: cat data.tsv | cut -c4,9 | xargs perl -e 'print "DELETE FROM SITES... " . join(",", @ARGV) . "\n"' | psql testdb admin Of course this should probably go in a file in your ~/bin or something and parameterized
hey, I did something like that https://github.com/hamstah/tbl does printing with some fancy stuff like sorting etc code is a bit hacky but does the job for me
You're welcome! The article is great, very well explained. EDIT: git? If you are a Python guy you should use Mercurial! :P
Cool! Let's go for a drink after my talk entitled "stop using meaningful whitespace". ... I'll see myself out...
Disclaimer: I'm not well-versed in functional programming, just interested in learning more about it. So... what's up with these variable names? Don't get me wrong, I really like the ability to define lambdas using fn._ ...But it's kind of the worst, most generic variable name isn't it? The readme even mentions a conflict it has with the Python REPL, which also uses "\_" as a variable name (and did so before this module was written). If you look in underscore.py , it has a name ("shortcut"), presumably because "\_" was too vague when writing the module. So why name it "\_" for the user? Why not give it a descriptive name in the module, then allow the user to rename it to something confusing. fn.F is another example. It's a class that assists in currying functions, but the name "F" doesn't say anything to me. edit: escaped the stupid underscore 
This is really interesting. Fills in a lot of things I missed/had ugly workarounds for as well as some really useful stuff I didn't even realise I was missing. This will definitely be getting used next toy project.
I have listened a few of the "from python import podcast" but I would not mind to see additional offerings. I think there is space for more productions and of good quality (both content wise and audio quality wise) 
This makes Python just awful to read. It defeats the purpose of using Python. Some of its ideas are great but it's horribly executed. In other words, it's not well thought out. For example, one of the things on the "to do" list is currying. Umm, even if they worked out a solution, it wouldn't work because Python has optional and keyword parameters. @curry def foo(x, y=None): return lambda z: z + 1 bar = foo(1) #What the hell does this evaluate to: #a function or 3? bar(2)
So let's say (for whatever reason) you want a little generator that gives you lines of text that draw an ASCII art checkerboard, like this: +-+-+-+-+-+-+-+-+ |#| |#| |#| |#| | +-+-+-+-+-+-+-+-+ | |#| |#| |#| |#| +-+-+-+-+-+-+-+-+ |#| |#| |#| |#| | +-+-+-+-+-+-+-+-+ | |#| |#| |#| |#| +-+-+-+-+-+-+-+-+ |#| |#| |#| |#| | +-+-+-+-+-+-+-+-+ | |#| |#| |#| |#| +-+-+-+-+-+-+-+-+ So you write: def checkerboard(): for i in xrange(1, 4): yield "+-+-+-+-+-+-+-+-+" yield "|#| |#| |#| |#| |" yield "+-+-+-+-+-+-+-+-+" yield "| |#| |#| |#| |#|" yield "+-+-+-+-+-+-+-+-+" for i in checkerboard(): print i Fine and dandy. But you see some redundancy. All those ` yield "+-+-+-+-+-+-+-+-+"` lines are the same. So you refactor that out into a separate method: def line(): yield "+-+-+-+-+-+-+-+-+" def checkerboard(): for i in xrange(1, 4): line() yield "|#| |#| |#| |#| |" line() yield "| |#| |#| |#| |#|" line() for i in checkerboard(): print i Oops. That doesn't work. You can only have a `yield` in the generator function itself, not in anything it calls. With real coroutines, you can yield *anywhere* in the callstack. That means you can full compose code that uses coroutines. It means even code that works with higher-order functions can yield. 
 from fn import _ as XXX it suggests that somewhere in the page.
since map normally returns a list, is calling the list built-in necessary?
What jsproat is suggesting is: from fn import argument_placeholder as _ or some other more useful name by default. The user can then import this as the confusing name if they want something short.
In 3.x `map` and `filter` both return iterators. EDIT: Thanks for the correction /u/oantolin
is it possible to install all that on python 3.3? or is only for 2.7?
functools.partial is currying isn't it?
The superpack is only for 2.7. It looks like most of the packages do support 3.3: https://python3wos.appspot.com/, but you'd have to install them some other way. You could do Enthought, but it doesn't have a 64-bit version for OS X. I would still be a bit wary of using python 3 for science, with the caveat that I don't have much experience with it. New tools in science take longer to get working than tools that have been used for years. Also, it might end up you need some random package that isn't python 3 compatible yet, rpy2 for instance.
Did you mean `filter` instead of `reduce`?
i use 2.x for my work so i always forget about that switch. thanks.
That's exactly what I meant to say, thank you.
**Feature I want :** Parse C/C++ header file, sprinkle in some basic rules (byte ordering, endian byte bounds&lt;16/32/64&gt;, size of particular base types), and generate the proper binary structures for your module. :-) Thanks for putting this up on /r/python.
On further review, the user should be able to generate multiple, independent instances of "\_". The way the underscore shortcut is currently implemented, the generated function requires one parameter for each instance of the underscore shortcut in the "lambda" expression. This has the potential to get a little unmanageable when you have variables which are intended to repeat in the expression: from fn import _ # one root of quadratic equation # usually needs 3 variables # now has 5, but which ones repeat? (-_ + sqrt(_**2 - 4*_*_)) / (2*_) (...not to mention how goofy-looking "-\_" looks. I'm calling this the [Sloth expression](http://www.toptenz.net/wp-content/uploads/2010/10/Sloth.jpg) from now on.) I think this might be a little easier on the brain, kind of like [how Sympy does symbols](http://docs.sympy.org/0.7.2/tutorial.html#symbols): from fn import Shortcut a, b, c = Shortcut('a b c') (-b + sqrt(b**2 - 4*a*c)) / (2*a) Side benefit: now you don't need to worry about the imported symbol having a name that's too long, because the user automatically and implicitly gets full control over how their variables are named. 
_ is a bit too magical for me, although I would like clojure style function literals: `#(%1 + %2*%3) == lambda a,b,c: a + b*c`
Interesting, but fortunately all it takes is "from ... import _ as __" or something similar and the conflict has been resolved. :-)
Good point. Alternatively, one could follow the Boost C++ library and use _1, _2, _3, etc.
Once you know what the _ object and the &lt;&lt; operators mean, though, I don't see anything wrong with readability at all --- all it is doing is just chaining a bunch of anonymous functions together, which isn't hard to understand.
It is worth noting that variables named _1, _2, _3, etc. would also work and would be valid Python syntax, if the author decides to implement them.
It blows my mind that you were able to do this with only overriding operators.
[Boost.Lambda](http://www.boost.org/doc/libs/1_53_0/doc/html/lambda.html) (a C++ library) has been doing this for years. It has the advantage, though, of being a library for a statically typed language with an ahead-of-time compiler that actually optimizes away all of the overhead of building up and interpreting the resulting syntax tree so that the result is no slower than what you'd get by writing the same thing at a lower level of abstraction; by contrast, it is unfortunately the case that in most dynamically typed languages such as Python you have to pay a price in runtime to work at higher levels of abstraction as the work of building up and interpreting the syntax tree (in the library code) has to be done *every time* the feature is used at run time instead of exactly once at compile time.
How can you listen to "Radio Free Python" with regularity? It's soul-crushingly irregular!
Check out BeautifulSoup
IMO it would be more readable if it were multiple lines: assert list( map( F() &lt;&lt; str &lt;&lt; (_ ** 2) &lt;&lt; (_ + 1), range(3) ) ) == ["1", "4", "9"]
This. Or Selenium if you're doing automated testing.
Like bulv1ne said, [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) (or [lxml](http://lxml.de/)) are *the* way to go. [Here's](http://blog.dispatched.ch/2010/08/16/beautifulsoup-vs-lxml-performance/) a short benchmark of the two. I've found BeautifulSoup to be a lot easier to install, and more "intuitive" in use, so I stick with it. Also, I think people are more likely to have it installed if you are distributing a package.
Not exactly, it's partial application. 
Very good point. :-)
https://code.google.com/p/html5lib/
With partial function application, my example `foo(1)(2)`'s equivalent expression would look like `partial(foo, 1)(2)`. This would evaluate to the lambda function. To call it, you would do `partial(foo, 1)(2)(2)` which would evaluate to `3`. To show that `partial` is not technically currying, you can't chain them like you can in Haskell; `partial(partial(partial(foo, 1), 2), 2)` (or abbreviated as `partial(foo, 1, 2, 2)`) won't work, because creating a `partial` object never executes the function's `__call__` method. This would just bind more arguments than `foo` will accept. EDIT: I did not test any of this and I updated to include a shortened partial chain.
You *can* write that on multiple lines...it's syntactically valid because of the open parentheses.
Development on 3.x halted for a while in 2010 IIRC, but 4.x seems to have taken of again. I switched to `lxml` a while ago. It has a slightly steeper learning curve compared to `BeautifulSoup`, but that investment is worth it given the very noticeable speed-up, and build-in support for e.g. XPath, validation, XSLT, etc. Installation of `lxml` used to be somewhat tricky, but on a Linux system it is a breeze, e.g. apt-get install libxml2-dev libxslt-dev pip install lxml
For your count + ifilter example, there is a better function in itertools: &gt;&gt;&gt; print list(itertools.takewhile(lambda x: x &lt; 20, itertools.count(10, 1))) [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
I edited my comment and made you look a fool. Take that craisineater :P
It was not designed for such purposes. It's really god for small inline functions that should be easy understand without counting of "\_" signs. Like "\_ &lt; 10" (it quite easy to understand that it's something that less than 10), or "_ + _". Your example is really too sophisticated and I don't see any advantages of using shortcut(s) for function definition. 
if you happen to know jquery, check out pyquery
Currying is all about positional arguments. Just don't use it for function that accepts named argument(s). What the problem is? 
If fn._ ins't intended for anything moderately complex, then what advantage does it have vs. using the lambda keyword? 
"_ + 2" is a lot more concise and than "lambda x: x+2"
Here's an example for you, then: _ / _. This is a very simple function (and so the kind of function your library is designed to make easier to write) *but* if the first argument needs to be the denominator rather than the numerator then your library won't work. I would recommend creating placeholders _1, _2, _3, etc. that lets one explicitly specify which argument goes into which place, because it would greatly expand the potential use of your library for writing short functions.
The main idea around this `_` shortcut is currying (actually, it's one of the basic idea in FP and you can meet it almost everywhere). Adding new shortcut generates for you new function to consume new positional argument. If you need to change arguments order use `op.flip` (by the way it's common practice in Haskell). If you need sophisticated order, like `_3 ** _1 - _2` it's really better to define function with **normal** names to clarify what's going on. Or rethink arguments order. 
I've always enjoyed the revision battle that went on over that one. http://stackoverflow.com/posts/1732454/revisions?page=1 
wish i would have read this a few month ago when i started to really get into python, would have avoided a lot of confusion. good read nevertheless
One advantage is that, since it's enclosed in parentheses, you could have multiline lambdas (which is, frankly, something that's been stubbornly missing). A function that has to be declared separately just to be returned at some further point downstream is just ugly and annoying. But, to answer your question directly, some very simple examples are also precluded by ``_``'s parameterization. Say, (x &gt; 0 and x &lt; 10). You'd have to go back to the unfortunately lengthy ``lambda`` keyword for that, which is more of a pain to read. If possible, I'd love to see a scheme similar to ``string.format``, like ``({0} &lt; 10 and {0} &gt; 0 and {0} &lt; {1})``.
`ModelStruct` was only my suggestion - if it doesn't make sense to you, come up with something else meaningful. You can always do: BinIO = NewClassName # Backwards compatibility Yes, the count expression will need its own quotation marks in tuples. That seems like an acceptable trade-off to me, but I can see that with very large structures it might be mildly annoying. Using `eval()` is also a point of concern. Although I think your validation code looks safe, maybe someone else could get past it. I'd be inclined to parse the expression to an AST, and validate that there are no [Call](http://greentreesnakes.readthedocs.org/en/latest/nodes.html#Call) nodes there. GH/BB: It's a bit of learning to get started, but it's valuable to know. Here's [Github help](https://help.github.com/) and [Bitbucket 101](https://confluence.atlassian.com/display/BITBUCKET/bitbucket+101).
I've used lxml.html a lot. It uses the ElementTree API, which I like, and it's pretty fast (mostly written in Cython, IIRC, on top of libxml2).
X
pypy doesn't suffer from the GIL. It's an implementation issue not a language design issue. If you are going to troll, it helps to know what you are talking about. 
X
Pics/video? 
&gt; But the lambda is more readable because the letter looks like a variable whereas the underscore looks like an operator at first glance. I suppose to some extent this is subjective; I am used to underscores being identifiers so it would never have occurred to me that it was an operator. I do agree with you, though, that _ makes it look like something more interesting than a normal variable is going on, and that is a good thing because that is exactly the case. The _ operator is a placeholder that will be filled in with the argument of the function. Once you know this, it is incredibly easy to see what is going on at a glance. &gt; Not to mention that with the underscore you're limited to single-use positional arguments only, and apparently a very small number of them at that. I agree that it is unfortunate that the order of arguments is fixed. As I have said elsewhere, one could partly fix this by introducing positional arguments _1, _2, etc., but it sounds like the author of the library thinks that having this capability would encourage poor coding practices (which is a bit ironic given that many people here are probably think the exact same thing about his library as it is now :-) ). I am a bit surprised to hear that the number of arguments is limited, though, since I assume that an expression tree is being built up and so I have trouble seeing where the limitation would be as there is no limit on the size of the tree. &gt; I'm having some difficulty seeing the benefit. Could someone please show some real-world examples of why it's useful? I can't think of an example from my own code off the top of my head, but you'd typically use it in cases like ``map(_+2,list)`` where you want to hand an anonymous function to a higher-order function and it is so small and simple that creating a lambda expression would just add line noise.
True, but no matter what you call it there will probably always be some other library out there that has a name conflict; that's why the "as" clause exists in the important statement. So the only reason that it would make sense to change the default is if this library is sufficiently important and widely used that it is worth picking a more cumbersome name to avoid conflicting with it. (And honestly, that might be the case here; its not a library that I am familiar with so I won't claim to have a qualified opinion on it.)
&gt;PyPy only supports Python 2 which has been deprecated for how long now? Python 2 is "deprecated" - you must be trolling. There are still major libraries that only work on Python 2 and haven't been ported over to 3 yet. Most of the world is still using Python 2. PyPy rushing to support Python 3 wouldn't be a good use of their development time.
How long has it been deprecated?
Name conflicts between libraries are fine in a language with namespaces, in my book. However, a library polluting keywords, type names, etc. is just asking for trouble.
Negative karma here we go.
Python 3.0 was released in 2008, and at this point Python 2.7 only receives bug fixes, not feature updates. Still, the users aren't migrating due to the chicken-and-egg issue with library migration, and who knows how many years it will be before that changes. 2.7 is still the de facto Python version used by most of the world.
X
Right on target for my Python level of knowledge. Very clear!
&gt; pypy doesn't suffer from the GIL. You're misinformed, they do have GIL as of now. Moreover, even their planned approach (which may or may not succeed) is not to remove GIL in general, but to implement a very limited kind of STM that will allow parallelizing event-driven frameworks like Twisted. A better example would be IronPython and Jython, but those have their own tradeoffs. &gt; It's an implementation issue not a language design issue. It's actually a rather fundamental language design issue, otherwise why do you think all other similar languages either use GIL (Ruby, Lua) or don't have shared-state threading at all (Perl, PHP)?
Dude, you're suggesting switching to another programming language on a PYTHON board.
Radio Free Python is really fantastic, I wish it would come out more frequently. It's so rare that both host and guests are so knowledgeable on a topic.
I noticed one missing possibility: cute lambdas would really synergize with LINQ-style combinators, `.map(_.strip())` is way better than `.map(methodcaller("strip"))`.
Ok, implemented
I have uploaded a new version, with the requested feature of initialization with lists of triplets.
Do not use BeautifulSoup. It's buggy, it's incorrect and we have a better solution: html5lib + lxml. Example: from html5lib import HTMLParser from html5lib.treebuilders import getTreeBuilder from lxml.cssselect import CSSSelector XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml' html_parser = HTMLParser(tree=getTreeBuilder('lxml')) def compile_selector(selector): return CSSSelector(selector, namespaces={'html': XHTML_NAMESPACE}) def parse_html(string_or_stream): return html_parser.parse(string_or_stream, encoding='utf-8', useChardet=False) def test(): doc = parse_html('&lt;h1&gt;Hello World!&lt;/h1&gt;') find_headlines = compile_selector('html|h1') for headline in find_headlines(doc): print headline.text if __name__ == '__main__': test() 
well, everything has its good and bad points, take Java for example, it's a rock-solid implementation with the best VM around, tons of year-proven libraries and so on... and yet is a horrible language to work with. it's really important to know the weaknesses of the tools you use but also know when those are a major problem for the current task so you actually *need* to switch to a different language.
If you need to use threads like you are in Java, there is Jython. The GIL exists for reasons you will understand if you ever implement your own interpreter, and its impact isn't dramatic enough to make CPython unfit for use. But let's be honest, you would not use Python even if the GIL went away tomorrow. 
Just bought your books. Thanks. Are you open to comments?
Your point is that partial never knows to return a value when give the last parameter, and instead returns a function that takes no arguments? True currying would return the value?
Normal python functions accept named arguments. The issue is that the meaning is unclear with variadic functions.
X
There's an emacs hook to convert the lambda keyword to the λ character in python mode, which gets rid of some of the clutter of using traditional lambas.
Well, I might improve the validator, for example - I think I can do it without much extra code. ;-) And small projects have a habit of growing. But honestly, I think a public repository is just good practice for an open source project, like uploading Python modules to PyPI. People can see your code, there's an obvious way to report bugs, and it encourages people to fix things themselves. [Here's](https://bitbucket.org/takluyver/pynotify2/src) a similarly tiny module that I've put on bitbucket, for example.
Yes, always! Be brutal, I can take it (you can contact me directly at jeff@jeffknupp.com). Most of the good ideas/corrections in the book are the direct result of feedback I received from someone.
This isn't a random, low-impact name conflict. This library introduces a convention: it tries to claim _ as a special character like jQuery's $. But _ is already overloaded both for gettext AND as a convention for throwaway values. Unfortunately, these conventions are much too old and widespread to make people give them up. So why make this situation even worse? This convention will create a persistent headache for anyone touching a project that uses this library. This library is brand new, it shouldn't be a big problem for it to change its docs to save its users (and everyone else) some trouble. Python isn't a language of glyphs, let alone glyphs which are remapped by user libraries. It isn't polite to reserve single-character identifiers for your library (and IMHO it is marginal to reserve a tiny word like 'fn').
Correct.
I know what you're talking about, and I try to be explicit in the post: "Anything you can (legally) place on the right hand side of the equals sign is (or creates) an object in Python." It's a quick litmus test for beginners. I can't do `x = import collections`, so that's probably not an object. The same with `pass` and `::1`. The `for` loop actually does create an object, so that may not be the best example (`for` on its own is nonsensical; any valid `for` statement creates an Iterator).
&gt; The ::-1 in s[::-1] is not an object. Yah it is. class showSlice(object): def __getitem__(self, key): return key s = showSlice() print s[::-1] Output: slice(None, None, -1) It's a slice object! For extra fun: print s[...] Output: Ellipsis
Agreed. It makes sense to start by looking a limited C/C++ header file or one that has already run through the C preprocessor.
If it were a discussion of say, I am trying to do something in Python but need a performance boost from multiprocessors, a suggestion to use another language might be in order. Instead, your comment is essentially just trolling and not adding any value, that is why you are downvoted. The karma system works, because most people don't want to see these troll comments.
You can even do: sudo apt-get install python-lxml (Use `python3-lxml` for Python 3). If you're using virtualenv, you'll need to create virtualenvs with the `--system-site-packages` flag so they see the global installation.
Thanks!
after learning here about "Radio Free Python" I went back, downloaded the episodes and listened to a couple of them. I like it. Looking forward to hear more of it.
Account created 15 days ago? Go away, troll.
X
Cute, but why didn't you... `import valentines` `print valentines.ascii_heart(6)` 
I'm just trying to raise awareness. Check out the Hacker News discussion [here](http://news.ycombinator.com/item?id=5221093).
Yeah I should learn perl one of these days ...
I wanted to read this, but the logo in the background is too distracting. It looks neat, but it's makes your site nearly impossible for me to read. usability and readability &gt; aesthetics. Every single time.
http://xkcd.com/353/ 
Doesn't Google use Python for everything? I'd imagine a letter from them would hold a lot of value. I'm sure they have offices somewhere in the EU.
I can't imagine that this will be a problem. But just in case a sent a danish book on Python. I hope that results from a lot of different countries will make the case easier.
Take a look at "Two Scoops of Django" [[link]](https://django.2scoops.org/)
I wasn't being literal, silly. I just meant that they use it quite heavily. I think YouTube's backend is all Python.
They prototyped almost everything of youtube with Python and only rewriting the most time critical parts in C. I think it was mentioned in a clip that still 80% of the backend is still Python. Don't quote me on that number though, but it was a pretty large portion.
I can heartily recommend this book. However, it's not meant for the very beginner. I would say: go through the Django tutorial etc... and get a grip on how everything works together first. 2scoops is written by experienced developers and focuses on best practices, common patterns and techniques. It's written with Django 1.4 and 1.5 in mind so it's very up-to-date with current thinking.
That sure is a lot of code compared to pyquery: import pyquery doc=pyquery.PyQuery("&lt;h1&gt;Hello World!&lt;/h1&gt;") for headline in doc("h1"): print headline.text (pyquery uses lxml)
I had a hard time with this too. I ended up just installing them (using apt-get) on my VPS and doing all my development over ssh.
I'm personally a 2.7.3 coder, but I'm not sure which version to buy. Can't really afford both as a student (mostly in time but a bit in money), so I'm trying to decide which one to go for. I'm really considering to make the jump to 3.3, but I'm not sure how big the gap is, and what the differences are. I was hoping you could shed some wisdom, since you have written your book in both and most likely are very knowledgeable about the differences. Thanks for the great article too!
:-) True. I've yet to find a "regular" Python podcast.
Well they use Debian Squeeze to serve their website which ships with Python 2.6. They only have to run 'python --version' on their own web server to know how stupid they are being.
&amp;lt;pedantry&gt; That's actually a slightly dangerous design of the `parameter(…)` method, as it means there's no distinction between "parameter does not exist" and "parameter does exist but is empty". It would be less surprising to follow Python's `dict.get(key, default=None)` model: `Request.parameter(name, default=None)`, then use: param = r.parameter("testing", "") Or even param = r.parameter("testing") or "" &amp;lt;/pedantry&gt; Yes, I 100% agree. I have… trouble… imaging a world where: fixed = r.parameter("testing") .map(methodcaller("strip")) .filter(len) .map(methodcaller("upper")) .get_or("") Is preferable to: param = request.parameter("testing") fixed = (param or "").strip().upper() Possibly this is just a poorly chosen example on the author's part… But I don't have the monad-foo to suggest a better one :\
[Take a look at this](http://www.youtube.com/watch?feature=player_detailpage&amp;v=KKQS8EDG1P4#t=2061s).
If your job is that bad, why do you want to stay?
Where did he say his job was bad? Also not everyone has the savings to just quit a job any time they don't enjoy it. 
I don't think it would make a difference because even python code would use network and port settings. Also, it's probably a violation of your employment conditions so you could lose your job. Why not invest in a 3G tablet?
Willfully bypassing corporate restrictions is an easy way to have the decision made for you.
I'm pretty sure that they are aware what Python is and how popular it is. My guess is they're just hoping to get some free SEO. If someone googles for Python, their ad may appear, or sth like that. Either way, IMO this is a well-planned move on their part. 
you should take a look at pytest fixtures that can be parametrized also pytests parametrize and metafunc options
I'm sorry, but what? You need 'evidence' of the use of Python software throughout the EU. I present as my witness, your honour, the clear and obvious facts of reality which are plain to see for anyone with an Internet connection who can read. While you guys are at it can someone send me some evidence that gravity works throughput the EU since someone got www.gravity.co.uk and is trying to sue physics for trademark infringement. If courts take this seriously and don't tell these people in no uncertain terms to fuck off and get real then something is badly wrong. What am I talking about, most things are badly wrong with this world. /rant Edit - the bastards did as well!
You can't. Sure, it's beneficial to use a parsing library like lxml, however this is the naive case where all websites have completely well-formed HTML that's totally RFC-compliant. In the real world, this is far from the truth. You will need to write your 10-line parser then spend another 3000 lines on exception handling, which you need to update on a case-by-case basis. Have fun! 
&gt;Cython I was going to snarkily correct you to CPython, but then I discovered that [Cython](http://cython.org) is actually a thing. Looks interesting.
Google isn't really a fan of C++ that's one reason why they built Go. 
And then you get a severance package :)
If by "well-planned" you really meant "bad-planned". This is already back-firing at them.
Thanks for posting this. I sent them an email asking politely to pick another god-damn snake to use.
Just in case anyone takes that seriously: NO YOU DON'T If you willfully bypass company restrictions, firing you would be considered rightful dismissal.
Fair point.
Guido van Rossum, who first designed Python, worked at Google from 2005 up until a few months ago when he went to Dropbox. So I'm guessing he has quite a few connections there.
The booby-trapped random.random is a neat debugging trick.
That being said, beautiful soup with lxml is still not as fast as pure lxml, though I'm not sure why. If you're looking for pure speed, go with lxml. 
Oh man, I'm *so* told, snap! Lol, how cute. What would the internet be, without depressed teenage trolls projecting their masturbatory frustrations over random bystanders? Ah well, at least it'll keep 'em off the streets, or something.
Really nice illustration of a *lot* of things.
Now why would they do something that ridiculous????
Beginning to wonder myself
Good one !
I wonder how serious the threat actually is. Can a judge seriously allow Python to be used as a trademark ? It seems so ... (sorry I can't find a suitable word.)
X
I don't see `$EDITOR` on that list, why isn't `$EDITOR` on THAT LIST? I now hate that list since it doesn't have `$EDITOR` and all the people who don't use `$EDITOR` are poo-poo heads.
I was searching it before I was submitting it but I found only this [this!](http://www.reddit.com/r/prograrticles/comments/18cto5/start_writing_more_classes/) and it was not showing the python entry.
and how well does html5lib do on non-well formed html documents, since that is bs4's strength. 
seriously though how fast does it have to be to scrape imgur? 
Nah, I use $OTHER_EDITOR which is way better than yours!
Horseshit! $EDITOR has had $EPIC_FEATURE since $ARBITRARY_DATE!
But CPython is just the main python interpreter...
Whatever! $OTHER_EDITOR has $OTHER_EPIC_FEATURE and $DISPUTABLE_WORKAROUND to do that. Besides, it also the favorite tool of $EPIC_OLD_SOFTWARE_ENGINEER and you can use $ARBITRARY_PROGRAMMING_LANGUAGE to make plugins, etc.
cat.
Yeah well, $ABYSMAL_RETORT.
I enjoyed this entire exchange. +1s to all of you. 
&gt;&gt; DeviceAddedListener blocks in a loop right when it gets instantiated. WTH? &gt; Better way to implement this? Place loop outside the class? It's okay to have this kind of loop in a class. But it shouldn't run right when you instantiate it. It's better to call a method explicitly which does the looping then. It's like running code when you import a module, never do that! &gt; I wouldn't edit the config by hand and you cannot actually add a device via arguments, to me it seems the only sensible way is via the -a interactive CLI. Why not? Most software I know is configured only by editing a file.
I think I'll file a divorce and take Python with me. I just can't believe you would betray me with an nasty $EDITOR like that.
Take it and then take that stinkin' $LANGUAGE with you!
Yes. Generic words are allowable as trademarks as long as they aren't descriptive of the line of business in which they apply. So, Apple is a perfectly acceptable trademark for a [company that sells computers](http://en.wikipedia.org/wiki/Apple_Computers) or a [company that produces music](http://en.wikipedia.org/wiki/Apple_Records) but it wouldn't be okay for a company that sells apples. Python can be a trademark for the name of a programming language, but it wouldn't be a valid trademark for someone selling snakes.
I never want to see you again!!!! ;(
best part of the article :D
For the foreseeable future, I'm going to be suggesting Ramnode.com for inexpensive VPSes. They were suggested to me a couple months ago on Reddit for a couple Drupal projects and it has turned out very well so far. Use a discount code (there are various ones floating around, but IRC33 will give you 33% off for life). You can get a 1GB RAM, 4 CPU Core, 20GB SSD (or 60GB SSD cached), a gigabit port, 3TB monthly bandwidth VPS for $10/month, or cheaper if you pay yearly. There are only two downsides to Ramnode 1) The sign-up form is a little confusing for payments... gotta choose Paypal to use a CC, but doesn't require Paypal login. 2) They don't have a phone number to contact them (which doesn't bother me). They are reachable through Ticket system, IRC, Skype, and Email. Oh, and their remote backups are only once per week and requires a ticket to restore, if that matters to you.
&gt; An IDE (Integrated Development Environment) is one of the best tools a programmer can wield. It allows developers to work efficiently and forget about the boilerplate. I think this premise is somewhat incorrect in the context of Python. It would be quite accurate in the case of Java for instance (if you remove the boilerplate part) but I do not think it applies well for Python. IDEs introduce inefficiency as well. They often take a long time to start. They gobble up a huge amount of your available memory. They cannot be used in a simple terminal when working on a remote machine. Many of them have so many features that they can be considered a distraction from doing the actual job of developing. &gt; While some programmers scoff at the idea of using anything more than a text editor [...] I feel like you were referring to me there but I would say that scoff is the wrong verb here. I have no intention of mocking people who use an IDE for developing with Python. If that works for you, go ahead. It just does not work well for me. I like the KISS principle (Keep It Simple and Stupid). IDEs introduce unnecessary complexity in my already complex life. As a side note, I like what the people behind Komodo Edit are doing even if I'm not using it.
Thanks for the link. I haven't checked in a year or so and hadn't really been following the issue. Apparently it's starting to look much better.
That said, I really don't see [Wing](http://wingware.com/) on the list, which I've been using for years with few complaints.
&gt; I enjoyed this entire exchange. all = [you+1 for you in all] 
1. Process A and Process B are running simultaneously. * Process A is executing the code written here. * Process B just runs `os.makedirs(CONFDIR)`. 2. `CONFDIR` does not exist yet. 3. Process A starts running and executes `os.path.exists(CONFDIR)`. It gets back `False` and so moves into the branch. 4. Meanwhile, Process B gets some time. It runs `os.makedirs(CONFDIR)`. The directory now exists. 5. Process A gets to run again, it tries to do `os.makedirs(CONFDIR)` gets an exception and returns -1.
X
Just a kind and off-topic advice on linking stuff on the internet: * Not so good: *Check out the Hacker News discussion [here](http://news.ycombinator.com/item?id=5221093).* * Much better: *Check out the [Hacker News discussion](http://news.ycombinator.com/item?id=5221093).* The link text should describe what you are linking to :)
This is an implementation detail and not a language feature. There are many predefined objects in the standard C Python implementation including some small integers and several single ascii characters. For instance code like: a = "a" b = "a" a is b &gt; True But the same with more complex assignments doesn't work a = "cat" b = "cat" a is b &gt; False
This is only because `CONFDIR` doesn't exist. If before the `if` block `CONFDIR` was defined then this would not be a race condition, correct? Additionally if `CONFDIR` was a generator could it cause a race condition as it wouldn't exist until that line was executed?
Ah, thank you.
This is speculation, I haven't gone through the source code to verify it, but from what I understand of the implementation I'll throw it out there. All python variables are bindings to a reference. When you run "i = 1" you get an integer object in memory with the value 1 and a name '1' that points to it. If you then execute "j = 1" you get another reference 'j' pointing to the same integer object. &gt;&gt;&gt; i = 1 &gt;&gt;&gt; id(1) 35513144 &gt;&gt;&gt; id(i) 35513144 &gt;&gt;&gt; j = 1 &gt;&gt;&gt; id(j) 35513144 The range of integers that this works for is probably arbitrary. With practically every implementation decision being a trade off of speed vs. efficiency, I would guess that the actual range of numbers that are optimized in this manner was arbitrarily limited. By your own observation: &gt;&gt;&gt; i = -8 &gt;&gt;&gt; id(i) 35788688 &gt;&gt;&gt; j = -8 &gt;&gt;&gt; id(j) 35788616 You could verify this in the source, but I'm pretty sure this would be the explanation. 
I also tinkered with identities and found this: &gt;&gt;&gt; id(257) 167911064 &gt;&gt;&gt; id(258) 167911064 &gt;&gt;&gt; id(257), id(258) (167911064, 167911040) Implementations are always weird. I'm still wondering why they choose to start it from -5. I understand -1, because atleast find() function uses that to return 'not found'.
Python variables are better explained as Tags that are attached to objects. So the numbers 1, 2, 3, the strings "a" and "cat", and the function "foo" are all objects that are kept alive as long as variables are tagging them. So, to keep memory constraints down and things speedy, the Python interpreter keeps certain objects permanently alive and beyond the reach of the garbage collector so that they can be efficiently reused. So, 300==300, but 300 is not 300, because the values match but the objects are different.
The point is that it's possible for stuff to change between the `exists` and `makedirs` and that means a potential for bugs. Of course there are situations where that code works, that's the nature of race conditions.
WSGI kills me. I wish there was a way to say "I can't finish this response". I also wish there was a way to deal with chunked request bodies. And that there was some way to hook logging into it. And some other stuff. We end up using a server we've modified to behave in a consistent (if not standard) way.
Ah okay. Is there a better way to write the above `if` block?
 try: os.makedirs(CONFDIR) except OSError as e: if e.errno != errno.EEXIST: raise # or to mimic what the code above does "return -1" EDIT: also, see: http://docs.python.org/2/howto/doanddont.html#exceptions
On the CPython implementation [-5, 256] are *cached* internally. You can literally never remove the instances of those integers. Therefore, when you ask Python if `-5 is -5`, it will certainly be `True`, because both instances *are the same instance* whereas outside that range, CPython is free to create *and probably does* create new instances of those integers.
or they are integers that are pretty widely used, -1, 0, 256, 128, are all numbers that are probably pretty common. Other langauges do this with integers and strings as well.
The company in question has a Twitter account @PythonCloud. and a G+ account https://plus.google.com/109472590503457709404/posts
I use -6 a lot.
That link was very helpful and informative. Thank you. Do you have any other suggested readings like that? Also, thank you for taking time out to explain that information, it's appreciated.
 Juan-Pablo Scaletti • take a look at [Clay](http://clay.lucumalabs.com/) , easier to use. 
Then maybe you should recompile python and change that `#define` to include -6 as well. 
&gt;It's like running code when you import a module, never do that! Hrm... I was looking at some code today where I set up constants within the module by reading an /etc config file. The constants are accessed by a bunch of functions in the module. I guess I could do a config file read each time one of these functions is called...
First of all, this is specific to the "python", the Python interpreter written in C, which is also known as "CPython". This isn't part of the language, and it may not be true in other Python interpreters (like IronPython, PyPy, and Jython). Here's what's going on. Python internally represents an integer as an object. Whenever you do something that creates an integer, like type in a number, or perform some math, Python makes a new object for the integer. But creating integer object is a little slow. So there's a special case for exactly those integers, as a small speed optimization. Python pre-creates all those integers, and then it's about to create a new integer object it checks to see if it's between -5 and 256 inclusive. If it is, it just gives you a new reference to the premade integer. [Here's the code for this for Python 2.7](http://hg.python.org/cpython/file/e63c4bc81d9f/Objects/intobject.c), and [here's the code for the current trunk](http://hg.python.org/cpython/file/8b85f10b5341/Objects/longobject.c) (what will become 3.4). In both cases search for NSMALLNEGINTS; in 3.4 it's right at the top. The numbers are right there--NSMALLNEGINTS is 5, which gets negated to become -5, and NSMALLPOSINTS is 257, one past 256. Python calls this process of deliberately storing objects eternally and reusing them "interning". CPython hand-interns those integers. It also interns strings quite frequently. In fact, it's so frequent, it can be hard to get CPython to stop doing it! Any hard-coded string in any module is automatically interned, and that includes the names of classes, functions, and variables, not to mention the names of the modules themselves. But I played with it for a few minutes and got it to break. Take a look at this code, which runs under Python 2 and Python 3 (though under 2 it prints some extraneous parentheses): def rofl(): return "rofl" def roflcopter_identity_tester(x): y = rofl() + "copter" print("x is y", x is y) print("x is 'roflcopter'", x is "roflcopter") print("rofl() + 'copter':") roflcopter_identity_tester(rofl() + "copter") print("'roflcopter':") roflcopter_identity_tester("roflcopter") CPython says the two hard-coded 'roflcopter' strings are the same object, and none of the other strings are the same object. The moral of the story: don't use the "is" operator for anything but your own objects.
IIRC, it uses HTML 5's parsing algorithm, so it's a very solid parser. BS 4 includes support for html5lib-based parsing.
Some of the online books and exercises in the sidebar look like they'd probably be good extra information. The python docs are, in general, quite good as well. No prob, glad to help :)
 ... , seed=random.random()): Wow. How lazy. 
It uses lxml but it does not use html5lib. lxml.html is a horrible parser.
"The moral of the story: don't use the "is" operator for anything but your own objects." Wrong, if you want to specifically distinguish False from 0 and True from 1, you need to use the "is" operator.
This is the likely truth. 
The problem is that I don't want a VPS. I want something that is managed by someone else that can run my WSGI application and give me a PostgreSQL database to connect to.
And a more common case - if you want to test whether a variable is `None`, you use `is` rather than `==`. In general, you check for singletons (True, False, None, NotImplemented, Ellipsis) using `is`. The action of `==` can be overridden, so I can define an object that appears to be equal to everything. `is` can't be overridden, so `a is None` means exactly what it says.
 __import__('BaseHTTPServer').BaseHTTPRequestHandler.address_string = lambda x:x.client_address[0] This will make your `wsgiref.simple_server` faster.
`pype` is awesome. renamed ;)
That's too bad, it's a nice library to use.
eh, renamed repo and link is broke. it is over here now: https://github.com/jisaacstone/pype
Oooh. I didn't come across this one when I looked around for similar projects. I'll definitely check it out. Thanks
What is wrong with an MIT license?
or how absolutely correct? Though, since it's seeded elsewhere, maybe how absolutely not random would also be correct?
This is blog spam - submitted by the blog that wrote the divisive article in order to generate ad revenue. Look at this rubbish: &gt;While some programmers scoff at the idea of using anything more than a text editor, when you are working on a very big project consisting of many files, an IDE will have features that will make your life as a developer much easier. &gt;Some features you can expect a good IDE to have are: &gt;Code completion &gt;Syntax highlighting &gt;Templates for common code &gt;Source Control support (Subversion, Mercurial or Git) All of which I get in vim. 
The correct thing to do as far as WSGI goes is to not call ``start_response`` more than once after data has been sent. That's easy enough to do in your application by hand :-)
More accurately, == isn't what you're usually meaning to do. It tests if the left and right side are the *same* value, but normally you care about a conceptual equivalence, rather than if they are literally the same value in memory. The reason == "MIGHT" work for strings is because the compiler is able to identify many cases where the same string is being used, and avoid creating new objects. * `"a" == "a"` : `true` - trivially, compiler can immediately tell these are the same string. * `"a" == "a"+""` : `true` - fairly simple optimization to remove the static concatenation. * `5+"" == 5+""` : `true` - similarly, static cast / concatenation. * `int x=5; x+"" == x+""` : `false` - though almost identical the compiler doesn't optimize the variable away, so it' can't be certain the strings will be the same at runtime. * `"a" == new String("a")` : `false` - explicitly creating a new string will prevent the compiler from optimizing these strings to the same value. * `"a" == new String("a").intern()` : `true` - conversely, the [intern()](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#intern%28%29) method returns a canonical reference for a given string, such that "`s.intern() == t.intern()` is true if and only if `s.equals(t)` is true". Since the first `"a"` is a static string, it's already interned at compile time. Using `==` isn't bad "because it MIGHT be true sometimes, but other times no" but because it's not what you need. In Python, `==` somewhat more intuitively does an equality check, where `is` does an identity check, like Java's `==`. In both cases, it's a mistake to do an identity check unless that's really what you want to do.
This question showed up on Stack Overflow a few years ago: [Python “is” operator behaves unexpectedly with integers](http://stackoverflow.com/questions/306313/python-is-operator-behaves-unexpectedly-with-integers). There's some more details there, but essentially, like dfndoe said, this isn't part of the language, but is instead an optimization to avoid Python needing to create many instances of the objects representing these very common values. You can see in the [source code for Python int/longs](http://hg.python.org/cpython/file/3.3/Objects/longobject.c) references to this range. The range [-5,257) (which is technically how it's defined in the source code) is likely based on some heuristics run against regular Python programs, they're the numbers used an inordinate amount more than arbitrary other numbers. They likely concluded that expanding the range past -5 or 256 wouldn't net much improvement.
I think it's still a little intriguing to know what heuristics they had for choosing that specific range. Or is it just some random cut off that whoever wrote that implementation used.
What license is applicable to `cronex`? I didn't see any LICENSE file or anything in the source code, and there's no `setup.py` or PyPI project.
Forgive me if github already has this question answered, but which version of Python is this written in? Won't ~~compile~~ *execute* in 3.2, so I'm guessing 2.7 or 2.6?
Absolutely, Java's a strictly-typed language, not a totalitarianly-typed language :P Under the covers, the `+` operator compiles into Java's [StringBuilder](http://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html) class, which has append (essentially, concatenate) methods for Objects and all primitives. So it's effectively the same as `new StringBuilder().append(5).append("").toString()`. The compiler can sometimes optimize out those extra calls, but that's why you shouldn't use concatenation to cast to a String - `String.valueOf(5)` is much faster than `5+""`.
X
If I were forced to choose, I would recommend the 3.3 version if only because the 2.7.3 version is written as close to Python 3 style as possible (especially for things backported to 2.7.3). Python 3 is clearly the way forward (although 2.7.3 will be maintained until 2016 I believe). The only reason I would buy 2.7.3 is a) if you were forced to use that version at your job or b) you were working on a 2.7.3 project and using a large number of packages not yet compatible with Python 3
Only if you need "100% success rate" (which isn't possible anyways). Using my lib ( https://github.com/mattseh/magicrequests ): print magicrequests.get(url).xpath('//a/@href') That'll get you all the links on a page. Wrap it with a try / except to stop network failures, seriously screwed up html etc. Then use magicrequests.imap to do 100 requests at once :)
I see it works with threads, so it is quite possible to use this as a synchronization server with gevent monkey patching Thanks for the lib
Just a suggestion, perhaps offer support for running jobs as separate processes. Should be dead-simple with the multiprocessing module. You could even allow it as a per-job option, e.g. run this job in a separate process vs in a separate thread. The main thing is, if I were running this, I wouldn't want one misbehaving job to kill all my other jobs. It's not that hard to crash the Python interpreter on accident if you're interacting with native libraries (especially under-documented libraries) either through ctypes or extension modules. I just don't really think this is real-world usable without some sort of job-isolation support.
It's not copyleft so some neckbeards will whine about your license.
How fast is the company growing? Is it possible that they want to build out two teams?
Yawn, has nothing to do with it. Having two leads makes no sense in a start-up, I'm here to work not to figure out who is going to do what. Running every little thing by another lead is not an ego thing, it's more of a productivity thing. And dealing with who get's to do what when we get more hires would be wierd as well. You obviously never worked at a start up to make such a blanket comment, leads are in charge of a lot of planning this is not a strictly programming position. BRB Two leads managing a team of 4 people.
TIL some programmers care about job titles.
I think those bridges are burned now, but I might do that.
&gt; *You obviously never worked at a start up to make such a blanket comment, leads are in charge of a lot of planning this is not a strictly programming position.* You'd be wrong. 20+ years as a developer. Start ups, established firms, old firms doing new things, new firms doing old things. Teams, mixed groups, solo developer. I do believe I've done all the variations. You are a guy who runs a machine shop. You make software for the business to accomplish the business goals. As the "lead" in the machine shop, you get to guide the rest of the mechanics and coordinate their work to try to be efficient. You are not a rock-star. Your position is not so important that there should be any conflict with other "leads". Work together. Divide up the tasks. Demonstrate that you're a professional who can get done what the business needs done and not a wanker who gets uptight about titles. 
Oh wow, 20 years... cool. Does that make you an expert by default? Talking about ego, ironic. Explain to me, why would there be two leads for a 4 person team what is the point of it? If you knew what you were talking about you would realize that's beyond retarded.
Tiny team does not need two leads as a self proclaimed CTO you should know that. I like how both of you mention how many years you worked like that means anything to me. If you think a start-up team with 4 people and 2 leads doing planning for those two other people is great then more power to you to me it screams waste of money and time. 
I wasn't clear - there is absolutely no need for **one** lead in a 4-person team. 
Sounds like you aren't the technical founder, so who cares. If there is a technical founder, then they will be making all the ultimate decisions. If there isn't a technical founder, then the company should be hiring smart technical people. You're probably confusing their title of 'team lead' with what they really mean of 'senior developer'. I can tell you though, the one thing they don't need is a prima donna developer that isn't a team player.
Sure... *rolls eyes*
Break the project into components, assign a lead for each. As a joe schmoe programmer who doesnt have the fancy title of "lead" but does work do some amount of work deferment to a couple newer members of the team, its plenty of extra work. Dony get caught up on job titles, your role seems to be continued developmeny duties with extra responsibility over others on your team...are you happy with that? If so, stay.
"Programmer Therapy" I think we should start it.
Ah, yeah, I'll toss in a license file soon, but it's listed in the cronex.py file as Public Domain. If you absolutely need the code to have an explicit license since public domain isn't universally recognized, consider it licensed under the FreeBSD or MIT.
X
Ah yep, sorry I was using 2.7
Great, now we need the tools to help package developers create cross-platform binaries containing extension modules, and test them in the relevant environment. An environment that builds a wheel, installs it, runs a test script (similar to Travis-CI). The developer gets an email with the test results and a link to download the file, which can then be uploaded to pypi. 
The documented WSGI behavior is one you don't want as an application: an undefined exception. The post says for instance that wsgiref does not raise an exception. That is incorrect: import sys from wsgiref.simple_server import make_server def app(environ, start_response): start_response('200 OK', [('Content-Type', 'text/plain')]) yield 'Foo' yield 'bar' try: 1/0 except Exception: start_response('500 INTERNAL SERVER ERROR', [('Content-Type', 'text/plain')], sys.exc_info()) make_server('localhost', 5000, app).serve_forever() It does raise an exception: $ python test2.py Traceback (most recent call last): File "/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/wsgiref/handlers.py", line 86, in run self.finish_response() File "/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/wsgiref/handlers.py", line 126, in finish_response for data in self.result: File "test2.py", line 12, in app start_response('500 INTERNAL SERVER ERROR', [('Content-Type', 'text/plain')], sys.exc_info()) File "test2.py", line 10, in app 1/0 ZeroDivisionError: integer division or modulo by zero Yes, as far as the response goes it looks truncated, but that's because you were trying to do something that is not supported.
Why didnt python just embrace fastcgi instead? wsgi is a mess. Passing in a callable is not easy for beginners to understand. And then wrapping that callable is even more of a mess.
How would fastcgi have been any better? seems that either way I have to poke around in a dictionary for request vars be it os.environ or an environ passed in as a parameter. wsgi isn't for beginners. there are plenty of frameworks that hide wsgi from beginners. wrapping callables however seems to be perfectly fine for beginners since frameworks such as bottle, flask and pyramid all "require" the use of decorators to get things done. 
can someone explain the use of this?
Another interesting case: &gt;&gt;&gt; 1000 is 1000 True &gt;&gt;&gt; a, b = 1000, 1000 &gt;&gt;&gt; a is b True &gt;&gt;&gt; a = 1000 &gt;&gt;&gt; b = 1000 &gt;&gt;&gt; a is b False It appears that when I type the same literal twice in a single statement, CPython creates a single int object.
Perhaps an ignorant question, but why not just embrace cross-platform (and language) self-describing data set formats
pip always builds from source. easy_install supports the old style binary egg packages, but it doesn't support virtualenv/pyenv, which is a major problem. This new package format will hopefully allow pip or pyenv to not have to rebuild everything every time. That can suck if you have to do it often and you're using modules that have things to build, such as C modules. For example, you might set up your CI server to create a fresh virtualenv and run the testsuite every time you commit to your VCS. Or maybe you have a lot of servers to deploy. Whatever the case, this allows building once and then deploying from that, rather than having to build the same source over and over again every time.
easy_install works with virtualenv just fine. Largest issue with binary eggs was lack of binary ABI on Linux. Build on distro X, see it not work on distro Y. 
Format for python extension modules.
How do you define troll? Because someone with different opinions, even stupid opinions, is not always a troll. I hate it when people accuse people with very unpopular opinions (like shitting on Python in /r/python) of being trolls. Do you have evidence of this user saying random inconsistent shit, just to piss people off? Break free of the groupthink.
Changed my password, but Chrome gives the following message on Windows 7 and iOS when accessing as https: "The site's security certificate is not trusted!". 
Oftentimes someone who is "shitting on Python in /r/python" is a troll, because they do so merely for the point of stirring up contention, rather than from an attempt to improve the language through criticism. One of the best signs of this is a highly-contentious statement (like the GP) without any explanatory comments. But I agree that "troll" is over-used; just think it's appropriate in this case.
Check his history, he gets around. It's one thing to talk shit for everything but Go, but to only have a 2 week old account and then accuse me of hating free speech is a little telling. I appreciate your skepticism though, but I'm a little e-insulted.
Briefly looking through his history I do not see evidence of that. Unpopular? yes. Bottom? no. Always? no. I feel you've exaggerated and misled me.
Are people with two week old accounts not allowed to state unpopular opinions? &gt;a little e-insulted. If skepticism insults you, you should feel *way* more insulted than that while speaking with me.
&gt;One of the best signs of this is a highly-contentious statement (like the GP) without any explanatory comments. Sounds like laziness or inability to write a convincing argument. That's not a troll.
Oooh, cool.
We're in the process of installing a new, CA-happy certificate. Should be done any moment now, actually. Sorry for the Big Red Message (and lack of certainty) in the interim. 
The browser-happy certificate is now operational :-)
The change from -1 to -5 was done in http://hg.python.org/cpython/rev/12753e7b15f7?revcount=120 The commit message is "Initialize the small integers and \_\_builtins\_\_ in startup." The commentary is at http://osdir.com/ml/python-patches/2002-09/msg00155.html . &gt; It may also be useful to define the small negative int (NSMALLNEGINTS) to be 5 or so instead of 1. There are several uses -2, -3, ... in the standard library. So the answer to why -5 is because the standard library uses it. I assume the upper limit of 257 is similar.
&gt;Largest issue with binary eggs was lack of binary ABI on Linux To be clear, you mean lack of binary ABI **in Python** on Linux, right? Linux doesn't keep a binary ABI for kernel drivers but I don't imagine that affects just about any Python packages.
As long as it's not PHP.
yup, we all know each other. There is no rivalry here. Just talks with different emphasis.
Bikeshedding: Why not use `.wheel` for the extension? DOS is dead.
Interesting. Msgpack does seem to be overall a better choice, since neither has a schema anyway.
Confirmed, thanks!
I do not even know how to interpret your question. This is about code, not data.
Ha ha ha ha! We LOVE freedom of speech. And no one here will try to censor you. And since you apparently love freedom of speech, you should cherish each and every downvote and dissenting opinion. See how that works? There is no good fight to be had here; just a sub-reddit that doesn't appreciate the off-topic, inappropriate, and evangelizing of a programming language (namely golang) in a python reddit. In fact, some would call that trolling. ::gasp::
"Never attribute to malice that which is adequately explained by stupidity." :P
You have to have that sort of implicit casting around if you want to shoot yourself in the foot all the time.
BSON should be more efficient to read based on the fact that you can memory map that thing and then don't have to actually parse anything really. Now how well that works in Python is a different story.
Hmm, I'm a little confused. Is this like a file to install a package? or is it like a 'binary' to run, kind of like a jar?
static vs. dynamic and strong vs. weak are pretty much orthogonal.
Or you could type-check. But you're probably doing something wrong if you need to make this distinction.
Shrug. Ever since at least the GoF book was published, we've seen repeated demonstrations that any kind of software engineering advice you give to the masses can be shockingly misinterpreted and misapplied, and that the end stage of this process is frequently "automatic code generation/rewriting" of one sort or another. No wonder that talented people consider it a major code smell in itself.
I agree that Python is in general a strongly typed language despite being dynamic, but one would initially think that Java is even more strongly typed. Java is certainly not a "weak yet statically typed" language (if such a thing even exists).
thanks!
&gt;a "weak yet statically typed" language (if such a thing even exists). It certainly does, and languages like C and Java qualify by most accounts. C++ has a much more sophisticated type system than C, and avoids a lot of type-safety loopholes (mostly to do with implicit function definitions, a "default" standard library scheme for formatting strings, etc.), but it still crucially gives you a bunch of implicit casts between numeric types. (Python avoids this by simply not having the numeric types; even having `int` vs. `long` in 2.x was presumably seen as a premature optimization and a mistake when it was taken out for 3.x.) If you want an actual *strongly*, statically typed language, you're looking at things like Ada. Or perhaps languages in the Haskell family, but those at least do you the service of type inference.
I didn't watch the whole video, but what is your problem reading the files? Can you post the code you have so far?
X
The code and an example GPX file are linked from the youtube video. https://docs.google.com/folder/d/0B-OhTg6e0IZMSDRib2FBbjVtQTQ/edit?usp=sharing
It's a file to install, like an `.rpm` or a `.deb`.
I think this is a good example of how people should ask programming questions. Not necessarily the Youtube part but the fact that you've explained the background, provided an example and shown what you've done to try to solve the problem so far. My first thought here is that you could use [gpsbabel](http://www.gpsbabel.org/) to convert the GPX file into a CSV file that you can read very simply with [python's csv module](http://docs.python.org/2/library/csv.html). My second was that you might benefit from trying the code line by line in the python shell to see what it is doing or when that becomes annoying learning about pdb. pdb will let you step through your code line by line and see what variables are. I don't know whether your editor has any debugging capabilities, but it's very simple to run the debugger on the command line. python -m pdb readgpx.py You can step through your file and check the values of variables. % python -m pdb rgpx.py &gt; /home/armchairist/src/readgpx/rgpx.py(1)&lt;module&gt;() -&gt; import xml.etree.cElementTree as et (Pdb) n &gt; /home/armchairist/src/readgpx/rgpx.py(5)&lt;module&gt;() -&gt; file = open('xmlfile.gpx','r') (Pdb) &gt; /home/armchairist/src/readgpx/rgpx.py(7)&lt;module&gt;() -&gt; data = file.read() (Pdb) &gt; /home/armchairist/src/readgpx/rgpx.py(8)&lt;module&gt;() -&gt; tree=et.fromstring(data) (Pdb) &gt; /home/armchairist/src/readgpx/rgpx.py(9)&lt;module&gt;() -&gt; file.close() (Pdb) &gt; /home/armchairist/src/readgpx/rgpx.py(16)&lt;module&gt;() -&gt; print "first loop" (Pdb) first loop &gt; /home/armchairist/src/readgpx/rgpx.py(19)&lt;module&gt;() -&gt; for dt in tree.findall('trkpt'): (Pdb) tree &lt;Element '{http://www.topografix.com/GPX/1/1}gpx' at 0xb73bcc08&gt; So, we can confirm that tree is an Element instance that refers to the gpx tag. The [documentation for Element.findall](http://docs.python.org/2/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element.findall) say that it finds subelements by tag name or path... The normal structure of the GPX file is something like this. + gpx |-- metadata |-+ trk |-+ trkseg |-- trkpt findall will find "metadata" or "trk" elements as they are subelements of gpx, we can confirm this in the pdb shell. (Pdb) tree.findall("trk") [] this doesn't work, and you get a clue as to why in the pdb output earlier... (Pdb) tree.findall("{http://www.topografix.com/GPX/1/1}trk") [&lt;Element '{http://www.topografix.com/GPX/1/1}trk' at 0xb73bcf50&gt;] Now, you can find direct subelements by tag name, so you could get the trk element from gpx, the trkseg from trk and so on. There is an easier way though, you can use xpath to find subelements. There are some decent examples of this [here](http://docs.python.org/2/library/xml.etree.elementtree.html#example) and the table below explains the syntax. So the end result is that you need to replace. for dt in tree.findall('trkpt'): with for dt in tree.findall('.//{http://www.topografix.com/GPX/1/1}trkpt'): It is possible to register namespaces, if you want to get rid of the {http://...} 
Why not use `.whl`?
.whl is ambiguous, .wheel isn't. You don't know its the vowel removed shortening of wheel, it could also be an abbreviation, it isn't like .txt or .mov in its obviousness.
I can't watch the video, so I don't more about your problem than what's in the title and comments, but I have used https://github.com/tkrajina/gpxpy in he past with success for reading GPX files.
Looks like they might have changed the login structure? I get "couldn't contact login site. Exiting." 
The namespace is the problem. You can either do it [the right way](http://www.reddit.com/r/Python/comments/18ongp/i_need_help_im_making_a_raspberry_pi_project/c8gmqwx) or fix it with a hack like this: # before et.fromstring() data = data.replace('xmlns="http://www.topografix.com/GPX/1/1"', '') # replace for loop with this for dt in tree.findall('.//trkpt'): [More solutions here](http://stackoverflow.com/questions/8113296/supressing-namespace-prefixes-in-elementtree-1-2). And I'd suggest not using spaces in Python filenames.
Can it cooperate with virtualenv / pyvenv (3.3 native), or set either of those up? Nice work man!
Nobody is hating freedom of speech, but when you spend all your effort defending your right to it and not answering the most basic (and first) response to your highly ambiguous statement...it pretty much looks like you're trolling; hence the downvotes
Just tried it with no problem. Are your login credentials right? Is there anything that would be preventing python from accessing the internet? Works with Python 2.7.3
It should cooperate well, but I've not tested it. Installing them may come in a future release.
That really was the best way of asking for help with a programming problem that I think I've seen. Plus it takes guts to put up a video about how you can't figure something out. 
Maybe they wanted to add some more Features to the standard dict and have not yet implemented those features.
I detect a fundamental misunderstanding of how Python works.
Your probably right, but if you could, can you tell me how i have gone wrong instead of laughing at the python noob?
Historical reasons. There used to be metadata attached to the fields which was stored in the dict. I assume a dict was used because it has a convenient (key=value) constructor. You can see that the last use of this was removed in [this commit](https://github.com/scrapy/scrapy/commit/951ba507f94cbdeb7b573020dc6fe730fdc61dbe). At this point it makes very little difference and it could just be a plain object (although changing could be difficult if there's still code out there which assumes it's a dict for some reason).
I think you and I both know how well that works in Python ;)
&gt;Python is not and probably will never be 'compiled' in the strictest sense of the word. What you're looking for is 'interpreter'. In what way? Any interpreted language can be compiled to machine code.
that was exactly what I thought. "uhh, you mean like pytest.parametrize()?"
simple but nice :) just a question, why do you omit args with a *trailing* underscore instead of the ones that start with it?
preceding underscores typically specify 'private' variables (by convention) which you still want automatically set I think. So no underscores is public, preceding is private, and trailing is omitted. Nice and simple I think?
Thank you for this clarification. Would you like to answer the SO question to? Just copy this text. If not, I can put a quote there.
Nice idea :) Screws with the autocompletion of pretty much any IDE though.
Good point. I also wondered if some of the IDE's would flag these auto-instance vars as 'undefined' when read. I really wish something like this were builtin so it would be accounted for in the IDE's, but I'm dreaming of course.
Hmm... then "wheel" seem to be a bit confusing name... To me wheel associated with something that can be run
Given all of what you just said, why not just use a vanilla `dict`?
&gt; Dicts have some nice features [...] That's not the point. The point was that a defined `Field` (aka `dict`) was not used as a `dict`.
Just a minor thing, but to check if a string ends with a given suffix, use `foo.endswith('_')` not `foo[-1] == '_'`. The latter has to create a new temporary string of length 1, compare it against a string constant, and then throw it away.
Yeah, they don't modify the class in any way; my guess is that there used to be some other attribute or method that got removed, and they aren't changing it in order to keep it backwards-compatible.
&gt; Some might believe this to be 'unpythonic', but I would respectfully disagree. We've listed a decorator and argument names denoting our intent, so IMHO we've been plenty 'explicit'. mfw
Would you mind elaborating on what you mean by native codegen path?
but creating new string variables from old ones (substrings) in Python is very cheap. I would argue that `foo.endswith('_')` is more clear as to it's purpose and easier to modify, (for example you could change it to `foo.endswith('__OMITME')` without having to muck with indexes and count the length of the string `'__OMITME'`
Consider adding it to the [Python Decorator Library](http://wiki.python.org/moin/PythonDecoratorLibrary).
I see, it's good. btw have you thought of using annotations? that may be a way to declare the rules without having to modify the way you instantiate the class. also, how do you deal with `*args`? thanks!
You could use these builds as well: http://download.opensuse.org/repositories/home:/cavallo71:/opt-python-interpreters They are for rhel 4, 5 6, fedora, mandriva and opensuse amongst the other.
Someone else pointed out it's a legacy hold out, but in my own code I might subclass dict so that later I could do simple sanity checks like `isinstance(what_is_it, Fields)` versus having to dig into the object itself to verify it met the expectations of being a Field dict.
Perhaps the absence of a linker and final assembler stage?
Ah, okay, makes sense.
&gt; btw have you thought of using annotations? Interesting. These are new to me and I had to look them up. I think these are specific to Py3k though? &gt;also, how do you deal with *args I'm assuming you are referring to the use of \*args by the wrapped function. Never tested it - I guess my assumption is you would use those *or* @instancevars and not both together. Something to test... I *think* it would just work but I don't really know. 
I like it. I was just lamenting to one of my coworkers that this isn't built-in to most languages.
You should give this a new name. Plain-old pip is already "pip for Windows" since it runs fine on Windows. You have written a new thing that adds onto pip, it should have its own name.
I agree with the sentiment but I think that the trailing _ rule is a bit too obscure. Consider the following: class A(): @instancevars('a', 'b') # declare which vars are assigned def __init__(self, a, b, c): pass 
I thought of that as well, but in the end I prefer the succinct-ness of listing the variables once. Also, this creates the ambiguity of whether the listed vars are auto-initialized or omitted, something I wanted to avoid. Probably just my perspective and others are certainly welcome to disagree. Its on github, so feel free to fork and modify.
The inbuilt csv module
yes but I'm wondering if there's some wrapper module that does the "updating"
 infile = raw_input('filename input:') outfile = raw_input('filename output:') column = raw_input('column:') import csv def fix(data): return data o = csv.writer(open(outfile,'w')) for row in csv.reader(open('infile','r')): row[column] = fix(row[column]) o.writerow(row) o.close() 
why?
Well done! Will take time to go through it.
Just as I said, to load programs from an SD card. It's for a gaming console-esque thing, but that's as much as I want to say. I've known of people who have stolen ideas from people I know after the person I knew told them, so I want to beat around that bush as much as I can. I don't know how profitable it'll be, so I don't want to give anything away.
I've been using [honcho](https://github.com/nickstenning/honcho) and Procfiles for a while to solve this.
How would you recommend running an operating system that has nothing but Python on it? Surely the rest of the OS would need to be coded in something non-Python (and be able to run those non-Python executables that the OS is made from). And an OS written in Python would likely be terribly slow. 1. I highly suspect that anything Windows will not give you a level of control to sandbox a user like that, so Linux would be your best bet (and Python is pretty much the same on any OS, so no loss there). 2. If you want them to run PyGame, you don't actually want a "terminal OS" since PyGame is a GUI. Since you'll probably also want the user to have access to a window manager (for taskbar, etc.) you'll inevitably need to allow the user to execute non-Python things since the login session runs under the user's account. 3. If you want to limit them to just a terminal, you'll want to look into the command `chroot`. This will separate the user from the rest of the filesystem and you can put a Python exe in there so the user can have access. 4. There is absolutely nothing you can do to prevent a user from plugging in a flash drive and copying over and running an executable. The OS will always be able to run those or it wouldn't be able to run Python.
It's pretty trivial. There's not much point in such a module. rows = list(csv.reader(file_obj)) # rows is just a plain list. mess around with it however you want here. csv.writer(another_file_obj).writerows(rows)
How big is the csv? It doesn't seem to difficult to read the whole thing and then overwriting it with the inbuilt modul.
thanks Mark, Going to wrap this up and add to my toolbox infile = r'\\blah\blah\test.csv' outfile = r'\\blah\blah\testfixed.csv' column = 13 import csv def fix(data): if data == '0': data = '20130218' return data with open(outfile, 'wb') as ofile: writer = csv.writer(ofile) with open(infile,'r') as ifile: reader = csv.reader(ifile) for row in reader: if row[column] == '0': row[column] = fix(row[column]) writer.writerow(row)
Ideas aren't worth sit, implementations are. 
not even big by any definition (10K to 100K lines), I just thought someone must have had created a "tabular data updater"
Thanks! I doubt that this will actually be created, but I just was wondering if I could do something of that nature.
Ideas are sometimes worth more than their use. The theory of relativity, probably one of the most well known ideas ever, has never gotten close to being proven. Not that this is the theory of relativity, but I don't know crap about making an OS or what an OS's limits are, so I can ask any stupid question I want. So yes, ideas *can* be worth 'sit'
I'm not sure why you need it to "run nothing else". You could come very close to this by installing linux on the Pi (or whatever you use) and set a command in your bashrc (or other shell) to launch python immediately. Then every terminal you open would just look like a python terminal. You might even be able to use python as a shell replacement, although I bet this would cause tons of issues with other scripts
python isn't a good systems language so you can't really write operating systems out of it and if you already have an operating system just install python and run everything through that like a normal person
I have no idea how I'd be able to program without Google or DuckDuckGo.
A: Python is not what I'm saying the OS should be built on. B: This would be an implementation into something other than just a home PC.
here's a guide on what to do: if (there's an os that can run python for your platform): install it install python on it else: write one install it install python on it alternatively, if there's no os for your platform that can run python, consider writing your program in something that it can run
Probably overkill for what you are doing but pandas has great support for this and makes it really easy to import data with the read_csv method.
annotations are specific to py3 yes but I think there's some workarounds for py2 (such as using the docstring). regarding `*args` I got curious about where would you get the name for the instance var (since those are unnamed as they come as a tuple), looking at your code I see you're using `inspect` but you never use varargs so those will be ignored. I'm also wondering how this would work with inheritance.
True - trying to think if it would be useful or not auto-setting all the varargs and kwargs. Seems like if you are using those it is likely something 'special' and you don't necessarily want all those set as instance args. They are still there for you to explicitly do anything you like, but I agree it should be called out in the docs that we omit them. It works with inheritance in general. Take a look at the tests. I had the same question myself but the tests pass.
Pip for windows for linux please :)
Uh, Linux? I think you're asking for Linux. I think pretty much all Linux distros have a version of python installed. You run programs at the command line like this: python my_program.py However ameoba is right. A great idea can't become real without someone actually creating it, and doing it well. The idea people tend to overvalue that contribution and undervalue execution.
I think the potential to make a wireless HD IP camera for ~$50 is just awesome.
actually in this case i'd say your idea isnt worth shit, if you are going to make a game console why on earth would you use python
Just pulled in changes to make this compatible with Python 3. This did add a runtime penalty of roughly 7-8% (had to wrap the items and zip in lists). Also, added a quick benchmark and found this to be roughly 4X slower on Python 2.7.x and 5X slower on Python 3.2.x than manual initialization. For light usage this probably isn't a big deal, but might mean certain usages aren't viable. NOTE: 'endswith' was quite a bit slower than the current implementation, so was not changed.
Viable replacement for my very aged wrt54gl? 
I set one up over the weekend too, really handy device to have. Has yours been stable? Just curious.
I have several of these. Add an USB audio stick and you can do lots of cool streaming stuff :)
Yes, unless you need the antennas (range of the 703n is limited because its only antenna is on the PCB). If you want more range/5GHz/more speed have a look at the other TP-Link hardware that's supported by OpenWRT. They're not much more expensive than the 703n: http://wiki.openwrt.org/toh/start#tp-link I have a WDR4300.
Wonderful. I definitely will take a look at the TP-Link products! :)
I think you will like the new version better possibly. It has an 'omit' list arg instead of the underscore. Just pushed to github.
&gt;but it's more work and less convenient IMHO. How so? The RP has more means of access, more customizability, and is harder to brick... Don't get me wrong, I love this Router, I just think that the RP is easier when it comes to doing cool stuff.
Is there a convenient way to control the audio source (e.g. a web GUI)?
Python doesn't run on any OSes where you only get 8.3 characters.
Eh. This is a really bad benchmark. It benchmarks a stack (wsgiref) that says in docs "a demo HTTP server that serves WSGI applications". demo, not production. There are quite a few better web stacks to test with varying performance on both PyPy and CPython (gunicorn, tornado, cyclone.io, twisted.web)
Cool solution for instancifying kwargs. Most SQL ORMs also have some sort of `__init__` magic for instance variables. These may also be useful for similar use cases: * https://github.com/enthought/traits * https://github.com/j2labs/schematics * https://github.com/Pylons/colander
Excellent point. I didn't really mentally consider the cost of wifi/psu/etc. as I had those things lying around, but this wifi device is indeed about half the cost after factoring all those things in.
I just have it listen on a multicast RTP stream. Pulseaudio can send and receive those.
I'd suggest "pipboy", but Bethesda would sue.
I've compiled my own firmware from the tip of the attitude_adjustment branch in OpenWRT SVN. It's been very stable for me. It seems that using up most/all RAM makes it less stable.
http://blog.jetbrains.com/pycharm/2013/02/dynamic-runtime-type-inference-in-pycharm-2-7/ This should help I guess...but haven't tried it so not sure how well it works or doesn't work.
Clarke's third law.
what
Yeah they included that in the latest release... It happily resolves (and stores) dynamic attributes. Wing IDE has had a similar feature for years (only during debugging though).
From one Python noob to another... ... to be technically correct (and that's the best kind of correct;)) Python is not compiled; instead [it is interpreted to bytecode and executed in a bytecode virtual machine](http://docs.python.org/2/glossary.html). That's why you can run Python code without a compilation step (the translation to bytecode used to be call 'automagic' I think). Then again, it's not important to know this right now, but a fun fact for other people to educate you about ... ... anyway, chances are that in your case the problem is either in your code - in which case you will see a Python stack-trace and that wil have a helpful error message somewhere - or in Tkinter executable (more info and links [here](http://wiki.python.org/moin/TkInter)). Tkinter is a compiled binary executable (i.e. it IS compiled!) and you might need to look in your OS's error log for an error code that you can then search for on the internet for help. Changing your compiler/version of Python and TKinter might help - but who knows ... try and find an error message first and that will be a better solution. I might have got some of this wrong, sorry if I have...
I can't find anything about running Python on it, except [a page saying Python does not run on it](http://www.designspark.com/blog/hacking-the-tp-link-tl-wr703n). What gives?
OK, here you go: http://pastebin.com/dxtE2RNZ 
Noob question here ... could not find an example Core Data file on your github site - but I'm guessing this is the source of the Flask server definition. Could you upload an example so I can understand more about your project? Thx
Well, I made a virtual machine who exits on its own VLAN, and has its own (open) SSID. If you connect from a computer you get the [Dial-up kid](http://www.aporcupine.com/dialup.swf), from a phone you get a random offensive GIF
It's "wheel" as in "wheel of cheese", i.e. packaging for a [Cheese Shop](http://stackoverflow.com/questions/5393986/why-is-pypi-called-the-cheese-shop).
You can use a memory stick as external storage to install to, so python would fit there.
Python is one of the packages available for it, and I have verified it works myself. Lots of Python packages available too, like Django, PIL, etc. (see [here](http://downloads.openwrt.org/attitude_adjustment/12.09-rc1/ar71xx/generic/packages/), these can be installed on the fly from the router BTW). 
There's also a stripped down mini version that barely fits without external storage. 
Yep, that's one feature. 
Wheel is also about pre-built pure Python packages. Without binary packaging you need the whole of distutils / setuptools / distribute to install. Once you have a wheel setup.py is gone and the package can be installed with much less code; you can even think about removing distribute from the deployment environment or using novel replacements for setup.py. Wheel can't do anything about the OS ABI problem, but the pip fork makes it easy to rebuild all the wheels required by your virtualenv with a single command "pip wheel -r requirements.txt"
Python distributions like ActiveState's ActivePython (with their pypm installer and their own binary format) run build servers with binary packages for much of PyPI. A similar service could provide wheels.
That's true, coming from Java/PHP/Bash experience the lack of type-loose string concatenation was probably the most confusing thing for me about starting Python. If you're curious about the opposite direction, check out Scala - it's built on top of Java, but does a lot of clever magic, like enabling the user to define custom [implicit conversions](http://tomjefferys.blogspot.com/2011/11/implicit-conversions-in-scala.html) that enable automatic type-casting at runtime.
Mine's been fine but haven't left it running long. 
The benchmark I'd really like to see is Pypy + Tornado vs. Node.js.
Actually, it looks like he's already done this: http://blog.kgriffs.com/2012/10/23/python-vs-node-vs-pypy.html
Thank you for the respone, it was of great help !!
Haven't tried it, but I got the impression that extroot worked fairly well?
apply is certainly outdated, but Python 2 is not.
Unless you are doing this purely as an exercise in Python, you should be using a spreadsheet. I love Python, but it's not the right tool for everything.
The project is on Github, why don't you go submit an Issue and see what he says? link: http://github.com/kennethreitz/python-guide/ Personally, I use neither pattern. It took a while, but I really don't think of strings as mutable objects anymore, which is where the need to append comes from. Instead, I tend to keep a `list` when I'm building a string to print, and call `''.join(&lt;listvar&gt;)` only when I'm ready to use it for something.
I've made things a bit like this before, should probably find a place to upload them. The idea was to make something a bit like the declarative django models + let you decide modify the data as it goes through. I should really seperate these out + upload them somewhere if people might find it useful.
While I'm familiar with `map()`, I tend to use list comprehension to the point that I can't readily think of a use case where I'd find `map()` more appropriate. List comprehensions about in Python. Once you understand them, they're very easy to read. Having both forms in a single project is more confusing that a single form - and `map()` is awkward in many cases.
Basically you can take something like FreeBSD (a clean OS), build and install python in it. setup the default shell account as python script with idle like console. Delete /bin and /sbin non necessary programs. Check libraries and delete unnecessary ones. Clean up pythons core libs of file operations and OS relations. Add plugin installation to the console script. Then whenever you login to this OS you will get python script of your choice running whatever you want and how you want. OR You may even scan the AST tree and block not needed nodes, so your user is not able to run underlying os programs (and you won't have to delete em) but you can keep them for maintenance.
That guy's tests are not realistic. I did not try node.js But wsgiref would not be on par with gevent never ever... Either his scripts are crazy or I don't know what has he done to make gevent run like wsgiref... Why I know? We've been doing ddos firewalling with gevent with rewriting of the headers etc. I'm talking about thousands of requests per second and 20K bots attacking with sophisticated algorithms... Gevent started to fail at around 2000 of requests, on 1 CPU core of E5450. It's not C but still a good result. SimpleHTTPServer did not pass even 100 requests per sec.
Maybe pipman if it easier to access the manual...
fuck, I hate hacking
Point taken. I wish the name contain "pip" and "windows", so that it ranks high in Google search with these terms. Maybe pip-windows ?
Hard to say, but it uses an integrated PCB antenna so not particularly great. It's possible to [solder on an external antenna](http://blagg.tadkom.net/2012/09/15/better-wr703n-antenna-mod/) though, and I believe it outputs up to 0.25 W.
The range is shit. I investigated using these as devices for a custom residential ISP deployment project, but they are not up to the task of providing the most basic coverage in a single room at fairly low speeds.
Did you know creating multiple accounts to spam your site will get you banned?
I have an idea that I've been far too lazy to implement, but this looks like it could make it pretty simple. Basically, what I want is: when my cell phone connects to my wireless network, an ardunino is activated which presses the buzzer which opens the door to my apartment building. I'm on the second floor, so from the main entrance my phone just barely connects. I figure have a script that watches for an ARP request from the MAC on my cell, and BAM, no more taking my keys out until I'm at the door to my apartment. Does this sound like something that would be relatively doable with this?
&gt; basic coverage in a single room at fairly low speeds. I think that's a bit of an exaggeration (not to say that the range is great).
Sounds pretty easy, at least the stuff on the router side (a Python or shell script could do it). I believe there are a few GPIO pins free on the router (not 100% sure), so you might be able to skip the Arduino and have it control the buzzer with minimal additional components.
It sound terribly insecure, to be honest. Why don't you just set up a small server and use some kind of cryptographically secure authentication before opening the door? Remember, MACs can be easily spoofed. The authentication upon WiFi connect could be done using Tasked and a shell script. (Assuming you use Android) The Arduino could handle the server part. (Only accessible from the WiFi network of course)
Two different people, blogging on the same blog. Different articles also.
So two separate spammers?
And I am not looking for an argument. [Take a look at the FAQ.](http://www.reddit.com/wiki/faq#wiki_what_constitutes_spam.3F) It has a checklist of sorts to help you out. From the linked FAQ: "If over 10% of your submissions are your own site/content, you're almost certainly a spammer."
Criminals usually aren't very smart, and I don't envision a problem unless people know beforehand about this.
I believe there are Android apps (dsploit and network spoofer. Both are not on market) which use ARP spoofing or something clever to acomplish a similar task, but it would, of course, be illegal to do this on someone else's network
&gt; They're not much more expensive than the 703n $120 (according to [amazon](http://www.amazon.com/Network-TL-WDR4300-Wireless-N-Gigabit-Router/dp/B008J4BAKI)). That is 480% more expensive than 703n. A viable replacement that works with openwrt would be a Linksys wrt160n (check the revision), which goes for $30-50 refurbished.
Well now I just feel terrible.
xpost r/programming
Are you sure you don't feel self righteous? :P
That lapse is something I find very annoying these days. People always focus on an rPi at $35. The reality is, for most people its closer to $55-$65 if on the cheap. Its easy to jack it up to $75-$90 if you are not a frugal shopper. 
winpip, wpip, wip, whip
Take a look at Matplotlib's [imshow](http://matplotlib.org/users/image_tutorial.html) command. tl;dr: You have an array of image data called image_data: import matplotlib.pyplot as plt plt.imshow(image_data) Depending on your use case, you may want to turn off interpolation, or use a different color map (the default is Spectral -- a heatmap). You can do that with the cmap and interpolation arguments: import matplotlib.pyplot as plt from matplotlib import cm plt.imshow(image_data, interpolation="nearest", cmap=cm.Greys) Check [here](http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps) for a list of the available colormaps. Depending on your environment, you may need to type plt.show() after the imshow commands to get something to pop up.
I've now tested it, and it needs some tweaking. Expect a new release in a couple of weeks (or days ?). It will not use pyvenv, but virtualenv (which works on 3.3 too, I presume).
Even in a low density situation, like testing in our office, range dropped off by ~20 ft, the results really were abysmal, but what can you expect from something with a PCB antenna? Cool little devices in the right situation
So posting on reddit then?
The Cisco E3000 series regularly go for $50-60 on sale. They probably have the best usable wifi range of any COTS consumer router I've tried. Rock solid running DDWRT as well.
Yes. 
Guys, this is taken out of the 600x course at www.edx.org To the OP, these questions should be posted on the website forum and not here on reddit. Please let's try to keep the Honor Code alive.
what a bad and dangerous idea to present argument binding that way (slides 12, 13). Audience should understand why that happens! The `a` argument gets bound to the list object at the time the function is declared. The slide makes it seem as it's an obscure language limitation! Also, the "solution" should not evaluate the boolean value of a, but rather check if a is None. Next slide: what's with "argument preloading". That is called currying [1] and there's nothing being "preloaded". Sorry for the tone, but I think I'm stopping here :\ [1] http://en.wikipedia.org/wiki/Currying
Here's a solution which requires the least amount of time learning matplotlib. You shouldn't use it though. Matplotlib is a) awesome and b) idiot-friendly. Set `data`, `white` and `black` as appropriate for your needs. Saves the 2x2 array data to `foo.pgm` in a format that GIMP, at least, can read. data = [[45, 6], [10, 12]] white = 50 black = 0 f = open('out.pgm', 'w') f.write('P2\n2 2\n') for row in data: f.write(' '.join(str((x-black) / float(white-black)) for x in row)) f.write('\n') 
In future /r/learnpython is a better subreddit. /r/python is mostly for professionals and python enthusiasts that will largly downvote your questions into oblivion. Meanwhile the people on /r/learnpython are much more receptive and willing to spend a lot more time helping you.
Here is a solution that requires no time learning MatPlotLib. #!/usr/bin/env python from PIL import Image d = [ [i for i in xrange(1000)] for j in xrange(1000)] img = Image.new("RGBA",(1000,1000)) pixels = img.load() for i in xrange(1000): for j in xrange(1000): pixels[i,j] = d[i][j] img.show() Downvotes? Go get somebody else to help do your homework.
It might be helpful to rephrase that as constructive criticism :-) 
It was fine until someone started to post naked girls ಠ_ಠ Edit: Now Emma Watson
Hoping to reduce the NSFW issue by visibly associating IP addresses with the images. Edit: That seems to have worked as I haven't seen a single NSFW submission since I added the IP address association. Of course, that also means the number of submissions drastically decreased.
Thanks!
matplotlib's `hexbin` may help with creating a 2D histogram visualization: http://matplotlib.org/examples/pylab_examples/hexbin_demo.html
You didn't format your code accordingly for reddit, so it looks like some of the code got interpreted as text formatting and I can't really tell what the original source was supposed to be. Put at least one newline before a block of code and indent the code 4 spaces to get nicely formatted code blocks: Like this a = b + c
**keep getting error for value at y = a..**
This person is correct, the division operator is a forward slash (`/`), not a backslash
hope you're getting paid.. a lot. sounds like a shit gig :)
$72k? thats pretty average for Utah. But me being the only developer gives me a lot of freedom so I look forward to it actually.
I'm a rather new python programmer myself, but I think it looks good. I think base classes should inherint from `object`, but a cursory glance over the rest didn't reveal anything I'd laugh at.
Neat! Server-Sent Events are awesome. Most of what people want to do with websockets could be done much more simply with Server-Sent Events. If only IE supported them :( For those who might not know, this is also known as "EventSource", after the name of the javascript API that handles the client side. The HTML5Rocks site has a [really good tutorial on EventSource](http://www.html5rocks.com/en/tutorials/eventsource/basics/). There is an extremely simple WSGI demo app at https://bitbucket.org/btubbs/ssebin/, and running on Heroku at http://ssebin.btubbs.com/. Click "View source" on that last link to see how little work it takes to use these on the client side.
I don't mean to start a flame war, but why migrate away from postgres? Getting away from PHP I can fully understand, but postgres is pretty damn functional.
migrate AWAY from mySQL TO postgreSQL is my plan
Is the employer happy that you will be spending all this time reimplementing existing functionality in a different language? Don't get me wrong, I hate PHP but it sounds like a massive waste of time to redevelop the whole thing...
From the sounds of it. It sounds like the clock is ticking. The code is held together with duct tape and bailing wire. There is NO CMS. No standardized deployment method and a laundry list of broken functionality. I think in the long run it will save everyone time and money not to mention they will have a newer and better product to offer their customers. 
Classes implicitly inherit from `object` in Python 3
All classes are new-style implicitly in Python 3.
thanks .. will do..
thanks.. will give it a go
thanks 
I was going to say the same thing, even as a Python 'evangelist'. OP: Are you the ONLY developer working on the project? How much infrastructure is already in place? How much investment is there in PHP at the company? Personally, I wouldn't rewrite anything that isn't especially broken. I wouldn't go looking for work at a new job that wouldn't immediately have positive outcomes for the company. It's just not worth it. Start developing the CMS (and any new code) in python (maybe look at http://pinaxproject.com/, definitely django depending the requirements. You can use python technologies to start scripting the deployments (fabric). Start using postgres. But you don't have to switch everything at once. This is especially true if you're not hosting the stack. If you're going to have to support the old PHP stack anyway, why create more work for yourself? 
The most I can see this accomplishing is having a static defaut seed which is randomly generated at script execution of which all instances inherit. This can be acheived by setting a class variable within the body and has the benefits of being clean code while maintaining a segregated environment. 
Is it BI Worldwide?
No. It is not. 
Only thing I'd say is your run function could be broken up a bit - it's got quite the number of indents. I stick to 80 characters per line to prevent myself from having too branches in one function. The more you have, the more complicated the code is, and the harder it is to read (though in this case, it's not terribly complicated). There are obviously many exceptions to this rule, but it's just something to try and follow. Take a look at web.py code. Very rarely does it have lots of branching in one function. 
Just thought I'd check. It's a local company here (MN) that is in the same business, and recruiters will call about openings there fairly often. I've heard it's pretty much a revolving door.
This might come in waves, so I don't end up duplicating reviews of sections by other commenters. if __name__ == "__main__": backup_location = backup_location(sys.platform) parser.add_argument("-i", "--input_pattern", type=str, default=backup_location, Why not inline this as: parser.add_argument("-i", "--input_pattern", type=str, default=backup_location(), And remove the platform argument to backup_location() entirely? Since you use it exactly once, there's no need to pass it sys.platform. Unless you're going for testability. But for a short script, just inline it. Also, in that example, you completely blow away the definition of the function backup_location, so you'd get an exception if you tried to call it again.
&gt; ... you would Google for “Python list length site:docs.python.org”...and the first result is… a page with several chapters on standard types? actually the first result I got was [Built-in Functions](http://docs.python.org/2/library/functions.html) &gt;But one issue in particular bothers me to no end: the assumption that source code is a reasonable replacement for documentation. The documentation on module X is bad? Just read the source. Want to know how the Python interpreter deals with input Y? Read the source. And so on, and so on. I think we say this because Python code is easier to read compared to PHP. &gt; Isn’t the purpose of tools to make your job easier, and less time-consuming ? So PHP does this^tongue^in^cheek &gt; Let’s do an experiment. Think of a random function in a random standard library module in Python, visit its documentation entry, and try to find all the error conditions (return values, exceptions, when they happen, …) without scrolling the page. Didn’t work? That’s not very surprising. Well the first function that came into my mind was [random.random](http://docs.python.org/2/library/random.html#random.random).
I think migrating php to python should be at the bottom of the priority list. Firstly, are there tests? If not write some. Is there a CI/CD server? If not setup one. Then, I would work from the simplest to the hardest. Get some quick wins so you feel good about yourself and then focus on the other aspects of the system. Also, is it worth porting 10 years of php? Might as well propose a complete rewrite. Be sure to highlight the business benefits. If doing it isn't going to increase revenue then there's absolutely no reason to do it (from a management perspective).
 def query(self, sql, params=None): try: c = self._db.cursor() c.execute(sql, params or []) res = c.fetchall() self._db.commit() except: if self._db: self._db.rollback() raise c.close() return res This would be much better written as a Python context manager (http://docs.python.org/3/reference/datamodel.html#with-statement-context-managers): class TransactionQuery(): def __init__(self, db, sql, params=None): self.db = db self.sql = sql if params is not None: self.params = params else: self.params = [] def __enter__(self): c = self.db.cursor() try: c.execute(self.sql, self.params) res = c.fetchall() self.db.commit() finally: # Always close the cursor. c.close() return res def __exit__(self, exc_type, exc_val, tb): if exc_type and self.db: self.db.rollback() class DB(): def query(self, sql, params=None): return TransactionQuery(self._db, sql, params) Then you can do this: with DB.query("SELECT ...", [...]) as result_set: # use result_set The problem with doing: try: except: raise Is that the except: block clobbers your traceback up until that point, at least in Python 2.x. You will only see what happened after the "raise", not what actually caused the original exception. Fun fact: automatic transaction rollback is already implemented in the sqlite module as a context manager as of Python 2.6: http://docs.python.org/2/library/sqlite3.html#using-the-connection-as-a-context-manager
Avoid relying on global state in a script like this. It's very easy to accidentally run over something you didn't remember was global, or to have trouble in multithreaded code like this. Generally, reserve global variables for constant data. Example (bad): def run(): args.x if __name__ == "__main__": ... args = parser.... args.x = y run() Example (better): def get_message_list(args): ... args.input_pattern ... def get_parser(): parser = ArgumentParser(...) ... return parser def run(): # Parser and args remain local to main() parser = get_parser() args = parser.parse_args() message_list = get_message_list(args) ... if __name__ == "__main__": run()
I think at this point extensibility is a concern. They know the code is old and brittle. So no new releases have been made in the last 3 years they said. Its just been fixing client issues on a case by case scenario. I think this is cause their deployment method is so bruteforced. I purposed more or less a complete rewrite with myself and some new developers. It won't be over night but in the end they can actually start extending their product rather than reselling the same one with more duct tape and fishing line wrapped around it. 
You don't seem to have any error handling. * What happens when the SQLite database you are reading from doesn't exist? * What happens if the output file already exists and can't be written to? * What happens if you don't have permissions to truncate/create the output file? * What if the SQLite database is corrupt? * What if the database you're reading is a SQLite database, but the table format is incorrect? (e.g., not an iPhone text message database) 
I usually do this as: class Whatever(object): # define vars in the body some_var = 23 other_var = "foobly" def __init__(self, **kw): cls = self.__class__ for k, v in kw.items(): if hasattr(cls, k): setattr(self, k, v) else: raise TypeError("Unexpected keyword argument", k) This is about as DRY as you can get, and it still allows for additional initialization or other stuff. Put it in a base class and call it with ``super()``, or mash'em up hash'em up put 'em in a stew. ;-) 
The best thing you can learn from the old code is common patterns that were replicated across the old installations. Now when you redesign with the new codebase, implement those patterns. But this time use configurable parameters so you can customize things by just changing a few text file entries instead of modifying the code. And automate the hell out of the deployment and testing. Then when you show it around have a non-programmer deploy a whole new site ina few minutes by just tweaking a few settings. Jaws will drop and you will be a hero. And everyone will agree the redo was worth the effort.
Complete rewrite is the way to go, but I would think less of it as a 'porting project' and more as a 'new version'. Document it exactly as if you were starting from scratch, planning out all the features and requirements and such. Now look over the php and note all the shortcomings and add that to your docs as things to avoid and how. Don't just try to mirror exactly what it did, but make it do more and do it better. Also, I'm going to assume there was no trouble ticket system used for the current version, but if there was i would go through it and look for major pitfalls that you'll have to avoid. Chances are that code wasnt so awful when it started it just became awful when they kept hacking on things that it wasnt designed to do, so knowing about them now gives you a huge advantage. 
Oh! My mistake. So sorry.
Do you know of any good ticketing system in python? one I can get going right away? I was probably just going to use bugzilla to keep my own productivity up. But a user ticketing system would be nice. This is all great advice BTW. I'm getting more excited for this project. What once looked like a nightmare is seeming like a fun oppertunity to be as creative as I like. 
No they install a machine with LAMP at every site from what I understand. What would be a good CI/CD server to get started with? 
not too bad for utah! freedom if they give it to you, responsibility if they expect you to deliver features
True but it looks as if this was originally written for Python 2.x, and I was mainly trying to clear up OPs misconception considering the amount of people who are still adopting/beginning with 2.x.
I think at this point they just want some of the features fully functioning. Because a lot of things are broke but the previous developer has "work arounds" for most of them.
Since the repo's README said it was Python 3.x compliant I assumed the OP was using Python 3.
Dude. Wanna know about lists? `pydoc list`. It's that easy. Oh, don't have easy access to a command line? Fire up the interpreter and use `help(list)` and you'll get the same. I don't get it. Why google furiously when it's already on your computer? Make use of the docstrings, that's why they exist. &gt; I will no doubt piss off quite a few people with this statement, but the community around Python is one of the most hostile and unhelpful communities around any programming-related topic that I have ever seen... You're going to piss me off because I help with one or two of these communities, and no, they aren't generally hostile until someone chimes in like they know their ass from a hole in the ground with some huge opinion about how the docs suck. In what community doesn't this happen? The communities that I've experienced are wonderful and helpful places. Newbies ask questions in the learning version of this sub and they receive helpful direction and additional code review and suggestions, it doesn't get better than that. PresTronPaul mentions Stack Overflow, which is also a great place and answers many of my questions before I know that I have them. &gt; ...visit its documentation entry, and try to find all the error conditions (return values, exceptions, when they happen, without scrolling the page... Let's play the game where we place unnecessary restraints on ourselves! Or you can search. From inside `less` with the aforementioned `pydoc`, I just use `/ exception` and I'm grand. I don't get the issue here. I agree that things could be formatted to make it easier, but that hardly makes the documentation bad. The information exists and is easily accessable. &gt; THE DOCUMENTATION IS UNCLEAR Examples please. &gt; If you are not only reading this article, but you are sufficiently pissed off by it to think something like this ... does that not mean that you are already experienced enough not to need solid documentation? Nope, I'm experienced, but I use documentation all of the time! And it does wonderfully by me. This sounds entirely like someone had a little bit of difficulty moving from the formatting of one language's docs to another, and had another bad experience asking for help in a community. I'm sorry that you had a shitty time, but next time, try it without the attitude and the stupid memes. I love helping people learn Python. I tutor one for free and have taught the language to several people in the past who continue to communicate with me and ask for help over the email. I try my best to help here and in /r/learnpython. I'd do the same in the IRC channel, but I can't be asked to register a name. What you are saying completely flies in the face of what I've seen in the communities where I help. Could the documentation be improved? Probably. I'm happy to admit that. But I'm just not willing to agree that it's bad. There is a **single** page of documentation that I've come across that I'm not pleased with, and it's [this one](http://docs.python.org/3/reference/datamodel.html), mostly because I'm looking for the various dunder special methods and I have to search for them. It takes whole seconds sometimes. For what it's worth, this is the first time I've posted angrily to either of the python subs. I probably should have waited a tick, but you really crawled under my skin with the way you wrote your piece. Ask for help nicely and you'll see the usual side of me.
Yes this, this, this.... Sorry: self? :)
Thanks for the advice I will start researching these. I don't think anything is expected from me right away. I have the next 30 days to make a development outline/plan/course of action. 
More comments aren't always better, especially with a language as readable as Python. It's an awful standard to put forward, as so many beginner-intermediate programmer's will learn to use comments as a crutch. Well defined, properly labeled code is often times self-explanatory, and if you have to explain every function or conditional then you're probably writing overly-complex or just plain bad code.
There is always a middle ground. Don't write comments that should be obvious, don't not write comments that would be helpful to understanding the context of complex code.
Have you ever tried Stack Overflow for Python questions? Every time I've had an issue I've searched or asked there and it's been rather helpful. I've never noticed community issues when I was learning Python. Do you bring up PHP a lot? There's a lot of stigma around PHP in nearly every language community (we make fun of it at work and we're a Java/Ruby/Clojure/Scala/R/.Net shop and yes we use all of them).
The only part of this I agree with is that `#python` on Freenode can often times be quite hostile with their responses. I've also seen them say "join `#twisted`" every single time anyone asks any question remotely related to sockets or network programming.
One thing that's frustrating about the documentation for me is the site's search engine. It brings up a huge list of related stuff, but I don't think it ranks them helpfully. 
&gt; Ever tried to look up the exact point where something happened in a novel? It doesn’t work. Well, yes, I have, and yes, it works. Extremely well. Python's documentation gives *context*, which is completely lacking in many documentation systems. As an example, the MSDN documentation (seems to) split every function and class up, providing very little context for how it interacts. For someone unused to Windows programming, it means I have to have four or five tabs open to work out what parameters go where, and how to use the classes, and how to construct things. Python's standard library, on the other hand, gives a fairly complete overview of how classes within a module interact on a single page.
Uh... I have a feeling you might be right about some things but how do I put this.... perhaps your general candor is a little sour. I won't hazard as to why.
I have never met a friendly IRC community. Maybe I am not looking in the right places, but something about IRC seems to just encourage a chilly reception for newbies. Especially if you're also new to IRC as well as the subject in question. I've pretty much given up on it.
Honestly, by IRC standards #python on Freenode is pretty damn friendly.
If you decide to port, be prepared that during some time period you will be supporting both versions. If you really need to port, create the system from scratch, give it to new clients, and migrate old clients one at a time. Partial migration is always a good way if it possible.
Thats really good advice thank you!
Sounds like United Health Care and Overstock here in Utah. I don't know many developers that haven't worked for one or the other here lol.
It is very interesting what author will post if he tries to learn something more complex? Read the source is most wise advice you can get. PHP have worst community ever because most people who calls themselves "PHP developers" actually only able to copy-paste code from other place and even don't care what code actually do. "Use twisted" means "read source of twisted and learn how it works" because it is good way to understand how any servers actually works. I will not protect python docs, often PyMOTW have better practical examples, but it is not broken. It is not working the PHP-way, you cann't mindlessly copy-paste. You need to read and understand. Considering that python have wonderful introspection I totally disagree with article. If you don't like to read source code then go away and do something else you like more. 
Whats wrong with twisted?
That's true. It's thousands of times nicer than `#c` for sure.
If you havent seen the hostility of the python community, try come with a little liberal tought of the lang, maybe hang out in #python more.
I'm presenting a poster at PyCon titled "Is Python a Newbie Friendly Language?" It is, compared to most languages. But there are issues and docs is definitely one of them. There are so many other issues though. I'm an instructor and I see the things that are roadblocks for people new to the language (because I see newbies bumping up against them) that experienced Pythonistas can easily explain away/around. Encouragingly I think we're starting to see some awareness in the Python community at large that some of the "user experience" around Python is less than optimal. Kenneth Reitz "Python for Humans" might be one data point in this direction. My only point of rabid disagreement would be that I think the Python community rocks! And I'm hoping we rock hard enough to hear criticism (even from other "P" language refugees) and figure out what needs to be better.
Don't worry about saying it, I know that I was abraisive. It's entirely due to the way that the blog was written. Several times the author acknowledges that he/she may make readers angry, yet they post it anyway. Why would anyone wishing to create positive change seek to make their target audience angry? To whine. I don't respond positively to that. In the interest of not playing into the accusation of hostility among the community, I ask anyone concerned to review my post history, particularly in both /r/python and /r/learnpython to ensure that I have, indeed, been helpful and nice in the past. Edit: No, there's more to it than that. We've all been new, it's a requisite. We've all struggled at some point in time to learn how to do something, I know that I have. What I have not done is created a large post about how that which I'm attempting to learn is wrong, until I understand the environment. Perhaps there is something that I don't understand that will help me to unravel my issues, or to understand why something frustrating exists. I instead ask for help and seek to understand. Writing incendiarcy blog posts about something that you don't fully understand is not the way to go about this.
"pydoc list", sure....because a bunch of methods will help a newbie? Thats what we are talking about after all. The docstrings wont even help them.
All right, I'm delaying working anyway! Overall, the documentation is fairly cryptic - I'm not sure sure what it does... In `backup_location` you are being passed a platform - but you're only ever called once and it's always sys.platform. Might as well just inline that. Are you sure that "osx" or "mac" can ever occur? If not, kill them. It doesn't help, and it's more cognitive load. `dict_factory`: Please don't use "idx" for an index variable. Everyone else uses i, you should too! Remember, code is written once, read ten times... You can rewrite it as a one-liner using a dictionary comprehension: return dict((col[0], row[i]) for i, col in enumerate(cursor.description)) In Python 2.7 and up, you can even write: return {col[0]: row[i] for i, col in enumerate(cursor.description)} However, there's a bigger question - what's happening here? Why are you doing this? I see it being used a few lines later... but why? I agree with another commenter that DB doesn't need to be an object. db can be the object and query can be a function taking a db. If you are making it a class, try to avoid actually opening the database in the constructor. It's a bad idea to have too much work in a constructor, particularly things that might block or fail. There's a deficiency in `query` - if there's an exception, you don't close the cursor. It will eventually close when the garbage collector gets it, but don't rely on that - always put your closers in a "finally" clause so they're always called. `extract_messages` - I wouldn't recommend opening the database as part of this. Do the database opening at the top then pass that open database to all the work routines. There is too much random logic here and too many random constants... `'is_madrid', [3, 35]`. I frankly have no idea what you're doing at all, and that's bad - I'm usually pretty good at figuring it out. Certainly, telling us what a database element looked like at the top of the file would really help! You use an anti-pattern of checking if an item is in a dictionary using `in` and then retrieving that item - incurring the cost of hitting the dictionary twice. You definitely need to use the [get method of dict](http://docs.python.org/2/library/stdtypes.html#mapping-types-dict) more consistently. if 'madrid_handle' in row: address = row.get('address') or row['madrid_handle'] else: address = row.get('address') or row['account'] is logically equivalent to: address = row.get('address') or row.get('madrid_handle') or row.get('account') Quick question - are you perfectly sure that all of the fields that you dereference in this method without using get are _always_ there? Even if you get shoddy data? Error handling is a huge issue and I don't see any evidence that this code wouldn't fail and die if handled somewhat deviant data. `compare_files`: message_guid_list = [] file_guid_list = [] # No need to declare these before you use them! compared_list = [] for item in message_list: message_guid_list.append(item['guid']) could just be: message_guid_list = [m['guid'] for m in message_list] Even more, assuming that it works if you open your JSON files in universal line ending mode (which I'll bet it will), you can simplify the following: file_guid_list = [] if args.output_data == "csv": with open(file_name, newline='') as f: reader = csv.DictReader(f) for item in reader: file_guid_list.append(item['guid']) elif args.output_data == "json": with open(file_name, "r") as f: reader = json.load(f) for item in reader: file_guid_list.append(item['guid']) becomes: with open(file_name, newline='') as f: if args.output_data == "csv": reader = csv.DictReader(f) elif args.output_data == "json": reader = json.load(f) else: # error handling... file_guid_list = [i['guid'] for i in reader] Remember: DRY - [don't repeat yourself](http://en.wikipedia.org/wiki/Don't_repeat_yourself). Overall, I've read through the whole thing and I really have no idea what it's doing at the high level. A lot of it is the choice of names - `compare_files` tells me nothing about what sorts of files are being compared or even what "comparing" files means (the result appears to be some sort of list of guids, I'd be expecting a comparison to return booleans!) You can see some of my code here: https://github.com/rec/echomesh/tree/master/code/python/echomesh
We are talking about new people. beginners. __le__ dont say them a shit. __imul__, __gt__, __rmul__. What does that tell a beginner? Hint: Nothing. They have to look what they does. And where do you do that? pydoc __le__? nope. Dosnt help. So back to square one. EDIT: _*2 bolds everything...cba to fix.
I think the point of the article is that it doesn't do that well. In my experience, the python official documentation is better for a beginner because its laid out like someone new learning everything in the language rather than organized for a quick search for some behavior. The problem might be the lack of a javadoc surrogate where they host a remote copy that you could generate from the cpython source tree. I don't think that kind of thing would be necessarily wieldy for the language, given its intended simplicity, but what a lot of people want is a "google for class / function / concept X, get a page about X on the python site, that details its use, methods, implementations, etc).
Why leave mysql? It is a reliable, fast database.
I prefer PostgreSQL?
Good comments, except: &gt; Is that the except: block clobbers your traceback up until that point, at least in Python 2.x. This is not correct, and I just tried it to make sure. `raise` with no arguments _does_ preserve the stack trace. def foo(): raise Exception def bar(): try: foo() except: raise def bang(): try: foo() except Exception as e: raise e If you call bar, then you get the complete stack trace: File "/development/test/ExceptionTest.py", line 17, in &lt;module&gt; bar() File "/development/test/ExceptionTest.py", line 7, in bar foo() File "/development/test/ExceptionTest.py", line 3, in foo raise Exception Exception If you call bang, you only get the partial stack trace, as you'd expect: File "/development/test/ExceptionTest.py", line 17, in &lt;module&gt; bang() File "/development/test/ExceptionTest.py", line 15, in bang raise e Exception 
Sorry, I deleted my other post because I thought that the English was terrible and didn't express that you are correct. Still, I argue that it does tell them shit. A whole lot of shit. None of it addresses the issue of determining string length specifically, but in most cases, it provides a wealth of information. Further, I feel that being exposed to such a list (ignoring the dunder methods that you mentioned) is useful for anyone. How are you to know what behaviors an object has without it? It's an excellent way of stumbling upon a solution that you never new existed. Still, as I mentioned in [my replacement post](http://www.reddit.com/r/Python/comments/18ssb6/the_python_documentation_is_bad_and_you_should/c8hpx5d), you are correct. While the solution is listed in the help, it is not done so in a way that is accessable for a new user (or really anyone who isn't already aware of the solution). My apologies for deleting the previous post instead of just editing it.
pydoc is indeed a feature i didnt know we had (used dir() for the most part). But we are also talking about people maybe confused about the whole concept of classes and methods. I am afraid methods, when you actually need the lenght of a list, is just a leap too big for most people. EDIT: Also gotta say the tone of last post was kinda harsh, sorry for that.
I know when I'm wrong, no worries. We do lack examples, but only in places. You cannot imagine how pleased that I was to see example implementations in places like the `itertools` library. They both helped me to understand the functions and to reimplement them in Java, when I couldn't find a satisfactory combinatorics library.
I'm not trying to backpedal and suggest that you're wrong this time, but I would argue that if a user is having difficulties with concepts like methods and classes, they need to be looking in places other than a reference manual. Reference manuals are just the wrong place to learn about core programming ideas.
I believe thats the problem joepie has with the python documentation ^^
That's like expecting... no, I won't get into it. I've expressed that I disapprove of joepie's post and I'll let it stand. Again, thanks for the constructive criticism.
Well, i wouldn't exactly call the PHP docs good. They usually tend to include unmature or unreleased features in the documentation, which is annoying at least. Also, a lot of examples are very outdated and, in comparision to pythons docs, are teaching some very old very bad habits.
The problem with the open source community is that you get to have multiple choices and still not one of them doing exactly what you want to do. An important component of the talk is literate programming and there are already systems that allow you to do that (emacs/org-mode/babel, tex/tangle/weave etc) and now you have one more option. Not to mention a proliferation of ["scientific workflow systems"](https://en.wikipedia.org/wiki/Scientific_workflow_system) coming from a completely different angle (graphical interfaces etc). A few years ago (early 2010 to be exact), I started using python, numpy, scipy, on ubuntu, as a complete replacement for MATLAB and as a new user I discovered that the eigenvalue solver was broken. It did not produce the reference results that I had from MATLAB. I stopped using it. A year later I installed a different python and numpy version, on a later version of ubuntu and on a different machine, and ran the exact same code out of curiosity, and it produced correct results. That experience is still in my head everytime I decide to give it a second/third shot. Anyway, that was just a rant!
New users a resource. They give you a fresh-eyed view of your environment. Let me grant that his tone was abrasive. You can either look past that and learn from his newbie-ness or you can get offended and waste that resource. Pydoc is a poor solution for a newbie, because it is very idiosyncratic. How do you learn PHO? With Google. How do you learn the way to the supermarket? With Google. How do you look up the quadratic formula? With Google. How do you read Python documentation? With pydoc. Pydoc also lacks hyperlinks and navigation. Pydoc is a great answer to a DIFFERENT question: "I have an object in the repl and I want to know what I can do with it." The poster is quite right that Python's manuals were written as books 25 years ago and that decision has just never been re-evaluated in light of changing technology and changing habits. While it is great that there are pages that give context, it is unfortunate that every method does not have its own page with a comment section below it.
This post summed up the problem with the Python community nicely IMO: http://bitboxer.de/2012/10/03/ruby-vs-python/
`if platform in {'win32'}` is the most efficient on versions of Python with the `set` literal. In cpython they special case it to use a very efficient lookup in a `frozenset`.
We've recently done this, currently some clients on new and some on old. The old system was Perl code some of which dated back to 2000. Over the 10+ years it has been running, it has accumulated an awful lot of no-longer-used cruft and had generally become unmanagable. Some of it still had "print" statements to generate pages:( The new system is Python on a custom framework, and in our case, the rewrite absolutely been worth it. The new stuff is much easier to understand (and not just because its more recent in our memory) and easier to modify. So much so that there is noticeably less maintenance work now (which is a bit of a shame as I'm paid by the hour!). The strategy we used was to reimplement the in-house back-end administration code first, so we could get a good feeling for the new system without exposing end-users to it. Then we worked on the front-end code, rolling it out to smaller clients first, cynically because if they had problems that was less of an issue, but mainly because they used less functionality. We rolled it out to the larger clients as and when we had re-implemented enough. The largest client gets at it shortly ..... Some people say re-implementing large code bases is a waste of time. I'd say it depends on how large, how much is no longer needed, and how awful the old code base is. Everyone's mileage will vary:)
This is me, did a search for python list length on Google. &gt;2. Built-in Functions — Python v2.7.3 documentation &gt;docs.python.org › The Python Standard Library &gt;New in version 2.2. len(s)¶. Return the length (the number of items) of an object. The argument may be a sequence (string, tuple or list) or a mapping (dictionary). The Google search result itself has the answer, what was wrong here ? Edit: I did another search with an igconito windows, and got Builtin Type as first result. So, let's navigate to [list type](http://docs.python.org/2/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange) Aand, there're over 10 operation with sequence type, with clear result and Notes, with len(s) as one of those. I don't understand what's the problem is, but that's how you use the docs: you understand the things you are searching for, and read for it.
No, I learned using a book (or a comprehensive book-like source). I find that blog posts about programming are poor substitutes for a comprehensive look at a topic. If you want *part* of the story, sure, read a blogpost about `super`, by all means (just an example). But if you wish to learn about inheritance in Python, you'd better be willing to attack the subject in a more comprehensive manner. I don't think that a reference manual is there to teach you proper means of inheritance, or that a better solution is often composition. I don't mind that pydoc lacks hyperlinks and navigation, but I'll agree that sometimes people look for different things. I'll grant you that it isn't always the best solution. I still can't help but think that a page that provides no context (only a single function/method is addressed) is a better solution. I appreciate the ability to stumble upon functions/methods that I did not know existed, and when a programmer focuses on a topic that he/she doesn't fully understand with a singular solution in mind, that programmer misses out on the myriad of (often better) solutions available. I feel that people need to recognize the resource for what it is, a reference, and to not treat it as a place that teaches them the entirety of programming. There is a tutorial and a collection of wonderful (and often free) books focusing on addressing that concern. Edit: My English is terrible tonight. Also: Comprehensive, because I didn't say it often enough.
Learning to code is all about logic. The language used is irrelevant mostly. The only reason why python is recommended is because of the simple syntax.
There is no need for an OrderedDict at all. DictWriter is perfectly happy with a list or tuple for the ordered field names.
If for some reason you do want to create an OrderedDict by sorting the items of a dict, there is no need for passing key= argument to sorted(). Comparing 2-tuples will be by the first entry in the tuple. The second entry will only get compared if the first is equal, and that is guaranteed never to happen on dict items - they have unique keys.
using a program called 'dash' to look up modules and classes in python makes the documentation a bit better, but yeah, i dont necessarily like how its not organized in a way like java's / as3's , etc
I've never been treated worse in an IRC channel than in #slackware. They're basically a bunch of snob retards, some of them are just there to humiliate newbs and have a laugh at their expense. Horrible community.
Python doc site is pretty well organized. Let's say you are new and want to know how to find the length of a list. Open the tutorial the site offers you first and you'll learn enough to start:-) 
PHP's documentation is like that cartoon you loved as a little kid. At the time, you thought it was the greatest thing in the world, but when you go back and look at it with adult eyes, you ask yourself, "WTF was I thinking?" I remember not liking the Python help system when I first was learning Python, but honestly once you know the basics of the language `help(whatever)` will solve 90% of your problems. The hard part is getting all the basics down first.
I disagree. Maybe the site's documentation is different than php.net and he's used to that, but that doesn't make it shit. Also, the community is bigger than just docs.python.org... who limits himself to "some_function site:docs.python.org" when looking for help?? The community is pretty big, there's a lot of people helping at SO, #python isn't anywhere near as bad as this guy makes it sound and since we're comparing python to php... let's also compare python's most popular framework to php's most popular framework when it comes to documentation and community: Django vs Zend.... Django is arguably one of the best documented frameworks in any programming language... but still not anywhere near as popular as Zend because the suits love that JAVA looking garbage. But if you compare the docs it's a Gold vs Shit race. /rant
That's fine.... I was just concerned that you seem a little close to the issue and that might cloud your feelings somewhat. The ins and outs of that are probably a little complex but where the OP may have come from a place of callousness or even carelessness, it seems you are coming from a place of... shall we say anger or at least reactionary disharmony. There's a subtle but disturbingly tangible difference. In the former people's views tend to evolve to improvement whilst in the latter case the tendency in communities may broods^2 .
Ah.. ninja edit. If your comment had read like this I initially I wouldn't have said anything.
I'll tell you a story - last year I moved into a position where I could, near as damnit, dictate which tools and which languages were used. Where I work it's not directly a programming shop but we service another part of the business with tools and applications etc. When I first moved into this position there were a myriad of half-complete, downright broken and ass backwards programs and websites written in a mix of VBA and PHP. I deleted them all. I'm talking `rm -rf`'d those bastards to the depths of digital entropy. Fast forward *a year* later and the higher ups and co-workers are only *now* starting to see the benefit of what I did then. It was a huge struggle to not only get over the political and personal issues of doing something like that but to convince non-technical people that a re-write is not only financially viable but *required* to move a business forward is an extremely hard task. If you want to do something like that, recruit the right people in your team to back you up and make sure you make a solid case for a re-write.
#Clojure is actually quite a nice and relaxed place. Yet to see anyone even remotely act hostile. I also have never seen IRC as a bad place, i rather think its an bad excuse too act in the same way.
YAGNI dictates that yes, the DB interaction be as simple as it is required to be. But database interaction is one of those things that always comes back to bite you in the arse. It's just better from the get-go to have it in it's own class with it's own interface, clearly documented. Moving to a different, or even wholly alien back-end is very simple when your DB is a class. Functions could do it, but then it becomes annoying when you want to have a database object or something.
2.6+ I believe.
I saw your other post addressing my edits (yea, I'm too often guilty of that), but I'd still like to address this, just to explain, if nothing else. The blog post was incendiary, and the poster knew it. If they hadn't, they wouldn't have said, "this may make some angry," in so many ways in so many places. This shouldn't be necessary in argumentative essays. It's just silly to be abrasive to your target audience when you're attempting to affect change as you'll only incite people (points finger at own chest) and accomplish nothing. Given that the blog post was made this way, I feel that it was not posted in hopes of affecting any change, but as a way of venting frustration. I can understand that, but if that's the case, there's no need to hide it behind a veil of attempted constructive criticism. Hell, the title of the blog says it all. An insult and a meme rolled into one. When was the last time you ran into a worthwhile post seeking positive change that was so labeled? Even Djikstra managed better with his pointed criticisms, and he was a well known asshole. As I feel that the blog post was merely angry venting, I felt no need to be terribly respectful in addressing the often vague and misguided concerns. Even if some of the points were accurate, one is bound to strike the target if one throws enough darts.
&gt; PHP's documentation is like that cartoon you loved as a little kid. At the time, you thought it was the greatest thing in the world, but when you go back and look at it with adult eyes, you ask yourself, "WTF was I thinking?" I strongly disagree. I don't know about PHP, but when I occasionally have to write some C#, I find my fingers remembering that you can press F1 on a method, see how nice the MSDN documentation is, and begin to wonder if having perceived Python docs as good just moments earlier might signify a deeper mental problem, like, what if being desensitized to shit makes me a worse programmer. A nicely organized documentation is not catering to mentally infirm, it is catering to people who don't have to prove their manly ability to wade through bullshit to anyone.
I was absolutely wrong, and it's been addressed perhaps twice in the reply comments (no worries). The answer (`len(x)`) is listed next to `__len__`, but I wouldn't expect anyone who wasn't already familiar to pick that out, or be able to understand what it implied. In any case, I was more pointing out a means of accessing documentation that wasn't addressed in the blog post. While we're on *that* subject, I question the Google-fu of the poster. I was able to get the correct answer as the first result to my first query: "Python length of list." Certainly, the issue was the official docs, rather than one of the communities that the blog called hostile. The official Python page for lists does indeed have the answer, even if you have to scroll a little. Could this function have its own page? Sure, but then you'd miss out on a good deal of other related information that a programmer not aware of `len` would likely benefit from knowing. I'd call it a question of "what you want" vs "what you need." I'd rather encourage well educated programmers than provide shallow topical information, but that's my opinion, and a whole other argument. The previous makes it obvious that I don't think that there's anything wrong with people using Google, but they need to appreciate the limitations of the pages that Google directs them to. It's the same thing when your professors tell you to make sure that a page is credible. Is a simple blog post sufficient to teach you what you're trying to learn? If it is, then make use of it, but simple blog posts are often not sufficient for instruction in deeper topics, or are misleading or incorrect. I discuss this further in the children threads of my original post. It is a valid criticism of Python to suggest that development on Windows is a nightmare. I'm installing virtualbox and a linux installation tomorrow for someone that I'm teaching the language because of this limitation. Of course, his issue is compounded by using portable python, but that's a rabbit hole for another day. Of course, I'm not well versed in any development on Windows, so I'm unqualified to comment.
I couldn't disagree more with the "use Python 2" suggestion. NumPy and SciPy have supported Python 3 for quite a while now. I understand Matplotlib might not yet be fully up to speed, but it's probably good enough for 90% of people. If you write a big ol' codebase in Python 2 *without care*, you're going to end up with scientific code, which traditionally doesn't get maintained particularly well, that is tied to an eventually long-dead Python syntax. I've done plenty of scientific Python coding. Python 3 works great for it, and most of my work predates Matplotlib's Python 3 support. Other than that, good read.
While I agree that the author's Google search seems a little unrealistic (who has the patience to add the "site:..." stuff every time?), I think it was mainly to demonstrate that the documentation, which, in an ideal world, should be the main source of information about the language and its features, is sometimes lacking. Edit: I mean "lacking" in terms of "hard to find specific information", not "not containing the necessary information". 
Python should have an documentation browser like Factor. And yes, functions and classes should have their own pages.
&gt; Now let’s say that you wish to do the same in Python. In this case, you would Google for “Python list length site:docs.python.org”, and the first result is… a page with several chapters on standard types? It’s entirely unclear how to get the length of a list, and you’ll have to scan through a giant amount of text – even ctrl+F will not help you much here That is... a very odd declaration. When I try that and C-f "length" I get a few hits on `bit_length` and then... &gt; len(s) length of s
&gt; If you join #python and do annoying things (like ask if you can ask questions) That's a pretty low bar to set for defining "annoying things". In other places that would be 'being polite'.
Sphinx's search (I'm pretty sure the Python doc uses the built-in sphinx search) is definitely completely unusable. Plus it tends to bring up the C API stuff long before the Python-level calls, which is... rather unhelpful in most cases.
I'm not defending Python, just shitting on PHP. It is the Reddit way. 
I agree that the exceptions throw by the function should be mentioned more clearly
You're right! Thanks for correcting me. I didn't realize that except: without capturing the argument behaved differently in Python 2.x. I will point out that both cases have preserved tracebacks on Python 3.2: Traceback (most recent call last): File "test_exception.py", line 24, in &lt;module&gt; main() File "test_exception.py", line 21, in main bang() File "test_exception.py", line 14, in bang raise e File "test_exception.py", line 12, in bang foo() File "test_exception.py", line 2, in foo raise Exception Exception I've spent enough time in frameworks manually preserving tracebacks that I now wish I could convert our code base to 3.x...
Fair enough, I'll agree with that. My concern is if someone is writing some sort of numerical simulation involving thousands of lines of code. I just don't see the point of staying on Python 2 if it can be avoided.
don't forget IRC is not amazingly real-time. By the time the ask-to-ask, get-permission, ask-question dance is complete, easily half an hour can have passed depending on channel activity, with precisely zero constructive content. Also, a lot of the time, asking-to-ask is of the form "can someone help me?". That is essentially forcing someone to make a commitment to solving your problem before you've even explained what it is. Basically, it's better if you (politely) state your issue, then people can chip in as and when they can contribute (which is also why I don't help people troubleshoot via PM)
OP has a point about examples in the docs. Imagine if each docs page had an integrated [notebook](http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html) with examples? That would be pretty nifty.
It's a little bit complicated, though. In PHP there is a one to one relationship between a function and its behavior. So there is just a function for the length of an array. In Python, though, the len function gets the length for *any* object that implements the len builtin, and its behavior and exceptions depend somewhat on the implementation of that specific object. So really it just isn't possible to have one page per function in the same way that PHP does it. More importantly, PHP needs the documentation it has *because* its syntax is so idiosyncratic. The order of parameters from one function to the next seems entirely arbitrary. 
But it's not immediately obvious to a newcomer how they should ask a question. People are used to thinking in terms of manners and respect, not in terms of signal to noise ratio. I think the problem with online communities is that every newbie seems the same, so the old hands get tired of explaining the same thing time after time. Why do they never learn? But of course, every newbie is individual, and doesn't know what you told the last 20 people. The best response is to design a system which doesn't invite newcomers to do the wrong thing. Stackoverflow is a good example of this for programming questions.
2.7
CC is pretty old and bad at this point. Having used both it and Jenkins, I can't really recommend CC. 
Trac is written in Python, but for a tool like a ticketing system use the one that fits best in your environment - not the one written in your language of choice. 
Good manners should never be discouraged. This only invites poor manners to take their place.
As someone who has never used struct, never used binaryIO outside of reading and writing to CStringIO objects and generating images from PIL. Would it be possible for someone to explain/write a tutorial for those of us who are less than familiar with lower level IO? I was trying to use this as a method of reading and writing Minecraft worlds (I know of pymclevel, it was a contrived project) and couldn't work out what I needed to build the correct file structure.
As someone currently trying to learn Python, this hits home for me. Starting a new project is always really intimidating, because I know that eventually I'll have to spend (quite literally) a week searching for the one command I need. Hell, when I first picked it up, I had to spend 2 hours reading various intro books before I found out how to print. Of course, when I searched the documentation, it told me to do it one way, only for me to realize much later that it automatically searched the v2 documentation, and not v3.
we use Trac, and I can honestly say use Redmine. it may be written in ruby, but who cares? it's much better at the job then Trac IMHO and is more up to date.
I think Python docs are structured better for structured learning about a system, rather than quick-reference function docs like PHP. But as it's said elsewhere in the comments here, `help(func)` is really all you need for basic "what does this function do" references.
I've been teaching myself Python for a few months now, and this is literally the first time I've even heard of the pydoc command. One problem I can immediately see, however, is that you already have to know what you're looking for. If someone is brand new to programming, they're not even going to know what a list is. Having come from Java myself, it took a ridiculous amount of time to find out that Python has lists, rather than arrays.
Either escape it with backslashes: \\\_\\\_len\\\_\\\_ or put it in grave accents \`\_\_len\_\_\`. Anyway, honestly, do those *need* docstrings? If you don't know what they do, you probably shouldn't care in this case, because you probably won't ever *directly* call them.
[Direct, no blogspam bullshit, link to the project](https://bitbucket.org/akorn/wheezy.web).
 &gt;&gt;&gt; help(list) [...] __len__(...) x.__len__() &lt;==&gt; len(x) And this helps, how?
The author's point was that the official documentation is not good, hence the searches being restricted to official documentation. 
I would recommend wr741nd v4. Very reliable. We have around 200 in local mesh (http://wlan-si.net)
&gt; I didn't realize that except: without capturing the argument behaved differently in Python 2.x. It has nothing to do with capturing arguments, it has to do with re-raising with an argument or not: if you edit `bar` to `except Exception, e` you'll still get the same result. It breaks if you `raise e`, whatever the capturing clause is: the `raise` does the stack serialization, and thus loses part of it if you explicitly re-raise the exception object rather than use a bare `raise`.
So...Python developers have grown-up jobs? ;) The article makes a good point about the speed of change. I find it funny that it assumes the reader will agree that fast change is better.
There probably should be more example code per page, though.
This isn't a Python issue. Not to language bash but Ruby is **far** worse. I think why PHP has better docs is because it had a lot more use in the 90's where Python/Ruby has gotten popular a little more recently. Programming just seems to be more elitist these days. Back in the day the elitism was contained to C/C++ and Perl/Java/PHP were pretty friendly/helpful since they were languages "for the rest of us". But these days a lot of heavy lifting is being done by scripting languages and they've become a little less friendly as a result. Plus it seems like every few years some new paradigm gets invented(MVC, paired programming, agile, letting your code be your docs, etc) where before it was mostly about just getting crap done by whatever means possible. 
A symptom rather than a cause I think... Python, like any popular language, attracts a great number of people who are interested in creating "the ideal programming language". Such people tend to have very definite ideas about how a language should be and tend to war with other language enthusiasts. This can be pretty hostile to those who merely want to use a particular language. So rather than complain about hostile developers I think it would be more helpful to think about way to keep new users *away* from the developers. The Python documentation tends to reflect ongoing debate about how people *should* be programming as opposed to how people are *presently* programming. 
I don't think the python documentation is bad and I don't feel bad because someone else might struggle with it. I don't have a blog to write this on either :-\ 
What's with the "&lt;a&gt;" HTML tag around the introduction? It makes the text change color when clicked on. Distracting enough that I wrote a comment about it.
As your potential employer, If I found out that instead of improving the companies existing assets like I hired you to do, you were wasting time and money doing something other than what you were hired to do.... well.... lets just say you wouldn't last long. 
no, that's the python docs insisting python 3 is "the future". they reorganized things recently.
IMHO you shouldn't be browsing Python documentation by using Google. You browse Python documentation by visiting docs.python.org, selecting your Python version, and clicking on the relevant links (e.g. Library Reference -&gt; Built-in Types -&gt; Sequence Types). For someone who never used the docs before, it may not be trivial to find what they want, but you get used to it very fast. In PHP pretty much anything is a function in the same huge namespace, so naturally googling it may be the best approach. I don't see it as an advantage, though.
Upboat for the use of "arse" instead of "ass".
Stack Overflow is indispensable. I find everyone helpful and knowledgeable when I go there for assistance. Often, I get more information that I asked for and come away with more than just an answer to my question, I get an understanding of all the corollary ideas as well. It's one of the better online forum experiences.
In an ideal world you find the answer to your question. As long as answers are vetted by a voting system, the quality is just as high as for official documentation, in my experience. (ref stackoverflow)
Yes, but that implies an already in place community, which python already has. This wouldn't go so well if you're trying to start a new language though.
My point was that the *official* Python documentation is poor. I certainly agree that many things are answered on StackOverflow, but imagine that you're looking for something that not very many people use. You'll search on Google, not find any StackOverflow posts (after all, nearly noone uses the thing you're looking for), and you just find a few unclear blog posts and a Python documentation page. Official documentation is important especially as a fallback when other sources fail to provide the relevant information. As such, the focus of the official documentation should be on complete and clear, unambiguous reference. That's not what the official Python documentation provides. While len() may be a very simple example (and intentionally chosen for that reason), I've more than once run across things for which basically no documentation could be found aside from an ambiguous explanation in the Python documentation that never got me anywhere. EDIT: All that said, StackOverflow is an absolutely golden source of information.
This pretty much sums up my thoughts on it. My primary reason for writing code is not learning how to do it or enjoying it - it's to get work done, in a sane way, as quickly as possible. I have a very limited amount of time (and far too many things to do), so documentation that doesn't waste my time is absolutely critical to me. I'd imagine many others are in the same boat (and frequently see indications of that from others, as well).
I think you answered your own question about the problem. The reason why nobody is fixing the *official* documentation is that there isn't a pressing need. There is a wealth of supporting documentation, tutorials, reference material and support/discussion forums (e.g. stackoverflow) so that it's perfectly adequate to have the official documentation be simple reference material. 
That thread is absolutely bad, but not really relevant to 'the community'. The average PHP developer never even touches bugs.php.net (and doesn't talk to any core devs, for that matter).
The problem with "it provides useful information that you weren't looking for" is the part where you weren't looking for it. When I am looking for a quick reference to something, I don't really give a crap about all the 'context' that surrounds it. I either already know all that stuff, or have no need to know it at that point in time. The documentation doesn't give me the choice to switch to a 'reference only' mode where you just get per-entity reference (per class, per method, etc). It always throws a wall of text at me, 99% of which is entirely irrelevant to what I am looking for, and at that point just a giant waste of time. I've been developing things for years, and I *know* that more concepts are involved with something than just the function reference. I am perfectly capable of looking for the context by myself, without having the documentation throw it in my face all the time.
Yes, the article was a rant. That's why it's tagged as 'rant' (see the list of tags at the bottom). I have tried civilized discourse about the Python documentation with other developers many times. Every single time it turns into the 'experienced' Python developers waving criticism away, trying to justify why the docs work a certain way, or even deflecting away to "but PHP is worse" as if that justifies the issues with Python docs... all the while newbies are sending me private messages how they fully agree with what I'm saying, but don't want to say it in public. I've given up on the civilized discourse. [Sometimes the only way to get someones attention is by pissing someone off.](http://shadow.cat/blog/matt-s-trout/on-being-a-bastard/) Judging from the discussion that has started here, that works, at least to some degree. Also consider that people in this thread are, individually, agreeing with certain things and disagreeing with other things. The interesting thing is that what people agree on, differs per person. This indicates that all of the issues mentioned are present to *some* degree, but certain people take issue with them while others don't. Clearly there's a problem.
http://twistedmatrix.com/documents/current/core/howto/ is a good place to start.
Sure, but this is not about what is *better*. This is about newbies not knowing the unwritten rules of the place they go to for help, and getting a frosty reception, never going back, and the cycle repeats. If the expectation is that "newbies should know better" then it is a futile expectation and has always been so.
It's great that you learned using a book. But recognize and accept that others may have different optimal modes of learning.
&gt; actually the first result I got was Built-in Functions I've discussed this issue with quite a few people in the past, and while occasionally 'built-in functions' came up as first result, most of the time people got [built-in types](http://owely.com/6c1pvv) (which is the standard types page I was refering to). &gt; I think we say this because Python code is easier to read compared to PHP. While that is often indeed the case, it's not a reason to throw away documentation or the perceived need for it. Even very readable code still takes an insanely large amount of time to read, compared to a reference table (because you have to understand the entire program flow). &gt; So PHP does this Oh, PHP itself definitely doesn't. It's an absolute spaghetti mess of functions and classes everywhere. The documentation, however, is very organized and unambiguous - and it definitely makes things much easier and faster. &gt; Well the first function that came into my mind was random.random. I should've probably said "a random function that has its own error conditions" instead :)
That assumes that you already know where to search for what you need. Often you have no idea what module will have the method or class you're looking for.
That part of the documentation explains certain concepts, but for certain other concepts (such as.. writing a reverse proxy), it doesn't really tell you anything. Sure, you can learn everything about Twisted, how it works internally, how every single feature works... but if you just need a quick working reverse proxy, that's not an acceptable option.
No. The reason that noone is fixing the documentation is that the developers that are *capable* of doing so (the experienced developers) do not *see* the need because they don't have an immediate need for it *themselves*. It's a perception problem, not a lack of urgency. And as I said before, there are quite a few things that pretty much no documentation can be found on outside the official docs. I constantly have newbies complaining to me that the documentation is poor on the one hand, and experienced developers claiming there's no problem on the other hand. And when the newbies try to talk about this problem to the experienced developers, they are met with the elitism that I am also describing in the article.
&gt; help(whatever) woah ! how did I not know that one ? who failed to tell me ?
I have to agree 100%. Even in cases where I'm not new to the subject, sitting and watching people lambast others because they didn't ask the right question makes me sick to my stomach. I always think to myself "If you're so repulsed by being asked questions about the topic, why do you even come here?" Then there's the "homework" problem. Any programming question that comes from a beginner is often touted as "homework help" and dismissed. I won't say never, but very rarely do people come in asking for another to DO their homework for them. Forget the fact that a number of language tutorials have a homework'y feel to them. Basically, the pros of the topic need to look at IRC/Forums/Whatever as an opportunity to fine tune their own skills rather than lambast others. As an article recently posted on reddit pointed out, tutoring/mentoring is one of the finest ways of mastery. So while the topic expert grows, as does the student. It's a win win. Unfortunately, that's far from what I see happening the majority of the time.
If you haven't already seen it, [this talk](http://pyvideo.org/video/880/stop-writing-classes) has an interesting perspective on the (over)use of classes. I don't mean that you should never have a DB class, and there certainly are situations in which that would be useful, but the OP's DB class is simply a 1-function level of indirection to the sqlite database implementation. `sqlite3.connect(*args, **kwargs)` already returns a database object, so in this case I think it makes more sense to extract the `query` function to the toplevel and pass the database as a parameter, rather than encapsulate it in yet another object.
Your code looks like you are **very** new to Python and programming in general. Consider /r/learnpython next time. When people post their projects here just like that without asking for review or telling that they are total newbies, I immediately assume they have some experience. So, when I looked at your code with that assumption in mind, it made me cringe a little. I don't mean to demotivate you but please be honest about your level of experience and ask for help, review and best practices. Please don't get this comment in a wrong way. Everybody was a noob at some point.
I applied the standard 2to3.py transformation and two more conversions from bytes to string, and it seems to work in Python 3 as well. You would probably be better of using [requests](http://python-requests.org) instead of urllib though.
try #php @ QuakeNet :)
I just recently did this. I was hired to figure out what a mess of a system that was 10 years of C++, PHP, and VBScript did and then rewrite it from the ground up in Python. The most important thing is to talk to the users. There are features in there that your product owner will insist are critical, but no one actually uses or at least does not pay enough for. There are features in there that no one at your company even know exist that some users are using every day. Find out how they use the app, what features they use, and what they would like to be different. Rewriting with better technology/architecture doesn't do you any good if it doesn't do what the paying customers need it to do.
It sounds like more python teachers should explain how to use the "help" built-in function. One of my favorite things to do in python when working on a bigger project is to have the interpreter running so I can play around with stuff and use the help function when I need to. It works on modules, functions, classes and even instances. I wonder if most people know, after importing anything, they can use help on the whole package/module. It will show you the functions, classes and explanations of each (if the module is documented of course). Its simple, but I wonder how obvious/advertised it is. import itertools help(itertools) Although I guess you would have to know the [built-ins](http://docs.python.org/2/library/functions.html) to use help on them. They should also encourage/teach early on how to write docs for functions, classes, modules, ect early too.
Maybe recognize the same thing and change your title to "The python documentation isn't optimized for a specific google pattern of searching." 
The TL-WDR4300 has some really iffy reviews on Newegg.
I'd be hesitant to label it "elitism", but I understand your point. And I think we are saying much the same thing. The experienced developers see the official docs as a reference, not a learning aid. Those new to the language are frustrated by not having a single source for both learning and reference. Personally, I see it as a strength that there are so many different sources of knowledge about Python. People can choose the documentation or tutorial sources that fit their current knowledge level and/or learning style. And instead of attempting to be all things to all developers, I'm ok with python.org/doc being dry reference material. It's like the difference between a drivers-ed course and your car's owners manual. 
I've found I'm much more productive when I don't have to switch to a web browser and google trivial functions by a text description whenever I want to do something. Adding in examples wouldn't suck though, I'll agree with that. The way I learned: ipdb + ipython. &gt;&gt;&gt; a = [] &gt;&gt;&gt; a.&lt;tab&gt; # gives a list of stuff you can do PHP was forced to generate docs with thorough examples because the language behaves so erratically. I say this confidently after writing PHP for a decade (2003-&gt;present). In python, if you want the size (length) of something, you always call len() on it. Built in objects follow the same pattern over and over, and for the most part are completely predictable. Learning how to read the docs seems to be a significant barrier to entry for a lot of programmers on a lot of different languages. Once you get over that hurdle you'll be productive.
With OpenWRT it's fine. What are they saying?
*Lots* of complaints of consistently dropped wireless connections. Apparently there's common DHCP problems requiring manual DNS configuration. Also a smattering of other features that just stopped working for people and poor support response from the company. I'm looking to finally retire my old WRT-54G R.2 and every time I see a router discussion I jump on it with excitement. I'd want to see a lot of reviews by Open/DDWRT users before grabbing one.
I notice from experience with working with people who started on python verse lets say start in C. Python is amazing and you really can be lazy about how your structure your code. From past experience programmers that who learned to program on the old languages C/FORTRAN etc had really nice code structure. I get why someone would want to learn to program in python. You really can do anything a student needs with very simple syntax. 
The WDR4300 has two radios, one 5GHz, one 2.4GHz, which is useful. They share antennas though, so you'll have to look out for special dual-band antennas if you want to replace them. With OpenWRT, almost everything works: both wireless devices, USB, the switch. The hardware NAT isn't supported. I'm running current attitude_adjustment (compiled myself because the latest RC is missing some essential patches that make the wifi drivers not crash every 1-2 weeks). Anything specific you want to know?
The positions I am linking here involve codebases that are dominantly written in Perl. However, I thought it would be appropriate to post here as well because we welcome great developers whose favorite or most-known dynamic language is something other than Perl. In addition, some of our people are working on a very important piece of infrastructure using Python, and it would be good to have other perspectives, knowledge of other already-solved problems that we may currently face, in our toolbelt. At a certain point, it becomes less about the language and more about the problem one is trying to solve, the people one is trying to help. Let me know if you are interested. :)
The title is intentional. See also my response about this being a rant. This topic is consistently sweeped under the carpet whenever brought up. This is an effort to bring it into the sphere of discussion (or even controversy at some points) by 'triggering' enough people to make them respond. Part of that, is giving the article a title that, in itself, will make people go "wait, what?". And let's not forget that you *should* indeed feel bad - it's the responsibility of everyone that is capable of doing so, to fix this issue. The issue lies with the developer community as a whole, not one individual or group of individuals. Unless people realize that there is a problem and feel bad about that problem existing, there is exactly zero percent chance that it will ever be fixed. If this article genuinely does not apply to you because you are already working on fixing this (or are not capable of doing so), you won't feel any guilt and it won't have any influence on you - because you, yourself, know that it doesn't apply to you. If the title and the article piss you off enough to take issue with it, you should consider whether it might be because it points out one or more problems that you're trying to ignore. I don't like that this is necessary, but so far all civilized attempts at approaching the issue have vanished into obscurity. Consider this a [last ditch effort](http://shadow.cat/blog/matt-s-trout/on-being-a-bastard/).
The Python documentation actually tries to be both and neither at the same time. On the one hand you have the reference buried in a pile of theory, then in another place you have dry reference without enough context to understand it from scratch, and in yet another place you just have an entire page of theory without any referenceable material whatsoever. It's fine to have a separation of reference material and theory - in fact, it's a good thing - as long as: 1. this material is separated clearly, and 2. both are complete. In the case of Python, neither of those requirements are met.
Nicely organized != organized for search engine access. 
I agree the Python documentation could use some improvement. However, my number two programming language is probably R, and, oh man I wish it were anywhere near as good as the Python docs.
Glad we could oblige, meatbag.
This is why I come here. Thank you!
Well, it is all open source. If you do not like and your itches are not being scratched, I suggest you dig in and make it better. Critique is well and good, but a constructive suggestion on how make it better would be more appreciated. Actually helping to fix it would be best of all. 
&gt; when I occasionally have to write some C#, I find my fingers remembering that you can press F1 on a method, see how nice the MSDN documentation is I find the MSDN absolutely terrible when trawling through it looking for information. If you already have the symbol at hand and ask specifically for what that symbol means it's nice, but then again so is `help(symbol)`. MSDN's siloing and over-compartmentalization makes it very hard for me to get any information worth reading without switching back and forth between half a dozen tabs.
this actually highlights what is wrong with the SO approach. It would be better if answers could only be provided by pointing to OFFICIAL documentation. And anyone should be able to contribute to the official documentation (wiki).
honest question, why don't you do it better than?
I sadly do not have the time (or knowledge of Python, for that matter), to rewrite the documentation into a different format. And that's not a fancy way to say "I prefer being in front of a TV" - I *actually* do not have the time for it. I'm already occupied by other (open-source) projects pretty much from the moment I get out of bed until the moment I go back to sleep. To be perfectly honest, it annoys me to no end that I'm not able to fix this. I don't like lingering problems.
Well, Apache *is* terrible...
Why Maya? I guess in an Open Source environment its random what tools are made, but Blender seems a much better fit overall.
See http://www.reddit.com/r/Python/comments/18ssb6/the_python_documentation_is_bad_and_you_should/c8hxx9n.
pick the biggest problem you have with it and just work on that. 
That's the point. It's not an issue with one particular part of the documentation. It's the structure of the documentation in general.
I'm not sure what you mean by "structure." Would you just prefer that every function have its own page like php?
That's one option that would likely improve at least the searchability and the ability to do quick reference (assuming a standardized page format). That is not to say that this should be the *only* format available, or even the only solution to these issues.
It's kind of a long line, but my new favorite way to generate a password: python -c "import random, string; print(''.join(random.choice(string.digits + string.ascii_letters) for _ in range(12)))" If only there were a core-library `random` function for sampling with replacement...
so what else do you mean when you say, "it's the **structure** of the documentation"?
&gt; "If you're so repulsed by being asked questions about the topic, why do you even come here?" because they didn't view the channel as being dedicated to answering the same questions over and over, frequently from demanding individuals.
That's a sign of bad documentation, not good.
Then i suggest you try give a solution in either #python or reddit which might not be according to PEP, i challenge you.
Calling most of those "professional" is rather stretching the meaning of the word. Edit: Not that I have anything against PyGame, but by setting this up the way you did, and then giving those examples, it feels like damning with faint praise. 
While not a game, I always feel [MCEdit](http://www.mcedit.net/about.html) deserves a mention.
That's not a very good password generator if there are no special characters.
Really? I like python, but for me, it's simpler to just &gt; cat /dev/urandom | strings -n 15 Or, if you need a bunch of them in a hurry: &gt; cat /dev/urandom | tr -dc 'a-zA-Z0-9!@#$%\^&amp;*()_+-={}[],.' | fold -w 15
This is the third time I've addressed this. I'd edit my post, but I didn't want to yank the rug out from the others that pointed this out. I was incorrect in that single point. I was more interested in addressing a general strategy of accessing documentation.
I do not feel that any amount of disparate blog posts are sufficient to cover the breadth of knowledge that programming requires. This applies to any language. I do not feel that any reference manual is sufficient, for that matter. There are a variety of concepts that need to be addressed in depth for a programmer to be successful. I understand that there are other resources, which is why I also added "comprehensive book-like." I'll back down from this point as soon as you can find me a blog post that does a good job teaching something like object oriented programming in its entirety.
Lots of linux distros ship lots of crappy games. Something some guy made for an indie contest =/= professional development.
I mentioned that I was sorry that you had a bad time of it, and I truely am. That said, do you believe that getting attention and affecting change go hand in hand? A child can squall about a desired toy in the middle of a store all day, does he deserve that toy? It is abhorent that anyone would deflect rational criticism, but given my exposure to your discourse, I can't help but feel that you did something to "get attention" there as well. You suggest that there is clearly a problem simply because there is no perfect consensus? How does the old saying go, "you can't please everyone all of the time," or something.
I quit that place years ago. I came in to ask a question and was repeatedly told by one of the OPs that I shouldn't be doing what I was doing and that I was wrong for trying to do what I was despite me explaining clearly explaining why.
Here's one for Javascript: http://killdream.github.com/blog/2011/10/understanding-javascript-oop/ It explains an OOP concept completely unlike classical OOP, from the ground up, so it's a particularly good example of how one blog post can explain an entire concept. That being said, blog posts are not my optimal mode of learning - and as your response seems to imply that it is, I'm not quite sure where you got that from. The most efficient method of learning to me is Googling for things, figuring out related concepts, creating a mental model of the steps involved in getting where I want to be, and then looking at a reference to learn how each step works in detail. I quite literally only learn what I need, as I go along. I typically don't learn for the sake of learning.
You are misrepresenting what I said. There are two very different concepts here. You seem to claim that I am saying that "acknowledging a problem automatically fixes it". What I am *actually* saying is that "to fix a problem, it first has to be acknowledged". It's a prerequisite, not a cause.
I realize what you said, I'm suggesting that it doesn't matter. In argumentation, some things are necessary, one of which is **not pissing off your target audience**. It is as simple as that. If you don't, everything you say (has) will be dismissed as whining. Because it is. I'd like to you pay attention the next time you have the opportunity to take English composition.
Clearly "not pissing off your target audience" hasn't worked, seeing as the docs are still in the exact same state as before I tried civilized discourse. The one that's most pissed off here appears to be you. And judging from the conversation going on here, on Hackernews, and on IRC... you are one of the few that dismisses it as straight-out "whining". Most others are attempting to actually discuss the points raised.
Here's mine: tr -cd a-z &lt; /dev/urandom | fold -b8 | head Mine is 38 bits of entropy and yours is 96, which definitely seems like overkill to me. The thing is, by using a password generator, you're making a password much, much better than one generated by hand, so you can throw out the conventional wisdom about password length and character sets. NIST estimates that for user-generated passwords that include capitals, numbers, and punctuation, you need 22 characters to get 38 bits of entropy, and 80 characters to get 96 bits. So your password is as secure as an 80-character user-generated password.
Those docs are awful. Simply, purely awful. The explanation of the core concepts are so good that it gets your hopes up for documentation for the features you actually need to use... that... doesn't... exist. Every attempt I've ever made at using Twisted to solve a problem has ended in failure, and it's always been a problem of documentation. I don't want the docs to show me how to do specific things. I'd be happy if the methods and classes were documented *at all* 
So, SolarWolf isn't a professional game. (It is, I admit, the weakest entry on that list.) You said "most" of the games in the list weren't professional. Which others? You mentioned indie contest != professional. But the only ones I mentioned (as being finalists for IndieCade and Independent Games Festival, not just entrants) are sold as commercial products. I say that makes their developers professional developers and the games professional games. (7 Grand Steps isn't sold yet, since it will be released this spring. But the dev behind it has developed other commercial games, so I include it under the "professional" label.)
That's a good way to run some Python code, which may or may not use Django or your Django app… but that's not what this article is talking about. This is an idea for a Django startup hook that runs in the same process and initializes things within the Django environment, before anything else happens. I personally would love something like this. But – and correct me if I am wrong – just having a `startup.run()` call in manage.py won't help you for WSGI, e.g. when you're running under gunicorn.
I got this to work, thank you!
Thanks for your help. I know matplotlib is on my list to learn but this project is due in a week and I'd like just something simple. thanks again!
&gt; Just because I slap something on Soundcloud and charge $5 for it doesn't make me a professional recording artist. No, but people paying $5 for it does. I think your definition of "professional" is really "produced by a company with a large budget" and your definition of "most" is actually "some".
Aw, dammit--I've been committing a useless use of cat. I agree 15 truly random printable characters is overkill for most applications, but as long as I don't have to remember them, I don't mind.
**file** is a [builtin](http://docs.python.org/2/library/functions.html#file); while Python *lets* you override that, doing so without a really good reason is a bad idea.
If you were in that much hurry, setting the 4 pixels manually in the gimp would be even faster than typing the above.
Write a Python function, clip(lo, x, hi) that returns lo if x is less than lo; hi if x is greater than hi; and x otherwise. For this problem, you can assume that lo &lt; hi. Don't use any conditional statements for this problem. Instead, use the built in Python functions min and max. This is the code submitted. but not working any ideas?
Oh, sorry. I didn't see below where you addressed it, but it's possible I just jumped on you. I don't know if you're familiar with this convention or not, but sometimes people edit their posts at the bottom, with a bunch of dashes, followed by their edit—like this: ----------------------- **Edit:** This is usually how I do it, so that no one can accuse me of cheating ;-) ----------------------- **2nd edit:** Okay, this is a real postscript. I up-voted your comment below, earlier in the day, about learning from a book. When *I* want to learn something new, that's almost always what I do. I buy a book or two on the subject. Author's go through a lot of hard work to walk you through things—and if you think about it, civilization is built on books. I don't know where this "if you have to read a book" attitude comes from. (I'm guessing you don't either.) I'm not going to speak for you, but I'm actually pretty unsympathetic to people who are allegedly so interested in learning something, but can't plunk down 35 dollars to learn it.
I suggest you remove those big print statements - because if you don't and if this gets used at all, someone will fork it and do it for you.
Because more people have written a CMS after getting a CS degree than the number of people who started bands after having heard the Velvet Underground.
Also, python -c "import antigravity" is very helpful. 
&gt; makes it very hard for me to get any information worth reading without switching back and forth between half a dozen tabs. Nah, three at most. Plus three more if you're exploring the API when you're reading a high-level how-to. OK, half a dozen, all right, but you can't actually do anything close to that within the Python documentation.
I've been there too, many times. You have to sell the rewrite as an investment, and you absolutely have to make a business case for it. And if you can't, you shouldn't be doing it.
CakePHP's docs are an excellent counterpoint to topic-style documentation pages being useless (e.g. http://book.cakephp.org/2.0/en/models/retrieving-your-data.html). Each section contains a mixture of topical context and function definitions. When I began learning Python I shared some of the article's documentation criticisms, but I think the *style*, documenting a topic, is fantastic. Organisationally, perhaps some room for improvement.
a more sophisticated version of the article’s grepping: site=/usr/lib/python3.3/site-packages grep -lrI "if __name__.*__main__" $site | grep -v test find $site -name "__main__.py" this gets also modules with double quotes around `"__main__"` and `__main__.py` files, ignores binary files (pyo, pyc) and test modules, and outputs only the file names
EVE Online uses Pygame? I doubt it.
So instead you just bitch. 
My experience with #ubuntu has only ever been nice.
I this much of this with regards to maya is outdated and superseded by autodesks native implementation of python in maya since about 2007?!
Because the only movies that are "professional" are ones that are made by Hollywood, duh! In all seriousness, it is pretty pretentious to suggest that a game is not "professional" just because it was not a name-brand title made by some name-brand studio...
What is this supposed to highlight?
On how to use control flow in Python. 
Not to be negative, but this may be too introductory for this sub.
I also agree, but I figured it would make more sense to post the 'simple' case. If the site does allow printable characters, you can replace `string.digits + string.ascii_letters` with `string.printable` (although that can return some funky whitespace from time to time).
I generate my passwords with Unix commands too: Python's random numbers technically aren't as random as `urandom`'s (although that's probably never going to make a real-life difference). Perhaps I should have said, "my new favorite one-line command in Python which will generate a password." The Python version *is* cross-platform though and I like that it actually uses the `string` module (which I was totally unaware of outside until I was playing with this exercise).
I actually got caught up with the default behavior of integer division because I was sloppily calculating some array indices via division under Python 2. When I ran the code in Python 3, I was assaulted with **TypeError**s because division behavior had changed.
I wouldn't play any of these games.
I wouldn't say it has to be name branded but it shouldn't look like it was made for a contest entry. Some of these games look decent but others do not. These games, while an interesting list, don't give me the idea that pygame is for professional game development. P.S. Just because a game isn't professional doesn't make it bad. Not meant to be an insult 
No, I don't call that civil discourse. Read what I said better. Civil discourse was what I attempted *before* writing this post.
Okay, this is just getting ridiculous now. &gt; It's a given, considering the way you teach yourself. You cannot run into all of the information important to programming if you only jump out there for small bites that satisfy your current need. And you conclude this, how exactly? I don't have any issues with this. That I run across information in a different order does *not* mean that I do not run across it at all. &gt; How will you ever learn of some of the excellent patterns that have evolved? You won't ever say to yourself, "I should use an MVC pattern here," unless you are aware of that pattern. Since the MVC is fairly popular as of late, I should add that it was used only as an example. There are many subjects out there that you would not think to search for. I run across design patterns quite often in random strolls over the internet. You seem to assume that unless you "follow a design pattern", you can't possibly write proper code. Have you considered that I might be able to think for myself, and end up on a similar or potentially better structure to write my code, without *having* to run across an article about an existing pattern? It's not as if there's some kind of group of people making up design patterns all day long that other people could not possibly think of. Things are not hierarchical like that. I have more than once seen people that are unaware of design patterns come up with an idea virtually identical to an existing pattern, without ever having heard about it from others. No problems there. I am perfectly capable of reasoning as to how I can make my code easy to read, maintain, and reuse, for a particular kind of project. Assuming that I would always need an externel entity to tell me how to do that, is sheer ignorance. And yes, I am offended. &gt; It's also fairly obvious that you do not have a broad understanding as your post mentions that you were looking up the means of determining the length of a list. This is something that all comprehensive books cover. And usually early. And they often use it as a segue to the topic of iterables and sequences, on which such functions operate, and why. When you only look up the bits of information that you need, you miss out on the grand picture. Have you considered that I might prefer assembling that grand picture myself? Again, that I learn things in a different order, does not automatically mean that I am missing things. Your assumption that I must not have a broad understanding because I learn things in a different order is, once again, sheer ignorance. I suggest you take into account the possibility that someone else approaches things differently than you do, and can still end up with a similar or even better result. If you want to learn from books and guides that explain everything from start to end, great for you - but don't project that desire onto others, and ditch anything that deviates from it without even looking into it.
Always be careful when porting existing code. When people write unmanageable systems like this it's frequently due to the intention of the original idea shifting. As many others have said, rewriting from scratch is often better. Make sure you understand the full requirements and when you get stuck check the old code. Use it as a reference, not a guide. 
Try my password generator based on sudoku grids, here: https://github.com/dodecatheon/sudoku-password-card
You're right, it is getting ridiculous. I'm not going to convince you that the way you do things is wrong, and you're not going to convince me that it's right. That's the way it is. If you had written your blog post in a different way, I'd have respected your opinion, but that's not the case. I see no reason to continue this. For what it's worth, I didn't downvote any of your responses, only the initial blog submission. I don't know if you care, but I do. Even if I disapprove of you means and opinions, they were generally expressed with good intent. I genuinely hope that whatever strategies you use work out for you, even if I don't believe that they will.
My editor will jump to the doc or the file in a keystroke, just like yours will. Where's the problem?
Python is a pretty systematic language, it only takes a few hours to learn the layout of that system (including len). If you are too much of a busy bigshot to learn the basics and expect to be hand-held through every individual task, but only in the official docs and not any other source, then just use other languages you already know instead of complaining about ones you don't know simply because you don't know them and don't want to use anything except official docs which you hate.
I don't know about that. For example, #vim is just about heartwarming
I do have to admit that there have been times where MCEdit has caused me to restart X entirely because it fucked up my mouse input. In any case, doing what you've done in MCEdit is no small feat and should be recognized as such (at least that was the point of my initial comment).
Your missing out, analogue: a hate story is fantastic.
Doing it myself is not an option, civil discussion turned out not to be an option, so the only option left is indeed bitching about it enough to make people talk about the issue. Correct.
So by that definition, if you (say) made software to create Bingo cards, and sold it for decent money, that would be professional even if you hadn't produced something like Mass Effect with half a movie budget. Every commercial iteration of Deer Hunter and Solitaire which is part of a making a livelihood, even written by one person, is professional. That bar is not terribly restrictive in terms of size or artistic merit.
Yes, precisely. I think in terms of programming it's an important distinction to draw, as hobby/"fun"/side projects often make decisions for fun, the lulz, to learn a language, whatever. Not really a useful gauge of technical merit that it would be if someone actually staked their ability to put food on the table on the tech.
Was that strawman really necessary? I'm not expecting to be "hand-held through every individual task", I'm expecting a proper language reference that's actually usable as a reference. "Only in the official docs and not any other source" is once again something I never claimed - I could consider that another strawman. As I have clearly explained in another comment on this thread (and even in the article itself) I have restricted the search to the official documentation because *that's what I was discussing*, and as elaborated on elsewhere in this thread the reason for that is that not everything *is* documented by third party sources. I am perfectly fine with criticism or counterarguments, but throwing statements at me that I never made in the first place - just to have something to complain about - is completely unnecessary.
Every time someone stops using Perl, an angel gets its wings.
don't understand this at all.. little help.. 
I understand that you may not grasp the basic idea of scripting languages like python, and compiled languages such as c++. Scripts are not compiled, and are simply text that is interpreted during run-time. This means that they require the python interpreter to run. Compiled languages such as c++ are compiled once, and then can be run on any computer if it is compatible with that operating system. Honestly, I think you should use the Python IDE if you are a "Noob". It is easy to use, and has syntax highlighting which is useful. I hope this helped you on your journey into the world of python.
It's a great example of the development time advantage of Python. The engine, low level side of it is written in something C like, the higher level game logic is not.
I'd love to see more games using Python like Battlefield 2 did.
It truly astounds me how many people think that anyone else could possibly give a shit about what they put in their blogs.
Look at the decimal module.
It's really not, though. Have you seen the Java documentation? Stackoverfow is awesome for gotchas, edge cases, and how-tos with that language but everything you technically need to know is there. Just because there are other resources doesn't mean that the primary (and official) resource ought not to be the authority on the subject.
Can you give a simple example of how to use this routine?
If those games are being sold, how do they not fit your definition? ("following an occupation as a means of livelihood **or for gain**")
Maybe this example will help: http://stackoverflow.com/questions/6483440/python-decimal-precision
I'm confused about why the estimate of the number of cards in circulation is relevant to the problem. Just because a gift code is not being used does not mean it can't be guessed.
Outside of the tutorials to get you started the code itself is pretty well documented, but I think it's convoluted just because of the sheer amount of stuff the Twisted can do. Also http://krondo.com/wp-content/uploads/2009/08/twisted-intro.html is an excellent introduction to not only Twisted but also to async programming. 
Thank you, that decimal module did the trick - the code works now! Interestingly, the value changed from 0.000000444 when I used Float96 to 0.000000452 when I used the Decimal module with a very high precision (getcontext().prec = 100). I guess that means that the original value I obtained with the Float96 was incorrect due to a lower precision? 
The problem is that there are too many introductions to Twisted, and not enough simple documentation of all of the other components. The code documentation of the core features is *great*, but Twisted doesn't need more core documentation. I can't tell you how many times I've found out about some great feature set Twisted has that could solve my problem... only to find the whole module basically undocumented. 
My post didn't make it clear. I wanted to say "... of someone guessing a 15 digit code correctly (that had money attached)?" The number of cards in circulation is relevant because it determines if your guess is correct or incorrect (if there is money attached to a code). Consider this: If there were an equal number of gift cards in circulation as there are codes (each and every code has money attached), every guess is a right guess. Then the probability of guessing a code with money (a correct guess) is 1.0. 
That is very good advice thank you! I presented my development strategy today and they seem to like it and I will present it to the CEO tomorrow and its sounding like a complete rewrite at this point
Ah, that explains it. I thought you were trying to calculate the probability of someone guessing your exact code (rather than just any valid code), which would be 36^-15
If you use [IPython](http://ipython.org/) as your interactive shell -- which I highly recommend -- you can also get help on something by typing the symbol name followed by a question mark. Check it out: In [1]: len? Type: builtin_function_or_method String Form:&lt;built-in function len&gt; Namespace: Python builtin Docstring: len(object) -&gt; integer Return the number of items of a sequence or mapping. You can see the source code for a function `foo` with two question marks: `foo??`. Tab completion works. There are handy built-in commands for timing and profiling. There's a one-liner to pickle and save variables for later sessions. I wish I'd known about all this sooner.
The problem here shouldn't be with the size of the float. Even a 64 bit floating point value should be plenty. Floats limit precision, not magnitude. If you pay attention to the order of your calculations, you should be able to get a good answer with floats.
All the time!
Great list, Al. Do you have more input on doing 3d stuff with py game as is obviously done in metin? In your books I got the impression that you should really only attempt simple 2d arcade style games with py game, but between the Russian RTS and Metin2 I feel like there's no reason you can't make a first rate game as popular as mine craft or torchlight with py game. What's the catch? 
You're right , I should've put in into the learnpython sub. Thanks.
`python -m antigravity` works too.
Title said professional, not triple A. So any game that makes money counts. 