Perl programmer here. Perl's `strict` pragma is what enforces declaration of lexical variables, it does help catch some things (although after a while you get trained not to make those mistakes any more). I personally like it, but I have no problems with languages that don't enforce it. To be honest, it's a silly thing to argue about. Perl does have some [nice stuff](http://search.cpan.org/perldoc?Moose), but this is a minor difference at best. The `strict` pragma doesn't apply to everything. Ask him if he ever gets his hash keys wrong. I rarely do, and he probably doesn't either. 
Yes. Not having to declare your variables leads to Python's fucked up scope, and 2 different keywords (`nonlocal` and `global`) to try and attempt to work correctly with them. All of this could be fixed by simply having a mandatory `let` keyword to declare variables.
No. 
&gt; In other words, Python shadows by default, and forces you to be explicit when you muck about with variables outside the immediate scope. Which is the problem. And now we have 3 different scopes and 2 keywords instead of one and one.
&gt; I basically know anything there is to know about a variable by just looking at it. You're talking about types, OP is talking about scopes. And scope inference is broken.
Personally I almost like the way python does variables. Variables that are global by default is evil (javascript), but the awkward local inference is a bug bed. myglob = 1 def funky(): print(myglob) # &lt;--- throws an exception! myglob += 1 funky() I think the way to go would have been all variables are local unless stated otherwise (as global or as nonlocal).
&gt; Python treat variables as names which are bound to values. Multiple names can bind to the same value, but you cannot use an unbound (undefined) name. Doing so raises a NameError. So? &gt; And the other 2 are for changing the parser's name resolution behavior: Right. Instead of having a single keyword to declare a name within a scope, you have two to try and coerce the language in not blowing up.
No, the scope of resposibility is just different. In e.g. ASM you take care of things in very low level, such as memory management. In high level language, your increased productivity allows more complex systems, and your responsibility is on higher abstraction level; taking care of maintainability, security, performance and so on. Irresponsible programming leads to bad products, no matter what tools you use.
Just because a language is popular doesn't mean it has no flaw.
Someone is asking what a language gain by doing something different from another language. What benefit do you gain from being able to type `x = 10` instead of `let x =10`? What's the problem of choosing this behavior? Is the tradeoff worth it? If Python has done it differently from the beginning would you like it better?
Why doesn't it treat you as responsible adult and let you deal with memory management, too? Why does it errs on using undefined variable or class? A responsible adult should never code it wrong.
Declaring your variables at the start of your code means that people can quickly see what variables are being used in your code. For example, if you forget what type "foobar" is, you can just look at the top of your .py file. If you want to change it, you can do that too. I think it's more of an imposed style thing more than anything.
Agreed. So many people upvoted your parent comment not knowing he is talking about completely different thing from the OP. This is a sad situation of uninformed majority. OP talking about declaring variable doesn't mean static typing, people!!!
But then you'd have to explicitly say global print In order to use the print function in an user-defined function.
not being funny, but there is only one response to a perl snob: bless
i'm more concerned about the place both op (who wants to know "why python does not force your to declare you variables") and his friend, who is having an issue with the whole thing, work... 
Would any of the bugs you found have also been found by pylint? 
And what makes a language a "scripting language"? I can see a difference between a Python "script" that munges some data in 20 lines, and a Python "program" like a Django App sittiing on top of Apache2. But it's not thr language that makes the differences. And just because it's compiled, C source doesn't qualify for being a "program". Awk or Sed might be qualified as "scripting" but then again don't let me get caught by some really hardcore Awkers. The point being: if you cabn do anything in a language, it's a language.
You got me. I'm flabbergasted... I don't see a cool solution then...
I would suggest that running pylint on python is both easier and more comprehensive than running javac on Java code. 
Actually maybe I should supply an example of using pylint: """ Module which shows who pylint finds errors""" class Foo: """ Class Example """ def __init__(self, a_value): self.a_value = a_value def use_b(self): """ Use b which is not actually defined """ print self.b_value def bar(q_value): print r_value ************* Module bad_class E: 11:Foo.use_b: Instance of 'Foo' has no 'b_value' member R: 4:Foo: Too few public methods (1/2) C: 13:bar: Black listed name "bar" C: 13:bar: Missing docstring E: 14:bar: Undefined variable 'r_value' W: 13:bar: Unused argument 'q_value' 
Python 3 has the excellent [py-postgresql](http://python.projects.postgresql.org/) library. I used it to build [Stirimango](http://pypi.python.org/pypi/Stirimango/0.2.1) which provides database migrations for Python projects. Stirimango does not provide an ORM, so it might not be what you're looking for. I highly recommend this library as it uses one of the best open source databases, and provides some unique features: * Stored procedures or prepared statements are exposed to the programmer as callables. * It seems to be blessed by the PostgreSQL devs and will hopefully become the one database adapter for PostgreSQL with Python 3. * Written in Python, but optionally uses C where speed improvements are possible * Transactions can be used with context managers to provide easy transaction support.
Bad example. lxml has been shipping with libxml2 included on Windows for years. (not always the absolute latest release however, so you might need to do "easy_install lxml == 2.2.6") 
To be fair, it *is* pretty common to find scope and type declaration together, especially in languages inheriting the C legacy where these two have essentially been *merged* and only the type declaration remains, the scope one being implied. A step away from *that* (in a language inheriting the C legacy of course) can be found in C# 4.0 and the `var` keyword which, while it replaces the usual type specifier, is not a type specifier at all, but essentially here to point out a variable declaration in the current scope, with type declaration absent (and inferred).
Why retaliate? he's pointing out an entirely correct flaw of Python. That's it, agree, accept and move on.
Explicitly declaring a variable's scope would have solved the issue: let myglob = 1 def funky(): print(myglob) # the runtime can walk the lexical scopes *at compile time* and see what we're referring to myglob += 1 funky() Furthermore, this alleviates part of the typo risk: for variables themselves and barring mucking around with `locals()` and `globals()`, the parser can statically see and resolve variables. It can even perform constant expansion. Unfortunately, the core developers team didn't consider that an endeavor worth engaging in for Python 3.
Things are not bad, its just that creating a full fledged application still doesn't seem possible yet (but I could be wrong). This is a good step to getting closer though.
I think it's pretty good evidence that the flaw, if flaw it is, must be pretty easily surmountable.
I am distinguishing the between c structures in the implementation and the dict object in python-space. The number of entries in the dict can decrease while the size in bytes taken up by structures that represent it do not. When this warning comes up it is because the size of the dict, as a collection of items, as changed. NOT because the bytesize of the structures representing it have changed.
I make mistakes. I take responsibility for my mistakes. I don't need rigid software to protect me from myself. I want flexible software that lets me express what I want in the shortest form practical. Short code has less surface for errors and I can have it reviewed more often.
C and asm require a responsible *expert*. Python requires a responsible *person*.
Because declaring variables means nothing in this language. it would not make any sense. What does "declaring" mean when your variables are in a mutable key-&gt;value store? "Hey, python, I'm gonna set this key later, ok?" Declaration comes from languages where compilation requires static allocations to be made for the stack, especially when you've got different types with different byte footprints, so you need to declare what they are, not just how many and names.
I just did. Thanks for the tip :-)
&gt;The straightforward way of doing this would be to declare one class inside the other. I'm not sure I'm following you here. All nesting will control is namespacing - where the class is visible from. And its pretty odd to assert that this is the most straightforward way of producing other objects! 99% of the time, you're going to produce an object that is already publicly defined elsewhere. You might want to do this if you want to make it clear that this class belongs to the enclosing class, and isn't to be used elsewhere, but that's a fairly specific need, and I don't think it really makes much sense to reuse the constructor as a public method, especially if you **want** information about the parent class. Just grouping by module is usually more natural, and making the factory a specific binding to the class (or a full-fledged factory module). &gt;But there doen't seem to be any way for this constructor to find out which outer class instance it was invoked on ! I take it you're talking about something like: class Outer(object): class MakeInner(object): def __init__(self, foo): print "Inner constructed with", foo # Want to know the Outer instance who made me... o = Outer() o.MakeInner() Note that this is identical to: class Inner(object): def __init__(self, foo): print "Inner constructed with", foo class Outer(object): MakeInner = Inner There's no magic happening to let Inner know its associated with Outer, as is done for binding methods (though if you *really* wanted, you could define your own metaclass to do so). MakeInner is just an attribute on the class that happens to point to another class. If you need to provide it information, do so explicitly. Ie. class Outer(object): def MakeInner(self): return Inner(self) # Pass constructing instance explicitly &gt;Is there a good reason why we can't have an iterator which behaves well when the underlying collection is modified ? That depends. What does "behaves well" mean? Eg. what should the below print: d = {1:1, 2:2} for k in d: d[3] = 3 Should d[3] be included in the iteration at a later point? Reliably? How about `d[k+1] = k+1`? Infinite loop, no change, or varies depending on the vagaries of the hashtable? Ultimately you can't have an iterator that "behaves well" because "behaves well" means different things in different situations and to different people. Inconsitent behaviour is pretty much a recipe for bugs, so probably the best well-defined version would be: iterate over a snapshot of the current collection, ignoring modifications. But there's already a means of doing that pretty much just as efficiently as an iterator doing so: do the copy yourself. ie `for k in list(d):`. &gt;Isn't it about time python got generic waitable objects Not a bad idea, though cross-platform implementation may be tricky. The OS level primitives for waiting on disparate types of objects don't neccessarily exist on all platforms. Especially if such a framework would need to support software waitables that don't correspond to kernel-level objects at all. As such, doing so both efficiently *and* cross platform would probably not be possible in all cases. (Eg. resorting to polling threads) While not part of python core, there are some libraries which do provide such a framework however. Eg. [Twisted](http://twistedmatrix.com/trac/) implements reactors which knows about events from various IO and network primitives, UI toolkits and others that allow it to integrate it within its event model.
It's a problem with long functions/methods. If a method covers 100 lines, you get lost and don't remember what all the variables do and where they are used. But you shouldn't write long functions anyway. 
Yes. Typos should be caught by the interpreter or compiler, not left until runtime to throw an error just as bad as a real logic bug.
You are forgetting that time=money, so even as a responsible, experienced programmer you will always pick the *best tool for the job*. This includes taking Python over C++ if you need efficiency and are able to not fuck it up.
So you're saying every variable is global unless declared otherwise (nonlocal, let). This is hitting me across the head because my biggest annoyance with javascript is that variables are global by default...
Sure, that still doesn't mean it's not a flaw. Nobody, including the OP, claim that not having to declare variable is a how stopper. Why do I have to love the language so much that I can't honestly criticize which part of it is bad?
As someone who worked years in Pascal, I can say that not declaring variable sucks because it doesn’t catch typos. Of course, when i work in PHP, I set it to report all errors so it does catch those typos (especially the case-sensitive ones — he who invented case-sensitivity shall be banished to all the lower circles of hell at the same time).
It's not a flaw. We like it that way.
Put another way, do you mean that you ship code that was never even executed in test suites? (This question applies to any language). And just declaring variables isn't that much help: declare applestotal, applesoutside, applesinside, bananas applestotal = applesoutside + bananas Or: declare calories, caloriesbanana, caloriesapples calories = caloriesbanana + caloriesapples (The bug in the last one is that one of the variables is actually holding Kcal but that is what we humans commonly refer to as calories.) Just because something "compiles" does not mean it is right.
Python's "variables" cannot be checked at compile-time, because nearly everything is undefined until runtime. That's what makes python dynamic. The loss of static type checking is a penalty but a small one IMHO. Python *could* add runtime type-checking, but this would kill language performance. That's the reason the language doesn't include this feature. It's got nothing to do with whether or not this is a useful feature (who wouldn't want the compiler catch bugs for us). It's about what's a reasonable to implement in a interpreted language. Runtime type-checking is just not worth it. Having said this, an interesting extension for python is the Traits package (http://code.enthought.com/projects/traits/). This adds runtime checking to declared class instance-attributes ("traits"). Only class members you declare to be checked are, so the performance impact is small (determined by how much checking you want). It also adds lots of other benefits like notifications, auto-GUI generation and lazy evaluation. 
I'm sorry, but you don't know what you are talking about. The only "variables" that are in a dict are either global variables or class members. Local variables are statically allocated. Instance members are not variables (i.e. must always be accessed through the instance). Proof of static allocation: x = 10 def f(): print x x = 20
&gt; It's not a flaw. Considering all the trouble it brings as well as `global` and `nonlocal`, it is most definitely a flaw kept more for backwards compatibility than any actual reason. And I sure as fuck don't "like it that way". It's one of the two big Python flaws as far as I'm concerned, along with the shitty `lambda`.
&gt; So you're saying every variable is global unless declared otherwise (nonlocal, let). Uh... no? edit: to be clear, my comment was about how the language *could* be fixed. `let` is not actually a Python keyword. Currently, you have to use `global` to tell the language *this variable is global, don't look it in the local scope*. Otherwise, the issue is this: Python sees that within your function you have `muglob = 1` (let's skip over the addition). That, to it, makes it infer you're creating a local variable. Because Python's scopes are broken and the scope inference is stupid. So it sees your code as this: def funky(): # declare variable "myglob" but there is nothing in it* print(myglob) &lt;== Wha? Why is there nothing in myglob? myglob += 1 And that's why you get a `UnboundLocalError`. Every time Python sees an assignment to a variable in the local scope, it infers that this variable is local. `global` and `nonlocal` (in Python 3) are used to tell it "no you moron, it's in *some other* scope". In this case, the global scope (nonlocal is for nested functions, in order to reach lexical function scopes between local and global). &gt; my biggest annoyance with javascript is that variables are global by default... Well it's just that instead of blowing up it creates them at the toplevel and may output an "undefined variable" warning if you're in strict mode (which you should be). I find that most sensible, even though I'd rather have it completely blow up. Always `var` your JS variable (or use `let` if you're writing Firefox extensions) and you'll have no trouble. If somebody doesn't `var` his variables, beat him to death with a baseball bat then set his corpse on fire. Simple, no? \* Note that "nothing" here is different from `None`. `None` is something. Since you know Javascript, `None` is `null` but this here is `undefined` (some other languages call it "bottom" and represent it as `⊥`), and while Javascript deals with `undefined` Python doesn't.
You don't have to declare your variables in Perl either unless you "use strict", which is good form but purely voluntary. As long as you have some way of catching problems, who cares? I like the term "Perl snob". That's like saying a "Leftover food snob". Don't get me wrong, I love Perl and use it frequently, but it's a big mess.
&gt;Well it does seem Ruby (or Array#each anyway) doesn't explode when altering the collection. That just sounds broken.
And this, dear sirs and madams, is the strawman of the day. 
That is an implementation detail and previously locals really was a dictionary. And even in this light, you do "declare" them by assigning to them in the function. The thing is, you dont have anything other than the name and number of variables, so you dont need declaration, which is more about type signatures.
Well... yeah? See the 7 lines which follow...
Then don't use it. And get outta my way ;)
I think you need to reread the definition of the word responsible. The more one has the do, the more responsible they are. As an example, a mother of 12 must be more responsible than a mother of 2. She has more obligations to meet and is accountable for both her actions and obligations. The same is true with programming. The level of abstraction just takes away certain responsibilities. Python does lots of stuff for you, this thread is an example of that. You mention the following &gt; In high level language, your increased productivity allows more complex systems, and your responsibility is on higher abstraction level; taking care of maintainability, security, performance and so on All of those things still need to be done in the Assembly application. Its not as if one could not write the same exact application in Assembly that he can write in Python. Certainly the programmer who wanted to write the same exact program, which function identically would have to be a more responsible programmer. He has far more obligations to meet. Everything he needs to do must be done manually, with great care. Whereas on the other hand python or other high level languages will take care of almost all of this. By nature, Python demands a less responsible programmer. You cannot even argue the fact that doesn't. If you wanted to make app A in python, making app A in Assembly will take every bit as much work and responsibility and then you can multiply it by 100. I find it staggering, that I am getting down voted for an idea that should be well known. This is one of the many reasons Python has only ~4% market share in industry, and its dropping.
I am not even considering speed of development, nor is that even a consideration for what I am trying to iterate here. I fully agree writing a large app in Assembly is a waste of time. I have even said I think Python is a great language. But to say that creating the same exact large scale App in python and assembly requires the exact same amount of responsibility is silly. Its just not true. The assembly programmer will have far more to develop, far more to secure, far more to test, far more to know. I am being downvoted for saying something that should be clearly obvious.
&gt; the way to go would have been all variables are local unless stated otherwise (as global or as nonlocal). isn't that how Python behaves ? 
We didn't test it, but it is possible. This was actually a software engineering class project. Our teacher tried to make it real world-ish (as he called it) so he looked for actual clients with actual needs. As far as they were concerned, the script worked fine, they just wanted it to run on java so it could be easily incorporated inside of another larger project. Actually I didn't use port lint, but would it be able to determine problem when you have multiple classes and for example you're passing variables between them? I think to do that without any type declaration it would need to be capable of understanding the entire program which I don't think it's possible.
&gt; Put another way, do you mean that you ship code that was never even executed in test suites? (This question applies to any language). Not all code is meant to be shipped, and not all code goes to control aircrafts or nuclear reactors. In languages with relatively high assurances from the type system (e.g: Haskell), I can trust less important code (e.g: Corner cases of various less important scripts) without even testing those paths. Sure they might break when actually run, but it happens far less frequently than with Python. &gt; And just declaring variables isn't that much help: You just showed an example not caught by declarations, but that's silly. Everyone agrees variable declaration does not get rid of all classes of bugs. It does help against: applestotal = applesoutside + appliesinside # actual mis-type I just had! &gt; (The bug in the last one is that one of the variables is actually holding Kcal but that is what we humans commonly refer to as calories.) &gt; Just because something "compiles" does not mean it is right. In Haskell, you could tag in the type whether something holds Cal or KCal, and so have the compiler catch this bug (Trying to add Cal and KCal will be a compilation error).
That's great, it really is. I think pylint is still far from the state of the art of compiled languages such as Haskell though, both in the scope of things verified and in the depth covered (e.g: Accidental use of None). Also, in practice we've found pylint to have a lot of false positives.
I have little experience with Java, and indeed it has a horrible and weak type system that will catch only a few bugs. Given a choice between Java's type system and Python+pylint, I would choose the latter. But for most things, I'd prefer Haskell's powerful type system, because unlike Java, pretty much anything in Python which is considered good style has a straightforward representation in Haskell, but with really great assurances from the compiler.
you shouldn't have variables in programs that are so far divorced from their point of use that you no longer remember what it does 
Because Python is dynamic, it would be impossible to implement. For example: def test(): self.person_name = 'bob' self.person_age = 24 self.person_city = 'California' update_variable = 'person_age' update_value = 25 setattr(self, update_variable, update_value) When you can arbitrarily modify any object using setattr, declaring variables becomes useless. Of course this can lead to shooting yourself in the foot if you accidentally use a variable name which is already used by something else, such as email or file!
if you're writing code so that other people can read it easily, you shouldn't run into such use cases i've had to use global once in the last 6 years, and that was back when I first started using python, and I don't even think it was legitimate. 
&gt;Why do I have to love the language so much that I can't honestly criticize which part of it is bad? Oh, don't whine at me. It's not bad. The very fact that OP had to be told that it was a problem by somebody else kind of nullifies it. And let's be clear. Not having to declare your variables is not some small, obscure part of the language. It's one of the defining (no pun intended) features. If you don't like that part, I find it hard to see why you would use Python at all.
well it is far, far behind Java in adoption by the corporates
&gt; Not having to declare your variables is not some small, obscure part of the language. It's one of the defining (no pun intended) features. Ugh. How does having to do let x =10 instead of x = 10 significantly change Python's way? What current feature or Zen of Python do you think will be affected by having to declare variable?
There are frequently problems in perl if you use it without `use strict`, which is probably what your friend is basing this off. However, there are differences between what python and perl require you to declare, so applying that experience to python is inaccurate. In (non strict) perl, **any** use of a variable is valid, and takes a default value. Thus you can do: $my_variable = 1; print $_my_varaible + 1; # Note the mis-spelling And get the answer 1, rather than an exception or the intended 2. Python will not allow this: you get a NameError on the access to the uninitialised variable. In that sense, python *does* have declaration, it's just that declaration and assignment are the same thing, so every assign is a potential declaration too. This is much less problematic than perl's behaviour, though there are potentially problems. Ie: my_variable = 1 ... my_varaible = 42 Here, you haven't updated my_variable, due to the misspelling, but have created a new misspelled variable. This could potentially lead to an error, but in practice this is generally much rarer, and easier to spot than perl's behaviour. The reduction in boilerplate "`my`" declarations may be a net benefit, depending on how you weigh these things. However, there is another advantage to declaration, which is that the scope of the variable is explicit. This is behind some of python's behaviour with nested scopes, where there's no way to draw a disctinction between "rebind variable x in the parent scope" and "create a new local variable x in the current scope" (which is what happens by default). To work around this, you do need declarations, but python does this essentially the other way round: requiring you to declare that a variable is **not** in the current scope (with the `nonlocal` or `global` statements), rather than declare when it is. This is a reduction in the number of times you declare, since you only have to note the scope in the rarer case, but does feel a bit backwards to me. All in all, I think I'd actually prefer explicit declaration for this reason, but it's not a huge deal. 
I write lots of Python code, and neither global nor nonlocal really bothers me. nonlocal wasn't even added until recently, so obviously this case wasn't bothered too many other people either. global is slightly annoying, but again not a huge deal. IMO, having to type "global" once per function that modifies a "global" variable is less annoying than having to type something every single time you define any variable.
I somehow doubt that's because corporates were starting from scratch, looked at both, said "SHIT, NO DECLARED VARIABLES?" and chose Java, don't you?
So, let's say an ASM programmer has to take care of 100 times more things than Python programmer, so if it takes one month to create something in Python, it takes almost a decade to do it in ASM. How do you think, that our Python programmer spends those years, when ASM programmer takes care of his responsibilities? Relaxes? No, I think he builds more complex system, that his higher abstraction tool allows. With more complexity comes more responsibility, even if low level responsibilities are taken care of by the tool used.
The cool solution is *don't use global variables.*
as someone who's new to python and know little Java, I think you know why better than me 
Well, in my opinion the big advance over Java is not having to declare types, which can get hellishly annoying surprisingly quickly. The reason Java's ahead, if you're asking, is that it's older, was marketed well, had some important advantages over C++ in the early 90s, got a lot of libraries written for it, and is generally fine for what it is. I've been used to python so long that writing Java is rather tedious, but it's far from the worst thing in the world.
&gt; How about "simple is better than complex"? How about "explicit is better than implicit"? &gt; How about "Readability counts?" And `let x = 10` is so much harder to read how? &gt; Where would you put the declaration in [list comprehension] You don't. Its scoped should only be inside list comprehension, not leaked outside. So it's not declaring new variables. Those construct can all stay the same. And that shows another problem with Python. Counter variable in `for` loop or variable in list comprehension "leaks" outside the construct. That's why you think list comprehension variable should used declaration syntax. 
You think that declarations are "more about type signatures" only because you don't realize how much could be gained by having declarations without type signatures. I don't even need to speak of benefits and justify why they are indeed valuable when I can simply point at warts, like the `nonlocal` keyword, with no comments needed. Or at the crazy generator scoping rules, which changed from 2.x to 3.x and then again from 3.0 to 3.1 IIRC (though it was implied to be a "bug fix"). In languages with declarations you can give a scope to every compound statement, so that your "`for i in something:`" binds `i` in the loop body only and doesn't bleed it into the entire function, possibly overwriting some other `i`. In Python it does bleed out of loops, does not bleed out of generators (but does bleed all over the generator itself), and either way produces exceedingly depressing results when you try to capture the variable in the nested (anonymous) function. Just look at this shit: &gt;&gt;&gt; for f in (lambda: i for i in range(3)): f() ... 0 1 2 &gt;&gt;&gt; for f in [lambda: i for i in range(3)]: f() ... 2 2 2 &gt;&gt;&gt; for f in [lambda i = i: i for i in range(3)]: f() ... 0 1 2 Also, it might be possible to get rid of `self`, I'm not sure it's a good idea but the fact is that without explicit declarations there's no choice to discuss. Look at that from this angle: dynamic typing is nice because every function becomes intrinsically polymorphic: it can work with any of the infinite number of acceptable arguments' types; creating a type system powerful enough to describe the range of acceptable arguments is hard, even harder to make it non-intrusive and easy to use. With variable names on the other hand there's no such infinite range: all that are used are here in the file, explicitly! You don't need access to the function's local variables from the outside, so all information you could possibly need is available statically.
I can vouch for Shed Skin being awesome, give it a try.
&gt;you're much less likely to accidentally declare a variable in a loop because you mistyped the name of another variable declared outside of it. Um, why exactly? Wouldn't you catch it at the exact same point, that is, at testing?
&gt; nonlocal wasn't even added until recently, so obviously this case wasn't bothered too many other people either. Wrong inference. nonlocal was added as soon as it could be as it is a major scoping change, it couldn't be added for a point-release.
The failure mode of the language also matters. For example if you mess up C/C++ you will get a core dump at the location (if lucky) but far more likely some form of incomprehensible behaviour/memory corruption/later crash. With Python, Java and other more modern languages you get an exception or equivalent. I Python's case my general unhandled exception handler will also include each stack frame and the value of local variable in each one. Consequently I don't mind handling those by people finding the problem at runtime and reporting it. In the case of typos, in sections of code that are not tested, you can use the various static analyzers. My point was railing against the "if the tools/compilers are happy then the code must be right" crowd. There are bugs that get caught by human minds that the tools will never catch. Using tools/compilers is the very first step, but should not be the last one. On the units side, the [Frink](http://futureboy.us/frinkdocs/) language does an excellent job. The [sample calculations](http://futureboy.us/frinkdocs/#SampleCalculations) are increasingly funny. Python, Haskell etc will not be the last ever programming languages. The newer ones will build on the older ones. I'm hoping that they will draw something from both Python and Haskell. On the Python side the reason why I like **not** declaring variables is: * It makes the code longer (more lines) * It is redundant - I indicate wanting the variables by actually using them * Having to declare introduces another class of issues (eg declaring ones you don't use)
Its not a question of time, its a question solely based on the actual responsibilities that pertain to programming in that language. Of course I will agree with you that programming any user application in C or Assembly is a silly waste of time. I will also agree that languages like Python are capable of building amazing software and are the absolute correct choice for any non system based software. All of this is a given. Though my entire point from the beginning is that, when you build the exact same application with Assembly and Python, the assembly programmer will have more responsibilities to tend to, thus for project completion will require a more responsible programmer. Again this is not a question of the best way to build software, but instead on the actual requirements of the given language. The same complex systems will be built in both the Assembly version and the Python version. So there really is no notion that there is more responsibility between the different versions of the exact same application design. The implementation or the means to get to the finished product is the difference. It would be silly to assume that python demands a equally responsible programmer to build a large scale application as compared to an assembly programmer. Python simply doesnt demand such responsibility, the language implementors of various forms have done the nitty gritty for you. All I am simply saying is, if we where to build application X in both Python and Assembly, the programmer to take on the assembly version would by far have many more responsibilities than the Python programmer. This has absolutely no bearing on competence. Though it does take a very responsible and competent person to design full fledged application in only assembly. I again agree with you that making application X in assembly is silly and there are many other language choices, python included. 
&gt; But to say that creating the same exact large scale App in python and assembly requires the exact same amount of responsibility is silly. Its just not true. The assembly programmer will have far more to develop, far more to secure, far more to test, far more to know. This is all true. But you said that conversely, Python programmers are not responsible programmers. At least that's what we understood. And Python is not meant for people that are not knowledgeable or not responsible. If a language is easier to learn than C++ it does not mean it is meant (made for) the ones who are not capable of being a C++ programmer.
You would get a message complaining about an uninitialized variable instead of random side-effects due to the fact that the variable inside the loop didn't get initialized. Much easier.
I think everybody mistook what I wrote, which is ok. I was not implying python programmers are less competent, not any worse of a programmer. I was simply saying that higher level languages allow for less responsibility to be taken on by programmer, allowing for faster development, all while allowing a lower bar of entry for many people to program. It is certainly easier to teach a kid python vs C or assembly. I was just saying that Python does not demand responsibility like assembly does. Not saying you don't need to be responsible. 
Like argparse, only orders of magnitude better.
&gt; Like argparse, only orders of magnitude better. or, maybe optparse?
re: the edit about downvotes You haven't asked your question properly. It seems that you want to connect to the existing database. Judging by the indirect evidence like the mention of "our DB admin" -- because you haven't spelled it out straight. Then, _if_ that is true (you see, I'm not even trying to answer your question but I already have troubles because you haven't supplied enough information), the next thing that you should have stated explicitly is what is the DB that you are trying to connect to. I understand that you did that not out of malice, you probably didn't realize that there _are_ different kinds of databases until now, but still, for us the lack of such vital information seems actually offensive, and you should have researched the problem with your DB admin (like, make a 3-minute call, "hi, what should I know about our DB before I try to connect to it programmatically, using Python for instance?") before asking.
Not sure applying *The Elements of Style* to code is a particularly appropriate thing to do, but what the hell -- have an upvote!
How about making PyMOTW part of the official Python docs? Is there something preventing this from happening? The official docs for a specific module often lacks in tutorial-like content. I'd really like either PyMOTW or Beazley's [Python Essential Reference](http://books.google.ca/books?id=Chr1NDlUcI8C&amp;lpg=PP1&amp;ots=OAIwtld0Hh&amp;dq=Python%20Essential%20Reference&amp;pg=PA355#v=onepage&amp;q=logging&amp;f=false) become part of the core docs.
To me, it seems natural for the class to go on the class for the same reason that it's natural for the methods to go on the class, even though they could be defined elsewhere - namely that it's the class's behaviour it's defining. &gt; There's no magic happening to let Inner know it's associated with Outer, as is done for binding methods So I've discovered, but I'm still puzzled as to why. Doesn't the fact that it's a callable attribute mean that by python's defined semantics, I should get an Outer instance reference ? (and then, by constructor semantics, I should get an Inner instance reference as well) &gt; &gt; Isn't it about time python got generic waitable objects &gt; Not a bad idea, though cross-platform implementation may be tricky. True, but if the interpreter doesn't do it, the difficulty doesn't go away, it just gets passed to me. &gt; The OS level primitives for waiting on disparate types of objects don't neccessarily exist on all platforms. &gt; Especially if such a framework would need to support software waitables that don't correspond to kernel-level &gt; objects at all. As such, doing so both efficiently and cross platform would probably not be possible in all cases. &gt; (Eg. resorting to polling threads) Since I asked this question I've been thinking how to do this, and it looks possible. When a python-level wait was done on set of waitables, the underlying objects would be grouped by type then have a non-blocking check done on each type, to avoid overhead except when there was real waiting to be done. If real waiting was necessary, a notification would go to an os-level thread dedicated to waiting on all the objects of that type, i.e. one thread would "select" on all the sockets being waited on anywhere in the python program. It isn't necessary for the os to be able to wait on disparate types of object, because as a last resort we can send the notification via the same type of object as the ones the thread is waiting on. When something became ready, a notification would be sent back from that thread to the interpreter main thread(s), thereby turning every kind of wait in the program into a thread-wait. Or perhaps, a thread for every os-level object being waited on. Or some intermediate solution ? Twisted looks interesting, but from what little I've read about since it was drawn to my attention, it seems to be a way of doing asynchronous i/o right, rather than, as waitables would allow, not doing it at all. (you could probably wrap it up so that it did the same thing but that strikes me as being Complicated Twice, rather than simple)
down-vote! 
I found two packages on PyPI, [strait](http://pypi.python.org/pypi/strait) and [roles](http://pypi.python.org/pypi/roles), but a package recommendation that somebody's actually worked with would be awesome!
Doug is a Python committer, primarily interested in working on the docs, I imagine he'll be pulling in some of the good bits as time goes on.
I think the only thing preventing it is an official suggestion to either Doug or python-dev, which I don't believe has happened. I've read several people suggest that the Python docs could use a more conversational, tutorial-like approach, in addition to the reference approach. I've found myself going to PyMOTW even recently because the docs.python.org content doesn't always cut it in terms of examples.
&gt; &gt; The straightforward way of doing this would be to declare one class inside the other. &gt; Not really. Nested classes are not used very often in Python, they're usually not useful at all. Hardly surprising, given that they don't work. &gt; &gt; But there doen't seem to be any way for this constructor to find out which outer class instance it was invoked on ! &gt; Good. Why would that horror happen? Consistency, simplicity and usefulness are horrors to you ? &gt; Well if it needs an instance you give it to him, that would seem sensible no? What exactly can give it to him ? You're not being very clear here. &gt; &gt; Writing a portable single-threaded program &gt; Like what's in threading or multiprocessing? 
I have noticed something interesting employing the package chardet. A particular html document declared UTF-8 encoding. However, chardet finds an ISO-8859 encoding, and the lxml parser gives me a far better result with this particular encoding. I can not access my code now. I will go to send you this snippet tomorrow.
kingkilr is correct; in fact I advocated for him to get +commit due to his pymotw series.
Yep, that's why I trust UnicodeDammit more (it uses chardet) and use that instead of lxml... In the end, I strip the encoding and decode the page with whatever encoding chardet/BeautifulSoup tells me.
I like it. Though it's more than I ever wanted to know about the internals of the python class system.
Enthought has a [Traits package](http://code.enthought.com/projects/traits/).
http://pypi.python.org/pypi/AddOns does something similar. 
Heh. That's not actually using anything "internal" to the class system. That's all well-documented, part-of-the-spec stuff. ;-)
PyLint is weaker in some other systems. It *will* catch most issues from undeclared variables. 
PyLint is certainly strong enough to catch most errors caused by not having to declare variables, which is on topic. Another perspective is that static analysis can find some bugs, testing, inspection, and run time analysis can find others. And that all of these have decreasing returns the more of them you use. If I can get the stupid bugs found by lint and still get a simple and flexible environment, I will be at a better place for many projects than a more comprehensive static constraint system. 
I agree on the false positives, at least you can check and ignore or suppress. Forcing people to declare variables creates some false positives also, where the code would be correct if only the requirement was not there. 
Yes.. from long time ago.. stioll the best gtk "distribution" is a gimp repackaging, dont seem to be an official distribution for wind. Gave up and moved to pyqt which is much more stable, and a nicer api, so thankful in a way.
&gt; So? So I was trying explaining the design decisions behind Python's variables. Not trying to assert any sort of subjective judgement upon which method of defining variables is "better." &gt; Right. Instead of having a single keyword to declare a name within a scope, you have two to try and coerce the language in not blowing up. I'm not sure how name resolution order can cause a language to "blow up." In fact, one of the few name resolution related errors in Python is what you responded to with "So?" above, so I believe I already covered the "blowing up" case fairly well. There are really far better things to argue about in language design than the decision to use a keyword to denote local scope or a keyword to denote global scope. That seems like an awfully inconsequential design decision to me. However, there may be some "blow up" case I'm missing.
Consider it a subtle hint concerning your choice of operating systems.
That sounds correct. But statements like those however &gt; All that speaks to is a lack in responsible programmers taking positions as employees and students in those organizations. are simply wrong (and sound condescending, hence the downvotes). One reason why Python is getting popular in universities is that it is easy to use (for students) in courses that have nothing to do with learning programming but need to have something implemented (i.e. a networking application). The other popular use of Python in universities is using it as a tool in research.
Because of that, it's why I prefer wxPython or PyQt.
Indeed.
&gt; Hardly surprising, given that they don't work. They work perfectly well. They just aren't special. They're classes. Same as all other classes. &gt; Consistency, simplicity and usefulness are horrors to you ? No, but it completely fails at the first two and it barely scratches the third one. &gt; What exactly can give it to him ? A method or function, what else?
&gt; To me, it seems natural for the class to go on the class Java has apparently broken you. &gt; So I've discovered, but I'm still puzzled as to why. Doesn't the fact that it's a callable attribute mean that by python's defined semantics, I should get an Outer instance reference ? No.
Yeah, but then you need the QT libs... *shudder*
Well, code that is incorrect because it does not compile is a much less severe problem than code that is not correct because it has some bug which will only be discovered when the code is executed.
&gt; Another perspective is that static analysis can find some bugs, testing, inspection, and run time analysis can find others. And that all of these have decreasing returns the more of them you use. This isn't really true. There is really no limit on what kind of bugs *aided* static analysis can find, and this is what a type system is. &gt; If I can get the stupid bugs found by lint and still get a simple and flexible environment, I will be at a better place for many projects than a more comprehensive static constraint system. pylint will miss many bugs that Haskell's type system will catch.
Do note that both core dumps and exceptions are runtime failures, and compile-time failures are much preferable in almost all circumstances. &gt; Consequently I don't mind handling those by people finding the problem at runtime and reporting it. Of course this is still far far worse than catching the bug at compile-time. &gt; In the case of typos, in sections of code that are not tested, you can use the various static analyzers. Yes, but no static analyzer of a dynamic language will be as good as a good static type system (e.g: Haskell's). &gt; My point was railing against the "if the tools/compilers are happy then the code must be right" crowd. There are bugs that get caught by human minds that the tools will never catch. Using tools/compilers is the very first step, but should not be the last one. The tools can be leveraged with modern techniques to catch more and more of the bugs at compile-time. For example, in Haskell you could use a simple Integer to represent Cals and KCals, but if you do choose to use the unit-wrapper, you will avoid this kind of bug at compile-time. More advanced type systems called "Dependant types" really have no limit at all on what can be specified, verified and guaranteed at compile-time. &gt; Python, Haskell etc will not be the last ever programming languages. The newer ones will build on the older ones. I'm hoping that they will draw something from both Python and Haskell. I think Python has many interesting ideas. I think Haskell has almost all of the interesting ideas from Python, and then more ideas. This of course has a disadvantage (There's more to learn about Haskell before using it seriously) but many advantages. IMO, the forefront of programming language research are dependently-typed languages. &gt; It makes the code longer (more lines) Usually a variable declaration is just a token, not a line. i.e: var x = 5 Instead of: x = 5 So it's pretty negligible. &gt; It is redundant - I indicate wanting the variables by actually using them It isn't really redundant in many cases, that's why Python has "nonlocal" and "global". But these are really awkward compared to simply specifying the variable scope in that particular scope. &gt; Having to declare introduces another class of issues (eg declaring ones you don't use) Fortunately these are trivial to catch in static analysis, and indeed they are caught.
Easier than java.. shivers.. :-)
pyqt is so much nicer than everything else I've tried.
n/2? Try sqrt(n).
The only thing I like about PyGtk is the API myself.
heh, I actually considered leaving it at n just to boost the performance difference between the interpreted and compiled versions ;-)
The installation is a pain and the result is not so good!
lol @ QT snobs. [ebuild R ] x11-libs/qt-core-4.6.2-r1 156,838 kB [ebuild U ] x11-libs/gtk+-2.20.1-r1 [2.18.9] 18,642 kB Explain!
I like the title, but examples in bash prompts (with $'s) might not be a universally wonderful idea. Especially for windows guys... Maybe that's part of the requisite hardship.
Spawning does not seem to be actively maintained now. [Gunicorn](http://reddit.com) can do the same and also works with eventlet (and gevent and even tornado).
Another similar library - [gevent](http://gevent.org). It uses libevent-dns to resolve DNS queries.
Some day someone will write the windows package manager. Some day.
He says the book teaches "attention to detail" on one page then tells you how to set up "OSX" on the next. Fail. Seriously, why do so many people get this wrong? Is it that hard to remember the name of a major OS?
If I had Guido's time machine, I would use it to go back and make it `x := 1` on first assignment and `x = 2` thereafter. It would be a nice, transparent way of setting the scope of variables without having to use keywords like `global` and `nonlocal`. 
A system I worked on recently had a bug where the estimated offer price was used for redemption estimates and the estimated bid price was used for contribution estimates, which is the wrong way around. If a system of types was developed to enforce correct use, (possible but complicated) the developer would just have enforced the wrong thing. There are limits on the bugs a type system can find. Analysis shows that the most expensive bugs are in requirements, and type systems don't find them. The language with an elaborate type system will make a developer think about, and enter a bunch of constraints, while a developer with a less sophisticated system could be doing a code walk through, writing unit tests, talking to users, or other things which may find more bugs. 
Read _Language Log_. _The Elements of Style_ is a terrible guide to written language style (they break a lot of their own rules, not all writing needs to be terse and active voice, etc., etc.), let alone code style. Downvotes for the both of you. :-)
So would it be Fail as well if he said WinXP or just XP? Or Linux?
Very cool! Some feedback: * It crashes if you provide no parameters (perhaps this is a conscious choice to keep the code small) * You could keep both `__name__ == "__main__"` and `target` in the same file, making it runnable both as a script and a compiled file.
&gt;In Python 3 it does, but not in previous versions No, it always has. It's just that there was no mechanism to tell it **not** to shadow, so that was the only option you got.
&gt; A system I worked on recently had a bug where the estimated offer price was used for redemption estimates and the estimated bid price was used for contribution estimates, which is the wrong way around. If a system of types was developed to enforce correct use, (possible but complicated) the developer would just have enforced the wrong thing. The type system enforces that code is correct with regard to a certain specification. If you get the specification wrong, you will still have bugs, of course, so it is not a panacea. But a specification is typically independent and separate from the implementation, and often much simpler and less implementation-dependent, so it's hard to get it wrong. &gt; There are limits on the bugs a type system can find. Analysis shows that the most expensive bugs are in requirements, and type systems don't find them. Can you cite any such analysis? In my experience the vast majority of bugs are implementation bugs and not specification bugs - especially not when there are written specifications/requirements. &gt; The language with an elaborate type system will make a developer think about, and enter a bunch of constraints, while a developer with a less sophisticated system could be doing a code walk through, writing unit tests, talking to users, or other things which may find more bugs. This is true when the type system is costing you time, as it does in C++ and Java. Haskell's type system is actually a time-saver, as the type system constraints often mean you write less code rather than more. It also aids in structuring the code, and makes deeper abstractions more practical and approachable. It also means you can write a lot less unit tests to cover much more grounds.
If I'm doing Linux only I stick with PyGTK+, but if Windows is even a possibility I go with wxPython.
8% market share is hardly 'major OS' territory. Wake me when they wrangle a quarter, maybe? 
###### ITS GNU/LINUX AND IF YOU DARE SAY OTHERWISE YOU ARE A DOLT AND A FAILURE AS A HUMAN BEING
Original poster here. Thanks! :)
What an excellent tool this is :)
1. GTK+ is a GUI framework. Qt is a general purpose framework for everything. It has its own sockets and strings and ... 2. GTK+ is written in C. Qt is written in C++.
I think he was bitching about "OSX" instead of "OS X".
Yes, it's a big pain on Windows, and even worse on MacOS. (Unless you use a package manager like Fink or MacPorts to do it for you.) Note that the PyGI introspection stuff has been merged into PyGObject, and this has been blessed as the road forward for Python GTK / Gnome bindings. That should simplify things, as we'll only need PyGObject not both PyGObject and PyGTK.
Glib (non-UI part of GTK) only adds another 16MB. C vs C++ shouldn't matter much. We're talking a 5 fold difference. QT-core is the largest package on my system and I've been battling for years to remove any software that depends on it. edit: just did some more research. QT-core doesn't even include the UI portions, so I should be comparing Glib with QT-core, and GTK+ with QT-gui. This makes the situation even more ridiculous. 
Have you tried PySide? PyQt is still GPL while PySide is LGPL. And PySide claims they have Python 3 support coming soon, and it's been made to work in PyPy. (I haven't touched anything Qt in years. I mean to take a serious look at PySide sometime soon.)
Contact him and let him know. I'm sure Zed Shaw would love the chance to rant about your comment.
I would call Yahoo a major search engine even if it is a ball of fail.
$ prompts are probably the greatest common denominator, though. I've written some documentation that users of all OS'es will see and I tend to explain Windows first, then Mac/Linux, then before I move on from there I state that the rest of the doc will use the Mac/Linux way. Maybe this should be explicitly explained*, but I don't see anything wrong with keeping the prompts that way. \* I just quickly scanned the doc, might have missed said explanation.
http://github.com/rtyler/Spawning/ Last commit is July 18. What makes you think it's not maintained?
Personally I would say forget it and look at wxPython. It's very easy to use (imo) and I've yet to have an issue on windows or linux regarding its installation.
Maybe there could be a CSS/javascript button to replace all the $'s with c:\\&gt;
Isn't there a wiki?
I use PyQt myself, but I just wanted to test out the GTK backend for Matplotlib.
Oh fer chrissake. I AM a linguist. And I was simply making a jocular point; in no sense of that comment can you read it as though I'm a Strunk &amp; White fan. I just thought the parent of my comment was making a clever juxtaposition that I found amusing. Good grief, you can't say *anything* around here without getting shot down ;)
PySide doesn't have Windows support yet though, and PyQt already supports Python 3.1.
You know Qt doesn't just do GUI, right?
For those who are interested in a backstory and discussion on this and Zed - http://www.reddit.com/r/programming/comments/bv9gt/
I found that earlier, but isn't the same kind of traits as referred to in the article. The traits in the article are (being really facile) basically mixins that are statically checked to make sure they don't collide. The traits in Enthought's package seem to be a way to make class properties with slightly different semantics than usual, useful in particular for UI stuff.
Page 93: "Every if-statement must have an else. If this else statement should never be run, ... use a die function that prints an error and exits" what? are asserts too hard for the hard way?
looks a lot worse than what greenlet and stackless already provide without unnecessary syntax changes
I guess asserts are too easy for the hard way. Maybe he doesn't like asserts because they're turned off by -O?
Thread on py-ideas: http://markmail.org/thread/t77cxvuhtlu7vkdh
Yes it is an issue. But we like it that way. Now get off my lawn! :-) (Although I would love to have Pyflakes in IDLE with the standard install)
Using CPython as a reference, what can't Shed Skin do yet?
The Zope Component Architecture does allow one to detach roles from classes using adaptation. These are not traits as described, because the hooking up of adapter to object occurs during run-time instead of during compile-tile, but you can solve some similar issues with this (and different ones). You can for instance add "save" adapters for the particular model classes in your application. 
Because it's a high level language...that's it.
Because it's a high-level language...that's it.
but I can't possibly think of putting a mandatory else for every if. especially for cases like: def f( x ): if x == 0: # return on invalid inputs return do_work( x ) and other cases which do not require an else clause
You started out with Python in the past few months? 
I love the direction he's taking with this. It's almost a godsend. *But* I hate the title. I wish he would change it. Oh, how I wish he would. It's nearly a showstopper for teaching. It seems smart and clever. But I teach a lot of people who think Python/computers are scary and hard. I have to **hide the title** from them or they won't even look at the tutorial or document. They are like "whoah, no, this is just too hard for me". I didn't realize it until I suggested someone try it and they gave that kind of resistant reaction. Such a terrible idea to name a teaching book that-- quirky and cool to us programmers, but terrifying to people used to "Python for Dummies". Coding is already scary enough as it is to non-techies. I think the contents are going the right way, but please come up with a quirky but non-scary title for true programming beginners.
Thanks, yeah, that's just me trying to keep the example small. It does show one drawback about the compiled program though - it just crashes instead of throwing a nice IndexError.
Absolutely, especially if you let it go poking around to load site.py, fiddle with its environment etc. Consider: $ time python -c "pass" real 0m0.015s user 0m0.012s sys 0m0.000s Versus (no site.py, no env vars, no writing bytecode files): $ time python -sSEB -c "pass" real 0m0.006s user 0m0.000s sys 0m0.004s Still, reducing the startup overhead could on its own be a valid reason to compile down to a native executable.
It's the GTK part of the equation which is tedious. Win32 is something of a second-class citizen when it comes to GTK. You can use the full bundle and just delete all the .a and .h and PO files and so on, or you can do the dependency dance as you've already found. I maintain a cross-platform pygtk program for our organization, my GTK runtime dir is about 16 MB, which is really unfortunate, but GTK was designed to sit on top of a *nix stack which already has libjpeg and that sort of thing, so there is a lot of duplication of effort on win32. And you really were trying to get all the anti-GTK people to come out of the woodwork weren't you? I hope an apology is forthcoming.
\o/
It's a take on a Perl book of a similar title. And really shouldn't they trust you enough to take your word for it when you say this is a good book?
Interesting question shoot him an email asking about it I'm sure he will be happy to explain. Or if you aren't interested in asking him I could on your behalf. 
I don't see what prevents the PyGTK/GTK people from wrapping up all the dependencies into one .exe (like the PyQt, WxWindows, etc. folks do). They could probably automate most of the process so it wouldn't be too much work with future releases. Judging by some of the comments here, PyGTK would be a lot more popular if the installation process was just a bit easier. And for the record, I wasn't trying to incite any GTK bashing. I was just surprised at how far behind they were lagging in these regards.
I was expecting the text to be faithful to the title. 1. Type Theory: Duck Typing and the calculus of constraints 2. Garbage collection models and memoization through weak-value referencing 3. Formal lambda calculus to Python equivalency proofs 4. (Forth) VM analysis roundup or "Why Pythons make Smalltalk over Java and V8" And then have the text be Title, Abstract, Theory/Lemma/Proof, Theory/Lemma/Proof, Conclusion, Exercises. Have you solved all 23 Hilbert problems on the back of a napkin but can't be bothered to find a damn stamp or make out an envelope? Do you quip "MIT? More like MIJC"? This is the book for you, my friend.
You want to shoot Zed and email telling him to explain himself? I don't expect we'll see you again.
If he said WindowsXP or Windows X.P., then yes, that would be a fail as well. WinXP is an abbreviation, and so not a fail. 
Does it compile to an executable without any dependencies?
First rule of the internet: there's always a bigger pedant. ;-D
I think that part of the idea is to make it easier to write things like stackless and greenlet without having to DIY the trampolines, etc. that you'll need to get things working. PJE isn't the one doing this PEP, but he wrote a pretty good defense of some of the ideas behind it: http://mail.python.org/pipermail/python-dev/2010-August/102648.html Personally, I haven't been superimpressed with the proposal's necessity so far, but it looks like it has a better than even chance of getting accepted by Guido, so if you have a complaint, now's the time to air it on python-ideas.
Is this your homework or something?
Aren't we all.
Yes, it's a completely stand-alone executable. Its only dependency is libc.
On August 9th? I don't think so. College freshman, teaching myself a new language.
Please write this.
[P!=NP](http://www.scribd.com/mobile/documents/35539144) ಠ_ಠ
Take an off-the-shelf ILP solver, such as lp_solve http://lpsolve.sourceforge.net/5.5/Python.htm You basically encode the solution constraints into (in)equalities over problem variables, and express the quantity to be optimized as a linear combination of the problem variables. For most combinatorial problems, using an ILP solver is a better use of your time than coding your own optimization algorithm. (And you need to be quite good to be able to tackle those that ILP can't give you).
I wish I could. To be honest, "Duck Typing and the calculus of constraints" sounds like something of enrapturing interest. And a comparative analysis of VM architectures? Where do I sign up for this?!
couldnt agree more... and tried almost all of them in tcl/tk.. and in my environment at the moment and lots of different gui+testing equipment+sensors.. its brilliant. Am updating all my clients applications via svn up or tortoise, no reinstall etc. Works a dream..
Well then, you're going to find that being in CS involves a lot more than programming. 
Actually every time I have emailed him and asked him an honest question he has been more than kind. He just doesn't tolerate fools or people who attack him in some stupid epeen measuring contest. I will shoot him an email and report back. 
Sorry, not sure I understand you. You are implying I should attempt to figure out my own algo for it? Maybe I should, although that wasn't my original goal. Suppose it would still be a useful exercise. 
What I mean is that the Travelling Salesman problem is a classic example of a problem that is (usually) too difficult to solve. The gist of it is that, in the generic case, there is no known way to efficiently verify if a given answer you found is optimal. In essence, you have to sort through all possible paths in order to conclusively provide an answer. Of course, there are probabilistic solutions that give answers that are good, but these solutions could never be verified as being correct without going through an exhaustive search. In CS, you occasionally run up against problems that are so difficult that finding an provably correct solution for them is hopeless. The amount of time required to solve them increases very very quickly as the problem gets larger. One such subset of hard problems is the set of NP-Hard problems, to which this problem belongs. 
I understand. Hence viadley's references to P!=NP below. So there is no algorithm out there that can efficiently solve TSP, instead they must rely on brute forcing it. Does the fact that someone recently maybe proved P!=NP mean that there could from his work be derived a solution to TSP?
&gt; But I teach a lot of people Can I ask you what format is your teaching ? is it private training class or college class setting ? 
I don't think P!=NP has been proven recently. If it has, both my CS and Math departments would throw a week long party. I assume you're referring to the 'serious attempt' at the proof that I recently saw on reddit and ignored. If it's a serious proof, that's awesome, but it would have to be *very* carefully read before it was accepted. The problem is a long way from being solved, even if the proof is valid. Also P!=NP would not require a constructive proof. In other words, proving P!=NP would require just to show that there exists such an algorithm, not providing it. Of course, they could provide a constructive proof and get the Fields medal twelve years in a row, who knows? 
*I* understand the reasoning, etc. That doesn't change its effect. They trust me, but it's already an uphill battle of me reassuring them. I want them starting out optimistic believing that it's easier than they think. When I put this in front of them, it hurts my credibility and their confidence. I have to explain that the title is more of a joke, but I don't need that distracting from a good lesson. Why start them out doubting themselves?
In person I tutor high schoolers and some curious adults 1-on-1. The adults are primarily people that want to code, are absolutely smart enough to do it, and also don't believe they could ever learn. I'm using Python to show them that they really can. I also am heavily involved in a global gaming community that has "tricked" thousands of teenagers and ol' fogies into trying their hand at Python to customize games. We've had dozens of people get into university with the code they wrote, etc. People who never would have coded before are now getting degrees in CompSci. I've been looking for a much better resource to get them started to jack up the adoption rate. I've been so excited about this project. I had one of my students actually write up their experience with this book in its early days. They got completely destroyed the first time floating point numbers are mentioned-- what the hell is a "floating point" number to someone who hasn't coded before? And "google it" (the answer in the book at the time) isn't a good answer the first time you see this word. After Zed's response to my concerns about the title, I'm hesitant to submit the usability feedback I got because I seriously doubt it will be taken seriously. He's probably not really aiming to train newbies-- I fear it's going to do what the other books have done and ditch the non-programmers half-way.
Are you me? &lt;3 if so I love us. I'm doing the same thing but varying what I learn in the morning. I am a night owl so reddit helped me out with a caffeine wake up/ reboot. I can't find the original thread but http://lifehacker.com/306029/reboot-your-brain-with-a-caffeine-nap is very similar. Just have some caffeinated beverage on the night stand set your alarm up with a 15 minute snooze wake up enough to down the cup of joe or whatever you choose ( I used cold coffee) and hit snooze. When you wake up you are READY to learn. Btw I book marked your blog kudos for plugging away at something. 
wow nice work you're doing for the newbies and Python community! you're like freakin mother theresa
Well then just edit the pdf make sure to attribute it to zed and change the title to something like "The idiots guide to python for people with low self esteem who are easily discouraged". I jest, at least you are trying to expand other peoples horizons. In my own experience if people don't fall in love with programming on their own they will probably never be very good so you may be wasting your time. Still if it is wasted time it's wasted in a good cause so I wish you luck. 
I find it difficult to just learn a language without having a specific project or goal in mind. Figure out what you want to use Python for and then learn what's necessary to complete the task.
so this book is intended for people with no programming experience ?
Holy fucking Comic Sans (http://klappnase.bubble.org/TkinterTreectrl/index.html).
Learn other languages or learn other parts of programming. Learn to use Django and make a web application. In the process of doing that learn javascript and how to do cool ajax stuff. In the end though, you have to find something you want to do, or something that you feel needs to be done, and then work on it. Ask for help if you get stuck, but a goal is the best way to push yourself ahead.
search sourceforge etc for an open-source project coded (primarily) in python, and start contributing bug-fixes.
I'm fairly entry level myself, but my rule of thumb is that if it takes more than about 20 lines of shell scripts, it's probably better to build something in Python. So, I use it for stuff at work. As I'm a network engineer, I write things that interface with routers and firewalls and such. I wrote a script that logs into our devices and backups the config, and then turns around an posts it to a wiki for easy web based version control. I wrote a CGI interface to LDAP password resets. A few SNMP based scripts. Bandwidth monitoring. Redundant firewall failover checking. etc. A mini script for determining what a reverse DNS entry for IPv6 should look like. Also, I have the PyPi RSS feed in Google Reader. I look through that every day for projects that I can build something off of. So, I guess my advice would be to "scratch an itch".
I emailed Zed and asked him the same question you posted. His response was lengthy because he actually had good technical reasons for explaining things that way. It was a bit too long for a Reddit post but it made very good sense to me and it could really help someone else who is learning to program so I paste binned it. You can read the whole thing here. http://ubuntu.pastebin.com/raw.php?i=hX6zjgBD Cheer up gloomy sometimes people and things are better than expected :D. 
Agreed. Why don't just use stackless or greenlet?
Sounds good, but how does this compare to Learn Python the Tedious Way and Learn Python the Painful Way?
Yep, finding a project to do is what gets me learning something.
It's rather unfortunate that the term "traits" was used for this. That's why when Perl decided to name them "roles" (because the word "trait" was already in use for Perl 6), I was quite happy. It's much easier to search for and discuss without confusing people.
hrm, didn't know about this github repo. seems that I was wrong.
I don't see the need for this new feature. What is the real additional value to the language? What can't be done today without this PEP? On the other hand: What's the downside to have this feature? It blows up the language (as all other not really necessary new features do) and is for my understanding not pythonic and not very nice to read and understand, especially that cocall statement. Somehow that whole thing doesn't fit to my understanding of the simplicity and elegance of pyhton (but that's of course a very personal view).
&gt; I wrote a CGI interface to LDAP password resets. I did that too with Django and python-ldap. lusers, amirite?
Django is probably the fastest way to start "doing" stuff. the JS/CSS is the hard part :/
OSQA is the open source Q&amp;A system. It is more than just an FAQ page, it is a full-featured Q&amp;A community. Users earn points and badges for useful participation, and everyone in the community wins. 
[Python for Fun: Colection of lessons aimed at intermediate programmers:](http://openbookproject.net/py4fun/index.html)
More often than not, removing reassignments makes for better code. It's the second case that should be the ugly one.
All those strikeouts makes the reading terrible
I think he just doesn't get the point and vision of Python
Its because people are using generators for things that they were never really intended for namely threaded in-line call backs. It would be cleaner to separate this functionality into something new.
Yep! SSH and passwd was too hard. :) And then I had to create a function to scramble a password and email it to users that really got things screwed up.
tl;dr - This whole "roles" shenanigans is an inheritance-encapsulation hybrid with some semantic sugar. You can do multiple inheritance and decide to rename and/or exclude some methods. That way you get a more customizable and flexible way to reuse code. That's all.
That makes a lot of sense when you take the actual error message into account. Thanks.
They are now gone. I have substantially rewritten the post in light of reader comments.
Ian Bicking has a [blog post about something the Dutch call "Woonref"](http://blog.ianbicking.org/2009/01/16/woonerf-and-python/). The idea is that when you have less mindless guides like variable declaration, you have to pay closer attention, and so in the end you are more mindful and do better work. That has certainly been my experience.
Got a video?
No problem :-) I've been doing ruby on rails development recently, and seeing posts like this makes me miss python ALOT. good luck!
i do use them
on a sidenote - one can implement yield and yield from in terms of greenlet/stackless and without the need for extra keywords, one can't the other way around
Thanks :)
Summarizing README.html, which annoyingly doesn't seem to be on the web: You can't change the type of a variable. You can't mix variables of different types in a collection. You can't use reflection, arbitrary-size math, variable numbers of arguments, keyword arguments, multiple inheritence, nested functions or classes, unicode, inheriting from most builtins, __call__, or closures. You can't pass method references. And a bunch of standard library modules are incomplete or missing. So you need to port your code to Shedskin, rather than expecting it to compile existing Python code. So it's more like Cython than like PyPy.
If you don't want to roll your own, Twisted has custom reactors for several GUI libraries that handle this problem for you.
I think it's a great title. I've learned that any book that promises to make hard things easy or get them done in 24 hours is crap. So by admitting that it's going to be hard, the author gains some trust. Then he tells me that if I already know how to program, I'll hate his book. And it's true. So he got even more trust. I'm going to try this book on my kid in a couple of years. (She's 8, and not ready.)
The second one doesn't sound too bad. I might just write a comparison of VM architectures for the Python world :)
Thanks. I read his response. It's legit for when you first start your way to programming, but I can't feel it holds in real life projects. There are better methods. Asserts and unit tests, etc. But I guess that if you just begin, it's valid to help you understand what went wrong.
see stackless/greenlet
Cool. Zed is really a great person if you get to know him instead of his persona. 
In other words: it can't do anything that makes python awesome
Thanks for finding that, I've been meaning to look for some roles type packages for python and try them out. Of those two, i'm leaning towards roles since it seems simpler and more flexible, maybe there are features I want missing though?. I like the way strait manages method name collisions. If anyone has used either of these for real I would appreciate a recommendation as well.
Last time I used Tkinter it was butt ugly. Have they fixed that?
Mention the nightmare of installing 3rd party binary stuff like Matplotlib once you touched your installation.
&gt; the decision to use the greenlet library instead of generators for the basis of Diesel was, practically, the right call. *puts on sunglasses*
Stackless will never be merged into CPython. Guido thinks it's too complicated. So it's a pain to distribute software that relies on Stackless, because nobody but other Stackless nerds has it on his computer. If your code only has to run on boxes you control, no problem, but some people who don't have that luxury would also like to use coroutines.
Nice article, but I used to use PyLucene and I would recommend to anyone that they first consider Lucene-Java. Once you get beyond the basic the performance of Java over Python really makes a noticeable difference. I have a better experience using Solr's REST API than using PyLucene in a web application. That said, you can really do some cool stuff with minimal effort with PyLucene (minus the install and setup which can be a bit tricky or at least it was when I used it). In addition, the lucene-java community is very active and it's easier to interact with them when you are using the Java interface. Bottom line: Start with Solr, it opens up tons of doors (super easy replication, clustering, etc) and you won't regret it.
Yeah, this cocall/codef stuff actually makes me want to retroactively retract my tentative support for PEP 380. ;-)
You may as well submit the feedback, then the ball is in his court... best outcome it helps the community, worst nothing happens at all. 
Well, Cython allows to port incrementally, at least most of the stuff. What's more interesting to me: how does Shedskin play together with CPython? 
I think GTK people think the layered nature of the framework is a feature. You can use glib without GTK+, or glib and GTK+ but not Gnome, etc. Note the guy upthread whining about the size of a Qt install. That's a cost of putting everything in one big library rather than splitting it up. (Okay, actually Qt is bigger than all the GTK bits put together, but an advantage of splitting it up is that if you really only want glib you can just use glib.) Of course, the cost of splitting it up is that you have to install all the bits separately. This is trivial if you have a decent package manager that handles dependencies, but Windows still lacks one, so... And of course the people who do most of the work on GTK don't run Windows, and the Windows users who are unhappy with the situation tend to whine instead of pitching in, so the problems remain.
Totally agree. It also solves the variable = 1 if something: varaible = 2 print variable problem. OK, so there are many other ways around this, such as "well, don't do that then", but still, it'd be nice if the language supported it. 
Actually, further to that, I'd love "x = 2" to be syntactic sugar for x.__set__(2) or similar. This would give you a sneaky way of having slightly firm typing, because x := ComplicatedSomethingClass() #... x = 7 would then (potentially) be an error, and y := Complex(1,2) # ... y = 7 ... could potentially end up with y being equal to Complex(7,0) if you see what I mean.
not every developer has the option of making use of additional binaries. 
I can recommend PyInstaller, too. I recently used it to create a standalone package utilizing Matplotlib and wxPython. Considering I never used a python to binary converter before, the procedure was painless and straightforward for both Linux and Windows. Regarding the problems with Python 2.6 on windows mentioned in the arcticle, I can say that there was only one extra package to be installed and the problem was solved. 
yes, but adding stackless/greenlet to python would do better than inventing codef and other pains
BGP @ ~ 31:00 !!!!!!!!!!
[No](http://klappnase.bubble.org/TkinterTreectrl/screenshots.html).
To make your test suite run faster, rather than looking to improve Python performance, you can write more unit tests and use functional tests slightly less (although it's obviously still required).
thanks God.
That was long, but interesting enough to make it worthwhile.
The slides are available here: http://www.scribd.com/doc/35240506/Making-Python-Fast-PyPy-and-Unladen-Swallow
I understand you pain. These links may help if you are connecting to MySQL: http://www.devshed.com/c/a/Python/Database-Programming-in-Python-Accessing-MySQL/ http://www.tutorialspoint.com/python/python_database_access.htm http://www.kitebird.com/articles/pydbapi.html Good Luck 
For database-bound testing, try making your test database engine never commit data to disk. For sqlite, use the magic database `:memory:`.
Considering that line-for-line, functional tests test more, I'm not sure that's a good idea. Ideally you're after total coverage, but in practice you're looking for whatever gives you the most bang for your effort.
I bet I could write 100 functional tests.
When you see `time.sleep` in event loop code, you can tell someone's doing it wrong.
I dunno. There's a bit of weird logic in "my tests take too long to run conveniently by several orders of magnitude because they're all functional tests. The solution is to integrate a JIT so that,. when run unchanged, they take fewer orders of magnitude longer than is appropriate". A maybe more balanced thing to say might be, "My tests take too long because they're all functional tests. These tests overe here don't *really* need to be functional, they're only functional because I just cut and pasted the ones before it, so let me undo that. &lt;lather rinse repeat&gt;". And only when you had done that for all existing tests look to rising tide optimizations like interpreter speedups to bail you out. 
Thank you so so much.
I suppose. The nice thing about a JIT is that it's a one-time investment: some small team of experts somewhere builds it, and magically everyone else's (CPU-bound) code works faster with zero effort. That's some impressive effort magnification right there. If a JIT gets you acceptable performance with no effort on your part, I'd argue that's a win, otherwise we could just go back to writing everything in assembly. :)
This answer is very good, but I'd like to add that playing with sqlite3 is quite easy and can be quite powerful. It will give you a nice sandbox to poke and prod the DBAPI. The documentation from the standard library is quite pragmatic: http://docs.python.org/library/sqlite3.html
This requires more attention!
It depends. If your tests *still* take too long to run with the JIT in place, then I think it's time to actually think.
I think the latest idea of just making it a decorator is better than the idea of making it a keyword, so maybe that's what will happen. 
I think we're in agreement then. :)
Haha! I was there.
Oh wise sage who spouts criticism and hints at vast troves of superior secret knowledge, please enlighten a pitiful peasant. Surely if you could spare the keystrokes for `proper formating` it would be within your generosity to also provide a key phrase for use at the Oracle of Searching or the Shop of Cheese.
[Somewhat, yes](http://code.google.com/p/python-ttk/wiki/Screenshots).
http://twistedmatrix.com/ (More specifically: if you're using gtk, use `timeout_add` and/or `io_add_watch` and let gtk manage the event loop, calling your other code at intervals or when data arrives, as appropriate. This is what Twisted does.)
Thank you. Though I don't think that one line is bad enough to warrent installing another 34MB. Sleeping is crude but it perfectly effective for limiting the max update rate. Even on my slowest processor, polling a hundred times a second incurs a mere 1% CPU penalty. I will look into those other two, but it is rare that I am using Gtk at all. The benefit would have to be fairly significant to make up for lost portability and simplicity.
For something like a game event loop where you're only processing keyboard/mouse events and throwing frames on the screen, sure. When you want to do something more complicated, you need to use OS-provided event sources like select/epoll/kqueue, etc. (which, not coincidentally, gtk does. :)
We've been using shedskin for transparent integration of computationally intensive parts of our application. We have a package were the core algorithms live as shedskin-compatible py files. Our setup checks whether shedskin is installed on the system - if it is, we run it on top of our algorithms and generate cpython compatible extension code and compile it, so that when we from algorithms import slowthing we either get the original slowthing.py (in case there was no shedskin) or we get the compiled extension slowthing.so (as an extension with the same name precedes a py file). Worked out pretty well for us. Edit: For us, combining cpython and shedskin was perfect for showing and using the potential speedups of a compiled extension with an effort of maybe 1-2 hours setup on build and production server and team workstations and a few hours untangling the key algorithms from the original code (which we had to do anyways, so that wasn't an issue) and testing how shedskin performs with different kinds of input formats i.e. dicts vs lists of tuples.
Before somebody complains. This is an addition to, not a replacement for, possible many2many implementations using link table and (outer|inner) join.
Nice but a bit verbose. The entire code can be rewritten as Model: db.define_table('posts', Field('title',unique=True), Field('content', 'text',notnull=True), Field('author', db.auth_user, default=auth.user_id,writable=False), Field('post_date', 'datetime', default=request.now, writable=False)) Controller: def index(): return dict(posts = db().select(db.posts.ALL)) @auth.requires_login() def new(): return dict(form = crud.create(db.posts,message='Post saved',next='index')) You could also support [MARKMIN wiki syntax](http://www.web2py.com/examples/static/markmin.html) simply by replacing &lt;dd&gt;{{=post.content}}&lt;/dd&gt; with &lt;dd&gt;{{=MARKMIN(post.content)}}&lt;/dd&gt; EDIT: I saw the online version and it shows the actions in the menu. The code does not show how you do that. You must have somewhere the code to add the two actions to the menu. It could be: response.menu = [['Posts',False,URL('posts','index')],['New Post',False,URL('posts','new')]] 
that s awesome addition!
dont use django on appengine! it's nice to setup it up. the real trouble is getting stuff to work. even the flatpages that comes with all django doesn't work on appengine. use something that has been written for non-relational dbs or django-nonrel...
I know right?? I only posted this video to point out that I am in the background, and then people start arguing about JIT
He is using django-nonrel. 
How old is this guy?
it seems sinatra or web.py inspired :) that s nice
I love the sound of this conference name: PyOhio. Pie-O High-O. It's fun.
`19`.
Because sending email using Python is [not simple](http://code.activestate.com/recipes/576858/).
Anything that simplifies email is great. Email is such a mess.
Check your RAM and hardware for issues. User space programs *should not* be able to cause a BSOD.
and if it is, I want a copy of your script...for science.
Email in Python is dead simple compared to JavaMail. 
I agree. And every server is different. Plus many server block certain ports in an attempt to combat spam. Very inconvenient.
After 7 years I'm not surprised that it has developed a hardware fault, especially a laptop. Try running memtest86+ to find the error.
Cannot do the gmail authentication, can it?
Is this code available anywhere?
This is a confusing name given that RPy is the package to interface with the R statistical environment.
You monster
*sigh* Only ten more years and everyone will understand what unicode is.
Accurate username...
I wasn't really talking about you, just the fact that confusion and arguments still happen.
Well, this particular case isn't about confusion, it's about lxml refusing to accept previously-decoded content, really...
The source on [bitbucket](http://bitbucket.org/ginstrom/mailer) does handle gmail.
I'm the author of the mailer package. The code is on [bitbucket](http://bitbucket.org/ginstrom/mailer), and I'm happy to give commit privileges to anyone who wants to contribute.
Nice. I'll bookmark this
There are no open issues; what would you like contributed?
 from django.core.mail import send_mail
Well done on this package. I've got a nasty email class I hacked up to simplify things for my company's internal scripts (the API is actually reasonably similar to this), and I'm reasonably glad to see the back of it (differing version with each deployed package, arghhhhhh). That said, I'll fork yours and see if there's anything I can add to your source :); we occasionally need to mail all our customers (things like bills etc.) so I've got some semi-decent code for dealing with persistent connections to the SMTP server.
Your OS vendor has [good advice](http://msdn.microsoft.com/en-us/library/ms854944.aspx): &gt; This Stop message indicates that the requested page of kernel data from the paging file could not be read into memory. This Stop message is usually caused by a bad block (sector) in a paging file, a virus, a disk controller error, or failing RAM. In rare cases, it is caused when nonpaged pool resources run out. It is also caused by defective hardware.
this battery NEEDS to be included.
You do realize that the "random side-effect" is a NameError which is not random at all?
Leaking list comprehensions are considered a bug, they only exist in 2.x for backwards compatibility, 3.x changed that.
Consider this (a bit convoluted but legit): `def all_even(*numbers): """Returns True if all elements of the 'numbers' array are even""" my_var = True for i in numbers: if i % 2 == 1: # Oops, I meant my_var!!! my_var1 = False break return my_var Try `print all_even(3,4)` for effect. See the problem? If variables had to be declared, there is *no way* the code would work. Function provided free of `UnboundLocalError` errors.
Interesting 
Sorry Martin already posted that in /r/bioinformatics =) Have an upvote anyway and your first orange-red.
I was referring to goings on elsewhere in this thread. And yes, lxml—evils! Peril!
I try to write everything in Python 3 nowadays but I don't have any big apps that I'm converting any time soon.
I just gave a quick talk last night at a [ChiPy](http://www.chipy.org) meeting about porting to Python 3 and a doc that I wrote (I'll get to that later), and someone asked me the question of "what was the biggest headache you encountered?" Maybe I'm just writing boring code, but the answer was "nothing, really". I got off easy because the code I ported was an internal tool suite for work (automated functional, performance, and load testing of a historical trade data server) which runs on whatever version(s) of Python I say, so my range of supported versions is very small - 2.6 to 3.1, although I don't think any of the boxes use 2.6 anymore. I could just drop 2.x completely, but if I ever need to interact with code from other teams around the company it'll be 2.x, so I'll keep that compatibility in there for a while. I've also been lucky because my dependency list is incredibly small: [pywin32](http://sourceforge.net/projects/pywin32/) (which supported Python 3 right out of the gate) and [wmi](http://timgolden.me.uk/python/wmi/index.html) (also an early supporter of Python 3). Anyways, for those looking to port to Python 3, I have a guide in the works for the PSF Sprints organization at http://docs.pythonsprints.com/python3_porting/py-porting.html. The doc isn't complete yet (it's missing strings/bytes, sorry), but it might be helpful to anyone interested in porting.
&gt; Porting C source files is much trickier than .py files. The changes made to the C API in Python aren't documented. Do you remember specifically where you saw issues with C porting? The extensions I ported were fairly dumb -- they do next to nothing besides being the thinnest wrapper to a C++ API possible. Because of that, I just had a very simple bytes/string conversion function that would do the right thing on 2 or 3, and the module initialization #ifdef dance. After I finish the guide I [mentioned earlier](http://www.reddit.com/r/Python/comments/d0p7e/port_to_python_3_complete_advice_sharing_thread/c0wonod) I'm going to be writing a C extension porting guide, and I'd love to know where you ran into any hiccups.
The reason why I say porting C code is tricky is precisely because of the lack of documentation (so you're not too sure what to do). A documentation like what you're planning on writing would be of enormous help. The particular problems I had were only those I mentioned. The `PyObject_CallMethodObjArgs` problem and the `char *` --&gt; `wchar_t *` problem (it took a while before I noticed the signature change in the python docs). This was for `Py_SetPythonHome` and `Py_SetProgramName`.
Great tips. The one thing holding me back is WSGI consistency; I'd like the standard and associated libraries (i.e., Werkzeug) to settle down before I commit to it. I heavily researched going to Python 3 for a project I started this week, and, well, WSGI. Any advice for diving into 3 for WSGI apps? Is Werkzeug the benchmark for readiness that everyone else is waiting on, too?
Why do people down vote an OSS project's announcement of better support for the GAE environment... I would think people would want to see more of this... 
No. The idea was a fresh start, to be able to fix those things that couldn't be fixed and still be backwards compatible. Don't worry, 2.7 will be around for years and years.
Here are some things I have run into. Some modules that used to take str now require bytes. That's fine much of the time, but not when using string literals. The string literals require the use of the b prefix (b""), which is not valid Python 2 (except 2.7). For me, the problem was mostly in the struct module, where formatting requires bytes. If possible, move your code base to Python 2.7 where you can use the b prefix for forward compatibility. The mmap module now returns ints when indexed (not sliced), just like the bytes type. If you want that behavior in Python 2, you must use ord(). 2to3 doesn't know this, so it doesn't remove ord. Remove as needed. Also, the reverse of ord (chr) returns a Python 3 str object, not bytes. I'm not sure how to efficiently get bytes instead (instead of calls to encode()). The zipfile module returns str in Python 2, bytes in Python 3. Python 2 str will successfully compare with unicode as expected. Python 3 bytes == str will silently return False... always. Make sure to use decode() as needed.
No. Some things can't be fixed without incompatibilities, but it should be very easy to write pure Python code that works on both 2.7 and 3.1. Also Python has never been 100% backward compatible. You could have a program with a variable named "with" in Python 2.1 that would fail in Python 2.7.
Looks really good
bytes([1,2,3,4]) Should work for any iterable object that only returns ints.
this is really great one!, I will migrate my blog ( now wordpress ) to this running on gae.
&gt; The string literals require the use of the b prefix (b""), which is not valid Python 2 (except 2.7). Bytes literals were added to the 2.x series in 2.6. &gt; Also, the reverse of ord (chr) returns a Python 3 str object, not bytes. I'm not sure how to efficiently get bytes instead (instead of calls to encode()). The bytes equivalent of chr(c) in Python 3 is bytes([c]).
Heck yes! Keep up the good work on this! I look forward to seeing a stable release.
Neat, but... **"Unimplemented features: module imports"** ...not very useful yet.
&gt; The bytes equivalent of chr(c) in Python 3 is bytes([c]). Oh, I didn't realize that that was the preferred method.
&gt; Someone please explain the logic behind the python community's decision to make it this way? This isn't exactly hidden knowledge.
It's hidden to ME. You're not talking to a faceless name on the internet, you're talking to ME. oh wait
You don't have access go Google|Yahoo|Bing ?
I guess googling is an art, and that makes me a philistine. I googled python backward compatible why etc, and couldn't find any reasoning behind it. 
Looks interesting. Accessible only for Spanish speakers (or if you're willing to go through it with something like Google translate)
As soon as you run the test suite, which is before comitting, it will fail and you can fix the issue. I really don't see the problem here.
Google does a good job in this case too, or at least it's readable... Maybe if this magazine has enough interest some humans could get to translating it. :)
Nice! I've skimmed through it (Spanish speaker here) and it looks quite promising. Also, TIL what a decorator is.
If anyone's interested contact us at revistapyar@netmanagers.com.ar, even translating individual articles is useful and I'll get them published :-)
You should try and get a .py domain too, 'cause that would be awesome. Do you have any paraguayan pythonistas involved? :)
No, but I do have a friend who's a paraguayan php nerd so I can try :-)
So? Having to declare your variables is a "protect programmer against themselves", where you get more reliability and more readability in exchange for a tiny bit of verbosity. You could toss out a number of Python features because "well, it will fail and you can fix the issue anyway". Besides, not all programs have test suites, unfortunately.
That would be great since Python Magazine is dead.
C'mon guys don't be so difficult. Here's the original PEP for Python 3: http://www.python.org/dev/peps/pep-3000/ I'll be honest I thought there was more of a rationale as part of this... so I did some more searching. The PEP related to the moratorium offers some insight into the migration thinking: http://www.python.org/dev/peps/pep-3003/ You're right that there isn't an obvious "this is why we did it" article, but I have two (personal) thoughts about it: 1) This wasn't a spur of the moment decision, I think the core developers reached a point where they had to make very hard choices about the evolution of the language. Either bloat the language to attempt complete backwards compatibility and limit the ability to cast off long standing problems (looking at you Java) or make a clean break with no plan and court disaster (PHP 6, Perl 6). I think they made the choice to keep the language small at the cost of introducing incompatibilities. 2) They went about it in the best way possible. I don't think anyone expected Python 3 to become the de facto standard overnight (or even in a year). I expect that Python three will become the standard at about the same level of maturity that Python 2 really took off (3.5?). tl;dr: They had to do something, so they did it in the least painful way possible. 
you can avoid using math.sqrt and still getting the same result by def factors(n): p = 2 while p * p &lt; n: if n % p == 0: ..... p += 1
You need to do a little more to check if n == p * p at the end
Excellent. I was looking for an extra motivation to improve by knowledge of Spanish ... and this might very well be it! 
It says it's coming back on January 26th 2010 .... oops. Maybe it's pining for the fjords? I'll see what can be done about translating, and more important, I think I'll make a call for articles in english. Since the infrastructure to build the magazine is done, the second one is cheap to do.
Damn, you can't get a .py, just a .com.py That would work for a magazine in portuguese where com means with, though.
Let me explain my earlier point using smaller words....
Me gusta. Aprovecho para compartir mi blog en Español que toca temas de Python con frecuencia. http://elweb.tumblr.com Buen trabajo!
I took 3 years of Spanish in high school, which means I understand just enough to be frustrated. To people who take foreign language in school: go spend some time in a country where the language is spoken while the classes are still fresh in your head. Then you'll learn it for real.
Haha, darn. It would be great for a few words in Guaraní too. :( Maybe some day they'll be less restrictive.
Poor timing! &lt;grin&gt;
So you change a var declaration for a test suite ? 
I might take you up on that offer.a nice combination of my interests.
The blip.tv "Episodes Archive" page sucks. Here is a list of all videos sorted by title: http://bottle.paws.de/ep2010.html
[This talk](http://europythonvideos.blip.tv/file/3980864/) isn't loading for me, the others work just fine though. Any idea why?
Must watch: http://europythonvideos.blip.tv/file/3980879/ :)
I'm only half an article through, but so far is *very* well written. Good job. I'll try to participate in the challenge (last section), just for the hell of it.
too bad the audios arent good
...and recorded by a monkey!
Yeah, it was a fun one...
Tumblr? Really? :/
Wxpython
You could check out how PySide is coming along, it's Nokia's LGPL Qt bindings for Python. Haven't used it myself though. Otherwise PyQt is a good option.
Personally-- i almost always use wx, too-- mostly out of familiarity.
Qt. It's probably the best one out there.
PyQt
It might just be the fact that I live somewhere with really bad internet connectivity, but I don't see webapps as the ultimate solution. But they do have their place. 
I've used many GUI libraries, and have found Python/Qt to be the easiest and most powerful. Event-driven programming can be rather difficult. PyQt makes easy things easy, and hard things pretty straightforward. I loved this book: http://www.qtrac.eu/pyqtbook.html It seems the StackOverflow types are more on the wxPython camp (I haven't used it): http://stackoverflow.com/questions/115495/is-python-any-good-for-gui-development 
Webapps and desktop apps are completely different. Alas the OP didn't mention if a webapp would be appropriate. Note that Webapps can do GL, and can run -- well -- on cellphones: http://jquerymobile.com/
Listen on localhost and use [the webbrowser module](http://docs.python.org/library/webbrowser.html) to launch your "GUI". Web browsers truly are the universal UI toolkit you're looking for.
Tkinter doesn't win beauty contests, but it's nevertheless my absolute favorite and always a pleasure to work with. When I program with other toolkits I have the feeling that I have to force them to do what I want, not so with Tkinter which almost always does the right thing. Among the many things I love about it is its scheduler which frees me from bothering with threads. It never makes me write boilerplate code, it's fast, it yields results quickly, it's stable, it blends nicely with Python's idiom, it's friendly, humble, and wise. Two years ago, I developed an application that was relatively demanding with respect to the gui. It had to render thousands of objects moving on the screen at a frame rate &gt; 25Hz and was highly interactive. I was often amazed of how elegantly complex problems can be solved with Tkinter. The only other toolkit that is comparably enjoyable to work with, though in a very different way, is Cocoa. http://effbot.org/tkinterbook/tkinter-index.htm#introduction
Check out PyMT, we just released 0.5 as a stable version. It's meant for multitouch applications, but you can use it with a mouse and keyboard just fine as well. You might like it since you said OpenGL, you can do drawing straight in OpenGL in PyMT, all drawing is accelerated. It's also designed around the idea of making it easy to implement "custom" widgets that do exactly what you want and look the way you want (plus we have a bunch of standard widgets that work both with mouse and touch/pen input). Its cross platform, Windows/OSX/Linux, and your app will run everywhere. but it's not a native look/feel toolkit check for classic WIMP style apps, if thats what you want QT is probably a better bet. check out the website and wiki to get started: http://pymt.eu http://pymt.eu/wiki Also check out our viemo channel to see teh kinds of things you make using pymt: http://vimeo.com/groups/pymt 
PySide does look kind of appealing. It is currently missing windows support, so it loses a few points for cross platform compatibility. But looks like its coming soon.
At a quick glance I like it. And I will defiantly use it if I ever make a touch app. Not so sure about using it for apps that require "desktop integration"
Loading a full featured web browser is much more 'fat' than using a gui which only has the necessary functionality of your program, both in memory and screen real-estate. 
I've done this (well, actually, I used `web.py`) for a couple of recent desktop python apps. It's worked very well, and I've been able to deploy on Windows while developing on Linux.
Personally, I use GTK with PyGTK as the python wrapper. It's nicely cross-platform for linux &amp; win32, renders exactly the same if I want (or mimics the OS if I don't), has decent python integrate and good documentation. However... while PyGTK has nice installers to download, getting a good GTK installer, along with Glade (the gtk ui designer) set up under windows, and then getting it packaged into a standalone using py2exe... was somewhat of a pain under windows. (I'd love to post the scripts and sources I've collected for doing all of that, but they're all over the place in my company's build process). Another drawback is that it's possible to use on OSX, but the installation is more complicated, and the integration isn't as good. The next option is wxPython. wxWindows is a cross platform wrapper for native gui. On windows, it uses the std windows gui; on linux, gtk (or maybe qt?); and it's even native on OSX. I haven't used it that much, but it's got a good gui designer (wxGlade), and does manage to be almost seamlessly cross-platform. The only catch is that the gui object model is much more complex, since it has to encompass the superset of all the guis it's wrapping. [Not familar enough w/it to say more]. Then there's qt / pyqt. QT's now LGPL, which is nice. PyQT is still GPL / commercial; but there's a separate workalike project that's LGPL (PySide, which is coming along well). QT is probably the fastest, cleanest (design wise), and most responsive gui of the bunch. It'll work natively under windows and linux. Not sure about OSX. I'm also not that familiar with it either. On the more esoteric side... there's XULRunner, the backend system which Firefox and the other Mozilla projects use (along withe Komodo IDE). It's an XML ui language, w/ css for styling, and natively uses javascript as it's programming language. BUT there's a plugin called PyXPCOM which lets you code applications in python. As demonstrated by Firefox, this toolkit is incredibly cross-platform. However, the toolchain is complex, and PyXPCOM is still "alpha" quality. It does give you nice separation of code &amp; gui, but I wouldn't recommend this chain except for personal exploration purposes. All in all, while I'm partial to GTK, I think I'd have to recommend QT. If you do go that route, the exceptionally nice Eric Python IDE is not only written in PyQT (and thus is cross-platform itself), but has extensive QT integration, debugging, and widget designing. 
I find it interesting that even people who don't use QT recommend it.
The contenders are (in alphabetical order) PyGTK, PyQt, PySide, Tkinter, and wxPython. PyGTK Strengths: mature, good API, excellent event loop integration with Twisted, LGPL Weaknesses: a pain to install on Windows and MacOS, not native-looking on Windows. (There is a native-looking port for MacOS but it's not mature) PyQt Strengths: cross-platform, mature Weakesses: huge API covering way more than GUIs, camelCaseDisease, GPL PySide: Strengths: apparently already works in PyPy and Python 3, LGPL Weaknesses: not portable yet, huge API, camelCaseDisease Tkinter Strengths: comes with Python Weakness: fugly, runs a separate Tk event loop in parallel with Python wxPython Strengths: portable, looks native Weaknesses: an API even its own mother doesn't love I use PyGTK. PySide looks promising; I might use it in the future.
&gt; But which GUI toolkit should I use? Qt is the best cross-platform toolkit, and it has a GUI module. I am however, not fond of it's API, but that it is my preference. &gt; Python has hundreds of them. That is quite an exaggeration 
&gt; Personally, I use GTK with PyGTK as the python wrapper. It's nicely cross-platform Not really. It only looks nice in Gnome. Where as Qt looks nice everywhere.
Qt does more than UI firstly. Secondly, it renders better on all desktops.
I find the bread of Qt to be a pro, not a con. However, its API is very unpythonic.
What exactly do you mean by that? There's the gtk-qt engine, which makes it mimic the qt theme, so it doesn't look out of place under KDE. Under win32, you can have it mimic the native windows theme, which works quite well (at least under XP, I haven't tested Win7); or you can use one of the many gtk themes out there to pick the look you want. It's not pixel perfect by any means, but it's quite easy to deploy a professional looking gtk program under windows, gnome, and kde. While there are some serious deficiencies in the gtk api, the cross-platform behavior and appearance are not among them.
In C++, where the language doesn't inherently come with a big library, a giant framework that tries to cover everything is useful. (And was almost necessary before namespaces were added to the language, where mixing two frameworks was difficult because of name collisions. See: JavaScript today.) But Python already comes with sockets. I don't want my GUI library to come with more sockets. That's one of the reasons I like GTK's API better than Qt's -- it stays on topic. But Qt looks better on Windows and MacOS, which is why I'd consider holding my nose and using PySide, once it's actually portable and mature.
&gt; There's the gtk-qt engine Which is separate from Gtk+, and only works on Linux as far as I know. &gt; Under win32, you can have it mimic the native windows theme, which works quite well Not as compared to actual Windows or Qt. &gt; It's not pixel perfect by any means It simply does not look as nice as the native or Qt.
Yeah. I think it benefits greatly from being massively cross-platform, which generally helps free a code-base from any platform or hardware-specific assumptions. The inclusion of mobile devices definitely helped force the removal of extra cruft due to hardware constraints (which I think GTK could benefit from). Along with that, it's been (successfully) refactored a number of times, while GTK's got a bit too many kludges in it's code that it could stand to lose (I have hopes for GTK 3). That said, GTK's written in pure C, with it's own macro-based OO system, so it has a much easier time interfacing with other languages and event loops; while C++ has always been burdened with a (slightly) harder time in that department. Just want to add: whenever I start judging one toolkit too harshly relative to another, I try to come back to a more absolute perspective, and remember that they're both awfully good toolkits, which are far more feature-filled than any of the ones which came before them, or exist currently. edit: I forgot... QT's "slot and signals" system is a much better solution to event-based programming than simple callbacks, even though it required modifying the C++ language spec to make it work. Though GTK's event system isn't so much worse, but I would consider it a minor plus in QT's favor, one which probably helps it speed and resource-wise.
wxPython is easy, fun and I've not had any problems using it on Windows and Linux.
&gt; But Python already comes with sockets. I don't want my GUI library to come with more sockets. That's one of the reasons I like GTK's API better than Qt's -- it stays on topic. What about multimedia?
Actually that's what I started doing lately. Just start a local python WSGI server and let the browser be the GUI.
How can something that is fully theme-able "only look nice in Gnome" I use a few gnome apps in KDE and they look fine as does zenmap on windows. I seam to recall pidgin looking bad on xp but that was atleast 5 years ago.
You could try this http://code.google.com/p/python-twitter/
Why does it matter if gtk-qt is "separtate" from the core library? If you discount all the themes/engines except the default ones, both GTK and QT look kinda ugly. gtk-qt is an engine, you can use it. Not sure why gtk-qt cross-platform matters, if you aren't running your app under a gtk- or qt- based desktop environment (kde,gnome,xfce), what purpose does making gtk match qt serve? On windows, they both have to match windows, same for OSX, etc. As far as "simple does not look as nice", I'd love to here some specifics. I'll admit a raw gtk app doesn't look quite as good as other apps on windows, but that's usually because the other apps have been polished and given custom gradients in various places, etc. Once that's done, they fit in quite well. For a while I used Eric as my primary IDE on windows, and I can't say the QT look-n-feel ever matched windows perfectly either. But both of them were good enough that I don't see it as the deciding factor for which toolkit to use, or even how "cross platform" each of them are. (For the record, I currently use Komodo as my IDE on windows; and XUL is much more advanced in the area of native look-n-feel, though it lacks in so much else).
If I'm understanding the question right, I'd rather have multimedia in a separate library than built into my 2D GUI library. Obviously there's some overlap and practicality might trump purity.
&gt; Why does it matter if gtk-qt is "separtate" from the core library Because we are talking about the toolkits. Not their addons. &gt; If you discount all the themes/engines except the default ones, both GTK and QT look kinda ugly What are you talking about? Qt comes with all its only engines. &gt; Not sure why gtk-qt cross-platform matters I thouht the OP was asking about cross-platform toolkits. &gt; they both have to match windows, same for OSX, etc. But Qt does this better than Gtk+ 
Really? I've used both Swing and PyGTK heavily, and I think PyGTK has a better API. Granted, Swing does a better job of faking native L&amp;F, and avoids the installation issues since it comes with Java.
Well that's the problem with referring to Qt as a GUI library though. I'm not sure how purity really becomes useful here.
with pyqt you can use webkit and do interface in html/css/javascript and integrate it with the rest of application via qt. and you can enhance it with the rest of qt widgets.
&gt; Because we are talking about the toolkits. Not their addons. That's just playing silly buggers with semantics. It's like saying Python doesn't have a good gui, because you'd have to install pygtk or pyqt, and they aren't part of the stdlib. We're talking about: what can someone who sits down to develop for windows, linux, and platforms unspecified, make python + &lt;gui toolkit&gt; do for them? Many open-source projects are too large to be written by one group of people, so of course there will be components and add-ons written by others. The presence of those other projects only enhances the capabilities of the core library. It's the core library plus all the other things that could be bundles with it that makes it a toolkit. It's why KDE is calling their new releases "software compilations". I'm not sure how to spell things out more simply; gtk-qt doesn't have to be cross platform because it's not needed *on* other platforms, just like the native windows engine isn't needed on non-windows platforms. It doesn't affect *gtk* being cross-platform (actually it enhances it). I'm not really sure where you're going with this anyways. It's not like this is a football game, and we all have to pick sides and look down on the other one. We're all walking through a hardware store looking for tools, and the tools are all free, so we're trying to dispassionately judge which one is best. GTK's got a number of flaws (which I've tried to bring up in my other comments), but it's look-n-feel is not drastically worse; and focusing in on that one aspect gives disproportionate weight to one of the areas with the *fewest* differences, making the job of accurately weighing and judging toolkits that much harder (especially for anyone new to both of them).
PySide is still broken. At least, it crashes when I try to run the ported (from PyQt) examples. PyQt works. 
Yes, you'll definitely load more than is strictly necessary with the majority of gui frameworks, but likely not more than a web browser would. Screen real estate because you'll likely have browser toolbars and shit at the top. I guess you could load a window without that shit too though, but it honestly didn't occur to me at the time of the previous writing. Speaking out of personal opinion, it always annoys me when a local app uses a browser instead of a proper gui, they're almost always poorly made, slower, and less intuitive. It *can* most definitely be done well, but at that point, unless you're already a web designer, you might as well just learn a gui toolkit instead of learning html/css/javascript in addition to cross browser compatibility quirks,. Also, every gui framework I have experienced, none *require* learning hacks and tricks to make it display as you want it to due to the limitations such as that of CSS (that may sound bad, but it's not a negative of CSS, it is by design, but lots of things do not seem obvious or intuitive until you get used to its behavior). 
Claim: Python does not have 100's of them. Would not like to be proved wrong. Can you please list 101 of them please? I await, dans le shadow
I have been writing pyqt apps for many years. The apps run great on Windows, OS X and Linux/X11. One can write apps very quickly with pyqt once you have it installed (very easy on windows now) and use py2exe to build it stand alone and inno to package (the one I use). I use eric4 IDE it has a great debugger and use gvim for writing or rewriting large chunks of text. Use the eric editor for smaller changes and fixing bugs. I would try pyslide but pyqt is best right now and eric4 supports both. 
A big time second for pyqt.
Yeah I like wx
Which examples? So far they have been working for me.
I couldn't be bothered counting, but now I have I can see I was only off by a factor of 2. [There are 47 listed on this page](http://wiki.python.org/moin/GuiProgramming)
I retreat. You can probly find me in /r/atheism or somewhere else where I can feel superior. On another note. MAN UP
PyQT if you want all of your code infected with the GPL. Until they make this LGPL it's really not worth it.
"you are technically correct - the best kind of correct."
&gt; Tkinter doesn't win beauty contests An understatement. Tkinter is simply hideous to behold on Linux. It's sad, really.
awesome!!!
It's because Qt matches what you're looking for with the least problems involved. Good descriptions get answers that make sense.
He has an exception in there for linking with BSD-licensed code, but he won't make it LGPL. That's why Pyside exists.
You're in good company. There are quite a few apps that write the thinnest bit of native code to start up the webserver and load you into a browser with the url bar hidden. 
wx is just a really terribly designed API. It's nice that it's more liberally licensed than Qt used to be (and PyQt still is GPL, yeeeeeuck), but god damn, wx makes my brain hurt.
Have you looked at Tipfy http://www.tipfy.org/wiki/extensions/auth/twitter/
OOps frogot a link http://tipfy-auth.appspot.com/
http://popdevelop.com/2010/07/an-example-on-how-to-use-oauth-and-python-to-connect-to-twitter/ Might be work a look.
90% of desktops have a web browser loaded up/cached by default anyway. heck even steam does part of their gui with IE 
an excellent book is "Rapid programming with PYqt"
wxpython is sufficient for 99% of GUI CRUD apps and notifier apps where the most important aspect is doing something similar to what could be done in a webapp. 
Steam does part of their gui with IE because they show web content though, that's not exactly a compelling reason to use it for a desktop app.
yea but it's never with directly editable urls :) they just do one layout for their site that also works fine within steam. I dunno I've just run into too many instances where I'm going cross eyed keeping track of all the box models I'm chucking widgets into and suddenly realize the beautiful simplicity of HTML markup and forms :) I dunno most of my desktop apps are some version of CRUD and it seems retarded to write it twice as both a webapp and a desktop app. I was also pretty crushed that google gears got killed :( 
Just for clarification, does that mean that any app using PyQT as it's toolkit must be released under the GPL?
Looks like RMS is downvoting you...
Just gotta jump in here and mention [CherryPy](http://www.cherrypy.org/), which is kinda like the web.py thing self mentioned (sibling comment). I've used that before to build 'GUI's in a browser and it's worked pretty damn well for me.
I thought they switched to Webkit in the latest release?
Unless you buy a commercial license. That is the case with normal C++ Qt at least - I think it is the same case with Python.
RAM is cheap and it's supposed to be used. I understand and agree with what you're saying, but can you really not spare an extra 100mb of RAM?
I'm too lazy to reinstall it &amp; dig them up. Too, it was ~3 months ago. Maybe I should try PyPy again. 
Could be, I haven't really kept up with it since no games I've wanted have been released.
I had heard/read that Tkinter has made huge progress in the last year or so towards native looking UIs. Can anyone else comment?
I agree, it doesn't matter much, but you should not use more ram than you need to just because you can. I have 4 gigs of ram, on Linux I've never gone over ~700mb, and on Windows never over 2g, or ~3.2 while playing a game. Still, it's something I tend to look at. It's largely irrelevant, but if my whole DE, a movie player, im client, web browser, music player, bittorent client, and email client only eat up ~500mb of ram total and your app takes up 100mb it does make me think poorly of it. If it doesn't matter otherwise I'm not going to stop using it, but I'll definitely be more critical about my critiques of it and less forgiving when I find issues. That is just me though, the majority of people will likely never check or care. 
One of the best things about PyGTK is Glade! Glade is such a great GUI designer. The devs deserve a lot of credit for what they've accomplished. On the other hand, I do feel a little uncertain about GTK's support for attractive Windows GUIs that are easy to deploy. If I truly needed good Windows support, I would probably take a serious look at other options.
That background image makes it too hard to read the text.
[This diagram](http://www.zedia.net/wp-content/uploads/2010/06/oauth_diagram.png) helped me out.
Keep in mind that PySide is trying to achieve API compatibility with PyQt. So, for the time being, you can use the GPL version of PyQT and maybe by the time you are ready to release, PySide will be in better shape.
Thanks for writing this. Seems like a great idea. I can't wait to readover the source. 
Have you seen this? http://pypi.python.org/pypi/path.py
Twisted Python has a similar class called [FilePath](http://twistedmatrix.com/documents/current/api/twisted.python.filepath.FilePath.html).
Not anymore. In C++, QT is LGPL licensed. The reason PyQT keeps its GPL licensing even on the LGPL version of QT is because the PyQT company has a business reason to keep it that way. I personally think it's shortsighted and they should go for support contracts on an LGPL version, but whatever. It's their business and when PySide is done they will no longer have a business.
I'm surprised how little support wxPython has got on this thread. While Qt is a better designed toolkit than wxWidgets at the C++ level, wxPython is a much more "pythonic" binding than PyQt. The bindings convert to/from basic python types without needing to reference the associated C++ toolkit objects (e.g. QString / wxString). Compared to PyGTK, wxPython is a somewhat higher level toolkit. wxPython contains many many high-level widgets / dialog ready-made, so you don't need to design these yourself. With PyGTK, you need to build nearly everything with the raw controls. This gets quite tedious quite quickly. On linux, wxPython wraps GTK, so it's looks just as 'native' on that platform as GTK. The only area where I'd choose PyGTK over wxPython is if I needed GNOME integration. Things That Rock with wxPython: ready-made dialogs, demo-app, Sizer-based layout, native controls, good community Things That Suck with wxPython: new wxGraphicsContext is incomplete (use wxcairo instead for graphics), Table control API is awkward, no decent HTML-rendering widget. Finally, the wxPython Demo app is the best learning tool there is!
Python recently added tkinter.ttk to 3.1 and 2.7 which is a drop-in replacement to make tkinter look 10 times better, so I hear.
IIRC he has a non-infecting clause excepting BSD and maybe MIT licensed code that uses PyQt. But yes, otherwise, GPL, or buy a commercial license.
oh why do people write so many halfhearted clones of py.path
Musicbrainz Picard [http://musicbrainz.org/doc/PicardDownload] started with WX and had to do a complete rewrite to QT. Not sure about the exact reasons but I seem to remember it was stability on OSX
Yes, and the links are dead. I'd count that one against using it :D
I like this idea, but how does one get around the myriad end-user firewall configurations?
It does too! Thanks!
Most people will agree with you. Personally, I hate Glade---and all GUI builders, really---with a fiery passion. But most people will agree with you.
any chance to making a port of this to javascript? I could really use this...
One thing I ran into recently is the need to support setting mail envelop separately from the e-mail "From:" address. The application was a kiosk at a dealership where customers could send themselves e-mail. If once at home, they selected "Reply-To" on their e-mail client to ask more questions, we wanted it to go back to the dealer so they could follow-up, but if they just entered a junk address, we didn't want the dealer to get all the server bounces. What needs to be done is have the mail envelop From address be set to someone who handles the bounces, and the e-mail msg from address set to the dealer. Also, we set the "Sender" field in the e-mail msg to be the same person who handles bounces. Th point is that there is not just a single "From" field with e-mail and being able to control this is useful. From a quick look at your code, I only saw a single From that was used for both the msg and envelop. 
I have, and I believe my version is vastly improved: * That path.py subclass of string, and thus has many string methods attached to it that are really not helpful for a path. Mine is a subclass of tuple, and has no useless 'zfill', 'isdigit', etc. methods. * As a subclass of tuple, taking slices gives you parent directories or the base filename - if p is a Path, p[-1] is the filename, and p[:-1] is the parent directory. Slicing is useful in the context of paths. * Adding also works as a join - if you add Path('parent') + 'child' you get Path('parent/child'), instead of path.py's 'path('parentchild') * As Guido said, the path.py module is 'the ultimate kitchen sink' - it has 124 public methods. All of os and os.path are on the one object. My 'Path' object has 22 methods, all useful. I also made a Dir and File objects, with 26 methods each, every one useful. If you're working in an interpreter with a Path and hit p.&lt;Tab&gt;, it shows you what you can do with it, not an overwhelming assortment of methods.
Thanks! And, by the way, if you have a windows or mac machine, I would love to have someone test it there and help me out... if the base path construction methods work, so should everything else since its just using the os and os.path modules, but, well, you never know.
I can see why you might say that... I wasn't going to publish my 'halfhearted clone' for a long time, since it only had marginal improvements. But I kept improving it, and now I think its an awful lot more than a clone...look at my comment above, I really think my version is a vast improvement.
No, not really, sorry. I don't use javascript...
Pretty nice, every language should have Path and URL objects! (I've written my own URL class)
py.path is in pylib, its not even remotely the same as path.py and much more powerfull
Excellent! Yes, subclassing string was a bad design choice. Yours looks more useful.
One thing I would suggest is to replace the "transform" method with .as*() methods: * File.aspath() * Path.asobject() 
This is called [Generator Expressions](http://www.python.org/dev/peps/pep-0289/) In your example it does "generate a list with each item in sublist for sublists in l " or for sublist in l: for item in sublist: foobarlist.append(item)
baaaahhhh!!!!! I've just wasted half an hour trying to do this with doubly nested lists. What's bizarre is that if you take the listcomp and then nest that in a list comp it doesn't work: Consider: l2 = [[[1,2],3,[4]],[5,6],[[7,8]]] [item for sublist in l2 for item in sublist] works, but [item for sublist in [item for sublist in l2 for item in sublist] for item in sublist] fails with an error that an int object isn't iterable. I've tried chaining the fors as well to no avail. 
Hm. I was never satisfied with the name 'transform', but I don't see the need for aspath() - one can always use Path(fileobj) for exactly the same effect, and as File and Dir are subclasses of Path, there isn't much need for that anyway, as far as I can see...
BTW a two-level list comprehension will only flatten lists of depth 2. If you have: l = [1, [2, 2]] or: l = [[2, 2], [2, [3, 3]]] that code won't work.
yes, thanks for clarification.
You're right, I've never seen that before... but looking at it, I'm still not convinced. It is not a 'kitchen sink', but the choice of methods seems pretty weird to me... pypkgpath? Is that necessary as a method on a path? Maybe in the context of building packages... but not in the general case of path manipulations. Also, it does not do slicing at all, and adding is like the path.py - not what I would consider useful, and the slicing and addition parts of my Path object are what I would consider the most useful part.
Thanks! (-:
ok but shouldn't that be: [item for item in sublist for sublist in l] however that gives `[8, 8, 8, 8, 9, 9, 9, 9]` edit: someone at #python explained this same thing, sorry I didn't understand it here at first.
I would consider undertaking it but for what purpose would one use it as Javascript doesn't usually entail filesystem access.
That one does have (in my opinion) a fairly nice collection of methods... but does not have the addition and slicing that subclassing tuple gives mine, and I consider that to be really useful. Consider: &gt;&gt;&gt; p=Path('/home/wendell') &gt;&gt;&gt; p = p+'testfile.txt' &gt;&gt;&gt; p Path('/home/wendell/testfile.txt') &gt;&gt;&gt; p[-1] 'testfile.txt' &gt;&gt;&gt; Path('/home/other') + p[-1] Path('/home/other/testfile.txt') I have yet to see another module that can do that... and I find that to be the most useful part.
True, but that appears to be some time off. 
Unfortunately I'm familiar with Pyglet and Cocos2d myself :D The management's quite as he describes.
Have you tried the latest versions of Tkinter? They are a vast improvement, and it comes native with Python. I believe the version coming with Python 3 and 2.7+ will be up to standards with QT and WxWidgets. Not having to build some quirky installer that might fail, that makes a big difference to me. For one-shot stuff and programs for my own usage, I've favored WxWidgets with Python before, and GTK for other languages when not using native widgets.
Nope, haven't tried the new Tkinter. I do like how it was always darned fast, compact, and builtin to python. But without native theming, it's just so darned ugly that I can't use it in a customer facing application :( I've seen in the upstream Tkinter sites some of the theming code, which looked like it was coming along well. Once that hits python 2.x, if it can manage to get close enough to native look-n-feel, I might have to revise my opinion of it, as that was really my main objection. You wouldn't happen to know of a gui-designer (ala glade) for Tkinter?
I highly recommend doctest as part of a comprehensive testing strategy. I've found that doctests can generally replace unit tests as long as there are good functional tests to complement them. I think the best thing about doctests is how easy it is to move code fragments from an interactive interpreter to the source (docstring). If you have an editor that can run an interactive interpreter, you can really fly when creating and editing these tests. Doctests do take a bit of practice. I wish the ellipsis option was the default because it adds clutter to what should be easily readable. Rambling off. 
Yes, the syntax is goofy. These two are equivalent: &gt;&gt;&gt; l2 = [] &gt;&gt;&gt; for item in l: ... for i in item: ... l2.append(i) &gt;&gt;&gt; l2 = [i for item in l for i in item] Things to keep in mind: * There's no nested list comprehension. That's *one* list comprehension. * The syntax follows the order that you would write the loop out using the for statement. Which, yes, is kind of backwards to how the rest of the list comprehension syntax works. Still don't get it? Maybe some punctuation will help: [i &lt;- for item in l: for i in item:] That's not valid Python, but I think it illustrates the idea.
I'll point out an alternate, perhaps faster method: sum(l, [])
Wouldn't a recursive function work for all depths?
check the link to stackoverflow, the guy who proposed this timed the others and said this one was faster.
yeah but can you do that within list comprehensions?
isn't this a list comprehension? I thought [generator expressions](http://docs.python.org/reference/expressions.html#generator-expressions) are with regular brackets. These are with square brackets. &gt;&gt;&gt; type([i for i in range(5)]) &lt;type 'list'&gt; &gt;&gt;&gt; type((i for i in range(5))) &lt;type 'generator'&gt; 
My choice too. It actually creates a UI that *is* native not just *looks* native. 
OS X handles paths the same as unix: &gt;&gt;&gt; os.sep '/' That said, if you use os.path.split/join and os.sep, it should work on Windows too.
I'm not using any GUI-designers lately. I have this in my To-Try list: http://page.sourceforge.net/
Any way to get this working with a nice Pythonic REPL?
Just FYI http://web.archive.org/web/20071105095205/www.jorendorff.com/articles/python/path/ I've used this module for years now. I like it a lot. I'll see if I can ask the guy where his site went. *Edit*: Fork here also: http://github.com/jbalogh/path.py
Put your tests in one or more text files, then use (e.g.): def additional_tests(): import doctest return doctest.DocFileSuite( 'README.txt', 'OtherDoc.txt', 'Sometest.txt', ... optionflags=doctest.ELLIPSIS|doctest.NORMALIZE_WHITESPACE, ) Add test_suite='nameofmodule' to your setup.py setup() call (where 'nameofmodule' is the module or package containing the above code), and run "setup.py test" to run your tests. Then during development, I edit the text files and code side by side, and repeatedly run "setup.py test" in another window.
Yes, I'm pretty sure I have it set up to work fine... in theory, it should work, but the question is what will happen in practice. Thanks, though!
No, though you can certainly use a list comprehension in your recursive function.
That's not a generator expression, it's a list comprehension with a nested for loop. See the other comments in this thread for explanation.
Certainly, and I should have written that I knew how to deal with the issue. My point was that having tests in docstrings is really helpful but the clutter is increased by doctest options -- and that the clutter could be reduced by different defaults. And I'm glad you pointed out the use of separate text files for doctests; they're really great for the narrative style of example/howto/documentation. 
Um, is py.path on PyPI, so people can depend on it in their projects? If not, it probably won't matter how good it is.
hell, no. it is an alternate way of doing that.
The examples given do seem to pollute the original intention of the docstring. (documentation). Do you have any examples of this used well? I'd love to see some examples where this is just done quite well :)
its in the py package, along with py.test
Oooh. I like the approach. Now it's on my to-try list as well :)
Not any public examples with the tests still inside the docstring -- like pje pointed out, you can move the doctests to a text file, and that's what I've been doing. :( 
actually having add be a string add helps a great deal slicing is not that useful if you work in terms of absolute paths
There are some interesting crossovers in this domain, for instance [Pyjamas](http://pyjs.org/) which is closer to many desktop applications in it's API, and works by compiling your python code to javascript run on the client. There's also a machanism to run the same application unchanged as a pure desktop app.
Unsurprising. But `sum` is far clearer. Thus, until list flattening is a bottleneck, you should use `sum`.
&gt; fails with an error that an int object isn't iterable. I've tried chaining the fors as well to no avail. Uh yeah, that's normal, you have 3 bare integers at level 2 of nesting, so after removing one level of list nesting you end up with 3 integers at the toplevel (I've marked them): &gt; [[1, 2], {{3}}, [4], {{5, 6}}, [7, 8]] and you can't iterate over integer so that blows up. Nest them correctly and it'll work: &gt;&gt;&gt; l = [[[1,2],[3],[4]],[[5,6]],[[7,8]]] &gt;&gt;&gt; [item for sublist in l for item in sublist] [[1, 2], [3], [4], [5, 6], [7, 8]] &gt;&gt;&gt; [item for l2 in l for l3 in l2 for item in l3] [1, 2, 3, 4, 5, 6, 7, 8] &gt;&gt;&gt; 
use more java class "annotations".
&gt; aid this one was faster marginally faster, and only on this particular list. Is it faster with more lists? longer lists? Who knows! Don't prematurely optimize. As masklinn said, use the clearer way until you're sure that you need something better.
Thanks for pointing this out. If someone got the impression I was mocking the code itself, no it was just the instant availability of it.
I just want to add that generator expressions don't necessarily need parens: &gt;&gt;&gt; sum(i for i in range(5)) 10 Which can give you very, very clear syntax in some cases.
You never really stop hating other languages, it just goes from "burning hatred" to "smoldering hatred". More seriously, not all other languages are Java, there are always new and interesting languages out there to try that have features you'll miss in Python
I gave up.
Scala.
+1 You should try Scala, it feels lightweight and... in some way pythonic and even more ;-)
As a Java programmer turned Python programmer it is really difficult to work in Java now. As I'm doing my Java work, for every single function I just keep thinking how much easier it would be in Python.
I actually still occasionally enjoy C, even after a lot of Python programming. I work on scientific applications where speed can be (but isn't always) king, so C is clearly needed sometimes. It's much, much less elegant, but the speedups on heavily numeric code are very gratifying, and I find that there can be something kind of meditative (if time-consuming) about working so close to the bare metal and tending to every detail.
I agree on the general idea however this particular case doesn't seem clearer (any of the two really). `sum` doesn't hint me for "flatten"
&gt;private final static string notes="notes.txt"; Well of course you're not going to see those constructs in a language with a dynamic type system.
Thank you for this, this does look MUCH cleaner, and satisfies my requirement for building Android applications. Hopefully as I work with it, it will enhance my understanding of how java code is produced. Scala is technically a "functional" programming language but it doesn't have to be used as such from some of the code I've found, looks like it can be used for something other than CompSci ;) Now, I'm off to see the wizard, the wonderful wizard of oz...
Clojure?
None that I'm aware of, that's just the example he gave.
It seems as though you're implying that a statically typed language must use type annotations. The counter-example that comes to mind is Haskell: notes = "notes.txt"
&gt; attempt to make something like java more...pythonic? It's not Python, don't try to make it Pythonic
What is the "(View view)" part?
Try C#. Makes you hate some aspects of Python very fast.
The authors of Jython would like a word with you.
That makes sense. Then perhaps your examples should show this as the "recommended" usage pattern? :) (The last statement in the Example on your PyPI page calls f.transform().)
Care to explain? I have only dabbled very briefly in C# but am maybe at intermediate level in Python, so I'm curious.
making one language look like another is a good way to fuck things up horrifically for the next guy. don't do that. bad programmer. java may not be as fun as python, but that's no excuse not to learn the language and the style. I would recommend 'Effective Java' 2nd Ed. as for getting on with java, I'd recommend alcohol
I'm only starting to learn C#, and whilst I admit that there are some nice features, all of the ones I've come across are done in python, just in a different way. For example, 1. C# has separate `for` and `foreach` loops, but in python, you either use * `for index, element in enumerate(iterable):` (non-destructive) * `while iterable[slice(start, stop, step)]:` (destructive over portion) (`slice` used because it doesn't raise `IndexError`) * `while iterable:` (fully destructive). 2. C#'s operator overloading, which is matched by the fact that python methods/functions take * wild positional arguments (`*positional_arguments`) * keyword arguments (`keyword=default_value`) * wild keyword arguments (`**keyword_arguments`). 3. C# has ternary, but this is done in python with * `spam = eggs if condition else sausages`, or * `spam = (sausages, eggs)[condition()]`. 4. C# has `switch`, which is done in python with dictionary iteration. But being a C# nooby, I'm sure there's gems I'm yet to discover - do you have any specific examples?
I would be implying that if (P-&gt;Q)-&gt;(Q-&gt;P), but thankfully I was precise in my wording. Dick. You're right ;-), but to be fair Haskell is too much of a bad-ass language to fit my generalization.
I'm not sure why they killed Jython on Android... Jython as far as I know, could potentially introspect the Dalvik libraries and give you full GUI access. The other option is PyPy which can target the JVM as a backend (and then from there be translated to dalvik). PyPy might be appropriate since its memory usage is quite good if you turn the JIT off. (It'd be nice to have the JIT too, but currently PyPy's JIT can only generate CLI bytecode and x86/x86_64 machine code, and there's a large memory overhead) I should mention that I have no idea if PyPy translated to JVM is as memory efficient as it is translated to C...
How easy is it to develop with the Android SDK in Scala? I heard it had terrible performance (or was that Clojure?!)
Haha my bad, I took formal logic two years ago, but will not be looking at Haskell in great detail until this semester.
parameter called view, which is an instance of the class (or Interface) View.
Personally I think certain elements of C#, especially overloading, would be really pain-in-the-ass confusing if it wasn't for Visual Studio's excellent auto-completion. That said, it is really nice to use with said auto-completion.
Maybe turn that hatred in to pity?
You can overload operators in Python, in case you weren't aware. [link](http://docs.python.org/reference/datamodel.html?highlight=__mul__#emulating-numeric-types)
Well, the 'transform' method is the opposite of the Path(obj) pattern... I just don't have it in the example, partly because its not that useful.
How is Jython an attempt to make Java pythonic? It's just a Python interpreter written in Java, right?
TIL about `enumerate`! No more `for i, j in zip(some_list, range(len(some_list))`. I always felt *horrible* for writing crap like that.
As a side note: http://docs.python.org/library/itertools.html Search for "flatten" under Recipes.
Lets see... *\*highlights Jython* *\*right-clicks "Search google for 'Jython'"* *\*opens first link* *\*reads 'Jython: Python for the Java Platform' that's in big, bold letters across the jython homepage* I couldn't tell you.
Recursion can be avoided if you don't mind doing it in-place &gt;&gt;&gt; def flat(lst): i=0 while i&lt;len(lst): while True: try: lst[i:i+1] = lst[i] except (TypeError, IndexError): break i += 1 &gt;&gt;&gt; lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []] &gt;&gt;&gt; flat(lst) &gt;&gt;&gt; lst [1, 2, 3, 4, 5, 6, 7, 8] From http://rosettacode.org/wiki/Flatten_a_list#Python
I feel like Python has spoiled me too.
Right, but that doesn't make Java itself pythonic, does it?
[could be both](http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)
of course, silly me.
"...Jython is an implementation of the Python language for the Java platform. Jython 2.5 implements the same language as CPython 2.5, and nearly all of the Core Python standard library modules..." [[FAQ]](http://wiki.python.org/jython/JythonFaq)
Java is the name of a platform and a language. Jython provides the Java platform with something more Pythonic than the Java language. Jython does not make the Java language more Pythonic.
You may be confusing the Java language with the Java virtual machine. Jython is python but it compiles to java bytecode.
It sounds like you mean "How do you learn not to hate Java?" It is difficult to cope with Java after having used more powerful languages. I experience a similar difficulty with Haskell. I've loved Python for many years. After C++/Java-style type systems, Python's duck typing was a breath of fresh air. Haskell's type system has surprised me, though. Not only does type inference save you from all the tedious work of repeating information to the compiler, but it also supports all duck typing uses which are in good-style -- with a static type system! Now that I've used Haskell for a while, it's really hard for me to go back to Python, where code is not any more concise or less effort, but errors are detected far later, and execution is far slower :-(
"Functional" languages all support the imperative paradigms very well. They just typically have much better support for the functional paradigm than most imperative languages. They usually make it much easier to embed DSL's in them, too.
I may just be really tired and commenting on reddit. I have no actual knowledge other than how to google things. Anything I say is with no expressed or implied guarantee, warranty, or any semblance of fact. By reading this comment you agree to this TOS. These comments are purely for entertainment value and should be taken as such.
ah interesting, that's also much more readable (unlike the sum approach mentioned elsewhere).
Python has a lot going for it, but cleanliness? With all the self., \_\_FOO\_\_, and the incoherent devision between functions and methods, it's not the cleanest of languages. If you want something clean on the JVM, try Clojure. If you want to make Java more like Python, try Groovy. There are also libraries for Java to add some elements of functional programming. There's a Google toolkit, and one called Functional Java.
The same way you learn not to hate screwdrivers because you love hammers.
First you learn the other languages, and what they are good for. Then they're all tools in your tool box. If you are a hammer every problem looks like a nail. Don't be a hammer.
&gt; So I figure, hey, java shouldn't be all that big of a step from python right? LOL Once upon a time an ant said to an elephant : "I'm gonna fuck you up!!!"
C has a lot in common with Python, it is a simple system with few special cases and powerful rules that can be layered together.
What other programming languages?
You can also use reduce(list.__add__, l) which is basically the same thing but more obviously is doing the flatten that Samus_ is asking for.
Too much hate, man. Love the problem. When you find your true calling the language wont matter.
&gt; how do the people using these languages get by on a day to day basis? By using an IDE that writes half or more of the code for you. Java is a horrible horrible language, but it has some good dedicated IDEs and programming on a good framework can be relatively painless. You should try Scala as well as zepolen suggested, but I suggest you drop your prejudice about functional languages. Especially since you seem to love one of them. :)
Any reason for also providing a dumb Linux binary? Isn't fpath a pure-Python module?
It is also possible to prefer one language over another without being an idiot about it.
Haskell's list comprehension syntax is similar to your mock syntax: [i | item &lt;- l, i &lt;- item] 
You really want to "fold" the lists using the + operator, which is what "sum" is defined to do. That is, you want to transform: [[1,2,3],[4,5],[6,7,8]] to: [1,2,3] + [4,5] + [6,7,8] So it makes sense to "sum" them here. (Though it would be nice if Python used a different operator than + for list/string concatenation, as + should really be commutative. 
I am also spoiled with python. Verilog is **hardware** description language. While learning Verilog I had urge to modify it, to be more like python. So I started [VerilogScript](http://github.com/emiraga/verilogscript). It's a thin layer arround Verilog, just like Cofeescript is to Javascript.
I'm in the opposite boat. I'm really not liking Python right now, though there are many things I do like about it. I started dabbling probably last year, but have only lately been trying to get more serious, and it feels like a giant mess, and it's a pain in the neck to get things going in it for me. I wish I had a Python guru to hold my hand along the way.
ah true, makes sense if you think it that way but as you say + makes me think of a reduce instead of fold but it's true that `reduce(operator.add, l)` would do the same.
Languages are like girls; like most of them but love only a few
bwahahahaaaa!
Love the elegance of python, hate its slowness. Discover Haskell, get both and cry over the lack of book/people/support/stdlib. You will always have a reason to complain. Shut up and write some code, instead.
Sorry, I used incorrect terminology (thanks to `pwang99` for pointing it out) - I meant to say *method* overloading, not *operator* overloading! C#'s method overloading is where you define two methods with the same name but different signatures (within a class or class-hierarchy). This is generally used to define default arguments. So if Python had this feature, it would be like; class someclass(): def somemethod(self, argument1, argument2, argument3): # [...] return def somemethod(self, argument1): argument2 = arg2_default argument3 = arg3_default self.somemethod(argument1, argument2, argument3) # calls first somemethod because the signatures match. If you actually ran this code, it wouldn't work (even if you put something useful in the first somemethod block :P) because the second somemethod would replace the first, and then the second somemethod would try and call itself with the wrong amount of arguments. The Python solution is class someclass(): def somemethod(self, argument1, argument2=arg2_default, argument3=arg3_default): # [...] return Personally, I like the python solution better, because it's ultimately less code and it's flexible for clients (my favourite example is how you can say `iterable[:]` (copy), or `iterable[start:]` (tail), or `iterable[:stop]` (head), or `iterable[start:stop]` (partition) or `iterable[::step]` (every-nth), and it fills in missing values as start-&gt;0, stop-&gt;len(iterable), step-&gt;1). If you wanted to do this in C#, you'd need seven methods! ____ Edit: Fixed terminology mistake
Things that have bugged me so far in Python: * Some things are methods, some are functions. I.e. list.sort() vs. sorted(list). My best guess so far is that methods work on objects, and functions create and return copies of objects, so list.sort() will actually sort list, whereas sorted(list) makes a copy, sorts that, and returns it. If I'm right about this distinction, and it holds up all through the language, I'll be a lot happier and more secure. * Really struggling learning how inheritance works. I keep thinking I get something, trying it out, and I can't get to variables, or methods return something I don't expect. The easier stuff I get, but it pretty quickly devolves for me. * I often get bizarro answers from Python users who then fight me that they're right, and that my suspicion that this is weird is totally unfounded. They're never even willing to discuss the issue with me rationally. For example, you can do my\_dict.clear(), but not my\_list.clear(), and when you ask about that, they say "Why would you want to do that? Just do my\_list[:] = []" Yeah, shortcuts and sugars are neat, but there are little bizarre things like that all over. What if I want to write something that newbs can pick up on quickly? It would be cool in that instance to just have the immediately understandable my_list.clear(), and not have to roll my own version. * I constantly look up how to solve something, and the examples I find don't work, because I'm in a different version of python. I get that growth is awesome, but dammit all anyway. It's getting frustrating. All this morning that was happening to me. I actually gave up for the morning, saying something like "fuck that, fuck you, and fuck everything," and walked away. * This isn't even worth bringing up, but this is driving me insane: self self self self self self self self self self self self self self self I honestly can't believe you guys think that's awesome. It really clouds up code for me. I feel like I'm supposed to be paying attention to all of these arguments, but I have to ignore 15 or more words on one page, and it does take a toll on my brain. I haven't developed my self blinders yet. Someone on a webpage somewhere said that this really freed up the language to be way more powerful than the 'this' I know and love elsewhere, but then he never said why. No one ever says why. I constantly have Python devs telling me "BECAUSE IT'S BETTER," the end. I *want* to learn. If it's better, show me why. I'm not against better, I just don't believe you. I'm a skeptic. * I mentioned to a python friend that I was having a hard time in a particular app I use that has a Python interpreter now, though it's just wrapping the old embedded language. I used to indent the UI stuff to make it readable as to which layouts and controls were inside of other ones, similar to XML records of UI stuff. I couldn't indent anymore in Python, so I would have like 60 lines of UI commands all flushed up against the left, and it was impossible to comprehend the layout that way. He forwarded it on to a python list and they went nuts. They were so angry at how I coded. I stopped in to say hi, and immediately had to go on the defensive. Their suggestion took about 8 lines of code from me and turned it all into one continuous line of nested calls that was absolutely unparsable to my eyes. It was like Lisp, but without newlines and indents. They thought that was way better. I thought they were nuts. I get what they were saying - using an imperative language's lax whitespace rules to pretty up code into a false version of declarative data is wrong, but I was really limited in the embedded language, and it had worked great and been highly readable and editable for 8 years of my working life, but they really couldn't get past how much they hated me and my old language to help me very much. It even took like 15 replies before I could get a straight answer as to what bothered them so much. * I get why you might make it ' ,'.join(list), but it just feels so ridiculous. I'm embarrassed to use it in my code. I'm used to a language where I can call built-in methods that return other types. This has been some of my experience.
Haskell makes me happy. I still haven't figured out what to do with it though.
&gt; C#'s operator overloading is where you define two methods with the same name but different signatures That's called "method overloading" or "multiple dispatch". When the methods happen to be implementations of operators, then it's called "operator overloading".
&gt; incoherent devision between functions and methods How is it incoherent? &gt;&gt;&gt; class Foo(object): ... pass &gt;&gt;&gt; a = Foo() &gt;&gt;&gt; def func(self, arg): ... print "self:", self, "arg:", arg &gt;&gt;&gt; Foo.bar = func &gt;&gt;&gt; a.bar(123) self: &lt;__main__.Foo object at 0x9558d0&gt; arg: 123 &gt;&gt;&gt; Foo.bar &lt;unbound method Foo.func&gt; &gt;&gt;&gt; a.bar &lt;bound method Foo.func of &lt;__main__.Foo object at 0x9558d0&gt;&gt; 
Yea, clojure is making me dislike Python. Side effects are a pain. But OOP has its place I guess. 
I try to only use languages that don't suck. CoffeeScript is pretty nice if you're used to Python.
Multiple dispatch is completely different from method/function overloading. Multiple dispatch concerns dispatching function/method invocation based on the runtime types of more than one argument. Overload resolution is done using the static (i.e. compile-time) types of the arguments. C# does not support multiple dispatch as far as I know (but I'm not a C# guy). 
Sorry to hear your experience has been so negative. Many people forget that there are coders of all stripes out there and some of them don't "get" the Pythonic way at first, especially if they are really used to something very different. &gt; Some things are methods, some are functions. Generally, as you observed, methods mutate the object and functions create and return new things. In the core language itself, the functions that you generally run into are well documented in the builtins section of the docs (http://docs.python.org/library/functions.html), and they generally fall into a few categories: constructors of built-in types; functional operators on sequence/iterables; printing and debug helps; simple math. Most of the packages I use on a regular basis are pretty object-oriented, and so a lot of the functionality is implemented as methods. The standard library has some modules that are pretty function-heavy, but most of it is pretty object-oriented. &gt; Really struggling learning how inheritance works. Do you mean with multiple inheritance? Or single inheritance? What are some examples of things that tripped you up? I've found Python's inheritance to be pretty straightforward. It's just a cascading series of dictionary lookups. &gt; For example, you can do my_dict.clear(), but not my_list.clear() That's a good question. The thing to remember about list types is that they are *meant* to be accessed using slicing and indexing notation. It's not "sugar". It's a core part of the syntax of how they are supposed to be used. Some of the methods on the list class are redundant, and don't need to be there (extend, append, remove, reverse), because they can be done using the slice notation. It's not really an omission to not have one more redundant method. &gt; because I'm in a different version of python Are you on python 3? That's a fairly new development in the language. Since a vast number of people are still on Python 2 (and will be for some time to come), there are a lot of Python 2.x examples that require some massaging to work in Python 3. Most Python 2.x based examples will be compatible across the 2.x series. &gt; honestly can't believe you guys think that's awesome. It really clouds up code for me. Dunno what to say, except that I don't really notice it anymore. When I coded C++ I used m_ in front of all my member variables. Eventually I moved to using explicit "this-&gt;". I didn't find it to be a big issue. One thing that is nice about it is that you can look at a piece of code and not wonder what parts are part of the instance and what variables are truly local in scope. You don't have to rely on convention or good coding practice on the part of the author of the code, because the language forces you to be explicit about the namespace. &gt; I couldn't indent anymore in Python, so I would have like 60 lines of UI commands all flushed up against the left, and it was impossible to comprehend the layout that way. Hmmm. It sounds like you are trying to install a steering column on a racehorse, and neither one of you is very happy. I would second the opinion that you should probably take a more meta programming approach, although - again - perhaps the folks in the "community" could have been friendlier. I don't really read comp.lang.python any more but it used to be a fairly beginner-friendly place, even in the face of truly appalling code. For shits and giggles I would be interested to see the thread. Perhaps you can link to the google groups or gmane thread. &gt; I get why you might make it ' ,'.join(list), but it just feels so ridiculous. Then don't use it. import string string.join(mylist, ",") The string module is technically deprecated, but it's still there. Better yet, just define your own. In your site.py or somewhere, add the one-liner: strjoin = lambda L, sep: sep.join(L) And from now on you can just call strjoin() to your heart's content. 
This is why I sometimes say that python isn't a good first programming language. It's a great 'only' language for people with other jobs who want to learn programming, but if you want to learn all about programming I think python is a great second or third language. Just my opinion, and probably already repeated on here already. 
But when you have a big bag of nails and a house to put up, using a screwdriver can be pretty bloody painful.
Have you tried Go? I've been very much enjoying it recently and find it a nice blend of Python and C flavours. (And the speed is certainly none too shabby.)
I massively, massively prefer static typing (like Haskell or Scala's type systems implement, anyhow) over dynamic. While there are a few extra steps you have to overcome, they make me feel substantially more comfortable with my code than I otherwise would.
Yes, exactly.
I worked on the SchoolTool project long ago, and the main devs on the project wrote fantastic doctests, I suggest browsing the repo and seeing what you can dig up: http://bazaar.launchpad.net/%7Eschooltool-owners/schooltool/trunk/files/head%3A/src/schooltool edit: actually I'm not finding much, the code has changed a lot since I last saw it of course...
Few? Like, &gt; 1?
Or you may try Groovy++. It adds static typing and makes groovy fly
By using enough other languages that you realise Python sucks too.
My favourite part of Python's cleanliness is that it's not becoming Perl. Generators, comprehensions, context managers, crippled lambdas, no uniformity between classes and functions, freakish import special cases, decorators, scary holes in scoping rules, and god knows what syntax is being mooted currently to add things that should already be there (lexical scope? some bizarre argument-documentation/AOP decoration?). There should be only one obvious way to do it? Really?
Oh wait, let me add the high quality of simple, transparent library code out there. The various urllibs and other things that are superseded in stdlib, paragons of beauty and simplicity and cleanliness like Zope, Twisted, SQLAlchemy. Don't get me started.
Good point, I stand corrected.
What's incoherent about that? You've inserted an entry into Foo's classdict that maps the name "bar" to a function. When you ask the instance "a" for its "bar" attribute, it eventually finds it in its class's dict, and returns a bound version of the function. They are just three names for the same function code: &gt;&gt;&gt; func.func_code &lt;code object func at 0x914920, file "&lt;stdin&gt;", line 1&gt; &gt;&gt;&gt; Foo.bar.func_code &lt;code object func at 0x914920, file "&lt;stdin&gt;", line 1&gt; &gt;&gt;&gt; a.bar.func_code &lt;code object func at 0x914920, file "&lt;stdin&gt;", line 1&gt; 
Yeah, you're right... I don't know what I'm doing, just typed 'bdist' into the setup.py. I guess I'll delete it...
What, some language is making you dislike Python? Unpossible!
Learn Python The Hard Way, by zed shaw. Exactly what you're looking for.
&gt; I actually gave up for the morning, saying something like "fuck that, fuck you, and fuck everything," and walked away. If you want to be a programmer you need patience :) &gt; I wish I had a Python guru to hold my hand along the way. [See here](http://www.reddit.com/r/mentors/comments/czwc4/offer_i_will_teach_you_python_beginner_or/). This does not apply solely to teaching, I can help out and explain stuff sporadically.
All languages suck. Some of them blow. Some bite you in the ass. There have been many holy wars debating which category a language belongs in. &lt;/snark&gt; 
I don't get your logic. Could you explain? How does python being awesome and making other languages feel icky make it into a bad first programming language?
Exactly! I hate that I have to use Eclipse to code Java, but I admittedly think it's kind of cool when you start typing a class name that doesn't exist and Eclipse offers to write the boilerplate of that class for you.
You're not going to feel comfortable with ANY other language until you gain proficiency it. You can't take your "feelings" for Python and port them over to Java. You have to develop your feel for Java. Same goes for any other language. You can't learn a language in a year, it takes about 5 years or maybe even 10 years. Don't confuse "language inferiority" with your own ignorance. Learning a new language is going to piss you off. Learning ANYTHING new is going to be painful because it forces you to change. People are in such dire need of learning this lesson that it causes me a pain!
I cope with the need to program in Java for Android by charging for my application. I'm not gonna subject myself to all those brackets for free!
Perfect. Thank you so much.
&gt;...and thinking to myself, how do the people using these languages get by on a day to day basis? IDEs. It's the only way. I usually hit pr[tab], fi[tab], sta[tab] str[tab] notes="notes.txt";. It's still a mess, but hey, there's no GIL and the language can do a lot of number crunching.
Not only is it fast but you can program some hair on your chest.
I wouldn't call monads supporting the imperative paradigm well.
I'm guessing pohatu means you could jump the gun and get spoiled by python and never have the patience for c.
Well sure, but my parents didn't introduce me to food by first making me eat mud so I could appreciate steak later.
Fuck. Should not have read.
I love that clause. Gets 'em every time!
I am a Java programmer by day and an avid Python programmer. There's one trick to learn that might help: get as experienced as you can so that you only really write small amounts of code because that's all that's necessary :) About the hatred of other languages: it's lame, don't do it. Programming languages are tools, not religion. Some are more useful in certain situations than others.
I like C and even C++ in certain cases, but I hate Matlab. My managers keep assigning me small/medium projects to do in Matlab and I keep finding excuses to do them in Python. They complain, but I'm cranking out enough good code that they're complaining less and less. It's good to know both low and high-level languages, and functional languages, too, and to use the right one for the job. But where a high-level language is right, I want to use a good one rather than a bad one. I don't dare even mention haskell or scala right now, but maybe some day. Java's not so bad. It's like C for Android. If you want to program for Android you should learn it. Eventually there will be better Jython support.
What I was referring to is that there doesn't seem to be any logic to what's a method on a list or string vs what's a function that takes those objects. Even worse, you can't reliably chain functions lisp style because half of them modify an object in place and don't return it. Try using lambdas for anything complicated and you'll soon want to do something not allowed in a lambda like printing. Closures work strangely with regard to modifying their enclosing state. Another gotcha: you can't explicitly reference functions in the base package if their names have been reassigned (in 2.x anyway).
Thanks, I didn't know about that. It seems pretty far from a stable release though.
That is quite possibly the stupidest analogy I've read all day. Congratulations.
I like [Project Euler](http://projecteuler.net/) to learn new languages. It allows you to do things in not the best way, but when you learn new techniques, you can then go back and remake earlier problems.
No, but I make my kids eat the vegetables before they get the rice/pasta/bread. It's kinda like how I think a good first car would be an older, affordable, reliable, stick-shift. You should learn how to shift a manual transmission so that you intuitively understand what the thing does - even if you don't need to understand it to drive a car these days. Plus, one day you might need to drive a stick and you'll want to know how. That's not a great example, because its not as though python hides stuff from you - you actually learn quite a bit about languages and language theory using python. It's more that after using Java or C or C++ you'll better appreciate Python. That, and if you're going to eventually learn C++ or Java, its less frustrating to start with C or Java or C++. If you start out telling the compiler how to do stuff, you can move to Python and have it just know what you meant and learn to trust it. Plus, moving from a code/compile/run/debug or (test)/code/compile/runtests/run/debug model to an interactive shell is awesome. But going back is painful. Although, if you do start with Python, and you decide to learn c#, then iron-python might be an amazing learning tool. You'll be able to use python to get .NET objects and interfaces and learn how they function in the python interactive shell, and then just apply that knowledge to the C# program you're working on in the other window. I don't know if the other python-y things like Jython work the same way. But I also don't really think C# is a good first language, although the coding-for-fun guy is awesome. All that said, I guess it doesn't really matter. I mean, when I said this, I was thinking of the "I'm going to be a professional programmer. I will likely take a job programming C++. I will major in CS." That type of person. If you know you're going that route, I think it's good to start with C. But if you know you're going that route, you're going to learn all about compilers and programming concepts and different languages and stuff, so starting with python isn't necessarily bad. And if you haven't already made up your mind like that, then Python is so much fun that it's probably a really good first language to turn people on to programming. So, I don't know. Am I over the word limit? Sorry for the essay. Telling the compiler what to do and how to do it is a pain in the ass when you just want to tell the computer what to do and have the compiler figure it out. But it's critical to understand if you really want to be an expert - one of the guys the rest of us look up to. They all understand, in intimate detail, what the compiler is doing, and what the linker is doing and all that stuff. And because first impressions leave such a lasting mark, I think having a first language of C is a much better foundation than even Java or C++, or python. Getting your head wrapped around the heap, the stack, the compiler and the linker and enough assembly to understand about registers and the stack pointer, frame pointer, return addresses, etc. If I were designing a curriculum the intro to programming class would be just that, C with assembly. OO can come later, Functional concepts can come later, templates and meta programming and dynamic types and all that can come later. But clearly top universities disagree with me, so, like I said, it's just my opinion.
Thanks for writing this up for me! I really appreciate it and will be referring back to it as I continue learning. I think something that's been frustrating is that nothing works as I automatically think it should. I've very little success in guessing at anything. I'll make an educated guess based on what I already know about the language, it invariably won't work, and I'll iterate for 10 minutes through 2 dozen tweaks, failing constantly, *finally* look up how to do it, and then find I don't really like how I'm supposed to do it in Python. This also makes everything a lot harder to remember. I think I was most in-tune with Flash Actionscript during the MX days. I bought a book on it and read it while a passenger on a long car trip, and I remembered everything I read - cover to cover. I was full of new info, and couldn't wait to get home and start dabbling, and when I got to a computer finally, and installed Flash (had never used it before the ride/read!) I was able to just code up an idea straight through with no referring back to the manual or the integrated help file. It just all worked like I thought things should work. With it I wrote small 3D and physics engines, particle engines, video games, dabbled with my own encryption ideas, did lots of little code-based animation and UI concept demos, and through it all, even random guesses at the proper method names for things seemed to always 'just work.' I would think "It's probably something like .toUpper(), type it, figuring it would burp at me at runtime if I was wrong, and it usually wouldn't. We were simpatico. I would have an idea out at dinner with friends, code most of it in my head while eating, and get home and type the whole thing out from memory in 15 minutes (just like I'm typing this message now), hit run, and it would work. I remember one such incident. I was at Chili's with my pal Jay and wanted to make a crystal ball I could draw on, then spin it around and see the lines through the back of the ball as it spun around. I got home and made it in about 20 minutes (found a pic for the ball, too - it looked pretty cool). I was at a boring family reunion once and asked someone for some paper and wrote a 3D engine in Actionscript on it while listening to conversations from family members, and when I got home I typed it over into Flash and hit run, and there it was - a 3D wireframe object spinning around, controlled by the mouse with the ability to throw it with an inertial falloff. There were no errors on the paper. I felt like Mozart in that language. I feel like a complete retard in Python, failing to get things to work over and over. I'll keep at it. I was terrible at the language embedded in our app at work, and now I use it for everything, and tend to crank out about 200 lines of code per hour. It took months to finally grok it, though, but once I did... That's what I'm hoping will happen for me with Python. I want to get past this banging my face against the monitor phase.
Stop being a snob?
Another flawless victory!
some things to consider: [Narrative tests are lousy unit tests](http://bemusement.org/diary/2008/October/23/narrative-tests) and [Tests are code, doctests aren't](http://bemusement.org/diary/2008/October/24/more-doctest-problems)
Or put them in two suites. The unit tests are what you run often, maybe even have a file save trigger running them. The functional/slow tests go in their own suite; you could even run those in the background, so they don't interrupt your workflow (but maybe beep at you when they fail).
&gt; http://www.tutorialspoint.com/python/python_database_access.htm ugh, terrible, includes an example of using string interpolation to build a query. do not ever ever do that for data values. ever. do [this](http://wiki.python.org/moin/DbApiFaq) instead.
&gt; public class main extends someclass (View view) {... &gt; private final static string notes="notes.txt"; Although it's not pythonic, the above code is entirely clear.
Realize they're all variations of Lisp.
last I played with it is was about as fast as python, but that was quite a while ago. how does it compare now?
This is the flatten function I use in several of my projects def flatten(list_name, containers=(list, tuple)): if isinstance(list_name, containers): if len(list_name) &lt; 1: return [] else: return reduce(lambda x, y : x + y, map(flatten, list_name)) else: return [list_name] It works great for what I need it for :)
You're afraid of them because you don't know them. Also Haskell is the only wide-spread functional language which needs monads to achieve imperative effects. (Also monads are useful for other, non-imperative tasks !)
There's nothing there but consistency and coherence. What are you referring to?
I also dislike this language, you can follow my hatred here: http://twitter.com/pythonhater
The concurrent_map function spawns a new thread for each element witch results in an additional linear operation, i.e. Θ(n). Computationally intensive functions, well known candidate for parallel processing, would actually run very slow on this implementation due to sheer Thread overhead.
Many of the things I'd forgotten upset me are in there. Thanks!
&gt; reduce(list.__add__, l) Dude, gross! As a rule, you should rarely if ever need to directly access "protocol" methods (those with double leading and trailing underscores). For instance here you could/should use `operator.add`.
no pypyor psyco benchmark?
Same here. LISPness, destructuring, minimalism, persistend data structures, builtin concurrency, JVM/CLR based -- I'm really liking what I've got here.
Or simply getting good enough at the one that you are using that you start running into its limitations so often you find yourself wanting to scream. (I don't think you actually need to use other languages to come to the vital epiphany that the language you are using sucks, although you certainly due to come to the much /more/ vital epiphany that all languages suck ;P.) (Upvoted, btw.)
First your learn Lisp. Then you realize you hate Python, too. Then later you realize you also hate Lisp, and accept the fact that every languages make their own trade-off, and that your current language also has its drawback, too. By the way, don't try to program Python in Java. Each language has its own convention and best practice. Working against how the language was designed to be used is only going to make you hate the language more, when you actually only have yourself to blame.
But he is at class declaration (notice `class` keyword). May be I've been away from Java too long but I don't think you can pass parameter to class declaration that way.
There's [`map_async()`](http://docs.python.org/library/multiprocessing.html#multiprocessing.pool.multiprocessing.Pool.map_async) also.
I'm using it for some statistics work and it's blazingly fast for my purpose. (And I'm using the 6g compiler, I read the GCC back-end is even faster.) My Python experience has always involved hits on a DB so I can't mentally compare the speed of two very accurately.
I think I will give it a shot later in a mac machine, any test suites in the package?
I very much agree with your first pieces of advice, but 5-10 years to learn a language? I concede that you will *continue* to learn a language after 5-10 years -- and that mastering may well require as such -- but I think a very good level of adeptness with a language can be achieved much sooner with frequent use, viewing of others code and discussion with others.
Why is that? p.s: It's an overstatement to say Haskell uses "monads for imperative programming", it just packages a tiny part of its imperative DSL interface that way.
What stuff do you program in other languages?
"reduce" is a fold.
I've been meaning to read up on this... do you have to do the graphics using javascript etc., or is there a way to still code in Python?
For this particular case, you'd want to use the multiprocessing module's `map` instead: http://docs.python.org/library/multiprocessing.html#using-a-pool-of-workers
It's clear in the sense that it's descriptive how what it is and what it does, but it's hardly _zen_. I feel for the OP as I recently did a project in ActionScript and a lot of things made me twitch (an empty `Array` is _truthy_? I can't iterate over a `Dictionary`? I have to import _one class at a time_ or _all of them_? There can only be one "visible" declaration per file?) in addition to the bloated Java-esque syntax. Yes, explicit scoping and type declarations can be useful (or at least I hope so, because so many languages have them). But there is something to be said of Python's conciseness -- it manages to erase a lot verbiage (cf. Java) without hampering readability (cf. Perl). And this isn't just because it doesn't have type declarations, but because it has a lot of sugar (syntactic or otherwise) that just makes your life easier.
I wouldn't call myself a python ninja but that's close to my experience ;-). Probably there's a bigger disappointment in python because there is "import this" and so few contributors seem to get it.
I suppose I shouldn't be surprised that such a completely insightless comment has garnered so many upvotes. The properties you mention belong to C certainly, I'd also mention Scheme, Tcl and Javascript .. but Python doesn't belong in the same breath unless it's your first day using it.
…or so they say. Truth is, for most programmers there's either no choice which programming language to use or the available languages are so similar in how appropriate they are for the given task, the differences don't really matter. Ideally, you'd always pick the language that is perfect for the job. In practice, however, it depends on lots of other factors (i.e. the context rather than the problem itself). It doesn't matter unless you really need to optimise, anyway. The right tool for the job is the one you know how to use, though it's debatable whether you're also the right person for the job in the first place (e.g. if all you know is embedded C and the client needs a website).
Euler's also great because along the way you build up a library of reusable code in unexpected ways.
Yes, sometimes. I've been using PHP for years before picking up Python. I know less Python than PHP, but I still find Python more comfortable to code in. The same is true for Java and JavaScript: even when I knew less Python than each of those, I preferred Python. It's possible to prefer a new language over an old one. But I guess it depends on the circumstances under which you pick the new language up: if you do it voluntarily, your chances to like it better are quite good. If it is forced on to you, not so much. However I feel that Python has spoiled me. Any language with braces automatically feels kludgey to me. But I can live with that as long as I can code in Python for myself.
Sounds like you're trying to write LISP code in Python.
Just use: class someclass(): def somemethod(self, arg1, arg2="arg2_default", arg3="arg3_default"): pass Or using kwargs: class someclass(): def somemethod(self, **kwargs) arg1 = kwargs[arg1] if ("arg1" in kwargs) else arg1_default etc...
True, method overloading can be helpful, but it's not very meaningful in dynamically typed languages like Python because where it excels is class polymorphism (which needs type checking). Overloading methods for argument counts is mostly a hack. In Python you can use defaults for missing arguments, which makes the creation of shorthands (the static equivalent of currying) unnecessary. Overloading methods in dynamically typed languages for other purposes (i.e. having `foo(a)` do something different from `foo(a, b)`) is usually asking for trouble because it hampers readability and is not very explicit. I don't see how Python could possibly implement any meaningful form of method overloading. Somewhat OT: Something I always miss in languages that allow operator overloading is the option to define _new_ operators. This will probably not happen in a major language until Unicode becomes the status quo (sadly many programmers still think ASCII is good enough for everything), though, and abuse could likely result in a new APL or worse.
Fair enough.
True. Not all other languages are Java. There's also Perl and PHP. `*cringes*`
Isn't Groovy more like Ruby than like Python? 
Cool, thanks!
You do know about both `sys.stdout.write` and `__builtins__`, don't you?
PyPy has a translator in it. Write RPython and compile to blazing fast ELF's ;) http://www.rfk.id.au/blog/entry/compiling-rpython-programs
C# has some really awesome features that do not work in python due to how the language is designed. In c# a namespace is stateless ehich enables all kind of things that would never work in python. You can load libraries into different app domains, a concept missing in python. C# has static typing but can still fall back to late binding which is awesome. It has extension methods that do not depend on monkey patching. It has awesime native code interop, allows to inject meta information to *anything* and has a specified bytecode and with new versions even a documented ast. It has Linq, multimethods, generics, proper interfaces and so much more. It's nkt only the runtike that rocks but also the core libs. Everything supports proper unicode and i18n, l10n Nd more. I think it might be the most ambitious and best designed language und runtime i have ever sorked with.
I've just never run into any problems where pythons 'slowness' was an issue for me. Everything I've programed has long pauses between activity, or they are GUIs. I've never had to do massive number crunching or 3D.
Right, so the list is now: 1. Python 2. Java 3. Perl 4. PHP Any others? Does anyone know of *any* other languages? I think we've got them all, time to publish a blog with our list of the top 4 programming languages!
I have the first page or so done on there, it's great. 
[Programming Praxis](http://programmingpraxis.com) provides a collection of etudes, updated weekly, for the education and enjoyment of the savvy programmer.
Exactly what I'm looking for. Thank you lots. Anyone have anything else like this?
&gt; there doesn't seem to be any logic to what's a method on a list or string vs what's a function that takes those objects For lists, you mostly use slice notation, and very seldom use methods. The only methods that might be useful are index(), pop(), remove(), and the in-place reverse() and sort(). The len(), reversed(), and sorted() functions can be used if you are trying to chain up functions. If you need to chain up a lot of list operations, you just chain up the index operations. Unfortunately, this becomes unreadable very quickly. So, most of the time, I find that I do list or generator expressions with if-statements. For strings, just keep in mind that they are fundamentally immutable. Therefore, everything is a "make a copy and reassign the variable". &gt; Try using lambdas for anything complicated and you'll soon want to do something not allowed in a lambda like printing. if you really need to print inside a lambda, use sys.stdout.write(). You're right, though - lambdas in Python are not mean to be used as ubiquitously as blocks in Ruby. On the other hand, if you are writing a giant multi-line lambda, just stick a def and a name in front of the damn thing. &gt; Closures work strangely with regard to modifying their enclosing state. Can you elaborate? &gt; Another gotcha: you can't explicitly reference functions in the base package if their names have been reassigned We'll replace the string.join function: &gt;&gt;&gt; myfunc = lambda x: x &gt;&gt;&gt; myfunc &lt;function &lt;lambda&gt; at 0x952730&gt; &gt;&gt;&gt; import string &gt;&gt;&gt; string.join &lt;function join at 0x96d2f0&gt; &gt;&gt;&gt; string.join = myfunc &gt;&gt;&gt; string.join &lt;function &lt;lambda&gt; at 0x952730&gt; Re-importing doesn't work, because the string module is in the sys.modules registry: &gt;&gt;&gt; from string import join as realjoin &gt;&gt;&gt; realjoin &lt;function &lt;lambda&gt; at 0x952730&gt; &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.modules["string"] &lt;module 'string' from '/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/string.pyc'&gt; So, we move it out of the registry, and re-import the function we want, then replace it: &gt;&gt;&gt; _string = sys.modules.pop("string") &gt;&gt;&gt; from string import join as realjoin &gt;&gt;&gt; realjoin &lt;function join at 0x96dc30&gt; &gt;&gt;&gt; sys.modules["string"] = _string And now everything is cool: &gt;&gt;&gt; string.join &lt;function &lt;lambda&gt; at 0x952730&gt; &gt;&gt;&gt; realjoin &lt;function join at 0x96dc30&gt; Alternatively, if you think this is gorpy, then you can try using the functions in the importlib to directly do the import.
Awesome! Nice vimeo channel with more video also: http://vimeo.com/groups/pymt
The last time I didn't know what to code, I founded http://www.reddit.com/r/SomebodyMakeThis :)
Write a simple raytracer. May seem crazy, but you'll learn a lot from it, even if it takes you weeks to complete it.
If you're interested in math and algorithms, [Project Euler](http://projecteuler.net/) is a good site to work through.
It's not too hard. You just have to change your ant rules to compile your scala. Here's a [tutorial](http://www.tylerlesmann.com/2009/dec/04/integrating-scala-android-ant/) on how to do that. It only covers up to the 2.0 SDK, but it's easy enough to figure out. Performance is nearly the same as plain Java in my experience.
I am in the same boat.
That looks horrible. :|
That's what I was thinking. If only his explanation actually explained what that's doing...
pythonchallenge.com
The original point was that Python isn't clean because it has lots of special cases. You can do things with enough knowledge, but the language doesn't have the top-to-bottom consistency of Lisp, Smalltalk, or even C, where everything works the same way. Your example works with string.join but I don't think it will work with map. I did "from theano import *" recently, which replaces map and other base functions with ones that work on numpy arrays. I don't have the environment handy to test but I don't think your method will work to get them back because base isn't a real package. Regarding closures, the issue is that closures can assign to globals but not to locals from the enclosing function's scope because assignment will implicitly create a new local variable (and there's no local or lexical keyword corresponding to global). The workaround is to use arrays (x=[1] instead of x=1) and alter those if necessary. 
Groovy is semantically very much like Java but with dynamic types, closures, and chainable functions. I don't know Ruby but it always struck me as more perl inspired.
Yes but my point was that Python makes you know lots of special ways to do particular things instead of having one consistent way.
Python encourages this by giving map, filter, reduce, any, partial, etc. but the resulting code is ugly because you have to keep jumping back and forth between list methods, base functions, and array slices.
Instead of starting a whole new project by yourself, I would recommend you join one that is of your interest (some app or library you will use). Project management is a different skill than programming, and like you learn to program by reading good code, it is good to learn project management by following/contributing in matured projects.
For learning functions and idioms, try and implement some sorts (quicksort, shellsort, mergesort, etc.). Your results won't ever be as good as the built-in sort (which, by the way, is timsort) because it's optimised like mad and python primitives (eg, list) aren't as efficient as C primitives (eg, arrays), but it's still a lot of fun to see the container pop out sorted. For learning classes/OOP/python data model, try and write your own data structures. You could write a chain map (dictionary which searches multiple primitive dictionaries in some order), or a numeric type with weird behaviours (eg, a float which automatically absolutes itself), or any kind of exotic structure. If you're up for a real challenge, try and write a generalised publisher/subscriber model. And check out reddit's [SomebodyMakeThis](http://www.reddit.com/r/somebodymakethis). Also, be sure to peruse the python [language reference](http://docs.python.org/reference/index.html), as well as the python [library](http://docs.python.org/library/index.html), and especially the python [built-in functions](http://docs.python.org/library/functions.html). There's a lot of stuff in there that can save you a lot of grief if you know about it.
Couldn't agree more. 
Some of them are quite useful, but comprehensions make some of them redundant, too. I guess it feels ugly if you're coming from LISP and want to follow a strictly functional style.
Is pt2 coming out someday?
Because most people (including myself) have no problem picking up another imperative language, whereas I'm still struggling to fully understand do-notation. How else can you do imperative programming without monads or something like unsafePerformIo?
You're right, I don't know them, but it's not for a lack of trying. Imperative-style programming in haskell is way harder than, say functional-style in python, ruby, or javascript.
This is a good idea, it will give you something tangible (well, as tangible as a digital image) to show off. Just start simple, only spheres to begin with. Then you only need to focus on the calculations that describe a sphere. If you're interested I can try to dig up an old C++ program that did this.
&gt; The original point was that Python isn't clean because it has lots of special cases. You can do things with enough knowledge, but the language doesn't have the top-to-bottom consistency of Lisp, Smalltalk, or even C, where everything works the same way. Python as a language has been accumulating features over the course of its 20 year history, so that contributes some warts. Some of Python's "uncleanliness" (as you put it) results from the fact that is multi-paradigm, so you can both treat some underlying data structures in a functional way, or in an object-oriented way. &gt; Your example works with string.join but I don't think it will work with map. Well, it doesn't really need to work with map. map is defined in the _ _ builtins _ _ module, which cannot be overridden. &gt; I did "from theano import *" recently, which replaces map and other base functions with ones that work on numpy arrays. It replaces them in your local namespace. You can always get access to the default implementation of map by doing: map = __builtins__.map In any case, you really shouldn't do "from PKG import *" in production code. Most experienced python programmers will encourage you to keep explicit namespaces. I'm also curious why Theano feels like it needs to replace map(), since numpy arrays have always supported iteration, so the built-in map() should work just fine. &gt; Regarding closures, the issue is that closures can assign to globals but not to locals from the enclosing function's scope because assignment will implicitly create a new local variable (and there's no local or lexical keyword corresponding to global). The workaround is to use arrays (x=[1] instead of x=1) and alter those if necessary. Yes, there isn't a simple way to step outside of your local scope to just the enclosing scope. I'm curious as to what your use case for this was - I've never run into it, and I use closures with some regularity. 
I did the import in a long-lasting ipython session was was annoyed that I couldn't get my environment back to a usable state without restarting. I wouldn't normally try to modify external state from a closure but the use case is to keep a count of how often something was executed, like a gradient update step in an optimization process. 
A lot of them don't seem to be updated anymore. too bad, I could go for a python on a chip.
&gt; Because most people (including myself) have no problem picking up another imperative language, whereas I'm still struggling to fully understand do-notation. That's because most imperative languages are more similar to each other. I'm also pretty sure it's not "do notation" you have a problem with, but with the combinators it expands to. &gt; How else can you do imperative programming without monads or something like unsafePerformIo? If IO had: bindIO :: IO a -&gt; (a -&gt; IO b) -&gt; IO b returnIO :: a -&gt; IO a instead of a monad instance, then you could still use the IO DSL in the same way, but there would be no mention of "Monad" anywhere. The fact these 2 functions match the structure and the laws of: (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b return :: a -&gt; m a means that these 2 combinators can be put in the "Monad" instance, so you get a bazillion functions for free.
I had great fun writing an IRC server, you can try that. 
I spent several days looking into PyQT, PyGTK, WxPython, and Tkinter. I ended up settling on Tkinter out of simplicity. In the future, I'll probablyrevisit WxPython or PyGTK.
I'll need to check this out as well. (http://page.sourceforge.net/)
Thanks everybody. Found lots of cool stuff.
I'm learning python myself, there are several books in this free collection I downloaded that are probably relevant to your interests http://www.esoft.in/ebooks/27486-python-programming-ebook-pack.html I would in particular skim the game development books.
I agree with you. In fact, I think that monads shouldn't be learned with Haskell, where they are too important. I think that I understood monads (if I did !) by learning them with OCaml : as OCaml is a non-pure language, monads are not used to achieve imperative programming (and it don't bother you with do notation unless you want to use the camlp4 extension). Take a look at Parsec, it also is an interesting way of learning monads.
[Python imaging library](http://www.pythonware.com/products/pil/)
Right now, web programming in Ruby and Python, and fun music stuff in Ruby. I've thought about the potential of Haskell with musical applications but I haven't explored the idea fully yet.
is fold a reduce as well? I was thinking on erlang's fold which takes an accumulator separately from the input list, I think that difference may give you more flexibility than reduce, am I wrong?
Write a program to come up with ideas for projects.
&gt; I want to learn how different image formats are stored, how they are different, and how to work with them. Source code isn't always the best way to understand how image formats are stored. I have found that reading specifications for a particular file format is a better way to figure that out. PIL, Imagemagick, etc. are going to give you a quick way to load and manipulate images. If you have a particular application, it might influence what you are doing. Are you just playing around? Are you building a game? Are you making images from a math algorithm? I have made images in PNM format that my program wrote the file using a couple of write statements.
the main types of list folding are left-associative fold (foldl) and right-associative fold (foldr). For example, a foldl with division and "1" as the base element evaluates to: foldl (/) 1 [1,2,3] == (((1 / 1) / 2) / 3) (parenthesis stick to the left). A foldr with the same params evaluates to: foldr (/) 1 [1,2,3] == 1 / (2 / (3 / 1)) (parenthesis stick to the right). In Either case, you could say there's an "accumulator" taken separately from the list. So reduce is just another name for "fold". It's not more powerful or weaker.
Haskell is getting some nice web frameworks too.
&gt; I did the import in a long-lasting ipython session was was annoyed that I couldn't get my environment back to a usable state without restarting. Yes, that is annoying. However, IPython is a thin wrapper around the underlying Python interpreter, which *does* allow you to make irreversible changes to the namespace and even the underlying OS. It's not Mathematica or Matlab, even though it can be made to look pretty close. &gt; I wouldn't normally try to modify external state from a closure but the use case is to keep a count of how often something was executed, like a gradient update step in an optimization process. If your callable intrinsically has state, then make it a callable class with a class variable for keeping count. You can define an nested class just as you can define a nested function. class myfunc(object): callcount = 0 @classmethod def __call__(cls, *args): cls.callcount += 1 # do stuff 
I want to make cellular automata and stuff like that and make images from them. I'm just playing around. I also want to make images of fractals, like the Mandlebrot set. So yes, I am making images from a math algorithm.
incredibly helpful. lolz.
So I hear - time to look into it again. :)
I've been using Python for a little while, and I'd tend to agree that its a fairly simple language. This feeling is especially strong since I just spent 2 hours with a mentee of mine searching the internet for the exact differences between $foo and @foo in Perl and how to accomplish something vaguely like a = [(i, foo(i)) for i in some_generator()] for num, num_str in a: what-have you After having gone through that cluster fuck, I feel like Python is positively elemental. What do you think makes it complex? 
how about this? lists:foldl(fun(X, Count) -&gt; Count + 1 end, 0, [1,2,3,4,5]).
too bad all the imaging libraries do not have python 3 versions.
Yes, avoiding recursion usually leads to ugly code. However the `lst[i:i+1] = lst[i]` idiom is a nice one.
Pygame. Write a video game.
Yes, PIL is good. I prefer PyCairo for pure drawing. But it doesn't support as many image formats as PIL, so it's not a full replacement.
http://www.pythonware.com/products/pil/ says that a Python 3 version of PIL 1.1.7 is planned.
so does this mean that plugins written for Vim can be created using Python 3 now?
The post was not meant as a general benchmark shootout, more of a look back at what has been achieved (and what is still left to do).
I once modified my python ray tracer to do all the primary rays for each pixel and cache the results then do all the secondary rays for each pixel and so on. The idea was to make it look cooler when you were watching it render, with each pass adding more detail. But the huge overhead of python objects meant it wasn't long before I ran out of memory and my machine crawled to a halt.
do you work ? maybe you can apply it to your work
wth is a "raytracer" ?
where ?
Thank you for that.
[Invent Your Own Computer Games with Python](http://inventwithpython.com) is a free Creative Commons book that lists the source code for several game projects. You could either try writing your own version of the games or changing the source to add new features.
A program that traces rays.
[Invent Your Own Computer Games with Python](http://inventwithpython.com) is a free Creative Commons book that lists the source code for several game projects. You have the complete source code for actual games, and you learn the programming concepts from the source code.
Here is Haskell to demonstrate: Prelude&gt; foldr (\x y -&gt; y + 1) 0 [1,1,1,1,1] 5 Prelude&gt; foldl (\x y -&gt; x + 1) 0 [1,1,1,1,1] 5 And in Python: &gt;&gt;&gt; reduce(lambda acc, x: acc+1, [1,1,1,1,1], 0) 5 
I can't help you hate other programming languages less, but after ten years of professional Python development I can definitely give you tips on hating Python more. ;-)
.
Is this open source, or the code otherwise available? PyPy's objects are usually a good bit smaller than CPython's, so it might be possible to run this (and it sounds like in general it'd be a good benchmark).
amazing! didn't even knew that `reduce` accepted an "initial" :) thank you
You declare a bunch of geometrical 3d objects mathematically (sphere here, box there, etc) and then you shoot "rays" from some imaginary position of the viewer to each of the screen pixels. You "trace" the ray through the mathematically described model to find the "intersections" of the ray with the objects in it. Then, when you've encountered an object, you can trace a ray towards the reflection. In effect, you're reverse-tracing the light as it hits the object and goes to the pixel. This allows for a very precise/realistic computation of the colors pixels should have to render a scene. Things like glass can be modeled by splitting the ray to continue through the glass, and towards the reflection. It is also not very complicated, you just have to solve some simple intersection equations, and rotation/finding normals.
You may want to look at numpy/scipy/matplolib if you're doing math (lots of math and matrix built-ins, and associated graphing tools). See http://www.sagemath.org/ for a starting point for a package that contains most/all of the software you'd need to start out. Re: a mandlebrot set, there is a very poor tutorial on doing this here: http://www.scipy.org/Tentative_NumPy_Tutorial/Mandelbrot_Set_Example * edit: removed the period at the end
Reddit: The new Google
I've taken a couple of stabs at converting a big (and ugly) program over to PyPy but cannot for the life of me get it working with custom C-extensions. I've recompiled and imported the cpyext module but no joy. Pre-Alpha indeed. Can't wait for it to get ironed out though.
Looks like p14p is alive.
[Seriously.](http://www.google.com/#hl=en&amp;source=hp&amp;q=how+do+you+work+with+images+in+python)
The article appears to answer that. Yes.
I don't know if you already have, but you should join us on http://codespeak.net/mailman/listinfo/pypy-dev we are generally helpful there :-). There's also #pypy on irc.freenode.net which is a good place to go depending on your timezone. Either way I'm sure amongst us is someone happy to help you. I made a fair number of changes to try and get NumPy to work on CPyExt (currently to no avail), the needs of a particular module or two are likely going to be the driving force behind developing CPyExt, so I encourage you to work with us on it.
Yeah that was exactly my thought when I saw the implementation. His benchmark (retrieving URLs) worked very well with his implementation because the bottleneck was the network. I suspect it'd work well with disk intensive tasks too, but some kind of thread pooling would be necessary for it to do well on CPU-bound tasks.
Why do you need to store more than two levels of rays?
Nope, you are right, I didn't read it properly.
Mostly growing number of synctactic features, the lack of compositionality which should make them unneccessary. See [here](http://www.reddit.com/r/Python/comments/d1ulc/so_how_to_you_learn_to_not_hate_other_programming/c0wyzw5) for example. The thing is, Python is quite simple and rather beautiful for short scripts – but once you start using it seriously the warts appear.
Plug: [processing.py](http://github.com/jdf/processing.py)
I had a lot of trouble building PIL on Snow Leopard, so your mileage may vary. Other than that it works pretty well. [Here's a neat little script to get you going](http://code.activestate.com/recipes/412982-use-pil-to-make-a-contact-sheet-montage-of-images/) It shows the basics of importing the image, scaling it, combining and writing it. Toy around with it and you can make checker patterns and so forth.
True. It doesn't get any poorer than: &gt; This page does not exist yet. You can create a new empty page, or use one of the page templates. 
Image file formats have nothing to do with that. If you want to generate images you'll likely want to generate a bitmap (just a matrix with each element representing a pixel's color). Different image formats are just different ways to compress that bitmap.
Thanks, I'll have to check that out. I'm going to take another shot and re-building the extensions in the morning via distutils. The current flow is kind of custom (read: poor).
I love when people make php look/function like java
build lipjpeg and libpng first, it helps. Edit: also freetype2
Remove the period at the end, [thusly](http://www.scipy.org/Tentative_NumPy_Tutorial/Mandelbrot_Set_Example).
MIT and new BSD licenses are GPL-compatible. He doesn't need a non-infecting clause.
not necessarily at the same time
sorry I thought it might be n00bish question lol
Yes, he does, if he wants code that uses PyQt to be releaseable under the BSD or MIT licenses. GPL-compatible means that you can take GPL code and BSD/MIT code, combine them (this includes library imports), and release the result under the GPL. The non-infecting clause/BSD-and-MIT "exception" that PyQt makes means that you can release code under the BSD/MIT licenses that makes use of PyQt as a library. Without it, code using PyQt would itself need to be released under the GPL in order to be in compliance, unless one acquired a commercial license. See [this entry of the GPL FAQ](http://www.gnu.org/licenses/gpl-faq.html#WhatDoesCompatMean). IANAL.
I don't understand why people feel the need to say this every damn time. Maybe he's looking for a realistic example. Sure, I could look through google to find a GUI library and test a few - or I could ask reddit what to use, since I trust fellow redditors.
I reverted the code as soon as I realised what was happening, but I might have kept a copy in source control.
OMG! Nerd orgasm.
From memory it ran out of memory and bogged down long before completing the first pass on a 800x800 pixel image.
While on the topic, anyone know of any python code handling PGF files? A [libpgf](http://libpgf.org/) wrapper, or whatever? 
I would love to use the ray tracer (in its official or modified form), link?
No, but you can always wrap a library with ctypes.
i still use 2.x because some of the libs i use dont have 3.x equivalent :-)
I use 3, but I'd never suggest you learn with 3. Learn 2, use it for several months and then switch to 3. The more you know about 2, the more you'll understand and appreciate 3. It won't be a difficult transition. It will not be hard to update your code or your skills. Also, if you learn 3 first you'll never bother understanding why 2 works the way it does, and you'll constantly come across old libraries and code you don't understand. This advice will not apply in a year or two as everything moves forward.
IAMA pretty much Python newbie but still have some commercial django apps to my name. I just kinda seem to learn it as I go along. I'm just *starting* to appreciate 3 and by the time it becomes properly mainstream I'll probably be gagging for it. http://www.zedkep.com/blog/index.php?/archives/313-quote_plus-retardation-and-Django-saves-the-day-again.html
&gt; python2 is deprecated and is on its way out. not quite so. Python 2 is going to be around for years, only quite likely less and less used for new projects understandably. Python 2.x has much more legacy than 1.x so unlikely to disappear overnight. With that said, I don't see both as massively distinct aside from a few critical aspects (probably my main point would be the switch from a unique str type to conceptually consistent unicode/byte types). Right now, I would probably choose Python 3 if I started a long term project and whatever comes for smaller scripts.
Django handles most of the unicode problems with 2, so you've probably just been lucky. [This](http://diveintopython3.org/porting-code-to-python-3-with-2to3.html) is a good summary of the differences between 2 and 3. Sometimes you have to explicitly ask for lists, the builtin reduce is moved to a module, apply went away, and lambdas have more restricted namespaces, but the benefits are really nice. Old style classes are gone, raw_input and execfile and &lt;&gt; and \`backticks\` are gone, sets can be defined like `s = {1,2,3}`, and we have set and dictionary comprehensions a la: `squares = {n: n**2 for n in range(100)}`!
same here. But I worry about porting over to 3, with quite a lot of syntax changes, it's going to be hell
There is also imagemagick.
Much obliged.
You know the [2to3](http://docs.python.org/library/2to3.html)? If yes, your statement is quite nonsense, if not, have a look and be more optimistic!
It has only one string type. That's reason to switch right there.
And no more long vs. int. And 2/3 != 0
I find it interesting you mention coming to understand and appreciate 3. I've never seen a mention of any compelling reasons to move to 3, and I've used 2 for many years. Would I need to move to 3 to acquire these things? Are you sure that's not Stockholm syndrome? :)
After having used 3 (almost exclusively) for the last two months, 2 seems bloated with idiosyncrasies. I had no compelling reasons to switch until I started writing a unicode tool which really showcased the problems with 2. With 3 it's usually a pleasant case of "oh, I don't have to care about that anymore!" The overall migration will be slow, but your personal experience needn't be. 2to3 is really good at porting code, and you can pretty much continue doing what you already do.
i dont think its going to be hell, from my side of things changes should be pretty cosmetic ;-)
oooh, TIL
Python3. A lot of what I write is small, simple, and doesn't need many libraries beyond Python's extensive standard library. And Python3 is a better language in several small ways.
Screw 2to3! What is needed, is a working [3to2](http://wiki.python.org/moin/3to2). That way developers can port their libs, maintain one(!) canonical trunk and still offer backwards-comatibility. 2to3 conversion is not a working solution because of the string -&gt; byte/unicode mapping (it's ambiguous and needs manual intervention).
Python 3! For my needs, simply scripts, it is the better choice. In your case I'd strongly recommend starting with Python 3. Every language takes some time to learn so i don't expect you to need to many 2.0 only libraries. Also the world is sliwly moving to 3.x Python and the library situation gets better every day. In any event you won't be using many of those libraries to start. Depending upon where your interests lay you may never have a need for those 2.x libraries anyways. In the end if you are starting out it is a good idea to learn on the better platform. Dave
Python 2.7, trying to keep backwards compatibility until 2.5 for larger projects and scripts(without back. comp. obviously).
I really need to start writing in 3 for the small more scriptish-type code. But my main python activities involve Numpy and Scipy and other libraries that don't (fully) support Python 3 yet.
If you are a complete beginner it does not much matter whether you use the more common 2.6 or 3.x, just be aware that the majority of the tutorials and such will focus on 2.6 features. The "sexier GUI" is a syntax highlighting editor or IDE - [PyDev](http://pydev.org/) is a pretty good one and will work on any of the common platforms (Windows, MacOSX, Linux) [Useful Links to beginner material](http://wiki.python.org/moin/BeginnersGuide). I'm not going to answer thirdly, if you don't find the answers for yourself you won't learn but the above is more than enough to deal with your "assignment". Good Luck!
The courses have used Python 2.x series. Since you are a beginner, I recommend just getting the 2.x series and working with it.
For me, it comes down to the libraries I use, so Python 2 most of the time. Visit blip.tv for videos discussing Python 3. 
I've tried many approaches with complete beginners. So far, every single one has found difficulties in completely different aspects of programming and python in particular. I'm always willing to try with different people, but the one-true-book approach really doesn't work. That's why "dive into python" succeeded - it's for a very particular kind of person: those who already program something else.
+1 for Python2 is going to be around for years because of legacy stuff -1 for recommending 3 anyhow. Everyone is still using 2 for everything, afaik
NumPy already does. SciPy is on the way.
2, because that's what's installed at work, and that's what all the libraries support. But this isn't really a big deal. They're not that different. You can convert most pure-Python code back and forth very easily.
Python 2. Python 2 has a massive amount of documentation and libraries available. Python 3 will need years more to get there. I'm pretty confident in saying that the overwhelming majority of developers that use Python uses Python 2 for their daily work. 
It's debatable. Mostly I'm still using Python 2 so the rationale would seem good but I feel you can't really go wrong using Python 3 in many cases already. Unless you already know there is one lib you'll require that doesn't run on it, I'd say there's not much stopping you from making the jump.
If it's going to be on-line I use 2, until Django is ported to 3 that's the way it's going to be. (And that will probably be many years from now.) If it's not going to involve a framework I tend to use 3.
In fact you have to care about unicode in 2 in almost the same way as in 3. In 2, you have strings (bytes in 3), and unicode strings (text in 3). You shouldn't mix them without doing some conversion, which is either to unicode or from unicode. The main difference is that Python 3 enforces this, while Python 2 allows you to mix them anyway and have it blow up in your face sometime later in your code. Doing it right in Python 2 takes discipline (converting to unicode on input and to strings on output, unicode in your app throughout), but the actual operations you need to do are the same as in Python 3. Upgrading an undisciplined Python 2 codebase to one that uses unicode in a disciplined way can be a major pain. But you'll have almost the same amount of pain in upgrading an undisciplined non-unicode Python 2 codebase to Python 3. Witness the endless discussions about what to do with unicode in WSGI in Python 3 for an example of why you do have to care about it in Python 3. 
&gt; Doing it right in Python 2 takes discipline (converting to unicode on input and to strings on output, unicode in your app throughout), but the actual operations you need to do are the same as in Python 3. Not exactly, because far more operations in 3 are unicode-aware (because they're just using the default string type) whereas in Python 2 code is far more likely to fall over itself because APIs were expecting str (and completely not unicode-aware) and you gave them unicode. 
Agreed. I'll be happy when 2to3 converts the source for C modules as well.
python2. I love all the batteries, especially the ones that aren't included. Until they upgrade, I'll stay here.
yeah personally I really hate the adding of parens to the print statement. I use it a lot in debug and the parens make it slightly more cumbersome to use, kinda like semicolons.
Yes, if you interface with a library that does the wrong thing with unicode, you have a problem. I was describing the discipline you have to take in your own code in the assumption that you don't have to deal with that sort of library a lot. Note that much Python 2 code that just works with strings will also work with unicode strings, unless the library itself tries to do encoding the wrong way, or if it deals with data coming from the outside world. In that case you'll have to deal with the conversion yourself, but then again, you'd have to do the same thing with a Python 3 library that takes bytes only. I've heard that even in Python 3 parts of the standard library don't handle encoding issues correctly or at least not conveniently. That these issues surface now is in part because Python is more strict, but I suspect also in part because code that used to be generic enough to handle either (by accident) doesn't work anymore because Python became more strict, and use cases for both bytes and text use exist for the same functionality. By the way, I'm not arguing that Python 2's way is easier than Python 3's way. Python 3 has the better design. I'm just arguing that Python 2 + discipline is quite similar in use to Python 3. Case in point is zope.schema, which since 2002 or so has defined a bytes and a text field. 
You don't always know in advance that libraries you require, and when you find out that you do need one, the chances are a lot higher it'll be there for Python 2. 
&gt; Yes, if you interface with a library that does the wrong thing with unicode, you have a problem. I was describing the discipline you have to take in your own code in the assumption that you don't have to deal with that sort of library a lot. The problem is that many such libraries are part of the wider Standard Library. And then you're fucked.
You are welcome to help with trivial python3 migrations like: http://mercurial.selenic.com/wiki/Py3kPort . (took one GSoC to have one command working, and it's not because the guy dropped out, quite the opposite actually).
For us still on 2.x, what do you find better in 3?
I'd love to jump headfirst into 3, but my job involves a large django project and makes heavy use of scapy. Until these are ported (not holding my breath), I'm afraid 3 is a non-starter. I don't want to keep two installs around, either. I'm also rather concerned about mod\_wsgi. My understanding is that making a working python3 version is problematic because it uses a lot of string operations on str() types where the encoding is not known. Since bytes() does not provide any string methods, there is no practical way to port it short of implementing this stuff by hand, which will have serious performance impact. With mod\_python being dead, this leaves django hanging until a new solution comes along. :/ *Edit: markdown fail*
I ported around 20K lines of pure Python and a C extension to work on 2.6 through 3.1 in around a day. If you have to support earlier versions it'll be a bit tougher...but it was not at all hell for me.
Always 3. I do try to keep later 2.x versions like 2.6 and 2.7 in mind since it's not too hard to write code compatible across both versions.
You want a good resource on curses? I recommend urbandictionary.com (Sorry, I couldn't resist)
I still write 2.x only, because allot is written for 2.x But, I do take precautions when using print (because it's not a function) so I use this small trick: print("Hello %s how are you?" % ( name )) ... instead of the usual 2.x print "Hello %s how are you?" % (name) So, when python3 finally steps over for good, I don't have to use conversion tool, plus it builds a habit of referring to print as if it's a function. But there's a small question I haven't clarified to myself: ( "..." %(...) ) might translate to a tuple instead of just parenthesis around the string (??)
People have supported version ranges as wide as 2.0 through 3.0, [such as this guy](http://pythonology.blogspot.com/2009/02/making-code-run-on-python-20-through-30.html).
The str unicode, etc. differences are not that trivial though...
Thank you for that.
At that rate Python 3 won't get very far.
[Here's a slighted dated, but example rich PDF](http://heather.cs.ucdavis.edu/~matloff/Python/PyCurses.pdf) on curses with Python. It also provides a little bit of history as well. Also, download the Python sources and check in the directory Demo/curses.
Tuples are defined by commas, not parentheses. &gt;&gt;&gt; type(1) &lt;type 'int'&gt; &gt;&gt;&gt; type(1,) # SPECIAL NOTE &lt;type 'int'&gt; &gt;&gt;&gt; type((1)) &lt;type 'int'&gt; &gt;&gt;&gt; type((1,)) &lt;type 'tuple'&gt; SPECIAL NOTE: The comma here is treated as belonging to the parameter list of the function call to `type`, not as part of a tuple. When you're passing a literal tuple to a function, you need to surround it with parentheses to denote it as a single expression. Hope that helps!
Oh yeah! Now I remember the (x,) thing... thanks for clearing that up!
I just had to extend a reporting utility that had to be 2.5. After six months of strictly 2.6 and 3, I had syntax issues all over the place for features I took for granted. I like the str.format method, syntax changes (as, with), the simplified library grouping (dbm, urllib), exception chaining. After back-porting, I also realized 3 is appears more pythonic.
Python 3, tho mostly because I just started learning Python 2 weeks ago. :-D
If it wasn't posted in /r/Python, I would have considered it fair game. :)
That is what worries us Python 2 devs. We would like to switch, but at that rate, we won't be able to for quite some time.
Ask your local witch doctor. Dohohohoh.
Hi, I would really suggest looking at [urwid](http://excess.org/urwid/), its a very solid library that does a far better job than curses. I'm currently writing a frontend for ipython using it... it could have been done using curses, but seriously, urwid is far better. Python curses also has some quirks - I can't remember what it was now, but at some point I found there were a few functions that are in the normal curses but not the python version, and I could not replace them without modifying the curses library... something I did NOT want to do. Anyways... if you can, switch to urwid. Its a lot easier to use.
No problem - 1-tuples are kind of funny edge cases and that used to trip me up, too. Glad to be of service. =)
great, I may be able to move sooner than I expected
I'd just do **from \_\_future\_\_ import print_function** so you get the actual print-as-function functionality.
Pyevolve (Genetic Programming) is memory-intensive ! You can adjust this using a large population of individuals for example.
it all depends on what kind of applications you code - i can suspect about 90% of my code will work with really small changes.
I can only use 2.5 currently. No complaints, it is awesome enough for me.
[eBay might be a good place to start](http://everythingelse.shop.ebay.com/Everything-Else-/99/i.html?_nkw=curse&amp;_catref=1&amp;_fln=1&amp;_trksid=p3286.c0.m282)…
Exactly. The most common source of frustration I find with language hoppers is their desire to find a paradigm that works for them and force said paradigm on every language they use. This, of course, makes their lives much, much harder.
Do you have paypal? if you can do some of my pending stuff for cheap it's still some incentive :D
Python 2 when I have to == all the time.
There are more unicode aware libraries for Python 2 than there are libraries for Python 3. :) 
Maybe not, maybe so. I myself think the incremental path where people adjust their codebases to Python 2.7, and then adjust further in Python 2.8 which might drop Python 2 features (say, old-style objects) might be a way to get there incrementally. I realize that there's not supposed to be a Python 2.8, but we'll see. 
I am concerned about this as well, no proper mod_swgsi support for Python3 is killing my motivation to learn it for web development over PHP.
I have a lazy sys-admin at work, so we aren't going to be updating to 3 anytime soon. With that said 2.x works fine for most things.
Take a look at [this graph](http://dev.pocoo.org/~gbrandl/py3pkgs.png) of the number of Python 3 packages available on PyPI from December 2008 until now (the image regenerates every day). More and more packages every day are being listed as supporting Python 3. I'm sure a lot of them are new, but I would imagine that a lot of them are existing packages which added support for 3.x. Yes, you are correct that the number of third-party packages for 2.x is larger, but 3.x *is* catching up. No one said 3.x adoption was happening overnight. Also, I would say your problem of not being able to foresee dependencies is artificial and a sign of a lack of planning. Sure, things change, we all know that, but I don't really think it's a legitimate excuse to have a project stick with 2.x just because they might at some point need some dependency that may or may not be supported. Dive in, see what happens, and if you come across something that needs to be ported, ask the author if they are interested, or just take a whack at it yourself -- it's probably not that hard.
Found my old git repo. Just remember that this not only the first ray tracer that I wrote, but my first python program too. Weirdly, it actually runs fine now with cpython 2.6.5, completing the 800x800 pixel render with only ~750 mb of ram. [The end product that I ended up submitting.](http://github.com/phire/Python-Ray-tracer/) I pulled the experimental multipass rendering out of the history and put it into a [new branch](http://github.com/phire/Python-Ray-tracer/tree/multipass) If you want to use it I'll update it with an appropriate licence and maybe merge some features from the master branch into the multipass branch.
I'd recommend using [urwid](http://excess.org/urwid/), as wacky [mentioned](http://www.reddit.com/r/Python/comments/d2ldk/hi_rpython_can_you_point_me_to_a_good_resource_on/c0x3lz8). However, if you're dead set on using curses, be sure to check the curses manual pages (e.g., `man ncurses`).
python2. I am not a fan of the parentheses they added to print. Not needing them was a convenience I enjoyed. Also, python2 is default on all my boxen, so I've seen no reason to even try python3 as of yet.
I wasn't expecting Python 3.x adoption to happen overnight - when did I say that? You can find statements from me dated a few years ago where I said the opposite. In fact I *wish* overnight adoption was possible, but it isn't. And I've seen the graph before. It's a good sign, and it's only a couple of hundred libraries right now, and we'll see. A lot of stuff I use every day hasn't been ported yet though, and some of that is my own code, and I'm too busy to spend the time at the moment, thanks. It's my time and I want to get work done. But other people are free to do it if they feel so inclined. I'm claiming that if you are beginning with Python, it's better to pick Python 2.x at the moment because there are a lot more libraries, and more mature libraries, and more powerful libraries, that you can use, and especially if you are a beginner you won't be able to foresee what these will be. Don't paint yourself in a corner if you don't have to. Eventually that might change, but it hasn't changed yet in my opinion. I also think that if you start a new project today you're better off with Python 2, unless you really know your project is small, or that you won't need any dependencies soon that haven't been ported yet, or it's a hobby project and it doesn't matter that much. On foresight. If I start, say, a CMS project years ago and I'm still maintaining it today, I might want to add, say, a WSGI library or JSON library. 10 years ago such things didn't exist yet. To claim I'm lacking foresight in such a situation is rather silly. That's an extreme time scale, but if I'm a newbie and I want to say, web dev, I might be disappointed that there's no Python 3 WSGI spec yet, and thus no proper WSGI libraries, for instance. Porting is probably not that hard. For most libraries. It is hard for some libraries (porting setuptools/distribute was probably hard). It's also a lot of time if you need a lot of libraries. Again, it's my time, and I rather spend time writing something interesting. 
FUCK SHIT CUNT ...wait, those are not the curses you were looking for, right? Oops, sorry!
I'm currently using 2.5, but that's only because it's all GAE currently supports.
Both. For web dev with the big frameworks I am stuck with 2.x but for simple data munging and automation I try to 3.x wherever it is practical. 
Python 2. For libraries other people might use and where the amount of work is low I also try to achieve Python 3 compatibility, but I don't care too much about that at the moment.
2.7, and I wherever possible I use 3's features and syntax. The transition for me will be trivial, someday.
Are the parentheses *really* that much of a bother? People seem to talk about this all the time but I can't possibly understand how it's such a stopping point for so many people. I also think too many people reject print-as-a-function before being aware of the *features* it provides.
What does "more pythonic" really mean, without hand waving? :-)
[George Carlin has you covered.](http://www.google.com/url?sa=t&amp;source=web&amp;cd=1&amp;ved=0CBIQtwIwAA&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D3_Nrp7cj_tM&amp;ei=uTpsTK7tK4H7lwegsrgS&amp;usg=AFQjCNHj1pNUHkMe7dFHoq4AxnEzMkbagQ&amp;sig2=lpR1WW9z4KjZcV7-idI00w)
I typically write code for Python 2.x but I try to write it so that it works for Python3. Such that, I always write my print statements as "print('hello')" and not "print 'hello'", and if I have to worry about functions changing between Python versions, I write an if-statement to store functions based on what version of Python is running. (Like how raw_input() is input() in Python3, range() is the new xrange()...) I just write everything in Python 2.x. That's what comes on my Ubuntu as standard for now.
Everyone uses Python 2. Python 3 is only used experimentally by early adopters. I love Python 3 though. It is stable itself, the main issue is lack of ported libraries. [Get porting](http://wiki.python.org/moin/PortingPythonToPy3k)!
 &gt;&gt;&gt; atuple = 1, &gt;&gt;&gt; atuple (1,) &gt;&gt;&gt; type(atuple) &lt;type 'tuple'&gt; Incidentally, this is why you can ``return multiple, values`` - you're actually returning a tuple. It is also why you can ``assign, multiple = variables, values`` because it's "pattern matching" tuples.
* ``print`` does not *need* to be a statement, unlike things like ``return``. * It is inconsistent with such things as ``sys.stderr.write()``. * You can't pass it as a function reference, do ``help(print)`` or ``print.__doc__``. * Weird special syntax ``print &gt;&gt;stream...`` not even sure I got it right there, difficult to look up (see previous bullet). * You can override a function but not a statement. For example make all prints calls to a logger instead. Also related to bullet point §3; pass a outputting callback to some call: def do_something(output=print): output('Does something') do_something(output=log) Why do you complain about parenthesis you use everywhere else? If you really mean in the interactive shell, I hear IPython lets you omit parenthesis for *any* function call.
As soon as pkgsrc has python 3, I'll move to it. Until then python2.6 is just fine.
Parenthesis serve only to disambiguate priority. There is no tuple in ``(2+2)*4`` and the reason you need them in ``sum(1 for i in (1,2,3) if i%2)`` is because the commas would otherwise mark the start of the next argument to ``sum``.
&gt; Parenthesis serve only to disambiguate priority Yes, yes, I know... I just wondered because if print is part of the language (not a function) the interpreter might get confused &amp; form a tuple with a string inside it (but it's stupid thinking, because I would at least see a tuple on the stdout) &gt;&gt;&gt;print ((1,)) (1,) &gt;&gt;&gt;print((1)) 1 ... :-/
Yeah, should be "more pythonistic" ;)
Good addition; thank you.
&gt; I like the str.format method, syntax changes (as, with), I believe all of these are in 2.x as well.
It's not stupid because the print statement does in deed do something with the comma: &gt;&gt; print 1, 2 1 2 &gt;&gt;&gt; print(1, 2) (1, 2) &gt;&gt;&gt; from __future__ import print_function &gt;&gt;&gt; print(1, 2) 1 2 
 &gt;&gt;&gt; print(1, 2) (1, 2) Hmm... I involuntarily skip this "error" by formatting all input to print into a single string as an argument (a bit like printf) with print("x %d, y %d, z %d" %(x,y,z)) 
I just started learning Python too and I 'm using 3. Why? Because I bought a book about it that uses 3(!) and because I read [this from the Python site](http://wiki.python.org/moin/Python2orPython3). To summarize that page (what I took from it anyway): if you are learning in a closed environment then you don't need backwards compatibility and you have nothing to rewrite, so learn what is current. If you find something doesn't work and you suspect it to be versiony (new word - yay!) then a quick look at the documentation should solve the problem. UP NEXT: ---an off topic rant--- And I just want to say that having been forced to learn Java and sit written exams in Java, I really like Python and hate Java. If I could only have found Python first. I almost quit programming because of Java (should add that it's not just Java's fault alone, but the schedule, deadlines for learning at uni makes it hard to take in so much in a short space of time, especially for non-programming students). But seriously, I fucking hate Java. /rant
Yes, I'm sure it's great from a language cleanliness point of view. But from a convenience point of view, it sucks. That's two key-chords I have to do that I wouldn't otherwise, and when I'm trying to toss out some debugging info quickly, it adds up. Besides, I have an RSI, and I'd like to minimize the pain. Even if I didn't, I still think it's stupid that it's been removed. If python3 supported both with and without parentheses, then I'd have no objections.
I was thinking this too at first, but realized they're not curses but swearwords. I'm now think something more along the line of 'may the hairs on your arse grow inwards and fester', and other such fun stuff.
I have no problem with print-as-a-function as long as print-as-a-statement doesn't disappear. I'm fine with those features only being available with print-as-a-function; just leave print-as-a-statement alone. And yes, it is a bother. I have to type two extra parentheses for every blessed print because someone *else* wanted features that *I will never use*. As I said before, python2 is still default on all my boxen, so I see no reason to mess with python3 at this point. Maybe at some point down the line, but I see no reason to play early adopter. *Edit:* Sigh.. is it verboten around here to reply honestly to someone's question? I'm sorry you couldn't change my mind, but that's hardly a good reason to down-vote. I don't understand what the whole point of this question was in the first place, or why people should even bother replying if we're not going to have a dialogue. That means respecting other peoples' points of view, even if they are contrary to your own. I don't know how what I've said could be characterized as offensive. Frankly, I think I'm making a good point here. There is *no reason* for me to go out of my way to use python3 on my Mac since that *would* be bleeding edge. It'd likely break the Mac-cocoa integration, and a bunch of my scripts. Maybe come 10.7 they'll ship with python3, and I'll try it then. In the meantime, there are things about python3 that do not appeal to me, and I'm simply stating as fact what they are, and why I'm annoyed when people try to tell me that it's somehow better for me when really *it's not*.
I only ever find myself using print for debugging. It's just a load faster to type it without the parenthesis -- not enough to stop me using py3k, just an annoyance.
Here's a (surprisingly) un-hand-wavy [explanation of python's design principles](http://www.python.org/dev/peps/pep-0020/). I think pythonic refers to things reflecting these principles, which certainly seems true of python 3 
Assembly
I'm not a passionate pythonist but I do have on the order of hundreds of lines of code that I use. I use 2 something ... I don't know what. I think this the reality of most of the real world developers. They install python, get the $10 used o'reilly book; try to go through the online documentation, and try to get some work done. It's just a hammer.
Open all the files using [mmap](http://docs.python.org/library/mmap.html) at the start. They will be open but not loaded into memory. The operating system will (hopefully) manage the loading of different parts of the file at the correct time for optimum memory usage. Unfortunately this will only really work with raw uncompressed images (otherwise you will still need to load the entire image out of the file and copy it into a memory buffer each frame) Edit: I put some more thought into this. The operation you are doing is nothing more than a copy of a series of bytes, the complexity comes from the fact that each output is made up from a single line out of 640 different images. If you simplify it to uncompressed data then it becomes a simple sorting problem. The problem set isn't even that large, 562.5 MB (640x640x480x3) You should be able to load all the images into a single numpy array, re-arrange all the bytes then slice it up and output to pngs. If you don't have 1GB of memory, (or you decide to use much bigger images in the future) you need to start thinking about loading data in and out of memory. I would just create a mmapped numpy array and everything should be handled automatically.
If you downloaded the 3.1.2 installer, it should have come up with something called "IDLE" Look for it in your program files
Step 1: Think of a joke Step 2: Realize everyone else will think of the same joke Step 3: Walk away...
I use Python 3 unless I need something that is Python-2-only (so far). Python 2.7 will be officially supported for at least five years, and possibly longer than that. But it won't get any new features. Python 3 is simply a better language.
Compressing and decompressing PNG files does take some time. Why don't you benchmark different parts of your program. How long does it take to simply load all of the frames? Can another image library do reads &amp; writes faster? Pygame uses SDL which is an optimized game library. SDL has a great surface to surface copy (a Surface is an what you get when you read an Image). I would consider this an option. Lastly, is there a more efficient algorithm to do this? (I know nothing about this algorithm.)
I would consider using pyopencl and/or ctypes+SSE. In general, you need to optimize your usage of cache/memory throughput and paging. My guess is that numpy alone won't help much if you're just moving data and not doing arithmetic. I'm not totally convinced that the mmap module will be better than file I/O -- the OS should manage this with the buffer cache. It might eliminate a copy, maybe. However, it does provide you with the opportunity to use flags like `MAP_LOCKED` (requires superuser or `CAP_SYS_RESOURCE` capability). It will pin the pages in memory. Also, you can use `MAP_HUGETLB` or a file descriptor from a `hugetlbfs` mount. Huge pages are great (if your hardware supports it) for reducing TLB pressure. If you're not using *nix, accessing huge pages and pinning memory will use a different interface.
Does SQLAlchemy or Elixir do this? (I don't know myself)
I believe SQLAlchemy has an introspection feature
I used Python 2.6, just because there were more examples. Wrote my first python programs less than 6 months ago.
If saving keystrokes is your concern, now that it's a function, you can do this at the top of your module: &gt; p = print After that, you can clean up your module's output in one fell swoop: &gt; p = logging.debug
I happened to have a pile of 640x480 images sitting around so I thought I'd give this a shot. On my system, it takes about 8 seconds per frame with your script. Most of this time is spent opening and reading the image files. Now 640 png files at 640x480 is only about 50 MB (probably varies with images, but hey). If you pre-load them all (a little under 8 seconds on my machine) you don't pay that price every frame. [Here's the source](http://pastebin.com/9vjHJR37). Note, it does take a [fair whack of memory](http://imgur.com/Kloqt.png).
The SqlSoup extension seems to fit the need
I'm not sure what the output was supposed to look like, but when fed [this](http://www.youtube.com/watch?v=1iV8kT3Hqtw) I got [this](http://www.youtube.com/watch?v=EmshR1EYAX0). Yeow, my brain. I'd love to see it on a real life sequence. Generate with: ffmpeg -r 24 -i output_%05d.png slit_out.avi
I'm porting a php application to pylons, and exactly same issues. I ended up with sqlSoup and a little ORm.. Yes hardocded sql joins I have control over, instead of some completely mad ORM gibberish that makes hardly any sense unless a SA dev. 
one thing to bear in mind: this makes it less clear to everyone when you're doing a potentially pricey join.
[web2py DAL vs SQLAlchemy](http://www.web2py.com/examples/static/sqla2.html) The comparison is a bit old and both have new features. The problem with what you suggest is that two tables may be related by more than one reference field therefore the join is not obvious. web2py allows you to define a join set and query the join set: myemployees=db(Employee.DepartmentID == Department.id) rows = myemployees.select(Employee.Name, Department.Name) You can also do for employee in db().select(Employee.ALL): print employee.Name, employee.DepartmentID.Name The latter (not the former) translates in a recursive select not a join.
yeah that's the shit I dislike about Python, the __ffffuuuu___ business
Except sqlsoup builds on the orm...so, you're using an orm to solve your problem, and you're not a dev. There's also hundreds if not more non devs using the orm fully- all that's required is to read the tutorials. Joins are explicit is one of the first things you'll note.
&gt; Screw 2to3! What is needed, is a working 3to2. That way developers can port their libs, maintain one(!) canonical trunk and still offer backwards-comatibility. I think you're on to something, there. At least, that would pretty much convince me. A version such as sgndave [mentions](http://www.reddit.com/r/Python/comments/d2ikf/when_you_write_some_new_code_do_you_choose/c0x3c00), which converts C modules, would be doubleplus good.
I don't get it.
I'll take a look, thanks for the link. Curses looks pretty simple itself, but that one looks like it has pre-made widgets. Handy!
Thanks, that looks perfect! Until now I had been looking at a curses based controller for Transmission...
&gt; The problem with what you suggest is that two tables may be related by more than one reference field therefore the join is not obvious But the join is obvious for two reasons. 1st I'm explicitly stating which field I am interested in "Employee.DepartmentID.Name". 2nd, which I didn't explicitly state is that Employee.DepartmentID has a foreign key defined on the table that references primary key Department.DepartmentID. So, given those two pieces of information, a tool should be able to infer that when I add .Name at the end that I am interested in doing an automatic join via the foreign key defined on Employee.DepartmentID. Actually there is some precedence for this type of pattern in accessing data like. C# LINQ to SQL does it quite well via the Association attribute, but I'm looking to use Python for quick, ad-hoc querying of highly normalized tables that I don't want to have to type out joins each time. 
Yes, this is true, but given that I'm going to be using this mostly for ad-hoc type queries or maintenance scripts its not that huge of a deal. I have the luxury of not having to worry about putting this in a team environment.
I checked the documentation but still appears the join must be explicitly stated which doesn't save me much from having to type out the JOIN statements in a FROM clause in SQL. Plus stacking multiple joins appears even more convoluted. I have a simple example here, but unfortunately I am looking at joins across a larger number of tables.
see Rudd-O's and thephotoman's and d1257's posts and everything below the threshold.
You could get it done just using PIL, which has an interface for writing on pixels and displaying them. Another option is using Tkinter's canvas, which also let's you write and display pixels. Numpy with scipy and/or matplotlib will also do, giving you an Matlab-ish interface. Ditto for OpenCV 2.1's Python interface. Also have a look at the two popular game engines, Pygame and Pyglet.
[Voilà!](http://pypi.python.org/pypi/3to2)
urg, not so, not so! In Python 2.x, there are two sorts of functions - print, and everything else. It's not just inelegant, it makes coding harder. One specific issue - there's no way to mock out or intercept the print function - you'd want to be able to write code like this: def foo(x, print=print): print('Hello, {0}'.format(x)) and later, in your test, to write foo(x, print=myPrintFunction) 
I toyed around with the idea back around 2003. I didn't have much in the way of programming powers at the time, so I actually made a Photoshop action (or whatever those macros are called). I'd start with a 1px wide image the height of my frames, which were dumps from my movie camera, which were of mountains and cars I drove past on the 405N near the Getty Center on the way home from work each day. I'd just hold the camera against the window and drive as usual. The action would select and copy the center column of pixels in the focused image, close it, then [in the original, blank image that was now focused after the close of the other image it would] scale the image by 2 pixels in width, paste, and flatten the image. The reason to grow by 2 around center was that I couldn't get it to paste to the far right edge of a growing image. By scaling it by 2px from center, I'd have a growing image to the left, and a growing blankness to the right, and in the end I could just crop the right half off the image. Then I'd point this at the folder of images and let it batch process the action over them. It worked very well, but was pretty obviously slow. I just felt like sharing that :) A cool secondary thing was to use different parts of the image, so instead of grabbing the center column, I'd grab the far left of every image and build that way. I made a huge pano for every column - 320 wide - in the video, then rolled through them in a fast image viewer, and it looked like everything was changing perspective, like I was rotating around the stuff in the image from a far-off telephoto vantage point. Pretty cool. Expected were the long cars - the ones I passed more slowly than the others. Unexpected were all of the backwards cars - the ones that were passing me and getting themselves scanned in reverse. There were several accordion cars that had wavered back and forth next to me before moving on, too.
I would try preloading the images -- if you get a MemoryError or swapping, well, okay, that wasn't the way to go. Another possibly worthwhile optimization would be to use xrange instead of range, or better yet, for source_image_id, source_image_name in enumerate(source_file_list) (and while you're at that, precompose the full pathnames instead of doing it in the inner loop). Another thing you could try is making your target image's format match the source images, so there will be no conversion. (That is, try "RGBA" instead of "RGB".) Finally, if you are able to preload the images, rotate them clockwise and do the slicing with horizontal slices. My intuition says horizontal slices would be much faster due to image layout in memory.
I have 2.6 and 3.1 on my system, but code for 2.5, since Debian stable is still using 2.5.
That *is* hand-waving. Beautiful is better than ugly indeed.. :-)
That does seem like the easiest way to optimize it. Unfortunately, this script and the version I had made to preload the images absolutely kills my poor out of date machine. Maybe it's time to get some time on a friend's shell... Edit: Examples! Here's the [output](http://www.youtube.com/watch?v=ycpzIM-ywg8) of [me sitting down in a chair in my kitchen](http://www.youtube.com/watch?v=0dg4RKCrfSo) See also [Surfing the 4th dimension](http://www.youtube.com/watch?v=k0q7mZr3Jdg) which is what recently renewed my interest about this technique
Thanks for your help. So far I've come up with this: [CLICK ME](http://i.imgur.com/s3Ebe.jpg) But I don't think it is right because Question 3 asks "Prints out the user/s first and last names in that order." but all I've done is a simple print command and not a script that once it has both answers it will print them out in order....hmmm.
Thanks for the pointers to new things for me to research :)
What rspeer said and also, you could set up abbreviations or snippets in your editor, whatever it supports.
&gt; If python3 supported both with and without parentheses, then I'd have no objections. Python 3 is all about dropping support for "more than one way to do it" and make the implementation saner. Also it couldn't support both as statements are reserved keywords.
That actually looks promising. YAY for GSoC :)
you've got the right commands, you need to write them into a script (with file extension .py) and just run it. See "Creating and Running Programs" section on [this page](http://en.wikibooks.org/wiki/Non-Programmer%27s_Tutorial_for_Python_2.6/Intro) 
[PyWeek](http://pyweek.org/) has almost started! Sign up and force yourself to throw together a game in a week. That's how I learned!
You are right. Now I understand better. We could add this feature to web2py. I will give it some thought and I may get this done in a week of two. I will announce it on the web2py mailing list. 
* The BIG one is that strings (in unicode) and binary data are now clearly separate. This is a major pain for someone CONVERTING code written under Python 2.x but is a much better design for something built from scratch. Beyond that, it's mostly little stuff: * Print is a function, so I can build something rough and quick using print then later replace 'print' with my own function feeding the data to someplace more appropriate than the console. * I can just use 'int' without ever having to worry about overflow. * The iteratable/iterator protocol is used more places (like comprehensions and dictionary keys) instead of creating lists. Mostly, this doesn't matter, but when the data structures get big it is a significant performance win with no syntactical penalty. * The format() method for string interpolation instead of %. (But I think they added this to the 2.x line also so I guess it isn't really a difference.) None of this is a big deal... hey, it's the same language after all. But these kinds of little touches are nice. Plus there is one more: * Never again having to wonder whether something is a "new style class" or an "old style class" or having to remember what the difference is between those. 
It really means "in the style of Python code", which just begs the question. A better answer would be that "pythonic" means written in a fashion that emphasizes code readability: with important things explicitly visible and arranged so unimportant things never even need to be said. This definition shows why Python's indentation-based block structure (often mis-named "significant whitespace") is better -- the indentation is required in all other languages too IF you want it readable. Making readability mandatory is pythonic, and making begin-and-end-markers unnecessary is pythonic. Never having to wonder whether your indentation and your braces match is pythonic. Another example would be this: if your function takes just 1 or 2 parameters, use simple positional arguments. If it takes 6 different arguments most of which are optional, use keyword arguments. Readability is the most important design principle of Python, but there are a few others that contribute to being "pythonic" as well. For instance, the "we're all consenting adults" philosophy. So using CONVENTION (leading underscores) to mark 'private' variables rather than compiler-enforced rules is pythonic. Providing libraries that make it easy to directly call C (or other languages) is pythonic for the same reason. 
That seems like odd advice. Why not go all the way and tell them to start with Java or Visual Basic, so they can *really* appreciate Python3?
&gt; Print is a function, so I can build something rough and quick using print then later replace 'print' with my own function feeding the data to someplace more appropriate than the console. You might be better off using the [logging](http://docs.python.org/py3k/library/logging) module for that.
If you can't see the ridiculously obvious advantages of Py3, prepare to get downvoted. (Note that I say this tongue-in-cheek as a Python 2.x user myself.) Note that one big underlying goal of CPython is to [make it a good glue language for C](http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235&amp;start=31&amp;msRange=1) (both external libraries and C extensions). If this isn't your goal too, you may want to consider an alternative implementation like PyPy or Jython where performance is a higher priority (and 2.x is the current language target).
Ahhh. Got it lol.
If I may humbly make a recommendation for [Django](http://docs.djangoproject.com/en/1.2/). It makes the DB shenanigans totally transparent, all you really have to work on is setting up good model classes. As a bonus, it is easy to pick up.
On the same website you may find an exemple of plugging the bus with AMQP: http://www.defuze.org/archives/207-plugging-amqp-and-websocket.html followed by http://www.defuze.org/archives/213-a-quick-chat-websocketsamqp-client.html If you've got a more specific example in mind you'd want to toy with, you may check on the CherryPy IRC channel.
You should do one for and exploit each iteration as you can. You could create all the images files partially and append the new data by iteration. This can be done if your output is a flat no compressed set of images.
also, when i write in code without running it, it is in color. But after i run a script, i never see colored syntax again until i restart IDLE after it crashes. Why is this?
Sorry I didn't respond to everyone, but I read it all and found tons of help. Thanks everyone. 
&gt; We could add this feature to web2py Seeing that this might not exist that would be the next best thing. Thanks! I think I was ultimately inspired by the LINQ to SQL model but I think the essence of what I am looking for is something that uses the databases system and catalog to automatically join the tables. INNER JOIN ... ON table1.joincolumn = table2.joincolumn is boilerplate in my opinion. LINQ to SQLs requirement of setting up entity classes is boilerplate (although they have tools to automatically generate this code to some extent). So something like this: joined = Join('Employee', 'Department') joined.select('EmployeeID', 'Employee_Name', 'Department_DepartmentID', 'Department_Name', 'Manager').where() or this with aliases joined = Join('Employee': 'E', 'Department': 'D') joined.select('EmployeeID', 'E_Name', 'D_DepartmentID', 'D_Name', 'Manager').where() One of the problems with the LINQ to SQL method now that I think about it more is that it would be redundant to have to say Employee.DepartmentID.Name, Employee.DepartmentID.Manager, especially as the number of column needed grows and you add more tables. Employee.DepartmentID.OrganizationID.Name is an example of how this creates its own boilerplate problem. If you had a lot of columns to specify from the Organization table it would be easier to type out joins and just use the table alias. So the ultimate goal or vision is to eliminate join boilerplate by using the foreign keys already defined in the database and having to set up entity classes or model classes up front. The Join (or whatever) function\class would use the database's system tables to auto-create the joins based on foreign key definitions. Column names that clashed between the tables would be required to add a table name prefix. Column names that are unique could be specified directly. 
IIRC, then you have to add a `raw_input()` at the bottom of your code so that the window stays open.
&gt; It makes the DB shenanigans totally transparent This is an interesting comment and I wonder if it reflects some of the downvotes for the php person bashing ORMs below (or maybe it was the php comment?). I see the value of ORMs with trying to get relational data stored into objects to be used in imperative code. I prefer that over saying using a SQL cursor to work with rows individually. However, for querying a single table "SELECT Col1, Col2 FROM Table1 WHERE Col1 &gt; 10" SQL just seems much less of a hassle. SQL declarative nature does have an advantage in some circumstances. The real problem with querying comes in with adding more tables and having joins where I have to explicitly type out join relationships every time I want to query. Years ago I remember working with a very talented programmer who hated relational databases. He wanted me to design a database that didn't use an ID but used a person's last and first name as a composite primary key that was referenced by child tables. So there was this customer table with a natural primary key and then there was an order table with multiple orders by this customer. He was now able to query the order table with the customer name without having to join in the customer to get names. This design obviously led to some other problems. I suspect its the joins that were the ultimate cause for him hating relational dbs and if SQL had some mechanism built in to take advantage of the foreign keys already declared that he might have found it much less of a hassle to work with. &gt; all you really have to work on is setting up good model classes. Setting up model classes is boilerplate. LINQ to SQL has this problem too although it has a tool to automatically generate the entity classes it uses. Its also C# and ad-hoc querying with python would be so much more convenient! 
you can set an automatic join with relationships : http://www.sqlalchemy.org/docs/reference/ext/sqlsoup.html#relationships
I had the IDLE-crashing problem on with 2.6 on Windoze. It is stated by some that 2.5 is the most stable version available for Win.
Bring up a command line and run `python -m idlelib.idle` to run it from there. Then if it crashes again you should get a traceback to look at and we can be of more help.
I would suggest using the latest version of 2.x (2.7) and transitioning to python 3 when you are comfortable with the language. I believe the MIT course uses Think Python, but in case it doesn't I would suggest using this as your starter: [Think Python](http://www.greenteapress.com/thinkpython/thinkpython.html). It's written for students who are learning programming from scratch and covers a lot of ground that is assumed knowledge in most every other course. I have mixed feelings about this one, particularly the tone, but you I think you might find this valuable as well: [Learn Python the Hard Way](http://learnpythonthehardway.org/index). Exercise 0 is all about setting up your machine to run python. For these exercises you will edit your programs in a syntax-coloring editor and running them on the command line (the DOS window). Good luck.
I'll have to take a look at this some more. I quickly browsed the documentation yesterday and it didn't seem to fit what I was trying to do. I refined some of my thinking with my responses to mdipierro and this SqlSoup model may work. I was originally inspired by seeing LINQ to SQL, but realized it could get really messy with multiple tables. This would be an example of how convoluted things could get: Employee.DepartmentID.OrganizationID.CountryID.Name in terms of column naming trying to get across multiple tables. It could end up being worse than the join. However: joined = Join('Employee':'e", 'Department':'d" , 'Organization': 'o', 'Country': 'c') selected = joined.select('EmployeeID' , 'e_Name' , 'd_Name' , 'o_Name' , 'c_Name')\ .where("c_Name = 'USA'") for row in selected: print(row['EmployeeID']) # or print(row.EmployeeID) # pyodbc style would be pretty close to perfect. I'm getting pretty specific here, but this would be the general pattern of how it would be done. Quick ad hoc querying eliminating the need to type out explicit joins each time. I'll try SQL Soup to see if the db.join() demonstrated there can handle more than two tables and does aliasing with automatic column prefixing in cases where the column named is duplicated (like it normally will with the foreign key columns). The other piece here that I'm wanting to avoid is the modeling of classes based off tables. That seems to me to be something that should be able to be down automatically based off reading system catalog tables in the database. I'm primarily interested in ad-hoc read-only access here and being able to quickly grab information off a large number of tables that have to be joined without having to specify joins each time. This is maybe where I'm coming into some conflict with some of the ORMs out there that may have CRUD web interfaces in mind? 
This seems like the best suggestion for now, but if you really aren't getting good results, maybe look into a new editor. Eric v5 is supposed to work with Macs and Python3 as well, though I suspect you'll be in for a bit of a compile/configuration cycle to get it going.
Optimized for time, but fairly brute force. Luckily, the machine I was using was fairly powerful (8 seconds per frame vs. 45 seconds). It probably would go so well on my home machine. I think [phire](http://www.reddit.com/r/Python/comments/d2s2g/help_me_speed_up_a_slitscan_pil_program/c0x4yhl) has a far more elegant solution. Your real world example gives a much better feel for what this does than my blobby video, too. 
I see this solved quite well in another language orm, Doctrine. I'm not sure if Elixir, or SA have this type of relations definition and access, but from experience this would be something like this in YML and Doctrine: invalid pseudo yml ahead: Employee: table_name: employee columns: id, department_id relations: Department: local: department_id foreign: id Department: .... Then you would access a user and department like this: $user-&gt;getDepartment()-&gt;getName(); Ideally I would have a python solution for you, but this has been solved in other places so that might give someone else food for thought.
I saw the $user and -&gt; and I though I would be going back to perl. Eliminating $ and replacing -&gt; with . was a one of the pluses in the switch to python. Having to get back to that syntax seems very unappealing. I appreciate your input in providing food for thought. If I'm lucky mdipierro will implement this for me or someone will eventually come along knowing the perfect package for this. Being specifically clear on what is needed helps. One of the things that concerns me about this "Doctrine" is it looks like you have to type out the YML to explain the foreign key relationships. This is something that I think should\could be done automatically by looking at the relational databases system's catalog table and views. I definitely don't want to be in a situation where a column is added or dropped on one of the tables in the database and I have to go redefine an entity class (LINQ to SQL) or YML (like Doctrine) or model class (SQL Alchemy?). That is a maintenance nightmare. Furthermore, in reflecting on this more, the $user-&gt;getDepartment()-&gt;getName() demonstrates another problem that I hadn't noticed with the LINQ to SQL type syntax when I first posted. If you have a lot of columns to select from tables joined in 2 or 3 levels deep, typing out the full names each time will get really old and worse than the join syntax boilerplate. Per my previous examples on this post: Employee.DepartmentID.OrganizationID.Name One column from the Organization table, but getting very messy when you need 10. 
I work with PyDev and Python 3. Nary a problem.
2.6 and above.
Hehe. Fair enough. But some of the seemingly-hand-wavy things like "explicit is better than implicit" are somewhat helpful when understanding Python. (Explicit is better than implicit generally means that functions and methods shouldn't have side-effects.) "Flat is better than nested" means it's often better to have functions that are outside of classes, and inner classes should have a strong reason to be inner classes. Some of the others also quite helpful. 
Is Wing IDE any good? I've been searching for a good Python IDE for some time now (I'm a typo master, in-line error checking would be a godsend). I know there's a 30-day trial, but I never get enough work crammed in to 30 days to know if I like it or not.