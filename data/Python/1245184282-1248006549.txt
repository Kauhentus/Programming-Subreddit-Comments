Here's one I wrote that actually shows how they're coded: http://justinbozonier.posterous.com/markov-chains-in-python
I'd check out [mnml](http://github.com/garethr/mnml/tree/master). It's very small, allows you to easily and quickly build up a wsgi application and routing, and appears to be very easily ported to 3.X via 2to3 through cursory testing.
How high is the lip on the end? Seems ok unless she rolls over the edge. Great programming/math article, though. :)
The detailed article starts with "python 2.x" - python 3.x has no official release ...
As in, the programming interface to samurai?
Someone (Martin Von Lowis) has done a port of Django to Python 3. It will be integrated and supported soon...
That's one hell of a crooked floor
Wow. A whole gallon? Wow.
Dude, you should have the house checked. 1 inch pr. foot is *not* normal.. Upvoted for extreme geeky nerdery.
I started to do something similar when i put in wood floors in my main room. I attempted find the uneven parts of the subfloor by creating a gradient vector field using level measurements on a 1x1ft grid. Then I heard about self-leveling cement. FML
im trying to learn python by recoding a site of mine in it. I come from PHP where apt-get install mysql php5 apache2 and im done...im now programming apt-get libapache2-mod-python didnt exactly get me up and running I just spent 2 hours setting up mod_python on my vps...finally got it to display a stupid "hello world" Then i read a site that said mod_python isn't for web development, but i should install cherrypy or a different one i forget hte name sorry Then i thought, hey maybe i should use a framework (not sure why i thought this but i did) so i tried installing pylons. Bad idea http://pylonshq.com/docs/en/0.9.7/gettingstarted/#creating-a-pylons-project That just lead me into a depression. Any recommendation on what a guy coming from PHP with not a whole lot of sysadmin experience should do? Should i start with no framework? Maybe you have some links you can share? Is mod_python the way to go? Thanks for any help
mod\_python has pretty much fallen out of favor (even with its developers). There are a lot of server options available, but you could do worse than mod\_wsgi on apache. Django seems to be the in thing these days as far as frameworks, though I don't really do much website development myself.
Before you get into the web development aspect of learning python, you should look at the basics. Do some command line stuff. Figure out how the inheritance model works. What is or isn't an object? (Hint: Everything is an object). Check out some libraries (numpy, anything database related, etc). The way I see it, you're trying to build a house, but you don't know how to use the tools.
There are more than one ways to start web programming in python. Check out this [tutorial](http://webpython.codepoint.net/) to understand different models. 
You sound like you're ready to stumble into Django. Go do the little tutorial first, it shouldn't take an hour. From there you'll be ready to try to move over your site. Lots of good people in #django if you have any issues. Trust me when I say this, once you find a great framework, your life will change.
no I do not. As I am stuck with 2.6, my "experience" with py-postgresql is limited to the (at least existing) documentation. Thanks for the heads-up though.
Thanks for this. Yes. Easily ported and thanks to the unit test, I can even check how good my porting efforts were (aside of the functional tests that require webtest which isn't ported and also depends on easy_install which isn't ported either). Also, it does EXACTLY what I need for my current project.
So what you're saying is we need to research the optimal curve to conserve distance while still providing a satisfactory chair-rolling experience in the event of range violations...
How about a chair without wheels?
isn't it ironic that gst is submitting it ?
... but that doesn't involve any programming or math at all ... :(
This is very true. It _is_ a really good way to learn though, if you can handle being criticized. The python community, while they will call you out for bad solutions, are more than willing to help you learn as long as you express a desire and will to - in fact, they seem to love this sort of person. Everyone's a newbie at something, there's no way to get better but practice, and programmers tend to be people with a love of learning. This seems especially true of the python community. That said, the level of benefit you would get from trying to port probably does somewhat depend on your level of skill. If you're not comfortable writing python, and reading python that you wrote, then you'd probably be better served by going through various tutorials and small projects until you are. Also, reading over parts of the standard library that you use often until you understand them. Reading other peoples code is arguably a much more important skill than being able to write code, at least once projects you're interested in get larger than a few hundred lines.
Looks like you're trying to do some web development. In that case, I recommend Django PHP is almost a web framework in itself, in that it's so simple to pump out a basic web page. Python is a language that focuses on very many different platforms and usages so it is easy to see why it did not click to you right away as to why it's so hard to create a web page using Python. I guess that's the simplest way to look at it :) Regardless, try out Django if you want to do web pages, but learn Python while you're at it and create some simple shell scripts.
I'd agree with previous reports -- if you have experience with PHP, start with Django. Find a great walkthrough at http://www.djangobook.com/ -- read Django Book 2.0 which covers Django 1.1 (the upcoming stable version). Django (Python, really) comes with a development web server (as opposed to a production web server, such as Apache) for development purposes, so you can start playing right away. Great for tinkerers. The Django docs are top-notch for beginners, as well. Digression: PHP developers tend to download and use whole LAMP stacks such as XAMPP (Windows) or MAMP (Mac OS X) because, as you've found, PHP and MySQL can be very easily bundled together with Apache for development purposes. After you've created a functioning (if basic) app, you'll find more instructions on deploying into a production environment (Apache and others) in the Deployment section in the official docs: http://docs.djangoproject.com/en/dev/ mod_wsgi is probably your best route.
Maybe they're constructing a new subway line across the street. It's happening here in Amsterdam, apparently they made a few misjudgments and now historical buildings are on shaky foundations... They're already considering canceling the whole multi-billion euro project.
Stop solving problems the easy way. Remember that multi-milion dollar space ball point? The russians use plain old pencils.
&gt;How high is the lip on the end? Seems ok unless she rolls over the edge. That provides conditioning in the event that the user's attention starts to drift away.
[They don't and they didn't](http://www.snopes.com/business/genius/spacepen.asp). :-)
No way should you use fastcgi, or any cgi implementation. Pretty much all cgi modules treat their target as a script, which ends up loading and initializing the python interpreter way too often (per-request, basically), so they just won't have the performance that any of the other choices will give you. There's basically 4 routes to go when deploying pylons... 1. apache + mod\_python w/ a wsgi wrapper. ([this wrapper](http://www.astllc.org/downloads/modpython_wsgi.py) is the one I use). This has the disadvantage of requiring a wrapper script, but it has the advantage that mod\_python is really common, and should be available everywhere. I go with this option very frequently, as it can be reliably deployed most places, and mod\_python is time-tested. 2. apache + mod\_wsgi. This is a somewhat newer solution, but it _is_ more efficient (and less interlocks to go "clunk"). If it's available, prefer this over (1), but once set up, they should both work the same as far as the WSGI stack cares. 3. paster serve directly - this works nicely for http, my company has a few apps deployed this way. It's much lower maintenance, more efficient and responsive... at &lt;20 users. It can't scale like (1) and (2). Problem 2: Paste doesn't serve static files as fast as apache. Problem 3: You'll need some upstart/init.d wrapper to keep your service going. I only recommend this for intranet deployments, but prefer option 4 even for this. 4. paster serve + apache proxy - This is basically the *only* way to do HTTPS with paster, the builtin https code is nowhere near reliable enough for production. Also, you can configure apache to serve your static files directly, set caching directives where possible, and the load on paste is reduced drastically. This is my preferred intranet deployment. Other webservers / reverse proxies will also work here, but see if they can serve your static files directly, that helps a lot. To summarize: Development: Choice 3 (direct paster) Public facing sites: Choice 2 (mod_wsgi) where possible, falling back to Choice 1 (mod_python+bridge). Intranet sites: Choice 4 (paste + apache proxy/static server). ---- Disclaimer: That wsgi bridge I linked to was written by me :)
just use django
jythonc?
Anyone mentioned Django yet? Oh. Alrighty then.
He might want to put a check in there for special methods like 'dog/__delete__', assuming a malicious server. No need to do an rpc call in the midst of garbage collection :)
I'm genuinely curious: what use case does this solve? I'm having trouble imaging a scenario where I'd need a new type at runtime (caveat: I'm really tired so perhaps my brain isn't working very well). 
The use cases that have an element of generating customized structures based on runtime information. Interfaces are one such a thing.
the best thing about dynamic typing is that you don't have to declare types before run time.
`'dog/__delete__'` def create_class(name, method_names): methods = dict((method_name, remote_method(method_name)) for method_name in method_names if not method_name.startswith("__")) return type(name, (RemoteClass,), methods) 
unfortunately you can't pickle a dynamic class created via type() (unless you put it in the module scope), so exec("cls") *is* often the right way to do it. Check the source of python's namedtuple for an example. edit: im wrong.
The article doesn't go too deep into the use case, but instead of making different types of Classes for each remote type, you could just use the same class for every remote type and just track the remote type as an attribute, e.g.: class RemoteThingee(object): # implement a strategy for working with # remote thingees ... pass cat1 = RemoteThingee() cat1.type = 'Cat' cat1.meow = 'meow' cat1.eat = 'cat food' cat1.sleep = 'zzz' dog1 = RemoteThingee() dog1.type = 'Dog' dog1.bark = 'Woof' dog1.eat = 'dog food' dog1.sleep = '...' Except this technique won't work if your remote types are organized hierarchically and you want to reflect that heirarchy in your dynamic types. In which case another solution would be to dynamically create interfaces and then declare that different instances of RemoteThingee() provide the respective interface. Seperating out Class types and Interface types into two hierarchies would let you have classes such as RemoteWebServiceThingee() and RemoteRelationalDBThingee() and then interfaces such as ICat() and IDog(), this way you seperate the concerns of how an object manages it's state versus what kind of state an object is representing. i.e. you could have a 'cat1' object which provides ICat but is a RemoteRelationalDBThingee` and a 'cat2' which also provides ICat but is a RemoteWebServiceThingee. 
how does exec("cls") pickle?
take a look at what they're doing at [http://svn.python.org/view/python/branches/release26-maint/Lib/collections.py?revision=72955&amp;view=markup](http://svn.python.org/view/python/branches/release26-maint/Lib/collections.py?revision=72955&amp;view=markup). its way more hacky than it should be IMO.
I'm kind of surprised the results turned out as close as they did. I guess the cost of a call each map iteration isn't much compared to the cost of creating all those strings.
Commented regexes . . . how do I not know about that?
Some stuff fixed/clarified in http://hg.diveintopython3.org/rev/96fa9b75f22d Latency/"orders of magnitude" fixed in http://hg.diveintopython3.org/rev/c1ef6736e3df Thanks.
Fixed in http://hg.diveintopython3.org/rev/2b6e26d89a55 Thanks.
Fixed in http://hg.diveintopython3.org/rev/c1ef6736e3df Thanks.
It looks like that issue was fixed in trunk (on which the Python 3 version is based) over 4 months ago. I agree a new release is a good idea, but please stop with the FUD. Trunk is quite stable.
So many goodies in there.. head = asplode I'm especially blown away by the fact that zlib and base64 encodings are built into the string class, very handy.
I've been checking out django. It's pretty awesome so far. Only thing i don't like about python so far is it's lack of multi-dimensional dictionaries. Making some things a pain in the butt. 
See also [The Complicator's Gloves](http://thedailywtf.com/Articles/The_Complicator_0x27_s_Gloves.aspx) EDIT: Markdown ist der Teufel
For what it is worth I managed to get it working, I had some stupid syntax errors in my previous attempt. For what it is worth I managed to double the speed of the previous version in which I used threading; however it is only a very small fraction faster than the original seriallized bourne shell pipeline. 
So all these comparisons: &gt;&gt;&gt; x = 5 &gt;&gt;&gt; 1 &lt; x &lt; 10 True &gt;&gt;&gt; 10 &lt; x &lt; 20 False &gt;&gt;&gt; x &lt; 10 &lt; x*10 &lt; 100 True &gt;&gt;&gt; 10 &gt; x &lt;= 9 True &gt;&gt;&gt; 5 == x &gt; 4 True would be this written in most other languages: x = 5 ( (1 &lt; x) &amp;&amp; (x &lt; 10) ) True ( (10 &lt; x) &amp;&amp; (x &lt; 20) ) False ( (x &lt; 10) &amp;&amp; (10 &lt; (x*10)) &amp;&amp; ((x*10) &lt; 100) ) True ( (10 &gt; x) &amp;&amp; (x&lt;=9) ) True ( (5 == x) &amp;&amp; (x &gt; 4) ) True ? 
Yes. Just syntactic sugar; There are a lot many gems in that same thread, tho'
Yes, most of the time. Only difference is that the expressions (like x*10) won't be evaluated twice, which would make a difference if it involved side-effects.
Yeah, I know. And I would've gone into the interview pretending to be Mr. Master-of-the-Regular-Expression too.
What IDE/TE you use? I use Wing and am happy about it. To me the intellisence, good Auto Complete and such features are far more important than having to type a few less key strokes. Tho' I must admit, never gave enough chance to Emacs or Vim. Scribes seemed better in that category. IDLE itself is quite nice, my recent discovery. 
Y'all didn't read _Dive into Python_? I thought that was required reading on Reddit.
For Python development I've never had a problem simply using VIM. For larger projects, there are some nice plugins like Taglist but even then I've kept mine pretty barebones apart from some syntax highlighting and PEP 8 standards
This has gone in python3 unfortunately. The encode/decode methods have been changed so that `bytes` objects have only an decode (which produces unicode), and `unicode` objects have only a encode (producing bytes). This is a good thing in itself (removes lots of confusion about which way round things go), but means there are no longer encodings translating like to like, such as base64, rot13 or zlib.
(Pronounced: Log 4 Gay) Currently running at: http://log4gae.appspot.com Just knocked up a little logging application hosted on Google App Engine in Python using the standard Webapp framework. There is a basic Web UI in place, but this will eventually be replaced by the REST interface. I've also included a little Python shell script that can be used within your scripts to log messages to the Log4GAE service. Source code is available at GitHub: http://github.com/jingleman/log4gae/tree/master 
"Unfortunately there is not an easy way of listening to the sound directly from python. If you're interested in having sound playback from python however check out the pygame library and have also a look at the psychopy package that uses the pygame library for sound playback in psychology experiments. " That is indeed unfortunate, and the reason I had such low expectations when I went to the page. The pygame API allows you to play sound files. That's it. Internally it "goes to C" long before it deals with any objects that would be useful for people doing audio manipulation. The other library he references is just a wrapper around existing libraries that either offer no more functionality or else aren't effectively multiplatform. Multi-platform audio processing fopr anything more substantial than playing an audio file is woeful on python. 
Yeah, you can pretty much ignore the module references. The standard wave module + numpy package should be enough to follow this. The interesting part of the article is that it walks you through using FFT to get back the frequencies and their amplitudes, if you didn't already know how to do that. I'm adding an similar implementation to a music theory package, which should open up some cool possibilities in music generation, recognition, etc. Python is awesome for that kind of stuff as long as you have a cross platform C synth to back you up (we use fluidsynth).
we call them *eggs*, scorpion.
On a related note, "Men have become the tools of their tools" -Henry David Thoreau.
It means there are no *built-in* encodings for `bytes`-&gt;`bytes` stuff. 
heh the focus of the article was quite good. We're all playing around with that stuff at the moment at work. But - as you'd have guessed - I've been frustrated by a related issue. I wrote a program to translate solfa into music at songseed.org. Last time I checked it out out it had a broken build script though, as well as the problems mentioned in the article. 
Removing indenting for control strutures: from __future__ import braces 
snake eggs, in fact and from a cheese shop
from **past** import tired_syntax
I'm not familiar with solfa, but fluidsynth seems like the perfect fit for that kind of stuff. Check out the pyfluidsynth bindings; should give you a cross platform solution.
What do you think?
emacs works on all platforms.
Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ? ImportError: No module named __past__
I usually use the text editor [Editra](http://editra.org/) (written in Python) which also has some useful IDE functionality. [Pydee](http://code.google.com/p/pydee/) is also quite nice. It provides a MATLAB like interface for Python and is pretty useful if you do lots of interactive stuff.
I don't understand why exec "make" the resulting classes pickle and not type: test.py: TypeClass = type('TypeClass', (object,), {'x': 42}) exec 'class ExecClass(object): x = 42' class NormalClass(object): x = 42 It works fine: &gt;&gt;&gt; import test &gt;&gt;&gt; import pickle &gt;&gt;&gt; pickle.dumps(test.TypeClass()) 'ccopy_reg\n_reconstructor\np0\n(ctest\nTypeClass\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n.' &gt;&gt;&gt; pickle.dumps(test.ExecClass()) 'ccopy_reg\n_reconstructor\np0\n(ctest\nExecClass\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n.' &gt;&gt;&gt; pickle.dumps(test.NormalClass()) 'ccopy_reg\n_reconstructor\np0\n(ctest\nNormalClass\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n.' According to the namedtuple example, you need to put the 'exec' class in __module__ too, just like 'type' class.
I got the cheap imitation. Note [Dive into Python 3](http://diveintopython3.org) is out there.
Nice set of tricks, however all but one of these are in the documentation. Can't people read?
For Windows I suggest you try Pythonwin. It has an interactive prompt, dynamic autocomplete, and integrated debugger. Notepad++ is great, but it's only an editor.
Very interesting. It uses curses and hence does not work on Windows.
 from __fifty_two_years_ago__ import fortran_statements :(
 &gt;&gt;&gt; from __future__ import braces File "&lt;stdin&gt;", line 1 SyntaxError: not a chance 
Hey cool! Maybe there's another editor/IDE for me to try out! ... Oh wait. Yeah, there's just Textmate.
Not to mention that vim's [cscope support](http://cscope.sourceforge.net/cscope_vim_tutorial.html) is great.
uhhh... wtf is that little +Aa thing and the weird box at the top? did they change self posts?? [edit: holy shit they did! I guess thats what I get for unsubscribing r/reddit.com. carry on]
I'm an old fart who uses vim for everything, so I can't give you advice about an actual IDE. What I can say is give [ipython](http://ipython.scipy.org/moin/) a try. They have slideshows and videos to convince you better than I could. It's an environment that not only makes programming python easier, but is so powerful that makes a decent replacement for bash.
No, they made it so you can add context to a post through that so the submitter doesn't have to make a comment to do it.
Well, you're a self-made man then.
Eric 4 ide and gvim. The debugger in Eric is great. When running code in Eric you can put sys.breakpoint() anywhere and it will stop there. Don't have to worry about F7 F7 F7 damn to far broke out :(. PS The debugger supports threaded apps very well. It is not just for PyQt apps.
Netbeans all the way. It has great support for more than Python (CSS, JS) which is wonderful when writing web apps.
Emacs supports UML?
by the title I thought it was a local logging not a webservice but interesting anyway :)
Kate? 
It seems like a legitimate site but somebody should maybe contact him...his site is being [reported as a phishing site](http://www.mywot.com/en/scorecard/xoomer.virgilio.it) by Web of Trust. Edit: I sent the site owner a message.
Using the Chaco plotting toolkit, you can do a realtime plot of the signal, its FFT, and a sonic histogram. (This is one of the examples that comes with the package.) screenshot: http://code.enthought.com/projects/chaco/img/audio-spectrum.gif code: https://svn.enthought.com/enthought/browser/Chaco/trunk/examples/advanced/spectrum.py 
FWIW, the quotation then means, U become the tool of the tool you made yourself.
Yes, I know what you mean. It is a bit confusing. I'll try and expand on the description on the actual site. Cheers for your feedback though.
Wing is probably the best, but the professional edition is too expensive for my limited Python programming. I've settled for Eric4 after trying PyDev, Netbeans, Stani and a few others. It still has many annoyances and in the spirit of OSS it has a crappy GUI and no documentation whatsoever, but it will have to do for now. The biggest drawback most IDEs have is poor debugger support.
Interactive debugging, navigation?
In C++ you could get rid of all the parentheses.
Wing Professional costs $179; If you work on any full time project; I dont see how it is expensive. Actually, Wing's Debugger, awesome as it is, is the feature I use the least. I find sitting in the console at the point U'd need to debug far more convenient.
Actually, this **can** be done with normal class syntax (without exec). Remember that python is dynamic - "`class`" is an executable statement that creates a class at the point it runs. Within a function, it will create a new class each time the function runs. Similarly there is nothing special about class bodies - arbitrary python code can be placed there, like loops and function calls, not just assignments and definitions. The only thing thing different is that the namespace the code is executed in becomes the class's methods and attributes at the end of the definition. This means that you can easilty create a function to do the same thing as follows: def make_class(name, base, methods): class C(base): for name, body in methods.iteritems(): locals()[name] = body C.__name__ = name return C &gt;&gt;&gt; Cat = make_class("Cat",object, {'meow': lambda self: "meow"}) &gt;&gt;&gt; cat = Cat() &gt;&gt;&gt; cat &lt;__main__.Cat object at 0x00A0D870&gt; &gt;&gt;&gt; cat.meow() 'meow' The only thing not creatable directly with this approach is the class name, and that's modifiable after the fact.
I'm trying to promote Python use in my organization and so far I'm the only one that has worked on some Python projects (not full time). Interactive console debugging is priceless! Wing pro has it, but the other versions don't. Eric also has it.
 Yeah - but that's not actually a very common situation. There's an inherent contradiction in the requirements: you care about performance in a CPU bound task enough to want to use multiple CPUs, but not enough to care about the up to 100fold slowdown of python vs C. There may be situations where this arises, but they're pretty rare. 
You got to thank me for pointing you at [this](http://www.ifi.uio.no/~inf3330/scripting/doc/python/ipython/node9.html) I don't use Wing, or its interactive console for debugging. I just embed iPython where necessary. I do it more often than necessary, `coz its just nice to do so ;)
we do need help with the documentation effort (which is ongoing), as well as having people simply getting it and using it so we can trace and fix the rough edges. Hop over to our mailing list, we're open and friendly ;o)
and a godsend to a few :) i'm indeed open to arguments regarding the licensing of Shoebot, so fire away!
vim is very good. cf &amp; ctrl-n &amp; cscope powah ! 
[More informative site](http://bobo.digicool.com/)
I'm using Vim for everything as well. I've just found [PIDA](http://pida.co.uk/), looks like it's a Python IDE that can use Vim (or EMACS) as its editor.
I use Gedit on both Linux and OS X.
What do you mean by ,,multi-dimensional dictionary''? You can have both compound keys `{(1,2): "Something"}` and dictionaries containing dictionaries `{"inner_dict": {}}`. You can even put a dict object in itself, but just don't. Can you tell me what you mean?
I would recommend eclipse and pydev, I have tried other s as well but this is the best free one
Seconded. Especially with the newest version of PyDev which allows you to easily edit your grammar version.
oddly, i'm trying namedtuple now and I can't get it to pickle even *in* the module scope. I wish this problem of pickling local-scope classes could be solved.
I love ipython for testing, prototyping, and just goofing around in general. It's definitely incredibly useful, but I'm not sure I'd call it an IDE nor a decent replacement for bash either. That's all just opinion though. What's important, and where we agree, is that ipython is freaking sweet. 
I like pydev, but it's a bit bulky, and was occasionally crash prone for me when running VMs (in virtualbox). Your mileage may vary of course, but one or two crashes in the middle of coding was all it took for me to stop. Vim comes with it's own host of issues, but at least I'm generally in control of the situation... generally :)
I wouldn't call it an IDE either, and perhaps I should rephrase... it makes a very *[interesting](http://ipython.scipy.org/doc/stable/html/interactive/shell.html)* replacement for bash. I only used it in bash's place for 3 months or so, but it changed the way I thought about shells.
WingIDE(not free), it's Debugger and Code Intelligence is Very impressive. I think it's very important to a newbie. IPython is useful too. VIM/Emacs always is the right choice, but nobody need it as the answer :)
Why would you run eclipse in a VM? That just seems kind of silly. 
[sarcasm]Someday we will just "design" UML diagrams and the code will be automatically generated.[/sarcasm] But I sure hope they're right about Python, because I'd sure love to use just one freakin programming language. Just to spare others the 3 seconds, the article ain't worth reading.
I'm in the middle of studying the guts of an OS. Believe me, you will not be writing it in python.
Actually I know of at least one attempt to write an OS kernel in Python: http://code.google.com/p/cleese/
I really hope not, python is a great language but innovation is neccesary and also most great ideas come from trying different approaches and different mindsets that you get from different paradigms. of course Guido thinks SICP ain't worth reading so it's no surprise most python sectarians disagree with me but just give it a try, programming has much more room that comprehension lists.
I had to abandon lisp for python to do web programming. For the love of god, I hope it does not come down to this for everyone.
&gt; Just to spare others the 3 seconds, the article ain't worth reading. thanks
&gt; Someday we will all program in Lisp. There, fixed it for you. 
An OS kernel should be hardware.
Sorry, but I think you meant: &gt; Someday 40 years ago we all programmed in Lisp. 
The reason the list comprehension is faster is because there is a special LIST_APPEND opcode that the list comprehension uses (since it knows it's adding to a list), whereas the loop has to do the attribute lookup on "append" each time through, since python's compiler doesn't know about types.
They're not mutually exclusive.
SOMEDAY PYTHON WILL BE FASTER THAN OPTIMIZED ASSEMBLY
Yes, but the Python kernel in Cleese runs in the Python VM, which is written in C.
I don't think there's any reason it couldn't run on PyPy which is written in Python (and is translated to C and from there onto ASM).
That may indeed be the case. Programs are getting bigger and bigger, and CPU time is getting cheaper compared to disk transfer (and access) time. Loading and interpreting or compiling a Python program could become faster than loading a compiled C program.
&gt; CPU time is getting cheaper On desktop computer, mainly. Nowadays, we see a proliferation of cheap, slower devices that benefit from optimization, like cellphones and netbooks.
I liked Wing a lot when I tried it but unfortunately the Mac version requires an X11 server and window manager. The X11 stuff made it flaky and a hassle to use. If I was developing on Windows I'd probably pay for the full version of Wing. The context-sensitive api information, debugger, and source navigation was extremely helpful when I was learning the language. You'll learn Python much quicker and easier with those features. I just wish they'd develop a real version for the Mac.
Just posted this in the other "Python IDE recommendation" thread. : I liked Wing a lot when I tried it but unfortunately the Mac version requires an X11 server and window manager. The X11 stuff made it flaky and a hassle to use. If I was developing on Windows I'd probably pay for the full version of Wing. The context-sensitive api information, debugger, and source navigation was extremely helpful when I was learning the language. You'll learn Python much quicker and easier with those features. If you do any reasonable amount of python development, the time-savings from that stuff will pay for the IDE within a week( IMHO). I just wish they'd develop a real version for the Mac. 
All hail the once and future king.
i was trying to create a dictionary using this format var['ads']['adsf']['asdf'] = '243234' It didnt like that
Python has a couple of hang-ups that would prevent it from becoming de facto. Don't get me wrong, it's a great language, and the batteries-included nature is pretty awesome. But, if you asked me to bet some money on what language would become the be-all-and-end-all, I'd probably say that pure functional languages are the underdogs that will surprise us all.
Looks like Sinatra on the surface, but go through the intro, and it looks a lot better and more powerful.
functional makes your brain hurt... ...and so does math ;)
This is mostly easy-to-find stuff, but I did not know that you could do this: try: throws() except Exception, original_error: try: raise finally: try: cleanup() except: pass # ignore errors in cleanup This traps a quick exception from cleanup() while the exception from throws() is still being propagated.
You either need to create each dict explicitly, like this: var = dict() var["abc"] = dict() var["abc"]["def"] = dict() var["abc"]["def"]["ghi"] = "123" print var Or use a defaultdict found in the collections module and some cheating, like this: from collections import defaultdict def dicts_all_way_down(): return defaultdict(dicts_all_way_down) var = dicts_all_way_down() var["abc"]["def"]["ghi"] = "123" print var Third option is a flat dict with tuple key: var["abc", "def", "ghi"] = "123" print var Pick your poison, I hope this helps.
You didn't understand a damn word of what I said, didn't you?
I'm not referring to any particular variant, since most of them have a syntax that drives me crazy. Just that the concepts behind it are all very desirable.
Except now I MUST read it... Jerk.
I'm sort of amused. The coverage.py [site](http://nedbatchelder.com/code/coverage/) tells me that Coverage.py was originally written by Gareth Rees. Rees is known to me as someone who wrote a few text adventures rather early in the modern amateur era. Strangely small world sometimes.
Except for the fact that PyPy is hopelessly, perpetually, immature.
yeah i tried the defaultdict, but django templates wouldnt loop over it. I didnt think to try creating the dictionaries explicity like that. ill try that next time. I found my issues was actually solved with django ORM. I really appreciate your help, thanks =)
its not terse enough to be a replacement for bash, and the ipython namespace is far too cluttered with python builtin language features. bash is a great language for shell, python is a great language for everything else :-)
No way.
..but they're still faster than computers from not long ago.. The iPhone 3GS has a ~600MHz processor and 256MB of RAM..
I cloned the repository and created a very rough port to python 3, which worked quite well actually. Now I'm adding some minimal additional stuff to make it work better with what I already have based on werkzeug (which I certainly am not able to port to 3 - too complex for my current skill level and also in need of some rewriting due to the compiler module gone in python 3), For those interested, the repository is [here](http://github.com/pilif/mnml/tree/master) but keep in mind that it still is very rough. Thanks again for the pointer
No problem. Let me know how your python3 adventures go. I'd love to be using it myself at work but too many dependencies on older code. 
while it may not be an IDE, I still spend more of my development time in ipython than I do in Wing. 
Great example! Thanks for the link.
This is the hottest Python framework, created by experienced developers with a focus on simplicity, speed and good documentation. It aims to be WSGI compatible and as neutral as possible in regards to templating, persistence, url dispatching, etc. 
"If events are really a bad idea for high-concurrency servers, somebody forgot to tell the Lighttpd, Nginx, justin.tv, memcached, LiveJournal, and Facebook folks..." That was the point of the article - conventional wisdom says the opposite.
"Yeah - but that's not actually a very common situation." Not at all true. Python developers are *often* trying to optimise their CPU bound code and having to drop down to C really is a worst case scenario.
&gt; Not at all true. Python developers are often trying to optimise their CPU bound code and having to drop down to C really is a worst case scenario. The point is that there's a big overlap between "code I need to be fast enough to be worth taking advantage of multiple cores" and "code that python is too slow for". Python is not well suited to high-CPU chewing algorithms, and the GIL pretty low on the list of things that will rule it out in cases where CPU performance is sufficiently important. Removing the GIL only helps the small region where python is ill-suited to the problem, but within a narrow range of tolerance of performance / usability constraints. Putting the CPU intensive part in another thread means you care sufficiently about performance to paralellise the critical code to take advantage of multiple CPUS (unlikely to give more than 2-3 times speedup, depending on machine and paralellisability of your algorithm), but that performance isn't sufficiently critical to care about python's own much larger slowdown. Solutions like multiprocessing further narrow down the region of usefulness by removing embarassingly paralell problems with no sharing involved from this set. I think the GIL will become more important as python improves in speed, so it may make sense as an eventual goal for projects like unladen swallow. Right now, removing it has, at best, the effect of making it suck slightly less at an area it sucks badly at - if that hurts the common case by slowing it down under most situations (where again, speed is nice, but non-essential), then it's ultimately a pessimisation. 
Is it decent at any level? Tell more.
The word "Zope" listed in in the first 25 words on their homepage scares the living crap out of me. I knew a Zope guy once. I think there were things not right in his head. it was terrifying.
I can say I've tried almost everything... but only on Windows. First... don't forget python has an interactive mode, you can actually run code by running the python interpreter directly, without passing any file as input parameter (run the python.exe). This is extremely useful for testing code snippets, or checking if a particular code is just right. Also, Python works on modules, any python source file it's actually a module (that's why we have the "if __name == '__main__'" stuff, so you're code it's not really tightly coupled like when you do have external code dependencies or declarations (like in C/C++), so you're code it's like having a 'top' module running and from there you can get your additional stuff (from XYZ import * it's sort of evil). So, any editor that is able to open multiple files and work on directories might be good enough for your situation. So my usual flow for Python development goes by making something that runs (really limited), then extending the functionality by splitting the code in multiple modules when the code size increases. I usually put some sort of helper test functions that run when my module is executed in 'stand alone' fashion. So this is a bare unit testing approach. Said that... There is not a perfect Python IDE yet, one that fits most of common use cases, so, this is my partial experience in summary: 1. For a start or if you like lean editting. I'd recommend SciTE, don't forget to map properly the run and compile commands in the python properties configuration file. SciTE captures properly any error message, and a double click quickly gets you to the offending line. * The advantage: Fixing code can be really quick, SciTE is simple yet powerfull (like regular expressions search and replace). * The downside: You might need to tweak it a little bit, over configuration files, to fit your taste. 2. It you're doing GUI stuff, get a RAD for your toolkit, like SPE (I like this!) for wxPython, Erick IDE for PyQt, for PyGTK, I really don't know. Maybe it's just me but PyGTK doesn't feel 'right' on Windows. Maybe is community support. 3. For Web development or general purpose stuff, get your favorite code editor, the one that makes you really productive, I can't say much on Eclipse based editors, in my personal taste, I'm sort of reluctant to use java based applications on Windows, I like snappy an responsive apps, but feature wise, PyDev is nice. Hope it helps. 
Metaclasses with nastier syntax...
I don't think this is how typical Python programmers (who are increasingly less likely to know C) think. If you have an inherently parallelisable problem unsuitable for multi-processes then Python programmers will look for a solution *in Python* and not naturally (or out of preference) turn to another language. In CPython turning to threads will make the problem *worse* not better. At Resolver Systems we didn't have this problem because we are using IronPython (no GIL) but our app performance would be a lot worse on CPython (we use threads for concurrent calculations). We are executing user code in parallel - so rewriting in C wouldn't help anyway (unless we make our scripting API a C API and dynamically compile - but I suspect our users wouldn't be happy with this).
I've been using http://showmedo.com for their video tutorials, and they're fairly comprehensive . From setting up the environment, to basic programming, to web development frameworks. 
It uses some Zope components (the Zope Component Architecture), but you don't have to know Zope or ZCA to use it. I may be the wrong person to comment on this, because I've been doing Zope development and haven't left screaming yet, but the Zope guys have been doing pretty cool stuff for over a decade now. If you trust more other frameworks (for example Turbogears), you'll probably know that tg2 uses some repoze packages (repoze.who, repoze.what) and there are some discussions to make reusable components (I think the views) between pylons and bfg.
Interesting but not really a "gotcha." Any code doing `int_a is int_b` is pretty suspect.
What's that about?
This isn't unique to Python, nor is it a gotcha when you use the wrong operator and get undefined results.
Identity is not equality, no shit? Identity iff equality, but not vice versa. EDIT: iff should be "only if".
&gt; Identity iff equality, but not vice versa. You means "implies" (or "only if"). Iff is used when the two are equivalent. 
The point isn't that identity and equality behave differently, it's that identity between two int objects behaves unexpectedly for certain values due to hidden implementation details.
It's not really unexpected, it is unpredictable. However it's expected to be unpredictable.
Err, it's entirely predictable once you know about it. It's entirely unexpected if you don't know about it. And most people don't know about it, because it's an undocumented side effect due to an implementation detail. The issue here is the identity operator's behavior, not how it relates to equality's.
Isn't this a beginner question ? &gt;&gt;&gt; a=500 &gt;&gt;&gt; b=500 &gt;&gt;&gt; c=200 &gt;&gt;&gt; d=200 &gt;&gt;&gt; id(a) 142297032 &gt;&gt;&gt; id(b) 142297056 &gt;&gt;&gt; id(c) 142155132 &gt;&gt;&gt; id(d) 142155132 &gt;&gt;&gt; id(200) 142155132 &gt;&gt;&gt; My understanding is that python create objects for low integers that it reuses all the time for performance reason.
&gt; My understanding is that python create objects for low integers that it reuses all the time for performance reason. CPython does, yes. It does this with other types of objects as well; for example, it keeps a list of dictionary structures in-memory (the actual C structs, not the high-level objects) and recycles them for common uses like setting up the keyword arguments of functions, rather then freeing and re-allocating each time one is needed.
That's beside the point. The whole point of abstraction is that the *implementation does not matter*. If you are comparing integers by identity then most likely you are working at the wrong level of abstraction. If you are comparing integers by identity and the results surprise you then you are most definitely working at the wrong level of abstraction. &gt; It's entirely unexpected if you don't know about it. And most people don't know about it, because it's an undocumented side effect due to an implementation detail. No, the trouble here is when people don't understand the difference between identity and equality. If you know the difference, then the results are not unexpected at all, even if you don't know the exact implementation detail that is causing it to occur. If you don't understand identity, then of course the results are going to surprise you.
It is pretty horrendous though. Either scalar values should have equivalent identity, or they shouldn't. They shouldn't sometimes-yes-sometimes-no have equivalent identity, in accordance with the runtime implementation. That's as bad as the "the behaviour is undefined" which litters the ISO C and ANCI C++ standards. It seems to me that the behaviour is post-fact asserted to be so, (which is an ass-covering move when you've introduced a bug), rather than it was ever designed expressly to be this way. The real issue is that the behaviour of the "is" operator is not explicitly defined (and can be in fact be said to be undefined in the language) upon these scalar values. 
The gotcha is when you're debugging somebody else's code that fails inconsistently and you can't put your finger on why.
&gt; The real issue is that the behaviour of the "is" operator is not explicitly defined (and can be in fact be said to be undefined in the language) upon these scalar values. It is explicitly defined, it's just not defined the way you want it to be defined. If values are the same object, then they are identical, otherwise not. You are imposing artificial constraints on the implementation and breaking encapsulation. The point is that you should not care about the implementation of a class (unless you are actually implementing or extending it), and identity is intrinsically linked with the implementation. 
In mathematics, __500__ and __5*10^100__ are different representations of a number, and have equality. In programming, __c__ and __d__ are different representations of a number, which will have equality when both are set to a representation of 500. The same goes in something like C++. The second assertion will fail, assuming no compiler optimisation. int c = 500; int d = 500; assert( c == d ); assert( &amp;c == &amp;d ); 
I understood that it is defined by the implementation. And that is equivalent to no definition, if you look at the equivalent unhelpful gaps in certain areas of specification of C and C++. 
I assume you mean an expression which is actually equivalent, 500 != 5e100. Never the less, 5*10^100 is not a number, in mathematics. It is strictly an algebraic expression under any understanding of pure mathematics. If it were evaluated, then it would be a number. Even assuming compiler optimisation, the 2nd assertion would fail. But the comparison is not really relevant - python is a symbolic language, with everything being a reference to an object - in this instance, these integers below 256 are recycled. That "is" functions differently for a restricted subset of integers is an unhelpful side-effect. Why it is unhelpful is that it is a gotcha, and it is obscura. Things should be consistent, and they should work as expected, and be friendly to developers. Side-effects are unhelpful to developers at large. I have a high regard for python, and consider it the heir-apparent in the scripting language space - for it's lively culture, it's excellent documentation, it's strong cross-platform support across unix variants and windows - and it's strong project leadership - nothing else comes close. However the reason for the variation in the behavior of "is" is purely an optimisation issue of the implementation of the interpreter. That an implementation issue infects the public behaviour of the operator is not good manners. 
Ok, so you think it is a bad design decision. Can explain why (I'm genuinely curious)? Do you you think the *is* operator is badly designed: "The operators is and is not test for object identity: x is y is true if and only if x and y are the same object. x is not y yields the inverse truth value."? Or do you disagree with the way integers are implemented? Do you think equal integers should refer to the same object (presumably this would create extra overhead to maintain this condition after every operation)? Or do yo think that no integers should refer to the same object? This seems to be much more memory intensive. And should the exact implementation be documented? This would set it in concrete, disallowing any future improvement on the implementation. Finally, what possible reason do you have for comparing integers by identity, unless you are actually modifying the class?
I got my scientific notation wrong it seems, but whatever. What I was trying to say is that it's in the land of implementation details and outside the letter and law of the specification. It's poor form, definitely, but we really should leave the clever tricks to the people who deal specifically in optimisation and we should stick to what's been promised not to change as application developers.
&gt;The whole point of abstraction is that the implementation does not matter. I agree entirely. But look here: &gt;&gt;&gt; a = 3 &gt;&gt;&gt; b = 3 &gt;&gt;&gt; a is b True &gt;&gt;&gt; c = 999 &gt;&gt;&gt; d = 999 &gt;&gt;&gt; c is d False I would expect false in both cases, given how identity is supposed to behave. But really, how can this be explained without referring back to the CPython int-caching behavior? You have to know the implementation details to know why the 'is' operator behaves this way. That's not good.
Why would you expect False? According to Python the behaviour of 'is' is undefined in this situation. That's like taking the following in C: int *a = malloc(sizeof(int)); printf("%d\n", a); and expecting the value `0` to be printed out. It will probably be 0 most of the time, but it's really undefined.
 &gt;&gt;&gt;the memory location of a == the memory location of b True &gt;&gt;&gt;the memory location of c == the memory location of d False I think that's reasonable. The following is still true, if that's what you want to do: &gt;&gt;&gt;500 is 500 True &gt;&gt;&gt;200 is 200 True
Out of curiosity, which other languages cache references to small integers like this? Is it pretty common?
&gt; The real issue is that the behaviour of the "is" operator is not explicitly defined ... upon these scalar values. Actually, the behaviour of 'is' is perfectly defined. The problem is that it is not defined as to whether different numbers have to be the same object or not. I don't see any point in defining that as it puts an unnecessary limitation on python implementations.
Sun's Java implementation, for one.
Java has the same behavior, except '==' is more like 'is' in Java. So to compare equality properly, you need to use the objects equal() method
&gt; I would expect false in both cases, given how identity is supposed to behave. Of course not... clearly *a* and *b* refer to the same object in memory. Forcing them to be different would presumably be less efficient, especially for such frequently used values. &gt; You have to know the implementation details to know why the 'is' operator behaves this way. That's not good. "is" depends on the implementations details by definition! You can't abstract that away because by definition "is" relates to how the objects are represented in memory. The fact is that if you are using "is" then you *need* to know the implementation details. Whether that's a good idea is a different issue.
FTA: &gt;In Python, is tests for identity, not equality. x is y if and only if x and y reference the same thing. You could make the case that a and b are separate objects, so even if they hold the same value they don't reference the same thing. But ints aren't treated as references, right? In that case, you're right, it's just a mess of undefined behavior. So... why are you arguing for undefined behavior? Especially in Python, of all languages.
No gotcha here - those int are objects as promised, and == will work as promised. Nobody promised you that "is" will return True of False for some integers. This is implementation detail you should not count on. You should use "is" only when you want to check for object identity.
&gt; Err, it's entirely predictable once you know about it. Yeah, but the one thing every Python program should know about `is` is "don't use `is` unless you want to know if two things have the same address in memory." So, even if you don't know off the top of your head how `int` is implemented in Python, it should be obvious that you shouldn't use `is` unless and until you find out. 
This is stupid, and every Python newbie should know the difference between `is` and `==`… But that said, I can see how it would be easy to overlook the difference and think that they were two ways of writing the same thing if you didn't read the documentation and were just learning Python by copying other people's code and experimenting. Maybe Python 4000 should drop `is` and just encourage people to write `id(a) == id(b)` instead.
Actually, all Java implementions do this by specification.
RTFM. That's the nice thing about a language that is actually defined... http://docs.python.org/reference/expressions.html#literals &gt; _may_ obtain the same object or a different object with the same value What you expect doesn't matter when you can inform yourself. The language doesn't guarantee anything about the objects behind literals, hence the word _may_.
You see, the only sane way to remove the undefined behaviour of `is` is removing `is` altogether. The other solution would be to make `is` equivalent to `==`. But in both cases there is a need for comparing actual identities: reintroduce `is` or mandate `id(a) == id(b)`?
I'd change the "is" to "==" right away if I saw it used to compare two ints...
&gt; if id(a) == id(None): &gt; print("urgs") I think 'is' is perfectly fine
Whoa cowboy. I thought I completely agreed with you that it would be annoying to some, if not many, users. As I said, it's annoyed me a few times. =) My concern with turning this noise down by default is that users won't be aware that it's available--it *is* useful in more complicated situations that involve more than one target host(ETL, sometimes, notably). ATM, I'd rather the user have a wtf moment when he sees the excess, hit the docs, and to find a way to silence it for *his application*. Yes, 0.8 has nothing in the docs, but 0.9 does. Granted, hazarding that the wtf moment might direct him/her back to psycopg. =(oh wellz) 0.9 has 'msghook' attributes, and 1.0's DB-API will probably make further use of them. As far using Python logging/warnings, I figure that's up to the application(install a postgresql.sys.msghook and format/direct the message to one's taste. for errors, postgresql.sys.errformat). Cheers. p.s. the server location(c source file names and line numbers) information takes up a single line of output, is that really too much?
&gt; And that is equivalent to no definition, if you look at the equivalent unhelpful gaps in certain areas of specification of C and C++. Curiously enough, this specific case is well-defined in C++: two different objects can't have the same address. One _very_ unpleasant consequence of that is that the minimal size of an object is one byte (i.e. one int due to alignment on most architectures), which in turn means that when you create a functor object which doesn't have any data, say as a comparison for sorting, it is still allocated (on the stack) and passed as a parameter. Sufficiently clever compiler™ could optimize it away in simple cases, of course.
`a == None` also works. People just don't do it because of the speed advantage of `is`. But maybe that's a premature optimization that confuses noobs excessively. 
Repeat after me: `==` checks integer (and other) equality. `is` checks *object identity*. This is not a gotcha at all for people who, you know, actually know what these operators do in Python.
And integers are not boxed by default, so that doesn't even apply. This behavior is only possible in a language where everything is an object.
I think this may happen in some implementations of Common Lisp.
This shouldn't be "gotcha" at all. I can't imagine why you'd ever write code asking if "*a* is *b*" when *a* and *b* are integers, or some other "basic" type. When you're explicitly creating objects, it's perfectly reasonable to ask "does *a* reference the same object as *b*". When you're talking about integers, objects that are implicitly created by the interpreter, you're asking about internal behavior of the interpreter, which seems like a pretty patently Bad Idea.
This sounds like the EQ vs. EQUALS predicates in Common Lisp.
When "a is b" returns False and "c is d" return True, it is inconsistent. It's a gotcha; no need to apologize.
&gt; People just don't do it because of the speed advantage of is People also don't do it because `a is None` (or `a is True` or `a is False` for that matter) just plain and simply reads better.
No, it's an expected property of any language that lets you define this type of operation. Equality is not guaranteed to be identity. Note that you can even do this in, say, Java -- two objects may be "equal" according to `equals()` (and also according to `hashCode()`, and note that in Python the same will be true with `hash()`), but not be the same set of bits in physical memory.
No, it is not consistent if a *is not* the same object as b and c *is* the same object as C. Neither Python (the language) nor Python (the implementations) make any guarantees regarding object identity except than an object is identical to itself and certain objects (None, True, False) are singletons. That integers below a certain number are interned is entirely an implementation detail which programmers are not justified in depending on. If you're comparing integers with `is`, you're doing it wrong. Case closed, problem solved, fix your code.
no one said about comparing. If you talk about identity, c=200; d=200; c is d; should not return True as they are two different objects. The inconsistency here (if the blogger was correct) is that cPython treats numbers differently.
&gt; no one said about comparing. [As you can see if you'd do a modicum of research](http://docs.python.org/reference/expressions.html#notin) `is` and `is not` are *comparisons*. They *compare* object identity. Therefore if you're talking about `is`, you're talking about comparing two things. &gt; If you talk about identity, c=200; d=200; c is d; No. `c` may or may not be `d` in that case: the Python implementation has no responsibility to intern the number `200` and ensure that `c is d` in this case. On the other hand, if you did this: &gt;&gt;&gt; c = 200 &gt;&gt;&gt; d = c &gt;&gt;&gt; d is c Then you would rightly expect (and the Python implementation would rightly return) `True` for this object identity comparison. &gt; The inconsistency here (if the blogger was correct) is that cPython treats numbers differently. There is no inconsistency here. You and the blogger both are simply arguing based on your *intuition* about what `is` means rather than simply *knowing the language as it is defined* and relying on the properties it guarantees. Basically, you're arguing out of your arses.
Not everything that is true `is True`. Not everything that is false `is False`. Implicit truth is pythonic.
[Sufficiently Smart Compiler](http://c2.com/cgi/wiki?SufficientlySmartCompiler) is mostly related to high-level languages with unfulfilled promises, but I guess it applies to C++ too.
It's you who talking out of an ass. You can't distinguish between the difference of the specification of a language and the implementation of a language. Everyone knows exactly what the definition of "is" is in Python: it compares objects. Integer caching is cPython is an implementation that results in the artifact exposed by the blogger. Namely, c=200 d=200 c is d returns True Python does not specify this. It is a result of an implementation of the language (FYI, unlike Perl 5, Python does not get defined by an implementation). And this fact is undesirable. It is undesirable because first c and d are conceptually different objects and second for value greater than 256 they return a different answer (false), which causes further confusion. 
&gt; And this fact is undesirable. I like that fact, because it makes my program faster, and the keyword `is` in Python code is quite rare. The manual says clearly that you can't depend on the value of `2 is 2`.
Truthiness is pythonic when what you want is truthiness. But it's not always (though it usually is) the case, and when you want truth rather than truthiness, `is True` does the job much more readably than `== True`
I'd guess that in a lot of CL implementations, the stack has pointers to heap-allocated bignums, but fixnums are placed directly on the stack. `EQ` compares pointers, or fixnums if they're stored in that place instead.
FTA: in the current version of CPython, yes, but not according to the specification.
&gt;I like that fact, because it makes my program faster, and the keyword is in Python code is quite rare. That is a reasonable argument, but you can't deny it's a gotcha.
so what's bizarre about this? i don't get it. 
&gt; a == None also works. Usually, but consider: class Dumb(object): def __eq__(self,other): return other == None &gt;&gt;&gt; d = Dumb() &gt;&gt;&gt; d == None True &gt;&gt;&gt; d is None False This is contrived, but you can imagine something similar actually occurring. (Say, if `__eq__` made a comparison with some attribute that got unexpectedly set to `None`.) If you you want to be absolutely sure that something is `None`, you should ask if it `is None`.
The spec doesn't disallow this behavior AND not creating a new memory object to represent ever integer less than 256 is a simple optimization that doesn't break the spec. Its worth noting that C python does the same thing for some simple string objects as well.
I didn't believe I'd ever say this about PyPy, but well done!
If PyPy progresses enough to become completely compatible and faster than CPython, do you think it could replace CPython as the "official" Python implementation?
Maybe it'll become CPyPython, best of both worlds?
You should never write `if x == True`. Just write `if x`. Similarly, not `if x == False` but `if not x`. That's basic PEP-8 stuff. I can't think of any reason why you would want to test for `is True` off the top of my head. It wouldn't really make sense unless you had variable that might contain a normal object or it might contain a bool object and you were interested to know which. But why would you have a variable that flexible? 
CPython will always be, and probably should be the official reference implementation.
PyPy's aim is not to be faster than CPython. That's only a side-effect. After reading up on Psycho (I wondered why development stopped), I found and read up on PyPy. PyPy is trying to implement a general way to implement compilers for new languages - but in a high level way. You make a description of your language in high level Python, and the PyPy backend can turn that description into ... anything else. C. LOLCODE. Automagically.
It's so difficult to promote something like this.
CSquirrelfishPyUnladenPsychoSwallowThon
Late reply here, but may I ask what midi bindings you use? I'm writing an evolutionary-algorithm music generator and trying to get real-time midi output, which is tricky so far. What music theory package is it? 
Why not? Looks like a great project to me...
I use [pyFluidSynth](http://code.google.com/p/pyfluidsynth/) which is included in the music package as well (see [mingus](http://code.google.com/p/mingus/) for the project).
PyPy does not aim to support CPython's C API, so it won't be compatible with extensions. They do support ctypes, so you could implement a lot of stuff, but not PIL (for example). Also, I have not seen a python language test suite they can pass to claim compatibility. Currently compatibility is measured in "can you run django?".
Once it actually is faster and robust, I'll switch.
Although the project is a general interpreter compiler toolchain the *main* motivation of the developers is to provide a more flexible, fully compatible and *faster* implementation of Python.
They run the whole Python test suite. Other than a few tests which test implementation details (e.g. reference counting) they have a remarkable level of compatibility.
It's unlikely to become the "official" implementation because the Python core developers, responsible for maintaining and evolving the language, are not familiar with the codebase.
Is this work in progress? Debugging paragraph basically tells you that you can 1) add breakpoint, 2) run debug. Great. I didn't expect that at all. How about more useful stuff?
It's worth noting that `id(a) == id(b)` isn't a perfect replacement to `a is b`. If a and b are expressions returning a transient object, it could be created and destroyed before evaluating the rest of the statement. For example: &gt;&gt;&gt; [] is [] False &gt;&gt;&gt; id([]) == id([]) True &gt;&gt;&gt; id([]), id([]) (21066496, 21066496) However is guarantees that both objects are alive at the point of comparison, so `[] is []` is always false.
Undefined behaviour allows optimisation. Making things too tightly specified ties you to irrelevant implementation details, preventing more efficient methods being used (like caching integers in this case). Another case of undefined behaviour is deterministic finalisation. Python doesn't guarantee it, even though the CPython implementation happens to provide it due to its refcounting semantics because it prohibits more advanced garbage collection approaches. For another example, consider the order the keys of a dictionary are iterated over. This is completely undefined behaviour, but specifying it would either require using a tree instead of a dictionary, keeping a seperate list of ordered keys, or else sorting the dict before iterating, all adding significant performance cost to deal with something completely irrelevant. If anyone *needs* that, they should not be using a normal dictionary. In any case, "is" is acting completely predictably and as specified - it returns True when objects have the same identity. The thing that isn't specified is whether identical immutable objects can share the same memory representation, which is a pointless thing to overspecify since there should be no reason it should ever be relevant to anyone other than performance. 
&gt;encourage people to write id(a) == id(b) instead. That could lead to more confusion. A puzzle for you: &gt;&gt;&gt; class C(object): ... def foo(self): pass &gt;&gt;&gt; c=C() &gt;&gt;&gt; id(c.foo) == id(c.foo) True and yet: &gt;&gt;&gt; c.foo is c.foo False 
Holy mother fuck of fuck, I remember when this project was announced and when the project was bootstrapped but only ran at one hundredth the speed of CPython. Holy fuck. EPIC, EPIC WIN. Now all that's left to see is if this thing doesn't have a GIL or unladen-swallow's ideas can be merged into this, and that's right, baby, a rocket snake!
You forgot V8 and Monkey.
it is a great project, they just haven't done shit for 6 years except waste time working on a million things at once instead of concentrating on the important stuff
Ah, that's a pity...
It would have to have some very compelling advantages for the core Python developers to jump over to a new codebase -- especially given they would probably have to keep the CPython codebase in maintenance mode for some years in parallel. If PyPy were generally no slower than, and fully compatible with CPython, Jython and IronPython, then the fact that all three could be built from a joint codebase would be useful, especially if RPython turns out to be strikingly better for implementing new language features in. The fact that CPython has Google backing it (via the UnladenSwallow fork), and IronPython has Microsoft committed to it raises the bar even higher.
I saw the Wing guys at PyCon, and though I'm not a Mac user, they brought up that there are some recent fixes to this problem... Perhaps more on the Apple end of things than their end. I have a colleague who is so mac that he even has mac keyboards and screens and routers, and even he likes Wing (given the proper tweaks). Anyway, wing on linux is great. ++1
I have tried some but not all of the options, and am now running Linux on Wing. I would say one thing: don't get too worried about "free" (as in beer). If you're going to ultimately make any money with python, it's ok to invest a bit on excellent software. I'm not making the point that the non-free options are inherently better, of course, just that don't get hung up on it. If you're going to be a programmer, spend $200 or whatever it is to get the very best tools available to you. Not going to address the "Free" (as in speech) issue here, as I believe that both the Wing and Komodo folks are as open and cooperative as can be expected given their business model. I use WingIDE. On Linux. Wing is one of only two pieces of software that I have to pay for, and I'm enthusiastic about doing so. Wing has incredibly generous upgrade terms (I bought it once like 7 years ago, have used it on 2 different OS's, lots of computers, and have upgraded *many* times. I feel *guilty* at how little money I have given the Wing guys. The Wing guys are also very nice, and a generous sponsor to Pycon... everyone who attended sprints got a free license! Komodo was nice last time I saw it, too, but I prefer Wing. I think that the Komodo guys also make "ActivePython" which includes a quick, decent IDE for Windows. I know that the text-editor afficionados prefer emacs and vim to the built-ins, and I do respect that point of view. When I need to do some serious text editing, I move to vim and go back to Wing when I'm done. I know that my text-editing would be better if I used one of these classic methods. It's just that Wing's ability to understand, parse, lookup, and find your code is extremely helpful. Just an example: if you ctrl-click on a variable, wing will find where that variable is declared *no matter where -- in any file on your python installation* and show it to you. This includes built-in types, functions, and libraries. Also, as you type, you can configure a tool to show the embedded documentation and function signature to you, so you don't have to go look it up. These two things alone save me like 1 minute every 5 minutes. It's like having a digital reference book open on another monitor that follows along with your work. The debugger is very nice, too. Sure, python has an integrated debugger, but it's easier to traverse the stack, set watches, watch variables change in a multi-framed graphical debugger. Try wing!
Call me daft, but I don't see how this works. So you can interpret python in python. I get why that is cool... ... but what is "running" the outside python (the interpreter)? How do you "execute" python without a compiled interpreter?
They also have RPython, a restricted subset of implicitly statically typed Python, which the core of their interpreter is written in and they can translate RPython into C, as well as into JVM bytecode, CLI bytecode, and probably some other stuff.
PyPy has also received support from Google, they were also EU funded for like 2 years.
I like nose: http://somethingaboutorange.com/mrl/projects/nose/0.11.1/ It comes with a plugin to give code coverage too: http://somethingaboutorange.com/mrl/projects/nose/0.11.1/man.html#cmdoption--with-coverage
One interesting approach taken by Repoze developers is: If the feature is not documented, then it is broken. So, you will find pretty good documentations for all the libraries that they have created so far.
Repoze.bfg is characterized by some it's goals: 1. Everything is reusable/pluggable via WSGI (which is also the goal shared by the parent project - repoze) and play well with other frameworks. In short, create libraries, not another "framework" 2. Make the goodness of zope like component architecture, object traversal, ojbect database without the zope2 baggage. 3. Pay for what you eat. You don't have to use the whole framework, if you don't have to. 
Isn't this totally backwards? Why wouldn't you write the main fraimwork in python, using c++ calls when necessary?
For coverage info, there's always [coverage.py](http://nedbatchelder.com/code/coverage/)
I assume you're going off the headline. He never said otherwise. I think it should have been titled 'Performance cost of calling an attribute lookup repeatedly instead of calling it once and saving the result' or something.
This is obvious. I think it would be to anyone familiar with the Python C API (as opposed to boost.python). Edit: actually I'll go further and say that it's obvious even if you only know boost.python.
+1 it's not too hard to wire the two together to report on coverage as well as tests results. That's what we're doing in my group.
&gt; You forgot V8 and Monkey. Is tomato juice the only thing you can eat while your face transplant is healing?
How would I know?
PyPy can compile itself to C ... which can be compiled to executable machine code. But PyPy is such a *high level project* that it is verboten to tell someone this even if this is the first thing that someone would want to know. &lt;Michael Caine Voice&gt; Not a lot of people know that. &lt;/Michael Caine Voice&gt; Here is how to compile PyPy: &gt; cd pypy/translator/goal &gt; python translate.py --opt=3 targetpypystandalone.py *... wait forever ... * &gt; $ ./pypy-c Python 2.5.2 (64177, Apr 16 2009, 16:33:13) &gt; [PyPy 1.1.0] on linux2 &gt; Type "help", "copyright", "credits" or "license" for more information. Yay, I guess. 
err. So, the compiled-into-c (which compiles presumably into kernel-executable code) runs python faster than cpython, which is compiled from c into executable code? Whoosh. &lt;duck /&gt;
Because of the magic of JIT compilation. [throws other shoe]
+1 for nose, very pleasant to work with.
This is already obvious if you just know C++
Hell yes. Rocket Snake.
Thank you, I thought that nose was only about testing mock objects (I'm not sure if that's the terminology), but since I've heard a lot about it, I will look into it, after your suggestion, thank you.
Ah, thanks for that, the HTML output looks great!
Darn, I was thinking about doing this exact same thing. Didn't have the time though :( Ah well, let's test this thing out.
They have a hosted test server, i cant really get it to function quite properly or even write into the wave input box though. There are alot of widgets and such though. Looks fun thus far
I would like to understand why this link was #1 on my reddit homepage with the following stats: 0 votes submitted 1 hour ago Edit: Also, discussing python web frameworks on a page written with ASP.NET send up a red flag in me.
&gt; Also, discussing python web frameworks on a page written with ASP.NET send up a red flag in me. Most good URL routing systems can do that even if the page isn't ASP (or PHP, or ColdFusion, etc.). And every year I think about setting some hated extension on the end of my URLs as an April Fool's prank...
py.test gave me some epic win things none else has 
Woah. That's confusing. Why isn't `c.foo` the same as itself? Is it creating a new bound method every time you access it? But if it was doing that, wouldn't the new method have a different location in memory than the old one? I don't get this.
Have a look at [Robot Framework](http://code.google.com/p/robotframework/)
Noone speaks of c titus brown? http://ivory.idyll.org/
Komodo is pretty good, but if you want a free and open source editor .. try Komodo Edit: http://www.activestate.com/komodo_edit/ 
&gt;Is it creating a new bound method every time you access it? Yes, this is what's happening. The subtlety of the ids being identical is because ids are only unique for objects alive at the same time. What's actually happening is the equivalent of: temp1 = c.foo # Create a new bound method with id X temp1_id = id(temp1) # temp1_id = X (returnvalue from id) del temp1 # bound method doesn't get assigned, so refcount drops to 0 # as soon as id() releases its reference - temp1 gets freed temp2 = c.foo # Create a NEW bound method. temp2_id = id(temp2) del temp2 temp1_id == temp2_id # Actually do the comparison, both objects are already dead Which should explain why its *possible* that the second bound method *could* have the same id. The reason it usually *does* is because of the way python manages memory. To avoid fragmentation, pools of similarly sized memory objects are maintained. When an object is released, it is returned to this pool, then when a request to allocate an object of this type arrives, python sees it has an block of memory of the appropriate size sitting in its free object pool, and returns it. `is` doesn't have this problem because the call to is takes a reference to both objects, ensuring they are alive at the time of the comparison. 
I think you can. A gotcha is something that will catch you out, but here there's no **reason** here to be comparing integers by id. No-one ever does so, and if they do, it's an outright bug. Is this page showing someone writing some code and being caught out by it? No - they've written some examples noticed by either noodling at the interpreter, or more likely by knowing in advance how object interning is done and showing some implications. Nowhere is anyone being "gotcha'd". This is no different to someone complaining that the order of dictionary keys is different from sorted. Looking soley at dict((i,i) for i in range(100)) they might mistakenly come to that conclusion, but it's still not a gotcha, just an unfounded assumption based on not reading the docs. It's missing the requirement that this might be something a reasonably informed person would be expected to *do*.
For those still reading this: using MNML suggested by tehmatticus in the comments and using current mod_wsgi trunk, I was able to port the project in question to Python 3. Load-Testing with ab against apache 2.2 / mod_wsgi 3.0 trunk proved the application to be stable and in the process, we also gained 200rps with p3/mnml/mod_wsgi3 compared to p2.6/werkzeug/mod_wsgi2 (from 700rps to 900rps). In the process, I have ported MNML (source [here](http://github.com/pilif/mnml/tree/master)) and the pure python memcache client (source [here](http://github.com/pilif/python-3-memcache/tree/master)). Both ports are still quite rough around the edges, but, as I said, they work, even under moderately high-load conditions using apache and mod_wsgi. Also, I wanted to thank the reddit crowd for their wisdom and especially tehmatticus for his/her recommendation of MNML which made this possible in the first place. I'm ever so happy that we can now use Python 3.0 which means that we are today at the very comfortable place of having code that, in 10 years, will still use the latest family of python available (assuming that 3 lives around as long as 2 did) Thank you all.
+1 for Wing. I use it on both Windows and the Mac.
Yup. It isn't just a case of maintaining the PyPy source (written in RPython - and RPython itself is poorly specified and the PyPy guys say that although it is a subset of Python it isn't a fun language to use) - but it would also mean maintaining the whole compiler toolchain and the JIT (including the assembler backends) that make-up PyPy. I *still* have high hopes for PyPy, and if they can remove the GIL and get faster performance than CPython it might well become very widely used. I doubt it will take over as the reference implementation in the near future. As others have said - the chances are much higher of unladen swallow being merged back into Python trunk. It does have the difficulties of being in C++ (currently no C++ in the python codebase) and poor Windows support in the LLVM.
PyPy currently has a GIL (just because it made implementation a bit easier) but they think it shouldn't be too hard to remove. Unladen swallow is a very different project and there is little that can be brought into PyPy from it. On the other hand there are already some optimisations in PyPy (method caching for example) which have been brought into the core CPython project.
Ah, Unladen Swallow's being in C++ not C had escaped me. Though making a faster Python in C++ than in C would be a good advertisement for C++.
I don't think Python is concerned with advertising C++... Also there are compiler and ABI concerns with C++ for some of the platforms that Python supports - I don't know the details though.
WSGI more of an interface standard rather than a web framework.
wsgi is more like isapi not asp.net.. apples and oranges man.
As others have said, WSGI is merely a specification for how servers should talk to applications--regardless of how the applications are written. If you want sessions for a WSGI-conforming application, you should check out [Beaker](http://beaker.groovie.org/), which is a layer between your application and the server (middleware) that adds sessions and caching.
What is wxPython? I've been wanting to learn Python as a hobby but I get confused about all these variants. 
wxPython is a library that helps program GUI's ie Windows and buttons. It's just an import for whatever python you are using. Python itself doesn't specify how you do gui's. Best idea is to learn python then go learn a gui library. There are other options for adding gui's eg. tkinter, PyQt, but wx is a good option. 
You're not 100% sure that you can get all the classes from wxPython on every platforms. What you can do is try to look for the documentation of the TextCtrl C++ class on the wxWidgets pages, and see if there's a note about Linux.
I like wxPython, a lot, but I would not advise anyone without expertise in GUI programming to attempt it. Just visit [the api reference](http://www.wxpython.org/docs/api/) and do a search for "Proxy of C++". Each one of those is an undocumented class. That said, it is incredibly powerful and when you figure out how to use the undocument and under-documented classes you can make some very professional looking Python apps.
...each one of those is a class which is documented in the wxWidgets docs. Yes, it should be integrated, but seems they're working on a way to automate the docs generation.
The WxWidgets documentation does not always make sense if you hardly ever touched C++ in your programming career.
I've been working on a Twitter library for Python in my spare time. It's the first library I've written in full for the language, so I'm sure there's quite a few things that could be improved, but I think I've gotten it to a point where I can throw it out there and see if anyone's interested in it. It covers the REST API and the Search API at the moment. I'm working on OAuth support, and I haven't had time to look at the Streaming API stuff in-depth yet, but I'd like to hit that at some point as well. There's still a lot of other small pieces that I want to add which would respect the API more, but it's usable in its current state. There's an experimental build for Python 3k as well, if anyone's into that sort of thing. I wouldn't consider either of these fully production-ready yet, but feel free to use it however you want. I'd really appreciate it if anyone could check it out at the following link and critique it. It's somewhat inspired by Python-Twitter (http://code.google.com/p/ python-twitter/), but I'd say it's a little more simplistic overall. It requires people to be familiar with the Twitter API itself, so you can't just blindly use the library. I consider this a good thing, but some others might not. ;) (Oh, for the inevitable "Do we really need another Twitter library" comments: I found it a fun project to practice Python on. Sue me. :D)
Skipping through the source, the first thing I would suggest is reading http://www.python.org/dev/peps/pep-0008/ 
Nice approach... I just wonder how big the py2exe-Version is. What about performance and startup times?
You could abstract out a lot of the repeated 'are we authenticated' checks in a decorator. (Also, avoid comparing to True. Instead of 'if x is True', use 'if x'.) 
I've enjoyed working with wxPython. The easiest way I found to get in to it (with decent Python experience) was with an app called FarPy. FarPy is a simple GUI WYSIWYG editor that can then export the design to wxPython code. Generally, I just create a mock-up of the GUI, export it and then do the fine-tuning "by hand". The design process is slightly like that of VB.NET, without the portion where you would normally write event code.
Expanding on this: - ``if kwargs.has_key("questionMarkUsed")`` -&gt; ``if "questionMarkUsed" in kwargs`` - constructApiURL could be much shorter. I.E: ``"?" + "&amp;".join(["%s=%s" %(key, value) for (key, value) in params.iteritems()])`` - Unnecessary ``pass`` on line 162 - Using ``id`` as a variable name is generally frowned upon, as it is used to get the unique memory address of an object. There isn't anything wholly wrong so far. Just some room for improvement.
&gt; That's my problem with the WSGI. So... your problem with "the WSGI" (is that more like the google or the intarwebs?) is that it *isn't* a fucking web framework in the first place? WSGI means Web Server Gateway *Interface*. From the "What Is WSGI" page, it's the following: &gt; It is a specification for web servers and application servers to communicate with web applications (though it can also be used for more than that) See "web framework" here? I don't think so. That's because it's not one. It's the specification for an interface between webservers and web applications (whether those are built upon a framework or not).
You could always build it yourself or if you're pressed for time use easy_install. The only Python packages I get from apt are numpy or pygraphviz, and that's only because of weird build issues
Also, it's much better to let exceptions propagate up than to catch them and print an error. If you want to catch them and reraise something more closely related to your library, that might be reasonable, but you should definitely propagate them rather than swallowing them. 
Twisted.cred, it's a bit overkill but it's robust and easy to reuse in multiple projects.
Django &amp; Django's Auth contrib app.
In that same vein: [Code Like a Pythonista][1]. [1]: http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html
Intriguing, but needs more documentation. What are the prerequisites? What about security? How do you keep anyone else from running your app?
I wrote my own, which uses our DB server login. I don't recommend this for general use, but since my component is behind our firewall on my computer, and I only start it when I (or someone I trust) needs data, so it is good enough. Don't overlook simple when something else ensures only people with some level of trust are the only ones who will access your component.
repoze.who and what seems to be the best mix of ease of use for the majority of use cases, and flexibility for those weird ones. tg2 uses it, but it's easily incorporated into pylons which is just a thin layer over wsgi. That should work for you.
Roll your own.
Haha, yeah, I wasn't sure if some of the stuff I was doing would be acceptable in that vein, but I went with it to get it rolling. I'll definitely check that out!
Ah, these are awesome! Thanks for taking the time to look through it, I'll make some revisions later tonight.
Your best bet is going to be to search/ask a win32 forum on how to implement this functionality. People there will be much better versed in the win32 API. Then translate it into something usable with win32api. Also, py2exe *should* have no baring on this task as it is only a packaging mechinism (which I of course say knowing how finicky py2exe is whenever you trying to do anything other then "Hello World").
please update if you figure this out. I'm interested as well
http://www.reddit.com/r/programming/comments/224se/ask_reddit_why_is_tk_still_the_standard_gui/c225pf
It's not de facto? So what is it, imaginary?
django-openid-auth If you aren't using openid, no one will sign up for your site soon.
It'll be de facto when there will no longer be a market for programmers who know Java, Perl, C, C++, etc.
Are you familiar with the definition of "de facto"?
Yea because 90% of the market is a real point of decline. Get real people. Windows 7 and even Vista are growing much faster than Linux or Mac. http://www.w3schools.com/browsers/browsers_os.asp In last 5 months Windows 7 is up .9% and Vista is up 1.9% Linux is up .2% and Mac is up .3% That is so far from a decline it's insulting. I don't find disinformation a valid form of marketing. 
From that table, WinXP is down 2.6%, win2000 is down 0.5%, and win2003 is up 0.1%. That's a net drop for Windows of 0.2%. That looks an awful lot like a decline to me.
write your own. edit: also this is a dupe. http://www.reddit.com/r/Python/comments/8irn0/new_to_pylons_do_i_use_authkitrepozewho_or_do_my/c09exwt
I haven't used bilsbrowser, but I did write a small PyQt app using a similar set of components (embedded QtWebKit etc.). It's always possible I did something so stupid that my experience is irrelevant, but I would guess: * With the best compression py2exe offers it's unlikely to get down to less than 10MB. * Uncompressed it'll easily be 20-25MB -- 15MB for Qt Core/UI DLLs and the Python bindings, 5MB for WebKit, another 5MB for Python and your libraries. * It'll be quite slow to start up, but compare favourably to apps which have to load Java, .NET, XULRunner etc. Performs snappily once it's up. 
"Roll your own" is the advice on two threads here. Isn't that just a little bit worrying?
"unless you are paid to do it, why would anyone want to get intimate with Windows?" LOL! 
GP is arguing it's not *real* decline. Not that statistics can't be used creatively. Besides, the decline of Windows will not be very quick on the big picture, as it involves large organizations switching over. Large organizations are slow and careful more often than not. They'll change eventually, especially when others of their size and style have successes at something. I'd look at computer markets that involve the workforce of tomorrow and personal choice of hardware setups. I've seen some points of higher education sporting as much as 60% market on Macs. Higher ed is quantitatively pretty small and won't dent Windows at large, but I do not believe anyone can question the implications for the future.
I've read a book about Windows programming that sucks, therefore Windows sucks.
Sorry, I'm a bit late, but hopefully someone gets to read it. As FelixGommen said, Eclipse with Pydev is certainly not a bad choice for beginners. I would still like to point out (even if it is done so in every such thread) that it's really worth it to learn Emacs or Vim. A tip on learning how to use them: I tried starting using emacs two or three times (going through the turial etc.) but gave up every time because of the key combination hell hole I could not make sense of. What I want to say is: fuck all tutorials, just start using it exclusively and look up things as you need them. I guess the same holds for vim. Useful things for Emacs with Python: * python-mode * autocompletion-mode (useful for everything, not just Python). * pycomplete. 
I once was given homework by the information theory lecture to implement such a random text generator (k-th order markov chain, k configurable). As I just started with python I thought it would be fun to do that in a one liner. It happened, though it was a really long line and a total lambda mess.
You could have a much easier life by using a better suited tool :)
Is there a GUI kit that uses HTML to specify interfaces? That should be interesting, if it's responsive...
&gt;This then, was the big eye-opener for me: that despite all the hype, Windows UI programming is as tedious today as it was in 1995. Sure, the new UI looks a lot better. But that's mostly glitz: 3D effects, color gradients, video, and so on. Sure, it's all object-oriented now. But it hasn't really gotten any less complex to create the simplest of simple UIs. Anyone developing client side applications should look at Qt. It's by far the most pleasant toolkit I've ever had the pleasure of using with C++, and there are nice Python bindings for it too.
Seconding. If you use Beaker, which takes away all that messy sessions and caching stuff, authentication becomes checking a dictionary and authorization becomes writing a few decorators. I guess it's a hassle for really complicated policies, but I've never seen a library scale on policy complexity than your own code. (Disclaimer: then again, I have not used every auth/auth library.)
My god, who can keep up with the embarrassment of riches these days? CS today is nothing like it was say, 20 years ago. 
Hey. You and [MSDN](http://www.reddit.com/user/msdn) should exchange phone numbers.
So when will nltk be part of ubuntu?
Cool. Some actual examples would have been nice, but they're in the [linked page](http://www.hedgerwow.com/360/dhtml/css-round-button/demo.php).
I used a custom-rolled toolkit. I used to use AuthKit w/ Pylons. However, AuthKit fails for a couple of reasons: Mainly, it's incredibly over-engineered, with nested subclasses that explicit inherit from classes in other toolkits which it's basically replacing... makes things slightly a mess. Add to all that the fact that it lacks any sort of beaker/session integration, and it's sqlalchemy integration is arranged strangely, I finally had to abandon it for a custom rolled library which I derived from AuthKit. Sad thing is, there aren't any good auth components which actually play nice with each other in a flexible way... you either use them to provide complete vertical security (which is a PITA if you want to deviate in your app), or you end up rolling your own. In my custom rolled library, I've been trying to architect it so that it divides into separate wsgi apps that play nice on the stack, and allow my different apps to easily subclass / ignore the parts they don't need. I should probably clean it up and release it or something :) Until we get a good division of labor for what the various bits of auth middleware should contribute, it's probably going to be "roll your own".
But, that book does not suck. It has excellent examples, it explains what it's going over, and lists the code you need to do it.
The best way to this is to use python's cairo library bindings and use vector graphics to draw the button, gradient and apply text. You can easily hook this up to a web interface and generate buttons with various color schemes, rounded edges, text etc without involving a lot of other programs. it's called [pycairo](http://cairographics.org/samples/)
How so? Cyc, naive bayes, hidden Markov, support vector machines and WordNet were around 20 years ago.
Howdy all; I'm the post author. Just to clear up a couple of things: 1. First, I'm using "gotcha" in this article to mean, "something which one might expect would work a certain, consistent way, but which doesn't." Here, I believe it's reasonable to say the inconsistent results of `is` are genuinely surprising if you don't know why it's being done. The question the article tries to answer is: _why are two integers with equal values the same object in some cases, but not others?_ 2. I think most people are aware of the difference between `==` (value equality) and `is` (reference equality), but that's not the gotcha. The gotcha is the apparent inconsistency. It's a perfectly reasonable (and probably very effective) implementation decision. Other languages do the same thing; for example, Java caches its `Integers` when their boxed value is between -128 and 127. Thanks for reading; took me a bit to figure out why I was getting a visitor spike. ♥ Reddit!
Why in the world was it necessary to do start, end = start, end = (192, 192, 224), (255, 255, 255) instead of start, end = (192, 192, 224), (255, 255, 255)
How can Python motivate third-party module maintaiers to port to 3.1? Start to refer to 2.X-only stuff as "legacy?" Offer to have Guido do their voicemail greeting? I want to move to version 3, but it isn't an option without all the database drivers and whatnot that I need.
I guess I'm a bit confused. You seem to be assuming that, since not every piece of Python software ported overnight, that means none of them ever will. Which, frankly, is idiotic given how many times the topic's been covered; at this point everybody who's paying attention knows that the 3.x migration process is expected to take a year or two for most large projects (which have things like commitments to existing installs to take into account as they work on dropping support for older Python versions).
Are there any improvements from unladen-swallow included in this release? I remember reading something about a pickle improvement getting merged, is that all?
Wow. One can't even discuss programming languages on reddit without some troll busting in and using words like "idiotic." Be civil or leave. Please.
I daresay that O'Reilly is on its way back. This looks like a beautiful, interesting, well-made book. I like the last two paragraphs: &gt; Linguists are sometimes asked how many languages they speak, and have to explain that this field actually concerns the study of abstract structures that are shared by languages, a study which is more profound and elusive than learning to speak as many languages as possible. Similarly, computer scientists are sometimes asked how many programming languages they know, and have to explain that computer science actually concerns the study of data structures and algorithms that can be implemented in any programming language, a study which is more profound and elusive than striving for fluency in as many programming languages as possible. &gt; This book has covered many topics in the field of Natural Language Processing. Most of the examples have used Python and English. However, it would be unfortunate if readers concluded that NLP is about how to write Python programs to manipulate English text, or more broadly, about how to write programs (in any programming language) to manipulate text (in any natural language). Our selection of Python and English was expedient, nothing more. Even our focus on programming itself was only a means to an end: as a way to understand data structures and algorithms for representing and manipulating collections of linguistically annotated text, as a way to build new language technologies to better serve the needs of the information society, and ultimately as a pathway into deeper understanding of the vast riches of human language.
You've had all kinds of time in which to find out how the migration process is meant to work, and either remain ignorant of it or haven't understood it. At this point I don't see any excuse for either, and asking how to get existing projects to drop well-known, well-planned migration processes and port immediately shows not just lack of knowledge/understanding, but lack of judgment. So I stand by my comment. Do your homework and use your brain before opening your mouth, or leave. Please.
I saw that, was just wondering which were from unladen-swallow.
Hm... I tried Python 3 a few months ago, after it had been out for quite a while, and many things I needed just weren't there for it yet. Clearly this is a serious drawback that should be corrected. So, as this is the python subreddit (one of dozens I subscribe to) and not the core python developer's mailing list, your nasty demand that I do considerable research before commenting on my experience is WAY out of line. So again. Be civil. Be polite. You aren't the boss of reddit. Stop trolling or fuck off.
So... you didn't read anything at all about planned migration processes, which would have told you up-front that Python 3.x probably wasn't going to have lots of the libraries you wanted yet, and then discovered that fact independently and decided it was a problem with the release? And expecting you to take even a basic, five-minute glance at Python's dev process or the migration plan of a library you'd like to use counts as demanding "considerable research"? In all seriousness: when did we decide that willful ignorance was acceptable, or that asking people to read even a simple FAQ document up-front was just too damned much?
This is funny. Let me be clear: I would much prefer to be ignorant and idiotic (and whatever other insult you come up with) than to be such a nasty, angry, raging internet tough-guy like yourself. Enjoy the lonely life your horrible personality brings. I'm done with you. Continue to troll if you like, you are now ignored. Thanks for popping by to spew insults. You are a true asset to reddit.
&gt; Clearly this is a serious drawback that should be corrected. It will be, in time. Currently, supporting 2.4/2.5 is more important than 3.x for most people. There is no good way to support 2.4/2.5 and 3.x concurrently. So you aren't waiting on the developers to port to 3.x so much as you are waiting on 2.4/2.5 usage to drop (RHEL / Centos currently ship 2.4!). It is going to be awhile (if I had to guess, it'll be 1-2 years before a good portion of libraries support 3.x).
&gt; There is no good way to support 2.4/2.5 and 3.x concurrently. "no way in hell" is a bit extreme. It's possible, but a significant cost especially for medium-to-big projects.
Wait for it. I know it's hard, but it'll take time. PyQt is already ported... ditto for lxml... PLY-3.0... They are working on porting numpy first to 2.6... On the other hand, sadly, there's no plans to port PyOpenGL to python 3 currently..
No, you're an ass. Ubernostrum posts good stuff here all the time. Then you came in and asked a trollish question and got unreasonably offended when ubernostrum made the obvious point that (duh) the transition to Python 3 will take several years. No article about Python 3 that I've read has ever failed to mention the expectation of a several year transition period, so you're question was kind of baffling. I guess ubernostrum shouldn't have used quite as strong language as he did, but the demand that he "be civil or leave" was a bullying comment cloaked in a mantle of false demand for etiquette. If anyone's the "internet tough guy," it's you through the jujitsu of taking easy offense.
If you just want to experience with Python 3 without installing anything or messing your existing python installation, have a look over here: http://www.portablepython.com/
You can also use sandboxie to run it in a sandbox, works pretty well for me...
&gt; Hm... I tried Python 3 a few months ago Well there's your problem, there's a reason why the python irc channel topic starts with "It's too early to use python 3.x", you're not supposed to use it yet, the release right now is for people to mess with and so that library creators can go ahead porting stuff. You're not _supposed_ to be using it yet, that's how the migration progress was planned, that's how it's currently working, and that's how it will work until everything is ported. (By the way, ubernostrum wasn't trolling, you're overreacting to a single word. If you think that's trolling you haven't seen anything yet. I agree that his post was a bit harsh, but not a troll by far.)
Large organisations mean that there will be a lot of 'inertia' stopping the switch, and like you say it'll take some [large](http://arstechnica.com/open-source/news/2009/03/french-police-saves-millions-of-euros-by-adopting-ubuntu.ars) [scale](http://news.slashdot.org/story/09/06/28/0344234/The-State-of-Munichs-Ongoing-Linux-Migration) successes to persuade them that switching is a good idea. But if that happens, the decline may be fast, not slow, due to the size of these organisations. The education example is a market where money is often tighter than business, this can help with the decision to switch from Windows to cheaper alternatives (TCO arguments don't work as well here). Increased familiarity with the alternatives will certainly make more people comfortable using them after school/uni. I wasn't putting that much faith in the stats garnered from one site, just pointing out they were being misleadingly used by GGP.
&gt; That would be why I said "no good way" not "no way in hell". Uhm. You did. And I quoted it. Yet I read "no way in hell"... I can only ask for your forgiveness, I truly seem to have gone funny in the head.
I believe the 2.7 release will be the end of the 2.x branch, and then their focus will be on the 3.x branch exclusively (except for any bug fixes, etc.).
In [1]: x = 'cake' In [2]: cake = 'something' In [3]: eval(x) Out[3]: 'something' 
I think a dict might suit here. Instead of using a bunch of variables you could just update the values in the table directly. mydict = {} mydict["cake"] = "good" var = raw_input("Enter something: ") if mydict.has_key(var): print mydict[var] The library reference for dicts is [here](http://www.python.org/doc/2.5.2/lib/typesmapping.html)
Alternately, you can use the "dir" function to get a dict of variable names (strings) to their values. Try it on the interactive prompt to see the dictionary it returns. Why do you want to do this, anyway?
Another approach would be to just use a dictionary. So just stick the user input into a dictionary as a key, e.g.: d['cake'] = 'good' print d['cake']
It's only for Windows.
You want locals()["cake"]. But yes, use a dictionary if you don't absolutely need to do what you're doing...
Yes, I will second the use of dictionaries in this situation. They are a far safer approach than something like evaluating strings as variables.
FWIW the unladen swallow guys removed their vmgen implementation in favor of the CPython direct threading since it is more maintainable, although it costs 2-3% on benchmarks.
Validate their input with a regex, pad it with a special character, and make a hash table. Letting a user define or modify a variable named anything they want sounds like a security risk, though I guess that matters less if this is client side "newbie learning how to code."
This works, but it's a dangerous habit to get in to if you move away from writing local apps where you trust the user input to writing web or network applications. because eval() executes arbitrary code and is essentially giving the user a shell account with whatever permissions the python process has.
Donc do that. It's bad. That's what `dict` is for.
Don't use `mydict.has_key(var)`. It's deprecated. Use `var in mydict` instead.
`dir` is used to find the attributes of an object. &gt;&gt;&gt; class A: ... b = 1 ... &gt;&gt;&gt; dir(A) ['__doc__', '__module__', 'b'] What you're talking about is `vars()` or `locals()`. &gt;&gt;&gt; help(locals) Help on built-in function locals in module __builtin__: locals(...) locals() -&gt; dictionary Update and return a dictionary containing the current scope's local variables. &gt;&gt;&gt; help(vars) Help on built-in function vars in module __builtin__: vars(...) vars([object]) -&gt; dictionary Without arguments, equivalent to locals(). With an argument, equivalent to object.__dict__. 
If you don't have 64-bit Vista.
People have Vista?
Whoops, my bad. Haven't programmed in python for a while and should have read the library reference that I linked to a little more closely!
Agreed. There are lots of alternatives in Python (e.g. __getattr__), but restricting the user to looking up elements of a predefined dictionary is the safest approach. 
I've read in the past to use *try: mydict[var]* as it's much faster than *if mydict.has_key(var):*. Is that still the case with *var in mydict*?
It depends on if you expect it to usually hit or not. These days, it makes the most sense to just use a `defaultdict` if you already know what you want to happen when the key's not there.
ಠ_ಠ This look of disapproval is more directed towards those who downvoted morgan_goose than morgan_goose himself. eval is the new goto. Every time it's mentioned, everybody gets in an uproar and acts like the inquisition. Out of these people, most either wouldn't know when to actually use eval and thus want to ban it and pretend it never existed, or are just trying to get approval from the former. Truth is, eval has its uses, and has a lot of theoretical value. It'd be better to educate OP and this poster on why does this work and why it's not a good use case, not just mercilessly downvote the post into oblivion. This is not a good use for eval in Python since Python's unlispy syntax (and in this particular case, its lack of symbol handling) will make it troublesome to avoid evaluating unwanted expressions that could have unwanted side-effects or reveal unwanted information. Furthermore, this would give the user access to the whole variable scope, which is something OP probably doesn't want, which is why the locals() alternative won't be a great idea either. The possible values should clearly be stored in a separate dictionary.
Sure. First task, read http://diveintopython.org
I think he was looking for an import python statement for his brain
Second task, explain above joke to prove you've read the book. :P
Sure. First boot up in your favorite distro. I use Arch Linux, but this works in Ubuntu too. Start a terminal (for instance: alt-f2, then type in gnome-terminal). You will now be at "the commandline". Then, try typing in the following: python 2+2 print "hello" import math math.sqrt(9) Now you're using Python. For something with more feedback, start with editing a file (for instance, alt-f2, gedit myfirst.py) Type in the following: import turtle for x in range(90): turtle.forward(x) turtle.left(90 - x) Then save the file and type this on the commandline: python myfirst.py You should see a little turtle (black triangle) draw some sort of spiral. What does it do? The "for" keyword saves you from typing the two following lines 90 times, while x is just changing slightly for each iteration. Google the words, change the numbers, experiment! Now, the same little app, but with a few lines you should include as a habit: #!/usr/bin/python # -*- coding: utf-8 -*- import turtle def main(): for x in range(90): turtle.forward(x) turtle.left(90 - x) if __name__ == "__main__": main() After you've saved the file, make it executable: chmod +x myfirst.py And just run it: ./myfirst.py Search the web, read tutorials, read sourcecode, experiment and ask well-formed questions here, on IRC and on forums when you're stuck. Good luck and have fun! :)
Thanks SS. So, get started with installing linux pretty much then. Good times.
I recommend starting with IBM's [Discover Python](http://www.ibm.com/developerworks/views/opensource/libraryview.jsp?search_by=discover+python) series. It's nine articles that will get you up and hacking in no time. After that, read Dive Into Python.
Or start by installing python, then follow from his second sentece on. 
The article is saying Windows is in decline as development platform, not as an operating system. And that people are choosing web technologies over Window Forms for building UI's. And that this is because it is complex. Not sure about the precise situation on the ground in terms of "decline". I do thing building even simple GUI's is complex. http://www.indeed.com/jobtrends?q=winforms%2Cswing%2Cgwt%2Cjquery%2Cspring+mvc&amp;l= 
that's uncalled for
&gt; These days, it makes the most sense to just use a defaultdict if you already know what you want to happen when the key's not there. or `dict.get(key, default)`
Now, if you're willing to use a third-party repository http://cl.naist.jp/~eric-n/ubuntu-nlp/ We've been using it from there for awhile now. I don't know the maintainer personally, but have heard good things about him.
I'll let someone smarter talk for me: http://blog.thetonk.com/archives/dont-be-lazy-dont-use-eval#comment-8
I get asked this by colleagues all the time, so I wrote things down in my blog, that you might find useful... http://blog.sadphaeton.com/2009/01/13/python-uninitiated-developer.html And I assume you are using windows... http://blog.sadphaeton.com/2009/01/20/python-development-windows-part-1installing-python.html http://blog.sadphaeton.com/2009/01/20/python-development-windows-part-2-installing-easyinstallcould-be-easier.html 
Thats not really very useful. Yes it does in the simplest case do what the eval function would have, but with more effort, and more places for exceptions. You have to know before hand that you want to read that variable though, and thus loose the usefulness. You end up writing more boilerplate just to read a simple string/file than is necessary. This also ends up being no safer than the eval usage. Eval is not harmful, and its only fud to say so. Eval does what it's name suggests, it evaluates what an expression would do, it doesn't execute, and it does it in a local scope: http://docs.python.org/reference/executionmodel.html?highlight=eval#interaction-with-dynamic-features Making eval() out to be a little Napoleon that if let off elba would ravage your code and data is a much overblown notion. As this professor notes: http://blog.thetonk.com/archives/dont-be-lazy-dont-use-eval#comment-8 
It would have been a lot better if the author had checked for the error messages in each slide containing python code before uploading this
I strongly but respectfully disagree. How is it more effort to declare a dictionary? The o.p. stated that they wanted to be able to do a look up on an arbitrarily defined variable. The simplest and safest solution here is a dictionary. &gt;You have to know before hand that you want to read that variable though, and thus loose the usefulness. You end up writing more boilerplate just to read a simple string/file than is necessary. This also ends up being no safer than the eval usage. I'm not sure what you're trying to say here. There is very little boilerplate involved, it's a symbol look-up, just like the o.p. wanted. Eval is not _always_ harmful, but here it is a) unnecessary and b) you'd be allowing the user to execute arbitrary code. I'm not making it out to be a little Napoleon, eval can be quite useful, but it is not, in my opinion, a good solution here.
Also, resizing the browser window scales the text, while leaving part of the slide unreadable. Thanks guys.
I don't/didn't see where it stated that it needed to be able to loop over a dictionary? But if thats the case then the dictionary's iterator/keys function would be more useful. With a dictionary you do also run the risk of bad input with dicts that you wouldn't with eval, in that a dick key can be any valid string, which isn't the case for a variable. One example being: x['this is a variable?'] = "cake" Thats perfectly acceptable as a dict key, and as user input, but not as a variable name. My perspective on the question was that given a python program/module, how can I let a input value print the variable value it represents. So I took it be that the variable was already defined, and not as a dictionary, and eval() would be the only way to retrieve that variable's value. If the person asking the question, it also defining the variables, then yes the can rewrite the code to use a dictionary, but if they aren't then they'll have to have some way of getting all of variables into a dictionary to access them, which ironically enough is what the eval() documentation seems to suggest it does. Also eval() isn't exec(). For instance: x = "import os\nos.system('ls')" eval(x) -error exec(x) -works
Use-once has the benefit of being able to forget the backlog of returned things, which is ideal for long-lived generators and the expectation for most uses of generator. I would add something akin of `list()` that can wrap a generator so that it can be iterated from the beginning several times. Perhaps two: one that re-instantiates the given generator every time it is used (basically `lambda: g`), another that memoizes the already yielded values.
&gt; Remember, this is Python, so I am not constantly reminding myself about the type of something Then you're doing it wrong. Just because the language doesn't demand to know doesn't mean that you shouldn't know it.
Treating a generator like an iterator is like treating a float like an int. They *usually* work the same.... 
"I don't understand generators so I'll assume they're exactly the same as lists... Hey I found a bug in Python!" The "use-case" described is for that of a list, not a generator. If generators were modified to allow them to restart they would no longer fullfil one of it's existing use cases, iterating over data that doesn't fit in memory. 
Exactly. As well, generators can be used to give iterator like access to transitory or ephemeral data, such as real-world events (sensor readings, I/O streams, etc.) that would be impossible (or prohibitive) to start-over from the beginning. Gonna have to chalk this one up to "doing it wrong". P.S. You could "fix" his code in one line without backtracking through the codebase to find the "problem". Just add `node = list(node)` at the beginning of that function.
tl;dr: User desires drastic modification to Python's type system due to being bitten by his own under-documented code.
I'm writing that down for later :)
You could fix his code easier than that. Rather than having: sdnode = ''.join(node) in one place and then doing ''.join(node) in another place, you could simply use the previously created variable. This fix is FAR simpler than going back through his old code, performs less work, doesn't need to create a new list object. His code isn't actually required to go over the generator twice.
Well fine. Just be all more betterer and sh-t. Edit: actually you are even more righter. The `if` chain goes: `if snode` ... `elif snode` ... `else *no mention of snode*` -- for consistency &amp; clarity he should have used `snode` in the else clause. But then there wouldn't have been a problem and he wouldn't have been able to write a blog entry about it. 
Heh. Not trying to disagree with your main point. You're right, this is a case of "doing it wrong." I was just providing an alternate "right" :)
No, you're right. Your "right" is more right than my right. Right?
People here don't seem to be acquainted with C# generators. _"If generators were modified to allow them to restart they would no longer fullfil one of it's existing use cases, iterating over data that doesn't fit in memory."_ is a perfect example of narrowness of experience leading to narrowness of imagination. No, you don't have to convert generators to lazy lists. All that is needed is a distinction between `enumerable` and `enumerator`, with all functions like `map` and language primitives like `for x in ...` accepting enumerables, and it won't even surprise anyone ever. It's not about "restarting" the generator. (crossposted from [here](http://www.reddit.com/r/programming/comments/8wpvn/pythons_iterators_are_a_bad_implementation_of/c0aob2c)) EDIT: fixed markup
Yes, but you still need to know when you're giving a goose to something that expects a duck.
Anyone have a better introduction to the flex layouts here? I've never done Flex/Flash, but it seems like genetic programming + UI design could yield some interesting possibilities.
Yeah I found that too, but I was wondering what the deal is, is Debian / Ubuntu refusing to include it? They can just use his packages right? Or maybe some license problem? Anyway nltk is pretty awesome, but I haven't got around to using it yet. Does it have categorial grammar support? Or can you extend it easily to add specific formalisms? I read some of the documentation but it's a bit frustrating that they give really easy examples and then stop ...
Sure, but after you cook and eat that duck, do you still expect it to be a duck the next time you look at it?
You don't have to use Linux, but I do recommend it.
There is much more on the site: http://www.drewconway.com/zia/?p=345 e.g.
That site looks to be a treasure trove of info. Upvoted.
I tried to read the slides in Chrome, and they were half-truncated and all over the place. But in general, I will vouch for lxml, it's the bee's knees. For html web crawling, I had been getting my html with urllib2, pipe the stream through popen2 executing tidy.exe (yeah I know, Windows) which produces a neat xhtml stream, then manipulate lxml elementtrees. Trust me - this combo rocks. 
[adobe's docs](http://learn.adobe.com/wiki/display/Flex/3c.+Designing+a+UI+-+Layout) are fine, flex is pretty easy to grasp
&gt;All that is needed is a distinction between `enumerable` and `enumerator` That distinction already [exists](http://docs.python.org/library/stdtypes.html#iterator-types). Think about it - how else would it be possible to iterate over the same list twice? If it were merely an iterator, it would continue from where you left off just like the generator.
I recommend use Scrapy. [Scrapy](http://scrapy.org) is an excellent framework for make Screen Scraping. As scrapy.org home page says: &gt;Scrapy is a high level scraping and web crawling framework for writing spiders to crawl and parse web &gt;pages for all kinds of purposes, from information retrieval to monitoring or testing web sites. **Try it, you will not regret!** 
Call me dense, but if it doesn't have any fitness test and resultantly doesn't have anything to drive the next iteration of evolutionary output, then how is this an example of genetic programming?
I think the tidy step is not needed, lxml.html has what you need (cleaners and broken tree parsing)
Just don't do this in a long running process. I've recently been fighting with [this memory leak](http://bugs.python.org/issue1208304) in urllib2...
I have gotten the todo list to work as a text pad. I have been guessing at names on the search. Mine is **fls** (ef-el-es). I'll add any to the wave if you comment your username here.
I really had some malformed html however... lxml.html didn't really grok it. :) I understand html5lib produces elementtrees also, but it's really how a library makes sense of garbage which is important for any webcrawling app I think. 
http://www.amazon.com/Python-Programming-Absolute-Beginner-Michael/dp/1598631128/ http://showmedo.com/videotutorials/python
He is just showing how to use the GP of Pyevolve, I've never seen GPs in layouts, I think it's a very interesting use of GPs.
Yep, I think its best to ask some windows gurus on this so I crossposted it on programming. 
I've been using urllib2 extensively in several applications, using it to access SOLR, crawl webpages, and also via feedparser, issuing many thousands of requests per day. All of them have been running for weeks with no issues. the gist of the ticket seems to be that its a windows-only issue.
this is python dev, not php dev. we can handle it.
So I discussed this further with a friend, and we came up with some examples that would cause an issue. So I concede that there are important reasons not to use eval, when letting an arbitrary user make the input. Also a simpler way I think to use your dictionary trick would be to use, like Poromenos states below: cake = 'good' user_input = "cake" print locals()[user_input] I like this because it negates my argument against using it, since now no dictionary creation is required.
OK.. I don't mind that solution, but it has two problems. One is that I don't see how it fixes the issue you had with dicts before (about illegal var names; which, by the way, could easily be remedied with a regex) -- you can easily do this: locals()["is this a var?"] = "yes" But perhaps more distressing, that approach would allow the user to overwrite local variables with whatever they wanted.. variables your program might be using... myvar = 5 print myvar 5 locals()["myvar"] = 6 print myvar 6 
Yeah the indexing issue still stands, and really both solutions will have problems. I don't think its reasonable for one to expect all problems with user input be solved with a single function or a specific data type. Also in the scope of the original problem there would never be an instance where the input would be used to set a value. Nor would there be an instance to use local()['var_name'] = 'some value', and my example didn't show any. They wanted to know how to intake a var name and output its value. locals()["myvar"] = 6 &lt;&lt;-- never needed or used because we want what myvar is, not to set it's value. 
Let me short the story down: Silly C# programmer makes self-righteous rant because it took him 5 minutes of trial and mostly error to understand iterators in python and he misses the crap pile of abstractions and patterns that was his c# programmer brain-crutch. I don't want to see crap like this on python reddit.
Source on github: http://github.com/brosner/everyblock_code/tree/master
Link: http://pytest.org/
I didn't do much C++ programming in my life, but I have no problems reading the wxWidgets chm docs. I've already developed about half a dozen wxPython apps, some of them quite complex. 
&gt;&gt;return HttpResponseRedirect('../../../') omg
Wrong /r/.
Good tip, but did anyone catch that he lives with his parents? This is a stereotype we need to kick. ;)
I liked the Knight Foundation more when it funded missions for Michael Knight and his trusty companion K.I.T.T.
Well, maybe they live with him, which is okay and commendable.
Down voted due to full page pop up ad.
Same here. Talk about intrusive.
Yeah, I noticed they aren't using reverse() or the url template tag anywhere. Wonder why not.
Touche
Why X over Y? Is that a useful discussion at all? How do we measure or justify subjective belief? That's the real question. But one may as well ask why the sky breathes.
&gt; Python is laid-back about objects, because you probably know what's going on inside them anyway I like that. Also, mandatory whitespace... it's hard to describe how much I like that 
The answer to the question "why is Python more widely used than Ruby is?" is simple: it's been popular for longer period of time. There are many linguistic differences that makes one language better than the other in one respect or another. None of those are the reason. Python has simply been around longer, that's all.
It also had an acceptable implementation sooner. Last time I checked Ruby was still struggling with Unicode.
But.. but.. Japan.. Han unification... ITS NOT FAIR!!
Better check again, I suppose. Ruby 1.9.1 speaks Unicode and many other encodings.
Both languages came up at about the same time, but Python still got a big first-mover advantage because it was being discussed and promoted in English-language forums from the start. Ruby didn't cross the language barrier until quite a bit later, and I think that was a huge factor: it basically gave Python the best part of a decade to get a head start on adoption, documentation, libraries, etc. in the broader programming community. Also, I think it's to Ruby's detriment that the only thing people typically associate with it is Rails. There's a bit of a pigeonhole effect going there, where Python's got established tools in a variety of fields (everything from sysadmin scripting to number-crunching scientific applications) and Ruby's still really only known as the language that web framework thingy is written in.
&gt; Last time I checked Ruby was still struggling with Unicode Python up to at least 2.6 still has its share of unicode strangities
Yeah, more languages need forced whitespace. Today I was asked/ ordered by a colleague to remove all indentation from my CSS source files (and most from my HTML templates) "because it's confusing and makes lines too long", even though I kept under 80 characters per line. :(
who cares. use php or perl :) somebody had to make a flame war comment
Python's failure to take advantage of the power of OO is a drawback, not an advantage. Methods are superior to libraries of utility functions hands-down, any day. As someone who has done a not-insiginificant bit of work in python, perl, and ruby; I must say that enforced indentation and superior documentation are python's primary advantages. If I'm going to inherit someone else's code, I pray that it is in python. But when I write new projects, I pick ruby. And I think this is the way of the future. Look at the interest in groovy: ruby-like syntax for java. OO is part of ruby's soul. That philosophy makes you write better code, faster.
I agree with this. Python was the most logical step for all the Perl programmers when Ruby wasn't part of the default install. I came late to the party and I had to make a choice between what was a better investment of my time: Ruby or Python. The breadth of libraries, documentation, cross-platform support, open / free books made it a no-brainer. Ruby was only really tied to Rails at that stage and wasn't a default install in any Linux distro's. Actually is it now? I tend to think of them like brothers or cousins, they are similar in many respects but have their own styles and idiosyncrasies. 
While Python's exec times are frequently faster (http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&amp;lang=python&amp;lang2=ruby), I prefer Ruby's syntax. They are different tools for different things. I use Python for its speed, utility, and variegated modules, while I prefer Ruby for beauty, ease-of-use, and elegance.
That made me shudder.
I personally really like all the meta-programming stuff and having played with Haskell in the past; it's really something I use a lot. But I can imagine somebody not being into meta-programming to considering Ruby to be **pure magic at times.** And although that sounds like an advantage, it really is not. Most programmers prefer to feel like they are in control. And magic does not give you that feeling. The simplicity of Python in that regard is an advantage. Personally though, I still prefer and love Ruby. It's just so darn pretty. If Ruby didn't exist I still wouldn't use Python much. I consider all the dynamism to a bad thing. But it's just so pretty. Sure, you can write combinators and create a DSL in haskell, but it's so much more pretty in Ruby. Did I forget to mention how pretty ruby was?
Your username is pertinent.
I might suggest that instead of wanting to change any language you might use which doesn't have forced indentation, you perhaps work on the more achievable goal of getting the incompetent people you work with fired. Preferably into the sun.
I can't believe you're modded down for that comment. I'm sure people may disagree, but I can't see why they'd downmod.
I thank you for your sympathy. I have found that most of the subreddits have dominant dogmas. You can't post anything at all thought-provoking--just "rah rah rah for the dogma of /r/ourDogma"! If you post something that might even slightly question the dogma, you will be voted through the floor. Some subs, like /r/perl, even ban members who question the dominant dogma. As soon as I find a community site which honors controversial and insightful posts rather than abhorring them, I plan to leave reddit for it. This site has a fundamentally flawed model which is hostile to intelligent discourse. At least slashdot has minimum standrds for moderation and requires some reason other than "I disagree!" for community censorship.
People actually use Python. Seriously. I use tons of python-powered Linux apps daily, but nothing that uses Ruby (Metasploit is the only program that has ever required me to download the thing). Python comes pre-installed on many Unix systems, making it the ideal choice for some quick scripts. Once again, Ruby does not. And what websites use RoR, other than Twitter, which, from what I've heard, suffers from constant downtime due to Rails inability to scale well. Yeah, just use python.
It's not much of a flame war when it's universally accepted that you're wrong.
&gt; While Python's exec times are frequently faster Note that this really isn't the case anymore. [Ruby 1.9 and Python 3](http://shootout.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=python3&amp;lang2=yarv&amp;box=1) are pretty much the same.
I've also started an entry explaining how the logging module works in more general terms. It seems to be something that a lot of people fight with or get wrong. Has anyone else observed this?
Python suffered a setback in speed with Python 3 (they probably wanted to finish the job before making it fast), the was corrected in 3.1 that was just released. You might want to compare with that instead.
I think they are pretty clear about using the same urls. They don't need any flexibility for change. For one thing, if you use {% url %} even if one view has an error, the template displays an error page; since to obtain a reverse match, all possible regexes have to be compiled.
&gt;I can imagine somebody not being into meta-programming to considering Ruby to be pure magic at times. One of Ruby's "problems" is that you don't even need to dwelve into metaprogramming (which Python will be happy to let you play with incidentally) to get hit square in the face by magic. Ruby's blocks are already magical syntax (and not a good one to boot, considering Smalltalk's blocks are perfectly regular and more flexible). I'm ok with Ruby in general but that's one of the things I find downright disgusting. 
Those benchmarks are for Python 3.1
Wow, I'm impressed by how fast they upgrade to newer releases...
Ruby's a default install on OS X. It's hard to say what's 'default' about anything based on debian, though it's an easy install there.
Actually, I worked for a rails monitoring company, and you're just plain wrong. The vast majority of ruby / rails apps maintain at least 99% uptime. Most of the downtime we saw was from deploys, which are obviously not the same as 'not scaling'.
Ruby's blocks are just closures by another name. If you have a problem with closures, you'll have a problem with blocks.
Python has tons better scientific libraries. Anything that does number crunching, it's a huge win. It's often more maintainable, given the forced whitespace and higher threshold for metaprogramming madness. Better interpreter, as far as I am aware. Ruby's C internals are terrible. If you need a GUI, Python tends to have much better support for the major toolkits. Ruby's gui support is pretty abysmal. If you want to write C extensions to the interpreter, Python seems easier to do this in than Ruby. C extensions in ruby come in two flavors: RubyInline, which is awesome and easy and brittle, and FFI extensions, which are not awesome, not easy, and brittle. If you want to do crazy threading, Python has a more stable threading model, though it still has the GIL, where JRuby doesn't. But JRuby is still in development, and isn't the 'official' runtime (yet). *Edit: Also, Windows: If you're planning to deploy on windows, you better use python.* ------ Why Ruby over Python? If you like metaprogramming, if you like easy web apps (Sinatra is amazing), if you like an incredibly active community on Github, or if you've ever taken a couple terms of Japanese.
&gt; Ruby's blocks are just closures by another name. Irrelevant, that's not the issue I have with Ruby's blocks. Please try to read my post instead of providing a stupid canned response.
They're not magic syntax. They're simplified closures, in the same way that Smalltalk blocks are simplified closures. They aren't regular (boy howdy), but that doesn't mean they are any less of a closure. Edit for clarification: And if blocks are magical syntax, therefore so too are anonymous function arguments that carry a scope. Anywhere.
I've developed a preference for putting my opt parse stuff within an init() function to keep all its initialization code away from my main(), in which I just do args, options = init()
Use argparse. `easy_install argparse`
True (although I think there are some funny scoping details), but what masklinn's getting at is that in Ruby the syntax restricts you to passing at most one block to a method. It's a jarring limitation in a language that prides itself on giving you freedom.
In particular it had an English documentation earlier. I have to confess that I prefer Ruby, but I use Python simply because of its popularity.
Why do people think grey on white is readable?
&gt; They're not magic syntax. Wow... Calling a method: `a.foo()`; calling a method with an argument: `a.foo(b)`; calling a method with a block: `a.foo() {|i| i}`. The block is completely outside the argument list yet there isn't any magical syntax? Having a block argument: `def foo(a, &amp;b)` or `def foo(a)`. The block either is a special (magical) parameter prefixed with a magical operator (within the arguments list that time) or isn't even specified in the argslist yet it's not magical syntax? Affecting a block to a value: `a = {42}`? Nuh-uh, that's a syntax error, `a = lambda() {42}`. Because blocks aren't objects, Procs are, blocks are just magical syntax. &gt; They're simplified closures, in the same way that Smalltalk blocks are simplified closures. First of all, they're not "simplified closures". They're not "closures" at all. They're anonymous functions that form closure, which is slightly different. Second, there's nothing magical about Smalltalk's blocks. They're perfectly standard objects and values that are provided as message parameters, given names and passed around in perfectly standard and normal ways (as far as Smalltalk is concerned). &gt; Edit for clarification: And if blocks are magical syntax, therefore so too are anonymous function arguments that carry a scope. Anywhere. This mostly clarifies that you haven't the faintest idea of what my issue with Ruby's blocks is. edit: and it's not like Ruby's syntax magic blocks are even *good* magic: they don't provide any additional flexibility and if anything make the system less flexible (completely breaks down if you want to have 2 blocks provided to a single method)
You are currently at -1 meaning you have at minimum 2 persons who voted you down and if more, also N-2 person who voted you up. Yet you jump to the conclusion that the whole set of people reading your comment is incapable of handling your comment.
99% uptime - 87 hours of downtime a year - is terrible. If you think the vast majority of rails apps are 'at least terrible' I don't have much confidence. I think Ruby's quite scalable but your post doesn't prove it. Edit: Added numbers to the 99% figure since reddit doesn't seem to have much experience in this area.
I'll wait for inclusion in stdlib. This way I won't have to f-riendly easy_install it everywhere I want my single-file cli scripts to run, thankyouverymuch.
Well, according to their own webpage that version isn't even supported on all platforms yet so that kind of proves my point.
&gt; but what masklinn's getting at is that in Ruby the syntax restricts you to passing at most one block to a method. Not even that, but that's a problematic consequence of Ruby's blocks being magical syntax.
They want us to consider \ and ¥ the same and then have the gall to get upset because we want to consider 令 in a Japanese font the same as the same character in a Chinese font? Japan can fuck off and die. 
Define "its share." The only two I can think of "the `str` vs. `unicode` thing" (which Python 3 *solves by renaming* them to `bytes` and `str` respectively!) and that using characters not in the BMP can sometimes cause the `len` of strings to be wrong depending on the system you use (ie. the same thing Java did). Both are real problems, but I wouldn't say they amount to a "share of strangities." 
To supplement mordaunt0's suggestion, you could probably get rid of all the conditional handling: `logging`'s loglevels increment by 10 (10 is `DEBUG` to 50 `CRITICAL`) and each is a threshold (so -80 is still `DEBUG`). So you could treat your verbosity as a decrementing counter: multiply the counter by 10 and substract it from `logging.CRITICAL` to get the actual loglevel, default to `2` for a default of `loglevel.WARNING` import optparse, logging parser = optparse.OptionParser() parser.add_option('-v', '--verbose', dest="verbose", default=2, action='count', help='Increase verbosity') opts, args = parser.parse_args() logging.basicConfig(level=(logging.CRITICAL - opts.verbose*10)) logging.debug('debug') logging.info('info') logging.warning('warning') logging.error('error') logging.critical('critical') Another idea could be to use the `callback` action and decrement the logger's level by 10 every time the callback is called: import optparse, logging def callback(*args, **kwargs): logging.root.setLevel(logging.root.level - 10) parser = optparse.OptionParser() parser.add_option('-v', '--verbose', dest="verbose", action='callback', callback=callback, help='Increase verbosity') opts, args = parser.parse_args() logging.debug('debug') logging.info('info') logging.warning('warning') logging.error('error') logging.critical('critical') which yields the same thing as the one above: $ python test.py WARNING:root:warning ERROR:root:error CRITICAL:root:critical $ python test.py -v INFO:root:info WARNING:root:warning ERROR:root:error CRITICAL:root:critical $ python test.py -vv DEBUG:root:debug INFO:root:info WARNING:root:warning ERROR:root:error CRITICAL:root:critical $ python test.py -vvv DEBUG:root:debug INFO:root:info WARNING:root:warning ERROR:root:error CRITICAL:root:critical $ python test.py -vvvvvvvvvvv DEBUG:root:debug INFO:root:info WARNING:root:warning ERROR:root:error CRITICAL:root:critical 
&gt; (which Python 3 solves by renaming them to bytes and str respectively!) And by making most text APIs return the new `str` (formerly `unicode`) instead of `bytes`, which is pretty significant.
You know, there are greasemonkey scripts that show how many ups- and downvotes you got.
I have always found the belief that an OO solution is always the superior solution to be a little strange. 
I wrote this a couple of years ago. Its a .net commandline css compressor based on minify for JS, basically just ripped it off, it should remove comments and whitespace. Basic idea was to strip out the unneeded stuff from CSS before a deployment, but keep the working version all tabbed and commented. It might be useful for you, but just be careful as I never thoroughly tested it. http://sites.google.com/a/dvs.net.nz/projects/Home/csscompress EDIT: LOL just reviewed my own code, its so basic and lazy I should be ashamed :)
Because it's been there first, and Ruby has no chances against lock-in. 
But Ruby is not just an OO solution... OO is part of Ruby's soul, you see, and that is the way of the future.
Thankfully the "Ruby's soul synergistic philosophy future" meaningless rhetoric doesn't work on everybody. 
&gt; I have found that most of the subreddits have dominant dogmas. You can't post anything at all thought-provoking Persecution complex much? If it helps, I'll explain why I voted you down. &gt; Python's failure to take advantage of the power of OO is a drawback You've given no indication on how Python fails in this - leading me to conclude that you referring to parent's parent's note regarding (what I assume to be) lack of protection within objects (specifically public/private). I disagree that this is especially "powerful" (or at least, it conflates 2 orthogonal concern - object definition, and access control), and I consider a proper module system to be a better solution. You further make the unsubstantiated claim that: &gt; Methods are superior to libraries of utility functions hands-down, any day. Which I disagree with, and so would expect you to back that up. &gt; That philosophy makes you write better code, faster. Finally, we end with another unsubstantiated opinion. Adherents of any particular coding practice will claim that it makes you write better code, faster. This would be more tolerable except that so much has already been written about the complete [ambiguity of the term OOP](http://www.paulgraham.com/reesoo.html). Your entire post is meaningless to me until I know which specific OOP features you actually consider to be OOP. I think that best that can ever be claimed is that certain types of development fit more cleanly into OOP paradigms (once you define this) than others. But how you get from this position, to your extremely heavy-handed response is a mystery to me.
When I commented he was -5, not long after posting.
That's as may be, but it's not a reason to downmod
Probably the most compelling reason is because you can start epic flame wars like this thread will surely be. Also when you choose python over ruby, you can bench 350 lbs, appear more attractive to members of the opposite sex, and people quite literally throw money at you all day. It get's annoying after a while. 
Regarding threading, CPython does indeed have the GIL, but if you are going to compare anything to JRuby, you'd have to go with Jython - threading in Jython is full JVM threading as far as I'm aware.. (threading in the other Python implementations (e.g. PyPy, IronPython). Also, Stackless Python has a fantastic microthread concept that does away with GIL problems... *Edit: correcting reference to "stackless"*
I think it's readability. Ruby is easy to understand once you grasp the language. While Python is almost readable by non-Python speakers.
I am surprised you skipped Stackless Python implementation for threading.
so am I - I messed up the formatting (bad link formatting in the last sentence, will fix now)
&gt; Also when you choose python over ruby, you can bench 350 lbs, appear more attractive to members of the opposite sex, and people quite literally throw money at you all day. It get's annoying after a while. Whew! I thought it was just me!
Nice. I do something similar but have never taken the time to create a handy starting template. Would be cool to add imports for most standard libraries, to add examples of different kinds of options, perhaps pep-257 compliant docstrings, etc, etc.
Where do you see that? It's supported on Mac, Linux, Windows, and Solaris, at least. Ruby recently dropped support for a variety of other very uncommon platforms, things like BeOS and VMS, due to lack of developers, but I hardly see that as a problem...
On [this](http://www.ruby-lang.org/en/downloads/) page in the sections "Ruby on OS X" and "Ruby on Solaris" they mention 1.8.x versions as being supported which leads me to the assumption that newer versions are not. I also just checked my Gentoo Linux system and when I try to install ruby without unmasking any unstable packages it wants to install 1.8.7. Gentoo isn't exactly known for using extremely old packages you know...
It isn't like someone murdered his cat...
I can't speak for the various packagers and such, so I can't comment there. MacPorts has had ruby 1.9 for months, so I don't know what the deal is. You can certainly compile it yourself, though. Anyway, I guess I'm not sure what you're arguing. If you're arguing that 1.9 is a pain to install on some systems (Solaris, Gentoo) since you have to compile it, well, ok. Has nothing to do with 1.9's handling of Unicode, though. If you want to use ruby and use Unicode, there's a 99% chance Ruby is supported on your platform and can be compiled. If you want to know the biggest problem with 1.9, it's that many libraries (gems) are not 1.9 compatible, resulting in lots of frustrations if you happen to need one of those gems.
What I am saying is that 1.9 might not have arrived completely on all platforms so you can't rely on 1.9 only features in development much.
&gt; it's that many libraries (gems) are not 1.9 compatible This is evolving rapidly. I converted a decent sized Rails app over to 1.9.1 recently and it was relatively painless. Out of 14 gems (in addition to the Rails gems) and 13 plugins, only 1 gem was broken and there was a development branch on github with the needed one-line change.
&gt; &gt; Python up to at least 2.6 &gt; which Python 3 solves Yes, that's why I said *up to 2.6*
All you have to do to change what you're discussing is to pass your blocks inline with a lambda or a proc or a detached method. What you're complaining about is mere syntactic sugar.
wait -- what? Is '\n'.join(lst) going away?!?
&gt; which Python 3 solves by renaming them And by doing away with `basestring` so that byte sequences aren't and can't be confused with strings, where in Python 2.x both `str` and `unicode` are subclasses of `basestring`, which means they'll often pass tests you don't want them to pass...
Yo dawg ...
But what I'm asking is were there any other strangities besides that in Py&lt;2.6? It's not that Python had bad or inconsistent unicode support, it's just that it didn't culturally insist as strongly on bytes/string separation.
My only problems with such an approach is that (1) the values of those constants aren't by any means guaranteed (2) your approach breaks if I'm using more of the features of logging such as adding my own log levels. But I like the ideas. Very clean.
Since I swap over to C, C++, perl, and other languages for work, I still have this habit. I'll probably update the post to remove it, though, just because it would read more pythonic.
I've actually been inching up the darkness level of the main text color on this theme I downloaded. I'll go tweak it a little more later today.
Not at all but that's not the same thing. "join" works fine if you've got a list of strings but requires an explicit conversion otherwise. print('\n'.join(str(item) for item in lst)) There's uses for both I guess.
Reading this bit, if '__main__' == __name__: # Late import, in case this project becomes a library, never to be run as main again. import optparse I was going to mention that doing a late import is probably not really necessary, since it likely only adds 1 or 2 milliseconds to execution speed, at most (but then, it's not really hurting anything either). But look at the line before it! if '__main__' == __name__: ZOMG! The sky is falling! "main" and "name" are on the wrong sides! It's "if name equals main" not "if main equals name" ... that line is making my poor little brain implode. 
good point I like my main() to only have a handful of lines it in and allow the reader to get a high-level understanding of the whole program very quickly.
Sup homes?
exactly
Comes off a bit dogmatic, I agree... Sometimes what you want is a quick script that reads a file, sends it to a function to processes it, and that's it. OOP is a paradigm, not a religion. Some day another paradigm will come along (maybe aspect oriented programming).... Look at how fashionable functional is now...
This is a great example of the problem with reddit and group-think. I stated an opinion. You disagree with my opinion. Therefore, you seek to censor me. That's a clear violation of reddiquette, but you are proud of it. Sad.
I heard you like Python logger consoles.
Huh? Perhaps I was too polite. I downvoted you because of the general low quality of your submission. You said nothing of any value, yet stated your bald opinions as if they were substantiated facts. Your post was not nearly as intelligent or interesting as you seem to think that it was. And you further confirm my instinct... Rather than replying with anything resembling support of your position (in which case I might have reversed my downvote - as if it even fucking mattered), you act instead like an indignant, whiny bitch. Incidentally, THIS is also why I post on Reddit so rarely. Almost impossible to generate anything resembling an interesting conversation.
This is an artifact of the C code I have written over the years; an old time trick. If you accidentally fail to hit the "=" a second time, putting the constant on the left side of the expression will save your ass. "if (x = 2)" will evaluate to true, but "if (2 = x)" will throw a compiler error.
Its my definite weekend entertainment.
There is also [FirePHP](http://firephp.org/) brought to you by [Wildfire](http://www.wildfirehq.org/).
Sweet. I've always wanted a program on my phone that would detect my location and automatically forward calls to where I was. eg, when I'm at my office, forward all my cell phone calls there. When I'm at home, forward calls home. Either using GPS, or figure out which wifi networks were there, or I don't mind the idea of whipping out phone and scanning a sticker next taped to wall everytime I walk in.
Works as a middleware with django!
&gt; What you're complaining about is mere syntactic sugar. Syntactic sugar for what? I might very well know less Ruby than I thought, but I don't think I've ever met a construct equivalent to blocks which blocks could be sugar for.
I wish they wouldn't create a confusion this way - dynamic programming is reserved to something completely else: &gt;dynamic programming is a method of solving complex problems by breaking them down into simpler steps. It is applicable to problems that exhibit the properties of overlapping subproblems and optimal substructure (quoting Wikipedia) 
In the interpreter, blocks are an optimized version of a lambda. Let me submit an analogy: blocks : lambdas :: fixnums : bignums You can go look at the C code and see what I mean. You're right that they're not regular, but you're wrong that they're somehow fundamentally different from procs, lambdas, and methods. Under 99% of use cases, you can convert code from def foo yield bar end foo do |kipp| ... end to def foo(blocky) blocky.call(bar) end foo(lambda {|kipp| ... }) without any other changes to the code barring efficiency. There are places that MRI is _buggy_, and breaks on things like that, but don't blame the blocks.
so, um, wtf is spring python? first time i heard about it.
Excuse me sir, but you might want to notice that your `lambda` call takes a fucking block. The very block I have issues with in the first place. You're just moving the magical syntax elsewhere. I'm still waiting for an alternative syntax for block specification. Furthermore, of course, using that (fairly obvious but irrelevant) transformation results in ungood Ruby style-wise. &gt; you're wrong that they're somehow fundamentally different from procs, lambdas, and methods. I don't think I said that, and if I did it was a slip. I don't think I said anything about what blocks fundamentally were, apart from a shitty magical syntax for specifying anonymous functions that are to be provided straight to method calls
After four clicks, it's some kind of database library? I am not entirely sure.
Not really no :) It's a "port" of [Spring](http://www.springsource.org/) to the Python language. Mainly bringing some of the tools of Spring like IoC, security, AOP, remoting, etc. In the Java world, Spring has become very popular through the rejection of large monolithic frameworks in favor of smaller bricks that are (fairly) independent. Spring Python tries to bring those ideas to Python. 
Oh hmm, that sounds very interesting then, I should look into it... Do you know of any good docs that serve as an introduction?
Well for now, I can't offer better link than the reference manual itself and the source code. The Spring forum is quiet but the project maintainer is really helpful.
Ah, thanks for the hint, I'll read that then.
see also: http://wordaligned.org/articles/europython-2009 Tony Hoare’s vision, car crashes, and Alan Turing
The project's home page is http://springpython.webfactional.com. This includes links to the reference docs in both HTML and PDF, which includes details about how to use it including lots of code samples. For quick intro, you can see the slide show "Introduction to Spring Python" I presented at the SpringOne Americas 2008 conference at http://blog.springpython.webfactional.com/downloads/intro_to_spring_python_turnquist.pdf . There are also links on the home site our forum, where you can post questions (and which I have tried to answer quickly in the past!) . There is a link to the Blog site I run alongside with the project, where I have written columns oriented towards Spring Python, and the concepts we are trying to tackle. -- Greg Turnquist, Spring Python project leader
Oh nice, the PDF explains a lot, although it's still geared to people who are familiar with Java's Spring. Maybe you should include an explanation on the site for people who don't know about it (at least I haven't seen one, my apologies if you have one I missed). All told, it looks like an interesting project, thanks!
I am a python newbie. What does this thing do. What does this thing mean: sudo easy_install firepython. Thanks.
The Inversion of Control (aka Dependency Injection) is a powerful tool that separates the instantiation of objects from your code (in java, you are not calling "new Foo()" all the time). Instead, Spring lets you define the objects in an XML configuration file, which are then instantiated by Spring and set into our objects. Its power really comes when you are unit testing and you want a way to provide a fake or mock implementation during testing and a real implementation during actual use. I am still not convinced that Python needs Spring's style of dependency injection due to the dynamic nature of Python. For example, you can monkey-patch or dynamicly replace an object in Python--something that Java is not equipped for. It will be interesting to see how Spring is adopted in the Python community. Spring Python is definitely an interesting project, but it seems more designed to make up for deficiencies of Java.
If you are referring to "Introduction to Spring Python", then yes, I was presenting that at a Spring conference, which is primarily made up of java people. But considering that I could draw about 15 people from a 200-person convention to talk about python, I think it was pretty good! The real kicker was the fact that the previous night's keynote involved a Monty Python sketch. I opened by indicating that "SpringSource has definitely shown keen support for python-based solutions" the next day! Your suggestion "Spring Python for python users" and "Spring Python for java users" is a good idea. I remember reading a book called "C for Pascal Programmers", and I really loved it. I have tried documenting things, showing that you don't have to do one lick of XML: http://springpython.webfactional.com/reference/html/objects.html#objects-config-object and http://springpython.webfactional.com/reference/html/aop.html#aop-pure-python show this. I understand Spring has a long history of being XML-based, and when you get to python, it probably isn't the first thing you want to use. I believe in using pure python, while still supporting java people that want to migrate over a la the XML styles. In fact, in my slideshow, I made a point to use pure python in all the samples, and not even demo XML.
Essentially it's a way to log information from your web application into firebug's logger. Normally firebug will just give contain information which you log from javascript. However, this outputs any logging statements in your (python) application in a form which is then displayed in the console, allowing you to trace the server-side activity, as well as javascript in a single place. &gt;What does this thing mean: sudo easy_install firepython. "sudo" is a unix command meaning "run this as the root account" - which will allow you to run with [heightened privileges](http://xkcd.com/149/), such as being able to install applications. If you're on windows, you can ignore that bit. "`easy_install firepython`" will install firepython using [EasyInstall](http://peak.telecommunity.com/DevCenter/EasyInstall). If you install [setuptools](http://pypi.python.org/pypi/setuptools), you will be able to run the easy_install script as above from the commandline and have it download the files and install them as python modules.
He thinks Birmingham is OK.
I've seen python at work in some Apple installers (notably XCode.) I wouldnt be surprised if there were more utilities or random bookkeeping being done under the hood by something python. if you're really that concerned, open the terminal, run 'top' in one window and 'lsof' in another. 'lsof' will show pretty much everything on the system being used by anything, so you might want to filter it a little with 'grep' ('lsof | grep python' for example.) maybe download ClamAV and run it overnight just to be safe. I'm almost certain its harmless, but it never hurts to be safe. edit: I'll actually keep an eye out on my own system for comparison purposes and report back later.
Oh, I'm sorry, which large high-availability websites do you run?
...[coming back to this] Could you elaborate on "better results overall"? I understand that the -1 rowcount issue was surprising, but you haven't submitted any more reports, so I'm forced to assume that you didn't run into more problems.
Not a Mac user, but ps aux gives the full command line for all the processes. You could also check /proc/PID/cmdline that is if OSX uses the proc filesystem
Online trading for the world largest hedge fund. If we had 87+ hours of downtime a year - ie, '99% uptime' - we'd all be fired.
Hi. A google search for supervervisord only returns this comment of yours as a result. Can you give some references? Thanks!
I'm sure you're personally responsible for all of that. Honestly, most of the sites on earth aren't trading apps. Most of them can be down without killing anyone.
You generally require more than one person to design and run a trading app. So your argument now is that my knowledge of web apps is limited to large environments, and that my uptime expectations are too high? You're really winning me over here. 
I enjoyed Europython - and Birmingham has improved immeasurably since I lived in the area 20 years ago - but I found the quality of the presentations to be highly variable and somewhat unpredictable. Speakers and organisers need to put more thought into preparation prior to their talks. I spent a disproportionately large amount of time looking at Display Settings dialogs rather than learning. Also there were too many parallel tracks for too many talks that were thin on content. Shorter talks with the same content and fewer tracks would give a better pacing to many of the presentations and allow delegates to see more. In many talks the rate of information transfer was quite low. They keynotes were good. They best session talk I went to was about IronClad by William Reade. Maybe I will blog in more detail about my experience as a punter in general...
No, my point is that your environment is not everyone's environment, and that you can stop having such a hard-on for uptime statistics.
Hey there, I did the lightning-talk about my game engine. I tried briefly to get my laptop working before hand, realised I didn't have time to get it to work and just winged it when they called my name. I wish more people had done the same - I also hated staring at display settings too. :) I personally did not like the venue. I found Birmingham to be extremely boring (but I live in Manchester so yeah) and the conservetoire was a confusing labyrinth of a building. Let's not even talk about the wireless connection. Despite that I also enjoyed the conference immensely. I got a lot out of the tutorials and talks. I thought the keynotes were brilliant (except Cory Doctorows which I'm pretty sure I've read before.) The socials afterwards were brilliant and I got to meet lots of fun people. I'd recommend Europython to anyone with even a fleeting interest in Python, especially if you live in the area it's being held.
hehehe - dude you were the one quoting uptime stats. I'm just pointing out the stats you quoted are considered poor, regardless of scale - 87 hours of downtime for my blog would be poor.
That seems to be the convention in Linux-land. Arch Linux does this, as does Fedora (well, there's a python2 link; Python 3 hasn't been officially packaged yet). Debian naturally has something rather more complicated internally, but calling python2 and python3 should work there as well.
I like this idea...
Awesome. I figured that would be the case (or would be becoming the case). I just don't have access to any Linux systems bleeding edge enough to have dealt with this.
This isnt MacPorts or any distro, its part of Python's standard build process.
I'm actually pretty vague about what's platform-specific and what's not, which is one of the reasons I'm asking about this here. If I understand the READMEs correctly, for Python 2.x, `make install` installs a `python2.x` binary and makes `python` a hard link to it, while for Python 3.x `make install` creates a `python3` hard link. Oh, cool. The Mac mpkg installer for 3.1 does the right thing (creating `python3` as a symlink). Okay, this is all good evidence that MacPorts' current behavior is aberrant and should be changed.
Cool stuff, but reading this code shows me how much of a PEP8 purist I've become.
You think this is bad, wait until you use a distro that relies on Python for package maintenance. Yeah, I'm talking about you behind your back again, Gentoo.
Awesome, except for one teeny weeny insignificant detail: how can we actually use this? Where are the examples? Where is the tutorial?
Yes, the naming of the Pythons was discussed at the Python Language Summit, 2009, and is close to what you've suggested. Follow-up on python-dev was at: http://mail.python.org/pipermail/python-dev/2009-April/thread.html#88862 With Python 3.1 the default "make install" or "make altinstall" of CPython was changed so that it installs a "python3", but it will never install a "python". It is being recommended to Python installers/distributors that "python" always point to Python 2, and there always be a "python3" pointing to Python 3 when that is available. There has not been an attempt to create a "python2" yet though, at least the default CPython 2.6 install doesn't create one. This does mean that we are stuck with "python3" for a long time to come (I imagine this decision might be revisited in the future, but I'd guess not for quite a few years ... probably whenever distros stop shipping a Python 2 altogether) -- but it also means that Python 3 can be introduced into Linux distros etc. a lot easier and quicker since there will be no confusion as to if "python" should point to a 2 or a 3, it will always point to a 2. With Python 3.0 you used to be able to do "make fullinstall" and get a "python" pointing to Python 3, but this was changed in Python 3.1 to support the recommendation that "python3" be for Python 3.* and "python" be for Python 2.*. http://bugs.python.org/issue6047 So for now it is necessary to manually create a "python" symlink if you want "python" to use a Python 3 install. Which is what I'm doing since I like all my Pythons to be named the same :) (but the default "python" on my PATH still resolves to a Python 2 install) 
Gentoo handles "version slots" perfectly.
It does, for almost everything. Python is the exception.
Did you miss the comment I posted below, where you don't have to use ANY XML with Spring Python? I think I covered that in my response down below. XML is an option, and you don't have to use one iota of it. Check out the slide show I have down below, and you will see no XML.
Well, that just made my brain hurt.
But it's a *C-specific* artifact; since statements are not expressions in python, all it does is confuse the reader, as the interpreter will raise `SyntaxError` if you try to use assignment where you meant equals...
or you could use twistd and get this for free.
 dev-lang/python Available versions: (2.4) 2.4.6 (2.5) 2.5.4-r2 ~2.5.4-r3 (2.6) ~2.6.2-r1
And then you install it and it foobars portage.
Agreed with eliben. In the last section, just call it functional programming. Also the primer on the type() builtin is misleading, since the Python community prefers EAFP, in essence duck typing, to LBYL. It's a good function to know about but not to be used like that.
You can try this [classes tutorial](http://pytut.infogami.com/node11-baseline.html). You can also give a specific question, or try to say what are you having trouble with.
Longer than necessary - you can simply add 's' to year/month/day/hour/minute/second if the unit is plural. Also, see django.util.timesince.
wtf
Im a very very fresh beginner to python, but isn't the tabbing very important? there is no tabbing in your code, but i see If statements.
Python programmers quickly learn that popular blogging systems don't support the sort of indentation schemes necessary to properly represent Python code. As such, you generally come to assume that it's the fault of the blog engine (in this case, Blogger, which is one of the worst offenders) rather than whatever the author put into the text box.
I think they just forgot to put the code into a &lt;pre&gt;formatted tag, so everything collapsed.
Thanks. 
So we finally got months down to 30 days each? I seem to be missing that memo...
Try supervisord.
from my experience, getting incompetent people fired is not a more achievable goal than getting a programming language changed...
Yes, and only between 45 and 90 minutes we speak of one hour.
Thanks! (Reddit, you never cease to amaze me...) 
There are samples in the distribution. BTW the last release came out on 2008-09-03.
one of the things that Python needs to fix and clean up IMHO.
Yeah I know most remove formatting, but I just thought that they would do some sort of code tag to combat this
I have recently been making the transition from Ruby to Python, for various reasons. I love rake, but I'm surprised to see this Python project using a Ruby build facility. Is this typical? Is there a Python equivalent to rake?
No doubt. I've actually written my own wrapper since i could never remember how to manipulate date in python without having to look it up. Not very pythonic.
I played around with dates/timestamps in python a few months ago.. my head exploded trying to figure out why it was made in such a twisted and difficult to use way. Why does it have to be really hard to make a UTC timestamp then add/subtract an hour from it, then output it in a certain format? This is very basic stuff..
Are there any languages which do this better?
Hey, now it has been corrected. something I tried to share the code first time :-) 
Thanks for the tips..it works
actually saying I want to upload the file. but I could not see any way around for that. blogspot is something new like my blog :-). 
No problem. Looks much better now. ;-)
No problem. Looks much better now. ;-)
PHP's actually works remarkably well. You just need a few core functions to do just about everything (date, time, strtotime, and you're usually good.)
Sadly, from my limited interaction with their libraries, both perl and ruby handle this better. (Which is a long way from well, mind.) This is one of my (very few) frustrations with python -- the library is periodically crufty and/or cantankerous. 
Dang, I can't believe that BFG beat Grok to 1.0 final ... McDonough is a coding machine - that's a crazy amount of web framework to have produced within just one year!
* http://diveintopython.org/ * http://diveintopython3.org/
I use slots definitions as documentation.
I was recently drowning in timezone stuff in Cocoa and had a similar experience, even though (in hindsight) the code was written relatively well. In this language, timezone was handled well - everything was stored internally as GMT, and so long as you ensured that any times were parsed as GMT then you time math was simple. Still, it hurt my head a whole fucking lot dealing with it. One problem was the xcode environment itself, which would display all times in my current time zone in the debugger. I was debugging the changing of time zones, so this meant that every time I changed my time zone, all the numbers I was dealing with would change in the quick view of the debugger. I think this highlights why a lot of languages have difficult time zone control: most coders don't have to deal with this often. Typically, the user's current time zone is good enough. So languages make more-used case fast (current time zone) but the less-used case painful (different time zones).
Anyone have any hard numbers showing how big a benefit using slots has?
No hard numbers, other than "shaved 10s of megabytes off my task" and "shaved seconds off my task" :) Sorry, years since I (ab)used them.
A very unpythonic feature.
&gt; In this language, timezone was handled well - everything was stored internally as GMT, and so long as you ensured that any times were parsed as GMT then you time math was simple. I recall once running into a very strange case in Cocoa, though admittedly not related to time zones. `NSDate` serializes to a timestamp since epoch, which in itself isn't particularly controversial, but the epoch it uses is January 1, 2001, which screws up all sorts of things which have standardized on parsing timestamps since the Unix epoch.
Okay I'm a real big fan of Python, but why do I always see it redefining the wheel with stuff like this? The syntax and required knowledge is getting crazier and crazier, instead of clean like it should be. It looks like it's cutting corners and slowly turning into Perl.
As with so many things, it depends. The CPython dictionary implementation is optimized for speed, but not for memory use; it resizes somewhat aggressively to keep the hashtable sparse. So this does make a difference, because Python knows exactly the size of the structure it needs under the hood and doesn't have to do the resizing dance (note also that Python dictionaries do not shrink when you remove keys; they only grow when you add keys). To get a very rough number, I did a highly unscientific test using the class definition in the linked article (tweaked to make it work -- `__slots__` is valid only on new-style classes). I simply wrote a script that created three million instances of `Foo` and kept them in memory for the life of the script, and watched the memory use. Without `__slots__`, the script peaked at 524MB. With `__slots__` it peaked at 106MB. Your mileage will almost certainly vary.
You've got one set of guys who are tackling complex issues with the language and then you've got another set of guys who wet their shorts when they get the interpreter to print a number. No language can satisfy both constituencies with perfect precision.
I agree, looks like a hack.
My numbers aren't hard, either, but I've got a package that allocates millions of small objects (messages off a socket read), and I can confirm that I've saved many megabytes by implementing the classes with slots. 
To be honest, I haven't seen many cases where `__slots__` is really needed, and typically only people who do really need it bother to know about it. It's certainly not something everybody needs to learn.
and the part2: http://mlbiomedicine.blogspot.com/2009/04/active-learning-with-python-libsvm-part.html
it's an optimization damn snob
I think all those ugly double underscores are supposed to discourage you from using them. So if you want clean code, just avoid them altogether.
&gt; The syntax and required knowledge is getting crazier and crazier For a feature that was released in [2001](http://docs.python.org/whatsnew/2.2.html#peps-252-and-253-type-and-class-changes), I think it's a little late to be using the present progressive. :) And for a feature that you haven't run into for eight years, I'd say that would exclude it from the list of required knowledge for Python.
Erm… while I agree with you in general, there's precisely 0 new syntax involved in slots and the feature is 8 years old. 
Are you ironing or is your post serious?
I read this. Then I read the comments. And I still didn't see anything that wasn't "Python didn't work exactly like what I was used to in C++". And I saw a lot of things which were flat-out factually wrong. Then I saw something about "C++ is designed to be a light-weight language" and gave up.
How did you insert ` monospaced ` font ? UPD Thanks. Why it is absent from "formatting help"
Backticks or indenting a line with four spaces. `foo` becomes `foo`.
"missing visibility modifiers for class members (”public”, “protected” and “private”) and, most prominently, that duck typing." That's like complaining about needing to understand recursion to use functional programming languages. OP's complaints are with the paradigm of the language, not the language itself. I feel like every "I've been using Python for 3 months and here's what I hate" blog post boils down to complaints about working with a dynamically typed language by someone who's never used one.
I'm teaching my boys how to program this summer and using this book as the primary source. It has gone well and the book is nearly the perfect resource. However, the notes on installation of pygame, numeric, pythoncard, wxpython, etc - don't work on macos because python is already installed. EDIT: responses to the below. I did mention on his forum that the install wasn't going well. Unfortunately, they never tested it on macos - and didn't have one available to use to help. However, a few other posters seemed to have more luck. Regarding mac ports - do you need cocoa, pyobjc and select? And thanks!
Have you tried telling the author this on the books web site - by reading the replies he seems to respond quickly.
"In Python, a class is essentially a special type of object that works as a function. When this class function is called, it creates a copy of itself and calls the __init__ method of this copy." Hahahahah
... I am guessing that the "Source &amp; SVN" section is not supposed to be a segment of Lorem ipsum?
Hah, the project is hosted on google code so all the source &amp; svn stuff can be accessed from there http://code.google.com/p/kamaelia/
Don't do that! Slots have weird side-effects, you shouldn't use them unless you really need compact memory.
I like it when I get an error about undeclared members. It means I made a typo :)
Perhaps you'd be happier with a different language...
Actually, I'm trying to build a new programming language using Python. It's just that Python is the language I think I'm the most productive with currently.
Also, I'm looking for more good &amp; simple programming tools, games, etc that the boys can write beyond what's in the book. Ideas so far: # * encryption/decryption programs # * pig-latin translator # * tic-tac-toe # * snail population calculator - based on assumption that our acquarium snail population doubles every day. Need to calculate depth in inches of our town assuming that the snails are evenly distributed. # * renaissance-inspired insult generator # * nick-name generator # * sudoko analyzer # * ? Also, another online book with more examples is here: http://pythonbook.coffeeghost.net/
Multi-version installation and isolation is a frakkin huge headache for me right now. Been waiting for an article like this, thanks. Could I request a Part 2 that delves a bit more into common virtualenv use cases?
It doesn't. A lot of Java frameworks exist to hack around Java's static nature. 
hmmm. virtualenv is certainly useful, but fabric looks awfully like it's a complicated way of writing a shellscript - what am i missing? also, is it worth investing time in pip when the python core is looking at packaging? will their work make both pip and easy_install irrelevant?
&gt; He also failed to mention the thing I miss most when working with Python: via Peter Norvig’s Python IAQ, quoting Bjarne Stroustrup: &gt;&gt; “If I were to design a language from scratch, I would follow the Algol68 path and make every statement and declaration an expression that yields a value.” Yes! I'm not the only one! I've always found statements retarded. They are like expressions' poor cousins and left handed hammers. You have expression forms, which are awesome because they can be used and combined in any way, and then you go and create restricted special forms which may only be used in some ways, absolutely for the heck of it because there's not a single reason to keep them. The damage Fortran has done to programming is still evident over half a century ago.
The packaging improvements happening in Python core right are primarily to improve the specification and handling of metadata and the core APIs. Tools such as pip and buildout will be updated to work with those formats and APIs, so you won't have to re-learn a new pip if the underlying details are updated - they will most just make these tools be cleaner under the hood, and make it feasible to manage packages with "a quick hand rolled script or two" using the new APIs if that's your inclination over picking and learning an existing tool. So, yes, use pip, it's a good tool and it won't be changing ... well, at least the core packaging work won't affect pip. It is still at version 0.4, so obviously there is work and ideas and improving pip, but I'd expect it'll mostly be the addition of new features. Also, Buildout has been at 1.0+ for a long time now, so it's a very satisfactory tool for doing project-specific package management. 
I had recently been meaning to write up an article similar to this. Good work! Another great thing is using pip freeze together with revision control to track library upgrades. This way, when something library-related breaks, you know exactly when you upgraded each version of each library, just by looking through revision control history of your `frozen.txt` or equivalent file.
To expand a bit more on some of the core packaging work, PEP 376 proposes to fill-out the metadata available for installed python distributions, as well as provide a simple API for querying those distributions. If you run "pip install [somedistribution]" in Python 2.6, it will plunk an egg-format *[somedistribution].egg-info* directory alongside the install location of that distribution. But if your run a distutils-driven install "python setup.py install" (and the setup.py does a "import distutils" not "import setuptools"), then the *[somedistribution].egg-info* won't be a directory but will instead just be a file containing only the PKG-INFO for that distribution. Yes, Distutils does in a way already support "eggs" just a different format than setuptools "eggs" (confused yet?) - and the worst part about a distutils install as-is right now is that there is no RECORD of files installed. It can spray stuff where ever, *but it doesn't log the locations of where it's spraying stuff*! And so how do you uninstall a distutils-driven install? easy_install may catch a lot of flack for not having an uninstall feature, but at least it keeps a record of everything it's installed, so it is actually possible to implement an uninstall feature (and has been done, but it just hasn't landed on trunk). But migration is not really an issue to be worried about. If you install with one (or more) tools with Python 2.6, then the metadata will be a mess. But if you upgrade to Python 2.7 or Python 3.2, then the metadata will be clean and consistent (yay!). The whole point of using a tool such as pip is that you can easily repeat an installation of a set of Python distributions. So when you upgrade from Python 2.6 to Python 2.7 you don't just "copy a big nasty ball o' random stuff" from the 2.6 site-packages into the 2.7 site-packages (and hope that everything works as-is), but instead will do a "pip install" into Python 2.6, and then a "pip install" into Python 2.7. 
for deployment to remote servers fabric is quite simple (compared to capistrano). unfortunately it couldn't do commands on one of my remote servers so I had to switch to capistrano. (and now cap has broken on os x 10.5, haven't had a chance to examine) a lot of time I end up writing a shellscript on the remote server and cap (or fab) just runs that. still, it saves so much time. one of the most productive little tweaks I've done. check into it more if you deploy stuff. 
just in case this is "what you are missing" : def deploy(): local('git archive --format=tar HEAD | gzip &gt; $(site).tar.gz') # did you get that this being run on the remote server, not local ? run('rm -rf $(root)$(site)') and has var substitution 
well, yes, but ssh can also run command remotely. if i type 'ssh quiet ls' at a prompt on my laptop then i get a listing of the home directory on my server (called 'quiet'). i don't need a fancy system to do that. same for variable substitution, obviously.
ah, neat. thanks - that was a big help. i need to see whether pip supports 3.x (or will, soon). thanks again.
There is also cmdln: http://code.google.com/p/cmdln/ I am currently writing an easy/simple API to abstract all the logging stuff: logging to ~/.myapp.log and rolling it (like bzr), attaching console taking care of automatically mapping verbosity to pruning debug/tracebacks, .. and integrating with a simple console progress bar (like bzr -- too bad they made it GPL).
Yeah, it's a limited-access wiki, and there are a lot of hoops to go through to get access. Fixing the site doesn't look to have the priority for anyone that has it. There are some broken links, too.
&gt; hmmm. virtualenv is certainly useful, but fabric looks awfully like it's a complicated way of writing a shellscript - what am i missing? Fabric is not going to change your life. If you really want to write a deployment shell script, you can write one that will work fine. Fabric just tries to make it easier and cleaner, especially if you prefer Python. And I don't really understand what is complicated about it -- if anything, it's too simple. I wish it had the [atomic-directory-switchover feature](http://www.capify.org/index.php/Frequently_Asked_Questions#What_are_deployment_.22strategies.22.3F) that Capistrano has. Here are some notable features: * Automatically lists all functions in your fabfile when you run `fab --list`, and shows their docstrings (documenting what they do). In other words, it's very clean and easy to have `--help`-like functionality without manually parsing arguments yourself. * Mixing locally-interpolated variables and remotely-interpolated variables in a shell script command is going to get pretty ugly, compared to Fabric's (and Python's) syntax. * It has built-in commands for common stuff, like `rsync_project()`. Yes, you could easily implement this yourself, but you'll end up with a shell script that's cluttered with command line arguments and other noisy details, instead of something clean and readable like `rsync_project(remotedir='/home/$(fab_user)', delete=True)`. * Simple syntax for running different commands on different remote hosts. It's basically the mini-library you would have written yourself to do the same job.
&gt; perl was my previous favorite language for *system programming* projects And that's where I stopped reading.
:-D
Damn, even I get that, and I'm not even 30 yet. ;-)
&gt; fabric looks awfully like it's a complicated way of writing a shellscript Fabric and tools like it don't do anything a shell script _couldn't_ do, but typically they do so with less code. If you're doing this sort of thing regularly, you'll probably build up a little library of helper functions which automate or simplify different parts of the process (e.g., you probably won't want to manually type long `ssh` command lines every time you run something remotely), and Fabric is simply an example of doing that, albeit in Python instead of shell script.
Weird effects like what?
thanks for all the replies on this
I have an even better tool. I call it an intern.
FTFY: [The explanation.](http://www.mail-archive.com/python-dev@python.org/msg40096.html)
As if the name of the language wasn't a big enough hint!
Shame one me. Please don't put it on digg now, reddit is enough... :) It's harder for a non-native english person to get such catch phrases I assure you. Fetchez le tarek.
Hmm... never heard of "no one expects the spamish acquisition"?
Might as well go with the latest.. Most of the basics actually haven't changed much.
No, I haven't. And the Spamish people, despite their delicious canned meat, haven't heard of it either.
Monty Python is stupidly overrated. Fortunately, the language is not.
One of the nice things about Monty Python references is that they port seamlessly from Python 2 to Python 3.
heh I remember that episode but didn't made the connection until reading the explanation below :P
And now for something completely downvoted.
Don't forget to see the ``mod_wsgi`` docs about ``virtualenv``.
Oh, I hope you don't mind my posting it. I just thought it was funny, because your English is so good, I never thought that you might be a non-native English speaker, which brings "special" difficulties with it on the Python mailing list. :-D I also thought it was funny that everyone in the list felt compelled to write a reply with a link to YouTube simultaneously. 
PEby is hard enough to understand when he's not making cultural references.
Our two main weapons -- no, our three -- 
I believe the article mentions that descriptors are all funky (things like properties). Not all introspection tools can make sense of them. There's other things I've seen in PEPs (like, "this works for everything, except when you use slots"), but I can't remember them, because I filtered them out when I decided "I'll just not use slots".
I don't mind at all, that was funny ;)
which kind of dictionary do you want, african or european?
Are you suggesting references migrate?
Ehh.. What the hell are you talking about? He's asking you to elaborate you ninny. Censoring works kinda' the opposite way in my experience. Plus I agree, you made a lot of interesting claims which I found intriguing since I've yet to try out Ruby.. But then I realized you didn't actually argue for them, but simply put them out there, which made me discard you're entire post after the final sentence. Ohh, and stop your whining
Wow, that looks awesome. Although `pdb` is not *that* bad, having color (like `pdb++` but I could never get it to run) for me is the one single biggest plus.
I love the fermat function on the bottom. Oh those pythoners, so clever...
Not at all. They could be carried.
2.6 It's the bridge between 2.x and 3000. There's really no reason to jump over to 3000 until all the major framworks/libraries make the jump. The bonus of 2.6 is that there's not much you'll have to to to transfer to 3000. If you stay with your mind open to 3000 there's little you'll have to do to make your code work in the next version (most of the time you can probably get away with using the 2 to 3 tool).
Thanks for submitting my project to reddit. Do you use it for anything? I'm curious to hear feedback on what people use SUMMON for.
What, a swallow carrying a reference?
Right, you're drunk on your own dogma. Opinions which back up your bias are great on their own. All others require extensive research and citation or you attempt to censor them with your down arrow. I pity you. What a mindset.
No problem. I just came across your project and thought I might share it.
....can i use it with vim?
I prefer winpdb.org (not windows specific.) It lets you run a process in debug mode and then attach to it whenever you like with a debugger. The debugger and debugee can be on different machines. 
okay, showing some naivety here. why would I use this over the debugger in pydev? 
Which seems to be working everywhere Pydev works, not just *nix.
No, really, I am interested.. maybe you should stop playing a victim here, and either back up your claims, not by *extensive research* but your own arguments, so I can figure out what you're basing it on.. And maybe, you'll have a Ruby convert here..
There are many valid use-cases for macros on Python and any other programming language, even though Guido loathes them because they come from Lisp. (I guess if it was Java who had macros, we'd have got a nice macro system in recent Pythons. (Take this as a very, very strong form of insult. (Actually, I don't think of Python that lowly; it's one of my favourite programming languages (and yay, eat my nested parens you fuckers :P).))) What are you thoughts on this effort? I may consider using it in the future. I've just discovered MetaPython, and I see it has interesting use cases, though I believe I'm missing something like reader macros that will allow me to customize the syntax of the Python I write. For example, I would like to be able to transform Python code (at least statement by statement) so that I can hopefully turn statements into expressions (probably with the help of a let macro) and fix the stupid issue of statements.
Thanks.
Downvoted for what? My post is well written, meaningful, devoid of anything false presented as fact, devoid of fallacies that I can think of, etc. Maybe the Pythonic inquisition just modded me down for suggesting something that may make Python a tiny bit more like \**gasp*\* functional programming languages. BDFL forbid!
I'm having trouble imagining any valid use-cases for macros in Python. Do you have some examples?
There's a discussion here: http://blog.pythonisito.com/2009/03/python-macros.html "Macros are great for conditionally ignoring a section of code. The one particular use I have in mind is for debug logging. Our massive code project is littered with function calls to do debugging, protected by `if trace_level` conditionals to prevent evaluation of the function call and its (sometimes obscenely large) argument payload. Two of the most expensive things one can do in Python are create objects and call functions, and logging generally does both."
For example: * DSLs. Solve a problem by implementing a langauge, or use Python to specify a solution in a language that suits best the problem domain and it's easier to use than raw Python (think you could require your users to write this). * Fix annoyances with the language. * A portable way to rapidly prototype and/or implement new language features for Python. You could test and implement many PEPs without messing with CPython's code (which takes a much greater effort to understand, modify, distribute and install), and if PyPy, Jython and IronPython implement the same macro system, they automatically get the feature too. * Special evaluation forms for different evaluation models (which would make Python an even better multi-paradigm programming language). * Metaprogramming, as required by even the Python standard library. Building strings and evaluating them is ugly, dangerous, error-prone, and the opposite of Python's clean, no-nonsense style. * A way to increase readability when there's full of boilerplate code that follows a pattern. Also, check out what the top voted guy lists here: http://stackoverflow.com/questions/764412/python-macros-use-cases I believe I've listed and linked to more use cases for this feature than many other features of Python required before being accepted into new versions fo Python. The big downside of macros is that they're unpopular among the Python community just because Lisp has them. I've found that, for some completely nonsense reason, there's an almost generalized hostility towards anything Lisp within the Python community. Heck, most of my comments as both a Python and Lisp enthusiast are met with downvotes here in Reddit.
Since python isn't compiled, I'm uncomfortable with the term 'macro' - to me that implies source code modification before compilation. In python's interpreted enviroment, using conditionals to ignore code would only be to save execution time. I usually use a variation of the following if a `if trace_level` type guard is too cumbersome: trace_level = 0 def my_log_func(stuff): print stuff if trace_level&gt;0: log_func = my_log_func else: log_func = lambda x: None if __name__=='__main__': log_func('hello') If debug logging is disabled, the logging functions becomes a no-op lambda. True it doesn't completely eliminate execution overhead, especially if the arguments to the logging function require computation. However, I fail to see the advantage of a macro conditional versus a regular old if. Both take space in the source and both are evaluated at runtime. All the "macro" conditional would have is an unfamiliar syntax. I think I need more convincing. 
This follows in a (not very) long tradition of Python being a Macro language. e.g. [PyASM](http://members.verizon.net/~olsongt/usersGuide.html)
I have no idea what you are talking about. Most hardcore Python nerds I know are also hardcore emacs nerds and have an .init.el file longer than their resume. Who doesn't love lisp?
You can do crazy stuff that the language doesn't support with macros. For example, you could create a macro that looks like a function call, inc_this(a_local_var) that actually modifies the local value of a_local_var by evaluating to a_local_var += 1 Not that I am trying to convince you, or would find that convincing. ;-)
For starters, Guido van Rossum. After an initial batch of Lispy features that made it into Python early (lambda, map, etc.), he's been doing anything he could to get rid of them and divert from Lisp. He tried to remove lambda, refused to remove the useless, worthless limitation statements are, when pushed to add at least an expression if..else form he did it in a way it's useless for nesting, he pushed reduce away and tried to do so with map and filter, and so on. I'm not just dissing GvR: I think he has designed a great language and is a good BDFL overall, and that he's a very valuable member and representative of the community. It's just that he has never seen the value of functional programming and doesn't want to allow Python to support decent functional programming too just because of this. And then you have the whole Python community. Go any Python forum, including this one, and start talking about macros, eliminating statements, adding more FP utilities, etc. More than half of the people will be hostile to you.
Check my post; I've mentioned many other use cases for macros.
What's the problem with function calls that modify things? Python is *full* of them. sort and list.append are two of them. The only difference is that this inc macro would rebind a variable because numbers are immutable. This, however, can be done in function form as well if you use a locals().\_\_setitem\_\_, \_\_dict\_\_.\_\_setitem\_\_ or \_\_setattribute\_\_. This is one place where macros could be useful: many programmers, even non-functional programmers, consider C's behaviour of having assignments being expressions, as well as the pre/postincrement operators very desirable. Python doesn't support this because... does anybody know why do we have statements in the first place? They are useless. Anyways, Python is limited in this sense, and you could work around this limitation with macros.
I really wish it started with realistic use cases, i.e., cool things you can do with MetaPython. The tutorial is kind of dense, and doesn't implement a very exciting case.
Please don't think I'm hostile towards any of this. But.... I've been a programmer for quite some time and have worked (for real) with many languages over several paradigms (C/C++/Java, Perl, Python, Erlang, Haskell, Lisp, Forth, etc.) and I'm still not convinced that the FP paradigm is a "good" solution to general purpose programming. It certainly has some problem domains where it's a nice fit, but when you move into more real-world situations, you end up having to jump thru more hoops than if you went with another language family. So far, Python, IMHO, is one of the best languages for almost all situations. No, it's not perfect, and no it's not the most optimized for some problems, but I'm willing to trade that in for it's readability, maintainability, portability and speed of development. All of that aside, I am comforted by the fact that "macros" and DSL's and many of the abilities of FP are possible in Python for those that want those features. Seeing metapython implemented as a python package I take as a testament to Python's flexibility and extensibility. *"why do we have statements in the first place? They are useless."* -- now that's just crazy talk right there. :-)
I did not say it was a problem. sort and append are both methods and do not change their caller's local variable assignments. You might be able to look at your callers stack frame and screw with its locals if you were bloody-minded enough. I'm not sure why you are arguing with me, I haven't contradicted you.
Macros make me wet?
All expressions are statements, but not all statements are expressions. What is the value of an "If:...else:..."? What is the value of an "if () {} else {}" in C? It does not have one. It isn't an expression, it's a statement. Your beef is just that some things that you expect to be expressions are merely statements. And probably, it's just assignment that really bugs you. It annoyed me a bit way back when too, but now the only time I run into it is when I've accidentally used '=' instead of '==', and then I say thanks. I don't know why this design decision was made, but I expect it was because it makes faster the overwhelmingly more common case where you don't immediately care what the value of an assignment was, and as an added bonus a class of bugs become impossible. But that's just me talking through my hat.
If Guido and RMS got into a fist fight, who would win? / I'd pay to see it.
You are under the false impression that python isn't compiled. Python is compiled. It's just compiled dynamically at package import time.
Well yes...and no. It's "compiled", but not to native instruction set, but to an intermediate encoding which is then processed by the python runtime. 
See? All of my posts in this thread are &lt;= 0. This is the hostility I'm talking about. I've said the L-word, and now pythonista redditors are treating me like a heretic.
None of what you've said would be incompatible with adding more goodies from functional langauges to Python. They're hostile to something just because they would use it. If programming languages were roads, Python drivers would want to close the roads they don't go through. &gt; "why do we have statements in the first place? They are useless." -- now that's just crazy talk right there. :-) Please explain: what's crazy about it? Statements serve no purpose. while, if, def, class, etc. could all be a special form yielding a value. You already have expressions built into the language, and arbitrarily chose to have a more limited form of them with absolutely no reason to. You could have exactly the same special forms, only make them yield values and be usable anywhere and combinable in any way, but they were arbitrarily, artificially chosen to be limited to appear only in certain points just because Fortran had that design wart as well. Statements also complicate the syntax of the language without offering any gain. You have special forms such as lambda or if..else that may do anything, and then you have statements, just because, like a left-handed hammer. Name one reason, just one reason, why you think statements serve a purpose they couldn't serve as just more special forms. Why couldn't we have assignment work as in C-like languages, if:else:etc. work as an expression (which would have eliminated the need for the other awkward if..else expression), while an expression that returns the last evaluated value, def an expression like function is in Javascript (which would eliminate the need for lambda), etc.? It'd make the language so much simpler, so much nicer, and so much expressive, at absolutely no cost for anything Python already has and is good at.
All expressions may form an expression statement, but they are not statements. Statements are completely unnecessary. You could have exactly the same language, only with the ability to use anything anywhere, for no cost. Actually, for cheaper, because the language grammar would be simpler and you wouldn't need lambda or the awkward if..else expression form we have. &gt; What is the value of an "If:...else:..."? If it were an expression form, it could yield the last evaluated value in either of its suits, of course. This means you could still do this, as always: if a == 1: print a else: print b but being an expression would also allow stuff like: a = if b &lt; 5: 3 else: 0 which is how it works in languages such as Ruby or Lisp. See how this would eliminate the need for if..else, since you could have if cond: part1; else: part2, which is also much nicer and conventional than Guido's if..else expression quirk designed to piss functional programmers off. if is a statement in C, because C has this defect to. So? It's an expression in Erlang, Scheme, etc. &gt; Your beef is just that some things that you expect to be expressions are merely statements. My beef is that statements are an unnecessary complication and bother. It's like saying you'll drive your car anywhere, but you have to use even gears while turning right and odd gears while turning left, just because. Why do we need to put up with this kind of arbitrary limitation? The fact most people don't realize how silly it is beause they have been infected by imperative languages derived from Fortran is no excuse to keep doing it. &gt; And probably, it's just assignment that really bugs you. No, the fact statements exist bug me. Why can't I do anything anywhere? Why do I have lambda vs. def? The ugly if..else expression? Why am I unable to use while in a lambda-expression? And so on.
"Compiled" languages tend to not have the compiling environment around during runtime. He's saying one can harness the available runtime compilation to do exactly what static macros would do without doing source transformation.
I hear what you're saying. In response I can only say, if you want to use a functional programming paradigm, use functional language. Not everything is an expression - sometimes a cigar is just a cigar. If you want static typing use C++ or Java. If you want prototype based OO, use Javascript. If you want something that tries to be multi-paradigm and combine abilities from several ways of thinking use Python. No, it will never be as "pure" as other languages that are rigid in their domains, but I'm ok with that. I like being able to use a while loop around list comprehension that has a lambda in it - if that is what will allow me to express what I'm doing most clearly. Statements are one way of expressing a semantic concept. Expressions are another. Sometimes an expression is a cleaner way of doing it and sometimes statements are more concise. I disagree with your metaphor, python drivers wouldn't close the roads they don't use, they just wouldn't import them. And all I get from your postings in this thread is that you're here for an argument. That'll be $5. 
A more equivalent way to do it would replace normal, untraced functions with increasingly tracing wrapping functions at startup time. In normal operation only the bare functions are available, and the available tracing does not add any overhead whatsoever. Your method, on a glance, only replaces a real function with a dummy function: there's not much gain there. Gains come from eliminating function calls completely.
 if a = "b": ... if a == "b": ... When assignment is not an expression, there are less ambiguity and subtle bugs involved in conditionals. A `:=`-assignment would however not have these problems, and could be introduced in parallel to the statement assignment. It's not considered pythonic enough. In my opinion the best way to assign names to values is a lisp-style `let` form, that has a clearly defined scope and is not confused to equality. Again, very unpythonic.
Then your understanding of the term 'macro' is rather limited. Check out how macros are used in Lisp in a very dynamic way. It's not at all about conditionals at compile time. There's a very good book available for free online on Lisp macros that will blow you mind ;-) [On Lisp](http://www.paulgraham.com/onlisptext.html)
because eclipse weighs 3600 tons, IDEs can't easily embed debugging *anywhere* (like, while running paster server, on a shell server, etc.) and pdb just needs a little more UI friendliness to be perfect.
&gt; if you want to use a functional programming paradigm, use functional language 1. Not having the design wart known as statements does not imply it's a functional language. 2. It doesn't hurt to fix Python, so why not do it? &gt; If you want static typing use C++ or Java. If I wanted static typing I'd use a programming language with a decent type system that features type inference. &gt; If you want something that tries to be multi-paradigm and combine abilities from several ways of thinking use Python. Exactly. And I'm saying more can be incorporated into Python without adding complexity (actually reducing it) and without hurting anything it already has. &gt; No, it will never be as "pure" as other languages that are rigid in their domains Oh, and BTW, I consider Python's object system to be some of the best. In no way I think Java's is an example to be followed. If we're talking purity here, Smalltalk would be the language to mention, but I feel Python's object capabilities are nearly perfect for my idea of perfection. &gt; Statements are one way of expressing a semantic concept. Expressions are another. The functionality and use of expressions includes and supersedes that of statements. Statements are useless. &gt; Sometimes an expression is a cleaner way of doing it and sometimes statements are more concise. Oxford: concise: giving a lot of information clearly and in few words. With statements: if b &lt; 5: a = 3 Without statements: if b &lt; 5: a = 3 And that's the worst case: one where expressions aren't nested anywhere useful. &gt; I disagree with your metaphor, python drivers wouldn't close the roads they don't use, they just wouldn't import them. Then why not implement more functional programming features and just ignore them? &gt; And all I get from your postings in this thread is that you're here for an argument. That'll be $5. I'm here for discussion on why a language that's pretty good cannot be better just because people are hostile towards what they don't use even if having these features wouldn't compromise what they use. The fact you see discussion on a programming language features as an argument says something.
After learning C, I remember confusing = with == once in my life. But make it := if it'll avoid this problem. &gt; It's not considered pythonic enough. Which roughly translates to "I don't like it. Fuck it." The problem with wanting a pythonic language is that instead of getting the best possible language, you get the most pythonic language, for an obscure, arbitrary, personal definition of pythonic. &gt; In my opinion the best way to assign names to values is a lisp-style let form, that has a clearly defined scope and is not confused to equality. Again, very unpythonic. &gt;&gt;&gt; a = 5 &gt;&gt;&gt; class let: ... a = 6 ... print a ... 6 &gt;&gt;&gt; print a 5 Durr hurr hurr! (Note: I'm aware of the shortcomings.)
The point of "pythonic" is not the best possible language ever for everyone, mainly because it's that hard to accomplish, but the best possible language ever for the largest count of people. It means not implementing new best ways to do it, because the old best way to do it is good enough. Choices are there if you *really* need it, but the non-obvious choices need to be kind of awkward, because then we'd have multiple obvious but subtly different ways to do the same thing all with their own gotchas. If not, we'd soon approach C++ style choice. This also keeps the language smaller and more uniform in style, which is a desirable property and a good part of what Python is.
Guido looks kinda tough, but RMS is huge and can obliterate him while he sings the free software song. However, I'd rather see Lisp hero Gerry Sussman in that match.
&gt; The point of "pythonic" is not the best possible language ever for everyone, mainly because it's that hard to accomplish, but the best possible language ever for the largest count of people. And doing things such as getting rid of statements would work towards this goal, as it hurts no one (you don't even have to understand what's this about and stay oblivious to it), and helps those who can appreciate it. &gt; It means not implementing new best ways to do it, because the old best way to do it is good enough. Okay, since Lisp is 50 years old... &gt; Choices are there if you really need it, but the non-obvious choices need to be kind of awkward I agree. However, I don't see how this would make Python awkward. &gt; This also keeps the language smaller and more uniform in style And this is, again, one of the reasons why we need to get rid of statements: an extra, unnecessary, arbitrary rule for complicating the language with absolutely zero gain.
I used `__slots__` in one of my programs to save a significant amount of memory. I don't recall the exact numbers now, but for this particular data set, the mem usage without slots was over 4 GB and with slots it was around 2 GB ~ 2.5 GB. I only have 4 GB in my system, so I probably killed the first version before it peaked. I think the rule of thumb is if you are creating thousands or millions of the same object (like I am), the memory savings from using `__slots__` can be substantial.
which problems did you have with pdb++? It should just work out of the box, if you put it into yout pythonpath
A bare expression is a statement, but yes, not all expressions in python (eg, a subexpression) are statements; they just could be. I should learn to be more pedantic I guess. I like expression-based languages. I use lisp every day. But Python just isn't like that. If it were, it would be a very different language. What you are proposing isn't a small change, it's a new language with incompatible design goals. Feel free, I'll totally check it out when you get a prototype together.
You argued with me for several paragraphs and I didn't even contradict you, I was just illustrating one of your own points.
wat
Almost nothing is compiled to the native instruction set anymore.
But, he's using a macro language already, and his creates an extra noop.
No, I just downvoted you because you're just a babbling persecution-complex having moron. *-Signed, a Lisp hacker.*
Why are OO languages better than procedural languages which happen to support OO? That's hard to explain to someone who has limited experience. This is what I've got for you: OO languages are data-centric, and data is what really matters for most things. Real OO languages are also faster to program in and are less error-prone because they are more organized. Want the length of aString? In "traditional" languages, you look up what utility function is needed to find that, import it if it is not there, and deal with bugs if the utility function was really designed to act on some other datatype. In a real OO language, it's just aString.length. There is no possibility of type mismatch, you don't have to search for utility functions. What you need is right there next to your data, so you use it and don't interrupt your workflow. Now bury my comment for being too vague to be meaningful or whatever BS you poor people use to justify your dogma. Enough downvotes and my comment won't be displayed. Yay!
I always found it annoying that you can't change the font in the console and source view. By default it uses a tiny courier new type font. Unless this has changed in a more recent version.
It wouldn't be very different at all; it can be made 100% backwards-compatible with the current syntax. I don't have time to go through CPython and modify it that much though. See, this is why macros are useful: if Python had a powerful macro system, parts of the language such as these could be made with the macro system.
There are better ways to do it. The idea is sound. A general idea is wrapping (=replacing) some or all real functions with functions that add useful things for the occasion: logging, debug info, optional features... The minimal functionality desired would only run that minimal functionality, the extra stuff is all left unapplied and at most occupies memory. A proper macro system (e.g. that of Lisp) could one-up that by removing unneeded function calls (inlining of sorts) on top of that. Lisp is great if one can write programs that write the program one wants, as the resulting program can omit everything not necessary for the configuration.
Ugh. a = if b&lt;5: 3 else: 0 Seriously? That's the ugliest bit of pseuod-python I've seen in a while. I'd rather keep the warts of statements than have to read code like that. If i wanted to do that, I'd use ruby, thanks. (And I do use Ruby, but I hate that sort of idiom with a passion.)
What better ways to do it? I very seriously can't think of an assignment based solution that doesn't create a noop, and python doesn't do dead code optimization so you would have a function call (remarkably expensive in python) for no reason.
I recommend you take a look at pymedia and I'm too lazy to google it for you
im to lazy even to type out a http://lmgtfy.com/?q=pymedia&amp;l=1 oh wait that was it already damn &lt;remembers simpsons lolapaloza episode with homer and the roadies...&gt; 
I'm not sure about videos. I tried playing .wav files in pyglet, but it took up about 20% of my CPU power (and I'm using a 2.4 Ghz dual-core CPU). By comparison, iTunes takes up about 1-2% of my CPU. I'm sure iTunes has plenty of bloat and unnecessary features, so I was hoping that playing streaming music in python would take up about the same amount of CPU power or less.
C? In which every application on your desktop is likely written...
No it's not, it's compiled to llvm for most of the applications on my desktop. See: C-lang. Anyway, if you think most of the applications on your desktop are written in *C* and you're not running gtk only on Gentoo, you're so wrong that this conversation is done.
Does it actually use all the cores on a multi-core system?
Oh my God what is the matter with you people?!?
Not much different from: a = if b &lt; 5: 3; else: 0 which is not much different from: a = b &lt; 5 ? 3 : 0; which is not much different from (but definitely far more beautiful than): a = 3 if b &lt; 5 else 0 which is currently valid Python.
FWIW Zeus for Windows also supports Python - http://www.zeusedit.com/ Zeus is also scriptable and of course Zeus scripts can be written in Python. 
 def real_one(arg, arg2): ... def real_two(arg, kwarg=None): ... def log(f): def wrapped(*args, **kwargs): ... # do logging return f(*args, **kwargs) return wrapped LOGGED_FUNCTIONS = { 2: ["real_one", "real_two"], 1: ["real_two"], } if logging_level &gt; 0: for func in LOGGED_FUNCTIONS[logging_level]: globals()[func] = log(globals()[func]) else: # look ma, `log` is never called if it's not needed pass To expand the idea some functions can use specialized functions to do useful stuff for that particular occasion. Dynamic inheritance can do the trick for highly object-oriented stuff.
It can. You just have to be careful how you do it. iTunes has that apparently low CPU usage because it's only running long enough to toss another chunk of the media onto the buffer. When you do it directly in Python (or any other language) you need to manage that buffering yourself. And manage it in such a way that you're not sitting in an idle loop chewing up CPU doing nothing. Doing nothing well, is one of the hardest things to do. 
Sorry, I should have mentioned that in the comment PyMedia does not support Python 2.6. Unless there is a way around this besides downgrading I'd really prefer not to do this. EDIT: I've spent countless hours trying to find an alternative on Google prior to posting to StackOverflow and Reddit.
All of which are heinous, valid Python or no.
So you've limited your solution to a decorator wrapping function calls? You're really failing to demonstrate this is better than a simple macro language that can be used anywhere.
Did I not mention that a proper macro system (namely that of Lisp) can do that and even a little better further up in this thread? A lesser macro system may also, but I don't want to learn a new language to use another slightly better. Lisp macros, for the record, are written in Lisp, processing Lisp. A non-lesser macro system would turn the language in question into Lisp. Without Lisp the "decorator wrapping function" style is better, because *I don't introduce a new language* but use the normal programming language to express self-reflective concepts, if only in a non-perfect way.
I have no idea what you're talking about. Metapython macros written in python, process python, and output python. Are you just a lisp bigot? I'm really not getting it.
Then I've wasted my time here.
Eric Nichol's ubuntu repository is out-of-date; there's ongoing work on a debian package [http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=279422]. NLTK has categorial grammar support. 
thanks. that was exactly what i needed. monday morning i need to go move a few methods from model classes to custom managers...
Excellent post many thanks.
Nice article. Good to know if you have to deal with Windows services there's a sane way to do it from Python.
Being able to control windows from python has been the only thing that has made ubuntu -&gt; vista transition bearable. 
Why are you taking this step backwards?
new gaming laptop came with it and I forgot to partition it before I installed a ton of stuff on it :|
Isn't there NTFS partition resize support in gparted?
as soon as I find an external drive to create some backups before attempting it :) 
What are you doing on your vista gaming laptop that requires you to use python on a regular basis?
nope - it's still built on Python. I think parts of it run on IronPython and Jython where it can use multi-cores. There are also some process based components, using multiprocessing, which also can use multiple cores - even with CPython.
Well pdb also needs to not interpret `c = "var"` as the same thing as `c`. Or any other command for that matter :( when debugging using 1 letter vars is nice.
adding extra nitpicky functionality to windows.
I approve of this project, keep up the good work!
[Explanation](http://github.com/alex/pyvcs/tree/master) &gt; pyvcs is a minimal VCS abstraction layer for Python. It's goals are to provide as much functionality as is necessary, and no further. It doesn't try to abstract every layer or feature of a VCS, just what's necessary to build a code browsing UI.
I like it. Thanks. argparse had some advantages over optparse, but on the whole cmdlin is more powerful.
But of the them all Guido chose the least heinous one, in my opinion.
Why? Mod python is excellent.
This links to a page that doesn't exist, and thus isn't particularly useful.
Try SQLAlchemy mailing list, since it's one of the most supportive ones out there.
I tried posting a different question through google groups about an hour ago and it still hasn't shown up... don't know whats going on there
I've been a big fan of [mnml](http://github.com/garethr/mnml/tree/master). It's small, easily embeddable in your app and upconverts to python3 fairly trivially via 2to3.
Yay, another web framework. I was just thinking yesterday about how few of these there are, and the need to really start pumping them out. Question though, why not call your framework "Python on Rails"?
Juno is more close to [sinatra](http://www.sinatrarb.com) than Rails
Thanks for the Sinatra link. :)
Erm, if you just want to get to the Juno homepage, it's here: http://brianreily.com/project/juno/
jinja2 ftw
also see [bottle](http://github.com/defnull/bottle/tree/master) if you're shopping around...
Spooky, I was just playing with this framework not 24 hours ago. And now it shows up on reddit. 
Yikes. A little harsh?
Cheers, I've been looking for a micro web framework just like this.
I must admit it is the [virtualenv+ fabric + pip](http://clemesha.org/blog/2009/jul/05/modern-python-hacker-tools-virtualenv-fabric-pip/) combination with a modern DVCS like Mercurial. It is the best workflow I have.
vim/linux/git/distutils/metaclasses/pyflakes (in the order specified by the question, rough definitions) Edit: And xmonad is handy too, on a large monitor. workspaces: code, web, testing, misc, misc, misc, music, email, im
Eclipse for big things. SciTE for small things.
Eclipse has some nice plugins for python and handles it very well. Just too bad the only code completion I found is either for-pay or with a nag screen every 2 hours.
Code completion? PyDev has that built in. Any time you hit a period it'll show a drop-down.
I cant believe no one mentioned [web.py](http://webpy.org/) here on reddit...
I think !c = "var" prevents it interpreting it as a pdb command. Personally I just double letter that shit - cc,dd,ee,ff etc.
`(g|mac|)vim`
[Stani's Python Editor](http://pythonide.blogspot.com/2007/02/how-to-download-latest-spe-from_26.html)
Eric4 IDE for PyQt4 development. Vim for everything else.
Emacs, it is just faster to browse around the many files I have in my project. Eclipse+Pydev is really nice too, though.
Two questions, because I simply don't get it. Does setuptools anything but resolving package dependencies and downloading and installing them and if so why can't this functionality simply be implemented in distutils? 
Dammit, people... it's not _that_ hard to spell!
setuptools is a cancer
Yeah, free PyDev version shows the nag screen he's talking about. I can live with it though.
Sorry for my mistake)
Eclipse + Pydev for projects bigger than single file -- full code completion, interactive console with code completion, visual/interactive debugger, class viewer, TODO list, coverage.py integration and analysis. I need to look up Eclipse-Git integration, as I am working with repos outside of IDE. I've recently started Unittesting everything I do, which saved me from headache at least twice in last week. For now I'm also using Idle/Gvim when doing single file scripts on Windows (at work) and IPython/Vim when working on Arch box (at home). I am thinking about dropping them and using Eclipse/PyDev exclusively -- its editor is not as good as Vim in regard of touch typing, but the IDE part is awesome. (edit: s/it's/its/) 
vim for everything.
Seconded. Makes deployment a breeze. Hopefully, with the new version of fabric, you can write a script where you just specify a host and it sets up everything for you.
done
pida(think gvim+) with IPython in the shell
[nose](http://somethingaboutorange.com/mrl/projects/nose/) and [Sphinx](http://sphinx.pocoo.org/). Fantastic software with fantastic extensions.
Two reasons why I use setuptools over distutils: One is [pkg\_resources](http://peak.telecommunity.com/DevCenter/PkgResources), which has a thought-out entry points system that makes it fairly simple to let other people extend your own libraries. Pylons and Paste heavily use these entry points. And, if you want to hook onto entry points, you have to use setuptools. (Hence the "cancer" bit, I suppose.) pkg\_resources also has a real requirements system that lets users specify a fairly wide range of dependencies on your libraries. Package installers like `pip` and `easy_install` use these, for example. The second reason is `python setup.py develop`, which only installs a single egg-link to get a library onto `sys.path` but lets you develop the library in the same place without having to type `python setup.py install` every time. i--i'm pretty lazy Along the lines of what a lot of people over in Pythonland have pointed out, I'm betting that the first person who writes a serious competitor to setuptools that's compatible with all the existing infrastructure without all the frustration will get a lot of hugs from a lot of people.
I sit at a WinPC, I never edit/code on it. So: ssh, vim, svn an the LAN-connected Ubuntu box ssh, svn export/checkout on the webfaction account I do django work, so a lot of command-line "manage.py shell" for a smart python interactive shell. 
yeah! vim FTW!
entrypoints. more or less required for nose plugins and similar.
Emacs with [flymake](http://flymake.sourceforge.net/). It's like a syntax highlighter, but it shows language-level problems AS YOU TYPE. Warnings like variable not used are in one color, errors like in red. I now enable it on every computer I use before doing much of anything. http://www.youtube.com/watch?v=F5Cc2W6PbL8
&gt; And, if you want to hook onto entry points, you have to use setuptools. Entry points are described by a flat text file in the egg info, which can be included in the source archive using distutils.
I've recently tried [Netbeans for Python](http://www.netbeans.org/features/python/) and fell in love with it, the code analysis is really good (way better than Eclipse+PyDev's IHMO). I'm not saying that it's better than Eclipse, just superior to PyDev from my usage perspective. 
Tarek Ziade has been working to port (or rewrite) some of the functionality of Setuptools into distutils.
lots of nasty magic, bad toy 
No textmate fans here? I'm not hacker enough to handle a terminal text editor.
It's all about gedit for the python and the django. It's also all about virtualenv.
I am the pusher robot. I push the packages down the stairs.
I'm a textmate fan. To avoid editing via the terminal I just mount the server with sshfs.
nothing special, usually just textmate with IDLE open for the shell.
good ol' textmate
How is it that this article got a score of 366 with 132 comments on the programming Reddit, but barely registered here?
Because most people already said what they wanted to say there and saw no reason to repeat themselves.
gedit on Ubuntu with code completion, custom snippets, ability to edit remote files over ssh, todo list, external tools plugin for running code directly from gedit (a la textmate), ability to extend functionality using plugins written in Python, etc. I love it.
vim/gvim, screen, and [this](http://technotales.wordpress.com/2007/10/03/like-slime-for-vim/). makes a convenient environment for testing and playing around
&gt; Hopefully, with the new version of fabric, you can write a script where you just specify a host and it sets up everything for you. An even funner integration would be the ability to deploy a venv or a pip requirement file straight to the remote host (to another venv in both cases)
Huge TextMate fan :) TextMate does a great job as a file and text browser, especially when combined with command-line 'mate' launcher. $ mate ~/some-project/ Generally used in conjunction w/ Buildout so that I can repeat the install process in a local dev instance seperate from any production or test instances, so it's not necessary to use anything to remotely mount files (TextMate sucks over NFS, since it does a lot of stat'ing). 
Komodo Edit for all my interpreted language needs. IDLE if I'm just writing something quick.
You can do that already, I have my requirements file versioned so a push to the host includes the file, and it's as simple as installing it with one fabric command. In my original post I meant this, plus creating the webserver files and databases the app needs automatically.
Thinking hard.
iPython
``pip install -e svn+http://server/proj/trunk`` works wonders for me. And it can be run several times, such as when you need to regenerate your egg-info due to additional entry-points, for example. A simple ``svn up`` will do in the other situations. I've been running without setuptools' version of setup() for a couple of months, lovely; thank you ``pip``! And ``virtualenv``! 
Ahh, the Feynman Problem-Solving Algorithm: 1. write down the problem. 2. think very hard. 3. write down the answer
Lets see, which code is nicer? This: while 1: next = obj.next() if next is None: break next.do_somthing() Or this: for next in obj: next.do_something() 
Started using this last week and love it. Used textmate until the trial ran out, but will stick with the bean for now.
[bpython](http://www.bpython-interpreter.org/)! I develop primarily in emacs, but bpython is indispensable as a commandline option. You can actually save your session to a file, press up to edit previous lines, and even rewind to undo the last thing you typed if you messed something up
That's actually pretty clear. Kind of sucks how everyone has to be an ass when I ask a question, though. I guess I'll unsubscribe from /r/python until I'm worthy. I'll also be a gentleman and delete my post before it soils this subreddit further.
gvim+ipython
ViM or SPE (Stani's Python Editor) depending on the situation. Geany is nice too, but only for big projects. ViM is definitely the tool of choice for me.
What's worse than this is assigning the result of a function as a default argument. Since default arguments are evaluated at compile time you can only call functions which have already been defined (ie., occur above the function definition in question). This requires ridiculous source code reorganization. Eg. def debug(msg): print msg def nodebug(msg): pass def doSomething(dbg=debug): .... When one might prefer to place such utility functions (not to say cruft) at the very end of one's source. The code for my bachelor's project employed this trick of mutable default arguments but the drawback was that the default argument is really only evaluated once. In this case it was a co-routine (technically a bi-directional generator I believe) which apparently could stop due to an error condition at which case it needed to be reset. I presume this to be an instance of the singleton pattern.
I find that it really helps in Python (and in every language that I've worked with where functions are first-class) to really think of function definitions as the binding of a function object to symbol, just like you'd assign any other value to a variable. R in particular makes this extremely explicit, with functions being defined à la: foo &lt;- function (bar) { return bar+1 } (Forgive any minor syntax errors; it's been a bit.) To use something close to your example, if you think of: def debug(msg): sys.stdout.write(msg) as just syntactic sugar for debug = lambda msg: sys.stdout.write(msg) then it makes perfect sense why you have to re-order your code before you have a statement like def doSomething(dbg=debug): 
http://effbot.org/zone/default-values.htm
Know thy runtime model
pida, vim, mercurial, rope, virtualenv, pip
The wifi was HORRENDOUS. It mostly didn't work at all, when it did you were lucky for it to keep up for longer than a few minutes. This really confounded tutorials as you can guess. It was still an awesome week, but the wifi was crappy.
&gt; what is the reason for binding the default argument at function definition, and not at function execution? Well, the default argument is getting bound at runtime (not definition). My understanding is that the behavior stems from the following facts: * For arguments, Python handles basic types **by value** (lifetime: function call) and non-basic types **by reference** (lifetime: reference counting). * It seems to assign a static lifetime to default arguments of non-basic types. So when needs to use the default argument (non-basic type), it finds the one already allocated. Following demonstrates the difference in handling of basic and non-basic types. def foo(a=[]): a.append(5) print "foo:",a def bar(a=0): a += 1 print "bar:",a foo() foo() bar() bar() Results: foo: [5] foo: [5, 5] bar: 1 bar: 1 
There is no such thing as "definition time", every time is runtime. This behaviour (mutable argument handling) stems from the langauge definition. Python calls functions by reference (label). Period. Cpython implements some basic immutable types in cache(a=2;b=2;a is b;a=10**100;b=10**100;a is not b), but this has nothing to do with the function call. I recommend: http://video.google.com/videoplay?docid=7760178035196894549 
&gt;"For arguments, Python handles basic types by value (lifetime: function call) and non-basic types by reference (lifetime: reference counting)." The distinction is that the 'basic types' as you refer to them (ints, strings, etc) are immutable, and the 'non-basic types' are muttable. Everything is pass by reference in Python, the real issue is whether you can modify the object that you receive a reference to.
The timing of this thread is crazy, as I just ran into this issue late last night (I'm fairly new to Python) and couldn't for the life of me figure out why my empty default parameter list was unexpectedly containing values when I called the function. Thank you for the thread/replies!
It was good last year! (PyConUK) Perhaps it had to do with the number of participants compared with last year...
Indeed, and it surprises me that the other references only talk about the confusion; we teach it to people early because it's *useful* to have a near-equivalent of C's function-local "static" variables (though a memoizing decorator is better, it doesn't always fit the problem.) Also several of the comments talk about the argument being global - that's simply not true, it's not in the global namespace at all: def foo(bar=[]): bar.append(len(bar)) return bar print bar NameError: name 'bar' is not defined
From what I could gather they were indeed completely unprepared for the sheer number of delegates that turned up. The venue itself seemed way too small most of the time, the corridors were just full of people sitting on the floor.
They're not treated any differently by the interpreter, but it is still useful to distinguish between "code that runs when the module is imported" (like function/class definitions) and "code that runs when your app is actually doing something" -- load time vs. runtime.
+1 for bpython. I find that bpython has all of the features that I used from iPython, and them some. I know I'm not an iPython pro though...
In my humble opinion it is misleading to distinguish between load time and runtime. Consider for example a very simple decorator code: def traced(func): def wrapper(*__args,**__kw): print "entering", func try: return func(*__args,**__kw) finally: print "exiting", func return wrapper The definition of the wrapper function is not executed on "load time" but is executed on "runtime". So, the load time of a nested function is the run time of the module. I think this is confusing.
I think the point that slate's making is that there is no fundamental distinction between "load-time" and "run-time". Code in modules just tends to get executed before anything else, since the first thing programs generally do is import modules. I can certainly define functions outside of module imports, at what you're calling "run-time".
A lot of the rooms in the Birmingham Conservatoire are just too small. Really the whole thing needs to move into a University to get decent lecture halls or a hotel even.
I suppose it's a symptom of it being quite easy to write your own web framework. I look forward to each new web framework that comes out, I always go and have a look and see if there are any new or interesting ideas in it.
Ewww....this just led me to discover something I really don't dig about python. If python worked like other languages, this would be just fine: def make_incrementer(): x=0 def incrementer(): x=x+1 return x return incrementer foo=make_incrementer() foo() Instead, it pukes, because in python, there's no way for incrementer() to assign a value to the variable **x** defined in make_incrementer().
Yes, and now a proper fork: [distribute](http://mail.python.org/pipermail/distutils-sig/2009-July/012512.html)! Finger crossed!
I think they should do the following: add prefix '++' operator that triggers _SyntaxError: there is no '++' operator_. The same for '--'. It would be _extremely_ Pythonic.
The blog's title is unintentionally appropriate for the tone of this post.
vim + bpython
Actually, no, what you've show is unrelated to what the original topic is about. The problem with what you have is nothing to do the the assignment, instead it doesn't know where to pull x from to use in the expression x + 1. Note that this has been fixed in 3.0+: def make_incrementer(): x = 0 def incrementer(): nonlocal x x = x + 1 return x return incrementor() foo = make_incrementer() foo()
I know it's not what the original topic was about—that's why I said it led me to discover that. I saw that default parameters were being used for essentially creating "static" variables in functions, and I wondered why the usual approach that I'd use in other languages wouldn't work. A bit more research led me to discover PEP 227. Glad to see that this is changed in 3.0.
You can always use thunks if it bugs you so much: &gt;&gt;&gt; def do_something(dbg=lambda: debug): ... debug_func = dbg() ... debug_func("hello world") ... &gt;&gt;&gt; def debug(msg): ... print(msg) ... &gt;&gt;&gt; def nodebug(msg): ... pass ... &gt;&gt;&gt; do_something() hello world &gt;&gt;&gt; do_something(lambda:nodebug) Or you can just use `is None`: &gt;&gt;&gt; def do_something(dbg=None): ... if dbg is None: dbg = debug ... dbg("hello world") ... &gt;&gt;&gt; def debug(msg): ... print(msg) ... &gt;&gt;&gt; def nodebug(msg): ... pass ... &gt;&gt;&gt; do_something() hello world &gt;&gt;&gt; do_something(nodebug) 
I have worked on a python project called pyrit. It used to support using pysco, but recently dropped support. A piece of sse2 assembler code was added to a CPython library for 3x speed. Psyco caused the program to crash when the assembler was added. Another issue I have with psyco is that it is 32-bit only. All my personal machines are 64-bit. The one exception of a Core Duo Macbook Pro which is 32-bit only. Even that is used pretty much only by my fiancée at this point. This issue they seem to realize, and do mention. Though at this point it really should be their focus, not their after thought.
What exactly is so wrong with doing.. for x in range(10): operator.add(1, x) ..that you need to add a function to let you do.. addone = partial(operator.add, 1) for x in range(10): addone(x) ..? It might make sense in Haskell, but Python isn't Haskell.
Should be their focus? The work was sponsored by a company who have a business interest - what *should* be their focus is what they need. I'm grateful that a lot of us are able to benefit from it.
Hello Redditors, I've frequently felt a need to print large tree structures, such as parse trees, but have been unable to do that, because python's builtin *pprint* module doesn't support custom types. I wrote *xprint.py* to solve this. I hope this is useful to others.
Yes, I settled for the latter in the end. But the point is that there should be one way to do it, not tricks around it. I'll just have to adjust my intuition that this was the one way..
I get the idea that Python is the wave of the future. First pypy, then unladen swallow, and now this. Great news it seems.
I'll have to get time to continue testing with the pypostgresql dialect. There were a lot more test failures when I ran it which I have to track down. Since I don't know the nature of these test failures, its impossible to say at the moment where the issue lies or if it was just something silly, or how severe they are, hence I've had nothing to submit as of yet.
what would happen here is SQLA users would request that the SQLA dialect does what it has to in order to turn this debug output off. So at least within SQLAlchemy usage, it would like be a pypostgresql behavior that nobody sees anyway :)
 `+ ipython + bash + virtualenvwrapper + wingide
Not nearly as many features. ipython is an entire implementation emulating python shell; bpython just adds clear nifty features on top. ipython magic functions are truly magical; They literally _wrote_ the python functions for all your normal bash commands; What more even for the common aliases. Try ll on your ipython shell. Try %alias. You just pass a code object to the %ed magic function and it loads the vim (or your configured editor) to open that file at that point in the file. And then you can also see all your history of commands, the entire history of inputs and outputs, You can log it; log it in several modes; This is just things over the top on my head. But yes, I do accept that the bpython auto suggestion without waiting for the tab is even more user friendly. It even displays the function definition. So I think this curses concept has to be hooked up to ipython; because I want the best of both worlds.
pida loves you. But how does it auto complete?
I &lt;3 iPython and have been using it for a while. But the ability to see the arguments even without having to tab, _means something_ I am an iPython power user. I use all kinds of %magic functions, so I kinda have to stick to it for now; but I love the idea of bpython. I so want this curses concept and display while type to be added to ipython.
So, this looks interesting. Has anyone tried it out yet?
Very pythonic in that you refused the temptation to guess (how an object should be printed). By letting clients register their adapters, you've made it very simple and sensible. Well done! 
Python is the wave of the present.
since when is micro web frame work a thing?
Unfortunately, the new psyco is still slower than the old one for all my code, both with and without generators. I trust that future iterations will be faster. Thanks for the work you're doing on Psyco; keep it up!
I wish this worked in Windows, but apparently you need the curses library which doesn't seem to be available.
[This](http://adamv.com/dev/python/curses/)? Or is it not it?
Code may be modified to use that library, but it's no 'import curses'.
Ah, too bad...
Already tried and it doesn't work :(
cool one. installed and love it!
The best part is that it's a AK47 not an AR15.
Wrong subreddit.
&gt; the point is that there should be one way to do it, Well, if it were the other way around, how would you do static variables in Python? There would be workarounds with nested functions and whatnot, but it wouldn't be as clean… If I were re-designing Python from scratch tomorrow, I would probably reverse this design decision, just because it seems to trip so many people up, but I do still think it's defensible… (OT: but I think I would change it so that optional args are marked with a `?` like `def f(arg?):` and then if no arg is passed, it's set to a special `NoArg` object that you have to `if arg is NoArg:` yourself.)
Thanks!
I had to work with it for a computer security course. I didn't like it, but that's just my own personal opinion. If you need something to keep track of your work, I'd recommend emacs org mode.
the current dev version grabs autocomplete information from stuff like rope and passes it down to the editor i dont remember the details of the 0.5 series 
I have no experience with it, so I don't know if it'd work, but have you tried it with [Cygwin](http://www.cygwin.com/)?
I just tried it out for a while. It looks like it could be very useful, but the UI is too cryptic. It's an excellent idea, though. With some refinement it could be awesome.
There's been a lot of refactoring work to make it *possible* for further development to continue. Hopefully this means that there is room for more performance gains in the future.
Tried it yesterday - it seems kind of ok - a bit too complicated but probably ok once you 'get it'. I much prefer wikidpad as a note taking app. It's simple but very very efficient. I can link to documents, websites etc. in the text as needed, I can search for any phrase (i.e. full text search) in all notes. 
I've used it quite a bit for at least six years now. I don't use it as a program editor - but instead use it to keep track of notes. And for that it does well: #* multi-platform &amp; free - so I can give a leo file to a coworker and they can fairly quickly access the details #* hierarchical topics - with full notes attach to each #* cloning of topics - which allow a single note to have multiple parents The downsides include: #* printing is difficult #* can be slow for large files #* installation isn't trivial #* I *really* want columns All in all, a very nice free tool. I need to start playing with writing my own enhancements to it in python. 
No, haven't tried it yet. If I did, I'd probably have to re-install Python under Cygwin, which is just more bother than it's worth.
Actually, if you use ProcessPipeline or ProcessGraphline, if can happily use multiple cores, in CPython. Threaded components suffer from a GIL. Standard components are single threaded. However, we've realised that if like ProcessWrapComponent we had a ThreadedChassis - for taking a standard component and running it in a thread (safely), we could happy run our systems with arbitrary numbers of threads, and on IronPython &amp; Jython. Apparently Kamaelia runs cleanly on Jython these days, so it's a logical &amp; sensible thing to do. After all then many programs with this little/minor tweak would happily use all the cores you have on a system.
Oh, the GIL isn't such a big issue really because we're not tending to do CPU heavy work. For CPU heavy stuff we do want offloaded, we do that in a separate process.
Ah, the infamous "restring".
You tried org-mode, or Leo? 
This seems like a good idea. I've recently been working in Perl (ugh), and I miss almost everything about Python, except I love the ease of using regular expressions in Perl.
That seems really... odd. Wouldn't it screw with the interning of strings?
Mutable attributes on immutable objects? Yeah it probably screws with a lot of stuff ;)
Totally need `.fnmatch()`, those handy `string` and `unicodedata` constants, `.zlib_compress()`, and while we're at it `import pickle ; obj = pickle.loads(s)` would be way awesomer as `obj = s.loads()`. Oh, and `.html_escape()`, `.sh_escape()`, `.urlencode()` and `.parse_query_string()`! Conclusion: packing this gunk inro `str` might save typing, but it's an evil precedent that contributes to software design for generations as beginners see their language taking bad shortcuts. Modules (and types proper) exist for a reason :) I've been annoyed in the past with having to need a temporary 'match' object, but the problem is not the string type's API (let's also not forget there are two of them), but the re module's API. Perhaps context manager abuse could help? with re_context.match('^blah', s) as match: if match: ... else: ...
I'm guessing the `match' object is there because writing if line.re.search(r'Date: (.*)'): print line.re.group(1) is asking for a race condition to happen.
I've never understood the desire for automatic API-documentation tools. Yes, you should have useful docstrings, and yes these tools will pull them out and organize them nicely for you, but that's a far cry from "documentation"; it's just "here's a list of classes, methods and functions". It doesn't tell you things like what you'll need to install/configure, high-level overviews of the various parts, recommendations on how best to use things, etc., and those are often the most useful bits of documentation to have (especially since `pydoc` can get me your docstrings once I want to dive in to specific bits).
We are working on 'cusswords' which will be an API against the Python curses module but on a much higher level. It will, in the end, replace bpython's raw curses calls. Hopefully we can add support for cygwin or anything through cusswords, however, the native command line of Windows is very limited.
Damn Python fanatics hiding *seldom-used things* in *modules*!
As an aside, I'm surprised there isn't a python package system called ["la vache"](http://www.youtube.com/watch?v=YV0LGMGuLN0).