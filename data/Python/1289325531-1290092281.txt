interesting, thanks for the info
To "get my job" I had to start my own company. :) I would say the most important things are a community of people that you can get feedback from and learn from, and an ability to figure things out as you go along. If you can do that, you're probably fine without grad school, but it's hard to say. I got a Ph.D. ... that was overkill, but for the most part it was fun. 
Image processing can work well under the right conditions, but I've had better luck using capacitive sensing. This uses a hardware platform called Sensetable. 
Have you tried PyQT?
I have but was using a maemo build at the time that didn't support QT yet.
So apparently it is doing this (unrolled) &gt;&gt;&gt; t = ([],) &gt;&gt;&gt; l = t[0] &gt;&gt;&gt; l += [2, 3] &gt;&gt;&gt; t[0] = l Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignment The tuple is immutable so it won't take an in place add. List does an inplace add, but the following assignment to the tuple fails.
It also throws an exception when you have len(y) != 1
I actually find list comprehensions to be perfectly comprehensible. That particular line isn't the best example, but in my own work, ~90% of the time, a list comprehension is just as legible as a (series of nested) for loop(s). For what it's worth, I was mostly addressing the assertion that the code in question would "not run any faster" than the equivalent non-one liner, which was false.
I have used Chaco and Trait libraries from enthought with pyserial + pyVisa combo to get most of my work done.
The size of the list *could* be relevant in some cases--if it's really big. True, this doesn't come up all that often, but when it does, it might be preferable to modify the list in place rather than make a copy. Of course, a wholly different approach might be indicated, but there's no way to say without knowing what the code in question is supposed to do.
That is so cool, I would love to play (and learn) with that!
Were you doing image-processing stuff? How about buttons, sliders etc? I will be creating software for other scientists to use, so I want something thats nice and friendly to use.
traits and traitsui take care of all that for you. if you can install EPD (enthought's python distribution, complete with most/all libraries you'll need) it'll be easy to deploy your code to multiple machines. the enthought tools also have something called codeblocks i think, i don't recall exactly. but it's a way to wire together blocks of code like labview. i'm not sure how mature or maintained that particular code is though.
Awesome. Thanks. One last question and sorry for turning this into an AMA, but at what age did you start your company? If you are shy or can't say, can you approximate?
I started when I was 29. (I'm 33 now.) So, if you start straight out of school, you'll have a 7 year head start on me. :) 
No. think I got it form the output of the indicators function. Yet I did not fully understand it so I must have done something wrong.
Not always. See [this topic](http://bytes.com/topic/python/answers/36581-list-comprehensions-performance).
Do you keep an eye out for tender requests from places, or are you generally approached first?
You're absolutely right. I tried this on a range of 1 million and my solution suffered terribly. Thanks for pointing that out! Now you can ask me if I learned something :)
That code works even if `y` is not a sequence (in other words, `y` doesn’t implement `__getitem__`) but just iterable.
I need waaaaay more detail than that i'm afraid :) It looks amazing. Also this is a whole IAMA thing, someone will ask eventually so I may as well do it.
Generally I get approached first, but I'm trying to be more proactive about it now...
Who said anything about for loops? def get_server_string(self, servers): whatevers = (server[1] for server in sorted(servers)) return ', '.join(whatevers) #... ts = self.get_time_string_from_timestamp ss = self.get_server_string items = sorted(self.combined.iteritems()) jsvalues = ('[new Date("%s"), %s]' % ( ts(k), ss(v)) for k,v in items) data = 'var data = [\n' data += ',\n'.join(jsvalues) data += "];\n" or minimally just write it like data += ',\n'.join( '[new Date("%s"), %s]' % ( self.get_time_string_from_timestamp(k), ', '.join(server[1] for server in sorted(v)) ) for k,v in sorted(self.combined.iteritems()) ) 
I love it. What else is there to say?
One more suggestion. Have the get_indicators, etc. loops over all pages. there is n need to get one page at the time. very useful. I am downloading the entire database now...
Glad you like it! My tools are basically along the lines of PyOpenGL, but OpenGL support is rolled into openFrameworks, so I get it from there. openFrameworks is a C++ library, but people have wrapped it using SWIG to use it for python stuff. This way, you can render quicktime movies to an OpenGL scene with just a few lines of code. Built into the table is a capacitive sensing circuit which I developed called [Sensetable](http://www.pattenstudio.com/projects/sensetable). This tracks the objects on the tabletop, but to draw graphics around the objects, you need to convert from the coordinate system of the table to that of the video projectors. That's what the matrix math is for. Not sure if the above info is helpful, but if you have some specific questions I can try to answer. If you're curious about this kind of work in general, looking at PyOpenGL would be a good place to start. HTH
Why don't you do: temp = x[:] temp.append(y) for i in temp: ... print i ... 1 2 3 4 
I blogged about idiomatic Python here (with code examples) here: http://www.pixelmonkey.org/2010/11/03/pythonic-means-idiomatic-and-tasteful I also particularly like this in Python: if 0 &lt;= i &lt;= 10: print(i) People often forget that the comparison operators are chainable. And properties -- @property is good stuff, especially @property, @x.setter and @x.deleter. Love it.
Excellent, thank you. Now to go make use of it!
You can say x + [y]: otherwise you're creating a tuple of a list and int which then in turn **for** will only iterate over 2 items e.g., ([1,2,3], 4). You can also just loop over x and use y at any point. 
How much can a multitouch screen that big cost? And where did you buy it? It amazing, thanks for sharing!!
You just shouldn't modify a list while you're iterating over it. If filtering the list (and perhaps transforming the remaining elements) is all you need to do, list comprehensions are the right way. If you do need to do additional operations (like printing in your example), just remember that appending elements is much more efficient than removing them anyway, so iterate over the old list and append to a new list (in my example I'm giving the old list a new name and then assign the new list to the old name to achieve the same effect in the end that your example was intended to have): lst = [1,2,3,4,5] old_lst = lst lst = [] for i in old_lst: print i if i != 2: lst.append(i) EDIT: explanation added
BlockCanvas, in the [CodeTools](http://pypi.python.org/pypi/CodeTools) package. It's really more of a tech preview than a mature library. While it has its use cases, I doubt this is one of them. It doesn't look like Reddactor cares too much about the visual programming aspects of LabView. I will also note that Traits won't help with the image processing, but there are plenty of [Python image processing libraries](http://pypi.python.org/pypi?:action=search&amp;term=image+processing&amp;submit=search) around. Our plotting library, [Chaco](http://pypi.python.org/pypi/Chaco), is good for putting up those images and interacting with them.
 In [6]: def flatten(seq): ...: """ ...: Flattens an array or tuple into a 1d list ...: """ ...: ...: ret = [] ...: def _flatten(seq): ...: for i in seq: ...: if isinstance(i, (list, tuple)): ...: _flatten(i) ...: else: ...: ret.append(i) ...: return ret ...: ...: if isinstance(seq, tuple): ...: return tuple(_flatten(seq)) ...: ...: return _flatten(seq) ...: In [7]: x = [1,2,3] In [8]: y = 1 In [9]: z = 'b' In [10]: flatten([x,y,z]) Out[10]: [1, 2, 3, 1, 'b'] In [11]: save the flatten function for later. or if you don't care about how deep it is nested: import itertools a = [1,2,3] b = 'f' for i in itertools.chain(*[a,b]): print i 
Thanks! Glad you like it. Technically, it's not a multitouch screen, because it tracks tagged objects rather than finger touches directly on the screen. (For a few reasons, people tend to find this approach, called a "tangible interface" easier to use than multitouch.) The sensing system is called [Sensetable](http://www.pattenstudio.com/projects/sensetable). My company designs and produces it. 
Yeah, sorry, I just read that on your site... So, can I ask what technology do you use to track the objects? Because I don't think it's RFID...
That is awesome.... good work! 
Thinking about it... what would you get if you took one atom of each element in the periodic table and mixed them all together at the same time...?? report back!
The Sensetable link above has an overview of the tracking technology. 
Is this Open Source by any chance. Heck even if not Id pay to play with this on my PC or phone (n900). 
Wait, how do you know how old I am!?
 things = x + [y] for thing in things: print thing
Well, for me, I glanced at it, thought "What's that for", looked at the second version, thought "Oh right", went off on a brief tangent about [the implications](http://www.reddit.com/r/Python/comments/e3er9/what_nice_python_idioms_are_you_particularly/c14zfki) of identity vs equality and None's singleton nature, and eventually concluded it was probably pretty safe but I'd rather just see the second version and not have to do any extra thinking. Chacun à son goût I suppose.
enumerate over your list to get the index to every element. for i, e in enumerate(lst): i is the index and e is the element. Then just say lst[i] = e_modified That should work simplest.
No need to pack then unpack a list. Just provide the components individually: for i in itertools.chain(a,b): print i The above only works because b is a string, which is a type of sequence (and thus iterable). If b=2, say, you'd have to write this: for i in itertools.chain(a,[b]): print i But if you know the types of a &amp; b, and they're not too big, this is easier: for i in a + [b]: print i 
but in his case the tuple is never going to contain constants, since he wants to check whether or not any of the variables are None ...
If you're really that worried about performance why use Python.
I tried unsuccessfully, Using my example ['a','2','j','3','b','c','1'] how would you use this method to place an 'x' after each 'a,b or c' only if they are followed by '1,2 or 3' so that the list would become: ['ax','2','j','3','b','cx','1']
I was making a lot of assumptions... sorry. :)
L = \['a','2','j','3','b','c','1'\] m = ('1','2','3') for i, e in enumerate(L): if e in m: L[i-1] = L[i-1] + 'x' print L ['ax', '2', 'jx', '3', 'b', 'cx', '1'] Had to fiddle with the formatting a bit, but that should work. EDIT: Heh, missed the part that you were only looking for a,b,c - vbgunz's post below covers it though.
 lst = ['a','2','j','3','b','c','1'] tc1 = ['1', '2', '3'] tc2 = ['a', 'b', 'c'] last_e = object() for i, e in enumerate(lst): if e in tc1 and last_e in tc2: lst[i - 1] = '%sx' % last_e last_e = e Check that out. I hope it makes sense.
 L = ['a', '2', 'j', '3', 'b', 'c', '1'] for i, e in enumerate(L): if e in ('a', 'b', 'c'): if L[i+1] in ('1', '2', '3'): L[i] = e + 'x'
forgot this :) &gt;&gt;&gt; L ['ax', '2', 'j', '3', 'b', 'cx', '1'] Looks like it should work.
I've started to think downvotes on submissions are equivalent to the background radiation in space. They're just *there* and you can't really do anything about them.
I Love science museums!!! awesome. 
This is really cool - good work!
Why isn't this more popular? It seems it'd be a great way to develop apps interactively. Though, it appears to dislike threaded programs :(
That's gotta look pretty bad-ass on any resume. 
Thanks, that's perfect. I understand it mostly, 'object()' is the only command I'm not that familiar with. I'm curious, is there a way to make tc1 any element in a list that ends in the number 1, similar to how it is done with regex searches? 
Thanks, this also works perfectly. I kind of feel dumb now for not thinking of using L[i+1] to identify a pattern.
Fantastic!
1. Is Python your primary language of choice? 2. What other languages do you use besides python for work? 3. Are there any other examples of you work on the internet we could take a look at? 4. What OS is this running under? Checked out the Sensetable website some pretty awesome stuff. You have the one of those programmer job that 98% of coders aspire to and these types of demos give us hope.
A user here by the name of fishdicks put me onto using object() as creating a unique sentinel. Basically it means creating an object that is unique (a sort of flag object). e.g., I could have chosen None or 0 **but** what if you had 0 or None in tc2? Outright confusion. By making the first value of last_e object(), I pretty much insured that value is never in tc2 so no confusion. As for the rest of what you're asking I can't make it out. Sorry :/
You are a gentlemen and a scholar. All my if statements are horrid garbage now.
When the circumstances allow it, Python is my favorite language to use. I do a fair amount of embedded development (AVR and friends) and for that I use C, or if the going gets tough (cringe!) assembly. For normal stuff, I try to do Python first, and if it's not fast enough, even after profiling, I'll rewrite some of it in C or C++. Often, when a project requires C++ for some reason, I may write a throwaway prototype in Python first. [Here is my portfolio](http://www.pattenstudio.com/projects) and [my blog](http://jamespatten.tumblr.com/tagged/pattenstudio) which shows some works in progress. This is running under Windows. Normally I prefer to develop under Linux or MacOS but in this case the museum required that all computers coming in the door be running windows. The AV company that supplied the computer for the exhibit gave it to me with a specially tweaked version of Windows XP that seemed to be much more well behaved than what I'm used to. Thanks for checking out the project! Glad you like it. 
psycopg2 for its gevent support, otherwise im pretty indifferent
You'll probably see a dispatch pattern more than your pattern: handlers = { 'error': my_error_def, 'end': my_end_def, }[status]()
Man! This is awesome! *Nice work!* The only nit I could possibly make (and it is petty) is that using two projectors at different angles would remove the hand shadows. But, wow, this is cool.
I didn't know about the setter/deleter thing, but the result doesn't seem all that elegant compared to the usual `blah = property(_get_blah, _set_blah, _del_blah)`. Usually if I need a data descriptor I will write one myself as a separate descriptor class.
Since what you describe is exactly its use case, have you looked into using [Cython](http://www.cython.org/)?
BASH has it as well: `for i in {1..10}; do` echo $i `done`
Is there any time that you would realistically override __eq__ to make it return True when you compare to None?
You want to return chain(new_num) at the end, not simply call it.
Thank you master.
Yeah, its -very- powerful and worth your time learning, although the learning curve can feel a bit steep, at times. I would have a very hard time moving back to MacOS or Win because it feels so restrictive after using linux. That being said, the software that I've had the hardest time replacing is ArcGIS, I've only *just* been able to go ArcGIS-less.
You hiring?
Python just became an [Ouroboros](http://en.wikipedia.org/wiki/Ouroboros).
Where is the version for my computer or Droid?
I looked into Pyrex awhile back, but didn't get around to using it for anything. Cython seems like a handy tool. 
I suggest taking a look at some code I [wrote for this very purpose](https://github.com/sethwoodworth/collect_phil_cdc). I also used it to scrape a site (public domain) that had about 35000 pages (and high res images). I'd be happy to answer questions and walk you through some of modules and reasoning in the code if you're curious. PM me and I'll send you a phone number or skype.
If you want something really impressive check out ksplice. Hot patch a running linux kernel.
Is that supposed to give a boner? Just curious. That is awesome work!
I think unladen swallow was abandoned because it couldn't compete with PyPy. PyPy is the future of Python. Aside. When will I be able to compile PyPy with my 2GB RAM laptop?
Here are [some links about Cython](http://keithdevens.com/weblog/archive/2010/Oct/28/Cython) I saved a couple weeks ago you might be interested in, fwiw.
Really cool!
Some web frameworks have this built-in so as you write code and save it to disk, it will reload as needed.
This would be even better if, instead of doing a check every *n* seconds, it used a file [write|close] event callback. That way, it only performed its checks when the files of interest had been updated.
Besides the excellent PyQt (or PySide these days), you'll need various interface modules like pyserial, depending on equipment. The PyQwt widget library for PyQt provides many widgets that one might find useful at the lab, as well as a plotting library which I found much snappier than matplotlib (although definitely less gorgeous)
&gt; I think unladen swallow was abandoned because it couldn't compete with PyPy. It wasn't "abandoned", it'll most likely end up merged in CPython 3.3.
I hope so. But it looks like it did.
This seems to come up every few weeks, but the Google engineers who were working on the project have moved onto other projects now that U-S got where it did and was accepted to be merged. I guess it's "abandoned" in the sense that none of the core people are working on it full time at the moment, but the project certainly is not forgotten, and it will be up and running again in the near future.
Heck, this sounds interesting so I might even like to help you out. I had a job where all I was doing was scraping website in python, and it was actually quite a bit of fun. Anyways, down to business. My recommendation is to go with urllib, lxml and pyquery (if you know Javascript then you'll love PyQuery as you can select html using the JQuery selector syntax) lxml is written is C, so you'll need to follow the equivalent steps on your machine to get it installed and working: aptitude install libxml2 aptitude install libxslt aptitude install [libxml2-dev] aptitude install [libxslt-dev] aptitude install python-dev (python development headers, you'll need these) aptitude install python-setuptools (gives you easy_install and a way to install python packages from pypi, including lxml) easy_install lxml You can adjust the package manager to be the one on your machine e.g. using yum instead of aptitude. Also the package names may vary depending on what Linux flavor your use, so you may have to do a search on the repository using something like apt-cache search &lt;something&gt; or yum list/search &lt;something&gt; I gleaned the lxml install instruction from &lt;a href="http://www.google.com/url?sa=D&amp;q=http%3A%2F%2Ftightwadtechnica.com%2F%3Fpage_id%3D4163"&gt; here&lt;/a&gt; if you want more detailed instructions. Once you have those 2 things installed then you can do something like this in your scraper: import urllib from lxml import html from pyquery import PyQuery as pq if __name__ == '__main__': url = "http://websiteOfInterest.com" response = urllib.urlopen(url).read() dom = html.fromstring(response) d = pq(dom) tables = d("table") for table in tables: d(table).children().... # you get the idea If you find that urllib isn't working quite right, look into using mechanize's Browser class. It keeps track of your cookies and you can set the headers to fake Firefox, etc, if the site you're scraping is on the lookout for bots. As for xls stuff I don't know, but I hope that this gets you started on the scraping stuff. Good luck, and feel free to send me a message if you want more info. 
haters gonna hate.
Fair enough; though that was in 2.4 - I haven't heard much about 2.6 or 3.0.
Yes. Use Python. We do the same (on a professional basis). The key libraries are: - numpy - scipy - matplotlib - Enthought Tool Suite (Traits/Chaco/Mayavi) - VTK - PyTables - wxPython/PyQt (I prefer wx, but Qt is an increasingly compelling option) If you use NI-488 (GPIB), I think there are already python-bindings available although we rolled our own using the cytpes module (you only need ~ 3 function calls to make this work). We also used ctypes to wrap the NI-DAQmx libraries for IO cords. NIDAQmx is a large API but you can wrap it function-by-function as you discover you need them. Sadly, our code is not open-source so I cannot share it, but there's nothing magical in it. ctypes turns each API call into a python one. One could probably automate this with SWIG but ctypes avoids the need for a compiler. Just say no to Labview.
If you have a 32-bit system, you can definitely compile PyPy with 2GB of RAM already now. If you want to compile a 64-bit PyPy, you can try to disable some modules, it should be enough to keep the translation under 2GB.
You can translate it today, just don't expect to be able to use it during that time :-). I've done it plenty of times with 2gb, but once you start swapping you're screwed, so you really need to leave it be. This is what motivated me to take some old hardware and make a buildbot server type thing.
There are hundreds of posts about this in the wxPython user mailing list archives and in the py2exe mailing list. It's a combination of both msvcr90.dll and manifest file. A pox on Python for moving to a version of MSVC that requires the manifest file. But check in the archives for both of these mailing lists for insight into the MANY issues with manifest files and DLL files.
It's probably not too likely in practice. One thing I can think of is if you have a set of (programmatically generated) rules that inputs must match somewhere, and you want a case where anything is allowed, where you could potentially use an "equals everything". Overloading `==` for this isn't really good style, and it's not going to be common, but it is a theoretical issue. An alternative possiblity would be something that actually *forbids* `==` by raising an exception in `__eq__` (the same way complex numbers do for `&lt;` and `&gt;`). You might want to do this if modelling a "null" or "NaN" type object, and want to be sure it never gets compared to something real. (Alternatively, someone could have got lazy and defined an `__eq__` that doesn't first check the type, and throws an exception unintentionally when compared with None)
They're designed to be used as decorators. Eg: class Square(object): @property def perimeter(self): return self.size * 4 @perimiter.setter def perimeter(self, value): self.size = value / 4.0 The alternative is using property directly, which means you have to define temporary functions (in some namespace that won't clutter up the class's) and then create the property from it. The decorator way has less clutter.
You probably want to switch these imports: try: import json except ImportError: import simplejson as json since simplejson is the optimized and fast C-version.
It also didn't come nowhere close to it's stated goals. The merge is pending provided it'll speed things up (in PEP speedups are modest and memory consumption is huge).
Very interesting. Do you need to use PyQt and traits together? After reading the tutorial on traits, it seems to be a complete system. Do you prefer Chaco or matplotlib? I want something up and running ASAP, so maybe I don't need all the features of QT for this project. 
That right, I don't really care about graphical programming, although I don't mind using it if it's available. Do you think I should skip the Qt stuff and do the whole project with traits? 
No need to duplicate work, try http://bitbucket.org/iElectric/python-crontab-docs/overview
This is awesome. Does anybody know of plans for pypython 3?
I don't understand why there are so many downvotes. Are we against noob questions here?
there is no "typeof(x)" in python, I think you meant "type(x)"
I never knew max/min had a "key=" parameter. Will use.
currently, we have no immediate plans for Python 3. The current focus is to become usable (and used :-)) for Python 2
I love the MOSI. How come they didn't hire me for Month in the Museum?
Because it may not work as you'd expect. The builtin `reload()` function reinitializes a module, but does not touch any instances or references in other namespaces. If you instantiate a class and then reload the module that defined the class, your instance stays the same. You have to re-initialize it to get the new behavior. If you use `from ... import ...` the imported objects are immune to reloading, too. Some hotswap libraries try to fix this by monkey-patching module-level instances, but nested structures are a problem. Even if someone manages to monkey-patch each and every object in the entire python process, you'd still have to deal with inconsistent state. Welcome to debugging hell. The only reliable way to 'reload' a modified module is to restart the entire python process. [Bottle](http://bottle.paws.de) uses this approach and it works quite well (for web applications). 
Checks are cheap and file event callbacks depend on OS support.
i dont think it is quite that easy. lots of people install python from the packaged versions provided by their distros and such. 
Doesn't bother me personally, The internet on a whim shames those who lack knowledge, reddit is no exception. Having said that, the question's not worth up-votes either. I'm just glad my question was answered. 
Why would something this cool have 50 downvotes?
I'd be interested to see how it goes using Sikuli. I've done something similar myself (although a rather different game) using Python + libraries and am in the process of writing it up.
Yeah, I wouldn't expect it to be popular, I think 1 upvote and 1 downvote would have sufficed. (it was about 1 up and 5 down at the time I posted the original comment btw)
And fast :-) There is a 2.7 branch which will make a first step towards python 3.
While I know exactly how to plan it out, I am currently limited by my knowledge of Python syntax and all the new things that are different from PHP.
cool! Thanks :) I haven't learned any BASH before but I've heard it's fairly easy if you know python.
I use Sikuli all days long, using jython in an external editor (coz' the IDE is buggued) : it's perfect for this kind of task
This is a really cool app, I am amazed about the impressive interface and tech it incorporates, so congratulations! But I just can´t think of many useful applications of it. There´s not enough info and it´s too flashy for real scientists to use, and there´s not much to learn for students. A hands-on approach of experimenting is much more efficient from a teaching aspect, simply because a) it´s "real" b) it takes time to prepare for and make the experiment, so it becomes memorable. Sadly it seems like a flashy application to quickly impress students, but nothing that could be used as learning or teaching material. Once again, I still think it is very impressive and I congratulate you for it, but also way too expensive and sadly bit pointless; your skills could be better used at other projects. I suppose you didn´t think of the idea yourself, and you had to do something educational with your table.
There isn't. There's not likely to be. It'd be like trying to measure market penetration for free linux desktop distros. One way to look at the trend is to look at the growth in Python 3-supporting modules, because those modules become dependencies in other projects, and keep projects from moving to Python 3. The Pypi index for Python 3 packages is woefully small -- it fits on a single page. http://pypi.python.org/pypi?:action=browse&amp;c=533&amp;show=all I wish I knew what kept module authors from porting to Python 3. For modules I've authored (I'm no saint in this), I guess I don't consider it a huge priority because I'm the only one using them (as far as I know), and other modules not porting to 3 acts like cement boots keeping me in 2.x land. I'm working on a module now that I'm going to port to Python 3 extremely soon, though, so at least I'm going to make the effort. I hope more do it too, because Python 3 has so much awesomeness it'll give you chills :) 
 def import_string(import_name): """Imports a module then returns it by a given ``import_name`` string.""" return reduce(getattr, import_name.split("."), __import__(import_name)) 
Incredibly cool. 
You could poke around [http://www.python.org/webstats/](http://www.python.org/webstats/) and gather some information on the downloads of the various versions over time. That obviously only covers python.org downloads, but you'd also want to know about ActiveState downloads as well, since they are pretty heavily used at least in the Windows world. There's also, as stated in the other comments, the whole Linux world, where most people are picking it up from their distros. Although the number is very small, [Python 3 packages on PyPI are rising](http://dev.pocoo.org/~gbrandl/py3pkgs.png). I've seen a few packages which support 3.x but are mis-categorized, so the number is probably a little higher, but not significantly.
&gt; I'm working on a module now that I'm going to port to Python 3 extremely soon, though, so at least I'm going to make the effort. Excellent. What module is this?
Distro installation is a big killer. Sure different installs exist side-by-side often, but if I have to compile a library for one install vs. using apt-get for the other, whenever I don't have all the time in the world I will stick to apt. So basically always.
Stuff like this amazes me. You more than likely changed a number of kids' lives with this. Well done.
I believe it's supposed to be syntactic level only; JavaScript has a `typeof`, so I presume it's just a lightweight syntax atop JS (which the main page attests to, sighting CoffeeScript as inspiration). 
well, it's only used by me, and it's not ready for prime time or anything, but it's called TimeMachine. It's just a collection of date manipulations that I find useful. At the very least, it needs to support a dynamic start-of-week day before I do anything drastic like posting it on pypi. For now it's on github: http://github.com/bkjones/TimeMachine A small effort, but effort nonetheless. :)
Good point - I hadn't considered that tons of packages leave the 'Py Version' field on PyPI blank, for example. 
why does he use sage to do anything? i understand using it to do actual work, but why use sage to run cython?
Would you say Scrapy is the best option for a python novice?
appengine.
 try: if os.stat(file[:-1])[8] &lt;= os.stat(file)[8]: # This module is unchanged if the .py-file # is older than the compiled .pyc or .pyo file. continue except OSError: continue After reading the source, I see it's just doing a stat on each file it's watching and its compiled counterpart. That is indeed fast! I thought at first there were higher-level directory scanning operations taking place that would have been costly.
FWIW this was posted months ago but apparently had no (good) answers. It seems interesting now, so I reposted it...
good
Using a list to implement a linked list sounds incredibly stupid to me. Try reading [this](http://greenteapress.com/thinkpython/html/chap17.html) instead. It looks much saner than the linked list implementation you found.
lists are already implemented in Python... If you want to understand lists, and learn why do they exists, you must implement them in C
The problem is with the version of msvcr90. The dll from a win7, vista, and xp machine are all different. locally, as in on your system, you need the correct dll for the windows 7. If you plan on distributing this program to others, once you successfully have the binary built, look through the dist folder and remove any of the windows specific dlls such as msvcr90
Thanks, I already tried to use this approach but I couldn't figure out how to move among the nodes, hopefully this text makes me figure out how to finnish it
I know, Python doesn't even use pointers but I guess it's too late for me to start using another language at this level :(
print map(lambda x: x.upper(), ["one","two","three"]) can be reduced to print map(str.upper, ["one","two","three"])
I'd say Wordpress or plain HTML might be a better way to solve the problem. It might be a decent exercise, but at first glance it seems a bit too simple. Maybe it would be better to try something a bit more complicated.
It looks like you are using a list to represent a pair (where perhaps the first element is the item in the list, and the second is the remainder of the list). But then things get all confused from there, especially because you are using a list as a building block for building lists, and because you are thinking in terms of pointers (which are implicit in Python), and because you aren't specifying what your data structure means. Creating some functions, even really little ones, will help you clarify your own thinking here. For instance, here's some functions I'd define for a linked list: list_item, list_rest, is_empty, list_length, and maybe map or for_each (which are going to require some more thought, as they require taking functions as arguments). Also these could be methods if you make a list object (which may be a lot clearer generally, as suggested by mikm).
Yes I know. I just take every chance I get to point out that languages don't matter all that much and people should focus on efficiently getting their problems solved. Very often best way is bash and in general the unix philosophy.
Okay, as you know the point of a linked list is that you have a series of nodes and each one has a "next" pointer to another node (or no/null next pointer, for end of list). And as you know, Python does not in any trivial way provide access to raw memory addresses. You could simulate memory addressing with an array, but it's not necessary. I suggest creating a Node class of some type: class Node(object): """Represent one node in the linked list. the text attribute is an arbitrary payload of data - you could use anything instead of text. The point is the next attribute. """ def __init__(self, next=None, text=""): self.next = next self.text = text Now you can set up the linked list by having each node point to another node: d = Node(next=None, text="d, the end of the line") c = Node(next=d, text="c, just one more") b = Node(next=c, text="b, now we're getting somewhere") a = Node(next=b, text="a, the beginning") This is how I would traverse such a linked list: node = a while True: print("Pompous Text: " + node.text) if not node.next: break node = node.next print "End of list" Doubly linked lists will also have a "prev" attribute in addition to the "next," allowing backward traversal and making some operations on the linked list a little simpler or faster I reached this understanding of linked lists by writing them many times in C and I recommend C to you whenever you have the time to really learn what you are just breezing through now. Learning Python very well (tackle some projects and read all the standard documentation) is going to be more immediately valuable to you now.
Oops, I wrote basically the same approach before I saw this linked. 
You can put links in a static HTML page. That would be useless from the standpoint of learning Django. If you wanted to, you could use this as an exercise to learn the Django template language (e.g. writing a base template and having other templates inherit from it). and some very basic setup that any Django app will require. That's not totally useless. However, if you want to learn Django you should do something that includes a range of exercises like these: * Collecting input through forms and validating the input * Storing data in a database * Retrieving data stored previously * Displaying retrieved data in a template, e.g. in a table with rows of alternating color * Setting and/or reading cookie values and/or other session mechanisms So you might want to change your idea to be something slightly more ambitious, like a website where you can go to a form to add new links to documentaries, and categorize them, and then your app can load and display them according to their categories. If you like the result you could track which user added each link, allow links to be rated, show little cover images, whatever.
[this](http://radbox.me/) does what you ask. It is made with web2py.
Getting a Wordpress blog into the shape you want might conceivably provide practice with basic PHP and CSS, but it won't really help you learn how to make web apps more generally, and it won't help at all with Python.
That depends purely on whether you need to do projects with DB2, and think Python is a reasonable choice for those projects (e.g. your shop doesn't care what language you use and you like Python, or your shop uses Python).
I think it sounds like a fun way to dive right in to Django! While Django is probably overkill (static pages or Wordpress would work just fine), it is a practical project that isn't overly complicated. I "learned" Django making a site related to [my favorite vintage computer](http://rainbow-100.com/). Again, I think designing the Django apps involved taught me a lot about the framework while keeping my end goal attainable at the introductory level.
The REASON is that if you don't return a value from your function, it automagically returns the value None (which is the only value of type nonetype). This fix works because you provide an actual return value, so it stops returning None.
What's wrong with the logging module in the standard library? Getting too fancy with logging is counterproductive when it increases the risk that the logging will fail as you are trying to report an actual problem, or bringing your app down even when nothing else is going on. You want simple and well-tested here, IMHO
I agree, I just wanted to point out that it's probably not the kind of problem that's best suited for Django.
Scraping requires you to understand what is happening in the code which scans or parses the HTML you retrieve and it requires you to understand your tools. You will need to learn the right approach the hard way. People are pointing you to useful tools like beautifulsoup, scrapy, urllib. You just need to try to use them. Until you have more specific questions there is not better guidance you can get than which modules to start with.
Thanks, I didn't know the variables could be used as pointers before your comment
You would implement that as all(item is not None for item in (foo, bar, baz)) or not any(item is None for item in (foo, bar, baz))
Yeah, but then you'll be sad when you pass in a unicode object and your code dies (if you're not using python 3).
Thanks a lot for helping me directly with the code!, I'm glad to know that I got the class right...at least, I will try to run and debug this code now :)
This is doomed unless you really understand what Python is doing. Those are not variables and pointers. They're references. Moving those around will be tricky if you are trying to get something else done. Use C if you want to understand linked lists or other data structures. Use Python if you want to get shit done.
&gt; Use C if you want to understand linked lists or other data structures. I came here to say this. python is essentially a scripting layer for C.
I understand that. But at least say why you are down voting. Maybe it even should be compulsory to leave a comment when you down vote!
Great link! My suggestion to the original poster is to read the link and then implement a single linked list that behaves the same as python's built-in list()'s methods. Specifically: append count extend index insert pop remove reverse __getitem__ __setitem__ __len__ __iter__ sort Some of these are going to be extremely inefficient compared to the list counterpart, but a few of them will be more efficient (notably pop(0)). Save sort for last as it will almost certainly be the hardest. Then if you're feeling adventurous, implement a doubly linked list and do it all again.
Or, use C to get shit done with an anal amount of control. I love using python, but I would feel ripped off if my undergrad did not tackle C. 
I strongly disagree. It's possible to implement a class based linked list type in Python that will illustrate the relevant concepts. See http://wyattbaldwin.com/2007/04/25/fun-with-python-bdd/ for an example.
[You can use Python to learn about linked lists.](http://www.reddit.com/r/Python/comments/e44gx/can_anyone_help_me_with_an_implementation_of/c155eos)
While I usually scowl at "anal retentive" or other Freudian references in everyday speech, I can not help but associate C with anuses, so I will agree with you instead.
I have nothing helpful to add except don't name a variable 'list', you lose the list() function, which constructs lists from other sequences. 
Well, the blog *is* about Sage, so that might be one reason, but he has a "History" section in a previous posting: &gt;Greg Ewing wrote "Pyrex" in 2002--2004..., which I guess he named after some cooking ware. It is amazing, but to understand this you must take a quick tour of Extending and embedding and the Python/C API reference. Pyrex let you write basically Python-ish code that gets magically turned into C extension code. &gt;In 2007 I forked it (discuss why briefly) and named Cython after this punk rock guy. &gt;At that time, Robert Bradshaw and Stefen Behnel spent a lot of time improving Cython, implementing tons of _optimizations_ and new features. &gt;Cython is now very popular in the "Scientific computing using Python" world. It is also heavily used in Sage. Plus, as [wikipedia notes](http://en.wikipedia.org/wiki/Cython), Sage is partially written in Cython, so he might be "leading up to" something more substantive. 
Just a warning, Sikuli is neat, but still a very immature project. You'll probably run into issues with the screen capture if you're running it with multiple monitors. When I tried, it would either crash or wouldn't seem to detect the areas that I had defined. There was supposedly a bug fix for this, but I still couldn't get it working solid enough for my needs. Also it's pretty slow (understandably) in comparison to conventional automation libraries. However, I'm assuming the game you mentioned is a card game, so speed may not matter so much.
The code above looks too complicated. Linked list is all about simplicity: class node_mixin: next = None class foo(node_mixin): """ Something that should be linked to the next item """ ... # Creating list (None is the empty list) list = None # Appending a node to the head of the list node = foo() node.next = list list = node # Iteration it = list while it is not None: # do something with it it = it.next This code compiles in reddit comment box, and may even work. It it does not, fix it. 
While delving into the functional capabilities of Python is a good way to get better at it, the most popular answer glosses over a lot of the OO functionality that Python brings to the table. Of course, that's probably due to the recent popularity of functional programming. Ultimately though that answer is right on one point: Balance. Once you can balance the strengths of OO and functional programming in Python, you're well on your way to becoming a Guru (though you're not there yet).
After reading through Learning Python, my impression of Python is summed up as: &gt;Operator overloading is awesome!
&gt; apt-get install python-lxml FTFY
thanks :D
The popular answer also mentions the Strategy pattern, which is where functional programming concepts meets OO designs. But Python's main strength is functional, so why avoid it?
I like the motto(from matrix): Being the One is just like being in love. No one can tell you you're in love. You just know it... ...through and through. Balls to bones. To be guru is in the same way to be the one.
I just thought it would run through until it returns either a 1 or 89 by just self referencing the function with a new value, but... no. Thanks mate. Kind of you to explain it.
It seems the programming sub-reddit does disallow noob questions, but I'm not sure about the python subreddit; That said, some recent noob questions have been ridiculously simple such that a good googling would have solved it (or reading any decent into tutorial). Python has a pretty good record for documentation, and reading then is a vital skill to a python (and any, really) programmer. Some of these noob questions just come across as lazy. Note: I explicitly except the following from being 'lazy': - anything regarding a nuance of python that is a difficult concept, or confused in some docs, i.e. mutable/immutable data-types, although this kind of thing is better on stack-overflow. - asking what are 'good solutions' to things, either by polling for common/good python idioms and methodologies, or looking for modules/libraries people have discovered as useful for a particular task, and thier respective pros/cons. This is essentially taking advantage of the fact that the python sub-reddit will be populated by pythonistas. Also, stack-overflow is good for this, though not, in my opinion, as 'casual' feeling.
Python's main strength isn't that it's functional, it's that it's flexable. If functional works, you can use functional. if OO works, you can use OO. You can pick the right tool for the job without having to switch languages.
Python uses pointers. All variables are pointers. 
Just make a bash script that downloads WordPress and untar+ungzips it. Make it runnable from anywhere and work in the current directory. It'll only be three lines long counting the shebang line. #!/bin/sh wget http://wordpress.org/latest.tar.gz tar -xf wordpress.tar.gz It doesn't do the final setup, however. But the SQL should be there and you can set that up with one or two more lines.
&gt; Annoy your cubicle mates every time they present you with a Python class. Claim it could be "better" implemented as a dictionary plus some functions. Embrace functional programming. I guess I'm just being annoying, but can you name a couple of examples of the "OO functionality that Python brings to the table?" (Honest question)
I would say it is, it lets you focus on your particular problem (the desired pages) while solving the rest of issues like requesting, downloading, scheduling, etc.
whats bugged about the IDE? The main issue I had with it is no "undo" command.
Things to think about: * which blog software will you use? * will it be multi-tenant (like WordPress MU) or one instance per user (like regular WordPress)? * what will the addresses look like? a unique domain for each blog? wildchar subdomains? or all on one domain mounted at different directories? * rough steps your script will need to do: deploy the code, write the blog configs, set up the server configs (e.g. vhosts), set up the db (which database will you use?), set up initial users &amp; data, send login credentials to the user * security: if one blog gets hacked, everyone else can be compromised * scaling
* It will be Wordpress no MU * Unique addresses (individual users with diff addys) basically all in the main public_html folder * Will prob use one database with "sample text" that could be extracted from VPS via FTP * The credentials to their ftp/jailshell/ssh will be provided by users * I was thinking of using the same password they give us to connect to their account as the database password * scaling is a concern :) 
Thanks for the starting point.
i dunno just import vulcanmindmeld
Try doing anything of any complexity using the OO as implemented in PHP. When you're done crying, I'll welcome you back to Python. We missed you.
*vomit...*
Looks like a really nice and useful package ... and great presentation!
"e^-1 mod x" here means "the inverse of e mod x" in this case, not "e to the power of -1" (which doesn't make a lot of sense) see: http://en.wikipedia.org/wiki/Modular_multiplicative_inverse
no multiple monitors here, just use a desktop replacement laptop(meaning high powered). I have noticed the lag issue but I figure this is what I Should expect if it's going to do pixel scanning. Hopefully I can reduce the lag with some more efficient coding.
Why the *float* in your code? Read here: http://en.wikipedia.org/wiki/Modular_multiplicative_inverse on how to compute *d* - there's even Python code there
Yes, I've done that, and all I've learned was OO implementations suck. I didn't cry, instead I went on to learn functional programming with Python. Now, give me a better explanation of the Python's benefits with classes that isn't basically the Strategy Pattern.
Forbidden You don't have permission to access /video/drewconway/10175 on this serve
@dansin, maybe the web host has a IP access policy. 
Hmm, well the sidebar does say "news about the... [python]"
ATM, I'm using Traits with the wxPython TraitsUI backend. This is the more mature of the two backends and wx has a more liberal license for commercial work. However, the Enthought guys seem to be mostly using the Qt backend now. If you don't care about the GPL license, it probably makes sense to go with Qt. Note, Traits itself can be used without a GUI backend; TraitsUI is the companion module which wraps either WX or Qt to provide the GUI. You can use Traits/UI without knowing the mechanics of WX or Qt. You can easily integrate custom GUI elements (Qt or WX) into a Traits app by making a custom "editor" object. Matplotlib and Chaco serve two somewhat orthogonal purposes. I use matplotlib for my script-based data analysis/visualisation. I use Chaco when building a traits-based data-acquisition application. One can use either in either role, but this approach plays to each libraries strengths. For fast application development there's nothing else like Traits that I've found.
The total only ends up being the first price + the current price: total = firstPrice + float(stock['Price']) should be something like: total = total + float(stock['Price']) or shorter: total += float(stock['Price'])
wow i'm feeling dumb. that's a pretty simple fix. thanks!
"undo" yes ... but indent/dedent is bugued too sometimes copy/paste do wrong thing sometimes, the editor is screwed (after using the image editor) In fact, I use the IDE to make screenshots only. But using an external editor, where I've got my habits, is perfect and as speedy as the ide. 
There's where all my semicolons went to. You can have them.
The only thing that sounds like is you being gay
dudes, Thank you again. I finally was able to come back to this project and within 25 minutes, I have successfully selected data from one datasource and was able to insert into another. OMFG! this feels pretty awesome. I'm going to polish it up tomorrow and package it as an MSI. Thanks again. This message below made me happy! ... &lt;pyodbc.Cursor object at 0x0164A560&gt; &lt;pyodbc.Cursor object at 0x0164A560&gt; &gt;&gt;&gt; cnxn2.commit()
I wrote a bunch of stuff wrapping the NIDAQmx library to use the NI USB multifunction DAQs. It worked pretty well. You will then need to use a toolkit. Tk is horribly primitive although the newest version in 2.7/3.x looks much better(with MUCH better documentation). GTK stuff is not well documented, QT/PySide looks promising and wx looks pretty well documented but I have not used it. http://www.scipy.org/Cookbook/Data_Acquisition_with_NIDAQmx
Yeah, do it. Build yourself a Link model, then once you're running put some data into it via the admin, and then write a view and templates to display it. http://docs.djangoproject.com/en/dev/intro/tutorial01/
Sounds a bit like what Celery does.
What is up with the line ending semicolons?
I like Python because everything is an object. I can take pretty much anything and pass it around however the fuck I please. It's like watching OO and functional programming make sweet love to one another.
Sounds badass. I don't know if I'll ever use it, but still.
What you are searching for is how sockets works http://linux.die.net/man/3/listen The backlog parameter set the number of requests that can be enqueued (so nginx will wait until one worker respond) You can set the listen queue of uWSGI with the -l option
Me in the wonderland!
A couple quick style notes: * since whitespace matters in Python, it'd be nice if you formatted the code properly (prepending each line with 4-12 spaces, in this case) * we tend to name things like min_price rather than minPrice * you don't need semicolons. Save yourself the keystrokes! * if you're going to work in Python, read through [PEP 8](http://www.python.org/dev/peps/pep-0008/). You don't have to use or even understand it all right now, but it'll familiarize you with the community's standards.
I like camelCase. I don't like that it's advised against in PEP 8.
that's just how i was taught to code. i didn't know it wasn't normal?
thanks. i've only been exposed to python within my classroom setting. nobody's ever taught me these things!
I'd prefer naming instances *this* over *self*, but I don't. In a language like Python, community standards matter.
Yeah i'd prefer that too. But you're right, it is better that everyone does it the same way. Wish I was benevolent dictator of a programming language.
It looks nice. It says it doesn't hold the GIL and allows threading in LUA code. The trick will be figuring out if it's really an advantage over Cython and Pyrex when Python is too slow. I imagine objects have to be copied back and forth to the LUA environment so it might not be suitable for operating on large numpy matrices, for example. 
That is a tricky situation, and with a fixed-size worker pool you are kind of stuck. But one possibility is to use something like `paste.recursive` (or simply `webob.Request.blank(...).get_response(...)`) to do your subrequests, thus doing them in-process instead of in a separate worker.
It's a little rough, and introduces a system more complex than you may want/need, but: http://bitbucket.org/ianb/silverlining/src/tip/docs/examples/wordpress/ (see http://cloudsilverlining.org for the general concept)
Or for (1..10) { print }; in perl.
Exactly. High coolness factor. Can't imagine using it. If it shipped with Python, I could see using this instead of ConfigParser.
&gt; Even if someone manages to monkey-patch each and every object in the entire python process, you'd still have to deal with inconsistent state. Not quite. All you need to do is modify the existing class and function objects in-place; most changes that you can make to a running program would survive this. (If you changed a class to a function or vice-versa, or needed to modify a decorated function, you might be out of luck, though.) IOW, you can easily get to a reasonable degree of reliability for incremental development such as minor bugfixes and code additions. What it'll fail hard on is any major refactoring.
I'll add that this works: &gt; python parser.py a But I'd like to avoid having to type "python" in front of all my scripts.
[Redis?](http://code.google.com/p/redis/)
Redis.
Says it is in-memory, so good. http://simonwillison.net/static/2010/redis-tutorial/ What I don't see (in the few minutes I have to look at the redis docs and reply to you) is anything about relations. * I'm not seeing ways to describe items that are related to another. * Also, it does not appear that lists can be contained inside other lists (or sets or dicts). Now, I was totally expecting the relational stuff to be lacking, since it is a key/value database. Question(s): * Am I correct about the lack of any relational logic (in redit and key/value databases)? * This means that I would still have to program a relational system to make it work; is this also right?
[This might answer the relational question?](http://blog.mjrusso.com/2010/10/17/redis-from-the-ground-up.html#heading_toc_j_45) I don't think I want to have to build relations in that manner. However, maybe I could actually build my own relational system and use redis as a good base for the storage ... so it may be a good option if I take that route. :) thanks
I don't think using a key/value store means you can't have relational data, just that you have to think ahead about what types of queries you want to run and store those in a denormalized form. For example you could have a teachers key set and a students key set. You would probably store the teacher's name in with the students' data. If you ever wanted something like all the students with teachers under 30 you would also need to store the teachers' ages along with the students' data, or you would have to do the logic in your program after grabbing all the data for teachers and students.
http://bugs.python.org/issue7936 scroll down to question 107780 
Yeah, that's the impression I got from [this link](http://blog.mjrusso.com/2010/10/17/redis-from-the-ground-up.html#heading_toc_j_45). So, thanks for confirming my understanding. For me, personally, I just don't think I will want to go through all the effort to do it that way. On the other hand, maybe it would be possible for me to write a more abstract relational system and still use redis for the raw storage (if pure Python key/values present too many issues or whatnot). Anyways, it's an interesting concept... and redis may open up some nice options for me... so, really, thanks everyone for the suggestion. Also, does anyone know any relational databases or Python relational library that does in-memory (and hard drive backup).
Also take a look at http://www.mongodb.org/ It allows more powerful queries than redis.
To dump a SQLite db use the [ATTACH](http://sqlite.org/lang_attach.html) statement.
Neat, but I don't see the niche for it. If you want to speed up parts of a Python app, you can use Cython and write in a faster, restricted Python. If you want to script some inflexible app with a long build/run/test cycle, you can use Python, JS or Lua. But there's really no need to add flexibility to Python, which I'd argue is the more versatile of the three. 
Go for it. Start simple, add features later (tagging, categories, favorites, rating, sharing). Django handles everything from the simple app to the complicated quite well. 
Doubt this is what you want: with sqlite, query "[PRAGMA synchronous = OFF](http://www.sqlite.org/pragma.html#pragma_synchronous)". 
That's nice. When will PyPy be ready for production?
For those to lazy: Now I found the real solution (and don't forgot to set it to Python 3 back). I have searched in the registry for python.exe to look how Python 2 is doing this. I sawed a key that looks dissimilar to the others before. It is the key HKEY_USERS\S-1-5-21-1078081533-682003330-1801674531-1003\Software\Classes\Applications\python.exe\shell\open\command which have the Standard value of "E:\Python31\python.exe" "%1". I set it to "E:\Python31\python.exe" "%1" %* and it worked.
C:\bin&gt;t.py foo ['C:\\bin\\t.py', 'foo'] 2 C:\bin&gt;python t.py bar ['t.py', 'bar'] 2 C:\bin&gt;python -V Python 2.6.6 Works for me
Haven't used it myself, but there's this: http://ringce.com/hyde It uses Django templates to build out a static site.
&gt; Neat, but I don't see the niche for it. Large body of existing Lua code that you want to leverage? You work in a Lua shop, but want to use Python for various reasons? I can think of a few. &gt; If you want to speed up parts of a Python app, you can use Cython and write in a faster, restricted Python. Or ShedSkin or PyPy or whatever. I don't think this is the aim of Lupa though. &gt; If you want to script some inflexible app with a long build/run/test cycle, you can use Python, JS or Lua. But there's really no need to add flexibility to Python, which I'd argue is the more versatile of the three. Python most certainly *is* the most versatile out of the box. That's kind of the point with Python (awesome language + batteries included). Lua has a different point: smaller runtime &amp; memory footprint, easily embedded, highly portable, &amp;c. &amp;c. I still don't see this as the point. I see this as being able to leverage any existing Lua code you might have, or testing something that requires Lua &amp; the like.
You mean like what the NY Times does because they have no educated developers or sys-admins on staff? Why not just setup a reverse proxy cache?
Because I am not and educated developer or sys-admin
I like [blatter](http://bitbucket.org/lost_theory/blatter) a lot. Plus a fabric script for deploying it.
Does it have to be written in python? If not, try [nanoc](http://nanoc.stoneship.org/) (ruby). It's very straightforward to use and has excellent documentation. 
Not all. Thanks for the recommendation. 
Install a reverse proxy cache on your server. There are plenty of tutorials to walk you through the steps... Ngninx or Varnish are what you want to use.
Well, that is interesting in its own right, but no, it probably is not what I want. I think [the following](http://www.sqlite.org/faq.html#q5) may answer my question: &gt; When any process wants to write, **it must lock the entire database file for the duration of its update.** .... Other processes just wait on the writer to finish then continue about their business. ... However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time.[bold mine] If anyone knows. Is *this* the reason why SQlight cannot handle larger loads like, say, Postgresql?
This fixed it...I guess I'm a moron for not reading all the way to the bottom of my own link :-( Thanks for the help. I have no idea how the association got mixed up in the first place, but either way, I'm disappointed the uninstall/reinstall didn't fix it.
Context wouldn't hurt.
second the fabric usage, but I use blogofile
I haven't used any of the open source ones but I can tell you what I find desirable. You want periodic checkpoints to disk so that if you shut the system down, you have a persistent database. You want writes to be written to a transaction log on disk, but the write should not have to complete for the write to be successful. This gives you "mostly" up to date information if the system crashes - at worst you might lose the transactions that were not yet committed to disk. Ideally this should be configurable so you can choose slow writes and gain more integrity, if you should so wish. You do not want to have to talk over a socket to get to the data; shared memory access to the data is desirable. Shipping data over sockets is dumb when the data is already there in ram on the same machine. I use TimesTen for this kind of work, but that requires a budget. You can download it and use it for free for development though, I believe.
I guess it all depends on how much data you're planning to write to your database at once, and if the DB will be used mostly for searching, querying, or just plain referencing. Also knowing if you're planning to do most of the magic in the DB, or plan to write all the logic yourself. I like SQLite for a lot of smaller things. It's fast, works well under a high load. Its [standard testing harness](http://www.sqlite.org/testing.html) is something seriously awe inspiring. Good for searching and built into Python- nothing new to add to make it happen. the NoSQL stuff is good if you're wanting to put stuff in a database and have very basic tools to get it back out again. I'd use Mongo or Redis for limited items and nothing that requires any intense searching capability (example, no fulltext searching of items inserted, having to learn new interfaces (like JSON) to handle input and output). It may be fast, but they stripped out some usability to make it happen. Postgres is probably a little much for your project if you're looking for an in-memory database. In my current project, I'm planning to handle terabytes of realtime streaming data so it's a fit for me (MySQL is a non-starter since I'm not giving Oracle any of my business). So, I didn't answer your question. If there was a top two, then i'd say CouchDB (nice features, I think), and SQLite. Couch can handle in-memory, but it requires some tweaking to make it happen. For my project, I spent two weeks working with Mongo, Redis, and CouchDB. Mostly Mongo. Best of luck!
Link to [blogofile](http://www.blogofile.com/)
Origin: I first heard of the concept from a Smalltalk library. The way I remember it, it would load the database into memory and let you interact with it as objects (probably similar to SQLAlchemy for Python). Also, it had a mechanism for backing up the stuff in memory (to a real db or disk or whatever). Reason(s): * speed -- Also, I really would like to give it a try: maybe even learn something and/or make something new :) * to save me time -- if someone already made such a Python library, maybe I could save me lots of frustrating and just use it for now. :) So, I was looking for something in Python like the following: * database with the ability to model relations * Loads the db into RAM. * Allows me to query and modify the database in memory. * In the background, commits the results to a heavy duty database (like Postgresql) or directly to disk. * Can scale to larger projects (for example, SQlite is not meant for larger projects, while PostgreSQL is). Actually, SQlite comes close, but not quite on the last 2 points. As I understand it, it is not a good choice for larger projects (maybe because it has to lock the database during writes? and/or because it uses 1 file?). SQLAlchemy+Postgresql has a lot of similarities too, but it doesn't load the db into memory and then handle automatic backups as needed or specified. Other factors? * Maybe this might provide me an opportunity to explore some new concepts related to graph databases and massively parallel programming. *but you didn't really want to know that part did you :)*
I recently found [APSW](http://code.google.com/p/apsw/), which provides an interface to the backup statement implemented in sqlite - I build my data base in memory, as doing so is much faster than flushing every transaction to disk, then use the backup facility to dump it to disk when I'm finished. Conversely, you can 'backup' a database from disk to an in memory database, makes changes, then dump it to disk again... when you're inserting hundreds of thousands of rows at a time, this is quite quick.
I gave it a try, documentation sucks, but it's quite straightforward once you get how it works.
CamelCase is used for classes, isn't it?
er, shouldn't a classroom have a teacher to teach you these things?
what !?! ATTACH performs essentially a "join" of remote sqlite databases across a filesystem -- allowing you to query across all ATTACHed databases using: select DBNAME.TABLENAME.COLNAME from DB.TABLE where 1; .... it has nothing to do with "dumping" a database's content to a file in so far as i am aware of.
Maybe I should run some tests. :) &gt; I guess it all depends on how much data you're planning to write to your database at once I guess not a lot of heavy writing ... though some parts do need to add data ... + lots of querying on data that doesn't change often. In some ways I'm also interested in other theoretical applications beyond my particular situation. Anyways, I guess there's a lot of options to consider -- even if there is no read-made solution for Python.
Use the [.dump](http://www.youtube.com/watch?v=agCqVr-m68A) command in SQLite?
There's a reason why nothing does precisely what you want without hacking it: what you want is wrong. Nobody tries to manage their data persistence in a zillion tiny changes, because it is both safer and faster to save logical transactions in atomic commits. Saving each change individually is very chatty, and a crash can leave your application in an inconsistent state. You can mess up SQLite into doing what you want. Maintain a threadsafe queue of data changes, and have your active threads log their changes to that queue. Then have a single thread that drains the queue and writes everything to SQLite. But...why? Give some more thought to your actual performance requirements, and whether or not there's any actual benefit to being too lazy to define and commit transactions.
Why not just use a query cache? What problem are you trying to solve here?
Just use [Membase](http://membase.org/). It's by the some of the same guys who came up with [memcached](http://memcached.org/), the infamous distributed caching "database". :) It's basically just memcached with disk persistence. Use it as a nosql store, and you're done. Well, maybe. It's not really a database, but it's a start. **Edit:** Alternatively, you can use [DRBD](http://www.drbd.org/) to create a block device where one node is on a RAM-disk, and another is on traditional disk. Then if you use PostgreSQL on the ramdisk, DRBD will take care of persisting writes to disk, asynchronously if your writes are substantially less frequent than your reads. Just make sure to mount them as noatime, nodiratime so it doesn't try to copy access times to the disk mirror.
&gt; If anyone knows. Is this the reason why SQlight cannot handle larger loads like, say, Postgresql? Yes. It's also the reason MySQL performs great with MyISAM until concurrency drives the performance down and you need to switch to InnoDB. SQLite is great for just having a quick'n'dirty database, but its locking is even worse than MySQL beause it's "database" level instead of table level. I like SQLite, but not if you want high transactional throughput.
According to pypy developers, 32-bit PyPy is already stable for production usage.
Yeah, I agree that trying to save to disk every time you make a change would be quite slow. The key issue is whether there is a Python library like the Smalltalk library that (1) loads the database into memory, (2) works only on the copy in memory, for speed, (3) and commits to the database on occasion, for backup/permanent storage. I don't know for sure how how the Smalltalk library handles the commits to the database; but I suspect that it only would do it occasionally to back up (otherwise there would be no point... like you suggested). Of course, I may have misunderstood the design of the Smalltalk library a while back.
:) Thanks for the confirmation. BTW, do you know if SQlight locks reads while it is writing (I know from the docs that it locks other writes while it is writing, but I'm not 100% sure on the reads part)?
Not sure if this would really help, but SQLite does have a [hot backup api](http://www.sqlite.org/backup.html). You could run it in-memory and occasionally dump to disk. If multiprocessing is what you're after, consider sharding the database among multiple processes. An external process could then query some or all of these shards and combine the results. And if any writing were to be done, it would hopefully be localized to only some of the shards.
dammit, Lupa doesn't automagically handle userdata T_T
Would you need anything more than rsync to deploy a static site?
I don't know much of anything about [Firebird](http://www.firebirdsql.org/) but it might be worth a look.
Do you have a quick run-down of how it works ? 
Handling of templates would be nice. So going from a text-based document format (markdown etc..) to HTML. 
This is a good starting point http://stevelosh.com/blog/2010/01/moving-from-django-to-hyde/
Looks promising, thanks.
You might want to look at pytables if you can structure your data hierarchically and don't need arbitrary joins. It should be extremely fast and you can probably make it behave like an in-memory db by prefetching the whole dataset. It's a wrapper for HDF5, which supposedly has optimizations for sending compressed data between processor cache and main memory that let it beat raw C arrays in some cases. http://www.pytables.org/moin Honestly, Python is so slow that you won't be limited by the speed of your DB in many cases if it's small enough to fit in memory because it will be cached after the first query. Remember the rule against premature optimization.
Using a language with 1 based indexes (Lua) inside a language with 0 based indexes(Python) sounds like an awfully bad idea. 
How about something like: &gt;&gt;&gt; -time Prints the time at which the screensaver last activated or deactivated (roughly, how long the user has been idle or non-idle: but not quite, since it only tells you when the screen became blanked or un-blanked.) See here: http://www.jwz.org/xscreensaver/man3.html There may be yet another more generic X11 utility that returns the result of that API call.
That depends on xscreensaver which I am not running. The commands in that post will work on any X.org server so I do not have to worry about what screensaver application the user is running or if they're running one for that matter.
While I'm loathe to help with a ctypes solution (since you'll inevitably get crashyness from 32/64bit pointer/integer size issues, etc. when moving between machines and X libraries), the reason you couldn't find the symbol is because it doesn't exist: http://google.com/codesearch/p?hl=en#OxCq8X8Lf2I/xlib/X11/Xlib.h&amp;q=DefaultRootWindow&amp;sa=N&amp;cd=2&amp;ct=rc&amp;l=74 The bottom comment on that blog linked to another utility which talks to the SCREENSAVER extension and returns the same information. Why not just depend on that?
I would much rather use ctypes and minimize dependence to an xserver and Python. Plus, I would much rather deal with ctypes over pipes in Python any day.
[Durus](http://www.mems-exchange.org/software/durus/) might work for you.
Fair enough. :) In which case you might want to check out https://code.google.com/p/pyxlib-ctypes/ , looks quite thorough, and allows you to bundle it in the same directory as the script you're writing, or alternatively just cutpaste the struct defs from there instead.
What's DE class?
Data Structures, is a computer science class in which we learn algorithms
That'd be a DS class.
&gt; At work they have me spending 5 days a month hand-extracting this information and filling .xls's My god.
Sorry, I forgot to mention that I'm from Honduras, I can't make a proper comparison between a degree from US or EU to one from our local universities, but I bet that overall things are still hard, I had to take calculus II, 2 times to pass it, it seems differential equations will take a long time too :P
 ATTACH "persistent.sqlite3" AS P; [for table in schema] CREATE TABLE P.[table] AS SELECT * FROM [table] [endfor]
Good luck!
Why a static site when you have a dynamic site generator. Try the web2py wizard. Here is a [demo](http://web2py.com/demo_admin/wizard). You can create static pages with it using the MARKMIN wiki syntax.
It's overkill for what I need. I just want to be able to; * Create text documents in RST, markdown * Translate this into HTML with using a template * Serve the page statically I don't need a database backed dynamic web app. 
Thanks, I'm trying to stay on this degree until I finish it. 24/50 classes passed so far, (4 of them on my 2nd try since I dropped out the 1st time but still) edit: I just realized I wrote incorrectly the word "structures" :P
I've had good experiences with http://markdoc.org/ . Write in markdown, generate static pages, rsync/copy to site.
It is, although for the record it's in the *MyClass* sort of way and not the *myClass* sort of way. Which I think is what you were saying, but just wanted to contrast that against OP's code.
FWIW, I think most classrooms are really only good places for certain kinds of stylistic considerations: * did s/he encapsulate repeated code in functions? * how about blank lines? is there at least one between function definitions? * did s/he comment liberally about what's going on? The kinds of community standards I was pointing to are really for someone 3+ months into Python, IMO. They're non-essential, but they're *enormously* helpful when you want to convince the rest of the Python community to help you. It makes it easier for us if we know how to read your code, you know?
If it's an intro to programming class, then no, that's not a great place to teach about PEP 8. The semicolons ... maybe. Otherwise, the stuff I mentioned is really non-essential.
Looks simple enough for my needs. 
Didn't have initial luck w homebrew and 10.6 :/ ah well
I wanted to do the same thing and I looked for a tool to do it, but I couldn't find one that did exactly what I wanted, so I rolled my own. Don't dismiss this possibility. My home-brewed code is about 50 lines (it renders Jinja templates) and is customized to my needs.
thanks, I will look into it. 
[Sphinx][] is basically technical documentation-purpose, but I think it can be a good static site generator. [Sphinx]: http://sphinx.pocoo.org/
Have you looked at ZODB? http://en.wikipedia.org/wiki/Zope_Object_Database
That's the way Lua is usually used - as a scripting language inside projects written in C or C++. I don't really care about 1-based vs. 0-based indices, but having to mix the two is incredibly annoying. Other than that, Lua rocks.
How many large Lua code sets are there outside of games, where you really don't want to throw in a second scripting language? 
DefaultRootWindow is a macro, which is why it won't exist in the library. You can replace DefaultRootWindow with XDefaultRootWindow, which does exist. Here's my solution (warning: tested in python3 only), #!/usr/bin/env python3 # Modified C code: ## #include &lt;X11/extensions/scrnsaver.h&gt; ## #include &lt;stdio.h&gt; ## ## int main() ## { ## XScreenSaverInfo *info = XScreenSaverAllocInfo(); ## Display *display = XOpenDisplay(0); ## XScreenSaverQueryInfo(display, DefaultRootWindow(display), info); ## printf("%u ms (%d, %d)\n", info-&gt;idle, sizeof(XScreenSaverInfo), ((unsigned int)&amp;(info-&gt;idle)-(unsigned int)info)); ## return 0; ## } # # Output: # # 4 ms (24, 16) import ctypes import struct # libraries xlib = ctypes.cdll.LoadLibrary("libX11.so") xss = ctypes.cdll.LoadLibrary("libXss.so") # functions XScreenSaverAllocInfo = xss.XScreenSaverAllocInfo XOpenDisplay = xlib.XOpenDisplay XScreenSaverQueryInfo = xss.XScreenSaverQueryInfo XDefaultRootWindow = xlib.XDefaultRootWindow # let ctypes assume defaults for all these return values, as it doesn't matter really... # production code might want to not hardcode the offset 16... display = XOpenDisplay( ctypes.c_int(0) ) info = XScreenSaverAllocInfo() XScreenSaverQueryInfo( display, XDefaultRootWindow( display ), info ) time = bytes( ctypes.cast( info, ctypes.POINTER( ctypes.c_ubyte ) )[16:20] ) time = struct.unpack("@L", time)[0] print( "%.03f sec" % ( time / 1000.0 ) ) Enjoy:)
I guess since LuaJIT is pretty fast, you could use it to speed up some code by writing parts in Lua ;-)
Does this work well with Confluence? I have a site which changes only very slowly. How can I set caching expiration in nginx to a day, or so?
[apsw](http://code.google.com/p/apsw/) is an alternate wrapper for sqlite, which enables you to backup an on-disk database to memory before doing operations import apsw # Original SQL file disk_con = apsw.Connection(path_to_file_sqlite_db) # New database will exist only in RAM mem_con = apsw.Connection(":memory:") # We will copy the disk database into a memory database with mem_con.backup("main", disk_con, "main") as backup: backup.step() # copy whole database in one go # There will be no disk accesses for this query  mem_cur = mem_con.cursor() for row in mem_cur.execute("select * from s"): pass The same works for copying the in-memory database back to disk.
Thank you! The change for Python 2.X was trivial; time = ctypes.cast( info, ctypes.POINTER( ctypes.c_ubyte ) )[16:20] time = struct.unpack("@L", ''.join([chr(c) for c in time]))[0] 
I've written a few, on platforms where it wasn't feasible to bring Python or the like everywhere. I've not run into many, but I've seen pockets Lua here &amp; there. Still, the point stands: I could see this being a useful tool for such teams, or for teams transitioning away from Lua to Python (or just attempting to leverage existing tools). 
You missed the part about Cython (or ShedSkin or whatever). Here is some [shootout code](http://sage.math.washington.edu/home/wstein/tmp/pidigits.pyx "pidigits") where speed is [comparable to C](http://www.mail-archive.com/cython-dev@codespeak.net/msg06982.html "ml thread").
I have 4 commands: * clean - removes the output directory * regen - calls `clean`, then regenerates the output * serve - runs blatter's server, which has automatic reloading so you don't have to regen every time you want to see a change * publish - uses fabric's `project.rsync_project` to rsync the output directory to the server
ShedSkin is particularly desirable, since you don't even really have to make changes, assuming you write in the supported "restricted" dialect. Even at this stage, it's pretty enticing to use.
+1
Thanks, I'm starting small and making sure I understand what's going on under the hood. Google's learn Python coursework has been a useful resource, and I'll be working my way up to utilizing the modules. [trncn](http://www.reddit.com/user/trncn) has also been kind enough to answer a lot of my questions. 
1.4 release should be ready for 32bit usage.
&gt; *Such as in: 9 print "Let's talk about %s." % my_name* Confusingly the % is doing two things in your example. %, the operator (that's the one between the quoted text and the `my_name` variable) does what's known as *string formatting*. It takes the text on the left and fits in the variable on the right based on formatting tags. And that's what the % inside the text is. It's a formatting slot. Specifically, **%s** means, "put a text (string) value here". The formatting codes are based on the C language `printf()` function and can be kinda odd to people unfamiliar with it. (Us old dinosaurs speak printf in our sleep) There is a new string formatting system for later 2.x pythons and python 3. Have a look at those too. Personally I love the % operator. Edit: Think of it like the plus sign (addition operator), but for text. `print 2 + 3` takes the value 2 and adds 3 and prints the result. `print "%d" % 5` takes the value 5 and formats it for display and prints the result. (`%d` is for numbers!). The useful bit is the format control modifiers....like..... `print "Your pizza is $ %7.2" % (2.99 * 12)` will print the cost of 12 slices at 2.99, over 7 columns with 2 decimal places. [Here is the relevant section of the documentation that explains all the fun variations you can do](http://docs.python.org/library/stdtypes.html#string-formatting) 
Let me see if I understand. The operator % tells the program to insert Zed A. Shaw which I previously set up to equal my_name?
The % operator is being replaced by the format method for strings in newer versions of Python. % acted as a place holder in strings which you could be replaced dynamically later, like in your example. The format method achieves the same purpose, but works like this: my_name = "Zed" my_string = "My name is {0}!" print my_string.format(my_name) &gt;&gt;&gt; "My name is Zed" The 0 refers to the first argument given to format(), other numbers work in the same way. For more complex string formatting you can use names and pass them to format as keyword arguments so the order doesn't matter. Example: my_string = "Hey {g}, my name is {z}!" print my_string.format(g="Guido Van Rossum", z="Zed Shaw") &gt;&gt;&gt; "Hey Guido Van Rossum, my name is Zed Shaw!"
Exactly. It's like a fill-in-the-blanks operator. With the added bonus that you get to control how the blanks end up looking (in general)
I'm doing the LPTHW too- on Chapter 14. Its pretty good stuff so far. I'm also watching the MIT class on iTunes U. Google also puts their intensive 2 day class on [video](http://code.google.com/edu/languages/google-python-class/). [These](http://www.thenewboston.com/?cat=40&amp;pOpen=tutorial) are also some good, basic tutorials. I figure combining tutorials and book learning and practice is the right recipe for me, maybe it works for you too.
Note that when you want to use multiple values the values to be inserted must be a tuple, like this: variable_a = 'a' variable_c = 'c' print '%s %s %s' % (variable_a, 'b', variable_c) #will print: "a b c"
afaik it is like those commands in C %s in python makes it unpack a string much like %d would be specified in C to insert an int at the location. 
You may want to create a simple protocol to specify those classes that need to map to the database, and auto-generate glue code (e.g. simply for each class that meets your criteria - either via name, via a class variable being present, those that inherit from a particular parent class, whatever. The method is up to you), generate a module with _glue_&lt;classname&gt; and then import the glue module and include an instance of _glue_&lt;classname&gt; in each object)to map them to the database. Python's introspection (the inspect module) should make this pretty doable. You probably won't want to re-generate the glue each run, just when you make changes. 
That's how you code in C, or Java. Python does not require them except when placing two statements on one line.
Not to just 'deploy' a site perhaps. I have helper functions I made to manage my posts, and test out my site locally. They're simple enough, and in my [fabfile](https://github.com/goosemo/blog/blob/master/fabfile.py).
Share your code, I'm interested. I didn't find one that did what I wanted and started my own too.
The code that generates my website is not in a public repository and I wouldn't know where to post it, but it's similar to the code I use to generate my applications' help file, which is at http://bitbucket.org/hsoft/hscommon/src/tip/helpgen.py (it's a little longer than 50 lines though...)
Are you just talking about the readme? Does the wiki suck as well? https://github.com/lakshmivyas/hyde/wiki
Try web2py (1.89.1 released today). You create a model for example db.define_table('message',Field('body')) it write the SQL for you to create the table (or alter as necessary) and generates a web based interface (which you can run on 127.0.0.1 so you do not have to expose it). It also generates form form you from the definition. You can add CRUD forms into any view with {{=crud.create(db.message)}} {{=crud.update(db.message, request.args(0))}} {{=crud.select(db.message)}} Fields can be type 'string', 'text', 'boolean" (redered with checkbox), 'datetime/date/time' (rendered with popup calendar), 'upload' (rendered with upload form), 'list' (rendered growing list), 'reference' (rendered with dropdown), etc. You can customize everything (validators for fields, labels, widgets that render the fields, locations of the fields on the screen). It cames with wizard to build apps and you can [demo it here](http://web2py.com/demo_admin/wizard). Why make a GUI app when you can make is web enabled?
&gt; As I understand it, it is not a good choice for larger projects (maybe because it has to lock the database during writes? and/or because it uses 1 file?). It's not so much about the size of the project, but the way you use it. For example, Firefox uses SQLite, and it's definitely not a small project. I write a lot of small utilities and programs that have to persist their data, and there are two good choices I found out: * SQLite with SQLAlchemy - thanks to SQLAlchemy you can easily migrate to a "big" SQL database without a huge rewrite, and SQLite is a unbelievably good piece of software * ZODB - I use it as a pickle on steroids (which it is, in some sense), and works great for quick and dirty stuff. Hth...
But does the listen queue matter in this case? It seems that the problem is with the WSGI app trying to fetch /entries via nginx which is already blocking with all the workers busy trying to return the GET / requests. It seems to me like the /entries fetch needs to happen internally rather than externally via nginx again (although then you lose the caching benefits of nginx).
Thanks for the suggestion. I will look into the details of implementing something like this.
You might want to reconsider whether you need a relational DB or if you can get by with something like MongoDB where your objects will come out as maps with named fields. Pytables is also worth a look.
Do you know how printf works in C? The % operator takes a parenthesized tuple of values/variables on the right and sticks them into the %s/%d/whatever format specifiers within your string. You write something like "%3.2f" in the string to tell it to format a floating point number with certain precision, then on the right you give the specific number, like 123.456 . 
Thanks, I was not familiar with web2py. To answer your question: "Why make a GUI app when you can make it web enabled?" The only advantage I can see to making it a web app is that you wouldn't have to install the software on the client computers. But in my situation (small number of almost identical clients) this is a non issue. The advantages of a GUI app are that I can have multiple windows open inside my program (using QWorkspace in PyQT) and make the work environment highly customizable for the end users. With a web app, you are stuck working inside a browser. Also, I see web apps as less secure because of all the potential vulnerabilities in modern browsers. Perhaps I am missing something here, but I pose this question to you: Why make a web app when you could make a GUI app?
http://python.sourcequench.org
good stuff- is it on itunes?
The itunes p(v)odcast may still be broken. The author hosted a torrent here previously. http://www.reddit.com/user/ryanshea
If someone taught to code that way in Python, you should get a new teacher. And regarding what deadwisdom said: yes, you can use a semicolon to put multiple statements on one line, but if you ever do that in production code, I will be very unhappy with you.
I assume this would be done with an orm to map the generated classes to the db. I forgot to mention that
*Forgive me in advance if I'm blaspheming* Not necessarily directed at the OP: is it really a bad idea to use just raw SQL? Are there cases when raw SQL is a better idea over an ORM? Directed at the OP: Is there a reason you've decided on an ORM rather than just raw SQL?
Thanks, Windows!
This is an example of string interpolation (plopping a string somewhere within another string) the "%s" is a signal to the % operator, saying "put the string here." If you've ever used php, it's kind of like doing this: "Hello " . $name . ", how are you?" Except you have more flexibility. The letter s in "%s" is an option that says "format it as a string". You can change the s with various other options like f, to make it formatted as a float. [Here's a list of formatting options](http://docs.python.org/library/stdtypes.html#string-formatting).
I used SQLALchemy and wxPython, using this [this recipe](http://wiki.wxpython.org/Validator%20for%20Object%20Attributes) to connect objects to UI components. It has worked awesomely for me.
i don't think raw sql is a bad idea; it's just that an ORM is a better idea unless you've really got the squeeze the performance out. and a desktop db application isn't generally the place where you need to do that.
Let's say you want to make a lot of strings of the form "Hello X, welcome to Y!" Then you can make a _format string_ for it that looks like "Hello %s, welcome to %s!". Let's call it _f_. f = "Hello %s, welcome to %s!" Now, you can fill it in with the % operator and a tuple (or a single value, if there's only one thing to fill in, as in your example): print f % ("tallonfour", "Reddit") Prints "Hello tallonfour, welcome to Reddit!" 
Do you personally prefer ORMs? I find that even though I use an ORM sometimes, I still have to write custom queries here and there. Mostly for performance reasons though, like you said.
Good questions. I am certainly not an expert on this and am fairly new to ORMs but I will give my thoughts. Raw SQL does not usually mesh smoothly with Object Oriented design. An ORM allows you treat everything as an object. Once the mapping is established, you just access the objects as you normally would, and the ORM generates all the SQL for you. This encourages object oriented design and modular code that can be reused more easily. In previous code I have written using raw SQL, I find that much of my code is simply using conditional statements and inserting variables to piece together strings containing SQL queries. This leaves the application open to SQL Injection attacks and can be much more tedious and in-efficient to write than using an ORM. I am sure there are instances where raw SQL is preferable to and ORM. For trivial apps with very small databases, ORM is probably overkill. There are probably other instances as well. With SQLAlchemy, you have the option of still using raw SQL in addition to the ORM functionality. So you get the best of both worlds. 
Thanks! Haven't read through the whole link yet. But, this looks very promising. 
Thanks for your response. I disagree. Even if you have small number of users there is an advantage of having centralized software. It drastically reduces maintenance costs and everybody is always running the latest. Plus you keep data in one place which makes it consistent and easy to backup. You can make windows in the browser. Here are two examples that take different approaches: [1](http://www.captain.at/capos/) [2](http://trilancer.com/jpolite2/index1.html) (it is not more difficult than with Qt. I think it is easier and I know Qt). You can also have multiple browser windows open. If you use a high level framework it will solve most security issues for you. In any case if you do not make the web app public but you allow access from localhost (which you can always) is as secure as any Qt app.
The data will all be hosted on a central server whether it is a GUI or web app, so database backup should be the same in either case. But, you make some good points here. I guess I could foresee potential problems with clients running different version of a GUI app. Also, your assumption that this app will not be public, is correct. I have to admit that I have not done a lot of web based development, and don't know a whole lot about it. Perhaps I should reconsider making this a web based app. I appreciate your input. Thanks for taking the time! 
you should learn python the easy way... http://docs.python.org/tutorial/index.html
I've used markdoc as well. Is ok. You can't really do arbitrary structure though.
Yes, that didn't helped a lot then and being a Django user it was easier to take Steve Losh tour.
"Also, it does not appear that lists can be contained inside other lists (or sets or dicts)." You can achieve that by saving the list to another key. Redis has a function that allows you to do this atomically.
There is Redis, which is not relational. But there's also this: https://github.com/JakSprats/Redisql I have not try this myself, but if it works as advertised...
web apps can run on any system with a browser. you only need to write the interface once, and it makes it easy to keep the code up to date.
He needs to increase the width of that column so the mono-spaced code doesn't wrap. It's driving me insane! (But my eyes are getting a saccadic workout, I guess.)
Sorry, I don't have enough experience to tell you that. I know tons about PostgreSQL's locking and storage mechanisms, but SQLite is just one of those things I haven't dug into that deeply.
&gt; It's not so much about the size of the project, but the way you use it. If it matters, by "larger projects", I was mostly referring to the load -- the number of simultaneous threads trying to interact with the database and/or many complex queries. So, I guess we both agree. :)
Sorry to not even bother with your question (I don't know Web2py), but have you tried [Stack Overflow](http://stackoverflow.com)?
For one thing, you're missing a colon between mssql and //
You should use raw SQL for as many years as it takes until you start to realize what aspects of it are really entirely reasonable candidates for automated generation. In my case it was about ten years of avoiding all SQL generation tools other than my own, which left me with a pretty deep concept of just how much can be automated, given a particular software development paradigm (my own development is oriented around object-oriented "domain models", http://en.wikipedia.org/wiki/Domain_model) . I then turned that into SQLAlchemy.
yes its posted
my bad i know what you mean will try
fixed that no solution :(
Is anyone else tired of seeing this guys face?
I don't have the answer, but the [web2py mailing list](http://groups.google.com/group/web2py) is *the* place to go for quick answers to web2py questions. Try posting there.
I very much like the idea of ORMs. Most of them are disappointing, though, in that you have to jump through silly hoops, and they feel quite fraglie. SQLAlchemy is the best open souce ORM available in nearly any language, IMO. I don't think you can do them right without metaobjects/classes, and very very few languages have that sort of thing. (Python, Common Lisp)
As Koroviev pointed out, the % operator has been deprecated in Python 3.1 http://docs.python.org/py3k/whatsnew/2.6.html#pep-3101 So start using the .format() function instead, which is in 2.6 onwards. If you want to know more about the % formatting, apart from any good Python book, another good place might be the printf function documentation in any C book, cos that's where it is derived from. 
i'm assuming localhost\master is referring to the instance? if you're using SQLExpress edition the default instance is localhost\sqlexpress also, stupid question but are you sure the slashes are all correct? I don't have any web2py experience but have worked with django and pylons/pyramid
the syntax is: mssql://username:password@localhost/test test being the db name but thanks for trying ^ ^
I tried and the first question went though and now i think they are blocking me :( ... to be honest my first question wasnt the best but this one has code and a lot more work behind it so im at a loss 
I thought it might be useful to make 2 other notes: (1) First off, it may help to clarify something: When I say "copy the database into memory" ... this would mean copying the data into Python vars and objects... then you would have a Python library that give you "database-like" ability to manipulate those objects. The database is just the way to backup to disk or for a central storage. (2) Your post brought out a good issue I hadn't really thought about. When you back up the Python objects/vars, you have to make sure you don't corrupt anything. One method would be to store a list of all the changes you made in memory and flush them as commits to the database all at once, every now and then. A second, would be to lock the Python objects temporarily, copy all the data and dump the whole thing to a file. There may be other options. So, yeah, there's probably a lot of effort required to make a Python library like this.... (and, after considering your post, maybe even a little more complicated than I may have considered).
Some of them are definitely bots
Nothing turns me on more than looking over and seeing a terminal with python in it on her screen. She has only been doing it a couple weeks so she doesn't understand all the concepts but I'm slowly working with her to improve the code.
Awesome. Only suggestion out the door is getting her blog to do syntax highlighting and do better line wrapping to make the code more legible.
Bookmarked for future perusal. The family that devs together, stays together!
Nothing turns me on more than looking over and seeing my python in her. She has only been doing it a couple weeks so she doesn't understand all the concepts but I'm slowly working with her to improve the code.
This issue is [being addressed on the web2py mailing list](http://groups.google.com/group/web2py/browse_thread/thread/6a7c1c6051af5845#). Looks like pyodbc is unable to connect to db. It is not a web2py specific issue. 
Wow, that's super cool! I left her a comment about her Caesar Cipher post. Spoiler alert: the solution I came up with was: &gt;&gt;&gt; a = string.ascii_lowercase &gt;&gt;&gt; def encode(input, shift): ... tr = string.maketrans(a, a[shift:] + a[:shift]) ... print "Your encoded message is: ", string.translate(input, tr) ... &gt;&gt;&gt; def decode(input, shift): ... encode(input, -shift) ... It would only require a minor modification to handle uppercase letters as well. This demonstrates a few things: first, that if maketrans is useful in a one-off, it's probably useful for repeatability, too. Second, the nifty syntax of sequence slicing. And, finally, the reinforcement of thinking of functions abstractly in the way that encoding and decoding are reverse operations, and defining decode() to take advantage of that. I think you've got a keeper, sontek. Don't delete that name reference. ;)
lulz you linked me to my conversation 
Nowadays very impressive web apps can be made. Look at Google docs. But from a user experience point of view rich clients (or desktop apps) are superior in terms of responsiveness and consitency of use. Web apps can be made very fancy and flashy, but for "real daily" work users need consistency and snappyness of the application. I would base my decision on: 1) Is there considerable processing of local data? --&gt; Rich client / Desktop App 2) Do users work regulary with your app for longer sessions? --&gt; Rich client / Desktop App 3) Is the interaction with the app trivial? --&gt; Web client PyQt is a very good choice. It let's you create responsive, good looking and consistent UIs with key bindings and everything. For the database end: I'm currently using MongoDB with the python driver for prototyping stuff. It can't get any easier. Very smooth. I've written my DB-connection layer myself, but I think there're some mappers for MongoDB available.
If you're willing to go with wxpython instead of Qt, then [dabo](http://dabodev.com/) does pretty much exactly what you're asking for.
I do believe I saw this the first time 'round. A brilliant sketch! P.S: It's a parody of: http://www.youtube.com/watch?v=TqAHHhr7vmU&amp;feature=player_embedded#!
I needed that. I can see old Guido Watching these episodes. Dry humour at its best. 
Awesome! She probably knows more than me. I just started learning python 2 weeks ago and I'm getting addicted to it. "working with her to improve the code" - oh is that what they're calling it now a days? ;)
I'll learn your wife a python.
housewife_whacker!!
Since this is about growing a project… PEP-8 style isn't optional at any scale. Burn it into your brain once and for all so your own code doesn't become unappealing to work with.
They are probably improving the genetic code :D. 
Some points were new to me, some are arguable. All in all a good read. tl;dr DO repeat yourself. Separate tests. Avoid doctests.
..the hard way?
Prefering local, per-test setup/teardown code is a nice hint, and is compatible with *DRY*. e.g. creating a collection of test fixtures each single test can pick up and use. -- not sure what else "Do repeat yourself" would mean here. I think that's one of the strength of nose compared to unittest: it's quite tedious to set up a local per-test fixture whit unittest, when a simple decorator does the trick in nosetest. And fixtures can be reused for a group of test. That group not being necessarily the whole class. 
I've been trying to think of a way to get my girlfriend to do this, as it used to be an interest of hers and she hasn't been opposed to it when i asked her. I think i just need to find an interest of hers.. something to program for/on that she would enjoy. Any tips?
They're both excellent :D
I think the best thing to do to help motivate/improve her skills would be for yall to work on a small project together. As long as the project is motivated, it'll be sure to give you two something to work on and discuss while having fun and learning.
That's really cool - I hope one day to have a wife awesome enough to learn Python. sontek's wife, you rock. Your code looks pretty good and I'm sure you'll make a fine Pythonista one day. :)
Arduino. Controlled. Dildo.
**Why is she blinking so much**?!?!
I don't see the advantage to use mindom instead of the ElementTree-API of the standard lib! DOM might be acceptable in other programming language, within Python there are better ways to deal with XML as proved by the ElementTree-API.
LOL. I know. This was mostly for other readers who do not follow the web2py mailing list.
That's just it, isn't it? Even people who may be interested in learning program (python or otherwise), never do so, because they simply don't have an itch to scratch. I dabbled in python for a long time, but never got anywhere with abstract exercises like those in 'How To Think Like A Computer Scientist' (free, online, excellent, BTW). Then I found a little open-source command-line image collage making software called feh, and my python scripting began in earnest, creating programs to abuse feh in various ways to create art. Only then did I finally learned why people are so passionate about python: because it *rocks*.
No, thats your job. Next time call a spade a spade and just post: &gt; Hey guys, im totally awesome cause my wife codes python too. Arent you so jealous???
Pretty cool. I was working on a Turing machine implementation as well, but I think yours is probably more efficient. One of the first things I noticed here is lines 15 and 16. Why not simply use TuringInstance.running instead of making a method that retrieves that value?
Could you explain in more detail (the style you want and the style you don't want that most servers use)?
maybe she like art ? try making patterns with turtle-graphic: import turtle as t for x in range(100): t.fd(x) t.left(30) 
Mm, so - two queues on each side, one incoming and one outgoing. Three threads, one for processing, one for receiving items and putting them on the incoming queue, and one for taking stuff from the outgoing queue and sending them. Right?
"if not(value in validnums) would be prettier as "if value not in validnums" I agree that the big for/else with all the breaks is hard to read. Maybe add a helper function called all_quaples_valid
Sometimes a huge if block can be avoided by using its negative version: if value in validnums: continue #rest of block here unindented
Questions: A server is an "event" system by it's nature. Something requests the data, the server sends a response back.... So, what happens if there is nothing to send back in response? It seems like you would need data in your queue before you can send a response; where is this data coming from. On the browser side, your *only* option is an event model, since that is has javascript works. You send a request (ajax) and wait for a response back from that very specific request; this is the only way to get data from a server, since the server cannot "push" a new request to a client; it must be requested by the client/browser. So, to achieve what you want, you have to work within these limitations. You could run a "constant" series of requests, where you send a request to the server from javascript asking if there is any new data. If so, it will take the data from server.queue and send it off to the browser... but don't do this over the web. :) Of course, there may be lots better way to do it, but I gotta go for now. :)
I feel silly for missing that. Post updated.
I'm not sure I read your code correctly but I think you can reduce your indentation level by replacing patterns like: if [condition]: lot of code else: break by : if not [condition]: break lot of code
Nice xD im just started on turing machines in automata 
It is always interesting trying to optimize code, it may not be the best solution but here it is what I got: for value, validnums, strtab, timediff in quaple: if value in validnums: continue if '%' not in strtab or breakOnAtoms(strtab.split(','),timediff): break else: return getWeekDay(year,month,day) def breakOnAtoms(atoms,timediff): ok = False for atom in atoms: if atom.startswith('%'): modulus = int(atom[1:]) if not(timediff % modulus): break else: ok=True return ok def getWeekDay(y,m,d): return (datetime.date.weekday(datetime.date(y,m,d))+1)%7 
I've done that as much as possible. As far as I can tell, there is no other way to arrange the if... conditionals. My only qualm at this point is how I had to go about doing a for else loop inside another one.
Yo dawg, we herd you like Turing machines, so we put a Turing machine inside yo python virtual machine, which can be approximated by another Turing machine. So you can run yo code on Turing machine while running yo code on Python Machine approximated by Turing machine.
The processing thread takes things *off* the incoming queue, you need another thread to put stuff *on* it.
You should leave the original code up so people can see where are we going. Maybe split it in two sections, before, after...
Thanks for taking the time to look at my code. If there is no getting around the for...else... cleanly, I will probably end up just keeping it inside of one function so I don't have extraneous methods in the class or functions in functions.
Good idea; done.
You looking for [this](http://www.barrucadu.co.uk/turing-machines-in-python) ?
There is no point in having the same thread put stuff on a queue and consume from it, then you might as well just take the network messages directly and process them. If your processing thread is then slower than the messages, your network buffers will fill up and you will have degraded performance for both the server and client. If your processing thread is fast enough, there is not reason to use a queue at all. Note that Twisted queues up network messages for you.
In Version 2, the elif '%' not in strtab: break is superfluous. If % is not in strtab then all atoms from the split will not start with % and the for loop will default to else causing it to break. This might or might not be more efficient; it depends on the length of strtab and the number of commas it contains. The code would be 'cleaner' but maybe not 'clearer'. Sometimes you have to make the code a little bit dirtier to keep it readable. Add comments!
It hasn't been deprecated. It says right there in the page you linked that .format() is an addition to % operator, an addition which has also been backported to 2.6.
The tutorial isn't easy if you have no programming experience. The book he's using or Think Python are better suited for a complete beginner.
See also [Plac](http://micheles.googlecode.com/hg/plac/doc/plac.html) for another argparse wrapper.
One of the coolest things you can do in Python is scratch the tiniest itch. Look at your computing lifestyle and find these tiny itches and scratch the hell out of them. Find the tiniest thing that bothers you and *try* to fix it. I guarantee you there are hundreds of itches to scratch for fun. Maybe start there?
The Project Euler problems aren't particularly hard in python because it's got such a strong standard library. I would expect a maths major with a decent understanding of the language to be able to do most of them. I wouldn't use them as learning exercises as they don't really build on one another. Think of them as a kind of end of term test; once you can reliably solve an arbitrary Euler Problem then you are no longer a beginner. Is there a specific problem or class of problem that you're having trouble with?
Its just a by-product from other languages I program in. I actually prefer it, as I'm a big fan on having a getter function to return a private variable
I'm surprised you're finding it difficult. I found most of the Project Euler problems to be too mathy for me. Do you understand the mathematics involved in solving these problems but can't grasp how to code it?
That's actually the exact problem I'm having. I don't know a lot of programming tricks, so I get stuck not knowing what to do. For example, the pythagorean triplet one (where a+b+c=1000), I got stuck on, and I easily solved it by hand while spending another hour or two just googling ways to find a bunch of solutions to the pythagorean theorem. The one that I tried the other day before just giving up was the one to find the first number that's divisible by all digits below 20. My code was literally just something like: for x in range(0,99999999,20): if x % 19 == 0: solution + 1 etc. etc etc. if solution == 14 (or however many if checks I did): print x maybe I'm just bad at programming and I should give up :(
Could you maybe give me an example of this? Sitting here trying to think of one is probably making it more difficult to actually come up with something.
You'll never be a programmer then. It's something you have to work at.
Yes, Project Euler can be used as a learning tool, if you have some help. If you're having trouble with some particular problem, why don't you go over to the [python-tutor](http://mail.python.org/mailman/listinfo/tutor) mailing list and ask? Post what you have, how you think the problem should be approached, why you can not express this approach in code, and ask for *hints*. I hang around there too, and it works great. You don't have to do all learning by yourself
Write a python script to download a page given a URL and classify it, based on keywords inside that page.
Good point. Still, removing that line will probably increase execution time (albeit trivially, especially since this is for a cron); the vast majority of cases will not have '%' in them which means the split and search would have been for nothing.
This is pretty much the way to approach most if not all personal projects in my opinion. It's hard thinking of ideas, but if I step back and think for a second of what *my ideal workflow* would be for a given task, I can usually find something to automate or hack around with. And I believe Python is a language strongly suited to that :)
How does this differ from [plac](http://pypi.python.org/pypi/plac)?
Here's one I've had a few times (albeit, better solved with bash, but I digress): * Change the names of all the images in a directory from DSCxxx.jpg to Colorado_vacation_xxx.jpg
The major problems I see in setup/teardown is to adequately balance the repeatability with the speed of execution. You can make something very repeatable and correct say by destroying and recreating the service for each test. But this lengthens the time that it takes all tests to run. It is more pure to create, test and destroy than to run operations in reverse. At the end of a test suite the system should not have visibly mutated. The other biggest mistake I have made in testing is to conflate the area under test. Just because you are *right there* doesn't mean you should grab just a little bit more coverage. Each piece of leaf functionality should only break the test specific to that functionality. When you refactor, you have less test code to fix and all of those other little ad-hoc tests sprinkled throughout your testing codebase do not offer an advantage. They are a liability. If you have a situation where it is very difficult to get the application into a state, and even in doing so you will trigger bugs then you should create a bridge, a piece of utility code for setting up a large body of tests. It can have asserts to prove that you are where you think you are but *it is not a test.* Once you have arrived at this setup state, then create many smaller leaf tests each only covering a small piece of functionality. 
Nose and Py.Test are vastly simpler than *unittest.* It is a shame that a functional test library like Nose or Py.Test is not in the standard distribution. The inclusion of *unittest* gives people the impression that it is the preferred way. I usually create a utility library that puts a series of classes in a known good initial condition where my areas under test can then be exercised. def test_affiliate_blacklisted( self): self._affiliate_off_state_helper( 'beth','BLACKLISTED') Where _affiliate_off_state_helper() does setup and common assertions. Each individual case should be very clear and succinct. 
Wow, what a rotten thing to say. Not only is it unkind, but it's also so wrong as to be meaningless. Not being able to solve one kind of problem is no indicator of programming ability. Bad malfy, baaaad! And get down off the couch. No treats for you!
You may be interested in [Programming Praxis](http://programmingpraxis.com), which provides a collection of etudes, updated weekly, for the education and enjoyment of the savvy programmer.
The first program I write when teaching myself a new language is the [Caesar Cipher](http://en.wikipedia.org/wiki/Caesar_cipher). It is just far enough into string processing and program flow to teach a bit about how the language works, and you can google it later and (sometimes) find an idiomatic version that shows better ways of doing it in that language (which also makes you say, 'huh, I never thought of that'). I say sometimes because it appears as if everyone who implements the cipher in python uses the *ord()* and *chr()* functions, which seems wonky and outmoded to me, even if it may be the most efficient way. When I wrote my version of this code, I used a dictionary lookup instead of *ord()* and *chr()*, and it taught me a lot about how Python works.
#warfarink: &gt;maybe I'm just bad at programming and I should give up :( #malfy: &gt;You'll never be a programmer then. It's something you have to work at. That's how you should read that interaction.
Which is, I think, a rather beautiful response. 
It's open source, if you want to comment on my style, give me critiques or whatever. Basically, it's a mortgage calculator that can calculate any of the 4 variables (principal, monthly payment, interest rate, number of payments) based on the value of the other 3. I used tkinter, and I even wrote some unit tests. I've also compiled mac and windows versions if you find such a tool useful. Sorry Linux dudes, I don't have a clue, but you should be able to run mortgageGUI.py and get the same functionality. I have several plans for how to make it better, but I am certainly happy to hear your opinions on why it sucks, or what it needs to do better.
Doing the Caesar Cipher shouldn't require any of those things, though. It's good to practice with what you've mentioned, but really: from string import maketrans, letters "I am Caesar.".translate(maketrans(letters, letters[6:] + letters[:6])) Add `string.punctuation` too if desired, or make one with variable shift.
See, this is exactly what I'm talking about. I had no idea that anything like translate/maketrans even *existed*, and just talking about a learning exercise is teaching me new things. Of course, my version only translated letters, and left the extended ASCII alone ;)
Also [Python 3.1.3 RC1](http://article.gmane.org/gmane.comp.python.devel/118715). 
Based on [this comment](http://www.reddit.com/r/Python/comments/e5r6d/is_project_euler_too_lofty_a_goal_for_a_beginner/c15ixo9), I'm ready to diagnose your problem. It's not that you're a bad programmer, it's that you didn't realize that most of the Project Euler challenges are *trick questions*. They are designed so that the straightforward solution is *impractical or wrong*, so that you have to learn about a mathematical fact to make a solution that runs in a reasonable time. There are two tricks to get around this which will help with almost every Project Euler problem, both of which are neatly illustrated by problem 5, the one you posted code for in the comment I linked to. The obvious idea is to check every number until you find one that is divisible by 1 through 20. That will take a while, so the first trick is **reduce the search space**. You already figured out that you'd only need to check every multiple of 20, but that still requires checking millions of candidates before finding the solution. Then, for each candidate, you checked whether it was divisible by *each* number less than 20--even if it had already failed one of those checks. The second trick is **fail fast for wrong answers**. Taking the second trick (fail fast for wrong answers), we could change your if x % 19 == 0: solution += 1 if x % 17 == 0: solution += 1 ... if solution == 14: #or whatever print x to if x % 19 == 0: if x % 17 == 0: ... if x % 3 == 0: print x We stop looking at a candidate number as soon as it fails one of our checks, and move on to the next candidate. Does it make sense that this would be faster? For the first trick (reduce the search space), we can improve this part for x in range(0,99999999,20): by thinking about what qualities the solution will have to possess. A number that's divisible by 2 and 3 has to be divisible by 6, right? If it's *also* divisible by 5, then it has to be divisible by 30. So a number divisible by all of the primes below 20 is divisible by 2\*3\*5\*7\*11\*13\*17\*19, or 9,699,690. So the `for` line becomes for x in range(0,999999999999,9699690): and we're moving through the search space roughly 500,000 times faster than you were when counting by 20. So, when encountering a new Project Euler challenge, ask yourself these questions: * How many possible solutions are there? * Is this higher than my computer can count in two minutes? * If so, how can I avoid checking possible solutions that I know are wrong? * For the possible solutions I do check, how can I detect incorrectness quickly? **tl;dr**: It's not you, it's Project Euler.
A pirate's favorite argparse wrapper.
To me it is quite the opposite. Projekt Euler questions can perfectly well be solved by novice programmers. But the result will ALWAYS be extremely slow. If you want to solve it PROPERLY you NEED to be a math major. You shouldn't have any problems, I guess :)
wow, thanks so much! those two tips helped me figure out why my computer slowed to a halt when I ran my code and never returned an answer. I'm going to go make some revisions now :)
except you can't use bash on windows (well you can if you like pounding your head into walls)
Are you kidding me? It's an *excellent place to start*. 
i've just recently started using wxpython is there any gui designer for tkinter? I prob wouldn't use wxpythong without wxglade (even though it is unintuitive)
_Caveat: I have only solved around 113 or so problems, so if you're past that already, feel free to disregard._ For the average programmer, I would say that about 20-30% require explicit "math" knowledge that is domain specific, e.g. Euler's totient function, that even a capable CS student would not have been exposed to. Another large chunk of the problems ostensibly require only basic mathematical knowledge, but are not tractable unless you apply some mathematical insight. The remainder however, require specific knowledge of algorithms and are more CS in nature than math, and I think these are far more useful for someone wanting to learn/practice programming. I've just tried to go through the list, splitting them into categories (e.g. simple math but tricky programming vs tricky math and simple code) but only made it to problem 43. Instead I think I will just warn you about gotcha-problems. Problem 54 sucks. Not hard math, not hard programming but just really tedious. Many people who solved it disliked the problem and made it known in the discussion. Problem 64 was pretty tricky for me. Problem 69 begins the first of a recurrent theme of problems that are tricky unless you grok the totient function. Problem 79 can much more easily be solved by hand. Problem 96 can be rather straightforward as solver can be easily written to solve almost all the problems. You can either extend your code a bit to solve the rest (like I did) or work out the remaining 4 or so by hand or via another solver. Problems 162, 173, 205, 206, and 307 are significantly easier than their neighbors. I have slowed down working on these (now I sleep during the night rather than hack away :) ), but let me know if you want to check ideas or work together for other problems. (Not giving the solution, but rather shooting down bad ideas/giving hints when stuck.) EDIT: PS-- great choice on using Python. Sometimes the ability to handle big numbers and the presence of itertools makes the problems so easy it feel like you are cheating. I prefer to think you simply chose the correct tool for the job. ;)
I don't think there's a gui designer, if there is, I didn't use it.
I think you're being too hard on yourself. Based on some of the comments you made, you have solutions to some of the problems, but you think they aren't good enough or fast enough. The nature of a good programmer (like a good writer) is not to write it perfectly the first time, but to be able to write it, then look again, and rewrite it better in an iterative fashion. When you finally get a solution that is fast enough and correct, then checking the forums for the solved problem will let you see others solutions and that is another great way to learn: Try something yourself, and only after considerable effort see how others do it. And if you are still discouraged, then go out and build something yourself, or fix bugs, or learn more languages. It's a big ocean out there, but just enjoy yourself whatever you do. 
Let's talk about this problem (Problem 5 for those of you following along at home :) ) because I think it demonstrates the spirit of PE nicely. Your approach: start with 0, and check if it passes the 20 necessary tests (divisible by 1, 2..20) Another faster approach: we need a number that is divisible by every number 1-20. Let's start from the beginning. 2 is divisible by 1 and 2, but not 3. Ok, 6 works for that. However, 6 is not divisible by 4. We could just multiply to get 24, but we already have a factor of 2 in there. 12 would fit the bill. AHA! That's the key to solving it-- we need to find the prime factors of each number first, and ensure the product's factors includes (but does not exceed) the factor list for each number. Now that's basic math and I'm sure you knew that. If this were a written problem, you would have had the answer 5 minutes ago. Here's where the programming challenge kicks in-- how do we efficient track the factors we have used? There are a few ways to do this, and I'll go through two of them. Do you know about dictionaries? They are a nice way of associating key-value pairs. So if we want to track a value, such as a factor, and it's multiplicity, we can just say factordict[factor] = multiplicity This is nicer than using a list because look up is way easier. (You would have to add each factor explicitly to a list-- 8 would be [2,2,2] or use a list of lists with factor and mult-- for 8 [[2,3]], for 14 [[2,2],[3,1]]) So, for approach number 1, the method would be: Create an empty dictionary to track the factors required for the product. Loop through the numbers 1-20. For each number, factor it into primes. For each factor value, check the multiplicity in the product dictionary. If the new multiplicity is greater or if the factor itself is new, add it to the dictionary. When the loop is done, iterate through the factor multiplicity pairs and multiply the whole shebang. OK, that was approach number 1. Let's do it differently now. This time we will keep a list of the numbers 1-20 and step through it. We will multiply the value by a variable that will track the growing product. To make sure we don't use factors too often, we will cancel out the factor from the remaining numbers in the list. Let's do it for 1-8. Start with [1,2,3,4,5,6,7,8]. Your product variable starts off as 1. Now for the loop: Start with 1. 1x1=1. Now 2. 2x1=2. Now we need to cancel it for the remainder. The only remaining digits that have 2 as a factor (i.e. n % 2 == 0) are 4, 6, 8. Divide those by two in the list so the list is now: [1,2,3,2,5,3,7,4] Go on to three-- the value is now 6 and the list will become: [1,2,3,2,5,1,7,4] The next value is 2, so that makes the list [1,2,3,2,5,1,7,2] and the number 12. Hit 5 so 60, list remains the same. Hit 1, no changes. Hit 7, so 420. Hit the final 2 and you're done with 840. This is MUCH faster than iterating and checking (aka brute forcing). *I can almost guarantee that if you're looping and checking, there is a trickier but faster way to do it.* The key bits of knowledge you'll need to know for the second bit that is Python related is that you can't iterate over the list while mutating it. I hope this bit of explanation about mindset helps. I love discussing PE stuff so feel free to PM/message back if you want ideas on others.
Even simpler (you don't even need any imports): "I am Caesar.".encode("rot13")
If encouragement is mean, so be it. Man up, and stop crying like a sook like me, 'cos you can't solve a problem. Programming is art, learn to love it and develop an appreciation for it - just like math. Eventually you will find Nirvana and a blissful state of mind. I still have problems with some string manipulation in C/Python along with types and pointer bugs. I also have horrible logic bugs in almost all my code. I hardly use OO techniques unless I really have to and I re-use code everywhere...but I still love programming. EDIT: There was a reddit post a while back discussing how people who find programming easy, are actually harming themselves due to the fact that programming is actually hard, and their self-confidence will actually be increasingly lower each time they encounter a hard problem.
pyqt4 + Qt Designer is the nicest, in my opinion. But I might be biased, because I prefer to place my own controls instead of relying on a vague sizer container to do it for me.
Project Euler is great if you want to program like a computer scientist thinks. I like it for that reason. As a math major, I wouldn't be surprised if that's what would interest you in the end either. It's not what many people who think of as programmers would think of as programming though unfortunately; The focus is on elegant solutions to hard problems, rather than hitting things repeatedly with a hammer[0]. I can't remember if the rules allow it or discourage it, but it might be helpful to have someone with a strong background in this to be able to point you in the right way every once and a while; The hardest bit about Project Euler is knowing /what/ technique to use. For example, if you don't know about the existence of dynamic programming, it's pretty hard to even consider it as an option. Having someone that can suggest you look up some dynamic programming techniques would help you learn more than bashing your head against a brick wall. Project Euler is a really steep learning curve, and really quite difficult. The upside is that if you can do it, you're not going to find anything else very hard afterwards. [0] Maybe I'm dissing out software engineers a bit here, but it honestly seems what some of them do. It makes me cry inside.
I actually did this problem by hand, because I realized that the answer is the least common multiple of those numbers, which you can compute easily by prime factorization. 
I noticed this about 4 years ago as a freshman fooling around with Python. I didn't think much about it. It does violate the principle of least surprise, but it's something I hope nobody would actually do in practice.
Python is (usually) compiled into fairly systematic byte code, and that is fairly easy to de-compile. This makes Python not be a good option for you to hide the low quality of your code, I'm afraid.
Good job on taking this step. &gt; It's open source, if you want to comment on my style, give me critiques or whatever. Coding style is definitely subjective, but there are a couple of things that are good to keep in mind: * Pick a line length and stick to it. That allows me to open my window to a certain width and not have any wrapping. I prefer 80 characters max per line, though you can argue it's outdated. I like it because you can see it on smaller screens with larger fonts, and because it forces you to put less on each line, which is better for clarity. Right now, you have a *lot* on each line, so 182 characters definitely seems too large. * There's some sloppiness overall, such as extra blank lines in some places, whitespace at the end of lines, and arbitrary switching between single and double quotes. Not *too* important, but it's good to be disciplined. I'm sure you wanted the functionality first, but when you go to clean up (and you should), think about how you want others to see your code. Get rid of old functionality that's commented out, document your classes and methods, and so on. &gt; Basically, it's a mortgage calculator that can calculate any of the 4 variables (principal, monthly payment, interest rate, number of payments) based on the value of the other 3. I used tkinter, and I even wrote some unit tests. It works just fine. Though, I was confused when I first started the application. Perhaps you should have a help message at the top that says, "Fill out any three of the boxes below and press Calculate next to the fourth box." &gt; I've also compiled mac and windows versions if you find such a tool useful. Sorry Linux dudes, I don't have a clue, but you should be able to run mortgageGUI.py and get the same functionality. Works fine on Linux as you said. Of course, it should work fine on Windows or Mac too when you run mortgageGUI.py, since that's just good practice. &gt; I have several plans for how to make it better, but I am certainly happy to hear your opinions on why it sucks, or what it needs to do better. Good job overall.
Some useful answers here. One guy pointed out that you could make a small C extension to hide the part of your software that's secret. You've also got to bear in mind that almost everything can be reverse-engineered, and everything can be pirated. What do you want to protect your code/program/business from? http://stackoverflow.com/questions/261638/how-do-i-protect-python-code
Make web services and appliances. Control the hardware that runs the software.
I want to protect my games from people copying them too easily and putting them on their own websites and seeing my methods which i've worked hard on optimizing (for example my advanced path finding algo).
Do you know software I could use that is not easily decompiled? How about c?c++?c#?gml?cocoa?java?
Many PE problems can actually be done more efficiently by hand, especially the earlier ones. I recall one problem (79 from my other post in this thread) where basically _everyone_ solved it by hand.
In your particular use case, I would suggest that you use Cython (think C for Python) to code your algorithims and make them available as extensions to the other parts of your code base that require it. Since Cython code is compiled you also get a nice speed boost this way.
Can people still decompile the cython code?
Yes.
If project Euler is too "mathy" and you want to learn more about python and less about prime numbers, try the python challenge. * http://www.pythonchallenge.com/
I think decompile cython is as easy(or hard) as decompile C code. maybe put the secret algorithm on your own server is the only way to protect it(as long as the server is safe).
There's a better alternative to wxglade called wxFormBuilder.
Huh, I saw a not-obviously-related blog link and thought it was spam. Sorry about that.
The real question is: who do you want to keep your path finding algorithm from? I'm going to go out on a limb and assert that Blizzard isn't interested. In which case. . perhaps other indie developers? Are you afraid of a full-on clone of your game or just them taking your path finding algorithm and repurposing it? No matter what, the majority of devs aren't going to bother even the effort of reverse engineering actionscript or python, unless it is truly best-in-class. And if it is, even writing it in C or C++ won't stop the reverse engineers. -- If you do want to go down that road, personally I would write everything in C and start looking at the anti-tampering / anti-debugging literature. But, be aware, that it a major investment in time and mental energy. [edit:typo]
How would I even go about writing the logic for 79? I've done ciphers and such by hand so my superior human mind could solve it, but trying to state explicitly my method and code it, meh, confuses me on how I'd work it.
You know, I'm going to suggest that you dive into list comprehensions. Since you are a math major it should appeal to you and may actually be easy because it's set theory and lambda calculus.
Thanks for the suggestion! I'll make a confession, I'm only a second year math major so I haven't done too much theory yet, but reading the wiki page for lamba calc looks like a lot like calc with programming logic thrown in.
I'll show her how to get syntax highlighting on there. I know a few javascript libraries but do you have any suggestions? I use pygments on a custom blog engine for mine but shes using blogspot.
Open a few files on disk and parse them for the most arbitrary pieces of information. The program you write up doesn't have to be useful or the best thing ever created; it just has to meet it's goals. Go through some emails from Bob, sort the words Bob use most and see what's Bobs favorite word is? Totally useless and pointless and maybe perceived as borderline stupid but fun and you'll learn things regardless by making your programming personal to you. You can either inform yourself and nothing more "Bobs favorite word is Fish, after 'the' and 'a'". You can perform an action like "Email Bob his favorite word of the month". To some it'll sound simple. For others this would be hundreds of lines of code to do as correctly as possible. You may need the os, glob, mailbox and re modules to complete this. Depending on what you want to do exactly you may end requiring the shutils and sys modules. But it sounded simple didn't it? Brings me to another point. Nothing is simple. If it ain't "print 'hello world'" chances are it really isn't simple. So you may be discounting problems you *think* are simple whereas in reality you're far away from the truth about them. One of the worse things you can do is go into problems thinking "This is gonna be simple". Do things for fun and for informational purposes only or perform some actions based on the information or both. You have all types of issues and itches dying to be scratched and some problems no matter how obscure may help you further understand what is and isn't possible. Here are some tips in finding them. Approach your computer with this idea "I wish xxxxx". Keep it short and simple. Got it? Go for it. Or use this "What if xxxxx". It can't currently be done? Go for it. "I hate xxxxx the most". Try to fix it. The simpler you try to fill out the blanks the more surprising the problem may present itself in the end. Good luck! 
She loved the fact that I work from home and have the freedom to travel and asked if it was easy to learn, and since shes pretty logical/mathematical already I told her it was pretty easy. So I told her to go through google's lessons: http://code.google.com/edu/languages/google-python-class/introduction.html and after she went through them she realized she actually enjoyed it. I think the biggest thing is to be helpful, usually when a buddy asks me about a problem I give them a hard time about not doing the research/reading documentation before asking me but with her I think she likes me helping instead of pointing her to docs because its something we can do together.
Well, yeah, but that doesn't work in general for arbitrary length. But if all you want is rot13 sure.
Thanks for the feedback. I took all your advice, except the thing about the long lines. I may do something about that at some point, but for me it works pretty well, as my screens are all 16:9, so there is plenty of room on the right. In notepad++ on my laptop, it goes 230 characters before I have to do any sideways scrolling. On my desktop, it's even farther, I think.
If you're trying to make a career out of casual games, what I hear about it from many people who do it is that you have to be *constantly* coming up with new stuff, no matter what. You can't just sit on one piece of code and say "this is better than anything else that exists! NOW I HAVE A USERBASE FOREVER." People can go to all the effort to decompile your code, but here are other things they can do that are much easier: * They can just copy your entire game, without decompiling, and put their own ads on it * If your game idea is successful, they can make another game with the same idea (and players won't care if your path finding algorithm is better) * If your game idea is really successful, Zynga will take the idea, make it worse for players but more addictive and more "monetizable", and spam it all over Facebook (that's their business model). Even if none of those happen, your player base will eventually lose interest and move on to the next thing that captures their attention. So every minute you spend being paranoid that someone will copy your *algorithm* is utterly wasted, and you should be using that time to come up with the new things that will actually make your games succeed.
http://wxformbuilder.org/ They can't even keep their website up (and it isn't written in python) why would I want to use it?
Yes, the website is down. Do you stop using Reddit every time it's down? [wxFormBuilder](http://sourceforge.net/projects/wxformbuilder/)
your just gonna let him rip on you like that?
you didn't mention you are doing games, you know civ4 makes big use of a python scripting engine, you might as other people have suggested need to use more than one language if you wish to prevent people from stealing all your work, however civ4's use of python and the boost C library allows it to become even more extendable
Yeah, because everyone shares your idiolect. Seriously, most Europeans looking at `.5` think "WTF?" unless they've learned about the notation when they were introduced to number literals. Same goes for `5.`, which happens to be well-formed Python, too (though I fail to see any use outside the interactive shell).
probably wouldn't be here if it wasn't working the first time i tried to use it :/
Two approaches were discussed. One statistical, and another looking at what cannot be the first digit and excluding them from the first digits of the lines given. Without giving it away, you can see the remaining steps...
Page does not exist!
yeah, link's broken--EDIT: github's database's were [overwritten earlier today](https://github.com/blog/744-today-s-outage) so they spent the day restoring the site from backups. explains the outage
I think you're looking at it wrong. The problem isn't the cost of bandwidth. It's true that this will be negligible outside Google/Facebook/Yahoo scale. The problem is performance (think low-bandwidth users, e.g. mobile devices) and performance is directly related to conversion rates (i.e. "stickiness" of visitors). For the majority of sites this isn't really an issue either way, and common sense helps making it less necessary (e.g. DRY code probably means smaller file size regardless of minification), but the same is true for most techniques -- e.g. SEO (which is 90% common sense anyway). The costs of implementing minification as a step in publishing are so minute, however, that it doesn't really hurt to use it, even if it could be regarded as premature optimisation. For example: I write my stylesheets in Sassy CSS and my scripts in CoffeeScript. Sass has a switch to provide minified output (in CSS, this mostly boils down to stripping unnecessary whitespace), so it's as easy to do as providing non-minified CSS. CoffeeScript doesn't have this, but it's easy to chain it to a JavaScript minifier. This is quite different from supporting IE 6: for most sites, the advantage -- in terms of conversion rates -- of fully supporting IE 6 is pretty small in comparison to the effort it takes to provide that support. Because "backporting" the site to IE 6 may mean a high investment, it's very important to check your demographics before making that decision. Minification on the other hand usually has an investment that is barely noticeable (even if you have to write a script or two for your purposes, you'll probably be able to re-use that in all following projects).
Women who know Python are hot. Even if they are not. But, if they are, then they are very hot. On a side note: code samples that show once and for all what feminine logic really is would be quite valuable to husbands around the world.
That's why nice web developers provide unminified copies, too.
With estim.
[Mongo](http://www.mongodb.org/) stays in memory if memory is available.
Do you think its possible to out zynga zynga? as in, find the games that are succesful on their network, and copy them? If I host my own game, how would anyone know its succesful?
Its not just the path finding algo. I make (I think) quite innovative games. So yeah, i'm worried they'll get copied and profited from (iphone devs, zynga etc.). I'm considering leaving game dev for that reason. Can't stand other people stealing my work!
Wheres the rip?
I was thinking about something similiar, but using fabric to connect through ssh to make archives, and then just download generated archives. What do you think about doing it that way?
:| didn't this used to be newer than my comment?!
Consider sticking to PEP 8 when it comes to code style: http://www.python.org/dev/peps/pep-0008/ Line length is not only about your screen size, but the space one *wants* to give your editor, console, etc. Also reading long lines is usually a lot slower than a narrow block of text for most people. EDIT: for commenting I recommend PEP 257: http://www.python.org/dev/peps/pep-0257/
&gt; Do you think its possible to out zynga zynga? It depends. Are you evil, in bed with Facebook, and hiding a team of marketers somewhere? 
Seems like this guy missed every piece of news about IronPython over the last month. * No more Hugunin, no more Microsoft involvement. No need to put out job recs, it's a community project. * Accepting patches soon, probably once 2.7 final goes out and the infrastructure is all setup. Jeff Hardy already made his first commit the other day. Overall, this boils down to "there are bugs in IronPython".
Civ is probably a bad example. I hear the Civ series is famous for open-sourcing older titles (not necessarily in the FLOSS sense, though).
If the games are innovative enough, it's not the implementation that will be copied, it's the gameplay. And no source code obfuscation can prevent anyone from doing that.
What's also interesting is that you don't need to "import os.path" - I always just "import os" and just use "os.path.isdir()" or whatever. I'd never really stopped to think about why it worked, so it's interesting to see this explanation (from the opposite viewpoint, but the explanation fits both ways).
I think the reason you are getting downvoted is because you seem ignorant of the way a computer program works. You cannot prevent decompilation. Even compiled code is still readable: C++ is compiled to machine code, which is a low-level byte code but still a programming language in the sense that it's a codified series of instructions. Java and its JVM cousins (Scala, etc) are compiled to Java byte-code, which is a bit higher-level than machine code and is executed by a virtual machine. The same principle roughly applies to C# (.Net / CLI), ActionScript (AVM) and CPython (Python bytecode). Even if you use a language that compiles to machine code (C, C++), you're still only _translating_ from one language into another and there's no way to prevent anyone from either reading that translated code or translating it back into a higher language (the outcome will usually be very obfuscated, but that's beside the point). If someone will spend this kind of energy on "cracking" your code in order to tweak it and pirate it (in the sense of "use commercially without permission"), you have a lot bigger problems than obfuscating your code. This is security 101, really: you hand someone "encrypted" data (the encryption in this case be the programming language or byte code structure) and the "decryption key" (being the interpreter, virtual machine or OS capable of running the code) and expecting the content of the data to remain a secret. That just doesn't work (this is also why DRM failed, and keeps on failing, hard and often). If it's the games you are worrying about, either make them worth buying (i.e. innovative, entertaining, interesting, etc) or lower the production costs so you can release new games frequently (this is how most "puzzle" games and other "casual games" do it). You don't really have to worry about anyone stealing your code (and use it commercially). That's what copyright is for. You may have to worry about people stealing your ideas, but that is why you should try to excel through quality (so the competition sucks in comparison) or quantity (so the "theft" becomes less painful). I think we can skip the discussion about the harm and benefit of non-commercial software piracy (it can't be stopped) and digital rights management (it doesn't work), but it's probably a good idea to look at other companies/developers who sit or sat in relatively the same boat as you (be realistic -- you're probably not Zynga) and how they fare with those problems. The obvious example are server-based web games (not just Zynga): these usually work by putting a lot of the logic and data storage on a server and thus making the client itself worthless (this is also how MMORPGs usually work and why they tend to go after free-shards (i.e. independent server clones) so hard). That said, your expectations seem a bit naive (it's okay to look at bigger companies for inspiration, but you have to keep in mind what kind of budget and workforce they have vs what you have).
You fail at reading comprehension, both in the title and the linked article.
I'm not a math major or a CS major, but I've always viewed lambda calculus more as a formal method for writing programs as proofs. It doesn't relate to what I think of when I think of calculus (derivatives, integrals, etc)
What would that be, for example? I'm lacking in creativity right now :(
Having recently run into this issue while embedding Python in my own project, I'm really happy to see this going into core Python. As it is, I may very well go ahead and test out the patch on stackless 2.7 and see how well it works. :D EDIT: It works. Since, as I mentioned above, I'm using 2.7 instead of 3.x, I had to swap out the wide chars with normal chars (as well swapping as the wide character copy calls to strncpy and strcpy, where relevant), but after that it worked like a charm. Also note that because the patch is for a fairly recent revision of Python, the line numbers don't jive with 2.7, so the patch has to be manually applied.
Absolutely anything. Open up your file manager and take a look at your system. Visually dive into any directory and something would have to spark. Maybe you can try to create the insanest "copy" program. Call it ccp for "crazy copy". Don't discount even the simplest ideas as they sometimes turn out to be the most complex. Start with copying one file. Then recurse and copy files of a certain type. Then maybe copy files that contain certain data. Then maybe create a config that'll contain defaults e.g., If you're gonna prompt, why? Maybe tar everything up in the end for good measure. Maybe you'll never again use your OS copy dialog. Maybe you can create a better one better suited for the way you copy stuff. That's just one idea. Just imagine for a moment if you could do anything to help improve the way you use your computer. If you can imagine just one thing you can do even slightly better, solve that no matter how simple or minor of a nuisance you *think* it may be.
Just as easily as if you'd written the game in C or C++. There's no magic bullet here. Honestly, though, you should focus more on making certain that your games are good enough to copy.
Because now you can now also: &gt;&gt;&gt; from os.path import dirname, join
just wanted to update on this. it seems that the biggest issue I see coming up is performance. Sikuli does a pixel scan of the screen. This takes only a second or two, but when it involves a transaction of over 30 cards, it may take quite awhile. On a side note, even though there are quite some oddities in Python(I'm saying this as someone who is coming from PHP), the sheer amount of functions that reduce the amount of code I need to write up is amazing. I can definitely see why you guys love this language.
Isn't this always the rule? &gt;&gt;&gt; import xml.etree &gt;&gt;&gt; xml &lt;module 'xml' from '/usr/lib/python2.6/xml/__init__.pyc'&gt;
There's no good reason to ever use minidom! Use ElementTree, it is in every way better.
Thanks for linking those. I modified my comments to follow PEP 257, and changed a lot of the spacing to fit PEP 8. I still need to shorten up the lines I guess, but it just looks uglier and harder to read to me.
Well, given the modular structure of my script, this could be implemented as "generator" plugin. I am planning to add some sort of SSH capability to it. Primarily, "publishing" the generated files would be a nice-to-have for me, but as you say, executing remote archive jobs and downloading the files would be interesting as well. I was thinking about twisted, but that seemed way too bloated for this. So I deferred the SSH functionalities to the future, when I found a valid alternative. Now that you mention "fabric", I can hear a loud bell ringing in my head. I'll have to look that up. Unfortunately I mostly get time to work on it on weekends. I'll see what I can do. Again, my main goal was to make the script easily customisable, so if such an idea pops up, it would be easily implemented. So out of my head I would see something like this in a "generator_profile". Note that I don't know fabric yet, so consider this a "pseudo" high-level idea: def run(staging_area): conn = connect_to_remote_host( CONFIG['host'] ) # assuming everything necessary to create the tar file is contained in the config variable "archive". With sources, exclude rules, and optional params to `tar`... or so... create_and_fetch_tar( conn, CONFIG["archives"]["mytar_file"], staging_area) conn.close()
Yup. Talk about perfect timing :)
I've quickly skimmed over both fabric and paramiko now. Both seem well suited and should be usable in a custom profile. I'll see what I can do... Any reasons why you preferred fabric over paramiko? It seems that running remote tasks and downloading files is not much harder on paramiko than on fabric. As fabric uses paramiko internally, this would limit the requirements for this "profile".
note that this article is about unit tests, which should not really require very much state.
You should get [pylint](http://www.logilab.org/857). From the site: *analyzes Python source code looking for bugs and signs of poor quality. Pylint is a python tool that checks if a module satisfies a coding standard. Pylint is similar to PyChecker but offers more features, like checking line-code's length, checking if variable names are well-formed according to your coding standard, or checking if declared interfaces are truly implemented, and much more*
Project is quite old, presentation is not so fresh either, but it's awesome nevertheless. Kind of scary that they went and used Python for this, and that they made GUI guy the architect. Otherwise it looks nothing but impressive.
OK, I just know flash . Can you tell me how easy is it to decompile c or c++? Is it a few minutes, or a few hours or so? Flash is very easy to decompile.
I was using fabric for doing deployments, and i was doing something like : check, tar and gz , copy to host, untar, create proper directories, run whatever you like, finish. So the nice backup would look like this, but in reverse :) so just dump database, run custom commands, tar.gz , cpoy to local/somewhere else, remove. I wasn`t looking at paramiko at all, fabric has got everything i need, and on high level that i liked. But for sure if You want to do more, Paramiko may be better.
Thanks for the explanation of machine code. I understand that my games can be copied design wise. I would want code obfuscation is to prevent the amateur copiers, which are the majority rather than unhackable code which as you say, is impossible. So, I guess what I should do is: Focus on making money from my games through ALL avenues (flash+iphone, maybe indie), meaning learn iphone programming and c++ AND obfuscating code/making decompile harder to prevent amateurs stealing my game and putting it on their sites (This is where I originally thought python would help.); Server side is still confusing. PHP is ok, but not really very good for graphics. Any advice on how to overcome this? 
pics? demo? for the lazy.
I'll keep this use-case in mind. Thanks for the info.
Note - all of what I'm about so say is really beside the point. If your game is good, your code is less in danger of being stolen than your idea. There are plenty of software developers out there who happily write clones of games all day, every day - for free. If a company decided they could profit on what you're doing, I'm sure they could find someone willing to implement it for them. That said, it's quite easy to decompile C and C++. Groking the resulting assembly is another matter. I'd rate it as at least "moderately difficult", but then, I don't know assembly. Those that work with it on a daily basis might rate it as a warm up exercise. :D Also, I know there are a number of ways of inserting a "shim" between a dynamically linked executable and underlying libraries in Linux (e.g., [ld-so/ld-linux](http://linux.die.net/man/8/ld-linux)), and I wouldn't be surprised if there were similar techniques that could be employed on Windows and/or OSX environments. In such a case, even if they couldn't completely reverse engineer *all* of your program, they could potentially substitute their own calls for those of yours that they weren't able to decipher. The difficulty of this? Well, I'm just a humble code monkey, but it only took me an hour to figure out how to do it. The fact that I had to do so to get a binary compiled against a later version of glibc to run on a slightly older version is probably better left for a different rant. :D
Any reason you went with TKinter? I haven't done any gui applications yet, but I've looked into both wx and pyqt4. Everything I read, and based on personal experience, said that tkinter was too outdated and really there's little reason to learn it other than it's included with python.
Nice, what do you use it for?
It is the first piece of a cross platform cron I am going to be writing. Making a very basic cron with what I have is quite trivial too, something along the lines of (does not account for blocking, logging, etc. It's just an untested demo): import cronex import os import time while True: jobs = [] for line in open("crontab").readlines(): jobs.append(cronex.CronExpression(line.strip())) for job in jobs: if job.check_trigger(*time.gmtime(time.time())[:5]): os.system(job.comment) time.sleep(60) I need a cron scheduler that responds to system activity and will delay certain jobs for a certain amount of time if there is user activity. For example, I have backups that run via rsync at 2 am and a script that updates my mirror of the Debian repos. When I'm using my system, I'd rather not have them running. This module will be the backbone for it. EDIT: Tested it, and it does work even if it's quite crude.
OP specifically said that minifying saves money by saving bandwidth. I merely debunked that _specific_ argument for minification. But sure, shaving 20 kB off the total required bandwidth for the first page is worth _something_. But as I said at the start of the thread, in my experience, most sites that do use minification actually _don't_ bother compressing their output _or_ setting reasonable caching policies, two steps that would offer significantly larger bandwidth gains. The first rule of optimization is to optimize the things that actually cost you, not the things that are really easy to optimize.
Hah, now I realize why that article seems so out of date, gst is submitting super old articles with similar dates in previous years. The article is from Sun, 12 Nov 2006 
If you want to continue writing browser games you're pretty much going to be writing stuff that's copyable no matter what you use! Especially if you stick with the mindset of putting everything in one file. Now, if you make something that relies on a backend on the server, that can be pretty much tied to one site - if parts of the game logic are happening on your server, in code you never intentionally send out to users, you're a lot safer. But this doesn't suit every game. Assuming you're still going to be programming games, you might want to look in to [Unity](http://unity3d.com/) - it's based mostly around Javascript, so your Actionscript skills will translate pretty seamlessly and it can dump out executables for win/mac/iOs (android is "coming soon") as well as deliver stuff packaged for their browser plugin. (see [Blurst](http://blurst.com) for some nice examples of what it can do) Also, of course, in the grand scheme of Being A Programmer *any* language is worth learning because it will make you think in different ways; even if you don't become a raging Pythonista with a picture of Guido tattooed over your heart it can give you some new techniques to take back to your favorite language.
Np, i will take a look in to the code, i will check how good it meet my needs, so maybe some patches/contribution will take place.
You do the graphical part in something that's good at graphics. *grin* So for instance Farmville has two major parts: there's the Flash file that's embedded in Facebook, that handles all the pretty pictures and animation and user interface... and then there's a big mass of PHP/Python/Java/C/Ruby/Haskell/whatever that sits on their servers that handles saving your farm and Aunt Mina's farm and handling interactions between them. The same thing goes for pretty much any game with some kind of persistent world - Warcraft, for instance, has a client that runs on your machine and talks constantly with Blizzard's servers. If you're interested in making games that mostly deliver a single-player experience (or maybe multiplayer with people sitting in the same room), you don't really have a reason to do this - and thus this way of keeping "ownership" of your game's use is denied to you.
i think over time you will come to like short lines... reading other people's code (especially weird formatted code) may lead to better understanding of the reasoning behind pep 8.
Its amazing that we did the very same thing for our project a while back in Python. This should get into the standard library.
I wrote a Windows cron service. It has very crude parsing support atm. http://gitorious.org/epycron Maybe you can use parts of it or want to merge effort? Either way, fine with me.
I got this and set it up last night before I went to sleep. It rates my code something like -7/10. I can't even get a 0! It doesn't seem to like my java style variable naming conventions, or tabs, or my long lines. Other than that, it didn't seem to find much.
I tried Unity earlier this year. Its nice, but the games look bad. I can do passable 2d graphics, but don't dare to go 3d. *sigh...* Might as well just give up.
&gt; Just because you are right there doesn't mean you should grab just a little bit more coverage. Each piece of leaf functionality should only break the test specific to that functionality. [...] It can have asserts to prove that you are where you think you are but it is not a test. Once you have arrived at this setup state, then create many smaller leaf tests each only covering a small piece of functionality. For all aspiring (or actual) testers out there: if you'll learn something today, let it be those wise words.
Can't you make that a little more compact? Here is the same (entire core) rewritten with web2py (we added a validator too and wiki support): #models/db.html from gluon.tools import Crud db=DAL('sqite://storage.sqlite') crud=Crud(globals(),db) db.define_table('note',Field('body','text',requires=IS_NOT_EMPTY())) #controllers/default.py def index(): # was main_view return dict(form=crud.create(db.note),notes=db(db.note).select()) def edit_note(): return dict(form=crud.update(db.note,db.note(request.args(0),next='index') or redirect(URL('index')))) #views/layout.html &lt;!DOCTYPE html&gt; &lt;!-- NoteTaker/src/notetaker/templates/layout.html --&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;NoteTaker&lt;/title&gt; &lt;link rel="stylesheet" href="{{=URL('static','style.css')}}" type="text/css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;NoteTaker :: {{ block title }}Main{{ end }}&lt;/h1&gt; &lt;/header&gt; &lt;article&gt; {{include}} &lt;/article&gt; &lt;/body&gt; &lt;/html&gt; #views/default/index.html {{ extend "layout.html" }} &lt;section id="notes-section"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;Id&lt;/th&gt;&lt;th class="text"&gt;Text&lt;/th&gt;&lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {{ for note in notes: }} &lt;tr&gt; &lt;td&gt;{{ note.id }}&lt;/td&gt; &lt;td&gt;{{=MARKMIN(note.body)}}&lt;/td&gt; &lt;td&gt;&lt;a href="{{=URL('edit_note', args=note.id)}}"&gt;edit&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; {{ pass }} &lt;/tbody&gt; &lt;tfoot&gt; &lt;td colspan="3"&gt;{{ =len(notes) }} entries&lt;/td&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/section&gt; &lt;section id="note-add-section"&gt; {{=form}} &lt;/section&gt; #view/default/edit_note.html {{ extend "layout.html" }} {{ block title }}Edit {{ =form.record.id }}{{ end }} {{=form}} Works on GAE too if you replace 'sqite://storage.sqlite' with 'gae'. 
Ok... I didn't know this either, but Pyramid is a web app framework and is part of the [Pylons Project](http://docs.pylonshq.com/faq/pylonsproject.html#how-does-the-pylons-project-relate-to-pylons-the-web-framework). It can be found at http://docs.pylonshq.com/pyramid/dev/
Not a very interesting polyglot to be honest. IMO the point of polyglots is when the same line of code is exectued by 2 languages and gets a different result because the same line is valid in 2 syntaxes in a different way. All this is doing is using the fact that the ### comment doesnt do multiline in python and then declare some functions built in to coffeescript and then use the fact that the syntaxes are almost the same anyway.
Not sure what Confluence is... But to set the to last a really long time, just set the TTL to a day or so. You can also setup a feature in Varnish that won't drop the expired page until a new one is re-generated.... which allows you to set really short TTL times, but still keep everything cached and fast... search "dogpiling". Nginx might have a way to do that too, but I'm not as familiar with it.
Confluence is a popular enterprise wiki (unfortunately in Java). Thanks for the hints, I'll try doing it.
Is your implementation posted anywhere?
It's not about being compact, it's about being easy to understand, so people can learn something.
From various discussions occurring right now, it's looking like Pyramid is about to bring the merger of BFG, Pylons and TurboGears all into one unified project.
It's an article about coding with a specific server side framework. A pic or demo would only showcase the capability of your browser to render html. wtf would be the point? 
Asynchronous IO can be done in several ways in python actually. The easiest by far is probably by using gevent or Eventlet and their monkey patching abilities. This allows for threads of execution that cooperatively give up control when blocking on IO operations or sleeping. Monkey patching allows for modules that use the python socket module to automatically become non-blocking as socket.read() and socket.write() will switch threads of execution when they would block. Twisted, if the protocol your looking for is support, uses callbacks to do asynchronous work. If your protocol isn't supported then you'd have to implement it yourself using Twisted ideas. Finally if all else fails just use python threads. This basically works the same way as gevent or Eventlet in that there are seperate threads of execution except now they are real OS threads (pthread under posix like operating systems). The downside is that python then has to do some juggling as the interpretter (I'm assuming CPython) can only do work with one thread at a time. I hope this helps. 
Yes, you're correct. I misinterpreted the OP and now don't even really see the point he was trying to make. The only thing that's weird about the os module is that os.path is imported implicitly, and even that isn't that weird.
Anything GObject related is horrible.
GObject is an object system built for C, which inherently makes it a bit of an awkward monstrosity. Having to deal with it in Python is redundant and also awkward, but sadly required sometimes. Doing asynchronous stuff in Python is perfectly doable; it just depends on what you're working with. GNOME-centric libraries tend to work with glib's event loop, so you might want to look into that. And if you can get at some file descriptors, you can always use `select()`. A quick google search turned up [this](http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html#making-asynchronous-method-calls) and [this](http://stackoverflow.com/questions/2142115/implementation-of-an-async-method-in-python-dbus).
&gt; it's about being easy to understand Hmm, the blog post doesn't indicate the code is intentionally verbose in order to aid understanding. Are you saying the app could be made as compact as the above code (at the expense of some clarity)? If the above code were explained/annotated as in the blog post, wouldn't it be just as easy to understand as the Pyramid example (even though more compact)?
I think so. I was looking to use gstreamer for decoding, converting to PCM and resampling that PCM and it just felt so messy. I wanted to do it in a way that allowed me to read a certain amount of bytes of the decoded and resampled data but I never found a good solution. I ended up using cytpes and wrapping libmpg123 and that felt (and works) a lot better. 
&gt; Anything GObject related is horrible. Including [Vala](http://en.wikipedia.org/wiki/Vala_%28programming_language%29)? I actually find Vala to be quite nice, as far as such things go.
just use threads they have the most support of all these methods and are the most battle hardened. If you are i/o bound and not cpu bound then threads will really never be an issue, if they are maybe you shouldn't be doing that particular part in python
Vala was invented in order to make it less horrible. It's kind of neat but I'm not really interested in a language designed around a C object system (and it's really just a platform-specific language like C#). It doesn't look like many applications have been written in it yet. Linux needs decent high-level languages for writing apps, C and C++ is just unsustainable. My current choice is Python, but it's slower than I'd like (too dynamic for its own good sometimes).
&gt; Vala was invented in order to make it less horrible. It's kind of neat but I'm not really interested in a language designed around a C object system (and it's really just a platform-specific language like C#). It doesn't look like many applications have been written in it yet. Yes, yes &amp; yes, but it means that there is *at least one thing* that isn't horrible about GObject, which was my question :D &gt; Linux needs decent high-level languages for writing apps, C and C++ is just unsustainable. My current choice is Python, but it's slower than I'd like (too dynamic for its own good sometimes). I'd like to see Rust fill this void, or something similar (Clay comes to mind too). Something static + good tools + widely supported + semi-efficient code. oh, I would also like a pony...
I agree, it's not very weird at all. And when you look at os.py you see that depending on platform different modes are imported, and at the end named to os.path. Essentially you have: if posix: import posixpath as path elif nt: import ntpath as path ... sys.modules['os.path'] = path I think that's very clear and clever. 
I always loved project Euler, even though I've only done about 30 or so problems. For me, I always thought of it as useful for people who want to learn some Math *via* programming-- but that's just the direction I'm approaching it from. I love Math, even though I am pretty bad at it, and PE kind of makes it easy for me to develop some deeper understanding of Math concepts by viewing them in my natural habitat: deeply nestled within computer code. To answer your question, it's pretty useful for learning the syntax and libraries offered by a *new* language, but probably not very good for your *first* language. The reason is that many of the tools and techniques you'll need to make some of your programs actually finish in your lifetime (memoization, lazy evaluation) are not found in most beginner books and tutorials. TL;DR: Nah, not really. PE is more about mathy programming puzzles for programmers than a learning tool for beginners. YMMV though, so ignore me, and try some out anyway.
Mate, bit late to the party, but no. It's not too lofty. I myself knew nothing about programming and do not have a maths background and have used Project Euler to teach myself some python. I've done 65 Euler problems to date, after about 4 months of intermittent effort. Just look at a bunch of problems and do the one you're most interested in at that time. The earlier ones tend to offer frameworks to approach the later questions through.
&gt; I would want code obfuscation is to prevent the amateur copiers It only takes one person to decompile and release your source code or the cracked version, then all the "amateurs" can get it. It's not like crackers keep their cracked copy to themselves.
Nooooo. No more languages that use common English words. Bad.
What are you complaining about? I'm sure Mozilla Rust is somewhere in the 1500 pages of google search results; how hard could it be to find? :D Actually, in all seriousness, Duck Duck Go has "the correct" (based on the context we're using) Rust within a few scrolls of the mouse, so that's nice. Still, I agree, if you're going to name a language, at least go for something a little more search friendly.
Yeah, I keep on coming up with good names. The perfect one: Galapanas (file extension glp, compiler executable glpc). The only search results for Galapanas are Lithuanian, the file extension is open, and compiler executable is open.
It's in a list because the numbers in the list represent the index of another list. Basically, it generates all possible combinations of the contents of some other list. What I came up was this: syll_string_length = int(input('Length of syllable string? ')) base_syll_string = [0] * syll_string_length for a in range(len(base_syll_string) - 1, -1, -1): if base_syll_string[a] == max_index_mu: base_syll_string[a] = 0 else: base_syll_string[a] = base_syll_string[a] + 1 etc. It's a small part of my thesis, which is in the area of metrical stress. Thanks for yr help, everyone!
Pylons, Zope, repoze, Turbogears, all in one? why not if it is the best of all worlds
I don't know web2py nor pyramid. &gt; Hmm, the blog post doesn't indicate the code is intentionally verbose in order to aid understanding. I guess the title "Getting Started with Pyramid: A Notes Application" indicates it enough. It probably would be as easy, but still, it's not a contest to create most compact code in the world, but to learn basics of something. You can write a simple loop example in C to show newbies how to do it, and if someone would jump and say I CAN MAKE IT SHORTER and write a bash oneliner, he would be missing the point.
I wrote a good chuck of the software for the Dark Energy Survey and some for BOSS. We used twisted a ton. It is really great for programming concurrent connections.
First of all, fuck PHP. That many big companies use it doesn't you should, too. The reasons to use PHP for big projects are usually related to the costs of switching a platform late into development rather than a conscious choice at the beginning of the project. That said, server-side programming is less about the language you use and more about architecture. Just keep your data on the server and access it via some layer of API. It's just a fancy interface to a database anyway. If you are writing Flash games right now and want to stop people from just copying the files and publishing them elsewhere, keep some of its data on the server-side and access it from within Flash. Use relative paths and add some dynamic aspect to your data so a copycat can't simply imitate your server-side scripts. Of course they could still supply proxy scripts that delegate the calls to your server, but that's probably more trouble than most people would go through in order to steal your work. As for the graphics, that's irrelevant to the server side. It's not an either or -- you keep your data storage ("persistence") and application logic on the server-side and your presentation logic on the client-side. Think of the client-server communication as callbacks. It's probably a good idea if you learn a bit about software architecture before going any further. It's very important to fully understand the difference between client-side code and server-side code, what abstraction is, the difference between application logic and presentation logic (MVC is a good start -- no, not .Net; that's just an implementation of that architecture), and so on. The distribution channels (iPhone, Flash, whatever) are pretty irrelevant to the architecture. For browser based games it's probably a good idea to stick to Flash. For iPhone apps you probably first need to learn a new language and how to interact with touch input. Either way the reverse engineering / decompilation issue is negligible if you keep your game server-based (this may be a problem with the iPhone, too, as phone users may expect your game to work offline unless it's multiplayer-based or competitive in nature -- that said, redistribution of iPhone apps is harder because you have to go through the app store, so the chance of someone stealing it is far smaller and theoretically easier to resolve). Forget about obfuscation, though. Obfuscating your code won't help you if your game code is isolated (i.e. all logic is in the downloadable file). If it's not, obfuscation is pointless because decompilation won't provide access to the entire logic anyway. That said, you can expect the number of filesharing users to be at least an order of magnitude bigger than the number of legitimate customers whenever you sell software. That's a fact of life and doesn't mean you're losing out on potential sales. Just make it clear to everyone that you don't appreciate the filesharing (don't offer support to illegitimate users, ban anyone advocating filesharing of your games from your forums if you have any, etc) and maybe offer a tipbox (PayPal / what have you) for people who like your work but don't want to buy a copy (some may consider this unprofessional or encouraging filesharing, though). If you're providing your games as a service (i.e. server-based only, maybe with a subscription model), you can avoid this drama altogether, of course. Either way, you should consider taking legal action against anyone exploiting your work _commercially_. An informal warning (possibly with the threat of legal action) is usually enough. Lawyers are probably too expensive to warrant their use unless they're required _and_ they're worth it. Forget about suing clones unless they're using your assets (artwork, sounds, trademarks, etc) or code directly, though -- that's perfectly legal and encouraged. __tl;dr__: Learn a bit more about software engineering before you decide on what to do next.
Hey. This is very interesting, can you mail me at fijall at gmail or find me on IRC for details? Cheers, fijal
I guess for now we just have to wish for someone to do the work of making a nice pythonic version with decorators and such.... (looks around for a high motivation person...)
chmod/chown the script so that it's only read/writeable by authorised users/groups.
use configparser and chmod the config file
Hi from ASTRON (.nl), programming for the LOFAR telescope :) Unfortunately, we use Python only as occasional glue and for some scripting in post processing. 
Hm. I tried improving the runtime of my script by offering it a few bucks, but it just stared at me, nonplussed. Is there some minimum amount?
I wrote a small convenience module for interacting with my keyring application and all my scripts obtain passwords via that. The keyring application handles all the encryption and access permissions stuff for me.
Have a look at the netrc module.
um, keyring? http://pypi.python.org/pypi/keyring
No, no, this is more mob-like. You give PyPy the money, they then 'protect' your script and handicap everyone's else scripts, thus, yours is faster.
we don't
Ah! I didnt know about that before now. Thanks for mention it, I will have a look at it! +1
You can do simple Python scripting with [SL4A](http://code.google.com/p/android-scripting/).
I periodically try learning Obj-C, but the syntax makes my head hurt. So, I started learning Lua, to use with the [Corona SDK](http://developer.anscamobile.com/). The Lua based SDK compiles to run on android and Apple devices, and has reasonable functionality, ie sprites, camera, GPS etc, but can't access custom code. Still, its the fastest way I have yet found to script-up apps. Lua is a little simpler that python to learn, and runs faster as well, but has waaaaay less in the way of libraries.
I've obfuscated it sometimes. You obviously get no real protection, but it does keep passwords out of plain site, and a non-technical person won't be able to get at the password. In my opinion that's worth a lot even if any other programmer can still figure out the password. I've done something like this: #Make password (run once) import base64,zlib encoded_pw = base64.encodestring(zlib.compress(PW.replace('\n','').replace('\r',''))) #Use the encoded password import base64,zlib zd_b64d = lambda s: zlib.decompress(base64.decodestring(s)) decoded_pw = zd_b64d(encoded_pw.strip()) I also put it online here: http://utilitymill.com/utility/obfuscate_password_for_a_python_script 
You guys really are programming exemplars. Fearlessly going in and learning new languages with which to write brilliant applications, so long as they are not difficult or unpopular. Your willingness to learn a language as excellent and simple as Python goes miles ahead of your unwillingness to learn the prescribed platform-specific APIs and patterns encouraged by the vendor and used by the community. [Pic related](http://xkcd.com/801/)
DBus is not asynchronous? That's news to me. Web developers _ALWAYS_ have a problem transitioning to desktop application development. You have to switch your mindset. They particularly have problems adjusting to callback and event-based programming.
maybe she could use github gist? https://gist.github.com/
They don't seem to have OpenGL yet :(
I know and have written both Obj-C on the iPhone as well as Java (though not on the Android). I manage Obj-C projects on the iOS every day. The only way I would be willing to code either language myself would be if my life depended on it. And it doesn't. Let's put it another way. I would let a guy rape me in the ass if I had to choose between that and being beaten to death, but I do not voluntarily go out and seek to get assraped.
[pycrypto](http://www.dlitz.net/software/pycrypto/) might come in handy for this. But no matter what you chose. As soon as an attacker has access to your code, every bit of obfuscation/encryption is utterly worthless. If the attacker has not access to your code, then you should still keep away from often used solutions like Base64 or UU encoding. They are also very weak. A trained eye recognizes them from miles away. Even mixing it with other solutions (like zlib) won't help. A quick look at the file header tells you everything you need to know. In general: If it looks like UU/Base64, decode it. Look at what's left. If it looks binary, look at the header,... and so on. You can do other tricks with your data, but then you are beginning to re-invent the wheel -&gt; [pycrypto](http://www.dlitz.net/software/pycrypto/) (or keyring) As said, as soon as the attacker has access to your code, you're pretty much screwed. Relying on the OS to make the critical data unaccessible (chmod/chown) are your best bet to prevent unprivileged access.
Speaking of feeling like you are cheating... [Link to my Euler level image](http://projecteuler.net/profile/Valdemarick.png) This was accomplished several years ago, when the problem cap was 225. I originally started working my way through the easier problems using Python. Having zero formal education in mathematics above basic algebra, I quickly began reaching my limits in what I could solve. However, during my struggle, one particular problem had me directly accessing the web server through Python as a (legitimate) potential solution. While working on this problem, I inadvertently came across an exploit in the form post method on the site, allowing me to "credit" my account as having solved any given problem. So I did. I created a Python app to iterate through all available problems, and credit my account. It took about 20 minutes to progress from discovery-&gt;exploit creation-&gt;implementation-&gt;all problems solved. As my memo says on my [rankings profile](http://projecteuler.net/index.php?section=scores&amp;level=5&amp;page=1) (about 3/4 down the page, username Valdemarick): _"Gained level 5 in 20 minutes using a site exploit. It's a little meta, but I feel self-justified in my achievement."_ Had a site administrator contacted me about this glaringly obvious admission, I would have gladly informed them of the problem allowing such a thing to occur. They never did, and time has since erased the specifics of it, from my mind. That was my experience with Project Euler.
&gt; I guess the title "Getting Started with Pyramid: A Notes Application" indicates it enough. I don't see your point. Just because the blog post is intended to introduce the reader to Pyramid app development does not imply the code is unusually verbose. Unless otherwise stated, the reader should probably assume the code is representative of typical Pyramid code for such an application.
oh man are you missing out.
cocos 2d
&gt; cocos2d for iPhone is a framework for building 2D games, demos, and other graphical/interactive applications. It is based on the cocos2d design: it uses the same concepts, but instead of using python it uses objective-c. :(
I'd be a real shame if something happened to your code's priority.
Same as you would in any other language: * Keyring for desktop apps (keyrings have the encryption issue worked out for you) * Properly permissioned configuration file for server apps (web apps, daemons, etc) Although if you're just trying to keep prying eyes from easily glancing and seeing your password, Python's builtin ROT13 codec is perfect: "erqqvg".decode('rot13')
Who's reading it, and why can't they copy it and put "print password" immediately after you get the cleartext? &gt;&gt;&gt; cred = "AWfdlJKG".decode("rot13") # avoiding use of word "password" That is just about as secure as anything. It will keep out casual viewers, and that's the only class of user you can protect against. 
Who can conduct business these days with that pesky 'scheduler' going around?
When configuring these scripts I always pass in a filename, and the file itself contains the login/password. This way I can change permissions just on that file, and I can check in or share the config without leaking that information.
Bit of a Python newbie here, but when having the same concern with a network login script I wrote, I went for the [getpass](http://docs.python.org/library/getpass.html) module. Doesn't save the password anywhere so most secure you can get :D (Obviously not great for full automation, but for my simple script it worked excellently.)
Exactly. An alternate approach I have seen is a small python library that reads in ~/.passwd/username. That way you can avoid having passwords in your revision control systems, but not worry about config files for your small tool either. 
This is my issue too. I'm really just waiting for SL4A to provide *ANY* hooks into something I would be willing to learn. I know Python, but c'mon, Android = Linux...why the hell are we being limited to 1 programming language for this platform? We should have C, Python, Java, LUA, Lisp, Ruby...you name it, we should have access to it right now! Hell, just allow the NDK access to the GUI and *I* would write a library for Python! (Btw this is actually what's holding SL4A back from implementing GUI access)
This guy repairs his cars atom by atom, because putting it together in cleaner, easier pieces is far too below him. God forbid someone wants rapid development, clean syntax, and a little bit of elegance in their code...
I chose it because it is included with python. I plan to move to something else eventually, probably qt.
Holy crap. I heard someone say they used cocos2d for iphone programming. I found the one for python and couldn't see how it let you program for the iphone. The found the one for the iphone and didn't see a mention of python. Your comment just pointed out my huge flaw. I'm sad too...
Haven't seen any BT modules outside of PyBluez, so you might be stuck with 2.x. The socket module supports bluetooth (AF_BLUETOOTH socket family), but that's really low level.
Ha, that's one way to do it! Any idea if this still works? There is sometimes mention of people who cheat by sharing answers, but this seems far more explicit, and given the pseudo-competitiveness of PE, I'm sure something like this would be a high priority for them to fix... &gt;However, during my struggle, one particular problem had me directly accessing the web server through Python as a (legitimate) potential solution. Do you recall which problem this is?
You don't even need strip, I think.
Sorry to disappoint, but I have no clue on either part. I *think* I had written a Python app to post "guesses" repeatedly, and depending on the positive / negative result, continue iterating through potential answers, and try again. Err, now that I think of it, I wasn't quite sure what a "correct" answer page looked like, and wanted one to reference. I believe my attempts to "resubmit" correct answers to previously answered questions led me down this path... which resulted in me figuring out a method of posting some invalid / malformed post data, which tricked the site in to crediting me. Hope that helps. =\
What do I enjoy most about Python? When I think about the problem at hand and sketch out my thoughts in psuedo-code, quite often it's eerily similar to the finished python code. I learned on Java and PHP yet after years with those languages, it was still a struggle to convert my high-level mental conception of the problem into workable code. OTOH I was "thinking in python" as soon as I started using it. 
I feel exactly the same. I picked up Python right before summer started and have been using it for small personal projects and the like ever since. The crazy thing was, when laying out the pseudo-code for an assembly program I had to make for a class this Fall, I noticed the pseudo-code was more or less Python! I was even writing python scripts that would help me visually map out my ASM algorithm (the program was a hexadecimal =&gt; binary &amp; decimal convertor), and I must say that using/knowing python helped me immensely! 
I appreciate the simplicity and elegance of it. In particular, looking at another person's code, I know that it is formatted (in terms of tabs/spaces) exactly how I would normally write it. An added bonus re: formatting is that, at least for me, it is easier to learn new tricks from others by reading their code.
import this
Compared to Ruby: nicer, cleaner, perform better Compared to C#: no compilation, no waiting, nicer syntax, easier manipulation of data. Compared to C: Everything related to syntax What sort of programs do I write in Pythons? Anything, from a small script to pull some pictures from a website, to a parsers. Python is powerful enough to support a full-size application, and also easy enough to code up some quick ideas. Python is my most favorite language.
The deeper I get into it, the more obvious it is, that this language is maintained by people who use it, to get shit done.
The way readability is encouraged. The fact that there is a [style guide](http://www.python.org/dev/peps/pep-0008/) that most of the community follows makes extending and maintaining code less painful than other languages I work in.
My favorite thing(s): 1. I can get the job done faster in Python. 2. I can maintain the code I've written over a year after I have written it and I can maintain anybody else's code as well. It is nice that it is object oriented and has support for features X, Y and Z. At the end of the day, I would not use it if not for the two points above. Python allows me to solve real world problems quickly and I can keep those solutions around and adapt them to other uses quickly and easily. I would use BASIC if it gave me a superior level of capability. Now some of the reasons it fulfills those two requirements are because of features X, Y and Z. For instance having one obvious way to do things is sometimes seen as Python's largest conceptual weakness, I disagree: having one obvious way to do things means that when I maintain old/other's code, I know what the heck is going on at first glance.
Are there a lot of inconsistencies and things that look like hacks, or is that just the impression of an outsider (me)? Certain things, like the whole double-underscore thing, and the lack of static typing (which I totally understand is supposed to be a *good* thing, but I prefer the readability of typed variables) just seem weird to me. Is it just unfamiliarity? Will I likely embrace these things if I remain persistent? :)
The open source and well-documented API that lets me write C extensions or custom Python binaries with ease.
it reads better than javascript.
The best thing about python is that the libraries all work together much better than in any other language, at least in the math/science/machine learning domain. Learn numpy/scipy and the things that connect to them and you'll have an environment with the power of Matlab or R but that doesn't abandon conventional programming techniques or impose a monolithic environment. Add the C extension support from Cython et al. and you don't really have to sacrifice speed for all the interpreted power. I wouldn't use python for anything multithreaded because of the GIL, and I've never tried it for GUI or web code but wouldn't expect it to be the right choice.
ROT13
the white space! Fuck the haters! 
the double underscores are a bit of an eyesore, but they expose the guts of the language and allow for really cool tricks, you will learn to love them. 
Easier to learn than fuckin' Perl
List comprehensions and generator statements.
The docs have gotten SO MUCH BETTER over the course of the period of 2.4 -&gt; 2.7 where I've been programming against them. And it's nice being able to read the implementations. And yeah, they're pretty easy to write against too.
Anything reads better than Javascript.
I'm basically doing what you're doing and the thing I like the best is the sheer amount of educational material out there. The community is very active and help is always right around the corner. I'm doing the MIT OCW class now and they've started teaching Python. Can't get much better than MIT pushing the language. As a beginner, it flows very logical and I find it fairly easy to look at others' work and figure out what's supposed to happen. Good luck on your learning.
The standard libraries. Batteries included indeed, it's pretty impressive just how much you can do in a single Python script that's dependency-free.
I've used them to overload the basic math operators for a custom number type class but that's it so far, can you suggest any examples showing what else you can do?
What makes python shine (to me): - Formidable prototyping language. Concise, interactive and powerful. It's extremely easy to "think" in python and write code that just works. - Huge number of very well thought libraries/bindings to C libs. You don't have to reinvent the wheel, it's there, and it works. - Great community/user base, lots of ressources. It's very easy to find answers to your questions and there are many helpful experts ready to help. - Excellent webdev tools. From django to flask or from mod_python to wsgi, python is a great language to webdev with. - Mature and rock solid. It's been there for a while and it'll be there for a long time which means that investing time in python isn't "risky" at all. (compared to younger or less well known languages)
Oh man, great thinking! Would you share with me which course(s) you're doing? I did a quick search and found this and a few others, but I'm wondering what else is out there: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-189-a-gentle-introduction-to-programming-using-python-january-iap-2010/ Good luck to you as well!
Any thoughts on what sort of hosting I should look for if I'm planning on building stuff with it? For now, installing Apache etc on my machine will be fine, but I'd love to be able to actually deploy &amp; use some simple tools I'm looking to build (like a simple personal del.icio.us clone for myself). However, I'm currently using Lunarpage's Basic (shared) plan, and I'm wondering if I'm doing myself a disservice because I don't have much control over the environment and third-party modules, etc.
It reads like English.
Plaintext and the honor system. 
Hey cool, now I don't need to write this. ;-)
What's this? Self?
And, let there be only four spaces to an indent. No, there should not be one as one can barely see that. Nor two for that is almost one. And three is right out being odd in more ways than one. Finally, more than four is a scandalous waste. 
I'm glad I'm not the only one iPhone devs all say it's fine
True, but not great for writing apps or games as they need it installed and the interface will scare non devs. Really need a way of embedding python, I'm suprised noone has done this with the ndk.
There is no one thing, except maybe if you accept the answer of "its overall gestalt". To rip on Perl, Python makes the easy stuff easy and the hard stuff also pretty easy. The last couple of days I've had to go back to C++ to do some things. Python really spoils me. Even though the C++ work is similar to what I often do in Python in terms of structure, it is like slogging through iron shards after ingesting a bunch of rare earth magnets. Python lets me construct elegant and complex structure where needed with a minimal of fuss. It lets me solve problems concisely and clearly. A page of such Python translates to many pages of C++ spread across many files. 
Not that I don't agree with much of what you wrote (and python's my language of choice as well) but what exactly makes it "nicer" than ruby? It's certainly stricter so I wouldn't define it as more inherently user-friendly and it's *differently* verbose so "nice" can't mean economic in syntax. As for generally being comfortable to use, approachable and/or bearing assorted easter eggs in the form of built in manifestations of jaw-dropping elegance, well, both languages will provide you with a steady stream of both so... "Define nice" is what I'm basically saying....
[Appcelerator](http://www.appcelerator.com/) maybe? 
Open up a python interpreter and try it. :)
&gt;Nor two for that is almost one THAT IS NOT HOW SPACES WORK
try it.
Check out the GNOME keyring tutorial [1](http://blogs.codecommunity.org/mindbending/bending-gnome-keyring-with-python-part-1/), [2](http://blogs.codecommunity.org/mindbending/bending-gnome-keyring-with-python-part-2/) and [3](http://blogs.codecommunity.org/mindbending/bending-gnome-keyring-with-python-part-3/).
My favorite thing is list comprehensions. mmmmm... they always go down smooth.
Simple things like there not being "end" syntax after you define methods make Python cleaner for the eyes. "puts/gets" is brain-wrenching for me as well as "using" instead of import... cars = { 'altima' =&gt; 'nissan', 'camry' =&gt; 'toyota', 'rx7' =&gt; 'mazda' } That is ugly. "=&gt;" should only ever mean "Is equal to or greater than" Also: class Employee &lt; Person "&lt;" should only ever mean less than. Their use of colons and pipes also pisses me off. &gt; It's certainly stricter so I wouldn't define it as more inherently user-friendly Python has a stricter use of grammatical punctuation, avoiding things changing meaning based on where they are used such as the "=&gt;" example. The only punctuation I know of that changes meanings in python is possibly the ":" where in 1 area it's used to denote the end of functions, methods, if statements, etc (the beginning of a code block)...and when being used in a dictionary. This *does* in fact mean it's easier to use because syntax doesn't change based on location of code.
Python is quiet nice for web code. I've never written GUI in anything but python, so I wouldn't know how it compares, but pyqt (and now pyside) works fine. It's a bit tedious sometimes, but I don't mind at all.
Readability. Most pseudocode translates very easily (almost exactly line for line) into Python. If I ever teach programming, I will require pseudocode to be written in Python.
the batteries included part.
Once you taste cleanliness, you never dare to jump in a puddle again.
Please, "ODBC" is a four letter word. Do not speak it.
AppEngine. Without it I would have never set my eyes on it.
It's unfamiliarity. They might look like hacks at first, but they add up to an incredibly elegant system. The double underscore thing might seem "hacky" but eventually you realize it's to ensure something is unmistakably readable. When you get to a function like __...__, you understand it has consequences. The lack of static typing isn't a "style" thing, it's an incredibly important part of dynamic programming languages. It's a different way of programming altogether, and is something you will have to learn.
I agree. The minidom method sucks and I'm the guy that wrote the article! I like lxml much better.
BeautifulSoup
I know it's lame, but I really miss the following while programming in other languages dir(anything) help(anything)
`'uhagre2'.decode('rot13')`
Wow! This is exactly what I'm looking for. It even has reporting. It seems that you don't really need to know wxpython to use it. But, it looks like it won't work with SQLAlchemy and doesn't really have a full ORM. Oh well, I still think it is my best choice. Thanks for the tip! Time for me to learn dabo!
OK, I'll bite. I prefer Ruby to Python somewhat, but not greatly. But some of these points doesn't really make sense. &gt; "=&gt;" should only ever mean "Is equal to or greater than" But "=&gt;" doesn't mean "is equal to or greater than" in either Python or Ruby. This syntax isn't reused. A syntax like {a:4, b:5} is supported in Ruby 1.9, by the way. As far as the use of &lt; to indicate inheritance, yes, it can be used to denote "less than", but it is obvious that it is not the case here. In Python, parentheses can be used to denote: Function application (or calling objects which look like functions) myfunction() Object instantiation obj = MyClass() Class inheritance class MyClass(MySuperclass): pass Generators gen = (x for x in [1,2,3]) gen.next() # yields 1 Operator evaluation order (to override precedence) (2+3)*4 # evaluates to 20 instead of 14 Tuples tuple = (1,3) # parentheses not strictly necessary in this case, but nonetheless You could also make the case that using the % operator for both modulus and string substitution is a reuse of punctuation like they one you're complaining about. Similarly, the asterisk is used for multiplication as well as passing the contents of a tuple (or list) as separate arguments to a function (as well as doing the reverse in a function definition, and you use two asterisks – which is the exponentiation operator as well – to get keyword arguments): arr = [1,2,3] myfunction(*arr) Also, passing keyword arguments uses an equals sign, which is also used as the assignment operator. Square brackets are used for both creating lists and indexing into tuples, lists and dictionaries. This kind of syntax reuse is present in most languages, and your examples hardly show that Python is superior to Ruby in this regard.
This is too complicated. Why not store a 1-way hash in your script, and hash the password before you check it?
From [Appendix A of Ruby Best Practices](http://oreilly.com/ruby/excerpts/ruby-best-practices/writing-backward-compatible.html): Ruby 1.9 adds a cool feature that lets you write things like: foo(a: 1, b: 2) But on Ruby 1.8, we’re stuck using the old key =&gt; value syntax: foo(:a =&gt; 1, :b =&gt; 2) (End of quote.) I could name a *lot* of things that I like about Python, but I have to give the win to Ruby on this one.
Parens? That's what you got? You debunk my argument with something that is basically universal to ALL major languages? I can agree with the asterisk, it is one that I had entirely forgotten about for *args **kwargs but nearly every example you gave for parens has been common usage for decades. You are right about =&gt; as well; I've never used it in that order (obviously...I'd get a syntax error) but I in my head it means the same as "&gt;="
My point was merely that syntax is routinely reused and that doing so is hardly unique to (or even particularly characteristic of) Ruby. Python uses parentheses a little more than most languages (using them for tuples, generators and inheritance in particular), but I completely agree that they are a punctuation mark that (justifiably) has multiple uses is most languages. You claimed that the only punctuation mark (that you were aware of) that was reused in Python is the colon: I was pointing out that there are numerous other punctuation marks which are reused in Python, as in other languages.
Dictionary and set comprehensions now, as well.
Grab a VPS.
List comprehensions is what got me hooked on python. They're so damn cool and useful. 
I can't disagree, you make valid points all around. There is still something about Python that seems cleaner to me, even if I can't put my finger on it.
It assumes I know what I'm doing, and will try to go with it for as long as possible. As opposed to Java, which will throw hissy-fits at the slightest variation from The Way.
I installed Python on my jailbroken 3GS and played around with pyobjc. Let me tell you, that shit is slow compared to native objc
On reddit we can be sad together.
FYI, you can get around the GIL with the [multiprocessing module](http://docs.python.org/library/multiprocessing.html). Just in case you want to write properly parallel code without sacrificing Python. Although, the threading module is just fine for certain applications. I've found that it's more than enough to handle laggy web requests in an alternate thread of execution, or to run intensive code behind a UI so the UI doesn't block.
As far as I can understand, they're supporting Javascript on mobile platforms?
Holy crap, I just looked into them and messed around in the interactive prompt, and they are indeed cool. I only barely touched the surface, I imagine, as I'm sure there are probably ways to return lists based on more than simple math and basic expressions (like string matching, etc)...
I spent a couple of days last week learning the basics and porting a bunch of stuff I used to do in mathematica over to python. This is mainly interpolation, fitting and plotting, so I've been playing around with numpy, scipy and matlplotlib. Right now, it's like it's like I've dropped into this big unknown city, and every time I turn a corner there's something neat right there in front of me. In the end, it makes it easy for me to screw around and try new things with very little overhead.
The right way is one tab. Then do: :set ts=4 Everyone gets the number of spaces they want.
Write an app that helps you think of apps to write.
It sounds like the world needs another text editor!
What genius decided the first example on the intro page should generate errors and hang the python repl? Seriously, they even document the AttributeError although I actually get something else about functions not being pickleable. I imagine if I really wanted to do process level parallelism in python that I'd use a message queue. Thanks for the pointer though, it's nice to have options.
A VPS would probably be the best option, but if your willing to put up with certain limitations (python2.5, google's data store, pure python libraries) App Engine would be an option as well. For doing simple personal projects the cost should be nothing.
&amp;#3232;\_&amp;#3232;
I concur. It's easy to spin off a thread in python. The python code in each thread cannot run in parallel, but if one thread waits a lot, or if it calls into a C library, it acts like normal threading.
Do I enter M-x :set ts=4 or do I have to be in elisp mode? I'm not convinced this is going to give me the number of spaces I want.
 Seconded. The number of times the standard library has had exactly what I wanted is a continuing source of amazement to me.
Object instantiation is just an instance of a callable object, and parenthesis are just a grouping operating for both generators and tuples.
If you learned in Java and PHP and never did any functional programming then you probably weren't really thinking in Python, just the subset that looks like pseudo-code. I think you have to be comfortable with functions that return functions that return functions (decorators with arguments, done manually) and Matlab type array slicing to really be using Python properly.
* One language, runs on JVM and everywhere else. * Simple and clean. Both the language and the philosophy behind the great built-in and 3rd party modules. Opposite of Java mentality. * It's interpreted!! So much more fun that compiled. 
I have a port of pygame here: http://code.google.com/p/android-jni-cpython/ (It's still very experimental.)
Note that if you want a &lt;br /&gt; as opposed to a &lt;/p&gt;&lt;p&gt; you can append two spaces. A single carriage return is ignored. these two lines are separated by only a break
Awesome! :)
Ruby is more Perl-inspired and encourages hacking for the sake of hacking. Python is philosophically more about giving you the tools to hide implementation details and expose a clean interface to the world. They've attracted different crowds, web developers for Ruby and the scientific data analysis crowd for Python.
[The Documentation](http://www.python.org/doc/ "Love those docs").
No that's the funny thing .. even without any exposure to functional programming, the functional-esque aspects of python seem like second-nature. Especially decorators, iterators/generators, array slicing and list comprehension. I find that for every mental abstraction I hold in my head, python has an equivalent. To put it another way, I don't have to struggle to work out the implementation of an idea in python. And conversely the idea behind the implementation basically jumps off the screen when you read python code.
I thought it was about [this](http://en.wikipedia.org/wiki/Player_Piano). 
I see this post like once a month. If you aren't able to come up with something useful on your own, why don't you contribute to someone else's idea? There is this whole thing called "open source" software setup to enable you to do just that.
HTML scrapers are fun and pretty easy for beginners.
[Project Euler](http://projecteuler.net/) is a lot of fun.
Because I don't have the skills required to contribute to other people's software. I don't want to hold anyone back; I need to learn how to program first.
This is really cool, thanks!
There's really no substitute for scratching your own personal itch. Are there any processes you do by hand that you could automate? File management? Media management? Simple web tasks? Do it with Python!
I want a GTK or QT app that tells me the status of my online Xbox Live friends. Should cover a few bases. [XML parsing](http://duncanmackenzie.net/Blog/put-up-a-rest-api-for-xbox-gamertag-data), GUI stuff, Threading. Sounds good right? k, go!
Good question. I would ask it in #Python on irc.freenode.net; I know at least one Member of the PSF who regularly hangs out there, and there are usually a number of highly-knowledgeable people around to answer questions. Anytime I've been unsure of which module to use or why I'm getting an error that debugging can't solve, they've been extraordinarily helpful.
 M-x set-variable RET c-basic-offset RET 4 RET Smartass. ;P
If you're on GNU/Linux go to a terminal and "man cp"... Now either completely implement your own version of cp using Python OR make it better. It might sound like a stupid idea but the manual for cp makes a great road map to a great program.
I can genuinely try -- it might take me a while, though.
It's certainly not my favourite thing, but I don't feel like repeating how well the language lends itself to pseudocode and high-level conceptualizations. People have already waxed poetic about the syntax, whitespace, first-class functions, list comprehensions and generator statements, lambda expressions, dynamic typing, and many of the other things I've come to love about Python. What I'd like to point out is how excellent the Python community is. /r/python is my favourite programming subreddit, and it's generally fairly ego-less. And the #Python channel on irc.freenode.net is always jam-packed with Pythonistas. I met somebody on there once who was unwinding late Sunday night by chatting about Python and machine learning. Then there are bloggers, and PyPI, and shedskin and Cython and...
I respectfully disagree, and would say that it reads better.
not php.
This is an *excellent* way to get to know Python, in that it leads you by the nose through a lot of the standard library. It's not such a great tool for teaching you how to program though, in that there's nothing to steer you towards good habits.
I've just started working my way through this. Great stuff :)
One of my first programs written for fun was a Sudoku solver. I think it's a great toy program. It's a small enough problem that a novice can reasonably complete it. It's great practice at designing your own algorithms (don't peek at how other people do it, until after you finish). It's got a bit of input/output to deal with, which is very helpful to learn early on. You can make a reasonably clean program without needing to dive into object oriented programming yet. And finally, there's plenty of solved examples, so you can *know* when you have a correct program.
If you're just getting started with programming, I wouldn't try this yet. There's something to be said for baby steps.
This is a message board with 11 pages of posts on ideas: http://www.daniweb.com/forums/thread32007.html I've coded up a few of these for fun. Not sure that many of them are very useful, but they are good for learning.
Mac OS X has "man cp" also. The beauty is, once you've coded it right, it should work on Windows too.
I've made one open source application, it's very simple. http://bitbucket.org/jgrigonis/mortgagecalculator
Obviously that's much simpler. :) I've tried to learn emacs a handful of times, but it continues to have one significant disadvantage compared to vi: I don't already know emacs.
Get out and meet people in the real world. You will find a lot of people don't know the first thing about computers, and what you'd consider a trivially simple program can save someone a huge amount of time and effort. Great place for this is non-profits and schools. Just don't go in asking "what could I program for you in Python" - you need to spend a bit of time and understand what they do and what you might be able to do to help. Another-words: volunteer.
I upvoted this. Then took it away again when I realized most of the suggestions listed were pretty bad. Sorry, mate.
Oh, a PEP 8 heretic, eh? (sharpening pitchfork)
The flexibility, and how many different industries it's used in.
&gt; I could name a lot of things that I like about Python, but I have to give the win to Ruby on this one. I didn't follow. Why did Ruby win? Because it has two ways to express a dictionary?
It's not necessarily a bad idea. It's just possibly a bit beyond your abilities, lol. 
A decent search engine for reddit is a perpetual need. You could try the exercises in SICP, the famous Lisp book, which would teach you both Python and functional programming. You might want to pick some libraries you're interested in and learn those. Mayavi2 is an awesome graphics library. NLTK can teach you natural language processing.
There are 11 pages. I suppose I could have just stolen the good ones.
I did this about 2 years ago. More fun than making the solver was making a tool to generate puzzles of varying complexity.
 - Very modern object-oriented programming facilities e.g. metaclasses, functors (callable objects), [`abc`][1]. - Well defined data structure interfaces e.g. iterable objects, iterators, generators, [`itertools`][2]. And good syntactic sugars for using them e.g. list/dict/set comprehensions, generator expressions. - Semi-functional programming facilities e.g. `lambda`s, [`functools`][3]. - There are several mature implementations e.g. CPython, PyPy, IronPython, Jython. - Very good documentation tools e.g. [Sphinx][]. - The idiom of polymorphic module/package usage e.g.: try: import cStringIO as StringIO except ImportError: import StringIO [1]: http://docs.python.org/library/abc.html [2]: http://docs.python.org/library/itertools.html [3]: http://docs.python.org/library/functools.html [Sphinx]: http://sphinx.pocoo.org/
Significant whitespace.
Here's an idea that's fun and I dont have time to do it. Scrape the RSS feeds of Politifact - http://www.politifact.com/truth-o-meter/ - have it run daily. Put the entries in a database with the person who made the quote, the quote itself, the "lie/truth" value, and a link back - the RSS entries themselves are laid out in a simple and predictable way, easy to parse. Then build us a site with analytics so we can see who lies/tells the truth the most. If you add some NL classification to the body text of the entries we can slice it along subject material too.
A number of people have mentioned how writeable it is, how well it maps to pseudocode, etc. I'd add that I appreciate the style it enforces. When I started using Python, I got annoyed by enforced tabs, being forced to use list comprehensions instead of functions (I was coming from Lisp at the time), and the idea that There Is One Way to Do It (see previous parens). And yet I can look back on Python code I wrote years ago and figure out what it does and how it works without referring to docs or even docstrings. I can't reall say the same for any other languages I've worked with (maybe TCL).
No wonder I couldn't find it. I was searching for Project Euclid.
I've always wondered, how exactly do I contribute? I would love to jump on some projects, but are there tools where I can submit "fixes" I've made?
This has been a real problem for me, since I keep most of my code in a publicly accessible source control website. Since I have only a few scripts requiring passwords, I've made it a rule *not to store them at all*, prompting the user each time, instead. This is definitely the safest way. That said, when a configuration script can access multiple machines and has to run without user intervention, this simplistic method won't work, so a keyring-based approach like suggested here by others will be better.
SEARCH ENGINE IS FINE
The syntax.
That was one of my favourite pastimes at college..cant sleep in the night lets code a notepad knockoff in blabla language..
i'll try it! if OP is up for it, i'll set up a public github repository so we can work on it together, i'll even host it. whats NL stand for though?
Hmm, I've been wondering if those VPSs are worth it. Would you consider the Base package ($50/month) from Media Temple to be a decent deal? http://mediatemple.net/webhosting/dv/ I'm currently with Lunarpages, so I suppose I'd love to consider their options as well, but not if it doesn't compare. http://www.lunarpages.com/parallels-virtual-private-server/ http://www.lunarpages.com/xen-virtual-private-server/ THANKS!
Thanks, but after some quick reading, I'm not sure the App Engine would suffice. I mean, at this point, where I can hardly get past a 'hello world' script without tearing my hair out, it's wayyy more than enough...but I've had plans to dive into some deeper server stuff for a while now, as well as python. Having my own little sandbox for complete control (for better or worse!) sounds like the way to go. :D
Couple of steps. 1. Find a problem to work on. Most open source projects have a bug/issue tracker and a development mailing list. Rather than picking a bug at random, I'd recommend joining the mailing list and sending a message introducing yourself, giving an estimate of your skill level, how much time you're interested in spending, and asking if they have any particular bugs/issues that'd be a good fit. They're far more likely to have a better idea of what's tough and what's easy than you could glean from just reading the bug reports. Pick something small and easy to begin with, unless you're an experienced developer. That way there's less work lost if they don't end up accepting your fix (which can happen--regardless of your skill--if they disagree with its design, implementation, style, etc). 2. Checkout the source code from their repository. If there's not already a test case which demonstrates the bug, I recommend writing one. Then write a fix, verifying that it makes the test case(s) pass. 3. Create a "patch" file (details of which depend on what type of source control they're using: SVN, CVS, git, mercurial, etc.) which contains the changes you've made. 4. Assuming that they're using an issue tracker, update the issue/bug that you're working on, attach your patch file, and ask for feedback. This will generally lead to them either applying your changes, or asking you to tweak a few things. 5. ??? 6. Non-profit!
**Make a program to track your expenses, its easy**. It is how I got interested in programming and it has a use. You just import the sqlite3 module and make a database with categories like date, amount, item and then you can learn to use sql queries as well as try differant ways to sort the amounts and where you spent your money. It is a great way to learn because not only is it useful but it relates to your own life. **Or use it to organize an address book or music collection, or photo album.** You can start small so it does not take a long time to think up a complex database structure then you can just start getting crazy and doing all sorts of methods. Trust me you will be organizing everything you have after you mess with it for a week. 
The danger of this is that you are liable to waste a bunch of time using the program instead of learning how to become a better programmer. I spent 2 hours hacking up the program, then 5 hours doing data entry...
`High five` for what looks to be an awesome resource, I'll check it out more in-depth later on when I'm not so busy. I'm also trying to get into Python a bit more and always on the lookout for new learning tools. I just wanted to point out, that site nearly made my eyes bleed. It wasn't really the design in general, which is sorta nifty... but when I moused over the home button...
Remember, it's pronounced Euler, not Euler.
Funny. I do the opposite. I write a program to solve a problem, and then spend all my time working on the program and forget about the original goal.
Don't. If you obfuscate passwords, the users responsible for the safety of those files won't feel like they are as vulnerable as they are and won't exercise the appropriate level of caution, yet potential intruders will remain completely unfazed.
&gt; Go back to tabs, they are better. Tabs are explicitly discouraged by the Python style guide (PEP 8).
I've been meaning to write a script that would monitor a product on amazon for a used version less than a given price and either email me about it or prompt a growl notification. Feel free to implement and post to github :)
Something in here might be able to help you read in the mp3 or ogg and get wave form data out of it: http://wiki.python.org/moin/PythonInMusic After that it probably gets complicated. If you are operating on something simple like a single sine wave you can probably just throw the wav data into something like NumPy, do an FFT (fast Fourier transform), and be good to go. On music or something more complex the FFT is going to return a variety of frequency components, which may or may not be what you want. edit: formatting
Also, you can use them with any iterable, including a generator or generator expression. I used a list expression on a generator in a [speed modification to Beautiful Soup](http://bazaar.launchpad.net/~leonardr/beautifulsoup/3.0/annotate/head%3A/BeautifulSoup.py#L339) (an HTML/XML parser for Python) that greatly improves performance for some searches. That brings me to my own thing: iterables. They're used throughout Python. Take the all(...) function. Example: You can easily check if every line in a file matches a given regular expression: all(regexp.match(line) for line in f) The code is so concise because (1) files are iterables, (2) all() acts on iterables, and (3) generator expression can be used with all. The equivalent in, say, Java would take many lines of code to do the exact same thing. The equivalent in C++ using its standard library would make Baby Jesus cry.
 While true , no pun intended, if you are creative you can figure out ways to import the data from existing sources (import win32) which leads to other ways to learn to program. You have to make programming about solving real problems or it just gets old. Just pick something that you want to accomplish and figure out a way to accomplish it by turning over stones as you get to them. For instance I want to import all my music lists from Itunes. How do I do this? As you search for solutions throughout the internet you just get better by figuring out how to solve it, by the end you may have forgotten your original intent but learned so much. **Figure out how to get Itunes music lists into Python in the process you will become better at programming.**
Perhaps he could implement a simple neural net that would output random ideas and he could vote them up or down to train it. Wait, this sounds fucking familiar.
Ruby: {x: 1, y: 2} Python: {"x": 1, "y": 2} It's a small thing (and not quite the same meaning, with symbols v. strings) but you were complaining about something small. Things I like about Python: * Generators * Comprehensions (both list and generator) * Enforced indentation, so I don't have to read misleadingly indented code * Explicit parentheses for function calls (though I admit that the lack of parens makes Ruby an excellent DSL) * Explicit binding (except with `from _ import *`) * Module-name matches filename (though I can see a rationale for Ruby/Perl-style namespaces) * Consistency. Rubyists like to claim that their language is highly consistent, but they're very selective in their examples. Brackets v. `end`, subtle differences among lambda/block/proc/function, and the `self.` syntax for class methods are all counter-examples. * The `with` context for resource release. The Ruby alternative is a bit more complicated than Python's `contextmanager`. * Decorators (though they can be abused with side-effects) * Doc-strings * Doc-tests Basically, the things I like about Ruby make me more productive as a programmer, while the things I like about Python make it easier for me to read code written by inexperienced coders. Bring on the hate, but that's how I look at them.
It's not like PEP8 is a law, and it's his code, so why use spaces if he prefers tabs?
Nobody makes text editors anymore. It's blogs now.
That seems nice, but I still can't find a good package. A search of 'waveform' through the page finds one package: Snack. It uses Tkinter and I have no experience with it, so it'd be good if someone who has used Python in music gave a suggestion too.
How about a game? Some sort of Space Invaders written with Pygame?
Random combo of issue and technology(ies) I shall write an app to solve "world hunger" using "version control" and "machine learning"
Consistent indentation, I think. It's almost always 4 spaces in Python. Ruby people seem to use 2 and that looks more cluttered. Code blocks in Ruby are useful but look cluttered (to me as a Python programmer anyway). Perhaps it's also the $ signs that aren't used in Python. Anyway I guess they are a matter of familiarity. Perl looks like line noise too until you work with it for a while and see that you can write perfectly normal, readable Perl. If that's so, it's certainly true for Ruby :-)
Maybe he could create a site where these neural networks would go and vote the ideas, and then he would implement the most voted ones.
I remember something about autocorrelation being used to detect pitch. Might be easier on the resources than FFT.
Bump for Project Euler. The later problems are pretty relevant to high performance computing techniques.
:( Its a Synergy database if that makes any difference. I thought this project was going to be cake until I hit this wall. this is my first Python script BTW. 
I'm just trying to get to the bottom of the objection... Is it that keys in dictionaries can be any object, and you'd rather keys be something specific and unique (is this how it is in Ruby? I'm curious, because I don't really know Ruby); or is the objection that strings as keys in dictionaries require quoting? One of the nice aspects of the ways dictionaries behave in python is just this, that any object/type can be a key. ... Or this is how I understand it. &gt;&gt;&gt; {True: 1, False: 0}[True] 1 
hmm, some more searching and I found this http://pymedia.org/features.html I haven't used it, so again I'm just throwing around possibilities, but it claims it can decode mp3 and ogg, and also mentions some analysis features.
Make your (better) version of **top**. This might need learning curses - not that very easy, but hey, no one learns by doing simple things. Make a simple server monitoring tool (RAID status, cpu temp, fan conditions, free space, ram utilization etc); make it send you emails / jabber messages with summary every *n* minutes If on linux, read some GTK/Qt basics (quite simple to use and talks great with python) and make a tiny app which shows a graph of disk space usage with things like showing largest files in subdirectories, etc) Or write an opensource email client with **proper** IMAP support ;)
A VPS is worth it if you can afford it. Root access, real security (i.e. Don't get hacked because a shared user is a retard), installation capabilities and configuration are too good to live without for anything largere than a basic blog. Linode has plans starting at 20bucks a month, that's what i'd recommend. Never had a reason to complain about their service in years.
Before we're comparing apples and oranges here: The closest counterpart to Python's lists are vectors in Scheme. The closest counterpart to Scheme's cons cells are Python's tuples. Except that tuples are immutable, and cons cells are not. If you want your mind blown, look at Clojure's vectors, which are purely functional (i.e., immutable), but allow list "mutation" (i.e., replacement of elements somewhere in the vector, yielding a *new* vector) with a much lower complexity than Scheme's single-linked lists.
'gunaxf!'.decode('rot13')
&gt;Because I don't have the skills required to contribute to other people's software. I don't want to hold anyone back; I need to learn how to program first. That's not true. Take a program you like with something (simple) that doesn't work the way it should. Download the source, then try hard to fix the issue. Once it's fixed, send a patch to the author. He probably won't accept it as it is, but will give you some advice on how to make it better. You will learn a lot more like this than by working on toy applications by yourself. And you won't be holding anyone back.
I wrote a script to download the latest xkcd from their rss feed and make it my wallpaper. There's probably already an app for that.
Here's something: Write a script that scrapes SC2 replays out of the "recent games" replay folder, and posts them onto http://replayfu.com/, and adds a link to the replay to a web page hosted somewhere.
Christ, I wish I had your problem. I have about twenty bazillion things I want to make, and no time to make them.
I am very surprised this hasn't been posted. http://projecteuler.net/ and run through some of their problems. Almost all of them require a computer to solve (though some are easier by hand if you aren't very savvy). When you gain a new skill or understanding, it usually becomes much easier to do a few new problems. For instance, when I learned how to split a number up by each digit, it allowed me to solve at least 2-3 more problems than I could have before. Its a wonderful thing to do
Only sufficiently immutable types can be keyed. The `object` type is keyable by default, though.
Whenever you have an idea, write it down. Keep a notebook with you. Soon you'll have too many ideas...
Is that a Monty Python and the Holy Grail quote?
That's actually a sweet idea. Noted.
I drunkenly talk to women on okcupid regularly. Do you think python can automate that for me?
You called?
Have you ever actually done that? You have to make it very clear that this is a one-off, unless you want to get called out every time they have a problem or feature request. Writing a program for someone is like having sex with them. Fun, but if you aren't careful you can end up having to provide support for the rest of your life.
Write an app that writes apps
I've been on a similar quest for half the year now. I'm in Maya (3D app) for work, and at home, and I've been doing MEL (Maya's scripting language) pretty hardcore for 8 years now. I have an SVN repo on my thumbdrive that I used to port my code between home and work, and I'd just commit to that all the time. All the MEL in there is my own, and there are over 70k lines of it. It's been a very handy language, and I've written some pretty complicated toolsets with it, but I was always limited. I got a new job in May, in Maya, and decided to switch to Python there and use it a lot more at home on my Linux box. It was a serious struggle for me. I didn't like so much about it, though I did love things like syntactic sugars (list comprehensions, multiple assignments, etc - all that cute/tricky stuff it can do). I was waiting for it to start feeling powerful, and I actually think that this week is when it started happening. I've been writing a UI toolset that will let me build windows, which meant I needed a tree, and spidering of said tree, and insertion of layout and control data into the tree, and a zillion other things - making a UI maker that's in a UI that shows the UI you're designing, and spits out code that will make the UI again later, and allows saving of the input information for later reloading into the UI to do all that I've mentioned already is quite a task, but it suddenly started to collapse, in a good way. I started realizing that I was reducing everything to a few lines of very simple code - things that would have taken pages of MEL script to accomplish. For example, in hier.py I have a Hier class, and it creates a self.children dict in its \_\_init\_\_. When you call its add method, it just makes a new Hier instance and appends it to self.children, and gives that Hier object a parent property with a reference to self. This means writing getRoot was about as a trivial as a `while parent.parent is not None` loop and, getDepth was about 1 line more difficult. To scrap together a tree of 20 random elements to screw around with testing, I did something like this: import random a = Hier() b = [a] for i in range(20): b.append(random.choice(b).add()) That's it. I can rerun the last 4 lines to recreate a new junk tree with 20 elements with different hierarchical layout each time. Everything so far has been this easy in this project. I have a spider function that will descend and fire off a callback starting from any node that calls it. It's 3 short lines of easily-readable code :) The spiderAll function just pops a getRoot() before the call to spider to do the whole tree instead. You just pass in callback, the only argument. Then I made a pretty printing thing for it in about 3-4 lines of code, 2 of them a def statement in the function to create the callback function I pass in to spider. This is what I'm loving about the language. I feel like I'm screwing around, and yet I'm achieving blissfully simple code that does exactly what I want, and isn't boxing me into corners or getting sloppy anywhere. In fact, on this particular, latest project, all of the solutions to problems have involved pruning the code way down to a few lines that do what I want better and far more elegantly than the mess I started out with. Add in that I'm becoming something of a vim power-user, and I feel like I'm flying through a world of code this week :)
I created http://www.reddit.com/r/SomebodyMakeThis for just these occasions :)
Classes as callable objects is interesting. I was unaware of that (but it doesn't surprise me). It could certainly be perceived as a distinct use to someone similarly unaware. It does seem quite Pythonic that it works like that, though. As far as parentheses as a grouping operator goes, I agree that there's commonality in their usage there, and that commonality is logical. Nonetheless they are necessary to create a generator (they can be omitted only if the generator is the sole argument to a function call, in which case there are parentheses anyways), and are the syntactic bit that separates them from list comprehensions. Parentheses are somewhat more optional for tuples, however (except in certain cases, such as the empty tuple). I accept that my list could certainly be condensed by combining some of these (as you've rightly pointed out); I think the point that reuse of punctuation is normal stands, however.
It reads like poetry.
Games! Perhaps not the overdone ones, but they encompass lots of interesting programming topics. Plus, making something easy and fun is a great topic in itself, instead of just making something work. I'd go for either that or volunteering.
Tuples in Python are just immutable arrays, there's nothing linked-list-y about them.
Open source is also about making it reasonably easy to contribute. If there are standards, and there's no controversy about them(or in this case, no longer), why not use them? There's also a reason that tabs were discouraged. Not all text editors treat them the same way. I once had an IDE mess up my indentation on my project, for instance. Also, this frees up the tab character, so that it just fixes the indentation.
...It HAS been posted! :)
Make a 2-element tuple where the second element is another tuple. Voila, linked list! 
The Mac version of "man cp," and the Mac version of cp itself, are far superior to the linux and windows versions because they were designed from the ground up to provide a second-to-none user experience. Discerning users use the Mac versions of "man cp" and "cp." It's because we are a cut above the rest.
How about trying to write a game? If you keep the scope as small as possible, as in just having something that is playable, you might be able to finish a simple, fun project. My inspiration is [PyWeek](http://pyweek.org), in which I've participated on occasion. Sometimes when I think of something useful, it tends to be over-the-top complicated, like "a custom, minimal Linux distribution that boots directly into an Atari emulator and provides seamless user experience and reliable networking with configuration tools on the Atari guest OS to modify the host Linux OS settings if necessary." That example is one I've thought about undertaking as it would be useful to me and a handful of others, but I rapidly became overwhelmed by how complicated such a project would be. 
I just wrote a very small python script that you could replicate: It traverses the directory tree from the point of execution and adds all files that have a modification date differing from the current date by a specified number of days to a zip file. Very useful :)
&gt; As a result, it's cheap to get a list's length, to append an element, or to access/rebind a list's item (all of these are O(1)). No data structure can have all these properties at once. In this case it's an array, so appending an element is *not* O(1). 
I have to Pypy pay to CPython run n-now ?
Since nobody has suggested it yet... The Python Challenge is a really fun way to explore Python by writing programs to solve simple puzzles (or not so simple once you get further in!) Check it out at http://www.pythonchallenge.com/
Ruby: {x: 1, y: 2} What if I want keys with spaces or commas in? Python: {"x": 1, "y": 2} OR dict(x=1,y=2) 
I _think_, but I'm not sure, that Python lists have extra room, making appending an element in most cases O(1). Except of course when the extra room is used up, and then a new array is created, with extra room again. _If_ they make it twice the size needed, then it works out to O(1) _average_ time. Not worse case of course. But now I need to stop typing because it hurts to post 95% conjecture :-)
See also: [http://jessenoller.com/2009/01/08/multiprocessingpool-and-keyboardinterrupt/](http://jessenoller.com/2009/01/08/multiprocessingpool-and-keyboardinterrupt/)
Good luck :)
How does it work?
Wow I completely forgot, but also for me, this was one of the first things I ever tried to program.
Actually that might work pretty well.
Although I hate doctests, I've always thought this was awesome.
how about metaprogramming? http://www.acooke.org/cute/PythonMeta0.html 
Cheers :)
Spoiler alert: I had to Google that, myself. While I don't have a problem with people using Emacs - the way I see it, Emacs and Vim are both way better than most other text editors - I'm probably never going to try it. One of my coworkers used to use it, and started getting "Emacs Pinky". Me and the other Vim guy convinced him to give Vim a try, so he switched to Viper mode. Best of both worlds, I guess! =)
Yeh, I looked at Pymedia, but it wants me to compile with MingW....:(
I gave up on the Python Challenge when it became clear that I wasn't actually learning the stdlib as much as I was bashing my skull against some clever person's idea of torturing me. Some of the challenges get really opaque, and I was spending more time figuring out *what* to do than *how* to do it. To learn the stdlib, read through [PyMOTW](http://www.doughellmann.com/projects/PyMOTW/).
Natural language.
Cool, thanks a bunch for the tips. Anything to keep baby jesus from crying...
[Programming Praxis](http://programmingpraxis.com) provides a collection of etudes, updated weekly, for the education and enjoyment of the savvy programmer.
Here's a fun one: write a checkers game. Make it simple, command-line only. You already know the rules (I'm guessing), and it'll teach you some basics of user input, control flow, etc.
Eulest.
Damn, it's a little discouraging that it took a while for things to "click" for you, though it sounds like it did in a major way. Also, it's cool to hear that it keeps its grace in a complex hierarcial OOP situation; so much of the examples I've seen so far don't focus on its OOP aspects, so I haven't been able to see the whole functional thing working along with the OOP stuff (which, to me, seems like two entirely different thing). And yay for Maya! I used to use 3DS MAX pretty heavily about a decade ago, and always looked to Maya!
what the poop?
&gt; Now of course we are lacking some of the complexities of GFS necessary for a fully functional system: metadata locking, chunk leases, replication, master failover, localization of data, chunkserver heartbeats, deleted file garbage collection. Right...
Cool, thanks, I'll take a look at them as well!
Nobody makes blogs any more. Now it's object-relational mappers.
When I started with Python some 5 years ago I wrote an RSS reader. It's something pretty simple to write. In the beginning it wasn't even a web or GUI based application. Then it became web based. After that I added article filtering and keyboard navigation. I still use it everyday. It's not as fancy as Greader or whatever but it feels good to eat your own dog food :D ...or you can write another CMS. The world clearly need another one.
Don't confuse worst case O(1) with amortized O(1). Edit: If i take a simple array, add extra space (and redouble size when full), I get O(1) worst case access plus O(1) amortized appends. To get O(1) length, i just augment it with a variable that is updated on every insert/delete. The key is that my append is O(1) amortized not O(1) worst case. Edit2: if we allow O(1) expected, then it can be done easily with a hash table whose key are the "indices" and value are the "item". Again this has to be augmented to store the length. This is easier in the sense that building on top of a hash table is slightly easier than building on top of an array (esp if you have to handle resizing logic yourself). 
I think you'd get a better deal with Linode: http://www.linode.com/
O RLY? What built-in function would you then use to iterate this linked list? Or map it into a new one?
There are no built-in functions for iterating over such linked lists (you could always write your own), but that doesn't make it any less of a linked list. Like wally_fish said, a two-element tuple is identical to an immutable cons cell. 
Yeah... it's *cool*, but you didn't *really* implement a filesystem.
And I prefer them anyway.
I have way more anecdotal evidence that proves that tabs are better for me.
Sounds like he means the REPL (read-eval-print loop). That thing that opens up when you run pythonw. If that's what you mean by "command prompt", then yes.
I've been calling all of the previous exercise files by using: C:\ &gt; python exINSERT_EXERCISE_NUMBER.py Does that mean I should be using pythonw to call the file instead? EDIT: Nevermind. tomazk FTW
Sadly, I don't really remember exactly. Basically, it would start with a completed sudoku puzzle (all squares filled in) and randomly remove numbers, until it passed a threshold. The solver had 4 steps of solving that it ran in order. As it required each additional step, it would output the puzzle in the last state and call it level [1-4]. I don't remember the first 3 steps explicitly, but they were progressively more complex. The fourth method used guess and check to get the solution. If the puzzle ever became unsolvable, obviously you would back track one removal, and that was the hardest puzzle I could come up with easily. I think that was called level 5. My goal was to give it a UI, and instead of it randomly picking squares to remove, you would be able to click out the squares you wanted to disappear, and then rate the puzzle 1-5. I never made a UI for it though.
Thanks, that's 2 of 2 recommendations in this thread, so I'll certainly take a look.
It is questionable whether the steps the solver needs is approximating how well a human could solve it. Also, what kinda steps to solve it are you talking about?
Ok, I didn't read the book but I think it wants you to do something like this: * open your command promt * navigate to the directory that contains your .py file * run python C:\path to your pyton instalation\python.exe * let us assume you have a .py file named *mymodule.py* with a function named *my_function* in it - now type this into your python interpreter &gt;&gt;&gt; from mymodule import * * you can now call this function from your interpreter like so &gt;&gt;&gt; my_function() Does this help? 
YOU ARE MY HERO. This is exactly what I needed. Thank you so much tomazk! EDIT: Removed "EVERYONE UPVOTE THIS MAN" for Redditquette.
Nobody makes object-relational mappers anymore. It's microblogging platforms now.
You should install ipython instead of using the plain python.exe REPL. The history and autocompletion are a lot more useful, among other things. Also, don't get in the habit of using import *, it will eventually mess things up when a library function has the same name as a standard python function, like map. It's ok for your own code but bad style for 3rd party libraries in general. 
Hey there. Please let us know if you have any questions about (mt) services. We are available 24/7 via phone and Twitter (@mediatemple).
Thank you very much for the helpful hints. I'll definitely keep these in mind and use them when I graduate from the beginner's book :)
You'll enjoy learning more if you use ipython, trust me.
They did really implement a filesystem, just not GFS.
PEP-8 is not law, but it is a commonly held community standard, and if I were recommending a project for someone to work on, all other things being equal, I'd recommend one that adheres to community standards, to help the person develop habits that will help them be a better citizen of the community. And yeah, that includes PEP-8.
Hop on github and bitbucket. Find some simple apps that do something you like, and start tweaking them. This will help you learn both how other people program, by reading their apps, and how to use a DVCS (Distributed Version Control System). It's probably best to learn both Mercurial and Git, because you'll find lots of projects that use both. Git is more powerful, Mercurial has a cleaner user interface design. I tend to find Mercurial powerful enough for most of my needs, and more pleasant to work with, but I think fluency in both is important. Fork projects, make branches that do different things. Once you're happy with one of your features, offer it back to the original author.
You don't always have to contribute in a huge way initially. You can submit fixes for small bugs or feature requests through the bug-tracker and eventually come up with your own features/fixes as you become familiar with the software. You can also avoid programming initially and write documentation for the code. This allows you to familiarize yourself with the codebase and software without "getting in anyones way". Though I highly recommend getting in someones way. There are definitely a few egos in open source that behave inappropriately towards new comers (capable or not)... but I've actually found quite a few communities that are happy to hold my hand and mentor me. Start with the IRC or Dev newsletter for a piece of software... then find a bit of missing documentation, then a bug, then a feature... then you will have *skills*.
Here's what I did: I started in on [Project Euluer](http://www.projecteuler.net) and did a bunch of those to really get into how Python works. I'm a math guy, though, so it was a little more my style. I also wrote a Home Library app, which basically lets me track my books, cds, dvds, [media_types]. For instance, I can check right now and see that my copy of the movie Dark City has been loaned to one of my friends, my copy of Hyperion by Dan Simmons is at my parent's house, and one of my old coworkers has my cheesecake pans. It also lends itself well to extension - there are hundreds of little ways to make it better, and each one is a new learning opportunity. For instance, I think the next thing I'll work on is a little android app for check-in and check-out. First, I'll make a simple interface for checks; eventually I want to use a barcode scanner to do it. This is how way leads on to way; if you choose a project that solves a particular problem (for me - losing books) and then think about how it can be generalized, you'll find something that works for you.
if this is instance based, how the heck does it persist over restarts for instance? I guess you could serialize these instances and output them in json or somthing. Pretty cool.
In chicken scheme there is an egg for dynamic vectors. In Gambit you have vectors and homogeneous vectors and in Bigloo as well, IIRC. One thing I don't quite get from the Clojure community is the branding. Clojure is really not any more special or different from a vanilla scheme than most implementations are. If anything, less emphasis is made about what's standard scheme and what's not, from the tutorials I've seen.
Scraping rss feeds and doing fun things with the contents has always been something I've been fond of. I wrote an markov based irc-bot that "learned" english from craigslist's casual encounters rss feed...
AFAIK, you 'call' functions/methods, not files. You import or execute files.
IMO, Clojure is rather Scheme-ish/LISP-ish than attempting at anything like being an ANSI-compliant LISP or R5RS-compliant Scheme. What makes Clojure's design attractive in comparison with R5RS scheme is that you have a clean separation between mutable and immutable data structures (rather than *treating* data structures as immutable most of the time, except when you're not, which can lead to hard-to-diagnose bugs). And of course, it has lots of publicity because of good JVM integration.
Well, first I wasn't the one complaining, I just did not follow why you thought ruby should get the win here. Second I don't intend to bring on any hate. That Ruby makes you more productive as a programmer is not something any amount of reddit-hate can change, it's simply your take on things. However, I am not sure I agree with your win. In ruby is the thing between the { and : contextually assumed to be a string used for the key? If not, how would I differentiate between a key string and key object? That seems like a loss to me. Why can I not use any hashable object as a key?
I think you mean hashable. The object doesn't have to be immutable, only the hash value returned by `__hash__()`. By default `object` is hashable, with `__hash__` returning the object id and all distinct instances comparing unequally. This makes it fairly reasonable to use nearly any object as a dictionary key. The only time this breaks down is if you want to be able to look up one object instance with another distinct instance. In that case you need to pay attention to hash value mutability and implement your own `__hash__` and `__eq__` (or `__cmp__`) methods.
Ah yes, apologies for the vocab.
Any "[whatever] Oriented Programming" is overrated. Need objects? use them. Map/Reduce techniques seduce you? use them, even with those neat objects you have. Your main loop and selected algorithms will most certainly be procedural anyway... Multi-paradigm languages for the win!
Glad it helped :) Keep in mind that if you edit your function after step no 4 in my previous post, the change will not be reflected in your interpreter. You'll have to reload the module with the built in function *reload* like so: &gt;&gt;&gt; import mymodule &gt;&gt;&gt; # edit your .py file &gt;&gt;&gt; reload(mymodule) &gt;&gt;&gt; mymodule.my_function() Note: I'm using a different type of importing this time. 
It runs reddit...
It's solid. I've been using ReportLab for over 12 years to produce medical forms among other things. The API has been remarkably stable over that time frame. Even though we produce thousands of pages of ReportLab output daily, I hardly ever think about it unless I've got a new project. 
reportlab+platypus is great! You may also want to look into [pyfpdf](http://code.google.com/p/pyfpdf/) for html-to-pdf without dependencies.
If you really want to mesh smoothly with objects, do you really want an ORM or an true object database such as ZODB?
I think step 1 was: Every empty space starts with all 9 possibilities. Go through the rows and columns that share that space, and eliminate possibilities. Also, in the 9-square, eliminate those possibilities. As soon as that technique didn't work any more, that was level 1. It was very very trivial to solve as a human. I think step 2 involved what I called pairs. I am at a loss for step 3. I think it was actually a pretty good indicator of difficulty for humans though. I made quite a few puzzles and played them. It may have been more accurate for me, because I modeled the solver after my own techniques.
If your just looking for a 'sandbox' environment to play around in and get some practice I would recommend running a linux distro (ubuntu server seems to be very popular) in VirtualBox or another virtualization app. Then you can just ssh in and use fabric to deploy to it. This way you wouldn't have to spend any money until your ready. The [Linode Library](http://library.linode.com/) is a good resource if your starting out on linux and want to learn how to configure apache/nginx/ssh/wsgi servers etc.
* Scrape a website and turn it into an RSS feed * APIs APIs APIs * Project Euler 
Ruby has "symbols", which do not exist in Python. Yes, you can use other things as hash keys, including strings, and in that case the syntax is a little uglier than Python's.
1) Write a rocket, start simple, iterate and go to the moon. 2) "Infinity, and beyond" -- B. lightyear
I wrote a small script that puts a random noun in front of "As A Service" to whet the appetites of our business folks. You can get a random noun from [here](http://watchout4snakes.com/CreativityTools/RandomWord/RandomWordPlus.aspx) to try it out; it's rather amusing.
Then I'll refer you to the first point of my previous message. Or we can really kick the anecdote-off up a notch and I'll say that ever since I stopped using tabs for indentation, my mustache has been way more lush.
The Ruby syntax above is using "symbols" as hash keys. If you use "strings", you need the more verbose syntax. {"x" =&gt; 1, "y" =&gt; 2} Interestingly, Ruby allows this: Hash.new {|h,k| h[k] = k.to_i*10} which is equivalent to this in Python: defaultdict(lambda k: int(k)*10)
I was only pointing out that while Ruby is a little more verbose in some cases, it also has some rather convenient syntactic sugar. Ruby and Python are actually very similar.
If tabs are stopping anyone from contributing to my project, I probably don't care. What I have found thus far is that Notepad++ is pretty smart about tabs, and has this neat little option here: http://imgur.com/mDg9z.png Unfortunately, to go back and fix tabs to spaces is a search and replace function, which could cause bugs. On my mac, I am currently using TextWrangler, which has an Entab/Detab menu option, but it's not as smart as Notepad++ as far as automatically converting as I type. If it was, I might switch... Also, tabs seem better for mouse driven development, as it's easier to be off by one space than off by one tab, when you click into whitespace. I'm sure there are some stupid IDEs out there, that can't do the right things with whitespace, but why would you use those for python? If I can find a better alternative to TextWrangler that can replace tabs with spaces while I type, I'd probably switch. My lush mustache: http://imgur.com/nHE1o.png 
I've been using Python for several years now, but never bothered to see what all the fuss was about ipython. This thing is amazing.
As said already a VPS is best, but there are shared options available if you are on a tight budget. Check out http://djangohosting.org/ Most of these will support WSGI which pretty much all python web frameworks will also support. 
File path manipulations are best done with [os.path](http://docs.python.org/library/os.path.html), not with plain string operations. I suggest you use os.path.commonprefix to find the common prefix and then chop it off the front of the second string.
There is also APScheduler with cron support, if you need inspiration or code to rip :) http://packages.python.org/APScheduler/
It's URIs, not file paths. Strings could potentially start with http://bla.com/bin/. I'm relearning python, I seem to remember some script language had a fancy way of doing what I want!
If you don't feel like you can contribute to the innards of a full-fledged project, you can always go down the plugins route. That's what helped me build up my chops (and self-confidence) to the point where I felt like I could jump into the codebase of a full app and help out. It's small enough so that you don't get discouraged or lost, yet it's tangible enough that it feels like you are actually contributing and creating something... and you actually are! ;) For Python, if you're interested in Gnome development, writing [Rhythmbox plugins](http://live.gnome.org/RhythmboxPlugins/WritingGuide) is always a good place to start.
 &gt;&gt;&gt; import urlparse &gt;&gt;&gt; urlparse.urlsplit('http://www.google.com/pants?q=1&amp;foo=bar#top') SplitResult(scheme='http', netloc='www.google.com', path='/pants', query='q=1&amp;foo=bar', fragment='top') &gt;&gt;&gt; &gt;&gt;&gt; urlparse.urlsplit('http://www.google.com/pants?q=1&amp;foo=bar#top').path '/pants' 
I think reportlab is great. There are not many open source reporting frameworks out there let alone in python. It takes a bit to get used to. The manual is so so. But the source code is readable. One thing you will have to do in more complex projects is subclass many things to create your own behavior. If you try to make the default classes do things they were not intended to do you will wind up with very complex code. So take a crack at it. Look at the source code often, and don’t be afraid to subclass and override. Also use pypdf to merge pdfs if you have legacy forms that need to be filled in. I’m using celery, django, and reportlab together and works fantastic.
use [os.path.commonprefix](http://docs.python.org/library/os.path#os.path.commonprefix) to get the common part, and then get its len to use on the slicing.
No, but it is trying very hard to sound like one!
Or use the posixpath library, because posix paths and url paths are basically analogous.
... which is identical to a two-element list, which is identical to a dictionary with (head, tail) keys, or a class with (head, tail) attributes. Saying tuples are the closest thing to cons cells is stupid, and so is whoever it was who downvoted me. Downvote me again, I don't care, I know I'm right. Edit: Actually since cons cells aren't immutable, they're more similar to python lists than tuples. Eat shit.
Oh, I am Sooooo not touching that ... 
Upper Class Twit of the Year is one of my favorite skits. So awesome.
[mincemeat.py](http://mincemeatpy.com) is only a little bit bigger, and has additional features like fault tolerance.
I use ReportLab to just make some PDF'd versions of tabular data for human consumption, and it feels very clunky for that. I think if I wanted to generate forms, where things are very precisely placed, I'd like it much more. I've started generating LaTeX with my new programs, and just running PDFLaTeX on it, to produce my PDFs, and it's much simpler. (I say that as someone who already had nontrivial LaTeX experience, though. YMMV)
&gt;which is identical to a two-element list, which is identical to a dictionary with (head, tail) keys, or a class with (head, tail) attributes Nobody is disagreeing with you. But you said this strange thing, &gt;there's nothing linked-list-y about [tuples] I demonstrated that tuples are a very natural choice for immutable linked lists. &gt;Actually since cons cells aren't immutable Depends. Sometimes they're immutable (Scala, Haskell), sometimes they aren't (Scala, most Lisps). &gt;they're more similar to python lists than tuples I don't think you're understanding these data structures. 
Hey I'm new to Python (and programming too). I found it very rewarding to make Conway's "the Game of Life" in Python. It took me a while to figure out, but it was very rewarding in the end, and made me happy when it finally worked. I'm now trying to learn javascript (just finished 'porting' my Python Game of Life to it.) Good luck friend.
I like bpython myself.
I agree. It is solid and I found the devs very helpful when I needed it.
I like the product, and they're good guys - I've had a phone chat or two with them. Also, we use Pisa (http://xhtml2pdf.com), which is based on ReportLab, which works well for our purposes (PDF versions of docs created with TinyMCE).
 &gt;&gt;&gt; "/bin/file/1234".partition("/bin/")[2] 'file/1234' &gt;&gt;&gt; "/some/other/path".partition("/bin/")[2] ''
That's probably the smart choice, but I've never let that sort of stuff sway me... ;) In all seriousness, I'd love a single server to host all my domains/sites from, so there's a lot more to it than just python. I'm quickly approaching the point where the multiple shared hosting accounts are getting too costly, especially when compared to the linode prices!
Thank Mister mediatemple! That there is some good (almost scary) customer attention! :)
 if str2.startswith(str1): list.append(str2.replace(str1,''))
 &gt;&gt;&gt; "/some/other/bin/path/".partition("/bin/")[2] 'path/'
Hmm... Is this a list you have? I did something similar (for files) using the csv library and '/' and a delimiter. This won't apply directly, but maybe you can use the idea for your situation. remnants.csv: W/Weber, David/The Warmasters.epub W/Wiiggin, Kate Douglas/A Village Stradivarius.epub W/Wilhelm, Kate/Symbiosis.epub W/Wilson, Robert Anton/The Illuminatus! Trilogy.epub W/Wodehouse, PG/Something New.epub W/Wu, William F/Cyborg.epub rename.csv: import csv listReader = csv.reader(open('scripts/remnants.csv', 'rb'), delimiter='/') for row in listReader: pre = row[0] auth = row[1] file = row[2] src = 'books/' + pre + '/"' + auth + '"/"' + file + '"' dest = 'organized/' + pre + '/"' + auth + '"/"' + auth + ' - ' + file + '"' print 'mv ' + src + ' ' + dest 
Here is how I would do it. &gt;&gt;&gt; print "/".join("/bin/file/1234".split("/")[-2:]) file/1234
and Python.
That looks very nice. I like the autocompletion but I can't figure out how to get it to display the help for a function easily like ipython's ?. F2 for display source sort of does it but not quite.
i just tryed out cython. holy shit. HOLY SHIT. I dumped a 400 line pure python math library i wrote into a C extension without having to change anything. 35% speedup. Then I added "cdef int" before all for loops, 80% speedup!
I found the this [workaround](http://stackoverflow.com/questions/1408356/keyboard-interrupts-with-pythons-multiprocessing-pool/1408476#1408476) to be ok.
Wayyyy better. Sometimes it takes a paragraph to describe what one line of python is doing. It's so concise and elegant.
There's something to be said for trying to be clever... it's usually not good :)
I wouldn't say so. The clever solution just needs to be a little more clever, that's all. ;)
They seem to have several platforms. And the mobile one looks to me like it only supports Java. Where did you see Python?
Uh, in case you downvoters don't know, that's the Monty Python skit that is pictured.
No. Ok, you did map reduce in python. All well and food. Don't say you reduced google to this one formula. 
Wow! Thanks for the link. I've been puzzling through these while watching TV with my wife for the past hour. I just finished #5 and am having a great time.
I have just completed a series of portfolio performance reports using ReportLab and couldn't be happier. I fought with CrystalReports (CR) for a while since the data platform I'm using has a nice OLEDB interface tailored for CR. In a fraction of the time I spent with CR I've implemented a wrapper around the exposed OLEDB interface and generated much nicer reports using ReportLab + Matplotlib than I could have hoped for in CR. Make sure you know how to generate output using both the canvas object and the Platypus layout engine. I recommend just reading through the Platypus code (not that large of a codebase) before starting (would have saved me a bunch of time). The source isn't that nice and the interfaces aren't exactly Pythonic but it works out of the box and I had decent output within minutes of using it.
Oh python, you can do this, but converting between UTC and local time takes reimplementation and detection of ALL POSSIBLE TIMEZONES.
Hey jedsmith, thanks again for the suggestion. I wound up getting one of the $20/month accounts with linode, and went from knowing next to nothing about setting up a linux server to knowing just a wee bit more. In just 5 minutes I had a SSH shell, and from there I was able to use their docs to update all the packages, set up a LAMP stack, and set up a web server with one of my domains pointing at the server. I'm waiting for the DNS records to propagate right now, but it works perfectly fine via the IP in the browser. SUPER COOL, and wayyy easier than I expected. This is going to be FUN! :D Thanks again!
Thanks again, sanktuaire. As I mentioned down-thread, I wound up going with linode and have already learned a lot. So cool, so easy: http://www.reddit.com/r/Python/comments/e74f7/reddit_what_is_your_favorite_thing_about_python/c1619bj
 $ pip install pytz
Most welcome my friend. Don't forget to check: http://library.linode.com/ Loads of awesome tutorials there, that'll make your life even easier.
emacs
 &gt;&gt;&gt; list=[] &gt;&gt;&gt; a='123a123' &gt;&gt;&gt; b='123' &gt;&gt;&gt; if a.startswith(b): ... list.append(a.replace(b,'')) ... &gt;&gt;&gt; list ['a'] &gt;&gt;&gt; if a.startswith(b): ... c=a[len(b):] ... &gt;&gt;&gt; c 'a123'
The ropevim and pyflakes plugins are a must. Instead of grepfind, I just have this: map &lt;C-f&gt; :lv "" **/*py&lt;C-Left&gt;&lt;Left&gt;&lt;Left&gt; And I look at the results with :lw
Using it for generating dunning letters for our customers. Works fine, even for slightly more sophisticated layouts. Takes a bit to get accustomed to it though.
Then you rewrote it in C using vendor supplied LAPACK routines and refactored your loops for optimal pipeline scheduling and cache-aware memory access patterns, 400% speedup! (This part is left as an exercise to the reader)
given str1, str2='/bin/', '/bin/file/1234' do str3=str2[len(str1):] if str2.startswith(str1) else str2 
NiiiIIIiiice! I like the way you jive.
I have a fork of [pyflakes-vim](https://github.com/alecthomas/pyflakes-vim) that support PEP8.
Thanks for the input everyone. Did anyone else find the installation process somewhat cumbersome? 
I also have been searching for something like this. The hard part is the "identify musical pitches". The best I could come up with is a web based Service / API for music analysis [Echonest](http://the.echonest.com/platform/). They also have a python lib for api access: [PyEchoNest](http://code.google.com/p/pyechonest/).
 import re def foo(str1,str2): regex="^%s" % str1 parts = re.split(regex, str2) if len(parts) == 2: return parts[1] else: return None
well said william!
he asked for more pythonic not more correct he never mentioned that the str1 occurs more than once in the str2
Yep, that's what helped me get started setting everything up. I love how informative and non-Linode-centric it all is. So much great information there, and they are *very* clear yet concise with all of their docs, but in-line with theur tools, and in their library. I wish *every* web service was like this; it's such a pleasure to use, even knowing next to nothing!
Thanks! Installed and testing!
Alright, this seems like my current choice of API/library. Cheers mate. If anyone comes across something better which doesn't require interaction with a web service, give me a shout. Much appreciated.
If you're looking to write a small useful script, I suggest writing something that will harvest your favorite online resource, or just access it if it's already available, and do some cool statistics with it. If not, I'd suggest writing a small game (in PyGame). Very educational, and you get to play with it and/or let other people play with it. First game that comes to mind: *Write Pong *Modify to make it Multiplayer Pong (i.e. 3-sided, 4-sided, n-sided, ...) * ??? *profit!
Oup. My bad - for mobile, Appcelerator only supports Javascript, Java and ObjC. http://www.appcelerator.com/products/titanium-cross-platform-application-development/ 