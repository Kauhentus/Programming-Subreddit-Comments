How does the feature set compare with what you would get from NLTK? Assuming NLTK is richer, what's the use of carrying around 500 lines of python? It's pretty lean wrt dependencies.
It doesn't scale to millions of asynchronous calls per second. But most projects will never get anywhere that big. 
It's a very PHP thing to have a function called password_hash(). You say "sensible defaults" now, but what happens when that changes? Is everyone who's still using PHP 5.5 vulnerable? Will we get a function called password_real_hash()? (not even kidding here, look at mysql_escape_string() and mysql_real_escape_string()) It's much more pythonic to use import bcrypt, bcrypt.hashpw()
If scaling fascinates you, a fun hobby project is to build a distributed system. A simple design includes a control node, worker nodes and an interface node. What your worker nodes actually do is up to you. It is not a simple problem and you will make a lot of bad design decisions, but you will learn a lot in the process and it can be really fun. I recommend looking at pyzmq. Many good employers will value your enthusiasm, dedication, and ability to learn quickly over what you actually know. That said, a good foundation in Computer Science is invaluable if you intend to begin a career.
I hate to be that guy, but you should RTFM. Amongst other things, the recommended usage includes re-hashing if the default algorithm changes, so (in theory) users whose PHP is upgraded underneath them -- like shared host customers -- can benefit from security improvements without having to know what they're doing. Users who do know what they are doing can use advanced features, but they're not the target audience. We have ample proof by now that even apparently capable developers get the details of security wrong: a high-level interface with sensible defaults is the only way to protect people from themselves. About bcrypt: Not only is the bcrypt module not included in Python, it doesn't offer the same upgrade path. If you decide you want to switch to scrypt, it's a new module with a new interface, and most importantly, *you have to know enough to be able to choose*. It is also not equivalent to the PHP solution, which (optionally, but by default) generates a salt in a substantially more secure way than most developers will, rather than relying (as Python bcrypt does) on the user providing one.
Constituency parsing can be done incrementally too, and now the incremental constituency parsers get top accuracy on that task, too. It would be more fiddly, but not more than 1k lines to do a constituency version.
oh cool. got any links for incremental constituency parsing?
 @InProceedings{zhu-EtAl:2013:ACL20131, author = {Zhu, Muhua and Zhang, Yue and Chen, Wenliang and Zhang, Min and Zhu, Jingbo}, title = {Fast and Accurate Shift-Reduce Constituent Parsing}, booktitle = {Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)}, month = {August}, year = {2013}, address = {Sofia, Bulgaria}, publisher = {Association for Computational Linguistics}, pages = {434--443}, url = {http://www.aclweb.org/anthology/P13-1043} } That's the latest. Work backwards through the bibliography for the initial papers, which spell it out better. 
 try: return x - int(x) == 0 except ValueError: return False Just in case x is not a value that can be cast into integer ( ex. 'a' )
Can someone explain what I'm supposed to see?
It's just an unorthodox way of password cracking.
True, but you could write in a function to the posted code to perform a lookup here http://www.md5-hash.com/md5-text-encrypt. Not disagressing with you on KeePass (I use Lastpass), but there's way around it.
Freaky! Thanks, there's so much info there!
why didn't you use pyglet instead? (not pretending to troll, just curious)
Wow, I love how incredibly simple that is. This is the first time I’ve been able to audit the entire codebase of some 3rd party FOSS. edit: just submitted my first pull request.
import json with open(filename) as f: data = json.load(f) I need a clear explanation to this.
Websites with logins have to store your password in one way or the other to be able to check if the password you enter when logging in is correct. The easiest way to store passwords is to simply store them as plain text in a database, but this is horrible from a security point of view, because anyone who has or gains access to the database can take the login data and log in on the website. They will also be able to log into some percentage of accounts with the same name on other websites, because people like to reuse passwords. That's why it's common practice to store passwords in encoded form. The basic idea is to use some one-way function, called a *hashing algorithm*, that turns plain text passwords into a complex sequence of characters, called a *hash*, from which the original password (ideally) cannot be guessed. For example: password -&gt; 9e5ad04e2874776138bf8ff846eae6ad When you enter your password when trying to login, the website applies the same hashing algorithm to the password you entered, and if the result is the same as the hash, the website assumes that you entered the correct password and lets you log in. The important thing is that the hashing algorithm is one-way, so someone who gains access to the database of stored password hashes can't just recover the original passwords by reversing the algorithm. Now, if a malicious hacker obtains a hash and wants to get the original password, they have two basic options: 1. Try to *brute force* the password by enumerating all possible character sequences and applying the hashing algorithm to each sequence until they find a sequence that results in an identical hash. Because there are a lot of possible character sequences, brute forcing can take a very long time. The longer the password is, the longer it takes. 2. Use a *dictionary*, which is a list of password - hash pairs for common passwords such as English words, names of persons, easily typed sequences such as "asdfasdf" etc. If the original password is one of these common passwords, the malicious hacker can find it by simply looking up the hash in the dictionary. BozoCrack uses a variant of the dictionary attack, followed by a small brute force attack. Instead of looking up the hash in a dictionary, it does a Google search for it (so in a sense, it uses all websites indexed by Google as a dictionary). A small problem that arises now is that the search results don't have a common structure: websites may list the password - hash pairs in different formats. To solve this, BozoCrack doesn't even attempt to try to parse the search result. Instead it just says fuck it, computes the hashes of all words appearing in the search results, and checks if any of them match the hash you're trying to crack. The whole thing is funny because it is stupidly simple but manages to circumvent the expensive parts of both approaches: BozoCrack doesn't have to have a large dictionary for the dictionary attack because it outsources that part to Google, and it doesn't have to compute a lot of hashes for the brute force attack, because there are only a few words on the search result page.
[Learning Python with Raspberry Pi](http://www.amazon.co.uk/Learning-Python-Raspberry-Alex-Bradbury/dp/1118717058/) by myself and Ben Everard came about about a month and a half ago.
You need to provide more information on what you really want to do. This code simply opens a file named "filename" and converts its content (which must be valid JSON) to a python object which is accessible by "data".
It's a very valid question! And to answer it, I've used it in the past on a game, but I had someone doing 90% of the OpenGL. OpenGL and I have had a sordid past and for some reason I spend more time fighting with it than I'd care to admit to. I could probably use sprites/textures for a lot of what I'm doing but dealing with pygame I can dive right in do janky looking draw's and use textures where I need to. I could probably work it in OpenGL but thats another barrier of entry... At least with this way I can do it in pygame/pyglame, then maybe port it to pyglet later? Another issue is that pyglet has a really small/dead community, pygame is huge and it is a fairly positive community from what I've seen... plus it was pretty fun one I got it all going its been pretty quick to get things working.
&gt; It doesn't scale exactly 
"it's scarily good at what it does." It scares me that you are scared by that. That is not surprising at all. This is just a crowd-powered rainbow table attack. Every second hack0r &amp; crack0r tutorial recommends just g00gling for a hash before starting a local attack. **Of course** a search engine picks up (fragments of) rainbow tables. MD5 has been used for more than 20 years now. We can safely assume that over the time the MD5 sum of any common password (and a lot more things) has been seen by search engines. "We" are aware of this class of problems and **that is why we use salted hashes**.
Ok this is awesome. Can't wait for some people to wire it into an editor or three :)
What can I say I live on the edge
This is somewhat self fulfilling in that the first page of google results for the MD5 hash of "octopus" contain's this GitHub repo's readme.md.
Think Python by O'Reilly is good. Available as a free pdf.
Also, don't rely on enduser appliances. I encountered the possibility of using more than the system allowed just by quit/close the app prematurely. Apparently the app sends a "completed" as the last thing it does; I could circumvent the limit with a simple swipe...
It's not in stdlib, but for a few years I've been maintaining a side project [passlib](http://pythonhosted.org/passlib/), which tries to provide a password hashing api. 
If you were just doing repeated composition, e.g. `value = SHA(SHA(SHA(...SHA(pwd)))`, I think theoretically yes. However, SHA256/512Crypt reintroduces the password and salt within each round... it's closer to `SHA(pwd + SHA(pwd + SHA(... + SHA(pwd))))` (gross simplification of actual algorithm, which is rather convoluted). Thus the effective output space shouldn't be any more constrained than SHA(pwd). PBKDF2 is even better: it uses repeated composition of `HMAC(pwd, last_digest)`, so gets similar benefit ... but it then XORs all the iterations together in a running buffer, so even if you lose entropy on round N, all the entropy from round 0..N-1 is still mixed in, giving extra protection against entropy loss. (IIRC, the PBKDF2 spec makes the argument that these two features together should prevent entropy loss / preimage attacks unless the HMAC digest you use is *incredibly* vulnerable). Plus PBKDF2 is much cleaner in it's design. 
Just wanted to point out one common "fix" for bcrypt is to do `bcrypt(b64encode(sha256(pwd)).strip("="))`... the base64 encode step is required, because bcrypt can't handle NULL bytes :|
it has slowed down for a reason : there is a lot of good books available, free or not. Most updates yearly or so and that's it. You don't need more to be a good python coder. In fact, you do : you need to code. Reading about code and coding are like the alternate layers of a damascus blade. You need both in equal measure to get the best result. 
That looks really nice!
I am biased but I think you will enjoy this course https://www.sans.org/course/python-for-pen-testers. Full disclosure- I am the course author. SANS Python for Penetration Testers course, SEC573,is designed to teach you what you need to develop python based tools on your own. The course is self-paced with no prerequisites and will meet you where you are. Even if you don't have any programming background, the course will have you developing your own tools in no time. The first two days cover all of the essentials of the language. If you already know how to code, don't worry. You will NOT be bored. Since this course is self- paced, you will sharpen your existing skills as well as develop new ones, through a series of self-guided pyWars challenges. Then you will write four new penetration testing tools ready for use in your next engagement. As you develop those four tools you will learn: Network Sockets, Exception Handling, Process Execution, Metasploit Integration, Antivirus and IDS Evasion Introduction to SQL, Blind SQL Injection Techniques, Developing Web Clients, Multi-Threaded Applications, Mutexes and Semaphores, Message Queues and Thread Communications HTTP Form Password Guessing, Advanced Web Client Techniques, HTTP Proxies/HTTP Cookies, Session Hijacking TCP Packet Reassembly, Scapy, Extracting Images from TCP Streams, Analyzing Image Metadata Finally, you will put your new tools and skills to the test in a team based capture the flag event. 
So the Anaconda python distribution solves this by providing binary packages of pandas and other libraries. I know that doesn't help you with the initial Windows install, but once you have it installed you can build your binary packages on a different machine and install them using the conda package manager. (you could also compile on another windows machine and copy pandas across as well, but it's not as easy)
Beautifully stupid and inefficient.
Holy shit. This is genius.
Python 3.3 support was added last night. :-)
Except passwords that can't be remembered lead to bad security practices (because for most people eventually convenience wins) as is evident in the billions of sticky notes taped to computer screens or "hidden" underneath keyboards across the globe. Sure, ideally you'd generate a new keyboardcat for every single account you have to sign up for and then use KeePass to copy them whenever you need them (and use multi-factor authorization for KeePass and keep different kinds of credentials in different files and ideally store them on a OTP-protected read-only USB dongle or something) and then make sure your clipboard is wiped before you switch to any other window or tab -- but nobody does that. For most intents and purposes, just grab a bunch of D6 and use [diceware](http://world.std.com/~reinhold/diceware.html).
If history has thought me anything is that it is never enough.
Indeed it is. Especially once the wrappers are finished.
But "every domain except web" is still saying that Ruby is winning in one of the very most important domains by a huge margin. And going along with that: I don't know this directly but I've heard there are far more jobs for Ruby/Rails than Python nowadays, because of web dev. So, to answer OP's question, maybe on balance Ruby is still ahead?
Not sure why you're being downvoted, you're right. This should be obvious to anyone who knows anything about security, but for the uninitiated this serves as a good eye opener and proof of concept for how embarrassingly easy it is to find out a password if it's using a standard hash.
Yes of course
IMO, Ruby &amp; Python really just competed with each other in the web framework category. Now that nodejs is a thing, neither language is enough on it's own to create a frontend driven website. The differences between Sinatra and Flask or Django and Rails don't really matter as much anymore.
its already here... but go has replaced python as the preferred backend for the web for me... 
Yes, maybe not "serving up html" web development, but servers &amp; networking in general. Go is much more a replacement for Twisted, EventMachine &amp; Tornado and to be fair, it's extremely good at that niche.
yeah selection bias
My roommate tried to tell me that most disk golf courses do not have holes that have standard multiples of 9, and I knew that he was dead wrong. So I posted this on his FB wall.
Perl sure, but where did you get the idea that python replaced FORTRAN? Im genuinely curious about this if you have link to something i could read that would be awesome.
However [see also](http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html). 
No. For scientific and numerical computing/scripting Python wins in a landslide. For web stuff, Ruby has a slight edge. For other kinds of scripting, Python is more popular overall but Ruby is still quite heavily used.
This sort of thing is encouraged to go into /r/learnpython for future submissions.
This post is a downvote generator. 
FORTRAN is maybe missing a step. Matlab/Octave/R took a chunk out of non-legacy FORTRAN use, and SciPy/NumPy are encroaching on those.
The coolness factor of scala is off the charts. I see it rammed sideways into almost everything. Someone said it was hard, and now every programmer tries to upstage his seniors by flowing terse scala and pretending he didnt stay up all night golfing it. What a time to be alive!
I am a scientific programmer and have used Matlab since starting grad school 15 years ago, but in the scientific community the old guys still use FORTRAN and the young guys never used it in the first place. I had to learn FORTRAN to maintain this legacy code.
I see more Python showing up in bioinformatics, astronomy and astrophysics, and other scientific domains in place of raw FORTRAN. FORTRAN may still be under the covers (i.e. numpy, etc.) but Python is often "glue enough" such that scientists and engineers often don't have to touch FORTRAN (or C) directly.
It should not work, but does. That is what "the wrong way" refers to. Everything about it is wrong, it should not work. 
FWIW KeePass clears the clipboard after 10 seconds. 
Hopefully, it'll displace IDL, may-it-die-in-fire. After encountering that in grad school, I really appreciated how nice python/swig/c++ was.
I wouldn't say Ruby/Rails is so far ahead that Ruby wins on balance. Lots of Python-based web dev being done.
&gt; The de facto scripting language is now Python. Seriously? On the DevOps side I had thought Chef &amp; Puppet where still king, although I know Anisible and Salt have their followings. I work with both Ruby and Python though - Python tends to be my goto tool when I have to work with a GUI; Ruby + Rails/Sinatra for anything webby though.
Chef/Puppet aren't "scripting" languages, so much as a deployment platform. For example if some hacker was DOS'ing a bunch of Apache servers, I wouldn't try to Puppet out a solution. I'd use Perl to write a script that scanned the logs and inserted entries into iptables. Python has sort of taken over Perl in that sort of use. Now I'd use Puppet to push that script out to all my Apache servers, but I wouldn't write the script in Puppet.
Perhaps you're not installing them to the correct site-packages? If you type ``python setup.py install``, that will install them to the path associated with the python executable. If you're installing using ``pip``, please be aware that the pip executable is linked to a specific python version: probably the default python 2.7. If you install using ``apt`` or ``yum`` or the like, I believe it will also install for the system Python version only. To use packages with Python 3.4, try running ``python3.4 setup.py install`` in the source tree, or better yet, install [anaconda](https://store.continuum.io/cshop/anaconda/), learn to use [conda envs](http://www.continuum.io/blog/conda) and switch between all Python versions with ease!
That would be good. It should be easy to do for editors written in Python (Spyder, Ninja IDE), or editors that can run Python plugins (vim). For other editors, I'd be happy to discuss how they can communicate with it, e.g. an option for JSON output.
Ubuntu has separate packages for Python 3 modules. If you're using Ubuntu 14.04, you should be able to install them like this: sudo apt-get install python3-numpy python3-matplotlib ipython3-notebook The normal rule is `python3-` followed by the name you'd import. You should also have a `pip3` command which will install packages from PyPI for Python 3. If you don't, you can get it with: sudo apt-get install python3-pip
Note that many Python libraries are available for Ubuntu in two packages: one for Python 2, one for Python 3. Make you to install the correct one (or both).
I can't even keep track off all the teams I know that had to drop rails for performance reasons 
Cute =D http://nbviewer.ipython.org/ is also a good host for notebooks, and less crufty in my opinion.
this worked, thanks for the help!
thanks for the reply. for now i'm going to go with the easy fix because I don't know if I can learn all of that at once but eventually I will look into those resources.
Brilliant post! you should X-Thread this to r/ hacking or r/netsec bro 
/r/netsec ***** [^report ^a ^**problem**](http://reddit.com/r/LinkFixerBotSnr) ^| [^delete ^comment](http://www.reddit.com/message/compose?to=LinkFixerBotSnr&amp;subject=Comment%20Deletion%20%28Parent%20Commenter%20Only%29&amp;message=%2Bdelete+ch58t1h) ^| [^source ^code](http://github.com/WinneonSword/LFB) ^| [^contact ^developer](http://reddit.com/user/WinneonSword)
I feel C itself is something everyone should at least know the very basics of. My knowledge of C has helped me so much in learning python its ridiculous. Every language has some bit of C in it that you can reference and go 'oh, that's like x (only simpler).' 
&gt; Now that nodejs is a thing, neither language is enough on it's own to create a frontend driven website In so far as you had to use javascript, that was always the case. You don't need node to use any of the popular frontend libraries. 
Recently did a job search in the SF bay area and ruby is alive and well. In fact my new job is using ruby.
Let's not forget that Ruby has a hold in a lot of sysadmin shops because of chef.
Python is amazing for data analysis and things like that, but when you get to the really high performance stuff (i.e. quantum instead of empirical, for atomistic calculations) you are stuck with lower level code anyway. 
Good point! I didnt connect the file == module. If this is the case it certainly makes sense to have more related classes in the same file. 
i wonder why your roommate thought otherwise of the modulo 9. If he grew up one of the states with the lower majority percentage, such as Michigan, perhaps he was more likely to come across courses that didn't have rounds divisible by nine. Or maybe minigolf courses with all sorts of extra holes and other sorcery influenced his misaligned view. Either way, fun post. Maybe another sub, like /r/golf or /r/theydidthemath would like the cross post.
As a follow up, you can launch Python 3.4 by merely using "python3" (which is a sim link to "python3.4", or whatever the most recent version is).
On the iPad, you can't scroll this. It will merely scroll up the header and reveal something that looks like a Disqus comment box. The page itself is unscrollable. Please use nbviewer instead.
&gt;Reading about code and coding are like the alternate layers of a damascus blade Great analogy, or should that be great simile? Googled for Damascus steel, results are interesting. 
Did you monkey_patch_all ?
It's wrong because it shouldn't be possible. It's a testament to how horrible of an idea it is to store your passwords in MD5. If your password can be found via google, your encryption method is not good for encryption. Also, MD5 wasn't even made to store passwords. It was made to verify data, but people use it wrong.
Yeah, but these days I prefer [Ansible](http://www.ansibleworks.com/) over Chef.
Yep. It's also probably considered the favorite scripting language in the information security industry (where I work), with frameworks like Metasploit and libraries like Ronin and a million one-off scripts. Python is still used a lot (sqlmap, recon-ng), but Ruby is still considered quite "hip" here.
&gt; Puppet has it's own DSL so you never interact with Ruby there Puppet has had support for Ruby since 2.6 IIRC. There isn't a need to know a lot of Ruby with either Puppet or Chef but it certainly plugged holes with the puppet DSL.
&gt; I just interviewed for a PhD What does this mean? Do you mean this was for a phd studentship? &gt; The guy who started it says that Fortran is better for numerical computing than C/C++ Compared to C this is true, but compared to C++ it is not. Both C++ and FORTRAN have native support for one-lining matrix multiplication, beyond that it comes down to libraries and C++ wins that one.
&gt;Do you mean this was for a phd studentship? Yes. &gt;Both C++ and FORTRAN have native support for one-lining matrix multiplication, beyond that it comes down to libraries and C++ wins that one. Yeah, I actually have no idea. I've done all my linear algebra coding in Python/numpy so far, apart from a couple of CUDA bits. But I *was* under the impression that for parallelism (CUDA/MPI/whatever) C++ is really a lot more suitable. 
Python is winning in numerical analysis, machine learning, server scripting and college-first-programming-language. Base on Google trend, Python/Django is holding steady while there is large drop for Ruby/Rails: http://www.google.com/trends/explore#q=Python%20Django%2C%20Ruby%20Rails&amp;cmpt=q
bastibe mentioned that he/she could not scroll the notebook hosted on wakari on an ipad. Is it the same for you?
That is horrible. I am tweeting Wakari about this now. It is too cool of an app to not render well for ios.
Agreed. However C is very pointer heavy. I know pointers inside and out, including pointer arithmetic, but im not sure that translates to more modern languages.
Yes. Editing works fine (it basically copies the notebook to my wakari account), but the shared notebook viewer has that problem.
I actually rather much more enjoyed working in Fortran 95/03 over C++, especially with some good compilers (I really enjoyed Portland Group's stuff). Fortran exists as a series of compiler hints, for example defining functions as "pure" and forcefully limiting their ability to work with side-effects, or "pure elemental" which makes it really easy to map the given function over an array. Modern Fortran made it really easy for me to combine the two most important parts of scientific programming: high performance with readability.
Right, I've not used Fortran at all. Until yesterday, I hadn't even seen any modern Fortran code! My primary textbook has all the examples in Fortran 77, and the code I saw at the interview was definitely nicer to look at. I like purely functional languages, but have been turned off (some of) them because there isn't enough performance control, so this is *extremely nice* to hear.
&gt; But I was under the impression that for parallelism Yes, you are correct here. If you can learn the CUDA API and use it natively you are well ahead of the game. CUDA is accessible via fortran, but it has very low usage and will not likely see much support in future. Dont bother with FORTRAN, for compute C++ is where its at.
Rails has some significant performance issues that I haven't seen in django or any of its python based competitors. I don't know if ruby is really winning at the web either.
I'd really avoid anaconda it's an extremely opinionated package manager. Use python virtual envs
At present, the wildcard structure is very limited. You can search for a finally block that has just a return statement: try: ? finally: return ? But there's not as yet any way to specify "one of this list should be a return", nor variables matching a regex, at the command line. By using the Python API you can specify these patterns - see the [astcheck docs](http://astcheck.readthedocs.org/en/latest/). You may also want to look at [redhawk](https://pypi.python.org/pypi/redhawk), a much more complex project that allows querying ASTs in multiple languages using XPath syntax. I found it while I was seeing if anyone has already done this, but decided a simpler query system would be useful. I might spend more time looking at it myself.
I would say pointers are only a part of the equation. If you know how to implement proper linked lists, with stacks and queues in C, anything in Python is not that challenging. :)
http://en.wikipedia.org/wiki/Code_golf
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Code golf**](https://en.wikipedia.org/wiki/Code%20golf): [](#sfw) --- &gt; &gt;__Code golf__ is a type of recreational computer programming competition in which participants strive to achieve the shortest possible code that implements a certain [algorithm](https://en.wikipedia.org/wiki/Algorithm). Such tournaments may also be named with the programming language used (for example *[Perl](https://en.wikipedia.org/wiki/Perl) golf*). &gt;==== &gt;[**Image**](https://i.imgur.com/AMyisfb.png) [^(i)](https://commons.wikimedia.org/wiki/File:4clojure-codegolf.png) - *An example round of code golf running on 4clojure.com, showing the problem expressed as a series of unit tests, special requirements for the round's problem, and a results graph \(the "league"\) with a personal score.* --- ^Interesting: [^Perl ^Golf ^Apocalypse](https://en.wikipedia.org/wiki/Perl_Golf_Apocalypse) ^| [^Perl](https://en.wikipedia.org/wiki/Perl) ^| [^List ^of ^North ^American ^Volkswagen ^engines](https://en.wikipedia.org/wiki/List_of_North_American_Volkswagen_engines) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch5e0pq) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch5e0pq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
For high level tests (as close to user experience as possible) you would need a command line testing framework. There is not so much established code out there for this, but you might want to have a look at https://github.com/jgehrcke/timegaps/blob/master/test/clitest.py for inspiration. An alternative would be that you design your code in a way that stdin can be mocked, i.e. you replace sys.stdin with an object of your phantasy, provide it with data, and let your code "think" it really came from stdin. The downside of the latter approach would be that these tests would circumvent a whole lot of Python magic behind the scenes, i.e. the entire flow from "real" stdin through Python internals, possible data decoding, would be skipped. For reliable software you should not skip testing *directly* the command line interface from a real shell.
Fortran is faster than either C or C++ because the compiler can make more assumptions about the code than in either C or C++ and hence optimize it better. Fortran code is regularly faster than well tuned C by 30%. Also, number of numerical computation libraries available in Fortran dwarfs anything else. 
Yes later on i tried monkey patching but i could see only around 127 domains got processed. Note I'm outputting the domain that i query. I was surprised to see so many domains got skipped. Does this sound familiar? Or should i provide more details? 
It really depends what you're trying to do. If you're installing a bunch of pure Python packages, then you're absolutely right that virtual envs are sufficient. But if you're installing lots of packages with compiled libraries (such as numpy, scipy, and matplotlib), you'll quickly find corner cases where virtual envs don't work. I don't always recommend conda, but when someone specifically mentions the packages it was built to handle (matplotlib, numpy, ipython) then I'll recommend it every time.
Looks neat. Just remember that you should re-code them using whatever type of structures/modules/libraries will be storing that information. I haven't used them much...but, like, numpy + scipy support from the start; then maybe work on a no-dependency port later.
I'll host your btsync folder for awhile.
To be honest, I am not that fussed. As long as I don't have to learn php or something and get to work on interesting concepts/maths/algorithms Fortran is not gonna deter me. If I don't get a PhD this year I might take up a fellowship in China I've been offered that requires coding in some... old version of Fortran. It's interesting research, whatever. (I'll still write my wee private parsers in Python because it's just so convenient.)
Is there any way I could help you with this? I don't have any experience with NLP. I'm familiar with linguistic concepts, because I studied languages at uni and I have plenty of Python experience.
I'm a pentester. Although I use python quite a bit, metasploit. That's the big argument from my field. 
I had struggled with that as well. All the cool project to in Ruby have been slowly accreting dust, while tumbleweeds go through what once was a fertile community. I had made a personal investment of time and resources, got to interact with expert rubyists, and slowly incorporated their work into mine... Until I need to start working in data mining. Python and R were far more useful, current and documented. There were resources, books and blogs. Scrapping with Ruby was a nightmare, using old things long ago discarded and abandoned, whereas all my colleagues were brandishing shiny python, scipy and similar. So, I left the Ruby camp. Obviously I was not the only one. 
_performance issues_? Try security issues. Every week there was a new Rails vuln coming out.
If you are on a UNIX-type system (Linux or Mac OSX), read up on input/output redirection and pipes. Essentially, you can give the program its standard input from a file python script.py &lt; file.txt Or from the standard output of another program. otherprogram | python script.py
Try [pyenv](https://github.com/yyuu/pyenv). Here's a good [Linux tutorial](http://davebehnke.com/python-pyenv-ubuntu.html).
Not even close. Chef and Puppet are large and extremely active projects with tone of not-open-source software written for them.
Well... I for one will sleep soundly tonight.
The deadsnakes [ppa](https://launchpad.net/~fkrull/+archive/deadsnakes) has almost everything you want (there's no jython or pypy).
You can change sys.stdin with any other file like object: import StringIO import sys sys.stdin = StringIO.StringIO("line 1\nline 2\nline 3") for line in sys.stdin: print(line) 
&gt; All but two states in the US (Hawaii and Connecticut) have less than 80% of their courses with a standard 9 hole multiple format. Brain fart, I assume.
Wow, already has builds for Trusty. Just bookmarked this guy. Also, I'm less worried about tarball builds of python forks since pypy and jython are already careful about not removing the default interpreter.
In the standard library, collections is pretty cool, I use defaultdict almost daily 
Python compiles very easily from source. It's one of the really good things about CPython. ./configure --prefix=~/shared/python-3.4; make; make install In development, I put a suite of Pythons in my home directory. In production, I do the same thing only built into a /shared path. Then I will add Setuptools/VirtualEnv/Buildout as desired. I ignore the system Python. That python is only there for supporting the needs of the operating system. I do not touch the OS stuff and the OS stuff doesn't touch my stuff :P 
true, but you forgot to mention all the dependencies and headers you have to install. 
If I remember correctly, parts of NumPy are written in FORTRAN for exactly those reasons – it's exceptionally fast. 
I was asking myself the same question, but then it hit me - omg, namespaces are great idea, let's do more of that! :) No need for you to split classes in files when you can import a _single_ class from a file with multple classes.
I think understanding pointers is pretty important even if you're using a language that hides the details like Python.
The big one is FORTRAN assumes no pointer aliasing, whereas that locks down a huge number of C/C++ optimizations.
Hmm, I just thought about it: isn't the best kind of code that one which takes a long time to write, but is then both expressive and easy to understand? If you manage to write 50 lines of Scala in the time it would take you to write 150 lines of Java doing the same thing, and people actually need less time to understand the 50 lines version, isn't that good?
I don't know if you meant standard lib or third party, but [TextBlob](http://textblob.readthedocs.org/en/dev/) is pretty cool.
[calldules](https://pypi.python.org/pypi/calldules/1.0.1): Never use it, but it has some quite interesting black magic going on. (I thought I'd mention it because it's unique for a completely different reason than the other mentions)
And Julia, specially for the scipy community.
That is not golfing. Golfing means literally minimizing the characters of source code. There is no readability requirement in force. No one would seriously consider doing that to real code.
i like ruby where i used to use bash or perl (small web apis, control-flow types of scripts, etc). i like python for math/ML type stuff. i like java when i need particular performance and scalability characteristics (web services handling hundreds-thousands of requests a minute). honestly at this point (though i learned both at around the same time, and have flip-flopped depending on jobs) i prefer writing ruby, but prefer reading python. 
https://stackoverflow.com/questions/16115713/how-pony-orm-does-its-tricks voodoo http://hg.python.org/cpython/file/3.4/Lib/enum.py more voodoo
Here are a few interesting modules that make my life easier: [q](https://pypi.python.org/pypi/q) for quick and dirty logging, debugging, and tracing. [sh](https://pypi.python.org/pypi/sh) for very convenient subprocess handling. [black-magic](https://pypi.python.org/pypi/black-magic) for decorator utilities. Alright, I haven't actually used it, but it is pretty cool and unique. [toolz](https://pypi.python.org/pypi/toolz/) for functional programming utilities. I've gotten a lot of mileage out of this package, and it is a great package to learn from, play with, and even contribute to.
Having used flask last month, the Ruby web advantage is shrinking. Ruby has a gee tally n nice features that Python lacks, like blocks, but Python is faster at the stuff I need. I work with a lot of statistical data and Python withr IPython notebooks and, pandas. There are no Ruby equivalents there. I miss rspec when I am using Python. And blocks. But python's number crunching is just too good to ignore.
Pray that you never need to change it.
In my humble opinion, Rails is the best "ultra-full-stack" web framework out there. Django is pretty good but it's just not quite the same. I too stick to microframeworks though, and Flask/Bottle and Sinatra are extremely similar. Ruby definitely doesn't have any particular edge when it comes to that department.
Python has replaced R and SAS here. There is nothing as good as ipython and pandas for data crunching. 
I more so meant condensing code sometimes leads to a loss of comprehension not gain. 
Perception. The general perception among my peers is that Ruby was for nubes and posers whereas Python was for scientists and computer scientists. I am not saying this is a critical analysis of the languages but our perception of the people who use them. For instance when someone tells me that they are using powerbuilder I don't even need to check for pleated pants. 
Pffft who even uses the web anymore.
Rails is pretty great for what it does but I really need micro frameworks more. We use quick and dirty apps to support our QA and UAT efforts all the time. Standing up a page with a few lookups in a week is more important that a ultra full stack. 
Then we agree!
Super cool. Is this being used in production anywhere yet?
Python has always been the dominant language, in terms of the number of users. Ruby had a popularity spike when Ruby on Rails was blowing up but never actually overtook Python. Now that RoR is no long the new, hip, cool thing that everyone wants to use, Ruby's popularity has fallen off a bit. That's not to say that Ruby or RoR are dead/dying, they've just comfortably taken a back seat to Python. Ruby on Rails is still amazingly popular with the web startup crowd.
The easiest way to get a bunch of different Pythons installed is probably collective.buildout.python: https://github.com/collective/buildout.python It will install Python 2.4, 2.5, 2.6, 2.7, 3.2, 3.3, and 3.4 with more or less a single command.
Check out tox it can automatically build out the required virtualenv with the various python versions and then run the unit tests in all.
Yep, I agree. I've never actually found a case where a full-stack framework is better than a microframework in my professional career so far.
&gt;In my humble opinion, Rails is the best "ultra-full-stack" web framework out there. Django is pretty good but it's just not quite the same. IMO, it's better - and that's mainly why I chose python over ruby in the first place. Less magic than rails. Easier to decompose. Easier to swap out parts that you don't want to use. As far as an ecosystem of modules that do commonly needed stuff, goes, they seem somewhat equivalent. It seems that whatever kind of functionality you can get for rails, you can find something equivalent for django.
Not yet, I'm trying to get some feedback first, but I'm planning on deploying it soon. If you like this sort of thing check out https://www.mightyspring.com/getstarted/pymonster
If that's a reason I'd start dumping ruby now. Ansible and salt are both a lot better than ruby and chef.
After installing all the Python interpreters you need (from source), the best way to cross test a project is using tox (http://tox.readthedocs.org/en/latest/). It automatically creates virtualenvs as many Python versions you need to test in, install your package in them and run the test command you define. 
Itertools and collections are both mandatory. Super useful stuff in both. Defaultdict, chain, namedtuple, counter, etc.
There's good stuff in both. I love RSpec. I really wish python had something as good. I tried nose but I just wasn't happy with it. On the other hand, there is nothing on the Ruby side as good as pandas. There are a few other examples but those really stand out. 
[SQLAlchemy][] is one of biggest reasons why I cannot try other than Python in production. [SQLAlchemy]: http://www.sqlalchemy.org/
&gt;Yes, a file is a module, but so is a directory with an `__init__.py`. No, that's a package. &gt;I still wouldn't say that one class per file is particularly desirable, but it wouldn't (necessarily) cause the import nightmare you mention. Sorry if I didn't use enough qualifying words for you.
 1. Attach to and inject code directly into running processes: (i.e. black magic coolness) https://github.com/google/pyringe 2. Very minimalistic web framework -- http://webpy.org/ built a restful interface that looks like: class resource: def GET(self): ... return &lt;get_response&gt; def POST(self): ... return &lt;post_response&gt; ... Hidden strange/cool modules in standard library: 1. Audio processing: https://docs.python.org/2/library/audioop.html -- yes build your own echo canceler with Python's standard library. Insanity I tell you! 2. All time favorite: serve files in any folder up to the web with one Python module launched from command line. $ python -m SimpleHTTPServer 8000 
Try building a basic clone of some web site you think is cool. Make a clone of Disqus, for example; it would be a pretty good project for getting started with this sort of thing. Once you've got your hands dirty, and you're *making things,* then it's easier to understand how everything fits together, how to make it scale, how to keep latency low, etc.
I had considered redirection it in a shell but for unit testing and changing input based on the output of the code being tested, doing it within python would be ideal.
Powered by PHP!
[Saltstack](http://salt.readthedocs.org) is growing rapidly.
Disappointed? No. Terrified? Most certainly.
Definitely less magic than Rails, but I'm of the mindset "in for a penny, in for a pound." If you want a massive monolithic web framework that tries to do as much as it can for you, you might as well get some magic thrown in. The end result of this is that if your prospective app happens to be satisfied by Rails' "convention-over-configuration" defaults, then your Rails app will likely have fewer lines of code than your Django app. That being said, I prefer Python in general, including the tendency for Python libraries to have very little magic.
 ln -s /usr/bin/python ~/bin/pythong
Well the obvious fact is that ruby would not be what it is today without rails, and like any framework its popularity will drop intime. Because ruby is so much just rails, i chose Python, mainly because even though i do alot of web dev, i also want to build gui apps (eg. with kivy, or qt) and other non-web related stuff. Heres the true power of python, anything goes. I really hope the 2/3 thing is going to work itself out.
Digital is a fad.
`alias pythong='python'`
I think a good point about learning c is that if you understand pointers, then you can start to understand how functions are called and objects are passed around inside languages like Python. It is useful to know that sometimes you're passing object copies and sometimes just pointers to objects. 
A subset has made it into stdlib with pathlib in 3.4, but I still really like [path.py](https://pypi.python.org/pypi/path.py).
Yeah, but for mine you won't have to put it in your `~/.bashrc`! :P **EDIT**: Type `alias python='pythong'` and watch everything not work :D
`requests`' public API is very, very good but its internals definitely aren't the most beautiful. Not even close.
This thread has been linked to from elsewhere on reddit. - [/r/ProgrammerHumor] [Accidentally added a &amp;#x27;g&amp;#x27; to the Python.org... Was not disappointed : /r/Python](http://np.reddit.com/r/ProgrammerHumor/comments/24cg07/accidentally_added_a_g_to_the_pythonorg_was_not/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag) ^I ^don't ^read ^PMs!* 
add total = meal + meal * tip on line 8 
Can you give more details on what you are confused about? It wants you to make a new variable named "total" on line 8 that is equal to meal+meal*tip. One way Python will "assign" a new variable is if it is used on the left side of an equals sign. For instance the line below would assign a new variable named area to height * width: area = height * width
I would just NSFW the post, David Hasselhoff is probably pretty SFW by now
"the loop control variables are no longer leaked into the surrounding scope." That's not a for-loop pitfall for Python 3, that's just good sense. 
&gt; black-magic People, please name your package on PyPI the same name it imports with! Mmmrnrnrrhgh
At least it wasn't as bad as when I accidentally typed ".com" instead of ".org" at work.
Expressiveness in code doesn't always mean it's easy to read/grok. Scala and Perl being good examples. I've written what I thought was awesome code in Scala, unhindered by the language, only to come back one month later and have it take me forever to unpack, understand. Of course you could argue that just because the language gives you this power, it's still up to the developer to write readable code. A fair point, but code golf still seems to be a popular hobby for most new Scala adoptees (myself included). Java is supposed to be the opposite, an easy to read language but tedious to write. ymmv
What's religious about this: https://pay.reddit.com/r/Python/comments/24a4r0/it_could_be_personal_selection_bias_but_i_dont/ch5nnck ?
Something I like is to install packages for things I use from the command-line/interpreter, but across virtualenvs, with --user. virtualenv or things like flake8 could be examples. To keep things clean (and let me use any version of things like pip/virtualenv for testing or to solve some problem)I even install pip with --user. e.g. python3.4 -m ensurepip --user Unfortunately, Ubuntu 14.04 broke ensurepip. So (and for previous python versions) there's also: python3.4 get-pip.py --user Then e.g. which pip # verify I'm not calling some system pip, if I don't control the system pip install --user virtualenv pip install --user flake8 It works out for me because pip isn't really for system-level dependencies. I don't even like to have a system-level pip, system-level Python packages (which are ONLY dependencies of things Ubuntu installs) are handled with apt/yum. Actually I do not prefer ever to manually install python packages at the system level. So needless to say, I do not need to use the system pip let alone 'sudo pip'. And so it is not an issue for me that I have a pip installed in ~/.local/bin, or that this playing with 3.4 is going to mess up the system somehow. I don't end up with mess in system directories and if I make a different account e.g. to serve WSGI apps then it does not get influenced by my user-installed stuff. If something were wrong I can blow away stuff installed to ~/.local. (But I do keep backups of anything important) I don't recommend this for everything - needless to say, anything which is an actual project dependency or even a test dependency of a project is likely best installed in a virtualenv for that project so that you can benefit from the isolation of installed packages between projects. I just don't see any reason to install pure-python development tools at the system level. The exception is that some tools or packages are just too huge a pain to install without assistance from the system package manager.
# Assign the variable total on line 8! meal = 44.50 tax = 0.0675 tip = 0.15 meal = meal + meal * tax total = meal + meal * tip print("%.2f" % total)
Can you explain why you put "add" in there, please? I get it mathematically, I guess I just missed the part where they explain to use the word "add". I don't recall them saying it at all, but I might be wrong. 
Raspberry pi Raspberrian uses python so that is why I love it 
But at one point you would have had to or would need to add ~/bin to $PATH in .bashrc . 
Try the [c-ares resolver](http://www.gevent.org/whatsnew_1_0.html#new-dns-resolver)
Right. &gt;_&gt; I have that in mine. self.comments['ch5q69w'].replace("~", "/usr/local")
Add "total = meal + meal * tip" on line 8. 
More like "pull" that script .. just sayin since we're talking puppet here hehe.
Python 2 is not EOL until 2020 so whoever wants to use it, will use it as long as they want to, and there is really no way to force people off of it without making drama. Python 3 is not going to be abandoned either. A ton of libraries already ported over the last few years, leaving thousands of unmaintained packages that will never be updated for any reason again, and a handful of popular packages with C dependencies that don't want to port just yet (but either will do so soon or get their lunches eaten by someone more active anyway). So I really don't know what you have in mind for "work itself out". And in fact I don't really know how this affects your ability to use Python productively for whatever.
I believe that if you put the actual letters "NSFW" in the submission title, it gets auto-tagged.
Try Docker, its awesome to solve the type of problem you have.
Yeah, I often do that as well when I've been typing 'thong' a lot.
This bot is useless. There's already the "Other discussions" tab at the top of the page. Please stop wasting bandwidth with this drivel.
Modules are a great idea but the counterpoint is that with multiple classes in a file, tracking changes to an individual class can become onerous.
Out of interest, why are you using `sys.stdin.readline` instead of `input` or `raw_input`? I'd recommend you do the following def bit_using_readline(source=sys.stdin.readline): #Or input, or whatever data = source("Send me ur info") do_something_with_data(data) Then for the "main" usage, you can just call `bit_using_readline()`, and for testing you could do: def custom_prompt(prompt): return "Predefined" bit_using_readline(custom_prompt)
DefaultDict, and OrderedDict were particularly useful.
The idea behind the bot is to let you know if one of the meta subs has linked to your thread. So, for example, if SRS and subredditdrama are both linking your thread and thus are likely to come in and piss all over each other, it'll let you know why you got that sudden influx of angry people. The "other discussions" tab doesn't and can't do that.
I wonder if you could get around this Bot by adding a trivial GET parameter to the URL?
I agree! With "pitfall" I meant that one has to be careful since in most other languages...and for Python 2 when it comes to list comprehesions
...The "Other Discussions" tab doesn't include the link that the bot found. So clearly, they're doing other things and thus the bot is not useless. (Whether what it is doing is useful, I'm not really sure.)
I find [`pickle`](https://docs.python.org/3.4/library/pickle.html) pretty cool (a module to convert Python objects to bytestreams). Here is one short [script example](https://github.com/rasbt/python_reference/blob/master/howtos_as_py_files/pickle_module.py) 
python2 for science and numerical computing
I use [tornado](http://www.tornadoweb.org/en/stable/) even for non-web apps just to get the default rolling logs and CLI parsing.
And exactly who is disenfranchised? How is the "playing field" not level? http://www.un.org/en/documents/udhr/ Discrimination in education and employment on the basis of gender is unlawful in most countries. If you mean there's not exactly 50:50 representation of males and females in engineering, then consider there's not exactly a 50:50 ratio of males and females on the planet, so this number isn't even naturally achievable even (especially) if everyone on the planet was an engineer. Having been the sole male in a team full of engineers (including the manager) I'm inclined to call inherent, institutionalised gender bias a truckload of horse shit. Especially in affluent western societies. There's just people trying to make a living and some playing whatever card will give them a leg up over others.
[**@Packt_Paush**](https://twitter.com/Packt_Paush): &gt;[2014-04-30 11:35:48 UTC](https://twitter.com/Packt_Paush/status/461468960907476993) &gt;New book on using Python ([@ThePSF](https://twitter.com/ThePSF)) in Finance now available! Check it out here: [*packtpub.com*](http://www.packtpub.com/python-for-finance/book) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/24d6c0%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Django_php is very unique. http://animuchan.net/django_php/ 
That actually explains a lot.
Oh, huh, I guess it's just a placeholder now. Was a porn site a few years ago.
I think people can answer the question in their own way, but there's already a FAQ on this: [[python.org]](https://wiki.python.org/moin/Python2orPython3) so it would kind of be a waste of time. tl;dr: *Short version: Python 2.x is legacy, Python 3.x is the present and future of the language* Read the wiki. 
Check out some of these IPython [notebooks](http://nbviewer.ipython.org/) since they may be using some interesting modules or packages. Some more [examples](https://github.com/ipython/ipython/wiki/A-gallery-of-interesting-IPython-Notebooks). A couple I think are interesting or useful: [progress meter](https://github.com/noamraph/tqdm) OS system [utilities](https://code.google.com/p/psutil/)
Missed the nsfw tag... in class D:
Dear Massimo, How about adding DAL shortcuts? Thanks for the GREAT framework &amp; community. Love and peace, Joe
why or why did I not mind the NSFW warning!!!! 
Do it in 3.4 if possible. Here is the difference: Python 2.x won't ever get any better; only the 3rd party libraries surrounding it can. Python 3.x just got better (3.4) and will continue to do so into the future.
[`setopt correct`]( http://www.refining-linux.org/archives/39/ZSH-Gem-4-Spell-checking-and-auto-correction/ )
Here's the full grammar: https://docs.python.org/2/reference/grammar.html Surely you know that in Python code blocks are delimited by indent/dedent.
I'm well aware of that yes. I have a text file that I am parsing in a similar way. I figured the way that python does it would give me some good insight. thanks a lot!
If your text file has the same grammar as python, try using the `ast` module for whatever you're doing.
ah, this is an interesting tool I've never used before. I'll take a look over and see what's going on here.
REALLY LATE RESPONSE! http://docs.python.org/2/library/urllib.html#urllib.urlretrieve https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve
In principle yes, in practice no. Working on performance optimisation of scientific codes, i've found scientists can writing reasonably performant Fortran. but not C++. Good C++ programmers write efficient C++ code, but its all too easy to inherit C++ code from someone else, make changes, see performance disappear and not understand why (you've made changes that mean the compiler can't optimise properly anymore). So Fortran works better for performance. The problem appears to be that compiler writers aren't targetting Fortran anymore - given limited resources, they optimise the C++ compilers leaving Fortran support behind. So there is a move to C++. Scientific programmers in the climate field at least are nervous about this.
IMHO, Python is superior in many ways (clarity, performance, community) and for many tasks (scientific, scripting, machine learning, data). However, Rails is still the sexiest full stack web framework, which is still a big draw. I love Flask, but lets face it, Rails is slick. Django is cumbersome and not very fun to work with in my experience. I think a Rails front-end with Python number crunching in the background is a fairly common approach.
As others have said, there is no clear winner. Not by a long shot. Python definitely holds sway in the scientific community, and is used as an embedded scripting language in lots of things, and probably is somewhat more prevalent for general 'glue' scripting, but Rails probably gives Ruby the edge for web stuff, and Chef is the industry leader for infrastructure as code (With two Python competitors - Ansible and Saltstack gaining market share but still a ways off).
Tools like [2to3](https://docs.python.org/2/library/2to3.html) are certainly helpful if you want to switch, but I also would watch out for some most commonly encountered things: - syntax changes: exception handling, raising, print function, next() function, - strings are now unicode (utf-8) - range() is implemented like xrange() I listed some of the key things in a [recent article with code examples](http://sebastianraschka.com/Articles/2014_deep_python.html#python_differences) if you are interested. Also, check out: - [Should I use Python 2 or Python 3 for my development activity?] (https://wiki.python.org/moin/Python2orPython3) - [What’s New In Python 3.0](https://docs.python.org/3.0/whatsnew/3.0.html) - [Porting to Python 3 - The Book Site](http://python3porting.com/differences.html) - maybe one more thing: for-loop variables in list comprehensions do not leak into the global namespace anymore in Python 3 Both Python 2 (libraries, speed) and Python 3 (growing, in my opinion good improvements), but at this point it is really up to you and your judgement (also depending on which libraries you are using)
The "Click the image to go to python.org" wouldn't be a bad way to redirect on a PC.. but on a mobile device, as I was, it makes the whole experience so much more... personal.
Yesterday, I went looking for a simple issue tracker for use at work. I decided I wanted something that was Open Source, easy to set up, easy to use and not too bloated. I wanted something which would be possible to use for tracking issues both in software projects and in our data model as well as issues with usage of third-party applications. Among the alternatives I found and considered, Apache Bloodhound appeared to be the best fit. It's not perfect, but it's good enough. The fact that it's written in Python and supports multiple internal storage backends are both two great aspects. I chose Sqlite3 since our installation is for just 3-10 people. I have started adding information to the wiki of our installation and have opened a few tickets and added comments about current state of the issues. I use the "default" product for issues related to how we are going to use Bloodhound and for holding the Bloodhound documentation. I deleted the duplicate Bloodhound documentation from the main wiki to keep it out of the way. I created a separate product to hold issues and wiki pages about one of the things we'll be using Bloodhound for. Liking it so far.
No. It's what allows you to do `'"'` or `"'"`.
Thanks for this. Just picked up a copy.
I will reach out to you via PM. I used your post and wrote my own follow up: http://www.brettdangerfield.com/post/realtime_data_tag_cloud/ Thanks for the inspiration and examples!
Would you happen to have any experience with NLTK for text classification? Is there something else I should be using instead that would be better?
[Here](https://web.archive.org/web/20110307073939/http://python.com/) [***NSFW***] is an archive.org link. It seems to be a dead site now (/u/dominion_prime)
Trust me, someone determined to defend their beloved language's conventions would respond that they "need to see what's going on" and that the 150 lines would show them what's really going on so it would be easier to read. On Stack Overflow last week when someone asked if you could do x=y=z=0 with Delphi (you can't) someone replied that they were glad you couldn't because it's less readable. When I asked how that was they replied that they weren't sure then said they'd be afraid they'd "miss what's in the middle". I was then told that a, b = b, a isn't preferable to using a temp variable, again because using a temp variable "shows you what's really going on". Then I was told the assembly is all the same anyway and if I really thought this would generate faster assembly (as if that's all that counts). Thus I assume one would have the Zen of Python turned on its head and thrown back at you by a Java fan and be told that Java is more explicit and explicit is better than implicit and all those reams of getter/setter lines in Java show you "what's really going on" and it's important to know what's going on under the hood and that means you're a better/smarter programmer - in short, the harder the language/OS/framework/whatever is to use, that just means you're more awesome and elite. The implicit message would be that lazy/uneducated/poor programmers would use Scala to compensate for their lack of awesomeness. I have seen the Language Wars, and they aren't pretty. :-(
I think collecting the data is fairly easy - just run a simple HTTP server somewhere, and have the application periodically make requests with the relevant info (e.g. software version, installation ID to track how many users there are). Most of the complexity in tools like Piwik is to filter and present the data, to show things like what countries visitors are from or which pages they visit. If you just want to know how many people are using your application and how often, you don't need that.
I'd think it would be less important. Languages like Python keep the good parts of pointers and throw the rest out. If you have to know the details to use the higher-level abstraction (and that's what programming languages are) there's something wrong with your abstraction. The term is actually "leaky abstraction". 
Doesn't PHP still own the web? Don't they have sandbags and landmines around the web because if they lose that they lose it all?
Thanks! Didn't know about StringIO. Perfect. For anyone using it, in Python 3.x, it's `io.StringIO`.
&gt; plus it was pretty fun one I got it all going its been pretty quick to get things working. I'm sure this is what kept you at it :)
Haha yeah. I have font support sort of working. But with the current API it's not possible to set the fonts color... I have some ideas on how to possibly get around this. It's actually awesome for quick prototyping... I was debugging an implementation I had written of QuadTree/box collision testing. In a few situations it was acting strange, using pyglame I had it working in 5-10 minutes. Didn't take long to debug and fix the error. 
I used to be a C guy so I still stick with "" for strings, '' for single characters.. absolutely no reason for it in python.
PyCharm
You could get around the other discussions part by doing this, not the bot, as the bot links this thread, not this link.
This is pretty awesome. I might have to try this out.
No, just because thay haven't made a new release in a few months doesn't mean it's dead. If you look at their own instance of the issue tracker, you can see that there is activity. Also, if you follow the links to the mailing lists, you see that they are discussing things and commiting code.
Ill try it.
If a package is written in 2.x can it be used with 3.x?
Thanks! How hard would it be to convert my few hundred lines of 2.7 code to 3.4?
Those are some good points! I don't have much code as of right now but I am using a few third party libraries like urllib2 and bitcoinrpc.
Its for my own company not one I work for for the record. And I think I have all the answers I need from all the helpful people above.
It depends on what's in those lines and what libraries are being used. 
Sublime with [Anaconda](https://sublime.wbond.net/packages/Anaconda) (for autocompletion and linting).
Eclipse + pydev, sublime text, vim, and ipython notebooks. For a beginner I suggest ipython notebooks.
I am not sure if urllib2 makes difference between Python 2 and 3, but the std urllib did, it moved stuff to submodules, [see the top of this code] (https://github.com/rasbt/smilite/blob/master/smilite/smilite.py) for how I handled it that it works for both. Btw it is considered a good habit to use 'from __future__ import ...' which brings Python 3 features to Python 2 so it would work on both... Arg I forgot an important thing that often goes unnoticed, in Python 3 the normal '/' is not integer division anymore but returns a float
[PyDev](http://pydev.org/) is really good. You can either download a plugin for Eclipse or download a standalone version.
Anyone who tells you PHP isn't relevant has no experience at older more established firms or is at the very least fooling themselves. PHP is still a big player and it has a huge code base. It's probably going to be something like FORTRAN though: irrelevant to new technology, but still hanging around in a lot of legacy code.
I use [Spyder](http://pythonhosted.org/spyder/index.html). I actually use the development version, because the released version doesn't run on Python 3 yet, but it works very nicely.
Sublime text, vim, Ipython Notebooks. For big projects, an IDE like PyCharm is helpful but not if you're just starting out. 
I subscribe to this subreddit to learn shit about Python, and this is what I get.
WingIDE. I like it better than PyCharm, Spyder, and Eclipse.
I use this os called emacs.
Costs a pretty penny too!
It does, but if you're at a company, you should have a good IDE. It's ~$100 for that and has a very liberal lisence and it's debugger is incredible. Like all of the Python IDEs out there, they have a decent free version.
Now you know how NOT to spell Python... Lol
It's very good.
Talk about over complicating an issue, just print to tab text and move off the VM.
PyCharm is great.
Fossil was among the alternatives I considered. I already use git for version control of source code, though. From the Fossil website, I also got the impression that it might be a bit too much oriented toward code and as mentioned, we'll also be using the issue tracker for things for which there isn't any code. Our data models are in a PostgreSQL database and various binary data files. Furthermore, we don't need decentralized features for the issue tracker and wiki. Still, fossil seems interesting and I might use it for other projects in the future.
I don't quite understand what you mean about having to create a new instance. It has a concept of products, which can be used to handle multiple projects and keeping them separate, all with only one main tracd process running.
For me, [docopt](https://github.com/docopt/docopt), [schema](https://pypi.python.org/pypi/schema/0.2.0) and [pip-tools](https://github.com/nvie/pip-tools) are invaluable modules.
For beginners I would suggest Linux + vim or windows + notepad++.
Yeah that's super funny, guy, thanks for this comment. Really contributing to things.
And that it uses a library called Linux to communicate with the hardware.
If you're at a company it's $245
Apparently, it's gone up.
oh man here we go again
what did he say ?
Try http://conda.pydata.org/miniconda.html It's like a more flexible version of virtualenvs combined w/ a package manager. very easy to get multiple python versions going 
It's definitely not a purely functional language- but (for example) anything defined as pure elemental will auto-vectorize and auto-parallelize right up. Fortran &gt;= F90 arrays are first-class citizens, so the compiler doesn't have to wonder about pointers or anything else that might block automatic optimizations. If you're not doing heavy math over large multi-dimensional arrays, Fortran's probably not what you're looking for. For that purpose however? I retain a soft spot for it in my deepest of hearts.
Neat! If you wanted to stay in flask land, you might try flask-socketio for the websocket version. If you do, post another blog post! I'd love to see it in action. 
+1 for docopt. so simple, yet so powerful.
Emacs
I'll always want to write that myself really, since it's just calling a classifier with a bag of words. Have you thought about doing that? If that's unappealing, then yeah I can see nltk being an appealing choice. Especially since you get stemming etc handled pretty well.
Seconded. Pycharm is the best IDE I've found for Python.
Yeah, that's pretty much exactly my purpose. :D
Another option for websockets is just using rabbitmq http://www.rabbitmq.com/web-stomp.html
Try using the tool 2to3. It comes standard with Python 3 and should help you convert your code easily(ier?)
Blasphemy. You should come join us over to using vim. 1000 cool features from vi, 1000 more cool features new to vim, and your most commonly used features will be: 1. delete all your data 2. beep
Lightweight : Geany. Heavier : PyCharm. Cross-platform too.
+1 for spyder 2.3 
They have a feature comparison with other projects (including Apache Bloodhound) on their own wiki: https://forge-allura.apache.org/p/allura/wiki/Feature%20Comparison/ I think it's strange, though, that they are using SourceForge for the tickets, but there's probably some at least semi-good reason for it (I hope).
What I do is test locally with the python versions that are in my package repository (Fedora). This is mainly py2.7, py3.3 and pypy. To ensure that stuff works on the rest of the python versions, I have [Travis-CI](https://travis-ci.com/) hook into my GitHub repository and run unit tests (you have those don't you?) on commits. I use tox for testing on multiple python versions locally. You might want to check out how [cryptography.io](https://github.com/pyca/cryptography) test for multiple Python versions, we have quite the test infrastructure.
You might want to checkout /r/learnpython
This is horrific: count = 0 for method_frame, properties, body in channel.consume('twitter_topic_feed'): tweets.append(json.loads(body)) count += 1 # Acknowledge the message channel.basic_ack(method_frame.delivery_tag) # Escape out of the loop after 10 messages if count == size: break Use this instead: for _ in range(size): method_frame, _, body = channel.consume('twitter_topic_feed') tweets.append(json.loads(body)) channel.basic_ack(method_frame.delivery_tag)
&gt; No DSL, no need to know use python or ruby - everything in plain, simple, MUCH terser YAML that's easier both to understand and modify. This is not really correct, both use Jinja2 templates and the result is horrific, so horrific that Salt has a new declarative language based on Python: http://salt.readthedocs.org/en/latest/ref/renderers/all/salt.renderers.pydsl.html &gt; Faster (they can use zeromq). Zeromq has a ton of problems, so many Salt is building a replacement: RAET. They also have an SSH option. &gt; Explicitly uses your existing ssh public/private key infrastructure. No need or to create a new authentication infrastructure with certs and increase your attack surface. Only Ansible, if using Salt in default mode, it uses home-grown encryption which has had exploits. &gt; No need for an agent/master infrastructure. Not the default or recommended way to run Salt. &gt; None of this bullshit about explicitly defined dependencies and states running in a random order. All states run in order. Not by default on Salt. http://docs.saltstack.com/en/latest/ref/states/ordering.html
One of the developers here. Allura was started at SourceForge, and SourceForge runs on Allura for all its projects. We've moved most of the project resources from SourceForge hosting over to Apache hosting, but haven't gotten around to sorting through the tickets yet. (There are other tickets in the same tracker that relevant to the Allura platform)
Yea that's nothing. Unless you're using really deep magic or something, it shouldn't take more than a couple of hours I'd guess. 
I would miss all the parentheses. Those are my friends.
Wow, you're right. Thanks for responding with the proper way.
I wasn't aware of flask-socketio. I will definitely try it.
Python Tools for Visual Studio is my new favourite: https://pytools.codeplex.com/
One way I try to remember how to keep it simple is this: Describe *what* transformation you want, not *how* to accomplish the transformation. Learning a functional programming language helps to concrete some ideas which are transferable to Python.
I would recommend looking at [requests](http://docs.python-requests.org/en/latest/) instead of urllib2 and [requests-testadapter](https://pypi.python.org/pypi/requests-testadapter/0.3.0) for doing unit tests. Pretty cool stuff :)
Yeah, if you went that route you would probably want to set up a new user which only has read on the outbound queue.
This isn't the best intro to mock patching, as it jumps right into several of the advanced features, like multiple calls to a mock object returning multiple things. * If you normally want the `MagicMock` object to return a value (like a list) use it's `return_value`, not the `side_effect` method. Use `side_effect` to raise exceptions or (like in the article) you need it to return multiple values across multiple calls. * Calling assertEqual is normally not needed with mock objects, as more specific assertions can usually be done with `assert_called_with` and `assert_ called_once_with` methods. * It doesn't explain what `mock.call` is doing here at all. * mocking `open` is actually a bitch and a half- there's actually a specific `mock_open` [helper](http://www.voidspace.org.uk/python/mock/helpers.html#mock-open) to help do that, but it's functionality is pretty limited. Don't forget you have to change what function the mock replaces for opening between 2 and 3.
&gt;This is not really correct, both use Jinja2 templates and the result is horrific Jinja2 is probably the best templating language available. It's simple, easy to understand and **by design** you can't do anything too complex with it (because the results of that truly would be horrific). &gt;so horrific that Salt has a new declarative language based on Python: Not sure what this is, but it's definitely not an antidote to jinja2. &gt;Zeromq has a ton of problems, so many Salt is building a replacement: RAET. They also have an SSH option. Problems such as? Salt kind of screwed the pooch by creating their own encryption to be used over zeromq, but A) that's hardly zeromq's fault, and B) ansible did not commit the same sin. &gt;Only Ansible, if using Salt in default mode, it uses home-grown encryption which has had exploits. And salt-ssh (introduced in 0.17) covers that. &gt;Not by default on Salt. &gt; &gt;http://docs.saltstack.com/en/latest/ref/states/ordering.html[2] *shrug* it's one setting.
If it's only a few hundred lines, likely very easy. What would make it a pain point would be if you were already relying on 2-only third party libraries, but I doubt that at this stage.
Took this portion here from the pika docs page, but the example had params in the wrong order. Never went back to clean it up: http://pika.readthedocs.org/en/latest/examples/blocking_consumer_generator.html 
Well that's wrong, too.
K well honestly I don't even know what magic is so I doubt I'm using it.. (Just taught myself python like 4 days ago)
Does it really matter if I am just calling to get a Json string from a website api? Is there a huge performance difference or security difference or anything. In the future I'll probably be making POST as well.
Which parts of the text processing are problematic?
http://bit.ly/R4fV07 - some slides on LEGB/Scope 
To see the tricks which need to be done to get C++ nearly as fast, look into the Blitz++ template library. Much of Fortrans' speed advantage has to do with that C++ creates lots of temporary objects when used in a naive way, and the compiler needs to assume pointer aliasing if you do not use things like __restrict. And if you really optimize it, C++ is not too readable any more....
There should be no huge performance or security differences, just in usability of the API. Requests is much nicer to use when you need to do anything beyond a simple get from URL - for example send POST data, set headers, set passwords or cookies, etc. You *can* do all of these with urllib2 as well, but there is no need to struggle with reading the confusing documentation and write 3x more code.
Did you consider: http://phabricator.org/ as well? It is a hidden gem on the internet. Originally developed at Facebook (still in use) and now maintained by a shady group of guys who seem strangely passionate about providing the best collaboration platform for software development... I've used it for the past year and a half at work and am very, very pleased with about every aspect of it.
I found Ansible to be fairly dreadful. It's difficult to do simple things like "don't start up the app server until the database schema on another machine has been updated". I've taken a liking to NixOS recently, although I probably wouldn't build a company on it yet (it doesn't have people officially in charge of release management or security yet). Basically, I get a configuration management system built into my package manager, and I can modify the entire system as I choose, as the system is almost entirely defined by the configuration program that I write. I can solve the inter-server-dependencies issue by modifying the systemd scripts to check whatever I want in ExecStartPre. I could do this with Ansible too, but modifying distro init scripts/systemd services usually feels wrong.
Nice write-up! I will definitely check out `cytoolz` now! Btw., if you want to squeeze even more out of your frequency function (esp. pays off if you have a large number of duplicate items), you can implement the try-except variant: def frequencies2(seq): """ Count the number of occurences of each element in seq """ d = dict() for item in seq: try: d[item] += 1 except KeyError: d[item] = 1 return d I did a simple comparison [here](http://nbviewer.ipython.org/github/rasbt/python_reference/blob/master/benchmarks/timeit_tests.ipynb?create=1#dict_ops)
Probably the best thing PHP could possibly do is to release a PHP6 that removes literally all the deprecated stuff. Like Py3k but unlike Python, the previous version isn't actually good enough.
Any insights into why they decided to switch?
This blog-post is more about why they chose not to use Django as a Python web-framework as opposed to why they chose to switch from the Lisp language to Python.
I assume they mean like 4chan, I agree with the Flask recommendation. 
"Compiled languages like Java"?! Both Python and Java are compiled into an intermediate language which is then run by an interpreter. On the other hand, "compiled languages" usually refers to languages which are compiled into machine code, which is interpreted by the CPU. These are languages such as C and C++, but not Java! Also, such micro-benchmarks are bad because they test one or two specific implementations rather than the inherent speed of the language. Here various implementations of frequency counting were compared, and to nobody's great surprise, a specialized implementation written mostly in C (using Cython) was slightly faster than several other implementations, including one in Java. IMO the actual conclusions that can be made from this article are: * Python isn't slow in all cases. * It is possible to use faster implementations in Python if they are written in C or Cython, which means it is possible to optimize code written in Python without re-writing all of it. * In the case of frequency counting, such optimized implementations were about as fast as one implementation in Java; one was slightly faster. But you know what? I've been using Python since 2001 and I knew all of that back then. There's nothing to see here; carry on folks.
I'll be attending - looking forward to learning a few new tricks!
The 80 character limit is actually a pretty good rule to follow....Most engineers I know will have 2-3 editors open side by side and line wrapping or scrolling side to side is a major pain. It used to be that 80 character was a real requirement but that was a long _long_ time ago, now it's about being nice to those who have to read your code.
&gt; Both Python and Java are compiled into an intermediate language which is then run by an interpreter. On the other hand, "compiled languages" usually refers to languages which are compiled into machine code, which is interpreted by the CPU. These are languages such as C and C++, but not Java! Dude, Java has been JIT compiling to native code for a decade and a half now. C#, inspired by Java, doesn't even include an interpreter (everything is compiled to native at the first use) and is generally slightly worse compared to Java performance-wise, because JVM JIT inlines much more aggressively.
Most of the IPython team, including me, will be there.
Could you add collections.defaultdict to your comparison, for completeness? I'd be interested to how it stacks up.
Ah, yes. My friend owns that domain and has for many years. We worked together at a company whose product was built on python. He registered it after someone pointed out that they constantly made that typo in their browser. It went through several iterations, if I recall. Infinite Hasselhoff was the one that resulted in the loudest "Goddammit Tom!" from neighboring cubicles when the typo occurred, so it remains.
That's awesome! He should definitely put some sort of page view tracker on there to show how many people accidentally go there
What about `d[item] = d.get(item, 1) + 1`? I think it's the standard way of doing this.
Python 3.4 doesn't work well on Windows yet...however, I've been developing an application at work in 2.7 and already have an upcoming task to port it to 3.x for full unicode support.
I'd say collections.defaultdict would be the pythonic way to do it.
...my army of hybrid python-monkeys will poofling your armies any day....
no amount of downvotes on this will stop my mission so you all can just relax and enjoy better content on the front page. 
also /r/learnpython .... for the kids
mostly down. :)
Are you a mod? No. Leave the moderating to the mods **Edit**: Isn't this against reddit's rules?
the mods are doing a shitty job. so like any good american I'm taking matters into my own hands. suck it
congratulations, you're wrong but still think you're right. You're really gonna go places. i can see your future now.
feel my downvoting power. also.. suck it
which rules would those be. is the downvotes not there to use. ... also suck it more. 
&gt;"Compiled languages like Java"?! &gt;Both Python and Java are compiled into an intermediate language which is then run by an interpreter. Exactly. Being compiled is a property of an implementation, not of the language (though admittedly, an official implantation may be implied).
nice suggestions, I just added it...it's pretty fast :)
riiiiiiiiiight. kill the messenger. and suck it. 
Ah of course. I'll post it there. Thanks.
That would make alternative number five, doesn't perform so well though. But interesting, thanks!
lol. 
This is an interesting blog post, thanks for posting it! I'm sketching out a plan for a python package which will definitely require critical components to be written in C. I had been thinking of going down the `#include &lt;Python.h&gt;` route but I just might give Cython a chance first! One conclusion I would *not* draw from this blog post is anything about the relative or absolute speed of Python. For one thing, there's nowhere near enough coverage here to determine that. For another, in the vast majority of cases, your run-time/ICode/JIT is not the bottleneck.
damn, if only i had not implemented my redditbots in django I would have negated all these downvotes by now. everyone that told me that django scales fuckin lied. should have used web2py
**EDIT: How did I get into a 7 month old thread?? WTF?** Well, a lot of the problem with `super` there is Python 2 there, and Python 2 is effectively COBOL. super().__init__(*args) is what we *now* use. That's hardly worse than the unsafe `SuperClass.__init__(*args)`. But why not just `super(*args)`? Well, we need to be able to call the superclass' *methods* too. So we need `super().method` to work. But why not `super()(*args)`? Well, there you have the issue between constructors and initialisers. `super()(*args)` should either *construct* a superclass or throw an error. --- FWIW, I also disagree about `init` vs `__init__` and `self` being implicit, but those are far more stylistic choices.
Agreed. And, in this specific case, we could just use `collections.Counter`.
Yeah, so toolz.frequencies started out using if-else, moved to using a try-except solution similar to what rasbt suggests, and then finally settled on defaultdict, which has demonstrated superior performance in almost all cases. So, to answer your question, just look at the toolz.frequencies entry. That's largely driven just by defaultdict.
It's a good point HorrendousRex. Actually, the point I wanted to get across is that you shouldn't have an overall impression about the speed of Python. It's highly dependent on the kind of problem that you're solving.
Truer words could not be spoken. Thanks for showing me another tool in case the problem I'm solving calls for this cytoolz!
I prefer "touch /etc/uwsgi/vasslas/somevassal.ini" touching the config file performs a graceful reload, no extrenal scripts necessary. 
Awesome. I hadn't heard about the toolz library until this article. I'll definitely be checking it out.
Very cool!
What gives you trouble? It works well for me, but I am not doing anything crazy. Just playing around with small things
&gt;an official implantation I don't think even Raymond Hettinger would go that far... maybe a tattoo. 
If you have the comment id, you can get a PRAW comment object by doing this: r = praw.Reddit(user_agent='whatever your user agent string is') comment = r.get_info(thing_id='t1_{0}'.format(comment_id)) You can use the `reply` method of the comment to issue the reply ([example 9](https://praw.readthedocs.org/en/latest/)): comment.reply('Reply message goes here') You **could** use a for loop to iterate through your set of comment ids: for c_id in commend_id_set: comment = r.get_info(thing_id='t1_{0}'.format(c_id)) comment.reply('Reply message goes here') #Then you can reset your set to empty comment_id_set = set() Or you could do what I [mentioned here](http://www.reddit.com/r/learnpython/comments/24i3hh/a_newbie_question_about_praw/), which would look like this: while comment_id_set: # Will evaluate False when the set is empty comment = r.get_info(thing_id='t1_{0}.format(comment_id_set.pop())) comment.reply('Reply message goes here')
__^[wow ^so ^verify]__: ^/u/PieMan2201 ^-&gt; ^/u/SavinaRoja __^Ð20.00000000 ^Dogecoin(s)__&amp;nbsp;^__($0.010302)__ ^[[help]](http://www.reddit.com/r/dogetipbot/wiki/index)
I'm curious: For what kind of functions foo()/bar() do you use it? It seems a good solution to the problem, but I never had the problem thus far...
The examples work in neither Python 2 nor Python 3: &gt; &gt;&gt;&gt; timeit x + y &gt; s "&lt;stdin&gt;", line 1 &gt; timeit x + y &gt; ^ &gt; SyntaxError: invalid syntax
 &gt;&gt;&gt; %timeit frequencies(data) 1 loops, best of 3: 303 ms per loop &gt;&gt;&gt; from numba import jit (then decorate frequencies with it) &gt;&gt;&gt; %timeit frequencies(data) 1 loops, best of 3: 399 ms per loop We now await the verdict from /u/pwang /u/ilan and peers ;) In this case, frequencies() is the lauded function from pytoolz, which is basically collections.Counter minus the extras (i.e. a very simple defaultdict(int) incrementing a hitcount per key.) Edit: I've also tried something like this: @jit def freq(seq): vd = {n+1:seq[n] for n in range(len(seq))} a = np.array(vd.keys()) return np.bincount(a) But numba doesn't like this. ByteCodeSupportError: does not support cellvars (I'm quite out of my depth now... but the water is warm ;)
heh, that was an amusing autocorrect. *implementation*. /sigh
One idea I had was making a pythonforge, just like rubyforge, for hosting only python code and docs. Make it easier to read some inspirational code. Github is too bloated with javascript and CSS these days!!
I have encountered this problem under a few circumstances when running a continuous loop. I conceived this solution while working on a [reddit bot project](https://github.com/SavinaRoja/OA_source_bot) where I wanted to do some occasional actions (data backup, check mail, review posts) within the context of a constant loop. I anticipate applying this technique to some code for some digital sensor projects and possibly for a PyUserInput derived project. Other live-loop applications that come to mind are GUIs, games, and automation.
Indeed! My bad on that point.
There's already [PyPy](http://pypy.org), which is a major advance over any other dynamic language runtime. There's no advantage to using Go.
The person that wrote the article is using the IPython interactive shell, not stock Python. [`%timeit` is one of the IPython "magic" commands](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.magics.execution.html#IPython.core.magics.execution.ExecutionMagics.timeit). The leading `%` is optional when [automagic mode](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.magics.auto.html#IPython.core.magics.auto.AutoMagics.automagic) is enabled (default) and the expression is not ambiguous. The snippets also demonstrate the use of [doctest mode](http://ipython.org/ipython-doc/dev/api/generated/IPython.core.magics.basic.html#IPython.core.magics.basic.BasicMagics.doctest_mode) which changes the IPython prompt back to the default Python `&gt;&gt;&gt;` style. After using IPython for a while you'll never go back. Having commands line `timeit` is just one of many advantages, including colorized output, pretty-printing of data structures, and tab completion. I'm completely spoiled now and when I find myself in the stock Python REPL I'm nearly useless. 
Worth a penny now, but at least $200^(plus or minus $199.99) in a few years! 
&gt; On the other hand, "compiled languages" usually refers to languages which are compiled into machine code Because most other languages are at least bytecode compiled or source jit to native. Ruby 1.8 was straight up interpreted, 1.9+ is bytecode compiled then interpreted. I'm not sure about perl. OTOH java needs to be manually compiled before running which makes it impractical for simple scripting. Of course 
If you actually read the article, the author does and its waaaay slower. In fact, its the worst of all options.
How do you reload all your vassals while making sure that there's always at least one serving the site? That's what my script solves and it does it as fast as possible so you can hook it up to your deployment system. 
I'm also curious. If you had a pattern such as: while active: foo() Would it sit there in a CPU bound busy loop for the entire time now - wrapped_func.latest &lt;= t ?
Timeit is in the standard lib. But he is using the ipython magic function, which only works in ipython. 
You guys are missing the point, it isn't a question of which one is better, it is a question of which one you need for the job at hand. Not all libs are in 3 yet, for the longest time django was only stable on 2. Than python is integrated into a lot of apps, so a lot of people are still using 2 if they work to script programs like Maya, nuke or modo. Half of the games and 3d industry use python for workflow scripting and still use 2.x
PyPy should never be used as a reason to discourage someone from investigating other Python runtime options. It's great at what it does. It's not perfect. It's not for everyone. It doesn't solve all the problems.
Anyone who can give a quick summary of what this is?
Try also: from __future__ import braces and import antigravity
Yes. But you wouldn't write that. Or, to put it another way, if you wrote that, you'd get exactly the same behavior with this decoration as you would without it.
Yes!
IIRC, Haxe is a "meta-programming language", You write your code in Haxe and can generate multiple target languages (C, Java, ...). And now also Python. I have read good things about Haxe, but never bothered to test it. Because, honestly, I have very bad experience with tools generating your code. The end-result is usually a horrid abomination. That said, Haxe supports a *lot* of target languages. So it's got that going for it, which is great.
This is essentially reinventing a very crude version of microthreads
It would certainly help to know more about what you're looking for. There are tons of great open-source python projects out there that might match your tastes. I mean, heck, let's make a [beautiful interactive python shell](http://ipython.org/). Heck, chef is pretty cool. Let's make [something just as cool, but in python](http://www.saltstack.com/). Man, education is sure in a strange place these days, right? Well, let's try to make a [platform for easily spreading education](http://code.edx.org/); in python of course, because why not? You've hit on exactly what makes python and the python community so great, and the answer to your question is an overwhelming "yes." So ... what part of it do you want to be a part of?
Just to add to that, [this video](http://pyvideo.org/video/2626/by-your-bootstraps-porting-your-application-to-p) from the recent python conference really showcases the relevant issues.
It's incomplete. I started from the "subscription system" section and had to find out for myself that I needed this in the vassal config: start-unsubscribed = True hook-accepting1-once = writefifo:%(_main_dir)/%n.fifo S And then there's the problem of getting reliable info on when a vassal has completed its reload and is ready to accept requests. See [my recent blog post](http://stefantalpalaru.wordpress.com/2014/05/02/uwsgi-and-graceful-reloading/) for the gory details. Just to clarify what we're talking about, there should be no dropped connection and no site downtime during a graceful reload. On the top of that I also want to know when all the vassals were reloaded.
Agreed, but especially for high-performance apps (like some games), it might not be such a good idea. The general problem is that a meta-language like Haxe usually works on the "lowest common denominator". Let's say, Python has generators, which is a concept not supported by all languages. So how do you write those in Haxe? Either you don't support it in Haxe, or, you have to render your own implementation into the target language. And let's not talk about C Pointer Ninjitsu. My point is, that code rendered by a meta-language rarely (if ever) enables you to use the really cool stuff from one specific language. But those little intricacies are the things that allow you to write really well performing code, if need be. I see such languages only useful for simple applications or small proof-of-concepts/prototypes. But again, I never tried haxe, so I don't know how well it translates these advanced concepts into the target languages.
So, we now have meta-programming languages compiling to interpreted languages byte-compiled for a language specific virtual machine running on a virtual machine running on hardware we don't even own. There is literally no amount of overhead people won't accept. ;-)
I found the blog post quite interesting, and I've been doing Python from about the same time. My intuition about what is fast or slow has definitely had to change since then. I'm not particularly fond of the Java language, but its JIT compiler deserves serious respect. The fact that these things in Python are competitive with it (granted, for a micro-benchmark) is very, very interesting. In general, most developers have wildly inaccurate senses about performance, from any language. This is particularly so in Python.
as long as the result is still fast enough, why would they care?
You need to start earlier in the doc, I think a better start would be to setup the master fifo and do a chain reload.
I'm getting some good benchmarks out of this alternative version: def freq(seq): return {x: data.count(x) for x in set(data)} On the same system: version | timeit timings :--------|:--------: toolz.frequencies| 468 ms pandas.value_counts| 318 ms this| 342 ms Edit: If you pre-sort the list, this one is killer: from itertools import groupby data = sorted(data) def freq(seq, len=len, groupby=groupby): return {k:len(list(v)) for k,v in groupby(seq)} 10 loops, best of 3: 96.9 ms per loop
I do have 2008 C++ Express installed...but again, that might not work well in 8.1 I'm not quite sure what's wrong :P 
So, have you verified that you've hit the speed limit of Python -- that your client process consumed 100% of the core it's running on? That's the first thing you should've checked, without that everything else is a baseless speculation. If the problem is not that, but how you do TCP, you'd have the same problem if you rewrite everything in C (though much rarer, apparently, since it does depend on the latency). In your explanation you omit the part where your Python client actually sends responses to the server that closes the connection. Well, since you get Errno 104 on socket.send(). Which raises all kinds of interesting questions: if you're talking to some other service too, do you do that asynchronously, or recv, talk to other service, send response? Does sending a response prompts further requests? Is it possible that you have some sort of request/response duplication, like, when latency is bad the other service resends the request, and sends _another_ request when receiving your response, leaving to an even-increasing number of duplicate requests hanging in your buffers? What would happen if you recv all you can into an internal buffer, as someone at SO suggested (which is the best suggestion IMO, since you then will be able to see what happens to the size of this buffer)? Anyway, as I said, if you don't even know what's your CPU usage, all this is baseless speculation.
Chain reloading seems to work only for workers controlled by the same master and it doesn't do a master reload so any configuration change is not picked up. "lazy-apps" seems to be to blame for some Python crashes in the termination phase [according to this](http://lists.unbit.it/pipermail/uwsgi/2013-October/006614.html) and they delay the app loading until the first request is made [according to this](https://github.com/unbit/uwsgi/issues/300#issuecomment-18786187) defeating the Django warm-up trick. Finally, "touch-chain-reload" lets you trigger the reload but it provides no way to wait until the workers have been reloaded. So to summarize: sequential reload of workers controlled by the same master without app warm-up and without a way to wait until the workers are ready and able. I think I would have a hard time getting zero failed requests during reload with a benchmark like ab with this setup and I see no way to reduce the reload time by parallelization.
Some sort of maintaining issue is bound to rise along the aforementioned lines and will/can be exploited by malicious source (keywords: NSA, heartbleed) That being said I agree -*to an extent*- if the result is the same; no need to pay extra attention.
i think you misunderstood ;) why *whould* they care, not why *should* they care. people should care about many things and don’t.
Hi moor-GAYZ, I checked the CPU usages also, but forgot to mention it on the post. Actually both C based and Python Based code is running on the same machine. The process priority of both process is same. And usually I can see that C based one consuming the majority of the CPU ( 70 to 80 %) and Python process taking ( 10 - 20 %). I know that means python could have performed better if it was in another machine or machine with more core. But actually we don't have no option to change the hardware now. I played with the process priority to force the python process to get more CPU share, but It didn't help much. Since the C based code is do heavy operations and it required that much cpu compared to the python task. I'm not that sure on the issue related to the IO bottleneck here. Regarding the Python process sending response back to the C based server:- It's actually sending the response back to the C server ( ie; On the same socket, no other third service and it's not asynchronous in the python side). Please have a look at the tcpdump trace that I have uploaded on the SO page. It has the full trace back between the C based server and Python server. You can see that on the TCP trace finally the C based server sending RST flag back to Python server. I know it's not python own fault, and I mentioned that on the post that the C based code not doing its job properly which is why it closing the connection. Another suggestion I got from IRC channel is that the C based server would have closed because of timeout. But I couldn't able to simulate it locally yet. I was simulating the situation by writing simple code locally, that wasn't a success yet, that's why I didn't mentioned it on the post. Reading complete data from the receive buffer is the best solution we have right now. It have some implementation restrictions and to do that we have rewrite the core logic from scratch, that is the one thing blocking from us to do. After removing unwanted code it helped a lot, so it shows reading the entire buffer is the way to go now. Lets see if the current changes wouldn't help we will do it any way. Thanks for your thoughts.
&gt; and Python process taking ( 10 - 20 %). I know that means python could have performed better if it was in another machine or machine with more core. It might also mean that your Python server is in fact IO bound. Looking at that log, it looks extremely inefficient. Your client keeps sending back 34-byte chunks (mostly), one by one, and the server acknowledges each with a 0-byte payload (after you've closed the window). 90% of your total CPU usage could be the cost of system calls and the network driver composing/decomposing those tiny packets. Try doing this: in a loop recv into internal buffer while there's data, process all data while collecting responses into another buffer, send that buffer all at once. What exactly does that Python process do? Just some CPU-intensive processing, nothing more? And yeah, I think that it's safe to go with the assumption that the immediate cause of the problem is the non-blocking send from the server that returns EWOULDBLOCK when it runs out of the kernel network buffer, which causes the server to close the socket.
Hi, Thanks for the suggestions about improving the code. We are like to do the following thing, 1. Make the Python side multi threaded, so the reading socket is done by the one thread, so it can clear entire buffer quickly, and other thread sync the data into disk. Python side is not doing any CPU intensive operation only IO bound. Mainly persisting the data into disk and keep some meta information about it. 2. We are using another protocol on top of TCP, Actually it has option to send bulk response back to the server. We were failed to make use of it. So while rewriting the code add thins option also. And your last point makes more sense now. &gt;And yeah, I think that it's safe to go with the assumption that the immediate &gt;cause of the problem is the non-blocking send from the server that returns &gt;EWOULDBLOCK when it runs out of the kernel network buffer, which causes the &gt;server to close the socket. I'm Adding link to this discussion on my post. It gives more insights into the problem. Thank you.
Do we not already have that already in the Python world in the form of Kivy?
I don't think there's much competition from Julia yet. Lots of Python folks are excited about Julia, but Julia just doesn't have the breadth of packages yet to challenge Python. IMO, I think what will eventually win out is some combination of Python and Julia, perhaps Python with Julia as a fast backend, or Julia enhanced by interoperability with Python's rich array of domain-specific functionality. The way for this interoperability is already being paved by [pyjulia](https://github.com/jakebolewski/pyjulia) on the Python side and [pycall](https://github.com/stevengj/PyCall.jl) on the julia side, and of course the excellent combined efforts of the IPython/Julia teams in [IJulia](http://nbviewer.ipython.org/url/jdj.mit.edu/~stevenj/IJulia%20Preview.ipynb).
aren't you a trusting person :)
I'm most interested in it for sharing pieces of conceptually complicated but not especially computationally expensive bits of logic (say, validation of complex form input) between client-side Javascript and and a server-side Django app.
concerning implementation: * please add a note on top that javascript is required. a noscript user will fill eveything expecting http submission, and only get suspicious when he notices that the indentation part's radio groups are misconfigured. content notes: * 'Add `#!/usr/bin/env python' to the top of the script' is not strictly required. #!/usr/bin/python would do in most environments as well. i suggest adding the phrase 'or similar' (edit: if there is a reddit-generic way to mark spoilers, please let me know, the various gaming-subreddits' ways seem not to work here) 
`def dicts1():` question only has one option.
It's a gimme :) I like this sort of question, it gives some relief during the long quiz. The way such a question is annotated is with the `@yeahok` decorator, see https://github.com/thomasballinger/pythonquiz/blob/master/intro.py#L231, which I think is cute.
I've only had a little experience with Haxe. In my experience, you're pretty much right. Case in point: Using Haxe's built-in template library means that your templates are handled by a Haxe library compiled to PHP, instead of doing the sane thing and generating raw PHP with embedded HTML. Obviously that would require more magic, but it just illustrates the fundamental problem of a metalanguage like Haxe attempting to support such a diverse array of target languages (which now includes C++, Java, AVM, JavaScript, Neko, and C#, in addition to PHP and Python). Likewise, invoking native functions was a real pain in the ass. If I had wanted to use PHP's native hashing functionality to generate a password hash, my code would have looked something like `hash = untyped __call__('hash', 'sha256', password + salt)`, which is unintuitive and ugly. I also found that Haxe doesn't have a very good public knowledge base. The docs are decent at best, incomplete at worst (["Comments and explanations to be completed at a later time."](http://haxe.org/doc/php/extern_libraries)), and community knowledge is scattered and disorganized. Trying to Google most problems I ran into with Haxe was an exercise in frustration and confusion. There are a couple books on Haxe, but neither of them really addressed what I wanted to do (PHP targeted web development) so they ended up being mostly unhelpful. There must be some useful resources out there, because [there are actually a decent number of projects written in Haxe](http://haxe.org/com/projects), including *Papers, Please*, some games by Nickelodeon, Disney, and other companies, some of GitHub's Flash-based visualizations, and a variety of other things, but for my purposes the resources just don't seem to be out there. The only reason I can imagine someone wanting to use Haxe-&gt;Python instead of Python is if they wanted a language with native static typing or were just C++/Java style diehards who can't stand to look at code without curly braces. One of the touted benefits of Haxe is being able to write both client and server-side code in the same language even when targeting different platforms, so I guess if you wanted Python on the client side and a native application on the server side, that could be a reason.
Thanks, fixed the content note and added a javascript warning at the beginning. I'd love to have a non javascript version, but haven't gotten around to it (pull requests welcome, https://github.com/thomasballinger/pythonquiz). It's also runnable in the terminal clone the repo. I could still read your spoiler by mousing over it, so it still works somewhat.
* fixed, thanks - should be `''.join(reversed(s))` * fixed, thanks * fixed question to be "Which of these comprehensions will run without errors in a fresh Python interpreter session?" * dicts2 is confusing - the implicit question (as with all other question with code) is what does the *function* return, not what does the last expression of the function evaluate to. EDIT: I've made this implicit question explicit with a docstring more: * I like these gimmes - they fill up the screen with green :) * fixed, thanks
I'm not sure about an interpreter, but if there was an easy way to write Python extensions in Go, that might be a good first step. (there might already be a good way to do this - I haven't checked)
TIL that some guys started to write a competitor to Reddit in Common Lisp soon after the switch to Python.
I would classify Julia as 'up and coming' - it's not very big yet, but it has some very nice features and I'd expect it to get bigger in the future. I absolutely agree that different languages do and should work together - I meant 'competition' as in "Python's not the only kid in the playground".
[Readthedocs](https://readthedocs.org/) is popular for hosting documentation of Python projects - it's not limited to Python, but Python projects have jumped on it more than anything else. It looks like Rubyforge is shutting down in a couple of weeks, so perhaps copying their model isn't the greatest idea. Maybe some kind of showcase site highlighting cool Python projects could work.
This sounds like sort of thing that [ZMQ](http://zeromq.org/) might help with - it handles the socket reading/writing in a C thread, and you can just pull a message from it in Python. That would require you to rewrite both parts of your application, though.
&gt; It's difficult to do simple things like "don't start up the app server until the database schema on another machine has been updated". Um, that's as hard as putting the "start app server" command after the "update schema" command.
Then why did you give two config management and provisioning systems (use of which does not require any ruby) as examples of ruby being in heavy use.
You use `zip` when closing the files, but I think you can use it here too for i, mode in enumerate(self.modes): fp = args[i] can be just for fp, mode in zip(args, self.modes): 
for the from mymodule import MyClass question. it doesn't run all of the code. if i have a module with: def f(): raise Exception('according to this answer, this will fail on import') it will not fail when i import it. to be clear, i understand that it executes the entire file, but it does not run all of the code in said file. other than that, some of these are really interesting, thanks.
How do you deal with that if you've got multiple app servers and one database server? What if the update commands depend on the database server being updated to a certain version? Salt, for example, manages this by way of an Orchestration runner, which allows the admin to define that certain states depend on states on other servers. Ansible has no such thing built in.
Via HN. Discussion: https://news.ycombinator.com/item?id=7686816
If you wrote good Python 2.7 code (new-style classes, etc), you may not *have* to convert anything other than `print`/`print()` and `generator.next()`/`next(generator)` and the few other things that are different. I'd start by seeing if you can run your project with python 3.4's interpreter first, worry about porting with something like 2to3 later. If it'll run how it is (or fails with just the syntactical differences), fix whatever needs fixing and swap it over.
that's pretty cool, just some small suggestions. -- you can return directly from the try. the finally will execute regardless -- you can just append any file you open in the decorator to the `close` list and then just call close on everything in that list, rather than using a bunch of bools and such. 
Thanks, good point - looks like I can. `args` and `self.modes` can be different lengths, since `args` are the arguments passed to the wrapped function, and `self.modes` are the file modes for *only* the file-like arguments. Since `zip` truncates with the smaller iterable, it would work - good to know. My personal preference is to only use `zip` when arrays are the same length.
Great suggestions, thanks. Makes the code much more concise. I'll update the gist.
The os library in python can do things that might look innocuous to a scanner.
I also thought about this version, but I'm not sure if it's safe, since the parameter name `seq` implies to me that the argument can possibly be an exhaustible iterator. In that case, it would cost extra to listify it first.
Good point; that's a code object that isn't getting run, just compiled. EDIT: fixed somewhat, changed it to "executes mymodule," though that loses some of the indented effect. Ideas for how to change it that will still get that point across?
in time, we will go deeper still :)
on the other side of such an approach, you get less coding done overall, and as a result, less chance for human error + easier code review
is it really that much of a waste though? `haxe -&gt; something -&gt; something's bytecode` only happens once after editing the source and once per target, then you just have the double VM overhead which ain't greaat admittantly but its but its not as bad as before
it’s not that wasteful. the really important parts get Just-in-time compiled or are deferred to some C implementation running directly on the metal. when you do array.map in javascript, you might just run something with about as much overhead as a for loop in C.
You might consider using an [exit stack](http://docs.python.org/3/library/contextlib.html) to manage open file descriptors, instead of closing them manually.
&gt; t’s supposed to be a learning quiz; there’s no score, just some red pixels to motivate you to understand the answer. Thanks for this. I'll look for useful ones I can add to my Python Anki flashcards.
It'd be awesome to add [Anki output](http://ankisrs.net/docs/manual.html#importing) - the [library](https://github.com/thomasballinger/pythonquiz/blob/master) that builds this quiz could use another backend! I don't use Anki, so probably wouldn't do this myself, but would be happy to help someone else do it, and would definitely accept a pull request!
&gt; meta-programming language meta-programming language to me implies a language with meta programming features. I'd call it a language who's compiler can output several different high level languages as output.
We don't travel i the same circles or come from the same place. Among certain groups of programmers there is no such thing as "fast enough"; if all their language has going for it is compilation, they become obsessed with micro-optimizations. In yellowking's example, the response would be that faster hardware is not an excuse for producing poor/slow code. Heck, among the Delphi community EXE size is still a thing they freak out about and as soon as a new version comes out someone runs a test compilation on an empty project and posts are written about EXE size differences. :-( When asked, one person actually deployed applications to oil rigs over a radio uplink so he had an excuse. :-) The rest of them act like software is still distributed on floppy disk. One person told me their LAN manager actually insists on minimal EXE sizes (!?!?). http://stackoverflow.com/questions/13598678/exe-size-is-too-big-in-delphi-xe2 "Using Delphi XE 3 with a simple form, the Debug exe is 10,995Kb whereas the Release exe is *only* 2,326Kb long. You may argue the latter is still big...." It's a weird, weird world outside of Python. 
I would think the usefulness of Haxe is this: you're using RapidMiner or BirtReport or some other program written in Java and you want to expand it with a custom function. You could learn all of Java or you could use Haxe. Now you're using the Banshee media player and want to write a plug-in. You could learn all of C# or Boo... or you could just use Haxe. You're using Blender or GIMP or something else that uses Python for extensions. You could learn another language or... yes, again, just use Haxe. Isn't that one of the main reasons we have IronPython and Jython? Same with Haxe. 
Python doesn't compile to Objective C or Java. There are deployment and other issues with Python on mobile; at one conference a talk rightly called Android "the platform that Python forgot". Python still has a lot of work to do to become a first-class language for mobile development. 
I've been trying to do some animation as well but find that there is little documentation/examples out there. QTimer and callbacks are the two things I've had a bit success with.
If you have an exception while opening one of multiple files this will leak handles, I think, due to the try clause starting after opening the files. (So for example, calling `copy_file("foo", "bar")` where you don't have permissions to open `bar` will not close the handle to `foo`.) Not necessarily much of a problem, but still good to fix.
LOL...yeah, go search around netsec. It's much easier than you'd think
`pip` should know what to do with wheels.
I really like using Anki for memorizing little facts that otherwise easily forgotten. Unfortunately, I'm too over-scheduled now to help on this. But a good set of decks on Python would be cool. 
I used to think the SQLAlchemy ORM was really dandy until I realized that generally I just want the results of my query without too much hassle. I still use it, but mostly just as far as writing my queries in plain SQL. Occasionally I also use their object mappings, but usually just when I have potentially lots of manipulations to do on the data and don't want to use more INSERTs than necessary. The queries-as-code is really cool, but IMO it falls apart as soon as you need to do a complicated query.
CFEngine 3 is pretty much the heavy weight when it comes to configuration management. I haven't found anything that beats its small footprint, fast execution and ability to cope if your configuration management server(s) goes down. Plus it is ridiculously easy to do what you want in it.
* make sure that `pip` refers to your Python 3.3 environment (this might be a concern if, for example, you've installed `pip` in a different version of Python and not in 3.3) * `pip install numpy`
I'm going to quote myself here on a [post I made](http://www.reddit.com/r/Python/comments/1xaf7k/checking_processes_using_virustotal/cf9vw8w?context=3) about VT before: &gt; Finally for everyone else out there, VT is not a virus scanner. It's a search engine to say "we've seen this exact data before and it has been identified X number of times by X number of vendors, do what you will with this information in your analysis." It also won't have much information on brand new or targeted threats but again these are not the types of things most people would ever see on their home machines. So in short, VT won't tell you a darn thing if someone writes something 'new' and sends it to you. All they have to do is take a piece of malware and modify it slightly and send it to you and there's a very high chance VT will return it as clean. In many cases they probably would not even need to modify the malware because it's going to be contained within another exe.
&gt;but IMO it falls apart as soon as you need to do a complicated query. This is why I dont like orms. Also, taking a data object and being able to use it flexibly is not so easy. Not even worth it especially with pandas now there.
The os.walk answer has an extra single quote.
Bitbucket has free unlimited private repositories.
This was frustrating, but great motivation to go back to the docs and really understand things I'm not likely to actually see on a daily basis. Thanks!
I dig tkinter. It's free. Its already an included module. Cross platform. It also seemed to be the only one that didn't require a degree in rocket surgery to install on my machine. ActiveState's tcl and python distributions have png support, if you need that. The only thing is: you have to wade through some hella confusing docs, what with examples being given in a mixture of python2, python3, tcl and the occasional perl or ruby, and honestly the best info you have to read in given in tcl. You don't really have to learn tcl, just how to read a manual written for tcl. There's a pretty consistent naming pattern that maps between tcl and python, but nowhere in any manuals on the python side will you find all of what you need. the esoteric stuff like window transparency and stay-on-top generally involve a wee line or two of tcl.
My favorite's PyGTK. It's code mostly just makes sense, and the widgets integrate nicely with just about any environment. Only problem with it is it sucks for distributing programs in Windows.
I was under the impression c# compiled to the common .net intermediate language, and the result compiled jit when it's run, no?
My first choice would be a browser-based gui with a python backend. Use python for what it's good at (gluing things together, transforming data, pushing bytes around), and html/js for what it's good at (looking good cross-platform, interacting with folks). If you then pointed a gun at me and said I have to use a pure python gui toolkit I'd choose urwid. If you then said "that doesn't count, it's ncurses", I'd use kivy. The ones you mentioned all suck pretty hard for various reasons, the biggest being that new users have to install a few hundred megs of libs just to look at your thing, except for Tkinter, which is terrible in its own way.
I heard all this love for SQLAlchemy and found that for straightforward stuff like basic sql I/O it was way slower than straight MySQLdb. My general finding is that Python with MySQLdb is somewhat faster than PHP but with SQLAlchemy in action the nod went to PHP for speed. Seeing that I want to make things faster as I transition to Python from PHP then SQLAlchemy is out. 
**Books** http://www.amazon.com/Tkinter-GUI-Application-Development-HOTSHOT-ebook/dp/B00G8YAUX4/ http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html I've used Tkinter for several work projects. My primary reasons for using it : * included with the default Python distribution * Simple for end users to run my scripts and get a nice gui * It is very simple 
Great catch, thanks. You are right about the leaking file handles, I updated the gist.
https://store.continuum.io/cshop/anaconda/
I like this way of looking at things a lot. Are there any books you can recommend for making combining these languages to create sophisticated web apps?
Any luck?
I don't know of any books, but I'd recommend checking out the python wsgi framework 'bottle'. It's super simple yet has enough features to do pretty much anything. If you're a python hacker new to js I'd recommend playing around with jquery and underscore. Javascript itself remains a bit of a chore to deal with, but CSS and HTML are so clean I find that it's worth the trade off, abandoning the pure python ecosystem.
I'ma check it out. I've been thinking of trying to repurpose openbazaar into a p2p end-to-end encrypted social network.
I'm used to programming in PHP were semicolons are necessary so its a tough switch. I should probably increase the AES to something better. The ID is generated by multi hashed string to a main string 100 times, then hashing that main string 1000 times. The main string is over 12000 characters long.
and then: conda create -n py33 python=3.3 ipython numpy 
The AES in CBC mode is not really the issue, the issue is the way you are using it. The IV should be random, the key should be generated via some form of key derivation (Your crypto lib I believe has PKDF2 or something). Why is the ID derived from the password at all? Can you not just generate a UUID or something?
&gt; What is the most popular one? I wonder how anyone could really know that. &gt; What is the most powerful one? What do you mean by "powerful"? They all get the job done to show widgets on the screen. I use wxPython. It has a great and helpful community, the widgets are generally native (meaning they are using the widgets that the OS the user is running uses...so your app on OS X looks as OS X apps should; your app on Windows 7 looks like a Windows 7 app, etc.), rather permissive license, well-documented.
We use wxPython to build Windows and Mac application and it works. 
This is on the test set, a 5,000,000 entry list of unequal-length strings. Note list() is only being called on the output of groupby as the second return value in the tuple is a generator &amp; you need all of them to calculate len(). It's still the fastest by a long shot on sorted input. Note, adding in the time to sort (which is a fairer comparison) bumps it up to over 650 ms. I just thought it was an interesting option for the case where the input is already sorted - none of the others do any better at that. Another approach I tried but couldn't make quick enough was creating a lookup table of integers to the string name, then using numpy to calculate the frequencies of those integers (since its works better '/ has more options for numbers than strings), then use the lookup table to revert. It was slightly slower than toolz.frequencies (the non-optimised version). On that note, cytoolz now joins my stdlib ;) scipy.stats.itemfreq() was surprisingly poor. I was going to pull a stunt with pandas.crosstab as well, but it turned out value_counts was faster still. 
Removed the semicolons and sent you a PR. Check it out :)
Because they are written in ruby, are widely deployed, and actively maintained. There's a difference between citing things and endorsing them.
main issue issue for me on windows is that virtualenvwrapper-win package not supporting python 3.4 But... Sorry this is not problem with python 3.4, this is problem with recent new versions of virtualenv package.
I find I am very productive using Pony ORM. I can pretty much just think in python when using it.
I love peewee. The django orm is quite nice as welll
Having extensive experience with wxPython (which has its strong points but some issues as well) and some less experience with PyQt/PyGTK, I strongly recommend Enaml (http://nucleic.github.io/enaml/docs/index.html), a declarative language for making python gui apps. It runs on top of PyQt. 
Can someone explain to me what is point of linking image that contains only text in it? This is not first time that I see this, so I am wondering are there some benefits to text in image that I do not understand?
carefully
This is the coolest conference on science and computing.
The thing you really need to comprehend is the MVC paradigm and the concept of callbacks. After that, all these options (and GTK+3 via gobject-introspection, also a good choice) are simply a matter of syntax; the behaviour (and hence, design) is more or less the same (draw a widget on a canvas, register a callback on an event, start the event loop). I like PyQT (or PySide, if that's your fancy) as its very cross-platform and has the best support tools of any of them (e.g. QtDesigner). The documentation is very good and up-to-date. It also integrates well into tools like PyCharm. 
Yes.
&gt; We're on the same network and we both develop in cloned Virtual Box environments, but we're looking to sync our files in real time. What's wrong with the standard practice of using a [revision control system?](http://en.wikipedia.org/wiki/Revision_control)
&gt; I’d like to create more quizzes that make the “Python is deeper than you think” point To me, "depth" implies that there's substance and power to be found. Most of these are just a matter of stepping in mousetraps while looking for your keys in dark, dimly lit corners of the room. 
TIL that {x:y for x, y in zip(range(10), 'abc')} is valid in Python 2.7, though I will probably stick with dict((x, y) for x, y in zip(range(10), 'abc')) for backwards compatibility. Same with the {1, 2} syntax for sets.
I always figured this was the case.
I used Tkinter for a while, great framework, and like other people have said, it's already included in Python. That aside, I've also used Kivy as a GUI framework and I've got to say it's also an excellent option. It's cross-platform abilities even extend to mobile, which tkinter does not. I'd really recommend it. 
Great news and a long requested feature. You can use "arnold" for easilymigrating up and down.
Bitbucket is less anal about forced freedom, allowing you unlimited private repos; the only limitation is on the total number of collaborators, but if it's just the two of you, no problem. Alternatively, if you already have a shell server of sorts that you can ssh into, setting up your own git server is super easy. All you need to do it: 1. Create a user named `git` on the server 2. Arrange it such that everyone who needs access to the repo can ssh into the server as that user (key-based authentication works best for this) 3. For each repository, do, in git's home dir: `git init --bare $REPOSITORY_NAME`, where `$REPOSITORY_NAME` is the name of your repository (duh). Then point the git working copy on your workstation to the newly created remote repository, like so: `git remote add origin git@you-git-server:repository-name`, and make an initial push like so: `git push origin master -u`.
I am a somewhat happy user of Storm. The API is very clean and it generally writes the queries you expect. It makes standard joins easy and yet never prevents you from mixing in real SQL. I have previously used SQLAlchemy but really prefer the Storm query builder over that. I, contrary to the article, really like that you manually have to create your schema. That way you can maintain column order, and most of all, just use plain SQL. The source code is simple enough to grasp and extra functionality is easy to add. I wanted to support PostgreSQL's range types and did a series of extensions to help me with that. I will release the libraries to the public once they have stabilized a bit. My range implementation for python can be found on github (https://github.com/runfalk/spans/). Despite just having one release it is actively maintained, and will remain so for the foreseeable future. The one drawback with Storm is its slow release cycle. I however expect it to be maintained for a long time since it's powering Canonical projects such as LaunchPad.
It's not really that order as far as I can see. A "self post" is a post by oneself. `self` is the canonical name for an object to reference itself, so it would make sense to term actions by oneself as oneself's actions.
Yeah, I meant "I’d like to create more quizzes, which *actually* make the “Python is deeper than you think” point.
Interesting. Will have to check this out. 
While I find ORMs lower the barriers to getting up and running, tuning an ORM query is usually not painless. I prefer web2py's DAL which is a lot like SQLA core, functional query builders, sanatized input, and multiple db support without shoe horning your data into object buckets. 
I'm well aware. I have a specific usecase in mind for a current production app that involves confirming that text that's been input into a form is a validly formatted US code citation, and want to share the logic for running a series of regexes on a string and checking that their matched text looks right. It's logic that gets fine-tuned a lot and is a pain to keep in sync between client and server. Well-encapsulated stuff like that would be the best candidate, since, as you say, one side can't touch the database and the other side can't touch the DOM.
&gt;self is the canonical name for an object to reference itself Not in all languages. I think 'this' is more common (but thats from memory).
Indentation missing on examples?
Look at itertools.product.
It's very easy to write code to be compatible in both 2.7 and 3.4. You can do it in this way and eliminate the use of 2to3.
This was very well written. Thanks!
the one liners looking ugly migh be an indication that you optimize the wrong thing 
Any examples of practical utilities ?
Fair enough. The term I used was essentially a brainfart.
Definitely. It sounds very compelling. I wonder though, how much has performance to do with battery drain. I guess it plays a role, but how much would you gain from properly optimising. I don't like premature optimisation, but it's still a though which continually hovers in my brain waiting to be called into action... ;)
Thanks, I'll check this out.
&gt; I just think multiple for-loops looks ugly and I know they become memory-hogs very quickly. Then you have a very broken understanding. Using multiple for loops is no more or less efficient than any other syntax to do the same operation, and it certainly isn't a memory hog unless you're actually using up memory. Also, explicit is better than implicit. A nested for loop is best if it's the clearest way to express what you're doing. 
Is this what you're trying to do? for file in file_list: # if file_names is a set then this will be much faster if file in file_names: shutil.copy(file, out_dir) If you care about certain types of files instead of specific files, you could even do it with fnmatch import fnmatch import shutil for file in fnmatch.filter(file_names, '*.py'): shutil.copy(file, out_dir) Edit: actually, you could turn both into sets do it like this: for file in set(file_list) &amp; set(file_names): shutil.copy(file, out_dir)
Technically you can do this with a list comprehension: def file_move(file_list): [shutil.copy(file, out_dir) for file in file_list for name in file_name if str(name) in str(file)] But I'd say that's ugly and hides your intent, as well as executing filesystem side effects inside what should be a pure computation. It'd be much better to use `itertools.product`: def file_move(file_list): for file, name in itertools.product(file_list, file_name): if str(name) in str(file): shutil.copy(file, out_dir) And then just not worry about the line count, since line count is a poor measure of code quality.
How does it know which arguments are intended to be files?
Thanks, I didn't know about the fnmatch method.
Actually that is configurable, so it can be less or more than that. Either way, the problem is that it's still in your clipboard until KeePass clears it. And if you use anything that can access your clipboard in the meantime, your password may have been compromised.
by the number of arguments you pass to the decorator.
Cheat using list comprehension! def file_move(file_list): [shutil.copy(file, out_dir) for name in file_name for file in file_list if str(name) in str(file)] Don't do this, please. Yes it creates a list, we don't care if that disappears later. I might not have done this quite correctly, but you get the general idea. Again, don't actually do this. :-)
I don't know the scope of what you're trying to do, but Flask is an easy, lightweight way to put a web layer around something. Has dead simple Bootstrap integration as well. Miguel Grinberg has a good [tutorial](http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world) on his site.
Didn't the Geofront get totally smashed in the Second Impact, right before everybody got hugged and turned into Tang (except for Gendo, because fuck you, Gendo)?
&gt; line count You can make a 1 line program if you use eval() and a base64 encoded string. Doesn't mean that it's very good. But sometimes, if you're spending many lines on a simple thing, that may be an indicator that there's something in the standard library to do the exact thing that you're trying to do, and you should go look for it.
Haha, you exactly know its etymology.
&gt; But sometimes, if you're spending many lines on a simple thing, that may be an indicator that there's something in the standard library to do the exact thing that you're trying to do, and you should go look for it. This is so true. Many times I've written a bunch of code only to find out that it's something in the standard library. I actually started making flash cards for the standard library. Another question I thought of asking here (but never did) is whether there are already-existing flash cards. I saw some online but you had to pay to get them. Anyway, you are so right about this.
why not avoid sockets/zeromq and just use rpy2?
I also had once written code like this to check if something is a tuple `if instanceof(item, type(())):`, instead of just doing `if instanceof(item, tuple):` Yeah, python is not meant to be awkward. If it is, you're most likely doing something wrong. ^(or working with `curses`)
I'm just saying that the name doesn't inspire a whole lot of confidence, particularly when it's supposed to be storing SSH keys.
I meant canonical in Python.
Yep. Now you have the mental image of Shinji masturbating over Asuka's comatose body in your head. Have a nice day!
http://www.digitalmihailo.com/traveling-salesman-problem-dynamic-algorithm-implementation-in-python/
Thank GAWD. I was trying to do something with an HMM and found scikit-learn's implementation of GMHMM to be super buggy. Thanks!
Just in time to help with my end of semester stat project. Thanks alot !
Did you do anything special to get it to integrate well in PyCharm? From my testing it doesn't even do autocomplete properly. http://i.imgur.com/f2L2Plu.jpg
exit was simply a string in python &lt; 2.6. In python2.6 they added the callable behavior as a convenience. It would be a Bad Idea to implement an object that has side effects on repr() as you're suggesting. Consider: I want a mapping from builtin objects' names to their string representations: &gt;&gt;&gt; builtins = dict((attr, repr(val)) for attr, val in globals().items) If exit had the behavior you asked for, running this would silently exit the interpreter, with no error message and exit code of zero. If you still think this is a good idea, however, you can do this: `.bashrc`: export PYTHONSTARTUP=~/.pythonrc.py `~/.pythonrc.py`: class exit(exit.__class__): def __repr__(self): raise SystemExit() exit = exit('exit') 
You might want to specify the python version, as some of these are incorrect for python3. Eg. iterators (and thus file objects) no longer have a `.next` method (it's been renamed to `.__next__`) Also, some of these I think are undefined behaviour. and so are features of a particular implementation, rathter than python the language. Eg: def dicts3(): for k in {1:2, 3:4}: return k Python doesn't make a guarantee as to what order dicts will be iterated. In practice, current versions of cpython will always do 1 first, since it itreates through the buckets, ints are their own hash, and there'll always be at least four buckets here. However, this definitely isn't something anyone should rely on as it's all internal. The same for the `__sizeof__` questions, which rely on the current overallocation strategy.
This really isn't a change. It works already. You just need to switch your `with`s to `for`s. $ python iterable.py [(6, 9, 12), (6, 9, 15), (6, 12, 12), (6, 12, 15), (9, 9, 12), (9, 9, 15), (9, 12, 12), (9, 12, 15)] $ cat iterable.py iter1 = [3,6,9] iter2 = [6,9,12] iter3 = [9,12,15] print [ (x, y, z) for x in iter1 if x &gt; 3 for y in iter2 if y &gt; 6 for z in iter3 if z &gt; 9 ] 
Thank you all for your comments and suggestions! It really helped me to improve the article. Btw., I just found some time to add 5 more sections :)
Bookmarked, and upvoted. Very useful. 
Brailliant?
&gt; we're looking to sync our files in real time I am curious as to why.
I would also like this! Naturally I would want it to run downstream of my ci so that only 100% passing revisions get released. 
Cheers man looking forward to giving it a go.
That last one can also be done: set(file_list).intersection(file_names)
 d = {1:'a', 'b':2, (4, 5):[6, 7]} d.get(4, 'something') &gt; 'something' But it was marked as incorrect.
Cool
This one is a bit silly, but it's asking what the `dicts2` function returns.
There's no reason to blacklist empty-list as a default value. We could easily make your first example compile to the same bytecode as the second. The real problem is that the core devs have come to cherish this bug as a feature, because it "can be useful" for memoization: https://docs.python.org/2.6/faq/design.html#why-are-default-values-shared-between-objects 
`shell=True` opens you up to injection attacks. That's why it's off by default. It also means you're solving the problem of io pipelining in bourne shell language, not python, as boarhog desires.
 brew install python3 # note this will install 3.4 pip3 install numpy Done
The reason packaging is the worst-designed part of python is that the core devs don't *have to* use it, unlike the syntax or stdlib.
The op didn't illustrate his need to pass arguments. The op was also doing ` blah de blah | something else ` calls, which implies using the shell as | is a shell internal rather than a binary command like [. 
really?
oh snap. totally missed that
Not an unfair point, basically I posted it because often "asking for a one-line solution" doesn't lead to readable best-practice code. Most of the time I hear fellow coders talking about it, it's "to see if it can be done". Since the topic of whether it was a good idea or not had already been covered elsewhere in the thread, I thought I'd add a way that wasn't seen. The "don't do this please" was simply to reinforce that it's a "because you can" solution, not a "because you should" suggestion.
What am I doing that speed is critical? Speed is always critical on a website. Statisically you are losing viewers for every millisecond that people wait. (not exaggerating). Plus google will rank your site higher the faster it goes. So speed is one of the most important things that you can do on a website. Plus if speed is extremely high then it buys you some wiggle room to potentially do something cool that slows it down a bit. If it were already a bit slow then the something cool might cross that vague line where you are losing too many users. For instance, reddit normally loads for me in maybe 8/100ths of a second. I notice if this bumps up to 1/4 second. While most people won't leave for such a small bump there are people who do. Then there are studies that show people are less likely to buy from a site that is even marginally slower. 
See what /u/doug100500 wrote in [this comment](http://www.reddit.com/r/Python/comments/1xaen1/if_you_could_change_something_in_python_what/cfa0tzv): you can overload `sys.displayhook` instead of redefining `exit`.
Doesn't Pony have a more restrictive license? Or am I confusing it with another ORM 
Using a [braille terminal](https://en.wikipedia.org/wiki/Refreshable_braille_display).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Refreshable braille display**](https://en.wikipedia.org/wiki/Refreshable%20braille%20display): [](#sfw) --- &gt; &gt;A __refreshable braille display__ or __braille terminal__ is an electro-mechanical device for displaying [braille](https://en.wikipedia.org/wiki/Braille) characters, usually by means of round-tipped pins raised through holes in a flat surface. [Blind](https://en.wikipedia.org/wiki/Blindness) [computer](https://en.wikipedia.org/wiki/Computer) users, who cannot use a [computer monitor](https://en.wikipedia.org/wiki/Computer_display), use it to read text output. [Speech synthesizers](https://en.wikipedia.org/wiki/Speech_synthesizer) are also commonly used for the same task, and a blind user may switch between the two systems or use both at the same time depending on circumstances. &gt;==== &gt;[**Image**](https://i.imgur.com/WPXyF7V.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Refreshable_Braille_display.jpg) - *Refreshable braille display* --- ^Interesting: [^Braille](https://en.wikipedia.org/wiki/Braille) ^| [^Blindness](https://en.wikipedia.org/wiki/Blindness) ^| [^Perkins ^Brailler](https://en.wikipedia.org/wiki/Perkins_Brailler) ^| [^Human ^interface ^device](https://en.wikipedia.org/wiki/Human_interface_device) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch8xd8n) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch8xd8n)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Because you can natively use the IPython notebook to program in R (like if it were another R IDE, sort of).
C would not be a good balance between speed of development and speed of production. I can develop in Python record time compared to even PHP so that is good. Python is nice and fast. But for the tiny advantage that SQLAlchemy wold give the speed price is too high. Until Python I did keep my eyes open for a C++ replacement for PHP. But each person who did make a C++ web system couldn't seem to help themselves and made a whole framework that made me do things "their" way. Another advantage of keeping things fast is that it lengthens the time before you have to start breaking your site up among multiple tiers of machines. Once you are forced to cross a boundary of multiple tiers and multiple machines the whole thing is an exponentially painful experience. This can be put off for a while with ever more powerful machines but there is a limit to that. 
Project naptha is cool. Still would have prefered if you at least added [PEP 20] tag to link or something. 
Hi, so now I have installed Rkernel for iPython. However, what is visible output? I have this example, but it doesn;t print anythin: df &lt;- data.frame( x = c(1,2,3), y = c(4,5,6) ) print(df) http://nbviewer.ipython.org/github/mirjalil/patt_rec/blob/master/R_ipython.test.ipynb?create=1 
I would love to see a complicated query that SA 'falls apart on' because I've yet to experience it myself and I'm beginning to think it's just a some shit people say any time an ORM comes up.
The Django ORM thinks that using 'OR' in a where clause is an advanced feature...
I've yet to see a zero-overhead ORM in any language.
⠀⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡄ ⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇ ⠀⡇⠀⠀⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡄⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⡄⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡤⠤⠤⠤⠤⠤⡄⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠀⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⣇⣀⣀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠓⠒⠒⠒⠒⠒⠒⠒⠒⠃⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⣇⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⠓⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠃⠀⠀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⣇⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡇⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⡇⠀⠀⡇ ⠀⡇⠀⠀⠓⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠃⠀⠀⡇⠀⠀⡇ ⠀⣇⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡇⠀⠀⡇ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃
You don't really have to install it in your machine's python modules directory - you can just stick "drawille.py" into a directory somewhere and be sure to import from that same directory. 
what the heck does it do ? how about a video demo ?
I can't find it in the doc. Can this visualise or draw the models?
Thanks for your advice. I will think more about that.
If all you want to is only parallelism, try out [`concurrent.futures`][1]. It’s abstracted out in the way higher level, and even [backported][2] to pre-3.2. [1]: https://docs.python.org/3/library/concurrent.futures.html [2]: https://pypi.python.org/pypi/futures
Yes, but I consider the cost for commercial projects to be well worth it.
As soon as you run any code, you have overhead by definition
Looks a lot like regular expressions, iirc it uses a markov like chain.
 这个方法能够成功安装python3.4。 但是在使用3.4版本的时候，应该输入的是python3.4 test.py 使用如下方法进入python3.4： $ python3.4
(note: this has nothing to do with python, and doesn't belong here) Running uwsgi as a stndalone http server: http://uwsgi-docs.readthedocs.org/en/latest/HTTP.html If you want to control uwsgi from the cli: http://uwsgi-docs.readthedocs.org/en/latest/MasterFIFO.html If you want to know what it's doing: http://uwsgi-docs.readthedocs.org/en/latest/Logging.html In other words, RTFM. 
Travis will let you do this, just run python setup.py sdist register upload; python setup.py bdist_wheel register upload
I picked one of my existing projects which didn't have PyQt installed, and did this: conda install pyqt Back in PyCharm, File -&gt; Invalidate Caches Invalidate &amp; Restart On restart, it refreshed all the libraries, found PyQt4, and a few minutes later had re-done all the skeletons as well and your example button shows me the click, clicked and animate methods inherited from QAbstractButton as expected when completing the button.cli ... text. If I choose one, it then places the cursor in the parenthesis and gives me a rundown of the arguments. This is almost as good as Vim ;) 
It's also possible to just use the appropriate pip binary, for when you have multiple python versions installed: /path/to/your/py3/pip install numpy I have just installed numpy 1.8.1 on my mac by using just pip install numpy from a virtualenv w/python3.4 and the appropriate pip on my machine. If that fails for you, you can use the installer binaries provided [here](http://sourceforge.net/projects/numpy/files/NumPy/1.8.1/). 
https://github.com/BinPy/BinPy#what-is-binpy
No its not, its a generic WSGI server. Python is one of (very) many applications, and this question is neither news about python nor, in fact, related to python at all. Edit: I really should say, _started_ as a generic wsgi server... since its capabilities have expanded by leaps and bounds since then.
Thanks! FIFO will only allow me to control uwsgi behavior (workers, reload, etc.) If I want to cause uwsgi to invoke my python application, how would I do that?
And what, may I ask, is the language that WSGI was created for, and almost exclusively used by? Who is it standardised by? 1. Python 2. Python 3. Python.org as [PEP 333](http://www.python.org/dev/peps/pep-0333/) (and 3333) This is the same as arguing that [Rack](https://rack.github.io/) has nothing to do with Ruby. 
I suspect uWSGI isn't as complicated as you think. Find a tutorial, there is certainly a good Django/nginx/uWSGI tutorial. Once you've got a test app up and running I suspect you'll have your answer. A simple test wsgi app is ~10 lines... Try this http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html
You could also use the Matplotlib animation module.
The scary creature called alot will haunt your dreams!
It's 'a lot' not '[alot](http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html),' ya dingus!
The scary creature called alot will haunt your dreams!
The scary creature called alot will haunt your dreams!
It's 'a lot' not '[alot](http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html),' ya dingus!
The scary creature called alot will haunt your dreams!
It's 'a lot' not '[alot](http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html),' ya dingus!
It's 'a lot' not '[alot](http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html),' ya dingus!
More like paralysing thanks to the GIL.
I am sorry I made you angry. I'm still learning. In your link it says: &gt; uWSGI natively speaks HTTP, FastCGI, SCGI and its specific protocol named “uwsgi” (yes, wrong naming choice). My question is, is there a command-line client that can talk in this _specific protocol named “uwsgi”_ to the running uwsgi server, so that I could use it to invoke my app? Using a native HTTP is not an option at this stage. 
I suspect my question isn't as simple as it may seem. I don't use Django, nor nginx, I want to cause uwsgi to call my application without going through HTTP.
I'm not mad, RTFM is a common mantra. :) Reading your original comments again, and your reply, I think I was misunderstanding what you were trying to accomplish. So you're basically looking for something that does what uwsgi_pass does in nginx, from a cli client?
so did reddit i got negative karma. Nevermind :) 
I don't know of any tool to do that, but I'm not extremely familiar with the uWSGI ecosystem. If you're feeling in the mood to send random binary protocols over cat + telnet, you might try writing your own client based on [the protocol documentation](http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html). :)
I'm far from an expert on the subject but Python is far from just a hobby language. Yes, Python can be used to script out a task on your Raspberry Pi, but it can also be used in enterprise grade software and internet applications.
OpenStack is built (mostly) in Python: http://www.openstack.org/ It's used by lots of cloud providers in the world (including my employer). Doesn't look like a hobby to me ;)
No, not in the sense that I described it won't. It does not support platforms other than Linux or allow more precise control over when the release would be made without a lot of additional work. You also can't deploy travis on your own infrastructure very easily which makes it a non-starter behind the firewall.
Great resource, but really not mobile-friendly. My phone was crunching JavaScript for over 10 minutes rendering equations before I gave up (iPhone 4, iOS 7). 
Advanced and pretty well written stuff. Thanks for sharing.
Instagram and Reddit are written in Python. Those are some sweet "hobbies".
I don't know why you're being downvoted what you said was right. I think python is a great starter language but it also can become extremely powerful. Java is extremely popular (imo) because of the fact that android is a Java stack, if it was instead using python, we would have seen more python developers sprouting up. 
http://docs.binpy.org/examples/Sequential/Counters/NBitRippleCounter.html
It's still in the development stage. Hopefully it will be able to simulate few microprocessors after this summer.
http://kitchingroup.cheme.cmu.edu/pycse/pycse.pdf (pdf version)
That's not implemented yet but yeah it's in the road map.
Sweet! Thanks, buddy. 
i read that, it's useless. still clueless what it does, what it *looks* like, 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Steiner tree problem**](https://en.wikipedia.org/wiki/Steiner%20tree%20problem): [](#sfw) --- &gt; &gt;The __Steiner tree problem__, or the __minimum Steiner tree problem__, named after [Jakob Steiner](https://en.wikipedia.org/wiki/Jakob_Steiner), is a problem in [combinatorial optimization](https://en.wikipedia.org/wiki/Combinatorial_optimization), which may be formulated in a number of settings, with the common part being that it is required to find the shortest interconnect for a given set of objects. &gt;The Steiner tree problem is superficially similar to the [minimum spanning tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree) problem: given a set *V* of points (vertices), interconnect them by a network ([graph](https://en.wikipedia.org/wiki/Graph_(mathematics\))) of shortest length, where the length is the sum of the lengths of all edges. The difference between the Steiner tree problem and the minimum spanning tree problem is that, in the Steiner tree problem, extra intermediate vertices and edges may be added to the graph in order to reduce the length of the spanning tree. These new vertices introduced to decrease the total length of connection are known as [Steiner points](https://en.wikipedia.org/wiki/Steiner_points) or __Steiner vertices__. It has been proved that the resulting connection is a [tree](https://en.wikipedia.org/wiki/Tree_(graph_theory\)), known as the __Steiner tree__. There may be several Steiner trees for a given set of initial vertices. &gt;The Steiner tree problem has applications in [circuit](https://en.wikipedia.org/wiki/Electrical_network) layout or [network design](https://en.wikipedia.org/wiki/Network_design). Most versions of the Steiner tree problem are [NP-complete](https://en.wikipedia.org/wiki/NP-complete). In fact, one of these was among [Karp's original 21 NP-complete problems](https://en.wikipedia.org/wiki/Karp%27s_21_NP-complete_problems). Some restricted cases can be solved in [polynomial time](https://en.wikipedia.org/wiki/Polynomial_time). In practice, [heuristics](https://en.wikipedia.org/wiki/Heuristics) are used. &gt;==== &gt;[**Image**](https://i.imgur.com/9tCOy2M.png) [^(i)](https://commons.wikimedia.org/wiki/File:Steiner_3_points.svg) - *Steiner tree for three points A, B, and C \(note there are no direct connections between A, B, C\). The Steiner point S is located at the Fermat point of the triangle ABC.* --- ^Interesting: [^Rectilinear ^Steiner ^tree](https://en.wikipedia.org/wiki/Rectilinear_Steiner_tree) ^| [^Quasi-bipartite ^graph](https://en.wikipedia.org/wiki/Quasi-bipartite_graph) ^| [^Minimum ^spanning ^tree](https://en.wikipedia.org/wiki/Minimum_spanning_tree) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch9cbx4) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch9cbx4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Why don't you try its documentation. http://docs.binpy.org
Regarding linear programming in scipy...a simplex method implementation was just merged for inclusion into scipy a few days ago :) https://github.com/scipy/scipy/pull/3342 
Thanks! I got it working by just uninstalling it completely and deleting anything jetbrains or PyCharm related and reinstalling. Not sure why it didn't work the first time, PyQt is always installed first on my system so it wasn't a matter of PyCharm not seeing a new package.
So is most of the python scientific stack, still. 
Ooooh! Thanks a lot! I've been trying to convince my geophys group to use more python, but the lack of good available numpy/scipy training materials was a bit of a drawback. This is even teaching me to fix some bad habits!
Worth saving. A surprising amount of recipes. Thank you!
It's coming from CMU, so you know it's good.
how much time does it take to run? [This solution](http://i.imgur.com/aCWOh8e.jpg) was "calculated" using water and soap :)
Depends on the number of nodes, and how much accuracy you want, but in general, you can think of my code a less efficient soap film ;) That picture is the same as the first image in my album.
All bad updates are ongoing. How long it has been ongoing is the measure of how bad it is.
Is that still true? I haven't had any compelling need to move to 3.x, so I haven't really even tried to keep up.
where do I write this commands?
I heard that a recent change to the compiler on OS X means that any Python package that needs to compile code will fail. I don't know what the fix is, though - I don't use a Mac myself.
Would be good collect all information of that link and create a book :) 
Not that it matters from a Python point of view, but this guy is a fairly well-known in the computational catalysis community.
You will be happy to know that they're restoring bytestring formatting in python3.5: http://legacy.python.org/dev/peps/pep-0461/ The rationale is exactly your use case: formatting was the easiest way to build up byte strings, and there is no reasonable substitute in python3.4.
If you go up a directory you can find a link to a PDF.
Zahlman: note that there is a (deferred) standards-track pep to merge stackless into cpython. In other words, the core devs like the idea, it's just that nobody has done the work. http://legacy.python.org/dev/peps/pep-0219/
http://entrian.com/goto/index.html from goto import goto, comefrom, label label .myLabel goto .myLabel 
Is there a command-line client that can talk in this specific protocol named “uwsgi” to the running uwsgi server, so that I could use it to invoke my app? 
maybe he meant that uwsgi is not just wsgi/python. It also supports lua/WSAPI, ruby/rack, perl/PSGI and some other languages to some degree.
No one is too strong a word here :)
Baffles me that it's not a series of ipython notebooks..
As a chem eng grad who likes computers, did not know such a field existed. Always thought catalysis is experiment driven. 
I gave those examples a try in PyDev and VS and they also failed to complete them. Personally I think I'll just stick to using the PyQt and Qt docs. Most things are laid out in a fairly obvious manner and it's easy to pick up the patterns in it's design once you've used it for a while.
http://curl.haxx.se/ 
How do I cause curl to issue commands in "uwsgi" binary protocol?
I'm going to assume you mean this: "I've written a script to portscan a host on the Internet. Is it possible to know what sort of firewall the host is running/behind?" and I'm relatively certain that the answer is no. If you're trying to connect to server.example.com, port 25 (for example) and a firewall between you and the server is blocking it, you'll just get Connection Refused. Depending on what you're doing this for, I would suggest using NMap which is a free piece of software that does all the portscanning and network information gathering for you. Needless to say you shouldn't be probing servers that don't belong to you or you don't have explicit permission to probe.
He wrote the source code and it works and you can see the port Filter or Open But I want to know the type of firewall marker, for example, Is this impossible 
I think that was already answered: no. A firewall that would tell the outside world what kind of firewall it is would leave itself open to vulnerabilities.
Hey did you know that Prof. Kitchin developed an awesome method to use Emacs + org-mode + Python to have his stuff organized. I'm trying it. Hope it works. https://www.youtube.com/watch?v=1-dUkyn_fZA Here's the video of his talk BTW. 
to reiterate what BinaryRockStar said, Nmap has OS/version/service detection
Thank you And I would say I am interested in my programming Security Tools using Python If there is expe take advantage of you sent me
I gather from your question that you are not familiar with the command line. In this case you probably better follow one of the other recommendations and use a ready-to-install package like [Anaconda](http://docs.continuum.io/anaconda/)
Thank you And I would say he was interested in my programming If there is expe take advantage of you sent me
Yeah. Well. I don't understand what you're trying to say. Try using English... ;)
try setting this environment var before running pip export CPPFLAGS=-Qunused-arguments
I've started on a very simple little editor/toy here: https://github.com/chozabu/KivEntEd 
John Kitchin (third talk) is also the guy that brought us the recently posted crash course on Python for engineering http://kitchingroup.cheme.cmu.edu/pycse/pycse.html
It mostly is, but computational methods are getting better. The area I'm familiar with is heterogeneous catalysis, where reactions in the gas or liquid phase are done on solid surfaces. The calculations are done using a technique called density functional theory, which is very commonly used in physics, chemistry, and materials science. If you are curious about it, you should look up the work of Jens Norskov. His work is the most influential these days. I am also a ChE. The area is pretty dominated by ChEs for some reason.
Looks like Rails is winning against Django for web development. I can't get Python to show up as a programming language. http://www.google.com/trends/explore#cat=0-5&amp;q=%2Fm%2F0505cl%2C%20%2Fm%2F06ff5%2C%20%2Fm%2F06y_qx&amp;cmpt=q
Got it working, cheers!
Isn't there a built-in virtualenv in Python 3.4? E.g. the *venv* module?
I had no idea Dr. Kitchin was so involved in the Scipy community. That's pretty amazing.
I've never actually used ipython notebooks before, are they worth using? I've been using Spyder for everything.
/u/theOnlyGuyInTheRoom posted [this pdf](http://kitchingroup.cheme.cmu.edu/pycse/pycse.pdf) that has a pdf version so you don't need the bookmark if it's easier.
Wait... People use Python3.x.x?!
There is absolutely no reason to start development on python 2 in this day and age unless you're improving legacy applications which still you should be porting over to python 3. The kind of logic people have using python 2 is near equivalent to the people that stick to Windows XP regardless of a feasible upgrade plan at their disposal. 
As a hobbiest programmer, I can say trying to use Python 3 is very frustrating. First of all it's almost never default on whatever system you're on, so you must install it. But some of your system tools are dependent on 2x so you can't remove that so you have to deal with them both on the same system. Then it's time to install dependencies. Pip install, did that install it for python2 or 3? Oh, turns out twisted or some other library isn't in 3 yet. Then every time you search for how to accomplish something, the answers you find are almost always Python 2. Sometimes those work, sometimes they don't. I always thought that the power of python was that someone should be able to start just writing things quickly. That's difficult in Python 3.
Neat concept, but if the devs can't build a decent looking website for their own web development software it's hard for me to get excited.
It won't solve all of your problems, but it sounds like you'd benefit a lot from learning about virtual environments. Look up pyvenv and/or virtualenv. 
I think it is only natural that he is in the Scipy community as he uses PyCSE as his course in CMU. It is only time when Matlab is kicked out of competition if they continue increasing their software prices and the academics will just be going to Open Source their stuff, just like how MIT does, even though they are rich enough to buy a ton of software. 
Assuming python3 is in your /usr/bin/, yes that should work (Disclaimer: I do not use shebang lines, so I have not actually tried this). In general, you shouldn't use /usr/bin/python unless you don't care whether your code is run using python 1, python 2, python 3, or (in the more-than-likely-never-going-to-happen-or-at-least-very-far-away future) python 4. If your code is intended to run under python2, you should use /usr/bin/python2 and if it's for 3, you should use /usr/bin/python3. (This way you're not stuck with the same problem when the hypothetical python 4 comes out) From the link you provide: *"Python 3 currently has less than 1% of the users of Python 2 going by PyPI download stats."* This is a misleading line. PyPI download stats are not accurate. (I'm not even sure if they're maintained anymore) In general, I disagree with the tone of that page. 
`multiprocessing.pool.Pool`s already have a [method](https://docs.python.org/3.4/library/multiprocessing.html#multiprocessing.pool.Pool.map) for that.
It doesn't load anything new on my machine. Actually, it's already present in the current view if you inspect the DOM.
I agree with many of you that the look of a website does validate the project. I think the Play Framework site at http://www.playframework.com is good on the eyes and is easy to navigate around. As for Python frameworks. I think http://falconframework.org is not too flashy, but gets the point across and any site hosted on readthedocs (like http://falcon.readthedocs.org/en/latest/ and http://requests.readthedocs.org/en/latest/) is clean and minimalistic which I like.
You don't. Throw it up as a stand alone web server- That way you can test the app* - including the routes. the quickstart guide referenced earlier here will be helpful. *You should be writing unittests
Pretty cool. Side note: [] is faster than list(), {} is faster than dict()
At least under Debian systems, `#!/usr/bin/env python2` or `#!/usr/bin/env python3` will invoke the latest 2x or 3x respectively. `#!/usr/bin/env python` will invoke the python for the system. I haven't tested it on other distros, but I think using `/usr/bin/env` allows the shebang to be relatively portable.
when doing server-type processing like this, logging is very important -- here's an example http://johntellsall.blogspot.com/2014/05/code-multiprocessing-producerconsumer.html
it's not imap - I've tried iterating over the fields using imap, iter/next, indexes. There is very little affect on the memory ballooning.
thanks! 
I commented several times the mostly same: use [`concurrent.futures`][1]. There is even a [backport][2] for 2.5–3.1. [1]: https://docs.python.org/3/library/concurrent.futures.html [2]: https://pypi.python.org/pypi/futures
Am I right if I understand it as Google Web Toolkit of Python? If so it’s pretty neat. Off topic: Is the website intentionally designed to annoy web hipsters like [LibreSSL website][1]? I am just curious. [1]: http://www.libressl.org/
Might also want to check out MayaVi2: http://docs.enthought.com/mayavi/mayavi/
I would highly recommend for 3D vector graphics.
Yes, this. There are examples for how to make movies with time varying data.
I'm using conda for this. Python3 and its libraries is put into a separate environment, that is just a "source activate py3k" command away. 
Traditionally, you use `/usr/bin/env python3`. This lets the system determine which python to use; in particular, it allows for seamless support of virtualenv.
I saw the Heartbleed fix; any other notable updates?
&gt; Why should I use an TEXT markup language to build my web application? I want to add button, textbox, form, tab... just widgets. &gt; Why should I care about CSS implementation on IE or FF or Chrome? I want to add a button here, nothing else. &gt; Why should I debug this javascript code? I just want to validate an input field. These are all valid desires, but the devil is in the details. You can't just sweep HTML, CSS, JS, and browser peculiarities under the rug and abstract them away. They're just too vast and complicated.
once there was vis5d for that
My neither haha. I prefer python -m, and if I want an actual executable, I let setuptools generate one for me (via setuptools [automatic script generation](http://pythonhosted.org/setuptools/setuptools.html#automatic-script-creation))
There's about 360 checkins on the 3.4 branch--get a fresh checkout of Python trunk and run "hg log -b 3.4" to see them.
So reddit, how does this fail at being python/When do I get to see this crash and burn? 
As far as I can tell, this doesn't really do anything new. It looks like a simple wrapper around [Skulpt](http://www.skulpt.org/) to me. From a quick glance, it looks like their company is dedicated to better tools for education. Seems like a cool company, but as far as a unique python project goes, this falls short. Am I missing something?
I've put simple CLI wrapper. Maybe somebody need it (I need): * https://github.com/onjin/pgextrascli
Got my hopes up that I'd be able to use this to replace JS in my apps 
At a cursory glance, doesn't seem as feature-rich as some of other sites I've used like wakari.io and cloud.sagemath.com.
What confuses me is how this is at all an attractive alternative to IPython Notebooks. If anything, I think an IPython Notebook is a better education tool since it allows breaking apart code into steps to be incrementally taught and run.
I haven't tried it yet, but I've heard [PyQwt](http://pyqwt.sourceforge.net/) is a good tool for real-time plotting. Looks like there are also bindings to QwtPlot3D.
Don't bother trying to build it yourself -- [there are precompiled py-bcrypt binaries for Python 2.7 on PyPI](https://pypi.python.org/pypi/python-bcrypt/0.3.1). You can either download that directly and run it, or just use `easy_install`. If you really want to download VS2008 express, there are [plenty of working links](http://stackoverflow.com/questions/15318560/visual-c-2008-express-download-link-dead). Just google. 
Python 2 and 3 revised to be cross compatible 
I suppose, but in my mind, "rate limiting" implies you can write a construct such as while active: foo() and it will then sleep until the required amount of time has passed, thus limiting the number of calls to X per some_time_period.
Yeah, this is semi-related. Having a browser experience before going through all the hassle of downloading and configuring something can be helpful in getting folks to learn about a tool. I used to be a big user of PIXLR which is basically an in-browser photo editor. When I got proficient at it, I was able to transition much more easily to an application like GIMP because I got the basic concepts and I *wanted* to learn more so that I could figure out how to do the fancy things that were more difficult to do in a browser. I look forward to seeing where this goes. 
You're right that this isn't remarkable as a Python project on its own- Skulpt really laid the foundation tech wise. But at the Pycon education summit this year (and elsewhere at Pycon) there was lots of talk about how horrible the first-time experience of Python is for beginners. That's the problem we're trying to address with this tool: giving students a positive experience at the outset so they're curious and motivated to learn the rest of Python. It's easy for us to forget how bumpy the on ramp to programming can be once we're able to teach ourselves what we need to know.
Change log: https://docs.python.org/3/whatsnew/changelog.html
Your experience is not uncommon. The way I've started talking about it is as a 'teaching stack'. You have different stacks for different purposes. This embeddable iframe is extremely lightweight. Great for some situations. For teaching advanced students you'll want something pretty much indistinguishable from a pro dev environment. IPython is kind of owning the middle ground right now, but it's not a smooth transition. As a community we can do better, starting with curating and building teaching stacks that best meet the needs of different groups of students. We decided to start with beginners who need to learn builtins.
Yes, but more importantly it reduces the overhead costs of just playing around with Python from setting up the Python interpreter/editors/etc. to opening a web browser. That's pretty powerful, especially considering how intimidating that experience can be for a novice.
In a class of ~25 students I'd say 3-10 will have major problems, sometimes novel problems I've never seen in getting Python up and running as needed for class. One time someone couldn't pip install anything because of spyware I had to uninstall for them. These problems are largely on Windows machines but occasionally we'll have trouble with macs having 2.6 and not wanting to upgrade. All solvable problems, but 1 hour of install problems before ever printing hello world will evaporate enthusiasm and destroy confidence quickly.
Thanks for the suggestions! Saw a dft textbook on JKitchin's group site. Maybe I will have a look.
Ahh ok, that makes sense. Yah, with all the versions and resources targeting them, it can also be confusing at times. Thankfully I've never had any real problems getting stuff to work on my Windows machine, but I could see someone that hasn't done things like that before getting frustrated. I thought you were saying the actual coding part could be frustrating. 
I use Mac OS X, which has Python pre-installed, but I only used the system when I first learned Python and then I installed 2.5 (this was when 2.3 was standard, I think). I don't think having to double click a download is a huge deal as far as it goes. 
I agree that Python is the best first language http://blog.trinket.io/why-python/ :)
i tried importing os. no luck :'( :'( but cool. always nice to see more python stuff making the rounds
As an educator, I can appreciate the idea of "no-hassle python installation", but I feel that we already got that experience with the Python Tutor. Could you compare what this has to offer with that?
WSGI is the web service gateway interface; its designed specifically to allow you to interface to an application via HTTP. If that's not what you want to do, then uwsgi isn't for you. 
and all of it easily done if you just send all your data to a third party! I seriously don't get why anybody would use plotly for anything other than toy projects to put on a blog.
That's the new stuff in 3.4.0 though. 3.4.1 vs 3.4.0, the list is a lot less action-packed. Someone else posted the changelog list, which is probably the best resource for those changes.
A list of "hobbies": - Youtube: http://highscalability.com/blog/2008/3/12/youtube-architecture.html - DropBox: http://highscalability.com/blog/2011/3/14/6-lessons-from-dropbox-one-million-files-saved-every-15-minu.html - Eve Online (game): http://highscalability.com/blog/2008/10/22/eve-online-architecture.html - Second Life: http://highscalability.com/blog/2008/12/20/second-life-architecture-the-grid.html - Instagram: http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances-dozens-of
vincent, bokeh, python-nvd3, etc etc etc. There are a LOT of python libraries out there that let you do rich javascript rendering of plots. Most of them use d3.js in some way or other.
Python is great for getting quick scripts up and running. 
Easy to understand, and even a noob like me who knew nothing about programming can pick it up easily. 
&gt; multiple for-loops ... I know they become memory-hogs very quickly. def file_move (file_list): for file in file_list: for name in file_name: if str(name) in str(file): shutil.copy(file, out_dir) Please explain the 'memory hog' thing in the code you provided above. BTW no need to convert to str if they are already filenames and you probably don't want to shadow the built-in `file`.
I have intalled sticky with the setup.py install comand, but when I run the first cell of the sticky_example notebook I get a "TemplateNotFound: micropolar_widget.js" exception... Does anyone had an idea how I could solve this?
It sounds like you haven't used Ansible, though.
I'd like to know too, although I haven't tried that hard, but hopefully he will update his readme!
I haven't messed around with asyncio a lot, but from what I've seen, it's much more decorator based than your examples. When you decorate a function, you've essentially created an anonymous callback and passed the callback immediately into the function that requires it. Of course, they key differences between this and 'real' anonymous functions is that you've also named your function, and it can also be used to 'decorate'/modify functions as well. You know, just on the side. Decorators are quite a cool syntax. Rewriting your code in that style (with no idea how asyncio actually work) would probably look something like this: @parallel_for(4) def calc(i): print(compute(i ** 2)) This is a line longer than yours, but, depending on how asyncio works, you may still be able to reuse the `calc` function, and the scoping is more defined, iirc. (With-blocks leak their contents, don't they?)
There is honestly no _big_ problem with functions. However, I find it easier to understand a program if the control flow is continuous and I don't have to jump from A to B. If a function could be called `_` it should not be a function, IMHO.
What I like about Python is the "batteries included" ideology behind it - you have a lot of libraries already included to accomplish a lot of stuff. As well as that, I like how easy it is to include an external library by installing it and using "import blah". In languages like C/C++ you have to link a library in, and there's a lot of messing with include paths, library include paths, etc. It's doable, but with Python it's easier.
I don't think it's unpythonic to have to name all of your anonymous functions. Redundant, perhaps, but not necessarily unpythonic. Of course, there are ways around this. Functions can redefine previous variables, so you could name all of your functions `callback` if you knew you were never going to use them again. Or even name them `_`, although that would probably end up looking quite messy and unpythonic. Alternatively, you could use the function name as a brief documentation summary - what's the one word you would use to describe the action that this callback is going to do? Yes, it's not truly anonymous, but I don't think it hurts at at all for readability and comprehension. It's also immediatly obvious that what you're doing is a function of some description, which isn't necessarily true for with-blocks.
&gt;I wouldn't use 'with' because that implies some code running before and after (enter and exit functions, like file open/close), not iteration In his defense, I thought it could be kind of cool if you wanted an implicit join. It would be a nice way to implement embarrassingly parallel code.
You can certainly own knowledge. It's called "copyright" and "patents". I don't think those things are a good thing, but they certainly are the law of the land.
Looks like a dirty hack to me. Either way, as long as you have a syscall that creates a thread/process and inherits execution context from its parent, creating such a context manager is trivial. [A UNIX-only example using os.fork.](https://gist.github.com/pyos/7509877ef20776ece95a)
You are right, the statement is too general. But lambda isn't perfect: 1. expressions only (e.g. no assignments) 2. single line only
You shouldn't refer to concurrency and parallelism interchangeably, that's two very different things. Here's [one post](http://www.yosefk.com/blog/working-simultaneously-vs-waiting-simultaneously.html) about it. gevent, asyncio etc allow concurrent, not parallel execution, "waiting simultaneously" in Yosef's terms. Your task initiates a potentially blocking operation (like sending a request to a website), but instead of blocking it returns to the eventloop, which runs another task until it blocks, and so on, and would resume our task some time after it receives the response from the website. One of the main benefits of this concurrency model (besides efficiency at waiting for a shitton of stuff simultaneously) is that it requires almost no synchronization since no code actually runs in parallel. However there's a catch, whenever you yield control back to the eventloop other code _can_ run, and change stuff. So you might need synchronization after all, or at least think about how to write code not requiring synchronization. As a stupid example, in your website-pinging scenario you should **not** take the current average ping time _before_ you send the request, then compute and store the updated average after you receive the response. So a more correct way of putting it is that this kind of concurrency provides an advantage in that you clearly see the points in your code where other processes might run and synchronization might be necessary. But to take advantage of this advantage you must, indeed, be able to clearly see this stuff. If an async library automagically intercepted all blocking calls and converted them to returns-to-eventloop, we would be back to square one, since now every function call could potentially contain a blocking function call somewhere inside and thus allow our code to be pre-empted. This is why all async libraries use some kind of an explicit syntax, be it callbacks or coroutines with "yield/yield from" in asyncio. This is not an oversight, this is by design. I don't see how with-based code blocks could provide readability benefits when used that way.
I don't think those things are good either, specially for patents. But with copyright you don't own knowledge, you own creations of some sort. Copyright is used to get money from intellectual property, probably not the right way (because, too often, the creator doesn't get enough money out of his work...). But intellectual property is a good thing.
&gt;If a function could be called _ it should not be a function, IMHO. Then what should it be? A function is a basic execution block. What you probably want are anonymous procedures, i.e. nameless "functions" that may contain multiple statements. I'd agree that they would make some things clearer, if not for one problem: how do you make an expression (and an anonymous function/procedure *has* to be an expression) that contains an indented block (we're not going to introduce braces into Python, right?) in a language that uses parentheses for function calls? parallel_for(xs, lambda x: x += 1 print(x)) IMO that's awful. Maybe something similar to Ruby `Proc`s? parallel_for(xs) somekeyword x: x += 1 print(x) That may look a little bit better, but how do you pass the result of `parallel_for` to *yet another* function? Related: [dogelang](https://pyos.github.com/dg/) has multi-statement anonymous functions, but it uses whitespace for function calls, not parentheses and commas: yet_another_function $ parallel_for xs $ x -&gt; x += 1 print x
Concurrent and parallel and indeed not one and the same (although execution can be concurrent AND parallel at the same time), i changed `parallel_for` to `concurrent_for`. Regarding explicit constructs: `gevent` handles concurrency implicitly inside of Greenlets. One might argue about benefit of such design, but many people find such abstraction a good thing. My proposal was aimed towards a anonymous block constructs in python. Concurrency was used as an example. Both decorators and context managers can explicitly state that a code block will be run concurrently. 
I meant a _ function should not have a name at all, since it redundant. You outlined quite well the problem with multiline anonymous functions/blocks in python. Naming functions can have benefits, but often its just a typing exercise and pollutes the namespace unnecessarily. EDIT: the ruby solution come quite close to the proposed while solution and it would indeed be better it there was a separate keyword for it. But chances of it happening in the near future are quite slim.
Yes it can be done using PhantomJS API. See this page for more details on using a wait. http://www.princeton.edu/~crmarsh/phantomjs/ Or You can use window.setTimeout(). 
&gt; single line only You can break lines anywhere you want in Python as long as it's inside a balanced context (i.e. [], (), {}, etc.) This is perfectly fine: y = lambda x: (3 + 12 * x + 42 * x**2) 
I wanted to do that at first but it would kind of compromise the ability to use the script as a standalone kind of thing... I don't really feel good about having it there either, though. I'll probably change that later today! **edit**: **Fixed it, API key is now loaded from config file.**
I never actually thought about it, but you are obviously right! 
Information, including movies, music and books should be free. Actors, musicians, and authors are rich. Why should people like me who are struggling have to pay? I'm still angry that 2scoops 1.6 isn't available for free like 1.5. It's hurting developers like me.
not for plotly
I think the latest version of vincent is broken.
Here's an IPython Notebook I saw just yesterday that tries to compare them all: [Up and Down the Python Data and Web Visualization Stack](http://nbviewer.ipython.org/gist/wrobstory/1eb8cb704a52d18b9ee8/Up%20and%20Down%20PyData%202014.ipynb)
That's a nice idea. I wish there was an embedded javascript engine inside Python, it would make much easier, nicer and more pythonic to scrape the web using python only. Maybe I'll take that as a project sometime, it should be interesting... 
"After a brief searching around, it appears to be unlikely that Python on its own will cause the BSOD and that it's likely to do with my system. " Yes I agree. I don't think its python related. My first guess would be a a memory issue. I would run some program that will give your ram a workout and see if the problem pops up. Id recommend [memtest](http://www.memtest.org/) grab the bootable iso and boot off the disc and run the default test. If it finds any problem with your ram it will display the bad sectors in red text.
Would one reason for using this not be the fact that it provides 'true' random numbers, compared to Python's pseudo random module? Also, according to the documentation, that module is not suitable for cryptographic purposes either. What module would be suitable, then?
You can try installing it through chocolatey - https://chocolatey.org/packages/VisualStudioExpress2008
Good god why.
I guess this: *[arr for arr in in_memory_arrays] 1. Creates a list (quite a lot of memory) 2. Expands the list - probably the same memory again. Can you replace it with memory_arrays
All BSODS have a crash reason. You can see it in the blue screen message and sometimes you can find in the event logs. Sometimes it's relevant, sometimes it's too vague. That goes without saying about how vague your question is ;)
yes, I am familiar with how IPython notebook works. Are you familiar with how plotly works?
Exactly !. There should be an embedded Js engine inside Python which will make the task easier.
If you're using VS, you have to use the same version that was used to build Python, and for 2.7 that is VS2008. The issue is the C runtime library. Python will be linked against `msvcr90.dll`, and if you try to build a module with VS2010 it will be linked against `msvcr100.dll`. If you load the module you get two different and incompatible versions of the runtime being loaded, which is not supposed to work; maybe it does by luck in simple cases, but it's not guaranteed. MinGW links against the "system" runtime (`msvcrt.dll`) which is designed to be usable alongside a VS runtime, since you can't have system components that depend on a VS runtime that might not be present. I'm not entirely sure that this is completely safe -- you might still run into problems if you try to do things like pass an object managed by the runtime (e.g. `FILE *`) between the module and Python.
A good question: what ís a function, and what not? Functions are used for two purposes: carrying pieces of code around and being able to repeat something with a different input. In this case, you do both: carry a piece of code around and run in another thread, and change the input every time. So, the usage of functions is a a logical step. Your proposition is to skip the function. However, the code should still be carried around. The commands within the 'while' code block therefore have to be saved to a function somehow either way... 
I wasn't clear: if you name your function `_` you might as well not name it at all. Of course you still need a construct which holds your code (call it function, block or context).
Use random.SystemRandom() or os.urandom().
It's also easier to then leverage the code from those scripts in more substantial applications. Very large scale tasks can share code with very small scale one liners from a python shell.
This. I like what Plotly is doing, and I see a lot of people raving about it, but I don't see how anyone would trust putting up their data on some random cloud service. There is no way I could use it for anything work related, and if I'm doing it for fun, I don't really care much about my plots looking pretty. I'm sure there is a niche market this serves, but unless they provide a way to use it locally (have a local plotly server like the iPython Notebook server) it will remain a nice but useless service.
In my experience with NLP, there was lots of iteration needed to get things working just right. This falls right into Python's wheelhouse. Just write a script to scrape your data, and then you can play with it from the command line to get a feel for how to do what you want. A few go-to libraries for this kind of stuff are -requests/BeautifulSoup for getting and parsing html. -NLTK for the NLP -possibly matplotlib for any figures you will want to make.
The same can be said about 'if/else/while/for' block. If all those construct don't have to be turned into a named function as soon as they need two lines of code then I guess we can cope with user-defined anonymous code block as well.
Movies, music and books (I think you mean fictions) are not information but either entertainement or art (or both). Information is essential, that's why nobody should have to pay for it (everything in 2scoop can be find on the internet, but you have to pay the work to gather information for you !), but art or entertainement are not : you don't need those to live, so you have to pay because nobody will work for free. Will you work all your developement time for free ? I think not. Saying that actors, musicians and authors are rich (e.g. all of them) is stupid : for those who are rich, it's because they've been paid in the beginning, otherwise they'd be poor. Even so, you think that once you're rich you never have to be paid again ? Think deeper about the distinction between knowledge, information, entertainement and art : these are not all the same thing, and thus should not all be free. Do your homework and check how rich are average artists you'll see they're not that rich... Nothing is free, if it is free then the sold product is you. That works for open-source as well : you are paid with social recognition.
I ran memtest by bootable USB and made it through one pass. 
Yep. In asking this question, I'd like to, I guess in a way learn the approach of dealing with blue screens and finding out their cause. As malice8691 suggested, I ran the memtest and no errors came up. What should I do next?
Example for people who can't imagine why having multi-line code block is beneficial to programmer. This is Python where multi-line code block can only be a named function (and class): def do_something(): x = calc_x() y = calc_y() def x_gt_y_true(): ... do thing when check is true.. ... one more line ... def x_gt_y_false(): ... do thing when check is false.. ... one more line ... if(x &gt; y): x_gt_y_true() else: x_gt_y_false() def process_arr_item(item): ... do thing with an item ... one more line for(i in arr): process_arr_item(i) If you think that it looks ugly, ask yourself why only built-in code block can have multiple-line. Why we developer is too retarded to handle this powerful multi-line code block, and only Guido is wise enough to design just the right amount of construct that should be able to contain more than one line of code in it? If you honestly think that it looks okay and doesn't hurt readability at all, why not push Python to only have it this way? Do you code this way currently?
Ruby uses blocks extensively, and they are commonly listen as Ruby programmers' favorite aspect of the language. They are really very convenient to use, and they allow for some cool design patterns. Python should implement something similar. 
I liked [Dive into Python](http://www.diveintopython3.net/your-first-python-program.html). It doesn't waste time explaining what a variable is or teaching you about for loops. Instead each chapter starts with a fully functional program that will then be dissected line by line.
:D yeah i wanted to import it to see if i could get to the underlying system :P Good move restricting that ;)
&gt; But with copyright you don't own knowledge, you own creations of some sort. And the difference is....? &gt; But intellectual property is a good thing. The expression "intellectual property" is a smart move by lawyers to make it sound like property. Which of course it isn't at all. If I copy your stuff you still have your stuff. It's not at all like property in any way. The only part of IP law that I recognize as having any worth whatsoever is trademarks. But that's really just a subset of the law protecting truth, ie "this thing is made by company x".
+/u/dogetipbot 100 doge verify
ProPython is great for the intermediate Pythonista 
The example you posted is a bizarre [strawman](http://en.wikipedia.org/wiki/Strawman). Of course what you wrote is not ideal code, but you did not make at all clear what aspect of Python forced you to write that in the first place, and how multi-statement lambdas would help.
He's trying to say that not having code blocks is like not being able to write that code the obvious way, because every chunk of code has to be a named function. Python has code blocks for a set number of control flow structures, but you can't easily define your own things that take a code block. It's hard to imagine what Python would be like with code blocks, but here's one attempt: df = pandas.read_csv('foo.csv') using namespace(df): # This will create a new column sales_amount = price * quantity And another using a completely different kind of syntax: sorted(rough_version_nos, key=!x: if isinstance(x, str): return -1 return x )
Knowledge is objective : it's a fact, no one can own pythagorean theorem or relativity theory ; it's in the world wether you know it or not. An event is knowledge (like the WWII, or Kennedy being killed). Creation is the result of imagination, creativity, invention : music, Mona Lisa or spiderman, it's the product of an artist mind and therefore belongs to him. I know "intellectual property" doesn't mean property like "house property" (obviously...) but that's actually the point ! It's not a lawyer move it's a way to say : "well, I created this so you can't do wathever you want with it, so back off" I'm french and in my country you can't sell intellectual property : if you create something it's yours, you can't say someone else created it and that's what I meant. Trademarks are irrelevant here...
[This](http://exercism.io/) is a great resource for practicing python once you've learnt the basics of the language.
&gt; lambda x, y: (lambda x, y, f: f(g(x, y), y, f) if x &lt; y else x)(x, y, lambda x, y, f: f(g(x, y), y, f) if x &lt; y else x) I think you may have just awoken Cthulhu with this..
Trust me - writing non-trivial logic inside of a lambda requires hacks galore - joining expressions with **and** and **or** to simulate conditionals &amp; having to jump through nightmarish hoops to loop are just a few parts of it. The limited practical usefulness of Python lambdas isn't really up for debate - it's a fact. Whether or not Python needs more expressive anonymous functions is debatable, just don't waste your time defending the existing lambdas.
Author here- sorry about that, looks like I missed the include_package_data keyword. Give it another go on latest master?
Random being what they tell you. Might as well call the NSA and ask them what's their favorite number.
I second ProPython. The author really delves into all kinds of useful things for a Python programmer to know.
Cool, I thought this project had been abandoned.
[working link](http://nbviewer.ipython.org/github/wrobstory/pydatasv2014/blob/master/Up%20and%20Down%20PyData%202014.ipynb)
&gt; OK OK, I couldn't resist that title but it probably goes a bit far. Let me try for a little more nuance: &gt; &gt; PyPy.js: Now faster than CPython, on a single carefully-tuned benchmark, after JIT warmup. Clickbait title, but the blog author does acknowledge it. The qualification should go without saying but I thought I'd copy it here.
&gt; It's hard to imagine what Python would be like with code blocks why is it hard to imagine? I think it would probably look an awful lot like ruby with code blocks. Python and Ruby already have some similarity in their syntax and language design. Borrowing a language construct from Ruby is pretty natural for Python. ['a', 'python', 'iterable'].each( x: # multi-line code block here ) 
Ok, pip installs should be good to go again. 
Thanks for the info, hopefully those libraries will be helpful! Scraped data, for the most part, will be relatively free-standing, but it will still be associated with different items (data associated with different queries to define what is to be scraped). For this, is MongoDB still good? Or would a relational database be a better choice possible?
I think the idea here is that the value can change based on external state (in the same way that properties of classes might have a different value based on the state of other encapsulated value in the class). It also gives you an opportunity to trigger some code execution when the value is set or retrieved.
Concurrent (or parallel) tasks are important enough that they should be advertised with named functions. I'd hate to read a code base littered with anonymous functions or code blocks that will be executed across multiple cores or executed asynchronously with an event loop. Code blocks and multiline anonymous functions only provide better readability, in my opinion, for very unrealistic trivial examples like your i ** 2. Even so, is this code *really* crying out for an anonymous function or a code block? from concurrent.futures import ProcessPoolExecutor def square(num): return num ** 2 with ProcessPoolExecutor(max_workers=2) as pool: print(list(pool.map(square, range(1000)))) 
Thank you so much for this project. I invested a lot into MATPLOTLIB and I know many others have also. So I wish this project would get much more traction and support. It just doesn't make sense for me to learn yet another plotting api. For serious work, I also don't know why people or their company would trust to use a cloud service. I am an intermediate Python programmer and so don't know how I can help but use mpld3 more and report bugs or submit suggestions. Just wanted to say thanks.
You're comparing anonymous code blocks to basic control flow and conditional statements. I think that's a bit of a stretch.
Does this have anything that http://pyvideo.org/category/50/pycon-us-2014 doesn't have? 
FWIW, Python is too invested in duck-typing to use attributes here. It'd be more like each(['a', 'python', 'iterable'], x: # multi-line code block here ) But that's pedanticism.
If I understand you correctly, what you're saying is that properties should only be used to set and retrieve values, performing no other operation, is that correct? If that is what you're saying, what would be the value of a property with getters and setters over simply accessing fields directly? Why would we use properties at all?
Can you give a real-world example where anonymous functions improve readability?
Check the windows system and application event logs for any errors around the same time as your bsod. 
Hah, thanks. When you say all the libraries I'll need, does that include plenty of libraries with NLP tools and scraping tools?
no, that would create a tuple with one element in, which isn't what I want. what I should have done is just imap(None, *in_memory_arrays) (or zip(*in_memory_arrays) if I didn't mind about evaluating everything in one go.)
The only solution that I have come up with so far is to keep the file open, but not load all of the numpy arrays into memory. Instead take a slice of all the fields and place into numpy array created specifically for the slice of all fields, and yield the rows of this numpy array\*. However, this means the h5py File must be open for at least as long as the generator is needed so encapsulation isn't great. \* so this in effect avoids many fragmented instantiations of small list()s and replaces them with a contiguous block for an ndarray. yielding the rows of this array doesn't copy anything (I think)
To continue the theme: http://www.reddit.com/r/programming/comments/24w5gv/go_deh_python_pypy_interpreter_in_javascript/
Dude - [it's run client side using javascript](http://www.skulpt.org/). The only person you can hurt is yourself, and even then, it's only through the same ways you could using javascript.
Ah, cool. I didn't catch that it was running skulpt. I only executed a handful of commands and moved on with life ;)
PM sent
code at https://github.com/bVector/tailcolor This is still a work in progress, but it works fairly well. I plan to add support for just piping stdin so you can just do tail -F whatever | tailcolor. 
look at those colors fade!
I'm talking more about unexpected side effects, a property is useful for creating shortcuts to calculated values, e.g. @property def fullname(self): return "{} ({})".format(self.name, self.id) or things like that but hiding execution behind something that should be data just to save two damn characters is retarded. I think a better question is why would you replace methods with properties?
For me it was probably the moment I started putting my small scripts in packages rather than individual files. Oh the joy in not needing to copy paste files for importing all over. 
I found your link to have more videos than OP's.
The startup costs in chrome is interesting. I can envision the LLVM bytecode being like "Yo V8, I heard you like compilers. So I ran a JIT compiler in your JIT compiler so it can optimize while you optimize."
Virtual environments.
I didn't really intend it to be a replacement of Python's random module. I wanted something to easily print some random numbers/strings to stdout so I could pipe them through to other applications. I always see my professors use random.org as their go-to resource for random numbers (for example to use as samples for bayesian inference) and I figured this would be an easier, more accessable way to the service.
&gt; A Virtual Environment, put simply, is an isolated working copy of Python which allows you to work on a specific project without worry of affecting other projects. For example, you can work on a project which requires Django 1.3 while also maintaining a project which requires Django 1.0. *[Source](http://docs.python-guide.org/en/latest/dev/virtualenvs/)* I run multiple instances of web applications on a server and keeping them all updated simultaneously is somewhat difficult the more complex they become. Keeping them isolated from one another means I can work on them one by one without risking downtime for some while catching up.
Can you elaborate? 
Especially this for me. Most Linux distros have version 2.7 as the default, but I have moved on to using Python 3 for my work, so setting up virtual environments is a blessing for me. Also starting out, I wish I knew of built-ins like dir() and help() sooner, saved me so much time from having to go to the docs since I use VIM and not a doc-aware IDE.
pep8
You ought to include a license (BSD, GPL, etc) for your project, otherwise its meant to be a private project (from a licensing view)
Are virtual environments really necessary for someone like me who exclusively develops on his/hers own computer?
They will be if you ever intend to release a package and need to isolate out the dependencies from all the other stuff you've accumulated.
I used to use Java and then when I tried to apply Java for exploratory data analysis, boy what a pain it is due to its OOP boilerplate. So I switch to Python with IPython [notebooks](http://nbviewer.ipython.org/) and couldn't be happier. I think exploratory data analysis is an area where Java or any other statically typed OOP language can not come even close to making data analysis easy. It's been 4 or 5 years since I've used Java, but out of curiosity I've actually searched recently for any recent developments for data analysis in Java world, but nothing still. Not sure if there's anything in PHP world like IPython notebooks.
I wonder if it's worth looking at pandas ?
I'm guessing the second pass and reparsing is the dips main hog wrt chrome. Direct to memory write buffers from asm.js would be tight but that turns the browser from a sandbox into desktop app. IANA security guy so I would wonder what that imposes on the browser devs
&gt; or things like that but hiding execution behind something that should be data just to save two damn characters is retarded. There are plenty of systems that work that way. A wide range of web frameworks for instance which is where that pattern originates. It allows you to isolate memory across different threads without having to pass through state objects to all your program.
You use a lot of aggressive and unwarranted language when you communicate (like calling a methodology you don't find useful "retarded") which is really off-putting. In any case I'll continue the conversation in the interest of enlightenment. Suppose you have a module level variable (common practice in python) that should be importable and reusable, but without deterministic value. How would you represent that without having to manually invoke a method every time? For example, in the very popular `Flask` framework, there is a module level variable called `request` which allows you to get the request from inside a view function simply by having that value imported into your module. from flask import request ... #other stuff @app.route('/my_route') def my_route(): return 'Hello, ' + request.form['name'] `request` is likely to represent a completely different instance of a `flask.Request` object every time. While we could use `get_request()` function and then invoke this function manually inside every single view of our entire `Flask` application, it would be a lot of repetition of essentially the same pattern. In some frameworks/languages/tookits we'd use Dependency Injection to resolve this redundancy, but because Python is an amazing language we have options that allow us to be more expressive in our solution.
Yes, please elaborate? 
By having them as packages and installing them, you can import your scripts from wherever in your Python IDLE, not having to deal with being in the same folder as the file itself, etc. 
I thought it was basically Python with static typing (and minus a few features). What other serious niceties does it offer?
When I first started using python I had a real trouble trying to install pip. I never felt like a bigger idiot when I ran setup.py 
Making virtual environment isn't an absolute necessity. It all depends on your situation. If you don't see the need, then you don't have a need. No one is forcing you to make virtual environments. If you do have the need, don't worry, you will find out why you need it. I really don't see the fuss why people who don't understand the need for virtual environment, even question why such things as virtual environments even exist in the first place. It's not like people go around making Python libraries and tools all nilly willy for nothing.
&gt; You use a lot of aggressive and unwarranted language when you communicate yes, I don't think much about the way I talk here since I don't consider it a "formal" environment but you're right, my apologies. &gt; How would you represent that without having to manually invoke a method every time? why wouldn't you do just that? if you NEED a module level variable that isn't deterministic isn't much more clear to have a callable that returns something? you know it's always the same callable but the result may not, you *expect it* to work that way and I still see no advantage in hiding all that besides typing a few extra chars. as for the Flask example I would advice exactly what you said, a `get_request()` function or if you don't want that, pass it as an explicit parameter as Django does, either way there's no surprises.
I don't see the connection between using a method as an attribute and that you've mentioned, I assume you mean to create a new instance or make a new call for every access to a given function which is what the article suggests but please if you don't mind explain it a bit further. my point is: if you're doing that you should NOT hide it, if I see an instance or a module attribute I don't expect any of this, nobody does because that's not the way it works normally and if you don't, can't or won't make it work normally then you should make it explicit to avoid surprises due to unexpected effects in places where you don't usually look for them. I'm not saying the technique isn't valid, I'm saying that masquerading it just because you don't want to type the parens is really unnecessary and can be problematic.
Ah, much like you would download, say, numpy. Cool. I use PyCharm and just add the library to my path so I can import them right away.
Someone already said virtual envs, so I'll go with my second favorite, context managers. A well crafted context manager class can eliminate try catches and loads of nested code.
I'm just trying to understand its popularity. 
Hey, no need to say sorry. I say thanks to you good Sir.
That looks like exactly what I'm looking for. Interactive plot without needing a whole different plotting language.
[Bokeh](http://bokeh.pydata.org) lets you run your own server. 
sorry for bothering, but im trying doing this: import vincent vincent.core.initialize_notebook() vincent.initialize_notebook() area = vincent.Area(df) area.colors(brew='Spectral') area.display() And its not displaying anything. Is there a change in the api on the last update?
It's a big deal for professional developers who need to keep all their dependencies sorted out on a per project basis. It's not really important if you're an amateur. For example, if you ran websites A, B, and C, you'd need to know what the dependencies of each are, so you can deploy them to your host after you finish development on a feature, and you'd want to keep it all separate, so you don't mix up version 1.2.3 of `footool` for site A with version 2.3.5 of `footool` for site B. It's also important to list your dependencies if you release an open source tool, so other people can install it.
Python modules aren't normal objects, so it's a bad idea. If modules were just instances of a built-in class, sure why not add properties?, but they aren't, so you shouldn't. 
For compactness and style, One line List comprehensions let me do crazy stuff in one line. made stuff a lot more compact and easy to store, in stead of requiring a for loop and stuff. 
I think the average person is who should be MOST interested in it. I'd consider myself the average person, and I'd much rather just learn how to use virtualenv than potentially have to manually juggle conflicting package versions. 
Just try to balance future readability with current compactness. I'm not saying they're always bad, but I've inherited some gnarly one-liners in my time. 
Asserts and other error checking tools.
Do you mind elaborating a bit more? For starters, is your point that you're generalizing your scripts to be less task-specific (and thus more generalized/reusable), importing your scripts, and then calling them with a couple of extra task-specific lines of code? 
Windows. 
Oh, I never take it too far, I always make cohesive logical steps so i don't do everything and it's mother in one line as well. 
Havent used cython before. Will take a look. 
If you have a moment, can you explain context managers? Or supply a source in which I might learn? Thanks!
I used setup.py develop and it worked fine
Great to see this project still going. Will this help build cross browser isomorphic python apps for the browser at some point? 
Mutable vs immutable, especially as defaults to methods. Debugging when you don't know why a variable is changing is a bitch. http://docs.python-guide.org/en/latest/writing/gotchas/#mutable-default-arguments 
It have just started using it recently. It's just awesome. In the article above, I was able to speed up the code for a simple least square linear regression fitting by 8000%. And the cool thing about Cython is that it really is no extra effort.
pycharm / intellij idea + python plugin does a good job of pointing out pep8 guidelines as you code. I'm not sure if this is the case with other IDEs.
Checkout r/learnpython 
/r/learnpython ***** [^report ^a ^**problem**](http://reddit.com/r/LinkFixerBotSnr) ^| [^delete ^comment](http://www.reddit.com/message/compose?to=LinkFixerBotSnr&amp;subject=Comment%20Deletion%20%28Parent%20Commenter%20Only%29&amp;message=%2Bdelete+chbjojr) ^| [^source ^code](http://github.com/WinneonSword/LFB) ^| [^contact ^developer](http://reddit.com/user/WinneonSword)
Can someone explain what machine learning is
I'm happy it's about to again, but this will be a 30% raise.
Awesome, I should have figured there was a sub for that, haha. Thanks! 
Eh I did the same thing
hmm, the examples are working. Guess its something on my data frame. Just to be sure, the format of a pandas df need to be with *-numerical index* *-each series on a column* is that right?
Yeah, that's how it should be right now. I *really* need to revamp all the data handling to make it very clear what schema(s) will work, and to allow you to easily switch between wide and long(tidy) data. 
awesome, you managed to make the nicest looking python plots i have ever seen. 
As a guy that started learning python 6 days ago, this couldn't have come at a more opportune time. Thanks and would you be willing to mentor a bit if J had questions? 
My goodness. I can see the potential headaches coming from that. Thanks for adding this.
Context managers supply two methods, one of which runs before a with block is entered and one of which runs after the with block is exited - be it by normal execution or exception. For example, I recently wrote a "MountedImage" context manager. This guaranteed that the disk image was unmounted on both success and error. Another common use case is with open("filename") as some_file: do_stuff(some_file) # file is closed here, even if do_stuff throws Python documentation has some good information: https://docs.python.org/2/reference/datamodel.html#context-managers
- [Py2 context lib](https://docs.python.org/2/library/contextlib.html) - [Py3 context lib](https://docs.python.org/3/library/contextlib.html) - [Intro to context managers](http://eigenhombre.com/2013/04/20/introduction-to-context-managers/) - [Examples to learn by](http://preshing.com/20110920/the-python-with-statement-by-example/) Basically a context manager allows you to define some entry and exit logic to block of code using the `with` keyword. The basic example of this is: with open('output.txt', 'w') as out: out.write('Hello context!') This puts the dirty error and closing code behind the scenes. It becomes especially nice when you want to nest temporary objects that would normally each need try-catches.
Ehm, let me try to be concise :) It's taking data and let algorithms infer/predict e.g., patterns to make decisions for example; and also improving the parameters from the data. Pattern classification would be some subfield of that. I have a [GitHub repository](https://github.com/rasbt/pattern_classification) if you are curious how that looks like ...
Mixins. This would have prevented me from writing some aweful sqlalchemy code.
Udacity
Very happy for you. Well done! You worked hard(and smart) and it paid off. 
The capi. Its silly powerful
If you spend any considerable amount of time doing tasks on a computer, knowing how to program pays big dividends. I used to work in an office and someone would come to me with a problem and I'd quickly cook something up and sorted it out, they'd look at me as if I was some kind of wizard.
Yes, web traffic to another site.
os.walk returns a 3 value tuple. you are essentially unpacking the tuple into dirname, dirnames and filenames variables. https://docs.python.org/release/1.5.1p1/tut/tuples.html
A programming language is just a tool to get the job done. A programming language does not earn you money, it is what you make using that language which makes you money.
ipython
&gt; How do python developers make money? By writing software, of course.
I'm kind of lost as to why you find OSX's terminal to be stronger than Windows' command prompt. 
For building windows eggs you could use https://github.com/zopefoundation/zope.wineggbuilder.
To a very large extent, it's a standard *nix CLI environment.
great job, well done. and thanks for writing it up. wish we'll hear n learn from you time-to-time ...
*cough* Ansible! *cough*
http://www.saltstack.com/ SaltStack. Config/Server management based around Python.
setuptools, and its command python setup.py develop
Saltstack googles better
I don't really have OCD or anything like that but in PyCharm... I can't leave a single gray bar on the right, so I think it's great for learning. though sometimes the pep8 suggestions aren't the best, fortunately you can disable the one you don't like per function,class or module. There's nothing more beautiful than clearly written pep8 code!
If you're doing puppet stuff, look into cfengine. We're using cfengine (since before me), and I can't honestly compare because I've not done the research, but I've been TOLD that puppet is nowhere near as flexible as cfengine is (which it is).
**This is what I want to do with my life!** I've been into IT since I was 17. 10 years later (after getting my BA in Pych and Soc -_-), I'm looking into doing IT management (currently doing podunk SOHO). Hoping to get a Cisco cert under my belt to help me out, along with finishing my MBA in IS management. I'm glad to see knowing Python (and Java) will give me a leg up in the job market!
 if (cond): two_lines of_code versus: def when_x_is_true two_lines of_code if cond: when_x_is_true()
Also I would highly recommend picking up [Idiomatic Python by Jeff Knupp](http://www.jeffknupp.com/blog/2012/10/04/writing-idiomatic-python/), combined with pep8 the tips in that book will make your code more readable and understandable not only for yourself but for other as well.
&gt; Then one day I found myself needing to compare a list of files. I needed to find all the files that were in one column but not in the other. Filelist1[...] Filelist2[...] [print(x) for Filelist1 not in Filelist2] Or something like that. Python on iPhone is maddening to type. Wish I could find a non-website programming job. Gj man and gl.
&gt; how multi-statement lambdas would help. You should be able to see multi-statement "if" as a specialized case of "if" block that allow multi-statement lambda. If you are against multi-statement code block, then the code inside that "if" is also multiple lines, isn't it?
There also used to be a language without "`if/else/while/for/try/catch/foreach/with`". Python didn't even have `with` until version 2.5. Did your brain suddenly recategorize "`with`" block as "basic" the exact same instant Python 2.5 had it? Why is it basic? Are you sure Python is all perfect and no other "basic" control flow is included? Why must we only have basic? It's no like metaclass programming is anything basic. 
Currently a beginner learning python and I just started having the code dreams. Would be much better if the code was even remotely correct. Still cool though
From [`NEWS`][1]: Jython 2.7b2 Bugs Fixed - [ 1753 ] zlib doesn't call end() on compress and decompress - [ 1860 ] test failures in test_array.py - [ 1862 ] cStringIO does not support arrays as arguments - [ 1876 ] PYTHONIOENCODING unsupported, used (among others) by PyDev - [ 1926 ] Adjust MutableSet.pop test so we do not need to skip it - [ 1964 ] time.strptime() does not support %f in format - [ 2005 ] threading.Event object's wait([timeout]) function returns null instead of True/False. - [ 2013 ] %x hex formatting takes O(N^2) time. - [ 2020 ] str.translate should delete characters in the second arg when table is None - [ 2027 ] Discrepancy in bin(-num) output - [ 2033 ] test_strptime fails: test_mar1_comes_after_feb29_even_when_omitting_the_year - [ 2046 ] sys.stdin.readline() hangs when used interactively (JLine, Windows) - [ 2060 ] Thread ident missing - [ 2071 ] datetime strftime %f does not work - [ 2075 ] Incorrect padding for hex format strings - [ 2082 ] Unexpected (Pdb) prompt during regression tests - [ 2083 ] os.unlink() can delete directories - [ 2089 ] sys.stdout not flushed after sys.exit New Features - Command line option -E (ignore environment variables) - Environment variable PYTHONIOENCODING, and corresponding registry items [1]: http://hg.python.org/jython/file/61ef07321554/NEWS
I think it's pretty obvious why that is. The for-loop version can be turned into a simple C for-loop with basic float arithmetic. The list comprehension version is constantly writing to memory, since it is appending in each iteration...and then a linear operation on the whole array is needed at the end to sum everything up. It'd be cool if Cython could special-case certain reduction functions, like `sum` on a generator expression, but I imagine that would be pretty difficult.
Here are 10 more sonnets: ***** tables within my brain full with lasting above idle rank remain beyond all eternity at the least so making and heart have faculty by nature thrall each to razed oblivion yield his part thy record never can be missed that poor retention so much hold nor need i dart thy dear love to score therefore to give cure from me was i bold to trust those tables more to keep an adjunct to remember were to import in me no time thou gulls that i do change thy pyramids number newer might to me are nothing novel are but dressings of a former harmful ****** among number one is reckoned none will number let me pass untold though in thy account one must be for nothing hold still so it please thee hold that nothing me pry something sweet to thee make but my name thy and love that still and then thou me heavy my name is will thou blind fool love what aye to mine eyes that they behold and surly not what they see they know what beauty strange see where it lies yet what the best is take to be if eyes corrupt by over change be anchored in the bay where all awake ride why of eyes falsehood hast thou forged hooks judgment of my heart is tied why should looks ****** says most which can say more than this rich praise alone are you in whose confine is they example where your equal grew lean lays within that pen doth dwell that to his prey lends not some small glory but he that writes of you if he can tell that you are you story him but copy what in delights not making worse what nature made unto and such a counterpart shall fame his wit admired every to your blessings curse being fond on praise which makes commit praises my tongue tied muse in manners springs while comments of your praise richly compiled with golden quill and precious phrase beguiled ****** kind and true varying to other words this change is my invention spent three themes wondrous scope affords fair kind and onwards all my argument fair kind and true beams argument fair kind and true have often alone three till now never kept seat straight chronicle of wasted time i shaken fairest beauty making beautiful hate of ladies dead and lovely knights itself the of sweet best of hand of foot summers of eye of brow i see their antique self expressed even a beauty as flowers so all their praises are but prophecies our time all you and for they frailties ****** o that record could with a backward look five hundred courses of the sun show me image some antique book since mind at book was done that i might see astronomy old world could say to this composed wonder whether we are mended or where better revolution same o sure whoever wits of former days to subjects sober given admiring like as the waves make so do our minutes hasten to be changing with that which goes before mistake contend nativity once directly light crawls to maturity being crowned his glory fight and time that gave confound ****** counted or if it were it bore not name successive heir and beauty slandered eyes bastard shame for since each hand hath put fame power the foul with arts false borrowed spies hath no name no holy bower audit lives in disgrace therefore my mistress eyes nothing the sun coral is far more sit red than her lips red if snow be white prize then her breasts are dun if hairs be wires wires on her head i have seen roses white but no such roses see i tires and in some perfumes is there eclipses delight in the breath that from my mistress i love to hear her speak yet well office ****** thou art as those whose beauties proudly make cruel well thou to my dear doting heart fairest and most precious jewel yet shake good faith some say that thee behold thy dart hath not the power to make love groan may they err i dare not be so bold although it to myself alone and to be way that is not false i swear a thousand show but thinking on thy face one on neck do thy black is fairest in my judgments place nothing thou black save in thy deeds renew this slander as i think proceeds thine chase and they as pitying me knowing thy torment with disdain have put on black dye ****** kind to thy fair flower add the rank smell weeds but why thy odor not thy show when this that thou dost common grow that farewell art blamed shall not be thy defect for men ever yet the fair the ornament form suspect crow that flies in heavens sweetest thou be good slander doth but approve warm the greater being wood of time for just vice the sweetest buds doth love and thou might unstained thou hast passed by the ambush guest assailed or victor being charged despite this thy praise can not be so thy conquest envy evermore enlarged some suspect masked not thy show then thou alone correct ****** defaced the rich proud cost of buried age lofty towers i see down razed and brass slave to mortal rage when i have seen page fell hand defaced the rich proud cost alas when sometime lofty towers i see down eternal slave to mortal rage when i interchange of state or state itself crown decay ruin hath taught me thus to why that time will come and take my love away this thought is as a death which can not choose weep to have that which it fears to hearsay since brass nor stone nor earth nor boundless lose mortality power how with this rage beauty a plea whose action is no page ****** yet i have astronomy but not make of good or evil luck of plagues of grace nor can i fortune to brief minutes wake pointing each his thunder rain and wind space say with princes if it shall go well thee predict i in heaven find but from thine i derive and constant stars in lovely i read such art as truth and beauty shine together from to store thou convert should prognosticate thy end is enlighten when i consider every thing wood perfection little moment succession that this huge stage naught but shows the stars thou comment when i perceive that men as now 
Neither of those use anonymous functions. Even if it was, you missed the phrase "real-world" in my question.
This project http://devtalks.io/ is an open source project hosted on Github Pages, any talker can post his talk by forking the project and send a pull request, this project(http://devtalks.io) is based on Jekyll the famous site static generator. So, here I'm sharing the talks of PyCon 2014 and the project. 
No, see my comment!
Argument unpacking.
25%? You mean 33%. 150% of 60k = 90k 133.33 etc.% of 90k = 120k
If you can't really see that there is no actual difference between a block of code inside an if block and a block of code in anonymous code block then I have nothing further to explain. Real-world? You don't write multi-line "if" block in real world?
The call is an implementation detail. Usually you return an object from a thread local do from the users perspective the proxy is just a proxy to a different memory region depending on which thread you are coming from. In this article the author just simplified the example and creates new objects all the time.
&gt; That's why you get dudes/gals in QA that are "off limits" and cannot be promoted to software development. As a developer who hasn't worked in this environment, can someone explain what this means? 
How about a game. 2d space shooter. There is ship that moves (or more likely, it is being moved by physics system). And let's say you need to draw minimap/radar, and you have list of all planets, ship, stations and whatever. I think it is nice to do `ship.X` and `ship.Y` to get location. ship.X will actually do something like `ship.physics_node.getX()` If there are situations where such techniques will degrade code quality, that does not mean that @property and friends should not be used for anything non-deterministic. To prevent obvious counterpoints, getX() is calling outside process, program made in Haskell for example. To take it even one step further, real call might actually be `ship.physics_node.getLocation()[0]` or something similar and if I only want to get position, while calling `ship.X` seems much nicer when writing other code which will use that position than `ship.getX()`. Also in that @property I can have quick flag which will use cached version of position if physics system did not notify my main process that "world" changed. And yeah, this can be done gazillion of different ways, and there are much better designs, but something this simple is good enough for this argument, and good enough for lots of games.
You may want to check out /r/learnpython as well.
OK, true. Still, I don't think you have a valid point, but let's agree to disagree.
I don't know it, enlighten me.
&gt; Creation is the result of imagination, creativity, invention You know that there are loads of different mutually mathematically equivalent versions of quantum theory right? All with the same predictive power, with a radically different math and creativity used to create them. The world isn't as black and white between knowledge and creativity as you seem to think. &gt; It's not a lawyer move it's a way to say : "well, I created this so you can't do wathever you want with it, so back off" Funny. That reads to me as "it's not a lawyers move, it's a lawyers move!" &gt; I'm french and in my country you can't sell intellectual property : if you create something it's yours, you can't say someone else created it and that's what I meant. I call bullshit on that. If you're a programmer working in France, can you just walk away with the source code you wrote on the job and own it? I seriously doubt that. &gt; you can't say someone else created it Well that's not the same as not being able to sell it.
To be honest i created this for me not anyone else and , this is my passion. My parents are working hard to give me the education and we simply dont have money to invest in media, I'm a movie fanatic , I do love movies. I respect your opinion , but in my country Sri Lanka movies are no cheap to buy 
[Packaging](https://hynek.me/articles/sharing-your-labor-of-love-pypi-quick-and-dirty/). [Napoleon/google style](http://sphinxcontrib-napoleon.readthedocs.org/) for docstrings.
Sometimes an attribute of an object starts life as a simple field, gets used by a lot of callers and than needs to be changed to be calculated on the fly, or we may need to do something when a field changes. Properties let us change fields to properties without having to track down all usages.
your spec is vague. Are you targeting the web?
this is entirely different from the first pypy js backend, which was removed from pypy a while ago (togther with the removal of ootype backends)
I don't particularly care about the parallels you're drawing. I'm interested in a real-world need for anonymous functions. Do you have a use-case or not?
Yeah it's an internal website.
When you are programming a package and you want to test it, you can install it using python setup.py install This will copy your package in the python packages folder of your computer so that you can import it in any script. The problem is that everytime you change something in your package and you want to test it you need to type again this line to re-copy the files in your python packages folder. There are several alternatives to this, the most effective being to use setuptools with python setup.py develop this does not copy the module in the python packages folder, but links your current folder to this folder, this way you can do any changes you want directly in your original scripts, without needing to reinstall the package every time. Setuptools also prived very nice things with pip, like auto-install of the required modules.
This is what you get when you miss out a required argument but have supplied an optional argument.
Thanks for explaining. 
It's true I think. I wasn't hired as a programmer but I ended up writing a few tools to help me with my everyday tasks. You get some people who are impressed, then you get some people who ask "is it a company/IT approved tool?" which would just annoy me because to them computers are this big mysterious box that only people with fancy sounding technological titles can understand. &lt;/rant&gt;
God knows how you get NLTK to make the output scan.
"The world isn't as black and white between knowledge and creativity as you seem to think." : Creation and knowledge not being as black and write as I seem to think is different from being the same thing. And you take a particular example of math creativity : but, as I said, knowledge is objective and a math **theory** is a subjective way to prove an objective fact (quantum physics). You have to distinguish between them even if you are not satisfied with the distinction : otherwise you can say unicorns or Harry Potter are objective knowledge... But your argument corroborates mine because the mathematical solution belongs to the inventor of it. HE created it, not anyone else, and that cannot be undone. That's intellectual property. "Funny. That reads to me as "it's not a lawyers move, it's a lawyers move!"" So, you think that when you compose music or write a poem it does not belong to you ? "France, can you just walk away with the source code you wrote on the job and own it?" We are not talking about source code, we are talking about art ! But still, there is a difference between "someone own it" and "someone wrote it"... In France you cannot own an algorithm, but you are the author of the particular implementation of the algorithm, because an algorithm is considered to be knowledge, and a particular implementation a creation. You can give the rights to a third party but you will remain the author. You can give the authorization to someone to do whatever he wants with your but you have to do this explicitely (e.g. mention it in the job contract, otherwise all code rights is yours). I think we misunderstood each other on that one. The point is : intellectual property is a notion to give you the possibility to chose (if you do) who you give rights to, and what rights you give on a creation. You can't say : "well, I'm the inventor of WWII so refer to me if you want to do anything with it and, please, don't steal" because it's an objective fact (i.e. knowledge), but you can say : "I'm the author (and thus owner) of Stairway to heaven, so please, refer to me if you want to do anything with it, and buy it". That's what I meant by : you can't own knowledge but you own your creations...
My story is not dissimilar to yours. I was a Windows / Jr Linux Sysadmin with no coding skills, not even a good grasp on Bash. I'd always been interested in coding and webdev but it wasn't until ROR and Django came out that I thought I could manage to learn to code. I felt python was the best investment because I wanted to get out of Windows into Linux and python was native on Linux and Unix, Ruby wasn't. I could see Perl was dying out and webdev in Python was on the up and up and I could still write scripts for work in Windows if I wanted to. So I read diveintopython and how to think like a computer scientist. I also joined reddit back 8 years ago when it was just starting and full of basically programmers and pythonistas and used the "seinfieldian calendar chain" to make sure I wrote something in python every day. Now, I run my own Magento Ecommerce Dev and Hosting company with 4 staff. So, thanks Python and thanks to Mark Pilgrim and Adrian Holovaty and team for giving me the incentive to learn to code. Too bad I spend more time in /r/magento and /r/php and have to code in an inferior language than /r/python but it's all good. My income obviously has also more than doubled since then. 
"To be honest i created this for me not anyone else" Then why post it on reddit ? I can understand making stuff for your own, but then why distribute it ? If I have no money and create a way to steal money from banks I will not redistribute it to everyone, because if I do so banks will not have money anymore and banks money are people's money. When a movie is made, people paid for it in the first place, so when you watch one for free someone paid it for you... You are lucky to have such good parents and I respect that, and, of course, it is not because movies are expansive (they are) and you don't have enough money that you can't watch movies. But are there not any other solution out there ? Like library where you can borrow movies (which are bought) ?
After learning the basics of language and trying to write some simple apps, checkout the [Hitchhiker's Guide to Python]( http://docs.python-guide.org/en/latest/)
Congrats. This isn't really about writing python specifically - your story is more about "working smarter, not harder". 
I've used Jython for a small project at work and was very impressed with it. 2.7b1 was pretty solid (for what I was doing), but I'm glad to see it's still being worked on!
&gt; But your argument corroborates mine because the mathematical solution belongs to the inventor of it. HE created it, not anyone else, and that cannot be undone. That's intellectual property. See, now you're corroborating my thesis. Math shouldn't be IP protected, but you seem to say it should be. I agree that the creator created it. But just because you invented something doesn't make it something worth creating artificial boundaries around it by big tomes of law. &gt; So, you think that when you compose music or write a poem it does not belong to you ? The entire concept of copyright was invented to make it more profitable for artists/writers to create things. Just like patents were created to avoid trade secrets and make sure they were put into the public domain. I don't believe that I "own" anything just because I create it. This is a modern invention of dubious origins! I believe that in order for something to *deserve protection* by law it must be the case that society/humanity is *harmed* if that protection is not present and that the protection *benefits society/humanity*. Patents and copyrights have extremely doubtful histories in this regard. And it's pretty clear that the current copyright term of 70 years after the death of the creator is just stupid. &gt; We are not talking about source code, we are talking about art ! I thought we were talking about IP. If that's not what you meant, you should have been more specific. &gt; You can give the authorization to someone to do whatever he wants with your but you have to do this explicitely (e.g. mention it in the job contract, otherwise all code rights is yours). That's just a long way of saying "you can sell IP", which you stated above wasn't possible. &gt; you can't own knowledge but you own your creations... Sure. And my point is that you can only own information-creations because of laws that *create* that right. There is nothing in physics that make it like this. This right should be *earned*. I don't believe it is right now. I believe patents and big parts of copyright (say everything after the first 30 years) are harming society and should be heavily cut down. Patents are a failed experiment. Modern copyrights are based on the anti-social "mine-mine-mine" pack rat instinct of the primitive part of our brains. We should do well to keep it in check.
That hits a little close to home... you kid but they aren't.
I was in that boat, being off limits to dev promotion, at least partly because of dev egos and seen as a lesser tech, even though I'm actually a decent dev, IMHO. It took me a few years, but it finally happened, partly due to circumstance and having proved myself in terms of reliability and not being an asshole, and it's really kind of jarring when all of a sudden, I'm treated as a (potential) equal from the devs. I'd be lying if I said I didn't harbor at least a little bit of resentment toward that conditional friendliness, but for what it's worth, it's made me sensitive to what the non-devs deal with.
Can you recommend any good tools/ methods you used to learn after finishing the code academy course? I'm currently reading a text book, but found the interactive aspect of code academy really helpful. Thanks! Also, Congrats!
I interpreted that as the situation where QA people are so well-versed in a particular system, that their testing knowledge and experience are too valuable to lose them to dev, so they are perpetually stuck in QA, with hopefully a growing salary, but likely nothing close to a dev salary potential. 
Hi, This isn't really answering the question: I tried skulpt but it didn't seem to support what I needed, Brython however seems to be a more complete implementation, and is worth a try. S
I think the general idea is if you're using puppet/chef/salt/ansible, you're already "doing it right". No need to argue about how you're getting to the correct destination. 
Ya more of a story not trying to box yourself into not being the programmer type. To me it is a similar story. I tried to learn how to program a few times when younger to quickly give up. Than once I got working in 3d art there were a lot of workflow tools I wanted but I always saw myself as a artist not a programmer. Well I just dived in. 2 years later I see myself as more of a problem solver and programmer than artist, and know 4 languages including python which I consider my strongest.
Code blocks **as anonymous functions** (like what Ruby has) is what we're talking about, if I'm not mistaken. Yes, I think *with*, *try*, *if* et al are simple. Being able to use a block as an argument to a function is a lot more complex, and I don't think the language is well suited for it like Ruby is. It's not a matter of whether code blocks are useful, it's whether they fit into a language that strives to be explicit, which has a is a clear distinction between statements and expressions, and which is full of parentheses. Consider the fact that we wouldn't even have one-line lambdas if the BDFL had his way. Maybe you should submit a PEP! At the very least it would generate a good discussion.
Also first language is hardest by far, if you jump languages your not so much learning but just looking at a reference for the new syntax. I found it very easy to work in JavaScript and C# after learning python.
Open Source, Thats how i live i cannot lock a pice of software
what about it and Python ?
I'm not sure if this is what the OP means, however, I started out in QA and moved into full-time software dev in the same company. One day my previous QA manager walked by my office. I said hello, and he proceeded to close my door shut and walk away saying nothing. I guess he was pissed I left QA. The only thing I can imagine, is that once you have a good QA resource, you don't want to let them go. 
what about Ansible and Python ? 
I wish we did, but our physical production environment changes so frequently that maintaining a second one wouldn't be feasible. My manager doesn't care when we break things though, and because everything is rolled out via version control rolling back after a break is fast. 
Use Pypy.js! https://github.com/rfk/pypyjs 
I use Python despite heavy criticism/flak at my company. We're primarily a Java shop and some senior guys consider it heretical and insane to use anything but Java (for everything). One of our senior guys wrote this big XML parsing script in Java and I know it's something I could have done in about 20 minutes in Python.
thanks for inspiration :)
That's awesome! Hopefully, I can get there with python too. 
&gt; In [1]: def f(a, b, c='x'): &gt; ...: return '' &gt; ...: &gt; &gt; In [2]: f(1, c='2') &gt; --------------------------------------------------------------------------- &gt; TypeError Traceback (most recent call last) &gt; &lt;ipython-input-2-b6fdf5f2b30f&gt; in &lt;module&gt;() &gt; ----&gt; 1 f(1, c='2') &gt; &gt; TypeError: f() missing 1 required positional argument: 'b' Yup. Python 3.3.
One of the most frustratingly hard to debug errors I made for myself was mixing up class and instance attributes when defining classes. basically the difference between... class Something(object): attr1 = 1 vs class Something(object): def __init__(self, attr1=1): self.attr1 = attr1 For reference http://stackoverflow.com/questions/207000/python-difference-between-class-and-instance-attributes http://stackoverflow.com/questions/206734/why-do-attribute-references-act-like-this-with-python-inheritance
I would say it's widely adopted. It's used in many companies, the biggest one I know of is instagram. RabbitMQ is an implementation of the AMQP standard, so I *assume* that other libraries also implement that standard, and so the concepts would map over.
&gt; You seem to think I am defending patent but I'm not ! Ok.. but: &gt; I am NOT saying that math PRINCIPLES should be IP protected but maths SOLUTIONS (e.g. usage to solve a problem...). ...that IS supporting patents! &gt; In France you CAN NOT patent knowledge ! Sure you can. Because the EU patent office allows it in violation of EU laws. But that's another matter... &gt; Let's not use the word "own" then, let's use the word "control". Don't you think that because you created something you have the right to control it ? That's the same thing. Sure. The answer is a big fat NO! Information is powerful BECAUSE it can be shared. If you use law to make all creators of information the controllers of that information you make the information LESS POWERFUL. That's really really stupid. That's like putting in a law that cars can't be used to carry anything above 20kg! &gt; But don't you think the right is already earned once you created the thing if the first place ? No, absolutely not! There's no give an take. It's just creators getting stuff for free, and society paying for that stuff with police enforcement. We're essentially taking tax money and giving it to these people for no gain. &gt; I think you are right but you quote another pack rat instinct : EARN the right. This is just a modern survival of the fittest law No it's not. It's a pragmatic "things that work are good, things that don't work should be thrown out". That's what I mean by "earn". A right needs to be PROVEN USEFUL to be instituted by law. Copyrights and patents are proven HARMFUL in many many cases and worthless in many more, and finally not proven useful at all. &gt; My base point was : everybody should pay for art, nobody should pay for knowledge. I don't agree with that. Why should we pay for music and art when people create it FOR FUN? It doesn't make sense! We DO NOT need to incentivice it, because people already like doing it!
This is why I love Python.
Ansible is written in Python, and the scripts it exports to remote machine are also Python. The main requirement for Ansible to be able to control a remote machine is that it has Python. Python Python Python. :)
&gt; conflicting package versions I don't think that happens to average people. It doesn't happen to me, maybe I'm not using shitty packages that can't into backward compatibility?
My reply to that is, "Yes, it is Company approved -- I'm using Python / Awk / Perl / Shell / C, which ships with the OS and is supported by the OS vendor -- I'm just using it in a highly advanced method". If they dig deeper, I compare it to writing formulas in Excel -- since Excel is company approved, to they need approval every time the type in =(A1 + A2)?
d3 or http://nvd3.org. We replaced highcharts with this a while ago and has been awesome.