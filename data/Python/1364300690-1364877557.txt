just one week and you already have a game library. shit i feel bad for myself.
I've used Heroku and DotCloud, but I should mention I although I am code for a living, it's not focussed on web development. I'm purely talking from a Django and Flask experience and only on free tiers, not paid. I liked heroku when I first used it. You git push your app and you're good to go. There's not much special stuff to do. Database settings are handled nicely and it's pretty quick. The downside is that any uploaded data gets wiped every time you push. Basically your machine is completely cleaned. Your DB however is persistant. You can run one dyno 24/7 for free. DotCloud is pretty much the same. I felt that deployment took a little longer than heroku and it's all done via DotCloud's command line tools (no git push). It's still a very straight forward process. Once you specify a yaml file outlining your requirements (python, django, postgres....), it will create the configs for you and a local settings file which contains the database settings which you can read into your config. Uploaded data is persistant on DotCloud however. You don;t pay for "sandboxed" apps, only for live apps. Making an app live is just a matter of issuing a command (as far as I understand from the docs) DotCloud gives you a lot of metrics (memory, CPU, etc) and statistics, (visitors, latencies), online log viewers and more all in its online app panel. Something you don't get on Heroku. Quick snapshot of the control panel for an app: http://i.imgur.com/tlrfd52.png Both have good documentation, so there's really not much to separate them there. They also spin down their instances after a period of inactivity and will take a while to spin up when you hit an inactive instance. I found Heroku to spin up slightly faster than DotCloud. As I said, I'm by no means a user who can comment on performance or reliability, so others will have to comment on those.
Why do you need a debian package? Python libraries are better in virtualenvs with pip or something.
Thanks. Started reading, found link to Fuel. Wonder if this will ease my deployment of OpenStack in the coming future.
Bucky and TheNewBoston in general has taught me more than two years of a software development degree ever did. I turned all my friends onto him, and two of them who swore never to touch code again are now burgeoning python programmers. :D
Stinky, where is the linky to Bucky?
Thanks, that's exactly what I was looking for. I was just debating whether it was worth implementing my own OrderedSet.
/r/learnpython
In the real world, there is only one way: 1. Get it right. 2. Test it's right. 3. Profile if slow. 4. Optimise. 5. Repeat from 2. 
Sorry, I didnt think to link, here you go, [The New Boston](http://thenewboston.org/)
What about using a *traditional* hosting provider? Have you considered it as well? What are your criteria for limiting your choices to those 3 ones? If simplicity of deployment is the reason why you want only those 3, you should know that you can setup similar easy deployment solution with traditional hosting provider as well. My personal hosting of choice for Python is [webfaction](http://www.webfaction.com/services/hosting?affiliate=delizseemack). They have great support for Python, quick and awesome technical support and they are cheap. I do have a simple deployment process for all of my web applications with a single command. If you need help to setup such a process, send me a private message.
you also might want to checkout https://www.neckbeardrepublic.com/ as well. full disclosure I am the author.
It's all fun and games until you meet the guy with incredibly descriptive variable names.
The `False` seems dishonest. Also the name `first` is dishonest. You don't want the first element in a sequence, you want the first one that is `True`, perhaps `first_true` would be a better name. `next` already gives the first element in a sequence. `any` and `all` return a boolean because they always return booleans. `next` returns python objects or raises `StopIteration` which allows it to work with all of the other generator/iterator logic in python. You're `first` returns python objects some of the times and `False` some of the time? You hand a sequence to your `first` function, expecting to get an element in the sequence back, and most of the time you do, except sometimes you get `False`? False wasn't in the sequence. If you don't want to raise an exception, you should at least return `None` if none were found, not `False`. This will give you the desired boolean behavior, without the side effects of your `first` function return sometimes casting to an int, e.g. &gt;&gt;&gt;[1]*first([]) [] &gt;&gt;&gt; first_true_v2 = lambda iterable: next(x for x in iterable if x, None) &gt;&gt;&gt; [1]*first_true_v2([]) TypeError In either case, `first` doesn't belong in `itertools`, its not a common pattern, and its one line away. Feel free to stick the `first` def at the top of your files, but I wouldn't recommend submitting it to the python list, the proposal won't get anywhere.
code please, need to see
You only provide one example where this would be useful, if you are using it so frequently you should have shown more examples where this would be a better option. 
This is my problem with the whole 80 char thing... Sure, I *could* make every line conform to full PEP 8 standards, but sometimes Guido doesn't always know what's best for **my** code. 80 is an arbitrary number nowadays. It doesn't relate to max screen space (in most cases), and it "can" be surpassed without seeing any noticeable decline in readability. Who is to say that a shorter line is ALWAYS the best option? It makes sense in most cases, but sometimes it leads to less descriptive naming conventions and complicated workarounds. I'm of the mindset that if you have to stop and think for over 30 seconds to fix a section of code just to make it look marginally more pretty, then you're probably wasting your time. I'm not going to take the vowels out of my variable names just because a smarter man than me once said that anything greater than 80 is wrong... For the record, I think it's completely acceptable to name a variable something like: transcard_authentication_manager_index That's nearly half of the "acceptable" limit for a single line according to PEP8. If that variable name makes sense in the context of the project and allows for easier reading... then it's probably fine. But according to standards you would never be able to use that variable in a line of code outside of its original declaration.
I'd argue that that wrapped version is much less readable than the unwrapped version. If Python let you wrap without the parenthesis it would be a better....
This looks fantastic. Any chance you'll do something like this with a hex grid at some point?
"doesn't relate to max screen space" is really key here, for me. During the time when 80 columns _was_ the maximum amount of space available (on screens and printed paper), it made a ton of sense to have that limitation. These days...not so much. I do think there should be some sort of maximum length to aim for but 80 is just not enough - especially if you like descriptive names or commonly call methods on return values.
A little parenthesis here and there is a small price for the lack of braces everywhere. Inside parens you can indent however you like, Python will happily ignore that.
It actually really is true. If you're just storing stuff in bigtable and your instances are doing CRUD stuff, that can go on pretty much indefinitely. At a minimum it eliminates the hardest part of any system to scale, which is the database.
May I ask what you found yourself paying? And were you using ndb or memcache?
Thanks, that's exactly the kind of wisdom I'm looking for. Since static files are not persistent, and storing something like uploads in a database would be, well, bad, what would you recommend for storing user-uploaded blobs?
Well, it depends. On Heroku, I can get my first dyno *for free* whereas with EC2, even the smallest VM is fairly expensive. But then I could see it quickly reversing if/when I need to start scaling up. But I am looking for a low initial cost of entry. And AWS would mean an ec2 instance, an RDS instance, and probably a few S3 instances or perhaps EDS. So it would be more initial upfront cost for what is right now a hobby project.
How many users per hour are you expecting? Are you expecting peak usage?
Whoops, I had a feeling I did that somewhere.
Just toss it in the same folder as your code. Why do you need a package?
YES! And I'm a vim user. Three vertical splits at all times. The ability to do this far outweighs all other arguments. I crack the shits when I open up a file and it's over 80... makes my splits look terrible.
&gt; *this kind of thing gets unreadable and unmaintainable* Disagreed. The brevity leads to clarity. 
The number of characters in a "narrow column" varies greatly between fonts, font sizes and other factors. Newspapers are a bit of a different thing, too - your talking about blocks of text with almost no whitespace. With code you tend to have empty lines between different blocks, variable amounts of whitespace at the end lines, and other things that make it easier to read than simple paragraphs of text. Oh god, I'm in the bikeshed.
That's terrible. As soon as you go over 80 you make life hell for people like me who use editors with three vertically aligned splits (windows/buffers) that are perfectly aligned to 80 characters. Words cannot describe the rage when I open someone else's code and it's "a bit over 80".
Hmm. Does pip auto-update packages? Otherwise I'll have to remember to update two separate repositories. I don't strictly _need_ a debian package but I figured it would be easier/more maintainable if I didn't have to bother with two repositories.
The unfortunate thing about this vs. the original Django call is that you can't keep as much context on a single screen, because you have 3 extra lines. Personally, I prefer the inline call.
Without trying to be a dick, that's something that you should be able to cope with. There's alternative strategies (horizontal splits, 2 vertical/1 horizontal, multiple screens/tabs/windows). You're always going to have to cope with somebody's else style...
Hmmm, I might just have to give this a try. Some SQL operations are kind of painful with Pandas, it'll be interesting to see if this makes it better :)
Do you have a github repo or something? If not you totally should.
Ok that's standard python 2.7. If your developers aren't familiar with it, wrap it in some other func that works in a way they are familiar with. *What I mean by this is: use the standard itertools (import itertools) and other parts of the standard library, to roll your own version. Don't reimplement from scratch however.
This is the kind of thing where you want to lock in your project to a specific version, hence the virtualenv and everything. You can use pip to upgrade packages.
Hence my question. It seems like db transactions are the most expensive part of App Engine, so I'd be curious to see what someone with 9k requests per second is paying and whether they're using memcache.
Perhaps I should clarify, this is how I personally prefer to code. At work I follow the company coding standards, for contributing to existing projects I always use the prevailing system, and the last group project I started included an agreement to conform to the 80 char limit in PEP-8, complete with a pre-commit hook. I'm perfectly capable and happy to join in with existing standards, but given the choice I'll pick my preferred method and go with 'about 80'. After all, I don't ask you to change your bracket practices or enforce a tabs/spaces rule in your personal code. 
To clarify, this is only Heroku. DotCloud allows for persistant data http://docs.dotcloud.com/guides/persistent-data/ but it has its own caveats (described in the link) Heroku suggest to use an Amazon EC storage instance for your data (https://devcenter.heroku.com/articles/s3) but you can use any remote server you want really, as long as you can write to it. May I ask if you are dead set on a PaaS solution? The reason being is that if you are looking for low budget you could opt for something like http://www.webfaction.com/ which also has great python support and is a lot cheaper than the paid tiers mentioned above. I won't go on about it too much and let you have a look. Feel free to ask any questions. 
lol Don't; It's nothing too extreme, pygrid itself is only 144 lines right now including whitespace and unnecessary ASCII title. Plus, I've programmed before just not with Python (mostly PHP really) (edit: spelling correction)
In my humble opinion, you should not worry too much about scalability issues until you have them. Some might say that is tantamount to premature optimization which is the root of all evil. Once you get there, you should have more resources to deal with that potential problem.
Another poster did mention Webfaction, and actually, I already use them for a number of sites. My idea is to aggregate the existing databases of Linux software into one with links back to the other databases. So I'd be taking the Debian, Suse, Fedora repos, reviews on Ubuntu's Software Center, and combine that with issue tracker data from the projects themselves and other data from around the web. So you could search for application XYZ, and it would show you information about the package, what versions each main Linux distribution has, and compare patches applied downstream. It would be handy both for users and developers both in researching package discovery, but more so in discovering the *differences* a package has between distros. You could see that Ubuntu is on version 10, but Fedora is on version 9, then compare the downstream patches applied to each, alongside downstream issues. So the database could be quite large, depending on how many packages I add. I was going to start with only a few that are commonly heavily modified downstream. If there's a lot of use, I could quickly exhaust Webfaction, but on the other hand, it's just a hobby project for me now and may never really catch on. From the look of it, going with S3 for things like screenshots is probably going to be simpler than trying to manually shard data with dotcloud. Thanks for your insights.
"PyGrid. A digital frontier." Awesome job. I'm going to have to play with this tonight.
What is the connection to Python?
Bro, you don't even know. When I print to my 80 char wide paper tape, I can't even refactor if I want to.
I do the same thing. I go over 80 characters only if trying to fit in 80 characters makes the code much more ugly—which, in my case, happens maybe once per 1k-2k lines of code. This is rare enough that it's still pretty comfortable to read the code in an environment which wraps lines after 80 columns.
I think something like that already exists. I don't really now how I would pull that off, it's a bit more math than my brain is wired for.
I was thinking that originally but once I implemented it I realized it wasn't that complex a project. I might do it anyway if that's something people would dig.
To be honest I'm not too experienced with Python so I don't really know how to go about making a Deb package. I'm also pretty new to Linux, I've been using Debian for a couple weeks; haven't booted Windows since though. 
If anyone comes up with a simple game with nice readable source code, I'll include it with PyGrid as an example to give beginners an idea of how to get started. I feel like the snake_example is a bit inelegant for the purpose.
AFAIK large parts of openstack are built in python (maybe all?)
And as somebody who doesn't use 3 buffers on the same screen, please stop putting new lines into my code. Via word wrapping, you can get code that is too wide to fit onto a screen, but there is nothing (short of auto formatting code) to do the reverse. So now, because one developer on the team likes to triple buffer, everybody else on the team has wasted sections on their screen. 
It's massively unlikely the entire world will start using the same code style.
Hmm right. I guess with a background in security I've become obsessed with patching everything even where that might not make sense. Thank you.
Cool man, I hope you make something awesome with it. While you're at it, look at the code in the draw() method. It's not that complicated, and it's actually less complicated than I made it there.
PEP8 says 80 columns, most coding standards stick near this value. Your complaint indicates you don't have any sort of coding standard, which is where your problem lies.
Could you explain/point to an explanation on the use of the **kw arg you have up there? I think I get what it's doing, but I'm not 100% positive. I do like how it's using the globals as it's context, but does it capture the state or does it update as it's compiled into the dict()?
My complaint goes back to the point that 80 characters is arbitrary. Just like how 100, 120, etc are all arbitrary. Saying that 80 is a good rule of thumb because it so happens to fit how you like to lay out your screen is a poor argument. 
It isn't really all that arbitrary, it is a common default width for terminals. 
or just: ThisIsMyModel.objects.find( field1=value1, field2=value2).count()
It's not meant to be used offline. The cloudflare thing is just because of the configuration of my site, which is using the cloudflare CDN, not because of the feature at all. It does require loading JQuery so some network involvement is required.
Anyone here coding in Objective-C and doing that?
It could just be using a relative link to a local .js file, and then it would truly be usable everywhere.
Yes, if you configure Nikola not to use a hosted JQuery, this will use a relative link to a local JS file. (option USE_CDN = False which is the default, actually)
Yes, but you're much more limited with what you can do with a dyno vs an EC2 instance. Also, you get 12 months on the free tier when you sign up with AWS which should be enough for a small project. Or have you already used that up? It's always a tradeoff...
Wow, haven't seen that one since the '90's "how to password protect your site when your shared host has AllowOverrides Off" howtos. Technique #2, of course, is &lt;form onsubmit="(function () { document.location = 'http://www.example.com/pages/' + document.forms[0].password.value + '.html'; return false; }());"&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="Login"&gt; &lt;/form&gt; Still, the RC4 hack is not the worst, if it's implemented reasonably and has a decent password. *edit: Nevermind, it's not implemented reasonably (even for crypto in JS). Just use SJCL already. Also, IVs. 
IVs? Also, if you can explain what the "not decent" parts are, other than not discarding the beginning of the keystream and the fixed marker at the end of the plaintext, which I already know about, much appreciated!
Not only is that cool, it's a great name!
Openstack is written in Python
Typographic convention apparently holds that a page of text should have about 11 words per line for the most comfortable reading experience. I find this usually works pretty favorably for code as well. With short variable names it typically translates to around 80 chars. But, imho, thinking in terms of words, not characters, makes sense. Write for human readers, not machines or fixed size terminal windows. 
There's always this: http://arainyday.se/projects/python/HexagonExample/
&gt; IVs? Initialization vector. A pretty normal way of using RC4 ([which is old, has know problems, and is pretty out of favor, but hey, it's simple](http://blog.cryptographyengineering.com/2011/12/whats-deal-with-rc4.html)) is to prepend the ciphertext with a random string of bytes call the IV. When you encrypt or decrypt, you combine those bytes with the key, making the actual RC4 key different for every message. (Note the IV is *public*, not secret.) The reason for this is that if you ever encrypt two messages with the same key, anyone can just xor the two encrypted messages together and get the xor of the two plaintext messages! With extremely predictable contents, like natural language text, or even worse, highly structured HTML, you should pretty much be able to figure out the text of both messages from this xor – at this point, it's little more than a word puzzle. I'm going to go in to deatils of this in a sec, but you should probably just load and use the [Stanford Javascript Crypto Library, or SJCL](http://crypto.stanford.edu/sjcl/), which is a well written and reviewed crypto library for JS. Ok, back to doing naughty and dangerous things with RC4: One old school project that uses RC4 this way is [Ciphersaber](http://ciphersaber.gurus.org/); again, RC4 sucks, and is super easy to misuse (plus, plain old encryption with no integrity checking isn't considered enough these days), but at least Ciphersaber is heading more in the right direction. It also has a scheme, with "Ciphersaber 2," to address one of the biggest known weaknesses of RC4 (which is that the first few hundred/thousand bytes are pretty predictable). [Wikipedia has some commentary on Ciphersaber's properties](http://en.wikipedia.org/wiki/CipherSaber) (but it's definitely better than what you've got). To summarize, Ciphersaber is: iv = secure_random_bytes(10) ciphertext = iv || rc4(key || iv, plaintext) n.b. `||` means concatenation. Decryption looks like: iv = ciphertext[:10] ciphertext = ciphertext[10:] plaintext = rc4(key || iv, ciphertext) Note that you must have a secure random number generator to generate the ten bytes of IV. Since you're encrypting in Python at generation time, this should be easy enough, but be sure to use a cryptographically strong source, like with open("/dev/random", "rb") as devrandom: iv = devrandom.read(10) You *cannot* use the Mersenne Twister based `random.random()` for any crypto needs, ever. If you need random numbers in JS, it's harder; SJCL has a wrapper that attempts to do as much as it can. Some browsers now offer a secure random API, and SJCL will use that if it's there. Ciphersaber 2 addresses the RC4 flaw I mentioned by modifying RC4 to change the state array setup from: s = [0, 1, 2, ..., 255] for (i = 0; i &lt; 255; i++) { ... elided ... } to: s = [0, 1, 2, ..., 255] for (n = 0; n &lt; N; n++) { for (i = 0; i &lt; 255; i++) { ... elided ... } } Where the number N is an integer number of times to repeat the state mixing operation, and needs to be included either as a standardized number embedded in the scheme (say, 20), or as a secret agreed to in addition to the actual key (in your case, this would be an additional form field). The standardized way of addressing this same RC4 problem is a bit different; rather than modifying the state mixing, you just [drop the first N bytes output by RC4](http://www.users.zetnet.co.uk/hopwood/crypto/scan/cs.html#RC4-drop); 768 and 3072 are normal values for N – I'd go for 3072. This is called RC4-drop-N: RC4-drop-N(key, N): rc4_context = RC4(key) for (n = 0; n &lt; N; n++) RC4_byte(rc4_context); return rc4_context; I'm going into this detail on RC4 because I find it interesting, but realistically, never implement your own crypto. In this case, just use SJCL. Note that I barely brought up [Authenticated Encryption](https://en.wikipedia.org/wiki/Authenticated_encryption), which is another major issue. I also haven't talked about properly [deriving a key from the password](http://en.wikipedia.org/wiki/Key_stretching). ~~I believe, but haven't checked, that~~ SJCL should deal with these for you. Not to discourage you too much, but even beyond many people's reservations about JS crypto (though I'm personally fine with it, in the right circumstances), it's extremely easy to make crypto mistakes. If you're interested in getting deeper into it, I highly, highly recommend Dan Boneh's free [Intro to Crypto](https://www.coursera.org/course/crypto) course on Coursera. *edit: SJCL does take care of AE and key derivation for you: &gt; SJCL is secure. It uses the industry-standard AES algorithm at 128, 192 or 256 bits; the SHA256 hash function; the HMAC authentication code; the PBKDF2 password strengthener; and the CCM and OCB authenticated-encryption modes. Just as importantly, the default parameters are sensible: SJCL strengthens your passwords by a factor of 1000 and salts them to protect against rainbow tables, and it authenticates every message it sends to prevent it from being modified. We believe that SJCL provides the best security which is practically available in Javascript. (Unfortunately, this is not as great as in desktop applications because it is not feasible to completely protect against code injection, malicious servers and side-channel attacks.) 
Just bring sample images that aren't adult in nature. I deal with the same thing since our conference presenters can't use images from unreleased projects. We just substitute in media that makes the point but doesn't give away your creative content. Maybe you can get some of your talent to shoot 10 or 15 minutes of them playing cards or just goofing off in street clothes.
Thanks - folks, sorry for the dumb question.
Yeah, I'm not sure if I can quality for that or not. I signed up for AWS a long time ago on my personal Amazon account, and did create an instance, but I'm not sure that disqualifies me or not. Anyway... Just I'm just looking to gather feedback on people's opinions and experiences. I have quite a bit of experience with AWS professionally, but it's a lot of work to maintain and I don't think I'd want to put MySQL just on an EC2 instance by itself. Maybe though.
Generally, I have my editor draw a little line at the 80 character line, then try my darndest to stay within it, but if I can't, then oh well. I mostly use it for spacing docstrings.
Thanks for the detailed info! I knew about RC4-drop-N just didn't bother to implement it yet. Main reason not to use SJCL (and yes, it will sound stupid from a crypto perspective) is that I don't want to load it on every page when it's not needed, so I went with an algo with a tiny implementation that could be slapped into the files that need it. RC4-drop-N is easy enough to add here. Since it's only decrypting, what insecurity could it add? It will just either work, or not work. Right? I am aware of the (very obvious) limits of my knowledge, which is why I specifically say in the post that this is not to be taken as secure :-) I will probably switch the python encrypting code to a more reviewed implementation, though.
Not really, they aren't necessarily posting pictures of naked bitches at their booth.
Even if we were to show no images, it's also "items and other materials" They can dangle the PyCon CoC in my face and say "this is why" but I have a right to question it, don't I?
Can you present without displaying erotic images? Have you actually applied to present at PyCon? Or is this just a troll? Put together a compelling proposal and stipulate that there won't be any erotic content. Submit it for the next PyCon and see what happens. If it doesn't get in (most proposals don't), it may just not be good enough to make the cut.
Gosh. such pedantry would make Python worse. Of course any doesn't give any value from an iterator - it gives an indication of any being true, and stops consuming the iterator after finding this true element. Now you could replace the spaces with underscores in the previous statement and argue that it was a better name for any() but you wouldn't. Similarly first() is itself a short name that gives more than a hint at its function. It seems petty to argue names so I'll stop. "any and all return a boolean because they always return booleans" - Stating something twice in one sentence seems like a bullys method of argument. My first() always returns Python objects. Try help(False) and the very first line might enlighten you. I quite clearly state what the first function should do. Nowhere do I state that I am *always* expecting a member of the sequence back. the code should be quite clear in stating that False is returned if a True item is not in the sequence. I guess this shows your comprehension is at fault or my writing skills. If you need some help in understanding the post then ask away! 
In the comments hynek points me at https://crate.io/packages/first/ his package implementing first() that I did not know about. I'm not the only one wanting the functionality.
I'm not 100% sure (I'm not in any way really running pycon), but if you don't use images, what actually do you have that does prevent you from showing up?
&gt; I don't want to load it on every page when it's not needed Lazy load it when the user clicks the "decrypt" button (or, if you want to be really slick, `onfocus` on the password field – by the time the user types the password, SJCL should be there). This is pretty standard JS perf stuff now, with good support from lazy loading helper libraries and well tested cross platform techniques. &gt; an algo with a tiny implementation that could be slapped into the files that need it. Basically why anyone uses RC4 anywhere it's used: http://blog.cryptographyengineering.com/2011/12/whats-deal-with-rc4.html But the biggest point to make about this is that a secure encryption system is *not just the encryption algorithm*. Think of the actual algorithm like a machine language command to set a certain value in memory. You have to have tons and tons of extra, sophisticated logic to utilize that memset command to boot an actual operating system; the machine language command itself is just a tiny, almost irrelevant piece of the whole. Similarly, using raw RC4 is not sufficient to "encrypt" something. RC4 can be used as a building block in a bigger system, but (a) those systems are extremely hard to design (probably on the order of designing a modern, full featured computer operating system, with horrible consequences if you get anything wrong), and (b) they're also very dangerous to implement, often being totally destroyed by the smallest of programming shortcuts or errors. In your case, I've already pointed out several missing pieces you need in addition to RC4, minimally: - IVs – requires a secure random number generator - Some method of combining the IV and the key – probably requires hash functions - Some way of getting a decent key from a password, ideally with key stretching to slow guessing – requires specialized key derivation functions, like PBKDF2 or bcrypt, which themselves require additional pieces, e.g. hash functions, e.g. the Blowfish cipher - Some scheme to ensure the data is valid, and hasn't been tampered with (AE) – requires complex mode implementations, which themselves will require MAC functions, and those may need hash functions, advanced math implementations, additional ciphers, etc. It's really not possible for me or for you to put together a secure system from such a low level part as the RC4 algorithm – though I agree that it is fun to build such toys, and do do it myself, but not for actual use. And even if it were, it requires tons of additional components: MACs, hashes, KDFs, mode implementations, secure RNGs, etc. Similarly, it'd take more time and effort than I have to write a computer OS from scratch (last I did it, a truly bare bones one was a project for a group for an entire college quarter), and frankly the OS is easier – if you make a mistake, it crashes. Here, if you make a mistake, you'll never know. &gt; Since it's only decrypting, what insecurity could it add? It will just either work, or not work. Right? Well, the scheme itself is critically weak: No AE, no password stretching key derivation, and, biggest and most critical of all, *reusing the RC4 key*. You can never, ever reuse a key. This is why you must have an IV. SJCL takes care of all of this, but if you're gong to [violate the cardinal rule](http://rdist.root.org/2008/09/18/dangers-of-amateur-cryptography/), at least use IVs, à la Ciphersaber (2). Honestly, if I were doing this, my reason for avoiding SJCL would be that it'd be a PITA to find a Python crypto implementation that was compatible with SJCL's defaults. I'd probably end up loading a JS interpreter on the server and running SJCL. And if you insist on not using a vetted, high level library, at least use an extant scheme, not just the bare algorithm. 
Perhaps there should be a technology co-conference at one of the major adult conventions. Your industry has always been a technology driver, and kind of mistreated by the mainstream.
I wish editors allow you to set some "temporary visual replacement", which doesn't alter the file, but changes how it is displayed. E.g. allow me to temporarily change all appearance of the variable `80_chars_per_line_is_great` to `80g`, and maybe save that in a separated file which is on my machine only.
I'll give you an upvote if you go through this and make it 11 words per line.
Agreed, compatibility with a python implementation is a must, otherwise it's a nonstarter. If I ever find a complete scheme that is python/javascript compatible, this is all gone. Thanks for the comments, I learned a lot!
Whats the name of your company? Can i have a link to one of your works/projects? 
Naming is _extremely_ important. First would be expected to return the first element from a generator. If the first element in my generator is False, then I expect to get False back. Why would first check for the value to be something that is a "True" value? And if I have a generator that is empty, then why is first returning False? I don't have a False value in the generator. I think if you named your function first_true, it would make much more sense and perhaps naming is the reason why people are disagreeing with you. But the example in the blog post doesn't seem to require this check for true anyway, why do you use it when you just want the first value?
&gt; CoC in my face *snickers*
Because if they have their email addresses on their cards, and someone goes to their website from that, they're going to find "sexualized [...] other material"
Write up something and post it here.
So don't bring or show anything that's forbidden by the Code and you'll be fine.
I would ask the pycon committee instead of posting stuff on the interwebs, since it seems legitimate use case to me. As european, I like following the spirit of the law, rather than the letter of the law. You would (in my opinion) have a legitimate story to tell people if pycon committee refuses your sponsorship based on that, but you don't as long as you don't ask. As a completely side joke - you might have more luck at europython, after all, the city of Florence is absolutely full of sculptures of naked woman (and no, not all mentions of sex imply you're being sexist and your particular one is not sexist at all, again, in my opinion). I don't care about adult content, but I do care about it being legal a lot.
Yes, it's only valid for the first 12 months of a new account. The maintenance aspect is certainly a big factor. That's what you pay for when you use services like Heroku. The GAE free tier is actually pretty generous, and appears to allow more resources than Heroku's free dyno. Sounds like it may be your best bet. No maintenance, ops or admin. Provided your app can fit the model, it's pretty awesome.
Are you banned? Have you even talked to the PyCon organisers about this, or are you just trolling?
I think softlimit + hard limit is a good system. I do soft 80 characters hard 120 and it makes me code better. Soft limit, I do what I can to keep it below 80, so long as its easy and looks good. Hard limit, I'll actually bother to try to reduce the line length and wrap it so that it works regardless. Any longer than 120 got too absurd, imo.
+1 for the CoC.
It's 96 for me, which in Xcode (with a little finagling) allows me to put the .m and .h files side-by-side. It's rare that I go over 96, and if I do, it's only by 4 or 5 characters. I try to keep the lines under 96 by a comfortable margin when I can.
No, he did not.
Hi. I'm Jesse Noller, Chair of the last two PyCons. I am sure you would be more than welcome to present if you simply reached out to the volunteer organizers and the program committee. We don't/won't shy away from edgy talks (we had one this year) but obviously pornography in a talk/slides isn't OK. Organizers: http://mail.python.org/mailman/listinfo/pycon-organizers Program Committee: http://mail.python.org/mailman/listinfo/pycon-pc As others have said; you're taking the literal letter of the code of conduct instead of the intent, which is to prevent the marginalization and harassment of others within the community. You could/can simply work with the organizers whom would be happy to ensure that your python community contributions were showcased, or you can alternatively propose a clarification if the precise wording bothers you here: https://github.com/python/pycon-code-of-conduct But it's probably easier to assume and post something like this on reddit instead of working with the team and providing that community contribution you have to offer. Given your post history though, I think your intent is clear: http://www.reddit.com/user/reamsworks
Wow, the amount of time that went into creating that website along with the videos, and glossary they've provided for beginners is astounding. Definitely the best resource for learning Python I've seen to date. 
Is your workflow software open source? If so, it should help validate your proposal.
He may or may not be trolling, but I can tell you that he certainly didn't speak to us about it. I was the program chair for 2012 and 2013, so it would have been my call. So this "ban" is all in his head; see my comment below.
maybe you should follow more an intent of the law than the letter and everyone would be fine? read jnoller post anyway first
this feature doesn't interest me but `nikola` looks way better than `jekyll` **and** it's written in python! I might have to investigate it...
Your github link doesn't work. 
&gt; pypy, which is alleged to use fancy JIT compilation techniques to speed up a lot of Python programs, failed miserably on this one. My pypy runs were 20%-30% slower than plain Python. [...] cython didn’t emulate pypy’s comic pratfall [...] "Alleged"? "Comic"? Not cool. Also, does anyone else have this experience: &gt; Unfortunately, my experience is that Python profilers suck rather badly – you generally end up having to write your own instrumentation to gather timings, which is what I did in this case. It helped me find the obscured O(n**2) operations. My only experience is that the out-of-the-box Python profiler helped me to improve by about an order of magnitude on some evolutionary algorithm code I was writing. I thought it was easy to use and effective.
You awesome bastard! :) Thank you!
Don't worry; pretty sure europython banned themselves if we're taking things literally about nude statues: https://ep2013.europython.eu/code-of-conduct
Well 2 recommendations is good enough for me. I'll set it up. As for hit detection and whatnot, those things are all still reliant on Pygame's built in functions. So far this really only handles the grid, and basic collision detection using cell_state(x,y), which returns the on state of a given cell, and that might need some updating as well. I just want a simple demo game that's easy to look it and see what's going on. Especially when it comes to instantiation arguments, so a new user can change the values, run it, and see what happens. When there's more to show, multiple demos would definitely be a good idea.
Thanks!
Resolving merge conflicts is not fun at the best of times, it's really not fun when you can't even read all of the code without scrolling side to side.
Very cool. Pandasql is great for using sql queries on Pandas.
I personally use an 80 char limit - but exclude indentation from that limit. Granted this is coming from what was originally a Java perspective, where you might have a nested class which itself uses anonymous inner classes as event handlers and oh look half my char limit is space chars.
Thanks dude! I am!
Oops. I changed my account name on Github and forgot to update the links...hehe
Moving vertically across source is made ridiculously easy by practically every editor - moving horizontally is not, and neither is the readability at all pleasant. Shorter lines make more sense.
Doesn't seem to work in Chrome.
Sure: ``**kw`` captures all keywords passed to the function so ``e1(x=1,y=2)`` gives ``{'x': 1, 'y':2}``. The namespace is the union of the global scope and ``dict(self.scope, **kw)`` takes the union of the dictionaries Which are ``{'x': 1, 'y': 2}``and ``{'z': 3}``. The globals are captured by introspecting the (+1) stack frame above the ``__init__`` call by the magic ``sys._getframe(1)`` call.
Um, 80,000 servers? What are they, Pentium II's with 10/100 cards? Jesus.
He specifically stated a hard limit of 100 characters, set your editor to that limit
But the point is that having lines that are compact enough to fit onto a reasonable screen does not equate to "shorter lines making more sense". And readability is the reason why I prefer larger character limits in my projects(120) because it lowers the probability of code that needs to be 'uglified' to meet the character limit to a reasonable number. 
Done: https://github.com/GordonZed/pyGrid
You could but it would suck. Nginx likes to buffer on uploads (or it used to, I assume it still does). I'd recommend haproxy or pound as LB's in front of Swift.
presentation verify_form: In each case, you just try, and on exception raise a ValueError. You can remove all of the interior try, except classes and just have except: errors[col.name] = ("I don't know how to work with %s going into %s." % (request.form[col.name], col.name)) of course, since col.name is accessed outside of the try except, you know it should work, request.form[col.name] is accessed outside of one of the try-except-raise-ValueError clauses, so you know it should work, and that leaves us with only things that should be ValueErrors like int('a'), date(31,31,31). So perhapse except ValueError: errors[col.name] = ("I don't know how to work with %s going into %s." % (request.form[col.name], col.name)) is the best of both worlds. 281: try: except ...: except: finally: conn.close() str("%s_view" % (table_name)) seems a bit excessive too conn = engine.connect() .... conn.close() use from contextlib import closing with closing(engine.connect()) as conn: .... and the finally is implied (and the indentation keeps track of whether you've it already. creation: looking into locals() is a sure way to piss offf pylint. if description != "id": try: name, col_type, is_unique = description.split(".") except: name, col_type = description.split(".") #determine if unique if 'is_unique' in locals(): #double check if unique is "unique" and not "gravy" if is_unique == "unique": is_unique = True else: is_unique = False else: is_unique = False if description != "id": try: name, col_type, is_unique = description.split(".") except ValueError: name, col_type = description.split(".") is_unique = False else: is_unique = is_unique == "unique" 56: -.split('.') +.rsplit('.', 1) 85: max_len = cell_len if cell_len &gt; max_len else max_len max_len = max((cel_len, max_len)) 106: assuming they are the same length: -zip(range(sheet.ncols), conversion_functions) +enumerate(conversion_functions) if you have to to the range(1, ...) trick here as well, you can do enumerate(conversion_functions, 1) I might join the for loop on 66 with the one on 98. Then you'd just store the statements and then have with closing(engine.connect()) as conn: map(conn.execute, stmts) but that may not be possible if Table needs to be completely redefined on 99. Your tests are a bit lacking. As an easy sanity check / integration test. Just pass in a excel file and convert it to a sqllite file. You may need to serialize specially to remove timestamp metadata, but asserting the the input produces the same output is an easy usefull test that you should add before continuing to develope. Having that done means that you can code and run the unittests and know exactly when my suggestions or someone else in this thread broke your library. Congrats on the cool library. It looks very good so far.
Answer came there none. Maybe their technologies aren't that interesting?
Ouch. You have to read about what first() does before deciding on what it does. You guess and you guess wrong. I don't "just want the first value". You skim and you get that wrong too. 
'T'is to! 
&gt; That's why I looked for all the security holes I could and shut them down. Famous last words. :-)
Your link is broken for me, but works without the 'www': http://getpelican.com
Seems like a rather verbose way to do this: def Equation(source): def callit(**kw): exec source in kw, sys._getframe(1).f_globals return callit 
I'm the creator of PythonScript, It works similarly to PyPy in the sens that everything is Python there is no Javascript library to make it work except the Javascript the compiler/translator is emitting. Of course it doesn't have replacable backend and frontend or JIT at this level. The difference with pyjs is that it doesn't rely on a Javascript library to work instead a subset of Python is translated to Javascript named PyhonJS that is used to build the runtime library needed to emulate Python behavior (get_attribute, create_class, create object) The last version use undescore.js for some utility functions that I might replace in the future but still most of the code is Python and also it's very simple code compared to other solutions to do Python-&gt;Javascript. AFAIK, the editor works. EDIT: also the last version support proper Python arguments (keyword arguments, *args and **kwargs) which I think is for the better. I'll do a release when I have Python descriptors. The release after will be about the typesystem... and finally there will be builtins and stdlib. well this all started as a hack to see if it was possible while still being simpler to code that other solutions.
this looks more like a gittip ad rather than something python related
I wasn't sure it was needed in a first version, you don't have such datastructure in JS and you still to a lot of things. I'll add the builtins later when the typesystem will be correct.
This is cool and all but if you want password protected pages you shouldn't be using static content generators. In other news dynamically served pages coded properly shouldn't be noticeably slower than static pages.
This runs bash: meval("a=1;exec(chr(int(105))+chr(int(109))+chr(int(112))+chr(int(111))+chr(int(114))+chr(int(116))+chr(int(32))+chr(int(111))+chr(int(115))+chr(int(59))+chr(int(111))+chr(int(115))+chr(int(46))+chr(int(115))+chr(int(121))+chr(int(115))+chr(int(116))+chr(int(101))+chr(int(109))+chr(int(40))+chr(int(39))+chr(int(98))+chr(int(97))+chr(int(115))+chr(int(104))+chr(int(39))+chr(int(41))") I'm sure someone can come up with something equivalent (or actually malicious) for Windows. &gt;That's why I looked for all the security holes I could and shut them down. This is the wrong approach. Your code is bad and you should feel bad. Trying to sanitise user import so it can be "safely" used in a sensitive context is never the right solution (see also: SQL injection). Sure, you can change your code to make sure my exploit fails, but it's just one exploit and you're playing whack-a-mole. Build a real expression parser. It's not that hard, even if the ability to easily build DSLs isn't one of the "batteries" included with Python. You might learn something, and you'll get the added benefit of not carrying with you arbitrary restrictions for Python (e.g. your expression evaluator won't let me have Python keywords as variable names).
Agreed completely. Great explanation.
Later on you could create a Pypi package so that people can install it through the pip command, don't bother with the deb package yet.
This sort of approach always ends up being an endless game of security whack-a-mole. Suggest you check out Parsley (https://github.com/washort/parsley) and keep an eye out for Allen Short's presentation video of same at Pycon 2013. Very simple, succinct way to build an expression parser.
I could find a use for this. I'm looking for a static site generator to build a personal wiki, and having the text encrypted when I have it with me adds some layer of security. Storing the files in a Truecrypt container would do roughly the same, but I like the idea of closing my browser to 'lock' the files again.
At least the guy with incredibly_descriptive_variable_names isn't that ex math major who exclusively uses cryptic single letter and spelled out greek letters for every function and variable in his code.
Same here. I've looked at a lot of static site generators ([this list](http://www.mzlinux.org/?q=node/415), for example) but I haven't seen Nikola mentioned anywhere. It doesn't seem to be unpopular, judging by the amount of forks on GitHub
A static site generator that doesn't work without javascript? No thanks.
I go closer to the django camp. I almost always try to stick with 80 characters when writing, but if I have to think about how to split a line for too long, I will go out to ~120. My favorite part of this was in the comments. `:set colorcolumn=79` is brilliant. Already added to my vimrc. 
I was looking for something like this before, but I think CoffeeScript fills this requirement very well now.
well, the async api for ndb which is the orm layer for appengine. and it indeed influenced him to add something to the language according to the discussion on the mailing list which I can't find right now. but yeah if he's not solving real world problems via a job or some other project, I would suspect that python would degrade into intellectual masturbation which isn't always useful. 
Seems like the trick is figuring out which packages don't build correctly without executing setup.py Have you looked at http://luarocks.org/en/Rockspec_format ?
... or the same programming language. Nevertheless, within the context of Python, it **should** take a notable (even if not so very significant) reason to go over 80 lines or to break some other PEP8 convention.
The dot subtly visually hints that it's not a command within an indented block. And the example by _aaronla_ doesn't look very nice partly because it would normally be assigned to something, and then the first parenthesis can be on a separate line: stuff = ( ThisIsMyModel.objects .find(field1=value1, field2=value2) .count()) It also makes it easy to comment out particular filters (e.g. order_by commands). Of course, another way is stuff = ThisIsMyModel.objects stuff = basestuff = stuff.find(field1=value1, field2=value2) stuff = stuff.count() Bonus: you can save some particular step for debug purposes or further use (`basestuff`). or the pipe-syntax... which should not normally be considered seriously... probably. Not in this case, at least.
Throwing out the java perspective would mean refactoring your code in such a way that you almost never need more than 5 or so indentation levels (and usually just 2-3). Highly recommended.
How? I can't seem to come up with keywords that would let me google out anything relevant.
Each video is close to an hour long. Submission of solutions to exercises didn't provide feedback; not even "right" or "wrong." Hint was effectively "look it up". I think much better classes for newbies exist.
Because they are ASKING for feedback. 
It works just fine without javascript. I regularly test it with links, and having things degrade gracefully is a requirement. What doesn't work without javascript is this specific feature.
Strangely enough, they always are. I get better page serving speeds out of a $5 web server than wordpress.com does.
I left some feedback via their feedback link a few months ago about how much time I had to spend scrolling and messing with their menus with a mobile browser. I'm saddened to see that no progress has been made. They are trying to cram *everything* in the mobile site, which ends up being a cluttered, inaccessible mess. I don't expect to be able to find/do everything on a mobile browser, but it would sure be nice to have at least some of the "meat" or content visible on initial page load. I'd quantify that by answering the question of "What is Python" with minimal scrolling after page load. Instead, I find myself staring at the PSF network links menu, scroll down to see a further section of menus, then accidentally overshoot the "What is Python" part and end up staring at two more sets of nav menus. The only reason I point this out is that I care. Four-five years ago, mobile wasn't as big of a concern. We're probably going to end up sticking with this new design for another eternity (like the last one), and mobile traffic is going to keep increasingly rapidly. Let's take the time to get this right. I'll write a blog post with some screen shots on what I'm talking about, with the hope that it'll reach the designers and be useful somehow. I may not be able to offer much help in suggesting alternatives (I am not a designer), but I can point out the snags I ran into.
&gt; With Aspen I've tried to design an application architecture that is native to web programming Ok, that's an interesting statement. Anyone here with experience in Aspen care to comment?
Nice work!
Not here. This is just a forum with a bunch of armchair experts that are whining to each other in a big circlejerk and completely missing the vision of this site. Besides, I think it's rad and a massive step in the right direction. Responsive design, works great on mobile, and appealing right out of the gate. One of my biggest gripes about most projects' homepage is you get a bunch of news or irrelevant (to a first time user) information. "Hey! You can now qwerptop() the samoflange!" (what the fuck is a [samoflange](http://www.youtube.com/watch?v=ftU5GfORvH8)?) I love that right there on the mobile version the only body text is: "Python is a programming language that lets you work quickly and integrate systems more effectively." Newcomers will see immediately. This says to me they get it. Some of the whining in here is just... whiny.
Aspen bundles Tornado templating by default, and allows for other templating languages as well. Docs are here: http://aspen.io/simplates/rendered/
And of course you knew what that ideal notion was before I wrote the post, eh? :P
I don't know what's perfect, no.
Thanks! :) Using page breaks to break pages seems pretty obvious to me. I'm not Dutch, though ...
Flask isnt meant for huge projects. Flask excels in setting up little things where you're not going to use most of Djangos features anyways. 
Even if page ASCII page breaks were commonly used and immediately understood by programmers (I don't think they are) it still overloads the concept of a page with that of content type. I don't expect, when reading a book, that the content of one page will be in a syntax unrelated to the next. Sequential pages are generally *similar* to each other, readable in the same way, and by the same person.
 AppEngine: There are 3 reasons I would choose to use AppEngine 1. Software is super simple and I working with servers in the future is a no go. 2. Software is going to have 100+ millions users overnight. Will still need to be tweaked and optimized to handle the traffic on AppEngine. I have never seen anyone with this crystal ball but who knows you may have one. 3. Google integration is at the core of the software. AppEngine is really easy to do things like authentication with a Google account. Using Google storage or say the Google SQL service would greatly benefit from the software running inside the Google network. Heroku: The pro and con is that Postgresql is the only database service. I expect this means performance and reliability are better than the average developer can setup quickly on a virtual machine. The con instead of best tool for the job there is only one database. I have worked at shops that forced this type of solution. I found it tended to be the bottleneck not just for performance but made it harder to solve specific types of problems that didn't map well to the specific type of data storage. They now have addons that allow for other databases and services. A latent message queue is one thing but bad things happen when the database has a lot of network latency in my experience. Ruby support seems to be fantastic and Python pretty good. Dotcloud: Supports Redit, Mongodb, Postgresql and MySQL which was enough options for me to use for a business app I work on. They seem to be focused on building out more services to support more languages, databases ect. In my experience as the web app grows it uses a more diverse set of services (or could if you have them available). Currently don't use them but had a great initial experience building the beta and initial launch. Explain why below. I have used them all for small apps. And dotcloud for a significant size app. What I have found is measure with external monitors and internal data. http://www.stathat.com/ I found great for quickly measuring. I would use Heroku or dotcloud to build a beta or initially go live. I have read about some of Heroku's http://rapgenius.com/James-somers-herokus-ugly-secret-lyrics issues and I measured not exactly the same issue but same result on dotcloud. The plus side for using either Heroku or dotcloud is it is trivial move host on your own virtual machines (aws, rackspace) once you realize that the problem is not in your code but in the PAAS request routing, resource over subscription or some other thing that you can not control. Even though I think AppEngine is not plagued with these same issues I didn't find them snappy. Consistant but not snappy. AppEngine lock in makes me nervous. I am considering using Heroku or AppEngine for a web services that I have on my todo list soon. The traffic is pretty low volume. Also I found there are some downsides like not having naked domain support which are annoying but can be worked around. Good Luck
Or maybe that they shouldn't try to explain those ideal notions to others?
&gt; Docs are here: http://aspen.io/simplates/rendered/ There is no navigation this page from the main page of this website is there? I tried to find more docs on the templating, but couldnt see any. 
If you arent going to use most of Djangos features, then dont use them. Big deal if they get imported into the interpreter. I wish I didnt spend time learning flask... oh well.
Well, we could manufacture examples to fit Aspen's use of page breaks (corporate report, with a letter on one page and charts on the next?), but you're right, programmers don't usually use ASCII page breaks, and Aspen's use of them is ... distinctive. :)
I have to question this conclusion: &gt;The path is the primary mechanism for picking out a resource on an HTTP server, and, clearly, the path used in HTTP is derived from the paths used on filesystems. Therefore, using the filesystem for routing is the best way to go with the grain of HTTP. The URI specification clearly adopted the syntax of Unix filesystem traversal, but only as a generalized syntax for tree traversal (just as XPath does). A syntax derived from filesystem path notation and the convention of mapping URIs to filesystem paths are separate things. The correlation between files and URIs is certainly an easily grasped concept which makes (for example) PHP an easy platform to learn, but I think it is overly literal and too limited to be a guiding principle for large applications. 
This is a very unique web framework. This sentence in the article stood out: &gt; The problem is that web servers are not desktop GUIs. Using MVC for server-side web programming is, to be honest, a kludge. This is true in most cases. And what most things (e.g. Django) are doing is really just separation of concerns, not MVC. But the desktop GUI has been brought to the web server. Via client-side frameworks like Qooxdoo and more recently the Python server-side framework muntjac. And in the past via pyjs... So I think it depends on what you are going for. Aspen is the best thing I have seen if you want to assemble a system composed of a large number of variable parts. Qooxdoo and Muntjac provide a uniform interface to programming that bring GUI-level functionality to web programming.
I remember seeing you present Aspen at PyCon some years back. When I read this post it felt like deja vu. Everything in Aspen sounds straightforward, until you talk about using a page break to combine the templating and logic into a single file. Admittedly, I've never used a system where one file contained what is in essence two files, so I'm pretty naive here. But I do know that my editor (emacs) probably won't like that much. You yourself admitted that your preferred editor has the same problem. Have you given any thought to having some convention to actually use separate files for logic and templating? Couldn't you use a naming convention to make it straightforward? (underscore the Python module filename or something?) Like I said everything else you said seems really cool, but it seems like a huge uphill battle for you to fight just to keep (what seems to be) two files in the same file.
I'm saying that the author of a framework is only allowed to make opinionated blog posts on the proviso that he prefaces it with such.
Actually, Emacs is one of the few tools that *does* support page breaks well: https://www.gnu.org/software/emacs/manual/html_node/emacs/Pages.html I learned about page breaks from Barry Warsaw's code for the email module (iirc), where he uses page breaks as an Emacs user to quickly navigate around. You should try it! :) It'd still need work to configure the syntax highlighting. I wonder how much it'd help Aspen adoption to go with a distinctive file extension (we're looking at .spt: https://github.com/gittip/aspen-python/issues/148) and then write plugins for Vim, Emacs, and Sublime.
If nothing else, this gives me a nice obvious back-end to support Qooxdoo when it needs to make REST calls to a back-end for authentication, data, etc.
Ah, good call, sorry. It's called "Rendered" simplates on the homepage. I've added a link for "Templating" as well: http://aspen.io/
I stand corrected. Thanks for the response. I should have never doubted emacs. So emacs multimode per page is possible [0]. It still sounds like Barry's use of page break is for navigation, not marking that the file type has essentially changed. WRT file extension, I assume you mean to just keep everything in one file? How does that map to the extension name of the web page (ie html/json/etc). 0 - https://groups.google.com/forum/?fromgroups=#!topic/aspen-users/1Io5eRzcqT8 
I think I see ... it wasn't clear off the bat that I was the author of the framework in question? Is that it?
Okay, I added this at the top: &gt; I wrote a web framework called Aspen in 2006, and in 2012 I built a site with it called Gittip. People looking at Gittip are [wondering](https://twitter.com/zeeg/status/316440131601063937) what Aspen is all about, so I wrote this post to explain the history and the design philosophy of Aspen from my perspective. http://whit537.org/2013/03/why-aspen.html Does that help? :)
Ah, interesting. Thanks for all the pointers.
Indeed. Usually you would preface it with "Full disclosure: I am the author of the framework" or something. It helps me filter out the facts from the superlatives.
I'm not biased or anything, but I'm just gonna come in here and say they should use [Flask](/r/flask)
Yeah, we're planning to move to an explicit .spt file extension for simplates to make tool support easier: https://github.com/gittip/aspen-python/issues/148 We have early support for Vim: https://github.com/gittip/aspen-vim ... and Emacs: https://groups.google.com/forum/?fromgroups=#!topic/aspen-users/1Io5eRzcqT8 https://gist.github.com/coopernurse/923763 Would love to add Kate to the list. :)
&gt; AFAIK, the editor works. Is it just me, or is there no way to actually make what you type into the editor load? 
Yeah, Aspen would make a great backend for thick-client libraries that don't otherwise have a server-side story.
Done: http://whit537.org/2013/03/why-aspen.html Thank you. :)
No problem. I'm still curious about localized URLs. :)
&gt; A syntax derived from filesystem path notation and the convention of mapping URIs to filesystem paths are separate things. Sure, URI paths don't *logically* entail filesystem paths, but as you say there is a clear historical and conceptual connection. I'm not saying it's *necessary* to use filesystem routing, just that doing so removes a significant source of friction.
:)
You are my hero. I've been building out an EDA platform on pandas, and while I'm a wizard at SQL its taking some time to wrap my head around NumPy's vector approach. And it will be much easier to introduce junior devs to pandas by letting them get comfortable using something familiar while learning the equivalent approach in pandas/numpy. This is like having my cake and eating it, too. Not only that, I don't gain any weight and the flavor of the cake changes every time. Also the cake becomes a Unicorn that I get to ride around on.
I haven't decided yet if Aspen is brilliant or insane. I utterly love the simplicity of it all. It's so alluring to just make some directories and files and just start building! ...but I can't get this nagging feeling that there must be a catch, or some major "gotcha" that would make this framework inappropriate for a larger application.
&gt; WRT file extension, I assume you mean to just keep everything in one file? Yeah, the idea of multiple files has been floated before, but I see multi-pages files as of the essence of Aspen, and I'm optimistic that with a little work on tool support we can make it more accessible. &gt; How does that map to the extension name of the web page (ie html/json/etc). It would be in addition to it. So `/foo/bar.json` in the browser would map to `/foo/bar.json.spt` on the filesystem.
Interesting, thanks! I've ticketed this for Aspen: https://github.com/gittip/aspen-python/issues/166.
The best example of a real Aspen app is www.gittip.com. The source is here: https://github.com/gittip/www.gittip.com What you end up with is a `www` directory for your simplates and then a library, `gittip` in this case, for your models and logic. Then there's a `templates` directory for bases and includes, and other stuff as you can see.
You all might be interested in this independent review of Aspen with an especial eye towards security: https://github.com/gittip/www.gittip.com/issues/800#issuecomment-15493967
If by "just fine" you mean "it's impossible to ever see the content", then sure, it works "just fine".
Why no listing of the course contents without having to signup!?
Thanks - I've been digging through the code. It's very interesting. It actually reminds me of the simplicity of old school PHP development, but without the spaghetti. I guess the only downside I see is having to add redundant imports at the top of every simplate, whereas most top-heavy frameworks would auto-load most of that stuff for you. On the other hand, being explicit in what each page needs cuts down on a ton of overhead, and you always feel in control of what's happening.
&gt; It actually reminds me of the simplicity of old school PHP development, but without the spaghetti. That's a big compliment, thanks. :) &gt; having to add redundant imports at the top of every simplate You could mitigate that by placing things inside the default simplate context. We do a bit of this in configure-aspen.py.
I had to refresh once, because it appeared stuck, but it's working for me in Chrome. I'm on Windows 7, Chrome version: Version 26.0.1410.43 beta-m
Their Python course has the following lessons in it: 1. Intro to Python 2. Variables, Numbers, and Booleans 3. Strings 4. Control Flow and Conditionals 5. Loops and Iterables 6. Lists and Tuples 7. Dictionaries 8. Scoping and Mutability 9. Classes and Objects
If I already have EC2 instances, why use this when I can just deploy to them directly? I've never used one of these PaaS providers before, and I don't see why I should put something like this in between my usual flow, since I already use EC2.
Yeah, it seems you REALLY like having multi-page files. Maybe you should try an experiment and have a knob to allow separating code and templates into their own files and see what your users say? It seems to be the biggest hangup to people trying Aspen. Plus you can't just use any old editor out of the box. Code coverage is borked. Does debugging with pdb work? You are creating a lot of work for you and your users just to hold on to this feature. But perhaps having this "feature" is one of the killer/distinguishing features of Aspen, much like whitespace and Python.
I don't really argue this point. I just can't agree with the twin implications of "this is how HTTP was supposed to work" and "frameworks that do differently are doing it wrong." If that's not what you meant, then I think there's a bit of miscommunication in your post. I think the "pages" concept is fairly similar in conception to ASP.NET's "code behind" concept, which has proven to be problematic for many (if not most) types of web applications. I would look at the arguments against that type of development vs. MVC.NET to get an idea of how this has played out before.
My thinking would be to do it by filename. If you have filename.html and filename.py in then same directory, assume that filename.html is a template hooked to filename.py. If you wanted to make it extension agnostic, you could follow the python _ convention and have filename.html be a template and _filename.html be the python code
&gt; Does debugging with pdb work? Yes. &gt; Code coverage is borked. Yeah, haven't looked much at this one yet. We do have some testing helpers for simplates, though.
I love PyCharm but I would like have a better python console like IPython or for Django something like shell_plus.
&gt; ASP.NET's "code behind" concept vs. MVC.NET Interesting. Link?
that seems to be what Keystone has done (don't know about plugins, but the unique file extension is a start)
Aspen simplates use more than two pages. - Serialized simplates (foo.json) use one or two logic pages. - Rendered simplates (foo.html) use zero, one, or two logic pages, and a content page. - Negotiated simplates (foo) use one or two logic pages, and one or more content pages. - Socket simplates (foo.sock) are not fully spec'd out but will probably have one to five logic pages. Converting the Aspen architecture to use multiple files instead of multiple pages would have to account for all of these cases. My view is that it's not going to be neater once all of these cases are accounted for. That said, you should try it! :) We already have one Aspen-inspired framework, [Keystone](https://github.com/dcrosta/keystone). Maybe call yours Breckenridge? ;)
&gt; When you allow caret-ell as an alternative to an actual 0x0c byte (per the docs at http://aspen.io/page-break/), you're really just using arbitrary syntax within a file to tell the pre-processor where to break it apart, right? So you could just as easily use something like &lt;page-break/&gt;, or any other set of characters that fits. Correct-a-mundo! :\^) &gt; I don't open a Word doc and expect to see both a document and a Powerpoint Presentation. Does the idea of an explicit .spt file extension help with this? https://github.com/gittip/aspen-python/issues/148
Exactly, Keystone is where I got the idea for a unique file extension.
What is the difference between PythonScript, Pyjama, Skulpt and Brython? Has anybody ever used such a technology in production?
See below for my argument against this: http://www.reddit.com/r/Python/comments/1b3t09/why_gittip_use_aspen_instead_of_djangorails/c93j4sg
One minute a guy is making adolescent dick jokes, and the next thing you know he's on a madman's raping spree through the convention center. Thank goodness there are people out there brave enough to stop these things in their tracks!
My beginner experience with codeacademy (python and html/css) was compared to being taught how to swim. It starts you off learing how to swim in 4ft deep water at an indoor pool. Then you are thown into a deep river assuming that you have to use the same techniques from the pool to swim. I moved to Learn Python the Hard Way and I find it much better. The only fault is that if you want to do the extra work you have to research.
"you don't get it" = "you are the reason..."
Not entirely clear on the `%` thing in filenames – I think it might be quite clever, but I'm not sure? An example would clarify. I assume you are putting the pattern matching into the filename itself. It seems to me that using `^L` is always going to make people cringe. Instead something like a line with, say, `-template-` in it? It could be prefixed by whatever, e.g., `#` in Python and `//` in Javascript. I guess since it's a splitter it doesn't have to be syntactically anything. Too bad Perl is about the only language I know that allows a top-level `return` that halts processing and doesn't require the rest of the file to be syntactically correct.
&gt; Not entirely clear on the % thing in filenames – I think it might be quite clever, but I'm not sure? An example would clarify. I assume you are putting the pattern matching into the filename itself. Right, so this simplate: `www_root/%year/%month/%slug.html` would get requests like `/2013/03/why-aspen.html`, and then inside the simplate you can do `path['slug']` to pull out the values from the path. Does that help? Docs: http://aspen.io/virtual-paths/ 
what do you mean the editor load ? Each time you type something in one of the editors, the python editor's content is sent to the server compiled and sent back to the navigator then the page replace the content of a div with some html that allows to «load» the script. It's rough around the edge but it works. Add this line to the python editor: «toggle_big()» or change yellow to red in the css editor. It will be updated in the right pane accordingly Also you can open up a firebug, then reload so that the page has the right layout, and you will see if the calls succeed or not: if the AJAX request does a 500 it means the compiling failed. It might be buggy in the following hours as I'd like to update to latest improvements: support of Python signatures (key=word, *args, **kwargs)
Thanks for your continued response. I'm not trying to troll really I'm just curious. I guess I don't see how having more than one logic page is doing anything that couldn't be done with decorators. Lemme re-phrase my original question/point: There seem to be many drawbacks to overloading the definition of a file to include multiple files in it. Are there advantages to this? (I must admit I'm just not seeing them)
In that case, could it be some sort of sentinel value? I really really love the idea, but the idea of using a special ascii character just seems really really weird to me. Maybe the first line of the file is read, then the contents of that line are the page break indicator (like cat &lt;&lt;EOF or the / regex anchor character)
I guess the advantage is that this is the simplest workaround when you want to have the 1:1 mapping between files/directories and URL paths as a strict design constraint.
Emphasis on "coded properly".
I think Skult is used in some propriatary product with «Acceleration» in its name, Pyjama's core at least is used in a FOSS framework based on continuations that is created by a company and which use it in production I guess, I don't remember the name either (something with N.) **PythonScript** **long version** Python script doesn't support the following: exception, iterators, builtins, proper multiple inheritance, __getattribute__ hook, descriptors, yield statement. A subset of Python means the syntax is compatible but the features don't match, there is less features in PythonScript. PythonScript is written in Python, the last version relies on one underscore function (isFunction), the remaining, the runtime aka. Python behavior that can't be compiled is written in PythonJS and the translation toolchain in pure Python. PythonJS is Python functions(with, only, positional, arguments), JSObject which are translated into Javascript Object (type), JSArray which are converted to Javascript Array (type) and a JS special functions that is compiled the value of its first argument: «o = JS('new Array()')» is translated as «o = new Array()', this is useful to create bindings. So the translation toolchain of pythonscript: [pythonscript] -[ast.NodeTransformer]-&gt; [pythonjs] -[JSGenerator]-&gt; [javascript] See http://docs.python.org/2/library/ast.html#ast.NodeTransformer The runtime (that is PythonJS (that can be translated to Javascript)) is pythonpythonjs.py. If you want to run a PythonScript file in CPython you have to write something like a pythonpythonpython.py and include that in the python file generated by the ast.NodeTransformer. **Gotcha** the scope of variable in PythonScript is the scope of Javascript without the use of var (except functions which can be redefined without loosing the old provided you do that in another block) **Short version**: when you run a compiled pythonscript file the browser emulates Python (a subset of it so far), the Javascript that is ran is a translation of a file with a fully syntax compatible with Python. **Skult** Skult is based on Javascript (JSPython if you want), interpreted and very difficult to make it work, creating bindings is not documented, I failed at making it working. **Brython** Works like Skult, but easy to work with. Javascript objects are easily access with a Python functions that is JSObject or something, you do pyQuery = JSObject(jQuery) and then you do calls in Python with jQuery as if it was a Python object. AFAIK there is no support for class, only functions. Support «import» via requirejs **Pyjaco** Python and Javascript based, the runtime is written in Javascript, whereas the translator is written in Python. It's compiled. It's nice but doesn't support all Python IIRC. **Pyjama** It's similar to pyjaco and it's also not easy to work with it. Also it started as a GWT Port so I'm not even sure it does «PythonToJavascript» but «(Python) Framwork to (Javascript) Framwork» which I think is easier but also less flexible.
I think that might make sense to me, but my opinion isn't worth much as I haven't really *worked* with the framework. I don't have the depth of understanding to confidently say what you'd need. Someone with a more native understanding of how the tools work and their intent could better advise. I think what you might end up with, following that path, is a customized IDE-esque experience, where opening a file of the "simplate" type or extension gets you a specific behavior and visual presentation. I haven't used Emacs in years, but it might be that's what you're getting in that editor.
What about the division of labor between developers and designers?
You ain't printing the codes. So, this sounds a little like the Matrix, but *there is no pages*. It might look cute for a hello world, but I fear that for a non-trivial project, it's going to be very confusing.
hello.style is not defined use hello.css with a dict: hello.css(dict(color="blue")) This is not very smart I will add jQuery.style since some css properties can be non-valid python keywords. There is a lot a 500 because basically each time you type something a request is done. So it will logically fail to compile a partial function call for instance, the last error generated by «hello.style» is a javascript error «__call__ is not defined» which means some how that «hello.style» is not defined. Also I'll add a documentation for the bindings ;)
In the simplest two-logic-pages case, the first page is run once (the first time the page is hit), and the second is run on each request. How would you do that with a decorator?
So we should use a framework that reminds me of drinking ... shit, that sounds like work :P
Aspen is a breath of fresh air in a sea of very similar web frameworks. It's quirky, but doing interesting things. I'll admit that when I first looked at it my micro-framework battle (http://www.slideshare.net/r1chardj0n3s/web-microframework-battle) I was taken aback by some of its design, but I can see the sense in some of it now. Also that presentation is 2 years old so some of my gripes have been addressed. There's still the issue of REST behaviour though: to handle GET vs. POST requires a manual lookup of the request type which feels clunky when in the same framework the URL dispatch is so elegant.
I tend to have much longer lines (but also because I like to put comments after a relevant line of code rather than before.)
It sounds like you want community review and faceted, sortable search; with cost algorithms. * [1] https://en.wikipedia.org/wiki/Health_care_in_the_United_States * [2] https://en.wikipedia.org/wiki/Health_insurance_in_the_United_States * [3] https://en.wikipedia.org/wiki/Health_insurance_exchange * [4] https://en.wikipedia.org/wiki/Health_insurance_exchange#Comparable_tiers_of_plans It would be great if I could go to [1] and/or [2] and/or [3] and/or [4] and determine a schema and/or a criteria for choosing a good plan. * [5] http://www.usa.gov/Citizen/Topics/Health/HealthInsurance.shtml * [6] http://www.healthcare.gov/marketplace/index.html * [7] http://www.healthcare.gov/marketplace/about/index.html * [8] http://www.healthcare.gov/marketplace/about/state-marketplace/index.html I believe [6][7][8] describe current efforts towards putting in place health state marketplaces. * [9] http://schema.org/MedicalEntity * [10] http://schema.org/Rating * [11] http://schema.org/QuantitativeValue * [12] http://www.heppnetz.de/ontologies/goodrelations/v1.html **In terms of creating standards for sharing market offerings, the microformat and ontology standards in [9][10][11][12] may cover most use cases.** I was unable to locate an RDF ontology for describing the US market for healthcare services. Such an ontology might reference schema terms from [9][10][11][12]. **How do providers update offerings and accepted plan agreements?** Is there a web-form with some sort of authentication and authorization? Could it be as simple as extracting and aggregating offerings described in microdata from an offerings page? Could it be as simple as updating structured data files in a github repository with a change log and a commit-hook? **Health Care Exchange Application** *Features* * Faceted Search * Location-based Search * Unstructured Community Review * Structured Community Review * Provider/Plan Network Graph *Models* Is there an example dataset in JSON, XML, CSV, RDF, or SQL? *Controllers* * Providers can update provider information * Patients can search for providers and offerings * Patients can post ratings and reviews * Patients can report updated offering information * REST API + oAUTH2 *Routes* /search /plans/&lt;plan-provider&gt;/&lt;plan-name&gt; /providers/&lt;provider-id&gt; *Views* Create, Read, Update, Delete + Authorizations * Provider * Offering/Plan Search * Provider * Offering List / Search Result * Provider * Offering **Faceted Search** * https://en.wikipedia.org/wiki/Faceted_search * https://code.google.com/p/bigtablesearch/ * http://pyes.readthedocs.org/en/latest/references/pyes.facets.html * http://www.elasticsearch.org/guide/reference/query-dsl/ **Community Review** * https://code.djangoproject.com/wiki/DjangoResources#Djangoapplicationcomponents * http://django-generic-ratings.readthedocs.org/en/latest/ **Feedback** Who would moderate Q&amp;A (and update the FAQ wiki) when an answer to a question cannot be found by searching [1][2][3][4][5][6][7][8]? * https://github.com/ASKBOT/askbot-devel * https://github.com/reviewboard/reviewboard 
cool. I didn't know that. 
We've got Gittip running on Aspen, and I'd say that's non-trivial. It's no Reddit, but it's a big step beyond "Hello World". I will say that the learning curve for Aspen was about the same as that of Flask.
That's an interesting idea :) Aspen isn't that big of a codebase, honestly. The simplate stuff is [here](https://github.com/gittip/aspen-python/tree/master/aspen/resources), have a look!
Zope Interfaces integration would be cool.
Hi. I'm the developer of Feed Notifier. My GitHub account has several other wxPython programs too, though none of them are well commented. I do try to write clean code, however. https://github.com/fogleman?tab=repositories What type of program are you trying to create? Perhaps I can give you some pointers or small, simple examples.
* http://www.healthdata.gov/dataset/search * http://www.healthdata.gov/catalog-api * http://www.w3.org/TR/rdb-direct-mapping/ * http://www.kaggle.com/competitions/search * http://www.w3.org/wiki/Foaf%2Bssl * http://www.w3.org/wiki/WebID * http://en.wikipedia.org/wiki/Semantically-Interlinked_Online_Communities * http://en.wikipedia.org/wiki/GNU_Health#Features 
Thanks so much for all this feedback - and the encouragement. I think I should be ok with the unit testing. I'm starting with test.py and it seems super easy. A while back I was scared of the standard unit testing module. Only hard work is getting it to work with persona.
"My company uses Python to automate image processing workflows and video streaming" That's the tech, that's what should be reported on. Not your company or it's SPECIFIC usage. 
Look forward to seeing what this means for ~~Matlibplot~~ Matplotlib, which wasn't directly noted. 
[This](http://support.microsoft.com/kb/303247) seems like a decent overview. An ASPX template can inherit directly from a C# class that inherits from Page, which allows custom code to be written in the class and invoked in the template.
sooo excited!
... And to improve [Blaze](http://continuum.io/blog/blaze), which extends Numpy with (among other things) support for data sets bigger than memory, compiling numeric kernels in Python to native code, and some really fancy shape manipulation.
The keyword is “might”. Most often it's just a closing parenthesis or sth like that that barely crosses the 80-column mark. Not really a crime if it's already a simple expression otherwise.
So is the Cosmic REST metadata in WADL format? Does this work with Swagger(https://developers.helloreverb.com/swagger/)?
Forgive my ignorance, but what are numeric kernels?
DARPA is probably the last government agency you should criticize for being a waste of money. Among the impractical things they've funded was something called the "Arpanet", which later came to be known as the Internet. They have remarkably low overhead, and don't make all their decisions by committee. In this case, their stated rationale is that they need better tools to work with sensor data on naval warships.
How do you match only limited characters in virtual paths? Eg in regex based frameworks I could match: /(?&lt;name&gt;\w+)/(?&lt;id&gt;\d+) To limit what each part can contain.
I guess it would've been too much to ask for an actual manual.
Which one? Note that we never put bugfixes in roadmaps; obviously we will fix as many bugs as we can in 2.7.x updates and during the development of 3.0.
At the moment we have no plans to provide a real manual (meaning a long text about PyCharm which is meant to be read from cover to cover), but we do plan to greatly expand our offering of tutorials and screencasts covering different aspects of PyCharm.
curly braces syntax is not supported yet. It's not possible to have traceback at compile time since there is no linking done. Actually the only traceback you get from the compilation process (500 from /compile) are parsing issues. Javascript errors are runtime issues like the one you had of an undefined method. Also right now get_attribute returns undefined when nothing is found instead of raising an AttributeError so it will be fixed sometime in the future.
Came here to basically say that. Its not too hard to build a real expression eval thing. I built a terrible one when I first learned C in 8th grade. Do it the right way, you'll get a load more out of it.
I didn't come to PyCharm from any previous IDE like it. I wasn't using anything like it on Windows, and I didn't use IntelliJ. So just getting started with it has been a tremendous amount of time. Three-minute videos and charts of keystroke equivalents don't do me nearly as much good as an explanation of what hundreds and hundreds of commands are. I've had a lot of trouble figuring out how it works with virtual environments I already had set up; navigating through the massive amounts of both application and project settings--pretty much, the first time I try to do anything it takes 15 to 20 minutes. I was _really_ hoping for a manual. I can read how to do something in 15 to 20 seconds in a manual, as opposed to having to find it in a 3 to 10 minute video.
Oh, wasn't expecting it to be something so simple. Thank you for the explanation!
How does it handle "modern" web development with fat javascript apps and an json API towards the server? ie. does it have a Tastypie?
It doesn't. Well, it apparently knows about returning JSON that then HTML based on file extensions. But .... .... every time I see one of these things, I just think, the author likely hasn't had any experience of large complicated web sites, by which I mean ones with lots of data entry pages and lots of back-end business logic. These frameworks are advertised as being great new novel ways of doing web applications. But they don't *do* web applications in general, they do a trivially small part of any significant application. They're not going to suddenly make life easier for most people. Arguments aside about whether MVC web frameworks really do implement "real" MVC, frameworks like Django (which I personally have a host of issues with) provide a structure on which to hang large applications. Stuff like Aspen look like a great way to the sort of tangle which befalls so many PHP sites. The page notes Guido's comment “It violates the principle that you should return from only one place". Whether thats a principal or not, it really makes a whole slew of stuff possible, for instance using middleware to handle some common needs. In Aspen that's (so far as I can see) just not possible. Another one is [meteor](http://meteor.com/). All very interesting and clever, and if your site is mostly an information display that updates in something approaching real time - something like facebook - then all well and good, and it might do the trick for you. But for most sites, natch, its just another child's toy. If they (Aspen, Meteor, ....) just said somewhere upfront "this framework will do such-and-such really neatly for you, outside that area your mileage may vary" they I'd look at them much more favourably. As it is, I just think "another guy/gal with a clever idea but who's had really limited experience of different web sites".
That's an interesting start! I'm curious to see where you take it next. One small wart that bothered me is the call to *normalize_schema*. While it makes sense, it's too ugly for python :) and it seems common enough to happen automagically when I assign a plain dictionary. schema = {"type": "string"} .... @horoscope.action( accepts={"type": "horoscope.Sign"}, returns={"type": "string"} ) Is so much cleaner..
Yes, but it doesn't have the autocomplete that IPythonQT has :(
This is just a link to some spam page, not even a story.
I can imagine Google closing many things, but I doubt that they will be closing GAE any time soon.
Ok, so because one tiny feature you probably are never going to use requires javascript, then it "doesn't work without javascript". You are amusing.
Point me to this mythical "properly coded" dynamic site, deployed on on cheap infrastructure, please.
As someone new to python and using the python plugin for intellij, is there a tutorial somewhere about how to set up your python project, especially how to use virtualenv? I'm pretty sure I have read that it has support for virtualenv, but i can't seem to find anything about how that works.
Yeah, but ... you know... Government is evil.
Excellent news. People often overlook the fact funding the facilitation of research is as important as funding the research itself.
When that feature disables the entire primary content of the page, I wouldn't call it "tiny"...
Can't go to slide #4 Uncaught Error: SyntaxError: DOM Exception 12 slides.js:115 buildNextItem slides.js:115 nextSlide slides.js:138 nextSlide sync.js:16 onKeyDown controller.js:14
Great. I Love PyPy. I know there is an own donation function on the pypy.org site, but I think on Kickstarter they could take a lot more money in a short time. Like [South](http://www.kickstarter.com/projects/andrewgodwin/schema-migrations-for-django) or [Veronica Mars](http://www.kickstarter.com/projects/559914737/the-veronica-mars-movie-project)
That's nonsense. Why should we have to tiptoe around our use-cases because we might offend a woman? And it's not like there's a clear-cut guideline. The CoC, if you actually read it, doesn't refer to just images. _Concepts_ to are verboten. Any material that is "sexualized" -- even a text description in clinical languages -- is forbidden. If ANY person decides something is offensive, PyCon condones broadcasting a public statement about it, and rewards the reporter--even if they determine no violation has occurred. This is not an environment we will invest our time and money to work within.
I think kickstarter is U.S only
Which autocomplete exactly do you mean? IPython running inside PyCharm uses PyCharm's autocomplete logic based on runtime information from the running Python instance, so it should work pretty well. If IPythonQT does something more, you're welcome to file feature requests for the missing functionality.
yes i saw that too , seems to work in Firefox , i will send an email to be fixed
Have you checked out PyCharm's quick start guide? http://www.jetbrains.com/pycharm/quickstart/index.html Every one of PyCharm's commands and settings is documented in the built-in help system, so if you want to find out what a specific command or setting does, or how to perform a specific task, you can always access the help system. We definitely plan to provide more text-based tutorials (similar to the existing quick start guide), not just videos.
Thanks for the Rockspec link. Some of how distil's build logic works now seems analogous with the information in your link - I'll take a more detailed look.
So people - and yes, governemnt researchers using your tax money - can use Python based solutions for free rather than buying *extremely expensive* software like MATLAB or LabVIEW or whatever - one copy which is probably 1 month of your salary. 
Any Linux. Use virtualenv. ArchLinux is quite good, so long as you remain aware that the 'python' command is symlinked to Python3, and you have to use python2 to run python2.x.
No environment is perfect, that said I use windows and don't have any problems. Here is a great page with builds of python packages for windows: http://www.lfd.uci.edu/~gohlke/pythonlibs/
import antigravity will actually work if DARPA has anything to do with it.
I am a former Linux user. Nowadays I am using OSX, as I also need to use a presentation software (Keynote, PowerPoint) and have a working video audio stack to make Skype calls. 15 years of Linux should be enough for everybody. I simply install everything using XCode + Macports + virtualenv for project specific libraries. It's as reliable as bleeding edge Linux distros. 
This was unexpected!
I use OSX with Homebrew, Aptana, Virtualenv, X-Code...nary a problem. Python should be useable between OS and Flavor. There may be some differences between *nix and windows, but nothing that shouldn't be able to be resolved through using available libraries that solve any one OS's issues. Things such as virtualenv may not work in windows - but should work the same on all *nix flavors including osx. 
Well, what I mean is (for example), in IPythonQT, you press "%" and "[TAB]", and you get this: In [1]: % %%! %config %%capture %connect_info %%cmd %debug ... ... etc. I'm also pasting the [actual example](http://i.snag.gy/66l5J.jpg), as it's very difficult to copy-paste from IPythonQT (it disappears whenever you press [CTRL]!) When you press [TAB] again, the cursor moves through all of the selections below. TBH, this is probably the best command-line auto-complete system I've ever seen. It's definitely better than CMD, it's better than the "I'm gonna beep until you tell me something more" system that bash uses, it's better then JPSoft's 4DOS/4NT/TCC system (which is what I normally use), mostly because it started to rely on actual windows (instead of in-console TUI, which can be used from SSH). ...So, where is this "feature request" page you're referring to? :)
[PyCharm Bug Tracker!](http://youtrack.jetbrains.com/dashboard/PY#tab=0)
No, it is incompatible with Swagger. Swagger looks great (seems to have improved since we last looked at it), but our approach is slightly different. By not trying to describe existing APIs we can make our spec simpler and more rigid, and our implementation more portable.
Thanks for the feedback. We started out by doing in the way you propose, but ended up going with `normalize_schema`. It is possible that we will end up getting rid of it again, I agree that it is not very Pythonic.
I get it too.....but that link is from the PyCharm blog so I am assuming it will be good. Edit: Seems to be up now.
I thought of a really provocative statement and it worked. Hahaha. 
&gt; [T]he author likely hasn't had any experience of large complicated web sites, by which I mean ones with lots of data entry pages and lots of back-end business logic. We're building www.gittip.com using Aspen, and I expect that to be the flagship and test case for a while, but you're right: I have limited experience and Aspen is unproven. Though since you suggest that Facebook is *not* a "large complicated web site," I'm not sure I trust your judgement. ;)
Note that REST branching is streamlined now, as we've added GET, POST, PUT, etc. as top-level booleans, so you can do: import blah # ====== ^L request.allow("GET", "POST") if GET: blah elif POST: blah response.body = {"success": blah}
Okay, we're moving to ---- instead of \^L: https://github.com/gittip/aspen-python/issues/167 :)
We've decided to change from \^L to ----: https://github.com/gittip/aspen-python/issues/167 :)
We've decided to change from \^L to ----: https://github.com/gittip/aspen-python/issues/167 :)
&gt; What about the division of labor between developers and designers? Good question! Aspen gives you a fairly neat division, actually. On Gittip, for example, we've got three main dirs in [the project](https://github.com/gittip/www.gittip.com): - `gittip` - Python library - `www` - web root (simplates in here) - `templates` - bases and includes for simplates So developers work in `gittip`, and designers in `www` and `templates`. Designers import modules from `gittip` into simplates and work with those APIs.
&gt; It seems to me that using \^L is always going to make people cringe. Okay, I've relented. :) We're going to change from \^L to ----: https://github.com/gittip/aspen-python/issues/167 :)
&gt;matplotlib* FTFY And I totally agree
With the idea being that you could also match: `/(?&lt;year&gt;\d+)/(?&lt;month&gt;\d+)` And send that somewhere else? You can't do that with Aspen virtual paths right now. You only get one wildcard per path part. The next level of complexity is "greedy" simplates: if you have a *file* with no extension named with a percent, it swallows all paths below it (that aren't otherwise existent on the filesystem). So `/foo/%bar` would eat `/foo/bar/baz/buz`. You'd have to process manually in your case, though. I've ticketed finding a way to fit your use case: https://github.com/gittip/aspen-python/issues/168
Okay, so from the example there it looks like a simplate would be parallel to one file with Mycodebehind.cs as the first page and MyCodebehind.aspx as the second page, ya? The thing that jumps out at me there ist the MyButton_Click call with runat="server". Looks like that's going to do a lot of magic to abstract away the network in between those two pieces of code, and Aspen doesn't do that. What specifically was learned from code-behind and how does it apply to Aspen?
Maybe. But I see it languishing. Guido isn't working on it anymore and Google is pushing Go. 
I'd recommend looking at Homebrew over Macports. Installs everything to /usr/local by default and doesn't ask for superuser unnecessarily.
Use a flag that gets flipped on first run?
Thanks, still learning it and always get that mixed up. 
Perfect, thanks for the info
I like Go.
Raspberry pi running Debian FTW. I've never felt better about spending $35. Okay I lied. I bought 3. 
There is also UK.
I use virtualenv+tmux+vim. 
PyPy support for gevent makes me extremely happy. I'm looking forward to updates regarding that! 
why doesn't that count? 
I don't understand how having another process prevents this. game scripting doesn't have to be ultra-high-throughput since it's usually just telling the engine what to do, so I'd think that importing the sandbox controller into the game and then using IPC from there should do the trick. Is that not the case?
I've used Ubuntu (since 8.04), every windows except Vista, cygwin and VMware/HyperV/VirtualBox. There's no perfect solution - from what I've used so far it's like this: * Ubuntu (and I suppose every other linux) will suck bad as a desktop. You need to fiddle with the configuration files all the time and stuff stops working properly after doing many upgrades. Expect flash websites to fail all the time and don't even get me started on how horrible is to make a multiple display setup. Ubunut is a poor farce when it comes to beeing a desktop operating system. But ... it works really well for development, most of the time everything installs and compiles out of the box and debugging tools are top notch. * Windows will make you jump through hoops if you want to do any real development on it. You'll need visual studio (the "right version") if you want to compile C extension. If you don't fancy the metro ui just use 7 otherwise 8 is really good and stable. Everything else just works properly, your desktop manager doesn't crash like in Ubuntu, video drivers just work, everything is polished (at least in windows 7 :) ... but then again ... no strace, arcane shell system and so on .... * cygwin is a toy really ... don't even bother with it. No one tests packages or anything there ... * VMware is nice, has ok windowing system integration (the "Unity mode" - don't confuse it with Ubuntu's Unity) but it is plagued by glitches and focus issues - it didn't detect focus-out properly a year ago, I don't thing it got fixed. Also, you need to install these integration kernel modules (vmware-tools) - which suck - every kernel upgrade is going to make them glitch and now your vm cannot be shutdown, you need to log in and run the shutdown command yourself or reinstall vmware-tools - awful ... * VirtualBox is kinda the same - I haven't used it much but it's the same idea but more scriptable (that's how Vagrant was made possible) and no "Unity mode" * HyperV is different - it's a headless virtualizer while VMware and VirtualBox are desktop virtualizers. This means HyperV has really good integration with windows but it's a bit more work to get it setup, you have no NAT from HyperV so if you want to share that VPN connection with the VM you're stuck with ICS (which is an unreliable piece of crap). Yeah, better make a shortcut to that ICS restart command ... But, and this is going to surprise you, integration of Linux in HyperV is really good - Ubuntu 12.04 ships with the integration kernel modules - you don't need to install anything at all ! No configuration fiddling, no googling for solutions - it just works ! You can set your vm to shutdown when windows shutsdown and starts when windows starts. This is actually nice. No more fiddling with VMware/VirtualBox scripts and services to keep your vm running. And you get this for free in windows 8. Now this leads me to my final point: If you don't want to run desktop apps inside the vm (in other words, you hate full screen mode or having two taskbars) then you have a problem. The best here is VMware which can accelerate graphics and and Unity. The rest are going to suck. HyperV can't even resize the display. But there's another way ... You know why Linux desktop sucks right ? X11 - it's arcane and it was designed for mainframes. Well, both a curse and a blessing I would say. You can run a X11 server on windows and have your VM use it instead of the local one. It's easy to setup (just enable X11 forwarding in Putty) - and don't use Xming - use [vcxsrv](http://sourceforge.net/projects/vcxsrv/) - this one actually gets maintained ! Ofcourse some apps won't work very well with a remote X server. Komodo works very well, PyCharm is a bit slow and has some "where my focus just go" issues, SublimeText is unusable (extremely slow). Haven't tried eclipse but I suppose it's plagued by the same problems as PyCharm (it's still java). But then again, PyCharm and Eclipse were too slow for my taste anyway back when I was struggling with Ubuntu as a desktop ...
It was down for a while earlier today, but should be up now. Sorry for the inconvenience.
Hmm, that's a little vague / open-ended. Perhaps you can send me a sketch of what you want the UI to look like, or your code so far, or specific questions.
python doesn't need to be funded from the resources of people who don't use python
NOOOOO... IT SOUNDS LIKE SCIENCE... 
Just a side note arch is awesome, but if you are new to Linux I would recommend something more like Debian, Ubuntu, or Fedora since arch can be really difficult to get setup and working and potentially kill any motivation you had to use Linux.(once you do get it set up it is really nice)
I did, but often it just raised more questions I couldn't easily answer. For example, this text from that guide: &gt;In all these cases, you need a special profile, or a run/debug configuration, which defines script name, working directory, environment variables, and other vital things. _Vital_ things? Ooh, better go have a look at that, thinks me, not wanting to get lost later when debugging doesn't work. Off to Run &gt; Edit Configurations I go, and I see "Python," "Python tests," and "Defaults." Well, let's look at defaults, since that could get me screwed over for lots of things. In "Defaults" I see "Python," and I open that and don't really understand what "script parameters" would be. Wouldn't "working directory" be my project's by default? It's blank. So I click the "?" button to open the user guide, and on my Mac OS X 10.8.3 system running PyCharm 2.7.1, I get [this window](http://i.imgur.com/GhnshHD). Well, obviously that's no help, and the Web is slow today, so I'll look at the top-level "Python" settings. There I see my current project. OK, now I'm getting somewhere. I see the working directory is set correctly, as is the interpreter and the script, and now I understand what those things are. But what is a checkbox for "shared?" or "Single instance only?" Let's try to find out. I go to the browser and kind of reflexively type "pycharm.com." When it finally resolves and goes...I get rick-rolled. OK, find the JetBrains site and go that way, done. Resources, online help, here we go. Now, is this a "Basic Concept" or a "PyCharm Usage Guideline?" (The latter sounds more like some kind of licensing restriction to me.) Basic Concepts seems to work, getting to running and debugging help. After about six clicks, I'm on "creating and editing run /debug configurations." Nope, not there, one more to get to the "run/debug configurations" page. Another click to scroll down that page and finally I'm here and see what these checkboxes do. "Share" proves irrelevant as I have no other team members on this, and "single instance only" means "run a new instance each time even if the old one is still running." But I've now spent 10-15 minutes simply trying to figure out what these "vital" tasks are that were mentioned in the quickstart guide. And I still don't know what the difference is between clicking "Apply" and "OK" in this giant dialog box, nor does the online help tell me. I usually click both just to be sure. This same task would have taken me less than 2 minutes with a manual. Repeat this for many of PyCharm's hundreds of features and you're where I've been. Most of what I get from the quickstart guide is "There is a lot of stuff here that could silently affect your project and all we're going to do is hint at it. Good luck!" I was really hoping for a manual.
&gt;And I still don't know what the difference is between clicking "Apply" and "OK" in this giant dialog box, nor does the online help tell me. I usually click both just to be sure. This is a standard UI convention. Apply saves the saves you made and leaves the window open. OK saves the changes and closes the window.
Windows is out of the question. I'm trying to get things setup faster and easier not the other way around.
I'm getting really curious about this raspberry thing.
Bonus points, if you write a scaffold (of course in http://mrbob.readthedocs.org/en/latest/)
for me: FreeBSD + Enlightenment 17 + tmux + virtualenv + vim (with the Lucius colorscheme)
I agree with you the perfect environment is that where I get shit done without having to go on a yak shaving trip to get a lib rolling. I have given up on many things bafore because I wasn't able to get PIL to work. This time around it is SimpleCV. Shouldn't python libs just run after "pip install"? Maybe I'm just spoiled.
Thanks for your detailed feedback! I've forwarded it to the documentation team, and we'll use it to improve the product documentation. I've also filed an issue to make the product UI less confusing: http://youtrack.jetbrains.com/issue/PY-9333
Wireshark ( network/socket analysis tool ) uses WinPCap for that purpose. ~~Quick googling for winpcap &amp; python led to this https://code.google.com/p/winpcapy/~~ Apparently the project exists but no source was checked in. Glancing over it, you may need to get acquainted with ctypes if this doesn't compile correctly or hasn't exposed the necessary API. Also as a word of warning, its almost impossible/very difficult to snoop on the loopback device on Windows 7+ due to how Microsoft set that up. edit: Another tool called Pycapy here - http://corelabs.coresecurity.com/index.php?module=Wiki&amp;action=view&amp;type=tool&amp;name=Pcapy Last release was 2010.
I actually switched to OSX recently, and am loving it. But I found the same thing, Python development using some modules is quite difficult. I use a virtual machine, and setup [Linux Mint](http://www.linuxmint.com/). So I get the best of both worlds. That way you avoid dual-booting also.
I use Pillow just fine. I did look up SimpleCV and the install does look a bit convoluted, but there does seem to be examples of installs on OSX of various sorts. SimpleCV https://github.com/ingenuitas/SimpleCV Pygame http://pygame.org/wiki/MacLionCompile?parent=MacCompile I am going to try and get them installed on my macbook air. I will let you know how it goes. VMWare is an option for running a *nix flavor side by side...no real prefect solution. I have one Python setup on a PC with Iron Python to work with Rhino and Grasshopper and another on OSX using various versions with Django, Flask, Bottle, etc. 
Thanks! Great info!
I would recommend checking out [WireShark](http://www.wireshark.org/) to see what you're up against, promiscuous sockets and network sniffing is generally the first introduction engineers get to dealing with [fire hose problems](http://www.youtube.com/watch?v=OXc5ltzKq3Y) ( lots of information at an unhealthy rate ). 
Thanks, I'll think about it The original Idea was to give the beginners understanding of how they should start. (Well, at least one of the ways) But maybe I'll do some scaffolding after everything will be covered with documentation :)
Thanks for the tip; done.
That is pretty awesome.
pygame would be a good choice, you could also look at the blender game engine kivy would be good to make a "controller" app for your installation
yes, it's java, you could also look at "fluxus" (scheme), impromptu (common lisp) i've used pyopengl before which is an interface to opengl, is fun for playing with 3d graphics
Cool, thanks
You can't MITM them?
Awesome idea. You might want to look into using some form of IPC to communicate between the server and client as this will help with the race condition you've noted in the documentation. You'll also be able to get rid of the sleep() in the daemon process.
Thanks again. Fluxus and impromptu look pretty cool too for live performance. Processing seems very promising too. I hope I'll be able to use the knowledge I acquired while learning Python on this language. I have some basic Java knowledge too and I feel like it's so different from Python. 
is it really that hard to look up the formula and write it? def f(t,y): return e**t def rungeKutta(t,y0, func): y = [y0]; yi = y0; for ti in t: k1 = func(ti, yi+0.5*k1*h); k2 = func(ti+ti/2., yi+k2*h/2); k3; k4; yi += (k1+3*k2+3*k3+k4)/8; y.append(yi) return y t = [1.,2.,3.,4.,5.,6.,7.,8.] func = f y0 = 0.5 rungeKutta(t,y0, func) If that doesn't get you 90% of the way there, quit. The formula is not right, but they layout is. It sort of depends on what you're trying to solve, 1st/2nd/2nd order stiff and how you want to interface with it (e.g. dt vs time series) but I'll leave that to you. EDIT: pretty! you need four EXTRA spaces.
Not sure why you linked to an unchanged fork? [Actual repo](https://github.com/fogleman/Minecraft)
This solves a series of 8 equations? 
Well, of course I cant show complete source code, but http://vidassa.com built on this approach... mostly Starter based on stuff implemented for this project. But whats done there can expand for dozen of articles :) 
http://nodebox.net/ is the usual python alternative to processing. 
I'm not going to do the WHOLE thing...but it's pretty close. Also, there's a few different ways to do a 4th order runge-kutta, so take your pick. Or you can just use scipy.integrate.odeint, but they you have to write it in first order form.
Okay thanks. Sorry if I sound completely useless, this is for a school project, I have never used programming software before, and out professor didn't teach us much of anything on how to use it. 
Lines starting with four spaces are treated like code: if 1 * 2 &lt; 3: print "hello, world!"
What the fuck is up with you. 
Speaking of Processing-like environment in Python, there is also [Pycessing](http://pycessing.org) (which is just coming out) or [Pyprocessing](https://code.google.com/p/pyprocessing/)
Now I don't know what to choose, haha. All these alternatives are pretty interesting. Pycessing seems to be really, really just starting so I don't know about that one : I'd need as much documentation as I can and there seems to be next to none. Pyprocessing, in the other hand, seems to have comprehensive tutorials and documentation. Interesting. Thanks to you two.
Lessons in C? I wrote a DCPU-16 emulator in C. Among many other projects. What have you done lately? https://github.com/fogleman/DCPU-16 
Heh, I wrote this. It's about 500 lines of Python. It could be less, but I have some code in there to split the world up into "sectors." Only the sectors near you are rendered, for performance reasons. I'm not convinced that's the best way to do it and I'm curious how the real game does it. I also only render exposed block faces. I didn't spend much time on this. Maybe I should re-visit it and try to make it a simple, generic Minecraft-type game engine.
I was wondering the same thing. At least we got a cool Minecraft thumbnail on the reddit post this way.
You should definitly go for Processing. The community is huge. There is so many examples and tutorials everywhere. And code is quite easy to learn especially if you start learning programming. Your experience in Python will help. And it has built-in functions to deal with video input. Here's a good ressource for examples of any kind: http://www.openprocessing.org/
That is pretty cool. My son loves minecraft.
I couldn't have said it better myself I found code academy to assume you knew something about programming before and I gave up on it, i have been using how to learn python the hard way and I agree it teaches the basics, gets you studying drills and gradually moves to harder and harder stuff...
Please stop commenting. This is bad writing. It reads really retarded, there is one huge paragraph with unreadably many words. If I were you I'd start taking some lessons in social skills. This will teach you better communication and social skills. Like not putting your foot in your mouth. And adding comments to reddit that are hostile and open for public ridicule.
http://pyvideo.org/category/33/pycon-us-2013 the video is there. alex gaynor also had another one on the same topic but different libraries.
&gt;there is one huge file with unreadably many functions. It's 500 lines! That is not huge, that's pretty typical.
I just appreciate it when someone has actually put time into making his project in such a way that it's easy to understand what's going on and to contribute. I might have gone a bit too far saying the code is bad and the project should be stopped. It's late.
Thank you for open sourcing this! Are you accepting real-world karma? https://www.gittip.com/on/github/fogleman/
Hi, Shoebot is an alternative implementation of nodebox1 - and can be used in on platforms that nodebox1 can''t be (ie non macs). On the other hand the latest nodebox does look pretty awesome. disclaimer - one of the shoebot devs. [EDIT] - Kivy looks very cool too, especially the multitouch stuff it does... also processing can be used from jython... which is interesting as you get python - but with processings large library support. S
Neat... thanks!
Are there separate chunks on the Y axis now? It used to be that everything was loaded from bedrock to sky, but it wouldn't surprise me if jeb rewrote that during the Anvil world format update.
I've been programming for years, mostly web development, but I wouldn't even have a clue how to go about this. I started making a 2d settlers game in Python with PyGame and so far all I've been able to do is initialize the board and know what resources the user is clicking on.
Have you got a plan? What's the next feature you need?
While I would agree that it could be split up in several files, I find the code pretty readable as it is.
I got side tracked with my masters program so I haven't touched it in a while. Here's what I have so far: https://gist.github.com/sareon/5268205
700mhz ARM processor, 512mb ram, hdmi out, runs on 700mah from a microusb power supply, runs a ARM edition of Debian which I haven't seen behave any differently than an x86 version. It's powerful enough to even boot a GUI. I actually built a trilateration service based off WiFi using 3 of them for a class project (and using mostly python). Total bill was under $200 for cases, wifi dongles, power supplies, and 3 pis. That's a lot of hardware for peanuts. If you have any interest, just go buy one. I guarantee you'll love it. At $35, I'm sure you've spent a lot more money and gotten a lot less satisfaction. PM me if you need more reasons. 
no it's still bedrock to sky. So 16x16xwhatisitnow256?
The solution for Win 7 doesn't seem to work, good to know they fixed it for the next generation though. A lot of info on possible solutions for the win7 loopback, I tried half of them and then just broke down and started debugging with two computers. http://wiki.wireshark.org/CaptureSetup/Loopback
This is incredibly cool. My little brother wants to learn python and loves minecraft. This is a perfect project for him to hack on and to keep him inspired! If I get the time I might go through and put in doc strings, would you accept that as a PR?
Whoa that's neat! I hope to see /spec.json all over the place soon :)
I don't read it but maybe it's for you: [ The Writing Idiomatic Python Book (9 USD, 74 pages) ](http://www.jeffknupp.com/writing-idiomatic-python-ebook/)
which does not help. you need to live in UK or US to receive money, most of us don't.
Two things I can think of reading your source: 1. You aren't really accurately discretizing the drawing parts and the simulation parts of the game. Any game worth its salt runs a simulation independently of how it is displayed with virtual coords / maps, and the rendering is just done as a snapshot of the game world. For example, the event loop should probably have a coordinate conversion of a mouse click on a region and call some method in the board that whatever a mouse click correlates to (you wouldn't want to call board.mouseclickAt() it breaks the abstraction) and let the board resolve the agents at those coords to interact with, etc. 2. You seem to have written it as a one off, but if you start thinking about game design from the structural level, you need the concept of "start a new game" as an algorithm so you can restart, etc. A lot of it seems to be a planning problem - a game is a very simple 4 step (5 with networking) process: * Resolve events (regardless of source, network, keyboard, etc) * Update the game world after external events are processed for a delta of time. * Render the frozen state of the game as it is. * Swap buffers (double buffering) and display frame. * (optional) communicate changes in the game to external sources (in a multithreaded game, this can be done any time after the update). It is just important to recognize how a game "progresses" which I think is the barrier you are up against.
I would have no idea how to start that. My experience with game programming is what I learned from the PyGame tutorial: http://inventwithpython.com/chapters/
As someone just starting to learn Python, and new to programming / comp sci in general, this is pretty damn inspiring. 500 lines of code doesn't sound like something unattainable.
There's no free VMWare for OSX. You have to purchase Fusion, or use a different product like Virtualbox. 
Feedback welcome; I just rewrote a lot of it to support getting each monitor as a separate PIL Image.
* http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html * http://scipy-lectures.github.com/advanced/advanced_python/index.html * http://www.youtube.com/watch?v=uOzdG3lwcB4 * http://scipy-lectures.github.com/advanced/interfacing_with_c/interfacing_with_c.html * http://pypy.org/ * http://www.python.org/dev/peps/pep-0008/ * https://pypi.python.org/pypi/flake8
So, sector = chunk?
FUCKING DO IT ALREADY! Seriously, my little cousin is obsessed with Minecraft, and if I could find a way to show him that his intelligence could be channeled into programming, he'd be better off than playing video games all day. A Python engine would be so great to get kids interested in programming.
What if they are in different folders?
Very cool! Let us see source.
Wow, that looks really awesome. If I compliment your neckbeard, will you give me free access? ;)
Internally, they split that chunk up into 16x16x16 pieces for rendering purposes.
You provide the whole path for each file.
I'm nowhere near a pro, barely amateur really, but I figure I'll add something in here. I learned a lot about how a game "progresses" by learning Unity, especially as far as how to structure pieces of a game. It really eased me nicely into sort of imagining how "things" in general are handled by a game. Objects and their logic and all that. It's not *directly* applicable to game development with PyGame/Pyglet (the overall concepts certainly are, though), and it's probably too much to try and do if you're working on your masters right now, but it's also something that could be knocked out [in a day or two](http://walkerboystudio.com/html/unity_course_syllabus.html) if you really wanted. I followed the course up through the point and click game and that gave me the tools and knowledge I needed to make a simple top down shooter in the vein of Crimsonland and Nation Red. Emphasis on simple, but it's playable as hell. I should really finish the course...
Right, but what if you want to copy 20 files from 20 different locations? That would be painful.
It is a good sign that it is 74 pages. Thanks.
I was bored last weekend and I thought I would love writing a simple good ol' Doom style engine in Python. never done that but it's a problem that I'd like to understand more. Your example shows me there are other people with similar weird idea :)
I'll have a look during the weekend! :)
This is impressive, thanks for open sourcing! 
Disclaimer: self-taught programmer with no formal training in linear or relational algebra, so may be difficult for me to apply my knowledge/preference to your background. TL;DR I can explore data quickly, especially in aggregate. For me it boils down to how the SQL language allows for expressing relationships, predicate logic, and set operations. Say we have a matrix of barometric readings at fixed intervals (every minute) from different locations across the globe. Rows=location, columns=measurements. Also I'm pulling all these numbers straight out of my buttox, humor me. Each of these locations has additional attributes - country &amp; city, lat/long, altitude. Mostly categorical values. What was the average pressure in the US in March 2013? &gt; SELECT &gt; AVG(m.value) &gt; FROM measurements AS m &gt; JOIN locations AS l ON l.location_id = m.location_id &gt; WHERE &gt; l.country = 'US' &gt; AND m.datetime_added BETWEEN '2013-03-01' AND '2013-03-31' |AVG(m.value)| |20.4234563| Standard deviation and segment the results by province/state: &gt; SELECT &gt; l.province, &gt; AVG(m.value), &gt; STDEV(m.value) &gt; FROM measurements AS m &gt; JOIN locations AS l ON l.location_id = m.location_id &gt; WHERE &gt; l.country = 'US' &gt; AND m.datetime_added BETWEEN '2013-03-01' AND '2013-03-31' &gt; GROUP BY &gt; l.province l.province|AVG(m.value)|STDEV(m.value) :-|:-|:- California|19.4513|4.5349 New York|20.4298|8.344 Now I want these values grouped by by year &amp; month: &gt; SELECT &gt; l.province, &gt; YEAR(m.datetime_added) AS year, &gt; MONTH(m.datetime_added) AS month, &gt; AVG(m.value) AS avg, &gt; STDEV(m.value) AS stdev &gt; FROM measurements AS m &gt; JOIN locations AS l ON l.location_id = m.location_id &gt; WHERE &gt; l.country = 'US' &gt; GROUP BY &gt; l.province, &gt; YEAR(m.datetime_added), &gt; MONTH(m.datetime_added) l.province|YEAR|MONTH|avg|stdev :-|:-|:-|:-|:- California|2013|01|20.4|3.8 California|2013|02|19.9|3.4 California|2013|03|19.5|3.2 How about pressure based on altitude of the location? Or surrounding population? Takes little time for me to asks these questions in SQL, but much more for me to do so in code, even with pandas &amp; NumPy.
I love using the [SCons](http://www.scons.org/) API for making quick and dirty build scripts, especially for non-Python languages! Oh, and [SciPy](http://www.scipy.org) and the Imaging library are fantastic for image analysis.
Apologies if I gave the impression I though FB was *not* a "large complicated web site," clearly it is! I used it as an example of the sort of site that meteor might be good at - a lot of dynamically changing data being displayed and updated in real time.
a couple of people have done ruby processing ports - ruby is more similar to python so one of those might suit you - i don't know how well they work though
Howcome this links to an unchanged fork rather than the [original repo](https://github.com/fogleman/Minecraft)?
There's a Minecraft for the Raspberry pi which allows exactly this. http://pi.minecraft.net/ http://www.stuffaboutcode.com/2013/01/raspberry-pi-minecraft-api-basics.html http://www.stuffaboutcode.com/2013/02/raspberry-pi-minecraft-analogue-clock.html 
I don't think that a son could write this to his father. I hardly believe that you are a father...
There's an optional third variable in range that lets you set the step size, which can be a negative value (in which case it will count down).
May as well future proof him and use python3 ;)
Went into it with prejudice and hate, came out pleasantly surprised. Nice writeup!
Slide #3: "Python is awesome!" Okay, well at least we're starting on the same page... ;)
While these slide shows can be informative, every time I see one I think it's a failure. If I can understand everything on the slide show, you're using slide shows incorrectly; What's the point of you speaking if reading the show behind you is just as informative? If you are using side slows to properly supplement and not implement your talk, then reading a side show will ineffective.
Generics, some inconsistent style regarding allocations, and error handling are the things that hold me back from looking further into Go
A chunk is still 16x16x256, but entirely empty 16x16x16 cubes need not have their data recorded in the chunk file
im totally baffled why the scientific community doesn't seem to need to ask data questions like these, otherwise SQL would be a lot more popular. I'm hoping that by bringing some SQL tools into the numpy/pandas community, maybe their use cases will become more apparent to me.
74 pages, but it is incomplete, as the website says.
Your professor is a jerk, and I would pay a visit to the school management to get him outta here.
One of the things I learned in high school is know the audience of these presentations. If the plan is for them to download it, its OK to put more information in the slides then in a one-off live presentation.
I will kill you for those semicolons.
Just a guess, but the difference between the two code methods looks like it has to do with creating multiple interpreters vs using only one interpreter. By creating and destroying an interpreter instance for each i you are automatically cleaning up any variables or files left open. The memory leak is still there, but the code does not run long enough to leak memory. I suspect that maybe savez does not close the files it opens automatically. You could test this by opening and closing the output file explicitly. 
Yet you use Python?
&gt; prejudice and hate Against a tool? Wow.
Dont know of any, but have a look at slidify and howto generate CSS slideshows. Then you can simply put one together by yourself. Edit: https://github.com/adamzap/landslide
Care to expand on the contradiction you see? Python libraries are dynamically linked, to the extent that the terminology can be applied to Python.
chill dog. figure of speech and all that. gotta love english. Takes everything too literally? wow.
 func (destination CheckingAccount) Desposit(amount int) error { ... } I've never approached Go so my question may sound daft but what's the purpose of "error" here? Is this a keyword or a type? Is it just to document the fact the function may return an error? If I don't provide it, does it mean the function must never return an error at all?
Except when you're running Python applications you need all the Python stack, i.e. for running Django, you'd need Python+standard library+Django. Go would be a single binary usually no larger than 9mb. Fine for me.
Definitely know your audience, but the options aren't just slides for a talk and slides with more information on them. It's a sign you shouldn't be making a deck of slides. There are other options -- if the plan is to have them download it to read it at home, you can write it long form, go to town on detail, include downloadable code samples etc etc.
`error` is a type. Return types have to be made explicit. func test1() error has to return an error (possibly `nil`). func test2() cannot return anything. func test3() (int, error) hast to return an int and an error. Many functions fit the last pattern: i, err := test3() if err != nil { //handle the error }
Ach, my bad. But $50 for VMWare Fusion? That's nothing! Workstation for Win/Linux runs $250. Maybe that's why you get free VM player with Workstation...
Cheers. That makes sense. In the example, he returns "nil" and I thought it was strange it represented an error.
[hieroglyph](http://hieroglyph.io/) makes slides out of ReST documents using Sphinx.
I wouldn't consider that spoiled. I find that as I get older, I have less patience with things that waste my time. So, if I'm deploying to a Linux production server, I'm going to do my development on a Linux box. 
I don't know about SimpleCV, but I was playing with pygame on my Raspberry Pi at pycon.
So you don't care about compile-time typechecking?
I see. Thanks for the explanation :)
Actually, I use Jenkins to check out my scripts from version control and run them on the fly, so I kind of appreciate not having to do any sort of compilation step, or at least having compilation to bytecode magically hidden away by the interpreter. I'm sure compile-time typechecking would be nice to have (I did use Java a lot once upon a time), but I rarely run into type problems.
One of the things Go is supposed to be good at (from what I hear, haven't had a chance to do much with it yet) is fast compilation. It was specifically designed to avoid a lot of the things that make it so C++ takes a long time to parse, compile, and link. I think you could use `go run` or `go test` for CI and it would be more or less the same.
Very cool.
From [golang FAQ](http://golang.org/doc/faq#new_and_make) and [Effective Go](http://golang.org/doc/effective_go.html#allocation_new).
Why is this inconsistent? They do different things: `new` only allocates memory. `make` allocates memory and initializes. If `new` allocated on some occasions and initialized on others, it would be inconsistent.
For different tasks, yes. 
Might want to move the conditional out of the loop, since it's really only dependent on the loop completing, and it's a clear performance hit.
I'm not sure if it helps but Guido just posted this on his twitter. ------ Best way to find #python memory leaks: objgraph pypi.python.org/pypi/objgraph
Minecraft for the Pi is a great way to great children into programming is easy to acetone results quickly. Check out the game of snake I made in minecraft. www.stuffaboutcode.com/2013/03/raspberry-pi-minecraft-snake.html
or even better: for x in reversed(range(11)): 
haha idiot.
[Here you go.](https://dl.dropbox.com/u/61793545/mandelbrot.py)
I keep seeing these posts and I think Go is cool and everything but I am not interested in _replacing_ Python with Go. I would love to _augment_ Python with Go instead of C. I would love to see a tutorial about that.
"I just made fun of my dad and all he did was laugh and put a picture of it on the internet."
Landslide rocks. Some presentations might look spiffier, but it works great, has a presenter mode (something many slideshows forget) and you write slides in markdown not in some cumbersome HTML crud. I use landslide for most presentations I do
I also thought I rarely run in to type problems. Then I started using Go for some things and realized how many problems in my Python code actually stem from type problems. Also the compilation time is negligible for most programs. I'm now a happy user of both languages. 
Upvote for Raspberry Pi.
Depends on the perspective. Yes, they technically do different things. The difference is to users *that does not matter*. I do not want to keep track of what needs initializing by "make", a random function, or that the zero-initialized memory is acceptable. I don't want an opinionated language that thinks I don't need a feature when they can't even design the language without it. Either everything should be using "new" only or everything should have access to "make".
&gt; I do not want to keep track of what needs initializing by "make" You don't have to keep track of anything. There are exactly two types that need initialization with `make`: channels and maps. If you can remember how to open files, close files, open database connections, close database connections, then you can probably remember how to deal with the two build-in types that appear in virtually every Go program. &gt;Either everything should be using "new" only or everything should have access to "make". No. `new` is the same as `malloc` in C. `malloc` should not initialize anything, it should have zero overhead. A separate keyword is the only sane choice here, as long as you don't want to introduce two large new concepts into the language, only to deal with slices and channels.
nice! the only thing i don’t like is that it exploits implicit behavior of the / operator when dealing with floats and ints: this makes it not run properly on python3. you should better use `from __future__ import division` and explicitly use // to get truncating division, instead of hacking around it like `width / float(height)`…
Since this is in the interpreter, the only way for it to execute that additional statement outside of the loop would have been to write a method. Since this is an introductory lesson, I assume OP just wanted to keep things simple.
Go's error handling is very well thought. I won't say it's better than python's but certainly is a respectfull aproach. There is a talk about it at the recent pycon, it's a nice sum on the topic.
I've always wondered why they used rectangular chunks, now it makes sense.
I definitely appreciate the static code analysis provided by a real compiler. There are too many ways you can shoot yourself in the foot at runtime with Python. Which has always made me wonder why the official Python distributions aren't bundled with something like Pylint or pychecker? I consider those tools *mandatory* if you're doing any significant amount of Python development. Unfortunately, (last I checked) pychecker seemed to be abandoned (not updated in years). Pylint seems to be actively maintained, but not available in all Linux distros (specifically, RHEL doesn't seem to want to officially support it). The other problem is that Pylint and pychecker don't always find the same class of problems -- you almost need to run both of them to be completely assured that you haven't missed anything (even then, there are no guarantees). In any case, I wish the Python.org weenies would "adopt" one of those two (or create their own) and start bundling it with the standard Python distribution. Without it, the whole "batteries included" thing is falling a bit short. 
I was skeptical, since it seems like changing the step size would be more efficient than creating a list with a different step size and then reversing the whole list, but apparently you're right. import timeit print timeit.timeit(stmt="for i in range(10000000,0,-1): d+=i",setup="d=0",number=2) print timeit.timeit(stmt="for i in reversed(range(10000000)): d+=i",setup="d=0",number=2) Output: 2.58884978294 2.35041093826 Using reversed was about 10% faster. Go figure. (OS X Lion, Python 2.7.1, FWIW.) Edit: When you use xrange (and you should, for large ranges like that), it evens out: 1.48559999466 1.48719191551 Edit again: To make it more relevant to the countdown at hand, let's make the for loop just 10 and time a million repetitions of it. print timeit.timeit(stmt="for i in range(10,0,-1): d+=i",setup="d=0",number=1000000) print timeit.timeit(stmt="for i in reversed(range(10)): d+=i",setup="d=0",number=1000000) 1.50534105301 1.62769198418 print timeit.timeit(stmt="for i in xrange(10,0,-1): d+=i",setup="d=0",number=1000000) print timeit.timeit(stmt="for i in reversed(xrange(10)): d+=i",setup="d=0",number=1000000) 1.46578407288 1.37068891525 The moral of the story: fuck this, I don't get it.
It's about security updates.
You're likely to have more success with Rust for that. Go can't reasonably called into.
I like pyflakes. It's fast enough to run it continuously in your editor and find typos and missing references.
SQL makes it **INSANELY** easy to slice and dice your data. Only need a few specific fields to answer a question? That's what the `SELECT` clause is for. Only need data for a certain subset of records? Say hello to `WHERE` (and `HAVING`). You can do the same sorts of things in a data processing pipeline. I did it yesterday for some baseball stats (`cut` to pull the categories used for scoring in my fantasy league, `grep -v` to exclude AL players, etc.). But I only did that because my needs were simple, and the data came my way in a CSV file. If I had needed something more sophisticated, I probably would have pumped the CSV data into a sqlite3 database and started sharpening my queries. One area where I think the traditional scientific processing tools have an edge is in advanced statistical analysis. Most database engines have advanced statistical packages, but they're non-standard and (at least in my experience), not particularly well documented.
It is possible that the slides are only a subset of the talk. But the slides are sufficient to convey the message. The rest of the talk could have been live coding or a nuanced discussion of additional details.
The IPython devs are working on one right now. You can actually get it by installing the development builds of [IPython](http://ipython.org/ipython-doc/dev/install/install.html#installation-from-source) and [nbconvert](https://github.com/ipython/nbconvert) Then follow the instructions [here](http://www.slideviper.oquanta.info/tutorial/slideshow_tutorial_slides.html#/) which is also an example of how it works.
the moral of the story is that premature optimization is for suckers
&gt;I suspect that maybe savez does not close the files it opens automatically. You could test this by opening and closing the output file explicitly. Hrm, I tried explicitly opening and closing the file def findem(SNAPNUM): some function stuff and calculations f=open(filename,'wb') savez(filename) f.close() But it still seems leaky. Must be one of the other functions I'm calling =/ I think you're correct about the separate interpreters though.
Let me guess. You're either (a) from 1750, or (b) not from a western country.
Seems like overkill for the small number of messages that I'm looking for... Or, am I wrong?
Wouldn't using a loopback adapter stop those transactions from taking place? In other words, I want to capture the packets during a live session.
"new" is like "calloc" and so there is overhead but it is low compared to a constructor. My point is that if they need it for the language, it probably is needed for library developers. See lucian1900's comment about OrderedMap. My opinion on language design is probably going to have no effect on golang, it probably is incompatible with some of the design goals of golang. These are just my opinions for why this Python/C++ developer is skipping over golang until there is a compelling need to.
The concurrency model does sound nice and it seems to have worked well for a lot of people. I like the idea of being expressive even in my concurrency model though. I suspect favoring one approach, even if others can be built efficiently on top of it, will lead to neglect of the others.
they were to try to be nice when I didn't know how to write code on reddit. i don't use semicolons.
&gt;My point is that if they need it for the language, it probably is needed for library developers. See lucian1900's comment about OrderedMap. Yes, the need for the make keyword arises from the lack of generics and overloading. The normal Go-style would be something like slice := lists.NewSlice() but without generics this is not possible. 
&gt; I'm talking about problems that it can be a tool to solve I'm also interested in this.
Python is *really fucking good* at making iterators go fast. Use them, your code will go fast.
Memory can leak for a few different reasons. The usual one is keeping references to things that aren't needed. Another is string interning, where some code tries to make string processing more efficient by keeping a hash table of common strings so they aren't duplicated. Another possibility is memory fragmentation, where things are freed but you end up with gaps between live objects in memory that are an inconvenient size to be allocated again.
How do you know it's a Raspberry Pi?
 echo cp file1 /trash/movies/ &gt;&gt; q.sh echo cp file2 /trash/movies &gt;&gt; q.sh echo mv file3 /trash/movies/ &gt;&gt; q.sh . q.sh
My dev (actually ~/src) is replicated online on github &amp; bitbucket! Except nomados and graphitidb... but activly working on PythonScript.
Thanks for your interest, all of you :)
He could use else to write "lift off" :)
Can you extrapolate a bit on how this is put together? In Pygame you tend to have a running loop (While True: .. ) but I don't see any loop in this other than the enqueue/dequeue and the pyglet.app.run(). Does Pyglet look for particular structures and do something with it? 
My pet Projects/Scripts: - Email a daily affirmation to a group of people - Email my home IP address once a day (dynamic IP address at home that changed more then I wanted) - Various web scrappers 
I'm not sure that's a figure of speech, or if it is it went right over my head too.
everything in this video was made with http://kivy.org https://vimeo.com/62715245
written in Python. Also PyPy is several things the exact name would be a toolchain to create JIT powered VMs with a high level statically typed language aka. RPython and an implementation of Python. So not it's not PyPy in this sens and of course it's a bit «marketic» in the bad sens...
My projects are more large scale, so I tend to make pretty big stuff. - Working on a giant [Flask](/r/flask) framework project for rapid development of form applications. - Unittest application for quickly testing performance of certain algorithms and data transfers from other languages (I quickly make a similar python algorithm and test it; for some reason it's easier for me to do this than doing it in the other languages). - Finding tiny differences in large data files, detecting even capslock changes and pointing them out for me, due to some sensitive files I work with.
Can you elaborate on what these tools do? I never had a problem with large-scale python development coupled with unittesting.
Should you use xrange though? I thought it was depreciated. Also speed isn't everything, which is more readable? (I have no idea, one is concise, and while range is used all the time, reversed is obvious)
rst2odp will create open(libre)office slideshows. It also contains a library to create slideshows without rst. (Disclaimer: I'm the author) https://github.com/mattharrison/rst2odp
&gt; Should you use xrange though? I thought it was depreciated. It's removed in Python 3, but only because it's the default behavior of Python 3's range.
I am scraping horse racing website I want to gather both entries and results so that I can track them long term (jockey or trainer win ratio, ,maiden verus non maiden). I wanted to learn how Python, so I wrote the first draft while learning python. I had not touched it in a while so I wanted to redo it. I wanted to apply some of the things I have learned with Python. Just a shout out to BeautifulSoup. They really make the whole idea of webscrapping possible with their HTML parser. 
You keep saying that you don't know this or that, but nobody was born with the knowledge. Track it down, and either: - be taught (eg. college) - read books and articles - ask on forums etc. Everyone starts somewhere. You just need to hunt down the answers you need.
why you don't use a dynamic dns service? 
Maybe so. At least [parts of xrange](http://docs.python.org/release/2.2.3/whatsnew/node12.html) are deprecated. It seems quite likely that the two have been internally optimized to near-equivalence in CPython. Perhaps absolute equivalence in most cases? \*shrug\* That's just the rule of thumb I remember from years ago: for small ranges use range, for large ranges use xrange.
print(x-11 if x != 10 else "Lift off")
Interesting. So the methods inside of the Window() class are all pre-defined in pyglet so it knows to look for them? I find it really hard to get a grasp of what's going on by reading through the code. I guess a better understanding of Pyglet would help, everything just seems so disconnected compared to reading through Pygame data. 
I'm making a similar video to [this one](http://youtu.be/4M0soXr2cHA) of my town Vilnius, Lithuania.
I would prefer explicitly choosing either messages or shared memory, with the other being forbidden when one is chosen. Rust is moving in this direction, but perhaps it is a bit too low level.
Well, when you put it that way it sounds magic, but most likely it's just inheritance working the way it normally does. The window here is derived from pyglet's Window class, which probably just has a game loop in the run() function which calls update() followed by on_draw() on a regular basis. The derived class has its own implementations of these which get called.
http://en.wikipedia.org/wiki/OSI_model can be treated as a tough guide. Messages descend from your application's socket down all the way to the physical layer when it leaves your computer and goes over the network. On arrival at another computer it climbs back up until it reaches the (ideally) destined server/client. I always imagine it like a V. With a loopback, the V is much smaller as it short circuits at the network layer. Depending on how you are sniffing traffic, that can be a tad more ideal because as a message descends, you can visualize it being thrown into a new envelope that will be collected when it hits where you're intercepting from. Higher you go, the easier life is. That's why chadmill3r suggested a man in the middle level attack, it's so high level that its much easier to grab the raw message and ignore the particulars.
So much for an easy solution. Maybe try a gc.collect() at the end of the finder to force garbage collection and print gc.garbage every 5 files and see if the list of un-collectable objects is growing with each iteration. 
What's so horrible about it?
That looks pretty intense. What modules are you using?
&gt; In any case, I wish the Python.org weenies would "adopt" one of those two (or create their own) and start bundling it with the standard Python distribution. Without it, the whole "batteries included" thing is falling a bit short. This reminds me there was much talking about static analysis during last year pycon (inspired by Guido's keynote, I think). I wonder if there was some effort to make an actual standard implementation... I personally use pylint a lot - both in jenkins job and in [real time in text editor](https://github.com/lunaryorn/flycheck), but figured out recently that [jedi](https://github.com/davidhalter/jedi) does better job in some critical tasks (most importantly: detecting wrong object attribute lookups). I'm aware that linting isn't the purpose of jedi, but it's built around a solid parser and ast generator - just like pylint - and these foundations may be used for the same purpose. I have a feeling that pylint checks ported to jedi ast would make the most awesome Python linter ever - something stdlib worthy.
do you know [scrapy](http://scrapy.org/)? Here is a video from pycon: [Scrapy: it GETs the web](http://www.youtube.com/watch?v=-JzH8TcwqxI)
Does it run inside of Csound or is it standalone?
&gt; D3's Javascript demos feel very zippy and efficient, until you realize how canned they are I'm glad that I'm not the only one who feels this way, at least as far as scientific visualization goes. But I really haven't experimented with the canvas/svg functionality in much depth yet, beyond looking at other people's examples. JavaScript-based plotting is still a very new concept to me.
As it stands, it runs inside. Csound has an option for allowing a user to specify an external program for preprocessing what's in the score. In this case, anything between &lt;CsScore bin="python pysco.py"&gt; and &lt;/CsScore&gt; is where one puts their Python code. So the orchestra and the Python Score ships in one file, which Csound then runs.
Sure it can. A Go backend has been included in GCC since version 4.6.
Rust generally seems to be nicer. It has generics!
This is pretty cool and has room for a bunch of simple optimisations. I'd like to see an OpenGL ES version... Writing games in Python is easy! You should all do PyWeek :-) http://pyweek.org/
It's amazing when working in a team. If you're thinking about `fmt` and `fmt.Println` for debugging, just use `println` instead. You can also assign to "_" if the issue is local to a function and you don't wish to remove the import at the top of the file: _ = fmt.Println No unused imports is a great feature. Most code is read more than it is written.
how are you finding tiny differences in large data files? are you using module difflib? 
&gt; they'll disappear in Python 2.3 Lol, Python 2.3 was released a decade ago. The difference between `range` and `xrange` has nothing to do with speed (although I suspect `xrange` gets "faster" as the range gets larger). `range` returns a list across the range, which means every element in the range is stored in memory. `xrange`, on the other hand, is a generator so only one element is "in memory" at a time. This makes it great for large ranges, but negligible for small ones. `xrange` is a bit more than a plain old generator though, since it supports the sequence protocol (`xrange(3)[2]`) which allows it to be used in functions like `reversed` although I believe that negates almost any benefits of using `xrange` over `range`.
&gt;the moral of the story is that premature optimization is for suckers -darth_aardvark Writing this down and quoting you forever. 
I throw them the $15 a year for maintaining the infrastructure necessary to providing the convenience that is their service—but I'm big spender.
I've been working on my own little web framework to try and learn the ins and outs of Python: http://simoncoulton.github.com/watson/ So far loving every minute of it, much more fun to code in than PHP :)
Because I hate the children: print('\n'.join(str(10-x) if x &lt; 10 else "Lift off!" for x in range(11)))
he's the son
It took me a while to find the free hostname section on dyndns. look under the Hostnames Available heading: https://account.dyn.com/dns/dyndns/?via=hostlink
Writing a roguelike based on STALKER and Fallout. Lots of focus on creating more of an action-oriented game by using real-time elements mixed in with some turn-based phases. The biggest feature (and almost the entire reason I created the project to begin with) is the AI, which builds relationships with other AI who then form groups/factions to fight over resources. Python is the perfect language for it, as I can develop quickly while still having a large amount of functionality.
I think you mean "deprecated."
I knew he said something similar. Thanks for the link :)
I started on the first slide.
It still requires a runtime and garbage collection and can't be called into as a C ABI. Or are you saying that's not still the case with gccgo?
 print(reduce(lambda sum, t : str(t) + "\n" + sum, range(1,11),"Lift off!")) 
I like the idea of a static blog. I wish your code was commented more though.
I wrote [ipxer.com](http://ipxer.com/) as a partial **dnsstuff** replacement a few years ago. It's built with python, django, dnspython and a few other libraries. It's not complete, but it handles [quite a few tasks](http://ipxer.com/about/) that I use frequently.
I don't think Go's error handling is bad, but it's definitely an area that's hurt by the simple type system. Returning both a nullable value and a nullable error instead of just either one is pretty ugly, but it was a sacrifice they decided was worth making. Avoiding catchable exceptions means no worries about all of the exception safety issues you face in other languages, at least if you aren't sharing mutable memory. In C++ and Java you have to worry a lot about making methods transactional, and it's really hard to get right.
Hieroglyph also has a presenter mode, and makes it easy to create HTML or PDF handouts from the same ReStructured Text files. [Disclosure: I'm the author of Hieroglyph.]
I've mostly used it for performance critical things but there are a few things that it does really well (and that python could learn from). * It is much easier to write concurrent code in go via the included light weight threads ("go routines") and channels (for passing variables). * The standard lib is very consistant and easy to use, in particular the prevalence of common file like interfaces like Reader and Writer makes it really easy to string together things (you want to send encrypted json over a websocket? just wire together the appropriate standard lib functions). * The Http client libs in the standard lib are really well done and far nicer then python for anything beyond basic get requests. This is especially nice if you do a lot of REST. * The included webserver is really good and great for building things like distributed we services with no dependencies on a traditional webserver. On a more ascetic level the go designers have taken a radical approach very much in keeping with "Explicit is better than implicit." and "Simple is better than complex." People either hate or love things like the error handeling and lack of inheritance but I have found it works well in practice. 
[PCRE bindings](https://github.com/stefantalpalaru/morelia-pcre).
I fail to see how that makes it worth not compiling code over unused imports. Languages shouldn't include libraries if they arnt used anyway, so there is no reason it shouldn't be just a warning.
web scraping ebay
Thanks, this is a good writeup. 
 for i in range(10, 0, -1): print(i) print("Lift Off!") Or if you want to be weird about it: for i in range(10, 0, -1): print(i) else: print("Lift Off!")
And, as I said, it would stop those transactions from taking place, and thus wouldn't work during a live session. Actually, I believe chadmill3r suggested a "man in the middle" approach, which usually means acting as a pseudo-router.
An RPG manager
Man, it's going to take all your resources and then your processes are gonna starve.
If we did, we wouldn't be using python, would we? :-) There's essentially zero evidence that compile-time type checking results in a statistically significant decrease in errors, but there is published evidence that dynamically typed languages can reduce development time by 50% or more for non-trivial problems. 
[Parsley](http://pypi.python.org/pypi/Parsley), a parser generator for Python. [Monte](http://launchpad.net/monte), a compiler from E to Python.
Liftoff is one word BTW. As in Liftoff Software (http://liftoffsoftware.com/) which incidentally makes open source Python software :D
You should write one, it's an excellent exercise to practice. Everybody has his own static website generator. Here is [mine](https://github.com/guide42/folio).
It is indeed. 
I think he just uses the "Custom domains" function in bitbucket.
Punish him by making him beat Ninja Gaiden for the NES.
print('\n'.join(map(str, range(10, 1, -1))) + 'Lift off!)
&gt; Knuth FTFY
I have a buddy that did it once. He was a fucking mad man. Almost beat Battletoads too. But yeah, I would wish that upon any child.
Tavis, I watched the recording of the Plover stenography talk at PyCon and I noticed you asking a question from the audience. It also occurred to me that both you and Plover were faced with a similar challenge: invent a new vocabulary for differentiating punctuation from plain english words. It seems Plover's approach was to phonetically-misspell the english words in order to achieve punctuation, while you invented all-new words that wouldn't conflict with the existing vocabulary. Do you think it would make sense to work together with Plover to formalize a standard "punctuation language" that can be used by both speakers and stenographers? It seems as though you are both doing things "phonetically" despite the differences between voice and chorded keying, so it seems like there might be some value to having a standard vocabulary for this. Just as an example, it would make it easier for people to do both stenography and voice recognition, or perhaps somebody with a disability might do some combination of both, and benefit from a standard language for this. In fact, I would go so far as to suggest that it might be possible to build a common infrastructure here; write an abstraction layer on top of both the voice input and the steno input, have those both as pluggable backends into the same phonetic interpreter. Then it wouldn't matter if you chorded "laip" or spoke it, either way it would result in inserting a left-bracket into your document (etc). Do you have any thoughts on this?
This sounds really interesting. I barely know python or game making, but it sounds like it warrants its own blog post. 
I think it's that the string isn't centred between the two triple quotes.
Slowly building a wind data analysis library, leaning heavily on Pandas and Numpy: https://github.com/wrobstory/climatic
You taught him, and that's how he rewards you? You've created a *monster*!
Bitbucket lets you apply custom domain names to your user pages.
So do I. I've been tinkering with it so much recently that I'm putting a moratorium on code changes for now, so I can later go in and clean it all up.
LOTS of Flask stuff lately! 
How does your Jenkins API compare to Python-Jenkins? http://pythonhosted.org/python-jenkins/
Correct.
He likes scratch, which is also on the raspberry pi distro 
I did not know, but now I do. Thanks!!
Correct.
I was on the light rail with zbyte64 at PyCon when he discovered django-hyperadmin-angularclient, and he was super excited to see it.
Nice :) He invited me to the sprint at PyCon when I submitted a bug report to hyperadmin .. Sadly I live too far away. But I'll be there for sure in 2014-15 when PyCon will be in Montreal :&gt;
That was my mistake - I forked it out of excitement and must have copied the wrong URL.
That was my mistake - I forked it out of excitement and must have copied the wrong URL.
I have to apologize, I linked to a fork rather than to the original by mistake. The original is [here](https://github.com/fogleman/Minecraft), thanks to the posters below who pointed it out.
But for him to really understand that else you have to teach him gotos!
Do you actually have papers to cite? I've seen precious little *actual scientific research* on either side of this discussion.
Nooooo don't dooooo ittttt. Raw sockets ahhhhhhh. Raw sockets are great in C, but not in Python, oh heavens. Just kidding, enjoy!
Agreed. Symbols should come after intuition, not vice versa.
Oh, I see now! I didn't look that closely before.
There is more control over allocation and garbage collected pointers are only used when really necessary. It's quite natural to write code without any GC, including interesting features like closures. It is also easier to reach into unsafe code when necessary. You are right about philosophy, though, and I find Rust's closer to mine.
That toolbar is just standard LXDE.
If you're digging into performance that tediously and specifically, why are you using python?
This is very cool. I've been writing similar software in C and C++ over the past few years. I've recently started getting into pandas, and I'm trying to convince more of my team to use more python for one-off non-cluster runs. We're writing tools that optimize placement of wind farms using high res wind data sets given power, size, area etc restrictions. Pandas is really a great library.
Not in the binary that's ultimately created in the end, but the compiler will still read the import and find the library, which adds to compilation time.
&gt; even though it is not sound (it doesn't forbid sharing memory between goroutines). Can you give an example of a case where someone might easily modify the same chunk of memory from two different goroutines, without realizing the mistake they were making?
I am familiar with why the else works, however is there also some benefit even if not likely to be encountered in real situations? Does using else as an alternative to the implied if, over running something outside of it altogether have an advantage?
Topaz: A Ruby VM written in RPython: https://github.com/topazproject/topaz
noooo i wanted the credit
An extension for Mezzanine and an async Tornado based scraper
gc.garbage shows cyclic garbage that the collector can't collect because of the presence of __del__ destructors. The most likely reason of this leak is that there is still a reference to the objects somewhere. It's simply not garbage from the collector's point of view. You can try finding the "garbage" objects in gc.get_objects() (returns a list of all live objects paritcipating in garbage collection) and then track down what refers to these objects using gc.get_referrers().
Shucks. My simplates won't pretty print on my fan-fold paper anymore. These young'uns that don't know what a ctrl-L is oughta learn a little history. 'Twas the content separation by form-feed that I found so charming when I first heard you speak of Aspen. Makes me sad to see it done in. 
Nice! I've been using Python-Jenkins, but maybe I'll switch to your project.
Well, looks like someone's already reported it: http://youtrack.jetbrains.com/issue/IDEA-101256
ew, train him to always use 4-space indentation and be pep-8 compatible from the start
I would like to know what he means by "get a life". Would appreciate if anyone clarifies. Unless I'm clearly off the mark, he might mean one or more of the following: - Socializing - Sex - Drugs - Music - Outdoor/sports/whatever - etc To which I'd say: kids will be kids ... until/unless they ... grow up!
As I do a lot of circuit design, I've picked up an existing Python 2.x project, gerbmerge, which tiles circuit board layouts so that they can be printed on one board anc ut out later. It needed to be ported to Python 3 and I remove a bunch of dependencies: [gerbmerge3](https://github.com/Susurrus/gerbmerge3/). Next step is to split out the Gerber RS-274X code into a separate library, as there is no Python library for that yet. My goal is to improve the open source software tools available for open hardware engineers.
How hard is making a Ruby VM? I've seen a lot of work being done on them recently.
The else clause is not executed when the loop is terminated by a break statement.
I like your parser generator
This is excellent! 
I've procured a device called the Tellstick from Telldus, a Swedish company. The Tellsticks are for radio controlling electronic devices, mostly switching lamps on/off. There are also devices for shutting blinds and reading temperature/humidity values. This company is kind enough to publish drivers and libraries for their devices as open source, with Debian and Ubuntu packages ready made. Now there already exists a couple of python wrappers for their C library, but they're both pretty nasty imo so when I wanted a local web interface for my home to use my Nexus 7 as a remote for all my lamps, I decided to write my own. So my pet project is a jquery mobile interface, against a REST API, that will make use of my library. So I can use my iPhone and my Nexus 7 to control all the lights and fans in my home. Eventually I want to get humidity and temperature sensors too for my vegetable grow ops. All this is already possible using the Telldus Live services, but I want to do it offline in my LAN at home, without requiring Telldus server access. 
I would like to hear more about the timecard system you wrote. Everyone hates time reporting at work, would love to see your take on the problem. If you are allowed to reveal details about the context that would be great. For example, we must each week report our time spent on various contracts in one tool, and also report any leave we take. Then in another tool we must check each week as finished, and report each hour we're away from work, and check each month as finished when the time comes. My wish would be to simply scrape peoples Exchange calendars. 
This is great, I've built one of these myself and ran it against a bunch of sites. It also downloaded old pastes for sites which had simple incrementing paste IDSs or were otherwise easily crawlable. I did a lot of analysis of random analysis on the data in addition to password/security scraping. It was pretty fun and quite an eye opener tto the content distribution of pastes. I've contacted several organizations/people which had pasted amazon AWS keys or other credentials which were valid and, if I were an asshole, would let me delete/steal/exploit all the things. It's pretty crazy! 
I'm working on a Bitcoin Arbitrage Bot https://github.com/maxme/bitcoin-arbitrage
I work in CAD/building modeling/finite element analysis. I write a 'mapper' application that transforms drawing layouts to arbitrarily complex shapes and finite element models. That's my second Python application after the first one, a very basic Evernote API web app. Initially I had a simpler task of converting one particular surface, but it got out of hand pretty quick.
Haskell's one and only good idea: the Maybe type. It would have been nice if Go had stolen it, but it's too late now.
This sounds awesome, do you have a blog or something where one could find out more, or is it too early?
Hi, Thanks a lot for this! I just forked and replaced the twitter bot by a dump to a redis database. https://github.com/maxme/dumpmon Also, I made some refactoring that you could merge.
&gt; Go for Pythonists nice front page typo! :-)
&gt; Also, not having first-class user types. That's going too far in your description. The trouble is that they do have generics, but only for the built-in slice (list) and map (dict) types. If they had real generics, then it would be an even playing field.
There is [python-blueprints](https://github.com/amirouche/python-blueprints) a python bindings of [blueprints](https://github.com/tinkerpop/blueprints/wiki) last time I checked it was installable via pypi you also have to pull https://pypi.python.org/pypi/Neo4j_jars/1.8 or you can directly pull neo4j python embedded which less fast. This is a graphdb but it can be used as a document datastore, the query language is Python.
http://labs.codernity.com/codernitydb/ Is a db built on python but i don't know if it supports all your requirements!
This looks very interesting. And it looks like it may be suitable for my particular case. Thanks!
In the shell I use Midnight Commander when doing file operations. If I want to copy/move 20 different files to the same directory for instance, then I put the target directory's path on the clipboard. Then in Midnight Commander you can do the following: * move the cursor on the file you want to copy/move * cpq/mvq &lt;Esc-Enter&gt; &lt;Shift-Insert&gt; &lt;Esc-Enter&gt; will paste the current file's name in MC. &lt;Shift-Insert&gt; will paste the target directory's path. For me it works very well. But you are right. Doing all this from the plain shell would be a pain in the ass.
Thank you friends for the information.
PyPy. Oh no, that's my job. I don't have anything then.
Is there a specific reason you don't want a schema? They're quite useful (particularly during development or data migration) and you get to use the lovely SQLAlchemy. You could still use SQLite though, either by changing schemas implicitly or emulating something like Postgres's hstore. Alternatively, ZODB should work from what you're describing.
In the main function, declare a mutable data structure. Then start two goroutines with closures. Now both goroutines can mutate the data structure at the same time. It is usually easy to find such cases, but I prefer having the compiler/runtime entirely forbid such things and instead require me to explicitly share memory instead.
I'm working on a script that converts text into sound! It's in a really early stage. It converts a-z into a1b2c1d1e1f1g1a2b2.. etc. In the end I want it to take into account formatting, spaces, punctuation, ladders and for bigger pieces of text even paragraphs. Then it's not converting text into sound, but text into music! Yay. Anybody looking forward to knowing what kind of music shakespeare wrote?
Your specs don't sound far off from simply using builtin python data structures (lists, dicts, etc.) and pickling them to files on disk when you need to. You don't mention how much data you'll be working with or whether you'll need indexes on that data so I'll assume no--and it's about as "fully embedded" as you can get. Writing queries would additionally be easy.
I will NEVER, EVER go again. The Code of Conduct is ridiculous, and it's SO BROAD that you'll never know if you're violating it. It prohibits many forms of speech, including anything that's "sexualized." Can I mention to someone that we're expecting a baby, for example? 
I like this, have you tapped into Csound's synthesis stuff yet? Also, have you explored using this with algorithmic approaches yet? 
 print('\n'.join(map(str, range(10, 1, -1))) + '\nLift off!)
reversed() just makes a reverse iterator, much ilke reverse iterators from C++. It doesn't actually reverse the whole list into a temporary list. just like xrange() is a generator function instead of a list "creator" like range(). So it should be rather efficient. 
Eh, why would xrange be depreciated? Generators used to be the hot new stuff in Python, now they are common place.
Pokemon catch rate calculator, recently added PyQT. I'm planning to expand either to mobile (calculating after gathering data form a picture of your console) or to web (switching GUI to WUI). If anyone would be interested in working together on the web project, feel free to PM me.
Nice! I like it. I think the redis database will come in handy for people who want to run their own local instance. I think I'll keep mine a Twitter bot so people don't necessarily have to do anything specific to set it up if they don't want to (and can get real time updates easily). I'm digging all the refactoring, though! If you would like, shoot me a pull request with things like the argument parser, logging, and other refactors and I'll merge it in (I think that's how it works... I only used Git as a local repo. Haven't worked with Github too much yet). Thanks for all the hard work!
There were women-only events at Pycon? That's fucking sexist.
DotGraph ( better name pending me thinking one up ) - a twitter like actor system that reports to users on various tasks/events * Reddit stalker "OP updated in a specific post" * Reddit, you have a message for account X * Your phone battery is @ 20% ( only happens when a setup ADK based phone is at home/work ) * Website X has updated * Task Y on machine X has finished/started/etc ( simple cron style doSomething &amp;&amp; report -success "doSomething" || report -fail "doSomething" ) * plus lots of other actor idea's I've got almost all of the components finished local client, a peer 2 peer server ( one runs at home with actors, smaller one runs on EC2 ), and finished half the actors/agents I listed above. On a side note is pywk at https://github.com/devdave/pywk and a explanation at http://ominian.com/2013/03/05/howto-make-a-html-desktop-app-with-pyside/ I haven't push the latest changes but pywk is going to be a dirt simple HTML5 desktop app platform ( You make a static/localhost style website and then connect that to a Python or NodeJS backend to do the actual work ). I started this because DotGraph needs a user friendly desktop UI and I don't want to lock into any of the GUI frameworks but WebKit is for the most part ubiquitous across all OS's ( Linux, Unix, Windows).
Cool. The package pandasql can also do this as well. 
It's nice of the other commenters to actively demonstrate why we need female-only events. With sexist assholes like [this](http://www.reddit.com/r/Python/comments/1bavg7/are_there_any_videos_or_recordings_of_the/c957pmw), is it any wonder that having to hang around men for several days might drive women away?
It's not very relevant to a programming language, but it is very relevant to our programming culture. Many women feel uncomfortable because of the typical behavior of male-dominated packs such as those you find at most CS/programming conferences. Having female-only events help relieve some of the unfortunate tension and support them. It may be discriminatory, but it's not really hurting men. It's about supporting an under-represented group. Someday, hopefully, it'll be strange to think we had to do this, but right now I've seen wayyyy too much research that talks about how difficult and alienating it is to be a woman in Computer Science.
You are a disgrace to our profession.
It's about female empowerment in a male dominated industry. You don't have to watch just like you don't have to watch womens volleyball. 
I've written many Csound-based synths over the years, but haven't combined the synths with this project, yet. I have played a little with algorithmic music with this system, but mostly as proof-of-concepts. Here's a first order [Markov chain example](https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/markov.csd), [listen here](https://soundcloud.com/jacobjoaquin/csound-python-markov). And a [second example](https://github.com/jacobjoaquin/csd/blob/master/demo/pysco/rcycle.csd) that uses cycling generators applied to bass, melody and rhythm, [listen here](https://soundcloud.com/jacobjoaquin/csound-python-score-rcycle-csd).
Well, there is Counter-Strike Source, which you can do mods server-side only. So players don't need to download anything, but somewhat limits what you can do since the client doesn't change (Ex: walking through a wall. The client expects to be blocked, so the player will see himself frozen and being teleported forward every 1/10 seconds). http://python.eventscripts.com/pages/Main_Page You can't do as much as with the alternative modding tools for CSS (SourceMod), but you can do quite a bit still. And the python tool doesn't support CSGO (and i'm not sure it support TF2). Another group has been coding an alternative that would support all Source games. I coded my own which is not open source yet since there are too many rough edges for now.
You could check out [jsonstore](https://pypi.python.org/pypi/jsonstore/1.3.1). I believe it meets most of your requirements. There was a lightning talk about it this year at PyCon.
I spent about 10 months on it before I open sourced it (with a lot of help from a few other people), and even with that it's still really incomplete. That said it's a ton of fun and I love it.
Ok I understand. Male dominance is everywhere, it's a cultural thing and it's hard to fight. However, It's difficult to know what PyLadies contribute to our community if the events are women-only (like OP said). Anyway, go PyLadies!
Basically, they provide a place where women who are feeling overwhelmed can go and get some support and find out they're not the only ones, and that aspects of our culture aren't the way they are because of their intrinsic nature, but that way because we happen to be currently male-dominated. We benefit in turn by these women staying part of our culture, thriving and eventually encouraging more women to join. Diversity helps improve perspectives in individuals and societies, and we should always look for new ways and thought processes to approach problems. 
You are incorrect. Some conferences are doing great with female enrollment. I attended SIGCSE '13 last month, and the gender balance was quite healthy. But unfortunately, the programming world at large is still massively unbalanced. It is not confined to a single geographic area. There is plenty of statistical evidence and research that shows the programming culture is still not close to being evenly split. Why on earth am I lonely and desperate?
Python will automatically close your file when it goes out of scope (at the end of your function). More likely something is being kept in scope when calling your findem function over and over. We'd need to see the full source of findparticles.py to say for sure though.
You already have a conclusion, so you're twisting words to support it. Quite saddening. I didn't say that the conference was healthy or unhealthy; I said the gender balance was healthy. I think conferences are better (more interesting and varied discussion) when they have a healthy gender split. Diversity among race is another issue, one that is also very important. Although immigration is not the same thing as race, it is tied somewhat to that.
&gt; [deleted] what was the comment ?
Something about how freaky the PyLadies get. It was slimy.
*still* working on a platformer, which is probably the pettiest of my pet projects. I'm slowly getting to something a bit more finished though: http://www.youtube.com/watch?v=FUN5oh0O3Ew
I watched your PyCon talk online recently, Parsley looked pretty fun.
It's unhealthy when one gender has more than 60-70% dominance. It'd be just as bad if it were mostly women.
I used to work on a similar sounding project in Python 2.
Civilization 4 is a multi-part architecture. There's a bunch of C++ libraries for graphics, and then there's XML and Python files. Python files determine almost ALL the behavior of all aspects of the game; the XML files let you add or remove or modify assets (civilizations, technologies, units, etc).
What conference are you talking about, anyway?
Oh, that's why. Europes doing a farrrrrr better job about gender issues. And outreach. I've considered moving there after I get my doctorate simply because of how much better their CS culture is.
Minecraft for the RaspberryPi has a python interface to interact with the world.
Ahhh. That makes much more sense.
umm yeah... you can mimic that function with a normal list/iterator and a single integer counting from the size of the list till 0. it probably uses yield though, in order to behave properly in for loops
Yep, I do! http://flagsdev.tumblr.com/ It's still pretty early. Even though I'm closing in on 6 months of development, I'm going to need another 2 or 3 before I can actually release anything.
Not a mod, but you can edit minecraft / terraria maps in python. http://www.terrariaonline.com/attachments/world1-png.24345/
Main libraries have been 3 compatible for a long time. Lesser popular ones, if you require them might still require older versions otherwise you have to build it. And you can have multiple versions of python installed at one time. I think people take 3 unless they can't.
Yes it's true. We have about 15 people working on commercial a commercial Python 3 codebase which has been on Python 3 for a few years now. Almost all the useful packages we need were ported a while ago now, and the ones that aren't - such as the Python Imaging Library (PIL) seem to have been abandoned anyway. I wouldn't start a new project in Python 2 and my own preference for my open source projects is to support Python 3 only and only port to Python 2 if there are sufficient requests to do so or if somebody else makes the effort.
Very cool, keep it up. 
Python 3 being the "present" is I'm sure what the official Python site developers want to believe and want to promote, but in real-world usage, 2.7 is the present and the reality. Which is no problem, because 2.7 is just about perfect.
I don't know if this is a pet project yet or not because I haven't done a lot on it yet but some planning. I am still in the process of learning python and I tend to be quite ambitious so I thought I am going to try to replicate the functionality of [SONOS](http://www.sonos.com/) with as much functionality as I can with python ( which I am planning on making it everything ). Right now there are some opensource projects that piece it together so I am planning on making android/ios apps with Kivy as controllers, making a program similar to Logitech Media Server in python, and then a headless python application to run on a raspberry pi to connect to speakers based off of [squeezelite](https://code.google.com/p/squeezelite/). But yeah its super ambitious but I really want this system to work super well but you know its going to take a while.
[Pillow](https://pypi.python.org/pypi/Pillow/2.0.0) is a fork, active in development and supports Python3 
Thanks for posting that code! Would you be willing to post this code. I really like the Lorenz images.
Python is my go to 'get it done quickly' scripting language. Many unix systems will have 2.X installed by default. I've tried using 3.X more than once before but I usually run into some module that doesn't work right. I definitely see 3.X as Python-Experimental and 2.X as Python-Stable. 
thanks!
Hey, contributing author here. Originally, we had plans to create pdfs, but the nbviewer site has been a great platform (much easier to do styling and such). We will probably stick with this for the time being. There are tools like [nbconvert](https://github.com/ipython/nbconvert) that allow converting to pdf from notebook. Similarly, if using chrome to view the books on nbveiwer, you can "print" as a pdf.
This is just a sample application - http://still-ocean-9664.herokuapp.com/ Nothing too elaborate. I am in the process of designing two, enterprise-level apps using my boilerplate template. The examples should be done soon.
The Pycon 2013 VODs are out? There goes the rest of my weekend...
While it doesn't directly address having women-only events at a conference, you may want to read this blog post about how the needs of disadvantaged groups doesn't equate to harming other groups: http://jezebel.com/5992479/if-i-admit-that-hating-men-is-a-thing-will-you-stop-turning-it-into-a-self+fulfilling-prophecy I'm glad there were women-focused events at PyCon and can appreciate the value of women-only events. I am a (male) member of the Society of Women Engineers and if at a conference I was asked to not attend a panel I would go get a coffee and not worry about it. Some events benefit from more diversity, but some conversations cannot be meaningfully held with the dominent group present.
What's your shebang?
I would hope python 3 taking over. But it is really frustrated to see that when I need help search engine always leads me to some python 2 solution.
#!/usr/bin/immature/my_shebang _ /\) / / ( Y) 
True, although true Python 3 support was only added relatively recently. We're stupidly stuck with Weave C integration in SciPy, which is the only thing holding us back now. 
I recommend option 1 for most cases. We usually include an `api.py` module that puts in the convenience imports that one would otherwise put into the `__init__.py`. Many users of the `foo.bar` package will do `from foo.bar.api import FooBar`. Others that want more control will do `from foo.bar.foo_bar import FooBar`.
I believe equality is when people don't care about gender, skin color or sexual orientation but about skills and knowledge. So yes, this is discrimination because you have to have vagina to participate. Sadly some people think equality is when women are 50% of any given community.
I am working on improving timezone and datetimes with python. I take advantage of both pytz and dateutils. http://delorean.readthedocs.org/en/latest/ https://github.com/myusuf3/delorean 
Battlefield 2
I pushed for my engineering company to move from Python 2.6 to Python 2.7 about 6 months ago. I argued there was no justification for us to be developing software using something that already was at it's end of life for projects that would be developed for the next 2 years. There are libraries we require for our day to day projects (vtk, wxpython, scipy.weave) that don't support Python 3. It's not going to happen until all the dependencies are worked out. Thankfully, matplotlib finally supports Python 3. That said, I develop an open source project that supports Python 3.2+. For the most part, the pure Python code is the same, but there are huge complexities when you move to binary file IO in Python 3. Most of it works the same, some of it just goes up in flames.
I'm personally a fan of how [Werkzeug does things](https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/__init__.py), and use it in my own projects. It allows for the the explicit import style of (1), but also allows (3) for convenience if you prefer that. 
I have one production project in Python. I would love to convert it to v3, but it will remain in v2 for as long as Twisted does.
I have that in something like 8% of my files.
especially example code. those bits tend to be small and self-contained.
there is absolutely no reason not to start new projects in python 3 if you don’t know from the beginning that you want to depend on one of the libraries that aren’t ported yet. if by “present” you mean “existing codebase” then yes, most organizations haven’t ported their entire codebase yet. but if they want to be able to use it in the future they better start porting today.
&gt; but I usually run into some module that doesn't work right never happened to me. give at least one example of a library thet officially supports python 3 and yet doesn’t run there properly while running properly on python 2.
thanks for the link, I'll have to look into this.
I tried adding gc.collect() in both places to no avail. I'm running the same script over and over again so I would imagine that references to objects would be replaced every time with new ones?
Why? Do you know what PEP-8 is for?
Yes. I've basically switched now, because almost all the libraries I use are available for python 3. As time passes, more and more libraries will become incompatible with 2.x, and more people will make the switch.
I haven't used Sentry, but I am familiar with it. The primary difference is that my project figures out which line caused the exception (because you tell it which files are library code) and it then uses git blame to email only the developer that is responsible for the exception. I've found it is a good way to be notified of issues the instant they start happening, but without me having to worry about 100 other exceptions that might be happening but are unrelated to what I've worked on.
I like importing key functions and classes. Flat is better than nested, so as a user of a library, I prefer `from library import ThingIWant` or `import library` and then using `library.ThingIWant` rather than `from library.things.thing_i_want import ThingIWant`. More specifically, I would often have the contents of `__init__.py` be: """Docstring explaining package""" from thispackage.module_or_subpackage import * from thispackage.module_thats_next_alphabetically import * ... And then have each module use `__all__` to specify which names constitute its public API that should be exposed by the package. For something you are distributing publicly, I don't think your `__init__.py` should ever by "blank" as specified by option 1: you should at least include a docstring explaining what the package does. This will help users poking around in ipython, etc.
Bottle.py is nice. 
Mount and blade
There is still a reference to the objects somewhere, so it is not garbage. It may not be a reference you intended to keep, but some dictionary or list or something is keeping a reference to the objects and keeping them alive and occupying memory. Perhaps they are garbage to you, but not the garbage collector so to.collect will not help. Try to find them in gc.get_objects() and see what is keeping a reference to them with gc.get_referrers()
You stick important parameters like __version__, __author__, release date, image DPI in there.
If RHEL would get on the ball and move from 2.7 to 3.x that would really help push things forward. Going from 2.6 with RHEL 5 to 2.7 with RHEL 6 is a good step, but for RHEL 7 they need to make 3 the default.
Thats default LXDE toolbar. It can also be Lubuntu or any distro with LXDE.
I'm at the university and we are learning Python 3.x; Django will soon be compatible with 3.x. I think it is a matter of time and Python 3.x will win.
In my opinion, 2 and 3 are both abuses of \_\_init\_\_.py. On the other hand, characterizing option 1 as "leave it blank" is also too strict. The purpose of \_\_init\_\_.py, to my mind, is to hold shared initialization code. In support of that, it should contain side-effect-ish code that you want run before anything gets imported from the package. For simple, or even moderately complex cases, this can degenerate to "leave it blank". But when there's a win for sharing initialization code, it may be an ideal place. Note that using \_\_init\_\_.pey in this way makes it directly analagous to a class's \_\_init\_\_() method, which I believe is exactly what the BDFL intended to imply when he named it.
Please don't use URL shorteners, they trigger the spam filter.
also, flat is better than nested, really. having to import stuff from various places to make basic uses of the api work is very much against python’s philosophy. as for the .api subpackage: why not just use `__init__.py`? it’s less stuff to type and remember and feels like a pretty natural place for the “public API”.
Speaking for myself, until Enthought ships a Python3, I'm still on Python 2.7. I just don't have the time/brain to spend building all the modules I need from scratch. Enthought does that work for me.
Funny that you say that schemas are useful during development and data migration, because those are exactly the times that they hinder you the most.
I started a python project once that, in it's early days, used __init__.py to do some basic dependency checks, and print out useful instructions about what to do when critical modules were missing from your system. It seemed clever at the time, but I had to scrap it when I started collaborating with a debian packager, and he said that it was useful to be able to build the package on a system that didn't have the deps installed. Turned out that setup.py was importing the version string from the project itself, so you couldn't even run setup.py if the deps were missing, and it made packaging difficult. So, that got scrapped and it's been empty in every project I've worked on since.
 print('\n'.join(map(str, range(10,0,-1))+['Lift off!']))
I don't know of any off the top of my head, but if you have a menial task that you find yourself doing often (such as cleaning a specific folder) then you should try writing a script yourself. The sys and os modules are very useful so you should read up on them if you want to start writing some scripts!
I do similar things. I think it's a nicer user experience. I normally will define __all__ in the module i want to bring into init and then import * don't need to worry about the coupling then
dtrx is pretty cool. It will provide you with a proper cli software to uncompress any type of archive.
I've deployed new Python products for customers three times the last year, all Python 3.2. So yeah, moving.
This is news to me, and all I can add is shheeeeeeit
Bottle is such a handy little library, I'm always eager to find unexpected new ways to use it.
If it's going to be a large or serious application, I probably wouldn't recommend this. A lot of time will be wasted on pickling and unpickling. OP should probably use Redis or MongoDB or something similar. Considering OP wants a pure Python solution though, for whatever reason, your suggestion is probably the best.
Python supports the entirety of Ubuntu's administration, when it's not C or something inherited from Debian that uses Perl. It's everywhere. Very soon, the base install will run on Python 3, and there will not even be a Python 2 installed by default. Py3 is now. Web pages will lag behind the repositories for a long while. Just use 3, and when something doesn't work, ask upstream and optionally run 2to3 and submit the results to them as a patch. If all that fails, then you should consider 2, but be prepared for a user to harass you about needing 2.
Link for those of us that prefer reading to watching video: http://www.webbot.ws
First impressions irrespective of technical merits... In a world where things like Bootstrap exist there is no longer an excuse for not looking better than this.
Hi andybak, I'm curious what your referring to, do you not like the way the framework sites look? Or are you referring to how apps look initially when you create them? There is nothing stopping the use of Bootstrap within WebBot apps, as bootstrap is simply a mechanism for creating css files. Thanks for checking out the project! Timothy
Wildcard imports make me sad. I want to be able to look at the module I'm in and determine the origin of everything in my scope. If there are wildcard imports (especially more than one in the module), I have to look at multiple other modules to see where things came from. Defining all reduces namespace pollution, but leaves the traceability issue. 
The main issue I have with stuff like this is that it feels like a throwback to the Java frameworks like Tapestry which didn't respect how HTTP and websites are supposed to work. Your demo doesn't have form tags, and the AJAX POST request has a "requestHandler" field which essentially indicates which component on which page was responsible for issuing the request (and presumably handling it), it all feels very wrong to me. The reason I switched to Python and Django was to get away from this paradigm.
Hi andrew, I appreciate the feedback! The demo does not have form tags because, there is not typical post form present in the demo - only AJAX calls - and I did not believe that using the form tag was necessarily the correct element to use when using AJAX calls since it can incur certian other problems (pressing enter could cause a full page submit when the intention was only to submit a section of a page) which would require hacks to work around - and this is the same if you build your sites with any framework. And sure enough you can wrap a form around your fields simply by dragging a form element and dropping it within guiBuilder, I simply did not in the demo for that reason. The requestHandler field is simply there to say which section of the page should handle the request - however it would be trivial to change that to a separate URL within the framework to make the request cleaner, and I believe this is a good idea. I think the main difference between this and older framework is that it gives you full access to the DOM from python, and literary enables to build it exactly the same as you would if you made the HTML from scratch - it simply gives you the ability to combine these DOM elements into reusable widgets - and then provides utilities for things such as AJAX calls. Thanks! Timothy
&gt; Of course it's gradually taking over. How could it not? It would be pretty simple. People would continue to use Python 2.
&gt; if by “present” you mean “existing codebase” then yes, most organizations haven’t ported their entire codebase yet. but if they want to be able to use it in the future they better start porting today. Why? Code doesn't just evaporate.
As someone casually browsing /r/python because I am trying to learn it, this was actually quite cool :) Thanks.
As of right now, Solaris 11 is on 2.6. We have plans to move wholesale to 3.x by the end of the year. For major corporate OSes like Solaris, every single piece of software has to move in lockstep to the new version. This means all of the core OS, GNOME, testing organization ... everything. It's a very complicated procedure because of how many software packages have to move.
People would choose to continue using an abandoned and unmaintained version of a language they love? I'm sure a few stubborn ones will, but my point was that this is not like the perl 5 situation where the old version continues to be actively maintained, with new features, performance enhancements, and other such innovations. The 2.x branch is in maintenance mode now, and in the not quite so distant future the plug will be pulled entirely. You have to be a special kind of masochist to continue using an unsupported platform. How many people do you see using Python 1.x today? 
What do they hinder?
Python 2.7 runs my Python 1.x code. :-)
[Django + Python 3](https://docs.djangoproject.com/en/dev/topics/python3/) I couldn't google up any conclusive evidence that Flask works with Python 3 yet. But perhaps it does. I haven't tried it in a year. Good luck! I used to use Delphi, and now I use Python. It's been great fun! EDIT: [wall of superpowers](https://python3wos.appspot.com/) presently says Flask doesn't work with Python 3. Flask has a good enough tutorial that you may want to use Python 2 for now. 2 and 3 are much more alike than they are different, so your learning would not go to waste.
[autojump](https://github.com/joelthelion/autojump/): learns what directories you use most often and lets you `cd` to them quickly. (I'm the maintainer.) [exifrenamer](https://github.com/wting/exifrenamer): I wrote this a few years ago to organize and rename jpeg files based on timestamp metadata. It's not updated because it just works for me, still using it weekly. [youtube-dl](http://rg3.github.com/youtube-dl/): Downloads Youtube videos.
I can't wait to finally start using 3. It looks like that point may at last be aproaching. Now when the pypy guys finish their py3 project and I can use pypy with python 3 I'll be a real happy camper.
I didn't think it was good form to fill __init__ up. I have to agree with OP here. It also decouples your public API from your code. You may want to change from bigstuff import Stuffinator to from littlestuff import Stuffinator 
No, nor is not something that is considered in need of fixing. If you remove the GIL but keep reference counts, then performance plummets as you have to take and release a lock any time you touch a refcount, which is very often, as opposed to taking and releasing a single lock every 100 opcodes or so, which is significantly less work. So what you're actually talking about is reimplementing the entire memory management system of CPython so that it uses a concurrent garbage collector instead of reference counting. (CPython does have a garbage collector now but it's only there to deal with circular references that refcounting would otherwise never be able to collect, so it's not handling the brunt of the work nor is it concurrent.) And doing *that* means that you have to rewrite all C extension modules, because they all participate in reference counting. If you thought users were mad about the module incompatibility situation previously, imagine telling them that you're planning to do it again in this lifetime. 
Nothing. Explicit is better than implicit.
&gt; For example if you want to write a unittest that imports stuff/bigstuff.py, it will break if something is wrong in stuff/otherfile.py as otherfile.py is imported in `__init__.py`. If your package is so broken that it doesn't import, then you need to fix it before moving on to other unit tests. The earlier errors can be detected, the better. It's a bonus that this structure will sometimes catch bugs at "compile time" before your tests even start to run.
&gt; having a threaded python program using one core out of the 8 on my machine is ridiculous. That's not necessarily true. It's both possible and common to do work in a thread without holding the GIL, such as waiting on IO or doing heavy number crunching in a C extension module. Many tasks that people want to use Python for fit this bill, such as a web server. &gt; they should have used the 2-to-3 migration as an excuse to fix it. They were already breaking things; why not break them some more at the outset? I was being a bit facetious. The idea of completely gutting CPython to remove reference counting is not even on the table and never has been, as far as I know. At that point you might as well just start over and target an existing VM with an existing concurrent GC, like Jython or IronPython did. They have no GILs. &gt; I have a smallish 5K line python 2.7 codebase that I couldn't be arsed to port to 3: why bother? Today? There's no compelling reason. But eventually there will be one -- maybe your linux distro begins to ship 3.x as the default, maybe 3.x gains a new feature you'd like to use, maybe you encounter a bug in 2.x that is already fixed in 3.x. That is what the "gradually taking over" part of the thread is about. 
Autojump looks super useful. Thanks for this!
Don't learn from this, please. Well, learn the language constructs you're not familiar with, but not to write code like this. Python is not Perl, thanks goodness.
For years after it was irrelevant, google was linking all Apache httpd results to the 1.3 documentation branch. Fwiw
Yep, same with rhel.
That's far too close to functional programming for Guido's liking. He's gonna find you. 
"No one can force you to do anything with respect to programming." Now, I'm not a professional programmer myself but I understand that some people are and I'm sure they have bosses, colleagues and company policies that sometimes force certain tool choices on them.
I love and hate that about rhel. I'd run it if I had to maintain hundreds of servers running vertical apps, but shipping with postgres 8 and ancient (but I'm sure very stable) versions of drbd just leaves me without new features I need. ("Need") Few people seem to understand the benefits of a longer software life cycle. I get it, it just isn't for me.
I work for a staffing agency, so 98% of our staff's billable hours go directly to the cost center they work in. There might be a few stragglers that work as needed for different departments, but they usually get paid through their home cost center. My take is for employees to log into the time clock and click in/out. The system slaps a timestamp. The user can adjust their in/out time manually but it flags the record for approval by their manager. Days off are input as sick/pto by the employee and are flagged for approval. At the end of a time period after all the cost center managers have approved all time it then gest posted to our financial ERP. It wouldn't be hard though to divide the in and out time up into projects, but like anyone, I hate narrating my day hour by hour. Since we can SQL directly into our financial software it makes it super easy to combine PTO/sick/OT/FT/PT and put the data anywhere we want. Just making one system to rule them all!
Archlinux has python, python3, python3.3 pointing to Python 3, and python2, python2.7 to Python 2.
&gt; You have to be a special kind of masochist to continue using an unsupported platform. That's a ridiculous thing to say, really. "Unsupported platform" makes no difference for many people, as 2.x is a mature platform which can be used reliably without any direct support from the core Python team required. Actually for all Python I've used it would make no difference at all to the usefulness of the language or its applicability to the problems I'm solving if the language had been abandoned. What could drive 3.x adoption is the transition of popular modules or the advent of new ones that only support 3.x. But at this point I'm quite used to not being able to get popular modules to work anyway, so it won't actually be much different.
Too bad this all played out the way it did. Too much hyperbole around the issue now, so it's just become a shining example of what happens when things get out of hand.
Any chance you could post/add the links you found in regards to packaging and publishing? I'm new to it as well, and haven't found anything helpful so far
Yeah no problem, [here's the Lorenz code.](https://dl.dropbox.com/u/61793545/lorenz_attractor.py)
Hi! Where can I read a good writeup about the file structure of Python projects? This __init__.py confuses me a lot. I don't when or how I should make it. I just learned the basics of the language, but Ive been coding for a long time. I'm now doing some reading on functional programming (right now Im on decorators)
Nonsense. There will always be bugs, and some of them can be showstoppers. For example, there was a pretty high profile hash collision denial of service vulnerability last year. It was fixed with a new point release of 2.7. What would you have done if this had occurred after the support period ends? You would have had vulnerable systems with no way to patch them, other than to hope that some third party stepped up and backported a fix. If the bug is serious enough, such a third party will generally exist, e.g. linux distributions. But what happens when you hit a bug that just causes a crash, or incorrect behavior, or some other problem? What if this bug affects you but no one else? What are you supposed to do then? This happens all the time. Read the changelogs, they are filled with hundreds of such fixes for each point release. To think that you won't ever be on the receiving end of one is hubris. 
2.7.3 was mostly [bugfixes for security exploits](http://www.python.org/getit/releases/2.7.3/). It's reasonable to assume that new exploits will continue to be found in future.
I was wondering, when do you use Python instead of bash for something like this? What's the point where the extra power needs to come in? (I use quite a few little helper scripts and they're in bash because they just execute a series of commands and have 1 or 2 conditions, wrapping those up in Python would just be making a weird detour)
By no means an expert, but I prefer #1 with some small common variables defined in the init. E.g: http-messages.py contains Request/Response, but http/__init__.py contains STATUS_CODES and the like. IMO it makes things more readable (is this function/class actually defined in the init or imported from elsewhere)
For anyone working with twitter, until tweepy moves across to python 3 then they'll be sticking with 2.7. IIRC there are no plans to port across given the work that's just been done to meet the new twitter API specs
Hi, I put a few links I found into the post.
I didn't believe this so I just tried it out and learned something new. Why does it work this way? If I do `import stuff.bigstuff`, I clearly want that module, not everything else that `stuff` imports. I tried `from stuff import bigstuff`, but that also didn't work. I could maybe imagine that the modules in the package often require each other, but there can't be cycles, so if you needed such explicit importing of a few package modules, at that point it should be both safe and up to you to `import stuff.bigstuffrequirement` and then `import stuff.bigstuff`.
Also, they are magic, and not KISS.
I would love it if rhel7 made python 3 default, but it's not going to happen; rhel7 is going to start beta'ing in the next couple months, and is going to be based on fedora 18 (this was [announced](http://www.h-online.com/open/features/Red-Hat-s-RHEL-7-roadmap-1631791.html) at the redhat summit) . So, rhel 7 will very likely have a 'python3' package like there has been since fedora 13. Even if they do have the 'python3' package in rhel7, I still won't use it until I can get it on my rhel5 and rhel6 boxes, or upgrade everything to rhel7 (with the amount of rhel5 boxes I'm still trying to get upgraded to rhel6, that isn't happening soon either). Why won't it happen? Fedora 19 (alpha) is still python 2.7, yum and anaconda (and MANY other tools) would need to be ported. It would be a LOT of work. 
Yeah, we also should have minimum 50% of disabled, homosexuals etc. Why does gender, sexual orientation or skin color even matter?
Diversity brings perspective. Having a diverse crowd is a very good thing. Exact fractions are a bit strange to talk about. The important thing is having a culture that accepts diversity. Sadly, an all white-male culture is not known for being welcoming and friendly. Often the discrimination is very subtle; a joke that's extremely insensitive or a comment that requires a certain background to make sense. By improving our ratios, we can easily increase the "welcomingness" of our culture.
Running rhel or a rhel clone is not just about a longer software cycle, it's about stability in the environment. It's the same kernel, same glibc, same everything. There are patches sure, but the environment changes very little. Also, there are a damn lot of people using it. Not to mention redhat and oracle's qa teams. When you run into a problem, there is a good chance someone else has already found that problem, and has a solution/patch/workaround. Or, if you report a bug, there are some fairly hefty resources assigned to fixing that bug (presuming it's critical). As well, if you are running fancy hardware, there's a pretty good chance there will be rhel drivers for it. You can jerry-rig them to work for any linux flavor sure, but they were only ever tested in a rhel environment. I think suse / ubuntu lts are fine choices for large scale corporate linux as well I just happen to work at a rhel company.
The Quickstart and Tutorial sections from the Flask docs are also a great place to start. http://flask.pocoo.org/docs/ 
Unless you try to do: raise "Error!"
If you want to change the type of a column and keep all the data inside it (eg. by performing a conversion of some sort), doing that in an SQL database usually means writing a migration script to rename the old column, add a new column, convert and copy the data, and drop the old column. That assumes you're able to do the conversion logic in SQL, which sometimes is not practical. Doing the same in MongoDB or similar is basically this (eg. convert a string field to an integer): for record in collection: record.field = ParseInt(record.field) collection.save(record) And you're done. You don't even have to do it as a separate script - you could put the conversion in your application and migrate each record as and when you read it. Generally you have a migration situation like this any time when you need to change the schema and keep the data - which happens an awful lot during development because you're often still discovering what to store and the best ways to store it. The best time for a schema-based system, which is generally safer but more rigid, is when you are fairly confident that you know the schema isn't going to change much or at all in the future - which is usually as you approach deployment time.
And they managed to royally piss off a bunch of people in the process. The renaming breaks shebang lines for any Python 2 scripts. There's no guarantee of an python2 hardlink/softlink on all distros, so no go on using: #!/usr/bin/env python2
Speaking as a developer, I won't touch rhel at all. It's like IE of linux distros...
I'm a little confused. Are you saying it should or shouldn't be in both `__init__.py` and `setup.py`?
&gt; You may want to change &gt; from bigstuff import Stuffinator &gt; to &gt; from littlestuff import Stuffinator Why?
Of course not. But once everyone has moved on and you sit on a codebase of an unmaintained language, you'll find it harder to expand upon that codebase. Sure, this is several years in the future.
[hide-stash](http://a9entropy.github.com/hide-stash/) hide porn on your computer.
Haha. Don't worry, I've already got other languages under my belt, so I know that this is really bad practice, but it's still quite interesting to me.
By the sounds of it, it should be hardcoded in one and then referenced in the other
 eternity = True for eternity: if user_is_waiting_for_next_section: print title_screen Otherwise a good intro.
This is largely driven by Redhat Enterprise Linux. My company targets RHEL for our clients, so we might take on python 3.x once they support it. Another limitation for us is that we use Jython for some applications, which only matches python 2.5. For libraries that needs to run on Jython, supporting python 2 and 3 with the same code is overly cumbersome, so for now we stick to 2.x. Once Jython has 2.6 or 2.7 support, making code that supports both will get a lot easier. 
[Hash ID](https://code.google.com/p/hash-identifier/downloads/detail?name=Hash_ID_v1.1.py) will identify an unknown hash for you. I've found it helpful.
I'd like to mention the Requests and pyquery tools for similar work, you may like them as much as I :-)
Thx, but I would recommend [requests](http://docs.python-requests.org/en/latest/) instead of urllib2 
What if I want to rewrite bigstuff at some point in a way that would break the current API. I can preserve bigstuff for explicit importing and going forward the new version of API would use littlestuff by default. 
I find that "easy web scraping" tutorials are always a bit deceptive. The arduous part of real-world scraping simply isn't in the parsing and extraction of data your target page. The difficulties are in post-processing; working around incomplete data on the page, handling errors gracefully and retrying in some situations, keeping on top of layout/URL/data changes to the target site, not hitting your target site too often, logging into the target site if necessary, respecting robots.txt, target site being utterly retarded, target site adding and removing data in the future (resulting in a rather null-heavy database schema and all that implies), keeping users informed of scraping progress if they are waiting of it, sane parallelisation as well as prioritisation of important requests, difficulties in monitoring a scraping system due to its implicit non-deterministic nature, and general problems associated with long-running background process in web stacks. In other words, extracting the right text on the page is often *by far* the easiest part with scarily little practical difference between sexy jQuery-esque parsing options and just using regular expressions.
Then the statement could be expanded to "No one can force you, bosses, colleagues or company policies to do anything with respect to programming". The context here is the idea that a variant of a popular language could somehow cause that language to cease being used. That's just not how that works. The best you can hope for is that the variant becomes popular too.
Can't you use obj.`__module__` though?
See the C programming language for why your argument makes no sense. 
The C programming language is not an implementation. It's an international treaty. It has nothing to do with the topic. 
Requests is overkill for this sort of thing. Urllib2 is fine if all you want to do is use urlopen for a little web scraping script.
[n00b question] Why wouldn't BeautifulSoup be used for this?
He only uses urlopen. You'd rather import a third party module for one function call?
Back when I was doing this sort of thing, I relied heavily upon [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/).
BeautifulSoup [supports CSS selectors](http://www.crummy.com/software/BeautifulSoup/bs4/doc/#css-selectors) so don't go thinking that you need to drop down to the lower level of using `lxml` directly to get that.
Option 3 is definitely how this should work, here's why. You start out with your library having a package "foo" and a module "bar". Users make use of things inside of "bar" like, `from foo.bar import x, y, z`. Then one day, "bar" starts getting really big, the implementations for things become more complex and broken out, features are added. The way you deal with this is by making `bar.py` into a package, and the `__init__.py` inside of `bar/` essentially replaces `bar.py`. Your users see no change in API, and there's no need for them to learn exactly which submodule inside the new `bar` package they need to use (nor should there be, as things can keep changing many more times - it wouldn't be correct to expose the userbase to each of those changes when it's entirely unnecessary). There's nothing hacky about this at all, it's how `__init__.py` is meant to be used, and to those saying "explicit is better than implicit" I'd counter with "practicality beats purity" and "flat is better than nested", not to mention [a foolish consistency is the hobgoblin of little minds](http://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds).
As he mentions at the beginning of the post, it was inspired by [Web Scraping 101 with Python](http://www.gregreda.com/2013/03/03/web-scraping-101-with-python/). Look in the comments of that post. Kenneth Reitz, the author of the requests library, [even admits that using his library would be overkill here](http://www.gregreda.com/2013/03/03/web-scraping-101-with-python/#comment-826489228). Requests is fantastic, but sometimes bare-bones is really all you need.
The writing is on the wall, django now supports 3, a good portion of well attended talks at pycon this year dealt with python 3. I think django has tipped the scales, and we will pass the point where 50% of new projects are started with puthon 3 in the next 1 to 2 years, with 2 being considered obsolete by most users in the next 3-5.
this sounds pretty interesting. Make sure to post it on here when it's done.
Actually the Dropbox API is also on twitter 2.7.
C is not as dead as you'd think -- it's updated regularly to gain new features. The last update was two years ago (C11). But I am referring primarily to implementation here. If someone was advocating using an end-of-life unmaintained C implementation such as gcc 2.x or 3.x, then I would have the same response. Pypy needs to support what its users need, and the majority needs 2.7 compatibility. Nothing I'm saying should be interpreted as claiming that 2.x is abandoned or outdated *today*. As I must keep pointing out, this thread is about what will happen in the future ("gradually taking over"), not what is happening today. The page I linked to was renamed the Wall of Superpowers some time ago, so I shouldn't have used the old name. 
Eh, all is there for a reason in my opinion. Plus i wouldn't consider it wild card when it's defined
I found a few mailing list posts where the author states he does not want anybody to use this project for commercial use, even if its just for code protection. However I know the license was changed from GPL3 to Apache 2.0, the author still seems to take the anti-commercial stance. My hands are tied about doing anything with nuitka, even contributing which I would love to and have time to do, until the author makes the licensing clearer with regards to compiling commercial code with it. 
Aren’t code intelligence tools supposed to be, um, *intelligent*?
Oh yea I know the reasoning behind why it won't happen, but I want to keep dreaming that they'll get with it at some point.
Someone get this man a monospaced syntax highlighter!
Some time you need just a one shot webscraping. using regular expression could lead to unexpected results
One major complaint about BS is speed. In fact, that's the only complaint I ever hear about it. Personally, I love it.
&gt; Many tasks that people want to use Python for fit this bill, such as a web server. I'm not trying to provoke a flamewar, but "some" is not "all", and that is a damned shame. The net result is that we have a beautiful language running on an interpreter not worthy of the language's aesthetics. FWIW, my prior crack about the GIL still being there in 3 may have been a little *too* offhand. A little bit of reading tells me that as of 3.2 there's a new GIL that makes threading less of an active nuisance and restores parity to sequential performance. So perhaps we're making progress towards a happy ending here, and some future 3.x release will have a proper threading solution. And since it won't be backported to 2.7, well, that'll be the kick in the ass that I need to get my code on to 3. 
ipython has a fairly useful lexical feature like: In [6]: dev = !ls /dev In [7]: dev.grep('sd') Out[7]: ['sda', 'sda1', 'sda2', 'sda5'] practically anything prefixed with ! tells ipython to execute that shell command and transform it into a StringList object. Unfortunately ! only works in the ipython interactive shell and can't be used in a non-interactive script. A near equivalent can be found in the envoy package https://github.com/kennethreitz/envoy A while back I made a push request to incorporate Ipython's StringList class but I don't think it got accepted.
Hah. That's a nice hack.
&gt; Eh, all is there for a reason in my opinion. Yes, to limit namespace pollution. It's still bad from a readability perspective. 
I write a bash script if it gets beyond 10 or so lines or if I need a function. Bash doesn't scale well in my hands (I explicitly do not blame this on bash, *per se* since there may be very good Bash programmers out there) and I find Python (moreso Go nowadays though) fits the niche between small script and fully fledged program.
ArchLinux pisses it's users off on a daily basis. We're masochists at heart. But that's the price to pay for bleeding edge.
Isn't it just a REST API? (Never looked into it myself.)
On the flip-side of this you could argue that it's distributions like RHEL that are holding technical progress back. By having such as a large and involved deployment cycle there are lives lived, loved and lost in between releases whilst other distributions have packaged, re-packaged and dealt with the change already. When it comes to packaging and versioning woes I prefer the pain in small bytes, I prefer to have a single package break in a single update, deal with/update (or pin that dependency) and move the fuck on. Contrast this with phrases like "We're a Python2.6/Django 0.95 Shop" and you'll see how ridiculous it can be. Horses for courses, however and I'm sure what I said will make little impact.
Script used to make this: https://github.com/rhiever/reddit-analysis Subreddit to request MUWs of other subreddits: http://www.reddit.com/r/MUWs/ Gallery of MUW clouds made to date: http://redditmuws.tumblr.com/
PyCon made it, dongle did not. Let's hope that's how March 2013 goes down in Python history.
I definately will post it here when it's in a more 'useful' or atleast a better state! :)
Yeah, but python symlink change was totally unnecessary. The AUR still hasn't had the hundreds of unmaintained packages migrated over, never mind the package renaming.
The AUR? Fuck the AUR. The AUR is a community repo, if the package is unmaintained then you can take-over yourself. If you're too busy to take over maintenance then just update the PKGBUILD.
I recently adopted Python as my free-time-project language of choice (doing PHP in my job) and i am fiddling around with twisted and gevent, trying to find the best possible way to go to develop a backend for high-load environments.
Haha, the lengths people will go to not actually have to do any work. A rest API is probably the most simple set of bindings you can code against.
How is an easier to use lib "overkill" for anything? What's the "over"? Are you thinking that installation is the problem? I'm honestly utterly confused by this statement. edit: Ah, if you are only going to run this script one time and then delete it, then yes, that's a good point.
What format do you return from phantomjs to python?
This is a general problem with programming blog posts I think. The hard parts of any real world job are more abstract and less interesting to people who have never done it (and probably will never do it). These people make up most of your readers. If you want people to read your blog posts in this area you kinda have to retread the same old ground and only cover the part that's "obvious" in a slightly different way. To put it another way, no one reads about software engineering, people read about one off throwaway scripting. Blog authors write for their audience, as they should.
That's a nice balance of practical vs simple for /r/learnpython. For this crowd I would add that you will probably have an easier time if you use a debugging proxy (I like mitmproxy but I'm a command line guy, there are other GUI centric ones as well) and a browser to figure out the login requirements and endpoints. Many sites will use a CSRF token and/or some rather complex redirection during authentication.
"There's nothing hacky about this at all" Damn right! You are writing an API to your package. Write a good API for your users and don't couple that with your internal implementation. "explicit is better than implicit" does not mean "write leaky abstractions".
That's exactly what I've been doing. As an AUR package maintainer, I've been having more trouble with the Python 3 = python-* renaming. There's no mechanism for automatically renaming a package, so I usually just put (USE python2-example) until the Python 3 package comes out.
And there was me thinking that code reuse was one of the benefits of a global community of developers
The only event I'm aware of that they ran as invitation-only was the PyLadies luncheon, at which they discussed the same things everyone else does at lunch (more or less, I think there were a few short presentations on a few of the new PyLadies chapters so people know they are out there, you can find the same info on their site).
Guess it goes back to preference
It seems like you should be able to specify the encoding in `ZipFile.open` as you can with the regular `open` (in 3.x at least).
Hello hello. I'm just commenting so I can find this thread tomorrow when I get on my pc. Tally ho!
Someone made a [Minecraft clone](http://www.reddit.com/r/Python/comments/1b7bcf/simple_minecraft_clone_written_in_python_im/) that's in development. Edit: CaPiTaLs.
If you could comment just a bit more for Python newbs like me, that would be amazing.
&gt; The thing that's a but cruftier and full of inconsistencies is matplotlib's Object-Oriented interface. Agreed. I inevitably end up using the pyplot (MATLAB-like) interface most of the time.
Theres no coming back to BeautifulSoup when you start using lxml. The performance boost you get is huge.
Indeed, but for something like a REST binding? It's not something you'd spend a minute messing around with really. I mean, for fuck's sake - it's basically 1) Query endpoint, 2) Use returned data. There's not much else to it.
thanks! If I had more than one up vote, you would get it.
Of course I don't know it, that's why I am here, looking to be pointed in the right direction of good (preferably free) online sources or books. I've gone the college route by my knowledge is in NLP and ML, not 3d game programming in python. I've read a few articles (the invent with python) which is how I am stuck in this rut, I know how to start making a PyGame game, but I do not have further knowledge to complete it, or make something like the Minecraft clone. That's why I am here on a forum looking for advice of good tutorials. A google search brings me to this: http://steveasleep.com/pyglettutorial.html which is good for learning Pyglet but it is still a simple game that doesn't abstract the game drawing from the game logic, which is what I seem to be stuck with in my settlers.
ZODB + repoze.folder + hypatia http://zodb.org/ http://docs.repoze.org/folder/ https://github.com/Pylons/hypatia/tree/master/docs It's an object database, but people often treat it like a document store (just add folders to the root and treat them like you might treat mongodb collections).
Yeah, I can see how that could be unacceptable or something.
why is everyone so interested in web scraping? python can be used for other things you know. 
I did notice the BeautifulSoup docs suggest that one can use it [on top of lxml](http://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parser).
I'm not sure why you want to add a length function to the String class. Just because other programming languages have a .length() function? That hardly seems like a rational reason for change. Instead, try to understand the history, logic and reasoning behind the design choices made. There is already a good way to get the length of a string, and any other sequence or mapping of objects. To change that would require a lot of good reasons not well documented in your blog post. Unless this is an early April Fools Day joke then, well, poor me. :)
The reason why it's a function and not a method is because it reads better. At last that's what Raymond hettinger said in one of his pycon talks. You're not the first to think of this, it was intentional. Writing a pep is also unnecessary, as an email to the bug tracker is enough.
I see. Thanks.
If you liked my pycon talk, you'll also like this lightning talk I gave last year which I've just found a video of http://www.youtube.com/watch?v=zjabxuWNHnM (watch it with headphones and full screen).
It's to avoid things like this that brought me to python. Why is this stuff necessary?
Slide 5 and 9?
Jeez mate it's april fools ;p .
holy jesus im stupid. sorry, still March 31 in USA... sorry :D!
Slides are at http://dabeaz.com/py3meta/Py3Meta.pdf in case you don't have 3 free hours at the moment.
I don't think it's preference. If you read a python script, and you can't tell where a function came from because of wildcard imports, it's just objectively bad from a readability perspective. Wildcard imports are good if you are using the interpreter interactively, not much else.
Just use scrapy. pip install scrapy BAM! Easy scraping.
Note that he does some live demos, which are worth watching.
It's fine not to agree. I have found times when it makes sense such as bringing multiple types of layout components into a single namespace. By importing star using all to init you don't lose the ability to do explicit imports. This is being over thought
A dependency check is certainly not the type of thing I would put in \_\_init\_\_.py (or probably anywhere, to be honest). Experience has also taught me to avoid importing into setup.py from within the package directory if at all possible (which it has been so far).
Many thanks!
I just push JSON to std out and and then parse it to dict with simplejson on the python end. It's not ideal - but it boosts productivity a whole lot for complex scraping, for example for scraping javascript heavy pages. What the author recommends is great for simpler stuff though.
Are we done recommending twisted now? 
 html = urllib2.urlopen(urllib2.Request(url,headers={'User-Agent':'Mozilla/5.0'})).read()
Yeah, the fact that you only get binary out is a bit of a bummer - being able to specify text mode and encoding would be nice.
Well I don't think you should spoof a browser user-agent, but yeah, that's how you should do it.
Yeah, I use phantomjs for that as well, should have mentioned that as context when I asked. I was curious what other people have done to solve that. I've dumped JSON to stdout and I've rewritten some html and attached classes or data-* attributes with javascript and then dumped the modified document to python on stdout (good way to compartmentalize the js code and keep it minimal and keep the main logic in the same language as the rest of your stack for code reuse). I was looking for some other ideas that might be worth looking at, how much processing do you do to the data in javascript? Do you dump raw data in that JSON blob or is it in usable form before you send it out?
Agreed, even with having to add an http header. If you have to deal with cookies then that's a different story, but what I wasn't taking into account was that this is about a one use throwaway script. Totally reasonable to just use urllib2 because you don't have to deal with the error handling that comes up when you are running it repeatedly.
Implementing Oauth? The myriad of different calls and options on the api? Format checking? I'd rather be doing something with the data collected rather than trying to work out what I'd done wrong in trying to talk to the damn API
**Is Python the way to go?** Yes! (admittedly I am biased but you did ask the question in /r/python :D ) **What framework should I use?** In this instance I'd recommend Flask (http://flask.pocoo.org) over Django or Web2py (http://www.web2py.com/) but let me explain why: Flask (like most micro/minimal frameworks) allows you to get started on your project with minimum impedance, with flask your project is a python project using a framework (flask) to interact with the web, with Django/Web2py your project becomes a Django/Web2py project that is written in python. For someone learning python I think this distinction is important; In other words you will find it easier to focus on learning python while building your project with flask, without running into issues occasioned by the frameworks requirements. This is not to say that you wont run into similar issues with flask as (any framework has a set criteria/requirements guiding its usage) its just that micro frameworks like flask are designed to stay out of your way while batteries included frameworks like Django/Web2py are designed to get you to a certain point quickly provided you use and understand the provided batteries. **What hosting provider?** Here you have a number of options: Heroku, WebFaction, VPS: Linode, DigitalOcean. If you need hand holding on the infrastructure end of things, id suggest you consider Heroku or webfaction, If you're comfortable doing basic linux config then a VPS like Linode or DigitalOcean **What database?** There is Only One: Postgres. Ok that's not strictly true; with python you can actually use most of the popular RDBMS out there including Firebird (which you might be familiar with given your delphi roots) **Can/should I build/design/test everything locally on my MacBook before I start paying for a hosted website?** Id say you should, not just because you would be saving on costs, but because the last thing you want to do is go live with your debug settings turned on by default (Although I should mention that this is a mistake that can be made even if you develop locally) 
In my limited experience, pyquery was a piece of shit (and I know jquery). I liked lxml and xpath. But that's just me :)
Most likely it isn't, in most cases. But in a few cases it is useful. Decorator are useful in a lot of cases. Not just when you use do "meta-programming" (which isn't a good term for any of this, since nothing in python are compile-time, which is normally one of the things that makes meta-programming special in other languages). A lot of web frameworks are build on the idea of decorators. flask for example, but dozens more. Descriptors are used under the hood by the `property` function. Which is also often used as a decorator. However using them directly is rare. Good use-cases for metaclasses are just as rare. However they are certainly handy for the implementation inside object-relational-mappers such as Sqlalchemy. Sqlalchemy is probably one of the best examples of why these things are important. The one thing to note is that to the user of the library, both descriptors and metaclasses are implementation details. Which goes to show that if you ever think you need descriptors and metaclasses you are probably building a very complex library or you shouldn't use them.
Clean way, sadly no. I'm unsure what you want exactly. I'm thinking you might want to look at the `decorator` package. https://pypi.python.org/pypi/decorator Concerning your example. Note that the body of a function makes assumptions about the signature of that function. So changing the signature usually requires wrapping the function. At least in the general case. Thus you might want a decorator. But it all depends on what it is you exactly want. Going from a general signature of `def f(*args, **kwargs)` to a more specific one `def g(a, b, c=None)`, the only think required is the create the function `g` and call the function `f`. Going further and wanting to create a function that does that for you becomes messy. Looking at the source of the `deocorator` package can give you an idea. It string-formats a new function and then evals it; to create the necessary signature and body which then calls the passed function body. 
You don't need to implement the entire API just to use the (probably) 2-3 endpoints you actually use. Indeed, you'll need to implement their "authentication endpoints", which is usually (again, not looked) a single endpoint you receive a token from.
Good question, I'd like to see what others recommend. Are you using PyQt?
For tasks like this -- yes, PyPy definitely should do a great job. But before that let's wait for pypy-arm being ready.
great post it shall help everyone realize that you're toasted as soon as you bump into a JavaScript heavy site, so you'll have to learn more complex scrapping tools
There's an example like that in Galry (based on PyOpenGL and PyQt): https://github.com/rossant/galry/blob/master/examples/realtime.py
it's probably safe to not mention old style classes now. Also, why not class decorators? they seem to solve the same problems, but I think they are easier to understand. http://www.python.org/dev/peps/pep-3129/ just my shitty opinion. 
Sounds perfect: &gt;The main goal of Galry is to provide the most optimized way of visualizing large 2D/3D datasets, by using the full power of the graphics card. &gt;Galry provides a Qt widget written in Python displaying an OpenGL rendering viewport. This widget contains your data. From the [FAQ](https://github.com/rossant/galry/blob/master/docs/faq.md).
Have a play around with the `functools` library
Got some good timestamps?
Eh? zip is a binary format, and each file in a .zip file could be text encoded with a different encoding to other files in the zip. If you know the encoding for a particular entry in the zip, you can wrap it with a `codecs.getreader(encoding)`.
I don't know why that is a case for ZipFile.open not taking a 't' mode and 'encoding' parameter (to map against the built-in open()).
Right, so ask some questions. People love to help but time is limited so you need to make it clear exactly which bits you don't understand, because if you just say you don't know anything, then trying to help you could involve writing a whole book. If you really do just want a book's worth of help then "Making Games with Python &amp; Pygame" looks like a worthwhile purchase. To be honest I don't think the things Xanny mentioned are that big of a deal at this stage. You've got barely any code there yet so your focus should be on implementing features rather than worrying about code quality. Pick a feature, try and code it, and if you fail, go ask somewhere. I think the best place for help like that is the Gamedev.net forums, but you might also have some luck over at gamedev.stackexchange.net if they don't decide to close your question immediately if you fail to get it completely on-topic and worded correctly. Finally, just 1 piece of direct code advice, don't do this: for i in range(len(self.points): blah(self.points[i]) That suggests you're translating C++ or Java concepts into Python. Python loops over the contents of a sequence, so if you want to operate on the contents of that sequence, you already have exactly the object you need - no need to build a list of indices just to then use that index to go back into the sequence. The `i` value is not needed here. Instead: for point in self.points: blah(point)
Just a minor stylistic note: W0311: 3: Bad indentation. Found 2 spaces, expected 4 ... W0622: 3:get_items: Redefining built-in 'zip' E0602: 13:get_items: Undefined variable 'os' 
You can matplotlib to do this. At the most basic level you can just update the graph data and redraw, and if for some reason that isn't fast enough (it usually is for most of my uses), there's lower level blit commands that can get a 10x or so speedup. See the [Cookbooks animation tutorial](http://www.scipy.org/Cookbook/Matplotlib/Animations) for some examples.
00:00:00 - 03:00:00 was pretty good.
How slow could it be? I'm just thinking along the lines of.. well I'd never select a R.Pi for anything I was even remotely interested in performance with. I imagine use cases like switching relays remotly to automate things. Polling sensors and logging to the network or SD. But nothing where an interpreted language could be to slow really. Are people trying to do stuff like computer-vision with this thing? What is it that Python is failing at, I guess?
Most of it seems to be rather basic stuff relevant since python 2.7 or even python 2.4. Edit: s/Most of it seems to be/Half of it is/
Yeah, I commented on the 'zip' part at the blog. Two spaces is for keeping it compact at the blog, and 'import os' is simply an oversight when extracting the snippet from the rest of the code.
It's run by some guy named McCarthy. 
Thanks for that link.
I remember recently trying to help someone pull and display 15 images from 15 web servers (security cameras) and display them on a screen, in python, on a raspberry pi. It did not go well. He was looking for 3-4 FPS. He got more like 3-4 SPF. Of course this was on #python, so ever 3 minutes someone would pipe in "USE TWISTED" so that was disruptive :-/
thanks, I've got Go on my list for some time, haven't touched it yet though
cool, I didn't know about praw :)
The author writes, in http://lists.debian.org/debian-legal/2012/01/msg00018.html : &gt; I didn't forbid "commercial" use at all. What made you think that I do? and elsewhere in that thread: &gt; I was seemingly unclear about my intent: It is _not_ that nobody shall money wise benefit from it. It really is not. Get rich. Sell Nuitka, it's OK for me. I want Nuitka, in this form already, to be included in about every Free Software distribution of the world. And sold too. By others. 
Thanks for the great comment, very useful! I spent an hour completing a few sections of python tutorials over at CodeAcademy last night, and I'm feeling pretty comfortable with the basic syntax at this point. I think I'll do the rest of their exercises before I try a flask tutorial. And I appreciate the Firebird reference--didn't expect anyone to throw that out there. We actually use Interbase more often at work but it's very similar. We'll be migrating to FB soon because it's more widely used/supported.
You're right, it is. However my plan is to start with one small piece of it and complete that, then build up from there. First I want to just make a webpage appear when I type something in my browser. Then I want it to show live data from my database. The payments and text/email notifications would be the final pieces. And I wouldn't even build that until after I demo it and get feedback (and probably rebuild the whole thing based on the feedback).
Have a look at [graphite](http://graphite.wikidot.com/). All you have to do is send it your data, and it handles displaying it. It also has a lot of functions (derivate, summarize...) you can apply to your data.
Porting from 2 to 3 isn't all that hard, I honestly wouldn't worry about it that much. 
you may want to post it as a [gist](http://gist.github.com) as well
Meta-point: run static checks on any final code. Easy and useful.
It depends (tm). I recently did this for an audio app, and I ended up with 2 completely different modes for sample-rate (oscilloscope style) and "strip chart" graphs where the update rate is in the 0-10 Hz range. For an oscilloscope display, it turned out best to replot completely every "frame". For the strip chart, it was best to incrementally update the plot and managed tiled redraw a la google maps. (The main requirement that led to tiling was that I needed a roll mode where the display smoothly scrolls even when no new data is coming in). In both cases, I was using the Python bindings for Clutter/Cairo to handle the drawing. Definitely fast enough to manage a realtime oscilloscope display.
Implementing a Z-Machine might be more worthwhile. Then you can use off the shelf editors to build the world and read just about any other interactive literature out there!
I didn't like the live demos. He took so much time typing things out just to show us the results that he has on the slides that he skips after.
Can someone explain to me how the sig.bind stuff works? It's executed in the body of the function as a function call but it affects the function object before the function is called.
Is software ever finished? In all seriousness, I believe the target is to have an alpha release out shortly.
SPAM
the workflow pieces will probably be the most difficult especially if you are using a lighter framework. not trying to discourage you though. Line of Business apps are a money maker but they are difficult especially for the web because of the workflow since http is stateless and workflow is essentially coordinating state.
You could use websockets and a javascript plotting package like d3.js. The JS packages are seeing pretty rapid development, while the python GUI toolkits have stagnated.
Thanks! I totally didn't see that. Looks like it'll be done soon. I'm definitely going to donate 
Look at bug report -- dafuq is this? Look at date -- jimmies unrustled.
* http://wiki.secondlife.com/wiki/PyOGP_Client_Library#Sample_Scripts * http://platipy.readthedocs.org/en/latest/pong.html * http://kivy.org/docs/tutorials/pong.html#doc-introduction * http://www.pyglet.org/doc/programming_guide/index.html * http://wiki.python.org/moin/PythonGameLibraries
God, I hate April Fools Day.
Take a look at : http://shopify.github.com/dashing/
Use Python 2.7 like the rest of us.
You could sandbox using restricted VMs like Travis does
http://www.GuiBuilder.net must also be built.
Do you ship commercial software? We do and there is almost no incentive to move to 3.x. For us and our new projects and old project 2.7 is near perfect. 
New libraries will depend on 3.x- features, so at some point you'll have to spend extra money to backport libs you want to use. Remember, I'm still talking about the future the whole time.
Why would I chose this over composing restful services and interacting with them using something like angular or ember or backbone? Looking at the demo it reminded me of WebForms. I don't know why I would ever want to go back to shoehorning a http request and response into a desktop style interaction.
While developing, throwing away all the data is a non-issue in most cases. In production, data migration without MVCC and schemas is extremely risky. I always want schemas. Even when I've had to use Mongo, I had my models enforce schemas and have explicit migrations.
I've used [highcharts](http://www.highcharts.com/) for this in the past, can't recommend it enough. 
i don't know really. in theory django will have bigger pieces to glue together so you wouldn't have to write as much. But the chances of all those pieces working together in an adequate way for you is probably pretty minimal. I would tend to go with a micro framework myself, but i've been doing this a while. :)
More importantly, it's very easy to write programs that run on both 2.7 and 3.3.
&gt;so at some point you'll have to spend extra money to backport libs you want to use. Not really. We concentrate on having highly decoupled components. If there is a must have feature or library that is not available for 2.7 we can throw up a restful service or strap a new endpoint on the message broker using 3.x in an isolated environment. But, we haven't ran into this yet. Again, 2.7 is near perfect esp in that we understand it's limitations. With 3.x it will be sometime before we can sign a contract with our customers promising five-nines and be confident about other SLAs. *edit..fixed some grammer
I'm curious. What kind if any SLAs do you have with you customers? Are you confident with 3.x and the supported packages at this point to make contractual promises about availability, accuracy and performance? Not meaning to sound negative but, genuinely interested since our strict SLAs require us to be cautious.
As much as I want to use Python 3 for everything, things not having been ported is a major stumbling block. I'm still in the camp of waiting. I do, however, keep wanting to get the ball rolling. Unfortunately, the Pocoo guys not being able to port stuff over is a major stumbling block. And now answer from the software developer in me: it will be done when it's done. When they feel they have something that is good enough, it'll then be marked as finished.
Yes, it can be finished. Sometimes there's no further functionality needed. It solves the problem you were looking to address perfectly, and does nothing more.
As the lawyers described it to me is that any code compiled with nuitka and distributed, anybody can ask the company to provide the source code (because of the open source license) and we MUST give them the entirety of the generated .cpp files so that they could re-create the .so that was distributed.
This article is in desperate need of editing, as there are minor mistakes and writing problems floating around in it. Other than that, it really doesn't talk about or motivate the use for metaclasses in any way, nor cover their behavior fully. This is another in a long line of tutorials trying to explain metaclasses by a person who clearly does not yet understand metaclasses.
I don't think class decorators are as flexible. I'm not too familiar with them, but with metaclasses you can use __call__ to return a completely different type depending on the arguments. Can you do that with a decorator?
seems like it
Hi jcaustin, Thanks for the great question! WebBot is as far from WebForms as you can get - it is not form generation (which inherently leads to artificial limitations and usually ugly generation) but a complete DOM implementation server side - and it does not shoehorn requests but uses the HTTP REST protocol as defined and intended. Also it is perfectly designed to be used with a separate REST API - only the building of the DOM would be done in Python instead of in JavaScript. Now why use it instead of these new breads of pseado MVC JavaScript frameworks that have been popping around lately? - It's Python - and using one language enables quicker development by reducing mental context-switches. - It allows the combination of both server-side and client-side code into new tags - encouraging semantic design and allowing clean and full reuse of web components something that is typically ugly, difficult and even often ignored when using separate server-side and client-side frameworks for obvious reasons. - Most JavaScript MVC frameworks use and or encourage logical design templates - which in my opinion are pointless since as soon as you have conditionals loops etc in your template you need a developer to do it (instead of designer), and you've essentially added one more additional language needed to learn. WebBot enforces pure template files that a designer could easily edit and which don't impose a new programming language. - If you use one of these frameworks your forced to either always load data via external AJAX/REST even when the data has to be loaded initially and updated after the fact - or have ugly hacks in your template files - that as I said earlier are already not really good MVC cause a programmer has to now go and modify them, or do you expect your designer to do this? Where as with WebBot loading something with the page or after with Ajax is easy, and you can even reload multiple sections of the page in one request without having to change your handlers or do more hacking. - WebBot provides GuiBuilder - a design tool that allows you to see changes to your templates while you make them which encourages designer to create them even more, and allows for quicker page design. Essentially WebBot does everything it can to encourage or enforce good WebDesign while allowing code-reuse and development using a single language. Thanks! Timothy 
No, iOS applications are in Objective-C and Android applications in Java. If you want to run your Python app on one of these platforms, you would have to write a Python interpreter in one of those languages (if I remember well, there is also a C SDK for Android so you could use that instead inb order not to end up with something wayyyyyy too slow).
What about Kivy? 
Nuitka, including its output, is under Apache 2.0, right? Apache 2.0 is a well-known permissive license. That means that you aren't forced to license your own code under the Apache 2.0 license. Here's exactly what it says: "You may reproduce and distribute copies of the Work or Derivative Works .. in Source or Object form" so long as you follow a few rules which don't seem to affect you. Section 4.4 is: &gt; You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License." What do you need clarified? Your lawyer's objection is that the Nuitka license requires source distribution, but the license nowhere makes that requirement. It says that object distributions are allowed, so long as the license (which contains the limited warranty information) is included somewhere. This is also what you need to do if you include software under the BSD license. In any case, thousands of companies distributed commercial proprietary software with components that use the Apache 2.0 license. The Android code base uses that license. Oracle ships software which contains Apache 2.0 components. How is that not enough for your company? 
I've been logging all my voice commands with the intention of doing something similar to whatpulse, but I haven't done anything with the logs yet. I've found my brain gets tired around the same time my voice does. Voice strain is definitely something to watch out for. Staying hydrated and eating apples or sipping honey water while dictating has helped me avoid it.
I would look into https://github.com/nod/databag. I have used it multiple times, and really like it.
Listening to her vocalization of stenography was hilarious. It definitely sounds a bit like what I do or like the original shorttalk system. I doubt a common infrastructure for the phonetic layer would be of much benefit, but having a common command/macro processing layer is a huge win.
Hi TheifMaster thanks for your comment I think the response I wrote to jcaustin best describes why this is not at all the case, Thanks! Timothy
You could use the English names for the commands just as easily. I have a good memory so I didn't find the effort of learning/creating this system too onerous. Learning Emacs itself is far more effort.
Note that the FileDownloader and InfoExtractor interfaces are not fixed/documented; we're still improving them - after all, youtube-dl is only import-able for a couple of months now.
Great. I'll take a look at it. I like the idea of using adventure paradigm as a shell also. 
The last time I ran into this problem, I just took the Windows approach - I reinstalled OS X. Once you do that, look into homebrew and virtualenv.
Thanks, these are all really helpful and insightful. When I get around to expanding/simplifying the code I'll keep these in mind. Edit: Just now learning about dictionaries, so will try to do that eventually. I've already simplified all the variable names and most of the boolean statements. One of the reasons the text is part of the code, is that my editor can collapse strings so that I can already follow the logic. Any suggestions on how to do this "If you generalize your test_input function to accept any input when choices_list is none, you can avoid raw_input in your in-game functions altogether." Also I removed a lot of those unnecessary variables like you said, the code is significantly cleaner now. Thanks again. Edit 2: Fixed \' issue. Also here is an update of the game http://www.mediafire.com/?wcj2732299gy7ov
Well, it solves your problem until you grow, or your problem changes, and then you need to do it again. Just one.... more........ change.........
Enthought python worked well for me on OSX for a while, but like some have mentioned, homebrew+pip+virtualenv is a great combo. I'd steer clear of setting up a python env with macports though , I had nothing but trouble there. 
Don't change the default. Instead use a virtualenv for each project.
This doesn't really have anything to do with python, it's just an API call. All it does is upload a video and download the CC file, entirely relying on the generosity and engineering of the underlying youtube transcription service.
Be sure to pay very close attention to the end of brew installs. They tend to give you very handy (and very necessary!) tips for updating your path or making sure that a certain program runs on startup. 
Tell that to Werkzeug. :(
mod_python, for example, is claimed to be finished.
There'd be some merit to that if one could show that backporting of features to 2.x continued in spite of the community's wishes. I think that would be a hard case to make. On top of that, if that was the goal, why make a compatibility-breaking 3.0 in the first place? I think a simpler explanation is just the tendency of people needing incentive to put in the effort to switch platforms/upgrade. The willingness of others to backport as many features as plausible from 3.x to 2.x just left much less incentive to make the effort. Python 3.0 came out in December 2008 while App Engine debuted in April of 2008. It only exited beta in September of 2011. Perhaps it's not yet making a profit or perhaps there's enough use of Java on it compared to python, combined with other libraries remaining on 2.x, that Google hasn't seen it worth the effort yet either?
I swear I saw an unofficial Py3k port of Werkzeug + Flask somewhere. 
Wrong. See my top-level reply.
I am really enjoying projects that are mixture of art/code like this. From the randomness of big data, interesting patterns can appear.
Some of the general info can be reclaimed via brew info &lt;formula&gt; I'm not sure about the items specific to your install though.
I've had reasonable success using MacPorts. However I ended up going with enthought eventually. Its just a cleaner install and worth 200 a year IMO. http://www.macports.org
I had a bad experience with pip/virtualenv. I just installed the basic numpy/scipy/ipython and I couldnt get them to pass all of their tests. I used Mac ports and it seemed to just work. Since then I just went the enthought route though because it simply feels cleaner.
Why is there a need to upgrade PyPy for python3? Is python3 _that_ different?