I hear "hello world" is using it print("hello world!") there you go ! ship it to production ! /has to port sqlalchemy
Durus 3.8 -- http://www.mems-exchange.org/software/durus/ -- was released yesterday, and is compatible with both Python 2.4+ and 3.0.
When will it be ready for gentoo T_T
Dictionary comprehensions are something I've been waiting for for a long time!
I feel the 10% speed decrease crashing over me.
That decrease isn't permanent. As 3.0 becomes more common, optimizations will come.
&gt; I can live without the new (2.6) string formatting system though (what was ever wrong with `str.__mod__`?). More to the point, why add another system when there's `string.Template`?
&gt; After the aching and painful years of the Python 2 series, the language once again shines bright and clear The idea that the 2.x series was in any way ugly or inferior to 1.x is foolish, surely.
That just means that the "waves of beauty crashing over you" lasts 10% longer!
&gt; [Python 2.0] also made necessary the awkward and expensive technique of building, and then immediately discarding, a list of tuples to quickly construct dictionaries [*example of building a dict using a genexp*] But [in Python 3k], no more! Ahem. This statement belongs in the comments of Python 2.4. Here is some code using both a genexp (introduced in 2.4) and a list comprehension (2.0): &gt;&gt;&gt; def makedict1(n): ... return dict((x, x*x) for x in xrange(n)) ... &gt;&gt;&gt; def makedict2(n): ... return dict([(x, x*x) for x in xrange(n)]) ... &gt;&gt;&gt; dis.dis(makedict1) 2 0 LOAD_GLOBAL 0 (dict) 3 LOAD_CONST 1 (&lt;code object &lt;genexpr&gt; at 0x5a728, file "&lt;stdin&gt;", line 2&gt;) 6 MAKE_FUNCTION 0 9 LOAD_GLOBAL 1 (xrange) 12 LOAD_FAST 0 (n) 15 CALL_FUNCTION 1 18 GET_ITER 19 CALL_FUNCTION 1 22 CALL_FUNCTION 1 25 RETURN_VALUE &gt;&gt;&gt; dis.dis(makedict2) 2 0 LOAD_GLOBAL 0 (dict) 3 BUILD_LIST 0 6 DUP_TOP 7 STORE_FAST 1 (_[1]) 10 LOAD_GLOBAL 1 (xrange) 13 LOAD_FAST 0 (n) 16 CALL_FUNCTION 1 19 GET_ITER &gt;&gt; 20 FOR_ITER 23 (to 46) 23 STORE_FAST 2 (x) 26 LOAD_FAST 1 (_[1]) 29 LOAD_FAST 2 (x) 32 LOAD_FAST 2 (x) 35 LOAD_FAST 2 (x) 38 BINARY_MULTIPLY 39 BUILD_TUPLE 2 42 LIST_APPEND 43 JUMP_ABSOLUTE 20 &gt;&gt; 46 DELETE_FAST 1 (_[1]) 49 CALL_FUNCTION 1 52 RETURN_VALUE For those who do not read disassembled Python bytecode, I'll explain. The first thing to keep in mind is that Python executes in a stack model, meaning that data is pushed onto the stack, an opcode is called, the opcode consumes some items from the stack (by "pop"ing, meaning by taking the top item away from the stack), then pushes the result back to the stack top. The bytecodes and how they work are at http://www.python.org/doc/2.5.2/lib/bytecodes.html . This means that the stack gets populated in a weird order, so the operation you expect to happen last might have need to push something on the stack first. You sort of have to read the bytecode that corresponds to each line of Python code inside-out to figure out what the result of that line will be. I'll work in logical order. The columns from the disassembler are (1) the source code line (once per source code line), (2) the address of the instruction, (3) the bytecode symbol, (4) the bytecode parameters, and (5) the variable, function name, or constant value, if the bytecode is loading or storing. So makedict1, using a generator expression, gives (essentially) this bytecode: 1. build an anonymous function out of the code inside dict that builds a tuple. 2. Next, push n to the stack (12). 3. Call xrange(n) (13). 4. Call iter() on the result from xrange. 5. Call the anonymous function with the result from iter(). 6. Call dict() with the result from the anonymous function. On the other hand, makedict2 does something different. I won't explain the bytecode this time, but it essentially translates this: [(x, x*x) for x in xrange(n)] into this: temp_list = [] for x in xrange(n): temp_list.append((x, x*x)) and then discards temp_list after it is used. On the other hand, the genexp translates this: dict((x, x*x) for x in xrange(5)) to something like this: def temp_func(n): number_iterator = iter(xrange(5)) while 1: m = number_iterator.next() yield (m, m*m) dict(temp_func()) del temp_func If you disassemble the "expanded" examples, you see basically the same code as the "compact" examples, except that all of the intermediate values are stored to named variables.
what does it disassemble into in py3k?
Thanks for all the great comments, folks. I did a round-up of the comments and some of the great links people posted here: http://reganmian.net/blog/2008/12/04/chinese-python-multilingual-programming-2/
Nevertheless, it's still disappointing. Python 2.x isn't that fast itself.
Dunno, IMO new versions of programming languages should not have such big slow downs.. 10% is significant.
Let me first re-emphasize the fact that I only wanted to show that Python 2.4+ also has the ability, contrary to this article, to construct a dict using comprehension-style syntax (specifically a generator expression, which was shown in the article) without constructing an intermediate list. That said, py3k treats the [] list comprehension syntax as syntactic sugar. In other words, my example of ``[(x, x*x) for x in range(n)]`` translates to ``list((x, x*x) for x in range(n))`` (noting that py3k's range() function returns an iterator, and so xrange has been removed). However, it still causes the creation of an intermediate list instead of simply using a genexp inside a call to dict().
&gt; That said, py3k treats the [] list comprehension syntax as syntactic sugar. Almost, but not quite syntactic sugar. I found a difference between the two and brought it up on the mailing list, but the group consensus was it's not a bug, since it's messing with undocumented behaviors: &gt;&gt;&gt; def break_fast(n): ... if n &gt; 5: ... raise StopIteration ... else: ... return n ... &gt;&gt;&gt; list(break_fast(i) for i in range(10)) [0, 1, 2, 3, 4, 5] &gt;&gt;&gt; [break_fast(i) for i in range(10)] Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 3, in break_fast StopIteration 
If a 10% runtime performance change impacts your project significantly, why are you using Python to begin with?
Summary: Here's a list of solved problems and non-problems that I don't understand regarding Python3k. I don't get it. I don't get it at all. Ruby did it better.
The comments on the page are good (far better than the actual article..)
Why?
From TFL: &lt;quote&gt; This is not (or at least not yet) a library to produce or interact with javascript code. I just liked the jquery API and I missed it in python so I told myself "Hey let's make jquery in python". This is the result. It can be used for many purposes, one idea that I might try in the future is to use it for templating with pure http templates that you modify using pyquery. &lt;/quote&gt;
I've heard of one person whose company switched to python 3 (this was a few months ago). In the open source world, it is much more complicated - first, you and your dependencies must upgrade to 2.6, then your dependencies have to run on 3.0, and then you can start moving to 3.0. So it will take quite a while before 3.0 goes anywhere. Up until now this process couldn't really get started with a substantial project for a whole bunch of reasons; the divergent except syntax is just one reason (2.5: "except ExcType, exc" 3.0: "except ExcType as exc" and 2.6 allows both)
Web robot?
Sign of the noob: &gt; I’m pretty sure I’ve written something like “`for i in xrange(a,b)`” in every significant Python program I’ve ever written, causing all of them to break in 3.0 until I update them. Man, I almost never use use ranges in my programs. Just use `for index, item in enumerate(items)`. 
Hey 2000 called. They want they announcement back.
I can't recall ever needing it, but I'm just glad it's there for completeness.
The speed I don't really mind, but the startup time really needs improving. Compare how long a MATLAB script takes to start running, with the equivalent numpy/scipy script and see what I mean.
&gt; Jens states in the comments to his article that he feels like the changes in Python 3.0 are “academic”, by which I assume he means “irrelevant to real developers and practical concerns”. Based on some of the examples above (and plenty more which can be found by browsing the new documentation), I hope it’s now clear that this is simply incorrect. Python has, for as long as I’ve been using it, come under continual fire from people who felt it didn’t embody some theoretical notion of purity that they cared about — Python doesn’t make threads the One True Way to do concurrency, Python doesn’t force everything to be an explicit invocation of a method on a class, Python isn’t a pure functional programming language, etc. — and over that entire time Python has steadfastly resisted the idea of purity for purity’s sake (or, more derisively, an “academic” notion of purity). As the Zen of Python makes clear, “practicality beats purity”. Written for the benefit of Wiseman1024?
Think this pretty much sums it up - http://www.somebits.com/weblog/tech/python/xpath.html &gt; Bottom line? Python is all about "batteries included". But the XML batteries are weak. There are some more powerful options but they've all got drawbacks. A decent API for parser and manipulating HTML / XML is much needed. 
&gt;But what this really means is that there's hardly anyone who will want to actually upgrade to Python 3.0 for the time being. &gt; &gt; ... &gt; &gt;it's displayed so prominently on the Python web site, without any kind of warning that it's not going to work with 99% of the Python code out there, scares the hell out of me. People are going to download and install 3.0 by default, and nothing's going to work. Folks won't want to upgrade, of course, but newbies won't want to invest in old technology. Eventually the twain shall meet. 
nice article. wanna to know is there any SVD(LSA) python module can handle sparse matrix? 
I figured people that already know what the project is would be interested in the news section, and that putting the detailed description of the features towards the end of the posting would be useful for those not already familiar with it.
I'm just hoping the Python people don't make the same mistake as the PHP people with PHP4. Python 2.x is very successful and widely used. It can't die, or else Python itself will suffer. 
It's based on lxml, it's just a nicer, higher level API to hack things quickly.
beautiful soup does a pretty nice job.
The point is there to separate the major version number (3) from the minor number (0). Without it, it would be thirty, not three.
This really doesn't need an article. How to configure and make is all he's showing, which is pretty standard fare.
&gt; gone through hell for unicode problems... So how will having two string types instead of two string types help you solve that? ;-)
Maybe scipy does - the have svd afaik and also support for sparse matrices.
' 
This guy just won't accept that he jumped the gun. Hey! how about *not* downloading and using python 3 on your machine at all! Does software install itself on your machines? 
Thanks for the reply from these two link: http://projects.scipy.org/pipermail/scipy-user/2004-November/003789.html http://aspn.activestate.com/ASPN/Mail/Message/scipy-user/3215081 It look's maybe some barrier here. :(
The dog told him to do it?
Haha, exactly what I was thinking, but I was about to write as "Keeping the flame alive!" or something around those lines. Basically, he got famous for bashing Python (in the wrong way, if you read the comments of his original post.) Then, when the spark was about to die, he had to write *another* post but this time attack Python in another level. No, it's not the language that's wrong it's... something higher.
Zed, fuck yeah! 
cryptic code.
?
You know who Zed Shaw is and you didn't read [Rails is a Ghetto](http://www.zedshaw.com/rants/rails_is_a_ghetto.html)? &gt; I don’t want to be a “Ruby guy” anymore, and will probably start getting into more Python, Factor, and Lua in the coming months. I’ve got about three or four more projects in the works that will use all of those and not much Ruby planned.
When you're sarcastic on the internet you have to use a smiley, otherwise someone will misunderstand your intent. This is a horrible state of events. Anyway, for that I think the standard is `:P` but I kind of prefer `q8Y` it is a duck in a backwards cap and sunglasses.
Only once you add http://code.google.com/p/soupselect/ IMO
Heh. &gt; practicality beats purity I believe Larry Wall thinks this way too.
No, he thinks pr&amp;ct!c@1i%y be@%$ pur!%y. :-D
Ahhhhhhhh. I think that's the first time I've ever seen a one character comment that actually made sense.
As far as I can tell Perl 6 has the kitchen sink and more. It will have a richer type system in that it will have some form of optional static typing. I suspect it will have a more advanced regex system that is built into the language. The Perl 6 switch statement is fantastic and I think you'd have to use a bunch of if-elif-else to do similar in Python. I'm sure there's plenty more but that's all I can think of right now.
People love to bust Zed's balls for being a bit of a drama queen. But you know what? That dude can code like a motherfucker, so I say that wins.
&gt; However, if you compare it to a postfix setup that’s using aliases off pipes to send email it’s already processed to a Perl process so that Perl can parse the email again in order to then send an email back to postfix using SMTP… &gt; The short version: Classes and methods beats pipes and processes. If performance is important.. Benchmark and profile, lots of people have been bitten by simply making a statement like this and going with it. While that statement may be true, there may be some other glaring flaw your presumption will cause you to not catch.
Could someone closer to Python development explain this? I hope the article is not correct, this is retarded.
In Python 3 filenames come in `str`, which, in Python 3, is in Unicode and only Unicode. On UNIX, however, filenames are arbitrary strings of *bytes*, without any inherent encoding. (Of course your system will still use an encoding, likely UTF-8, but nothing prevents you from creating a file with a name that is not a valid string in that encoding). To avoid raising exceptions `os.listdir` now silently ignores such files and doesn't list them at all.
I think this is quite retarded, but then UNIX filenames are retarded too. People are not notoriously good at handling random bytes, they are better skilled with characters, so filenames should have been proper strings, not bytes.
I guess I don't understand the problem here. Despite having spent years using Unix and Unix-like systems, I've never created a file which caused such a problem (and the idea of doing so intrigues me; if you've created a file whose name cannot be decoded by the system you're using, why would you expect a programming language running on that system to do any better at it? And what's the use of a file your system can't handle in the first place?).
Filename cannot be decoded, but most programs still show the file. E.g. try this: echo &gt; `echo файл | iconv -f utf-8 -t windows-1251` 
Thanks for this explanation (and the example below). Illuminating.
I don't see the problem. If you know you are dealing with improperly encoded files (which never ever should happen) you can still use the byte interface (that is os.listdir(b".")). On OS X i can create improperly encoded files as well and every GUI app has major problems. It still wasn't a problem. I don't know a single GUI application on Linux that I use that does not handle the filesystem encoding properly. Neither does any terminal app I have which in worst-case uses the terminal encoding which incidentally is utf-8 like the one for my filesystem.
The problem is that the apps actually have to handle this, because the setting is per-user. In the modern days, the OS/FS should enforce UTF-8 encoding and the only valid setting should be to use UTF-8 for all filenames. Otherwise, forget running apps not written in C, since almost every other modern language has a unicode string class which simply can't allow passing non-unicode strings trough, because it could cause security holes (and data corruption everwhere). Yes, Unicode breaks the old Unix 'everything is a stream of bytes' (even for file content, because you need to differentiate between text/binary). I suggest going back to ASCII if that is a problem. 
I agree. The only valid arguments (besides back-compatibility, of course) for filenames as bytes I have seen is this. Suppose you unzip an archive that comes from a different system. Then it might as well try to create files with non-UTF-8 names. But I think it is much better to force file-transfer programs (unzip, rsync, some others) to have "name deuglyfying" schemes than to force every second program that ever deals with files to handle such human-unredable names.
That is sweet. I wonder if it would work for binary extensions.
That is amazingly awesome. I wonder if it extracts the file to some temporary directory and allows you to reference other files inside the archive with "myfile.txt" for example.
Not right now, but it could. Needs a protocol to store platform-dependent modules at the least.
Two things: Firstly 'features' don't describe the core idea of the project. You need a one to two sentence explanation of exactly what problem it solves, generally starting out with "Spring Python is ..."? I'm guessing it's a web framework? I get that after going to the Spring Python website, and then finally to springframework.org. And since Python is polluted with frameworks, you should also mention what makes it different. Secondly, at-the-end is a lousy place to put it for anyone coming to it fresh. They just won't get there. Anyone will give up before getting that far. On the other hand, if you placed a description first, those familiar with the project would intuitively skip that paragraph, and read what they need to know.
good to know! it's called the shebang btw.
the article doesn't provide a workaround, which is posted above, but i'll post it here anyway: use a byte string. os.listdir(b".") instead of os.listdir(".") 
i had this in windows - i've downloaded a file which had some russian chars in its name; it broke certain apps before i renamed it. those apps were not python, btw, so i consider python 3k smarter than average now.
Can you link to the rest of the interview? This only covers two of the ten points and I can't find the other parts.
how much have you tried? there is a pretty good very basic introduction/tutorial through the scipy website. have you tried this: http://www.scipy.org/SciPy_Tutorial ? Once you get through that, i'd recommend writing a little python based data parser to scrape data from a website / database and do something with it.
how can you possibly talk about a CDN where files must be smaller than 1M ? everybody interested in running a CDN is doing it for audio or video content.
I've gone through some of the tutorial, the problem I've found is that there's one really basic issue I keep having. Most of my data is in CSV format, and R is really nice at keeping factorial, numerical and character vectors in "data frame" objects that keep the data all bound together with row names and column names, I've had trouble pulling in these files into Python, partly because they're a mix of character and numbers (I suspect). So maybe the big problem is I have poor knowledge of file I/O techniques in Python.
Muphry would be proud.
[interview part 2](http://www.artima.com/intv/prodperf.html) \(there is no part 3\)
It doesn't. It does, however, accept a directory instead of a zipfile, so you can do development in the filesystem without zipping it first. Also, if you use setuptools' "pkg\_resources" module, you can access files as strings or streams, whether they're zipped or not. You can also use resource\_filename() to get the filename, but that only works in the zipped case if you are using an .egg file.
Actually, it works just fine on .egg files. Setuptools can even generate the shebang for you, and it works with older Python versions. See [the eggsecutables doc](http://peak.telecommunity.com/DevCenter/setuptools#eggsecutable-scripts) for details.
Thanks. Always interesting to hear an expert perspective on Python.
Obfuscation contests!
That's quite eggciting.
They didn't exactly have Unicode when they developed the UNIX file management code..
[interview part 3](http://www.artima.com/intv/typing.html) (there is a part 3) [interview part 4](http://www.artima.com/intv/tipping.html) (there is a part 4 too) 
You can gain large increases in perceived responsiveness by serving smaller static files as javascript, css, and images used for chrome through a CDN.
Yes, it is an understandable decision, but that doesn't make it less retarded from my point of view. Edit: Also, I don't really know anything about Windows, but afaik filenames there are unicode strings now. Maybe UNIX-like systems should have enforced similar rules at some point too? I don't think it is worthwile to keep backward compatibility forever.
Bruce was the one who introduced me to Python through I side note in his "Thinking in Java" book, but really ``for line in file('filename').readlines():`` is just silly.
Heh, fancy that. They were not listed on the interview page. Just part 1 and 2. Thanks.
did you read the post? It mentions dictionaries a lot
true, but you will get much larger gain by compressing those and combining multiple chrome elements into single images. and using multiple domains ( image1.domain.com, image2.domain.com) because the browser will thread those separately. the CDN boost is going to be most effective for apps that need streaming, lots of images etc. I just thought the article was misleading, to go and read it thinking there was a way to really leverage app engine as a CDN. 
I feel like this breaks the zen of python. We still have name mangling as a somewhat implementation of 'private' members, which seems like a horrible answer. Explicit is better than implicit, and right now 'private' is implicit. If I'm investigating a new API that's poorly documented, I'm using dir and help a lot, and it'd be nice if I could see via those commands what the programmer really intended the 'public' interface to be and what I should just ignore as implementation details. Don't get me wrong, I like the fact that I can, if I want to be so bold, mess around with private members. I just don't like naming conventions like upper case letters and clever placement of underscores to replace something as explicit as public, protected and private. Just like type annotations in P3K, these could mean nothing to the runtime itself, but their mere existence was always just as a hint to the reader anyway...
[This](http://www.comp.leeds.ac.uk/nde/papers/teachpy3.html) is a good paper about teaching python 3.0, might be worth a read.
Python 3 is definitely a better language, but I also like ipython for dorking around, and all of my operating systems will probably come with 2.x for the foreseeable future. I dunno, man, but it keeps me up at night.
3.0 won't be standard for awhile after you teach the class. I'd say teach in 2.5/2.6 with an eye towards compatibility (you know, have them avoid `has_key` or string encoding, etc.) In addition, if your students look for help, or want to branch out from your class, 99% of the Python code on the internet is 2.x still and will be until 3.0 gains some adoption a couple of years down the line. EDIT: Not to mention books and other material already written for 2.x
Please check out http://blog.springpython.webfactional.com/index.php/2008/12/09/spring-python-0-9-1-has-been-released and tell me if you think this is a better lead in.
If they don't know anything about python yet, then 95% of what they have to learn will be identical across versions anyway. If you want to show off lots of the fancy non-builtin libraries (image manipulation, graphing, etc etc) then you'll need to stick with 2.6. Either way, not much of a difference in the core language as far as basic learning.
Those are a couple good points of why 3.0 is better for beginners.
&gt; you'd have to use a bunch of if-elif-else I usually use dicts for situations that sound like what you're talking about. Then the conditions can be dynamically modified and iterated or evaluated too.
[Python Programming in Context](http://www.amazon.com/Python-Programming-Context-Bradley-Miller/dp/0763746029) would be a **kickass** introduction to Python (or CS in general for that matter). It covers 3.0.
Way! Still doesn't *exactly* describe what it is, but it gives me a lot more to go on. :)
Are you really Japanese or are you just using a Japanese username? In any case, Japan has some problems with legacy JIS systems gunking up file system encodings. And don't get me started on \ vs. ¥.
&gt; In any case, Japan has some problems with legacy JIS systems gunking up file system encodings. And don't get me started on \ vs. ¥. So? If you have JIS on your filesystem set the encoding to shift-jis. If you have filenames of multiple encodings on your system you are screwed anyways and you have to use the byte interface and do the encoding guessing monkey dance.
I think this (iamjack's) point is far stronger than harma's paper. As a new student writing my first program, I definitely needed online references. 
Teach 2.x; it'll be a couple years before your students will be able to usefully work with/learn from software written in Python 3, so explain that to them at the start and then dive in.
Two not mentioned: Google Charts and Visualization. Definitely not useful in some circumstances, but really awesome if they are. http://code.google.com/apis/visualization/ http://pygooglechart.slowchop.com/
Awesome, simply awesome. I've long thought that a pure-python PG driver would be possible; it's nice to see others thought the same and acted upon it. Also: anyone have experience with this driver? I've used psycopg1 and psycopg2 and haven't had too much trouble. 
Right, in Perl you see a lot of hash dispatch also. Can you dispatch on the result of a regular expression match with dictionaries in Python?
do the win32api mods work with 3.0 ? If not then I would suggest 2.6 just to teach some really cool features. 
Wrong kind of graph. He means http://en.wikipedia.org/wiki/Graph_theory and http://en.wikipedia.org/wiki/Graph_(data_structure)
Agreed that those people are screwed, but sadly that happens way more often than it should. There's a reason that "moji-bake" is a loan word from Japanese to English.
Rather eggsellent.
It was released in December 2007...
Why would anyone want to scrap the web?
How can you scrap?
I, too, sometimes feel that the web should be scrapped. Start over fresh with something else.
That's what 2.6 is all about. It's the bridge between 2.x and 3000. I wouldn't bore them with the details, just teach them what is fun about programming, and use Python 2.6 if you can.
I use pg8000 for a variety of tasks, and I know of a handful of companies who do as well. I don't consider it up to the level of stability of psycopg2 -- it just simply isn't that widely used. I'm hoping that the new Python 3 port will bring the library to an expanded audience as, to the best of my knowledge, it's the first available PostgreSQL driver for Python 3. pg8000 also lacks support for many PostgreSQL data types. Types that are supported are listed in the [documentation](http://pybrary.net/pg8000/pg8000-v1.06/types.html#supported-python-types). I think that it covers the common, core types pretty well. Missing are things like network address types, geometric types, UUID and XML types... also, not all types are supported in arrays, as doing so requires that they use the binary serialization protocol. I think pg8000 has mostly been used where it's pure-python-ness is a distinct advantage -- situations where pushing a bit of python code is easier than getting C modules built. I'm hoping that it gets wider exposure and testing.
I'd bet the slowdown is in the unicode handling glue. Text will always be substantially slower, but I expect this to improve quite a bit over the next few revs.
I don't get it; PyDev has a terrific shell with code completetion &amp; all that...
Well, this doesn't look good.
It's actually because the IO portions have been rewritten in python exclusively, instead of C.
I've tried it and it inserts code for me which is a major no-no. Maybe it's an option I need to turn off but it doesn't seem to understand aliasing -- I have in my code the simple and idiomatic `import sqlalchemy as sa` and NetBeans insists on sticking `import sa` at the top of my file which then breaks everything. Infuriating. I may need to stick to Emacs and Komodo Edit for Python stuff and NetBeans for Java and JRuby.
Yikes! Have a citation for that? Google was not immediately helpful...
Go to the Python-dev mailing list and look at the 3.0.1 thread.
Thanks. [Issue 4561](http://bugs.python.org/issue4561) seems to be the crux of the issue for anyone else that's interested.
As a counter-point, I'd like to point out something I noticed while working on pg8000. The Python 2 head of pg8000 runs the unit test suite in about 30 seconds. The Python 3 head runs the unit test suite in about 2 seconds. I think the difference has to do with socket buffering (as the Python 3 version uses the io module's BufferedRWPair), but my attempts to introduce similar buffering in the Python 2 version of the library have not resulted in a massive performance improvement. So, I dunno. It's pretty cool that it's so fast, though. If anyone is interested in taking a look at my Python 2 socket buffering code to figure out why it doesn't kick massive ass like the Python 3 version, it can be found in [protocol.py](http://hg.pybrary.net/pg8000/file/3029a77f7b32/pg8000/protocol.py), lines 912 - 936.
Honestly, BeautifulSoup really does scrap it.
Never mistake cynicism for insight...
Not mentioning Mechanize = FAIL.
What version of CPython it is compatible with ? 
&gt; The whole idea of unicode is to move away from this expectation, and to start thinking of thing in terms of bytestreams. What on earth?? To paraphrase, "I am not able to rightly apprehend the kind of confusion of ideas that could provoke such a statement" 
please stop spamming this book.
Pray, Mr. Van Rossum, if I put into your language wrong bytes, will the right characters come out?
My team is already using IPy in production as a presentation-layer scripting engine for a SharePoint application (C#, ASP.NET). Very useful because it has access to the .NET objects.
IronPython 2 targets Python 2.5.
Yes, my bad, my bad.... I'm glad that the firestorm over my various malopropisms has yielded such corrections, and frankly has helped me to better the article. I will respond to your comment there too. Part of why I wrote this was to help me get my head straight when it comes to this stuff, something I had been unable to do using the Python docs. Your comment and others are helping. Thanks!
Performance is 'ok'. It runs pystone and richards *much* faster than CPython - but they are both terrible benchmarks. The IronPython Codeplex site has a page on performance showing PyBench runs for both CPython and IronPython 2. Some things (function calls, arithmetic, non-exceptional exception handling code) are substantially faster than CPython. Other areas are slower. Because the performance profile is so different to CPython you will tend to find that code optimised for CPython will run much slower on IronPython. If you write code *for* IronPython then you can get very good performance out of it. One of the major advantages of IronPython is that it is massively easier to write extensions in C# than it is to write C extensions for CPython. 
It's a scrappy little thing.
No AA font support and it gets uninstalled. I'm not going to work looking a poorly rendered fonts, if I wanted that I would go back to windows. If eclipse can use native font rendering, netbeans should do the same.
I run a couple of Drupal sites and a couple of Plone sites...and I have to say that I still prefer Plone when it's an option. Not that the author is wrong about the complexity of the system. Developing for it is hard, and it does have a lot of layers (reverse proxy for speed, Plone, Zope, ZEO), but that's because it's very, very complete. By contrast, Drupal's easy for quick and dirty, poop-me-out-some-web-and-host-them-on-LunarPages kind of stuff. However, security is a /nightmare/, you can't even have hierarchical content without wedging in a couple of modules for uses they weren't intended for, and handling of non-HTML content is awkward, like in all LAMP-based CMSes. 
&gt;I prefer Python over PHP any time There's is this framework called Django...
&gt;security is a /nightmare/ How so? Drupal is one of the most popular CMSs out there and I don't hear of up-to-date Drupal sites getting hacked.
Today was another day for a security advisory for Drupal: http://secunia.com/Advisories/33112/ This makes 137, as of now. http://secunia.com/advisories/search/?search=Drupal
&gt;These vulnerabilities are reported in versions prior to 5.13 and 6.7. ...The solution being merely to update which, although inconvenient, I wouldn't classify as nightmarish. 
Sorry; that's not the sense in which I was referring to it being nightmarish. I mean that it's stupid difficult to actually restrict user permissions on the site. The default security model is so coarse as to be useless. Add-on security modules are of widely-varying quality, and often play poorly together. On top of that, it's pretty clear that security is a pretty low priority for Drupal. I've had a [moderately-serious issue](http://drupal.org/node/129225) filed against it for quite a while—Drupal still shows menu items that a user does not have access to. I wrote a [module to hack around this](http://drupal.org/project/remove_nonviewable_menu_items) for Drupal 5. Someone alleged in the discussions for the bug filing that Drupal 6 does this check properly, but judging by the demand for a Drupal 6 version of the module, that's apparently not the case.
True in that regard. Drupal does have a lot of rough edges that, even in Drupal 7, are likely not going to be smoothed out.
Plone is an entire CMS, not a framework
I found Plone way to complicated just to get a website up and running myself. Bought a book and everything, eventually gave up and used Joomla.
I often baffle the developers I speak with as to why I don't use frameworks for my projects. I believe that frameworks are, for the most part, over-rated and for most people will end up costing them more time/effort than if they were to start from scratch or a small WSGI library. I tried Django for a month with various projects, and while I enjoyed the community backing it, and the ease of installing middleware for it, I just can't get over the bulk of maintenance and overhead ever-present. With WSGI and simple defs which provide efficient cookie storage/retrieval, custom MySQL handling to increase code readability, and Tenjin for template rendering almost 10 times faster than Django, I end up with code which uses only what it needs, and will never use any more resources than are necessary. I can easily transfer the code to other servers and not have to worry about installing a framework and configuring it for the system, then ensuring that the database is up to sync with the framework. If you are a developer who spends a lot of time in various projects, and want to have only what you need in your program, I suggest you give what I've described a shot. Otherwise, truck on with frameworks such as Django.
Updating every week? Are you kidding me? 
Drupal 5 was released earlier than February last year. Divide that amount of weeks by 14 releases and that's how often you have to do an update (much less frquently than once per week, less than one per month). Drupal 6 was released in Feb this year, so 8 releases in 10 months. Also, if you've set up your site properly, and haven't patched core too much, an update takes around 10 minutes. The point releases are easy to live with, it's the major releases, when they change the API, that require some elbow grease. :) 
I'm talking about the 137 security advisories. 135 since 2005-03-07. 
http://secunia.com/advisories/search/?search=Drupal
The updates address these, don't they?
And yet, interestingly, it was built on top of a web framework stack. Perhaps a CMS could be built on some other framework as well.
I've [answered these types of objections](http://www.b-list.org/weblog/2007/nov/19/frameworks/) (in fact, [multiple times](http://www.b-list.org/weblog/2006/jun/03/lets-talk-about-frameworks-programmer-edition/)), and yet no-one ever seems to bother rebutting me when posting comments like yours. Feel like having a go at it? ;)
Cute. I've written a few similar libraries for Ruby and C, sadly none made ready for general consumption. One useful addition to this approach is to keep a timestamp with each filter, so you can specify a (soft) maximum age for items in the group rather than just having the list of filters grow forever.
vim + the [project plugin](http://www.vim.org/scripts/script.php?script_id=69) is the way one should roll on any os.
Less than 1 update per month for weekly security problems? 
Security problems range in severity. Drupal is a very popular CMS used by some very high profile organizations. I don't hear of these sites being hacked so it would seem that Drupal's releases are addressing critical security issues promptly.
Well, that's hardly nightmarish, but I can see why it's frustrating. Out of curiosity, did you try menu_rebuild() ?
The module that I wrote works by hooking the menu building function, and creating "poisoned" entries for nodes the user does not have access to. At least in Drupal 5, I'm pretty sure that rebuilding the menu doesn't help. Perhaps "infuriating" is a better word than "nightmarish". Wanting to restrict access to part of your site to a group of users is hardly an uncommon task, and yet this simple thing can't be done with a basic Drupal installation, and can't be done easily and well even with security add-on modules.
What is k? Is it the number of bits you set to 1 for a given data item? 
k is the number of hashes you want to use, and in the scalable filter it's also the number of slices each filter has. The explanation of each variable can be found here: http://en.wikipedia.org/wiki/Bloom_filter
I would like to know how you handle cookies with WSGI. This has been a problem for me.
I've been learning Python by reading the documentation, some tutorials and the O'Reilly Learning Python book. I get the language syntax and semantics, have written some smallish-sized scripts, but I really want to get a better understanding of how larger-sized Python applications are structured. Any recommendations on good Python project source code to read to get a solid understanding of idiomatic Python?
Why not read the Python standard library code itself? It's rather informative, and full of good examples of Pythonic code. You'll find it in /usr/lib/python2.X. You can find other (non-standard library) good examples of structured python code for larger projects in the site-packages directories in those dirs. site-packages/numpy is a good start (it's installed by default in Ubuntu, I believe, though the 2.4 version only has C loadable modules). Pylons (a python web framework) is also a good start.
That's a good idea. Thanks! I am familiar with Pylons; I understand Reddit is based on this and I did look at the Reddit source code when it was opened.
Hi. I'm a Python learner like you, and I'm still struggling with finding the best IDE. Which one are you using?
Some people love vi or emacs. Both have support for Python. The top IDEs that I usually hear people suggesting are Komodo (the Edit version is free) and Eclipse with PyDev. I personally use Eclipse with PyDev because I have projects in Java too. PyDev incorporates unit test running, debugging, code coverage, refactoring, syntax highlighting, and code completion. I you are learning, sometimes is nice to use a simple editor like Gedit or Notepad++ so you are not trying to learn the IDE and language at the same time. Oh, and you *have* to get IPython, it is amazing. You can do tab completion and it lets you inspect objects.
I have not yet found an IDE I really like. I have been using either a text editor + command line, or IDLE. NetBeans just came out with support for Python; it's a pretty good Java+ IDE so I might check it out. The suggestions in johnnyh749's comment are also worth investigating.
Netbeans does fine Python editing too. Stani's Python IDE (SPE - cannot remember the link) is excellent with autocomplete and debugging but can be a little buggy at times.
Have you tried the NetBeans with Python support?
Other than the suggestion of the standard library, read [CherryPy's](http://www.cherrypy.org) code if you're doing web-dev stuff.
Django--it also shows you how you should be documenting your code. Learn the code style and idioms * Check out [PEP 8](http://www.python.org/dev/peps/pep-0008/) * [Style Guide](http://www.voidspace.org.uk/python/articles/python_style_guide.shtml) * [Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) * [Python Gems](http://www.eflorenzano.com/blog/post/gems-python/)
I second SPE, as long as you're building command line applications.
The full IDE version of Komodo is excellent. I bought the student edition a while ago for $30 but from looking at their site, it appears that you can't do that anymore. The non-student version is $245 which, nowadays with all the open source tools out there, seems excessive. Still, it's a great tool. It's like Visual Studio for the scripting world. It even has an emacs emulation mode. That being said, I haven't used it in a couple years. I found that it was great for big 5000+ LOC projects, but almost overkill for small scripts. Also, at my current job, I need to debug code on many many different platforms - more than just Linux, OSX, Windows and Solaris. What I'd really love now would be a Python debugger integrated with emacs. But anyway, I don't work for ActiveState, I just feel strongly enough about it to give them two thumbs up for Komodo. I love open source software but I still think it's reasonable to pay for quality commercial software.
I recommending Editra. It's a great cross platform editor, with lots of IDE functionality. It's also written in Python and a good project to go through especially if you want to learn wx (GUI) programming. 
or insight for cynicism.... (although, admittedly, this example was the latter)
I hate it when people name their programs things like *project* you always get millions of crap from google. Any link?
You can download [Reddit](http://code.reddit.com/).
NetBeans doesn't have subpixel font rendering. Ugly fonts aren't acceptable for an IDE. Gedit, or Eclipse + pydev work great.
Go through the tutorials and write a simple game with Pygame.
details?
I would say the exact same thing, but go with 3k instead.
Reformatting the list * [PEP 8](http://www.python.org/dev/peps/pep-0008/) * [Python Style Guide](http://www.voidspace.org.uk/python/articles/python_style_guide.shtml) * [Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) * [Python Gems](http://www.eflorenzano.com/blog/post/gems-python/) (For future reference, list items need a leading space per indent level, at least one)
I recommending WingIDE. It's "Auto-completion for Python and extension modules" and "Debugger" really impressive. 
SQLAlchemy
&gt; def update(self, time_passed): I'm not a big fan of making the game mechanics depend on the screen update speed. This can lead to strange behaviours and bugs when the game is running really slowly. It also means that if you record a demo of the game, it can't be replayed back at a higher frame rate on a faster computer, because this will change the character movements very slightly, possibly causing you to bump into a wall when you replay the demo, whereas before you just missed it (I'm sure some of you have seen this problem with some older games' record / playback function). I prefer to create two loops, one for the game mechanics which must always be called a certain number of times per second and must complete fully and quickly. The frame updates can then be done whenever there is time. By separating the screen updates and the game mechanics, you get better realism, and it's much simpler to make a recording of the gameplay without having to store massive amounts of information - just the user input per game mechanics loop, run length encoded. I'd like to hear what other games developers do - one loop or two?
I was thinking about using Eclipse, but I'm just starting to code with Python and figured I'd start with 3.0, are there compatibility issues with PyDev and Python 3.0?
I second wing, its a very solid app
I completely agree. I like to have a completely serializable game state, for playback and testing reasons. Most of the time, I don't decouple the render and simulation loops, because I assume the render and simulation will run quickly enough to allow a constant framerate. The only decoupling I do is when I want to speed up the simulation by doing 10 or more simulation loops per render. 
this just popped up in /r/programming. it's small and also awesome. http://www.reddit.com/r/programming/comments/7j88r/writing_a_game_in_python_with_pygame_part_i/
Marginally related question: What's the difference between, say, 'cd ../install &amp;&amp; pwd' (obviously with that funky character, not with a single quote) and $(cd ../install &amp;&amp; pwd)?
$() notation is the same as the `` notation. Which means it runs the command inside the notation and allows you to work with the output. For example: echo It is currently: $(date) Output: It is currently: Sat Dec 13 23:45:10 EST 2008 
OK, so there's no particular case in which I would use one over the other?
Not that I can think of. The thing is $() is only supported in bash.
$() can be nested, `` can't. `` is in every (Bourne-like) shell, $() is in most modern shells but can't be relied on for embedded or other odd Unixes. That's pretty much it.
If I ever need to make scientific-grade astronomical computations, I'll be sure to use this. Thanks, gst!
This is an interesting approach. Can you point to any "official" information (tutorials, articles) explaining it ? Also, does the "game mechanics" update assume it's called each N milliseconds and depend on that number ?
This [article](http://dewitters.koonsolo.com/gameloop.html) explains several different approaches quite well. I don't think there is an "official" best way to do things, but I'd love to hear from other game developers what strategy they currently use and what pros/cons it has. &gt; Also, does the "game mechanics" update assume it's called each N milliseconds and depend on that number ? Yes. The game mechanics runs in wall-clock time if it is called M times a second. Each call to update advances the game time 1/M seconds. You can call gameupdate less often or more often if you like but then the game won't run at normal speed. For example, if you call gameupdate 2M times per second, your game will run twice as fast as its supposed to, but all the game physics will be calcualted with the same accuracy. This might be useful in some circumstances, but normally, if you have spare clock cycles you would use them to make more intermediate frames (interpolation) instead.
Thanks for the link. I can see the benefits of this approach... The one-loop code, however, can be converted very easily to two-loop, passing the same time to time_passed. I also wonder what other game programmers think about this. Especially the luminaries (LaMothe, etc.) 
[First result](http://wwwsearch.sourceforge.net/mechanize/) after googling for: python mechanize.
I know what mechanize is; i've utilized somewhat extensively. My question is: Do you mean mechanize is good or bad? And why?
That's a good summary. `pip` will not work at my company. We need multiple versions of many libraries, in order to maintain existing, tested tools. It's not fun, but it's life. One minor thing I wish were different about `pkg_resources` is the fact that it fills `sys.path` with an unlimited number of eggs. It would be easier to understand if `pkg_resources` instead just installed an import hook into `sys.path` (or `sys.meta_path`) so that `sys.path` remains legible. The import hook would choose the right package or egg based on "requirements". The reason why I have not done that myself is that I do not know how to create an "importer" for eggs. Maybe some experts will see this post.
&gt; We need multiple versions of many libraries, in order to maintain existing, tested tools. This is what I use `virtualenv` to solve; since `virtualenv` gives me a cheap Python environment isolated from other libraries on the system, I can drop whatever I need for one situation into one `virtualenv`, and have it not conflict with anything else.
It's a nice insight, but Simionato has had such decorators available for years. He just put his [decorator module](http://pypi.python.org/pypi/decorator/3.0.0) on pypi.
Oh, right. What I said was actually "Not mentioning Mechanize" eq "FAIL", because IMHO Mechanize is absolutely a must when you're gonna try to build web-scrapper, that does anything more complicated than parsing single remote HTML file (and I've done it the hard way too, so I would know). Saves ton of time and hair pulling. Not mentioning it is a shame, especially since parsing was tackled with high level approach that is BeautifulSoup. (Edit: punctuation.)
Yeah, let's go way out of the way in order to be as far as possible from functional programming, because a functor class is "dude, easy" and the concept of closure is "unreadable, difficult functional programming concept for scientists". Python users, open your eyes. Stop running away from learning something new and stop trying to write Python as if it were some sort of improved Java with funny syntax. 1. Decorators defined as, well, what they are, **higher-order functions**, are shorter and cleaner to read. And they would be even better if Python's thing with lambda/def weren't this retarded. 2. You have to juggle more concepts in mind when you use functors (class, instance, attribute, method, constructor, callable object) than you have when you use closures (uh, well, closure). Please, for the love of all things good, quit the "Pythonic" crap. It's hurting Python like hell, and I feel very sorry for that because I like the language a lot and it's pretty close to what my ideal language would be (just have Sussman retouch it, and you'd get my ideal language).
In some cases I agree that the functional approach yields easier-to-read decorators, including the simple example given by this article. However, I believe that there are cases where a class-based approach makes more sense. Specifically, it makes sense when the decorator class is storing and using some form of mutable state, especially when that state needs to be accessible outside the decorating function. Guido's "Five Minute Multimethods" contains an example of this, where I believe the class-based approach is much more readable: http://www.artima.com/weblogs/viewpost.jsp?thread=101605
Please don't feed the troll.
Yes, if I'm not into snubbing functional programming and don't go out of my way to avoid it, I'm a troll.
I usually don't feed the trolls, but I responded in this case because I felt there was an actual point in what Wiseman1024 was saying, even if it was expressed trollishly. Indeed, when writing a new decorator which takes arguments, I often ponder whether to write it as a class or closure. Part of my wants to just say "There's More Than One Way To Do It", but that's never really been the Pythonic philosophy. My current thinking is what I expressed above; that decorators storing and using mutable state should be classes and others should probably be closures. But I'm kind of on the fence about it, so I figured I'd throw that out there and see if anyone had any constructive responses.
Ahh, the good ol' days.
pip pip boy
Cheerio, old bugger!
`easy_install` never breaks anything as long as you always use the multi-version mode (`-m`). But the author is right: it should check whether dependencies can be found and tested before installing the target.
I've generally found that there's no good hard and fast rule for when to use a closure and when to use a class; it tends to be a case-by-case thing according to what the result needs to be.
http://goonmill.org/hypy/
Father (one of, anyway) of the original Tk GUI that Python has bound as Tkinter.
xapian is worth a look at too.. I've used it before, mostly since it is the only search library with python bindings packaged in debian.. :-)
It's nice, but not nice enough that I would stop using the Regex Coach: http://www.weitz.de/regex-coach/ Mind you, the Regex Coach mostly only works on Windows.
I was using Regex Coach until I found [Kodos](http://kodos.sourceforge.net/) which supports the complete python regex syntax.
I sure would like some certainty on pricing. It is hard to justify building anything significant on App Engine without knowing how much it will cost.
Awesome, I think I'll use this instead of Kodos. Kodos has replace (but the code generation for that is broken) and it shows embedded flags but otherwise I think this is simpler and involves less clicking.
This is why I've decided against developing on AE. I like to know i have control to move something to another server if the shit hits the fan. It's one thing to be locked into a web host, it's quite another to be locked into a platform.
looks like the author of that article didn't do their homework. app engine's pricing was announced in may: http://googleappengine.blogspot.com/2008/05/announcing-open-signups-expected.html
It is amazing how incredibly hard it is to find out what does virtualenvwrapper actually do by following those links. Even http://www.doughellmann.com/projects/virtualenvwrapper/ doesn't have a simple explanation WHAT THE HELL IT IS.
Nice Article
Absolutely Fantastic
run the calculations on MapReduce would be nice
Go for it!
I generally don't like messing with sys.path, feels hackish.. in a bad way. I believe the better solution is to use 'python setup.py develop' to make sure that the "installed" version of your package is just a symlink to the source.. and then you can do absolute imports like "from myproject import mymodule"
Poor SOAP, WSDL and WS-DesignByCommittee support is feature, not a bug.
The problem is you're trying to use SOAP.
...as opposed to? REST? Most enterprise-wide web services still use SOAP and this article addresses a valid use-case that often comes up if one has to use Python.
&gt; windows-based machine Well there's your first big problem. If you choose a platform where it is difficult to do development without expensive tools, then don't be surprised when you have problems without such tools.
Python Dev = Free 
&gt; SOAP-based services This is your only problem. 
Comparing SOAP with REST is like comparing calling conventions with design patterns. Have a look around, most successful webservices APIs use neither. XML-RPC is an easy choice for Python, but simple form-encoded input and JSON or XML output works well enough. - I've used both in an enterprise-wide scenario with excellent results.
Gosh, people are still wrestling with this? * Follow the package-layout guidelines [here](http://jcalderone.livejournal.com/39794.html) * Put your `unittest`-based unit tests in files named like `test_foo.py` in the `test` subdirectory. * Use [nose](http://somethingaboutorange.com/mrl/projects/nose/) or [trial](http://twistedmatrix.com/trac/wiki/TwistedTrial) or your favourite test runner to run all your tests without having to mess around with `sys.path` hackery at all.
Upvoted, although I disagree with using setuptools. IMHO, it's best to stay away from the whole ecosystem. In the past, I've used symlinks and/or the PYTHONPATH variable to avoid setuptools. But now with python 2.6, I just put my stuff in /.local/lib/python2.6/site-packages and it's done. I've written hundreds of thousands of lines of python code. In those various projects, almost every time I've messed with sys.path, I've come to regret it later. 
I'm a fan of [the dpaste API](http://dpaste.com/api/v1/).
Starting to use the blog at my company. Feedback on my technical writing is appreciated.
Quoth your first link: &gt; the single Python source file option above was a trick - you always need at least one other file for your unit tests This is false; a Python source-code file can contain its own documentation and its own unit tests, if and when it makes sense to put them there.
Writing looks pretty good. Strongly recommend - do _not_ use old versions of libraries - very often newer versions have security fixes. Remember - you're working with data assembled/presented by someone else's machine - so you don't want to use a library that may be subject to buffer overrun problems. (For more info Google: "Smashing the Stack for Fun and Profit")
The simpler the better, these guys seem to get that. For a more general purpose API, I think [flickr](http://www.flickr.com/services/api/) have done a decent job.
False statements like these only hurt the open source / free software advocacy.
What's Really New: All the libraries I want to use don't work with it! Yay!
I plan to upgrade, I was installing for use with a client. Had to be done soon. Thank you for your recommendation.
Thus I'm giving myself a chance to hack together a little project in Py3k using only standard libs. Fun so far.
In what way is this better than using an interactive session of Python?
It adds commands (like 'workon') for using virtualenv from Bash and Zsh.
Don't forget to add: def __setattr__(self, k, v): self[k] = v This is also implemented as [web.py](http://webpy.org)'s Storage class. It's really addictive once you get used to it. I take it with me everywhere. (It's a public domain license.) http://github.com/webpy/webpy/tree/master/web/utils.py &lt;&lt; Search for 'class Storage'
Neat.
&gt; Also, that eval("""data structure""") makes me stabby. What the hell? TFA says the author stores config files in Python syntax; presumably the string being `eval`d is normally read from an external file. Still horrible, but less mind-boggling.
A python program with just a windows version, what has the world come to. Die .net, please just die already.
A very nice find. Anyone knows whether alternative PDF readers support image highlighting? 
Because every program is better if it is running in a spreadsheet!
I'm asking because I still feel most comfortable in IDLE while coding Python. I'd love to use Vim but I just can't seem to find a good set of plugins for this task. What I want basically is an editor that is kind of integrated or laid out for Python, yet doesn't have to be an IDE. Actually, I'd prefer if it wasn't an IDE at all. Code completion would be nice, syntax highlighting and auto indent (please no "smart indent") have to be there. Also a small 'project' browser couldn't hurt. But anyhow, I'm very open minded, so keep it coming :)
Excellent initiative. These guys are doing a fantastic job with IronPython.
Primarily my brain and fingers.
Firstly, you say you'd prefer if it wasn't an IDE and then hope for IDE features. In that case, I'd suggest Eclipse with the PyDev plugin. It's a fully featured IDE that find useful for anything larger than one-file projects. Secondly, consider "Programmers Notepad 2" as an alternate editor. It doesn't have all the features you want, but it's quick and easy. Thirdly, if you're on Linux, use Kate. Kate's Sessions gives project-like control and it has most of what you're looking for, except code completion. 
silly tip but it helped me debug a bit of code that was printing some stuff and I wasn't sure which part exactly did it.
Seriously...have we learned nothing from Excel and VB for Apps??? A spreadsheet is a spreadsheet, NOT an OS or some other ungodly construct. Why the fork would you put a webserver in a spreadsheet???????
what has .net to do with this company's choice? oh sure, it exists.
I use VIM with the Taglist, Mini-buffer explorer, and SnippetsEMU plug-ins. I mapped a key to run my code through pyflakes to catch errors. Emacs turns my hands into knots. YMMV Sometimes I use Komodo IDE.($$$) I've started experimenting with Eclipse and Pydev. Many people love WingIDE.($$$), Textmate($$) or E-text Editor($$). 
One spreadsheet to define and generate reports, many browsers to view them...?
It's an ill wind that blows no one good, as they say.
My sentiments exactly. Take a good, naturally cross-platform language. And restrict it to a single OS.
Interesting conversation in the bugs, with benchmarks, and it includes a link to the new IO lib's [place in the Python SVN.](http://svn.python.org/view/sandbox/trunk/io-c/)
David Beazley is the author of [PLY](http://www.dabeaz.com/ply) and [a Python reference book](http://www.amazon.com/Python-Essential-Reference-Developers-Library/dp/0672328623).
It's times like this I really wish the python code thing had a changelog and diff view.
&gt; We can't solve this for 3.0.1, downgrading to critical.
I agree (and that is what I do) but `import` does have limitations. Maybe this guy wants to be able to do something like this: python blah.py --my-config=test/blah.cfg
I thought this was common knowledge? Guess not. Regardless, could be a bit more detailed.
Read the modules in the standard library. This will both teach you how things are done, but also prevent you from reinventing the wheel (python comes with a lot of wheels already). Stuff like SQLAlchemy and Django are great tools, but the source is very complex and is not suitable to learning the ins and out of the language. They both use a lot of bizzare advanced tricks to hide their complexity from the programmer. The standard library modules are much much more straight forward. There is a lot of crappy Python code out there, whether it's people writing Java in Python or just not knowing the common idioms. Other than the Cookie module, the standard library is very idiomatic Python.
via http://powersoffour.org/blog/?p=763
Anybody here actually use, or know somebody who has used [Nvidia's Tesla Platform](http://www.nvidia.com/object/tesla_computing_solutions.html) ?
It's the thing to do: http://www.bitbucket.org/DeadWisdom/migratory/wiki/Home
Oh, excellent. I've been dragging my feet on playing around with CUDA; combining it with python should make experimentation a bit more fun, and at first glance this looks like a good wrapper for it.
The easy part is missing.
off the top of my head: - a periodic table of operators :) - language level support for grammars - multi-line anonymous functions (nothing new there) - a register based virtual machine with continuations - an implemenation in haskell Of course, python has things like list comprehensions, decorators, metaclasses, the new annotation syntax, and little things like a working, complete download. :)
For some apps, I use a library called [strongbox](https://secure.sabren.com/trac/workshop/), which lets you declare public and private slots on a class. You can still edit the private members, but they go inside a special member called .private. (It also does runtime type checking and coercion on the public slots)
Oh, I so badly want one of those. I suggested that we buy some at work, but our pet mathematician announced that the problem we solve is "not parallelisable". Neatly missing out the fact that two or more problems at the same time *are* parellelisable...but I've decided to let them figure that out for themselves when we go live. 
I was searching for this just yesterday and I stumbled upon [PyStream](http://code.google.com/p/pystream/). I wonder which one is better?
Another use - reversing lists: &gt;&gt;&gt; a = [1,2,3,4,5] &gt;&gt;&gt; a[::-1] [5, 4, 3, 2, 1]
I like the project's focus for security. I think I'll give it a whirl once it matured a bit.
Does it make my web server do its best Thai hooker impersonation like Wordpress does? If not, it'd be worth inspecting.
Wordpress focuses on security, too. :-) 
&gt;Unfortunately many cheap hosters do not provide Python hosting so it is currently a little bit tricky to get Zine running on cheap webhosts. Hmm.
Thanks! I'll check it out...
gaybar!?
I think that's the joke the author is after. INT TRENDY CAFE PERSON 1: Hey, PERSON 2, I just found the best backup app ever! It's called GAEBAR! PERSON 2: You *backup* by going to a gay bar? PERSON 1: No, it's called G A E B A R. PERSON 2: It's okay to come out. I've always known. PERSON 1: ...
Even the not so cheap ones would have difficulties spreading a dozen libraries over the harddisk. EDIT: **YOU** made an installation documentation that spreads libraries over your harddisk and installs the 0.1 blogging software in /usr/lib and /usr/share. And **I** get downvoted?
You! I wanna take you to a gaebar, I wanna take you to a gaebar, I wanna take you to a gaebar, gaebar, gaebar. Let's start a war, start a nuclear war, At the gaebar, gaebar, gaebar. Wow! At the gaebar. Now Tell me do ya?, but do ya have any money? I wanna spend all your money, at the gaebar, gaebar, gaebar. (Pause) I've got something to put in you, I've got something to put in you, I've got something to put in you, At the gaebar, gaebar, gaebar. Wow! 
The sort of parallelism you get from serving multiple requests simultaneously isn't really well suited to GPGPU. GPGPU really only works when you've got the same algorithm executing in lots of threads all in lock-step. Example: a large search, where you've got to compare one vector against many others. Each thread is running the exact same instructions at the same time, just for different data. Suits the GPU architecture perfectly, massive speedup. But if you're just trying to do lots of different things at once (e.g. serving a whole bunch of requests, which of course didn't all come in at exactly the same time) then GPGPU doesn't really help.
How so? Why "spread it over the harddisk"? You only have to dump them into a folder that is on the search path.
http://dev.pocoo.org/projects/zine/browser/INSTALL
And how is it a problem to install these libraries into a regular folder and just upload them? Granted, lxml is a bit tricky, but you still don't have to spread them all over your harddrive. I have installed all libraries into a local folder for developing, there is even a script in the scripts folder that creates a local development environment.
Before I get excited, how much of what's in the installation instructions is actually *required*? I ask because I want to a) install it not in `/usr/lib/zine` and `/usr/share/zine` and b) run it not using `mod_wsgi`. Nothing in `_install_posix.py` looks problematic (ZINE_LIB etc.) or difficult to do manually if necessary, and any WSGI server should be like any other. But is there anything buried in the code that will cause problems?
Not at all. We recommend actually setting up a virtual environment and `./configure --prefix=that_folder` and install it there. Zine is pretty flexible in terms of deployment. If we can't deliver what you want, please outline your deployment plan somewhere and we'll try to extend Zine appropriately. More information about deployment over here: http://dev.pocoo.org/projects/zine/wiki/DeploymentPlans
I'm terribly sorry if there are any errors in this document. * It's 5:16 AM and I haven't gotten to bed yet * I'm new to WSGI
Go to bed, you fool! I enjoyed this.
Now if only i can wgsi to work with apache..
cherryPy will run WSGI via fastCGI on apache.
^ lol'd
http://www.youtube.com/watch?v=HTN6Du3MCgI I can't explain why they censor the lyrics "start a war."
Look into [mod_wsgi](http://code.google.com/p/modwsgi/). It's been working very reliably for me.
Actually, your example is full of wrongness. 'this is a string'.encode('zlib') The above does not work properly for gzipping. I just tried it and got an encoding error in my browser. The function I created doesn't create an encoding error. I had originally tried using the zlib module like you mentioned, but it never worked out. After a while, I scanned the Python mailing list and found a mention of using StringIO with GzipFile. Testing it out, it worked fine.
You could also flup or even through regular CGI using: from wsgiref.handlers import CGIHandler CGIHandler().run(my_app) Of course, this is discouraged as it defeats the purpose of WSGI. 
I'm not a linux person, and the windows compiles of mod_wsgi don't have much documentation.. :(
It's covered in the Django documentation, with full details on how it works. But nobody ever bothers to read the documentation; I'm actually considering writing a CAPTCHA based on it, since anything which shows familiarity with docs must be a bot.
Keep in mind that the WSGI spec is ambiguous and arguably self-contradictory on the matter of whether anything other than the server is allowed to do this.
This is why we need to never allow hackers to name their own apps.
I think I love you a little bit.
Finally! I've been waiting for Pydev to support 2.6 and 3.0 since it was released. Good work, Fabio.
Google is [pro-gay](http://news.cnet.com/8301-1023_3-10052913-93.html). Now that you know, christians and muslims should avoid Google at all cost. Else you roast in hell. :0
 &gt; I'm not a linux person No time to learn like the present. ;)
I already know how to use linux, I just don't particularly like it. Having to play around with a conf file for *everything* is a pain in the ass.
Well, .NET was chosen as the development platform before Python was chosen as the language. .NET is ubiquitous (so unlikely to die) in the target market for this application - at least IronPython means .NET apps can be coded in Python.
The whole point of Resolver One is to learn from VBA horror. Spreadsheets are so *phenomenally* successful because the UI and formulae in cell model is so effective. Unfortunately in traditional spreadsheets like Excel the programming model is bolted on to the side. In Resolver One you can use standard programming best practises with full access to the spreadsheet model. Putting a web server in a spreadsheet is still pretty kooky though...
Ahh, you are correct, my apologies. Here is another example. http://svn.pythonpaste.org/Paste/trunk/paste/gzipper.py the zlib encoding does not write the gzip file header.
That's awesome! Thanks for the link! :)
If only as a means of making my voice heard, I am intentionally avoiding these kind of apps. For several reasons, the fact that this is barked primarily by Microsoft is a large part, but not all of it.
I was just checking this out last night. Prolog is pretty mind-bending.
Yeah, there are clear benefits to being able to programmatically interface with spreadsheets. It just makes me wary when people start building entire applications within the spreadsheet.
Well, apart from the fact that I agree with you... most spreadsheet use in businesses *is* to create what are effectively business applications. The problem is that to create a basic working model in a spreadsheet can take as little as a few days. If you then hand this model to the IT department for them to create a 'real' application out of, it will take six months or longer... The goal of Resolver One is to sit in the middle - where a standard spreadsheet like Excel or OpenOffice is not enough (or needlessly painful) and starting an application from scratch is too much.
Yep, Microsoft barking is fairly ominous.
Installing Zine on a webfaction hosting account: http://forum.webfaction.com/viewtopic.php?pid=8193
Thai hooker impression? (You mean it sucks whilst it blows?)
It goes down frequently.
Oh. :-)
It's multiple requests all to perform the same task on different sets of inputs (non-linear constraints optimisation), so I *think* that a Tesla would help a lot. But I may be wrong, hence why I've kept my mouth shut so far :-)
http://code.reddit.com/browser/r2/r2/lib/lock.py
I didn't dive into this very much but it looks like the same thing beautifulsoup has been doing, but with async networking (via twisted) right? Are there any distinct advantages using scrapy vs beautifulsoup? (apart from the network layer)
Scrapy is basically an application framework, while beautifulsoup is a parser. Seems you can get going with scrapy pretty fast.
I love it when I start a project, then immediately discover that someone else already wrote it. Just last week I started coding an asynchronous web crawler in Python.
Well, you always have the chance to write it better!
The in lock-step bit is important. IIRC execution units on CUDA GPUs are in groups of 32, so if you don't have at least 32 threads executing exactly the same instructions all together you miss out on most of the benefits of the architecture. The only way to get that working on a request-serving sort of workload is to batch requests together - and will you really be serving thousands of requests at once (the sort of thread count that you need get good utilisation on a single GPU, let alone a Tesla box). Also - I don't know what optimisation algorithm(s) you're using, but if it has frequent, unpredictable branches then that also rules out GPGPU because every time you branch and all 32 threads in your group don't take the same branch then you halve your utilisation. Oh yeah, and is a GPU fast enough to give you the turn-around times you want? GPGPU performance comes from being able to run hundreds or thousands of threads at once, per-thread performance is very weak compared to a modern CPU. GPGPU is great for some things, but it's not a silver bullet.
Thanks for the helpful replies. It seems to me that some good, old-fashioned benchmarking would be the way to check whether it will work for us. Our pet mathematician's pronouncement that it definitely wouldn't work irritated me not because it was right or wrong, but because it was made without any actual evidence to back it up :-( I don't know enough about the implementation of the solver they're currently using (I think it's quadprog within Matlab) to say whether it would/would not benefit from being GPU'd. 
Has anyone tried this? Looks like you need a pretty big scraping project to justify a framework. Certainly not for one-off scripts..
I tried it. It kinda works. I was on page 2 of the Tutorial when I started getting this: 2008/12/29 01:07 -0700 [scrapybot/bloomberg.com] ERROR: FRAMEWORK BUG processing &lt;http://www.bloomberg.com/markets/stocks/movers_index_spx.html&gt;: [Failure instance: Traceback: &lt;type 'exceptions.TypeError'&gt;: 'NoneType' object is not iterable Not really ready for prime-time. Also, badly needs a proper tutorial that demonstrates all the features. 
Same for me. The callbacks seem an interesting method to minimize memory. However, BeautifulSoup, the library used to parse html, builds the Soup (a DOM like structure). Is there something like BeautifulSoup but with a kind of SAX parser?
Give [lxml](http://codespeak.net/lxml/) a shot. It handles invalid markup about as well as BeautifulSoup (with the notable exception of encoding-guessing) and has a [SAX API](http://codespeak.net/lxml/sax.html).
I like `num_terminal_columns()` and its use. I guess it is only for posix systems though, right?
i, m, s, u, v, x, y, z - WTF ? Maybe if you just used decent variable names you wouldn't need to go to all that trouble on a variable lister ?
Is there a practical reason for this? import numpy import numpy as np 
JumpWorked? I thought using success exceptions would cause the world to implode. (Actually, after reading deeper, it seems this was for Python 1.5. Is this old, or did the developer just feel like being nostalgic?)
I'd personally like a Python IDE that colored the variables/objects in a different color, FWIW.
When using an interactive prompt, using short variable names is "ok". You usually do whatever gets the job done, with the least number of keystrokes.
i think so. and i think the stty call has to be changed for linux.
Not really, I was just throwing the code together from different sources. There's a somewhat prevalent convention in several libraries to have "np" be the numpy module. "from pylab import *" does this. The textual representation of types in the lsv() output follows that convention too.
Indeed. As long as you can remember 5 or so of the last ones you were using, that's enough to reach out far enough to figure out how to implement and evaluate certain algorithms, then you can rewrite them as a function in a file with more reasonable variable names. This lister just makes it easier to remember what the variable you were using 30 minutes ago were. But I think numeric programming will always have very short variable names. Descriptiveness is just only moderately helpful in this domain.
Don't stop with your project, it sounds interesting. I find scrapy to be too complex and I don't like the design.
I am relatively python newbie, I am looking into some of the python libraries. And they seem to do imports inside functions rather than doing global imports at once. is there any advantage of doing imports inside block scopes ?
If the function never gets called then you don't need to make the import. This saves memory, and if the required module happens to be missing, your program won't have any problems until that line is called, so other functions will still work. The disadvantages are: * Python has to check to see if the module has been imported already every time the function is called. This might become a performance bottleneck. It's probably not a good idea to import a module inside a loop. * If you need to use a module in many places, you will need to add imports to many different functions. It makes more sense just to make one global import in this case. * Sometimes it is better to crash early rather than crash late. It's annoying to get half-way through an operation only to have it crash at the end because a necessary module was missing. If you know you'll need it later, you can warn the user before they do a ton of work that will go to waste.
They probably only get imported if the function is called. Which makes a difference :)
&gt; Python has to check to see if the module has been imported already every time the function is called. This might become a performance bottleneck. That's odd: you're right that it doesn't re-do the import (just tested on Python 2.6), but it's not what I would expect, which is that "import foo" will always run all of the module-scope code in foo.py. 
And they get imported *when* the function is called the first time, which will effect how long the call takes. 
You can also use an equivalent of C++'s function-level "using namespace"; i.e. import foo # foo module is loaded print foo.x # here x it must be qualified def f(): from foo import x # within this function x does not have to be qualified print x Oddly, using "from foo import *" instead gives a SyntaxWarning but still seems to work.
If you want that behaviour, consider using reload.
I've had to do this before to resolve circular dependencies. The import is done when the function is invoked so you can defer the import until the method that requires the module's functionality is actually called.
MarkByers speaks the truth. Importing in the function is a bottleneck (as it does add a few opcodes to the function) and will result in some unhappy side effects of functions which can raise ImportErrors that won't be caught without good code coverage. That said, there is one singular good reason that has occurred with me enough times that I must state it here: module interdepdendency. I often have mixins in some module in package A called A.mixins and my classes in A.classes, and if some method in a mixin returns an instance of something from from A.classes, you cannot put &gt; from A.classes import SomeClass in the top of the mixins module if you put &gt; from A.mixins import SomeMixin in the classes module, as at import time one will try to import the other which will try to import the other and trip up an ImportError. If you have two tightly coupled modules you're going to have to import elements from one a-la-carte at the latest possible second. A purist will say that a package should not be designed/organized this way, and if I were not the person writing this post I would be the one responding that a package designed this way is Bad and Wrong, but these things happen.
Solutions to each of these points can be had by using zope.deferredimport (find it on PyPI... Zope rules!). If Zope3's not for you, bazaar's library bzrlib in the source tree has a module called lazy_import.py which seems to accomplish the same thing. 
Mercurial has also demandimport. When using bzrlib and Mercurial at the same time, I have to blacklist some modules from bzrlib probably because they are using lazy import.
Yep, that's the only case I've had for it. Circular dependencies can eat the brain until you realize you can just import from a function.
There is one case I use this somewhat, that is when modules contain a `__main__` section and the module is also used for importing (not just running it). Then it is handy to import stuff like `sys` only when you need it: # This is my module def some_utility_function(bla): return bla def _main(argument1, argument2, optional_argument=None): do_the_stuff() return 0 if __name__ == '__main__': import sys sys.exit(_main(*sys.argv)) Technincally I'm not importing inside a function, but I'm importing conditionally only when it is needed. 
Actually, I eventually came to the same conclusion and decided to continue on my own. Scrapy seems to have borrowed Django's design and applied it to web crawling, which seems like a fundamental mismatch. My design was a library (as opposed to Scrapy/Django's framework design) with some cues taken from optparse: create a crawler object, feed it with settings, initial URLs and callbacks, and press go. Tell you what. If it ever gets to a releasable state, I'll announce it here on /r/python.
Also beware of the 'import lock' which is obtained even if the module has already been imported. In certain glibc implementations this results in a FUTEX_WAIT syscall even if no lock contention exists. See https://bugs.launchpad.net/bzr/+bug/140834 for more info
&gt; Oddly, using "from foo import *" instead gives a SyntaxWarning but still seems to work. As of Python 3 an `import *` statement inside a function body is now an error, and will simply raise an exception.
Yeah, breaking dependency cycles is the only time I use local imports.
A module is a singleton, only one copy per process. Actually, I tend to use modules rather than objects as singletons in my code.
Why shouldn't it work, though?
The Python docs describe it like so (and give a clue into why it's this way): &gt; If the wild card form of `import` — `import *` — is used in a function and the function contains or is a nested block with free variables, the compiler will raise a `SyntaxError`.
Agreed. Local imports should only be used to break circular imports, imo.
For expensive imports that are not always needed it can be useful to delay the import until you really need it. After it has been imported the first time subsequent imports (calls to the same function) are effectively no-ops.
If that were the case, `import sys` and `import os` would end up being redone a bunch by each sub-module that imports them. Instead, they're effectively free. 
&gt; Python has to check to see if the module has been imported already every time the function is called. Performance-wise I'm not sure this is an issue; it's just a check for a key (the module path) in `sys.modules`. If you have a function which does an import, and that function gets called ten thousand times in a loop somewhere, I could see it being an issue, but for general purposes it's just not even going to be on the radar if you start profiling.
Yes, I concur. I think circular import breaking is the only reason I would use local imports.
import combo_breaker cb = combo_breaker.combo_breaker() cb.break_combo()
Do you know what versions of glibc are affected? My understanding was that uncontended locks involved no kernel space, just atomic ops. We actually *don't* use locks in the network data path code I work with for latency reasons; even the possibility of contention is too much to bear :) But that is C, not python.
 Traceback (most recent call last): File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt; cb.break_combo() AttributeError: 'function' object has no attribute 'break_combo()'
I have a lot of discrepancies with scrapy's design, one is the one you mentioned, it just doesn't make sense to me, other things I would do differently are: * Use lxml, scrapy duplicates some of the functionality, and doesn't do it as good as lxml. And it misses a lot of cool things from lxml. * Use something like cogen instead of twisted (and make it really async, also check the scrapy engine internals, it is really messy) * Python has coroutines and generators, use them more in the control flow of the engine, they are really useful here. * I don't like that responses contain the full body of the page, to me an input stream would be a lot better, sometimes you need to process a really big page (an 80+ mb xml for example), and having to load it all in memory before being able to process it is bad, I parse it with a SAX parser as I download it instead of having to build an even bigger DOM out of it. * etc etc etc, lots of other things :)
print "c-"*4 + "combo breaker!"
Thanks for the suggestions, I've copied them to my project notes file. Especially the reference to cogen; I hadn't seen that project before.
one case where I found it useful was for platform specific code that involved platform specific modules. In one of my files, [term.py](http://terminate.svn.sourceforge.net/viewvc/terminate/trunk/python/terminate/term.py?revision=194&amp;view=markup), I put import statements in the class' `__init__` methods. I did it this way because these particular modules were specific to the individual classes (I didn't want `UnixTerm` to bother about the `msvcrt` module).
&gt;When using bzrlib and Mercurial at the same time, [...] You.. You know what you're doing‽
Yeah, writing converters from the one to the other. That's easier than to import the one library and reverse-engineer the format of the other.
That's really quite depressing; I've previously found Python to be quite skilled at "making things as simple as possible but no simpler", but it sounds like the Great Push for Unicode in Python 3 has caused unfortunate over-simplification. That said, I'm not sure what they could have done differently - having all file-related APIs return `bytes` objects on Unix but `str` objects on other platforms seems a recipe for a different kind of horror.
print("c-"*4 + "combo breaker!")
From the [page](http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit) linked by the article: &gt; As a work-around, most APIs (e.g. open() and many functions in the os module) that take filenames accept bytes objects as well as strings, and a few APIs have a way to ask for a bytes return value.
Making all strings unicode sounds to me like the correct thing to do. How does Mono handle this problem on Unix? All C# strings are also unicode. Perhaps there's a solution there.
Oh, and I forgot about [mechanize](http://wwwsearch.sourceforge.net/mechanize/), should be useful to handle more complex crawling logics (not just following links that match some pattern) :)
&gt; Scrapy seems to have borrowed Django's design and applied it to web crawling, which seems like a fundamental mismatch. I had to admit this is my biggest discrepancy with the project, it is being modeled in the shadow of django and sometimes even twisted but that does not apply at all here, those are different projects with different functionalities and different goals and to replicate its way of doing things "just for the sake of it" is utterly nonsense. disclaimer: I'm a former employee of the company developing this software and I do work with it however this comment only reflects my personal opinion on the matter.
btw, there's #scrapy at freenode if anyone wants to chat.
all strings in Java are unicode, and java.io.File.list() returns an array of unicode strings representing a directory listing. There's nothing explicit about encoding at that level. So maybe there's something to be learned there (maybe not). But I agree with the link to the listdir() issue that simply omitting filenames that can't be decoded is madness. 
Well thought out, explained simply. Makes me want to take Jinja seriously, as opposed to the idea I get when I go to the Jinja website... Er, needs proofreading though.
A fundamental problem for Unix--a godsend solution for Windows. I can't even begin to remember all the times I had to fight APIs that refused or forgot to provide wide char support (including the C++ STL).
The problem is that pathnames aren't really strings, but are composed lists of other (relative) pathnames. Pretending they are strings is what gets you in this trouble. Worse: Even though you have no way of knowing what encoding they're in, most of the time it isn't necessary: You either want the parent directory, some child, or to compare two pathnames. If you actually want to *display* a path name, then fail or garble or whatever if that coding doesn't match up. Of course, this requires syntax (and `__repr__`) to do right, and it requires a culture that distinguishes between printing stuff for people, and printing data readibly. By the way, Mono is [just as stupid as Python](http://www.go-mono.com/docs/index.aspx?link=T%3AMono.Unix.UnixEncoding) and similarly *hides file names* when using `System.IO.Directory.GetFiles`. Java, Haskell, and Perl keeps the files in the list, but converts the "invalid" characters to gibberish, which makes saving file names and reading them back impossible. The only language I'm aware of that does this (conceivably) right is CL, and several implementations still get it wrong.
Java (and Perl and Haskell) converts filenames that cannot be expressed as Java-modified-unicode into gibberish, rendering them impossible to open, rename, delete, or otherwise manipulate.
I disagree. Users will still have to explicitly use bytestrings when dealing with filenames, and to independently make the decision what to do with encoding errors on an application-by-application basis.
That's a little bit of a problem....
Why use bytestrings for filenames? In NT-based Windows everything is UTF-16; codepages are used only for compatibility with Win9x-type programs.
I actually deal with mismatched filename encodings on a unix system (Debian GNU/Linux) fairly often. They are not safe for use even with the regular unix tools. I've had my terminal hosed by the output of `ls`, broken scripts, files with names I can't type or glob (easily), and I've even had a problem almost like the one with `os.listdir` only worse: `ls` output containing some kind of control code to go back and erase several previous lines. I haven't used Python 3, but from what I've heard they've handled encoding about as well as they could. Encoding is a pain, period. The "great push for Unicode" is to push the pain out to the edges of your program instead of letting it marble throughout as tends to happen in Python 2.x. You can (I'm told) ask for the result in bytes, so the information isn't inaccessible. The question is what to do when someone asks for Unicode results and some of the filenames won't convert. On the one hand, it's usually better to fail loudly than silently omit data. On the other hand, almost every time it comes up it will be someone looking for specific files with ASCII-compatible names and not even considering the possibility of differently encoded files they don't care about in the same directory. EDIT: punctuation
I'm wondering how they get around function overhead....
I disagree with you on pathnames. They're supposed to be strings because their purpose is to give each file a human-readable and -writable name. In my experience, most of the the time you are using a known name to find a specific file. The known name will usually be specified by a person (in a config file, through the interface, etc.) If you have a mis-encoded file in that situation, the problem is that you can't match the name without knowledge of the encoding.
Read the Python mailing list. This is a tough issue, but the long and short of it is "put bytes in and you'll get bytes back and the problem goes away. For everyone else, this won't be an issue unless your system has two different file system encodings on it… In which case you're pretty much screwed anyway."
hm. On further consideration, I'm actually having a hard time caring about this particular edge case. If you've got file names with weird bytes in them, then you're apparently in a world of hurt anyway (many unix tools can't even handle spaces in filenames properly). Provide a separate `posix` module to operate on file names as byte streams. I'd much rather solve the more common problem ('Unicode is painful to deal with explicitly') than the edge case. BTW, thanks for that link. *Edit*: Sorry, my statement about not handling spaces is wrong. I was thinking specifically of xargs and even that has a flag.
Of course, programs written in Python that are designed to run on Windows only can do exactly as you suggest, because Windows won't be able to access any non-unicode filename that any network-filesystem adapter presents to the OS. I'm not sure this is the common case though; most Python applications that run on Windows aren't *designed* for Windows, do they?
&gt; They're supposed to be strings because their purpose is to give each file a human-readable and -writable name. That's rubbish, of course. If they were supposed to be strings, then they would be strings. The fact is, the operating system treats them as path-delimiter-separated byte-arrays because that's what they are. Consider the following: a-bat/man.txt a/banana.txt apple/cookie.txt They're sorted lexicographically right now, but programs that people use (and thus, people's expectations) don't sort them this way. Instead they use: a/banana.txt a-bat/man.txt apple/cookie.txt because the "/" in the first "a/banana.txt" marks the end of the "a" directory. Consider also this example: CAT.TXT CAT!.TXT What order should *they* be in? Well, under MS-DOS, "CAT" comes before "CAT!" but under UNIX the reverse is true. Of course, nobody thinks pathnames are strings except programmers, and the only reason they are strings is to reuse a data-structure. Programmers like reuse, and so they often do it, *even when it flies in the face of reason and rationality*. &gt; In my experience, most of the the time you are using a known name to find a specific file. You're wrong though. Run `strace -ff your_favorite_program` (or truss or whatever the local equivalent is) any time you like to see just how many uses of pathnames there are that *have nothing to do with the specifications made by a person, configuration file, interface, etc*. File names are simply used by programs *far more often* than they are used by people, and so it makes sense to me to optimize for that case. Of course, if you have a *syntax* for entering pathnames, you'll see that this problem goes away. Consider something like this: fh = file(p'/tmp/x.txt'); This could let the parser/lexer know that the things between the `'` characters are the bytes (like `b''` is in py3k) that form a pathname. Then having `repr()` use this syntax as well would let programs interchange pathnames in a way that is *independant* of programs having to communicate those pathnames to a user- as they invariably eventually have to do. Of course, those pathnames aren't *usually* communicated to a user. That's a corner case that some programs do. Most just use the pathname, or perform a number of trivial operations on it (slash-splitting, extension-grabbing, etc).
&gt; many unix tools can't even handle spaces in filenames properly I'm not aware of any unix tools that cannot handle spaces in filenames properly. The shell may make entering strange characters more difficult than other characters, but this is to be expected in terms of overall usability. Care to elaborate on that? &gt; Provide a separate posix module to operate on file names as byte streams. This optimizes for an uncommon case (printing file names, and reading filenames in an unusual coding) instead of for the common case: Program wants to perform some operation on a bunch of files in a directory. I'd think Windows programmers would be wary of such garbage; There are a number of files and directories that can be created that both Explorer and cmd.exe make impossible to delete (or move or otherwise manipulate), and treating filenames as "strings" only reinforces the problem by forcing each programmer to continue to deal with it separately. Of course, making the problem *more* visible makes more people aware of it, and thusly, helps more people avoid it.
Even though its not guaranteed, you can relatively safely conclude that every string on a UNIX filesystem which is halfway modern is UTF-8. UTF-16 is in no way cleaner - your string routines still need to be aware when you end up with double-16bit unicode characters. 
It's useful to read the reply from Malcolm (Django developer) linked down in the comments.
You're right. However, the problem with Windows is that we cannot select UTF-8 (or any other Unicode encoding) as the *system codepage*. Therefore we cannot rely on a char\* interface to use Unicode; we also need a wchar_t\* one. Having **unicode** as the default string type in Python makes Windows programming more natural.
*I'm not aware of any unix tools that cannot handle spaces in filenames properly.* Kernel cannot handle #! line if there is a space in the program name. Some tools provide -0 option to end file name with zero byte to workaround space-in-file-name issue.
&gt; most Python applications that run on Windows aren't designed for Windows, do they? Exactly. That's why they forget that Windows cannot squeeze Unicode to a narrow char string in system calls.
&gt;That's rubbish, of course. &gt; &gt;If they were supposed to be strings, then they would be strings. The &gt;fact is, the operating system treats them as path-delimiter-separated &gt;byte-arrays because that's what they are. The ability to use arbitrary byte arrays as filenames is the file system's way of punting on encoding and language issues. You're still supposed to use names that are strings in some encoding. I tried `strace -ff` on my text editor. Almost all the files were dynamically linked libraries. That means the path comes from a config file saying where my libraries are (a directory named `lib`) and a name chosen by the library authors. I don't see what you're trying to prove with your discussion of sort order and syntax. 
&gt; You're still supposed to use names that are strings in some encoding. Says you. Care to back that up? &gt; I tried strace -ff on my text editor. Almost all the files were dynamically linked libraries. That means the path comes from a config file saying where my libraries are (a directory named lib) and a name chosen by the library authors. That's not exactly what's happening. The dynamic linker is *searching* for libraries where it takes path-stems and attaches some other path-stem. This is a purely binary operation- the system does not decode the characters used in the "configuration file" according to any locale or character-set; it doesn't care at all if the paths are even valid for the filesystem they're being used on. The operating system (well, dynamic loader in this case) simply treats them as byte-arrays because *there is no benefit whatsoever in treating them as strings*, and there's a significant cost: Transcoding all of those strings back and forth for no reason at all. That's exactly what Mono and Python and Java and Perl and Haskell are doing, of course: They're transcoding something that makes no sense to transcode, and when they have a coding error, they waste time, and lose data. For what? Why exactly is this valuable? All so that the error can be detected in `os.readdir()` instead of `print()`? A "pathname" data type which transcodes *when the decoded result is needed* makes far more sense to me. &gt; I don't see what you're trying to prove with your discussion of sort order and syntax. That files are a special case, and not mere "strings", nor some special kind of "string" (which I'm using interchangeably with "character-array"). Treating them as strings is what causes the problem, and there's no clear gain. There is however, a very big cost: anywhere from data corruption or data loss at worst, to unexpected (or unhandled) exceptional cases.
Do python windows programmers often make windows system calls?
&gt; Some tools provide -0 option to end file name with zero byte to workaround space-in-file-name issue. find . -type f -name '*.txt' -print0 | xargs -0 -i mv {} ~/Documents/. is the pedagogical example, of what you're talking about. It works this way because xargs splits on whitespace by default. However, xargs most certainly supports names with spaces - you can use `-d` to specify any delimiter you like, it's only that using spaces by default is convenient. See, most unix tools don't parse their arguments, but rely on the shell to do it for them. xargs is a rare exception, but it still supports filenames with spaces. So no, I expressly reject this as evidence that "many unix tools can't even handle spaces in filenames properly" as it's clear xargs *can* handle spaces, but by default, for conveniences' sake, it does not. An example of a unix tool that could not handle spaces in filenames would be something that parses its argument directly, or that reads the files its interested in from a configuration file- and most unix tools have terse inputs, and no configuration files, so I think I'm safe in expecting a tool to be rare. By the way, most of these cases are usually unnecessary: find . -type f -name '*.txt' -exec mv {} ~/Documents/. \; &gt; Kernel cannot handle #! line if there is a space in the program name. That's a strange corner case, but I'll accept it. Are you proposing optimizing for this case? Do you think it satisfies statictype's statement of "many unix tools"?
We have to. For example, printing true Unicode to the console requires a system call (WriteConsoleW). That's because the print statement uses byte-oriented stream IO and that, in turn, depends on the system codepage (which cannot be a Unicode variant). This means that something as simple as printing the result of os.listdir(u'.') will occasionally fail.
That's terrible. Does this mean that `os.listdir(b'.')` can fail on Windows?
Yes, in the sense that it will return invalid characters. It's the same deal as os.listdir('.') on Python 2.x: it just converts to the system codepage resulting in a bunch of '?' chars. It also uses best-fit chars when possible (e.g. 'ç∞' becomes 'c8'), which is a no-no when dealing with filenames.
Yuk. That's basically what Java, Perl and Haskell do. This means that `os.listdir(u'.')` can lose data on UNIX but preserves information on Windows, and `os.listdir(b'.')` can lose data on Windows, but is required on UNIX. I give up. Python's fucked.
http://wiki.python.org/moin/Audio/ JACK is the ProAudio system for Linux... http://sourceforge.net/projects/py-jack/
The OSS specific stuff... http://docs.python.org/library/ossaudiodev.html 
btw, there's this great website you should check out that let's you ask things and get answers. Goo something or other
&gt; we cannot select UTF-8 (or any other Unicode encoding) as the *system codepage*. Which was decided purposefully to fuck everybody's ass.
&gt;I'm not aware of any unix tools that cannot handle spaces in filenames properly Yeah, actually, I'm wrong on that one. The shell is where the problem is and even that is not a big problem anymore. &gt;I'd think Windows programmers would be wary of such garbage; There are a number of files and directories that can be created that both Explorer and cmd.exe make impossible to delete Well yes, there are all sorts of OS-specific rules there. You can't have a colon in file names, you can't name your file COM1 or whatever. But most of the time, you don't really have to deal these distictions. &gt;This optimizes for an uncommon case (printing file names, and reading filenames in an unusual coding) instead of for the common case: Program wants to perform some operation on a bunch of files in a directory. Well, I'm referring to a special-case library here to handle unix filesystems as bytes. So by definition, its optimized for the uncommon case. &gt;Of course, making the problem more visible makes more people aware of it, and thusly, helps more people avoid it. There's certainly some merit in that argument. By extension, the correct thing to do is keep unicode handling the way it works in Python 2.x, ie, let the programmer explicitly deal with it. Personally, in this case of character encodings, I prefer a leaky abstraction to no abstraction. 
I googled it already and found crap.
I think it was stackoverflow.co-something or other. Seriously, one has a much greater chance of getting his answer there than on Reddit.
&gt;The operating system (well, dynamic loader in this case) simply treats them as byte-arrays because there is no benefit whatsoever in treating them as strings, Since these byte-arrays are shown to the user and are, in fact, the *only* way a user has for identifying a given file, then there is most certainly a huge benefit in treating them as user-readable strings. If you want to argue that its ok for file names and paths to be some opaque data type (that are just historically treated as strings for convenience), then there also has to be some 'friendly' way for users to identify these files that doesn't involve recognizing arbitrary bytes. Currently, the internal representation and the representation exposed to the user are the same. That's how its been in (almost?) every major desktop OS. Claiming that this is the wrong way to handle paths is to basically ignore the reality of how people use file systems. 
I'm by no means an audio expert, but would SDL do it? I've just been using a cheap ctypes wrapper for the C SDL library. It's not very Pythonic, but it works well.
&gt;&gt;You're still supposed to use names that are strings in some encoding. &gt; &gt;Says you. &gt; &gt;Care to back that up? Wait a minute. Are you saying you see no problem with grabbing six bytes from `/dev/random` and using them as the name of a new file? I'm not talking about whether your language transcodes them or not. I'm not talking about whether your program needs to parse them or not. I'm talking about the names of your files. They're supposed to be strings. They're supposed to be human-readable and -writable. Which of your file names are not?
&gt; Well yes, there are all sorts of OS-specific rules there. You can't have a colon in file names, you can't name your file COM1 or whatever. But most of the time, you don't really have to deal these distictions. I wasn't talking about this. The filesystem calls like `CreateFile` have fewer restrictions than programs like Explorer and cmd.exe do. Because every program parses filenames themselves, *and because the rules for parsing filesystems are so complicated*, programmers often get them wrong. This of course, breeds problems. &gt; Personally, in this case of character encodings, I prefer a leaky abstraction to no abstraction. The only reason I could imagine people would prefer strings to a path-name object (that perhaps implements the string interfaces) is that they don't understand the cost of doing so, or underestimate the cost of path-name objects. I'm a big proponent of robust programming, and so I like libraries and languages that encourage it. [As I discovered elsewhere](http://www.reddit.com/r/Python/comments/7mlgf/one_of_python_3s_fundamental_problems_on_unix/7vo3), this change makes robust programming almost impossible in Python: The thing that works on Windows *doesn'*t work on Linux, and there's no reason for it! If I want to write a routine to find a string in a bunch of files matching `/^some_key\s*=\s*(.*)/` I'd love to do something like this: for x in os.listdir('.'): for y in file(x): if match(y): ... but I can't do that! On *windows*, I need to use: for x in os.listdir(u'.'): and on *unix*, I need to do: for x in os.listdir(b'.'): otherwise I can get an unexpected exception, or lost data. To insulate myself from this ugliness, I can encapsulate it. I can write an iterable, say, `dirfiles()` or whatever, that goes through the necessary contortions. The *problem* is that *every python programmer* has to go through these contortions, or their program is flat *wrong*. Are they going to go through the contortions? Correctly? Every time? What can we possibly be gaining by having `os.listdir()` return strings, that it is worth *this*?
How come when I click on this link, all I see is a blank page?
&gt; Since these byte-arrays are shown to the user and are, in fact, the only way a user has for identifying a given file, then there is most certainly a huge benefit in treating them as user-readable strings. I disagree. There's benefit in having names that are easy to type- hence terminal users tend to create files without spaces in them (and ? and other metacharacters), but I think it's a mistake to confuse the two problems. My terminal will decode utf-8 glyphs just fine when I `cat unicodefile.txt` - but `cat` doesn't need to know about unicode- or character sets, or anything else like that in order to accomplish that. It would actually be a mistake to teach `cat` about character sets because people use `cat` for things *besides* looking at the output with human eyes. Filenames are similar. Just because we sometimes look at filenames, and sometimes need to type them, doesn't mean that programs need to go through the contortions and the time of decoding them, just to recode them again when opening the file. &gt; then there also has to be some 'friendly' way for users to identify these files that doesn't involve recognizing arbitrary bytes Agreed. Having `print()` (or "stringify") do the encoding is a good way to do it. That way, if you actually *look* at the filename, you have to deal with the coding issue, but you don't have to deal with codings if you don't. &gt; Currently, the internal representation and the representation exposed to the user are the same But that's a bug, because they're not the same. The internal representation is a byte-string, but the external representation might be unicode, or might be something else. The latter, you can guess on, but if you guess wrong, it doesn't cause any problems except if the user tries to type the filename back in. And that, is what wildcards are *for*. &gt; That's how its been in (almost?) every major desktop OS. I'm not aware of any operating systems that do this. Microsoft Windows has two sets of apis for dealing with ANSI and Unicode strings. It also has 8.3 filenames and LFN filenames. The pathname as displaed may be `C:\Foo.txt` but internally it is `\\?\c:\Foo.txt` (I think). GNOME does the decoding right at the end, and any coding errors get replaced with "?" (or something else- sometimes hex-strings), but if you double-click on a filename, it still uses the internal (byte) name. HFS+ systems (MacOSX) use PBGetCatInfo to convert a directory index into a filename.
&gt; Wait a minute. Are you saying you see no problem with grabbing six bytes from /dev/random and using them as the name of a new file? I am saying that I find it totally unacceptable for a language to pretend that such a file doesn't exist. &gt; Which of your file names are not? It can happen for lots of reasons; problems in fsck, or malicious (or stupid) users, encoded filenames, sfs data symlinks, and so on. I typically use random filenames (using 8-bit set) for temporary files because it reduces the chances for collision. Basically, I use a contortion like this: x = make_random_filename(); f = open(x, O_CREAT|O_EXCL, 0600); ... rename(x, "real_filename.txt"); I cannot fathom the kind of mind that thinks that python *programs* shouldn't be able to see these files because *people* can't see these files.
I'd chime in with the "Google it, jerkwad" but I've tried to do this and there really is no obvious good solution, sadly enough. ossaudiodev is pretty basic and hackish, and ties you to an outdated API, but it will do the job. SDL is also a good suggestion. Also look at pygame's audio support.
Up voted if only because I can add an anecdote: my pro-audio-programmer friends use c++, python and jack. 
Pyddit?
&gt;I am saying that I find it totally unacceptable for a language to &gt;pretend that such a file doesn't exist. This all started when you said that file names should be thought of as byte arrays, and I said they are supposed to be strings. No one's pretending they're guaranteed to be strings, not even Python 3. &gt;It can happen for lots of reasons; problems in fsck, or malicious (or &gt;stupid) users, encoded filenames, sfs data symlinks, and so on. Maybe you've mistaken me for Python 3. "Encoded filenames" doesn't belong on that list because I'm talking about files whose names are not strings--in any encoding. I'm also not denying they occur. I'm saying they're not supposed to. They shouldn't be considered valid (which is not to say that all programs should detect and reject or omit them). As for the ways they can happen, well, that's the difference between "supposed to" and "guaranteed." &gt;I typically use random filenames (using 8-bit set) for temporary files Ah, now that's what I'm talking about. Don't do that. Use a string. If you want more randomness, use a longer string. It's worth it to use things the right way and avoid a lot of potential grief. Besides, you shouldn't be relying on the randomness of the name to prevent collisions. Opening with `O_CREAT|O_EXCL` will fail on a collision, so call it in a loop and use enough random characters that you rarely have to repeat. Better yet, use a library. Most languages have libraries to do it for you (using a string like `tmp.a6cf99`) written by people who know much more about creating temporary files than you or I.
English is not his native language. Give him a break. His coding skills are excellent.
&gt; Maybe you've mistaken me for Python 3. "Encoded filenames" doesn't belong on that list because I'm talking about files whose names are not strings--in any encoding Sorry, this thread is about python. Every byte string is valid in some coding, even if that coding is a binary one. It just also turns out that transcoding every filename read is stupid, *in addition* to being unnecessary. &gt; Besides, you shouldn't be relying on the randomness of the name to prevent collisions Rubbish. &gt; Better yet, use a library. Most languages have libraries to do it for you (using a string like tmp.a6cf99) written by people who know much more about creating temporary files than you or I. I doubt that. I have reasons for doing the things that I do, whereas you quote some cargo cult, and insist I don't want to do them. For some reason, you think that my problems stems from anything but the decisions that Python has made. *Who the fuck are you* to unilaterally decide for everyone what filenames should contain?
Goodbye, Happy New Year.
I don't know much about python packaging but his solution looks anything but sane.. I don't understand how his solution is better than existing packaging solutions. Can somebody enlighten me ?
Perfectly valid English.
The whole "?" unknown character thing is a (not the) main problem. There should be an icon for every byte character, including tab, LF, CR, etc (like how MS-DOS did it) for control characters.
I think you misunderstand: I don't have any problems with *displaying* "?", but with low-level interfaces generating a list of files *for a program* that the program cannot open *because* the file names have been mucked up in an effort to get them "unicode friendly". Python's `os.listdir` won't return names that `file()` can't open, whereas Java *will*.
hmm.. Perhaps since Python is open source, someone will submit a patch for it.
Having not heard before about genetic algorithms that was quite interesting, but I don't get something about the code inside evolve(): &gt;if random() &gt; random_select: &gt; parents.append(individual) since random_select is 0.05 a "not good/not retained" parent will be selected 95% of the time anyways Also, mutations will occur in 99% of the time since the condition to mutate is random() &gt; mutate (and mutate is 0.01) Both of these values sound like too high to me, as if they were reversed, but as I said this is new to me...
Man. I totally mangled the code everywhere in that writeup. Should all be fixed now.
good article, but now I guess you'll have to modify an nice part of it &gt; (although it spent **about nine thousand** of those generations making absolutely no progress,
Creative license. It's great. ;) In all fairness, the nine thousand stands pretty closely to my previous experience with genetic algorithms. ;)
A 95% survival rate is kind of high. I've been toying with a GA that I want to evolve rather rapidly (and cover lots of permutations) and have been using a 50% survival with decent results.
The results are much better this time. ;) It took 10 generations to reach perfection.
the problem is that it was a survival of 95% of the "already discarded" 80% of the population the top 20% was already selected for mating
Updated text ;) With 20% survival (plus an additional 5% of other individuals) and 1% mutation, it only took nine generations to reach a perfect solution. Then it will willingly go in circles for as long as you'll let the mutations continue run amok. But this is a good feeling right? If it only took us half an hour to solve a problem of this magnitude, imagine what we could do with a day. A genetic algorithm for optimizing your Apache2 configuration file for number of children processes? Easy as pie.
It doesn't look like it. The problem stems from treating filenames as *strings*, when the operating system treats then as *byte-arrays*. Having a third-type that implements a byte-array, but can be converted to a string on print (perhaps with other conversion rules) would solve this problem.
Can you please do a complete series of these applied to real world problems or something similar? This article is very timely for me, I have been trying to eat up as much GA info as I can. Regardless of whether you do it, I loved this article.
Nice introduction... Subscribed to your feeds and looking forward new articles.
&gt; - CSS-like style system Awesome, I've been waiting for a gui system with this feature for a while.
I've been looking into this same issue in recent weeks, and pygame's audio support works but it's limited. So if developers want to do anything more than loading and play audio files they'd need to find something else. I haven't yet found a good solution for cpython on linux. I keep going back to java where I can get things working, and then feeling dirty and thinking that *surely* it can't be this hard on python, a platform which wraps most things work beautifully. dspdude - you might be able to grab the source code to jokosher and make some sense out of that (it's GPL though - hope that's not an issue). psykotic on reddit gave a great introduction to the general topic of DSP here, also: http://www.reddit.com/r/programming/comments/6su1d/ask_reddit_how_to_get_started_on_microcontroller/c04ryb9 
&gt; Tell you what. If it ever gets to a releasable state, I'll announce it here on /r/python. Please do. Lately, I've been doing a ton of web 'scraping' using Beautiful Soup and customized crawling scripts, but none of that is really a 'reusable library'. I'd love to help out if you release it as an opensource project on google code, github, etc.
I realize that the linked toolkit might better serve your needs, but there is a toolkit that can be styled with CSS. It's called [XUL](http://www.mozilla.org/projects/xul/) and it's used liberally to form the basis for Firefox's UI. Its behavior can even be programmed with Javascript. This flexibility is what allows for extensions, and if you want to use it, you can always use [XULRunner](https://developer.mozilla.org/en/Getting_started_with_XULRunner). Once again, I realize that not everyone will like XUL, and there are issues, but I just thought you might be interested in this toolkit.
Cool, i'll have a look.
&gt; there are issues Oh, just a *few*....
Then look forward to [Eclipse/SWT 4](http://www.pushing-pixels.org/?p=519)
Hell ya! I love SWT, use it for all my java gui needs.
I do too, but the [Substance LAF](https://substance.dev.java.net/see.html) might make me reconsider. But then JFace Databinding is really really nice.
stunning? my expectation level was really up when i saw that adjective
While Substance looks nicer than Nimbus, I really hate the bloat of Swing in general. Also, as someone who respects UI design principals, i'm against using non-os standard schemes. I prefer using native o/s gui for my apps.
Psyco only works on x86 and, in *some* cases, provides *minimal* speed improvements with numbers.
Could you elaborate or link somewhere?
Just anecdotally: It's slow, it's ugly, it's hard to build, it's C++ (not necessarily a con for some people), it depends on XML, etc.
In my opinion, it doesn't really look stunning, it looks rather normal/boring. I want to see a custom Python UI toolkit that employs OpenGL (Yes, much like Blender) and makes it easy to integrate into games.
&gt; Visual WYSIWTF Designer That's how I feel when I use most Python GUI designers. What I see is: “What the fuck?”
Maybe [cocos2d](http://www.cocos2d.org/) is a start?
Ugh, GTK.
It might be all this but it usually does not look ugly, though. It looks like every other GTK+-application. And well, building Firefox (along with all the XUL stuff) wasn't terribly difficult.
&gt; It looks like every other GTK+-application. This is not ugly how? &gt; And well, building Firefox (along with all the XUL stuff) wasn't terribly difficult. Clearly, you've never built on windows, freebsd, or mac os x.
It's really easy to use, and works with complex types exactly as you'd expect.
Qt has had a [CSS-like style language](http://doc.trolltech.com/4.4/stylesheet.html) since 4.2. 
Nah, I'm sure it'll stay in beta for at least 6 or 7 years.
&gt; This is not ugly how? Not more ugly then other toolkits. Plus, it supports theming quite well, so if you don't like the look, you're free to change it. &gt; Clearly, you've never built on windows, freebsd, or mac os x. Building anything on Windows is quite a pain, and when I hear Mac OS X users complaining about lxml, it seems to be similar there too. Building it on FreeBSD shouldn't be too hard, the port should build with a simple `make` and anyway, Firefox is available as a package, so if you want it, you don't have to compile it yourself.
PyQt is another great option. On Windows there's a single download (Qt + PyQt), on Linux your package manager will make it easy and building from sources is easy on the Mac.
&gt; It's slow I can't tell if it is significantly slower, that is, if it's slow enough to matter. I'll take your word for it though. &gt; it's ugly By default, it's uses the native toolkits (I believe GTK+ is used when there isn't a "standard" one, like in Linux). Thus, it fits into your desktop perfectly. This is exactly like Firefox because they use the same technology. &gt; it's hard to build Do you mean it's hard to build the base? There are precompiled binaries for three major systems, and many Linux distros will already ship with it. Or do you mean it's hard to build *with*? I tried out the [tutorial](https://developer.mozilla.org/en/Getting_started_with_XULRunner), and getting started is easy. In addition, as seen from the significant extensions that are made for Firefox that add UI elements, it can't be so difficult that it's not usable &gt; it's C++ (not necessarily a con for some people) Most *users* of the toolkit won't look at the source. &gt; it depends on XML So? XML isn't that bad. Also, if you're worried about people having to install a runtime, then either it's easily available from the repos, etc. (for *nix with package management), or [Firefox 3 can be used to run the apps](https://developer.mozilla.org/en/XULRunner_tips#Using_Firefox_3_to_run_XULRunner_applications) (for Windows, OS X and possibly other platforms).
Doesn't seem more useful than Qt + Qt Designer. Though the interface is probably more pythonic.
First, sorry for posting this to pyreddit, but I thought this would yield a better recommendation for me than the java subreddit. *The Job* - It's mostly a web development position, so a book that uses things like tomcat and struts might be helpful. Or maybe I just need a general (but not Programming101) book on Java and then jump into those topics after that. I see 'Java in a Nutshell' breaking bookshelves all over the office, weighing in at 1,254 pages. It offends my sensibilities to have a book with that title be that large; *somebody* is doing *something* Wrong. I really, really love Python. I am an intermediate level Python programmer. I know almost nothing about Java. I know C and PHP, so the syntax should be familiar. Have any of you pythoneers come across a good Java book that doesn't agonize over the basics of programming and isn't so large as to dwarf the internet? I know there are probably some great PDFs or ebooks out there, but when I learn a new language I really like to sit in a chair with a good book (call me old fashioned that way.) (And just to make this explicit rather than implicit, I am not giving up on Python one bit. I love the language and am really excited about dict-comprehensions. Moving into a development position, even at a java shop, brings me closer to being able to work where I want so I can program in the language of my choice and be ridiculously happy. I will also be able to have a better conversation about why I like Python better than Java and tempt some of the Javaheads in my office.) Thank you in advance for any thoughtful or informative replies.
I wish you hadn't added the method call...
http://www.leepoint.net/notes-java/index.html Taught me all the basics of java.
No. Suicide is your best option at this point.
[Head First Java](http://oreilly.com/catalog/9780596009205/), but amazon's probably cheaper.
So, you're recommending the nutshell book then? I'm pretty sure that would finish me off.
Maybe you can sneak by using [jython](http://www.jython.org/Project/).
Java hurts. Thinking in Java, by Bruce Eckel is written well, by an intelligent man (who apparently prefers Python now). The 3rd edition is available for free, so you can check that out w/little risk. http://www.mindview.net/Books/TIJ/
&gt; It's mostly a web development position Wel development in Java? If you've done web dev in Python before (or even in PHP 5), you're likely to want to kill yourself soon. Seriously, java is one of the worst web dev environment (and I've done it for a pair of years before quitting), I'm not even sure Cobol on Cogs would be worse, and it forced me to consider using PHP -- a language which I loathe -- instead. Have there been any mention of web frameworks? (a few recent java frameworks alleviate some of the pain through sensible defaults and annotation-based config -- Stripes for instance -- but older XML-based frameworks only worsens it, Struts 1.x is a prime offender) You might want to read PJE's [Python is not Java](http://dirtsimple.org/2004/12/python-is-not-java.html) and [Java is not Python, either...](http://dirtsimple.org/2004/12/java-is-not-python-either.html) Read the latter first by the way, if you start with Python is not Java, you're going to hang yourself right off the bat. As far as books go, Thinking in Java 4th edition (java 5 support), just browse through it to get an idea of the language, and Effective Java 2nd ed (short book, enjoyable read and it will teach you how to think java in short bites). PS: try to see if you can use Jython, JRuby Clojure or Scala instead, they run on the JVM and they're not java, 2 great advantages.
I did a course called Enterprise Computing (insert laugh here) as (a very easy part) of my undergrad in CS at Edinbrugh University. Basically this course turned out to be more like Enterprise Java, and works through quite a lot of the web java features such as JSP,Hibernate,Tomcat and some stuff like the Java logger. While it may not help you to learn the language much it might certainly help when you come to cover the stuff required for deployment (like the JSP and servlet compile pathway). There is also quite a good introduction to ANT which will save you from actually killing yourself due to the inane nature of java classpaths... http://www.inf.ed.ac.uk/teaching/courses/ec/ Now for my token effort to avoid another Java train wreck, why not write in python and use Jython to compile to java byte code, they need never know! Although on a serious note I would check out groovy, especially if you are just learning. It is basically the Java language with a little bit of python flair installed for good measure and is widely supported now! http://groovy.codehaus.org/ Hope you don't end up doing something stupid, although I fear that ship sailed the moment you posted about learning Java to the python subreddit... Enjoy.
Believe me, if I had the choice to write in Python I would, but it's a case of having to conform to my team's environment. Thank you for the link Java link, that looks like it will be helpful.
I have done web development in Python, and I know this won't be anything like that. I'm not expecting this position to be my dream job or even make me especially happy. But I'd rather move into Java development rather than stay in a non-development position. I am fairly certain I won't like Java and that I may hate it. But I'm willing to try it and find out for myself. I probably should have made it more clear that this is an internal promotion and that I currently work for the company, and our desktop and web products are written in Java. Right now I build a lot of tools and web apps for internal use in Python. One reason I got the promotion is because I get stuff done so well and fast in Python. 
It might make a good April Fool's, but I have to work on the same code base as my co-workers, so I can't dictate language or tools. Unfortunately.
And don't forget to put us in your will!!!
Well good luck, but still once you're in place you'll probably ought to try to switch the language of the web frontend from java (as long as the chosen language runs on the JVM, the code shared between web and desktop will work and be useable)
It's not as bad now that it has generics and collections. Eclipse is a godsend, since most of your pain will come from looking up API calls.
how's moving to java a _promotion_ ?
I Second that, using Eclipse makes Java quite a bit more bearable. Along with Google and Sun's reference you can do pretty well.
Some years ago I got one of my best friends, a very intelligent Java guy, to join the company I worked at and write web software in Python. He hated it. I've since left, but he now heads all development there, having converted the whole place to Java, and he loves it. So it is possible to have fun web programming in Java. Embrace the challenge if you must. You'll likely get *something* out of it.
$$$
I'm amazed at how many web dev jobs are in Java. Especially once you get outside the silicon valley and out into the "enterprise". They aren't always the outward facing things, sometimes they are the little apps used within organizations. Enterprise IT just seems to love java. I don't know why. It's expensive, and a pain in the ass to code. But, they of course already have a set of people in place that know it, and they are doing the hiring etc.
I like your honesty.
Can you use Groovy? It'd be an easier jump for a pythonista.
&gt; Enterprise IT just seems to love java. I don't know why. It's expensive, and a pain in the ass to code. 1. Covering asses: just as nobody's ever been fired for buying IBM, nobody's ever been fired for going Java. In big corps, middle-managers first and foremost want to avoid the chance of being blamed. So they go for java because it's "the industry standard", and when the project is overbudget and/or late and/or a failure, it's not their fault. 2. [The python paradox](http://www.paulgraham.com/pypar.html): going for java ensures they have a huge pool of not-necessarily-qualified potential hires (see [java schools](http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html) &amp; al). This also pleases middle managers. 3. You saw point 1 about choosing IBM? Well IBM pushes java hard, so you buy overpriced IBM hardware (and software, hello Websphere), and then you code in java to top it off (Oh websphere, what a surprise!) I'm sure we could find others, but that's a good start
&gt; It's not as bad now that it has generics and collections. But the generics suck, and the collections don't have literal syntax (yeah you can approach it with anonymous classes tricks, but it's not exactly sexy), plus you need heavy libs (google collections) to use them non-imperatively. &gt; Eclipse is a godsend, since most of your pain will come from looking up API calls. I strongly preferred IntelliJ IDEA when I was coding in Java, though.
1984 by George Orwell
Going from a non-development position to a full time developer is definitely a promotion. =)
Why thank you, you have good taste.
I agree that Java isn't as bad as you think it will be. The language itself has a few quirks, but it is rather straightforward, and if you understand classes and inheritance well enough, you'll figure it out. Two tips: 1. Bookmark the API reference now. For J2SE 5.0, it's here: http://java.sun.com/j2se/1.5.0/docs/api/ 2. Get used to Googling for code examples. There are about a zillion examples out there. 
Jython would probably be better.
This is slightly OT, but how does one define themselves as an "intermediate"-level programmer in one language or another (particularly in Python)? Is it about knowing the standard library? Understanding less popular parts of the languages (such as generators, list comprehensions, etc.)?
&gt;You might want to read PJE's Python is not Java and Java is not Python, either... &gt; &gt;Read the latter first by the way, if you start with Java is not Python, you're going to hang yourself right off the bat. Uh, so you *want* zekel to commit suicide?
Ye gods, that's an ugly website.
If you're doing web development, look into the Google Web Toolkit. It lets you write all your code in Java, and basically converts it into JavaScript for you, and does a pretty good job of it too. The only downside I've ever run into (when I used to use it for work), was that at the time it was using a pretty old version of Java.
Look at the *hell* you've wreaked upon that company!
For a second, I thought you were indicating there was a book called *Java Hurts*. Come to think of it, that'd be a *great* title for a Java book...
Read up on design patterns, i can bare just about any language as long as im developing elegant solutions. Frameworks like [spring](http://en.wikipedia.org/wiki/Spring_framework) and [hibernate (ORM)](http://en.wikipedia.org/wiki/Hibernate_(Java) are a god send and you should feel comfortable with them coming from a python background. By the way i'm a hobbyist python programmer who works in Java development, its not half as bad as people make out. 
how is that helpful? He doesn't know Java and hes developing in Java not JavaScript..
well hopefully they have some kind of code review, its gonna be a little difficult to review byte compiled java.
If you can buck the trend there, trying pushing for something like GWT. Its still Java, but a lot of the pain is reduced for you. Its hard to tweak when things go wrong, but depending on the application that may be acceptable. I've also used OpenLaszlo. My recommendation is to stay far away. It can produce functional applications, but performance is horrendous and the JS backend is hardly mature. 
Well, I found myself to be an excellent audience for [Expert Python Programming](http://www.amazon.com/Expert-Python-Programming-Tarek-Ziadé/dp/184719494X). (I highly recommend it.) And since I'm not a beginner, that means I'm probably somewhere in between. Although maybe that means I'm an expert now... hm, nope.
I did post about Java on pyreddit. I'm sure some people will try to do me in for that.
Because its J2EE! its has enterprise in the name therefore its must be built for enterprise /sarcasm. Seriously though most of the lead developers at the companies i've worked for don't have any experience with languages like python, its in their best interest to keep everything in Java.
That's great to hear!
It is not because the language is hard, it's because the language lacks about any advanced features and forces people to do stupid workarounds, "to help them not to shoot in their feet" or something.
I took a peak at that in the bookstore. It looked littered with the 'for dummies' style. Pictures of giraffes and stuff...
Well obviously any code review would be done on the python side... The fact that it compiles to java byte code is only to satisfy any portability constraints on the system.
At first sight, I also thought 'Head First ...' was just O'Reilly's '... For Dummies', but no! I can't speak for Head First Java, but I read [Head First Design Patterns](http://oreilly.com/catalog/9780596007126/), and it's a pretty serious and insightful book in a very digestible format.
I can't stand the verbosity of this book.
I recommend [Java in a Nutshell](http://books.google.com/books?id=mvzgNSmHEUAC&amp;printsec=frontcover&amp;source=gbs_summary_r&amp;cad=0). The first part of the book is an excellent concise introduction to Java as a second language. [Sun's Java tutorial](http://java.sun.com/docs/books/tutorial/java/index.html) respectably taught many of the early adopters how to program in Java.
 print("c-"*4, "combo breaker!", sep="")
The *language* will make you want to kill yourself. Better find yourself a good window.
&gt; Read up on design patterns Instant downmod. Well, at least you're making OP kill himself with the Best Practice™ way. (Which is it BTW? Use the suicidal factory class to get an instance of a SuiciderBroker which uses an instance of SuiciderMethod to allow you to construct a SuiciderAction object to kill yourself? Will you recommend the free fall pattern for that?)
&gt; a very intelligent Java guy, to join the company I worked at and write web software in Python. He hated it. So I take a very intelligent Java guy is still below average as a Python guy? :)
Start with: new QuestionAsker(QuestionMaker.getInstance(new QuestionWrapper(new Question("I am moving into a development position at my company and need to learn Java. Can you recommend a book that might appeal to a Python programmer and not make me want to kill myself?")))).askIndeed()
&gt; Enterprise IT just seems to love java. It's because they care more about getting more bang per buck than their e-penis size, and Java gives radically bang when you look at the whole process of producing value with software in a large and complex environment, instead of just looking at the matter from an individual developer's immediate standpoint.
This is wrong. Completely wrong. It has everything to do with what they are used to.
I know Java just fine, thank you. It has very little place where it is typically used. It makes very little sense for web development, except perhaps in some edge cases. That's a fact. And the fact that you can't wrap your head around it is hardly evidence of "retardation" or "narrowmindedness". Feel free to call people names though, if it makes you feel better.
&gt;&gt; when you look at the whole process of producing value with software in a large and complex environment, instead of just looking at the matter from an individual developer's immediate standpoint.
Honestly, I don't feel the for dummies style at all. They explain in the preface that that they write the way they do in order to teach you the material and so that you retain the material with out having to put forth the effort to try to retain it. I like it. I would suggest giving it a try. If it's not for you, then it's not. Otherwise, it creates an atmosphere where minimal effort yields maximum retention, and who can argue with that?
And you have to factor in the perverse organizational incentives that exist. Some outfits budgets are allocated based on headcount, and depth of tree, so a two person team with a single layer counts less than a 7-person team with two layers; and a manager who is responsible for a team totaling 7 FTE doing Java, is better compensated than one who manages two programmers writing in python. Even if the two teams are producing equivalent functionality :P
&gt; from bjupton sent 12 minutes ago &gt; &gt; comment reply &gt; &gt; You are clearly too stupid to discuss this with. Clearly that is the problem.
Just out of curiosity; how do you explain the numerous instances of misapplied java frameworks that I've encountered? From using JSP to produce RSS (badly) to a very well compensated 'Senior Developer' who claimed that Hibernate let him ignore such pedestrian concerns as referential integrity and query performance; Java Programmers (as opposed to programmers who happen to know Java) seem to be much more prone to the lure of the Cargo Cult than most other IT workers. //me dislikes Java because i loves Unix
I have no reason to believe the cases of hilariously miscoded crap you've seen are much different from the similar cases I've seen. Incompetence has little to do with tools, except in cases where good tools make it possible for incompetents to produce at least some value, to the horror of the people who then have to maintain said crap for years. Having had been on the maintaining side, I would have formed the opinion that the incompetents should have failed int the first place, if not for the fact that good tools produce much better value to competent users than grief from the incompetents. If you do second-level caching right with Hibernate, you aren't bounded by database performance. Of course, doing it right means understanding how to get good performance in the first place.
Effective Java 2nd ed FTW!
Here's the direct link to Malcolm's comment: http://groups.google.com/group/django-developers/browse_thread/thread/4f5b01719e497325/a60123ee5af0c566#a60123ee5af0c566 (which is really worth the read).
Let me guess: You're a Java programmer? Python frees you from the requirement that each class be in its own source file.
The number of files and the lack of comments makes the code difficult to read. It would be a hundred times easier if there were comments to tell one what things like "color.py" does
you do realize that there are several design patterns that are intrinsically built into python right?
Please give your application a single namespace to use instead of futzing with `sys.path` and generic names, which lends for namespace collisions. You would then import `appname.libname` instead of `libname`. 
Well of course it would be an acceptable side-effect of my post, but mostly no, Java is not Python highlights quite a few differences between java and python, just because they're seen from the Python side doesn't mean they aren't interesting when you go from Python to Java. Just think of it as a smaller dose of the pain to be experienced later, to build immunity. Kinda like the guys who inject themselves daily with small doses of toxins/poisons to build resistance. In both cases, if you fuck up the dosage you might die, it's an accepted risk.
More than half of the book "Design Patterns" is bloated crap for "enterprise" and "best practices" software - patterns you're best not using because they lead to bloat in the code, verbosity, harder to use interfaces, and worst of all documentation hell. Two popular useless patterns are singletons (use globals for globals!) or factory classes (use functions for functions!), but there are other less obviously useless patterns. The more useful patterns are still a bad idea. First of all, they should occur naturally, without having to pull them from a recipe book, and they shouldn't be crafted more than once. We are not "web designers" copypasting JavaScript snippets. Programming is not about copypasta; it's about abstraction. As such, the programming language we use should be powerful enough to offer the abstraction capabilities to abstract any design pattern as a function. Python is generally capable of abstracting such design patterns into functions since it features first-class functions, first-class classes, and closures. We don't need copypasta, and we don't even need to read Design Patterns to work properly. Once a pattern is obviously useful and repeats through the code, you need to abstract it with functions, just like you abstract blocks of functionality which repeat through your code. The language is not free of design warts, however, such as the defect known as "statements" inherited from terrible languages such as Fortran. Because of them, and because of its syntax, but most importantly because of Guido's stubborn opposition to functional programming, Python doesn't have expression defs or statement-capable lambdas. Because of this, decorating functions would have been clumsy, so instead of fixing the underlying design and syntax problems, Guido added a Perlish hack known as the decorator feature ("@").
and yet... java was not designed for the Enterprise. It was heavily promoted by Sun as an applet technology (in set-top boxes). Getting adopted by the enterprise happened by itself, and was kind of surprising and strange. The whole "application server" thing came about as a surprise too - BEA Systems came along and did that. Java has something going for it... but what? Familiar to C coders, but much safer, simpler, friendlier error messages and more reliable, was what Java offered I think (some argue that other C variants, such as Objective C had this too) - and a virtual machine. I'm not sure how important the whole OO thing was, except as one of Java's well thought-out supports for modules, You can load classes dynamically (making it a "component platform"); you have classes and packages. This support for modules makes it possible to write big systems. "Components" and architecture dominate the big picture, but are invisible when writing specific code (forest/trees) - so, if true, decision-makers would love it, but coders wouldn't see why. 
&gt;Boo hoo, I have to program in an uncool language. What will my cool friends think of me now!? Suck it up, wusses.
Glad to see that there's new development on it. I tried it before, but couldn't use the current version because we have a very large SVN repo, and it locked up SVN for several minutes to calculate the status of every file each time I went to the repo directory.
nice python article...except all the code samples seem to be XML....
nice python article....except all the code samples seem to be XML
Where's the exception handling?
It appears they already had and addressed this problem, as the windows and balconies are all sealed.
Can you recommend to me the best 800 or so pages of Java in a Nutshell? I don't want to read too much unnecessarily, maybe I can just skim the other ~450 pages?
I think this is definitely the step in the right direction of choice. Personally I prefer (most) command line tools to their GUI frontends but for most Windows developers it's usually a cold wet plunge into another, unknown world once they want to port their project to Linux. This particular project should help those people get into the right 'feeling'.
Requires UNIX-only modules, too bad. Also, doesn't seem to be updated anymore, for anyone perusing old reddit submissions.
Why do you think that would particularly be an issue? Function call overhead is much lower in IronPython than in CPython by the way.
Possibly because each of your macros is a function, calling another macro from one, etc etc. Some spreadsheets are incredibly complex. 
No, that's not what I mean at all. I'm sure your logic is sound. But you effectively said, "Read Java is not Python by the way, if you start with Java is not Python, you're going to hang yourself right off the bat." This is the former word in the sentence, and this is the latter.
and still doesn't work with python 2.6 I guess we must wait till y3k for py3k
I found one: "ecasound". It is simple. 
Ok - but in Resolver One macros are not necessarily implemented as functions. Overall performance will be affected a great deal by spreadsheet complexity, but function calls may or may not be a substantial part of that.
&gt; But you effectively said, "Read Java is not Python by the way, if you start with Java is not Python, you're going to hang yourself right off the bat." Oh dear, I meant "if you start with Python is not Java", thanks, the mistake has been corrected.
The series is presented in 9 easy-to-assimilate parts. Written by Robert J. Brunner, a research scientist at the National Center for Supercomputing Applications and an assistant professor of astronomy at the University of Illinois, Urbana-Champaign.
Yeah, wasn't much IronPython there. Hopefully there will be a follow up on actually using it. Data binding is pretty big in .NET.
Netbeans supports Python now?
Not to mention your line exceeds 80 characters, which is the industry standard's limit.
Pygame's audio support is limited in terms of DSP, but I'm pretty sure you can do some audio effects much in the same way you do visual effects on pixel surfaces; Import the sound into a Numpy array and go crazy. I don't know about latency issues. Please enlighten me!
A module that integrates with MySQL will see wider adoption.
It's more than a DAL, it's a full blown ORM
I'm getting into python game programming, but noticed a lack of GUI and game melding (or maybe just blind). I've been learning pygame which seems to work quite well, and have also looked at pyglet. I found gameEngine (http://www.cs.iupui.edu/~aharris/pygame/) which melds basic GUI objects, multiple scenes and such with pygame but was wondering what everyone else recommends. What do you use to aid your python game programming? I'm using Python 2.5 on Windows (2.6 doesn't seem to have the compatibility that 2.5 does)
I will be surprised if there is no SDL binding for Python.
PyGame is your default suggestion. It's not that bad, really. Of course, I use IronPython to prototype games in XNA (thankfully, one can extend C# objects/interfaces in IronPython). It makes for an interesting combination. That said, XNA does bind you to Microsoft's stack, if that's an issue, and you're probably going to want to reimplement parts in C#.
[Pygame](http://pygame.org) is exactly that.
Ah my bad =]
Pygame is big and kind of messy. Pyglet is what you want.
SQLAlchemy rocks. Bravo to all contributors for releasing this new version. I use it everyday.
I've tried to get into pyglet, its where I started and then went to pygame actually. I dunno if its just me, but the pyglet website seems to die every time I try to access it to look at the api :(
There's also [PySoy](http://www.pysoy.org/), [Panda 3D](http://panda3d.net/index.php), [Python Ogre](http://www.ogre3d.org/wiki/index.php/Python-Ogre).
I've played with the Opiod2D framework in the past, which seemed quite fast and had some nice particle effects, but I ultimately found the way the it took control of the main loop as a 'director' too restrictive. Worth checking out though. Another very nice, lowish-level, Python library for fast 2D sprite rendering is Rabbyt ( http://matthewmarshall.org/projects/rabbyt/ ). It integrates with both Pygame and/or Pyglet, and uses OpenGL rather than plain SDL to improve sprite rendering and transformation performance. Almost all of the Python game frameworks you will find are built on top of Pygame or Pyglet. There are various higher level libraries listed on the Pygame site ( http://pygame.org/tags/libraries ), but IMHO there really aren't any amazingly good high-level 'frameworks' built on top of Pygame or Pyglet. I've noticed a lot of Pygamers tend to use their own mini-frameworks with various utility functions and enhanced Sprite classes, but very few people use anyone else's library - if you find a sane, stable well documented one that someone other than the creator can grok, tell me !
The old laptop sits upstairs with nothing to do all day except feed mp3s into the fm broadcaster. As it had nothing better to do I wrote a few scripts to improve on the choices over a simple "play all randomly". Play high rated songs more often, alternate songs with ripped movie quotes, play songs heard recently less often, no metal during sex, that kind of thing. Over the years robo-dj.py has become a reasonably sized package, and quite good at keeping to a theme. Now I want the same thing in the car. Anyone able to advise which mp3/media players will allow me to control their playlist with a python script, which runs on the player ? 
I run Python on my iPod touch fairly well. The package installed includes source code on how you can create UI elements right from Python.
I've been using Python for most of my recent projects for a few months now, and am relatively comfortable with it. One of my projects now demand a full GUI interface, something I've never done before from Python (except simple things in Tcl/Tk, but I didn't like the aesthetics of that very much). I've looked through the various toolkits available, but I haven't really been able to make a judgement on any of these. Does anyone have any experience with any suggestions or pros/cons? I'm not interested in creating a web interface for it, so please don't suggest a web framework. 
PyQt is the best; but also the one that is not free.
[wxPython](http://wxpython.org/). If you are using the Gnome desktop environment, I have had a lot of success (and a lot of fun) using [wxGlade](http://wxglade.sourceforge.net/).
If you want a portable interface, nothing's more portable than Tk. Sure it's ugly, [at least by default](http://tktable.sourceforge.net/tile/), but it works. If you want an app that looks and feels native to any given OS, then you'll have to use the Python bindings for that OS's GUI. On Linux, the Python bindings for GTK are pretty great, and on OS X there's an Objective-C bridge so you can call the Cocoa APIs directly. You could use a different GUI toolkit that tries to compromise between portability and native integration, but you'll just wind up beating your head against those compromises where the maintainer made slightly different trade-offs from what you would have wanted. I say, just pick one extreme and go for it - if you keep your data model separate from your UI, it shouldn't be too hard to wrap another UI around it later.
I agree with this wholeheartedly, though you can always package GTK with the program, like Pidgin does.
Uh? PyQt uses the same license as Qt itself - so if you write a free software application it's free for you.
This really depends on what your needs are. If you need something that supports a lot of widgets and can be easily distributed with your app (py2exe context) go for wxPython which uses the native toolkits of the platform. If you are a GNOME or KDE user you'd usually rather choose PyGTK or PyQt. Personally I prefer the PyGTK Binding as it is a bit more pythonic and is easier to grok but I admit that Qt as a toolkit is also a fine choice. Plus, you can easily use platform-specific extras with these toolkits like GNOME-Python(-Extras) or PyKDE.
Another vote for Tk as a very portable interface. There's some pretty good [documentation](http://www.pythonware.com/library/tkinter/introduction/index.htm), good enough that I was able to use this manual for Ruby/Tk programming when there wasn't enough information elsewhere. Also, the [Tcler's Wiki](http://wiki.tcl.tk/) has extensive information as well. I also know from experience that Tk has extensive hooks for a wide variety of tasks. For example, it turned out that canvas rectangles had `dash` and `dashoffset` options for the outline, so rendering the marching ants of a selection for a image editing application trivial. Similarly, for an application with text formatting options, the Text widget provided a multitude of formatting hooks. Perhaps other toolkits have these features, but Tk is great if you want to make a run-of-the-mill GUI with many "standard" or common features without implementing all these features. That said, I haven't heard of any graphical development tool, but I don't know how much that would affect frutiger's decision.
If you end up using GTK, I can wholeheartedly recommend [Kiwi](http://www.async.com.br/projects/kiwi/), a high-level Pythonic wrapper around GTK. It makes writing GTK applications a breeze.
PySoy is dead AFAIK. Panda3D has very good python integration much better than PyOgre. Ogre is a somewhat more modern engine, tho.
IoC is an useful idiom. Its in some ways an extension of the whole aspect oriented programming ideals. It can solve some problems, but overdone, it hides all useful knowledge of how a system works, relegating it to "black box" status. I think in the author's case, it can be justified (per object enforced permissions, for instance). 
Qt whenever I can, otherwise Gtk... but Qt is a lot more than a GUI toolkit.
Are Qt and Gtk really less portable than Tk?
Based on what I've read on the PyQt list, making the interface more Pythonic seems to be high on the todo list.
How is PyQt not free? I mean, it's free for free projects.
PyGtk: * very pythonic interface * relatively simple * good GUI builder * very portable when used with Python * used heavily by RedHat, and I suspect Canonical * simpler than PyQt as it's just GUI * sucks for use with py2exe * only looks native in Gnome * Gtk itself isn't as strongly support on Windows PyQt * unpythonic interface * good GUI builder (I think better than Gtk's) * very portable when used with Python * a lot more than just GUI interface * very looks native, at least on WinXP, KDE, and MacOS where I've tried the same app * supposedly easier to use with py2exe * stronger cross platform support * built in integration with things like Phonon and WebKit * also does some very cool 2D/3D interactions that I haven't seen in Gtk The first complete GUI app I did in Python was a small Point-of-sale app, which I developed and used entirely on Linux. A few months after I had forgotten about it, I needed it again, i was able to `svn co` the code onto my WinXP laptop, install Pyhton and the necessary Gtk libs and get the app running with no modifications. Gtk is LGPL I believe, so it's always libre and free. Qt is free for libre projects and requires licensing for commercial projects.
Not true. PyQt has its own [license](http://www.riverbankcomputing.co.uk/commercial/pyqt) Which means you might end up paying for two licenses if you are developing commercial app: Qt and PyQt because you don't have some stuffs and you want to extend with Qt itself. Well it's very complicated.
Free for *open source* projects, not *free* projects.
True. Your orginal statement suggested that it was completely unfree however. I haven't yet needed to write a free, non open source, to be distributed app.
These days, Qt and GTK+ run everywhere most people care about, but Tk was on Windows long before GTK+ was, and while Tk has been running natively (outside X11.app) on MacOS for ages I believe GTK+ has only just got a native port recently (I'm not sure, perhaps it's still under development). [Here's the list of supported Tk platforms](http://www.tcl.tk/software/tcltk/platforms.html)
It sounds like you know more than me. I'll have to check out the numpy approach you're describing. 
What with mod\_python development being just about dead and mod\_wsgi being this much faster, there's really no reason to still be using mod\_python (certainly for new projects).
Maybe \_backslashes\_ will do the trick? Edit: Yes, they do. Escape the underscores: \\\_
Strange then that the [django docs](http://docs.djangoproject.com/en/dev/faq/install/#do-i-have-to-use-mod-python) still say to use mod_python. Why do you say it's dead? (I use fastcgi because I knew it from before, so just interested)
Thanks.
Because they're outdated, I guess.
nevow stan is better, if you can generalize that. or elementtree, seems similar.
They recommended mod\_python because it's the most tested way of deploying Django. This will probably change when there's a little more experience with mod_wsgi. And they do say this &gt; mod_wsgi is a newcomer to the Python deployment world, but it’s rapidly gaining traction. Currently there’s a few hoops you have to jump through to use mod_wsgi with Django, but mod_wsgi tends to get rave reviews from those who use it.
The (scant) data presented in the article only suggests that mod\_wsgi is more lightweight, which is a definite win, but no evidence is presented that it is a better performer. Development on mod\_python has definitely slowed, but it is stable. It is the WSGI standard itself that has somewhat obsoleted mod\_python. While mod\_python has some WSGI support, it also carries a lot of extra baggage that a new player like mod\_wsgi can ignore. The real advantage is in coding to the WSGI standard, which can free an application from dependence on a specific module, HTTP server, or OS, thus improving portability.
Stable? I use it on a few legacy apps, but it's not exactly _stable_ for me.
Pete Shinners describes it here: [thread from gmane](http://thread.gmane.org/gmane.comp.python.pygame/1359/focus=1363) Good luck! I hope to hear about it on the mailing list.
why not use the "SQLAlchemy 0.5.0 Released" link: http://www.sqlalchemy.org/news.html#item_1
I've used mod\_python for several years, and it's always performed reliably and predictably (no crashes). Due to spurts in development, I'll admit it hasn't behaved consistently between versions, so I tend to use the latest stable version (or sometimes a development version for testing) on all of my machines. This is definitely a problem for projects intended for distribution. If this is what you mean by unstable, and are forced to support older and/or multiple versions packaged for various distributions, it's true that you are probably in for some pain. This is much of the appeal of WSGI.
I thought this particular write-up/overview was great, with screenshots: http://ginstrom.com/scribbles/2008/02/26/python-gui-programming-platforms-for-windows/ 
mod_wsgi can run a single multithreaded python interpreter in its own subprocess, insulated from the rest of the child forks in apache. the memory overhead of the interpreter is confined to that one fork, and you get multithreaded performance from it independent of MPM. therefore its a big big win.
Being lazy -- Anyone know if mod\_wsgi will work in shared hosting environments (unlike mod\_python). If my memory serves, its something about mod\_python always needing to run as a privileged user, thus giving it access to all accounts on the system. This is what Python really needs to be adopted by the small time bloggers of the world to catch up to PHP.
I filed a ticket about this yesterday after magus-(the blog post author) mentioned these benchmarks in IRC. Specifically the ticket adds documentation on using Django with mod_wsgi(which has been sorely missing).
For using pyGTK on windows and packaging with py2exe, I recommend this helpful blog post: http://unpythonic.blogspot.com/2007/07/pygtk-py2exe-and-inno-setup-for-single.html I was able to use this basic strategy for my own pygtk windows application http://rasm.ods.org/takenote . I was able to make an application that packages python and gtk within it so that users do not need to download/install any dependencies on windows.
I'll second that. Using wxPython on Windows with great results for different applications. They look great and native (unlike Tk's ugliness) and load quickly. wxPython is stable, has a good community and is well documented.
Pygame. Here's an ongoing tutorial: http://eli.thegreenplace.net/2008/12/13/writing-a-game-in-python-with-pygame-part-i/
Most embedded interpreters and other subprocesses run with the same privileges as the web server, which usually drops to a much less privileged user after launch. Since all code is running as the same user, it can access anything available to the web server user. PHP is also affected by this issue, and is one reason why virtual hosting is becoming more popular than simple shared hosting where multiple hosts share the same web server instance. The main advantage PHP has in shared hosting environments is that any change to code files is immediately reflected in the next page refresh. PHP developers typically need only an FTP account on the server, as long as PHP has been compiled with all of the necessary bells and whistles. Improvements have been made to mod\_python in this area, and even more in mod\_wsgi, but AFAIK both depend on the ability to flexibly configure the web server in a way that might conflict with the needs of other applications. Certain actions or configurations often require the web server to be restarted. Proprietary modules might need to be installed outside of the document root. Ultimately, this is much easier to achieve with a shell account and some degree of admin capability. Shared hosting isn't impossible, but I think most developers would find it too limiting, and some providers might find it requires too much customization. There's nothing preventing *software service providers* from offering shared applications built on these foundations, however. True small time bloggers don't care what technology their blog provider uses, for example. 
I use wxpython. I found it a lot easier to get going in then any of the other libraries, and the quality of the interface is nice, and you can expect it to have little features like status bar integration across platforms. (it's a bit fiddly, but far less than I expected) There are good books for it too. I used http://www.manning.com/rappin/. One thing that's not so good about it is that it doesn't work nicely with twisted which is one of the killer libraries for the platform. GTK seems the to be the recommended route for twisted lovers. I suspect you *could* get by with wxpython by using a lambda stunt in wx.Frame.OnTimer to regularly hand control back to the reactor. Ouch - jerky interface likely. Or you can resort to python threading, which kind of ruins the purpose. See http://twistedmatrix.com/projects/core/documentation/howto/choosing-reactor.html Unless... if anyone has some experience with combing wxpython and twisted I'd be interested to read of it. In particular, it would be great to have a library that abstracted all the threading coexistence of the two. I had a go and it didn't work out for me, but I was missing fundamental stuff about threads in python land. My gut feel is that someone who knew that world well wouldn't have too much difficulty. Barely related - another thing I'd like is a thicker curses layer that allowed me to knock together roguelikes by dealing with a very abstracted screen object. 
Same here. I've had numerous problems with deadlocks in mod_python which were not due to application code. I even had a script which would detect a deadlocked Apache, kill it, remove the SysV semaphores it left hanging around, and restart it. I used CherryPy and mod_proxy from that point onwards. The publisher module in mod_python is very similar to CherryPy's default dispatch system so the transition was very painless. 
Not really correct. As I wrote: when you write Free Software under the licenses that Qt has exceptions for, you can use PyQt under the same conditions (a friend of mine asked Riverbank). I didn't tell anything about propietary versions, because I just don't care. If you write propietary software, it's well possible that you pay twice. In that case it's your problem: either you pay for it twice or pay for Qt and write your own binding.
So? wxPython has been running on Windows, Linux, Mac and a few more for, like ages. And unlike Tk it did not look horribly because it could not antialias fonts.
Often times you don't need more and as far as I know PyQt does not wrap everything from Qt because Python has already other solutions to some of these things.
GTK also looks native on Windows, since it can use the Windows theming engine and on KDE, since there is an engine so you can use Qt themes. Oh, and Qt also recently got a GTK-Theming engines, so Qt apps can also look kinda native on GNOME and XFCE.
[Desktop applications. That's what Dabo does. It's not YAWF (yet another web framework). There are plenty of excellent web frameworks out there, so if that's what you are looking for, Dabo isn't for you. But there are almost no desktop application frameworks out there, and if you want to create applications that run on Windows, OS X or Linux, Dabo is for you!](http://dabodev.com/)
I have never seen a Gtk app look like native on Windows. Not apps I have done myself, or other known Gtk apps.
Tk comes with Python, PyQt (how'd they miss QtPy?) and PyGtk need to be added on separately. Not a huge deal, but it's nice that it's there already.
I've played around with cocos2d a bit: http://www.cocos2d.org/. It builds on top of pyglet, adding a director class to manage different scenes that you build (the main menu screen, game over screen, world 1 map, etc are examples of scenes) The director can create fancy transitions between scenes, and handles the order that they are presented, etc. It also provides a sprite class with some interesting transformation options. The documentation is decent, and the API seems pretty simple.
 * [Win 2000-Style](http://lyriki.com/images/5/58/Lyriki_rb_On_Windows_\(gtk\).png) * [Gnunet with XP-Style](http://gnunet.org/screenshots/gnunet-gtk-fs-status-winxp.png) * [PyGTK on Windows](http://www.learningpython.com/images/PyGTKWindows.png) * [GTK# on Windows](http://www.flickr.com/photos/michaeldominic/372018046/) Maybe they don't look 100% perfect native but that's well enough for me and most users and about 200% better than Tk. I don't know how native Qt4 looks on Windows, because it used to look foreign, with a bad imitation of Windows 2000 Style controls, but maybe it's better now. I don't have Windows, funtunately it is not my problem anymore.
Those screenshots (considering them being purely screenshots) look okay. Though Qt apps still seem better. I'll have to try out one of those apps some time. &gt; I don't have Windows, funtunately it is not my problem anymore True that.
I too use wxPython on Windows. It's great but not perfect. I've come across plenty of bugs and limitations that have to be worked around. Also, it's sometimes not very performant. I'd still recommend it over the other GUI kits that I've tried. If on Windows, consider trying out IronPython for the much better .NET GUI libraries.
&gt; Though Qt apps still seem better. Do you have some screenshots so I could judge for myself? :)
Another data point -- me and my day job -- sez: mod\_wsgi is good stuff. Using mod\_python occasionally results in both odd performance situations (resource spikes) and odd bugs (e.g., leaking data across virtual hosts running the same software with different config). Using mod\_wsgi makes these issues go away: the resource usage basically becomes a nice flat line (provided traffic stays relatively constant -- traffic spikes, of course, change things) and the ability to isolate subinterpreters prevents the other bugs (the biggest culprits, btw, tend to be C extensions -- if you've ever seen a `class decimal.Decimal is not class decimal.Decimal` error bubbling out of mod\_python you probably know what I'm talking about).
Good point: VLC is the first that comes to mind. I believe believe Google Earth as well. But this a more authoritative source: http://trolltech.com/qt-in-use
lmao, the programmer for that cracks me up, his noises in the videos are hilarious. Thanks for that link, looks very useful as scene manipulation was one of the things I was looking for
I've read both of those (and the pygame book), but I want to learn more about how to create multiple scenes... and things such as game menus and what not, both of which aren't covered in either your tutorial (yet? :)) or the pygame book
Thanks, I had forgotten the name for Panda3d, remember checking it out a while back when I was first learning about python. I'm looking for more 2d stuff for now though until I get a better grasp on python
Thanks for the links to Opiod2D and the pygame libraries. I'd forgotten about Rabbyt as well... soo many choices out there and thats the reason I made this post, to find out which were the good ones to use as they all have different coding styles, I don't want to pick the "wrong" one. Since you are looking for a well documented library, check out the one I found previously: gameEngine (http://www.cs.iupui.edu/~aharris/pygame/) It has good documentation and some examples as well, let me know what you think about it and what else you'd recommend.
Thanks, but no An iPod is an end-user machine, I'm a developer. I'd rather something a bit more linuxy
I host myself, I recommend getting a small VPS for yourself to learn how to setup the environment. Spry / VPSLink.com or even MediaTemple has them for pretty cheap nowadays.
For VPSes I hear good things about slicehost. For shared hosting, I've heard good things about webfaction.
This is probably the best possible explanation I could have hoped for. Thanks so much. :)
VPSlink.com is slightly better than slicehost i find.
Slicehost or Linode are your best bets in my opinion. I use Slicehost but I've heard very good things about Linode (mainly that's it's cheaper)
I came here to say the exact same thing. Slicehost has been good to me for a year and a half, never had any issues. WebFaction i used for a bit and they were great as well. I've also played with dotster, vpsland, vpslink, dreamhost, and hostgator. The only acceptable option in that last list is hostgator, if you need static pages and tons of bandwidth.
I've been on [Linode](http://www.linode.com) for about 6 months now - it's been totally great. They have a great web panel for viewing server stats and doing low-level admin, plus an ajax console in case you lock yourself out. Speedy, good value for money and great uptime.
Webfaction I've been using it for over a year now to host some Django instances. In the case of Django they actually give you your own Apache instance that runs as your user, so you have full control of it. Nice. Plus it's a shell account with ssh login. They provide basic dev tools. I've actually built some source packages that the server didn't provide. Oh, and it's very inexpensive for the freedom and resources you get with the account.
I work at [Internet Connection](http://www.internetconnection.net/), and so I recommend myself. We *do* offer VPSs, but we also offer a number of things in-between VPSs and shared-hosting accounts. For example, we make it possible to run your own (non-apache) webserver (including djago's built-in one). Programs like mysql and postgres are installable, packaged, and preconfigured to run inside `$HOME` so that you can use unix-domain sockets, rather than run the risk of the current mysql worms rooting your database. All of our hosting accounts have a static-IP, and our support desk actually includes people who program regularly, so you can actually get help with non-install issues like implementation advice. Our mail servers use your address as well, which minimizes your changes of getting blocked by other users on our network. Likewise, anything you're doing won't affect our other customers. Our current mail-load is around 120m deliveries per month, which is about 10% of our capacity. Your long-running services don't have to get started by cron, but can be started by supervice/daemontools under your account. This also keeps your process running if it crashes, segfaults, whatever. Our VPS platforms are kvm-based (not-Xen) which is important as Xen isn't in the kernel, so patches and fixes may take several days before the host can get them included. You can call us toll free, email us, whatever. We do offer demo accounts, and we do offer a money-back guarantee. We've been around since 1994 (!), which is an eternity in hosting-years, and we're likely to be around another 15 years or more...
I don't think my comment on his site when through, so I'll put it here. Why not just do this &gt;class Test(object): &gt; pass &gt; &gt;i = Test() &gt; &gt;i.foo() #doesn't exist yet, errors &gt; &gt;def abc(self): &gt; print "foo" &gt; &gt;Test.foo = abc #assign to class &gt; &gt;i.foo() #works
i'm using webfaction since quite a while. it's cheap, realiable and has a lot of ready-to-go tools you can setup with a few clicks (django, ...). the turndown is the memory-limit of just a few MB, if you get over it your apache instance is turned off, and furthermore the speed is really not the best... i'm mainly using it for a quick example-setups for customers and tests...
but django tends to consume some MB's of ram, and the packages typically include just a few of them... i used to often reach the top limits of memory usage with django instances, what results in an automatic stop of your apache instance.
If you're on OSX, use cocoa. Otherwise, use GTK or wxwidgets.
Amazon ec2
I'll basically echo this as I have experience with both. We use slicehost (many slices worth) at work and love it (primarily a Django shop) I'll also add that I just signed up for webfaction and the support has been incredible ("oh yeah we've been meaning to add git, we'll get right on that" and similar replies) haven't done much with the python support yet but they did have Python 2.6 and 3.0 insanely fast (maybe 2 days?) and they were formerly python-hosting.com 
shared hosting: webfaction VPS: Linode
Slicehost.
linode is excellent
 " ".join(title.split()[:-1])
Google AppEngine: http://appspot.com/
Definitely not Joyent. Unless you want to roll with older python stuff 2.4 without hassle. I had to wrestle with it for days to get 2.5 and Django setup and had to build many libraries on the accelerator. You'd think they would be up on this, support for AT LEAST 2.5 easily. Joyent isn't that python friendly. I wish it were different. I second webfaction if you have to go shared hosting/vps. And dedicated is probably the best way but slicehost, ec2, etc where you can setup what you need and have control to do so. Same goes for Ruby hosting.
I love some Slicehost. I've been with them for a little over a year now with not a single complaint.
 print reduce(lambda x, y: "%s\n%s" % (x,y), ["%d. %s" % (x + 1, s) for x, s in enumerate(["Learn Python", "Subscribe to Python subreddit", "Post obscure programming jokes", "...", "Profit"]) ]) 
This site might be good to take a look at: http://djangofriendly.com/hosts/ 
 print '\n'.join(["%d. %s" % (i + 1, s) for i, s in enumerate(["Learn Python", "Subscribe to Python subreddit", "Post obscure programming jokes", "...", "Profit"])])
I see what I did there. 
I see what I did there -- in less characters.
'fewer' is more characters than 'less', but at least it's correct.
Just so we both know what we did here: I was deliberately using baroque Python. Using a simple for loop would be way easier to read and shorter too. for i,s in enumerate(['blah']): print "%d. %s" % (i, s) 
I've heard so much bashing about MySQL from the django/python community that I think I'm going to use PostreSQL for my next project. Not dumping MySQL entirely, but it'd be nice to learn something new just incase things get worse
i had no idea MySQLdb leaked. That explains a lot - tsk!!
Yay, I like that series. Definitely a good start for Pygame.
(Sorry your comment got eaten by my spam filter. I dug it out of Akismet.) That works, but it monkey patches the class. So: &gt; j = Test() &gt; j.foo() # works I only wanted to add the method to the particular &lt;em&gt;instance&lt;/em&gt;. FYI, I'm subclassing optparse.OptionParser and required changes to optparse.HelpFormatter. Instead of monkey patching or requiring the client to pass in a specific HelpFormatter subclass, I check the formatter dynamically and inject the needed methods. Other suggestions welcome.
[pyglet](http://www.pyglet.org/).
I have developed with all of the ones you mentioned. Pyglet is my choice, now.
I am using cocos2d on the iphone. It is a python framework that utilizes chipmunk physics and is atop opengl. (of course I am using objC)
Pyglet seems to be the trendy choice, but I'm not really such a fan. I'd go with pygame + pyopenGL. For fanciness (gl extensions) forget glew/glewpy, use gl.platform from pyopengl. For vector graphics, I've heard Cairo is a good choice, but I've used pyAmanith with great success. Good luck!
The author (Andy Dustman) had a serious illness a while ago (IIRC). I've tried several times to offer my help and bring things forward (including submitting bugs and patches), but he seems to want to either continue work himself or hand it off to the MySQL people for further development.
i took the cheapest one i could find: [djangohosting.com!](http://djangohosting.ch/) and had no issues whatsoever. 60mb might be too low for some apps but for me its been just fine.
cocos2d is based on pyglet
Well, everything is based on *something* else. It is nice to know. Then I can reference that documentation also!
Get me repro steps via the [MySQLdb project page](http://sourceforge.net/projects/mysql-python), and I'll submit a patch.
Pyglet is what the cool kids are using, but I've only tried Panda3D. Panda is really a very comprehensive library, not just for 3D graphics but also for agents and more.
In general I'd recommend pyglet. However for prototyping games I've been using the Blender Game Engine lately. It's really interesting, and has python support, but probably not in ways that most python users would find pythonic. Nonetheless, really fast for creating small games or prototyping stuff. Check out Yo Frankie (http://yofrankie.org) for a good example of a more complex blender game engine game.
Here: http://www.reddit.com/r/Python/comments/7nvns/help_python_masters_what_to_use_for_game/ is a similar post I made a few days ago that might have some other suggestions.
pyglet is cool, but it's only a lib. it is not a complete game engine. you need panda3D or pyOgre. pyOgre is a bit new, so Panda3d edit : its python-Ogre, not PyOgre (an older quite project with the same goals).
PyOgre is dead. Python-Ogre is what it officially became but its cross-platform support is... not so great, really. Their installation procedure requires you to compile all necessary packages locally, even if you already have them. But I agree, Ogre is an amazing engine.
I saw that one actually, but if you are asking for game programming in general, Pygame is pretty much the default (and I'm using it with great glee). But this post is for 3D stuff rather than boring 2D :)
A good example of a web application based on [Werkzeug](http://dev.pocoo.org/projects/werkzeug/).
You can use PyGame for 3d as well, its (slightly) covered in the Pygame Book that I read. (From beginner to Pro(hardly :P)). Panda3d looks the most impressive and has both school and Disney following.
How is Panda3d for 2d games? or 2dish games like Warcraft style.
It's a nice app. It's too bad Python is so much more expensive to host than PHP.
linux VPS's are running as little as 6.95/mo these days. You can pretty much do what you want within the available memory/cpu constraints.
Webfaction is cheap *and* better... I don't that Python is more expensive these days. 
frankly, I see this as an interesting exercise of python web apps. Other than that, why would anyone want to use a duplicate of WordPress, which is easier to deploy, more widespread and probably more stable. If you want to implement a new blog engine at this time, after others have proven themselves, you have to have more attractive features and reasons other than that it's based on Python.
I think you underestimate how much people dislike PHP.
Sweet
[Mascot](http://blog.kevinmeltzer.com/archives/droopy.jpg)
I don't. I do think, however, many more choose a project because of convenience instead of theoretical purity. 
This sounds excellent.
it can talk to a large number of databases, including mysql, postgres, oracle, MSSQL, sqlite, firebird, DB2, MaxDB, etc. User-defined themes can use a coarse grained interface to determine how many SQL roundtrips to the database are needed for various views. [link](http://lucumr.pocoo.org/2009/1/1/sql-optimizations-for-zine-0-2) Generally its a much more interesting platform to expand from.
I'm tired of reading Simionato's pedantic righteous crap about patterns. This is like reading some idiot java developer's rants about how he wants private and protected attributes in python. 
plus the fanbois -for which python particularly destacates- they'll use it no matter how bad could be and even claim it to be the quintessencial truth (bonus if it resembles django). disclaimer: I'm not implying this "zine" to be good or bad.
Bah. I missed the *instance only* part of your post. Thanks for the info. I'm sure I'll be using it sooner or later.
If you are a nonprogrammer who wants to learn programming and you've chosen Python as your first language, I'd like to plug my free book [Invent Your Own Computer Games with Python](http://pythonbook.coffeeghost.net) While many books go through a bunch of syntax and reference material, this book focuses on complete examples of small games. Each chapter starts with the full source code for a simple game, and then explains the programming concepts from the example. It's completely free under a creative commons license.
just finished with Mark Lutz's _Learning Python_, O'Reilly, 2008. Typed in and ran all the example code and worked the end-of-section exercises. Yes, I recommend it. 4-1/2 stars. 1/2 star deducted for the clunky corporate-speak. It's noticeable, but not so bad that I ever considered abandoning the book. I had seen it in bookstores for years before getting serious about Python and always thought it was the "lite" version. The same author has a more advanced book _Programming Python_. After all, I ain't no newbie. :-) Now I'm glad I started with _Learning_, because Python is sufficiently different than C, Perl, PHP, etc. Your mileage may vary. HTH. P.S. Python *rocks*! 
The [Python website](http://www.python.org/) has a heap of resources. Depending on your programming experience, you could start by looking at [Non-Programmer Beginners' Guide](http://wiki.python.org/moin/BeginnersGuide/NonProgrammers) page or the [Programmer Beginners' Guide](http://wiki.python.org/moin/BeginnersGuide/Programmers) page.
Frankly the [Python Tutorial](http://docs.python.org/tutorial/) is pretty good, and doesn't cost you anything. 
&gt;plus the fanbois -for which python particularly destacates- they'll use it no matter how bad could be and even claim it to be the quintessencial truth Can't agree here. No one bashes zope more than those Python fanbois. Edit: In the end people will just do what they are doing now; evaluate it and use it or go back to building their custom solutions.
Byte of python! http://www.ibiblio.org/swaroopch/byteofpython/read/
and it covers everything which most of other tutorials is not so complete. After reading some python intro books(like DiveIntoPython, Programming Python, etc.), I finally start reading Python Tutorial again.
Bought both books (Learning &amp; Programming) and couldn't be happier.
Define "beginner".
You're beginning to suspect that you're in a difference universe when you see people who think that XML is just a way to store ascii key/value pairs in arbitrary order. And you *know* you're in a different universe when you see things like: &gt; I’m not entirely convinced that the module should be escaping xml, but I agree that it would be simpler for the user. (Let's pray those guys don't write software that someone else has to use, or software that produces files that someone else have to read.)
I read the previous edition of *Learning Python*. Highly recommended. Only complaint was his discouraging the use of list comprehensions (which he may no longer do in the newest edition). I wouldn't go for *Dive Into Python* unless you're fairly confident about your programming skills. It moves quite fast for a beginner, and some of its syntax is old. 
it is a bit strange but, and too early for you, for me, the best python book was a lisp book (The Graham). I knew the syntax but I couldn't get the agility that good pythoneers always talk of. I was stuck in the C-mindset (a bit expanded but still limiting), I didn't see the point. As Python is Lisp in friendly clothes, Getting the lisp-mindset was the best to happen to my python coding skills. 
it is focused on 3D but is able to make 2d game very easily. Note also that a lot of nice effects are easy to do in a 3D world even if the gamefield is in 2D. Think some camera moves, etc. A lot of games use this. (Wario shake for example) My advice would be gamelogic in 2D but display in 3D.
I am reading this book right now (about 3/4 through) and it is a really good book. The only experience I have is JavaScript and... PHP. I feel that I would have easily understood Python without these.
I heard that [Python Programming in Context](http://www.amazon.com/Python-Programming-Context-Bradley-Miller/dp/0763746029) is good. Covers Python 3.
Since Dive into Python was mentioned, it is free online: http://diveintopython.org/
_Learning Python_ is great for advanced beginners (after the `python.org` turorial of course). It is a bit slow for coders already competent in another language, but I don't think there's anything better. It is unfortunate that Lutz's other book, _Programming Python_, is still in print, since it confuses potential buyers of _Learning Python_. For someone who would rather learn in context, I would recommend _Python Programming in Context_ instead. _Dive Into Python_ needs to be updated. Then, it might be another good choice.
Speaking of O'Reilly books, I think their _Python Cookbook_ is the ideal second book on Python. (_Learning Python_ was my first too.) I learned more about common Pythonic idioms from the cookbook than from anywhere else.
The book I learned Python was written so well I couldn't put it down, and it made me want to program even when I didn't have to. It's very clear, fun, and takes you from knowing nothing about programming to doing anything you want in Python. It's called __Beginning Python: From Novice to Professional__. However, the version I read initally was published in 2002, and recently I looked through the new edition. It is not as fun or clear as the version I used, but it isn't too bad. So, you could go one of two ways. You could learn off the 2002 edition and then read tutorials on the changes since then, or you could go straight for the new edition. Since the new edition is on Python 2.6, and you'll probably program in the newly-released Python3k, I don't think it would be bad to use the 2002 edition.
I have the Python Cookbook as well and was woefully disappointed that it isn't nearly the same quality as their perl and PHP cookbooks.
Thanks for this! I'm just learning Python as well, and based on a quick look, I really like the way this is written. I think I found a typo in the Ceasar Cipher chapter. In the section on the chr() and ord() Functions, I think you mixed up what chr() and ord() do. You're examples are correct, but I think this description is backwards: *The chr() function (short for "character") takes a single-character string for the parameter, and returns the integer ASCII number for that string. The ord() function (short for "ordinal") takes an integer for the parameter, and returns the ASCII letter for that number.*
I just learned Python 3.0 with the [official documentation](http://docs.python.org/3.0/); it really is excellent. I already had experience with Java (doing pretty well in my AP Computer Science class (124% (down from 192% earlier this quarter)) (second year of Java)), so I don't know how you'd fare going into it with no programming experience, but IMO it is top notch. The great thing is that it's downloadable, so you can use it even when you're offline (in my case, I learned it during a three-hour car drive and continued during the next week or so with more Python 3.0 and PyQt4). If you really want it in book format, I'm sure you could just send the PDF version to a printer.
Try http://www.pythonchallenge.com and read the solutions after solving each level 
(Adds to Amazon list)
[*Python for Software Design*](http://www.greenteapress.com/thinkpython/), which used to be *How to Think Like a Computer Scientist: Learning with Python* is a pretty good book for a beginner. The draft, *Think Python* is available for free.
To get an account on Reddit and see how scalable Python is.
Easy: respond that _no_ language was, because no language has a magic "scaling feature" built in. It's hard work no matter what you're working with.
That statement is so vague and meaningless that the only possible response is not to respond, the questioner is not worth you wasting your time. Does that person have actual, precise issues with Python?
Why do they think it's not maintainable? Because it's dynamically typed and they've only ever written java? The scalability thing I just don't get. Scaling is about architecture, not code.
And when he complains about all the "You broke reddit!" screens?
Hah! Yes, exactly. Plus issues with class-per-file vs. multiple-classes-per-module. Java's rigidity seems to make people distrust anything that gives a programmer an inch of freedom..
I bought this and it's utterly fantastic. I only wish it would have been longer so it could have covered writing C extensions.
Not only is sqlalchemy ungodly good, but Bayer I think employs people to answer questions in his name on the newsgroup because he's easily the most responsive and helpful author of a major tool i've ever seen.
I am not sure it's a scalability problem. Do you have any proof?
Dive into Python is old.
&gt; Dive into Python is old. So is SICP, and yet people still think _that's_ a great book for programmers.
&gt; It moves quite fast for a beginner, and some of its syntax is old. All of its syntax still works on the latest 2.x Python, which is what a Python beginner ought to be using...
My point is that OP should learn from the current state of the art. I think people recommend these books because everybody else does. I have read Dive into Python, I don't think I will read it again. Oh yes, you mentioned SICP. If there was anything better than it, it would have been the obvious choice. There is better than Dive into Python.
Basic PHP and Javascript knowledge is pretty much it.
None at all. But someone who is prone to making baseless statements about Python isn't going to be convinced about its scalability if the site shows sad aliens frequently unless you have a reasonable explanation prepared. 
&gt; My point is that OP should learn from the current state of the art. Dive Into Python does a good job of that; there have been a few new features in Python which change the way you write code in certain circumstances, but they just aren't numerous enough to make a big difference. And it does a good job of covering practical topics that really matter to becoming a productive Python programmer (such as the mindset and style of good Python code).
If you're interested in gaming at all, I encourage you to look into Game Programming - the L Line. It's really more about game programming than Python, but the examples are in Python and the first four chapters teach Python from the beginning. A video course with everything in the book is available for free from my web site: http://www.aharrisbooks.net
I used that book too. I found it incredibly easy to read. I have an edition on Python 3.0, however. I had an eBook version of the original, and used that to get started in Python. I eventually purchased a copy that ended up being the 3.0 version. Either way, I agree. I second that book!
Couldn't agree more. I'd answer more often but he's so damn fast and helpful there's no way to compete. Mike Bayer is definitely an example of open source done right.
[Python version of How to think Like a Computer Scientist.](http://www.openbookproject.net//thinkCSpy/) It's an introduction to programming using Python.
&gt;All of its syntax still works on the latest 2.x Python, which is what a Python beginner ought to be using... True, but I feel some of the newer syntax is more expressive...
punch him for being a real-world troll?
gst is getting better and better.
very neat application to put your werkzeug/jinja2 apps to google app engine
can't wait for 3.1. Isn't there a rewrite of some of the core code going on right now? will that be in 3.1?
Will they do it live?
Try Postgres. It is eye opening to just try something different. I like to bash MySQL. It does have its faults. A lot of them are cultural development team faults (features over bugs and design). 
I'd agree. It's a very well written book.
Here's how I learned Python: I read the [Discover Python](http://www.ibm.com/developerworks/views/opensource/libraryview.jsp?search_by=discover+python) series to start. It took me a little over a day to read all the articles. Next, I read [Dive Into Python](http://www.DiveIntoPython.org) which is a deeper, computer sciencey introduction to the language. I'd also recommend _Beginning Python: From Novice to Professional_. It has a bunch of projects in it to get you really well-versed in the language.
[see here](http://sourceforge.net/tracker/index.php?func=detail&amp;aid=2125250&amp;group_id=22307&amp;atid=374932) Any time you query a table containing unicode strings (and using utf8 encoding on the cursor), you'll leak a little bit. I looked into it and worked around the bug by fiddling around line 204 [here](http://mysql-python.svn.sourceforge.net/viewvc/mysql-python/branches/MySQLdb-1.2/MySQLdb/MySQLdb/connections.py?revision=559&amp;view=markup), removing the list of converters and setting the string_decoder function directly. The leak is in the C layer and is probably caused by passing around references to the converter dict, which contains functions as values. Anyway, I don't have my patched version handy, but I can submit the diff if you're interested. 
I'm going into withdrawals without docs.python.org :( EDIT: Of course, practically as soon as I post this it's back. YAY! Anyone happen to know why it was down?
BOFH excuse #152: My pony-tail hit the on/off switch on the power strip. 
I started out with Dive into Python. It's nice as long as you're just reading/following along, but it's instantly useless when you start programming on your own and trying to use it as a reference. 
Yes.
strange indeed, but this surely exists in pypi or in a one of the web framework/template engine.
API for i86 Linux works ok. But this example on Windows still has a dependency on an unstable/problematic version of the rdflib package. Others have encountered the rdflib dependency problem and some report successful workarounds. I have not gotten this to work yet. http://alimanfoo.wordpress.com/2008/04/12/installing-rdflib-on-windows-and-making-it-work-with-pydev/ I would kindly suggest someone at OpenCalais fix the Windows version before posting the Python example again. If you follow the GoogleDev instructions, here's what you eventually end up with when it tries to install rdflib: running build_ext Traceback (most recent call last): File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setup.py", line 56, in &lt;module&gt; 'EARLPlugin = rdflib_tools.EARLPlugin:EARLPlugin', File "G:\Python25\lib\distutils\core.py", line 151, in setup dist.run_commands() File "G:\Python25\lib\distutils\dist.py", line 974, in run_commands self.run_command(cmd) File "G:\Python25\lib\distutils\dist.py", line 994, in run_command cmd_obj.run() File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setuptools-0.6c5-py2.5.egg\setuptools\command\install.py", line 76, in run File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setuptools-0.6c5-py2.5.egg\setuptools\command\install.py", line 92, in do_egg_install File "G:\Python25\lib\distutils\cmd.py", line 333, in run_command self.distribution.run_command(command) File "G:\Python25\lib\distutils\dist.py", line 994, in run_command cmd_obj.run() File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setuptools-0.6c5-py2.5.egg\setuptools\command\bdist_egg.py", line 174, in run File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setuptools-0.6c5-py2.5.egg\setuptools\command\bdist_egg.py", line 161, in call_command File "G:\Python25\lib\distutils\cmd.py", line 333, in run_command self.distribution.run_command(command) File "G:\Python25\lib\distutils\dist.py", line 994, in run_command cmd_obj.run() File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setuptools-0.6c5-py2.5.egg\setuptools\command\install_lib.py", line 20, in run File "G:\Python25\lib\distutils\command\install_lib.py", line 112, in build self.run_command('build_ext') File "G:\Python25\lib\distutils\cmd.py", line 333, in run_command self.distribution.run_command(command) File "G:\Python25\lib\distutils\dist.py", line 994, in run_command cmd_obj.run() File "G:\Python25\Lib\site-packages\rdflib-2.4.0\setuptools-0.6c5-py2.5.egg\setuptools\command\build_ext.py", line 46, in run File "G:\Python25\lib\distutils\command\build_ext.py", line 255, in run force=self.force) File "G:\Python25\lib\distutils\ccompiler.py", line 1175, in new_compiler return klass (None, dry_run, force) File "G:\Python25\lib\distutils\cygwinccompiler.py", line 292, in __init__ CygwinCCompiler.__init__ (self, verbose, dry_run, force) File "G:\Python25\lib\distutils\cygwinccompiler.py", line 84, in __init__ get_versions() File "G:\Python25\lib\distutils\cygwinccompiler.py", line 424, in get_versions ld_version = StrictVersion(result.group(1)) File "G:\Python25\lib\distutils\version.py", line 40, in __init__ self.parse(vstring) File "G:\Python25\lib\distutils\version.py", line 107, in parse raise ValueError, "invalid version number '%s'" % vstring ValueError: invalid version number '2.18.50.20080625' 
There were a few of these available in the early days, but they never really caught on. My guess is that they don't really buy you that much over string formatting combined with a simple helper: def esc(s): return cgi.escape(s).encode("utf-8") # or .encode("ascii", "xmlcharrefreplace") if you prefer print "&lt;tag&gt;", esc(text), "&lt;/tag&gt;" for simple cases. And for more complex applications, we already have roughly four million different templating libraries available. (fwiw, both lxml and ET supports the syntax used in that article, based on this little utility: http://effbot.org/zone/element-builder.htm and the HTML tag generator found [here](http://svn.effbot.org/public/stuff/sandbox/elementlib/makehtml.py). lxml and ET 1.3 also have HTML4 serializers.)
doesn't this harp back to the idea: create DOM in python, pass to the browser (using HTML, XML, RSS etc) verses use HTML templates and the MVC. DOM is for coders. Templates is for designers (and big companies with teams of more than one person)
sorry but i'm a bit of a newbie with all of this: how do scipy and numpy relate? are they distinct modules or does one incorporate the other?
I've built and used similar systems in the past and I have to report that there are reasons why you might not actually want to do that. The main one is that having the HTML structure hard-wired in your code means your logic and the formatting are commingled in a way that makes editing either of them difficult later. If you really want to assemble documents element-by-element, Elementtree is probably the way to go. Otherwise I would suggest one of the XML-savvy template libraries like Genshi.
Personally I consider such systems pure evil. Resulting pages are complex and difficult to maintain- I like to be able to see and edit the markup directly. You should be using a templating engine. (I recomment ZPT for Python). 
Go to [SciPy homepage](http://www.scipy.org/), where first lump of text you see says: &gt; SciPy (pronounced "Sigh Pie") is open-source software for mathematics, science, and engineering. It is also the name of a very popular conference on scientific programming with Python. **The SciPy library depends on NumPy**, which provides convenient and fast N-dimensional array manipulation. The SciPy library is built to work with NumPy arrays, and provides many user-friendly and efficient numerical routines such as routines for numerical integration and optimization. Together, they run on all popular operating systems, are quick to install, and are free of charge. NumPy and SciPy are easy to use, but powerful enough to be depended upon by some of the world's leading scientists and engineers. If you need to manipulate numbers on a computer and display or publish the results, give SciPy a try! 
I am all for logic should be separated from code, just à la Django way.
Numpy provides array and matrix abilities, among other basic things. Scipy is a bunch of libraries geared towards actual computation: Calculating condition numbers, numerical integration, interpolation, etc. Actually, Numpy provides some of those as well, but I think the long term goal is that Numpy simply provide the basic framework, and Scipy provide the rest. 
really looking forward to see a Python module dependency visualization. hehe.
This is one of the modules that needs to be ported to Python 3.0 before 3.0 will be the "main" Python version.
 &gt;&gt;&gt; from lxml.html.builder import E &gt;&gt;&gt; tree = E.html( E.head( E.title('title') ), E.body() ) &gt;&gt;&gt; from lxml import etree &gt;&gt;&gt; etree.tostring(tree, method='html') '&lt;html&gt;&lt;head&gt;&lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;' &gt;&gt;&gt; 
&gt; 124% (down from 192% earlier this quarter) Ahhh once again, reminding me of why AP grades counted for exactly zilch when I still worked in college admissions...
I would say this is _almost_ an excellent point. Saying that python is Lisp in friendly clothes is not quite correct (and disingenuous to arguments for either language), but you are capturing one key argument: Python is highly expressive and allows you to do things in a functional way. In other words, you get to sort of mix-and-match pieces of functional-ish code inside imperative code. Semantically, this has no meaning: int i; for(i=0; i&lt;N; i++) { anewlist[i] = alist[i]++; } since you push around too many bytes. If you've never seen C, or you don't know how a _for_ loop works, you're lost (and might not see the potential problem). Try this on for size: anewlist = list(i+1 for i in alist) Just read it aloud and you have a pretty good idea of semantically what's going on. Compare back to the C example, and without an entire course in C, you wouldn't understand why its result is different.
I have to agree here... the _Cookbook_ is nice for some things, but there is a lot of code that I read from there that just makes me cringe.
Actually, I just did really well; that was nowhere near the norm (lowest was I think ~30%; average was a B). The main reason my grade was so high was that the teacher assigned us to do [JavaBat](http://javabat.com) programs from a few different sections (generally ~5 per section, which contain anywhere from 9 to 30 programs and were graded differently depending on their difficulty). Well, I got bored one day and just went ahead and did all of them (except some really early/basic ones), including stuff we hadn't even learned yet (recursion). Little did I know that each extra problem would count for extra credit equivalent to what each required problem was worth, causing me to end up with 360%, 450%, 540%, and 1500% lab grades; counting up just the points, I could essentially not shown up for the rest of the quarter (not taken any tests, done any labs, homework, etc.) and ended up with over 100%, or at least an A (&gt;= 94% at my school). I'll post back later with a scanned copy of my grades if anyone's interested (you'll notice that I stopped caring about doing any work after this point, and indeed have a depressing amount of 0s).
**P**robably **e**xisting **b**ackup **k**eyword **a**ccess **c**ollisions
Oh. Hai. I did link to that one like 10 hours ago ;-) For extra bonus, bind E.html and friends to module-level variables, and you can has the syntax in the article.
abso-freaking-lutely!
Building full pages in code is pretty much insane. Building fragments to use in full pages isn't quite as bad, and is sometimes a really good idea. HTML is a hierarchical format, after all, and structuring your code in the same way can work really well. It all depends on what you do.
Extracting dependency information from pypi.python.org looks nontrivial. On Debian you can easily graph the subset of modules that Debian has packaged: (echo 'digraph {'; apt-cache search python | grep ^python- | (while read a x; do aa=`echo $a | cut -d'-' -f2-`; apt-cache depends $a | grep '^ Depends: python-' | (while read y b; do bb=`echo $b | cut -d'-' -f2-`; echo \"$aa\" '-&gt;' \"$bb\"; done); done); echo '}') | dot -Tps &gt; python-deps.ps
this is wonderful. now, what is it actually good for?
Damn! I click this hoping to see Sup Guys I'm lernin Python, it's sooo cash.
via: http://pyre.third-bit.com/blog/archives/1901.html
Wow! Thanks. I'll try it out
I'm sorry, I can't hear you over the cash, blow and hoes that come with python.
This is excellent. Since many people will be using both 2.6 and 3.0 into the near future its great to be able to choose which one on a per-project basis. 
What's one do with cash, blow and hoes (whatever they are)? I got a pony.
I have tried PyDev and it's great. But I find an IDE overkill for much of my proejcts so far.
Cash, blow and hoes make you fly. Being fly is cash. It's recursive and if you let it run all the way results in the value 42.
This is a remarkably good read, even if you read the first version of this (http://www.dabeaz.com/generators/). Beazley is one of the best python programmers out there, and even though I've been using Python for 10 years now, I learned some new tricks by reading through his examples. 
This really reminds me of Haskell's list comprehensions combined with lazy evaluation. Glad to see that it's applicable in Python as well.
IIRC, Python list comprehensions were influenced heavily by Haskell.
Influence? =) Guido says himself it is more than just influence. ;)
 &gt;&gt;&gt; sys.getrecursionlimit() 'Life, the Universe, and Everything' Huh, never noticed that before. 
Very elegant. 
I did say 'heavily influenced'. It sounded better than 'stolen'. ;-) Actually I couldn't find exact reference that you speak of even though I know it exists. It's not in the PEP.
Can I sum things, though? I don't see anything on this.
[Sure can](http://docs.djangoproject.com/en/dev/ref/models/querysets/#aggregation-functions) * Avg * Count * Max * Min * StdDev * Sum * Variance
That's what I was looking for but couldn't find, thank you!
You can count on it.
&gt; len() should be a method on collections, not a built-in. my_collection.__len__() knock yourself out. &gt; The GIL sucks, and it’s going to get suckier until someone fixes it, and that will be hard. Waaah waaaah wahhhh &gt; (Mutable) default arguments are shared across function invocations: def foo(bar=[]). No. This would require changing severe parts of the interpreter, and re-initializing default arguments at each method invocation (unless you have some magical way to determine whether a user-created object is mutable or not) &gt; This one nails newbies all the time. Too bad. &gt; (1) != (1,) — the first is an integer, and the second a singleton tuple. So what? `1` is an integer, `1.` is a float and `1,` is a tuple. Still, so what? You're stupid and still don't understand that parens are irrelevant and the comma `,` is Python's tuple operator? Sucks to be you. &gt; 2\*\*29 in xrange(2**30) should return instantly, like it does in Ruby, rather than iterating up to 2\*\*29. In other words, range objects should have basic knowledge of their endpoints. Python doesn't have range objects. &gt; Decorator syntax is ugly and un-Pythonic. If I wanted @ signs all over my code I would be using Perl. I like it. &gt; No support for labeled break and continue. I continue to respectfully disagree with the rejection of my PEP. Whine about something that looks somewhat Perlish, and in the next item whine that you don't get a feature from Perl. Perfectly coherent. &gt; There’s a copy() method on the mutable dict and set types, but not one on list — the best solution is to write foo[:], which is cryptic at best. `list(foo)` also works. Considering that `dict(foo)` duplicates a dict (or creates one from an existing mapping) and `set(foo)` duplicates a set (or creates one from an existing iterable), I don't think I've ever used `copy()`
blah.length makes more sense, len() is a weird special case. The GIL really does suck. Multithreading is becoming more and more important, though the "multiprocess" module is making this somewhat better. I'm not sure if the decorator syntax is good or bad -- it's ugly, for sure, but sometimes that's a good thing.
&gt; Whine about something that looks somewhat Perlish, and in the next item whine that you don't get a feature from Perl. Perfectly coherent. In your enthusiasm to respond to every point you've gone a bit too far. There's no conflict between disliking the look of Perl and wanting a feature that exists in Perl. For one thing, labeled break and continue exists in lots of other languages. For another, try a thought experiment: suppose Python lacked arithmetic operators like +. Would you still sarcastically say "perfectly coherent" if OP suggested adding them?
&gt; blah.length makes more sense, len() is a weird special case. A weird special case to what exactly? &gt; The GIL really does suck. Multithreading is becoming more and more important, though the "multiprocess" module is making this somewhat better. Multithreading is fundamentally, completely and utterly broken in imperative languages. The GIL is therefore irrelevant. &gt; I'm not sure if the decorator syntax is good or bad -- it's ugly, for sure, but sometimes that's a good thing. Well I find it ok, not awesomely great looking but ok, considering the lack of actual anonymous functions in Python. Now if you want a real Python wart, I submit that `lambda` is more of a wart than any item and combination of item in TFA's list.
&gt; For another, try a thought experiment: suppose Python lacked arithmetic operators like +. Would you still sarcastically say "perfectly coherent" if OP suggested adding them? `+` would come from mathematics notation. Unless OP had bitched the line before that some notion imported from mathematics was ugly/stupid/whatever, I'd have no reason to.
&gt; + would come from mathematics notation. It comes from Perl just as much as labelled break/continue does. And in any case, your argument is essentially "if you dislike X from Perl you must therefore dislike everything from Perl", to which the answer is: *Only a Sith deals in absolutes.* Or if you prefer: *You're either with us or against us.*
&gt; Multithreading is fundamentally, completely and utterly broken in imperative languages. The GIL is therefore irrelevant. How? In what way? The two common complaints that I see are: 1. Managing shared state is error prone, which is true, but can be mitigated. 2. Shared state is a hindrance to scalability, which is also true but again not really the point, there are times when you only need two threads, refusing to support them on grounds of scalability is absurd. Are you referring to those two or something else? This probably my single biggest complaint against Python. 99% of computers out there have multiple cores addressing a shared memory space; Java, C, C++, etc. all support that architecture, Python doesn't.
&gt; A weird special case to what exactly? A weird special case to accessing information about objects. object.whatiwant &lt;-- &gt; Multithreading is fundamentally, completely and utterly broken in imperative languages. The GIL is therefore irrelevant. It's not that broken. The computer you're sitting at right now is using tens of multithreaded processes that were written in imperative languages. That said, you could make the argument that it's not a good idea.
I agree that `__contains__` could be sped up on the xrange object, though it would really only be useful once in a blue moon. The GIL does suck, but I'm not sure whether it sucks more or less than the alternatives. It's an interesting debate. I don't understand why's it a problem that (1,) != (1) -- they're completely different types. And just to nitpick, (1,) isn't in any way a singleton.
&gt; No support for labeled break and continue. I continue to respectfully disagree with the rejection of my PEP. That's the only huge WTF I have with python. WTF!
The len(), dict.copy(), and tuple/parens issues were discussed pretty heavily on the Py3k mailing list. Poster should investigate this if interested in why these items are or are not going to be in Py3K. 2**29 in xrange(2**30) - I chop this up to the fact that Python LETS you shoot yourself in the foot, which I think most users prefer to languages like Java that won't even give you a gun. @decorator - I'm not particuarlly in love with the decorator syntax, but as someone working with Python 2.3.5 at work on a daily basis I can atest that its far superior to no syntax. Break/Continue - Read the PEP, never run into this issue before, but you could always implement the same logic with a coroutine: http://www.python.org/dev/peps/pep-0342 Also, "singleton tuple"? 
9. The parent of this comment.
You never ran into breaking out of a nested for loop?
&gt; len() is a weird special case Depends on your POV. It's such a common operation for things with container semantics that it seems like a shame to tie up a public identifier (and risk confusing people who might think you're implementing an interface when you're not), especially when the language is perfectly content to give you high-level polymorphic functions that operate on pretty much whatever. What's curious to me, though, is that it's always `len()` that people pick on, and never anything else. They never complain about `str()` and say they'd rather do `some_object.to_string()`. They never complain about `map()` or `filter()` and ask that they become collection methods (as, IIRC, they are in Ruby). It's always and only `len()` that gets this complaint. Why is that?
Those were my first reactions. I actually left the article thinking that I was very misinformed...
I have nearly all these gripes and am interested in the responses. Apologetics is a very revealing exercise. And to think, the author didn't even mention: - all the other built-ins besides len() - the double-underscore protocol itself - tuples themselves - C notion of expression truth - the proliferation of "self" - strings that join arrays
&gt; Are you referring to those two or something else? The error-proneness of semaphore-based shared-memory concurrency as a programmatic API. Not composable, not verifiable, not isolable, as soon as you're using shared-memory concurrency all guarantees you could ever have had about your programs code get out of the window, and you start having to manage and track everything manually. Which you (note, "you" here doesn't mean "you bcash" but a general "you a random programmer", it includes me) usually don't manage to handle for every single corner case, which means that your program *will* subtly and randomly break.
&gt; strings that join arrays " ".join(["I", "can", "never", "remember", "this", "bloody", "syntax"])
&gt; A weird special case to accessing information about objects. Except Python has plenty of those. Most `__builtins__` to start with so `all`, `any`, `abs`, `chr`, `ord`, `filter`, `map`, `reduce`, `dir`, `hash`, `hex`, `id`, `min`, `max`, `oct`, `range` and `xrange`, `repr` and `str`, `round`, `sum` and `zip`. And we can add the whole `itertools` module. Python relies on functions a lot. That's all there is to it. It's not much stranger for `len` than for every other function in the language that could have gone and balooned an object's method space. Why focus on `len`?
&gt; * tuples themselves What is your issue with tuples? That they're an iterable? &gt; * the proliferation of "self" ?
&gt; No. This would require changing severe parts of the interpreter, and re-initializing default arguments at each method invocation (unless you have some magical way to determine whether a user-created object is mutable or not) If something is significantly broken, the fact that it takes effort to fix isn't an argument against fixing it. If everything were easy to fix nothing would be broken. And it's not that hard to check whether a function alters its arguments and to decide whether they need reinitialising because of it. I disagree with him that it's a wart (though maybe I'm biased because I write a lot of functions that benefit from memoisation) and that it "nails newbies all the time" (mostly it seems it nailed one or two of them, who then wrote blog posts that got a lot of press), but the arguments you present are pretty weak.
 for i in some_iteration: if should_stop(i,another_iteration): break else: #more code here... def should_stop(i,another_iteration): for j in another_iteration: if some_condition: return True return False
&gt; And just to nitpick, (1,) isn't in any way a singleton. TFA actually got that right, a tuple of size 1 is indeed [a mathematical singleton](http://en.wikipedia.org/wiki/Singleton_\(mathematics\)) While it doesn't map to the most common CS/IT usage of the word, it's valid.
&gt; Also, "singleton tuple"? Yep, a 1-tuple is a singleton (a 0-tuple is Unit, a 2-tuple a pair, a 3-tuple a triple, ...)
&gt; Also, "singleton tuple"? Singleton in mathematics is a tuple (or set) of size 1.
Indent code with 4 spaces
Thanks
Tuples are good because they use way less memory and can be handled faster and with less overhead in some situations. Lists have to maintain a certain structure in order to provide O[1] indexing and their other features. Plus tupples are guaranteed immutable which can matter in some threaded situations.
Put it inside a function: def foo_yes_that_foo(bar_yes_that_bar): for i in bar_yes_that_bar: for j in another_iteration: if some_condition: return something_meaningful I agree that it would be nice if python could be [extended](http://github.com/rails/rails/commit/22af62cf486721ee2e45bb720c42ac2f4121faf4) to do something like this: break.once break.twice break.thrice ... Sorry couldn't resist... :-D
If you **really** need fast instant checking for very large range objects as part of some production code, just write a check: a = xrange(2**30) if a[0]&lt;=i&lt;a[-1]: foo() else: bar() But xrange aren't really intended to use in this way, you just iterate over them once and for all... For largish ranges numpy is pretty good but there seems to be a major gotcha: &gt;&gt;&gt; from numpy import * &gt;&gt;&gt; u = arange(2**26) &gt;&gt;&gt; 2**24 in u True &gt;&gt;&gt; 2**31 in u False &gt;&gt;&gt; 2**32 in u True Hmmmm... &gt;&gt;&gt; u = arange(10, 2**26) &gt;&gt;&gt; 1 in u False &gt;&gt;&gt; 2**37 in u False &gt;&gt;&gt; 0 in u False &gt;&gt;&gt; u[0]=0 &gt;&gt;&gt; 2**37 in u True &gt;&gt;&gt; So it would seem to use some sort of bit chopping when testing for '''in'''! 
My 11 (least) favourite Python warts: 1. Statements 2. No multiline lambda (partly because of point 1) 3. The way scoping works, requiring nonlocal 4. Tail recursion wastes stack space in the CPython reference interpreter 5. The GIL from the CPython reference interpreter 6. Cannot modify built-in types (this is both good and evil) 7. Decorator syntax (because of point 1) 8. Much of the standard library should be cleaned and simplified; sometimes it's a bit overengineered and relies too much on custom classes and message passing instead of list and dictionary declarations (which is a pretty common design mistake in OOP) 9. It doesn't make sense to have contradictory operator methods (__eq__ and __ne__, etc.) 10. Function argument default values aren't recreated on every call 11. The standard library re module doesn't support recursive patterns and some other PCRE feature I can't remember
&gt; mostly it seems it nailed one or two of them, who then wrote blog posts that got a lot of press Well, I'd say it happens to most Python programmers once. If it happens to the same persons "all the time", I'm not sure they're really meant to be programmers. ;-)
Oh, sometimes people also complain about `join` being on strings an not on lists.
Function calls in python are extremely slow, far slower relative to many other languages. And this isn't easily fixed by the JITs like psyco or pypy.
&gt; high-level polymorphic functions that operate on pretty much whatever. And conceptually, they're actually generic functions, a simple concept that seems to be utterly hard to grok for people who've learned programming by rote imitation in a inflexible OO language, and are therefore incapable of understanding that things can actually be done in another way. And before someone points out that Python doesn't have "generic functions", let me quote myself from another forum: &gt; The Python *language* doesn't support generic functions in the CLOS sense, but a given Python *implementation* may use a dispatching machinery to select the best possible implementation for any call to a built-in function. &gt; Or in other words, the len() function shouldn't just be seen as a function that *always* does &gt; def len(L): return L.__len__() &gt; because if you look under the covers, it might be more like (using a hypothetical Python dialect): &gt; def generic len(L: list): return list::get_size(L) # fast internal dispatch &gt; def generic len(L: tuple): return tuple::get_size(L) # fast internal dispatch &gt; def generic len(L: object): return L.__len__() # fallback behaviour, using method dispatch &gt; where the visible "len" represents a plurality of available "len" implementations. &gt; How the dispatching is actually done is up to the specific Python implementation; CPython, for example, offers a "slot" mechanism for types implemented in C that's quite a bit faster than the method call machinery. And the slot mechanism isn't always single dispatch. For example, internal getattr(obj, name) calls use one of several slots, depending on what "name" is. &gt; Other Python implementations may use different approaches, but the point remains: a builtin function "operation(a, b, c)" isn't always mapped to "a.\_\_operation\_\_(b, c)" by the runtime; code that uses the latter form may be less efficient. And it's definitely less Pythonic. 
| " ".join(["I", "can", "never", "remember", "this", "bloody", "syntax"]) `str.join(" ", ["the", "classmethod", "approach", "is", "more", "easily", "remembered"])` 
&gt; Tuples are good because they use way less memory and can be handled faster and with less overhead in some situations. Yes, but that's missing the point of tuples and lists. Tuples are records where the position of each value has a specific meaning. Lists do not give or imply a meaning to any specific member. 
What.
The `xrange` thing was actually discussed on the Python mailing list a while back. Some guy made a patch to make its `__contains__` smarter. I don't recall if the patch was ever accepted though. Apparently, it's not in 2.6. It might be in 3.0 though, I don't have it on this machine to test it.
Are you aware that Python supports `for` … `else` statements? &gt;&gt;&gt; for i in range(5): ... if i &gt; 10: break ... else: # Do this if it never breaks ... print "hi" ... hi &gt;&gt;&gt; for i in range(5): ... if i &gt; 2: break ... else: # Won't be called ... print "hi" ... &gt;&gt;&gt;
Post your python tricks! I'll start: you can have information piggyback on an exception with the args property: try: 1/0 except Exception, exc: exc.args = (exc.args[0] + '... OH S---!',) raise
You never really learned to respectfully disagree, did you? One of the things I like best about Python is that generally the community is receptive to criticisms like these. The OP is not whining, he is simply pointing out the parts of Python that he thinks could use improvement. This is how the language gets better. You don't have to agree with everything he says, and clearly you don't, but why do you feel the need to try and refute every point via insult? How does that add anything? If you truly disagree with every point, at least make an effort to explain why. &gt; `my_collection.__len__()` &gt; knock yourself out. I agree with the OP on len(). I really like that I can write almost all of my code using only parens, periods, square brackets and colons for special characters. The double underscore is a clue that you're accessing something internal that requires a special case. Getting the length of an object is not a special case. &gt; Waaah waaaah wahhhh Really? That's your best response? The GIL is a tough problem, and there are many cases where it makes things harder to do. You have to work around it, and if we can find a way to improve it, awesome! &gt; No. This would require changing severe parts of the interpreter, and re-initializing default arguments at each method invocation (unless you have some magical way to determine whether a user-created object is mutable or not) What do you mean "No"? The OP sees this as unexpected behavior. I agree. The question we should be asking is whether or not this unexpected behavior outweighs the benefits this "feature" provides. Remember, Python is about being explicit. &gt; Too bad. Really? &gt; So what? 1 is an integer, 1. is a float and 1, is a tuple. Still, so what? You're stupid and still don't understand that parens are irrelevant and the comma , is Python's tuple operator? Sucks to be you. Great response. One of your best. Insult the OP for making a mistake that nearly all Python users have made. If I'm coding, and I have a three-tuple, and I want to make it a two-tuple, I delete the last item and the comma preceding it. If I do the same for a two-tuple to a one-tuple, my program breaks. It's definitely a wart. (1,) is ugly, but as far as I can see, it's also necessary due to the double meaning of parens. Doesn't make it any prettier. &gt; Python doesn't have range objects. &gt;&gt;&gt; xrange (type 'xrange') &gt; I like it. He doesn't. I'm ambivalent about it. Is your opinion more important? Unless you're Guido, probably not. &gt; Whine about something that looks somewhat Perlish, and in the next item whine that you don't get a feature from Perl. Perfectly coherent. He's asking for functionality, not syntax. He complained about syntax, not functionality. You're right, it is coherent. &gt; list(foo) also works. Considering that dict(foo) duplicates a dict (or creates one from an existing mapping) and set(foo) duplicates a set (or creates one from an existing iterable), I don't think I've ever used copy() Clearly other people do use copy. Would this really be that hard to change? class list: ... def copy(self): return list(self) ... The problem with the way many programmers operate is that they insist on this binary I'm Right, You're Wrong view of the world, instead of conducting a respectful, productive discussion of the costs and benefits of making various changes. People who do that are infuriating to work with, and often spend a lot of time wasting other people's time with just this sort of drivel.
Damn. I read about that some time ago but promptly forgot about it. That's pretty useful. Does it work for other loop constructs as well?
What he's saying is that tuples are generally the Python equivalent of C's structs. For example, if you're storing a list of student data, each item in the list may be a 3-tuple containing the student's id, first name and last name. [ (1,'John','Smith) , (2,'Joe','Blow') ] Lists are generally used to keep a, well, 'list' of items of the same kind. A tuple is basically a composite data structure used to bind related data together into one piece. The fact that they are iterable makes them a little confusing to some, though, I agree.
&gt; all the other built-ins besides len() I don't see how this is anything more than preference. &gt; the double-underscore protocol itself I actually like this. I don't see the point of actually hiding members. THe double score serves as a suggestion to "dont't use this", shouldn't need more than that &gt; the proliferation of "self" Again, what is really the problem with this? Besides some people just really not wanting to type it. &gt; the proliferation of "self" you mean ''.join('h','i') ? Whats the problem with that?
I think performance, memory characteristics, and immutability are more of the "point" of tuples in real code.
The GIL is pretty much here to stay. The only escape route I see is alternate Python implementations like IronPython and maybe, Stackless.
Because len() tells us about an intrinsic value of a single object. In formal object orientation, one expects an object to know about its intrinsics. len() has to reach inside an object and tell you about it. Most of these other builtins are taking one or more objects and returning an alternative representation. Fundamentally, there is nothing wrong with having len(myCollection) and myCollection.__len()__. The problem is not having myCollection.length() because that is what an OO programmer is going to look for. When I was new to Python, that was one of the first things I hit my head up against.
&gt; Python doesn't have range objects. What type does `xrange()` return?
&gt; Also, "singleton tuple"? http://en.wikipedia.org/wiki/Tuple#Names_for_tuples_of_specific_length 
The rich comparison operators `__eq__`, `__ne__`, `__lt__`, etc. were originally added b/c of Numeric (now numpy). If `a` and `b` are arrays, then `a == b` returns an array of booleans of the elementwise equality of `a` and `b`. In that case it does make sense to have separate `__eq__` and `__ne__`. 
Reading this post has made me realize why I love CUDA so much: the concurrency model is much more like hardware design than normal multi-threaded programming. For normal multi-threading, the model is "several things _could_ happen at the same time, make sure nothing gets clobbered". For CUDA and hardware design the model is more like "Everything happens at once. Deal with it." This forces you to think much more clearly about concurrency and come up with more robust solutions, which leads to awesome performance :)
&gt; Multithreading is fundamentally, completely and utterly broken in imperative languages. The GIL is therefore irrelevant. Machine language is imperative. How do you propose we solve this utter and fundamental problem if all processors are fundamentally imperative?
That has nothing to do with breaking out of nested for loops.
[Jython](http://www.jython.org/Project/) too, which just recently released a beta for 2.5
&gt; a simple concept that seems to be utterly hard to grok for people who've learned programming by rote imitation in a inflexible OO language, and are therefore incapable of understanding that things can actually be done in another way I'm familiar with both the generic function and OO approaches, like both, and yet wish Python would just stick with one.
&gt; Waaah waaaah wahhhh &gt; You're stupid and still don't understand that parens are irrelevant and the comma , is Python's tuple operator? &gt; Sucks to be you. &gt; I like it. See, this is why we have trouble bringing more people into the Python fold. Too many self-important assholes.
Interesting... I guess I was wrong. "singleton" in programming refers to an object using the [singleton pattern](http://en.wikipedia.org/wiki/Singleton_pattern).
A generator.
It destroyed me on an AI assignment as an undergrad. My program had completely bizarre behavior that I simply could not track down. The root cause never occurred to me until my professor tracked down the bug. It doesn't look like creating an object to me, it looks like the default value for a function. This is the kind of feature that makes sense from the perspective of a language implementer (it makes perfect sense now that I've written an interpreter), but violates many users' intuitions. 
The array slicing is borrowed from matlab (even moreso in scipy) If you understand foo[10:] and foo[:10] (which most python programmers do), then I believe foo[:] should be pretty intuitive as well.
An iterator. But I don't see why it couldn't return a slightly more complex range object with a more intelligent \_\_contains\_\_ function.
&gt;It doesn't make sense to have contradictory operator methods (eq and ne, etc.) Can't \_\_ne\_\_ be implemented as not \_\_eq\_\_()? But I guess that still qualifies as a wart.
Complaining about these as 'warts' on the language would be functionally equivalent to refusing to bed Cindy Crawford because of her mole. 
What if I have "foo|bar|baz" and I want to turn it into "foo,bar,baz" (ignoring replace() or regexes or whatever else for a moment... I admit this is contrived)? Which way is more intuitive? "foo|bar|baz".split("|").join(",") # logical ",".join("foo|bar|baz".split("|")) # python Regarding the quote from the docs, yes, it's much easier to accept split() as a string method. The reason for that is that split() operates on strings. join() on the other hand, should operate on lists. Speaking of the docs... I always get a kick out of this: &gt; If none of these arguments persuade you, then for the moment you can continue to use the join() function from the string module, which allows you to write &gt; &gt; string.join(['1', '2', '4', '8', '16'], ", ") I don't like join() as a method on str, so you want me to use the join() function in the *string* module? I get the point they're trying to make, and love the veiled threat of deprecation, but on the whole I just don't buy any of it. It seems odd that so much else in Python seems to make perfect sense, and then weird curveballs get thrown in for the hell of it with no proper explanation.
I haven't. It's apparently not a very common use.
&gt;What do you mean "No"? The OP sees this as unexpected behavior. I agree. The question we should be asking is whether or not this unexpected behavior outweighs the benefits this "feature" provides. Remember, Python is about being explicit. Generally functions are defined when the interpreter evaluates a `def`. Functions are not re-defined when called. I do not think it is unexpected at all, at most a thing of "Oh, why didn't I think it through". &gt;If I'm coding, and I have a three-tuple, and I want to make it a two-tuple, I delete the last item and the comma preceding it. If I do the same for a two-tuple to a one-tuple, my program breaks. It's definitely a wart. (1,) is ugly, but as far as I can see, it's also necessary due to the double meaning of parens. Doesn't make it any prettier. Yes, parenthesis should be disconnected from any tuple definitions. Parenthesis indeed has a double meaning: syntax for grouping expressions AND syntax for calling functions. Observe: a * (b + c) # expressions b, + and c grouped d(e) # function calling, this could use consistency with tuples. maybe. d(e, f, g) # likewise h, i, (j, k) = struct # two-level tuple struct, unpacked by grouping l, m = m, \ l # no parens, need to escape linebreaks l, m = (m, l) # line breaks allowed now n = (o for o in p) # lone genexp; grouped expressions q = foo(o for o in p) # genexp parens unnecessary here 
It works with `while`.
You can rewrite my parent as: for i in some_iteration: for j in another_iteration: if some_condition: break else: #More code here continue break In fairness though, that is a bit complicated, and should be thoroughly commented. 