http://www.riverbankcomputing.com/software/pyqt/intro I've been using PyQt 4 for quite a bit. You'll have to use a separate IDE of course, so, that's a little weird to get used to. Otherwise, it works great once you get the hang of the SIGNALS, building the UI, linking it, etc. It's really not as difficult as it may sound, though.
I tried it on 33,000 document vectors each 200 floats long. It came back with good results in 0.008 seconds. So it's not slow. But I don't know how this compares to FLANN.
We aint really trying to combat any other Lisp. Scheme got their use, Common Lisp got their use, and Clojure have found its own crowd. I won't say Hy got a selling point, or got anything special setting it apart from any other Lisp. It's a language aiming to show you what you are capable of doing with the Python runtime. Full introp is awesome, imagen the languages you could create that can and will interop seamlessly with Python! Who does not want a Lisp, Haskell, Ruby, even PHP with their favorite Python lib?
I was ready to be all snarky since I couldn't get conda working the last time I tried it, but I just set up a Python 2.7 environment on a Windows box that has Python 3.3 installed on it. This is pretty cool.
Try to use the for loop for iteration when both equally convenient, esp in situations when you know the exact endpoint of the iteration like traversing a defined list. The while loop is useful for at least two special cases: iteration for an unknown or unpredictable number of cycles like requiring specific user input to break. Secondly for a purposeful infinite loop while True: #do something. Managing/traversing a nested list of lists (multidimentional array or matrix or table) can be confusing. One technique is to nest for loops: for row in table: for column in row: #do something to column Another technique is a complex list comprehension: [#do_something_to_each_column for column in row for row in table if some_conditional] A specific value or cell from a deeply nested list, or n-th dimentional table can be accessed by concatenating the indices until you work down to the n-th level: value = table[1st level index][2nd level index]..[nth level index] So accessing the 3rd column from the 2nd row of a 3x3 matrix: desired_cell = table[1][2] #remember that each index starts from 0 Alternatively you can define a matrix as a list within a list: desired_row = table[1] desired_cell = desired_row[2] I understand that numpy has more powerful tools for handling arrays, but I haven't used it yet.
I'm pretty much in the same boat, so I'm trying to study fundamental Comp Sci principles that I would've gotten in an undergrad if I hadn't majored in liberal arts instead. So, I'm reading through this book that deals with [Fundamentals of Python Data Structures](http://www.cengagebrain.com/shop/en/US/storefront/US;CMGTJSESSIONID=D2BqSY2G8nK74Q3Qjlf1fvB0l7yR2yZ0dnh2C6TfDzDqnvtl0Syf!-338613124?cmd=catProductDetail&amp;gclid=CMv606i0hLwCFew7MgodAAgAIQ&amp;entryPoint=storefront&amp;cid=GSEM1&amp;ISBN=9781285752006&amp;forceRegion=US&amp;messageType=catProductDetail). Beyond while vs. for loops, it deals with actual algorithms and complexity analysis. Might be a bit overkill, but definitely seems like the direction to go in.
[This is a video](http://www.youtube.com/watch?v=OSGv2VnC0go) that I found very helpful when I was getting started in Python. It's from Raymond Hettinger and it's kind of a hodgepodge of different Python topics, but you'll be sure to learn a lot.
1. "but it didn't really work for me" is not enough information to fix what you have going already. 2. Why Python 3.3? 3. Why does 64 bit matter (which parts of the toolchain have different width binaries)? 4. If you just want to hit the ground running, install [EPD](https://www.enthought.com/products/epd/) or Canopy Express. It bundles Python with matplotlib and tons of other science-y stuff into a dead simple Windows installer.
&gt; The default storage is in-memory, realized by simple Python structures.
I read this in the manual. But it doesn't matter if you are using Redis or not, the program won't run without it. Which does seem like a problem with the package.
If you need performance, try this: https://github.com/spotify/annoy
Work through [some sample problems geared toward learning](https://projecteuler.net/) and learn the basics of [runtime complexity](http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/) and how to use `dicts` to speed things up. It's like learning music, you're not going to be great after just a year or two but you'll be able to handle the things you practiced.
Here's what works from me on a fresh Windows installation: 1. Install Python 2.7. (I always install 32bit even on 64bit windows since it's much less of a hassle. Some libraries don't work well with 64bit.) 2. Open Computer -&gt; System properties (top of the window) -&gt; Advanced system settings -&gt; Environment Variables 3. Select "Path" from the "System variables" box, click edit and append this line (use whatever path your python is installed to): C:\Python27;C:\Python27\Lib;C:\Python27\Scripts;C:\Python27\DLLs;C:\Python27\Lib\lib-tk 4. Download this and run it: https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py (preferably from cmd since if something goes wrong you'll have time to see it) 5. Try in Windows command line: Microsoft Windows [Version 6.2.9200] (c) 2012 Microsoft Corporation. All rights reserved. C:\Users\bradur&gt;python Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win 32 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import easy_install &gt;&gt;&gt; 6. No error, it should now work with `easy_install packagename` straight from command line
&gt;The while loop is useful for at least two special cases: iteration for an unknown or unpredictable number of cycles like requiring specific user input to break. If you put user I/O into a generator function, you can write that very neatly as a for loop (but that might be a bit advanced for OP). OTOH, an "impure" generator (i.e. one with side effects such as I/O) could be surprising to other programmers, so I might prefer a while anyway.
These are the principles I adhere to when making decisions of the type that you're talking about: * https://en.wikipedia.org/wiki/Don%27t_repeat_yourself * https://en.wikipedia.org/wiki/Don%27t_repeat_yourself * https://en.wikipedia.org/wiki/Don%27t_repeat_yourself (it's REALLY important, so it deserves repeating!) * https://en.wikipedia.org/wiki/Separation_of_concerns * "Premature optimization is the root of all evil" While buried in code the thought that's usually going through my head is "how can I achieve this elegantly in the least amount of code possible?" One of the things that attracted me to python initially is that the community actually seems to give a damn about these principles whereas other communities *cough* JAVA *cough* clearly do not. Almost every design pattern or example of "how you should write GOOD code" as opposed to just working code can usually be boiled down to these principles.
All I see is a screenshot, and the MVP strategy (http://en.wikipedia.org/wiki/Minimum_viable_product#Techniques) seems to be pretty popular these days: 1) Generate "screenshot" 2) Get people to sign up for "early beta" 3) Develop code, but only if it's worth it 4) Release Hope it is not vaporware
*Here's the linked section [Techniques](http://en.wikipedia.org/wiki/Minimum_viable_product#Techniques) from Wikipedia article [Minimum viable product](http://en.wikipedia.org/wiki/Minimum_viable_product)* : --- &gt;A Minimum Viable Product may be an entire product or a sub-set of product (such as a feature). &gt;Product: (smoke test) The canonical MVP strategy for a web application is to create a mock website for the product and purchase online advertising to direct traffic to the site. The mock website may consist of a marketing landing page with a link for more information or purchase. The link is not connected to a purchasing system, instead clicks are recorded and measure customer interest. &gt;Feature: (deploy first, code later) A link to a new feature in a web application may be provided in a prominent location on an existing website. The feature is not implemented, rather an apology, mock-up, or marketing page is provided. Clicks of the link are recorded and provide an indication as to the demand for the feature in the customer base. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/NavreetGill can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?)
&gt; Your bot runs on our servers. No need to worry about downtime or latency. All I read was "give us your trading algorithms".
Yes, this is totally normal. On my work laptop I usually have 50+ tabs open with references, stackoverflow threads, etc. Just google every time you hit a wall. Almost every problem you encounter someone else encountered before you and wrote about it. And if you dont find anything, just start a thread on stackoverflow, sometimes even the really important guys answer. If no one can help you - well then you are about to expand the human knowledge. Perhaps also get 'the art of computer programming'. Bill Gates once said you get a job at Microsoft when you read them all.
You can also use PySide, which is LGPL licensed, useful when you are developing non-free software. It does not support Qt5 at the moment, though.
How on earth did you manage to overlook the **huge red block letters** telling you to post this on /r/learnpython? Reading is an important skill for a programmer...
It is very normal. This advice is based on the way I got past that plateau: * Whatever you do, keep practising writing small programs. You can't become a better programmer if you're not programming. * Try /r/dailyprogrammer. Start with the easy challenges and try the intermediate and hard ones if you're confident enough in your skills. Compare your own solution with those of other people who used Python to solve the challenges. Not every solution will be a good one, but it's useful to compare them. Also read the comments on those solutions, because often people offer suggestions for improvements. * See http://rosettacode.org/. Check out the different tasks, and try to solve them (since Rosetta Code is not a puzzle site, but more of a Rosetta Stone-like "compare the solutions in different languages to learn new programming languages", the tasks are mostly not very challenging). Then, if you're done or you get stuck or whatever, look at the Python solution of that task. Compare what you've done with the solution on the site. Those solutions are generally pretty good, but they're not gospel, so don't depend too much on them. Good luck!
I've written code I intend to be opens source, but I am too scared to show it to anyone. I've written some data science tools and some other bits and pieces....but I have a fear of showing it :), I guess I am insecure about what I have produced.
[OpenCV](http://opencv.org) is probably the most widely used free and opensource library for image processing and it has python bindings. You can go through the online [documentation](http://docs.opencv.org/) or refer to [this](http://opencvpython.blogspot.in/) blog for examples. For detecting circles, [this](http://docs.opencv.org/doc/tutorials/imgproc/imgtrans/hough_circle/hough_circle.html) page might be a good starting point.
&gt; is this normal? Yes, welcome to programming which I think of as solving problems with computers. :) Concentrate on solving problems. It may require a bit of trial and error, but as you solve more problems you will being to see similarities that become patterns to apply or tools in your toolbelt to adapt to various situations. But if you don't have a problem to solve, it is very difficult to gain any real experience at solving problems. If you respond better to entrepreneurial ideas, substitute "problem" with opportunity. As a matter of fact, you could write a program to do that for you if you are bored.
PIL and Pillow are only marginally useful for this type of work. I would *highly* suggest that you start playing with OpenCV and/or SimpleCV. SimpleCV would probably be a little bit better since you are new to image processing. The basic algorithm used for "finding and counting" objects like you are trying to do goes something like this: 1. Conversion to grayscale 2. Thresholding (either automatically via Otsu method, or similar, or by manually setting the threshold values) 3. Contour detection 4. Masking and object counting based on your contours
If you want to know, how it compares to others, maybe this comparison-posts here might help: &gt; [Part One](http://radimrehurek.com/2013/11/performance-shootout-of-nearest-neighbours-intro/) &gt; [Part Two](http://radimrehurek.com/2013/12/performance-shootout-of-nearest-neighbours-contestants/) &gt; [Part Three](http://radimrehurek.com/2014/01/performance-shootout-of-nearest-neighbours-querying/)
I have OpenCV and scikit-learn, but I want to actually learn and understand computer vision rather than just looking up documentation online. Instead of just arbitrarily using the Hough Circle Transform to find circular features because a StackOverflow page told me to. Are there textbooks or so that I could use to get a grasp of the general techniques used? Where can I educate myself on the fundamentals/basics of modern computer vision as well as popular techniques used?
Are you working in academia or is this part of some other project? The reason I ask is because certain parts of CV require a decent understanding of linear algebra, and some textbooks dive way too far into detail too fast. In that case, you would be better off reading an O'Reilly book until you are comfortable with the concepts of CV. Let me know and then I'll post some books.
bazillions... But I like it ;)
I've written a media center program to replace XBMC which I've used for ~ 2 years myself. Based on Django and VLCKit. https://github.com/boxed/cmi
...I have a bunch of other projects too, but this one is the one I think most people would be most happy using :P
Installing Python into Windows can be a real pain in the ass, make no mistake. I ended up editing the registry to get my python/pip/virtualenv to work. So you are not alone here. Keep at it. Also, I would really recommend that you stick with 32bit python, even though you have a 64 bit machine. Also, in you are installing 3, go for the latest. In particular, 3.4 has virtualenv built in. 
This is hardly a benchmark worth stressing about: it's recursive Fibonacci generation. That's about as unrepresentative as it gets. Chances are the slowness comes in part from long integers. That's a useful addition but it comes with a (small) overhead from Python 2's dynamic version (I think). Further, the Hy and Python on CPython 3.3 timings have a second difference between them despite compiling to *the same bytecode*. I'd take these timings with a heap of salt.
Hy actually uses Long in Python 2.x too, but your point is spot on. These tests are not representative of the interpreters, I think we're all mostly interested in the delta between Hy and lovingly written Python
I'm using GTK (PyGTK fom gtk 2 or gi for gtk 3). But PySide or PyQt are good too. I have some examples using gtk (2 and 3): https://github.com/alexandrevicenzi/GladeBuilder
This. Most of the Python documentation is good at explaining how to do things well, but some of the more complicated packages are more difficult to understand, so some external googling may be required. But always, always look at the official package documentation, too.
I second this. It contains simple, practical examples that don't get bogged down in wordy explanations or heavy math. It gets right to the point of the most common techniques, where they are used, and how to put them together, all with working code examples. This is the best place to start for any image recognition in Python.
For most of it, you really have to read the standard doc. If you don't know what loop to use or some other structure, ask yourself if you really defined your problem well. If you can't formulate precisely what you want to do, chances are you won't be able to decide on a structure. For me, it always helps to take a step back, reformulate what I want to do naively i.e. without any thought about code. Then I think about what I need to do to achieve crucial parts of it. After a while, this always boils down to mostly good choices in the structures picked: Do the indices in a list matter when iterating over them? No? Hello while loop! They do? A for loop it is! (for example) I also benefit a lot from theory, the knowledge about NP-hard (and beyond) problems also saves me a lot of energy during such a "boiling down" process. I'd recommend to read a lot on theory, there is a lot of material for non-scientists too. If you want to delve into making things really efficiently and sophisticated, chances are that you will have to read up on the science anyways to achieve it....so no harm done with meeting this side of the computational world too ;)
&gt; It might not be straight forward to install it though, so that's why I thought it'd be better to post the website. Because I'm actually working now on making the packaging/installation easier (and it's a pain in the ass). Can't wait then! I had a quick go at getting it run (~20 mins) but had trouble with a library called pydispatch. I'll definitely take another look when the website is up again!
A pretty good approach for myself in the beginning was to first make it *work* and then worry about how I can improve my expression via python code. If you worry too much about optimal ways of programming you will get lost and never finish, but the correct output of your program is what will motivate you on your journey! So once again first make it work and then worry about the rest. 
Release it. Just release it. Seriously you will get lots of useful feedback and learn how to do things more efficiently.
Yeah, sorry. That was meant to come across as a compliment
&gt; More code is bad, most of the time This is why I like coding in Python.
&gt; using Python 2.7 is not an option for me I've never encountered this. Can I ask why? I still have trouble with more obscure modules that never bothered with 3.x support so if that's the system-wide Python, I just use a virtualenv.
Maybe I am a little paranoid, looks like a great idea in concept, but I would be a little worried about hijacks. 
As a few other commenters have said, yes, it's completely normal. How you program now, and how you will program even in a year from now will be very different. You'll look back on your first attempts and cringe a bit. You are learning two skills at the moment: 1. Python as a programming language. 2. How to solve problems using a computer The best advice that I can give is just to keep reading, keep trying things out, and keep programming (as long as you enjoy it). You'll naturally keep learning new things and improve your practice as you go. And don't worry! We all started where you are and we were all as good as you are now :)
FYI [scikit-image](http://scikit-image.org/) is also a thing.
Take a look at [web2py](http://web2py.com/). I've been using it for a multi-user conversion of an old Access/DBASE-style database line-of-business application. It's got quirks when trying to customize things (only in that it's not like other application frameworks I've used; not a bad thing, just different). I think it meets all your criteria.
Line 26 of [the config](https://github.com/pixelogik/NearPy/blob/master/setup.py) needs to be removed. I will fork it, fix that, test it, and submit a pull request to the author later today.
Here are some book recommendations: - Programming Computer Vision with Python: Tools and algorithms for analyzing images - Practical Computer Vision with SimpleCV : The Simple Way to Make Technology See - OpenCV Computer Vision with Python And some textbooks: - Computer Vision: A Modern Approach (2nd Edition) - Computer Vision Start by learning the basics of image analysis. Moving to video analysis is a little more tricky, but certainly easier with a strong understanding of image analysis. Some of the books I mentioned above briefly review the basics of video analysis and tracking.
Does it work with python &lt;3.3 ? Edit: Is it me or is there a downvote attack in this forum these days, I have never seen so many posts downvoted without even a comment.
You might also want to take a look at Twisted -- it has an existing builtin DNS server and a bunch of utilities for helping out with such things,.
If you are really interested, [get a book](http://www.amazon.com/Image-Processing-Fundamentals-Maria-Petrou/dp/047074586X) and start asking your professors for help
Semantic versioning I guess. http://semver.org/
As in, a library? There's `zest.releaser`, and the less batteries-included `bumpversion`, both on PyPI. I feel like I've previously been aware of others, but they've evidently not stuck in my head. In the release-related tools I can think of, which might be tangentially interesting, there's `pyroma`, `check-manifest` and `twine`.
bumpversion! That was it.
Thank you sir. This looks promising
Your questions are normal. And you really only understand how to answer them with experience. Years of experience. Hohncipriano's list is excellent, I would add YAGNI, "you're not gonna need it". Which means don't over think, over engineer. It's good to have these questions, but don't sweat them. Unless the code you are writing isn't fast enough (it almost always is), or get's too complex and needs a good refactor (it almost always does). Write code. Lots of it. The more you code the faster you will get experienced. It is good to ask questions and think of larger issues BUT, if you spend too much time doing that you will never get experience.
You can use numpy.asfortranarray() to force your matrix to be Fortran contiguous. I don't know if any one-shot, copy-free approach to generate a Fortran-ordered Toeplitz matrix.
See http://www.python.org/download/mac/tcltk/
Just start my first job doing a lot of Python stuff and have been looking for a good, light IDE. I'll try this out for a week or so and see what I think :) 
I just added a quick thumbnail implementation to the github repository.
Since the author apparently is no longer able to remember how exactly to reproduce the bug, can you please try to make a minimal reproducing case? As I said in another comment, there's a shitton of seemingly inconsequential things that could cause a deadlock if you add one to the code he provided. Which, by itself, seems to run fine for everyone, including myself when I downloaded and built Python 2.4.1. So I really, really want to know if there is (or was) a bug in `communicate()`, possibly triggered by some more specific use case, or that you and other people here wrongly attribute their own bugs to it.
Funny enough, a few minutes after I read your post, I read the Pycoder's Weekly mailer, which mentioned [gitver](https://github.com/manuelbua/gitver). Seems to be a similar idea to bumpversion.
Quick note: numpy's arrays should actually incur *less* memory overhead than python lists, since they are of homogenous type and can be allocated contiguously. Allocating empty numpy arrays seems to take longer than make empty lists: In [18]: %timeit [] 10000000 loops, best of 3: 35.1 ns per loop In [19]: %timeit np.empty(0) 1000000 loops, best of 3: 971 ns per loop But as soon as we actually take up some memory, numpy is the faster one: In [20]: %timeit [0]*1000 100000 loops, best of 3: 5.2 us per loop In [21]: %timeit np.zeros(1000) 1000000 loops, best of 3: 1.33 us per loop
Good to know.
Consider cross posting to /r/fortran :)
Well you should look again with Pandas (built on Numpy) from those who have made the transition, blows MATLAB away...
A great way to progress is to get the IPython notebook and start to look at the many public notebooks covering a wide range of topics,, download them and make them your own, modify them, run them interactively
I guess this stuff is pretty subjective. To me it is not intuitive that these should be falsey. To help explain my self. I would think that [] is more zeroy than falsey. But 1 + [] gives you a type error. None is particually non falsey. To me it is closer to undefined. And undefined is not at all falsey. The cost of having to write slightly more code to be explicit about these types is more than made up for in the reduction in the number of bugs. Especially because different languages have different opinions on what should be falsey. 
If you are interested in how we put together the newsletter I can tell you first hand! Generally we don't collect too much stuff from r/Python, we usually just hit up r/Python for our weekly discussion because much of the best Python discussions are currently happening or do happen here. So that being said, where do we get our items? Everywhere! * We generally collect much of the newest/hottest from github/bitbucket/pypi. * We have a submission form on http://pycoders.com that people submit their latest too. * People send us email about new things they have done * People tweet at us about new things on twitter * We have some other scripts/methods and such for getting data about the latest happenings in Python We generally end up with about 100+ links at the end of every week. Then myself and Mahdi read everything and check out all the projects and choose what we think are the best or what people are going to be interested in as well as obscure things we think people would like to know about. Those 25-30 links(or less) are what ends up in the newsletter. All in all, you can see how some of the things that are in the newsletter end up on here and vice versa. When people find cool things they want to share them, so there is often going to be overlap. If you have any other feedback it would be appreciated! You can hit us up on twitter http://twitter.com/pycoders or just respond to the newsletter via email!
Nice! Thank you!
You might want to try ditching IDLE and learning the terminal, if you goto the terminal and type "python" you get a shell, if you navigate to your script and write "python script.py" then it will run your script. Learn Python The Hard Way (link in the sidebar) has a pretty good tutorial for this stuff. also come check out /r/learnpython!
One way to go here is to first create a Fortran ordered array, and then assign the toeplitz matrix to its elements. So: A = np.zeros((3,3), order = 'F') np.isfortran(A) # this gives True A[:,:] = scipy.linalg.toeplitz([1,2,3], r = [4,5,6]) np.isfortran(A) # this gives True again Note that the brackets on A are essential. If you left them out then A would be overwritten, and it becomes the default C-ordered array. A = scipy.linalg.toeplitz([1,2,3], r = [4,5,6]) np.isfortran(A) # this gives False Of course, the np.asfortranarray() would also work.
DRY is important for newbies to remember, but as you become advanced, it can be a fault. DRY obsession leads to meta-programming and meta-programming leads to unmaintainable code. The problem is that you have A and B which share some code. So you rewrite it to be DRY and both A and B are now instances of C. But then the requirements for A and B diverge. So, you make C into a monster to accommodate those divergences. Soon, no one can understand how C works because it's basically doing all of the work of A and B combined plus E and F that got added later. Long story short, whenever you "over-DRY" things, you introduce a dependency. A and B used to be independent things, but now you can't change B without accidentally also changing A. Dependencies are good when A and B really should be the same, but when they need to diverge, you'll wish you hadn't yoked them together.
Thank you both ! 
[Sentdex](http://www.youtube.com/user/sentdex) has some really good tutorials on this to get the ball rolling. 
I've never done any image processing with Python (a shame, I know), but I've done a bit with Processing (an odd little Java-y framework) and Javascript. Processing is a bit clunky, but it comes with tons of example code that should give you ideas on how to implement something in Python. Image processing in the browser was surprisingly easy to do, now that we have the canvas element in HTML 5. Your first step should be to learn how to calculate a 2D histogram of an image, which contains information on the distribution of colour intensities. Armed this information, you can start to do things like thresholding, which tends to make "interesting" areas of an image more prominent. From there, you'll want to play around with applying different kernels to an image so you get an understanding of how the various image effects (e.g. brighten, sharpen, blur) work. One of the more important ones for image analysis is edge detection, which is one way you might find features. For your example task, you'll probably want to look into blob detection. https://en.wikipedia.org/wiki/Kernel_(image_processing) Where are you doing your research? 
*Here's a bit from linked Wikipedia article about* [***Kernel (image processing)***](http://en.wikipedia.org/wiki/Kernel%20(image%20processing\)) : --- &gt; &gt;In image processing, a **kernel**, **convolution matrix**, or **mask** is a small matrix useful for blurring, sharpening, embossing, edge-detection, and more. This is accomplished by means of convolution between a kernel and an image. --- [^(**Picture**)](http://i.imgur.com/vrvC8ns.png) [^(image source)](http://commons.wikimedia.org/wiki/File:Vd-Orig.png) ^| [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/mazatta can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1vfqpf/how_do_i_learn_image_processinganalysis_in_python/cesdson)
Personally I just integrate the build system into the VCS (git in my case) and use tags with the version, no need for a tool. Just pass in the version information as either a -D define or by processing a .h.in config file. You can also put in the githash/commit number, the build time, branch and other build information. It does have some limitations. For example your source build must be a repo, not just a tarball, although you could make the generation of the tarball part of the buildsystem and include the processed .h file in there. The other issue is you need to have the repo tool accessible at build time (ie Windows needs it in it's $PATH). Also if you use multiple build systems you might need to set them all up. But none of those are major issues IMHO (worse case you have a fallback 'unknown' for the version for lazy devs and just ensure your build system is setup correctly).
Yes, I would probably not like you if you wrote that in a codebase and I came across it.
Possibly: https://github.com/manuelbua/gitver Appears it is on pypi also.
Actually, it's easy (for a techie anyway): http://stackoverflow.com/a/14407505/450917
May I ask you (generally) what's this for? I couldn't have less of an idea of what these images are about and what the research is for, so am kind of intrigued. Thanks.
This is vastly beyond the scope of what you can accomplish in the middle of a presentation like that. Just show them what the code looks like and what it can do.
The best way I've found to explain inheritance to my non coder friends: Lets say I have a class that makes a generic window. Now I want to make a second more specific window with a different title, I can just inherit the window. I'll get all the stuff I want from that window and I only need to change window.title to get it going. 
Objects are sort of overloaded. They serve more than one role in the language. That makes them useful, but pretty hard to explain briefly. Job 1: Suppose you have a bunch of code. How do you show what's related to what? The a.b.c.d hierarchy is now standard across a lot of different languages because it's a really nice way of grouping things. Job 2: Data types. As scientists, they surely have their own version of `class Point` with `x` and `y` attributes. Maybe they model something or another and that thing has a temperature, an altitude, a time, and a cost in USD. Whatever it is, sometimes it's useful to bundle data together. Classes are great for doing this. Job 3. Code reuse. You can get pretty far with just defining data types (job 2) and then passing data into a series of functions. But what if you have a function that does A, B, and C to a data object, and you wished it did A, D, and C instead? Polymorphism is the answer. Just override the B method with a D implementation and your object can inherit all the powers of the superclass, quickly and easily. Three different jobs that only partially overlap. Hard to put into slide form. Good luck.
That website is seriously overusing MUST in place of SHOULD. EDIT: Apparently, nobody reads RFC 2119 any more: &gt; Imperatives of the type defined in this memo must be used with care and sparingly. In particular, they MUST only be used where it is actually required for interoperation or to limit behavior which has potential for causing harm (e.g., limiting retransmisssions) For example, they must not be used to try to impose a particular method on implementors where the method is not required for interoperability.
Comp Sci major in his last year here. Out of interest in python in the business environment, how are you using python on your project?
Good programmers can become great Python devs. Python is very much a dev friendly language so brining people up to speed is super easy. I'd be more concerned with hiring people with good practices than specific language experience. However, "what's your favorite thing about Python?" And "whats the coolest thing you've built?" Are fun questions. Python is awesome and easy to find things to love about it. A more subjective one "2.7 or 3?" My answers to the above (for fun :) ) Comprehension, generators, and functional programming Web apps for data analytics 2.7 Alllll the way.
I agree with the crowd that language specific questions are not always the best judge of ability...but if you were going to go on domain specific knowledge here are some questions I believe will help: 1) Build a singleton (explain __new__ vs __init__) 2) talk through python memory management (will the OS release memory?) 3) inquire about their python code style guidelines (main point is that they have a strong opinion) 4) write a multi-threaded python app (make sure they mention the GIL and why Python may not be the right tool) The main purpose of all of these questions is to create a conversation about language trade-offs. Another viable route would be to ask them to compare python to any language that you know quite well (I find node to be a fun example) and make sure they can keep the conversation going.
Just keep in mind that a strong computer science background doesn't imply being a good developer. During University, I knew quite a few people who I would classify as the former and not the latter - and vice versa.
"Can you show me some code you've written?" I always ask this question, and if the code is good I don't care what languages the person has worked with before. Python is easy to learn, so it's much more important to get a good developer than to get someone who knows Python. And the only way to tell if someone's a good developer is to read their code.
"Do you know Python?"
Call it twice and see what happens.
&gt; Anyway, I would simply create an object instance at the module level. It would feel more pythonic than trying to play around `__new__`. Follow up question: Does that give you one instance per import of the module, or one instance total? Why? 
I prefer to ask "what's wrong with python and why?" rather than asking about the coolest part. If they give an answer like "the GIL, because you can't do concurrency," then you know you've got somebody who's read enough to talk their way through an interview, but doesn't really know python well (because there are lots of ways to do concurrency in python that don't involve threading). Though if they say "the GIL," and go on to talk about the shortcomings of other approaches and a time when they really did need threading, that could be a reasonable answer. If they give an answer that involves whitespace, thank them for their time and move on. The reason I prefer this to asking about someone's favorite thing about the language is that everyone's going to have something they love, but someone who loves the language, but has been around it enough to see its warts (but still loves it enough to want to use it for a living) is more likely to be a good candidate. This approach may depend on having someone on the interviewing side that knows their stuff well enough to evaluate the answers, though.
a couple of things you could check: 1 - do they know what generators are? i wouldn't expect everyone to know that they can be used in both directions (as coroutines), but they should at least understand how to use a generator to create a sequence of values (and what the advantages and disadvantages are of doing that relative to creating and returning a list) 2 - what tools do they use when working with python? in particular how do they manage dependencies? a good python dev will know about, and use, virtualenv (or pyvenv), and be able to explain why it's a good idea. also, they should know about at least one of pip or easy_install. also the a=[] question elsewhere here is a good idea for weeding out the very worst. not sure where you find people, but it's a very popular language these days, so i can't imagine you will have many problems. finally, i wouldn't want to hire, as a python developer, someone who objected to technical questions like these. i've seen code developed by smart people who don't understand the tools they are using, and if i had the choice i would avoid it. you want someone who is both smart *and* competent.
Good follow-up. It depends; usually just one, but if you import the module by different names, it could be more than one. 
Ask them to talk briefly about five different packages in the standard library (their choice). If nothing else, you'll learn some cool tricks from this one. Write them down and look them up later. I had a guy come in talking about how one thing he loved about python was that you could just do "import file" and be off and running.
that's an optional argument
Well you can't say what's wrong with it if you don't know what was intended: it may be wrong if you expect it to return [1] on repeated calls without an argument; or, maybe it was intended to return an ever-growing list in which case the code is wrong because it's a rather obscure way of doing that.
Everything.
Thanks, will bear that in mind although Twisted seems like a big dependency. Also, it was just fun to have an opportunity to breakout Wireshark and do some byte-level stuff.
That is a definitely a concern. I'm going to try and find a simple way to rate limit update requests or temporarily block bad IPs that try and crack the key.
I would check if the person knew how to handle generators and generator expressions correctly. For example, make him/her go through a large (several GB) Apache log looking for some specific information. Without generators, the entire log would uselessly be loaded in memory. I would also make him GET several hundreds of webpage, and ask him/her to full explain the chosen solution. The information you would be looking for is: does he/she knows how to handle asynchronous calls in function, and how? Using threads, greenlets, asyncio, twisted, etc? What's their respective strength? What about the GIL? Last idea, implementing a decorator. It's very zen/pythonic to use, but knowing how to actually implement is trickier.
One thing is not remembering syntax, another is actually understanding a language. An expert in a language is worth it because the really understand the reasoning behind the language, the objects model, etc. You definitely should ask for important or interesting CS questions, but the same applies if all you ask is specifics about certain algorithms or data structures. And also yeah, having a good CS background doesn't mean you are necessarily a good programmer, i think those are different skills.
We have candidates debug a python program live. Find some python program you have and can have candidates view, or one that is open source. Introduce a subtle (in the source) bug that majorly breaks functionality. Something like changing one number, or adding a "not", or returning the wrong variable. Give the candidate the program and as many tools as can be reasonably supplied and then watch them debug. See how they go about it. Ask them to talk you through as they go. Do they make effective use of python debuggers? print debugging? Do they get sucked down ratholes by making too many assumptions? Can they build a mental model of that part of the program? If the code is crappy/poorly documented, do they mention this? Do they identify well written code? Can they recognize when the repr is telling them they have a reference cycle?
&gt; That's like saying 1.0/3.0 * 3 should be equal to 1.0. It's just not going to happen. Just for the record: &gt;&gt;&gt; 1.0/3.0 * 3 1.0 &gt;&gt;&gt; (1.0/3.0 * 3) == 1.0 True
WHY IS THIS HAPPENING?!
I always prefer to hire people who write code in their spare time also, to make their lives easier. As a result, I find this a very useful question. People I want to hire will have an abundance of options. Your answer would be most helpful to me. I would know immediately not to hire you. Questions like this that divide the candidate pool clearly are good.
There's more to it than that. Yes, it's an parameter with a default argument, so it is optional to pass an argument. Further, the default argument is a list literal. That same list object (due to the fact that it is mutable) will remain the default argument, and will continue to grow when the function is invoked with no arguments. Try it out in your interpreter.
Is is instantiated when the script is first run, so the same list object is used, not new ones. That's why the following idiom exists: def some_func(mutable_default=None): if mutable_default is None: mutable_default = [] other_stuff() The difference is where the list is instantiated.
The numpy based stack is quite good. It involves skimage and mahotas (which I wrote). You can interact with OpenCV too without too much work. There is also a mailing-list for general python computer vision stuff: https://groups.google.com/forum/#!forum/pythonvision 
Can you elaborate on what you mean? The simple case of "import foo as bar" doesn't do this, because it just sets "bar" in your local namespace to point to sys.modules[&lt;actual_module_name&gt;]. Perhaps there is a way to muck with this in extension modules and their init_module() method? But I don't think that's even invoked, either, when the module is reimported. So, am I missing a corner case, or is your statement incorrect?
First of all, never *ever* use the term "rockstar" to describe a developer again. It's obnoxious and immature. You want to hire competent, mature developers who will write clean, maintainable code. "Rockstar" is code for overpaid prima-donna who will run off at the first sign of an even slightly better offer. As for the actual interview, the best way to judge coding skill is going to be to look at code. I would save the in-person or phone interviews for typically high level questions that gauge cultural fit, and judge programming ability by asking potential candidates to complete a short (1-3 hours) programming question before the interview. This should be something tangentially related to the types of things you plan to use Python for, and it should at least have some opportunities for some elegant, Pythonic solutions. Explicitly state that you would like them to adhere to whatever style guide you follow, and write the code as if it is meant for production, and not a first-pass hack. During the interview, you can always bring up the programming question again, and ask the programmer to walk you through his or her solution. I've found simple, Fizzbuzz type questions to be almost completely useless when it becomes time for an in-person interview. If people who can't complete these sorts of questions are making it all the way to meeting you in the office, you have a serious flaw in your hiring process. You should be vetting them based on their exiting body of publicly available code first, and then asking them to explicitly code something on their own time, before you ever talk to them. Also, none of this is particularly Python specific, because being language-specific is counter-productive. A good programmer is a good programmer, and will be able to master a new language as needed. Look for the types of thought processes that make somebody a good programmer, and not for a "python rockstar".
Many great Python devs have their own public projects that they're working on or have worked on, so asking about projects is a sufficient but not necessary criterion. There are many great devs that are slammed with working on internal projects at their previous place, and cannot really show you any code. You would be silly to exclude those people, because my experience is that they not only know how to better work on a team and have more grounding as "software professionals", but they also tend to understand more of the full stack because they have to integrate with external technologies like .NET or Java. One thing that I've learned, however, is that you must always ask some basic technical questions. Fizzbuzz is an insult - and *should* feel like an insult. Oftentimes, the people I'm interviewing are seasoned enough to have interviewed plenty of other people, and know first-hand that lots of good looking resumes can't code a string reversal. So, these folks understand. Newer/younger folks will get offended by fizzbuzz, but you can explain to them that there are lots of frauds in our industry. Fizzbuzz is also a great way to explore someone's technical grasp of Python. You can go from the simple for loop &amp; if statement, to more pythonic list comprehensions or using map and lambda. You can then ask about doing fizzbuzz driven by input from a file. "It outputs "fizz" with a variable number of Zs based on how many times the word "fizz" has been encountered in the file." etc. You can also creatively pose problems that would be idiomatically solved by sets and dicts, and and see if they know about itertools and generators. Basic topics I would expect a 3-4 year Python dev to be familiar with: * Import, modules, packages. * The existence of multiple interpreters, and basic strengths/weaknesses or at least rationale for each. CPython, PyPy, Jython, IronPython, Stackless... maybe Emscriptened CPython or Brython * Major environment variables: PYTHONPATH, PYTHONHOME, etc. * Libraries &amp; tools relevant to your application domain: * web dev: the major popular frameworks; WSGI; templating libraries; ORM &amp; DB layers; testing libs * IT/devops scripting: remote access, ssl, sys, os, datetime libraries * data analysis: numpy, scipy, plotting libraries, maybe pandas, Cython, etc. * The GIL, what it does and why it exists; why people think it sucks; does it actually suck; mitigating approaches for SIMD and task parallelism * Python 2 &amp; Python 3 * IDEs and dev tools: if emacs or vim, then knowledge &amp; use of the popular extensions for them; if not emacs or vim, then should be conversant about the IDE field like Wing, PyCharm, PyDev, Sypder. (They will encounter other devs who use a mix of these.) * Ecosystem &amp; community: conferences, thought leaders More Python specific things I would ask an architect- or lead-level developer: * Compare Python's object model against [language of their choice]. Usually this is C++, Java, or Javascript. If someone knows ObjC you can ask about dynamic dispatch and compare the two. Of course, this is predicated on the idea that *you* understand these well enough to at least be able to talk about them. :-) * Basic knowledge of Python performance: function dispatch is slow, dictionary lookup is fast, extension modules are readily available for most performance bottleneck areas, and run as fast as C/C++ equivalents. Tools like PyPy, Cython, or maybe even Numba for speeding up critical areas. * Development best practices with a dynamically typed &amp; dispatched language. Tests, docs, docstrings, doctests, coverage tools, lint tools, CI tools 
I don't think their answer would be a good way to judge them at all. It might be a nice thing to chat about around the lunch table, but not a hire/don't sort of thing. I don't go around with my language complaints on the tip of my tongue unless I've just recently had to deal with them. Also the GIL is a valid complaint, there's huge room for improvement (I've read), starting with making the c libraries thread safe. I think that having hundreds of cores is the future, as processing speed advancement slows way down, so having true concurency built into the language without hoops to jump through would be great. Hell I'd like simple openCL support without having to write openCL code. 
&gt;There are a million Python web frameworks out there. How does Morepath compare? There are always technical differences among different things. This by itself is not that interesting. I think the more interesting question is, "what problems does this framework solve that the existing ones have not?" From what I can tell, it's not much, or if anything especially interesting at all.
Your loss. There are many great developers that don't code in their free time. Think about how absurd this assumption would be for other professions. Like surgeons or structural engineers. 
You can't apply it to other people, because surgeons and structural engineers either can't get materials for personal projects or would have to pay exorbitantly to do so. Computer scientists are different, and the best of the best have definitely coded in their free time on a regular basis at some point and have some code to show, even if it was in college or high school.
Calling it with an argument just once creates the potential for confusion and bugs as well. Since it returns a list, it might not be obvious that it modifies the argument rather than returning a modified copy.
&gt; There are many great developers that don't code in their free time. True, but getting a job is, in of itself, a job. If you don't have any code from your most recent position that you can get permission to share, then when you are explicitly job hunting, you ought to spend a week putting together some sort of project. Programming is a mix of art and science, and every artist needs a portfolio. Even if it's not something you do "for fun", it's something that you *need* to put together as part of your professional development. You don't have to spend every single week of your life writing your own code on your own time, but setting aside a few weekends when you're thinking of starting a job search is completely reasonable. Hell - outright tell them that you wrote this code specifically for interviewing purposes - it demonstrates to potential employers that you are serious about this transition, and not just fishing for negotiating leverage so you can get a raise at your existing job. I'm not saying that every developer should have a decade-long history of github pull requests, but a small, self-contained, well-thought-out programming project is really not too much to ask. When you are looking for a new job, you should be practicing for interviews, and what better practice is there than actually writing some code that's explicitly intended as a tool to help you get a new job?
Sure, but then it would be instantiated at import time instead of when it's first used.
If you're looking to hire Python developers specifically: StackOverflow Careers, AngelList (if you're a startup), check out conferences like PyCon or PyData, local Python meetups (I'm guessing there's one in Seattle), Hacker News (on a "Who's Hiring?" post). That said, even though I'm a huge Python guy, I would bet that if you know how to code and understand the concepts, you can pick up Python quite easily (maybe it'll take you a while longer to write idiomatic Python or skip perf bottlenecks) and quickly be productive.
According to Wikipedia, EVE Online uses Stackless Python.
While I was a hiring manager in the defense space employers and candidates alike all understood that this would never happen, but candidates had the good sense to put together a clip book of code samples.. It's only really a problem if you have a naive interviewer who imagined that all candidates ought to be able to arbitrarily produce samples of code from the projects they disclose on their resume. In general the code samples are kind of useless, even though I think they're a nice touch because they indicate that the candidate knows enough about hiring in the industry to go to the trouble. These days everyone I know does homework problems following a phone screen instead of asking for code samples; seeing many example solutions to the same problem makes it easier for the reviewer to be objective, and having candidates code on a whiteboard or etherpad is an unrealistic simulation which usually sucks for interviewer and interviewee alike. 
Too bad it's not interesting to you! I think the answer to this question depends on what kinds of problems you're familiar with. I myself like my web framework to be able to generate hyperlinks for models, and I haven't found any routing web framework that can do this nicely: http://morepath.readthedocs.org/en/latest/models_and_linking.html Generating hyperlinks tends to be a kind "you do it yourself" or "minimal assistance" thing for most web frameworks I've seen, which is weird as hyperlinks are essential to the web. I also like the ability to extend and override applications. This tends to be useful when you have a large core application (like a CMS) that has all kinds of different deployments with customizations, or when you compose a larger application out of multiple small ones, or to reuse common view components for multiple model implementations. I think Morepath offers a rather interesting approach on this: http://morepath.readthedocs.org/en/latest/app_reuse.html Few web frameworks tend to tackle this at all; the only modern one that does in the Python world that I'm familiar with is Pyramid. But none of this may be relevant to you. I'm writing Morepath, so it's inevitably an expression of the problems I have encountered and the things I like to be handled nicely. If these topics *are* in fact relevant to you, then I need to improve my document. You can help me by letting me know how the document could be improved. 
You are right. I should not have said that. People who are all "no" all the time and give reasons why they can't do something annoy me, and I reacted poorly.
I'd agree with this. The generic questions are useful, but getting a language expert shouldn't be overlooked if you *need* that language. Speaking personally, I've picked up programming languages for jobs many times, but for the first many months, language experts would have laughed at my code, then for a few months it would have been merely sufficient before finally becoming good. Still, it takes years to be incredibly good at it.
Hife a C++ programmer who is willing to code in Python. That way you can use swig if you need to.
If you have xlsxwriter installed, it'll actually be the default writer used - I've found it has way better memory usage than openpyxl.
Going to be releasing 0.13.1 soon!
&gt; Like surgeons or structural engineers. You'd be surprised at how many aerospace engineers have done a preliminary design of an aircraft in their free time or written software to help them automate it.
I read an article a while back about why memorization is still valuable in the age of the internet, when we will be within 30 seconds to google-access for 90% of our lives. The problem with research is that the researcher has to know what question to ask, and how to phrase it. Now, don't get me wrong- it's obviously possible to perform meta-research. Instead of asking "How did you solve X bug dealing with Y library under Z conditions?" you might ask "What could cause X bug?". Surely, that's part of any skilled developer's repertoire. The problem is that with every meta-question one asks, the chance of missing the answer increases. Now, this isn't a condemnation of your method, just that language-specific knowledge isn't useless when the Doc is one click away. A developer still has to know what to look up and ask for. To some degree, you're saying the knowledge should be focused on theory (and I agree, since theory -&gt; language goes a lot further than language -&gt; theory), but I don't think it's a foregone conclusion that language specific knowledge should be unexpected.
For me I would say, here is my github address, feel free to poke around.
&gt;'m also noticing that the python community itself doesn't seem very big compared to other languages This is definitely not true. The Python community is huge, since many non traditional people(non CS) are learning Python.
I find I always get positive results when I post a crappy algorithm I made on stack overflow and ask how to improve it. I always learn a ton and people love the chance to critique and teach 
Why don't you like 2.7 outta curiosity? Stackless cython and a bunch of other great libs/implementations don't support 3.3
What is meant by "stackless" python? Does it not have a function-call stack, or does it mean something completely different?
*Here's a bit from linked Wikipedia article about* [***Stackless Python***](http://en.wikipedia.org/wiki/Stackless%20Python) : --- &gt; &gt;**Stackless Python**, or **Stackless**, is a Python programming language interpreter, so named because it avoids depending on the C call stack for its own stack. The most prominent feature of Stackless is microthreads, which avoid much of the overhead associated with usual operating system threads. In addition to Python features, Stackless also adds support for coroutines, communication channels and task serialization. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/xucheng can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**Summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1vj3te/are_there_any_python_made_games_on_steam/cess07s)
It's a different interpreter, which does not rely on the C call stack and uses its own system instead.
Various visual novels using [Ren'Py](http://renpy.org/) engine are on Steam, including: * [Analogue: A Hate Story](http://store.steampowered.com/app/209370/) by Christine Love * A sequel called [Hate Plus](http://store.steampowered.com/app/239700/) * [Dysfunctional Systems: Learning to Manage Chaos](http://store.steampowered.com/app/248800/) by Dischan And probably some others. Ren'Py actually seems to be quite popular among non-Eastern visual novel developers.
Here's some good Python-specific interview questions: 1. What is, in your opinion, the most annoying part of the PEP8 standard? 2. What are new-style classes, and when should they be used? -- expect a mention of python 3 and how doing it that way isn't required; also expect that they would always use them in python 2.x. 3. How to swap 2 variables without using a temporary variable? `a, b = b, a` 4. When should one use meta classes? -- This is sort of a trick question about complexity and keeping things simple. Answer: only when its absolutely necessary. This shows understanding of [the principles behind Python](http://www.python.org/dev/peps/pep-0020): simple is better than complex and explicit is better than implicit. 5. What static code analysis tools have you used? 
Depending on where you are located, "When can you start?" is probably the only one since you'll be darn lucky if you find one and they actually show up for an interview. But I would ask for code samples too because crap can be written in any language.
It's the only visual novel engine with documentation and tools available in something other than Japanese. There have been efforts to translate popular Japanese tools like OnScripter or KiriKiri2, but none of them are nowhere near completion, afaik.
I read it, I just didn't get enough replies on r/learnpython so my problem wasn't solved. However I figured it out now so that's fine.
I enjoyed reading it more than a lot of the stuff that appears in this subreddit. So keep it up. I don't really have any suggestions, but I did enjoy reading about reg as an alternative to zca. 
I'd agree with cliffm because it's generally a sign of not wanting to adapt. As time goes on the list of things 3 can't do grows slimmer, yet we still have people saying "2.7 alllllll the way".
It's good to be explicit in these things. That's exactly right.
sweet dude/tte thanks! 
in Python, that syntax defines a default value for the parameter that will be used when an explicit value of the parameter is not passed in at function invocation. there can be some tricky behavior involving default assignment if you use mutable values though, which is what the original post was testing for. in order to get it right you would have to know in some depth how Python implements lexical scope and how Python's variables work. 
I use python everyday at work... I guess programmers never really stop learning. :D I have never gotten in super deep into how and why things work in python, I just understand how to make them happen with a little tinkering at times.
Are there still third-party libraries that haven't migrated? That might be a valid reason to not switch...
Thanks! I hope I discover something very cool!
You're missing a corner case, which used to be fairly common in Django circles, due to the way projects were laid out by default. If I have my python path set to /var/local:/var/local/project, I can do import foo, project.foo, and get the same module imported twice, as two separate module objects.
No offence, actually, with offence, most of you would make terrible hiring managers. Expecting candidates to donate free hours of work before an interview, programming tests, ridiculous quizzes on python specifics and comp sci specifics, wanting to see a github account([read this](https://blog.jcoglan.com/2013/11/15/why-github-is-not-your-cv/)? You are not going to get good people with these things. You probably won’t get anyone. Judge people by their resume. If they worked at a few companies, and had promotions, and have good recommendations, one of two things happened. Either they were good at their job and were recognized for it, or they are masters at duping potentially dozens of managers and programmers for years on end into thinking they know what they are doing. That many people are not that stupid, so chances are they know what they are doing. Next, make sure they are a culture fit. This is super important. An anti-social, prima-donna douche will bring down your team. &gt; where do I find rockstar python devs to hire You have to go local Python or related meet-ups, or reach through your own professional network to find one. Hiring is a process that never ends. You always have to be out meeting and greeting devs for when you need to scale or fill in a seat when one leaves. Also, Python is not a difficult language to learn. Any experienced dev from another language and similar domain speciality could quickly learn it. For example, a Ruby on Rails dev could quickly become a Django dev and vice-versa.
Sure, "the GIL" is a valid thing to complain about, but if your complaint is that you can't do concurrency, or take advantage of multiple cores with python, then you have just demonstrated your limited knowledge of python.
[A few but not a lot.](https://python3wos.appspot.com/)
speiiling: prospective. just for fun! one hand washes the other.
It grows slimmer, but not nearly slim enough. The libs and implementations I use every day haven't migrated and its as simple as that. I won't either. Its less an unwillingness to adapt and more an unwillingness to sacrifice.
Unity of Command [steam](http://store.steampowered.com/app/218090) [dev website](http://unityofcommand.net/)
Rather than looking for amazing python devs, look for amazing devs. By the time you get to "amazing", learning languages is not an issue. Ask language agnostic questions and let them answer in whatever language they want.
just remember that there is a limit to how much public traffic can go through your Dropbox. I hosted an article on Dropbox which went viral and they shut it down. 
so the bulk of the complicated functionality is in the processing payments (3rd party) and db persistence(library) but flask gets the credit because of request routing. LOL
I've been programming for 30 years, and I've wrote extremely complex systems in Java / C++, and assembly. I've used operator overloading in C++ when it was appropriate, but I've never used template metaprogramming. Not knowing the edges of the language is not a problem, if you know the core. Java does not have operator overloading, but I've written large scale programs in the language, so using the same approach I could do the same code in C++, the code might not be as elegant or as efficient but the end result would be very similar. Python has generators which should be considered to be fundamental to an advanced programmer, but features such as metaclasses, writing decorators may not be as important (if you are working on a framework then the metaclasses may be essential). Before someone attends for the initial interview send them a small task (approx 1 hour of code) and ask them to program it (that cuts out some time spent interviewing candidates who are not appropriate and saves them time from attending an interview for a position they are not suitable for). After the interview ask for a more substantial project, where there will be a payment for the project (1 week max) and that can be used to distinguish between final candidates.
This is a VERY common problem, and completely expected for anyone learning to program. I'm a professional Python tutor on the side, and the only reason such a job even exists is because plateau-ing like this is so common. With my tutoring clients, we typically choose a small project that's intellectually interesting to them. They watch as I code a simple skeleton for the project (i.e. writing proper docstrings, defining the functions that will be required, properly running and exiting the script using "if __name__ == '__main__'", etc). After they see the project laid out like that, clients are typically able to take over and start implementing the functions one by one. As they go, we discuss their code and if there's a better way to write it. It's probably not the answer you're looking for, but finding a good tutor can *drastically* speed up how long it takes to pick up the language.
And tech aside, Analogue is a really fantastic game, if you're into visual-novel-gameplay.
For this initial analysis, I only compared simple Python code, but the results were quite interesting, and in some cases not so obvious. I'd welcome any thoughts and comments about the code and approaches I used. I hope we can start an interesting discussion here!
Some, but that excuse is growing weaker every day. I would suggest that the libraries that aren't compatible, may never be, and it's time to find replacements or to fork them and make them work.
I've heard people say their libraries haven't migrated before, without realizing that their libraries aren't maintained really anymore, and that new replacements already exist. How often do you research Python3 alternatives for your libraries? Probably not often at all, based on "2.7 allll the way". Exactly what I'm talking about.
The only reason that the complicated functionality is processing payments and persistence is because Flask gives you so much out of the box. The only things that remain are the problems you're actually trying to solve, rather than fighting with the framework.
Thanks for that. What's the best way to go about finding and choosing a 'good' tutor?
Mechanical engineer turned computer systems engineer here, I love python!
My problem with Flask isn't Flask. Its the same problem I have with web2py. All the jobs are for Django. :p
Elsewhere in this thread I have said things that mostly agree with you, and I admit that my statement was an over simplification. The bigger point was that a competent recruiting process should weed out people who would fail at fizzbuzz, based either on professional accomplishments or public code repositories or on a side project created explicitly to share with potential new employers or on a programming exercise you've asked candidates to complete. If people so grossly incompetent as to be eliminated by almost insulting tests are making it to your interviews, you are doing it wrong. 
Thanks, it's good to hear it was interesting to somebody! :)
And as new libraries are backported, the list of things you need 3.x for is pretty short too. In the scientific/numerical world 2.7 is still far more common.
I prefer pyflakes to pep8 and pylint because it mostly tells me about actual code problems, and doesn't nitpick about coding style. So I'm interested to see development on it. It looks like pyflakes development had another little flurry of commits two days ago, though. Are you in contact with Florent to try to consolidate the two forks?
This is pretty neat. I hope the Python 3 developers follow up on format performance. I'm not sure the regression compared to % matters a lot for most applications, but it seems it potentially could at least. 
Thanks. I was really surprised this particularly poor performance of `format()`. I will test it on other machines with older versions of Python 3 and compare it to Python 2.7. I made it a habit to use `format()` over the `%` operator in most of my code, so this is really unfortunate.
My girlfriend saw my playing it and said I was the only person she knew who would find a terminal-based section in a game fun.
I believe that is backend only
For the dictionary increment there are 3 other cases you should consider, using Counter, DefaultDict and count[i] = count.get(i, 0) + 1
I revisited the test using python 2.7.5 and the results are quite similar: `%` is much faster than `format()`. However, in Python 2.7.5, the regular `+` concatenation is ~ 2x faster than `%` So in summary cpu time in Python 3.3.3: `+`-conc. == `%`-operator &lt; `format()` cpu time in Python 2.7.5: `+`-conc. &lt;`%`-operator &lt; `format()`
Honestly, I have no idea. I'm on the other end (i.e. finding clients), so I've not had to do so. When you do find one, however, ask in advance what the curriculum will be. I always tailor it to my clients backgrounds and goals, so be wary if it's a fixed "course" (or worse, there is none). Perhaps sending an email on the python-tutor email list might find you someone (although the list is more for people to ask questions)?
If you installed it it should be in the start menu under python 
thanks, good points. Something I include in the next analysis!
Why should data locality be any worse? In the copying case I will have a new list evicting the old one. I don't see how this is more cache efficient. In the non-copy-ing case I only have an expected number of n/2 data movements per iteration. In your copying case, your have n data movements. This is the same reason why quicksort is faster in practice than mergesort.
One of the smaller of the many changes in the new 0.13 release of the Pandas data analysis library is the addition of support for XlsxWriter as an optional Excel writer engine. [XlsxWriter](http://xlsxwriter.readthedocs.org/) is a fast and fully featured Excel XLSX file writer module. One of the advantages of Pandas is that you don't have to use Excel for data analysis but if you are dumping data to Excel then this new engine offers a wide range of additional Excel features. For example you can you now insert charts into the Excel files that you create from a Pandas dataframe. The above is a link to a mini tutorial that I wrote on how to do that. 
I would *love* a job working with Django. Everything out here is Java, C#, and PHP. It's a viscous cycle of "it's made in PHP so we need to hire PHP devs, and then are next project is in PHP, and we lost some guys so we need to hire..."
&gt; Luckily, Stripe makes accepting credit card payments stupidly easy, and I already had an account with them. Their "checkout.js" solution creates a form and button on your page. When the button is clicked, a simple and attractive payment overlay is displayed. Sadly, Stripe have recently downgraded checkout.js to the same kinds of nasty behaviour as various other payment services, prompting our customers for things like an e-mail address that Stripe don't need and a checkbox they can use for making other payments with Stripe on other sites quickly later (but getting in the way of signing up with us right now). Along the way, they've also converted a single pop-up form into a two-step process, and the first page only asks for personal details that probably many sites already asked for once if the user was creating some sort of account. We recently had chance to watch a few customers trying to sign up in person using the new checkout.js. It was painful, with numerous obvious usability problems that we hadn't realised were there because we'd done our original testing on a previous version. It made us wonder how many conversions we've lost in recent weeks since those changes took effect, and moving to a custom form so we can dump checkout.js as soon as possible jumped right to the top of our to-do list.
It's not foolish if the rest of the team is Django and all the current code is Django.
Ah, interesting. That is is a really unfortunate pythonpath, though! :-) I wonder, though: if foo was actually a .so/.pyd, does Python actually run the init_module() twice?
Flask has 3.3 support. But less than 1% of the community uses it. I need 100% up time on my tools. This isn't a product, chasing down untested python 3 bugs will not improve productivity. But let's say I did want to man up and go for it. Our data analytics tools run stackless. Flask only supports 3.3. Stackless only supports 3.2. I'm not against python 3. But until everyone is on the same page the value add is not there. Considering I'm fighting for new C++ compilers 3 days a week I'm pretty invested in upgrading our environments. But there has to be a real immediate value add or I can't justify the overhead. Its not ignorance. Its real world code.
You're running python 3.3, so print requires parentheses, i.e. print("Hello world!") This is one of the differences between python2 and python3.
[Stackless Python](http://www.stackless.com/) is a variant of the main Python interpreter/language that has native support for 'microthreads'. Basically, it's designed to handle multitasking better.
You'd be surprised how many people that should know better in that regard just don't.
If they really are as similar as you say then I have to agree with you.
I'm a PL/SQL programmer and right now I would love working with Java.
'Thats basically what I do now, and why I was ok with diving into python myself.. it was just another language to code in to me but I have a hard time finding other people who feel the same.
What sort of task? I worry about plagiarism, its something I have had to deal with in the past.. one guy even once stole something I worked on and tried to pass it off as his, not knowing I was involved because he had been contacted by a third, different, person.
Honestly if you're familiar with one web framework, it'll take you six weeks to be decent with any other web framework. FTEs aren't productive after only six weeks anyway.
For the 1 hour task, take some existing code and ask for new functionality. So for example the XKCD recently had the regex golf on their and Peter Norvig posted a solution, but it didn't have character classes. That took around an hour or less to add, but it is the sort of thing where you have to be read code and understand it, and come up with a solution. You should ask applicants when is a good time to send a small task that should take around an hour, and email to them when they have free time, and you should expect reply within 4 hours (to allow for interruptions etc, since they are not being paid). It cuts down on totally unqualified people applying, and also on people who are not serious (ie, on unemployment and they have to apply to jobs).
If you're not already using it, use flask-bootstrap and wtforms. One line of template to render a complete form (including errors etc?)? Yes please! https://github.com/mbr/flask-bootstrap/blob/master/sample_application/templates/index.html
We are not using Django, we are using Pyramid/SQLAlchemy would that still work out? Django as a community tends to not work well with others.. don't want to stat any religious wars ;)
routing requests to functions is not complicated. 
Very good, thank you!
Thanks!
I wouldn't hire anybody who refused to answer questions, especially o the basis that the interview was unpaid. That just tells me they care about money more than code... and I love code more than money and thats why I make so much more money than people who only code for a job.
Ouch I feel pain looking at that and I still consider myself a python noob.
I actually ask that.
Do I expect them to bring it with them?
Half of this question was for me to find things I could learn on my own so they couldn't do hand waving :)
i think the point he is trying to make is how unbloated flask is compared to django when trying to solve these littleish problems, which is true
I agree with that, and am a major Flask fan, but it doesn't follow that Python and Flask are "ridiculously powerful" just because OP made a simple app that could wrap around Stripe and display some messages.
My condolences.
&gt; As a developer, I sometimes forget the power I yield. I suspect you mean "wield".
Bootstrap + flavor themes would be my recommendation. http://bootswatch.com/
[Dangerous High School Girls in Trouble](http://store.steampowered.com/app/27400/) is [pure python and pygame, packed with py2exe](http://www.pygame.org/project-Dangerous+High+School+Girls+in+Trouble!-791-.html). Galcon deserves a mention, even though the version(s) on steam aren't python (Galcon Fusion was multiplatform, at a time when getting a python app into the iOS store wasn't really feasible, so they did it in C++ and then continued with C++ afterwards). But the first commercial Galcon was [done in pygame](http://www.pygame.org/project-Galcon-340-.html), the author Phil Hassey's blog is carried by planet.python.org, and they've even released a game on steam ([Dynamite Jack](http://store.steampowered.com/app/202730/), rewritten in C++) that began as [a PyWeek entry](http://www.mechanicalcat.net/tech/PyWeek/1/entrants/philhassey).
So basically, by your metrics, the only people anyone should ever hire are people with years, possibly decades of directly relevant experience, in multiple companies to minimize the chance that they duped a single manager? Yeah, that's definitely a worse way to look than asking for an hour or two to do some coding demos. Hell, I've interviewed with big web companies and had them expect me to come back for multiple all-day-long interviews. Wasting an hour of my time on a weekend completing a coding exercise would be a hell of a lot better than being dicked around for three months while twelve different departments input their two cents into the process. I get what you're saying, that interview processes are dickish, and most hiring managers are incompetent boobs - and I actually agree. However, you're proposing the far opposite end of the spectrum, which is ALSO not productive. You have to find a reasonable middle ground.
Unintentional double negative in a programming sub? Yikes. 
this is excellent advice, and far better than "compete this well known example from Codekata" or "design a sort algorithm for blah blah blah". Taking an already mostly-complete example (possibly some internal code that is not so valuable that protecting the IP is important) and adding functionality to it demonstrates both the ability to read code and the ability to write it - two skills that are not always found together.
'rediculously powerful' is the only sort of thing that gets clicks these days on reddit it seems, sadly. And I agree it's lame. I think an article title 'Flask is an improvement over django in this case' should be great. 
there is no UI. it's a really simple service that parses an HTTP header, does a SQL query and then returns a 302 redirect. if I had needed a UI, I would have walked down the hall to the design team and asked them to make me one :P
 def get_power (power_level): while (True): power_level += 1 yield power_level Edit: thanks pyrocrasty
[Found an answer](http://superuser.com/a/343565/259627). How did I find it? Google. :)
Depends on what I'm hiring for ... If I need a contractor for a project that's already in Django, I don't want a Flask/Bottle dev having to come up to speed on Django - it's a waste of hours. If I'm hiring for a full time position, then there's time to ramp up. 
It may be more likely that a recruiter-type will reject you, on this basis. That happens often enough. But I'd really like to think that technical interviewers would know better.
Thanks, I really appreciate it! One thing though, (if you know) I followed the steps and merged the reg file: &gt;Windows Registry Editor Version 5.00 &gt;[HKEY_CLASSES_ROOT\Python.File\shell\Edit with IDLE\command] @="\"C:\\Python33\\pythonw.exe\" \"C:\\Python27\\Lib\\idlelib\\idle.pyw\" -e \"%1\"" &gt;[HKEY_CLASSES_ROOT\Python.NoConFile\shell\Edit with IDLE\command] @="\"C:\\Python33\\pythonw.exe\" \"C:\\Python27\\Lib\\idlelib\\idle.pyw\" -e \"%1\"" But when I later right-clicked on a .py file, I had no option to edit with IDLE. It does however work with .pyw. Do you know what I should do? I'm thinking that the problem was that the first one used pythonw.exe instead of python.exe, but I don't know how to undo the changes I already made.
syntax error ;-) def get_power (power_level): while (True): power_level += 1 yield power_level 
So true. i use web2py for personal projects. Django or Rails are for work although I take almost any chance to work with web2py at a paid gig. I definitely understand it from the recruiters perspective though. It takes a few weeks to get really productive with Django and learn it's quirks. Also, no one ever got fired for going with Django. 
It would be great / helpful to add the tools listed here which support semver.org to an #implementations section (such as https://github.com/mojombo/semver.org/issues/57)
&gt;Software using Semantic Versioning MUST declare a public API. This API could be declared in the code itself or exist strictly in documentation. However it is done, it should be precise and comprehensive. The "should" should be in ALL CAPS, and the MUST is questionable given the relative vagueness of this line. &gt;Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version. While modifying an old version is generally a Very Bad Idea, it is overly prescriptive for a version number standard to absolutely forbid it. This also implicates list items 6-8.
I'm pretty sure that Cryptic uses python for some of their backend stuff, but not everything is made with python. 
Employers now want someone that is plug and play. No training period, just come in and be productive asap.
&gt;&gt;Software using Semantic Versioning MUST declare a public API. This API could be declared in the code itself or exist strictly in documentation. However it is done, it should be precise and comprehensive. &gt;The "should" should be in ALL CAPS, and the MUST is questionable given the relative vagueness of this line. That does seem out of scope. &gt;&gt;Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version. &gt;While modifying an old version is generally a Very Bad Idea, it is overly prescriptive for a version number standard to absolutely forbid it. This also implicates list items 6-8. Bad/failed/scratched builds should be incrementally later. Why assign the same version string to two separate things? "Let's just reuse this UUID and hope it's not cached anywhere?" 
Why is there no mention of NDFrame in the documentation? I don't understand why there's no generic way to build the appropriate data structure from a numpy array of unknown dimension, or by stacking structures of dim N-1.
The job I have was advertised as being primarily a PHP gig, but I've managed to smuggle Django in for several projects, to the point that it's now my go-to framework. They love the admin interface and how quickly you can prototype an application.
It's also packed with Py2App for Macs. [7 Grand Steps](http://www.7grandsteps.com) is made the same way by the same developer, me. :-)
I usually ask them to send it to me after the interview. I don't read it during the interview, since I imagine they have better things to do than sit watching me read their code.
I have a hard time taking this seriously with inline HTML.
&gt;"I was actually surprised at how quickly and easily I got this working" i code on my free time. one of the reasons i moved to python is this. after work you have 2-3 hours. you need to get things done as fast as possible. i initialy used bottle and i was surprised i had a website running in 5 LOC without any XML bullshit at all. But the thing with python its not olny about LOC Its also readability. I consider python as one of the most readable languages out there. 
English is not my main language and it was posted quite late where I live :) Sorry ;)
Coding style ;-) def get_power(power_level): while True: power_level += 1 yield power_level 
+1 for pep8 personaly i sometimes ignore E501 line too long (82 characters). whats your answer to 1 just ouf of curiocity
The difference on CPython 3 is probably due to flags (`nfib.__code__.co_flags` vs `fibhy.__code__.co_flags`.) CPython has an `if` branch that slightly optimizes calls to functions with no keyword arguments and default values, but only if those functions have `co_flags` set exactly to `CO_NEWLOCALS | CO_OPTIMIZED | CO_NOFREE` (0b1000011 in binary form.) Hy also enables a couple flags I don't recognize: 0b10010000000000000. (probably some CPython 2-specific `__future__` imports.)
Other than bootstrap that comes to mind is gumby and foundation (from zurb). I mainly use bootstrap-sass and mainly use it for its grid. It would be nice to see something not so bootstrapish once in a while. (I'm on my mobile or else I would've posted links to those frameworks)
[Long Live the Queen](http://store.steampowered.com/app/251990/) is a pretty decent game made using Ren'Py, too.
Putting Flask to title means more upvotes. Post is basically click-bait.
Vampire: The Masquerade – Bloodlines uses python for some scripting tasks. If you use the fan patch you can easily read its source.
Has anybody read his book and can tell me if it's as packed with insights as this article?
&gt;manage stack in pure Python And how does this help with multitasking? The wikipedia article is a bit dense for my puny brain...
The main point is the C stack and some other OS API require the CPU changing between user state and kernel state. And it slows down the program. By managing all these by interpreter itself, CPU will stay in user state, therefore speed up program.
Which version of python? You don't seem to mention it in your readme file. I have never used pyflakes.
It's perfect now!
How do most people run Flask in production? I've used uwsgi and it was a bit awkward. Is there a better way?
Does Flask actually do anything more than web.py?
I have to say that the way Python does decorators is one thing I love about it. It is just so "clean". As long as you have the background knowledge of first-class functions, closures, etc you can understand and create your own decorators very quickly. 
Does GOG count too? [Blade of Darkness](http://www.gog.com/game/blade_of_darkness) uses Python for all game logic, even the save files are actually Python scripts (which is a somewhat questionable approach by the way).
2.6 - 3.4. Glad you noticed the lack of this info in the readme, will add it soon. Thanks! Tim 
So it's in-process thread scheduling of sorts? We're still restricted to runnong on one core, right?
Correct me if I'm wrong, but can't Conda only install packages provided by Anaconda? Pip allows you to install any python package. I'm pretty sure the Anaconda documentation says to use pip for anything not available through the Anaconda package index. Since you mentioned Mac, have you tried MacPorts (what I use) or HomeBrew?
The recent release of anaconda changed this: it will install any package available on pip. To upgrade, just type conda update conda
Flask app + everything it needs in a virtualenv including gunicorn and then Supervisor to take care of starting, stopping etc. I find that supervisor+gunicorn is easier to configure than uwsgi. uwsgi got way more features though so it depends on what you need.
Yeah
If you work with python packages which include compiled code (such as numpy, scipy, scikit-learn, etc.) there is no reason to use pip and virtualenv any more: they are simply the wrong tools for the job. Conda does everything they were designed to do, and does those things much more cleanly and with far fewer headaches. Try typing "pip install scipy" and then get back to me. If you're using packages written in pure python, pip works well, and virtualenv mostly works. Even in this situation, though, I find conda easier to use, as it handles interweaving dependencies in a much saner manner. EDIT: typo
Did you test it on Python 3.3.3? When I used Python 2.7.5 I also got much less than 10x differences (i.e., 2x using my simple test scripts). 
&gt; If you work with python packages which include compiled code (such as numpy, scipy, scikit-learn, etc.) there is no reason to use pip and virtualenv any more: they are simply the wrong tools for the job. Pip installs and compiles packages with native code just fine. What makes them "the wrong tool for the job"? What does conda do that makes it so much better than pip+virtualenv? Looking at http://docs.continuum.io/conda/ conda's environments seem less clean and convenient than virtualenv. (I have to manipulate environment variables directly?)
How about redis? https://devcenter.heroku.com/articles/redistogo
Fixed. This is one of the funnier typos I've made recently. I have Python on the brain I guess...
Docstring missing :) def get_power(power_level): """Return the current power level.""" while True: power_level += 1 yield power_level
No, it's not. I guess I was just surprised at how much I was able to do given such a small amount of code and so few tools. If the LOC to application functionality isn't impressive to you, than I guess the whole article probably sounds pretty tedious, which I can understand.
You'd rather I didn't let people know that I've come up with a free way to manage selling digital products online? If that's not useful to you, that's fine. Calling the article click-bait because it uses the word "Flask" seems pretty extreme, though.
As jakevdp mentioned: &gt; Try typing "pip install scipy" and then get back to me. pip is great for pure-python packages, and OK-ish for simple C extensions (but it cannot solve C dependencies). For numpy, which not only requires C, but also Fortran, life becomes more difficult rapidly. Then, with Numpy, life becomes even more difficult because you typically want to link to an external LAPACK library to get vectorization working. For an experienced linux user, that takes about a day to get working. On Windows, I don't even want to think about it. 
I'll just point out here - if this is interesting but you don't want to download the ENORMOUS default anaconda install, you can try it out with miniconda: http://repo.continuum.io/miniconda/
But it will use pip to do so, so this is kind of a moot point. If something is hard to compile and conda does not provide a binary installer for it, conda won't solve your problem. It's still awesome though.
I would pay money for `conda install pyqt5`. Apart from that, conda has pretty much replaced pip for me. However, I usually go `brew install python3`, *create virtualenv*, and only then `pip install conda`.
My answer to #1: What is, in [my] opinion, the most annoying part of the PEP8 standard? I dislike the fact that each and every method is required to have a docstring. I'm a big fan of self-documented code, so I prefer to not have to need docstrings for each function. My philosophy behind commenting is that one should use comments to either point out external references (like footnotes) or to explain why the code was designed in the way that it was designed, even though the developer did do a good job of using expressive and well-though-out names. Confession: I only know this because I use Pylint + Vim. :) 
I think, it's a great learning experience to reinvent the wheel - one should not expect the most robust software, though.
Brilliant! Thanks for the update.
&gt; I have to manipulate environment variables directly? No - at least I've never had to. There's a more complete description on creating and switching between environments here: http://www.continuum.io/blog/conda One huge benefit of conda over pip/virtualenv is that it allows you to cleanly switch between python 2 and 3: vital for package developers trying to maintain dual compatibility. Regarding the cleanliness and convenience of virtualenv: if you take time to look in detail at the horrible hacks that virtualenv is built on, my hunch is that you'd no longer be tempted to call it "clean".
Why go through the trouble of doing that if you're just needing a small solution? If he was building a large commerce site, I'd question his use of Flask over Django, but he just needed a simple way to sell his book. Plus, Django weighs in at 147MB. Flask it self is only 7.7MB -- factor in werkzeug (15MB), jinja2 (7MB) and itsdangerous (464K) and you end up with 30MB rounding up, almost a fifth the size of Django. Given disk space at this size isn't a main concern (hopefully), it just goes to demonstrate the size and scope of these projects. Django comes with a bunch of things whereas Flask doesn't. They have their niches. Flask fills this need better than Django because Jeff didn't need all the extras that Django uses by default. I'm not saying that Flask is superior to Django or whatever as a blanket statement, just that it fits better in this situation. He could have used web2py or cherry or bottle or pyramids or whatever else he wanted.
IPython itself is relatively lightweight, and would install via pip just fine. Features like notebook/parallel/qtconsole/etc., on the other hand, are much more involved: they have many dependencies, both python modules and system libraries. With pip alone, plan on spending a half day getting them installed on linux, and don't even attempt it on windows. Or, you can just type ``conda install ipython`` and be done in 30 seconds on any architecture.
On Windows, unless you really need them segregated on virtualenvs, you can just use the [precompiled binaries](http://www.lfd.uci.edu/~gohlke/pythonlibs/). It's not impossible to make them work on your virtualenv, but it'll need some moving around of files from the main site-packages to the virtualenv's.
&gt; One huge benefit of conda over pip/virtualenv is that it allows you to cleanly switch between python 2 and 3 I've never tried this, but I can't see any particular issues that would arise with such a switch. What's the problem with virtualenv, and how does conda fix it? &gt; Regarding the cleanliness and convenience of virtualenv: if you take time to look in detail at the horrible hacks that virtualenv is built on, my hunch is that you'd no longer be tempted to call it "clean". I've looked at the inside of the `activate` script, and even hacked the virtualenv script itself to fix a bug. I would hardly say that it involves horrible hacks. 
[Crea](http://steamcommunity.com/sharedfiles/filedetails/?id=189066547) (which is still in Greenlight) uses Python for all of its scripting.
&gt;Just because [] is an empty list doesn't make it stop being a list type. Right so why does it sometimes act like a boolean. I don't see the difference between wanting 1 + [] to work and if []: to work. Both seem equally valid/invalid depending on your perspective but inconsistently one works and the other does not. &gt;next person to pick it up isn't entirely comfortable with Python's behaviors The problem is that even if you are a experienced python programmer it can still lead to silent bugs. The bug I was referring to was not because I did not understand that in python None could act as a boolean. Knowing that helped me solve the bug faster. But the silencing nature of how None acts as a boolean meant it took longer to realize there was a bug at all. This is made much worse when you have to rely on other peoples libraries. 
Thanks! Never knew that existed, and installing a bunch of unnecessary packages always bugged me.
&gt; What does conda do that makes it so much better than pip+virtualenv? Basically pip is a source based tool. You download the package as source(c or fortan, etc), compile it on your own. And often got stuck with dependence issues. Conda on the other hand is a binary based tool. You just download it and use it. Also this means you cannot control how to compile packages. And there's a delay between package's update to conda's update. 
It is a good book with a lot of nice examples. And he regularly releases updates. Everyone on my team has access to the book; it's nice to be able to get how you're writing code out of the way and focus on what you're writing.
&gt;I've never tried this, but I can't see any particular issues that would arise with such a switch. What's the problem with virtualenv, and how does conda fix it? Conda is a single framework within which you can switch between py2 and py3. Virtualenv must be attached to one or the other, so you need two entirely separate frameworks set-up to accomplish this. In my experience, this adds needless complication, and my workflow is much cleaner after switching to conda (though this is admittedly a minor point compared to all the others brought up in this thread) &gt; I would hardly say that it involves horrible hacks. To each his own, I guess. But the number of issues threads I've seen which boil down to "this is an unintended side-effect of virtualenv's design" make me feel otherwise.
Yes, *I am* using Python 3! On Python 2 the optimisation of the `%`-formatting doesn't happen. dis.dis(compile("'a' + '1' + '2'", "", "exec")) #&gt;&gt;&gt; 1 0 LOAD_CONST 5 ('a12') #&gt;&gt;&gt; 3 POP_TOP #&gt;&gt;&gt; 4 LOAD_CONST 3 (None) #&gt;&gt;&gt; 7 RETURN_VALUE dis.dis(compile("'a%s%s'%('1','2')", "", "exec")) #&gt;&gt;&gt; 1 0 LOAD_CONST 0 ('a%s%s') #&gt;&gt;&gt; 3 LOAD_CONST 4 (('1', '2')) #&gt;&gt;&gt; 6 BINARY_MODULO #&gt;&gt;&gt; 7 POP_TOP #&gt;&gt;&gt; 8 LOAD_CONST 3 (None) #&gt;&gt;&gt; 11 RETURN_VALUE dis.dis(compile("'a{}{}'.format('1','2')", "", "exec")) #&gt;&gt;&gt; 1 0 LOAD_CONST 0 ('a{}{}') #&gt;&gt;&gt; 3 LOAD_ATTR 0 (format) #&gt;&gt;&gt; 6 LOAD_CONST 1 ('1') #&gt;&gt;&gt; 9 LOAD_CONST 2 ('2') #&gt;&gt;&gt; 12 CALL_FUNCTION 2 #&gt;&gt;&gt; 15 POP_TOP #&gt;&gt;&gt; 16 LOAD_CONST 3 (None) #&gt;&gt;&gt; 19 RETURN_VALUE Measure of overhead: &gt; python2 -m timeit "for i in xrange(1000): pass" 100000 loops, best of 3: 14.2 usec per loo Measure of times: &gt; python2 -m timeit "for i in xrange(1000): 'a%s%s'%('1',i)" 10000 loops, best of 3: 179 usec per loop &gt; python2 -m timeit "for i in xrange(1000): 'a{}{}'.format('1',i)" 1000 loops, best of 3: 297 usec per loop &gt; python2 -m timeit -s "mkstring = 'a{}{}'.format" "for i in xrange(1000): mkstring('1',i)" 1000 loops, best of 3: 262 usec per loop And for Unicode: &gt; python2 -m timeit "for i in xrange(1000): u'a%s%s'%(u'1',i)" 1000 loops, best of 3: 306 usec per loop &gt; python2 -m timeit "for i in xrange(1000): u'a{}{}'.format(u'1',i)" 1000 loops, best of 3: 619 usec per loop &gt; python2 -m timeit -s "mkstring = u'a{}{}'.format" "for i in xrange(1000): mkstring(u'1',i)" 1000 loops, best of 3: 587 usec per loop Relative timings: Bytes: (297-14) / (179-14) ≈ 1.7 Optimised: (262-14) / (179-14) ≈ 1.5 Unicode: (619-14) / (306-14) ≈ 2.1 Optimised: (587-14) / (306-14) ≈ 2.0 2.7 ÷ 3.3 (incl. overhead): %, byte str vs unicode str: 0.63 %, unicode vs unicode str: 1.07 .format, byte str vs unicode str: 0.78 .format, unicode vs unicode str: 1.62 mkstring, byte str vs unicode str: 0.76 mkstring, unicode vs unicode str: 1.71 So basically for speed 2.7's str &gt; 3.3's str (unicode) &gt; 2.7's unicode ... but since the world is Unicode anyway... :) 
This is very cool. Do you have any plans to do anything similar for the other office formats (e.g. docx)? 
I'm very, very happy to have XlsxWriter available for pandas now. But jesus fuck, dumping a large file is measured in miliseconds for csv and minutes in Xlsx, even with this change. (at least it finishes now though)
&gt;"(it's REALLY important, so it deserves repeating!)" You might be right, but you should check out this article: https://en.wikipedia.org/wiki/Don%27t_repeat_yourself :D
Dunno, last time I installed scipy it was just one or two homebrew install commands and the pip install.
Sorry, I missed that.
&gt; Try typing "pip install scipy" and then get back to me. Well if you say it, some idiot will do it. As you predicted, ``pip install scipy`` doesn't work because it required numpy during the install and scipy didn't specify that. So I run ``pip install numpy scipy`` which works fine, but takes several minutes to complete. Fortunately pip can use the *wheel* package to make and install binary distributions. ``pip wheel numpy scipy`` and a few more minutes and I have a pair of packages I can install in a new virtualenv in under a second. Pip is not the problem here.
&gt; However, I usually go brew install python3, create virtualenv, and only then pip install conda. How come?
Your system is likely not typical in that it has working C and Fortran compilers already set up and matching the path assumed by numpy/scipy's setup files. From this, I assume you're an active developer, running on linux, yes? Unfortunately most numpy/scipy users don't fit that mold. You're also fortunate that you didn't have a system numpy installed already via yum/apt/port/brew/etc... if you did, then most likely your current compiler would not match that used to build numpy, and you'd get strange errors. We used to run into that sort of issue with users all the time, until folks started switching to conda. Ever since switching to conda (and having my students, research group members, talk attendees, tutorial participants etc. do so as well), my life has gotten MUCH easier. pip may not be the problem here, as you say, but conda certainly is the solution.
There's also memcached. https://addons.heroku.com/memcachedcloud https://devcenter.heroku.com/articles/memcachedcloud#using-memcached-from-python
&gt;As far as I know, Python 2.7 32bit is the ONLY version I have installed. There's also a system-wide Python that came with OS X, in /System/Library/Frameworks/Python.framework. Sublime is probably using it instead of the one you installed. No idea how to fix that, though.
Well it seems pre-built wheel packages could help with that, without needing grumpy pip users to switch package installers. PyPI even supports hosting wheel packages, is there a reason scipy doesn't do this?
easy_install works on most of the binaries for virtualenv too as mentioned [here](http://stackoverflow.com/questions/3271590/can-i-install-python-windows-packages-into-virtualenvs).
None of the packages have anything to do with Django specifically. Just wanted to mention it because it is an active community with a lot of talented Python developers &gt; Django as a community tends to not work well with others.. don't want to stat any religious wars ;) What are you on about?
&gt; Are there really an abundance of applicants for development jobs that can't complete a working Fizzbuzz program or is this a bit of an exaggeration? In my opinion it's mostly an exaggeration, but every single time the topic comes up on /r/programming there are always a ton of very vocal people insisting that they see lots and lots of candidates who fail this test. I'm not how much of it is true and how much is based on some weird programmer superiority complex where they want to act better than the rest of the world. 
You are correct, and 2.7 is the "current" one there...with no 64- or 32-biot distinction. I wonder if I can use pygame with it. 
This is a staggering but not completely fair comparison. CSV is the simplest possible data file format and Pandas offloads it to a optimised library in C. In comparison a single worksheet in XLSX requires 9 relatively verbose files that once written have to be compressed into a zip container. When I wrote XlsxWriter I spent a lot of time profiling the code and improving the performance. As it stands it is as fast as xlwt which most people think is fast enough. [In optimised mode XlsxWriter could be 100% faster](http://xlsxwriter.readthedocs.org/working_with_memory.html) but that optimisation isn't currently available in Pandas without a large amount of refactoring of the Excel writing code. [PyExcelerate](https://github.com/kz26/PyExcelerate) is probably as close to the performance limit that a pure Python XLSX writer can get and that is still only 50-60% faster than XlsxWriter. I also have a prototype C implementation that is 1,000% faster than the Python XlsxWriter. Even so that isn't going to get you from minutes to milliseconds for any large amount of data. On the other hand CSV can't give you charts like the examples above, or formatting or autofilters or conditional formatting or data validation which XlsxWriter can do and more. 
I'm not sure about the second point, but your first point is not correct. You can get a list of installed packages and install them in a new conda environment like you do with pip: conda list -e &gt; requirements.txt conda install --file requirements.txt
No. Sorry. :-)
That's good to know. My `requirements.txt` comes in pip format though, with `package&gt;=x.xx,&lt;y.yy` so conda won't accept that anyway.
I agree with your points, but I think I may have been misunderstood a bit here. I said "free hours of work before an interview”. Small tests and such are perfectly fine, but expecting some to do many hours of work before you even meet them is not respecting their time, particularly if they are speaking to multiple companies. &gt; It says nothing about what motivates them or what they are re-learning or learning this week, and says nothing on average with who they are a person. And neither does GitHub or there code. This is something you pick-up from an interview or meeting them, or a recommendation from your professional network. In the last 13 years I have worked at and cofounded many start-ups, and I worked with many others. I have also had to hire and build teams many times. With that said, I would like to point somethings out. 1) You are way too absorbed with the idea that developers should program for fun in their spare time. Many great developers don’t have time to contribute to open source projects or program for fun because of family commitments. Particularly if they work long start-up hours. As well, someone can be an incredible dev without dedicating their spare time to it, and just because they don’t does not mean they lack passion. In my experience the greatest dev’s I know do the farthest things from programming in their spare time. Particularly ones who use their spare time for getting outside or exercise. It keeps their head clear for their job. The worst devs are the ones who turn programming into their lives and lack balance. 2) Github is a terrible portfolio. It has poor, basic rating systems, and does not allow someone to curate their portfolio and speak about how they approached the problem the way they did. Which is the most important thing to grasp about a candidate. 3) “Rockstar” types who are constantly trying to pad their github account can be terrible people to work with, and hiring them can poison a team. People in general are motivated by a varying mix of three things: Change, money, and ego. They want to change something or build something great, they want to make money, or they want everyone to know they are the best at something. Rockstar types are usually only motivated by the latter. They can be hyper-competive(in a bad way), and are always looking for any reason to get on a stage and preach. As such, they often make decisions which benefit their conference hopping, open source contributions, and misguided evangelism over the company. 4) You come across as too code focused. Code is a tool a dev uses to create a product to satisfy a customer. A good dev at a start-up puts building great products, customer satisfaction, and the company first, and there love of coding and new technologies second. For example, over-engineering systems, premature optimizations, using obscure new technologies which are difficult to hire for, poorly implemented or missing features, etc. can happen from a developer being too enchanted with technology and not with satisfying customers. As well, start-ups grow fast. Yesterdays dev is todays team lead and tomorrows CTO. They may not be coding full-time, if at all, very soon, and they need to be able to shift gears out of coding. 5) As a team manager, building your team is very important work. When you say things like "that we canceled our day of actual work” it leads me to believe you don’t take it seriously. As I said in my original comment, hiring is a process that never ends. You always have to be out meeting and greeting devs for when you need to scale or fill in a seat when one leaves.
To make "pip install scipy" work we need to build scipy wheels with statically linked atlas and libgfortran (the gfortran runtime libs). It's not impossible to do but we need to script a windows and OSX build environment to release those wheel packages as part of the scipy release process.
Oh trust me I understand why, I just wish I could get Xlsx with that speed. :)
http://www.continuum.io/blog/conda_packaging addresses a few of your points (including wheel) Travis-CI and Tox support would be cool. Obviously it's possible to just shell out to `conda` and check return codes. With pip 2.0 and latest conda, packaging latency (is this the latest package?) is not as much of a concern.
Thanks for the efforts! So format() does not seem to be so bad as my naive tests indicate. But `%` would still be the way to go for excessive string operations
Here's a quick IPython notebook I made to grab the list of Oscar nominated films and search for them on various streaming services. If you want to grab the notebook and change or extend it, you can get it from my github repo here: https://github.com/tdicola/Oscars_2013 The notebook uses a few really nice python libraries like requests and beautiful soup to do most of the work.
&gt; With pip alone, plan on spending a half day getting them installed on linux I just built ipython from source on a fresh install and it wasn't a problem at all if you're already using the numeric libraries. numpy and scipy are the pain points. Installing tornado, mathjax, and zmq are easy. Matplotlib is a bit slow to build but otherwise sane.
Using Anaconda for this very reason. I spent five hours today trying to get iPython Notebook to work on Windows &amp; Python 3 to no avail. Then I spent 20 minutes downloading and installing Anaconda and now I have iPython working flawlessly. 
I've never built a Reddit bot, but I may be able to give you some reading material until someone else more knowledgeable comes around. Check out [PRAW](https://praw.readthedocs.org/en/latest/) It's a Reddit API wrapper. The developer is also a Redditor. And seeing as I just mentioned 'PRAW,' he/she will more than likely be here shortly ;) Good luck!
First off I would look into using the [PRAW](https://praw.readthedocs.org/en/latest/) python package. It makes using the reddit api a breeze and it's pretty easy to install and use. I would also get a little acquainted with the [re](http://docs.python.org/2/howto/regex.html) python module especially the search and match methods. These use regular expressions to search through strings to find particular words or sequences of characters. I just built a similar bot but the code might be a little confusing if you're new to python but ill post a link anyways. [programming_stat_bot](https://github.com/bry012/programming_stat_bot). hope this helps and pm me if you have any more questions.
how would the token be stored in the browser? The only way I can think of is HTML5 Local Storage, which means that on older browsers, as soon as you close the tab you're logged out. Even just opening a new tab to the same page would mean you would have to re-authenticate.
No. Flash does a lot less. Web2py is fullstack that wins awards and flask is Just a micro framework.
I'm not sure what you mean by "Virtualenv must be attached to one or the other, so you need two entirely separate frameworks set-up to accomplish this." I have virtualenv installed for my default Python 2.7.6 environment, but to create an environment for 3.3.2, I just do this: $ python -V Python 2.7.6 $ virtualenv -p $(which python3) py3env Running virtualenv with interpreter /Users/ppinette/.pyenv/shims/python3 Using base prefix '/Users/ppinette/.pyenv/versions/3.3.2' New python executable in py3env/bin/python3 Also creating executable in py3env/bin/python Installing setuptools, pip...done. $ . ./py3env/bin/activate $ python -V Python 3.3.2 $ I could accomplish the same from a python 3 environment by using the `pyvenv` command, which is the standard library replacement for `virtualenv`.
You tried to install matplotlib through Homebrew and it didn't work? The maintainers of homebrew (or macports) packages should take care of all/most of that witchcraft for you.
&gt;Bad/failed/scratched builds should be incrementally later. Why assign the same version string to two separate things? "Let's just reuse this UUID and hope it's not cached anywhere?" Yes, it's a terrible idea. But that's not enough. The mere *existence* of such builds is not always going to cause distributors pain (and if it does, distributors can just relabel the versions), so a MUST is overkill.
&gt; I'd hope that issues/failures within the default python packaging tools (e.g. pip/setuptools/etc.) would be solved by improving those tools, not abandoning them in favor yet another option. You seem to be aware of the general troubled history in this area. Travis Oliphant (author of numpy, one of the devs of conda) speaks to exactly this point, here: http://technicaldiscovery.blogspot.com/2013/12/why-i-promote-conda.html I'll quote the relevant sections here for people who don't want to read through the whole thing: &gt; Naturally, I sometimes get asked, "Why did you promote/write another python package manager (conda) instead of just contributing to the standard pip and virtualenv?" The python packaging story is older and more personal to me than you might think. Python packaging has been a thorn in my side personally since 1998 when I released my first Python extension (called numpyio actually). ... &gt; We in the scientific python community have had difficulty and a rocky history with just waiting for the Python.org community to solve the problem. With distutils for example, we had to essentially re-write most of it (as numpy.distutils) in order to support compilation of extensions that needed Fortran-compiled libraries. This was not an easy task. All kinds of other tools could have (and, in retrospect, should have) been used. Most of the design of distutils did not help us in the NumPy stack at all. In fact, numpy.distutils replaces most of the innards of distutils but is still shackled by the architecture and imperative approach to what should fundamentally be a declarative problem. We should have just used or written something like waf or bento or cmake and encouraged its use everywhere. However, we buckled under the pressure of the distutils promise of "one right way to do it" and "one-size fits all" solution that we all hoped for, but ultimately did not get. I appreciate the effort of the distutils authors. Their hearts were in the right place and they did provide a useful solution for their use-cases. It was just not useful for ours, and we should not have tried to force the issue. Not all code is useful to everyone. The real mistake was the Python community picking a "standard" that was actually limiting for a sizeable set of users. ... &gt; Therefore, you can't really address the problem of Python packaging without addressing the core problems of trying to use distutils (at least for the NumPy stack). The problems for us in the NumPy stack started there and have to be rooted out there as well. This was confirmed for me at the first PyData meetup at Google HQ, where several of us asked Guido what we can do to fix Python packaging for the NumPy stack. Guido's answer was to "solve the problem ourselves". We at Continuum took him at his word. We looked at dpkg, rpm, pip/virtualenv, brew, nixos, and 0installer, and used our past experience with EPD. We thought hard about the fundamental issues, and created the conda package manager and conda environments. We who have been working on this for the past year have decades of Python packaging experience between us: me, Peter Wang, Ilan Schnell, Bryan Van de Ven, Mark Wiebe, Trent Nelson, Aaron Meurer, and now Andy Terrel are all helping improve things. (Disclaimer: I work with Travis and am mentioned in the blog post...) *edited: formatting
What Qt binding are you using for the qtconsole?
It always has.
I have noticed that django users as a community tend to be more about "django, or no go". Its been out right said by people who use django I know that to the django community, only django exists, and that IS web development.. despite the fact other options exist, so they just either refuse to learn what the options are or dismiss them because they are not django. This makes me wonder about the skill level actualy is, as I consider it a negative if somebody refuses to learn about new things. But like I said, I dont want to start a war.
&gt; From this, I assume you're an active developer, running on linux, yes? Unfortunately most numpy/scipy users don't fit that mold. It's kind of weird that this is true. The solution I ended up with 6-8 years ago was simply, "use Linux for development." Or you could use the Scientific Linux distro if your needs were narrow enough vs. the benefits of a more general distro like Ubuntu. There are still a lot of use cases where I'd recommend a pip/virtualenv toolchain over conda, like most web servers - it works and there's already a large body of knowledge on how to deal with edge cases and domain-specific issues. But conda is a huge quality of life improvement for anyone where deploying tools like NumPy / SciPy is a persistent problem. And yeah, you can get those tools working for one person via whatever toolchain given enough time and determination. Especially on Linux. But try deploying and maintaining it across a research lab with 20 computers and users at widely varying skill levels. Actually, that's also the only case where I've had to deal with a meaningful frequency of Python 3 code. Students &amp; researchers write in whatever, often unaware of the Python vs. Python 3 issue, and you'll often need or want to run it without a lot of time picking over the compatibility bombs. Having that *not be a meaningful problem* is already good reason to check out conda.
&gt; If that's atypical, that's a problem with how linux systems are configured. &gt; Who is talking about just linux systems? 
(I just tweeted about this, but what the hell...) There is a general pattern that I see whenever python packaging is brought up, here or on HN, and specifically when packaging of scientific libraries is discussed. Basically, there will be folks who have not paid the iron price in fighting all manner of insane and incomprehensible installation problems with the vast array of popular scientific python libs (numpy, scipy, matplotlib, pandas, cython, pytables, scikit-image, scikit-learn, etc. etc.), who pipe up and say, "I don't understand the bellyaching. Pip works just fine for me. Why are the scientific python people so daft?" This happened years ago, when the scientific community grew restless with the terrible state of affairs with numpy distutils and setuptools itself was abandonware. In the intervening time, pip came along and patched over some of setuptools's brokenness, and caused a lot of web devs to think that The Packaging Problem had been slewn. So, I would like to propose a new rule: **Until you've actually tried to install the scipy stack on a roomful of laptops belonging to other people** (like what one frequently encounters at hack fests, Scipy/Pydata tutorials, software carpentry workshops, and the like) **then you do *not* get to declare that all is peachy keen in the state of Denmark**, and that "pip install" or "brew install" or "port install" worked for you. One can think of it as "packaging privilege". If you've been privileged enough to only need to "emerge scipy" on your l33t gentoo box and deploy via RPM on a RHEL production server, then you have been playing the game on the easiest setting. If you'd like to play on a slightly harder setting, get a 64-bit Windows 8.1 box where you don't have admin rights, and let me know how long it takes you to get a working IPython notebook, Spyder, Matplotlib, and Cython. (Hint: depending on which version of Python you install, you might need a deprecated version of visual studio! I hope you have MSDN!)
If you would really pay money, please email sales@continuum.io and tell us how much. :-)
Ah, I didn't realize that! Like I said, though, this is a very minor point compared to all the other clear advantages of conda over pip.
Great! Now build it the same way using Intel compiler and ACML so functions are optimised for the amd64 platform. Running Windows 2008. Its really easy to build un-optimised BLAS/LAPACK from the default source code, and maybe you'll get away with baby's first FFT. But not any real workload.
Unfortunately homebrew recently completely broke the Python setup, completely disabling python3 (and therefore breaking macvim, pyqt, etc.) apparently in order to "fix" a problem they had with Mercurial because they were(are) doing stupid things with $PYTHONPATH I raised a bug and they closed it immediately, saying (essentially) "wontfix". Ironically this was the same week we were debating Py2 v. Py3 here in /r/Python That's what happens when you trust your python toolchain to a disinterested Ruby programmers. 
Did you just make a Game of Thrones reference while explaining the difference between users who have actually worked on deploying software and the armchair dev ops? I'd give you a dozen upvotes if I could, Peter :)
Thanks for the link, that's a very useful (and relevant) response. The combination of [very reasonable justification (thanks westurner)](http://www.continuum.io/blog/conda_packaging) and some serious expertise is a comforting combination. And, like I said, I can't fault anyone for wanting an installer that works today. Thanks again for the cogent response -- I'm somewhat new to python packaging and still learning a ton.
You missed a key part above: "Then, with Numpy, life becomes even more difficult because you typically want to link to an external LAPACK library to get vectorization working." I'm pretty much positive those commands will use the reference blas/lapack that comes with numpy. Which isn't what a lot of people want. Speed differences of 5x to 10x can easily happen for large matrix computations.
You betcha. I also tend to call VC-backed code-crushing Silicon Valley brogrammers "summer children", because they were not around to witness the dotcom bubble bursting. But winter is coming... 
No war here, but you might want to reexamine your thoughts on a entire, very large, and in my opinion very open and helpful community. Otherwise you could be missing out on connecting with some very bright and friendly people. I can tell you that most of the Django users I know are just like any other engineers; they like using the right tool for the job. Most of them have also worked in other frameworks, including RoR, express.js, flask, and even occasionally pyramid. While I am moving from Seattle, you should stop by the Django Seattle weekly hack night some time. Half of the people who show up aren't even working on Django atm. They just love talking about web development.
Numpy's setup script is smart enough to link against Accelerate/veclib, which is provided by apple and included in OSX. On Linux this is a bit more of a pain, usually one needs to explicitly link against an optimized Atlas build to get the fastest vector and matrix operations.
That's interesting. My experience was from Linux and I assumed it was the same for Mac.
Conda doesn't perform TLS verification, so by using it you are opening yourself up to a MITM attack: https://github.com/conda/conda/issues/400
Cool, thanks! I don't suppose this could be done with java too, right? Not JS.
This is for drupal and is off topic. Please report it!
Off the top of my head you could continue to have cookies for auth as well, and use a request to the main domain with the cookie/sessionid to get a new JWT for use against the API. Not seeing anything obviously wrong with that at first glance.
If you installed python it's just to write python in search idle will be one of the applications who appear
I know, and the fact that posting accurate titles gets you downvotes saddens me. 
As someone who has interviewed several potential candidates for programming positions, you would be very surprised how good a filter FizzBuzz is. I sometimes don't even make it there, because it becomes obvious they aren't going to be able to do it. The last girl I interviewed couldn't tell me what a Terabyte was (for a sort limitation question). Came to find out she didn't know gigabyte, megabyte, or kilobyte either.
If you really work there, any reason why you're not on Bintray?
You mean binstar?
https://bintray.com
Because homebrew is still a good thing. So is having all one's tools in one place. Most importantly, homebrew provides a unified and central way of updating and uninstalling software. Virtualenv, because I like to keep projects and their packages separate. Sometimes I purposely want to Install pre-release or older packages. This is something virtualenv does well. Conda integrates very well in virtualenv. 
Well, eggs had issues which wheel solves; and wheels are too new.
&gt; Hint: depending on which version of Python you install, you might need a deprecated version of visual studio! I hope you have MSDN! Or just settle for 32-bit Python. Not saying the Windows situation is sane, but you do not need a MSDN subscription.
Have you considered using simple memoization? Or on lru_cache on Python 3?
I would not use jreddit. It blatently violates Reddit's API rule #1, ignores rule #2 and #3 expecting you to meet them while never saying a word about them in the docs. Looks to me like using it is just waiting to get banned. 
[Merry Christmas](http://www.imdb.com/search/title). In Advanced Title Search, you can filter by tops (under "Title Groups") AND streamability ("Instant Watch Options). (And Oscar nominated etc.) Enjoy :)
Ended up going with memcached and using python-binary-memcached. Works perfect for me!
Ok, thank you!
&gt; Pip will happily deal with both eggs and wheels. Next step: support Conda binaries.
Then your process was woefully, hilariously flawed. These people should not be making it to interview stage in the first place. 
I agree that our candidates are awful, but our requirements are also. The positions are cleared positions where there are some other limitations, so our pool of candidates is already filtered. Plus it's a very competitive market for those cleared candidates. Our recruiter is also pretty terrible.
Your scrape is broken. Frozen links to some korean movie not the disney animated movie afak 
It's worth mentioning that, since conda uses a binary package format, it's (obviously) of no use on unsupported architectures/platforms.
This page is probably the best example of why pip is insufficient. Why do you need to rely on some person to build precompiled binaries if we supposedly have this packaging system that should be to do just that on your own machine?
If you search `~2ⁿ` items, then `~2ⁿ⁻¹`, then `~2ⁿ⁻²`, `~2ⁿ⁻³`, `...`, `1`, you'll have searched ~∑2ⁱ from i=0..n = ~2ⁿ⁺¹ `~2ⁿ⁺¹ ∝ 2ⁿ`, so this is `O(2ⁿ)` for `2ⁿ` items, or `O(n)` for `n` items.
Thanks for the clarification. So, this avoids the log n by not doing every path like quicksort would, and the geometric series converges so it's a constant factor slower than a linear scan.
Pip works fine for python-only packages, the problem are the ones who have C extensions. Windows doesnt ship with a compiler and it's a pain in the ass to get one to work with python.
I have been playing around with [Vagrant](http://vagrantup.com) and installing my pydata stuff on a portable linux virtual machine. Vagrant makes managing VMs pretty easy and lets you have a consistent development environment across host operating systems (osx, windows, linux). I'm still testing the setup, but I plan on trying it for a workshop I'm running soonish. Obviously the performance penalty of running in a VM is something to consider, but for something like a intro-to-python or software carpentry workshop it might be ok. edit: I should also note some of these are not mutually exclusive. I'm now thinking a Vagrant vm with (ana)conda already installed might be the way to go. Throw in a provisioning system and you could spin up an AWS instance (identical to the vm on your local machine for when you need more power. 
Conda is open source and we accept donations for it through NumFOCUS: http://numfocus.org/ This is an umbrella non-profit that also accepts donations for the PyData conference, IPython, and many others - including the John Hunter memorial fund. You can even donate in bitcoins! :-) http://numfocus.org/donations.html
By default conda installs packages from the Anaconda repository, but you can setup other conda repositories as well. A good place to share conda packages is binstar.org
There is tutorial in PRAW docs that explains writing a bot that does exactly this. https://praw.readthedocs.org/en/latest/pages/writing_a_bot.html
I got a python job 2.5 years ago using CodeEval. Neat service :)
So pip will likely never be focused around being able to do ``pip install llvm``. That being said it should be completely possible to do so, but I suspect the actual "doing so" will always be easier in Conda than in pip simply because of the different aims of the two systems. And that's OK. I hate when these discussions become folks on either side of the fence trying to make absolute statements. For some group of people Conda will likely be the right answer, and that's perfectly OK. Meanwhile for another group pip will be the right answer, and that's perfectly OK too. Personally I wouldn't want to pip or conda to install llvm , qt, libxml, or OpenSSL because I trust my distro package managers to maintain security patches for those libraries more than I trust most people, including myself. If what you're building is something that perhaps doesn't care as much about having a stable base with backported security patches (Think RHEL) but instead cares more about having a particular optimization enabled, then you're unlikely to care as much about having someone like RHEL provide security updates and are more likely to want to pull your packages from Anaconda which comes from the Science community and they are more likely to care about getting the maximal performance configuration. My main underlying point is really that it's not a you must choose this or that. Pick which ones goals works the best for you because in the long run both of them are going to make things easier and better and the bulk of the difference is going to in the focus of each tool and which group they focus on. In diagram terms it's a Venn diagram where most of the space is occupied in the overlapping sections but that doesn't mean that the two circles are completely overlapped.
How does it help you find a job? I see one job posted there. Is that normal?
Where do you go to read good code? I hear this recommendation often but there's never a list of places to go. 
You can also take a look at the existing wrappers: https://github.com/reddit/reddit/wiki/API-Wrappers
Hmm.. they changed the site since the last time I used it. There used to be a list of challenges you could view. Now it looks like you have to log in to see that page. It's here after you log in: https://www.codeeval.com/jobs_and_offers/#sponsored-challenges There are 20 companies on that page that have posted a challenge. After you solve the challenge the result is sent to the company and then they contact you if they're interested.
For me, it depends on the OS and if I have admin rights to the PC. At work, I have to use Windows and don't have admin rights to it. So if I have to install non-pure Python libraries like numpy and scipy AND make an isolated virtual environment, I am screwed unless my PC happens to already have C and Fortran compilers and other dependencies. If I don't need to setup a virtual environment, then I would use conda or download the windows binaries individually. At home, I use Linux and I can use pip/virtualenv for almost everything I need. TL/DR: Linux is more pip/developer-friendly; Windows...not so much.
The issue was I needed to use a DB option in heroku as making any local cache files would not persist between runs
&gt; Personally I wouldn't want to pip or conda to install llvm , qt, libxml, or OpenSSL because I trust my distro package managers to maintain security patches for those libraries more than I trust most people, including myself. Just to shed light on some of the miscommunication between the two domains, the issues you mentioned about security patches are usually not that applicable within the scientific python space. Usually we're talking about dependencies on Fortran libraries from 70s that may have a new release every decade or so. Scientific libraries move very slowly and security patches are usually an afterthought or irrelevant since they're not dealing with network or crypto at all. Usually getting maximal performance out of linear algebra libraries isn't even that much of a concern to most people. The overwhelming concern is just getting everything compiled and linked which very quickly can devolve into a nightmare. Things might be very different in the web python space where you're actually running code in production on servers, I don't know enough to comment about that. But the view from the "trenches" of most laboratories is that most folks aren't software engineers, they don't care about good software practices, and just want to work on their field of study with minimal effort. 
Yeah like I mentioned in the comment, searching on Amazon has a lot of false positives. It would be better if I could compare title, year, and director instead of just title and year. Amazon is also returning a Lone Ranger movie from 1950 with a 2012/2013 release date.
Good to know.
Why not try and begin with Github? This is also good: http://code.activestate.com/recipes/langs/python/
Right, that's why I said personally :) I understand that my needs as someone whose software tends to get deployed is different from the needs of a lot of the scientific community. That's why I try to advocate that people don't be so absolute with their statements about Conda/pip. They come from different backgrounds for different purposes, use whichever one's goals best fit your purpose :)
btw Ansible added to the list, checkout #9 http://pythonhackers.com/top-python-projects/
I've just encountered a bug with agent.py, it won't compile when I try to python setup.py install Likely something that won't work with Python2.6
How would I go about doing that?
I just paste it in their online editor
This is not related to Python, but I want to point out that I like the logo (and the motto :P) very much :) How did you make it? Which software did you use? Inkscape?
I personally really enjoy http://acm.timus.ru/ and https://open.kattis.com/ Had never heard of codeeval, will give it a try!
One thousand times thankyou.
Eh, I enjoyed Digital (and her free one, "don't take it personally...") much more myself. Analogue was unjustifiably long, in my opinion at least. I thought the other two delivered a more powerful story in a shorter format which had me interested throughout, whereas Analogue, I had to force myself to the end. Subjective opinion of course.
Technically, Unity supports Boo, which is a Python-ish language. It was more of a proof-of-concept thing, and it's been left to die since I think. The documentation for it is very poor. I'm curious to know if anyone actually uses it though. I personally doubt it.
If you have the source, just compile it.
Thanks! I make all my logos with the Gimp. inkspace etc are probably better tools at this point for logo making - but I've used the Gimp for a long time (http://kde-look.org/content/show.php/Intrigue+Icon+Set?content=29782) and so have a hard time transitioning to vector based graphic editors.
See https://github.com/lazka/pgi-docgen Basically fully automated from the library C source + the PyGObject Python overrides. (C -&gt; gi -&gt; gir/typelib -&gt; pgi + pygobject overrides + pgi-docgen -&gt; sphinx)
I regret that I have but only one upvote to give. 
I'm more impressed that you used nbconvert instead of nbviewer.
I don't have an answer for you, but if you want expert advice on geocoding and rectifying images and mapping in general then I would start in the #openstreetmap chat room on irc.freenode.net Also Python may not be the best tool for this job, you might find it more useful to start with a free software 2D or 3D mapping tool like jOSM, pTolemy3D or NASA World Wind.
Break up the pieces you want to vary as a list or tuple of elements. Join them back together to use however you like. Will give you the cartesian product for the varying sets of iterables. Did this real quick, hopefully it helps. import itertools combs = itertools.product( ["h", "H"], ["e", "3", "E"], ["ll"], ["o", "O", "0"], ["w", "W"], ["o", "O", "0"], ["rld!"]) for comb in combs: print "".join(comb)
Awesome, thanks. And the reason I was planning on using Python is so I could make it exactly how I need, e.g. receiving images from the aircraft in real-time and processing them. I will check those out though.
Written as simple as humanly possible: possibilities = [\ ['H','h'],\ ['e', '3', 'E'],\ ['ll'],\ ['o', 'O', '0'],\ ['w','W'],\ ['o', 'O', '0'],\ ['rld']\ ] passwords = [''] for p in possibilities: tmp = [] for letter in p: for word in passwords: tmp.append(word+letter) passwords = tmp for pw in passwords: print pw Good hunting!
Didnt see /u/_HULK_SMASH_ 's answer, which is obviously much nicer.
FYI you don't have to add slashes to continue lines in Python if the line breaks are inside brackets, parentheses or braces.
&gt; I want to overlay geotagged aerial photographs onto an empty map grid in the correct lat/lon positions, with the correct rotation applied to the images, and with the images scaled appropriately according to the altitude they were taken at. Recommendations? Yes, I recommend learning to program. 
It sounds like your are building your own tile server. The altitudes are referred to as 'zoom' levels. You should look up a book called Python for Geospatial Development. It has been very helpful to me in attempting to build a small GIS portal, which is, admittedly, a lot easier than building a tile server.
Good book. Lent mine out and never came back. Just reminded me to put it on my amazon list. Thanks :)
Thanks to you also,I appreciate your input dude.
Not to advertise, but this is what I do. If you're interested in spending a little money, I can set up a tile server for viewing your data, along with a server to automatically receive, georeference and color balance imagery (in real time). Send me a PM for more details.
The Workbook class only has a `save` method, I don't see an `open` or anything similar. Looks like it's only for creating, not for opening or modifying.
Pandas integration?
Thanks OP. Stuff like this is one of the reasons why I started learning Python.
Check out openpyxl. It seems to do what you want and is actively maintained.
I'd like to know what issues you ran into on Ubuntu. I've never had a problem with the following basic workflow, on any version of ubuntu: sudo apt-get install python3 virtualenv virtualenv -p python3 --setuptools directory At this point, virtualenv has automatically installed a local copy setuptools and pip.
Wheel reinvention! :-) from itertools import count 
It was on the docket, but was dropped in favor of just supporting openpyxl and xlsxwriter directly. It would be relatively easily for the PyExcelerate authors (or, frankly, anyone else) to integrate with pandas 0.13. We left hooks in just for this purpose. 
Perhaps he means with `pyvenv` rather than `virtualenv`, but I'd like to know what those Ubuntu issues were, too ... I use Ubuntu and haven't run into anything.
**Edit:** I just re-read your post and the "... persist between runs" bit jumped into my eyes. This is the *one* big point where you may want to chose memcached over memoization! --- Disclaimer: I never have deployed anything on Heroky, so I don't know about their limitations. The fact that you mention files, makes me thing that you did not look into memoization. So let me give you a quick outline of the differences. I am not saying that it is *better* than memcached. It is *different*. But I strongly believe that it is *good enough* for caching. It has it's caveats though. And ***if*** you run into them then `memcached` may help, but you can run into different problems... Memoization works in-memory. No files required. The Python3 `lru_cache` is a specific implementation of memoization, so the same thing holds true. As you are using memcached, I assume caching in-memory is an appropriate solution for your case. The big difference is that memoization works in-process. It uses the same "memory space" as the rest of the application. Which can be seen as a good thing. However, it's subject to dynamic process allocation as is the case in many web-server set-ups. Processes can be killed off and re-spawned out of your control. If this happens your memoized functions will lose their cached values. That may not be an issue though for you though (depends on your cache requirements). `memcached` runs as a separate process. So it has access to a separate memory "pool". It is uses inter-process calls to provide access. As far as I know over a Unix/TCP socket (other paths may be available though). More than one process can access the same `memcached` instance. This is dangerous (race conditions, lost updates, etc...). But if you are 100% certain about what you're doing then that may work for you. It really depends solely on your requirements. I would *always* prefer memoization over memcached until I *really* need it. I just had a quick browse over their wiki, and from what I can tell, they leave invalidation up to you. Which is not a bad thing, but it means that you have a persistent process which risks eating up more-and-more memory if you're not careful. Again, it depends on your use-case! Another argument against memcached is that the deployment process of your application becomes more difficult. It depends on a second application being installed on the system. And properly configured. As memoization is nothing more than a pattern, there's no requirements on the server-setup.
If you follow the link I provided, it explains that things get installed into subdirectories of the virtualenv under "local".
FYI: [openpyxl](https://pypi.python.org/pypi/openpyxl) can read and write excel files.
Ah. This was also filed as a [Python bug against venv](http://bugs.python.org/issue16480), but has been fixed upstream in Debian.
Cool, I'll take a look.
A coworker mentioned using this http://sourceforge.net/projects/decompyle/ But that wont necessarily work for stuff that's compiled with py2exe but should get you somewhere with pyc files. 
Your code shows exactly the kind of problem programming that needs to be fixed. You have a file you know originated on a Windows system, where the encoding can be completely variable. You then transfer this to a Unix system where the encoding is either UTF-8 or raw bytes (depending on the fs and userspace interpretation - for example Linux stores as bytes but best practice is to assume UTF-8). When calling os.listdir() you tell it to use the default system Unicode string representation for the filename; so in reality it could have been UTF-32 on the Windows system but you're implicitly telling it 'screw that, assume UTF-8') then wondering why it returns messed up. You should start by forcing bytes interpretation of the filename (e.g. os.listdir(b'.')) then should you need unicode string representation of the filename, encode() it appropriately. http://docs.python.org/3.3/howto/unicode.html (and in particular, http://docs.python.org/3.3/howto/unicode.html#unicode-filenames) 
this.
It's in every single IPython book I've read and it makes me cringe every time.
I agree 100%, but it is indeed present on many IPython books.
Pls do let me know if you have any recommendation for improving the code or any functionality. I am all ears. I tested on RHEL &amp; Mac OS X for now. :-)!
The problem with Python 3.3/pyvenv was since I was familiar with virtualenv, I assumed pyvenv would have pip installed. Not until you read further down in the [docs](http://docs.python.org/3/library/venv.html), until the shaded "Note:" box, that I realized that pyvenv does not come with pip. Not only that, you have to run distribute_setup.py to install easy_install so that you can install pip with easy_install. This seems like a lot of unnecessary work and on top of that, the doc doesn't say where you can download distribute_setup.py. Anyways, Python 3.4 IIRC is suppose to have pip installed (not sure by default or not).
What exactly was this supposed to demonstrate?
This is an example of agent-based modelling, or, agent-based computational economics, as it is known in economics. It's only a fringe part of economics (what is termed heterodox economics) but interest increased in it after the financial crisis. I haven't had the time to go trough what Norvig is saying yet though.
thank you sir
Very cool. Get-pip.py will make some in-house distribution easier for the computers brought online missing the standard install we've put together. 
come on, dude probbably bought some cheap quadrotor from china, put a dslr on it and will proceed to do what hundreds have done before..... by getting someone else to do the work for him!
TL;DR would probably be: He set up a population of people, made two people interact with a couple of different methods, multiple times per turn, for 25,000 turns, and their wealth would be redistributed via one of several methods. All the methods bar one made the rich get richer and the poor get poorer.
That was another point I meant to bring up: "the rich get richer and the poor get poorer" is usually used in the sense of "the people who started off rich got even richer while the people who started off poor got even poorer". Here, it is used in a rather different sense: "the top 1% of the population controlled a larger proportion of society's wealth, but the makeup of that 1% changed". While either would be an interesting result—if the transactions in the model weren't essentially random, and the model itself included some sort of wealth creation (and destruction) rather than being a zero-sum game—I was initially confused by this characterization.
This^^ If we were to see graphs of the relative wealth of particular actors from T=0 for most of these distribution methods we would see that the wealth would wildly fluctuate. Winner take all distribution for example. The number of wealthy is decreasing, and wealth concentration increasing, but any poor w/ rich interaction has an equal chance of the poor winning and reaching the 1%.
I'd rather not say too much before I actually get to read the damn thing but in general economists are not that happy with these kinds of models. There's been an increasing interest in modelling heterogenous agents in e.g. macro economics but, as I understand it (I'm not an economist), most of the mainstream reseach still uses the mainstream DSGE-models just with new assumptions and computational tools applied. Stray to far from that and you might end up with interesting but difficult to interpret results. I think Norvig's example is fairly simple but I'll have to get to you on that :).
The following is the heart of the simulation: &gt; **Transactions** &gt; In a transaction, two actors come together; they have existing wealth levels X and Y. For now we will only consider transactions that conserve wealth, so our transaction rules will decide how to split up the pot of X+Y total wealth. In other words, this is a zero-sum game. It simulates an economy where people bump into each other, play a game of chance and the winner seizes a portion of the loser's money. This is a simulation of a poker tournament, not an economy. &gt; (2) Many students will have preconceptions about how economies work that will be challenged by the results shown here. The simulation assumes there are winners and losers in every economic transaction and, unsurprisingly, the game ends up splitting the population into winners and losers. I fear this will only confirm the preconceptions of people who look at it uncritically.
Not even poker, since poker blends some pretty serious skill in with the randomness; this is more like flipping a coin.
There is also amon.cx, but it is not open source. This seems really awesome.
I'd be happy to play any of these games except `split_half_min` at Google headquarters. Why? Because they're all redistributive: the person who enters a transaction poorer is getting great odds because he has a shot at his counterparty's entire bankroll. If you looked at who makes up the top 1%, you'd see that this doesn't model the rich getting richer, just the wealth distribution getting more skewed while the identity of the rich changes every turn.
&gt; is a zero-sum game You can turn it into a non-zero-sum game by introducing a factor that models a general increase of prosperity like this: def simulate(population, transaction_fn, interaction_fn, T, percentiles, record_every, general_prosperity_increase): "Run simulation for T steps; collect percentiles every 'record_every' time steps." results = [] for t in range(T): i, j = interaction_fn(population) population[i], population[j] = transaction_fn(population[i], population[j]) if (general_prosperity_increase != 0) and (t % record_every == 0): # Everyone gets richer population = [p * (1 + general_prosperity_increase) for p in population] if t % record_every == 0: results.append(record_percentiles(population, percentiles)) return results And the call report with a fitting value, or, if you want to run the same simulations as in the original notebook, just set your value as the default value: def report(distribution=gauss, transaction_fn=random_split, interaction_fn=anyone, N=N, mu=mu, T=5*N, general_prosperity_increase=0.001, percentiles=(1, 10, 25, 33.3, 50, -33.3, -25, -10, -1), record_every=25): If we assume that the 25000 ticks the simulation is running represent 20 years, a general prosperity increase of 0.001 every 25 ticks amounts to an increase of roughly 2% per year. I didn't do a 1-to-1 comparison, but the modified version seems to paint a similar picture: All interaction functions except 'redistribute' lead to heavy inequality. However, with the assumption of a general prosperity increase, that inequality is even stronger. If you want to run the simulations yourself, here's the [modified code](http://pastebin.com/FGDLdUW5).
Except wealth creation doesn't make everybody suddenly wealthy by an equal, fixed amount. Not sure how to model it, off the top of my head, because I'm not sure if "creativity" or whatever you want to call it has any correlation with current wealth levels.
This doesn't necessarily model trade the way you're thinking about it. Suppose we're looking at companies developing competing products, who end up dividing the market according to some random rule. Or hedge funds taking offsetting option positions. The point is that in the absence of talent differences, randomness alone produces skewed outcomes under a wide variety of assumptions. An important consequence of this is that it's hard to model investment or gambling returns because the profits tend to concentrate in a small percentage of the simulation trajectories. The mean and median diverge. There's a result called the [Kelly Criterion](https://en.wikipedia.org/wiki/Kelly_criterion) that tells you the optimal amount to bet based on the edge you have and your current bankroll. The formula optimizes for the median law-of-large-numbers case where things that should happen with probability x actually do occur that frequently. The relevant result is that if you bet more than that amount, your profits decline, and if you bet more than twice that amount, you have a negative expectation in the median. However your mean profits go up, due to the amount you make when you get lucky and win more often than you should. This type of skewed distribution occurs in a wide range of random simulations, and yet most people assume skewed outcomes are prima facie evidence for skewed latent variables, i.e. talent.
&gt; All the methods bar one made the rich get richer and the poor get poorer. The one method you refer to is when he introduced his own "redistribute" rule. Basically, unless there is some outside force which governs the distribution, there will always be income inequality. &gt; We see that the redistribute rule is very effective in reducing income inequality: the lines of the plot all converge towards the mean of 100 instead of diverging.
You are an excellent apologist, but Norvig's write up isn't nearly as sophisticated as your interpretation of his model. I think it's clear that he's attempting to simulate household wealth and income inequality.
&gt; just the wealth distribution getting more skewed while the identity of the rich changes every turn. It's not even that it gets more skewed, as Norvig himself said it looks like a Markov process and is supposed to approach some stationary distribution depending on the probabilities. By the way, consider two agents playing random split: the average wealth distribution (which we need to average over time, since we don't have enough actors) would be 3:1. 
I think it's obvious that buying a shirt or even a house isn't well approximated by randomly redistributing the wealth of the buyer and seller. For this to make sense for household wealth, we'd have to be looking at a longer timescale like generations. You inherit the family business and end up with some outcome based on the market you're in. As for your original point, trade isn't zero sum, but that's irrelevant because we're not considering policy alternatives that affect the total amount of trade. To negate his point, you'd have to argue that more mutually beneficial trade happens as a result of a more skewed wealth distribution. I'd like to try a simulation that's more realistic for small transactions. Model the effect of wealth on negotiating power, where wealthier parties are able to get terms closer to the minimum the other party will accept. Or just model the effect of the Kelly criterion I mentioned, where the greater your wealth, the more you can risk on longshots that aren't economical for poorer investors. Maybe I'll run this simulation if I have the time.
Hm, a rich person that owns a lot is not very likely to put everything he owns at stake to have the prospect of obtaining the wealth of a person that is only a tenth of his value or similar. The current implementation sounds like two people meeting at an intersection, one with a shopping cart and one with a ferrari, and then they roll the dice and the winner gets the ferrari and the other gets the shopping cart. Maybe it should be a bit more like a split pot in poker? So, the poorer agent can only win as much as he is willing to bet in the transaction? Not entirely sure what this is supposed to show, even after reading the comments, but its an interesting approach. Certainly better than some business people just making stuff up as they go along when it comes to describing complex systems.
This reminds me a lot of the Sugarscape agent-based model work done by Epstein and Axtel. http://en.wikipedia.org/wiki/Sugarscape An excellent book on the subject is "The Origins of Wealth" by Beinhocker: http://www.amazon.com/The-Origin-Wealth-Remaking-Economics/dp/1422121038 
Great, great, great ... Excelent work. Thanks a lot man
If anyone wants to run this notebook straight from their browser, you can click here: http://wakari.io/nb/urls/norvig.com/ipython/Economics.ipynb And then click "Run/Edit this Notebook". 
Indeed, that caught me out. Note that these days distribute is on the way out since it was merged back into setuptools. And yes, I could have "easy_install pip" in my instructions I posted. Yes, pip will be installed by default for regular users (developers installing from source will have to explicitly run get-pip.py which comes with the source)
You are critically incorrect in your conclusion and I wanted to point out why...although it is possible you simply did not carefully phrase your point: &gt; The simulation assumes there are winners and losers in every economic transaction and, unsurprisingly, the game ends up splitting the population into winners and losers. You are correct in that the simulation assumes that there is a winner and a loser (or neither) at an individual transaction level. However, you are ignoring that the model also assumes that in every transaction both actors have an equal chance of being a winner or loser according to a probability distribution. Given some of these probability distributions have expected values (mu) of 0 we would actually expect, over time, all income equalities to converge; as we would expect samples to to converge to a population mean. This is especially true in his first simulation where the money is randomly between the two actors. def random_split(X, Y): "Take all the money in the pot and divide it randomly between X and Y." pot = X + Y m = random.uniform(0, pot) return m, pot - m Suppose X is poor and Y is rich. Then X has an equal opportunity of getting the "winning" share of the X+Y pot even though Y contributed more. So on and so forth. The interesting thing is that nothing close to a convergent trend is observed. The rich get richer and the poor get poorer. Thus, this extremely controlled model basically hints at an implicit, fundamental property of ***momentum*** to money. The implication for free market economics is pretty profound.
No, he didn't ignore that each agent had an equal chance to win. Free market transactions are nothing like this simulation. So, no, the implications are essentially zero. See, if I buy something from you, you get money, I get the thing I wanted more than I wanted that money. We both gain. 
You are correct...but there is no need to consider the money multiplier or overall utility when building this model since, again, it is about the implicit and overlooked momentum of money: The more you have the more you can get. Further, you can extrapolate this to your point: &gt; I get the thing I wanted more than I wanted that money. We both gain. Fundamentally, for this market action to occur one of you needs money and the other needs a valuable good. A valuable good need not be materialistic, however *all* goods (this is a bit of a stretch but sound I believe) have a cost to produce. This cost can be translated to monetary value so we can, roughly, accept a model which possesses no concern for utility and adopt dollar value as an estimate of utility. With this kind of relational equivalence you can easily see how: &gt; I get the thing I wanted more than I wanted that money. We both gain. Boils down to both parties requiring value/money. Further, it actually reinforces the notion that, "You need money to make money," which is what this simulation is illustrating. Edit: For clarity, I am essentially saying that the economic utility of the simulated population may be increasing (overall) like you say, however their actual wealth will continue to diverge regardless...ultimately leaving larger portions of the population poorer (and presumably losing utility provided other factors are equal).
&gt; The rich get richer and the poor get poorer. The model does not predict this. X and Y have an equal probability of winning the larger share, so who is rich and who is poor can swap after each simulation tick. (Social mobility!) The simulation only shows that the equilibrium state of the system is not a equal distribution of "wealth." This is completely expected if you think about it, since the likelihood of a 50-50 split is very small. &gt; The interesting thing is that nothing close to a convergent trend is observed. Also not true. The distribution does trend towards an equilibrium, just not an equilibrium where everyone has the same amount of wealth. To see why this is true, imagine an initial state where one agent has all the wealth (maximum inequality.) At each transaction with an agent with zero wealth, the rich agent would lose half his wealth, on average. His wealth would continue to diminish until other agents became wealthier and his wealth started coming back to him. A system with sufficiently high inequality will be forced back towards equilibrium. It's an example of entropy at work. Just as air particles in a room will have a range of kinetic energies from bumping into each other and exchanging energy, the agents in this simulation will have a range of wealth from randomly transacting. The system tends neither towards absolute uniformity nor maximum inequality.
There is no way that the statement 'the more money you have, the more you can get' is overlooked by economists. Or people generally. That's a bland, obvious statement. What kind of transaction does this model mimic? 
&gt; But there there's no history here, on each turn the wealthier dude is chosen at random between the two! That's the exact point of this model. And what I am trying to point out. The sole factor on how much money is distributed where is how large the starting pool (between two people) is. The implication is that pools of money are distributed unequally despite beginning in equally sized pools and distributed according to the exact same mu=0 distribution. Edit: Instead of thinking of the 1% as a person think of 1% as referencing the pool of money.
It looks like this is a year or so old, and there have definitely been improvements in that time - mainly for the better! One thing that isn't mentioned on the page (maybe in the video, I didn't watch it all) is [kivy](http://kivy.org). It has its own advantages and disadvantages, but I personally found it very enjoyable to use and with a remarkably pleasant android build process.
Except that you ignore that the two agents are interchangeable in this system. If agent A goes in with more money than agent B, we can assign without loss of generality agent A to the side with more money leaving the transaction. This essentially says that if Agent A enters a transaction with more money the transaction has more money, and therefore Agent A is more likely to leave with a large amount of money. Consider a different agent which does not have a large amount of money, when it enters a transaction it is unlikely that the transaction pool will be particularly large. While this isn't a particularly strong simulation of the economy, I do believe this demonstrates the "snowball" effect of money.
I do this and take it a step further sending it to a remote syslog server. This is great for debugging.
This sounds really interesting!
Well, a poker tournament with evenly matched players, then.
Ignoring the fact that many of the one liner examples are far too long and complicated to really belong on one line, why not just use the standard library [`filter`](http://docs.python.org/3/library/functions.html?highlight=filter#filter)?
I hope you filed a bug report.
Hi guys, Dennis from Swiftly here. Dan is an intern student helping us with some machine learning tasks using Python and gensim. Feedback is welcome. :-)
I really like pretty. It's a good library.
for those going, you should really check out this talk. https://us.pycon.org/2014/schedule/presentation/218/ Brett did the pipeline api for appengine and it is an amazing and under appreciated tech. One the biggest things I miss from my appengine days. Looking forward to the vids. 
Fix is landed here: https://github.com/pypa/pip/commit/a2a7ed2705d70e24ba1efc649f4882d2f676311b a release will be out soonish as far as I know
I've made one as well : https://github.com/PierrePaul/html5-dopetrope Another one I did with a friend : https://github.com/PierrePaul/pelican-strongly-typed
&gt; "easy_install" work originally done by the Chandler project Ouch....
This would be extremely useful for making REPL-friendly objects. I recently used a tree-like object as a hardware abstraction. Overriding `__repr__` made it useful from the REPL, but inevitably you want the traditional `__repr__` behavior for debugging (for example, `print tree.thing.nexthing` would give me `"30 degrees C"` instead of telling me that it's a `&lt;Temperature instance at 0x302340234&gt;`). If could have provided a `__pretty__` method and left `__repr__` alone I'd have had a much easier time.
Dope trope is sick, I use it on my personal site, [widdersh.in](http://widdersh.in/).
well now you know! =)
There are 2 PostgreSQL talks but no talks on: * MySQL * Any NoSQL There are 3 Django talks but no talks on: * web2py * pyramid
MySQL doesn't have any Python integration like Postgres. IIRC, you can write user defined functions in Python in Postgres.
What is with the "track" thing? I've never been to a pycon. Can you go between the different "tracks"? 
I'd *love* to use Python to write my Android app; however, for the moment, most of the solutions seem to be focused on games, where a UI doesn't have to match the rest of the system. For normal "apps", though, (as opposed to games), you have to have a nice, consistent UI, which is something I haven't come across in any of the Python toolkits yet. Looks like I'm still stuck with Java for now :(
2 scoops?
Still some work to be done (primarily testing at the client level) but I wanted to get the first cut shipped before midnight.
They do. Talks can be found [here](http://pyvideo.org/). If I remember correctly, talks started going up with in a week of Pycon last year.
You can go freely between events. I think track refers to the room the talks are being held in.
If you don't mind being a few versions behind, Debian is quite a wonderful distribution. It's the closest to arch with amazing stability. 
Very pleasant read. Got the gears turning very nicely.
Just so I understand, is Pelican basically like Jekyll, only for Python instead of Ruby?
you got that right :)
They refer to a single room, in which a series of talks will be held. You can go to any talk you want, and move from one "track" to another throughout the day based on what interests you. The main thing is that, often, a single "track" will have several talks in a row on a common theme. Let's pick Track I as an example: * Two of the three Friday-morning talks are on caching. * Friday afternoon has two talks in a row on Twisted. * Saturday morning is three talks on Django (including one by yours truly). * Saturday afternoon is three in a row on SQLAlchemy. * Saturday late afternoon is a couple of talks on working with PostgreSQL. So there are several "mini-tracks" of multiple talks covering facets of the same topic. And the track as a whole has a strong web-development theme (though it's not the only track you'll find web-dev talks in, of course).
The why is "to do what someone else did in another post in another language, in python, and have one function that works for both lists and strings without explicitly testing for the type of the input" - As the post says.
Good! web2py and mysql should not be encouraged at all.
Definitely something I wanted to try. I didn't realise the setup was so involved. Great article.
It is a bit of a mishmash anyways. Jekyll uses Liquid templating which is a Ruby port of Django or Jinja2 templating. Only Liquid decided to add template inheritance as an afterthought and therefore you have to jump through hoops to get it working in Jekyll. I value template inheritance highly, so that really turned me away from Jekyll. Also with Pygments there is a bit of Python still in Jekyll... 
I'm working on my first web app, so I'm sure others will give you better advice/suggestions but I've been using this cookiecutter template for flask: https://github.com/sloria/cookiecutter-flask It has basic user authentication, registration, pages limited to members only. It's also very easy to work with and improve it. The only thing that's lacking is the subscription part, but that doesn't sound like it's something that's hard to implement since it's basically changing one value in database, stripe does all the complicated parts. 
This is the sad truth.
AT LAST!!!! I had no idea
&gt;The closest thing I found was https://github.com/zhaque/django-saas-kit **but it hasn't been active for quite some time**. maybe that is because it was a demo app and not a library. nonetheless, the code might be useful to you. so what does it matter if the author hasn't touched it in 9 months or so?
Can't install on Python 3.3.2 :(
Hi, can you open a issue on github? https://github.com/joke2k/faker/issues?state=open
So, I installed faker using pip (v 0.0.4) and it doesnt have the Factory class on it... which version should I install? i want this so badly. EDIT. pfff. I should learn to read documentation. It's pip install fake-factory , and not faker.
This is cool, but the `en_EN` locale seems to be focused on the US (format of post codes).
I believe it's spelled "[miscellaneous](http://www.dict.org/bin/Dict?Form=Dict2&amp;Database=*&amp;Query=miscellaneous)", not "[miscelleneous](https://github.com/joke2k/faker#fakerprovidersmiscelleneous)"
mysql is used everywhere else and yet the python community hates it... how shortsighted i see the hate against web2py is here. Have you even tried it or are you just a person who Hates things with looking at them? you are idiot you know?
you're right, if you want to contribute send me a pull request! https://github.com/joke2k/faker/fork
I can take credit only for the minor changes needed to get it working under py3! But thanks :)
Amazing
"I am using django and flask" I am curious as to why both? 
Read reddit api rules and docs.
Kind of disappointing, even for an introduction. I don't think this intro tutorial would inspire any beginner to keep learning Python.
It was the first tutorial I've ever written, so I'm happy to take feedback. I'll probably be following it up in the future so I'm keen to get some suggestions / ideas on what you might like to see.
It's definitely better than anything I could've written. I'm really not sure how I'd keep readers interested in learning Python either, hopefully others have some ideas.
Python didn't have one? Coming from CPAN world where there is a few, this is nice.
You could check out https://github.com/cypreess/django-plans If you need subdomain based multi-tenacy also check out https://github.com/bernardopires/django-tenant-schemas
I have since found this code by Mike in the comments [here](http://programmingpraxis.com/2012/07/06/fractran/): def fractran(prog, n): while True: n = next(n*num/den for num,den in prog if not n*num%den) yield n It looks neat, but will fail prematurely if *no* fraction gives an integer when multiplied by n, i.e: [n for n in fractran(((1, 2), (2, 3)), 5)] # [] **A slight change:** def fractran(prog, n): yield n while True: n = next(n*num/den for num,den in prog if not n*num%den) yield n Gives this correct answer: [n for n in fractran(((1, 2), (2, 3)), 5)] # [5] 
I'd rewrite it like while all((n * f).denominator != 1 for f in flist): n *= f yield n.numerator **edit:** disregard that, I misunderstood the code. re: nearby comment, abusing `next` to throw the StopIterationException and get you out of the loop manually is horrible, don't do that ever. 
Surely f is left unset outside its comprehension.
Certainly it's well produced, I see that you make a great effort on make it understandable for the non-introduced guy :) I often see two approach about tutorials, 1. Try to be funny 2. Try to be useful. I will like to see a tutorial that is not the 1 or the 2, and be just 1 and 2. Will be great if you introduce beginners with an useful application, that encourage. Calculate a mortgage, a dinner tip, build a budget formula to teach variables, and how to reuse code. And do something funny like getting a travel budget for a family of friendly vampires to Acapulco. EDIT: Do not remove your bio, but will be the best that you put them at the bottom feels more natural, start with a line like: "I'm Daniel (learn more about me) I love programming in python and I want to introduce you to this wonderful programming language." 
Seems to only work for addresses in the US. Edit: Yep, says so on their homepage. Just not on the page linked by OP.
Just curious but why is this against the rules(I genuinely do not know)?
More than 1 request per second - the rule is there to prevent too much load on reddit servers by API calls. No unique user agent string - to make each request unique and it's generally advised to include your username in user agent so that admins can contact author if necessary this also prevents one script filling out one request per 2 seconds quota thus preventing other users with such ID from acceding API.
Write it yourself. You'll get some good experience developing a bootstrapping solution. That said... 1. Develop your project first, before developing a prepackaged solution for others. 1. Don't be wary of using/referencing a project that hasn't been touched in some time. People can't devote their time to one project indefinitely, and something like this isn't exactly the type of project that needs persistent development. 1. Someone else mentioned it, but why use both django and flask? The only reasons that would come close to making sense would be to use flask to implement an API, or use django for it's quick admin scaffolding. All the same, you really should pick one or the other. 1. Plans and payment are two separate concerns. They shouldn't really be intertwined while developing, otherwise you'll find it a pain to replace stripe with something else. If you wind up creating some boilerplate for others to use, they'll appreciate the flexibility.
What are you interested in...I'm more than happy to throw open-source engineering work at you if you want :)
Just a side note -- when first introduced, comprehensions did leak their variables, so f would be available. It's fixed now, though I'm not sure whether that's only in 3.x or also in 2.7.
I recommend using [PRAW: The Python Reddit Api Wrapper](https://praw.readthedocs.org/en/latest/)
Right, it's hard to interpret the results of a simulation. Just getting an outcome that agrees with observation isn't enough to prove that your assumptions are valid. I think the main value in Norvig's post or similar stochastic simulations is that it can correct the error of assuming that gambling/investment success is strong evidence of merit. Even with a strong advantage it takes a huge number of trials to get a good estimate of your advantage. We've been talking about this in political terms, thinking about tax policies and so on, but it's just as important when you're trying to estimate your own skill. If you're doing well at poker or stock picking or at founding startups, how confident should you be about pouring more money into it?
I'm fairly sure I've seen similar before, but it's quite possible this one is better and/or a closer match to the interface of the others.
Here's an idea: virtual media keyboard. Have python emit virtual key presses for play, pause, forward, back. Control it via sockets/webserver. Write a client that doesn't know the address of the media player so has to discover it using subnet mask. 
Should a separate locale be made, eg en_GB for Britain. I'm guessing you wouldn't want to mix different types of postcodes? EDIT: Also, should things like cities be changed? They are less likely to be validated to see if they sound like the country, unlike postcodes.
Made an issue report. This is extremely important.
&gt; awesome-slugify transformed the German 'ß' into the ASCII equivalent no, it didn’t. there is no ASCII-equivalent to “ß”. “ß” → “ss” is wrong. less wrong than “ß” → “”, but wrong still.
There should be. The Github site for faker includes links to versions in other languages and the the PHP(?) one has a GB data set. Someone needs to grab it, translate into Faker code, and we're done!
i *just* needed it today for a http-response class. when setting the message body, we want to check if there is already a content-length header set, and if so, change it. else we add the header: for i, (k, v) in enumerate(self.headers): if k == 'Content-Length': self.headers[i] = ('Content-Length', len(body)) break else: self.add_header('Content-Length', len(body)) /edit: and i just noticed that all this can be replaced by using a collections.OrderedDict instead of a list of tuples: self.headers['Content-Length'] = len(body) and i get to skip the `add_header` method, too.
I'll have a go then
Beginner tutorials are hard in that you can't usually do anything interesting right at the beginning as they need to learn the concepts first.
&gt; print "Hello world" ? Down with Python 2! Seriously, it's 2014.
Unless it sends the text to some kind of language detection engine, how does it know whether CJK is Chinese/Japanese. Also unless it knows the language it would not be able to handle stuff like the "Turkish I problem"
Does this have an analogue to Ruby's "Company" class for generating office themed bullshit? "envisioneer dot-com synergies" lol
Inspirations quoted for python faker are: https://github.com/fzaninotto/Faker "Php faker" http://search.cpan.org/~jasonk/Data-Faker-0.07/ "Perl faker" http://faker.rubyforge.org/ "Ruby faker" I guess just grok them and transripofferate into a new provider for GB
you can join my chess game https://github.com/papaloizouc/chess i want to make a website with different games and then allow people to upload algorithms and the algorithms will play against other algorithms etc but i started with chess
Slowly creeping towards QuickCheck ;)
Well, postal codes in the US (ZIP codes) are assigned geographically (such that adjacent codes have similar digits). Wikipedia has more on that, and there is a prefix part which corresponds to a state or group of states: http://en.wikipedia.org/wiki/ZIP_code#Structure_and_allocation
percent-enode everything and leave it to browsers to display it decoded in the address bar: http://stackoverflow.com/a/2742985/247482
Is python 3 sciency and numbery yet?
No John Hunter of Matplotlib? No one from numpy, but web tools are very well represented. Seriously?
thanks for the heads up! Will be updating shortly. Jim Hugunin added to the list. 
Thanks for posting this, though this isn't the most interesting blog entry about Morepath. I posted a Morepath comparison document here on reddit last week that may be more interesting to people: http://morepath.readthedocs.org/en/latest/compared.html
&gt; Down with Python 2! Seriously, it's 2014. Sure! I have some questions first though: * Have you ever ported any open source packages from 2 to 3 * Have you written a package that supports both 2 and 3 in a single source? * Do you use any legacy code or older distros of Linux? * Are you in a situation that **requires** the use of Python 3? * Do you work on large projects with lots of dependencies that you don't own? * Do you work with bytes or unicode often? If you've answered no to most of those questions then congratulations, you're forcing your logic on someone else without caring at all about the context of your assertion. I too want Python 3 to be fully adopted and supported but it's not going to happen if people keep standing up on their soap boxes doing nothing about actually fixing things.
Well done on releasing something to the wild, haven't had a play with it yet, but looks interesting :)
For the lazy among us: [QuickCheck for Python](https://pypi.python.org/pypi/pytest-quickcheck/).
Under the hood, awesome-slugify uses the rather popular unidecode package to handle it's default translations. Since you are an expert on this subject, you should send this complaint to unidecode's author. You can find them at https://pypi.python.org/pypi/Unidecode
i’m not saying it’s a bug, i’m saying the wording is wrong. “equivalent” is wrong. “equivalent” means faithful, reversible translation. “ß” → “ss” just introduces a spelling error. if you feel the need to have a url that works without percent-encoding, go ahead and slugify it. but since browsers decode percent-encodings before displaying urls, i don’t see the need.
Don't forget the Read The Docs people (Eric Holscher, Charles Leifer, and Bobby Grace)!
It does look very good and I'm itching to give it a try but for now I'm just going to add it to my price watchlist to see if the price goes down a bit in the future.
Are you the developer for this? it very much feels like you are selling this.
Just like Latin alphabet block of Unicode, CJK block contains both language-specific characters and language-agnostic characters. For example, the letters A, B, and C are used in almost all Latin based languages, while the letter Ñ is used by languages with significant Iberian (Spanish/Portuguese) influence. The same is true for CJK blocks, for a detailed description, you can read [Han unification](https://en.wikipedia.org/wiki/Han_unification) on Wikipedia. The library you specified says it does "context-free character-by-character mapping", so it is not going to work for certain context (e.g. Japanese text mentioning Chinese topic, vice versa). 
#####&amp;#009; ######&amp;#009; ####&amp;#009; *Here's a bit from linked Wikipedia article about* [***Han unification***](http://en.wikipedia.org/wiki/Han%20unification) : --- &gt; &gt;**Han unification** is an effort by the authors of Unicode and the Universal Character Set to map multiple character sets of the so-called CJK languages into a single set of unified characters. Han characters are a common feature of written Chinese (hanzi), Japanese (kanji), and Korean (hanja). &gt;Modern Chinese, Japanese and Korean typefaces typically use regional or historical variants of a given Han character. In the formulation of Unicode, an attempt was made to unify these variants by considering them different glyphs representing the same "grapheme", or orthographic unit, hence, "Han unification", with the resulting character repertoire sometimes contracted to **Unihan**.[citation needed] &gt;**Unihan** can also refer to the Unihan Database maintained by the Unicode Consortium, which provides information about all of the unified Han characters encoded in the Unicode standard, including mappings to various national and industry standards, indices into standard dictionaries, encode ... `(Truncated at 1000 characters)` --- [^(**Picture**)](http://i.imgur.com/2wXK1so.png) [^(image source)](http://commons.wikimedia.org/wiki/File:LatinAgraphemeVariations.svg) ^| [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/voidvector can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**Summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/Python/comments/1vv1gm/slugify_human_readable_urls_from_any_string/cewfv87)
Merci for the FYI! Even after now 2 years of coding in python every day, I can still learn something new about the basics...
I've been playing with this stuff lately. There's Seaborn, Vincent, Bokeh, Ploty and, of course, Ggplot. What if they joined forces?
For example, the phrase below is entirely in Japanese, but it uses 3 characters that are shared with Chinese. &gt;&gt;&gt; unidecode(u'東京から来ました') 'Dong Jing karaLai mashita' All the characters that are shared with Chinese are transliterated as Chinese using Pinyin, while the rest are transliterated as Japanese using romaji. 
yeah whatever also don't think codecademy is all that good for total newbies. things get stuck on simple shit like formatting that if you don't know will cause one to pull out their hair. look at a coursera course and learn python the hard way is pretty good too.
If someone finds those useful I recommend checking out Anaconda: https://github.com/DamnWidget/anaconda, which more or less packages them all together into a single addon with a few extra features added in. 
python3 support when?
I've been using this in my integration tests at work for the last few days with pretty good results. I do wish there was a way to generate valid zipcodes for a given state, but there are data sets you can download that provide that, so it's not a big deal.
It shows that you get a skewed distribution with no talent factor, where everyone has equal chances in any given encounter. If you do a different simulation where you model gambling with an edge, you see that it takes an enormous advantage or a ton of trials before luck stops being the dominant factor.
python test
for entertainment only: import inspect def fmt(s): return s.format(**inspect.currentframe().f_back.f_locals)
If you don't mind me asking, what is the "almost"? Also, you can make direct R calls from Python so why wouldn't you use Python as your base and drop into R when you thought it was necessary?
Thought the same thing.
Looks promising :)
Seems very web-app based. What about GUI toolkit people? Robin Dunn of wxPython, for example. Others that come to mind: Alan Gauld ("Learning to Program" and major Python tutor list helper to beginners), Leonard Richardson (Beautiful Soup), Fredrik Lundh (effbot.org).
Now? It's built with `six` and it builds/simple graphs work under Py3 for me when I clone it from github.
Really interesting. I really like how it makes the getter and setter functions so much easier to use.
Or better yet: 'The thing is {a}'.format_map(locals()) Don't forget that `locals` disables the JIT on PyPy and forces the function to use slow dict-based locals on CPython, though. Better not use it at all.
I'm not sure about better, but [https://github.com/antlong/picka](https://github.com/antlong/picka) offers similar functionality. 
This is great news! The only reason I used R was for ggplot2, once I find a module for adjusting p-values (maybe I should write my own), I can abandon R forever.
.format_map is Python 3 only, I believe
Why not?
oh how I love abusing `inspect` (actually, just doing what its probably meant for...) see [`p_rents()`](https://github.com/admalledd/event_engine/blob/master/lib/common.py#L24) or [`print_thread_stacks()`](https://github.com/admalledd/event_engine/blob/master/lib/common.py#L58). Actually, let me rephrase that: any time you touch a stack frame... So much fun causing things to explode while abusing strange things! at one time I made a function that would change where it would return to (kinda sorta like a `goto`, but actually just re-directed the frame to point to an older one that was saved, then update that one...)
 .format(**dict(list(globals().items()) + list(locals().items()))) Shorter: .format(**dict(globals(), **locals()))
Mucking around with the stack is fun and maybe useful for debugging, but certainly not a language feature with which one should be writing production code.
this is exactly why I did not place any numbers, and put a text about this. I don't care if Guido wrote the language or not. Without the community, any language is worthless.
thanks for the suggestions, please let me know if more projects pop into your mind
Ooh, I was looking for a better way to merge dictionaries. Too bad that only works with string keys though.
`statsmodels` has some. I use it for adjusting with Benjamini-Hochberg correction ("FDR").
Which is why I said to not use it in production code ;). Just a neat trick.
You are correct. $ python2 -c 'print(str.format_map)'; python3 -c 'print(str.format_map)' Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; AttributeError: type object 'str' has no attribute 'format_map' &lt;method 'format_map' of 'str' objects&gt;
Thanks, I will check it out.
If you use Python 3.3+, there's [ChainMap](http://docs.python.org/3/library/collections.html#collections.ChainMap).
Oh, so it's like SQL's `SELECT *`
Also, look at the [`c_`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.c_.html) and `r_` objects for stacking arrays: In [4]: a = np.array([1,2,3]) In [5]: b = np.array([4,5,6]) In [6]: np.c_[a,b] Out[6]: array([[1, 4], [2, 5], [3, 6]])
hmm, maybe &gt; However, please note that unlike the Django-only unicode-slugify package which preserves the non-ASCII characters, awesome-slugify performed an ASCII substitution on the German ‘ß’. or sth. like that?
Also if you use it in the wrong context this can lead to mass assignment vulnerabilities. 
Around the same subject : Faker have you some tips about http://stackoverflow.com/questions/21302997/when-i-insert-new-faker-data-in-my-fixture-i-need-to-update-many-assertion-hav ?
&gt; One time I made a function that would change where it would return to (kinda sorta like a `goto`, but actually just re-directed the frame to point to an older one that was saved, then update that one...) That sounds eerily like [call/cc]( http://www.madore.org/~david/computers/callcc.html ). Thought about packaging it up into a library for others to use? You'd make a lot of Schemers happy, and possibly some Ruby hipsters too.
Languages that desugar string interpolation let you have the best of both worlds. Things like *fmt("{a} = {b}")* desugar into *"%s = %s" % (a, b)*
List comprehensions leak in 2.x; all the other comprehensions don't. Everything is fixed and non-leaky in Python 3. Python 2.7.5 (default, May 15 2013, 22:43:36) [MSC v.1500 32 bit (Intel)] on win32 Type "copyright", "credits" or "license()" for more information. &gt;&gt;&gt; next(f for f in [1,2,3]) 1 &gt;&gt;&gt; f Traceback (most recent call last): File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt; f NameError: name 'f' is not defined &gt;&gt;&gt; [g for g in [1,2,3]] [1, 2, 3] &gt;&gt;&gt; g 3 &gt;&gt;&gt; 
Just curious- what's so bad about `SELECT *`?
Nothing. Raldi probably was just educated to only pick out the columns you need immediately when writing queries. Some ORMs select * all the time. 
Shorter version a = 1 'The thing is %(a)' % locals() #=&gt; 'The thing is 1'
I don't use Python on my day job at the moment, I only write in it when working on my personal projects. So I'm free to choose libraries that support py3. If it doesn't support py3 in 2014, I don't use it, it's as simple as that. This is supposed to be a guide for beginners who again will be free of any legacy. It's not wise to put that into the same disaster many are already locked in from the very beginning when it's totally avoidable.
Percent formatting is deprecated in favor of `str.format`.
in 2.7 or 3?
Except it isn't, realistically, no one is going to stop using it any time soon and i read somewhere the core devs recognize this... I tend to use percent for simple strings and format for bigger ones
No release yet, but you can check out the code. 
Hmm. &gt;&gt;&gt; dpc = 0.0016 &gt;&gt;&gt; got = 17255 &gt;&gt;&gt; # i"{something#flags}" == "{:flags}".format(something) ... print i"very much dogecoin: {got}, not many dollar: ${got * dpc #.2f}" very much dogecoin: 17255, not many dollar: $27.61 Looks good? (y/n) EDIT: Clarification: this is NOT valid Python (obviously.) I'm merely asking for an opinion on a hypothetical string interpolation syntax.
Doesn't format_map go against this principle? &gt; There should be one-- and preferably only one --obvious way to do it. Why have format_map(d) when you can do format(**d)?
&gt; &gt; &gt; stuff like PDF report generation with knitr. Notebooks can be exported to PDF via `nbconvert` (which comes with IPython) and there's also [Pweave](http://mpastell.com/pweave/) 
From the Python documentation: &gt;Similar to str.format(**mapping), except that mapping is used directly and not copied to a dict. This is useful if for example mapping is a dict subclass Though for some reason now that I try to actually use it, `format(**mapping)` works exactly the same way. http://ideone.com/65ya3v Not sure why. Maybe `format_map` would still work for objects that implement `__getitem__` but are not dicts? Also, if you adhere to formal logic when reading this principle, it doesn't state that there should only be one way to do something. It states that among all the possible ways, at least one of them (and preferably only one of them) should be obvious. `format_map` is hardly obvious. :-)
FPGA was the ideal really, but it has limited computation for what I want to do. GPU with FPGA using python as the glue sounds possible or insane? 
Why do you want to do this? It's possible, but you may end up writing more C than Python. 
`str.format` understands more data types, it can pull from python objects, dictionaries, lists, etc. Percent formatting is just dumb string interpolation.
I'm not arguing that % is better, but it's faster. Especially in simple strings, like the example provided.
Have you checked out MyHDL( www.myhdl.org ). Its a python hardware description library(not a high level synthesis approach), which is much nicer to use than verilog/vhdl.
Maybe, but I feel that since format is better in some cases, and not that much different or worse in others, it should just be used everywhere for consistency.
also **vars() could be used
Spam.
Yes, I think it is the good place. Even r/Programming sometimes likes pet projects written in python. Feedback : your lines are too long ! This is especially a problem on github, I have to scroll horizontally to see the end of some lines !
Excuse me if I am incorrect, but I believe that you intended to reference **/r/programming**.
 &gt;commentTag = ... This would look better if you stored it in a multi-line string, like this: commentTag = """------ *Hi! I'm a bot created to x-post gifs/vines/gfycats from /r/coys over to /r/SpursGifs.* ... *[Source code](https://github.com/pandanomic/SpursGifs_xposterbot)*""" &gt;if len(args) &gt; 1: Consider using [argparse](http://docs.python.org/2.7/library/argparse.html) for that.
Thanks, Link Correction Bot !
Yeah I use pycharm and I've noticed that pep8 checking only cares if lines are &gt;120 characters, as opposed to the usual 80. I'll go through in sublime text at some point and shorten things up haha
I'm not sure what you mean by the first part (although I'm on mobile, could be some formatting that I'm missing), or is that a python feature I can just use? Definitely going to check out argparse though. I figured there had to be a less janky way to do it than what I have there haha
This is not an user-accessible variable. It's validated before assignment. It was an example, not an actual part of my program.
&gt;I'm not sure what you mean by the first part In addition to standard single-quoted strings (`"these ones"`), Python has triple-quoted ones: `"""see?"""` The difference is that the latter can contain line breaks, which you have to replace with `\n` in the former. I'm suggesting that you rewrite `commentTag` in a way that uses these triple-quoted strings.
you can change that. i use intellij with the python plugin, but it's basically the same thing so hopefully this will also work for you: go to settings and in the search box (top left?) enter "right margin". that will show you where this can be changed (for me, it's in code style, general).
I hate that. Then you always need some other way of doing strings to avoid accidental interpolation. Explicit is better than implicit!
No excuse. If it's just hypothetical talk about spam and eggs or something. SQL should never be hand rolled like that. 
And why is that?
found it, thanks!
That's nice, thanks. I will update it!
&gt; I'm not arguing that % is better, but it's faster. I personally feel that it requires more intellectual effort to parse because of the way it works when there's more than one parameter (in the format string, in the argument, or both). So you should be always using .format in complex cases, and you end up spending more effort remembering/choosing between the two formatting approaches, and you end up being wary of and spend more effort checking that one-variable case is in fact a one-variable case too. Raw typing/reading speed is so much not a problem in comparison with that.
Thanks. -------- &gt;&gt; a = np.array([1,2,3]) &gt;&gt; np.diag(a[:,0]) array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) is a funny way to write &gt;&gt;&gt; np.diag([1, 2, 3]) array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) or &gt;&gt;&gt; a = np.array([1, 2, 3]) &gt;&gt;&gt; np.diag(a) array([[1, 0, 0], [0, 2, 0], [0, 0, 3]]) if you wanted to demonstrate starting with an array. ------- &gt;&gt; A = np.array([ [1,2,3], [4,5,6], [7,8,9] ]) &gt;&gt; np.power(A,2) array([[ 1, 4, 9], [16, 25, 36], [49, 64, 81]]) is perfectly fine code, but it obscures the main takeaway that is 'All operations are arraywise, not matrix operations' &gt;&gt;&gt; A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) &gt;&gt;&gt; A**2 array([[ 1, 4, 9], [16, 25, 36], [49, 64, 81]]) --------------- It would be cool if this managed to unlock some of the frequently-useful innovations of numpy, like broadcasting.
&gt; If you need to print global, local, and nonlocal variables, you're screwed. Btw nonlocal variables that are actually used in the function are included in `locals()` too. Alternatively you could walk the stack and collect all local variables...
It's still a bad idea to build SQL strings like that, because you might think you've validated all the arguments, but that is not always easy. Better to use a prepared statement and let the database validate/encode the data in the way that it knows best.
I've been developing software for embedded systems for about 15 years (flight controls, locomotive black boxes, automotive infotainment, biometric hand scanner, etc.) The closer you get to a standard pc environment, the easier it is going to be to develop your code in python. EDIT: Python is really much better at managing a system rather than actually controlling the system. Can you provide more information about your hardware architecture and os/software platform? For example, if you intend to run an ARM based processor and want python on the bare metal, you're going to spend a lot of time developing the c-code/libraries that will just run the machine. On the other hand, if you run an x86 processor with a linux kernel and an nvidia card, there's a good chance you can get that up and running. If it was me, I would pick a distro like gentoo which gives you a great environment to build new packages. I was able to put together a cross-compiler ARM based linux distro with python for some of the things I've worked on in the past. And I could simulate it using QEMU. But I have to tell you that it's far, far easier and less headache to run code natively (x86). But if you do go the ARM route, then cross compiler is the way to go. QEMU is just not performant. As for the graphics card, I suspect that you will absolutely need a driver from the manufacturer to exploit the hardware properly. As a consequence, I think you're going to be limited to x86 for something like nvidia. You might find a driver for ARM for other display devices.
I heard it's not a good idea to use it because it'd make your queries much more vulnerable to Sql injections but I'm not sure how exactly... Maybe it'll be easier to join with some other table and get to see all the results, instead of only getting the results the dev wants regardless of joins/unions. That's just speculation though; can't remember where I dad it
It doesn't show that, though, because it doesn't match observation. If it matched reality, then Bill Gates would have already lost all of his money again.
Nagare is neat, I think I ran into it before. Morepath is a lot more conservative in that it's model/view, though it does some interesting things with link generation and pluggability/reuse. 
Thanks a lot for this informative comment, I tried to clarify it a little bit!
Or one could embrace the "my OS is my IDE" philosophy: adopt an OS that doesn't suck, customize it to your needs, become friends with the shell, pick your favorite text editor, and you'll have an IDE that does exactly what *you* want, works with every programming language ever (including ones yet to be invented), and grows with your own development as a programmer.
http://en.wikipedia.org/wiki/SQL_injection is a Big Fucking Deal. Idiots copy-paste code all the time. Don't write bad example code. From the Python docs: # Never do this -- insecure! symbol = 'RHAT' c.execute("SELECT * FROM stocks WHERE symbol = '%s'" % symbol) # Do this instead t = ('RHAT',) c.execute('SELECT * FROM stocks WHERE symbol=?', t) http://docs.python.org/2/library/sqlite3.html
There's no reason to use % instead of ?.
&gt;is more verbose. this is a good thing. the entirety of python is pretty verbose. and really, it's not all that much worse than % once you get used to it.
Disclaimer: I don't know the real reason. Speculation: format(**foo) will create a real builtin dict instance from all the keys and values in foo. This is (a) wasteful, and (b) doesn't let you do magic dicts that compute the value in .get()/\_\_getitem__ for any key but cannot actually enumerate all the possible keys. (I'm sure googling for the PEP or commit that added format_map would've been quicker than typing up this message. Meh.)
 Operator overload magic is just that - magic, and should be avoided unless it makes sense. Overloading the % operator doesn't make sense and makes the syntax weird (like formatting a tuple).
Cool, will try it out later. Is there a flag or argument to specify a custom port?
Shorter *incorrect* version. You're supposed to use '... %(a)**s** ...' % locals(), but it's very easy to forget that you need a letter specifier after the closing ). I believe this was one of the reasons why str % dict() was deprecated and .format(**kwargs) was invented.
Oh yeah crotal server [any port you want to use] like crotal server 4000
yeah, i named it according to `crotalidae` :)
that's not why I thought it was dangerous. my mind misread it completely a couple times.
&gt; the entirety of python is pretty verbose Not really. Python is one of the more succinct languages. I'm not sure what you're used to if you think otherwise, but I'd like to try it.
And where did the data for that first query come from? I could have inserted valid SQL into that string, which, when you interpolate that into a future query, expands into a malicious command.
verbose might be the wrong word. explicit maybe? iDunno. either way, I prefer string.format to modulo format these days. the difference is negligible.
You might also like [unidecode](https://pypi.python.org/pypi/Unidecode). From the link: &gt;&gt;&gt; from unidecode import unidecode &gt;&gt;&gt; unidecode(u'ko\u017eu\u0161\u010dek') 'kozuscek' &gt;&gt;&gt; unidecode(u'30 \U0001d5c4\U0001d5c6/\U0001d5c1') '30 km/h' &gt;&gt;&gt; unidecode(u"\u5317\u4EB0") 'Bei Jing '
[The primitive call/cc is a bad abstraction](http://okmij.org/ftp/continuations/against-callcc.html).
:)
&gt; &gt;&gt;&gt; print (* x) 1 2 3 OMG, this is cool. For an unknown reason, I always forgot about the fact that print is a function and that unpacking works as expected.
It looks very interesting. Is there any examples of website powered by crotal ?
Shame you're being downvoted, because Pythonista really is a great app. It is limited by the small number of third party modules supported though. Personally I'd love to see NumPy (and even Matplotlib) and a native GUI toolkit. **EDIT**: oh wow, [both NumPy and Matplotlib](http://omz-forums.appspot.com/pythonista/post/6011081608658944) support will be included in the next version!
ImportError: No module named pygments 
Yes. Give us your children! But if you want to maximize feedback, downloads, contributions, etc., make sure to first make the github page as good as possible. Good readme.md that states what you're doing and how to use it, probably a pypi entry, etc.
Look at [VPython](http://www.vpython.org/). As far as graphing and visualizations go, it's my favorite. You can also use PyGame, TKinter, or SciPy (I think.) I had a physics teacher recommend VPython to me in college, and I've never looked back.
Is there any information here that's not already on the scipy wiki? http://wiki.scipy.org/NumPy_for_Matlab_Users
Where can I find some proof of concept code?
Morepath is aimed more at rendering JSON than HTML at the moment; HTML rendering is often done on the client these days. Many client side libraries, including the one I wrote (Obviel) can render a view asynchronously, though concurrency in JavaScript is another story, of course. Note that due to the decoupled model and view lookup in Morepath, it should be possible to factor things to make model lookup asynchronous, then asynchronously render views for the models. I'd need to hook in some deferred implementation to do that. 
It's interesting how a lot of the things Lift does (wiring, aspects of lazy loading) on the server are moving to the client these days. Of course having server support for asychronicity can still be handy. 
Proof of concept? Like examples? Or a video?
There is also the performance cost. For this example I'm referring to MS SQL Server, but the concepts are probably similar elsewhere. If, for instance, all of the data you *need* is included in the available indexes, but other columns are not, the SELECT * query may use the indexes to determine rows and have to return to the table again to gather the rest of the data, which then is sent to whatever executed the query (your web app, SQL client, or what have you). Compare that to the scenario where you only return columns that are part of or included in the index, at which point the index search has already gathered all of the information, and the resultset is smaller in footprint. Depending on the JOINs and the table structures involved, you might be talking a small increase in footprint of the result set, or you might be talking a very large difference. Even for the smaller increases, if that particular query runs often you can experience death by 1000 cuts.
Dank für Ihre Arbeit, halten auf.
scripting QGIS?
Danke.
&gt; If you slightly stretch the definition of addition They are different operations that share some aspects in common (the end result is larger than the inputs) and some aspects that are completely different (concatenation depends on argument order, addition does not, and these are key to the operation). &gt; An even better example of a good operator overload Some are better than others. No disagreement there. But I was just pointing out that the choice here is arbitrary. Some languages won't let you use '+' for concatenation. &gt; There's no "binary or unary context" An operator token used with one argument is in a unary context. That's how it is parsed, and how Python knows what semantics to associate with that token.
You forgot about Dre
You are right, that's also a great resource. But I found it to be more helpful to have examples with actual values
To thank everyone, I should make a dedicated provider! :) In the last 24 hours the faker has received more than 700 stars on [GitHub](https://github.com/joke2k/faker), and it is a fantastic result. In addition, some articles have appeared and many [tweets](https://twitter.com/search?q=joke2k)! [artandlogic.com](http://www.artandlogic.com/blog/2013/11/5ish-python-modules-you-didnt-know-you-wanted/) [leancrew.com](http://www.leancrew.com/all-this/2014/01/random-lipsums-and-faker/) [macdrifter.com](http://www.macdrifter.com/2014/01/faker-module-for-python-link.html) 
fair enough. mine was a sincere question.
Maybe not, but it's the first I had heard of it.
argparse looks like a badass resource, I was not aware of it. Hopefully you won't mind me asking: do you know if you can somehow direct it to use a input source besides `sys.argv`? A lot of the code in my IRC bot is exactly what argparse would replace, but IRC commands aren't coming from the command line.
Yes...calling R via Python remains messy and convoluted. It is a problem I am probably going to have to tackle at some point though...
Yeah, even just example code for a Tetris app would be nice.
Minor point, but in the wild I generally see b[:, np.newaxis] rather than b[np.newaxis].T
Should be on /r/Programming as its not really python-centric imho
Why hypothetical? Ruby and Powershell both have it and I believe both statically compile their interpolation strings.
Why is this better/different from other static site generators?
Another minor comment: np.cov([x1, x2, x3]) should work just as in matlab: no need for the intermediate matrix construction (that will be done internally in ``cov``)
i have some plans to extend this; i'd like to make it possible to have snout snap up all the generic views of an object and make urls for them. i just wanted to see if this community had any ideas. i've found this project very useful for small django apps.
&gt;In what way is it more Pythonic? It does align with python's focus on readability, being explicit, and it's traditional preference of words over symbols (as opposed to approaches like perl's). &gt;It looks like C#, and is more verbose. The ".format" vs " % " is a bit more verbose, but it's also a less error prone. Eg. can you tell me what the following functions do: def print_area(width, height): print "Area = %s" % width*height def log_item(obj): print "Received %r" % obj Both have important bugs, but lots of people don't spot them until they experience them for themselves. And if you write it to avoid these issues, the ".format()" syntax is really only 3 characters extra (well, 5 if you skimp on whitespace). In fact, to reliably solve both issues, you'll need to add an extra set of brackets around the whole thing in some circumstances, which reduces it to 1 character. If they'd named it .fmt() there'd be no real difference, and it seems a pretty small price to pay for the extra safety and power. The format string itself is actually slightly *less* verbose in most cases, if directly comparing like with like - it's no different for sequential values and saves two characters for keyword arguments (and also allows further savings in cases where you reuse positional variables), so it can easily make up those losses if you're using a few keyword arguments).
many game tools are written in python or extender in python (even Maya/3Ds Max have a python interpreter included) but very few games are made directly in python, because the language is considered too slow. This is partly true and partly cultural (game dev being obsessed with performance, often for good reasons but not always). (Former AAA gamedev here)
Why not use a complete graph and hold a collection of different graph coloring's ? I used pygraph for some practical applications with smaller nodes and was happy. http://sourceforge.net/projects/pynetwork/
Powershell isn't my favorite language, but it does satisfy this particular need. 'Single quote strings' are not interpolated; "double quote strings" are.
Actually, I seem to have lost that code in particular. I also recall that it either segfaulted the interpreter all the time in strange cases, or just plain did weird things (like running my new stackframe for a bit then suddenly jumping back to the old one). All I was ever able to track it down to was that CPython (and pypy that I actually user more than CPython) sometimes don't rely 100% on the stack frame. Most of the failures had to do with a parent frame that was calling into C or some such most notably `socket` stuff, but that was the only C code in my stack IIRC when I would move things around. Also: memory leaks. memory leaks everywhere. Those other frames tended to become orphaned and never be GC'd... Python *really* isn't meant to do this. Maybe someone with much deeper understanding of the magic behind the scenes could figure it out.
For bonus points, you could emulate dynamic scope by using the locals, not just of the calling function, but of every function on the call stack. If you do this, be sure not to document it properly (or even at all), as whoever has to maintain it will have a pleasant surprise when they realise what you've done.
Best mannered bot I've seen on Reddit.
nice one! just two things: 1. there is the wrong description in the third row. “Accessing columns (here: first column)” should be “getting the dimensions of the array” or so. 2. `np.c_` and `np.r_` are not functions. you should do `np.c_[a,b]`, not `np.c_([a,b])`. it’s like that to allow slicing syntax: `np.c_[a, 1:6:2]`
&gt;That is, it is not on track to be removed from the language Deprecated doesn't mean "on track to being removed" (though often it'll be a step in that direction). It just means it's disapproved of, and is not the right way to do something any more - it's only present for backward compatibility. % formatting certainly seems to fit that description.
I think anyone who has worked outside of academia has had a bad experience with someone re-writing their code. I've also had bad experiences **having** to re-write someone's code, and I've even had bad times re-writing my own code. That is a distinct issue from writing quality code in the first place. Just like I hope a C or C++ programmer would know they need to handle memory management in their own code or risk memory leaks which can contribute to performance problems, I would hope that a SQL developer would know that they don't need to be generating a resultset of 100 columns when they only need 10. 
Thanks for the catch! The third row was a duplicate of the 2nd row but with a wrong description, and you are also right for point 2! Fixed it!
Thank you, kind sir/madam!
Unclear. What's Go(lang)-Python? Python that compiles to Go? Impossible, unless you're willing to significantly restrict it in order to fit into the Go's type system (which, as far as I know, still doesn't even have generics.) Go that compiles to Python? What's the point? You wouldn't even be able to use Python libraries due to, again, pretty restrictive static typing. Also, it would be slow and interpreted, basically negating the two selling points of Go. Or is it Go FFI for Python? A Python interpreter in Go? Maybe a green thread library? Or what?
I guess it depends on your definition of deprecated. What I meant is that `%` formatting has not been formally deprecated in the documentation and it doesn't produce a `DeprecationWarning` when used. Both things are part of the official deprecation process (See [PEP 5](http://www.python.org/dev/peps/pep-0005/)) Also, `%` formatting will very likely be expanded in the future (See [PEP 460](http://www.python.org/dev/peps/pep-0460/) and [PEP 461](http://www.python.org/dev/peps/pep-0461/))
Just like CPython, PyPy, Jython and IronPython a Python interpreter in Go. With the benefits of Go and the coding of Python.
Right, I was speaking generally. Pypi is more for libraries than one-off tools.
&gt; One day you might extend the app to allow people to customise the entries in that list No I won't. Even if, don't you think I'd validate the inputs, just like any other input that the application accepts currently?
Ah, got it. Sorry, not interested. &gt;Cython That's not an interpreter, by the way.
I agree with you completely.
The developer, OMZ Software, also has another great iPad app [Editorial](http://omz-software.com/editorial/index.html), which is a writing application with a lot of pythonista functionality built it. You can create workflows and write python scripts to do all kinds of stuff with your text. I love it.
Corrected it thanks. Can you explain why not, maybe we can learn from it?
Speaking of lists of strings: if the bot in question has a sh-like command syntax, [shlex](http://docs.python.org/2/library/shlex.html) may be useful for transforming commands into argument lists.
Why not interested? Mainly because I don't really see any benefits in using Go. The way I see it, its "killer feature" are green threads, [which exist in Python](http://greenlet.readthedocs.org/en/latest/). It's also highly unlikely that you'll be able to make something with comparable performance to CPython (unless you know how to make JIT compilers. I don't.) And there aren't that many Go libraries to justify sacrificing compatibility with CPython extensions. Still, I'm not the one to say your idea is completely pointless. Anything seems good when compared to [what I've made](https://github.com/pyos/dg).
It's the first somebody not-me posts about it here, so thanks! 
You're welcome!
Great bot and great code! I am happy you learnt something from my bot! Your code is much better than mine! I need to edit my code to follow python guidelines... I have a question: is running the bot on Heroku free? Do you need to pay for sending web requests or anything?
I do it all with free utilities. I'll send you a PM later explaining how I set it up, I owe you that much at least :P
Why the sudo?
That would be great. Thanks!
&gt; .format is slower Are you sure? I mean, it probably is slower a bit, there's one method lookup here, but is it noticeably slower even in silly synthetic tests?
I might fork this to add it to a program I've been thinking of making - a desktop wallpaper changer that automatically downloads/switches wallpapers for your resolution or larger. 
I would love to see how that goes mate, be sure to share here if you do!
Wow mate ! Fork it and re-share it ! 
Rapid GUI Programming with Python and QT. Though it's Python 2 based, but should still be mostly workable. If you want something more basic to start in, you can start with Tkinter. It's not the prettiest, but works, and will get you the basic concepts of GUIs. Edit: It appears they've loosely applied some Python 3 updates, or at least account for them: http://www.qtrac.eu/pyqtbook.html#eg3 
... None?
Call me old fashioned, but I'd just use a debugger. \*walks off, whistling and whittling a stick\*
It has a GUI, but only with vector objects and photos
More of drawing libraries than a real GUI toolkit though.
Yea, anything wrong with Pelican or is this just made for fun? 
The following is a multitouch piano that comes as an example. I'm on mobile so code formatting is a no-can-do-sville. # Piano # # A simple multi-touch piano. from scene import * import sound from itertools import chain class Key (object): def __init__(self, frame): self.frame = frame self.name = None self.touch = None self.color = Color(1, 1, 1) self.highlight_color = Color(0.9, 0.9, 0.9) def hit_test(self, touch): return touch.location in self.frame class Piano (Scene): def setup(self): self.white_keys = [] self.black_keys = [] white_key_names = ['Piano_C3', 'Piano_D3', 'Piano_E3', 'Piano_F3', 'Piano_G3', 'Piano_A3', 'Piano_B3', 'Piano_C4'] black_key_names = ['Piano_C3#', 'Piano_D3#', 'Piano_F3#', 'Piano_G3#', 'Piano_A3#'] for key_name in chain(white_key_names, black_key_names): sound.load_effect(key_name) white_positions = range(8) black_positions = [0.5, 1.5, 3.5, 4.5, 5.5] key_w = self.size.w key_h = self.size.h / 8 for i in range(len(white_key_names)): pos = white_positions[i] key = Key(Rect(0, pos * key_h, key_w, key_h)) key.name = white_key_names[i] self.white_keys.append(key) for i in range(len(black_key_names)): pos = black_positions[i] key = Key(Rect(0, pos * key_h + 10, key_w * 0.6, key_h - 20)) key.name = black_key_names[i] key.color = Color(0, 0, 0) key.highlight_color = Color(0.2, 0.2, 0.2) self.black_keys.append(key) def draw(self): stroke_weight(1) stroke(0.5, 0.5, 0.5) for key in chain(self.white_keys, self.black_keys): if key.touch is not None: fill(*key.highlight_color.as_tuple()) else: fill(*key.color.as_tuple()) rect(*key.frame.as_tuple()) def touch_began(self, touch): for key in chain(self.black_keys, self.white_keys): if key.hit_test(touch): key.touch = touch sound.play_effect(key.name) return def touch_moved(self, touch): hit_key = None for key in chain(self.black_keys, self.white_keys): hit = key.hit_test(touch) if hit and hit_key is None: hit_key = key if key.touch is None: key.touch = touch sound.play_effect(key.name) if key.touch == touch and key is not hit_key: key.touch = None def touch_ended(self, touch): for key in chain(self.black_keys, self.white_keys): if key.touch == touch: key.touch = None run(Piano(), PORTRAIT)
When working on [windows/linux clipboard manager](https://bitbucket.org/mercnet/clipmanager) I used PySide. PySide and PyQt share common code except for a couple areas. If you go the Qt path, do not be afraid to look at C++ code and convert it to Python. Majority of the questions I faced only had solutions in C++. I wish there was more tutorials out there but I mainly learned through searching on google, github, and nullege.
if you feel like its useful to someone why not. if it was my code i'd change this: 1) if __name__ == "__main__": 2) use docstring for functions instead of comments on top 3) argparse as other mentioned 4) " ".join() or "{}".format() or "a%sc"%b instead of "a"+b+"c"
the name and main was not supposed to be bold but now i know how to bold in reddit ^_^. 
Wrap something in backticks to `make it monospaced like this`. Monospaced text ignores most formatting. For the rest, you can backslash-escape or use HTML entities. Indenting with four spaces: like this will let you do longer pieces of monospaced text (i.e. code blocks).
nltk maybe
Thanks, just trying to do what I can to help people to take up Py3k :)
This. 
this doesnt make any sense... its terrible but i dont understand grahm's things either.... how do i understant this?
Well, if you know the language coming in, you can rely on custom language translation functions, which I describe in the second article I wrote for this package: http://pydanny.com/awesome-slugify-human-readable-url-slugs-from-any-string-2.html
Okay, I'll change "equivalent" to "substitution" in the next day or so. Thanks for the feedback!
Or [Nicola](http://getnikola.com/).
haha that is awesome (now I'm reading this bot in the robot voice from the Gunrunners Shop in New Vegas...) 
Awesome, probably better than the crappy shell/curl script I've been using. I'll definitely give it a try!
You can use two ` to format the code. Just like what we usually do in GitHub. 
the auto down vote stupid fucking questions on reddit bot. which was ported to nodejs years ago
PyPy's thing is the JIT compilation it uses to improve performance. Jython and IronPython exist to make libraries for Java and .NET, respectively, to Python. I don't know much about Go, but does it have a lot of libraries that Python doesn't? I'm all for more Python interpreters, though... personally, I'd like to see one that integrated with Erlang.
Thank you!
Thank you for the followup comment. All too often I've seen posts like your original one without much context which is unhelpful both to those writing on the subject and to anyone new trying trying to figure out this Python 2/3 mess (I would not call it a total disaster though). I also agree that for beginners, Python 3 is usually the way to go so long as they're not going to be working with a library that requires 2.0. Today that's a decently rare thing thankfully... (gets off my own soap box)
That was just an example, my real function varies over time.
Numpy.... when I'm coding in any other language.
Blogspam advertisement for commercial Sublime Text text editor with plugin ability to crudely emulate a real IDE. You can get a better one using [Vim](http://www.vim.org/), which is installed by default on every OS that matters and doesn't cost an arm and a leg (or, in fact, anything at all). 
Writing a static site generator does sound like a fun and challenging project. Any tip where one should start?
i dont have any tips exactly. just do it and see how far you get. For me, i'm familiar enough with pyramid to get it to do things I want. So the idea was to write a web app that would list files in a directory, then inject handlers that would decide if those files need to be transformed in some way when being requested. a lazy saturday later I had this https://github.com/twillis/diredly The same can be done with any web framework and if it's wsgi, you wont need to serve it on a port because it's just a callable
looks like it was already submitted there
I'm now wondering if the question was meant to be, "what Python libraries do you *wish existed?*", Rather than which ones you "miss".
In python a function is an object. A decorator is simply a function that returns a function.
None is a builtin, not a library. Duh.
I have a fork of this which I call Scrotal - Crotal with balls
Sure! It's great when people can actually contribute new and interesting stuff pertaining to Python. Plus people will inevitably review your code which will only help your projects grow. 
Take the derivative and find where it equals zero. Also, do your calculus homework using calculus! But seriously - give us more context. You really can use numpy/scipy to get a derivative, or you can scan the function with some arbitrary input, or you can ask questions we can't answer without proper setup. WHY are you trying to find a local maxima? What inputs do you have? What context is this in?
waaaaaaaaaaaat
I would look into [wxPython](http://wxpython.org/). I've used it quite a bit to create GUI's with python 2 and I found I like it over Tkinter and QT. There is a project, [project phoenix](http://wiki.wxpython.org/ProjectPhoenix), whose goal is to make wxPython compatible with python 3, but I don't know what the current status of it is. Robin Dunn, the creator of wxPython has a book: [wxPython in Action](http://www.manning.com/rappin/) that does a good job of explaining the basics, but I found that the examples that come with wxPython, and user questions posted online led me to most of the answers I needed. A good place to start is the wxpy wiki: http://wiki.wxpython.org/FrontPage
This is why I was hesitant to order the summerfield book. I've only recently been working with python and it seems best to work with the latest stuff rather than "waste" time working with 2.7.
yeah I know 3's definitely a more elegant way to do it, just not what I'm used to. I'm not sure what you're referring to in #1 though?
Go for it~ (get it? :P) Despite the nay sayers, I can think of a few areas where a go-python implementation could be useful: - python has an overly complicated build system that still requires multiple different combinations of tools on different platforms to build it. The stackless python guys literally are making their own new version because the 'standard' one only compiles using VS2008. The python core devs still refuse to support mingw because it adds 'yet another platform we have to support'. Even if all you did was write a compliant python parser with no dynamic library support, and just AST parsing, lots of people would be *very interested* in it; especially if it leveraged the excellent go build system. - Another potentially killer feature for 'go-python' would be to leverage go's static binary model to create a top class distribution story, where you could precompile your .py files into whatever internal py-bytecode you use and bundle the code into the binary itself. Have a look at what the node-webkit guys are doing on this front https://github.com/rogerwang/node-webkit/wiki/How-to-package-and-distribute-your-apps Pretty impressive. Blows the binary-packaging-scanning-whatevering from py2app, py2exe, pyinstaller clean out of the water. Once again, *a lot of people* would be *very interested* in that sort of feature. It's tough work; but if you did manage to do it, there would be a lot of interest in it. My advice would be to start out with a parser based off the BNF here: http://docs.python.org/dev/reference/grammar.html Then move on from there~ 
I have the book and it works fine for py3
Considering Python is [developed using Mercurial](http://hg.python.org/), it's strange that hg wasn't an option. Thanks for sharing the results.
Yeah and considering Mercurial is written in python its even more strange ?
You say "moved on to PyPy" like it's a version of Python for more advanced coders or something. Not only it implements exactly the same language (meaning all those "backwards compatibility constraints" are present in full force, whatever you mean), attempting to manipulate frames will automatically disable the JIT, making PyPy run about 9 times *slower* than CPython.
Yes that is my undersight. An explanation is that this poll is not targeted solely at Python developers, more at the development community as a whole. It is interesting to note, however, that since posting this in /r/python the git responses have increased more than other. Also you may find it interesting that of the ~45 'other' responses, ~18 (approx. 40%) responded Mercurial. Thanks for your input and feedback!
Huge oversight in not including Mercurial.
Highly motivating comment. I think also that having a Gython will add new features like static compilation but also performance. Google is highly motivated to optimize and enhance Go, Python will profit also from their efforts. 
Why hasn't pip added a `pip --upgrade-all` or something yet? This seems stupidly obvious. I mean, it's trivial enough to do with some simple pipes, but it should be built into pip.
Apparently It was fixed a few hours ago. It was not a big issue, it is just that, now that a lot of code on the internet is read from mobile devices and websites have thiner designs, long lines of code are becoming really frustrating.
If you can't be bothered researching for two seconds what the current most popular modern VCS systems there are, I don't see why its results should have the slightest bit of credibility. Hg? Bazaar? Fossil?
You can write Python for lego's mindstorm.
I guess that begs the question...how old should people strive to make their package requirements assuming it's an open source project? It seems silly to support versions of scipy from 2 years ago, but is it really necessary to upgrade? There are quite a few packages that still support Python 2.3 and at my work, it's really handy when upgrading seemingly dead code. I wouldn't even know where to go looking for Numeric or ancient versions of setuptools, but often it's 10 minutes to upgrade the software to the latest version, which helps in the transition to Python 2.7.
Very nice!
maybe this one for pyqt 4.8 and python 3.2 : Introduction to Python® Programming and Developing GUI Applications with PyQT B.M. Harwani
I hope this helps shame the over pinning of requirements. Obviously it's what you've developed on and tested with, but you risk this spoilage as older package versions expire (both from pypi and support in general). 
Oh god, this is starting to sound like ruby, rails and bundle. edit: I don't understand the down votes. This comment seems relevant because bundle does what /u/nincompoop69 is suggesting.
I want to develop the code model into physical electronic hardware. By breaking it down slowly into different hardware levels I want to end up to mixed analog and digital design using both transistors for "hard computations" and digital for glue logic and control. So eventually I will write C and VHDL but I would like a step between matlab I use now and VHDL. Possibly if there was a python real time hardware embedding paradigm so I don't have to go to VHDL. 
&gt;If people get scared of programming with C, then they are not meant to be programmers.” luis.espinal God I hate statements like this. Similar to someone saying you need to know the process of combustion to drive a car. 
Actually this is just a prototype, I'm still working on this, my aim is to make it faster than other static site generators and easy enough to use :)
sorry, i'm not familiar with python3, so it's not part of my plan.
&gt; God I hate statements like this. Similar to someone saying you need to know the process of combustion to drive a car. Well, you should, otherwise like millions of other drivers out there you won't give the car a regular oil change, then wonder why it suddenly blows a crapton of blue smoke and seizes. 
Thank you for your suggestion. This seems to be exactly what I had in mind. I will give it a go after I finish a paper I'm working on
Why? I want that option too. 
I bet you know how the brain works to.
Personally, as an inexperienced beginner (started real hard work on learning about 6-7 months ago, obviously school gets in the way). Python is by far the least intimidating, I feel. After trying to learn C++ for a good while, I cannot even start to get it, I have no clue why, but I feel incredibly uncomfortable in a C++ environment. C isn't much better either. Python also seems to make a bit more sense to me, I don't know why. Edit: Haha, I am getting loads of suggestions I didn't even ask for! You guys rock!
Looks quite fine! One little remark. Instead of and path.exists(folder + cortado[4] + ".jpg") == False you can check the non-existence better with: and not path.exists(folder + cortado[4] + ".jpg")
http://python-gtk-3-tutorial.readthedocs.org/en/latest/index.html is a good tutorial for Python and GTK 3. :)
Because everybody loves Python.
Don't see any reason to not love it! Even experienced C#/C++ devs I know who are just learning python absolutely love it.
Sometimes I feel like being scared of C is a requirement of being a good C programmer.
https://github.com/nvie/pip-tools is another module which can tell your how out of date your requirements are. If you use it's pip-dump command it'll dump your requirements intelligently between requirements.txt and requirements-dev.txt
Obvious "that guy" post pointing out that a sample ~~size of 500 people~~ might not be representative. edit: ~~strikethrough~~
&gt;Python also seems to make a bit more sense to me, I don't know why. That's because Python is basically an executable pseudocode.
Been using C since 1980. Still do. Also love python! 
top-down: python/JS bottom-up: C/C++
Well, it's not very hard. Here's an example toy one: http://ralsina.me/weblog/posts/nicoletta-nikolas-little-sister.html it's 40 LOC
I think part of it, for me at least, was that C/C++ required me to have a much broader and deeper knowledge about systems and software engineering in order to make sense of each line of code. With Python, you can focus more on just the procedural and algorithmic aspect of it without dealing with malloc or pointers or type safety, etc. And although that's true of most scripting languages, Python also has a really nice combination of legibility, expressiveness, standard idioms, a great standard library, and a very strong, diverse, active, and devoted community. 
A small advice: one important part of making it fast is making it do incremental builds, and that's probably the hardest bit I faced when writing Nikola. I used doit to help, there are other alternatives, too. Good luck with your project!
Single quote v. double quote is also how it works in Bash and PHP. I still don't like it. 
Thanks for your feedback! I'll change that later and push the change to github 
That would be true but only after using C as least once before.
Of course, Python was designed by Guido van Rossum, as a descendant of ABC, a teaching language. "I decided to write an interpreter for the new scripting language I had been thinking about lately: a descendant of ABC that would appeal to Unix/C hackers." -- Guido van Rossum It was intended to be easy to learn, readable, intuitive, and all that jazz. Honestly, I'm wondering by what metric it is just now being considered the best starter language by someone. edit: correction - [/user/nieuweyork] points out below that it was designed for production use, and the usefulness as a teaching language is just a benefit of its lineage as a descendant of ABC. I've corrected my comment to be accurate. 
Not just functions, though. Any callable can be used as a decorator. Classes are probably the most notable example of this.
Great point, but I was just trying to simplify it for a user who really might not understand more complex definitions at the moment.
Most of my experience comes from C++ but when I met python, it was a perfect match between us. Now I don't have link various libraries and shit to get a scripting job done. I should get tax relief for utilizing python.
In many respects this comes down to top-down versus bottom-up. There are merits and dangers to both. One of the problems with top-down is that humans as a rule don't seek out pain and difficulty. I often see dynamic language developers who will express curiosity about lower levels but once they are 3 degrees outside their comfort zone they quickly adopt an attitude of "well this is just a casual interest and I don't *really* need to understand it because I am productive in my own little (python, ruby, js, whatever) domain". Conversely the bottom up weeds out people early on who will never be good assembler/C/C++ developers and often discourages them to the point where they give up on programming in toto. It's possible they could have some kind of career in a higher level language but they have already been selected (self-selected or otherwise) out at that point. 
Someone should develop a year long introductory course that uses C/C++, python and Haskell. I would be fun to write and then rewrite programs in an imperative and then a functional way.
As someone who does a lot of C I like Python as well, I prefer it actually. I just take the things I've built in C and interface it with Python using callbacks and such, it's actually pretty efficient outside of the function call overhead.
I have been taking classes that focus on Java, Python, and c++. I am not taking systems programming class and I feel overwhelmed. The professor is really helpful because he understands I am having a problem implementing the logic and not the logic itself. I go an hour early to class to get extra help with it. Just give yourself some time and it will eventually all make sense.
It's the beginning of wisdom.
Most of your pyqt4 and py27 code can be converted to pyqt5 and py3 very easily. Qt is definitely one of the best UI tools for python and even though most of the tutorials are for 2.7 and qt4, it doesn't take much work at all to convert them to py3. also if you're learning, you won't be hitting the differences right away. by the time you hit them, you'll be comfortable enough with it that changing your code to compensate will be a doddle.
Start with a text editor and a command line compiler like gcc or something. That'll get you closer to the code and it's really a lot simpler. Then go through some of the examples in those "teach yourself in 21 days" type books and switch things up a little over time. Get away from IDEs if you're messing with those because they're complicated and they add layers between you and the code. It's easier to feel what's happening if it's just you and the compiler.
Not really focused on Python 3, but I found [PySide GUI Application Development](http://www.packtpub.com/pyside-gui-application-development/book) to be a nice intro to PySide.
this is a good resource for beginners: http://zetcode.com/gui/pyqt4/ I learned pyqt from here. I also have the rapid gui book, but this was my first introduction to pyqt and has served me well.
I've got C projects on Github and I'm not afraid of memory management or bit twiddling. That said, C sucks as an intro language. Learners spend more time wrapping their heads around C's syntax and patterns than on the algorithms and concepts they're supposed to be learning. Here's a linked list in Python: class Element(object): def __init__(self): self.next_element = None head = Element() head.next_element = Element() Voila: list with two items in it. What's that going to look like in C? Which is going to be easier to learn and reason about? I think that C and/or ASM should be taught very early in comp sci curriculums, because ultimately your code is going to run on a physical machine and it's critical to understand what that actually means. But to start with? That's just sadistic.
thank you! :) Just now I've implemented part of incremental builds for posts in my way, and version 0.4.0 has been released. I create a `db.json` file to store the old posts' content, when generating the site, only the new posts created or the old posts modified will be read from markdown files, other posts will be read directly from the file `db.json`.
500 people is huge, statistically speaking. I would worry less about the sample size and more about the sampling methodology here - how were the respondents selected? Since the author filtered responses from various online forae, it's reasonable to expect significant sampling bias. Also note that the author was looking for recommendations from people who already know how to program, making the conclusion at best that Python is the most-recommended starter language. Determining what's actually the best language to learn programming would probably necessitate a significantly more involved investigation into learning outcomes of new programmers.
Well, the most common implementation (CPython) is extremely slow, and dynamic typing often defers catching error to when they are much more expensive.
Actually, Python was inspired by a teaching language called ABC.
You don't even need a linked list, as python has implemented lists already. You only need them to show how easy they are in python.
Well, right, but the goal of such a thing would be to demonstrate how linked lists work. You wouldn't actually want to use that in production. I wrote a merge sort yesterday just to see if I remembered how to do it, but I'd always used sorted() or list.sort() in real life. 
Yeah, just for learning/showing how something works, python is great for that, as it's really easy to understand. For actual code, you would want to just use the standard functions.
I'm on mobile, I thought it would.
The problem with the Python approach is that it doesn't jive with the structure of college courses. Should it be over-taught for a full year, then move on to C for a year to dig into its details? Learning C for a first year, then Python for a single semester seems to fit college schedules better. Or maybe Python in high school moving on to C in college would be an ideal approach. I understand the benefit of low-barrier to entry, but in reality programming is hard and is not for everyone. It would come as a huge disappointment if that second year rolls around and C is too tough.
Java is out of the list. Any reason there?
Thanks for the suggestion. I'll go ahead and order this from Amazon.
&gt; JavaScript? Shudder. FTFY
My high school to university track went something like Visual Basic -&gt; Java -&gt; C/C++ -&gt; Algorithms/Theory. The problem was that no course offered went deep enough into how to code graphical, interactive games. Always text-based programs. Gotta love palindromes. I'll be starting an introductory course in Computer Science for my grade 11 high school class in a couple weeks time. We'll be using Python and the free online resources offered here: http://inventwithpython.com/index.html Heard about Python a lot over this summer and very excited to be teaching it to new programmers. Extremely readable and easy to grasp. I really like that Python doesn't have any "throw away lines" of setup code (e.g. main method, String args[], ect.) at the beginning of every program. It's difficult to explain easily to students other than waving your hands and say "I'll explain all this later" (using pygame kind of has this, but by then its explainable). Not to mention how cool Pygame and Pygcurse is. My goal is to have students create an interactive, graphical program by June. I definitely think its possible, and something that will hopefully keep them interested in taking Computer Science again next year. In Grade 12, I feel somewhat pressured into teaching them Java. This is only because most universities still use that language in their introductory courses, and that AP only uses Java and C++ for their exams.
You already have an interpreter installed.
My former university offered a class just like that, except it was clojure instead of Haskell. It was saved as a high level elective and was probably the most interesting pure programming course I took. 
True, true, but for putting together a simple program that doesn't really need much in the way of processing power is a lot simpler than in most more complex languages. If I were to write a 3D game, I would do it in C++, experienced in it or no. Anything else though is totally cool in Python, I find. 
Thanks for your suggestion, and yes, I will definitely have to consider just sitting by and experimenting with my own code, rather than trying to jump straight into it with horridly confusing examples.
You're right. Posted a new question. 
Are you looking for functionality beyond those given by virtualenv? I've had linux and windows systems with multiple versions of python on them. The pain points are usually getting the base packages installed: e.g. python 3.2 with pip-3.2 and virtualenv for 3.2, repeat for 2.7 or others. Once that's setup, it's fairly straight forward to [create environments](http://stackoverflow.com/questions/1534210/use-different-python-version-with-virtualenv). And then once using a virtualenv, it behaves mostly as if there was only 1 version of python installed. EDIT: Some of this was either wrong and/or unnecessary. My reply below clarifies the setup I use which has, in the system wide environment, multiple python versions, but just one version of pip and virtualenv. My apologies for misremembering.
I don't think you understand how statistics works, I was very surprised that they chose a sample size that large
I actually like the syntax of Java, but I can see how its popularity is waning. My own school even replaced the language used in introductory classes with Python. I blame Oracle.
You say that, but Javascript has the benefit of being *right there*, all the time in your browser, and I think that's the best thing to have to learn programming with, accessibility. I liked the idea of learning programming well before I actually started because setting up a development environment confused me (I was pretty young and there weren't too many options for easy-start IDEs and such) which actually delayed me starting for two or three months because I got sick of not actually being able to do anything without so much setup, going outside and sitting in my hammock was so much easier. I actually consider the Raspberry Pi something of a failure in that regard, not sales-wise, or popularity-wise, it excelled there, but the original idea for the Raspberry Pi was to make a computer for British kids to learn programming on, but it didn't actually make anything about the process easier and that's why it's mostly a hobbyists project board, rather than a teaching tool. What kids need to learn programming in terms of technology is something like a RPi that boots into a linux distro with an icon on the screen for a dev environment for each language and like 5 example projects that literally anyone could do. Couple that with a quicker first-time setup and you've basically got yourself the next BBC B, the computer the BBC sold to go along with their TV series about basic programming for kids, besides using BASIC, which is something of it's own mistake, it was a perfect learner's computer, you plugged it into the wall for power and the TV for a display and it booted instantly and directly into a command line for BASIC, no installing the right *nix distro, no setting up your keyboard, mouse, wifi, choice of screen, etc, making a half hour job of what should for teaching purposes be a 5 minute job and you're already programming, the language didn't matter, in the same way Javascript being a bad language didn't matter, because it was *right there* and that was enough to learn with.
&gt; The problem is that you have A and B which share some code. So you rewrite it to be DRY and both A and B are now instances of C. But then the requirements for A and B diverge. So, you make C into a monster to accommodate those divergences. So, you make C into a monster to accommodate those divergences. Soon, no one can understand how C works because it's basically doing all of the work of A and B combined plus E and F that got added later. In other words: separation of concerns - which I listed 4th. Plus, turning C into a monster probably isn't going to be very DRY.
&gt;I don't think you understand how statistics works, Maybe. When I learned statistics in school we had a great negative example of a survey taken in front of a school for blind people and the resulting (newspaper) headline stating that 10 out of 10 people were blind. If this is a statistic that rose from a certain webpage that only a certain kind of people visit, it might not be representative. I said "might" too.
That's like saying losing your virginity to your step sister is best because she sleeps across the hall. I only *tolerate* Javascript because it is so ubiquitous. The trouble with js as a beginner language is it teaches things that are not transferable to other languages. That, and there are a million ways to do the same simple thing so someone starting out would become quickly overwhelmed with choice. If you have access to the internet, you have access to other, better, programming languages for free and with minimal fuss. 
haltingsolver
Yes, that's more a problem with methodology than sample size. Although, ten *is* a small sample size, but five-hundred? Not so much
Take a look to this: https://github.com/yyuu/pyenv I've been using it for months and it works like charm! But as far I know It doesn't work on Windows
I hate 1-based indicies, but it's a lot harder to port a program without a decent library to do: 1. Fortran/Matlab based arrays that are compatible with numpy. It really shouldn't be that hard. 2. Fortran/Matlab-style (one based indicies) for loops. 3. Fortran-style formatted/unformatted file IO.
I've done two courses solely devoted to learning C - one in college, based on the Kernighan and Ritchie book, and one online - Zed Shaw's "Learn C the Hard Way". By my reckoning, the main difference between the two is syntax - how the code is written and structured. LCTHW mentions something I never realized the first time, but is true upon reflection - K&amp;R's code syntax *sucks*. You can find plenty of examples - sometimes just a page apart - of the exact same process (say, an if statement, or a while loop) written two different ways. Totally fine - if you've been writing C for a while. Doesn't do much for a beginner who's trying to get comfortable with the language. I'm sure there will be people who will vehemently attack that notion, but I think Zed's right on the money with it - you need a little bit of structure before you can throw it all out the window safely (which you can do pretty quickly in C once you know what's going on).
A pure python plotting library. It doesn't need to be matplotlib, I haven't tried [pymaging](http://pymaging.readthedocs.org/en/latest/) yet, but maybe I can use that for something...
Who the hell recommends javascript as a first language?
Agreed. I've just seen people use DRY as an excuse to ignore separation of concerns. DRY is great in moderation. 
I disagree. I don't want to start a discussion on "what is programming", but the more I do it professionally (10+ years) the more I realize that the hard part of programming is delivering programs. This means that all the collateral skills you need (evaluating efforts, coming up with goo architectures that are abstract enough to be extended but enough "to the point" not to have hundreds of empty classes "just in case" and so on) are far harder to learn and require a lot of experience. Now, if you want to start programming, you *don't* want to promise your girlfriend that you'll be able to give make a her a script that renames her mp3 and be stuck instead on null pointers. You want the damn script. So yes, programming is like driving, while driving is not knowing the process of combustion, nor knowing which is the break and which is the accelerator, but driving safely, being able to "read" the street, chose the right routes and so on.
can you elaborate a bit more on this? i like to write a bit with both languages but never really figured out how to connect the two 
The love for javascript could be easily equated to stockholm syndrome
Cool. This needs direct setup.py support.
thank you
Nothing really. It's just that it needs some C extensions and depends on numpy. Sometimes I have need for a simple plot and matplotlib makes a fat dependency...
You can check whether any package breaks compatibility by any chance before upgrade each package.
Sure thing my friend. So the Bible on this is actually a nicely-written guide over here: http://docs.python.org/2/extending/extending.html In the end what this amounts to in practice is creating a wrapper API C "module" that includes the Python.h header and linking it against your pure-C shared library. Basically what this is used for is to write the really computationally-intensive bulk of your code (e.g. integrators, etc.) in C and then just make a simple API that you can use in Python to do higher-level things like statistics, graphics, machine learning, etc. 
&gt; The trouble with js as a beginner language is it teaches things that are not transferable to other languages. Particularly the prototyped inheritance model that no other major language uses and most Javascript programmers don't get right.
As someone who is doing serious coding in python as of late, I really am starting to hate it. There is a reason why we have the ugly bits in low level languages: you need them. I've lost count of the number of times I've thought "I'd get three order of magnitude improvement over this if I just had direct access to the memory locations where the object is stored". Yes, pointers are dangerous, but if you're doing anything interesting with computers you will always need them, because what becomes interesting is what can be done on the edge of the possible. That said, the saving grace for python is that I can write pure C to manipulate the bits that are too slow. If it wasn't for that I'd have given up on it by now.
Ok I'll edit my post accordingly.
Because Java sucks
done 
&gt; I've got C projects on Github and I'm not afraid of memory management or bit twiddling. It's when C starts twiddling you that things become dreary. On a more serious note, C/C++ have their applications and Python has its applications. As a started language, Python makes a lot of sense as many of the complicated aspects of the language are either abstracted out, or easier to implement. Templates, pointers, linking to name a few.
probably so that he/she can get an idea for his/her next project
Think about the real victims: Calvin Kline, Gloria Vanderbilt, and Antoine Bugleboy -- people who saw an overcrowded market and said, 'Me, too!'
I went from middle (Pascal), up (Java), down (C++ with raw pointers), to "higher" (Python, PHP, XSLT ...). I found a saying somewhere that a developer should be comfortable to go at least one, better two levels underneath himself. In Python that's Python bytecode and then C (and its memory model). In the end more information about lower levels comes in handy a lot when optimising. Things like locality of reference, pass-by-reference help you understand your code better. On the other hand, that knowledge can be a burden: all those details can get in your way. Much like having implemented a function and then constantly thinking about its implementation details. 
I'd like to see PyDBG ported to 3.x (it's currently still written for 2.4). Would anyone be able to suggest another way to script a Windows debugger with Python, or be interested in porting it with me as a side project?
Well, it's done. Thanks to everybody on this thread for the great suggestions. Results are here: http://digitalimagemover.tumblr.com
http://stackoverflow.com/questions/8228257/what-does-if-name-main-mean-in-python
thx guys , very useful will keep in mind
*Here is the text of the [accepted answer](http://stackoverflow.com/questions/8228257/8228259#8228259) to the [question](http://www.stackoverflow.com/questions/8228257/what-does-if-name-main-mean-in-python) linked above, by user [Bryan Oakley](http://stackoverflow.com/users/7432):* --- &gt;This allows you to use the same file both as a library (by importing it) or as &gt; the starting point for an application. &gt; &gt; For example, consider the following file: &gt; &gt; &gt; &gt; # hello.py &gt; def hello(to=__name__): &gt; return "hello, %s" % to &gt; &gt; if __name__ == "__main__": &gt; print hello("world") &gt; &gt; &gt; You can use that code in two ways. For one, you can write a program that &gt; imports it. If you import the library, `__name__` will be the name of the &gt; library and thus the check will fail, and the code will not execute (which is &gt; the desired behavior): &gt; &gt; &gt; &gt; #program.py &gt; from hello import hello # this won't cause anything to print &gt; print hello("world") &gt; &gt; &gt; If you don't want to write this second file, you can directly run your code &gt; from the command line with something like: &gt; &gt; &gt; &gt; $ python hello.py &gt; hello, __main__ &gt; &gt; &gt; This behavior all depends on the special variable `__name__` which python will &gt; set based on whether the library is imported or run directly by the &gt; interpreter. If run directly it will be set to `__main__`. If imported it will &gt; be set to the library name (in this case, `hello`). &gt; &gt; Often this construct is used to add unit tests to your code. This way, when &gt; you write a library you can embed the testing code right in the file without &gt; worrying that it will get executed when the library is used in the normal way. &gt; When you want to test the library, you don't need any framework because you &gt; can just run the library as if it were a program. &gt; &gt; See also `[__main__` in the python &gt; documentation](http://docs.python.org/library/__main__.html) (though it's &gt; remarkably sparse) &gt; &gt; --- ^[about.StackBot](http://www.github.com/gabrieldain/StackBot) ^| ^(downvote to remove)
Thanks for the link, it is very interesting. If it is yours or if you have used it, how fast is it ? For instance, how fast is the 'resize' function compared to the same function in C-based libraries like PIL, OpenCV, etc. ?
I think C isn't really that hard, though. I mean in comparison to other languages. (C++ is much more convoluted) I think hardest was getting the concept of pointers. Funny enough, everything became much more clear when it came to those when I dug even deeper and studied assembly (which has a reputation of being much more scary than it is – it's not hard per se, just annoying to code with plenty of opportunities to creep in because you have to type so much to accomplish so little).
python bindings for bankmaster unifam - cisam.
My first taught (as opposed to self-studied) language was Java. Back in the day when Java was just arriving and there was a lot of hype surrounding the whole concept of "write once, run everywhere". Back during Java 1.1-1.3 or so. I think it was a great choice. Java was a pretty clean object-oriented language in a healthy non-Oracle environment, with a vast library and good documentation thanks to Javadoc, and a bright future. It felt just plain _good_ to code in Java. It was very inspiring to learn to code larger projects in such an object-oriented language with none of the baggage like e.g. C++. Applets weren't that big back then, and we mostly wrote stand-alone applications. I remember we designed a multiplayer Tanks game using the Swing library, and also a motion detector app using multimedia API's. Oh, memories... It's easy to forget how modern apps you could write with Java back in the day. We also learned Haskell, which I think was another good choice. It's very complementary to many modern languages. What I like most with Haskell is how terse your code tends to become and how it feels like.. uh, that you somehow let the language work for you, if you're successful with it. When you've written a well-designed Haskell app where the language suits the job, you'll be rewarded with beautiful code. I've long forgotten much of it though since I haven't worked with it much since then, and it's so different compared to C++ and C# which I do the bulk of my work in today. Damn, I need to pick up Haskell again! I should think of a pet project. :p
I'm just getting started in python. Programmed a little in BASIC and PASCAL back in the 80's while in school. It was just a hobby. Python syntax just looks familiar to me. Granted, I have not looked too much into many other languages. But I'm hoping the familiarity will help me along some. 
I don't think Java is a great beginner language because of the boilerplate it takes to get anything done. It was taught as the intro language where I went to school and the amount of "ignore this we'll get to it later" we went through was silly.
An [autobahn](http://autobahn.ws/) websocket/RPC library for tornado. The only python library uses twisted.
Pointers. Memory leaks. Buffer overflows. Static type checking. Stack vs heap allocation. Copy constructors. The preprocessor. That's just some of what you have to worry about in C++ that you can ignore in python. Every language worth mentioning is Turing complete, that's irrelevant to how hard it is to use for any given problem.
100% agree. The python language is absolutely perfect for teaching kids, setting everything up properly is far more difficult than it has to be.
&gt;Programming is like building the car and yeah you need to understand how &gt;combustion works. Humanity used electricity for quite some time before understanding how it worked. There's a difference between an engineer and a scientist. The whole idea of a language or a framework is to abstract you away from implementation details. 
Java does everything ok but nothing particularly well. It's too low level to let people focus on ideas and too high level to teach how the machine works.
excellent answer, thank you so much!
Brainfuck is Turing complete too. Turing completeness is not a very good measure of what makes a programming language good at expressing human reasoning in computer code.
We could teach them batch files too!
MIT famously used scheme for the intro class for a long time, and I think they use python now. Syntax isn't what makes programming hard. I think it's a good idea to teach pointers and memory management early, but students get some of that in their digital logic class.
"Bicycle squeezes out Saturn V and pogo stick as best starter transportation"
&gt;Don't see any reason to not love it! If you're using a language on the decline, especially one whose niches are now being filled with python, that reason would be "jealousy". See Perl and Delphi developers and bring up Python being the leading scripting language or teaching language respectively. &gt;"The benefit of having a compiler is key in encouraging students to take up and &gt;stick with programming. Without a compiler it is hard for students to understand &gt;where errors are being made. Sounds a small thing, but makes a massive &gt;difference and has a huge impact on writing code where you can quickly see &gt;where there are errors and help address them. If you compare that to Python or &gt;Java Script, your soon understand what a benefit a proper compiler brings." -Embarcadero (Delphi maker) evangelist Stephen Ball, who refused to approve any dissenting comments to the blog article in which he wrote this &gt;"I'm convinced that in the business world Python has a fraction of the Delphi &gt;influence...." -Delphi product manager Marco Cantu in a blog comment reply after it had been suggested that Python has supplanted Delphi in the RAD niche. &gt;Although the percentage of everything that is Perl can falling, Perl itself is growing. &gt;Although Python might look like it is gaining, that doesn't say thing in relationship &gt;to anything else. It's a serious lack of numeric literacy that allows people to accept &gt;these irrelevant plots. Brian D. Foy, a Perl.org blogger, attempting to argue the innumerate notion that Perl's share of the market is irrelevant so long as the absolute number of Perl users increases, in response to Dr. Dobbs' state of computer languages in 2013 article that proclaims Python the clear leader in scripting languages, largely at the expense of Perl. Haskell users also badmouth Python, in this case because Haskell is an ideology and a "purity" language like Java &amp; C# (forcing object orientation on the user even in cases where it's a poor fit). On their discussion boards whenever Guido writes something that mentions functional programming they ask if it's April Fool's Day already. :-( Haskell is the Richard Stallman of programming languages. :-( They freak out if Guido suggests that anything about their paradigm is imperfect. Icon/Unicon users/supporters/developers also bash Python, in this case because they believe that Python borrowed its good ideas from them and they're jealous that the language never achieved Python's popularity. So yes there are reasons not to love it, but not good or rational ones. 
One has excessive layers of housekeeping, one doesn't. 
This was really interesting. Fun way to create GIFs. Thanks OP.
actionscript 3 has it, but it also has normal object oriented inheritance, and i have never seen anyone use prototype with as3
By the time you finish writing your getters and setters the class period is over?
&gt; but in reality programming is hard and is not for everyone. That goes against the very notion of Python. Python opens the world of programming to everyone (as it should be) and excels with "non-programmer programmers", those who don't want a CS degree but have something they need to get done. I remember being on a job interview and bumping into someone who was now a VP of Pricing for a shipping company; I'd dealt with him when he was just a pricing analyst. During our discussion we talked about analyzing data (I had been a programmer working for a logistics consulting firm who ended up moving into a logistics analyst role). I brought up how many IT people considered me a logistics person and logistics people often thought of me as an IT person and it was hard to be treated as someone familiar with both. He confessed that he'd begun learning VB.NET on his own and that it had already proven to be a great help "to solve those kinds of problems you just can't figure out with a spreadsheet macro." He then actually lowered his voice(!), learned forward and said "I really like it!". THESE are the kinds of people Python really helps. Almost EVERYONE has something in their line of work that could be made easier by a little programming, from a simple automation script to some number-crunching to whatever. Python helps open up programming to everyone and makes their job easier, whatever it may be - pricing analyst, scientist, teacher, etc. 
As far as I see it, there is only one way to start, and that is with C. And before you start tearing me a new one for this, read through the whole statement. Let's say you want to learn driving. You want to be a very good driver. You got yourself an empty field to practice in, so no danger of crashing. But what about the car? Do you buy an automatic with ABS, driver assistance, power steering, launch assistance etc., or do you get an old clunker that still works perfectly but has none of the above? I'd go for the second. It might be a bit harder at first,. but it will form all the right reflexes that you need. And if you veer off-course while doing it, you'd just end up on grass. Most importantly, it will teach you respect for the car, and that driving isn't an easy skill anybody can pick up in the 2 hours between breakfast and lunch. Now, suppose you'd take the first option instead. You'd learn a bit quicker, but what do you learn? Co-dependence. All your knowledge will boil to "you release the break, and the car magically goes forward". The car does everything for you. Not only wouldn't you learn *how to drive* and become at most an average driver, this wouldn't even be very useful in the real world(there is a reason that, in Europe, law forbids people who learn on automatic from driving stick). Same principle applies to programming. Start with C. What's the worst that can happen? You won't be working on anything important anyway. And if you aren't motivated enough to learn how to initialize a variable before using it, where will you find the motivation to learn best practices? OOP patterns? Wanna go the easy way? Then get your hands on PHP. Nothing easier than that. And, a few years down the road, you'll end up wondering why that *stupid Python/Java/C++ does not compile the line "5s" + 3* and why your colleagues laugh at you behind your back for writing a function with 30 parameters (I wish I was making this last one up). I recommend C because of its relative simplicity and popular "syntax". Yes, it makes it easy to shoot yourself in the foot, but it really won't do any harm when all you have is a BB gun. That is, nobody says one should become an expert in C and write his own mind-boggling OS/compiler before he even dares touch another programming language. And nobody says you should start directly by writing complicated pointer logic, using linked lists etc. No, start slow, print some hello world. Read a number. Make a static array. Make a function. By the time you reach pointers, one should either be enthusiastic enough, or skipping the class altogether. And the best part is: there are no high level concepts. There are no generators, nor objects. No templates. It allows you to focus on what matters the most: forging that structured thinking that one so desperately needs. Buffer overflows? Memory leaks? That can come a bit later. Now start tearing me a new one... *P.S.: I'm sick and tired of people saying stuff like OMG, pointers is too hard bla bla bla. If you cannot at all understand the concept of a pointer, even after multiple tries, you do not belong in programming.* **Period.**
I had a class like that as well, it was called "Programming Languages". We covered many different languages in the class. It was probably the most interesting class I had. I learned a hell of a lot too.
The arguments for starting with C are the same as the arguments for learning Latin, so that's not very surprising. The obvious benefit of JavaScript is that it is trivial to get started. You don't need to understand what a REPL is or download anything. If you have a modern browser, you already have a JavaScript console to get started. Like English as a foreign language it's very easy to get started although the peculiarities will lead to some surprises. Python was designed to be a good educational language and that's where it outperforms the alternatives: if someone sets you up with an interpreter, you can quickly gain proficiency and the language will give you room to grow. That said, JavaScript is an easier sell for aspiring programmers: you don't need any extra software and you can easily show off your work to friends and peers. It's not as well-designed as Python and especially for beginners there are a lot of gotchas and oddities, but as the article says: JavaScript is the post-dot-com era's BASIC.
That's a great point. What I meant is that 'being a programmer' is not for everyone, as in a professional software developer who is not limited to a particular language.
Those are some nicely-done GIFs. Also, looks like a useful Python library.
So if you're developing something with lots of parts or you're collaborating as part of a team or something, then it's probably a good idea to use one of these development environments, but if you're in a position to be doing development at that level, then you're not a beginner. If you're just starting out, then it's easier to just use a text editor (with basic features like syntax highlighting, etc.) and a command line compiler like gcc which, by the way, gives you very good feedback on errors and warnings. The reason is that now you don't have to learn *both* the language and the unfamiliar development environment. Having all those options available and not knowing anything about how to use them can be intimidating and confusing. So the idea is to get your feet wet with very simple programs and to use very few moving parts while doing so (e.g. text editor and cli compiler) so you can get a better idea of how things are fitting together *at the beginning* of your programming experience. I've personally been writing casually for several years in C and Python and I'm not doing collaboration and none of my projects has been more than a few thousand lines of code. Most are just a few hundred lines that do something specific and have a particular output and then I can string them together in the order I need to get the effect I want... so I'm still not using any sort of complicated development environment because I just don't need to. We used Eclipse in school a couple of years ago to write stuff in Java and I've got some experience with MVC++ from back in the day when I was modding the Half-Life SDK... and for a project like that, yeah, it's really useful to have an IDE, but I haven't worked on a project like that in years. So I'm just saying from my experience that keeping your toolset simple is perfectly effective for small projects and for a beginner, you're going to be doing small projects. The second prong is that you shouldn't put yourself in a position to have to learn **1)** How to think like a programmer **2)** An unfamiliar syntax *and* **3)** An unfamiliar development environment. You could just leave out the IDE *for now* and stick with steps 1 and 2. So that's my advice and some vague anecdotes that it's based on.
&gt; You also have to deal with the compiling process, explicit types, and its so much closer to assembly that it makes that learning curve lower as well. Other than types, I'm not sure that's a good argument for teaching C first. You think MIT might have too high starting requirements, but you're proposing that students have to drink from a firehose to weed out the ones who can't cut it. I'm curious, was C your first language? Learning memory layout and bit twiddling is certainly useful, but I think it would just be a distraction when you're trying to teach people to reduce problems to algorithms.
Wow. Excellent guide.
You're welcome to dive into the library's code https://github.com/Zulko/moviepy
[Image](http://imgs.xkcd.com/comics/purity.png) **Title:** Purity **Title-text:** On the other hand, physicists like to say physics is to math as sex is to masturbation. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=435#Explanation) **Stats:** This comic has been referenced 96 time(s), representing 0.96% of referenced xkcds. --- ^[Questions/Problems](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Website](http://xkcdref.info/statistics/)
This is not what the blog post is about though. And link title here is even worse. But hey, I know /r/python well enough now. God forbid that anyone expresses a little bit of criticism.
Thanks! I hadn't come across MoviePy and I love the ease with which the animated GIFs can be created.
Fantastic work
To do this - you need to setup your project file etc correctly. If you'd like to split your project up into several files like `level1.py`, `level2.py` etc, you'll need some sort of main module that loads the appropriate dependencies. You basically just need to make a directory named, for example `game`. Inside of this directory you'll need an empty `__init__.py` file to designate that a module exists. Then you can have your level&lt;number&gt;.py files in the same directory and import from them. If you have another file, called, for example `game_runner.py` it could access the level files by doing a relative import, such as: -- inside of game_runner.py from .level1 import level1stuff The project structure would look like game - | - __init__.py - level1.py - level2.py - game_runner.py 
We use a computer running 2 virtual machines from boot to run our windows and linux tests. It's VMWare Pro or something. That's combined with buildbot and nosetests. It's pretty slick that when you update the setup.py file (any change), all the packages get reinstalled, so if you're short on a package, you can't run anything. Each "project" is under a different virtual environment. Finally, we upgrade our packages every 6 months or so (you can pre-upgrade if you have a good reason to), so we stay nice and current. Finally, packages are reasonably spaced throughout the night to prevent multicore hogging. It's not smart enough to start when one is done. It's starts at 6 pm and goes through ~10 am with the more important ones at the top of the list.
The best part about python is it's library system. It's far simpler than most other languages, including other popular scripting languages like Lua and Perl. It's far broader than most other languages. It's cross platform compatiblity is much better than most other languages. A small few other tools may have lots of cross platform, easy to use libraries (cough Java), but they're generally less beautiful languages. The point is, doing this in python pretty much means using a library. That's Python's strong point. If you wanted to directly open up a binary file and manipulate it, python wouldn't be the typical first choice, you'd probably want something fast, lightweight, and strongly typed. Like the C/C++ that this library uses (ffmpeg) So your criticism doesn't make much sense to the python community here. We like python for these libraries.
Ah ah, don't call for more downvotes ! I disagree with your claim that the title is misleading. Here I only show basic examples but with more *actual* python code it would be possible to do much more (cf. last example).
Whatever, I don't care about the votes. I don't want to discredit the library itself. But the title suggested that I will see how to do it with pure Python, not with some rather simple API.
i'd lay it out like that but just imp.load_source as needed
Not my point. Not what I was criticizing. I only criticize the chosen title. I pretty much agree with almost everything you said, by the way. And for another nice "library" system, build environment and a quite nice language, look at Go.
I'm not sure. But use If levels is 1 Not == Good luck
An equivilant to ruby's fog.
No, `==` is correct for comparing numbers. `is` will also work for small numbers on CPython, but it's something you shouldn't rely on - another implementation may create a new object for each `1`, and then `is` wouldn't work.
I get you were just spitballing a list, but have you seen the dependency list of bokeh? Ridiculous. Plus, (last I checked) no easy way to save a static image.
&gt;Oh god, this is starting to sound like ruby, rails and bundle. So....that's bad? I don't know Ruby or how to interpret your comment.
Bundler Rubygems RSpec Pry (You can throw the rest of Ruby out the window, but these are awesome.)
auto answer: what is a gif
**Input interpretation:** Graphical Interchange Format (.gif) (file format) **Properties:** extension | .gif type | raster image release year | 1987 (27 years ago) MIME | image/gif UTI | com.compuserve.gif file signature | hex: 47 49 46 38 (ASCII: GIF8) **Sample supporting applications:** Adobe Photoshop CS5 | Apple Preview | Apple Safari | GIMP | Wolfram Mathematica *** ^^This ^^answer ^^was ^^generated ^^by ^^a ^^bot.
"Actually" suggests that my statement is incorrect. "Indeed, " might make your point clearer, if I understand it correctly.
I love when people dissect things in this way. It makes the learning process so much easier. 
Why you're getting downvoted is beyond me. :/
No, I meant jive, in the colloquial sense. But I didn't downvote you.
I'm his partner for the project. Thank you very much we will be sure to try that out and hopefully it will work for us with our limited coding skills. 
http://en.wikipedia.org/wiki/Continuous_integration#Software It's possible to install Bash almost anywhere, but I find it easier to write cross-platform scripts in Python (e.g. with os.path.sep, pathlib, or path.py). I think the Shining Panda and Selenium plugins for Jenkins CI are cross platform. http://jenkins-ci.org https://pypi.python.org/pypi/pathlib The nose and py.test test runners both support test output as XUnit XML (natively or through a plugin that also must be installed on build machines) which Jenkins can collect and chart as build artifacts. 
Your code looks pretty good! I love that I saw a *with open ...* structure in there, very classy. I did not have the luxury of learning on Python originally, so I envy you (I learned on GW-BASIC, where indentation is for the weak-minded, and everything should be in all-caps). My only question is why did you opt to learn with Python 2.7? If you're getting started, I would strongly urge you to work with Python 3. I only say so because Python 2.7 is a dead end, and your program is a simple one to write in Python 3. In your case, I think all you'd need to do is wrap all your print statements' arguments in parentheses. Not trying to start a 2.x vs 3.x flame war, just wondering...
 &lt;video class="notAGIF" autoplay="true" loop="true" muted="true" poster="true" width="300" height="226"&gt; &lt;source src="/videos/animation.mp4" type="video/mp4" /&gt; &lt;source src="/videos/animation.webm" type="video/webm" /&gt; &lt;/video&gt; yeah. the boilerplate html is a lot more than: &lt;img src="/images/animation.gif" /&gt; And there's that whole two formats thing. Le sigh. 
Compiling human language constructs into digital processor sequences is where the wheels touch the road in computer programming. Python and other high-level languages are at least two steps removed from assembly, so yeah I think C is better. A solid understanding of assembly is essential for understanding exactly what is happening in the machine, and C lays a better foundation for this than Python. I didn't say MIT has too high of anything -- I'm sure they do great just the way they are. I do not, however, think that their choice of introductory language is ideal. And I doubt they're doing much algorithm design in their freshman year. At that point you should be just learning what the heck is going on in the machine. My first language was BASIC, then Pascal and Fortran, before the C I learned in freshman CS. Don't get me wrong, I write Python every chance I get, unless the program needs to run fast then its C or SWIG and C. 
Ya I was able to setup vim for a really solid python ide, it works just as good as a paid solution like pycharm, but has no fat I don't want, and the vi motions are to engrained into my muscle memory to ever stop. I can toss my .vimrc up for anyone if wanted, all the add one are grabbed with vundle so it should just work.
I did it about the same way, with basic on Apple ][s, then having to be cured of using gotos with a pascal class. We didn't have to worry about memory management at the same time as syntax like you would in C. I think it would be incredibly frustrating to deal with memory leaks and segfaults while you're supposed to be learning lists, trees, hash tables, and sorting. We're dinosaurs - programming is moving in a functional direction and low level bit twiddling and memory layout is becoming a niche.
I would suggest writing a function that returned the level. def load_level(level_number): if level_number == 1: level_content = open("level1.txt", "w") do more stuff if level_number == 2: etc 
Having worked with a few obnoxious soap apis, a better soap client would be nice.
Hi I tried logging in with my google account and disqus wasn't letting me post. &gt;.&gt; Anyways here is my trouble and would appreciate help or an irc channel where we can communicate as I don't see one at moviepy's website. I couldn't get pass the first code exercise. Depressingly called "Use your head". www.pasteall.org/49030 imgur.com/NB4EVya 
I'm in the mood for exercises so I've been trying this website but it's terrible, most of their exercises are badly written, they don't show you your errors when something fails (they even asked me to write a program to echo the input and fail the exercise again so I can see that at least) and the interface is horrible. Cheery on top, they've got a GetSatisfaction forum with a bunch of PR people who can't do anything about the problems and most of the time don't even have a clue about what's being asked. So while /u/veritassf keeps spamming reddit with this crap you guys should check these: * https://getsatisfaction.com/codeeval/topics/by_what_metric_is_a_problem_partially_solved_vs_solved * https://getsatisfaction.com/codeeval/topics/swap_case_exercise_instructions_unclear * https://getsatisfaction.com/codeeval/topics/define_rules_for_email_validation
Thanks OP!
https://pypi.python.org/pypi/mailer
I also advocate using python 3. Since you're not using any packages, there's nothing really stopping you. Since you've already made it into a class, you could also make it a package to install using pip or just to keep everything packaged. It may be overkill for this program, but the practice could help for other big projects of yours. It's great that you have a LICENSE and your code is pretty well documented within the file itself. However, I mostly have a problem with the README itself. I feel like it doesn't really match the quality of your code comments. Some things to think about are explaining how to install/start the program, how to contribute, maybe a changelog, future plans. There's also some spelling and grammar mistakes. For the code, itself, I was thinking that you could actually do away with the words.txt file itself. Since the default file is so small, you could store the default words in the code itself and it would run a method at startup. If the file doesn't exist, then it would create it with some default words. Not necessary but could help lower the amount of files. Even better would be to grab data from a dictionary (using an api or something else) and write it to the words.txt so that it is different every time. So people could create a new file with multiple words and they could set syllable/letter/word length and how many words to download/have. Looks really good though.
It is niche, in the same sense that fancy cuisine is niche compared to McDooDoo's. If they just want fast food code then I'm out of their pay range. Try writing device controllers, or in particular GPU code without twiddling bits. Or try writing any big data algorithms without C, as well as compiler and code optimization. You'll laugh in the faces of recent grads that feel compelled to do it in Java. You'll keep your job and they'll work on the front end of some website. The value of knowing the ins and outs of how a computer works is eternal. When I took my 300 level Data Structures class, including the basic algorithms you mention, it was in C and simply assumed that we could deal with fundamental issues like memory leaks and segfaults. We were taught that the only substitute for quality code is valgrind and gdb. Some people get paid to write software without the same level of expertise, but I write scientific software and there is no substitute for quality programming in my field.
Alright, this is god damn impressive.
Hmm, just testing out his examples I had some trouble getting my fonts to work right--the Olaf one came out like [this](http://imgur.com/0IQ4SHn). Anyone have any ideas why that might be happening?
This is the example: text = TextClip("In my nightmares\nI see rabbits.", fontsize=30, color='white', font='Amiri-Bold', interline=-25).\ set_pos((20,190)).\ set_duration(olaf.duration) The parameter `Amiri-bold` asks for the font Amiri to be used. If you have left this and you haven't installed Amiri, a default font will be used instead. For some reasons Amiri produces big interlines, so I reduced the default interline of 25 pixels with `interline=-25`. Now since you are not using Amiri you don't need `interline=-25`. I think this is the issue. 
Good luck man! I personally started "programming" with Game Maker's scripting language back in like 2008 or 2009. The fact that there is very little syntax in either really helped pull me through. Fun times, actually. Game Maker was a really powerful tool for what it was.
Good points, haha. May I adjust my statement to no *valid* reasons to not love Python. I personally feel that people who much prefer other languages shouldn't really bash on languages that aren't their personal preference anyway, I know that can be reflected back to me a little, but I feel my points were more why I prefer Python, and why I learned Python but not the others. I feel that Stephen Ball's comment about the compiler is *really* idiotic though, despite being so new to this fantastic world of programming, I know that interpreters functionally will produce similar errors to compilers.
I didn't know that, but I suppose that does explain it. Thanks for the knowledge, stranger!
Well that is strange... This works fine on my computer: text = TextClip("In my nightmares\nI see rabbits.", fontsize=30, color='white').\ set_pos((20,190)).\ set_duration(olaf.duration) it also works if I set `interline=0` or `interline=50`. could you paste your code ?
Here's the closest to 0 I can set interline before it gives me the error: text = TextClip("In my nightmares\nI see rabbits.", fontsize=20, color='white', font='/usr/share/fonts/TTF/DejaVuSans-Bold.ttf', interline=-16).\ set_pos((20,190)).\ set_duration(olaf.duration) [image that makes](http://imgur.com/h2G1Rsd) Your code didn't work for me since it defaults to Times New Roman, which I don't have on my system (it's Linux). Edit: Just installed ttf-ms-fonts and it still didn't find the font, then gave me the out of range error again when I explicitly told it the font path.